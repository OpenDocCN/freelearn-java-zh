- en: Chapter 4. Collections and Functional Programming
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We are now comfortable with using Java code from our Clojure programs, and we
    also know how to expose our Clojure programs with a Java API. However, we need
    to take a deeper look at Clojure and its true nature, which is functional programming.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Basics of functional programming
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Persistent collections
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sequential and associative collections
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The sequence abstraction
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Collection types
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Applying functional programming to collections
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Basics of functional programming
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This is a topic that you can read about in lots of different places, and it
    seems that everyone has their own opinion of what functional programming is. There
    is however, some common ground that you will find in almost every definition,
    which relates to the benefits you gain from functional programming, such as:'
  prefs: []
  type: TYPE_NORMAL
- en: Easier code reuse
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Functions are easier to test
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Functions are easier to reason about
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In order to get these benefits, you need to take into account the following
    things:'
  prefs: []
  type: TYPE_NORMAL
- en: You should think of functions as first class citizens
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Functions should minimize side effects (they shouldn't change any state)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Functions should only depend on their parameters (this is called referential
    transparency)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Lets take a look at two examples of functions (or methods) in Java to illustrate
    how, even in Java, you can get benefits from writing functions without side effects
    and context dependency.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Imagine you had to test the preceding function; you might have a number of
    problems:'
  prefs: []
  type: TYPE_NORMAL
- en: You need to know how to get the current user; you might need to mock a database,
    or session storage. Or in the worst case scenario, you might need a real session
    storage service.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How can you know if something was paid for or not?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, look at this other example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code is easier to test; you can create a user instance any way
    you want and with the `ValidateStrategy` class (or interface) you could do whatever
    you need.
  prefs: []
  type: TYPE_NORMAL
- en: In the end, instead of a side-effect you get a return value stating if the action
    was possible or not. This way you don't need to mock and you can reuse it in different
    contexts.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have seen some common ground for functional programming, let''s
    take a look at Clojure''s value proposition for functional programming:'
  prefs: []
  type: TYPE_NORMAL
- en: Functions are first class citizens or values. The same as with integers or strings,
    you can create them in runtime, pass them around, and receive them in other functions.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The same way that functions are values, the data structures are also values;
    they can't be modified in the sense that they can be modified in Java but they
    are a fixed value, just as an integer is a fixed value.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Immutable data structures are very important, they allow for safe and simple
    multithreaded code.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Laziness (of data structures) allows deferring evaluation until needed, to execute
    just what you must.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Persistent collections
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the most important features in Clojure is that collections are persistent.
    That does not mean that they are persistent to disk, it means that you can have
    several historical versions of a collection with the guarantee that updating or
    looking for something in any of those versions is going to have the same effort
    (complexity). You get all this with very little extra memory.
  prefs: []
  type: TYPE_NORMAL
- en: How? It is actually pretty simple. Clojure shares a common structure between
    several different data structures. If you add a single element to a data structure,
    Clojure shares the common part between the two structures and keeps track of the
    differences.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see what we mean with an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, when you `conj` a new item into a collection, or even when you
    replace some elements from it, you aren't changing the original collection, you
    are just generating a new version of it.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In Clojure, you can use `conj(conjoin)` as a verb. It means adding new elements
    into a collection in an efficient manner.
  prefs: []
  type: TYPE_NORMAL
- en: This new version doesn't modify the previous collections you had in any way.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is a big difference from how common imperative languages work and at the
    first glance it might seem like a bad idea, but Clojure uses efficient algorithms
    that give us a couple of advantages, specifically:'
  prefs: []
  type: TYPE_NORMAL
- en: Different versions of the same collection share common parts, allowing us to
    use little memory
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When some part of the collection is not visible it gets garbage collected
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What you get out of this is similar memory usage to what you would have with
    a mutable collection. Remember that there is a cost in space and time but it is
    negligible for most use cases.
  prefs: []
  type: TYPE_NORMAL
- en: Why would you want to have an immutable data collection? The main advantage
    is that it is simple to reason about them; passing them around to functions does
    not change them and when you are writing concurrent code, there is no chance that
    some other thread has modified your collection and you don't need to worry about
    explicitly handling locks.
  prefs: []
  type: TYPE_NORMAL
- en: Types of collections in Clojure
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are three types of collections in Clojure: counted, sequential, and associative.
    They are not mutually exclusive, meaning one collection might be any.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at each type:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Counted collection**: A counted collection is a collection which knows its
    size in constant time. It doesn''t need to traverse its elements to get a count.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Sequential collection**: A sequential collection can be traversed sequentially;
    it''s the most common approach that you would use for a list. The easiest way
    to think about this is similar to Java''s list, which you can traverse with a
    for-loop or an iterator. In Clojure vectors, lists and lazy sequences are sequential
    collections.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Associative collections**: Associative collections can be accessed by keys;
    maps are the natural choice here. We said that one collection can be of any type;
    Clojure''s vectors can also be used as associative collections, and each element
    index can be used as a key. You can think of it as a map where the keys are 0,
    1, 2, 3, and so on.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Clojure has some functions that tell us if a given collection is of each type,
    sequential or associative. As you can guess, vectors return true for both. The
    following are those functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Function name | List | Vector | Map | Lazy sequence | Set |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| counted? | true | true | true | false | true |'
  prefs: []
  type: TYPE_TB
- en: '| sequential? | true | true | false | true | false |'
  prefs: []
  type: TYPE_TB
- en: '| associative? | false | true | true | false | false |'
  prefs: []
  type: TYPE_TB
- en: '![Types of collections in Clojure](img/00013.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: In the previous table and diagram, you can see that we take **Set** into account
    and as you can see, it's neither sequential nor associative.
  prefs: []
  type: TYPE_NORMAL
- en: We should look at another property; whether a collection is counted or not.
    It means that a collection knows how many elements it has. Lists, vectors, maps,
    and sets are all counted; lazy sequences are not counted, since they are generated
    on the fly and they could even be infinite sequences.
  prefs: []
  type: TYPE_NORMAL
- en: We will learn more about all of these sequences in the later sections of this
    chapter.
  prefs: []
  type: TYPE_NORMAL
- en: The sequence abstraction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Clojure has some unique features that make it different from other Lisps; one
    of them is the sequence abstraction. You can think of it as an interface that
    collections comply with. Clojure has a standard API of functions that you can
    use with sequences. Here are some examples of those functions:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `distinct` function: This function returns a sequence that includes each
    element of the original sequence just once:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `take` function: This function takes a number of elements from the original
    sequence:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `map` function: This function applies a function to each element of a sequence
    and creates a new sequence with these elements:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The interesting part here is that these functions receive and return sequences
    and you can compose them together. It can be seen in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'These are just some functions that accept and return sequences, but there are
    a lot more that you can use out of the box. The only assumption is that your sequence
    argument can respond to three functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '`first`: This function returns the first of a sequence'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`rest`: This function returns another sequence, containing everything but the
    first element'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`cons`: This function receives two parameters, an item and another `seq` and
    returns a new `seq` containing the item followed by all the items in the second
    parameter'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: One of the functions that you'll find yourself using more is the `seq` function,
    it can convert any collection to a seq, even Java native arrays and objects that
    implement the `java.util.Iterable` interface. One of its main uses is to test
    a collection for emptiness.
  prefs: []
  type: TYPE_NORMAL
- en: Specific collection types in Clojure
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that you know about Clojure's general collection properties and the sequence
    abstraction, it is a good time to get to know about Clojure's specific collection
    implementations.
  prefs: []
  type: TYPE_NORMAL
- en: Vectors
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Vectors are Clojure's workhorse; together with map, it is the most used collection.
    Don't be afraid of them; they have nothing to do with Java's `java.util.Vector`.
    They are just a series of ordered values, such as a list or an array.
  prefs: []
  type: TYPE_NORMAL
- en: 'They have the following properties:'
  prefs: []
  type: TYPE_NORMAL
- en: They are immutable
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They can be accessed sequentially
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They are associative (they are maps of their indices, meaning that their keys
    are 0, 1, 2, and so on)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They are counted, meaning they have a finite size
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They have random access, so you can access any element with almost constant
    time (with the nth function)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `conj` function appends a given element to them
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The nth function allows us to get the nth element of any `seq`, but you shouldn't
    use it without care. It has no problem handling vectors and it returns in constant
    time, but it takes linear time when used with a list, since it has to traverse
    all the collections looking for the element you asked. Try to use it just with
    vectors.
  prefs: []
  type: TYPE_NORMAL
- en: 'They have a literal syntax; you can define a vector with square brackets, as
    shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Besides the literal syntax, there''s another function that you can use to build
    a vector. The `vec` function can build a vector out of any sequence passed to
    it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Another important benefit of vectors is that they are used for function arguments
    for declarations and for `let` bindings.
  prefs: []
  type: TYPE_NORMAL
- en: 'Take a look at the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the parameters in the function are defined as a vector, same
    as the `let` binding.
  prefs: []
  type: TYPE_NORMAL
- en: One of the main complaints about Lisps is that they use too many parentheses,
    Clojure's decision to use vectors instead in these structures is welcomed and
    makes the code much easier to read.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are several ways to access a certain element of a vector:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Using the vector as a function**: Vectors can be used as functions of their
    keys; we haven''t discussed maps yet but you will see that this is because they
    are associative:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**The nth function**: The `nth` function can receive an extra parameter for
    signaling when an index is not found and can be used, as shown:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**The get function**: The `get` function can receive an extra parameter for
    signaling when an index is not found, it is used as shown. An important thing
    to keep in mind is that unlike nth, `get` cannot be used in sequences:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You should use vectors almost always; in particular, if you want to do any
    of the following there is no other way to go:'
  prefs: []
  type: TYPE_NORMAL
- en: You need random access to a collection (either modifying or accessing it)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You need to add elements at the tail of the collection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Lists
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Lists are the most important collection type in other Lisps. In Clojure, they
    are used to represent code, but their functionality is almost limited to that.
  prefs: []
  type: TYPE_NORMAL
- en: Lists in Clojure are single linked lists; as you can imagine, this means that
    they are not good for random access (you need to iterate the list until you get
    to the wanted index). That said, you can still use lists as sequences with every
    function of the API.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s list their properties:'
  prefs: []
  type: TYPE_NORMAL
- en: They are immutable
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They can be accessed sequentially
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They are not associative
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They are counted, meaning they have a finite size
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They shouldn't be accessed in random order. If you want the 99th element, then
    Clojure will have to visit all the first 98 elements to get the 99th.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `conj` function prepends a given element to it
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can use destructuring with lists, as seen in the previous chapter. You shouldn't
    be afraid to use the first function (or even nth with a small index).
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Lists have their use cases and as you learn more you'll probably be comfortable
    using them in some places (such as macros), but as a rule of thumb, try to use
    vectors instead.
  prefs: []
  type: TYPE_NORMAL
- en: Maps
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Maps are probably the most important collection type across all languages. They
    are also very important in Clojure.
  prefs: []
  type: TYPE_NORMAL
- en: Maps are collections of key value pairs, which mean that you can access or store
    an element by a key. We have been calling this type of collection an associative
    collection. Keys can be of any type of value in Clojure, even functions, lists,
    sets, vectors, or other maps.
  prefs: []
  type: TYPE_NORMAL
- en: Sorted maps and hash maps
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are two types of maps in Clojure, each one of them with its own advantages.
  prefs: []
  type: TYPE_NORMAL
- en: '**Hash maps**: They are the most used form of map in Clojure; the literal syntax
    of maps creates this type of maps. They have a nearly constant lookup time, which
    makes them extremely fast and usable in most scenarios. Their down-side is that
    you can''t access them in an ordered fashion. You can create them, as shown:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**Sorted maps**: If you need to be able to access a map''s key-value pairs
    in a certain order, then you have to use a sorted map. The downside of sorted
    maps is that the lookup time is *not* constant, which means that they are a little
    slower to access by key. However, when you need to traverse a map in the order
    of the keys, then this is the only way to go. A strong constraint here is that
    the keys must be comparable between them. Sorted maps can be created, as shown:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Comparable objects are the ones that implement the `compareTo` interface.
  prefs: []
  type: TYPE_NORMAL
- en: Common properties
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Associative objects, including maps have the following properties:'
  prefs: []
  type: TYPE_NORMAL
- en: 'They are functions of their keys:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'They can be used with associative destructuring:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'They can be accessed with the `get` function:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You can convert a map to a `seq` with the `seq` function; you will get a sequence
    where each element is a vector representing a key-value pair in the map:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '`Doseq` is similar to Java''s for-each loop. It executes the body for each
    element in a sequence.'
  prefs: []
  type: TYPE_NORMAL
- en: 'It works as shown: `(doseq [x sequence] ;;`. This works the same way as the
    let statement, you can use destructuring if needed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Sets
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Clojure sets are a collection of unique elements. You can think of them as mathematical
    sets and as such, Clojure has operations, such as union intersection and difference.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at the properties of sets:'
  prefs: []
  type: TYPE_NORMAL
- en: They are immutable
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They are associative (their keys are their elements)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They are counted, meaning they have a finite size
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Their elements are unique (contained at most once)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sorted sets and hash sets
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'There are two kinds of sets: hash-sets and sorted-sets.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Hash-set**: Besides the properties that we already saw, hash-sets are unordered.
    They are implemented using a hash map as a backing implementation.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Sorted-set**: Besides the properties that we already saw, sorted-sets are
    sorted. They can be used as a parameter to all the functions that expect a sorted
    `seq`. They can be accessed sequentially in sorted order:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: You can also reverse them without problems, filter them, or map them similarly
    to a vector or list.
  prefs: []
  type: TYPE_NORMAL
- en: Common properties
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Sets are associative, which gives them some properties of maps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'They are functions of their elements:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'They can be used with map destructuring:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `get` function can be used to access their elements:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Union, difference, and intersection
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If you remember mathematical sets, you''ll know that the three main operations
    you can execute on them are the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Union** (`union a b`): The union includes all of the elements both in `a`
    and `b`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Difference** (`difference a b`): The difference is all the elements that
    are in `a` except for the elements that are also in `b`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Intersection** (`intersection a b`): It includes only the elements that are
    both in `a` and `b`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here are some examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Applying functional programming to collections
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that we have a better understanding of how collections work, we have a better
    foundation to understand functional programming and how to make the most out of
    it.
  prefs: []
  type: TYPE_NORMAL
- en: This requires a different way of thinking about how to solve problems and you
    should keep your mind open.
  prefs: []
  type: TYPE_NORMAL
- en: 'Something that you might have found really strange about all of the collections
    is this feature: *They are immutable*.'
  prefs: []
  type: TYPE_NORMAL
- en: This is indeed something quite strange; if you are used to Java, how can you
    possibly write programs without adding or removing elements from a list or set?
  prefs: []
  type: TYPE_NORMAL
- en: How is that even possible? In Java, we are used to writing `for` and `while`
    loops. We are used to mutating variables every step of the way.
  prefs: []
  type: TYPE_NORMAL
- en: How can we cope with immutable data structures? Let's find out in the subsequent
    sections.
  prefs: []
  type: TYPE_NORMAL
- en: The imperative programming model
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The software industry has been using a single software paradigm for a long time;
    this paradigm is an imperative programming model.
  prefs: []
  type: TYPE_NORMAL
- en: In the imperative paradigm, you have to tell the computer what to do at every
    single step. You are responsible for how the memory works, for whether it is running
    in a single core or multi core and, if you want to use multi core, you need to
    make sure that you change the program state correctly and avoid concurrency problems.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see how you would calculate the factorial in an imperative style:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: You are creating a variable result and a variable `i`. You change the variable
    `i` each time by assigning it the value `i + 1`. You can change the result by
    multiplying by `i`. The computer just executes your orders, comparing, adding,
    and multiplying. This is what we call the imperative programming model, because
    you need to tell the computer the exact commands it needs to execute.
  prefs: []
  type: TYPE_NORMAL
- en: 'This has worked fine in the past for various reasons, such as:'
  prefs: []
  type: TYPE_NORMAL
- en: The tight constraints of memory size forced programmers to make use of the memory
    as efficient as possible
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It was easier to think about a single thread of execution and how the computer
    executes it step-by-step
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Of course, there were some drawbacks. A code can get complicated easily and
    the world has changed; the constraints that existed many years ago are gone. In
    addition, most of today's computers have more than one CPU. Multi-threading with
    shared mutable states is burdensome.
  prefs: []
  type: TYPE_NORMAL
- en: This makes thinking about this complicated. We get in trouble even in single
    threaded programs; just think, what would be the outcome of the following code?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Is it `0`? You can't possibly know because the `doSomething` method gets the
    list by reference and it can add or remove things without you knowing.
  prefs: []
  type: TYPE_NORMAL
- en: Now, imagine that you have a multithreaded program and a single `List` that
    can be modified by any of the threads. In the Java world, you have to know about
    `java.util.concurrent.CopyOnWriteArrayList` and you need to know about its implementation
    details to know when it's a good idea to use it and when not to use it.
  prefs: []
  type: TYPE_NORMAL
- en: Even with these structures, it is difficult to think about multithreaded code.
    You still need to think about semaphores, locks, synchronizers, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: The imperative world might be easy for the easy case, but it is not simple.
    The whole industry has realized this and there are many new languages and technologies
    that take ideas from other places. Java 8 has the streaming API and it includes
    lambda blocks, which are essentially functions. All these ideas are taken from
    the functional world.
  prefs: []
  type: TYPE_NORMAL
- en: The functional paradigm
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are other ways of thinking about how to solve a problem; in particular,
    the functional paradigm has become important lately. It is nothing new; Lisp has
    supported this kind of programming since it was conceived in 1958\. It has probably
    not been strong until recently, as it requires a more abstract way of thinking.
  prefs: []
  type: TYPE_NORMAL
- en: 'For you to get a better idea, let''s see a couple of examples of how functional
    programming looks similar to the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, it looks quite different; in the first case, we are passing
    the `str` function to another function called map.
  prefs: []
  type: TYPE_NORMAL
- en: In the second case, we are passing the `*` function to another function called
    reduce. In both cases, we are using functions as you would pass a list or a number,
    they are **first level citizens**.
  prefs: []
  type: TYPE_NORMAL
- en: One important difference in functional programming is that you don't need to
    tell the machine how to do things. In the first case, the map traverses the vector
    and applies the `str` function to each element, converting it to a `seq` of strings.
    You don't have to increment the index, you just need to tell the map what function
    you want to be applied to each element.
  prefs: []
  type: TYPE_NORMAL
- en: In the factorial case, there is a reduce function that receives the `*` and
    a `seq` from `1` to `n`.
  prefs: []
  type: TYPE_NORMAL
- en: It just works, you don't need to tell it how to do anything, just what you want
    done.
  prefs: []
  type: TYPE_NORMAL
- en: Both `map` and `reduce` are **higher order functions** because they accept functions
    such as parameters; they are also higher level abstractions.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Higher order functions are functions that either accept a function as an argument,
    return a function as result, or both.
  prefs: []
  type: TYPE_NORMAL
- en: You need to think on another level of abstraction and you don't care how things
    are really done, just that it gets the work done.
  prefs: []
  type: TYPE_NORMAL
- en: This comes with some benefit, if the implementation of a map someday changes
    to become multithreaded, you would just need to update the versions and you would
    be ready to go!
  prefs: []
  type: TYPE_NORMAL
- en: Functional programming and immutability
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You may have also noticed that functional programming makes working with immutable
    structures necessary, because you can't mutate some or the other state in every
    step; you can just describe how you want to create a new collection based on some
    other collection and then get it. Clojure's efficient collections make it possible
    to share pieces of collections to keep memory usage at a minimum.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are some other benefits to immutability:'
  prefs: []
  type: TYPE_NORMAL
- en: You can share your data structures with anyone you want because you are certain
    that nobody can change your copy.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Debugging is simpler because you can test the program with some immutable value
    instead of some mutating state. When you get a value, you can find out which function
    returned the value that you got; there are not multiple places where a collection
    was mutated for you to check.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Concurrent programming is simpler; again being certain that nobody can change
    your copy, even in other concurrently running threads, makes reasoning about your
    program simpler.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Laziness
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Clojure also supports lazy evaluation of transformations of sequences. Let''s
    take a look at the `range` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: When running this function without parameters, you are creating an infinite
    sequence starting from `0`.
  prefs: []
  type: TYPE_NORMAL
- en: It is an infinite sequence; so why does the Clojure REPL return automatically?
  prefs: []
  type: TYPE_NORMAL
- en: 'Clojure doesn''t compute a collection value until needed, so in order to get
    a value you would have to do something, such as this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you try to print an infinite sequence at the REPL, it will freeze.
  prefs: []
  type: TYPE_NORMAL
- en: Here, Clojure is resolving first one element and then five of the collection
    `r` because it needs to print them in the REPL.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Lazy evaluation just works for collections and for sequence processing. Other
    operations (such as additions, method calls, and so on), are executed eagerly.
  prefs: []
  type: TYPE_NORMAL
- en: The interesting part is that you can define a new lazy collection by applying
    functions like filter and map to a certain collection.
  prefs: []
  type: TYPE_NORMAL
- en: 'For instance, let''s get a new collection that contains all odd numbers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, `odd-numbers` is an infinite sequence of odd numbers and we have just
    asked for three of them. Whenever a number is already computed, it is not computed
    again. Let''s change our collection a little bit in order to understand how this
    works:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, some numbers get calculated first; you shouldn't expect or rely
    on a particular number of elements to be precomputed at a certain time.
  prefs: []
  type: TYPE_NORMAL
- en: Also, keep in mind that the computation isn't executed again when we ask for
    the same number of elements, since it has been already cached.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Collections and functional programming in Clojure are extremely powerful tools
    that allow us to use a completely different paradigm of programming.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s what we have learned so far:'
  prefs: []
  type: TYPE_NORMAL
- en: The mechanics of immutable collections and what each collection type in Clojure
    is best for
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How sequence abstraction and how a lot of Clojure functions are available to
    work on collections, using this abstraction
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How functional programming enables us to write simpler programs that work better
    in parallel environments and help us save resources using laziness
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the subsequent chapters, we will learn about other new Clojure features that
    give us a new and much more powerful way to implement polymorphism than what Java
    offers.
  prefs: []
  type: TYPE_NORMAL
