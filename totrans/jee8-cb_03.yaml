- en: Building Powerful Services with JSON and RESTful Features
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 JSON 和 RESTful 功能构建强大的服务
- en: Nowadays, using REST services with JSON is the most common method for data transfer
    between applications over the HTTP protocol and this is not a coincidence—this
    is fast and easy to do. It's an easy to read, easy to parse and, with JSON-P,
    easy to code!
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，使用 JSON 通过 REST 服务进行数据传输是 HTTP 协议中应用程序之间数据传输最常见的方法，这不是巧合——这是快速且容易实现的。它易于阅读，易于解析，并且使用
    JSON-P，易于编码！
- en: The following recipes will show you some common scenarios and how to apply Java
    EE to deal with them.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 以下食谱将向您展示一些常见场景以及如何应用 Java EE 来处理它们。
- en: 'This chapter covers the following recipes:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖了以下食谱：
- en: Building server-side events with JAX-RS
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 JAX-RS 构建服务器端事件
- en: Improving a service's capabilities with JAX-RS and CDI
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 JAX-RS 和 CDI 提高服务的能力
- en: Easing data and object representation with JSON-B
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 JSON-B 简化数据和对象表示
- en: Parsing, generating, transforming, and querying JSON objects using JSON-P
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 JSON-P 解析、生成、转换和查询 JSON 对象
- en: Building server-side events with JAX-RS
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 JAX-RS 和 CDI 构建服务器端事件
- en: Usually, web applications rely on the events sent by the client side. So, basically
    the server will only do something if it is asked to.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，Web 应用程序依赖于客户端发送的事件。所以，基本上，服务器只有在被要求时才会做些什么。
- en: But with the evolution of the technologies surrounding the internet (HTML5,
    mobile clients, smartphones, and so on), the server side also had to evolve. So
    that gave birth to the server-side events, events fired by the server (as the
    name suggests).
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，随着互联网周围技术的演变（HTML5、移动客户端、智能手机等等），服务器端也必须进化。因此，这就产生了服务器端事件，即由服务器引发的事件（正如其名所示）。
- en: With this recipe, you will learn how to use the server-side event to update
    a user view.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这个食谱，您将学习如何使用服务器端事件来更新用户视图。
- en: Getting ready
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Start by adding the Java EE dependency:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 首先添加 Java EE 依赖项：
- en: '[PRE0]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: How to do it...
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'First, we build a REST endpoint to manage the server events we are going to
    use, and to use REST we should start by properly configuring it:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们构建一个 REST 端点来管理我们将要使用的服务器事件，并且为了使用 REST，我们应该首先正确地配置它：
- en: '[PRE1]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The following is quite a big chunk of code, but don''t worry, we are going
    to split it up and understand each piece:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一段相当大的代码块，但别担心，我们将将其拆分并理解每一部分：
- en: '[PRE2]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Here, we have a bean to manage the UI and help us with a better view of what
    is happening in the server:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我们有一个用于管理 UI 并帮助我们更好地了解服务器中发生情况的 bean：
- en: '[PRE3]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'And finally, the UI is code a simple JSF page:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，UI 是一个简单的 JSF 页面的代码：
- en: '[PRE4]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: How it works...
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: We started with our SSE engine, the `ServerEvent` class, and a JAX-RS endpoint—these
    hold all the methods that we need for this recipe.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从我们的 SSE 引擎开始，`ServerEvent` 类，以及一个 JAX-RS 端点——这些包含了我们需要为此食谱的所有方法。
- en: 'Let''s understand the first one:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们了解第一个：
- en: '[PRE5]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Following are the main points:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些主要点：
- en: First things first—this method will create and prepare an event to be sent by
    the server to the clients.
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，这个方法将创建并准备一个由服务器发送给客户端的事件。
- en: Then, the just created event is put in a HashMap called `POOL.`
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，刚刚创建的事件被放入一个名为 `POOL` 的 HashMap 中。
- en: Then our event is attached to a URI that represents another method in this same
    class (details are provided next).
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们的事件被附加到一个 URI 上，该 URI 代表这个类中的另一个方法（详细信息将在下面提供）。
- en: 'Pay attention to this parameter:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 注意这个参数：
- en: '[PRE6]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: It brings the server-side events feature from the server context and lets you
    use it as you need and, of course, it is injected by CDI (yes, CDI is everywhere!).
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 它从服务器上下文中带来了服务器端事件功能，并允许您按需使用它，当然，它通过 CDI 注入（是的，CDI 到处都是！）。
- en: 'Now we see our `register()` method:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们看到我们的 `register()` 方法：
- en: '[PRE7]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This is the very method that sends the events to your clients—check the `@Produces`
    annotation; it uses the new media type `SERVER_SENT_EVENTS`.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 这是将事件发送到您的客户端的非常方法——检查 `@Produces` 注解；它使用新的媒体类型 `SERVER_SENT_EVENTS`。
- en: 'The engine works, thanks to this small piece of code:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 引擎之所以能工作，多亏了这段小代码：
- en: '[PRE8]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The `SseEventSink` is a queue of events managed by the Java EE server, and it
    is served to you by injection from the context.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '`SseEventSink` 是由 Java EE 服务器管理的事件队列，并且通过上下文注入为您提供。'
- en: Then you get the process broadcaster and register it to this sink, which means
    that everything that this process broadcasts will be sent by the server from `SseEventSink`.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，您获取进程广播器并将其注册到这个接收器，这意味着该进程广播的任何内容都将通过 `SseEventSink` 由服务器发送。
- en: 'And now we check our event setup:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们检查我们的事件设置：
- en: '[PRE9]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'If you pay attention to this line:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你注意这条线：
- en: '[PRE10]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: You'll remember that we've just used this broadcaster in the last class. Here
    we see that this broadcaster is brought by the `Sse` object injected by the server.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 您会记得我们刚刚在上一个类中使用了这个广播器。在这里我们看到这个广播器是由服务器注入的 `Sse` 对象带来的。
- en: 'This event implements the `Runnable` interface so we can use it with the executor
    (as explained before), so once it runs, you can broadcast to your clients:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 此事件实现了 `Runnable` 接口，因此我们可以使用它与执行器（如前所述），一旦运行，你就可以向你的客户端广播：
- en: '[PRE11]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This is exactly the message sent to the client. This could be whatever message
    you need.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 这正是发送给客户端的消息。这可能是你需要的任何消息。
- en: 'For this recipe, we used another class to interact with `Sse`. Let''s highlight
    the most important parts:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 对于此配方，我们使用了另一个类来与 `Sse` 交互。让我们突出最重要的部分：
- en: '[PRE12]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This is a simple code that you can use to call any JAX-RS endpoint.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一段简单的代码，您可以使用它来调用任何 JAX-RS 端点。
- en: 'And finally, the most important part of this mock client:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，这个模拟客户端最重要的部分：
- en: '[PRE13]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Each message that is broadcast is read here:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 每个广播的消息都在这里读取：
- en: '[PRE14]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: It could be any client you want, another service, a web page, a mobile client,
    or anything.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 可以是任何你想要的客户端，另一个服务，一个网页，一个移动客户端，或任何东西。
- en: 'Then we check our UI:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们检查我们的 UI：
- en: '[PRE15]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: We are using the `countClient` field to fill the `countClient` value in the
    client, so you can play around with as many threads as you want.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 `countClient` 字段来填充客户端的 `countClient` 值，因此您可以随意使用尽可能多的线程。
- en: There's more...
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更多...
- en: It's important to mention that SSE is not supported in MS IE/Edge web browsers
    and that it is not as scalable as web sockets. In case you want to have full cross-browser
    support in the desktop side and/or better scalability (so, not only mobile apps,
    but also web apps which can open many more connections per instance), then **WebSockets**
    should be considered instead. Fortunately, standard Java EE has supported WebSockets
    since 7.0.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要提到，SSE 不受 MS IE/Edge 网络浏览器支持，并且它的可扩展性不如 WebSockets。如果您想在桌面端实现全浏览器支持并且/或者更好的可扩展性（因此，不仅限于移动应用，还包括可以打开更多连接的实例的
    Web 应用），那么应该考虑使用 **WebSockets**。幸运的是，标准 Java EE 自 7.0 起就支持 WebSockets。
- en: See also
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: The full source code of this recipe is at [https://github.com/eldermoraes/javaee8-cookbook/tree/master/chapter03/ch03-sse](https://github.com/eldermoraes/javaee8-cookbook/tree/master/chapter03/ch03-sse)
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 此配方的完整源代码位于 [https://github.com/eldermoraes/javaee8-cookbook/tree/master/chapter03/ch03-sse](https://github.com/eldermoraes/javaee8-cookbook/tree/master/chapter03/ch03-sse)
- en: Improving service's capabilities with JAX-RS and CDI
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 JAX-RS 和 CDI 提升服务能力
- en: This recipe will show you how to take advantage of CDI and JAX-RS features to
    reduce the effort and lower the complexity of writing powerful services.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 此配方将向您展示如何利用 CDI 和 JAX-RS 功能来减少编写强大服务的努力并降低复杂性。
- en: Getting ready
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Start by adding the Java EE dependency:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 首先添加 Java EE 依赖项：
- en: '[PRE16]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: How to do it...
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'We first create a `User` class to be managed through our service:'
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们首先创建一个 `User` 类，将通过我们的服务进行管理：
- en: '[PRE17]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'To have multiple sources of `User` objects, we create a `UserBean` class:'
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了有多个 `User` 对象的来源，我们创建了一个 `UserBean` 类：
- en: '[PRE18]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'And finally, we create our `UserService` endpoint:'
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们创建我们的 `UserService` 端点：
- en: '[PRE19]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'To load our UI, we have the `UserView` class that will be like a Controller
    between the UI and the service:'
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了加载我们的 UI，我们有 `UserView` 类，它将在 UI 和服务之间充当控制器：
- en: '[PRE20]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '[PRE21]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'And we add simple JSF page just to show the results:'
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们添加一个简单的 JSF 页面，仅用于显示结果：
- en: '[PRE22]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: How it works...
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'We used two kinds of injection:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用了两种注入方式：
- en: From `UserBean`, when `UserService` is attached to the context
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从 `UserBean`，当 `UserService` 附着到上下文
- en: From `UserService` itself
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从 `UserService` 本身
- en: 'Injection from `UserBean` is the simplest possible to perform:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 从 `UserBean` 注入是最简单的方式：
- en: '[PRE23]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Injection from `UserService` itself is also simple:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 从 `UserService` 本身注入也很简单：
- en: '[PRE24]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Here, the `@Inject` works like the `@PostConstruct` annotation, with the difference
    begin in the server context running the method. But the result is quite the same.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，`@Inject` 的工作方式类似于 `@PostConstruct` 注解，区别在于服务器上下文中运行方法。但结果相当相同。
- en: 'Everything is injected, so now it''s just a matter of getting the results:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 所有一切都已注入，现在只是获取结果的问题：
- en: '[PRE25]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: There's more...
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更多...
- en: 'As you can see, JAX-RS eases a lot of the objects parsing and represention:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，JAX-RS 简化了大量的对象解析和表示：
- en: '[PRE26]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: By using a `Response` returning object and `@Produces(MediaType.APPLICATION_JSON)`, you
    give the framework the hard job of parsing your `user` object to a JSON representation.
    Lots of effort saved in a few lines!
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 通过返回一个 `Response` 对象并使用 `@Produces(MediaType.APPLICATION_JSON)`，您让框架承担了解析您的
    `user` 对象到 JSON 表示的重任。只需几行代码就能节省大量精力！
- en: You could also inject the user using a producer (the `@Produces` annotation).
    Check the CDI recipe from [Chapter 1](86071f26-42aa-43e2-8409-6feaed4759e0.xhtml),
    *New Features and Improvements,* for more details.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以使用生产者（`@Produces` 注解）注入用户。请参阅第 1 章（86071f26-42aa-43e2-8409-6feaed4759e0.xhtml）的
    CDI 菜谱，*新特性和改进*，以获取更多详细信息。
- en: See also
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 相关内容
- en: Check the full source code of this recipe at [https://github.com/eldermoraes/javaee8-cookbook/tree/master/chapter03/ch03-rscdi](https://github.com/eldermoraes/javaee8-cookbook/tree/master/chapter03/ch03-rscdi)
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 [https://github.com/eldermoraes/javaee8-cookbook/tree/master/chapter03/ch03-rscdi](https://github.com/eldermoraes/javaee8-cookbook/tree/master/chapter03/ch03-rscdi)
    查看此菜谱的完整源代码
- en: Easing data and objects representation with JSON-B
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 JSON-B 轻松表示数据和对象
- en: This recipe will show you how you can use the power of the new JSON-B API to
    give some flexibility to your data representation, and also help to transform
    your objects into JSON messages.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 此菜谱将向您展示如何使用新的 JSON-B API 的力量为您的数据表示提供一些灵活性，并帮助将您的对象转换为 JSON 消息。
- en: Getting ready
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Start by adding the Java EE dependency:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 首先添加 Java EE 依赖项：
- en: '[PRE27]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: How to do it...
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'We first create a `User` class with some customization (details ahead):'
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们首先创建一个具有一些自定义的 `User` 类（详情见后）：
- en: '[PRE28]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Here we use `UserView` to return the user JSON to the UI:'
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们使用 `UserView` 将用户 JSON 返回到 UI：
- en: '[PRE29]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'And we add JSF page just to show the results:'
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们只是添加一个 JSF 页面来显示结果：
- en: '[PRE30]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: How it works...
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: 'We are using some JSON-B annotations to customize our user data representation:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用一些 JSON-B 注解来自定义我们的用户数据表示：
- en: '[PRE31]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The `@JsonbProperty` is used to change the field name to some other value:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `@JsonbProperty` 将字段名称更改为其他值：
- en: '[PRE32]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Use `@JsonbTransient` when you want to prevent some property appearing at the
    JSON representation:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 当您想防止某些属性出现在 JSON 表示中时，使用 `@JsonbTransient`：
- en: '[PRE33]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: With `@JsonbDateFormat,` you use the API to automatically format your dates.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `@JsonbDateFormat`，您可以使用 API 自动格式化您的日期。
- en: 'And then we use our UI manager to update the view:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们使用我们的 UI 管理器来更新视图：
- en: '[PRE34]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: See also
  id: totrans-122
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 相关内容
- en: The full source code of this recipe is at [https://github.com/eldermoraes/javaee8-cookbook/tree/master/chapter03/ch03-jsonb](https://github.com/eldermoraes/javaee8-cookbook/tree/master/chapter03/ch03-jsonb)
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 此菜谱的完整源代码位于 [https://github.com/eldermoraes/javaee8-cookbook/tree/master/chapter03/ch03-jsonb](https://github.com/eldermoraes/javaee8-cookbook/tree/master/chapter03/ch03-jsonb)
- en: Parsing, generating, transforming, and querying on JSON objects using JSON-P
  id: totrans-124
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 JSON-P 解析、生成、转换和查询 JSON 对象
- en: Dealing with JSON objects is an activity that you can't avoid anymore. So if
    you can do it by relying on a powerful and easy to use framework—even better!
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 处理 JSON 对象是您无法避免的活动。因此，如果您可以通过依赖一个强大且易于使用的框架来操作它——那就更好了！
- en: This recipe will show you how you can use JSON-P to carry out some different
    operations using or generating JSON objects.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 此菜谱将向您展示如何使用 JSON-P 执行一些不同的操作，使用或生成 JSON 对象。
- en: Getting ready
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Start by adding the Java EE dependency:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 首先添加 Java EE 依赖项：
- en: '[PRE35]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: How to do it...
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Let''s create a `User` class to support our operations:'
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们创建一个 `User` 类来支持我们的操作：
- en: '[PRE36]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Then a `UserView` class to do all the JSON operations:'
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后创建一个 `UserView` 类来执行所有 JSON 操作：
- en: '[PRE37]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Then we create a JSF page to show the results:'
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们创建一个 JSF 页面来显示结果：
- en: '[PRE38]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: How it works...
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: 'First, the `loadFromArray()` method:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，`loadFromArray()` 方法：
- en: '[PRE39]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'It uses the `BuilderFactory` and the `createArrayBuilder` method to easily
    build an array of JSONs (each call of `createObjectBuilder` creates another array
    member). At the end, we use the JSON-B to convert it to a JSON string:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 它使用 `BuilderFactory` 和 `createArrayBuilder` 方法轻松构建 JSON 数组（每次调用 `createObjectBuilder`
    都会创建另一个数组成员）。最后，我们使用 JSON-B 将其转换为 JSON 字符串：
- en: '[PRE40]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Here, instead of an array, we are building a single JSON structure. Again, we
    use JSON-B to convert the `JsonStructure` to a JSON string.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们不是构建一个数组，而是构建一个单独的 JSON 结构。再次，我们使用 JSON-B 将 `JsonStructure` 转换为 JSON 字符串。
- en: 'We also took advantage of having this `JsonStructure` ready and used it to
    query the user profiles using the `JsonPointer` object:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还利用了已准备好的 `JsonStructure` 并使用它通过 `JsonPointer` 对象查询用户配置文件：
- en: '[PRE41]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'And here was the simplest: creating an object and asking JSON-B to convert
    it to a JSON string.'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 这是最简单的：创建一个对象，并让 JSON-B 将其转换为 JSON 字符串。
- en: See also
  id: totrans-146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 相关内容
- en: Check the full source code of this recipe at [https://github.com/eldermoraes/javaee8-cookbook/tree/master/chapter03/ch03-jsonp](https://github.com/eldermoraes/javaee8-cookbook/tree/master/chapter03/ch03-jsonp)
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查此菜谱的完整源代码，请访问[https://github.com/eldermoraes/javaee8-cookbook/tree/master/chapter03/ch03-jsonp](https://github.com/eldermoraes/javaee8-cookbook/tree/master/chapter03/ch03-jsonp)
