- en: Building Powerful Services with JSON and RESTful Features
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Nowadays, using REST services with JSON is the most common method for data transfer
    between applications over the HTTP protocol and this is not a coincidence—this
    is fast and easy to do. It's an easy to read, easy to parse and, with JSON-P,
    easy to code!
  prefs: []
  type: TYPE_NORMAL
- en: The following recipes will show you some common scenarios and how to apply Java
    EE to deal with them.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter covers the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Building server-side events with JAX-RS
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Improving a service's capabilities with JAX-RS and CDI
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Easing data and object representation with JSON-B
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Parsing, generating, transforming, and querying JSON objects using JSON-P
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building server-side events with JAX-RS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Usually, web applications rely on the events sent by the client side. So, basically
    the server will only do something if it is asked to.
  prefs: []
  type: TYPE_NORMAL
- en: But with the evolution of the technologies surrounding the internet (HTML5,
    mobile clients, smartphones, and so on), the server side also had to evolve. So
    that gave birth to the server-side events, events fired by the server (as the
    name suggests).
  prefs: []
  type: TYPE_NORMAL
- en: With this recipe, you will learn how to use the server-side event to update
    a user view.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Start by adding the Java EE dependency:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'First, we build a REST endpoint to manage the server events we are going to
    use, and to use REST we should start by properly configuring it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is quite a big chunk of code, but don''t worry, we are going
    to split it up and understand each piece:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we have a bean to manage the UI and help us with a better view of what
    is happening in the server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'And finally, the UI is code a simple JSF page:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We started with our SSE engine, the `ServerEvent` class, and a JAX-RS endpoint—these
    hold all the methods that we need for this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s understand the first one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Following are the main points:'
  prefs: []
  type: TYPE_NORMAL
- en: First things first—this method will create and prepare an event to be sent by
    the server to the clients.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, the just created event is put in a HashMap called `POOL.`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then our event is attached to a URI that represents another method in this same
    class (details are provided next).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Pay attention to this parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: It brings the server-side events feature from the server context and lets you
    use it as you need and, of course, it is injected by CDI (yes, CDI is everywhere!).
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we see our `register()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: This is the very method that sends the events to your clients—check the `@Produces`
    annotation; it uses the new media type `SERVER_SENT_EVENTS`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The engine works, thanks to this small piece of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The `SseEventSink` is a queue of events managed by the Java EE server, and it
    is served to you by injection from the context.
  prefs: []
  type: TYPE_NORMAL
- en: Then you get the process broadcaster and register it to this sink, which means
    that everything that this process broadcasts will be sent by the server from `SseEventSink`.
  prefs: []
  type: TYPE_NORMAL
- en: 'And now we check our event setup:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'If you pay attention to this line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: You'll remember that we've just used this broadcaster in the last class. Here
    we see that this broadcaster is brought by the `Sse` object injected by the server.
  prefs: []
  type: TYPE_NORMAL
- en: 'This event implements the `Runnable` interface so we can use it with the executor
    (as explained before), so once it runs, you can broadcast to your clients:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: This is exactly the message sent to the client. This could be whatever message
    you need.
  prefs: []
  type: TYPE_NORMAL
- en: 'For this recipe, we used another class to interact with `Sse`. Let''s highlight
    the most important parts:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: This is a simple code that you can use to call any JAX-RS endpoint.
  prefs: []
  type: TYPE_NORMAL
- en: 'And finally, the most important part of this mock client:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Each message that is broadcast is read here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: It could be any client you want, another service, a web page, a mobile client,
    or anything.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then we check our UI:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: We are using the `countClient` field to fill the `countClient` value in the
    client, so you can play around with as many threads as you want.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It's important to mention that SSE is not supported in MS IE/Edge web browsers
    and that it is not as scalable as web sockets. In case you want to have full cross-browser
    support in the desktop side and/or better scalability (so, not only mobile apps,
    but also web apps which can open many more connections per instance), then **WebSockets**
    should be considered instead. Fortunately, standard Java EE has supported WebSockets
    since 7.0.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The full source code of this recipe is at [https://github.com/eldermoraes/javaee8-cookbook/tree/master/chapter03/ch03-sse](https://github.com/eldermoraes/javaee8-cookbook/tree/master/chapter03/ch03-sse)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Improving service's capabilities with JAX-RS and CDI
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe will show you how to take advantage of CDI and JAX-RS features to
    reduce the effort and lower the complexity of writing powerful services.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Start by adding the Java EE dependency:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We first create a `User` class to be managed through our service:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'To have multiple sources of `User` objects, we create a `UserBean` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'And finally, we create our `UserService` endpoint:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'To load our UI, we have the `UserView` class that will be like a Controller
    between the UI and the service:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'And we add simple JSF page just to show the results:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We used two kinds of injection:'
  prefs: []
  type: TYPE_NORMAL
- en: From `UserBean`, when `UserService` is attached to the context
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: From `UserService` itself
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Injection from `UserBean` is the simplest possible to perform:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Injection from `UserService` itself is also simple:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Here, the `@Inject` works like the `@PostConstruct` annotation, with the difference
    begin in the server context running the method. But the result is quite the same.
  prefs: []
  type: TYPE_NORMAL
- en: 'Everything is injected, so now it''s just a matter of getting the results:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As you can see, JAX-RS eases a lot of the objects parsing and represention:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: By using a `Response` returning object and `@Produces(MediaType.APPLICATION_JSON)`, you
    give the framework the hard job of parsing your `user` object to a JSON representation.
    Lots of effort saved in a few lines!
  prefs: []
  type: TYPE_NORMAL
- en: You could also inject the user using a producer (the `@Produces` annotation).
    Check the CDI recipe from [Chapter 1](86071f26-42aa-43e2-8409-6feaed4759e0.xhtml),
    *New Features and Improvements,* for more details.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Check the full source code of this recipe at [https://github.com/eldermoraes/javaee8-cookbook/tree/master/chapter03/ch03-rscdi](https://github.com/eldermoraes/javaee8-cookbook/tree/master/chapter03/ch03-rscdi)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Easing data and objects representation with JSON-B
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe will show you how you can use the power of the new JSON-B API to
    give some flexibility to your data representation, and also help to transform
    your objects into JSON messages.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Start by adding the Java EE dependency:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We first create a `User` class with some customization (details ahead):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Here we use `UserView` to return the user JSON to the UI:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'And we add JSF page just to show the results:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We are using some JSON-B annotations to customize our user data representation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'The `@JsonbProperty` is used to change the field name to some other value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Use `@JsonbTransient` when you want to prevent some property appearing at the
    JSON representation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: With `@JsonbDateFormat,` you use the API to automatically format your dates.
  prefs: []
  type: TYPE_NORMAL
- en: 'And then we use our UI manager to update the view:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The full source code of this recipe is at [https://github.com/eldermoraes/javaee8-cookbook/tree/master/chapter03/ch03-jsonb](https://github.com/eldermoraes/javaee8-cookbook/tree/master/chapter03/ch03-jsonb)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Parsing, generating, transforming, and querying on JSON objects using JSON-P
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Dealing with JSON objects is an activity that you can't avoid anymore. So if
    you can do it by relying on a powerful and easy to use framework—even better!
  prefs: []
  type: TYPE_NORMAL
- en: This recipe will show you how you can use JSON-P to carry out some different
    operations using or generating JSON objects.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Start by adding the Java EE dependency:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s create a `User` class to support our operations:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Then a `UserView` class to do all the JSON operations:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we create a JSF page to show the results:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'First, the `loadFromArray()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'It uses the `BuilderFactory` and the `createArrayBuilder` method to easily
    build an array of JSONs (each call of `createObjectBuilder` creates another array
    member). At the end, we use the JSON-B to convert it to a JSON string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Here, instead of an array, we are building a single JSON structure. Again, we
    use JSON-B to convert the `JsonStructure` to a JSON string.
  prefs: []
  type: TYPE_NORMAL
- en: 'We also took advantage of having this `JsonStructure` ready and used it to
    query the user profiles using the `JsonPointer` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'And here was the simplest: creating an object and asking JSON-B to convert
    it to a JSON string.'
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Check the full source code of this recipe at [https://github.com/eldermoraes/javaee8-cookbook/tree/master/chapter03/ch03-jsonp](https://github.com/eldermoraes/javaee8-cookbook/tree/master/chapter03/ch03-jsonp)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
