<html><head></head><body><div id="book-columns"><div id="book-inner"><div class="chapter" title="Chapter 2. Concurrency on the JVM and the Java Memory Model"><div class="titlepage"><div><div><h1 class="title"><a id="ch02"/><span class="koboSpan" id="kobo.1.1">Chapter 2. Concurrency on the JVM and the Java Memory Model</span></h1></div></div></div><div class="blockquote"><table border="0" width="100%" cellspacing="0" cellpadding="0" class="blockquote" summary="Block quote"><tr><td valign="top"><span class="koboSpan" id="kobo.2.1"> </span></td><td valign="top"><p><span class="emphasis"><em><span class="koboSpan" id="kobo.3.1">"All non-trivial abstractions, to some degree, are leaky."</span></em></span></p></td><td valign="top"><span class="koboSpan" id="kobo.4.1"> </span></td></tr><tr><td valign="top"><span class="koboSpan" id="kobo.5.1"> </span></td><td colspan="2" align="right" valign="top" style="text-align: center"><span class="koboSpan" id="kobo.6.1">--</span><span class="attribution"><span class="emphasis"><em><span class="koboSpan" id="kobo.7.1">Jeff Atwood</span></em></span></span></td></tr></table></div><p><span class="koboSpan" id="kobo.8.1">Since its inception, Scala has run primarily on top of JVM, and this fact has driven the design of many of its concurrency libraries. </span><span class="koboSpan" id="kobo.8.2">The memory model in Scala, its multithreading capabilities, and its inter-thread synchronization are all inherited from the JVM. </span><span class="koboSpan" id="kobo.8.3">Most, if not all, higher-level Scala concurrency constructs are implemented in terms of the low-level primitives presented in this chapter. </span><span class="koboSpan" id="kobo.8.4">These primitives are the basic way to deal with concurrency-in a way, the APIs and synchronization primitives in this chapter constitute the assembly of concurrent programming on the JVM.</span></p><p><span class="koboSpan" id="kobo.9.1">In most cases, you should avoid low-level concurrency in place of higher-level constructs introduced later, but we felt it was important for you to understand what a thread is, that a guarded block is better than busy-waiting, or why a memory model is useful. </span><span class="koboSpan" id="kobo.9.2">We are convinced that this is essential for a better understanding of high-level concurrency abstractions. </span><span class="koboSpan" id="kobo.9.3">Despite the popular notion that an abstraction that requires knowledge about its implementation is broken, understanding the basics often proves very handy- in practice, all abstractions are to some extent leaky.</span></p><p><span class="koboSpan" id="kobo.10.1">In what follows, we not only explain the cornerstones of concurrency on JVM, but also discuss how they interact with some Scala-specific features. </span><span class="koboSpan" id="kobo.10.2">In particular, we will cover the following topics in this chapter:</span></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="koboSpan" id="kobo.11.1">Creating and starting threads and waiting for their completion</span></li><li class="listitem" style="list-style-type: disc"><span class="koboSpan" id="kobo.12.1">Communication between threads using object monitors and the </span><code class="literal"><span class="koboSpan" id="kobo.13.1">synchronized</span></code><span class="koboSpan" id="kobo.14.1"> statement</span></li><li class="listitem" style="list-style-type: disc"><span class="koboSpan" id="kobo.15.1">How to avoid busy-waiting using guarded blocks</span></li><li class="listitem" style="list-style-type: disc"><span class="koboSpan" id="kobo.16.1">The semantics of volatile variables</span></li><li class="listitem" style="list-style-type: disc"><span class="koboSpan" id="kobo.17.1">The specifics of the </span><span class="strong"><strong><span class="koboSpan" id="kobo.18.1">Java Memory Model</span></strong></span><span class="koboSpan" id="kobo.19.1"> (</span><span class="strong"><strong><span class="koboSpan" id="kobo.20.1">JMM</span></strong></span><span class="koboSpan" id="kobo.21.1">), and why the JMM is important</span></li></ul></div><p><span class="koboSpan" id="kobo.22.1">In the following section, we will study how to use threads--the basic way to express concurrent computations.</span></p><div class="section" title="Processes and threads"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec13"/><span class="koboSpan" id="kobo.23.1">Processes and threads</span></h1></div></div></div><p><span class="koboSpan" id="kobo.24.1">In modern, pre-emptive, multitasking operating systems, the programmer has little or no control over the choice of processor on which the program will be executed. </span><span class="koboSpan" id="kobo.24.2">In fact, the same program might run on many different processors during its execution and sometimes even simultaneously on several processors. </span><span class="koboSpan" id="kobo.24.3">It is usually the task of the </span><span class="strong"><strong><span class="koboSpan" id="kobo.25.1">Operating System</span></strong></span><span class="koboSpan" id="kobo.26.1"> (</span><span class="strong"><strong><span class="koboSpan" id="kobo.27.1">OS</span></strong></span><span class="koboSpan" id="kobo.28.1">) to assign executable parts of the program to specific processors--this mechanism is called </span><span class="strong"><strong><span class="koboSpan" id="kobo.29.1">multitasking</span></strong></span><span class="koboSpan" id="kobo.30.1">, and it happens transparently for the computer user.</span></p><p><span class="koboSpan" id="kobo.31.1">Historically, multitasking was introduced to operating systems to improve the user experience by allowing multiple users or programs to use resources of the same computer simultaneously. </span><span class="koboSpan" id="kobo.31.2">In cooperative multitasking, programs were able to decide when to stop using the processor and yield control to other programs. </span><span class="koboSpan" id="kobo.31.3">However, this required a lot of discipline on the programmer's part and programs could easily give the impression of being unresponsive. </span><span class="koboSpan" id="kobo.31.4">For example, a download manager that starts downloading a file must take care in order to yield control to other programs. </span><span class="koboSpan" id="kobo.31.5">Blocking the execution until a download finishes will completely ruin the user experience. </span><span class="koboSpan" id="kobo.31.6">Most operating systems today rely on pre-emptive multitasking, in which each program is repetitively assigned slices of execution time at a specific processor. </span><span class="koboSpan" id="kobo.31.7">These slices are called </span><span class="strong"><strong><span class="koboSpan" id="kobo.32.1">time slices</span></strong></span><span class="koboSpan" id="kobo.33.1">. </span><span class="koboSpan" id="kobo.33.2">Thus, multitasking happens transparently for the application programmer as well as the user.</span></p><p><span class="koboSpan" id="kobo.34.1">The same computer program can be started more than once, or even simultaneously within the same OS. </span><span class="koboSpan" id="kobo.34.2">A </span><span class="strong"><strong><span class="koboSpan" id="kobo.35.1">process</span></strong></span><span class="koboSpan" id="kobo.36.1"> is an instance of a computer program that is being executed. </span><span class="koboSpan" id="kobo.36.2">When a process starts, the OS reserves a part of the memory and other computational resources and associates them with a specific computer program. </span><span class="koboSpan" id="kobo.36.3">The OS then associates the processor with the process, and the process executes during one-time slice. </span><span class="koboSpan" id="kobo.36.4">Eventually, the OS gives other processes control over the processor. </span><span class="koboSpan" id="kobo.36.5">Importantly, the memory and other computational resources of one process are isolated from the other processes: two processes cannot read each other's memory directly or simultaneously use most of the resources.</span></p><p><span class="koboSpan" id="kobo.37.1">Most programs are comprised of a single process, but some programs run in multiple processes. </span><span class="koboSpan" id="kobo.37.2">In this case, different tasks within the program are expressed as separate processes. </span><span class="koboSpan" id="kobo.37.3">Since separate processes cannot access the same memory areas directly, it can be cumbersome to express multitasking using multiple processes.</span></p><p><span class="koboSpan" id="kobo.38.1">Multitasking was important long before recent years when multicore computers became mainstream. </span><span class="koboSpan" id="kobo.38.2">Large programs such as web browsers are divided into many logical modules. </span><span class="koboSpan" id="kobo.38.3">A browser's download manager downloads files independent of rendering the web page or updating the HTML </span><span class="strong"><strong><span class="koboSpan" id="kobo.39.1">Document Object Model</span></strong></span><span class="koboSpan" id="kobo.40.1"> (</span><span class="strong"><strong><span class="koboSpan" id="kobo.41.1">DOM</span></strong></span><span class="koboSpan" id="kobo.42.1">). </span><span class="koboSpan" id="kobo.42.2">While the user is browsing a social networking website, the file download proceeds in the background; but both independent computations occur as part of the same process. </span><span class="koboSpan" id="kobo.42.3">These independent computations occurring in the same process are called </span><span class="strong"><strong><span class="koboSpan" id="kobo.43.1">threads</span></strong></span><span class="koboSpan" id="kobo.44.1">. </span><span class="koboSpan" id="kobo.44.2">In a typical operating system, there are many more threads than processors.</span></p><p><span class="koboSpan" id="kobo.45.1">Every thread describes the current state of the program</span><span class="strong"><strong><span class="koboSpan" id="kobo.46.1"> stack</span></strong></span><span class="koboSpan" id="kobo.47.1"> and the program</span><span class="strong"><strong><span class="koboSpan" id="kobo.48.1"> counter</span></strong></span><span class="koboSpan" id="kobo.49.1"> during program execution. </span><span class="koboSpan" id="kobo.49.2">The program stack contains a sequence of method invocations that are currently being executed, along with the local variables and method parameters of each method. </span><span class="koboSpan" id="kobo.49.3">The program counter describes the position of the current instruction in the current method. </span><span class="koboSpan" id="kobo.49.4">A processor can advance the computation in some thread by manipulating the state of its stack or the state of the program objects and executing the instruction at the current program counter. </span><span class="koboSpan" id="kobo.49.5">When we say that a thread performs an action such as writing to a memory location, we mean that the processor executing that thread performs that action. </span><span class="koboSpan" id="kobo.49.6">In pre-emptive multitasking, thread execution is scheduled by the operating system. </span><span class="koboSpan" id="kobo.49.7">A programmer must assume that the processor time assigned to their thread is unbiased towards other threads in the system.</span></p><p><span class="strong"><strong><span class="koboSpan" id="kobo.50.1">OS threads</span></strong></span><span class="koboSpan" id="kobo.51.1"> are a programming facility provided by the OS, usually exposed through an OS-specific programming interface. </span><span class="koboSpan" id="kobo.51.2">Unlike separate processes, separate OS threads within the same process share a region of memory, and communicate by writing to and reading parts of that memory. </span><span class="koboSpan" id="kobo.51.3">Another way to define a process is to define it as a set of OS threads along with the memory and resources shared by these threads.</span></p><p><span class="koboSpan" id="kobo.52.1"> 
 Based on the preceding discussion about the relationships between processes and threads, a summary of a typical OS is depicted in the following simplified diagram:</span></p><div class="mediaobject"><span class="koboSpan" id="kobo.53.1"><img src="graphics/image_02_001.jpg" alt="Processes and threads"/></span></div><p><span class="koboSpan" id="kobo.54.1">The preceding diagram shows an OS in which multiple processes are executing simultaneously. </span><span class="koboSpan" id="kobo.54.2">Only the first three processes are shown in the illustration. </span><span class="koboSpan" id="kobo.54.3">Each process is assigned a fixed region of computer memory. </span><span class="koboSpan" id="kobo.54.4">In practice, the memory system of the OS is much more complex, but this approximation serves as a simple mental model.</span></p><p><span class="koboSpan" id="kobo.55.1">Each of the processes contains multiple OS threads, two of which are shown for each process. </span><span class="koboSpan" id="kobo.55.2">Currently, </span><span class="strong"><strong><span class="koboSpan" id="kobo.56.1">Thread 1</span></strong></span><span class="koboSpan" id="kobo.57.1"> of </span><span class="strong"><strong><span class="koboSpan" id="kobo.58.1">Process 2</span></strong></span><span class="koboSpan" id="kobo.59.1"> is executing on </span><span class="strong"><strong><span class="koboSpan" id="kobo.60.1">CPU Core 1</span></strong></span><span class="koboSpan" id="kobo.61.1">, and </span><span class="strong"><strong><span class="koboSpan" id="kobo.62.1">Thread 2</span></strong></span><span class="koboSpan" id="kobo.63.1"> of </span><span class="strong"><strong><span class="koboSpan" id="kobo.64.1">Process 3</span></strong></span><span class="koboSpan" id="kobo.65.1"> is executing on </span><span class="strong"><strong><span class="koboSpan" id="kobo.66.1">CPU Core 2</span></strong></span><span class="koboSpan" id="kobo.67.1">. </span><span class="koboSpan" id="kobo.67.2">The OS periodically assigns different OS threads to each of the CPU cores to allow the computation to progress in all the processes.</span></p><p><span class="koboSpan" id="kobo.68.1">Having shown the relationship between the OS threads and processes, we turn our attention to see how these concepts relate to the </span><span class="strong"><strong><span class="koboSpan" id="kobo.69.1">Java Virtual Machine</span></strong></span><span class="koboSpan" id="kobo.70.1"> (</span><span class="strong"><strong><span class="koboSpan" id="kobo.71.1">JVM</span></strong></span><span class="koboSpan" id="kobo.72.1">), the runtime on top of which Scala programs execute.</span></p><p><span class="koboSpan" id="kobo.73.1">Starting a new JVM instance always creates only one process. </span><span class="koboSpan" id="kobo.73.2">Within the JVM process, multiple threads can run simultaneously. </span><span class="koboSpan" id="kobo.73.3">The JVM represents its threads with the </span><code class="literal"><span class="koboSpan" id="kobo.74.1">java.lang.Thread</span></code><span class="koboSpan" id="kobo.75.1"> class. </span><span class="koboSpan" id="kobo.75.2">Unlike runtimes for languages such as Python, the JVM does not implement its custom threads. </span><span class="koboSpan" id="kobo.75.3">Instead, each Java thread is directly mapped to an OS thread. </span><span class="koboSpan" id="kobo.75.4">This means that Java threads behave in a very similar way to the OS threads, and the JVM depends on the OS and its restrictions.</span></p><p><span class="koboSpan" id="kobo.76.1">Scala is a programming language that is by default compiled to the JVM bytecode, and the Scala compiler output is largely equivalent to that of Java from the JVM's perspective. </span><span class="koboSpan" id="kobo.76.2">This allows Scala programs to transparently call Java libraries, and in some cases, even vice versa. </span><span class="koboSpan" id="kobo.76.3">Scala reuses the threading API from Java for several reasons. </span><span class="koboSpan" id="kobo.76.4">First, Scala can transparently interact with the existing Java thread model, which is already sufficiently comprehensive. </span><span class="koboSpan" id="kobo.76.5">Second, it is useful to retain the same threading API for compatibility reasons, and there is nothing fundamentally new that Scala can introduce with respect to the Java thread API.</span></p><p><span class="koboSpan" id="kobo.77.1">The rest of this chapter shows how to create JVM threads using Scala, how they can be executed, and how they can communicate. </span><span class="koboSpan" id="kobo.77.2">We will show and discuss several concrete examples. </span><span class="koboSpan" id="kobo.77.3">Java aficionados, already well-versed in this subject, might choose to skip the rest of this chapter.</span></p><div class="section" title="Creating and starting threads"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec15"/><span class="koboSpan" id="kobo.78.1">Creating and starting threads</span></h2></div></div></div><p><span class="koboSpan" id="kobo.79.1">Every time a new JVM process starts, it creates several threads by default. </span><span class="koboSpan" id="kobo.79.2">The most important thread among them is the </span><span class="strong"><strong><span class="koboSpan" id="kobo.80.1">main thread</span></strong></span><span class="koboSpan" id="kobo.81.1">, which executes the </span><code class="literal"><span class="koboSpan" id="kobo.82.1">main</span></code><span class="koboSpan" id="kobo.83.1"> method of the Scala program. </span><span class="koboSpan" id="kobo.83.2">We will show this in the following program, which gets the name of the current thread and prints it to the standard output:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.84.1">object ThreadsMain extends App { 
  val t: Thread = Thread.currentThread 
  val name = t.getName 
  println(s"I am the thread $name") 
} 
</span></pre><p><span class="koboSpan" id="kobo.85.1">On the JVM, thread objects are represented with the </span><code class="literal"><span class="koboSpan" id="kobo.86.1">Thread</span></code><span class="koboSpan" id="kobo.87.1"> class. </span><span class="koboSpan" id="kobo.87.2">The preceding program uses the static </span><code class="literal"><span class="koboSpan" id="kobo.88.1">currentThread</span></code><span class="koboSpan" id="kobo.89.1"> method to obtain a reference to the current thread object, and stores it to a local variable named </span><code class="literal"><span class="koboSpan" id="kobo.90.1">t</span></code><span class="koboSpan" id="kobo.91.1">. </span><span class="koboSpan" id="kobo.91.2">It then calls the </span><code class="literal"><span class="koboSpan" id="kobo.92.1">getName</span></code><span class="koboSpan" id="kobo.93.1"> method to obtain the thread's name. </span><span class="koboSpan" id="kobo.93.2">If you are running this program from </span><span class="strong"><strong><span class="koboSpan" id="kobo.94.1">Simple Build Tool</span></strong></span><span class="koboSpan" id="kobo.95.1"> (SBT) with the </span><code class="literal"><span class="koboSpan" id="kobo.96.1">run</span></code><span class="koboSpan" id="kobo.97.1"> command, as explained in </span><a class="link" href="ch01.html" title="Chapter 1. Introduction"><span class="koboSpan" id="kobo.98.1">Chapter 1</span></a><span class="koboSpan" id="kobo.99.1">, </span><span class="emphasis"><em><span class="koboSpan" id="kobo.100.1">Introduction</span></em></span><span class="koboSpan" id="kobo.101.1">, you should see the following output:</span></p><pre class="programlisting">
<span class="strong"><strong><span class="koboSpan" id="kobo.102.1">[info] I am the thread run-main-0</span></strong></span>
</pre><p><span class="koboSpan" id="kobo.103.1">Normally, the name of the main thread is just the </span><code class="literal"><span class="koboSpan" id="kobo.104.1">main</span></code><span class="koboSpan" id="kobo.105.1"> method. </span><span class="koboSpan" id="kobo.105.2">The reason we see a different name is because SBT started our program on a separate thread inside the SBT process. </span><span class="koboSpan" id="kobo.105.3">To ensure that the program runs inside a separate JVM process, we need to set SBT's </span><code class="literal"><span class="koboSpan" id="kobo.106.1">fork</span></code><span class="koboSpan" id="kobo.107.1"> setting to </span><code class="literal"><span class="koboSpan" id="kobo.108.1">true</span></code><span class="koboSpan" id="kobo.109.1">:</span></p><pre class="programlisting">
<span class="strong"><strong><span class="koboSpan" id="kobo.110.1">&gt; set fork := true</span></strong></span>
</pre><p><span class="koboSpan" id="kobo.111.1">Invoking the SBT </span><code class="literal"><span class="koboSpan" id="kobo.112.1">run</span></code><span class="koboSpan" id="kobo.113.1"> command again should give the following output:</span></p><pre class="programlisting">
<span class="strong"><strong><span class="koboSpan" id="kobo.114.1">[info] I am the thread main</span></strong></span>
</pre><p><span class="koboSpan" id="kobo.115.1">Every thread goes through several </span><span class="strong"><strong><span class="koboSpan" id="kobo.116.1">thread states</span></strong></span><span class="koboSpan" id="kobo.117.1"> during its existence. </span><span class="koboSpan" id="kobo.117.2">When a </span><code class="literal"><span class="koboSpan" id="kobo.118.1">Thread</span></code><span class="koboSpan" id="kobo.119.1"> object is created, it is initially in the </span><span class="strong"><strong><span class="koboSpan" id="kobo.120.1">new</span></strong></span><span class="koboSpan" id="kobo.121.1"> state. </span><span class="koboSpan" id="kobo.121.2">After the newly created thread object starts executing, it goes into the </span><span class="strong"><strong><span class="koboSpan" id="kobo.122.1">runnable</span></strong></span><span class="koboSpan" id="kobo.123.1"> state. </span><span class="koboSpan" id="kobo.123.2">After the thread is done executing, the thread object goes into the </span><span class="strong"><strong><span class="koboSpan" id="kobo.124.1">terminated state</span></strong></span><span class="koboSpan" id="kobo.125.1">, and cannot execute anymore.</span></p><p><span class="koboSpan" id="kobo.126.1">Starting an independent thread of computation consists of two steps. </span><span class="koboSpan" id="kobo.126.2">First, we need to create a </span><code class="literal"><span class="koboSpan" id="kobo.127.1">Thread</span></code><span class="koboSpan" id="kobo.128.1"> object to allocate the memory for the stack and thread state. </span><span class="koboSpan" id="kobo.128.2">To start the computation, we need to call the </span><code class="literal"><span class="koboSpan" id="kobo.129.1">start</span></code><span class="koboSpan" id="kobo.130.1"> method on this object. </span><span class="koboSpan" id="kobo.130.2">We show how to do this in the following example application called </span><code class="literal"><span class="koboSpan" id="kobo.131.1">ThreadsCreation</span></code><span class="koboSpan" id="kobo.132.1">:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.133.1">object ThreadsCreation extends App { 
  class MyThread extends Thread { 
    override def run(): Unit = { 
      println("New thread running.") 
    } 
  } 
  val t = new MyThread 
  t.start() 
  t.join() 
  println("New thread joined.") 
} 
</span></pre><p><span class="koboSpan" id="kobo.134.1">When a JVM application starts, it creates a special thread called the </span><span class="strong"><strong><span class="koboSpan" id="kobo.135.1">main thread</span></strong></span><span class="koboSpan" id="kobo.136.1"> that executes the method called </span><code class="literal"><span class="koboSpan" id="kobo.137.1">main</span></code><span class="koboSpan" id="kobo.138.1"> in the specified class, in this case, the </span><code class="literal"><span class="koboSpan" id="kobo.139.1">ThreadsCreation</span></code><span class="koboSpan" id="kobo.140.1"> object. </span><span class="koboSpan" id="kobo.140.2">When the </span><code class="literal"><span class="koboSpan" id="kobo.141.1">App</span></code><span class="koboSpan" id="kobo.142.1"> class is extended, the </span><code class="literal"><span class="koboSpan" id="kobo.143.1">main</span></code><span class="koboSpan" id="kobo.144.1"> method is automatically synthesized from the object body. </span><span class="koboSpan" id="kobo.144.2">In this example, the main thread first creates another thread of the </span><code class="literal"><span class="koboSpan" id="kobo.145.1">MyThread</span></code><span class="koboSpan" id="kobo.146.1"> type and assigns it to </span><code class="literal"><span class="koboSpan" id="kobo.147.1">t</span></code><span class="koboSpan" id="kobo.148.1">.</span></p><p><span class="koboSpan" id="kobo.149.1">Next, the main thread starts </span><code class="literal"><span class="koboSpan" id="kobo.150.1">t</span></code><span class="koboSpan" id="kobo.151.1"> by calling the </span><code class="literal"><span class="koboSpan" id="kobo.152.1">start</span></code><span class="koboSpan" id="kobo.153.1"> method. </span><span class="koboSpan" id="kobo.153.2">Calling the </span><code class="literal"><span class="koboSpan" id="kobo.154.1">start</span></code><span class="koboSpan" id="kobo.155.1"> method eventually results in executing the </span><code class="literal"><span class="koboSpan" id="kobo.156.1">run</span></code><span class="koboSpan" id="kobo.157.1"> method from the new thread. </span><span class="koboSpan" id="kobo.157.2">First, the OS is notified that </span><code class="literal"><span class="koboSpan" id="kobo.158.1">t</span></code><span class="koboSpan" id="kobo.159.1"> must start executing. </span><span class="koboSpan" id="kobo.159.2">When the OS decides to assign the new thread to some processor, this is largely out of the programmer's control, but the OS must ensure that this eventually happens. </span><span class="koboSpan" id="kobo.159.3">After the main thread starts the new thread </span><code class="literal"><span class="koboSpan" id="kobo.160.1">t</span></code><span class="koboSpan" id="kobo.161.1">, it calls its </span><code class="literal"><span class="koboSpan" id="kobo.162.1">join</span></code><span class="koboSpan" id="kobo.163.1"> method. </span><span class="koboSpan" id="kobo.163.2">This method halts the execution of the main thread until </span><code class="literal"><span class="koboSpan" id="kobo.164.1">t</span></code><span class="koboSpan" id="kobo.165.1"> completes its execution. </span><span class="koboSpan" id="kobo.165.2">We say that the </span><code class="literal"><span class="koboSpan" id="kobo.166.1">join</span></code><span class="koboSpan" id="kobo.167.1"> operation puts the main thread into the </span><span class="strong"><strong><span class="koboSpan" id="kobo.168.1">waiting state</span></strong></span><span class="koboSpan" id="kobo.169.1"> until </span><code class="literal"><span class="koboSpan" id="kobo.170.1">t</span></code><span class="koboSpan" id="kobo.171.1"> terminates. </span><span class="koboSpan" id="kobo.171.2">Importantly, the waiting thread relinquishes its control over the processor, and the OS can assign that processor to some other thread.</span></p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note6"/><span class="koboSpan" id="kobo.172.1">Note</span></h3><p><span class="koboSpan" id="kobo.173.1">Waiting threads notify the OS that they are waiting for some condition and cease spending CPU cycles, instead of repetitively checking that condition.</span></p></div></div><p><span class="koboSpan" id="kobo.174.1">In the meantime, the OS finds an available processor and instructs it to run the child thread. </span><span class="koboSpan" id="kobo.174.2">The instructions that a thread must execute are specified by overriding its </span><code class="literal"><span class="koboSpan" id="kobo.175.1">run</span></code><span class="koboSpan" id="kobo.176.1"> method. </span><span class="koboSpan" id="kobo.176.2">The </span><code class="literal"><span class="koboSpan" id="kobo.177.1">t</span></code><span class="koboSpan" id="kobo.178.1"> instance of the </span><code class="literal"><span class="koboSpan" id="kobo.179.1">MyThread</span></code><span class="koboSpan" id="kobo.180.1"> class starts by printing the "</span><code class="literal"><span class="koboSpan" id="kobo.181.1">New thread running."</span></code><span class="koboSpan" id="kobo.182.1"> text to the standard output and then terminates. </span><span class="koboSpan" id="kobo.182.2">At this point, the operating system is notified that </span><code class="literal"><span class="koboSpan" id="kobo.183.1">t</span></code><span class="koboSpan" id="kobo.184.1"> is terminated and eventually lets the main thread continue the execution. </span><span class="koboSpan" id="kobo.184.2">The OS then puts the main thread back into the running state, and the main thread prints </span><code class="literal"><span class="koboSpan" id="kobo.185.1">"New thread joined."</span></code><span class="koboSpan" id="kobo.186.1">. </span><span class="koboSpan" id="kobo.186.2">This is shown in the following diagram:</span></p><div class="mediaobject"><span class="koboSpan" id="kobo.187.1"><img src="graphics/image_02_002.jpg" alt="Creating and starting threads"/></span></div><p><span class="koboSpan" id="kobo.188.1">It is important to note that the two outputs </span><code class="literal"><span class="koboSpan" id="kobo.189.1">"New thread running."</span></code><span class="koboSpan" id="kobo.190.1"> and </span><code class="literal"><span class="koboSpan" id="kobo.191.1">"New thread joined."</span></code><span class="koboSpan" id="kobo.192.1"> are always printed in this order. </span><span class="koboSpan" id="kobo.192.2">This is because the </span><code class="literal"><span class="koboSpan" id="kobo.193.1">join</span></code><span class="koboSpan" id="kobo.194.1"> call ensures that the termination of the </span><code class="literal"><span class="koboSpan" id="kobo.195.1">t</span></code><span class="koboSpan" id="kobo.196.1"> thread occurs before the instructions following the </span><code class="literal"><span class="koboSpan" id="kobo.197.1">join</span></code><span class="koboSpan" id="kobo.198.1"> call.</span></p><p><span class="koboSpan" id="kobo.199.1">When running the program, it is executed so fast that the two </span><code class="literal"><span class="koboSpan" id="kobo.200.1">println</span></code><span class="koboSpan" id="kobo.201.1"> statements occur almost simultaneously. </span><span class="koboSpan" id="kobo.201.2">Could it be that the ordering of the </span><code class="literal"><span class="koboSpan" id="kobo.202.1">println</span></code><span class="koboSpan" id="kobo.203.1"> statements is just an artifact in how the OS chooses to execute these threads? </span><span class="koboSpan" id="kobo.203.2">To verify the hypothesis that the main thread really waits for </span><code class="literal"><span class="koboSpan" id="kobo.204.1">t</span></code><span class="koboSpan" id="kobo.205.1"> and that the output is not just because the OS is biased to execute </span><code class="literal"><span class="koboSpan" id="kobo.206.1">t</span></code><span class="koboSpan" id="kobo.207.1"> first in this particular example, we can experiment by tweaking the execution schedule. </span><span class="koboSpan" id="kobo.207.2">Before we do that, we will introduce a shorthand to create and start a new thread; the current syntax is too verbose! </span><span class="koboSpan" id="kobo.207.3">The new </span><code class="literal"><span class="koboSpan" id="kobo.208.1">thread</span></code><span class="koboSpan" id="kobo.209.1"> method simply runs a block of code in a newly started thread. </span><span class="koboSpan" id="kobo.209.2">This time, we will create the new thread using an anonymous thread class declared inline at the instantiation site:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.210.1">def thread(body: =&gt;Unit): Thread = { 
  val t = new Thread { 
    override def run() = body 
  } 
  t.start() 
  t 
} 
</span></pre><p><span class="koboSpan" id="kobo.211.1">The </span><code class="literal"><span class="koboSpan" id="kobo.212.1">thread</span></code><span class="koboSpan" id="kobo.213.1"> method takes a block of code body, creates a new thread that executes this block of code in its </span><code class="literal"><span class="koboSpan" id="kobo.214.1">run</span></code><span class="koboSpan" id="kobo.215.1"> method, starts the thread, and returns a reference to the new thread so that the clients can call </span><code class="literal"><span class="koboSpan" id="kobo.216.1">join</span></code><span class="koboSpan" id="kobo.217.1"> on it.</span></p><p><span class="koboSpan" id="kobo.218.1">Creating and starting threads using the </span><code class="literal"><span class="koboSpan" id="kobo.219.1">thread</span></code><span class="koboSpan" id="kobo.220.1"> statement is much less verbose. </span><span class="koboSpan" id="kobo.220.2">To make the examples in this chapter more concise, we will use the </span><code class="literal"><span class="koboSpan" id="kobo.221.1">thread</span></code><span class="koboSpan" id="kobo.222.1"> statement from now on. </span><span class="koboSpan" id="kobo.222.2">However, you should think twice before using the </span><code class="literal"><span class="koboSpan" id="kobo.223.1">thread</span></code><span class="koboSpan" id="kobo.224.1"> statement in production projects. </span><span class="koboSpan" id="kobo.224.2">It is prudent to correlate the syntactic burden with the computational cost; lightweight syntax can be mistaken for a cheap operation and creating a new thread is relatively expensive.</span></p><p><span class="koboSpan" id="kobo.225.1">We can now experiment with the OS by making sure that all the processors are available. </span><span class="koboSpan" id="kobo.225.2">To do this, we will use the static </span><code class="literal"><span class="koboSpan" id="kobo.226.1">sleep</span></code><span class="koboSpan" id="kobo.227.1"> method on the </span><code class="literal"><span class="koboSpan" id="kobo.228.1">Thread</span></code><span class="koboSpan" id="kobo.229.1"> class, which postpones the execution of the thread that is being currently executed for the specified number of milliseconds. </span><span class="koboSpan" id="kobo.229.2">This method puts the thread into the </span><span class="strong"><strong><span class="koboSpan" id="kobo.230.1">timed waiting</span></strong></span><span class="koboSpan" id="kobo.231.1"> state. </span><span class="koboSpan" id="kobo.231.2">The OS can reuse the processor for other threads when </span><code class="literal"><span class="koboSpan" id="kobo.232.1">sleep</span></code><span class="koboSpan" id="kobo.233.1"> is called. </span><span class="koboSpan" id="kobo.233.2">Still, we will require a sleep time much larger than the time slice on a typical OS, which ranges from 10 to 100 milliseconds. </span><span class="koboSpan" id="kobo.233.3">The following code depicts this:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.234.1">object ThreadsSleep extends App { 
  val t = thread { 
    Thread.sleep(1000) 
    log("New thread running.") 
    Thread.sleep(1000) 
    log("Still running.") 
    Thread.sleep(1000) 
    log("Completed.") 
  } 
  t.join() 
  log("New thread joined.") 
} 
</span></pre><p><span class="koboSpan" id="kobo.235.1">The main thread of the </span><code class="literal"><span class="koboSpan" id="kobo.236.1">ThreadSleep</span></code><span class="koboSpan" id="kobo.237.1"> application creates and starts a new </span><code class="literal"><span class="koboSpan" id="kobo.238.1">t</span></code><span class="koboSpan" id="kobo.239.1"> thread that sleeps for one second, then outputs some text, and repeats this two or more times before terminating. </span><span class="koboSpan" id="kobo.239.2">The main thread calls </span><code class="literal"><span class="koboSpan" id="kobo.240.1">join</span></code><span class="koboSpan" id="kobo.241.1"> as before and then prints </span><code class="literal"><span class="koboSpan" id="kobo.242.1">"New thread joined."</span></code><span class="koboSpan" id="kobo.243.1">.</span></p><p><span class="koboSpan" id="kobo.244.1">Note that we are now using the </span><code class="literal"><span class="koboSpan" id="kobo.245.1">log</span></code><span class="koboSpan" id="kobo.246.1"> method described in </span><a class="link" href="ch01.html" title="Chapter 1. Introduction"><span class="koboSpan" id="kobo.247.1">Chapter 1</span></a><span class="koboSpan" id="kobo.248.1">, </span><span class="emphasis"><em><span class="koboSpan" id="kobo.249.1">Introduction</span></em></span><span class="koboSpan" id="kobo.250.1">. </span><span class="koboSpan" id="kobo.250.2">The </span><code class="literal"><span class="koboSpan" id="kobo.251.1">log</span></code><span class="koboSpan" id="kobo.252.1"> method prints the specified string value along with the name of the thread that calls the </span><code class="literal"><span class="koboSpan" id="kobo.253.1">log</span></code><span class="koboSpan" id="kobo.254.1"> method.</span></p><p><span class="koboSpan" id="kobo.255.1">Regardless of how many times you run the preceding application, the last output will always be </span><code class="literal"><span class="koboSpan" id="kobo.256.1">"New thread joined."</span></code><span class="koboSpan" id="kobo.257.1">. </span><span class="koboSpan" id="kobo.257.2">This program is </span><span class="strong"><strong><span class="koboSpan" id="kobo.258.1">deterministic</span></strong></span><span class="koboSpan" id="kobo.259.1">: given a particular input, it will always produce the same output, regardless of the execution schedule chosen by the OS.</span></p><p><span class="koboSpan" id="kobo.260.1">However, not all the applications using threads will always yield the same output if given the same input. </span><span class="koboSpan" id="kobo.260.2">The following code is an example of a </span><span class="strong"><strong><span class="koboSpan" id="kobo.261.1">nondeterministic</span></strong></span><span class="koboSpan" id="kobo.262.1"> application:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.263.1">object ThreadsNondeterminism extends App { 
  val t = thread { log("New thread running.") } 
  log("...") 
  log("...") 
  t.join() 
  log("New thread joined.") 
} 
</span></pre><p><span class="koboSpan" id="kobo.264.1">There is no guarantee that the </span><code class="literal"><span class="koboSpan" id="kobo.265.1">log("...")</span></code><span class="koboSpan" id="kobo.266.1"> statements in the main thread occur before or after the </span><code class="literal"><span class="koboSpan" id="kobo.267.1">log</span></code><span class="koboSpan" id="kobo.268.1"> call in the </span><code class="literal"><span class="koboSpan" id="kobo.269.1">t</span></code><span class="koboSpan" id="kobo.270.1"> thread. </span><span class="koboSpan" id="kobo.270.2">Running the application several times on a multicore processor prints </span><code class="literal"><span class="koboSpan" id="kobo.271.1">"..."</span></code><span class="koboSpan" id="kobo.272.1"> before, after, or interleaved with the output by the </span><code class="literal"><span class="koboSpan" id="kobo.273.1">t</span></code><span class="koboSpan" id="kobo.274.1"> thread. </span><span class="koboSpan" id="kobo.274.2">By running the program, we get the following output:</span></p><pre class="programlisting">
<span class="strong"><strong><span class="koboSpan" id="kobo.275.1">run-main-46: ...</span></strong></span>
<span class="strong"><strong><span class="koboSpan" id="kobo.276.1">Thread-80: New thread running.</span></strong></span>
<span class="strong"><strong><span class="koboSpan" id="kobo.277.1">run-main-46: ...</span></strong></span>
<span class="strong"><strong><span class="koboSpan" id="kobo.278.1">run-main-46: New thread joined.</span></strong></span>
</pre><p><span class="koboSpan" id="kobo.279.1">Running the program again results in a different order between these outputs:</span></p><pre class="programlisting">
<span class="strong"><strong><span class="koboSpan" id="kobo.280.1">Thread-81: New thread running.</span></strong></span>
<span class="strong"><strong><span class="koboSpan" id="kobo.281.1">run-main-47: ...</span></strong></span>
<span class="strong"><strong><span class="koboSpan" id="kobo.282.1">run-main-47: ...</span></strong></span>
<span class="strong"><strong><span class="koboSpan" id="kobo.283.1">run-main-47: New thread joined.</span></strong></span>
</pre><p><span class="koboSpan" id="kobo.284.1">Most multithreaded programs are nondeterministic, and this is what makes multithreaded programming so hard. </span><span class="koboSpan" id="kobo.284.2">There are multiple possible reasons for this. </span><span class="koboSpan" id="kobo.284.3">First, the program might be too big for the programmer to reason about its determinism properties, and interactions between threads could simply be too complex. </span><span class="koboSpan" id="kobo.284.4">But some programs are inherently non-deterministic. </span><span class="koboSpan" id="kobo.284.5">A web server has no idea which client will be the first to send a request for a web page. </span><span class="koboSpan" id="kobo.284.6">It must allow these requests to arrive in any possible order and respond to them as soon as they arrive. </span><span class="koboSpan" id="kobo.284.7">Depending on the order in which the clients prepare inputs for the web server, they can behave differently even though the requests might be the same.</span></p></div><div class="section" title="Atomic execution"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec16"/><span class="koboSpan" id="kobo.285.1">Atomic execution</span></h2></div></div></div><p><span class="koboSpan" id="kobo.286.1">We have already seen one basic way in which threads can communicate: by waiting for each other to terminate. </span><span class="koboSpan" id="kobo.286.2">The information that the joined thread delivers is that it has terminated. </span><span class="koboSpan" id="kobo.286.3">In practice, however, this information is not necessarily useful; for example, a thread that renders one page in a web browser must inform the other threads that a specific URL has been visited, so as to render such a visited URL in a different color.</span></p><p><span class="koboSpan" id="kobo.287.1">It turns out that the </span><code class="literal"><span class="koboSpan" id="kobo.288.1">join</span></code><span class="koboSpan" id="kobo.289.1"> method on threads has an additional property. </span><span class="koboSpan" id="kobo.289.2">All the writes to memory performed by the thread being joined occur before the </span><code class="literal"><span class="koboSpan" id="kobo.290.1">join</span></code><span class="koboSpan" id="kobo.291.1"> call returns and are visible to threads that call the </span><code class="literal"><span class="koboSpan" id="kobo.292.1">join</span></code><span class="koboSpan" id="kobo.293.1"> method. </span><span class="koboSpan" id="kobo.293.2">This is illustrated by the following example:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.294.1">object ThreadsCommunicate extends App { 
  var result: String = null 
  val t = thread { result = "\nTitle\n" + "=" * 5 } 
  t.join() 
  log(result) 
} 
</span></pre><p><span class="koboSpan" id="kobo.295.1">The main thread will never print </span><code class="literal"><span class="koboSpan" id="kobo.296.1">null</span></code><span class="koboSpan" id="kobo.297.1">, as the call to </span><code class="literal"><span class="koboSpan" id="kobo.298.1">join</span></code><span class="koboSpan" id="kobo.299.1"> always occurs before the </span><code class="literal"><span class="koboSpan" id="kobo.300.1">log</span></code><span class="koboSpan" id="kobo.301.1"> call, and the assignment to </span><code class="literal"><span class="koboSpan" id="kobo.302.1">result</span></code><span class="koboSpan" id="kobo.303.1"> occurs before the termination of </span><code class="literal"><span class="koboSpan" id="kobo.304.1">t</span></code><span class="koboSpan" id="kobo.305.1">. </span><span class="koboSpan" id="kobo.305.2">This pattern is a very basic way in which the threads can use their results to communicate with each other.</span></p><p><span class="koboSpan" id="kobo.306.1">However, this pattern only allows very restricted one-way communication, and it does not allow threads to mutually communicate during their execution. </span><span class="koboSpan" id="kobo.306.2">There are many use cases for an unrestricted two-way communication. </span><span class="koboSpan" id="kobo.306.3">One example is assigning unique identifiers, in which a set of threads concurrently choose numbers such that no two threads produce the same number. </span><span class="koboSpan" id="kobo.306.4">We might be tempted to proceed as in the following incorrect example. </span><span class="koboSpan" id="kobo.306.5">We start by showing the first half of the program:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.307.1">object ThreadsUnprotectedUid extends App { 
  var uidCount = 0L 
  def getUniqueId() = { 
    val freshUid = uidCount + 1 
    uidCount = freshUid 
    freshUid 
  } 
</span></pre><p><span class="koboSpan" id="kobo.308.1">In the preceding code snippet, we first declare a </span><code class="literal"><span class="koboSpan" id="kobo.309.1">uidCount</span></code><span class="koboSpan" id="kobo.310.1"> variable that will hold the last unique identifier picked by any thread. </span><span class="koboSpan" id="kobo.310.2">The threads will call the </span><code class="literal"><span class="koboSpan" id="kobo.311.1">getUniqueId</span></code><span class="koboSpan" id="kobo.312.1"> method to compute the first unused identifier and then update the </span><code class="literal"><span class="koboSpan" id="kobo.313.1">uidCount</span></code><span class="koboSpan" id="kobo.314.1"> variable. </span><span class="koboSpan" id="kobo.314.2">In this example, reading </span><code class="literal"><span class="koboSpan" id="kobo.315.1">uidCount</span></code><span class="koboSpan" id="kobo.316.1"> to initialize </span><code class="literal"><span class="koboSpan" id="kobo.317.1">freshUid</span></code><span class="koboSpan" id="kobo.318.1"> and assigning </span><code class="literal"><span class="koboSpan" id="kobo.319.1">freshUid</span></code><span class="koboSpan" id="kobo.320.1"> back to </span><code class="literal"><span class="koboSpan" id="kobo.321.1">uniqueUid</span></code><span class="koboSpan" id="kobo.322.1"> do not necessarily happen together. </span><span class="koboSpan" id="kobo.322.2">We say that the two statements do not happen </span><span class="strong"><strong><span class="koboSpan" id="kobo.323.1">atomically</span></strong></span><span class="koboSpan" id="kobo.324.1"> since the statements from the other threads can interleave arbitrarily. </span><span class="koboSpan" id="kobo.324.2">We next define a </span><code class="literal"><span class="koboSpan" id="kobo.325.1">printUniqueIds</span></code><span class="koboSpan" id="kobo.326.1"> method such that, given a number </span><code class="literal"><span class="koboSpan" id="kobo.327.1">n</span></code><span class="koboSpan" id="kobo.328.1">, the method calls </span><code class="literal"><span class="koboSpan" id="kobo.329.1">getUniqueId</span></code><span class="koboSpan" id="kobo.330.1"> to produce </span><code class="literal"><span class="koboSpan" id="kobo.331.1">n</span></code><span class="koboSpan" id="kobo.332.1"> unique identifiers and then prints them. </span><span class="koboSpan" id="kobo.332.2">We use Scala for-comprehensions to map the range </span><code class="literal"><span class="koboSpan" id="kobo.333.1">0 until n</span></code><span class="koboSpan" id="kobo.334.1"> to unique identifiers. </span><span class="koboSpan" id="kobo.334.2">Finally, the main thread starts a new </span><code class="literal"><span class="koboSpan" id="kobo.335.1">t</span></code><span class="koboSpan" id="kobo.336.1"> thread that calls the </span><code class="literal"><span class="koboSpan" id="kobo.337.1">printUniqueIds</span></code><span class="koboSpan" id="kobo.338.1"> method, and then calls </span><code class="literal"><span class="koboSpan" id="kobo.339.1">printUniqueIds</span></code><span class="koboSpan" id="kobo.340.1"> concurrently with the </span><code class="literal"><span class="koboSpan" id="kobo.341.1">t</span></code><span class="koboSpan" id="kobo.342.1"> thread as follows:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.343.1">  def printUniqueIds(n: Int): Unit = { 
    val uids = for (i&lt;- 0 until n) yield getUniqueId() 
    log(s"Generated uids: $uids") 
  } 
  val t = thread { printUniqueIds(5) } 
  printUniqueIds(5) 
  t.join() 
} 
</span></pre><p><span class="koboSpan" id="kobo.344.1">Running this application several times reveals that the identifiers generated by the two threads are not necessarily unique; the application prints </span><code class="literal"><span class="koboSpan" id="kobo.345.1">Vector(1, 2, 3, 4, 5)</span></code><span class="koboSpan" id="kobo.346.1"> and </span><code class="literal"><span class="koboSpan" id="kobo.347.1">Vector(1, 6, 7, 8, 9)</span></code><span class="koboSpan" id="kobo.348.1"> in some runs, but not in the others! </span><span class="koboSpan" id="kobo.348.2">The outputs of the program depend on the timing at which the statements in separate threads get executed.</span></p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note7"/><span class="koboSpan" id="kobo.349.1">Note</span></h3><p><span class="koboSpan" id="kobo.350.1">A </span><span class="strong"><strong><span class="koboSpan" id="kobo.351.1">race condition</span></strong></span><span class="koboSpan" id="kobo.352.1"> is a phenomenon in which the output of a concurrent program depends on the execution schedule of the statements in the program.</span></p></div></div><p><span class="koboSpan" id="kobo.353.1">A race condition is not necessarily an incorrect program behavior. </span><span class="koboSpan" id="kobo.353.2">However, if some execution schedule causes an undesired program output, the race condition is considered to be a program error. </span><span class="koboSpan" id="kobo.353.3">The race condition from the previous example is a program error, because the </span><code class="literal"><span class="koboSpan" id="kobo.354.1">getUniqueId</span></code><span class="koboSpan" id="kobo.355.1"> method is not atomic. </span><span class="koboSpan" id="kobo.355.2">The </span><code class="literal"><span class="koboSpan" id="kobo.356.1">t</span></code><span class="koboSpan" id="kobo.357.1"> thread and the main thread sometimes concurrently calls </span><code class="literal"><span class="koboSpan" id="kobo.358.1">getUniqueId</span></code><span class="koboSpan" id="kobo.359.1">. </span><span class="koboSpan" id="kobo.359.2">In the first line, they concurrently read the value of </span><code class="literal"><span class="koboSpan" id="kobo.360.1">uidCount</span></code><span class="koboSpan" id="kobo.361.1">, which is initially </span><code class="literal"><span class="koboSpan" id="kobo.362.1">0</span></code><span class="koboSpan" id="kobo.363.1">, and conclude that their own </span><code class="literal"><span class="koboSpan" id="kobo.364.1">freshUid</span></code><span class="koboSpan" id="kobo.365.1"> variable should be </span><code class="literal"><span class="koboSpan" id="kobo.366.1">1</span></code><span class="koboSpan" id="kobo.367.1">. </span><span class="koboSpan" id="kobo.367.2">The </span><code class="literal"><span class="koboSpan" id="kobo.368.1">freshUid</span></code><span class="koboSpan" id="kobo.369.1"> variable is a local variable, so it is allocated on the thread stack; each thread sees a separate instance of that variable. </span><span class="koboSpan" id="kobo.369.2">At this point, the threads decide to write the value </span><code class="literal"><span class="koboSpan" id="kobo.370.1">1</span></code><span class="koboSpan" id="kobo.371.1"> back to </span><code class="literal"><span class="koboSpan" id="kobo.372.1">uidCount</span></code><span class="koboSpan" id="kobo.373.1"> in any order, and both return a non-unique identifier </span><code class="literal"><span class="koboSpan" id="kobo.374.1">1</span></code><span class="koboSpan" id="kobo.375.1">. </span><span class="koboSpan" id="kobo.375.2">This is illustrated in the following figure:</span></p><div class="mediaobject"><span class="koboSpan" id="kobo.376.1"><img src="graphics/image_02_003.jpg" alt="Atomic execution"/></span></div><p><span class="koboSpan" id="kobo.377.1">There is a mismatch between the mental model that most programmers inherit from sequential programming and the execution of the </span><code class="literal"><span class="koboSpan" id="kobo.378.1">getUniqueId</span></code><span class="koboSpan" id="kobo.379.1"> method when it is run concurrently. </span><span class="koboSpan" id="kobo.379.2">This mismatch is grounded in the assumption that </span><code class="literal"><span class="koboSpan" id="kobo.380.1">getUniqueId</span></code><span class="koboSpan" id="kobo.381.1"> executes atomically. </span><span class="koboSpan" id="kobo.381.2">Atomic execution of a block of code means that the individual statements in that block of code executed by one thread cannot interleave with those statements executed by another thread. </span><span class="koboSpan" id="kobo.381.3">In atomic execution, the statements can only be executed all at once, which is exactly how the </span><code class="literal"><span class="koboSpan" id="kobo.382.1">uidCount</span></code><span class="koboSpan" id="kobo.383.1"> field should be updated. </span><span class="koboSpan" id="kobo.383.2">The code inside the </span><code class="literal"><span class="koboSpan" id="kobo.384.1">getUniqueId</span></code><span class="koboSpan" id="kobo.385.1"> function reads, modifies, and writes a value, which is not atomic on the JVM. </span><span class="koboSpan" id="kobo.385.2">An additional language construct is necessary to guarantee atomicity. </span><span class="koboSpan" id="kobo.385.3">The fundamental Scala construct that allows this sort of atomic execution is called the </span><code class="literal"><span class="koboSpan" id="kobo.386.1">synchronized</span></code><span class="koboSpan" id="kobo.387.1"> statement, and it can be called on any object. </span><span class="koboSpan" id="kobo.387.2">This allows us to define </span><code class="literal"><span class="koboSpan" id="kobo.388.1">getUniqueId</span></code><span class="koboSpan" id="kobo.389.1"> as follows:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.390.1">def getUniqueId() = this.synchronized { 
  val freshUid = uidCount + 1 
  uidCount = freshUid 
  freshUid 
} 
</span></pre><p><span class="koboSpan" id="kobo.391.1">The </span><code class="literal"><span class="koboSpan" id="kobo.392.1">synchronized</span></code><span class="koboSpan" id="kobo.393.1"> call ensures that the subsequent block of code can only execute if there is no other thread simultaneously executing this synchronized block of code, or any other synchronized block of code called on the same </span><code class="literal"><span class="koboSpan" id="kobo.394.1">this</span></code><span class="koboSpan" id="kobo.395.1"> object. </span><span class="koboSpan" id="kobo.395.2">In our case, the </span><code class="literal"><span class="koboSpan" id="kobo.396.1">this</span></code><span class="koboSpan" id="kobo.397.1"> object is the enclosing singleton object, </span><code class="literal"><span class="koboSpan" id="kobo.398.1">ThreadsUnprotectedUid</span></code><span class="koboSpan" id="kobo.399.1">, but in general, this can be an instance of the enclosing class or trait.</span></p><p><span class="koboSpan" id="kobo.400.1">Two concurrent invocations of the </span><code class="literal"><span class="koboSpan" id="kobo.401.1">getUniqueId</span></code><span class="koboSpan" id="kobo.402.1"> method are shown in the following figure:</span></p><div class="mediaobject"><span class="koboSpan" id="kobo.403.1"><img src="graphics/image_02_004.jpg" alt="Atomic execution"/></span></div><p><span class="koboSpan" id="kobo.404.1">We can also call </span><code class="literal"><span class="koboSpan" id="kobo.405.1">synchronized</span></code><span class="koboSpan" id="kobo.406.1"> and omit the </span><code class="literal"><span class="koboSpan" id="kobo.407.1">this</span></code><span class="koboSpan" id="kobo.408.1"> part, in which case the compiler will infer what the surrounding object is, but we strongly discourage you from doing so. </span><span class="koboSpan" id="kobo.408.2">Synchronizing on incorrect objects results in concurrency errors that are not easily identified.</span></p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip8"/><span class="koboSpan" id="kobo.409.1">Tip</span></h3><p><span class="koboSpan" id="kobo.410.1">Always explicitly declare the receiver for the </span><code class="literal"><span class="koboSpan" id="kobo.411.1">synchronized</span></code><span class="koboSpan" id="kobo.412.1"> statement doing so protects you from subtle and hard to spot program errors.</span></p></div></div><p><span class="koboSpan" id="kobo.413.1">The JVM ensures that the thread executing a </span><code class="literal"><span class="koboSpan" id="kobo.414.1">synchronized</span></code><span class="koboSpan" id="kobo.415.1"> statement invoked on some </span><code class="literal"><span class="koboSpan" id="kobo.416.1">x</span></code><span class="koboSpan" id="kobo.417.1"> object is the only thread executing any </span><code class="literal"><span class="koboSpan" id="kobo.418.1">synchronized</span></code><span class="koboSpan" id="kobo.419.1"> statement on that particular </span><code class="literal"><span class="koboSpan" id="kobo.420.1">x</span></code><span class="koboSpan" id="kobo.421.1"> object. </span><span class="koboSpan" id="kobo.421.2">If a </span><code class="literal"><span class="koboSpan" id="kobo.422.1">T</span></code><span class="koboSpan" id="kobo.423.1"> thread calls </span><code class="literal"><span class="koboSpan" id="kobo.424.1">synchronized</span></code><span class="koboSpan" id="kobo.425.1"> on </span><code class="literal"><span class="koboSpan" id="kobo.426.1">x</span></code><span class="koboSpan" id="kobo.427.1">, and there is another </span><code class="literal"><span class="koboSpan" id="kobo.428.1">S</span></code><span class="koboSpan" id="kobo.429.1"> thread calling </span><code class="literal"><span class="koboSpan" id="kobo.430.1">synchronized</span></code><span class="koboSpan" id="kobo.431.1"> on </span><code class="literal"><span class="koboSpan" id="kobo.432.1">x</span></code><span class="koboSpan" id="kobo.433.1">, then the </span><code class="literal"><span class="koboSpan" id="kobo.434.1">T</span></code><span class="koboSpan" id="kobo.435.1"> thread is put into the </span><span class="strong"><strong><span class="koboSpan" id="kobo.436.1">blocked</span></strong></span><span class="koboSpan" id="kobo.437.1"> state. </span><span class="koboSpan" id="kobo.437.2">Once the </span><code class="literal"><span class="koboSpan" id="kobo.438.1">S</span></code><span class="koboSpan" id="kobo.439.1"> thread completes its </span><code class="literal"><span class="koboSpan" id="kobo.440.1">synchronized</span></code><span class="koboSpan" id="kobo.441.1"> statement, the JVM can choose the </span><code class="literal"><span class="koboSpan" id="kobo.442.1">T</span></code><span class="koboSpan" id="kobo.443.1"> thread to execute its own </span><code class="literal"><span class="koboSpan" id="kobo.444.1">synchronized</span></code><span class="koboSpan" id="kobo.445.1"> statement.</span></p><p><span class="koboSpan" id="kobo.446.1">Every object created inside the JVM has a special entity called an </span><span class="strong"><strong><span class="koboSpan" id="kobo.447.1">intrinsic lock</span></strong></span><span class="koboSpan" id="kobo.448.1"> or a </span><span class="strong"><strong><span class="koboSpan" id="kobo.449.1">monitor</span></strong></span><span class="koboSpan" id="kobo.450.1">, which is used to ensure that only one thread is executing some </span><code class="literal"><span class="koboSpan" id="kobo.451.1">synchronized</span></code><span class="koboSpan" id="kobo.452.1"> block on that object. </span><span class="koboSpan" id="kobo.452.2">When a thread starts executing the </span><code class="literal"><span class="koboSpan" id="kobo.453.1">synchronized</span></code><span class="koboSpan" id="kobo.454.1"> block, we say that the thread </span><span class="strong"><strong><span class="koboSpan" id="kobo.455.1">gains ownership</span></strong></span><span class="koboSpan" id="kobo.456.1"> of the </span><code class="literal"><span class="koboSpan" id="kobo.457.1">x</span></code><span class="koboSpan" id="kobo.458.1"> monitor, or alternatively, </span><span class="strong"><strong><span class="koboSpan" id="kobo.459.1">acquires</span></strong></span><span class="koboSpan" id="kobo.460.1"> it. </span><span class="koboSpan" id="kobo.460.2">When a thread completes the </span><code class="literal"><span class="koboSpan" id="kobo.461.1">synchronized</span></code><span class="koboSpan" id="kobo.462.1"> block, we say that it </span><span class="strong"><strong><span class="koboSpan" id="kobo.463.1">releases</span></strong></span><span class="koboSpan" id="kobo.464.1"> the monitor.</span></p><p><span class="koboSpan" id="kobo.465.1">The </span><code class="literal"><span class="koboSpan" id="kobo.466.1">synchronized</span></code><span class="koboSpan" id="kobo.467.1"> statement is one of the fundamental mechanisms for inter-thread communication in Scala and on the JVM. </span><span class="koboSpan" id="kobo.467.2">Whenever there is a possibility that multiple threads access and modify a field in some object, you should use the </span><code class="literal"><span class="koboSpan" id="kobo.468.1">synchronized</span></code><span class="koboSpan" id="kobo.469.1"> statement.</span></p></div><div class="section" title="Reordering"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec17"/><span class="koboSpan" id="kobo.470.1">Reordering</span></h2></div></div></div><p><span class="koboSpan" id="kobo.471.1">The </span><code class="literal"><span class="koboSpan" id="kobo.472.1">synchronized</span></code><span class="koboSpan" id="kobo.473.1"> statement is not without a price: writes to fields such as </span><code class="literal"><span class="koboSpan" id="kobo.474.1">uidCount</span></code><span class="koboSpan" id="kobo.475.1">, which are protected by the </span><code class="literal"><span class="koboSpan" id="kobo.476.1">synchronized</span></code><span class="koboSpan" id="kobo.477.1"> statement are usually more expensive than regular unprotected writes. </span><span class="koboSpan" id="kobo.477.2">The performance penalty of the </span><code class="literal"><span class="koboSpan" id="kobo.478.1">synchronized</span></code><span class="koboSpan" id="kobo.479.1"> statement depends on the JVM implementation, but it is usually not large. </span><span class="koboSpan" id="kobo.479.2">You might be tempted to avoid using </span><code class="literal"><span class="koboSpan" id="kobo.480.1">synchronized</span></code><span class="koboSpan" id="kobo.481.1"> when you think that there is no bad interleaving of program statements, like the one we saw previously in the unique identifier example. </span><span class="koboSpan" id="kobo.481.2">Never do this! </span><span class="koboSpan" id="kobo.481.3">We will now show you a minimal example in which this leads to serious errors.</span></p><p><span class="koboSpan" id="kobo.482.1">Let's consider the following program, in which two threads, </span><code class="literal"><span class="koboSpan" id="kobo.483.1">t1</span></code><span class="koboSpan" id="kobo.484.1"> and </span><code class="literal"><span class="koboSpan" id="kobo.485.1">t2</span></code><span class="koboSpan" id="kobo.486.1">, access a pair of Boolean variables, </span><code class="literal"><span class="koboSpan" id="kobo.487.1">a</span></code><span class="koboSpan" id="kobo.488.1"> and </span><code class="literal"><span class="koboSpan" id="kobo.489.1">b</span></code><span class="koboSpan" id="kobo.490.1">, and a pair of Integer variables, </span><code class="literal"><span class="koboSpan" id="kobo.491.1">x</span></code><span class="koboSpan" id="kobo.492.1"> and </span><code class="literal"><span class="koboSpan" id="kobo.493.1">y</span></code><span class="koboSpan" id="kobo.494.1">. </span><span class="koboSpan" id="kobo.494.2">The </span><code class="literal"><span class="koboSpan" id="kobo.495.1">t1</span></code><span class="koboSpan" id="kobo.496.1"> thread sets the variable </span><code class="literal"><span class="koboSpan" id="kobo.497.1">a</span></code><span class="koboSpan" id="kobo.498.1"> to </span><code class="literal"><span class="koboSpan" id="kobo.499.1">true</span></code><span class="koboSpan" id="kobo.500.1">, and then reads the value of </span><code class="literal"><span class="koboSpan" id="kobo.501.1">b</span></code><span class="koboSpan" id="kobo.502.1">. </span><span class="koboSpan" id="kobo.502.2">If the value of </span><code class="literal"><span class="koboSpan" id="kobo.503.1">b</span></code><span class="koboSpan" id="kobo.504.1"> is </span><code class="literal"><span class="koboSpan" id="kobo.505.1">true</span></code><span class="koboSpan" id="kobo.506.1">, the </span><code class="literal"><span class="koboSpan" id="kobo.507.1">t1</span></code><span class="koboSpan" id="kobo.508.1"> thread assigns </span><code class="literal"><span class="koboSpan" id="kobo.509.1">0</span></code><span class="koboSpan" id="kobo.510.1"> to </span><code class="literal"><span class="koboSpan" id="kobo.511.1">y</span></code><span class="koboSpan" id="kobo.512.1">, and otherwise it assigns </span><code class="literal"><span class="koboSpan" id="kobo.513.1">1</span></code><span class="koboSpan" id="kobo.514.1">. </span><span class="koboSpan" id="kobo.514.2">The </span><code class="literal"><span class="koboSpan" id="kobo.515.1">t2</span></code><span class="koboSpan" id="kobo.516.1"> thread does the opposite: it first assigns </span><code class="literal"><span class="koboSpan" id="kobo.517.1">true</span></code><span class="koboSpan" id="kobo.518.1"> to the variable </span><code class="literal"><span class="koboSpan" id="kobo.519.1">b</span></code><span class="koboSpan" id="kobo.520.1">, and then assigns </span><code class="literal"><span class="koboSpan" id="kobo.521.1">0</span></code><span class="koboSpan" id="kobo.522.1"> to </span><code class="literal"><span class="koboSpan" id="kobo.523.1">x</span></code><span class="koboSpan" id="kobo.524.1"> if </span><code class="literal"><span class="koboSpan" id="kobo.525.1">a</span></code><span class="koboSpan" id="kobo.526.1"> is </span><code class="literal"><span class="koboSpan" id="kobo.527.1">true</span></code><span class="koboSpan" id="kobo.528.1">, and </span><code class="literal"><span class="koboSpan" id="kobo.529.1">1</span></code><span class="koboSpan" id="kobo.530.1"> otherwise. </span><span class="koboSpan" id="kobo.530.2">This is repeated in a loop </span><code class="literal"><span class="koboSpan" id="kobo.531.1">100000</span></code><span class="koboSpan" id="kobo.532.1"> times, as shown in the following snippet:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.533.1">object ThreadSharedStateAccessReordering extends App { 
  for (i &lt;- 0 until 100000) { 
    var a = false 
    var b = false 
    var x = -1 
    var y = -1 
    val t1 = thread { 
      a = true 
      y = if (b) 0 else 1 
    } 
    val t2 = thread { 
      b = true 
      x = if (a) 0 else 1 
    } 
    t1.join() 
    t2.join() 
    assert(!(x == 1 &amp;&amp; y == 1), s"x = $x, y = $y") 
  } 
} 
</span></pre><p><span class="koboSpan" id="kobo.534.1">This program is somewhat subtle, so we need to carefully consider several possible execution scenarios. </span><span class="koboSpan" id="kobo.534.2">By analyzing the possible interleaving of the instructions of the </span><code class="literal"><span class="koboSpan" id="kobo.535.1">t1</span></code><span class="koboSpan" id="kobo.536.1"> and </span><code class="literal"><span class="koboSpan" id="kobo.537.1">t2</span></code><span class="koboSpan" id="kobo.538.1"> threads, we can conclude that if both threads simultaneously assign to </span><code class="literal"><span class="koboSpan" id="kobo.539.1">a</span></code><span class="koboSpan" id="kobo.540.1"> and </span><code class="literal"><span class="koboSpan" id="kobo.541.1">b</span></code><span class="koboSpan" id="kobo.542.1">, then they will both assign </span><code class="literal"><span class="koboSpan" id="kobo.543.1">0</span></code><span class="koboSpan" id="kobo.544.1"> to </span><code class="literal"><span class="koboSpan" id="kobo.545.1">x</span></code><span class="koboSpan" id="kobo.546.1"> and </span><code class="literal"><span class="koboSpan" id="kobo.547.1">y</span></code><span class="koboSpan" id="kobo.548.1">.</span></p><p><span class="koboSpan" id="kobo.549.1">This outcome indicates that both the threads started at almost the same time, and is shown on the left in the following figure:</span></p><div class="mediaobject"><span class="koboSpan" id="kobo.550.1"><img src="graphics/image_02_005.jpg" alt="Reordering"/></span></div><p><span class="koboSpan" id="kobo.551.1">Alternatively, let's assume that the </span><code class="literal"><span class="koboSpan" id="kobo.552.1">t2</span></code><span class="koboSpan" id="kobo.553.1"> thread executes faster. </span><span class="koboSpan" id="kobo.553.2">In this case, the </span><code class="literal"><span class="koboSpan" id="kobo.554.1">t2</span></code><span class="koboSpan" id="kobo.555.1"> thread sets the variable </span><code class="literal"><span class="koboSpan" id="kobo.556.1">b</span></code><span class="koboSpan" id="kobo.557.1"> to </span><code class="literal"><span class="koboSpan" id="kobo.558.1">true</span></code><span class="koboSpan" id="kobo.559.1">, and proceeds to read the value of </span><code class="literal"><span class="koboSpan" id="kobo.560.1">a</span></code><span class="koboSpan" id="kobo.561.1">. </span><span class="koboSpan" id="kobo.561.2">This happens before the assignment to </span><code class="literal"><span class="koboSpan" id="kobo.562.1">a</span></code><span class="koboSpan" id="kobo.563.1"> by the </span><code class="literal"><span class="koboSpan" id="kobo.564.1">t1</span></code><span class="koboSpan" id="kobo.565.1"> thread, so the </span><code class="literal"><span class="koboSpan" id="kobo.566.1">t2</span></code><span class="koboSpan" id="kobo.567.1"> thread reads the value </span><code class="literal"><span class="koboSpan" id="kobo.568.1">false</span></code><span class="koboSpan" id="kobo.569.1">, and assigns </span><code class="literal"><span class="koboSpan" id="kobo.570.1">1</span></code><span class="koboSpan" id="kobo.571.1"> to </span><code class="literal"><span class="koboSpan" id="kobo.572.1">x</span></code><span class="koboSpan" id="kobo.573.1">. </span><span class="koboSpan" id="kobo.573.2">When the </span><code class="literal"><span class="koboSpan" id="kobo.574.1">t1</span></code><span class="koboSpan" id="kobo.575.1"> thread executes, it sees that the value of </span><code class="literal"><span class="koboSpan" id="kobo.576.1">b</span></code><span class="koboSpan" id="kobo.577.1"> is </span><code class="literal"><span class="koboSpan" id="kobo.578.1">true</span></code><span class="koboSpan" id="kobo.579.1">, and assigns </span><code class="literal"><span class="koboSpan" id="kobo.580.1">0</span></code><span class="koboSpan" id="kobo.581.1"> to </span><code class="literal"><span class="koboSpan" id="kobo.582.1">y</span></code><span class="koboSpan" id="kobo.583.1">. </span><span class="koboSpan" id="kobo.583.2">This sequence of events is shown on the right in the preceding figure. </span><span class="koboSpan" id="kobo.583.3">Note that the case where the </span><code class="literal"><span class="koboSpan" id="kobo.584.1">t1</span></code><span class="koboSpan" id="kobo.585.1"> thread starts first results in a similar assignment where </span><code class="literal"><span class="koboSpan" id="kobo.586.1">x = 0</span></code><span class="koboSpan" id="kobo.587.1"> and </span><code class="literal"><span class="koboSpan" id="kobo.588.1">y = 1</span></code><span class="koboSpan" id="kobo.589.1">, so it is not shown in the figure.</span></p><p><span class="koboSpan" id="kobo.590.1">The conclusion is that regardless of how we reorder the execution of the statements in the </span><code class="literal"><span class="koboSpan" id="kobo.591.1">t1</span></code><span class="koboSpan" id="kobo.592.1"> and </span><code class="literal"><span class="koboSpan" id="kobo.593.1">t2</span></code><span class="koboSpan" id="kobo.594.1"> threads, the output of the program should never be such that </span><code class="literal"><span class="koboSpan" id="kobo.595.1">x = 1</span></code><span class="koboSpan" id="kobo.596.1"> and </span><code class="literal"><span class="koboSpan" id="kobo.597.1">y = 1</span></code><span class="koboSpan" id="kobo.598.1"> simultaneously. </span><span class="koboSpan" id="kobo.598.2">Thus, the assertion at the end of the loop never throws an exception.</span></p><p><span class="koboSpan" id="kobo.599.1">However, after running the program several times, we get the following output, which indicates that both </span><code class="literal"><span class="koboSpan" id="kobo.600.1">x</span></code><span class="koboSpan" id="kobo.601.1"> and </span><code class="literal"><span class="koboSpan" id="kobo.602.1">y</span></code><span class="koboSpan" id="kobo.603.1"> can be assigned the value </span><code class="literal"><span class="koboSpan" id="kobo.604.1">1</span></code><span class="koboSpan" id="kobo.605.1"> simultaneously:</span></p><pre class="programlisting">
<span class="strong"><strong><span class="koboSpan" id="kobo.606.1">[error] Exception in thread "main": assertion failed: x = 1, y = 1</span></strong></span>
</pre><p><span class="koboSpan" id="kobo.607.1">This result is scary and seems to defy common sense. </span><span class="koboSpan" id="kobo.607.2">Why can't we reason about the execution of the program the way we did? </span><span class="koboSpan" id="kobo.607.3">The answer is that by the JMM specification, the JVM is allowed to reorder certain program statements executed by one thread as long as it does not change the serial semantics of the program for that particular thread. </span><span class="koboSpan" id="kobo.607.4">This is because some processors do not always execute instructions in the program order. </span><span class="koboSpan" id="kobo.607.5">Additionally, the threads do not need to write all their updates to the main memory immediately, but can temporarily keep them cached in registers inside the processor. </span><span class="koboSpan" id="kobo.607.6">This maximizes the efficiency of the program and allows better compiler optimizations.</span></p><p><span class="koboSpan" id="kobo.608.1">How then should we reason about multithreaded programs? </span><span class="koboSpan" id="kobo.608.2">The error we made when analyzing the example is that we assumed that the writes by one thread are immediately visible to all the other threads. </span><span class="koboSpan" id="kobo.608.3">We always need to apply proper synchronization to ensure that the writes by one thread are visible to another thread.</span></p><p><span class="koboSpan" id="kobo.609.1">The </span><code class="literal"><span class="koboSpan" id="kobo.610.1">synchronized</span></code><span class="koboSpan" id="kobo.611.1"> statement is one of the fundamental ways to achieve proper synchronization. </span><span class="koboSpan" id="kobo.611.2">Writes by any thread executing the </span><code class="literal"><span class="koboSpan" id="kobo.612.1">synchronized</span></code><span class="koboSpan" id="kobo.613.1"> statement on an </span><code class="literal"><span class="koboSpan" id="kobo.614.1">x</span></code><span class="koboSpan" id="kobo.615.1"> object are not only atomic but also visible to threads that execute </span><code class="literal"><span class="koboSpan" id="kobo.616.1">synchronized</span></code><span class="koboSpan" id="kobo.617.1"> on </span><code class="literal"><span class="koboSpan" id="kobo.618.1">x</span></code><span class="koboSpan" id="kobo.619.1">. </span><span class="koboSpan" id="kobo.619.2">Enclosing each assignment in the </span><code class="literal"><span class="koboSpan" id="kobo.620.1">t1</span></code><span class="koboSpan" id="kobo.621.1"> and </span><code class="literal"><span class="koboSpan" id="kobo.622.1">t2</span></code><span class="koboSpan" id="kobo.623.1"> threads in a </span><code class="literal"><span class="koboSpan" id="kobo.624.1">synchronized</span></code><span class="koboSpan" id="kobo.625.1"> statement makes the program behave as expected.</span></p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip9"/><span class="koboSpan" id="kobo.626.1">Tip</span></h3><p><span class="koboSpan" id="kobo.627.1">Use the </span><code class="literal"><span class="koboSpan" id="kobo.628.1">synchronized</span></code><span class="koboSpan" id="kobo.629.1"> statement on some object </span><code class="literal"><span class="koboSpan" id="kobo.630.1">x</span></code><span class="koboSpan" id="kobo.631.1"> when accessing (reading or modifying) a state shared between multiple threads. </span><span class="koboSpan" id="kobo.631.2">This ensures that at most, a single thread is at any time executing a </span><code class="literal"><span class="koboSpan" id="kobo.632.1">synchronized</span></code><span class="koboSpan" id="kobo.633.1"> statement on </span><code class="literal"><span class="koboSpan" id="kobo.634.1">x</span></code><span class="koboSpan" id="kobo.635.1">. </span><span class="koboSpan" id="kobo.635.2">It also ensures that all the writes to the memory by the </span><code class="literal"><span class="koboSpan" id="kobo.636.1">T</span></code><span class="koboSpan" id="kobo.637.1"> thread are visible to all the other threads that subsequently execute </span><code class="literal"><span class="koboSpan" id="kobo.638.1">synchronized</span></code><span class="koboSpan" id="kobo.639.1"> on the same object </span><code class="literal"><span class="koboSpan" id="kobo.640.1">x</span></code><span class="koboSpan" id="kobo.641.1">.</span></p></div></div><p><span class="koboSpan" id="kobo.642.1">In the rest of this chapter and in </span><a class="link" href="ch03.html" title="Chapter 3. Traditional Building Blocks of Concurrency"><span class="koboSpan" id="kobo.643.1">Chapter 3</span></a><span class="koboSpan" id="kobo.644.1">, </span><span class="emphasis"><em><span class="koboSpan" id="kobo.645.1">Traditional Building Blocks of Concurrency</span></em></span><span class="koboSpan" id="kobo.646.1">, we will see additional synchronization mechanisms, such as volatile and atomic variables. </span><span class="koboSpan" id="kobo.646.2">In the next section, we will take a look at other use cases of the </span><code class="literal"><span class="koboSpan" id="kobo.647.1">synchronized</span></code><span class="koboSpan" id="kobo.648.1"> statement and learn about object monitors.</span></p></div></div></div></div></div>
<div id="book-columns"><div id="book-inner"><div class="section" title="Monitors and synchronization"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec14"/><span class="koboSpan" id="kobo.1.1">Monitors and synchronization</span></h1></div></div></div><p><span class="koboSpan" id="kobo.2.1">In this section, we will study inter-thread communication using the </span><code class="literal"><span class="koboSpan" id="kobo.3.1">synchronized</span></code><span class="koboSpan" id="kobo.4.1"> statement in more detail. </span><span class="koboSpan" id="kobo.4.2">As we saw in the previous sections, the </span><code class="literal"><span class="koboSpan" id="kobo.5.1">synchronized</span></code><span class="koboSpan" id="kobo.6.1"> statement serves both to ensure the visibility of writes performed by different threads, and to limit concurrent access to a shared region of memory. </span><span class="koboSpan" id="kobo.6.2">Generally speaking, a synchronization mechanism that enforces access limits on a shared resource is called a </span><span class="strong"><strong><span class="koboSpan" id="kobo.7.1">lock</span></strong></span><span class="koboSpan" id="kobo.8.1">. </span><span class="koboSpan" id="kobo.8.2">Locks are also used to ensure that no two threads execute the same code simultaneously; that is, they implement </span><span class="strong"><strong><span class="koboSpan" id="kobo.9.1">mutual exclusion</span></strong></span><span class="koboSpan" id="kobo.10.1">.</span></p><p><span class="koboSpan" id="kobo.11.1">As mentioned previously, each object on the JVM has a special built-in </span><span class="strong"><strong><span class="koboSpan" id="kobo.12.1">monitor lock</span></strong></span><span class="koboSpan" id="kobo.13.1">, also called the </span><span class="strong"><strong><span class="koboSpan" id="kobo.14.1">intrinsic lock</span></strong></span><span class="koboSpan" id="kobo.15.1">. </span><span class="koboSpan" id="kobo.15.2">When a thread calls the </span><code class="literal"><span class="koboSpan" id="kobo.16.1">synchronized</span></code><span class="koboSpan" id="kobo.17.1"> statement on an </span><code class="literal"><span class="koboSpan" id="kobo.18.1">x</span></code><span class="koboSpan" id="kobo.19.1"> object, it gains ownership of the monitor lock of the </span><code class="literal"><span class="koboSpan" id="kobo.20.1">x</span></code><span class="koboSpan" id="kobo.21.1"> object, given that no other thread owns the monitor. </span><span class="koboSpan" id="kobo.21.2">Otherwise, the thread is blocked until the monitor is released. </span><span class="koboSpan" id="kobo.21.3">Upon gaining ownership of the monitor, the thread can witness the memory writes of all the threads that previously released that monitor.</span></p><p><span class="koboSpan" id="kobo.22.1">A natural consequence is that </span><code class="literal"><span class="koboSpan" id="kobo.23.1">synchronized</span></code><span class="koboSpan" id="kobo.24.1"> statements can be nested. </span><span class="koboSpan" id="kobo.24.2">A thread can own monitors belonging to several different objects simultaneously. </span><span class="koboSpan" id="kobo.24.3">This is useful when composing larger systems from simpler components. </span><span class="koboSpan" id="kobo.24.4">We do not know which sets of monitors independent software components use in advance. </span><span class="koboSpan" id="kobo.24.5">Let's assume that we are designing an online banking system in which we want to log money transfers. </span><span class="koboSpan" id="kobo.24.6">We can maintain the transfers list of all the money transfers in a mutable </span><code class="literal"><span class="koboSpan" id="kobo.25.1">ArrayBuffer</span></code><span class="koboSpan" id="kobo.26.1"> growable array implementation. </span><span class="koboSpan" id="kobo.26.2">The banking application does not manipulate transfers directly, but instead appends new messages with a </span><code class="literal"><span class="koboSpan" id="kobo.27.1">logTransfer</span></code><span class="koboSpan" id="kobo.28.1"> method that calls </span><code class="literal"><span class="koboSpan" id="kobo.29.1">synchronized</span></code><span class="koboSpan" id="kobo.30.1"> on </span><code class="literal"><span class="koboSpan" id="kobo.31.1">transfers</span></code><span class="koboSpan" id="kobo.32.1">. </span><span class="koboSpan" id="kobo.32.2">The </span><code class="literal"><span class="koboSpan" id="kobo.33.1">ArrayBuffer</span></code><span class="koboSpan" id="kobo.34.1"> implementation is a collection designed for single-threaded use, so we need to protect it from concurrent writes. </span><span class="koboSpan" id="kobo.34.2">We will start by defining the </span><code class="literal"><span class="koboSpan" id="kobo.35.1">logTransfer</span></code><span class="koboSpan" id="kobo.36.1"> method:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.37.1">object SynchronizedNesting extends App { 
  import scala.collection._ 
  private val transfers = mutable.ArrayBuffer[String]() 
  def logTransfer(name: String, n: Int) = transfers.synchronized { 
    transfers += s"transfer to account '$name' = $n" 
  } 
</span></pre><p><span class="koboSpan" id="kobo.38.1">Apart from the logging modules of the banking system, the accounts are represented with the </span><code class="literal"><span class="koboSpan" id="kobo.39.1">Account</span></code><span class="koboSpan" id="kobo.40.1"> class. </span><span class="koboSpan" id="kobo.40.2">The </span><code class="literal"><span class="koboSpan" id="kobo.41.1">Account</span></code><span class="koboSpan" id="kobo.42.1"> objects hold information about their owner and the amount of money with them. </span><span class="koboSpan" id="kobo.42.2">To add some money to an account, the system uses an </span><code class="literal"><span class="koboSpan" id="kobo.43.1">add</span></code><span class="koboSpan" id="kobo.44.1"> method that obtains the monitor of the </span><code class="literal"><span class="koboSpan" id="kobo.45.1">Account</span></code><span class="koboSpan" id="kobo.46.1"> object and modifies its </span><code class="literal"><span class="koboSpan" id="kobo.47.1">money</span></code><span class="koboSpan" id="kobo.48.1"> field. </span><span class="koboSpan" id="kobo.48.2">The bank's business process requires treating large transfers specially: if a money transfer is bigger than 10 currency units, we need to log it. </span><span class="koboSpan" id="kobo.48.3">In the following code, we will define the </span><code class="literal"><span class="koboSpan" id="kobo.49.1">Account</span></code><span class="koboSpan" id="kobo.50.1"> class and the </span><code class="literal"><span class="koboSpan" id="kobo.51.1">add</span></code><span class="koboSpan" id="kobo.52.1"> method, which adds an amount </span><code class="literal"><span class="koboSpan" id="kobo.53.1">n</span></code><span class="koboSpan" id="kobo.54.1"> to the </span><code class="literal"><span class="koboSpan" id="kobo.55.1">Account</span></code><span class="koboSpan" id="kobo.56.1"> object:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.57.1">  class Account(val name: String, var money: Int) 
  def add(account: Account, n: Int) = account.synchronized { 
    account.money += n 
    if (n &gt; 10) logTransfer(account.name, n) 
  } 
</span></pre><p><span class="koboSpan" id="kobo.58.1">The </span><code class="literal"><span class="koboSpan" id="kobo.59.1">add</span></code><span class="koboSpan" id="kobo.60.1"> method calls </span><code class="literal"><span class="koboSpan" id="kobo.61.1">logTransfer</span></code><span class="koboSpan" id="kobo.62.1"> from inside the </span><code class="literal"><span class="koboSpan" id="kobo.63.1">synchronized</span></code><span class="koboSpan" id="kobo.64.1"> statement, and </span><code class="literal"><span class="koboSpan" id="kobo.65.1">logTransfer</span></code><span class="koboSpan" id="kobo.66.1"> first obtains the </span><code class="literal"><span class="koboSpan" id="kobo.67.1">transfers</span></code><span class="koboSpan" id="kobo.68.1"> monitor. </span><span class="koboSpan" id="kobo.68.2">Importantly, this happens without releasing the </span><code class="literal"><span class="koboSpan" id="kobo.69.1">account</span></code><span class="koboSpan" id="kobo.70.1"> monitor. </span><span class="koboSpan" id="kobo.70.2">If the </span><code class="literal"><span class="koboSpan" id="kobo.71.1">transfers</span></code><span class="koboSpan" id="kobo.72.1"> monitor is currently acquired by some other thread, the current thread goes into the blocked state without releasing any of the monitors that it previously acquired.</span></p><p><span class="koboSpan" id="kobo.73.1">In the following example, the main application creates two separate accounts and three threads that execute transfers. </span><span class="koboSpan" id="kobo.73.2">Once all the threads complete their transfers, the main thread outputs all the transfers that were logged:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.74.1">  // Continuation of the bank account example. 
  </span><span class="koboSpan" id="kobo.74.2">val jane = new Account("Jane", 100) 
  val john = new Account("John", 200) 
  val t1 = thread { add(jane, 5) } 
  val t2 = thread { add(john, 50) } 
  val t3 = thread { add(jane, 70) } 
  t1.join(); t2.join(); t3.join() 
  log(s"--- transfers ---\n$transfers") 
} 
</span></pre><p><span class="koboSpan" id="kobo.75.1">The use of the </span><code class="literal"><span class="koboSpan" id="kobo.76.1">synchronized</span></code><span class="koboSpan" id="kobo.77.1"> statement in this example prevents threads </span><code class="literal"><span class="koboSpan" id="kobo.78.1">t1</span></code><span class="koboSpan" id="kobo.79.1"> and </span><code class="literal"><span class="koboSpan" id="kobo.80.1">t3</span></code><span class="koboSpan" id="kobo.81.1"> from corrupting Jane's account by concurrently modifying it. </span><span class="koboSpan" id="kobo.81.2">The </span><code class="literal"><span class="koboSpan" id="kobo.82.1">t2</span></code><span class="koboSpan" id="kobo.83.1"> and </span><code class="literal"><span class="koboSpan" id="kobo.84.1">t3</span></code><span class="koboSpan" id="kobo.85.1"> threads also access the </span><code class="literal"><span class="koboSpan" id="kobo.86.1">transfers</span></code><span class="koboSpan" id="kobo.87.1"> log. </span><span class="koboSpan" id="kobo.87.2">This simple example shows why nesting is useful: we do not know which other components in our banking system potentially use the </span><code class="literal"><span class="koboSpan" id="kobo.88.1">transfers</span></code><span class="koboSpan" id="kobo.89.1"> log. </span><span class="koboSpan" id="kobo.89.2">To preserve encapsulation and prevent code duplication, independent software components should not explicitly synchronize to log a money transfer; synchronization is instead hidden in the </span><code class="literal"><span class="koboSpan" id="kobo.90.1">logTransfer</span></code><span class="koboSpan" id="kobo.91.1"> method.</span></p><div class="section" title="Deadlocks"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec18"/><span class="koboSpan" id="kobo.92.1">Deadlocks</span></h2></div></div></div><p><span class="koboSpan" id="kobo.93.1">A factor that worked to our advantage in the banking system example is that the </span><code class="literal"><span class="koboSpan" id="kobo.94.1">logTransfer</span></code><span class="koboSpan" id="kobo.95.1"> method never attempts to acquire any monitors other than the </span><code class="literal"><span class="koboSpan" id="kobo.96.1">transfers</span></code><span class="koboSpan" id="kobo.97.1"> monitor. </span><span class="koboSpan" id="kobo.97.2">Once the monitor is obtained, a thread will eventually modify the </span><code class="literal"><span class="koboSpan" id="kobo.98.1">transfers</span></code><span class="koboSpan" id="kobo.99.1"> buffer and release the monitor; in a stack of nested monitor acquisitions, </span><code class="literal"><span class="koboSpan" id="kobo.100.1">transfers</span></code><span class="koboSpan" id="kobo.101.1"> always comes last. </span><span class="koboSpan" id="kobo.101.2">Given that </span><code class="literal"><span class="koboSpan" id="kobo.102.1">logTransfer</span></code><span class="koboSpan" id="kobo.103.1"> is the only method synchronizing on </span><code class="literal"><span class="koboSpan" id="kobo.104.1">transfers</span></code><span class="koboSpan" id="kobo.105.1">, it cannot indefinitely delay other threads that synchronize on </span><code class="literal"><span class="koboSpan" id="kobo.106.1">transfers</span></code><span class="koboSpan" id="kobo.107.1">.</span></p><p><span class="koboSpan" id="kobo.108.1">A </span><span class="strong"><strong><span class="koboSpan" id="kobo.109.1">deadlock</span></strong></span><span class="koboSpan" id="kobo.110.1"> is a general situation in which two or more executions wait for each other to complete an action before proceeding with their own action. </span><span class="koboSpan" id="kobo.110.2">The reason for waiting is that each of the executions obtains an exclusive access to a resource that the other execution needs to proceed. </span><span class="koboSpan" id="kobo.110.3">As an example from our daily life, assume that you are sitting in a cafeteria with your colleague and just about to start your lunch. </span><span class="koboSpan" id="kobo.110.4">However, there is only a single fork and a single knife at the table, and you need both the utensils to eat. </span><span class="koboSpan" id="kobo.110.5">You grab the fork, but your colleague grabs a knife. </span><span class="koboSpan" id="kobo.110.6">Both of you wait for the other to finish the meal, but do not let go of your own utensil. </span><span class="koboSpan" id="kobo.110.7">You are now in a state of deadlock, and you will never finish your lunch. </span><span class="koboSpan" id="kobo.110.8">Well, at least not until your boss arrives to see what's going on.</span></p><p><span class="koboSpan" id="kobo.111.1">In concurrent programming, when two threads obtain two separate monitors at the same time and then attempt to acquire the other thread's monitor, a deadlock occurs. </span><span class="koboSpan" id="kobo.111.2">Both the threads go into a blocked state until the other monitor is released, but do not release the monitors they own.</span></p><p><span class="koboSpan" id="kobo.112.1">The </span><code class="literal"><span class="koboSpan" id="kobo.113.1">logTransfer</span></code><span class="koboSpan" id="kobo.114.1"> method can never cause a deadlock, because it only attempts to acquire a single monitor that is released eventually. </span><span class="koboSpan" id="kobo.114.2">Let's now extend our banking example to allow money transfers between specific accounts, as follows:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.115.1">object SynchronizedDeadlock extends App { 
  import SynchronizedNesting.Account 
  def send(a: Account, b: Account, n: Int) = a.synchronized { 
    b.synchronized { 
      a.money -= n 
      b.money += n 
    } 
  } 
</span></pre><p><span class="koboSpan" id="kobo.116.1">We import the </span><code class="literal"><span class="koboSpan" id="kobo.117.1">Account</span></code><span class="koboSpan" id="kobo.118.1"> class from the previous example. </span><span class="koboSpan" id="kobo.118.2">The </span><code class="literal"><span class="koboSpan" id="kobo.119.1">send</span></code><span class="koboSpan" id="kobo.120.1"> method atomically transfers a given amount of money </span><code class="literal"><span class="koboSpan" id="kobo.121.1">n</span></code><span class="koboSpan" id="kobo.122.1"> from an account </span><code class="literal"><span class="koboSpan" id="kobo.123.1">a</span></code><span class="koboSpan" id="kobo.124.1"> to another account </span><code class="literal"><span class="koboSpan" id="kobo.125.1">b</span></code><span class="koboSpan" id="kobo.126.1">. </span><span class="koboSpan" id="kobo.126.2">To do so, it invokes the </span><code class="literal"><span class="koboSpan" id="kobo.127.1">synchronized</span></code><span class="koboSpan" id="kobo.128.1"> statement on both the accounts to ensure that no other thread is modifying either account concurrently, as shown in the following snippet:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.129.1">  val a = new Account("Jack", 1000) 
  val b = new Account("Jill", 2000) 
  val t1 = thread { for (i&lt;- 0 until 100) send(a, b, 1) } 
  val t2 = thread { for (i&lt;- 0 until 100) send(b, a, 1) } 
  t1.join(); t2.join() 
  log(s"a = ${a.money}, b = ${b.money}") 
} 
</span></pre><p><span class="koboSpan" id="kobo.130.1">Now, assume that two of our bank's new clients, Jack and Jill, just opened their accounts and are amazed with the new e-banking platform. </span><span class="koboSpan" id="kobo.130.2">They log in and start sending each other small amounts of money to test it, frantically hitting the send button a 100 times. </span><span class="koboSpan" id="kobo.130.3">Soon, something very bad happens. </span><span class="koboSpan" id="kobo.130.4">The </span><code class="literal"><span class="koboSpan" id="kobo.131.1">t1</span></code><span class="koboSpan" id="kobo.132.1"> and </span><code class="literal"><span class="koboSpan" id="kobo.133.1">t2</span></code><span class="koboSpan" id="kobo.134.1"> threads, which execute Jack's and Jill's requests, invoke </span><code class="literal"><span class="koboSpan" id="kobo.135.1">send</span></code><span class="koboSpan" id="kobo.136.1"> simultaneously with the order of accounts </span><code class="literal"><span class="koboSpan" id="kobo.137.1">a</span></code><span class="koboSpan" id="kobo.138.1"> and </span><code class="literal"><span class="koboSpan" id="kobo.139.1">b</span></code><span class="koboSpan" id="kobo.140.1"> reversed. </span><span class="koboSpan" id="kobo.140.2">Thread </span><code class="literal"><span class="koboSpan" id="kobo.141.1">t1</span></code><span class="koboSpan" id="kobo.142.1"> locks </span><code class="literal"><span class="koboSpan" id="kobo.143.1">a</span></code><span class="koboSpan" id="kobo.144.1"> and </span><code class="literal"><span class="koboSpan" id="kobo.145.1">t2</span></code><span class="koboSpan" id="kobo.146.1"> locks </span><code class="literal"><span class="koboSpan" id="kobo.147.1">b</span></code><span class="koboSpan" id="kobo.148.1">, but are then both unable to lock the other account. </span><span class="koboSpan" id="kobo.148.2">To Jack's and Jill's surprise, the new transfer system is not as shiny as it seems. </span><span class="koboSpan" id="kobo.148.3">If you are running this example, you'll want to close the terminal session at this point and restart SBT.</span></p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note10"/><span class="koboSpan" id="kobo.149.1">Note</span></h3><p><span class="koboSpan" id="kobo.150.1">A deadlock occurs when a set of two or more threads acquire resources and then cyclically try to acquire other thread's resources without releasing their own.</span></p></div></div><p><span class="koboSpan" id="kobo.151.1">How do we prevent deadlocks from occurring? </span><span class="koboSpan" id="kobo.151.2">Recall that, in the initial banking system example, the order in which the monitors were acquired was well defined. </span><span class="koboSpan" id="kobo.151.3">A single account monitor was acquired first and the </span><code class="literal"><span class="koboSpan" id="kobo.152.1">transfers</span></code><span class="koboSpan" id="kobo.153.1"> monitor was possibly acquired afterward. </span><span class="koboSpan" id="kobo.153.2">You should convince yourself that whenever resources are acquired in the same order, there is no danger of a deadlock. </span><span class="koboSpan" id="kobo.153.3">When a thread </span><code class="literal"><span class="koboSpan" id="kobo.154.1">T</span></code><span class="koboSpan" id="kobo.155.1"> waits for a resource </span><code class="literal"><span class="koboSpan" id="kobo.156.1">X</span></code><span class="koboSpan" id="kobo.157.1"> acquired by some other thread S, the thread S will never try to acquire any resource </span><code class="literal"><span class="koboSpan" id="kobo.158.1">Y</span></code><span class="koboSpan" id="kobo.159.1"> already held by </span><code class="literal"><span class="koboSpan" id="kobo.160.1">T</span></code><span class="koboSpan" id="kobo.161.1">, because </span><code class="literal"><span class="koboSpan" id="kobo.162.1">Y</span></code><span class="koboSpan" id="kobo.163.1"> &lt; </span><code class="literal"><span class="koboSpan" id="kobo.164.1">X</span></code><span class="koboSpan" id="kobo.165.1"> and </span><code class="literal"><span class="koboSpan" id="kobo.166.1">S</span></code><span class="koboSpan" id="kobo.167.1"> might only attempt to acquire resources </span><code class="literal"><span class="koboSpan" id="kobo.168.1">Y</span></code><span class="koboSpan" id="kobo.169.1"> &gt; </span><code class="literal"><span class="koboSpan" id="kobo.170.1">X</span></code><span class="koboSpan" id="kobo.171.1">. </span><span class="koboSpan" id="kobo.171.2">The ordering breaks the cycle, which is one of the necessary preconditions for a deadlock.</span></p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip11"/><span class="koboSpan" id="kobo.172.1">Tip</span></h3><p><span class="koboSpan" id="kobo.173.1">Establish a total order between resources when acquiring them; this ensures that no set of threads cyclically wait on the resources they previously acquired.</span></p></div></div><p><span class="koboSpan" id="kobo.174.1">In our example, we need to establish an order between different accounts. </span><span class="koboSpan" id="kobo.174.2">One way of doing so is to use the </span><code class="literal"><span class="koboSpan" id="kobo.175.1">getUniqueId</span></code><span class="koboSpan" id="kobo.176.1"> method introduced in an earlier section:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.177.1">import SynchronizedProtectedUid.getUniqueId 
class Account(val name: String, var money: Int) { 
  val uid = getUniqueId() 
} 
</span></pre><p><span class="koboSpan" id="kobo.178.1">The new </span><code class="literal"><span class="koboSpan" id="kobo.179.1">Account</span></code><span class="koboSpan" id="kobo.180.1"> class ensures that no two accounts share the same </span><code class="literal"><span class="koboSpan" id="kobo.181.1">uid</span></code><span class="koboSpan" id="kobo.182.1"> value, regardless of the thread they were created on. </span><span class="koboSpan" id="kobo.182.2">The deadlock-free </span><code class="literal"><span class="koboSpan" id="kobo.183.1">send</span></code><span class="koboSpan" id="kobo.184.1"> method then needs to acquire the accounts in the order of their </span><code class="literal"><span class="koboSpan" id="kobo.185.1">uid</span></code><span class="koboSpan" id="kobo.186.1"> values, as follows:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.187.1">def send(a1: Account, a2: Account, n: Int) { 
  def adjust() { 
    a1.money -= n 
    a2.money += n 
  } 
  if (a1.uid &lt; a2.uid) 
    a1.synchronized { a2.synchronized { adjust() } } 
  else a2.synchronized { a1.synchronized { adjust() } } 
} 
</span></pre><p><span class="koboSpan" id="kobo.188.1">After a quick response from the bank's software engineers, Jack and Jill happily send each other money again. </span><span class="koboSpan" id="kobo.188.2">A cyclic chain of blocked threads can no longer happen.</span></p><p><span class="koboSpan" id="kobo.189.1">Deadlocks are inherent to any concurrent system in which the threads wait indefinitely for a resource without releasing the resources they previously acquired. </span><span class="koboSpan" id="kobo.189.2">However, while they should be avoided, deadlocks are often not as deadly as they sound. </span><span class="koboSpan" id="kobo.189.3">A nice thing about deadlocks is that by their definition, a deadlocked system does not progress. </span><span class="koboSpan" id="kobo.189.4">The developer that resolved Jack and Jill's issue was able to act quickly by doing a heap dump of the running JVM instance and analyzing the thread stacks; deadlocks can at least be easily identified, even when they occur in a production system. </span><span class="koboSpan" id="kobo.189.5">This is unlike the errors due to race conditions, which only become apparent long after the system transitions into an invalid state.</span></p></div><div class="section" title="Guarded blocks"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec19"/><span class="koboSpan" id="kobo.190.1">Guarded blocks</span></h2></div></div></div><p><span class="koboSpan" id="kobo.191.1">Creating a new thread is much more expensive than creating a new lightweight object such as </span><code class="literal"><span class="koboSpan" id="kobo.192.1">Account</span></code><span class="koboSpan" id="kobo.193.1">. </span><span class="koboSpan" id="kobo.193.2">A high-performance banking system should be quick and responsive, and creating a new thread on each request can be too slow when there are thousands of requests per second. </span><span class="koboSpan" id="kobo.193.3">The same thread should be reused for many requests; a set of such reusable threads is usually called a </span><span class="strong"><strong><span class="koboSpan" id="kobo.194.1">thread pool</span></strong></span><span class="koboSpan" id="kobo.195.1">.</span></p><p><span class="koboSpan" id="kobo.196.1">In the following example, we will define a special thread called </span><code class="literal"><span class="koboSpan" id="kobo.197.1">worker</span></code><span class="koboSpan" id="kobo.198.1"> that will execute a block of code when some other thread requests it. </span><span class="koboSpan" id="kobo.198.2">We will use the mutable </span><code class="literal"><span class="koboSpan" id="kobo.199.1">Queue</span></code><span class="koboSpan" id="kobo.200.1"> class from the Scala standard library collections package to store the scheduled blocks of code:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.201.1">import scala.collection._ 
object SynchronizedBadPool extends App { 
  private val tasks = mutable.Queue[() =&gt; Unit]() 
</span></pre><p><span class="koboSpan" id="kobo.202.1">We represent the blocks of code with the </span><code class="literal"><span class="koboSpan" id="kobo.203.1">() =&gt; Unit</span></code><span class="koboSpan" id="kobo.204.1"> function type. </span><span class="koboSpan" id="kobo.204.2">The </span><code class="literal"><span class="koboSpan" id="kobo.205.1">worker</span></code><span class="koboSpan" id="kobo.206.1"> thread will repetitively call the </span><code class="literal"><span class="koboSpan" id="kobo.207.1">poll</span></code><span class="koboSpan" id="kobo.208.1"> method that synchronizes on </span><code class="literal"><span class="koboSpan" id="kobo.209.1">tasks</span></code><span class="koboSpan" id="kobo.210.1"> to check whether the queue is non-empty. </span><span class="koboSpan" id="kobo.210.2">The </span><code class="literal"><span class="koboSpan" id="kobo.211.1">poll</span></code><span class="koboSpan" id="kobo.212.1"> method shows that the </span><code class="literal"><span class="koboSpan" id="kobo.213.1">synchronized</span></code><span class="koboSpan" id="kobo.214.1"> statement can return a value. </span><span class="koboSpan" id="kobo.214.2">In this case, it returns an optional </span><code class="literal"><span class="koboSpan" id="kobo.215.1">Some</span></code><span class="koboSpan" id="kobo.216.1"> value if there are tasks to do, or </span><code class="literal"><span class="koboSpan" id="kobo.217.1">None</span></code><span class="koboSpan" id="kobo.218.1"> otherwise. </span><span class="koboSpan" id="kobo.218.2">The </span><code class="literal"><span class="koboSpan" id="kobo.219.1">Some</span></code><span class="koboSpan" id="kobo.220.1"> object contains the block of code to execute:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.221.1">  val worker = new Thread { 
    def poll(): Option[() =&gt; Unit] = tasks.synchronized { 
      if (tasks.nonEmpty) Some(tasks.dequeue()) else None 
    } 
    override def run() = while (true) poll() match { 
      case Some(task) =&gt; task() 
      case None =&gt; 
    } 
  } 
  worker.setName("Worker") 
  worker.setDaemon(true) 
  worker.start() 
</span></pre><p><span class="koboSpan" id="kobo.222.1">We set the </span><code class="literal"><span class="koboSpan" id="kobo.223.1">worker</span></code><span class="koboSpan" id="kobo.224.1"> thread to be a </span><span class="strong"><strong><span class="koboSpan" id="kobo.225.1">daemon</span></strong></span><span class="koboSpan" id="kobo.226.1"> thread before starting it. </span><span class="koboSpan" id="kobo.226.2">Generally, a JVM process does not stop when the main thread terminates. </span><span class="koboSpan" id="kobo.226.3">The JVM process terminates when all non-daemon threads terminate. </span><span class="koboSpan" id="kobo.226.4">We want </span><code class="literal"><span class="koboSpan" id="kobo.227.1">worker</span></code><span class="koboSpan" id="kobo.228.1"> to be a daemon thread because we send work to it using the </span><code class="literal"><span class="koboSpan" id="kobo.229.1">asynchronous</span></code><span class="koboSpan" id="kobo.230.1"> method, which schedules a given block of code to eventually execute the </span><code class="literal"><span class="koboSpan" id="kobo.231.1">worker</span></code><span class="koboSpan" id="kobo.232.1"> thread:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.233.1">  def asynchronous(body: =&gt;Unit) = tasks.synchronized { 
    tasks.enqueue(() =&gt; body) 
  } 
  asynchronous { log("Hello") } 
  asynchronous { log(" world!")} 
  Thread.sleep(5000) 
} 
</span></pre><p><span class="koboSpan" id="kobo.234.1">Run the preceding example and witness the </span><code class="literal"><span class="koboSpan" id="kobo.235.1">worker</span></code><span class="koboSpan" id="kobo.236.1"> thread print </span><code class="literal"><span class="koboSpan" id="kobo.237.1">Hello</span></code><span class="koboSpan" id="kobo.238.1"> and then</span><code class="literal"><span class="koboSpan" id="kobo.239.1"> world!</span></code><span class="koboSpan" id="kobo.240.1">. </span><span class="koboSpan" id="kobo.240.2">Now listen to your laptop. </span><span class="koboSpan" id="kobo.240.3">The fan should start humming by now. </span><span class="koboSpan" id="kobo.240.4">Turn on your </span><span class="strong"><strong><span class="koboSpan" id="kobo.241.1">Task Manager</span></strong></span><span class="koboSpan" id="kobo.242.1"> or simply type </span><code class="literal"><span class="koboSpan" id="kobo.243.1">top</span></code><span class="koboSpan" id="kobo.244.1"> into your terminal if you are running this on a Unix system. </span><span class="koboSpan" id="kobo.244.2">One of your CPUs is completely used up by a process called </span><code class="literal"><span class="koboSpan" id="kobo.245.1">java</span></code><span class="koboSpan" id="kobo.246.1">. </span><span class="koboSpan" id="kobo.246.2">You can guess the reason. </span><span class="koboSpan" id="kobo.246.3">After </span><code class="literal"><span class="koboSpan" id="kobo.247.1">worker</span></code><span class="koboSpan" id="kobo.248.1"> completes its work, it is constantly checking if there are any tasks on the queue. </span><span class="koboSpan" id="kobo.248.2">We say that the </span><code class="literal"><span class="koboSpan" id="kobo.249.1">worker</span></code><span class="koboSpan" id="kobo.250.1"> thread is </span><span class="strong"><strong><span class="koboSpan" id="kobo.251.1">busy-waiting</span></strong></span><span class="koboSpan" id="kobo.252.1">. </span><span class="koboSpan" id="kobo.252.2">Busy-waiting is undesired, because it needlessly uses processor power. </span><span class="koboSpan" id="kobo.252.3">Still, shouldn't a daemon thread be stopped once the main thread terminates? </span><span class="koboSpan" id="kobo.252.4">In general, yes, but we are running this example from SBT in the same JVM process that SBT itself is running. </span><span class="koboSpan" id="kobo.252.5">SBT has non-daemon threads of its own, so our </span><code class="literal"><span class="koboSpan" id="kobo.253.1">worker</span></code><span class="koboSpan" id="kobo.254.1"> thread is not stopped. </span><span class="koboSpan" id="kobo.254.2">To tell SBT that it should execute the </span><code class="literal"><span class="koboSpan" id="kobo.255.1">run</span></code><span class="koboSpan" id="kobo.256.1"> command in a new process, enter the following directive:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.257.1">set fork := true 
</span></pre><p><span class="koboSpan" id="kobo.258.1">Running the preceding example again should stop the </span><code class="literal"><span class="koboSpan" id="kobo.259.1">worker</span></code><span class="koboSpan" id="kobo.260.1"> thread as soon as the main thread completes its execution. </span><span class="koboSpan" id="kobo.260.2">Still, our busy-waiting </span><code class="literal"><span class="koboSpan" id="kobo.261.1">worker</span></code><span class="koboSpan" id="kobo.262.1"> thread can be a part of a larger application that does not terminate so quickly. </span><span class="koboSpan" id="kobo.262.2">Creating new threads all the time might be expensive, but a busy-waiting thread is even more expensive. </span><span class="koboSpan" id="kobo.262.3">Several such threads can quickly compromise system performance. </span><span class="koboSpan" id="kobo.262.4">There are only a handful of applications in which busy-waiting makes sense. </span><span class="koboSpan" id="kobo.262.5">If you still have doubts that this is dangerous, start this example on your laptop while running on battery power and go grab a snack. </span><span class="koboSpan" id="kobo.262.6">Make sure that you save any open files before you do this; you might lose data once the CPU drains all the battery power.</span></p><p><span class="koboSpan" id="kobo.263.1">What we would really like the </span><code class="literal"><span class="koboSpan" id="kobo.264.1">worker</span></code><span class="koboSpan" id="kobo.265.1"> thread to do is to go to the waiting state, similar to what a thread does when we call </span><code class="literal"><span class="koboSpan" id="kobo.266.1">join</span></code><span class="koboSpan" id="kobo.267.1">. </span><span class="koboSpan" id="kobo.267.2">It should only wake up after we ensure that there are additional function objects to execute on the </span><code class="literal"><span class="koboSpan" id="kobo.268.1">tasks</span></code><span class="koboSpan" id="kobo.269.1"> queue.</span></p><p><span class="koboSpan" id="kobo.270.1">Scala objects (and JVM objects in general) support a pair of special methods called </span><code class="literal"><span class="koboSpan" id="kobo.271.1">wait</span></code><span class="koboSpan" id="kobo.272.1"> and </span><code class="literal"><span class="koboSpan" id="kobo.273.1">notify</span></code><span class="koboSpan" id="kobo.274.1">, which allow waiting and awakening the waiting threads, respectively. </span><span class="koboSpan" id="kobo.274.2">It is only legal to call these methods on an </span><code class="literal"><span class="koboSpan" id="kobo.275.1">x</span></code><span class="koboSpan" id="kobo.276.1"> object if the current thread owns the monitor of the object </span><code class="literal"><span class="koboSpan" id="kobo.277.1">x</span></code><span class="koboSpan" id="kobo.278.1">. </span><span class="koboSpan" id="kobo.278.2">In other words, </span><code class="literal"><span class="koboSpan" id="kobo.279.1">wait</span></code><span class="koboSpan" id="kobo.280.1"> and </span><code class="literal"><span class="koboSpan" id="kobo.281.1">notify</span></code><span class="koboSpan" id="kobo.282.1"> can only be called from a thread that owns the monitor of that object. </span><span class="koboSpan" id="kobo.282.2">When a thread </span><code class="literal"><span class="koboSpan" id="kobo.283.1">T</span></code><span class="koboSpan" id="kobo.284.1"> calls </span><code class="literal"><span class="koboSpan" id="kobo.285.1">wait</span></code><span class="koboSpan" id="kobo.286.1"> on an object, it releases the monitor and goes into the waiting state until some other thread </span><code class="literal"><span class="koboSpan" id="kobo.287.1">S</span></code><span class="koboSpan" id="kobo.288.1"> calls </span><code class="literal"><span class="koboSpan" id="kobo.289.1">notify</span></code><span class="koboSpan" id="kobo.290.1"> on the same object. </span><span class="koboSpan" id="kobo.290.2">The thread </span><code class="literal"><span class="koboSpan" id="kobo.291.1">S</span></code><span class="koboSpan" id="kobo.292.1"> usually prepares some data for </span><code class="literal"><span class="koboSpan" id="kobo.293.1">T</span></code><span class="koboSpan" id="kobo.294.1">, as in the following example in which the main thread sets the </span><code class="literal"><span class="koboSpan" id="kobo.295.1">Some</span></code><span class="koboSpan" id="kobo.296.1"> message for the </span><code class="literal"><span class="koboSpan" id="kobo.297.1">greeter</span></code><span class="koboSpan" id="kobo.298.1"> thread to print:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.299.1">object SynchronizedGuardedBlocks extends App { 
  val lock = new AnyRef 
  var message: Option[String] = None 
  val greeter = thread { 
    lock.synchronized { 
      while (message == None) lock.wait() 
      log(message.get) 
    } 
  } 
  lock.synchronized { 
    message = Some("Hello!") 
    lock.notify() 
  } 
  greeter.join() 
} 
</span></pre><p><span class="koboSpan" id="kobo.300.1">The threads use the monitor from a fresh </span><code class="literal"><span class="koboSpan" id="kobo.301.1">lock</span></code><span class="koboSpan" id="kobo.302.1"> object of an </span><code class="literal"><span class="koboSpan" id="kobo.303.1">AnyRef</span></code><span class="koboSpan" id="kobo.304.1"> type that maps into the </span><code class="literal"><span class="koboSpan" id="kobo.305.1">java.lang.Object</span></code><span class="koboSpan" id="kobo.306.1"> class. </span><span class="koboSpan" id="kobo.306.2">The </span><code class="literal"><span class="koboSpan" id="kobo.307.1">greeter</span></code><span class="koboSpan" id="kobo.308.1"> thread starts by acquiring the lock's monitor and checks whether the message is set to </span><code class="literal"><span class="koboSpan" id="kobo.309.1">None</span></code><span class="koboSpan" id="kobo.310.1">. </span><span class="koboSpan" id="kobo.310.2">If it is, there is nothing to output as yet and the </span><code class="literal"><span class="koboSpan" id="kobo.311.1">greeter</span></code><span class="koboSpan" id="kobo.312.1"> thread calls </span><code class="literal"><span class="koboSpan" id="kobo.313.1">wait</span></code><span class="koboSpan" id="kobo.314.1"> on </span><code class="literal"><span class="koboSpan" id="kobo.315.1">lock</span></code><span class="koboSpan" id="kobo.316.1">. </span><span class="koboSpan" id="kobo.316.2">Upon calling </span><code class="literal"><span class="koboSpan" id="kobo.317.1">wait</span></code><span class="koboSpan" id="kobo.318.1">, the </span><code class="literal"><span class="koboSpan" id="kobo.319.1">lock</span></code><span class="koboSpan" id="kobo.320.1"> monitor is released and the main thread, which was previously blocked at its </span><code class="literal"><span class="koboSpan" id="kobo.321.1">synchronized</span></code><span class="koboSpan" id="kobo.322.1"> statement, now obtains the ownership of the </span><code class="literal"><span class="koboSpan" id="kobo.323.1">lock</span></code><span class="koboSpan" id="kobo.324.1"> monitor, sets the message, and calls </span><code class="literal"><span class="koboSpan" id="kobo.325.1">notify</span></code><span class="koboSpan" id="kobo.326.1">. </span><span class="koboSpan" id="kobo.326.2">When the main thread leaves the </span><code class="literal"><span class="koboSpan" id="kobo.327.1">synchronized</span></code><span class="koboSpan" id="kobo.328.1"> block, it releases </span><code class="literal"><span class="koboSpan" id="kobo.329.1">lock</span></code><span class="koboSpan" id="kobo.330.1">. </span><span class="koboSpan" id="kobo.330.2">This causes </span><code class="literal"><span class="koboSpan" id="kobo.331.1">greeter</span></code><span class="koboSpan" id="kobo.332.1"> to wake up, acquire </span><code class="literal"><span class="koboSpan" id="kobo.333.1">lock</span></code><span class="koboSpan" id="kobo.334.1">, check whether there is a message again, and then output it. </span><span class="koboSpan" id="kobo.334.2">Since </span><code class="literal"><span class="koboSpan" id="kobo.335.1">greeter</span></code><span class="koboSpan" id="kobo.336.1"> acquires the same monitor that the main thread previously released, the write to </span><code class="literal"><span class="koboSpan" id="kobo.337.1">message</span></code><span class="koboSpan" id="kobo.338.1"> by the main thread occurs before the check by the </span><code class="literal"><span class="koboSpan" id="kobo.339.1">greeter</span></code><span class="koboSpan" id="kobo.340.1"> thread. </span><span class="koboSpan" id="kobo.340.2">We now know that the </span><code class="literal"><span class="koboSpan" id="kobo.341.1">greeter</span></code><span class="koboSpan" id="kobo.342.1"> thread will see the message. </span><span class="koboSpan" id="kobo.342.2">In this example, the </span><code class="literal"><span class="koboSpan" id="kobo.343.1">greeter</span></code><span class="koboSpan" id="kobo.344.1"> thread will output </span><code class="literal"><span class="koboSpan" id="kobo.345.1">Hello!</span></code><span class="koboSpan" id="kobo.346.1"> regardless of which thread runs </span><code class="literal"><span class="koboSpan" id="kobo.347.1">synchronized</span></code><span class="koboSpan" id="kobo.348.1"> first.</span></p><p><span class="koboSpan" id="kobo.349.1">An important property of the </span><code class="literal"><span class="koboSpan" id="kobo.350.1">wait</span></code><span class="koboSpan" id="kobo.351.1"> method is that it can cause </span><span class="strong"><strong><span class="koboSpan" id="kobo.352.1">spurious wakeups</span></strong></span><span class="koboSpan" id="kobo.353.1">. </span><span class="koboSpan" id="kobo.353.2">Occasionally, the JVM is allowed to wake up a thread that called </span><code class="literal"><span class="koboSpan" id="kobo.354.1">wait</span></code><span class="koboSpan" id="kobo.355.1"> even though there is no corresponding </span><code class="literal"><span class="koboSpan" id="kobo.356.1">notify</span></code><span class="koboSpan" id="kobo.357.1"> call. </span><span class="koboSpan" id="kobo.357.2">To guard against this, we must always use </span><code class="literal"><span class="koboSpan" id="kobo.358.1">wait</span></code><span class="koboSpan" id="kobo.359.1"> in conjunction with a </span><code class="literal"><span class="koboSpan" id="kobo.360.1">while</span></code><span class="koboSpan" id="kobo.361.1"> loop that checks the condition, as in the previous example. </span><span class="koboSpan" id="kobo.361.2">Using an </span><code class="literal"><span class="koboSpan" id="kobo.362.1">if</span></code><span class="koboSpan" id="kobo.363.1"> statement would be incorrect, as a spurious wakeup could allow the thread to execute </span><code class="literal"><span class="koboSpan" id="kobo.364.1">message.get</span></code><span class="koboSpan" id="kobo.365.1">, even though </span><code class="literal"><span class="koboSpan" id="kobo.366.1">message</span></code><span class="koboSpan" id="kobo.367.1"> was not set to a value different than </span><code class="literal"><span class="koboSpan" id="kobo.368.1">None</span></code><span class="koboSpan" id="kobo.369.1">.</span></p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note12"/><span class="koboSpan" id="kobo.370.1">Note</span></h3><p><span class="koboSpan" id="kobo.371.1">After the thread that checks the condition wakes up, the monitor becomes owned by that thread, so we are guaranteed that the check is performed atomically.
</span><span class="koboSpan" id="kobo.371.2">Note that a thread that checks the condition must acquire the monitor to wake up. </span><span class="koboSpan" id="kobo.371.3">If it cannot acquire the monitor immediately, it goes into the blocked state.</span></p></div></div><p><span class="koboSpan" id="kobo.372.1">A </span><code class="literal"><span class="koboSpan" id="kobo.373.1">synchronized</span></code><span class="koboSpan" id="kobo.374.1"> statement in which some condition is repetitively checked before calling </span><code class="literal"><span class="koboSpan" id="kobo.375.1">wait</span></code><span class="koboSpan" id="kobo.376.1"> is called a </span><span class="strong"><strong><span class="koboSpan" id="kobo.377.1">guarded block</span></strong></span><span class="koboSpan" id="kobo.378.1">. </span><span class="koboSpan" id="kobo.378.2">We can now use our insight on guarded blocks to avoid the busy-wait in our </span><code class="literal"><span class="koboSpan" id="kobo.379.1">worker</span></code><span class="koboSpan" id="kobo.380.1"> thread in advance. </span><span class="koboSpan" id="kobo.380.2">We will now show the complete </span><code class="literal"><span class="koboSpan" id="kobo.381.1">worker</span></code><span class="koboSpan" id="kobo.382.1"> implementation using monitors:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.383.1">object SynchronizedPool extends App { 
  private val tasks = mutable.Queue[() =&gt; Unit]() 
  object Worker extends Thread { 
    setDaemon(true) 
    def poll() = tasks.synchronized { 
      while (tasks.isEmpty) tasks.wait() 
      tasks.dequeue() 
    } 
    override def run() = while (true) { 
      val task = poll() 
      task() 
    } 
  } 
  Worker.start() 
  def asynchronous(body: =&gt;Unit) = tasks.synchronized { 
    tasks.enqueue(() =&gt; body) 
    tasks.notify() 
  } 
  asynchronous { log("Hello ") } 
  asynchronous { log("World!") } 
  Thread.sleep(500) 
} 
</span></pre><p><span class="koboSpan" id="kobo.384.1">In this example, we declared the </span><code class="literal"><span class="koboSpan" id="kobo.385.1">Worker</span></code><span class="koboSpan" id="kobo.386.1"> thread as a singleton object within our application to be more concise. </span><span class="koboSpan" id="kobo.386.2">This time, the </span><code class="literal"><span class="koboSpan" id="kobo.387.1">poll</span></code><span class="koboSpan" id="kobo.388.1"> method calls </span><code class="literal"><span class="koboSpan" id="kobo.389.1">wait</span></code><span class="koboSpan" id="kobo.390.1"> on the </span><code class="literal"><span class="koboSpan" id="kobo.391.1">tasks</span></code><span class="koboSpan" id="kobo.392.1"> object and waits until the main thread adds a code block to </span><code class="literal"><span class="koboSpan" id="kobo.393.1">tasks</span></code><span class="koboSpan" id="kobo.394.1"> and calls </span><code class="literal"><span class="koboSpan" id="kobo.395.1">notify</span></code><span class="koboSpan" id="kobo.396.1"> in the </span><code class="literal"><span class="koboSpan" id="kobo.397.1">asynchronous</span></code><span class="koboSpan" id="kobo.398.1"> method. </span><span class="koboSpan" id="kobo.398.2">Start the example and inspect your CPU usage again. </span><span class="koboSpan" id="kobo.398.3">If you restarted SBT (and still have battery power) since running the busy-wait example, you will see that the CPU usage by the </span><code class="literal"><span class="koboSpan" id="kobo.399.1">java</span></code><span class="koboSpan" id="kobo.400.1"> process is zero.</span></p></div><div class="section" title="Interrupting threads and the graceful shutdown"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec20"/><span class="koboSpan" id="kobo.401.1">Interrupting threads and the graceful shutdown</span></h2></div></div></div><p><span class="koboSpan" id="kobo.402.1">In the previous example, the </span><code class="literal"><span class="koboSpan" id="kobo.403.1">Worker</span></code><span class="koboSpan" id="kobo.404.1"> thread loops forever in its </span><code class="literal"><span class="koboSpan" id="kobo.405.1">run</span></code><span class="koboSpan" id="kobo.406.1"> method and never terminates. </span><span class="koboSpan" id="kobo.406.2">You might be satisfied with this; </span><code class="literal"><span class="koboSpan" id="kobo.407.1">Worker</span></code><span class="koboSpan" id="kobo.408.1"> does not use the CPU if it has no work to do, and since </span><code class="literal"><span class="koboSpan" id="kobo.409.1">Worker</span></code><span class="koboSpan" id="kobo.410.1"> is a daemon thread, it is destroyed when the application exits. </span><span class="koboSpan" id="kobo.410.2">However, its stack space is not reclaimed until the application terminates. </span><span class="koboSpan" id="kobo.410.3">If we have a lot of dormant workers lying around, we might run out of memory. </span><span class="koboSpan" id="kobo.410.4">One way to stop a dormant thread from executing is to interrupt it, as follows:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.411.1">Worker.interrupt() 
</span></pre><p><span class="koboSpan" id="kobo.412.1">Calling the </span><code class="literal"><span class="koboSpan" id="kobo.413.1">interrupt</span></code><span class="koboSpan" id="kobo.414.1"> method on a thread that is in the waiting or timed waiting state causes it to throw an </span><code class="literal"><span class="koboSpan" id="kobo.415.1">InterruptedException</span></code><span class="koboSpan" id="kobo.416.1">. </span><span class="koboSpan" id="kobo.416.2">This exception can be caught and handled, but in our case, it will terminate the </span><code class="literal"><span class="koboSpan" id="kobo.417.1">Worker</span></code><span class="koboSpan" id="kobo.418.1"> thread. </span><span class="koboSpan" id="kobo.418.2">However, if we call this method while the thread is running, the exception is not thrown and the thread's </span><code class="literal"><span class="koboSpan" id="kobo.419.1">interrupt</span></code><span class="koboSpan" id="kobo.420.1"> flag is set. </span><span class="koboSpan" id="kobo.420.2">A thread that does not block must periodically query the interrupt flag with the </span><code class="literal"><span class="koboSpan" id="kobo.421.1">isInterrupted</span></code><span class="koboSpan" id="kobo.422.1"> method.</span></p><p><span class="koboSpan" id="kobo.423.1">An alternative is to implement an idiom known as the </span><span class="strong"><strong><span class="koboSpan" id="kobo.424.1">graceful shutdown</span></strong></span><span class="koboSpan" id="kobo.425.1">. </span><span class="koboSpan" id="kobo.425.2">In the graceful shutdown, one thread sets the condition for the termination and then calls </span><code class="literal"><span class="koboSpan" id="kobo.426.1">notify</span></code><span class="koboSpan" id="kobo.427.1"> to wake up a worker thread. </span><span class="koboSpan" id="kobo.427.2">The worker thread then releases all its resources and terminates willingly. </span><span class="koboSpan" id="kobo.427.3">We first introduce a variable called </span><code class="literal"><span class="koboSpan" id="kobo.428.1">terminated</span></code><span class="koboSpan" id="kobo.429.1"> that is </span><code class="literal"><span class="koboSpan" id="kobo.430.1">true</span></code><span class="koboSpan" id="kobo.431.1"> if the thread should be stopped. </span><span class="koboSpan" id="kobo.431.2">The </span><code class="literal"><span class="koboSpan" id="kobo.432.1">poll</span></code><span class="koboSpan" id="kobo.433.1"> method additionally checks this variable before waiting on </span><code class="literal"><span class="koboSpan" id="kobo.434.1">tasks</span></code><span class="koboSpan" id="kobo.435.1"> and optionally returns a task only if the </span><code class="literal"><span class="koboSpan" id="kobo.436.1">Worker</span></code><span class="koboSpan" id="kobo.437.1"> thread should continue to run, as shown in the following code:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.438.1">object Worker extends Thread { 
  var terminated = false 
  def poll(): Option[() =&gt; Unit] = tasks.synchronized { 
    while (tasks.isEmpty &amp;&amp; !terminated) tasks.wait() 
    if (!terminated) Some(tasks.dequeue()) else None 
  } 
</span></pre><p><span class="koboSpan" id="kobo.439.1">We change the </span><code class="literal"><span class="koboSpan" id="kobo.440.1">run</span></code><span class="koboSpan" id="kobo.441.1"> method to check if </span><code class="literal"><span class="koboSpan" id="kobo.442.1">poll</span></code><span class="koboSpan" id="kobo.443.1"> returns </span><code class="literal"><span class="koboSpan" id="kobo.444.1">Some(task)</span></code><span class="koboSpan" id="kobo.445.1"> in a pattern match. </span><span class="koboSpan" id="kobo.445.2">We no longer use a </span><code class="literal"><span class="koboSpan" id="kobo.446.1">while</span></code><span class="koboSpan" id="kobo.447.1"> loop in the </span><code class="literal"><span class="koboSpan" id="kobo.448.1">run</span></code><span class="koboSpan" id="kobo.449.1"> method. </span><span class="koboSpan" id="kobo.449.2">Instead, we call </span><code class="literal"><span class="koboSpan" id="kobo.450.1">run</span></code><span class="koboSpan" id="kobo.451.1"> tail-recursively if </span><code class="literal"><span class="koboSpan" id="kobo.452.1">poll</span></code><span class="koboSpan" id="kobo.453.1"> returned </span><code class="literal"><span class="koboSpan" id="kobo.454.1">Some(task)</span></code><span class="koboSpan" id="kobo.455.1">:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.456.1">  import scala.annotation.tailrec 
  @tailrec override def run() = poll() match { 
    case Some(task) =&gt; task(); run() 
    case None =&gt; 
  } 
  def shutdown() = tasks.synchronized { 
    terminated = true 
    tasks.notify() 
  } 
} 
</span></pre><p><span class="koboSpan" id="kobo.457.1">The main thread can now call the synchronized </span><code class="literal"><span class="koboSpan" id="kobo.458.1">shutdown</span></code><span class="koboSpan" id="kobo.459.1"> method on the </span><code class="literal"><span class="koboSpan" id="kobo.460.1">Worker</span></code><span class="koboSpan" id="kobo.461.1"> thread to communicate with the termination request. </span><span class="koboSpan" id="kobo.461.2">There is no need to make the </span><code class="literal"><span class="koboSpan" id="kobo.462.1">Worker</span></code><span class="koboSpan" id="kobo.463.1"> thread a daemon thread anymore. </span><span class="koboSpan" id="kobo.463.2">Eventually, the </span><code class="literal"><span class="koboSpan" id="kobo.464.1">Worker</span></code><span class="koboSpan" id="kobo.465.1"> thread will terminate on its own.</span></p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip13"/><span class="koboSpan" id="kobo.466.1">Tip</span></h3><p><span class="koboSpan" id="kobo.467.1">To ensure that various utility threads terminate correctly without race conditions, use the graceful shutdown idiom.</span></p></div></div><p><span class="koboSpan" id="kobo.468.1">The situation where calling </span><code class="literal"><span class="koboSpan" id="kobo.469.1">interrupt</span></code><span class="koboSpan" id="kobo.470.1"> is preferred to a graceful shutdown is when we cannot wake the thread using </span><code class="literal"><span class="koboSpan" id="kobo.471.1">notify</span></code><span class="koboSpan" id="kobo.472.1">. </span><span class="koboSpan" id="kobo.472.2">One example is when the thread does blocking I/O on an </span><code class="literal"><span class="koboSpan" id="kobo.473.1">InterruptibleChannel</span></code><span class="koboSpan" id="kobo.474.1"> object, in which case the object the thread is calling the </span><code class="literal"><span class="koboSpan" id="kobo.475.1">wait</span></code><span class="koboSpan" id="kobo.476.1"> method on is hidden.</span></p><p><span class="koboSpan" id="kobo.477.1">The </span><code class="literal"><span class="koboSpan" id="kobo.478.1">Thread</span></code><span class="koboSpan" id="kobo.479.1"> class also defines a deprecated </span><code class="literal"><span class="koboSpan" id="kobo.480.1">stop</span></code><span class="koboSpan" id="kobo.481.1"> method that immediately terminates a thread by throwing a </span><code class="literal"><span class="koboSpan" id="kobo.482.1">ThreadDeath</span></code><span class="koboSpan" id="kobo.483.1"> exception. </span><span class="koboSpan" id="kobo.483.2">You should avoid it as it stops the thread's execution at an arbitrary point, possibly leaving the program data in an inconsistent state.</span></p></div></div></div></div>
<div id="book-columns"><div id="book-inner"><div class="section" title="Volatile variables"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec15"/><span class="koboSpan" id="kobo.1.1">Volatile variables</span></h1></div></div></div><p><span class="koboSpan" id="kobo.2.1">The JVM offers a more lightweight form of synchronization than the </span><code class="literal"><span class="koboSpan" id="kobo.3.1">synchronized</span></code><span class="koboSpan" id="kobo.4.1"> block, called </span><span class="strong"><strong><span class="koboSpan" id="kobo.5.1">volatile variables</span></strong></span><span class="koboSpan" id="kobo.6.1">. </span><span class="koboSpan" id="kobo.6.2">Volatile variables can be atomically read and modified, and are mostly used as status flags; for example, to signal that a computation is completed or canceled. </span><span class="koboSpan" id="kobo.6.3">They have two advantages. </span><span class="koboSpan" id="kobo.6.4">First, writes to and reads from volatile variables cannot be reordered in a single thread. </span><span class="koboSpan" id="kobo.6.5">Second, writing to a volatile variable is immediately visible to all the other threads.</span></p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note14"/><span class="koboSpan" id="kobo.7.1">Note</span></h3><p><span class="koboSpan" id="kobo.8.1">Reads and writes to variables marked as volatile are never reordered. </span><span class="koboSpan" id="kobo.8.2">If a write </span><code class="literal"><span class="koboSpan" id="kobo.9.1">W</span></code><span class="koboSpan" id="kobo.10.1"> to a volatile </span><code class="literal"><span class="koboSpan" id="kobo.11.1">v</span></code><span class="koboSpan" id="kobo.12.1"> variable is observed on another thread through a read </span><code class="literal"><span class="koboSpan" id="kobo.13.1">R</span></code><span class="koboSpan" id="kobo.14.1"> of the same variable, then all the writes that preceded the write </span><code class="literal"><span class="koboSpan" id="kobo.15.1">W</span></code><span class="koboSpan" id="kobo.16.1"> are guaranteed to be observed after the read </span><code class="literal"><span class="koboSpan" id="kobo.17.1">R</span></code><span class="koboSpan" id="kobo.18.1">.</span></p></div></div><p><span class="koboSpan" id="kobo.19.1">In the following example, we search for at least one </span><code class="literal"><span class="koboSpan" id="kobo.20.1">!</span></code><span class="koboSpan" id="kobo.21.1"> character in several pages of the text. </span><span class="koboSpan" id="kobo.21.2">Separate threads start scanning separate pages </span><code class="literal"><span class="koboSpan" id="kobo.22.1">p</span></code><span class="koboSpan" id="kobo.23.1"> of the text written by a person that is particularly fond of a popular fictional hero. </span><span class="koboSpan" id="kobo.23.2">As soon as one thread finds the exclamation, we want to stop searching in other threads:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.24.1">class Page(val txt: String, var position: Int) 
object Volatile extends App { 
  val pages = for (i&lt;- 1 to 5) yield 
    new Page("Na" * (100 - 20 * i) + " Batman!", -1) 
  @volatile var found = false 
  for (p &lt;- pages) yield thread { 
    var i = 0 
    while (i &lt; p.txt.length &amp;&amp; !found) 
      if (p.txt(i) == '!') { 
        p.position = i 
        found = true 
      } else i += 1 
  } 
  while (!found) {} 
  log(s"results: ${pages.map(_.position)}") 
} 
</span></pre><p><span class="koboSpan" id="kobo.25.1">Separate pages of text are represented by the </span><code class="literal"><span class="koboSpan" id="kobo.26.1">Page</span></code><span class="koboSpan" id="kobo.27.1"> class, which has a special </span><code class="literal"><span class="koboSpan" id="kobo.28.1">position</span></code><span class="koboSpan" id="kobo.29.1"> field for storing the result of the exclamation mark search. </span><span class="koboSpan" id="kobo.29.2">The </span><code class="literal"><span class="koboSpan" id="kobo.30.1">found</span></code><span class="koboSpan" id="kobo.31.1"> flag denotes that some thread has found an exclamation. </span><span class="koboSpan" id="kobo.31.2">We add the </span><code class="literal"><span class="koboSpan" id="kobo.32.1">@volatile</span></code><span class="koboSpan" id="kobo.33.1"> annotation to the </span><code class="literal"><span class="koboSpan" id="kobo.34.1">found</span></code><span class="koboSpan" id="kobo.35.1"> flag to declare it volatile. </span><span class="koboSpan" id="kobo.35.2">When some thread finds an exclamation character in some page, the </span><code class="literal"><span class="koboSpan" id="kobo.36.1">position</span></code><span class="koboSpan" id="kobo.37.1"> value is stored and the </span><code class="literal"><span class="koboSpan" id="kobo.38.1">found</span></code><span class="koboSpan" id="kobo.39.1"> flag is set so that the other threads can stop their search early. </span><span class="koboSpan" id="kobo.39.2">It is entirely possible that all the threads end up scanning the entire text, but more likely that they see that </span><code class="literal"><span class="koboSpan" id="kobo.40.1">found</span></code><span class="koboSpan" id="kobo.41.1"> is </span><code class="literal"><span class="koboSpan" id="kobo.42.1">true</span></code><span class="koboSpan" id="kobo.43.1"> before that. </span><span class="koboSpan" id="kobo.43.2">Thus, at least one thread stores the exclamation position.</span></p><p><span class="koboSpan" id="kobo.44.1">For the purposes of this example, the main thread busy-waits until it reads </span><code class="literal"><span class="koboSpan" id="kobo.45.1">found</span></code><span class="koboSpan" id="kobo.46.1">, which is </span><code class="literal"><span class="koboSpan" id="kobo.47.1">true</span></code><span class="koboSpan" id="kobo.48.1">. </span><span class="koboSpan" id="kobo.48.2">It then prints the positions. </span><span class="koboSpan" id="kobo.48.3">Note that a write to </span><code class="literal"><span class="koboSpan" id="kobo.49.1">position</span></code><span class="koboSpan" id="kobo.50.1"> occurs before the write to </span><code class="literal"><span class="koboSpan" id="kobo.51.1">found</span></code><span class="koboSpan" id="kobo.52.1"> in the spawned threads, which in turn occurs before reading </span><code class="literal"><span class="koboSpan" id="kobo.53.1">found</span></code><span class="koboSpan" id="kobo.54.1"> in the main thread. </span><span class="koboSpan" id="kobo.54.2">This means that the main thread always sees the write of the thread that set </span><code class="literal"><span class="koboSpan" id="kobo.55.1">found</span></code><span class="koboSpan" id="kobo.56.1">, and hence prints at least one position other than </span><code class="literal"><span class="koboSpan" id="kobo.57.1">-1</span></code><span class="koboSpan" id="kobo.58.1">.</span></p><p><span class="koboSpan" id="kobo.59.1">The </span><code class="literal"><span class="koboSpan" id="kobo.60.1">ThreadSharedStateAccessReordering</span></code><span class="koboSpan" id="kobo.61.1"> example from an earlier section can be fixed by declaring all the variables as volatile. </span><span class="koboSpan" id="kobo.61.2">As we will learn in the next section, this ensures a correct order between reads from and writes to </span><code class="literal"><span class="koboSpan" id="kobo.62.1">a</span></code><span class="koboSpan" id="kobo.63.1"> and </span><code class="literal"><span class="koboSpan" id="kobo.64.1">b</span></code><span class="koboSpan" id="kobo.65.1">. </span><span class="koboSpan" id="kobo.65.2">Unlike Java, Scala allows you to declare local fields volatile (in this case, local to the closure of the enclosing </span><code class="literal"><span class="koboSpan" id="kobo.66.1">for</span></code><span class="koboSpan" id="kobo.67.1"> loop). </span><span class="koboSpan" id="kobo.67.2">A heap object with a volatile field is created for each local volatile variable used in some closure or a nested class. </span><span class="koboSpan" id="kobo.67.3">We say the variable is </span><span class="strong"><strong><span class="koboSpan" id="kobo.68.1">lifted</span></strong></span><span class="koboSpan" id="kobo.69.1"> into an object.</span></p><p><span class="koboSpan" id="kobo.70.1">A volatile read is usually extremely cheap. </span><span class="koboSpan" id="kobo.70.2">In most cases, however, you should resort to the </span><code class="literal"><span class="koboSpan" id="kobo.71.1">synchronized</span></code><span class="koboSpan" id="kobo.72.1"> statements; volatile semantics are subtle and easy to get wrong. </span><span class="koboSpan" id="kobo.72.2">In particular, multiple volatile reads and writes are not atomic without additional synchronization; volatiles alone cannot help us to implement </span><code class="literal"><span class="koboSpan" id="kobo.73.1">getUniqueId</span></code><span class="koboSpan" id="kobo.74.1"> correctly.</span></p></div></div></div>
<div id="book-columns"><div id="book-inner"><div class="section" title="The Java Memory Model"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec16"/><span class="koboSpan" id="kobo.1.1">The Java Memory Model</span></h1></div></div></div><p><span class="koboSpan" id="kobo.2.1">While we were never explicit about it throughout this chapter, we have actually defined most of the JMM. </span><span class="koboSpan" id="kobo.2.2">What is a memory model in the first place?</span></p><p><span class="koboSpan" id="kobo.3.1">A language memory model is a specification that describes the circumstances under which a write to a variable becomes visible to other threads. </span><span class="koboSpan" id="kobo.3.2">You might think that a write to a variable </span><code class="literal"><span class="koboSpan" id="kobo.4.1">v</span></code><span class="koboSpan" id="kobo.5.1"> changes the corresponding memory location immediately after the processor executes it, and that other processors see the new value of </span><code class="literal"><span class="koboSpan" id="kobo.6.1">v</span></code><span class="koboSpan" id="kobo.7.1"> instantaneously. </span><span class="koboSpan" id="kobo.7.2">This memory consistency model is called </span><span class="strong"><strong><span class="koboSpan" id="kobo.8.1">sequential consistency</span></strong></span><span class="koboSpan" id="kobo.9.1">.</span></p><p><span class="koboSpan" id="kobo.10.1">As we already saw in the </span><code class="literal"><span class="koboSpan" id="kobo.11.1">ThreadSharedStateAccessReordering</span></code><span class="koboSpan" id="kobo.12.1"> example, sequential consistency has little to do with how processors and compilers really work. </span><span class="koboSpan" id="kobo.12.2">Writes rarely end up in the main memory immediately; instead, processors have hierarchies of caches that ensure a better performance and guarantee that the data is only eventually written to the main memory. </span><span class="koboSpan" id="kobo.12.3">Compilers are allowed to use registers to postpone or avoid memory writes, and reorder statements to achieve optimal performance, as long as it does not change the serial semantics. </span><span class="koboSpan" id="kobo.12.4">It makes sense to do so; while the short examples in this book are interspersed with synchronization primitives, in actual programs, different threads communicate relatively rarely compared to the amount of time spent doing useful work.</span></p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note15"/><span class="koboSpan" id="kobo.13.1">Note</span></h3><p><span class="koboSpan" id="kobo.14.1">A memory model is a trade-off between the predictable behavior of a concurrent program and a compiler's ability to perform optimizations. </span><span class="koboSpan" id="kobo.14.2">Not every language or platform has a memory model. </span><span class="koboSpan" id="kobo.14.3">A typical purely functional programming language, which doesn't support mutations, does not need a memory model at all.</span></p></div></div><p><span class="koboSpan" id="kobo.15.1">Differences between processor architectures result in different memory models; it would be very difficult, if not impossible, to correctly write a Scala program that works in the same way on every computer without the precise semantics of the </span><code class="literal"><span class="koboSpan" id="kobo.16.1">synchronized</span></code><span class="koboSpan" id="kobo.17.1"> statement or volatile reads and writes. </span><span class="koboSpan" id="kobo.17.2">Scala inherits its memory model from the JVM, which precisely specifies a set of </span><span class="strong"><strong><span class="koboSpan" id="kobo.18.1">happens-before</span></strong></span><span class="koboSpan" id="kobo.19.1"> relationships between different actions in a program.</span></p><p><span class="koboSpan" id="kobo.20.1">In the JMM, the different actions are (volatile) variable reads and writes, acquiring and releasing object monitors, starting threads, and waiting for their termination. </span><span class="koboSpan" id="kobo.20.2">If an action A happens before an action B, then the action B sees A's memory writes. </span><span class="koboSpan" id="kobo.20.3">The same set of happens-before relationships is valid for the same program irrespective of the machine it runs on; it is the JVM's task to ensure this. </span><span class="koboSpan" id="kobo.20.4">We already summarized most of these rules, but we will now present a complete overview:</span></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong><span class="koboSpan" id="kobo.21.1">Program order</span></strong></span><span class="koboSpan" id="kobo.22.1">: Each action in a thread happens-before every other subsequent action in the program order of that thread.</span></li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong><span class="koboSpan" id="kobo.23.1">Monitor locking</span></strong></span><span class="koboSpan" id="kobo.24.1">: Unlocking a monitor happens-before every subsequent locking of that monitor.</span></li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong><span class="koboSpan" id="kobo.25.1">Volatile fields</span></strong></span><span class="koboSpan" id="kobo.26.1">: A write to a volatile field happens-before every subsequent read of that volatile field.</span></li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong><span class="koboSpan" id="kobo.27.1">Thread start</span></strong></span><span class="koboSpan" id="kobo.28.1">: A call to </span><code class="literal"><span class="koboSpan" id="kobo.29.1">start()</span></code><span class="koboSpan" id="kobo.30.1"> on a thread happens-before any actions in the started thread.</span></li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong><span class="koboSpan" id="kobo.31.1">Thread termination</span></strong></span><span class="koboSpan" id="kobo.32.1">: Any action in a thread happens-before another thread completes a </span><code class="literal"><span class="koboSpan" id="kobo.33.1">join()</span></code><span class="koboSpan" id="kobo.34.1"> call on that thread.</span></li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong><span class="koboSpan" id="kobo.35.1">Transitivity</span></strong></span><span class="koboSpan" id="kobo.36.1">: If action A happens-before action B, and action B happens-before action C, then action A happens-before action C.</span></li></ul></div><p><span class="koboSpan" id="kobo.37.1">Despite its somewhat misleading name, the happens-before relationship exists to ensure that threads see each other's memory writes. </span><span class="koboSpan" id="kobo.37.2">It does not exist to establish a temporal ordering between different statements in the program. </span><span class="koboSpan" id="kobo.37.3">When we say that a write A happens before a read B, it is guaranteed that the effects of the write A are visible to that particular read B. </span><span class="koboSpan" id="kobo.37.4">Whether or not the write A occurs earlier than the read B depends on the execution of the program.</span></p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note16"/><span class="koboSpan" id="kobo.38.1">Note</span></h3><p><span class="koboSpan" id="kobo.39.1">The happens-before relationship describes the visibility of the writes performed by a different thread.</span></p></div></div><p><span class="koboSpan" id="kobo.40.1">Additionally, the JMM guarantees that volatile reads and writes as well as monitor locks and unlocks are never reordered. </span><span class="koboSpan" id="kobo.40.2">The happens-before relationship ensures that nonvolatile reads and writes also cannot be reordered arbitrarily. </span><span class="koboSpan" id="kobo.40.3">In particular, this relationship ensures the following things:</span></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="koboSpan" id="kobo.41.1">A non-volatile read cannot be reordered to appear before a volatile read (or monitor lock) that precedes it in the program order</span></li><li class="listitem" style="list-style-type: disc"><span class="koboSpan" id="kobo.42.1">A non-volatile write cannot be reordered to appear after a volatile write (or monitor unlock) that follows it in the program order</span></li></ul></div><p><span class="koboSpan" id="kobo.43.1">Higher-level constructs often establish a happens-before relationship on top of these rules. </span><span class="koboSpan" id="kobo.43.2">For example, an </span><code class="literal"><span class="koboSpan" id="kobo.44.1">interrupt</span></code><span class="koboSpan" id="kobo.45.1"> call happens before the interrupted thread detects it; this is because the </span><code class="literal"><span class="koboSpan" id="kobo.46.1">interrupt</span></code><span class="koboSpan" id="kobo.47.1"> call uses a monitor to wake the thread in a typical implementation. </span><span class="koboSpan" id="kobo.47.2">Scala concurrency APIs described in the later chapters also establish happens-before relationships between various method calls, as we will see. </span><span class="koboSpan" id="kobo.47.3">In all these cases, it is the task of the programmer to ensure that every write of a variable is in a happens-before relationship with every read of that variable that should read the written value. </span><span class="koboSpan" id="kobo.47.4">A program in which this is not true is said to contain </span><span class="strong"><strong><span class="koboSpan" id="kobo.48.1">data races</span></strong></span><span class="koboSpan" id="kobo.49.1">.</span></p><div class="section" title="Immutable objects and final fields"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec21"/><span class="koboSpan" id="kobo.50.1">Immutable objects and final fields</span></h2></div></div></div><p><span class="koboSpan" id="kobo.51.1">We have said that programs must establish happens-before relationships to avoid data races, but there is an exception to this rule. </span><span class="koboSpan" id="kobo.51.2">If an object contains only </span><span class="strong"><strong><span class="koboSpan" id="kobo.52.1">final fields</span></strong></span><span class="koboSpan" id="kobo.53.1"> and the reference to the enclosing object does not become visible to another thread before the constructor completes, then the object is considered immutable and can be shared between the threads without any synchronization.</span></p><p><span class="koboSpan" id="kobo.54.1">In Java, a final field is marked with the </span><code class="literal"><span class="koboSpan" id="kobo.55.1">final</span></code><span class="koboSpan" id="kobo.56.1"> keyword. </span><span class="koboSpan" id="kobo.56.2">In Scala, declaring an object field as </span><code class="literal"><span class="koboSpan" id="kobo.57.1">final</span></code><span class="koboSpan" id="kobo.58.1"> means that the getter for that field cannot be overridden in a subclass. </span><span class="koboSpan" id="kobo.58.2">The field itself is always final provided that it is a value declaration, that is, a </span><code class="literal"><span class="koboSpan" id="kobo.59.1">val</span></code><span class="koboSpan" id="kobo.60.1"> declaration. </span><span class="koboSpan" id="kobo.60.2">The following class depicts this:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.61.1">class Foo(final val a: Int, val b: Int) 
</span></pre><p><span class="koboSpan" id="kobo.62.1">The preceding class corresponds to the following Java class after the Scala compiler translates it:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.63.1">class Foo { // Java code below 
  final private int a$; 
  final private int b$; 
  final public int a() { return a$; } 
  public int b() { return b$; } 
  public Foo(int a, int b) { 
    a$ = a; 
    b$ = b; 
  } 
} 
</span></pre><p><span class="koboSpan" id="kobo.64.1">Note that both the fields become final at the JVM level and can be shared without synchronization. </span><span class="koboSpan" id="kobo.64.2">The difference is that the getter for </span><code class="literal"><span class="koboSpan" id="kobo.65.1">a</span></code><span class="koboSpan" id="kobo.66.1"> cannot be overridden in a </span><code class="literal"><span class="koboSpan" id="kobo.67.1">Foo</span></code><span class="koboSpan" id="kobo.68.1"> subclass. </span><span class="koboSpan" id="kobo.68.2">We have to disambiguate finality in the reassignment and overriding sense.</span></p><p><span class="koboSpan" id="kobo.69.1">Since Scala is a hybrid between functional and object-oriented paradigms, many of its language features map to immutable objects. </span><span class="koboSpan" id="kobo.69.2">A lambda value can capture a reference to the enclosing class or a lifted variable, as in the following example:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.70.1">var inc: () =&gt; Unit = null 
val t = thread { if (inc != null) inc() } 
private var number = 1 
inc = () =&gt; { number += 1 } 
</span></pre><p><span class="koboSpan" id="kobo.71.1">The local </span><code class="literal"><span class="koboSpan" id="kobo.72.1">number</span></code><span class="koboSpan" id="kobo.73.1"> variable is captured by the lambda, so it needs to be lifted. </span><span class="koboSpan" id="kobo.73.2">The statement in the last line translates to an anonymous </span><code class="literal"><span class="koboSpan" id="kobo.74.1">Function0</span></code><span class="koboSpan" id="kobo.75.1"> class instantiation:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.76.1">number = new IntRef(1) // captured local variables become objects 
inc = new Function0 { 
  val $number = number // recall - vals are final! 
  </span><span class="koboSpan" id="kobo.76.2">def apply() = $number.elem += 1 
} 
</span></pre><p><span class="koboSpan" id="kobo.77.1">There is no happens-before relationship between the assignment to </span><code class="literal"><span class="koboSpan" id="kobo.78.1">inc</span></code><span class="koboSpan" id="kobo.79.1"> and the read of </span><code class="literal"><span class="koboSpan" id="kobo.80.1">inc</span></code><span class="koboSpan" id="kobo.81.1"> by the thread </span><code class="literal"><span class="koboSpan" id="kobo.82.1">t</span></code><span class="koboSpan" id="kobo.83.1">. </span><span class="koboSpan" id="kobo.83.2">However, if the </span><code class="literal"><span class="koboSpan" id="kobo.84.1">t</span></code><span class="koboSpan" id="kobo.85.1"> thread sees that </span><code class="literal"><span class="koboSpan" id="kobo.86.1">inc</span></code><span class="koboSpan" id="kobo.87.1"> is not </span><code class="literal"><span class="koboSpan" id="kobo.88.1">null</span></code><span class="koboSpan" id="kobo.89.1">, invoking </span><code class="literal"><span class="koboSpan" id="kobo.90.1">inc</span></code><span class="koboSpan" id="kobo.91.1"> still works correctly, because the </span><code class="literal"><span class="koboSpan" id="kobo.92.1">$number</span></code><span class="koboSpan" id="kobo.93.1"> field is appropriately initialized since it is stored as a field in the immutable lambda object. </span><span class="koboSpan" id="kobo.93.2">The Scala compiler ensures that lambda values contain only final, properly initialized fields. </span><span class="koboSpan" id="kobo.93.3">Anonymous classes, auto-boxed primitives, and value classes share the same philosophy.</span></p><p><span class="koboSpan" id="kobo.94.1">In current versions of Scala, however, certain collections that are deemed immutable, such as </span><code class="literal"><span class="koboSpan" id="kobo.95.1">List</span></code><span class="koboSpan" id="kobo.96.1"> and </span><code class="literal"><span class="koboSpan" id="kobo.97.1">Vector</span></code><span class="koboSpan" id="kobo.98.1">, cannot be shared without synchronization. </span><span class="koboSpan" id="kobo.98.2">Although their external API does not allow you to modify them, they contain non-final fields.</span></p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip17"/><span class="koboSpan" id="kobo.99.1">Tip</span></h3><p><span class="koboSpan" id="kobo.100.1">Even if an object seems immutable, always use proper synchronization to share any object between the threads.</span></p></div></div></div></div></div></div>
<div id="book-columns"><div id="book-inner"><div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec17"/><span class="koboSpan" id="kobo.1.1">Summary</span></h1></div></div></div><p><span class="koboSpan" id="kobo.2.1">In this chapter, we showed how to create and start threads, and wait for their termination. </span><span class="koboSpan" id="kobo.2.2">We have shown how to achieve inter-thread communication by modifying the shared memory and by using the </span><code class="literal"><span class="koboSpan" id="kobo.3.1">synchronized</span></code><span class="koboSpan" id="kobo.4.1"> statement, and what it means for a thread to be in a blocked state. </span><span class="koboSpan" id="kobo.4.2">We have studied approaches to prevent deadlocks by imposing the ordering on the locks and avoided busy-waits in place of guarded blocks. </span><span class="koboSpan" id="kobo.4.3">We have seen how to implement a graceful shutdown for thread termination and when to communicate using volatiles. </span><span class="koboSpan" id="kobo.4.4">We witnessed how the correctness of a program can be compromised by undesired interactions known as race conditions as well as data races due to the lack of synchronization. </span><span class="koboSpan" id="kobo.4.5">And, most importantly, we have learned that the only way to correctly reason about the semantics of a multithreaded program is in terms of happens-before relationships defined by the JMM.</span></p><p><span class="koboSpan" id="kobo.5.1">The language primitives and APIs presented in this section are low-level; they are the basic building blocks for concurrency on the JVM and in Scala, and there are only a handful of situations where you should use them directly. </span><span class="koboSpan" id="kobo.5.2">One of them is designing a new concurrency library yourself; another one is dealing with a legacy API built directly from these primitives. </span><span class="koboSpan" id="kobo.5.3">Although you should strive to build concurrent Scala applications in terms of concurrency frameworks introduced in the later chapters, the insights from this chapter will be helpful in understanding how higher-level constructs work. </span><span class="koboSpan" id="kobo.5.4">You should now have a valuable insight of what's going on under the hood.</span></p><p><span class="koboSpan" id="kobo.6.1">If you would like to learn more about concurrency on the JVM and the JMM, we recommend that you read the book </span><span class="emphasis"><em><span class="koboSpan" id="kobo.7.1">Java Concurrency in Practice</span></em></span><span class="koboSpan" id="kobo.8.1">, </span><span class="emphasis"><em><span class="koboSpan" id="kobo.9.1">Brian Goetz, Tim Peierls, Joshua Bloch, Joseph Bowbeer, David Holmes, and Doug Lea</span></em></span><span class="koboSpan" id="kobo.10.1">, </span><span class="emphasis"><em><span class="koboSpan" id="kobo.11.1">Addison-Wesley</span></em></span><span class="koboSpan" id="kobo.12.1">. </span><span class="koboSpan" id="kobo.12.2">For an in-depth understanding of processes, threads, and the internals of operating systems, we recommend the book </span><span class="emphasis"><em><span class="koboSpan" id="kobo.13.1">Operating System Concepts</span></em></span><span class="koboSpan" id="kobo.14.1">, </span><span class="emphasis"><em><span class="koboSpan" id="kobo.15.1">Abraham Silberschatz, Peter B. </span><span class="koboSpan" id="kobo.15.2">Galvin, and Greg Gagne</span></em></span><span class="koboSpan" id="kobo.16.1">, </span><span class="emphasis"><em><span class="koboSpan" id="kobo.17.1">Wiley</span></em></span><span class="koboSpan" id="kobo.18.1">.</span></p><p><span class="koboSpan" id="kobo.19.1">In the next chapter, we will cover more advanced building blocks of concurrent programs. </span><span class="koboSpan" id="kobo.19.2">We will learn how to use executors to avoid creating threads directly, concurrent collections for thread-safe data access, and atomic variables for deadlock-free synchronization. </span><span class="koboSpan" id="kobo.19.3">These high-level abstractions will alleviate many of the problems inherent to the fundamental concurrency primitives presented in this chapter.</span></p></div></div></div>
<div id="book-columns"><div id="book-inner"><div class="section" title="Exercises"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec18"/><span class="koboSpan" id="kobo.1.1">Exercises</span></h1></div></div></div><p><span class="koboSpan" id="kobo.2.1">In the following set of exercises, you are required to implement higher-level concurrency abstractions in terms of basic JVM concurrency primitives. </span><span class="koboSpan" id="kobo.2.2">Some of these exercises introduce concurrent counterparts of sequential programming abstractions, and, in doing so, highlight important differences between sequential and concurrent programming. </span><span class="koboSpan" id="kobo.2.3">The exercises are not ordered in any particular order, but some of them rely on specific content from earlier exercises or this chapter:</span></p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem"><span class="koboSpan" id="kobo.3.1">Implement a </span><code class="literal"><span class="koboSpan" id="kobo.4.1">parallel</span></code><span class="koboSpan" id="kobo.5.1"> method, which takes two computation blocks, </span><code class="literal"><span class="koboSpan" id="kobo.6.1">a</span></code><span class="koboSpan" id="kobo.7.1"> and </span><code class="literal"><span class="koboSpan" id="kobo.8.1">b</span></code><span class="koboSpan" id="kobo.9.1">, and starts each of them in a new thread. </span><span class="koboSpan" id="kobo.9.2">The method must return a tuple with the result values of both the computations. </span><span class="koboSpan" id="kobo.9.3">It should have the following signature:</span><pre class="programlisting"><span class="koboSpan" id="kobo.10.1">            def parallel[A, B](a: =&gt;A, b: =&gt;B): (A, B) 
</span></pre></li><li class="listitem"><span class="koboSpan" id="kobo.11.1">Implement a </span><code class="literal"><span class="koboSpan" id="kobo.12.1">periodically</span></code><span class="koboSpan" id="kobo.13.1"> method, which takes a time interval </span><code class="literal"><span class="koboSpan" id="kobo.14.1">duration</span></code><span class="koboSpan" id="kobo.15.1"> specified in milliseconds, and a computation block </span><code class="literal"><span class="koboSpan" id="kobo.16.1">b</span></code><span class="koboSpan" id="kobo.17.1">. </span><span class="koboSpan" id="kobo.17.2">The method starts a thread that executes the computation block </span><code class="literal"><span class="koboSpan" id="kobo.18.1">b</span></code><span class="koboSpan" id="kobo.19.1"> every </span><code class="literal"><span class="koboSpan" id="kobo.20.1">duration</span></code><span class="koboSpan" id="kobo.21.1"> milliseconds. </span><span class="koboSpan" id="kobo.21.2">It should have the following signature:</span><pre class="programlisting"><span class="koboSpan" id="kobo.22.1">            def periodically(duration: Long)(b: =&gt;Unit): Unit 
</span></pre></li><li class="listitem"><span class="koboSpan" id="kobo.23.1">Implement a </span><code class="literal"><span class="koboSpan" id="kobo.24.1">SyncVar</span></code><span class="koboSpan" id="kobo.25.1"> class with the following interface:</span><pre class="programlisting"><span class="koboSpan" id="kobo.26.1">                class SyncVar[T] { 
                  def get(): T = ??? 
                  </span><span class="koboSpan" id="kobo.26.2">def put(x: T): Unit = ??? 
                </span><span class="koboSpan" id="kobo.26.3">} 
</span></pre><p>
</p><p><span class="koboSpan" id="kobo.27.1">A </span><code class="literal"><span class="koboSpan" id="kobo.28.1">SyncVar</span></code><span class="koboSpan" id="kobo.29.1"> object is used to exchange values between two or more threads. </span><span class="koboSpan" id="kobo.29.2">When created, the </span><code class="literal"><span class="koboSpan" id="kobo.30.1">SyncVar</span></code><span class="koboSpan" id="kobo.31.1"> object is empty:</span></p><p>
</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="koboSpan" id="kobo.32.1">Calling </span><code class="literal"><span class="koboSpan" id="kobo.33.1">get</span></code><span class="koboSpan" id="kobo.34.1"> throws an exception</span></li><li class="listitem" style="list-style-type: disc"><span class="koboSpan" id="kobo.35.1">Calling </span><code class="literal"><span class="koboSpan" id="kobo.36.1">put</span></code><span class="koboSpan" id="kobo.37.1"> adds a value to the </span><code class="literal"><span class="koboSpan" id="kobo.38.1">SyncVar</span></code><span class="koboSpan" id="kobo.39.1"> object</span></li></ul></div><p>
</p><p><span class="koboSpan" id="kobo.40.1">After a value is added to a </span><code class="literal"><span class="koboSpan" id="kobo.41.1">SyncVar</span></code><span class="koboSpan" id="kobo.42.1"> object, we say that it is non-empty:</span></p><p>
</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="koboSpan" id="kobo.43.1">Calling </span><code class="literal"><span class="koboSpan" id="kobo.44.1">get</span></code><span class="koboSpan" id="kobo.45.1"> returns the current value, and changes the state to empty</span></li><li class="listitem" style="list-style-type: disc"><span class="koboSpan" id="kobo.46.1">Calling </span><code class="literal"><span class="koboSpan" id="kobo.47.1">put</span></code><span class="koboSpan" id="kobo.48.1"> throws an exception</span></li></ul></div></li><li class="listitem"><span class="koboSpan" id="kobo.49.1">The </span><code class="literal"><span class="koboSpan" id="kobo.50.1">SyncVar</span></code><span class="koboSpan" id="kobo.51.1"> object from the previous exercise can be cumbersome to use, due to exceptions when the </span><code class="literal"><span class="koboSpan" id="kobo.52.1">SyncVar</span></code><span class="koboSpan" id="kobo.53.1"> object is in an invalid state. </span><span class="koboSpan" id="kobo.53.2">Implement a pair of methods, </span><code class="literal"><span class="koboSpan" id="kobo.54.1">isEmpty</span></code><span class="koboSpan" id="kobo.55.1"> and </span><code class="literal"><span class="koboSpan" id="kobo.56.1">nonEmpty</span></code><span class="koboSpan" id="kobo.57.1">, on the </span><code class="literal"><span class="koboSpan" id="kobo.58.1">SyncVar</span></code><span class="koboSpan" id="kobo.59.1"> object. </span><span class="koboSpan" id="kobo.59.2">Then, implement a producer thread that transfers a range of numbers </span><code class="literal"><span class="koboSpan" id="kobo.60.1">0 until 15</span></code><span class="koboSpan" id="kobo.61.1"> to the consumer thread that prints them.</span></li><li class="listitem"><span class="koboSpan" id="kobo.62.1">Using the </span><code class="literal"><span class="koboSpan" id="kobo.63.1">isEmpty</span></code><span class="koboSpan" id="kobo.64.1"> and </span><code class="literal"><span class="koboSpan" id="kobo.65.1">nonEmpty</span></code><span class="koboSpan" id="kobo.66.1"> pair of methods from the previous exercise requires busy-waiting. </span><span class="koboSpan" id="kobo.66.2">Add the following methods to the </span><code class="literal"><span class="koboSpan" id="kobo.67.1">SyncVar</span></code><span class="koboSpan" id="kobo.68.1"> class:</span><pre class="programlisting"><span class="koboSpan" id="kobo.69.1">            def getWait(): T 
            def putWait(x: T): Unit 
</span></pre><p>
</p><p><span class="koboSpan" id="kobo.70.1">These methods have similar semantics as before, but go into the waiting state instead of throwing an exception, and return once the </span><code class="literal"><span class="koboSpan" id="kobo.71.1">SyncVar</span></code><span class="koboSpan" id="kobo.72.1"> object is empty or non-empty, respectively.</span></p></li><li class="listitem"><span class="koboSpan" id="kobo.73.1">A </span><code class="literal"><span class="koboSpan" id="kobo.74.1">SyncVar</span></code><span class="koboSpan" id="kobo.75.1"> object can hold at most one value at a time. </span><span class="koboSpan" id="kobo.75.2">Implement a </span><code class="literal"><span class="koboSpan" id="kobo.76.1">SyncQueue</span></code><span class="koboSpan" id="kobo.77.1"> class, which has the same interface as the </span><code class="literal"><span class="koboSpan" id="kobo.78.1">SyncVar</span></code><span class="koboSpan" id="kobo.79.1"> class, but can hold at most </span><code class="literal"><span class="koboSpan" id="kobo.80.1">n</span></code><span class="koboSpan" id="kobo.81.1"> values. </span><span class="koboSpan" id="kobo.81.2">The </span><code class="literal"><span class="koboSpan" id="kobo.82.1">n</span></code><span class="koboSpan" id="kobo.83.1"> parameter is specified in the constructor of the </span><code class="literal"><span class="koboSpan" id="kobo.84.1">SyncQueue</span></code><span class="koboSpan" id="kobo.85.1"> class.</span></li><li class="listitem"><span class="koboSpan" id="kobo.86.1">The </span><code class="literal"><span class="koboSpan" id="kobo.87.1">send</span></code><span class="koboSpan" id="kobo.88.1"> method in the </span><span class="emphasis"><em><span class="koboSpan" id="kobo.89.1">Deadlocks</span></em></span><span class="koboSpan" id="kobo.90.1"> section was used to transfer money between the two accounts. </span><span class="koboSpan" id="kobo.90.2">The </span><code class="literal"><span class="koboSpan" id="kobo.91.1">sendAll</span></code><span class="koboSpan" id="kobo.92.1"> method takes a set </span><code class="literal"><span class="koboSpan" id="kobo.93.1">accounts</span></code><span class="koboSpan" id="kobo.94.1"> of bank accounts and a </span><code class="literal"><span class="koboSpan" id="kobo.95.1">target</span></code><span class="koboSpan" id="kobo.96.1"> bank account, and transfers all the money from every account in </span><code class="literal"><span class="koboSpan" id="kobo.97.1">accounts</span></code><span class="koboSpan" id="kobo.98.1"> to the </span><code class="literal"><span class="koboSpan" id="kobo.99.1">target</span></code><span class="koboSpan" id="kobo.100.1"> bank account. </span><span class="koboSpan" id="kobo.100.2">The </span><code class="literal"><span class="koboSpan" id="kobo.101.1">sendAll</span></code><span class="koboSpan" id="kobo.102.1"> method has the following signature:</span><pre class="programlisting"><span class="koboSpan" id="kobo.103.1">            def sendAll(accounts: Set[Account], target: Account): Unit 
</span></pre><p>
</p><p><span class="koboSpan" id="kobo.104.1">Implement the </span><code class="literal"><span class="koboSpan" id="kobo.105.1">sendAll</span></code><span class="koboSpan" id="kobo.106.1"> method and ensure that a deadlock cannot occur.</span></p></li><li class="listitem"><span class="koboSpan" id="kobo.107.1">Recall the </span><code class="literal"><span class="koboSpan" id="kobo.108.1">asynchronous</span></code><span class="koboSpan" id="kobo.109.1"> method from the </span><span class="emphasis"><em><span class="koboSpan" id="kobo.110.1">Guarded blocks</span></em></span><span class="koboSpan" id="kobo.111.1"> section. </span><span class="koboSpan" id="kobo.111.2">This method stores the tasks in a </span><span class="strong"><strong><span class="koboSpan" id="kobo.112.1">First In First Out</span></strong></span><span class="koboSpan" id="kobo.113.1"> (</span><span class="strong"><strong><span class="koboSpan" id="kobo.114.1">FIFO</span></strong></span><span class="koboSpan" id="kobo.115.1">) queue; before a submitted task is executed, all the previously submitted tasks need to be executed. </span><span class="koboSpan" id="kobo.115.2">In some cases, we want to assign priorities to tasks so that a high-priority task can execute as soon as it is submitted to the task pool. </span><span class="koboSpan" id="kobo.115.3">Implement a </span><code class="literal"><span class="koboSpan" id="kobo.116.1">PriorityTaskPool</span></code><span class="koboSpan" id="kobo.117.1"> class that has the </span><code class="literal"><span class="koboSpan" id="kobo.118.1">asynchronous</span></code><span class="koboSpan" id="kobo.119.1"> method with the following signature:</span><pre class="programlisting"><span class="koboSpan" id="kobo.120.1">            def asynchronous(priority: Int)(task: =&gt;Unit): Unit 
</span></pre><p>
</p><p><span class="koboSpan" id="kobo.121.1">A single worker thread picks tasks submitted to the pool and executes them. </span><span class="koboSpan" id="kobo.121.2">Whenever the worker thread picks a new task from the pool for execution, that task must have the highest priority in the pool.</span></p></li><li class="listitem"><span class="koboSpan" id="kobo.122.1">Extend the </span><code class="literal"><span class="koboSpan" id="kobo.123.1">PriorityTaskPool</span></code><span class="koboSpan" id="kobo.124.1"> class from the previous exercise so that it supports any number of worker threads </span><code class="literal"><span class="koboSpan" id="kobo.125.1">p</span></code><span class="koboSpan" id="kobo.126.1">. </span><span class="koboSpan" id="kobo.126.2">The parameter </span><code class="literal"><span class="koboSpan" id="kobo.127.1">p</span></code><span class="koboSpan" id="kobo.128.1"> is specified in the constructor of the </span><code class="literal"><span class="koboSpan" id="kobo.129.1">PriorityTaskPool</span></code><span class="koboSpan" id="kobo.130.1"> class.</span></li><li class="listitem"><span class="koboSpan" id="kobo.131.1">Extend the </span><code class="literal"><span class="koboSpan" id="kobo.132.1">PriorityTaskPool</span></code><span class="koboSpan" id="kobo.133.1"> class from the previous exercise so that it supports the </span><code class="literal"><span class="koboSpan" id="kobo.134.1">shutdown</span></code><span class="koboSpan" id="kobo.135.1"> method:</span><pre class="programlisting"><span class="koboSpan" id="kobo.136.1">            def shutdown(): Unit 
</span></pre><p>
</p><p><span class="koboSpan" id="kobo.137.1">When the </span><code class="literal"><span class="koboSpan" id="kobo.138.1">shutdown</span></code><span class="koboSpan" id="kobo.139.1"> method is called, all the tasks with the priorities greater than </span><code class="literal"><span class="koboSpan" id="kobo.140.1">important</span></code><span class="koboSpan" id="kobo.141.1"> must be completed, and the rest of the tasks must be discarded. </span><span class="koboSpan" id="kobo.141.2">The </span><code class="literal"><span class="koboSpan" id="kobo.142.1">important</span></code><span class="koboSpan" id="kobo.143.1"> integer parameter is specified in the constructor of the </span><code class="literal"><span class="koboSpan" id="kobo.144.1">PriorityTaskPool</span></code><span class="koboSpan" id="kobo.145.1"> class.</span></p></li><li class="listitem"><span class="koboSpan" id="kobo.146.1">Implement a </span><code class="literal"><span class="koboSpan" id="kobo.147.1">ConcurrentBiMap</span></code><span class="koboSpan" id="kobo.148.1"> collection, which is a concurrent bidirectional map. </span><span class="koboSpan" id="kobo.148.2">The invariant is that every key is mapped to exactly one value, and vice versa. </span><span class="koboSpan" id="kobo.148.3">Operations must be atomic. </span><span class="koboSpan" id="kobo.148.4">The concurrent bidirectional map has the following interface:</span><pre class="programlisting"><span class="koboSpan" id="kobo.149.1">            class ConcurrentBiMap[K, V] { 
              def put(k: K, v: V): Option[(K, V) 
              def removeKey(k: K): Option[V] 
              def removeValue(v: V): Option[K] 
              def getValue(k: K): Option[V] 
              def getKey(v: V): Option[K] 
              def size: Int 
              def iterator: Iterator[(K, V)] 
            } 
</span></pre><p>
</p><p><span class="koboSpan" id="kobo.150.1">Make sure that your implementation prevents deadlocks from occurring in the map.</span></p></li><li class="listitem"><span class="koboSpan" id="kobo.151.1">Add a </span><code class="literal"><span class="koboSpan" id="kobo.152.1">replace</span></code><span class="koboSpan" id="kobo.153.1"> method to the concurrent bidirectional map from the previous exercise. </span><span class="koboSpan" id="kobo.153.2">The method should atomically replace a key-value pair with another key-value pair:</span><pre class="programlisting"><span class="koboSpan" id="kobo.154.1">            def replace(k1: K, v1: V, k2: K, v2: V): Unit 
</span></pre></li><li class="listitem"><span class="koboSpan" id="kobo.155.1">Test the implementation of the concurrent bidirectional map from the earlier exercise by creating a test in which several threads concurrently insert millions of key-value pairs into the map. </span><span class="koboSpan" id="kobo.155.2">When all of them complete, another batch of threads must concurrently invert the entries in the map - for any key-value pair </span><code class="literal"><span class="koboSpan" id="kobo.156.1">(k1, k2)</span></code><span class="koboSpan" id="kobo.157.1">, the thread should replace it with a key-value pair </span><code class="literal"><span class="koboSpan" id="kobo.158.1">(k2, k1)</span></code><span class="koboSpan" id="kobo.159.1">.</span></li><li class="listitem"><span class="koboSpan" id="kobo.160.1">Implement a </span><code class="literal"><span class="koboSpan" id="kobo.161.1">cache</span></code><span class="koboSpan" id="kobo.162.1"> method, which converts any function into a memoized version of itself. </span><span class="koboSpan" id="kobo.162.2">The first time that the resulting function is called for any argument, it is called in the same way as the original function. </span><span class="koboSpan" id="kobo.162.3">However, the result is memoized, and subsequently invoking the resulting function with the same arguments must return the previously returned value:</span><pre class="programlisting"><span class="koboSpan" id="kobo.163.1">            def cache[K, V](f: K =&gt; V): K =&gt; V 
</span></pre></li></ol></div><p><span class="koboSpan" id="kobo.164.1">Make sure that your implementation works correctly when the resulting function is called simultaneously from multiple threads.</span></p></div></div></div></body></html>