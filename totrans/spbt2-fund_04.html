<html><head></head><body><div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">The MVC Pattern</h1>
                </header>
            
            <article>
                
<p class="mce-root">Today, we will learn how to build a web-based application in Spring that uses web pages to interact with the user. As an example, we will be using a simple blog application. For that, we will first look at the Model–View–Controller (MVC) design pattern and how we can benefit from it.</p>
<p class="mce-root">The MVC design pattern is a very commonly used application design model. This model breaks an application into three interconnected parts. This is done to reduce the time taken to create object-oriented applications that have user interfaces. This model allows for the decoupling of the different models, views, and controllers, thereby facilitating the reuse of code and the simultaneous development of different sections of the application.</p>
<p>By the end of this chapter, you will be able to:</p>
<ul>
<li>Define the Model–View–Controller (MVC) pattern and its benefits</li>
<li>Explain the role of the model, the view, and the controller</li>
<li>Distinguish between a request-based and a component-based MVC</li>
<li>Construct your first real-life Spring Web MVC application</li>
</ul>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Introducing the MVC Pattern</h1>
                </header>
            
            <article>
                
<p>When web applications are built with a <strong>User Interface</strong> (<strong>UI</strong>), it can be cumbersome to develop the application when multiple developers are involved. In addition, maintenance can be difficult if too many concerns are mixed in parts of the written code.</p>
<p>A design pattern called MVC solves that problem. By separating the concerns for rendering and manipulating application data, it allows multiple programmers of a team to work on different aspects of the application in parallel. While one developer concentrates on the view, another one is able to implement the business logic.</p>
<div class="packt_infobox"><br/>
There are also patterns to solve common software development problems. A popular set of these patterns has been introduced in the book <em>Design Patterns: Elements of Reusable Object-Oriented Software</em>, by Erich Gamma, Richard Helm, Ralph Johnson, and John Vlissides.<br/>
If you're interested in the history of the MVC pattern, you can still find the original description of the MVC pattern on the pages of Trygve M H Reenskaug at <a href="https://heim.ifi.uio.no/~trygver/themes/mvc/mvc-index.html">https://heim.ifi.uio.no/~trygver/themes/mvc/mvc-index.html</a>. Additionally, the original MVC reports are available at <a href="http://folk.uio.no/trygver/2007/MVC_Originals.pdf">http://folk.uio.no/trygver/2007/MVC_Originals.pdf</a>.</div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">The MVC Components</h1>
                </header>
            
            <article>
                
<p>The three components that are defined are as follows:</p>
<ul>
<li><strong>Model</strong>: The application state or data.</li>
<li><strong>View</strong>: Renders the application data.</li>
<li><strong>Controller</strong>: Mediates between model, view, and the outside world.</li>
</ul>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Comparing Model, View, and Controller</h1>
                </header>
            
            <article>
                
<p>Take a look at the following table, which highlights the main concepts:</p>
<div class="packt_figref CDPAlignCenter CDPAlign"><img src="Images/1613014f-6d55-4bdc-abb1-b62da0c71a1c.png" style="width:29.08em;height:25.75em;" width="848" height="749"/></div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Interacting</h1>
                </header>
            
            <article>
                
<p>Now that we have learnt about the MVC components, let's take a look at how they interact with one another:</p>
<div class="packt_figref CDPAlignCenter CDPAlign"><img src="Images/2fa1d4b8-fa5d-453d-ac6c-fecfcdece32b.png" style="width:22.75em;height:20.50em;" width="1273" height="1150"/></div>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>
<p>A typical interaction consists of the following steps:</p>
<ul>
<li>The client makes a request to the controller.</li>
<li>The controller manipulates the model.</li>
<li>The model updates the view.</li>
<li>The view is rendered and sent to the client.</li>
</ul>
<p>These steps illustrate the separation of concerns, as each component has a very well-defined task to accomplish.</p>
<p>MVC uses another design pattern called the <strong>observer pattern</strong>. It describes how a subject (the model) will update a number of observers (the view or parts of it) about changes that have been made.</p>
<div class="packt_infobox"><br/>
If you want to learn more about the observer pattern, you can find more information in the book <em>Design Patterns: Elements of Reusable Object-Oriented Software</em>, which we mentioned previously. Another good starting point is the entry about this pattern at <a href="https://springframework.guru/gang-of-four-designpatterns/observer-pattern/">https://springframework.guru/gang-of-four-designpatterns/observer-pattern/</a>.</div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Advantages and Disadvantages of the MVC Pattern</h1>
                </header>
            
            <article>
                
<p>The advantages of the MVC pattern include the following:</p>
<ul>
<li><strong>Simultaneous development</strong>: Interfaces are well-defined and leverage developers with different skills.</li>
<li><strong>High cohesion</strong>: Groups code that belongs together and that helps with maintenance, improvement, and refactoring.</li>
<li><strong>Multiple views</strong>: Implements separate views for different media and keeps a single implementation of business logic.</li>
<li><strong>Loosely coupled</strong>: Only a small amount of knowledge is shared between components, and changes can be restricted to isolated parts of the implementation.</li>
</ul>
<p>The disadvantages of the MVC pattern include the following:</p>
<ul>
<li><strong>Navigating through the source code</strong>: Source code can become very scattered.</li>
<li><strong>Multiple implementations</strong>: Developers have to keep track of multiple implementations.</li>
<li><strong>Understanding the pattern</strong>: Developers have to understand the pattern.</li>
</ul>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Request-Based versus Component-Based MVC</h1>
                </header>
            
            <article>
                
<p>There are different ways to implement the MVC pattern.</p>
<p>In the request-based MVC approach, the developer has to handle the incoming requests themselves. This means that data has to be converted and validated manually.</p>
<p>On the other hand, in a component-based MVC application, the framework will take care of the processing and builds components that resemble the parts rendered by the view:</p>
<div class="packt_figref CDPAlignCenter CDPAlign"><img src="Images/49cd8c7a-41d9-4c46-87b1-a718a34211c9.png" style="width:36.67em;height:12.58em;" width="870" height="299"/></div>
<div class="packt_infobox"><br/>
While the request-based MVC architecture requires a lot of boilerplate code, it gives you fine control over the whole process and output. When you have very complex requirements to your view, this approach may be the right choice.</div>
<p>On the other hand, the request-based approach introduces more complexity, while the component-based method raises the developer's burden of component customization.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Spring Web MVC Basics</h1>
                </header>
            
            <article>
                
<p>Now that we have learnt about the Model–View–Controller pattern, we will now take a look at how Spring Web MVC leverages this pattern to enable the development of web applications.</p>
<p>When we talk about web applications, we usually mean that the view is rendered in a browser. But before getting into the details, we will have a short discussion about two different ways that such a front-end can be implemented.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Single-Page Applications Versus Multi-Page Applications</h1>
                </header>
            
            <article>
                
<p>There are different ways to implement the client side of a web application that is also called the "frontend". The most commonly used architectures today are <strong>S<span>ingle-Page</span><span> </span><span>A</span></strong><span><strong>pplications</strong> (<strong>SPA</strong>). Requests only change parts of the view.</span></p>
<p>In contrast, <strong>Multi-Page Applications</strong> (<strong>MPA</strong>) render a new page for every request.</p>
<p>In an MPA, the HTML of the view gets rendered on the server and is then sent back to the browser. Each action taken by the user results in a request made to the server, which responds with another full page or view.</p>
<p class="mce-root"/>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">SPA versus MPA</h1>
                </header>
            
            <article>
                
<p>Take a look at the following table that highlights the main concepts:</p>
<div class="packt_figref CDPAlignCenter CDPAlign"><img src="Images/98401246-5187-439b-b3d6-59a5296af0d0.png" style="width:34.58em;height:27.67em;" width="811" height="648"/></div>
<div class="packt_figref CDPAlignCenter CDPAlign"><img src="Images/c130cbc5-45db-4194-83dd-5f08ac2842ae.png" style="width:34.50em;height:10.67em;" width="840" height="260"/></div>
<p>In this chapter, we will be focusing on how to build a multi-page application. Next, you will get to know how to architect and implement an API that can build the back-end side of an SPA.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Java Servlet API</h1>
                </header>
            
            <article>
                
<p>We will now discover the Java Servlet API that builds an important foundation for any kind of web application in the Java ecosystem.</p>
<p>Depending on the level of knowledge, you may choose to focus on this sub-section or go ahead to the next one.</p>
<p>The Java Servlet API is an architecture that aims to process HTTP requests that are made to a so-called container. It is developed under the <strong>Java Community Process</strong> (<strong>JCP</strong>) and is currently available in Version 4.0.</p>
<p>Popular containers that follow this specification are Apache Tomcat and Jetty.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Servlet API Components</h1>
                </header>
            
            <article>
                
<p>The following block diagram shows a typical relationship among the various components:</p>
<div class="packt_figref CDPAlignCenter CDPAlign"><img src="Images/59d3414e-4c34-4077-9920-b6f92a9affcf.png" style="width:43.00em;height:26.92em;" width="1218" height="762"/></div>
<p>Take a look at the following table, which highlights the main concepts:</p>
<div class="packt_figref CDPAlignCenter CDPAlign"><img src="Images/ab9d0b47-e1ed-4f67-bbe8-38c7782486ea.png" style="width:42.92em;height:49.75em;" width="669" height="775"/></div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Spring Web MVC</h1>
                </header>
            
            <article>
                
<p>As we have been looking at all the basic patterns and technologies that are required to build and understand a working web application, we are now going to see how all of this can be applied to a Spring Boot application.</p>
<p>Spring Boot uses "starter dependencies" to add various features and capabilities to an application. In our case, we want to implement a web application that will require a web server to run. We also need support for the MVC pattern. The Spring Framework includes all that is required for building rich and modern web applications based on the MVC design pattern.</p>
<p>To leverage these features, all that is required is to include the spring-boot-starter-web dependency in our Maven <kbd>pom.xml</kbd> file.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Utilizing Spring Web MVC Starter</h1>
                </header>
            
            <article>
                
<p>The aim is to display an output on the web page using Spring Web MVC Starter. The steps for completion are as follows:</p>
<ol>
<li>Open a CMD window and navigate to <a href="https://bit.ly/2DmTaQA">https://bit.ly/2DmTaQA</a>.</li>
<li>Make sure that your <kbd>JAVA_HOME</kbd> path is set correctly and start the project using the <kbd>mvnw spring-boot:run</kbd> command.</li>
</ol>
<p>Take a look at the following screenshot:</p>
<div class="packt_figref CDPAlignCenter CDPAlign"><img src="Images/f27559f7-b5e2-4bee-a3d5-cede5a82ae80.png" style="width:43.08em;height:20.25em;" width="848" height="397"/></div>
<div class="packt_infobox"><br/>
Notice the application stopping immediately after startup.</div>
<ol start="3">
<li>Navigate the browser to <kbd>http://localhost:8080/hello.html</kbd>.</li>
</ol>
<p style="padding-left: 60px">  Take a look at the following screenshot:</p>
<div class="packt_figref CDPAlignCenter CDPAlign"><img src="Images/5d450b7e-c18c-4e13-ac87-ee448f3638f5.png" style="width:61.17em;height:43.92em;" width="687" height="493"/></div>
<div class="packt_infobox"><br/>
The browser cannot connect to the server and therefore displays an error page.</div>
<ol start="4">
<li>Add the following dependency to your <kbd>pom.xml</kbd> file:</li>
</ol>
<pre style="padding-left: 60px">&lt;dependency&gt;<br/>    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;<br/>    &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;<br/>&lt;/dependency&gt;</pre>
<ol start="5">
<li>Start the project again.</li>
<li>Navigate to <kbd>http://localhost:8080/hello.html</kbd> to see a greeting page.</li>
<li>Press <span class="packt_screen">Ctrl+C</span> to stop the program. You can safely ignore the error message here.</li>
</ol>
<p>You have obtained the expected greeting page using Spring Web MVC Starter.</p>
<p>Take a look at the following output screenshot:</p>
<div class="packt_figref CDPAlignCenter CDPAlign"><img src="Images/239a6f9e-966e-4f56-a603-043a0a905570.png" style="width:71.25em;height:26.83em;" width="642" height="242"/></div>
<div class="packt_infobox"><br/>
Go to <a href="https://bit.ly/2OfiTwW">https://bit.ly/2OfiTwW</a> to access the code for the <kbd>WebstarterExerciseApplication.java</kbd> file.</div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">The Embedded Web Server</h1>
                </header>
            
            <article>
                
<p>Thanks to the auto-configuration features of Spring Boot, the only thing you have to do is add the spring-boot-starter-web dependency to your Maven build file. By default, this will add an embedded Apache Tomcat server to your build. It will also build an executable JAR file that will start the server and deploy your application to it.</p>
<p>If you prefer to use a different web server, you can choose to do so by excluding the spring-boot-starter-tomcat dependency and add one of the following dependencies instead:</p>
<div class="packt_figref CDPAlignCenter CDPAlign"><img src="Images/c5f3b11d-a2b6-416e-8ab5-0a47d4cfcd73.png" style="width:44.08em;height:8.33em;" width="827" height="155"/></div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Spring DispatcherServlet</h1>
                </header>
            
            <article>
                
<p>Spring Web MVC handles incoming requests by providing a servlet called <kbd>DispatcherServlet</kbd>. It is also called a <strong>Front Controller</strong> since it is the first part of the controller that handles incoming requests and dispatches them to other controller implementations.</p>
<div class="packt_infobox"><br/>
By default, the <kbd>DispatcherServlet</kbd> will be called for every request that is made to a URL starting with <kbd>/</kbd>. You can change this so-called context path by setting the <kbd>server.servlet.contextPath</kbd> property in the application.properties file:<br/>
<br/>
<kbd>server.servlet.contextPath=/my-app</kbd><br/>
<br/>
In the preceding example, the <kbd>DispatcherServlet</kbd>, and thus your application, will only respond to URLs starting with <kbd>/my-app</kbd>.</div>
<p class="mce-root"/>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">DispatcherServlet Interaction</h1>
                </header>
            
            <article>
                
<p>The following block diagram shows a typical relationship among the various components:</p>
<div class="packt_figref CDPAlignCenter CDPAlign"><img src="Images/36a3b584-6b32-4dfb-a664-fb06f0d097a9.png" style="width:38.83em;height:26.17em;" width="1436" height="970"/></div>
<p>The <kbd>DispatcherServlet</kbd> does all the heavy lifting when it comes to handling incoming requests:</p>
<ul>
<li>Determines which controller to call depending on the request URI. For this, it uses a <kbd>HandlerMapping</kbd> that is able to retrieve the controller.</li>
<li>Calls the controller method, optionally passing in the model</li>
<li>When the controller has finished, it returns the name of a view</li>
<li>Determines the view based on the name returned from the controller</li>
<li>Resolves the view</li>
<li>Renders the view back to the client, passing in the model to be rendered</li>
</ul>
<p>This is a very simple view on what takes place for incoming requests. We will get into more detail later when we look at some of these components.</p>
<p class="mce-root"/>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Controller as Components</h1>
                </header>
            
            <article>
                
<p>While the <kbd>DispatcherServlet</kbd> is the front controller of the application responding to each incoming request, the business logic is implemented in its own method.</p>
<p>As we have discussed in the previous section, a <kbd>HandlerMapper</kbd> is used to map the request.</p>
<p>By default, a <kbd>RequestMappingHandlerMapping</kbd> is installed, which finds methods annotated with <kbd>@RequestMapping</kbd> contained within Spring components annotated with <kbd>@Controller</kbd>. We will learn more about this kind of mapping in a later chapter.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Static Views with HTML and Assets</h1>
                </header>
            
            <article>
                
<p>Every web application will require some kind of static view or asset. Take an "About" page, for example. However, since you cannot embed data from your model into this kind of page, you may not have much use for them. On the other hand, you will be required to serve some kind of static assets such as CSS files, JavaScript, or images. Spring Web MVC is able to serve this kind of content that is placed in a folder called <kbd>static</kbd>. If you're using a build tool such as Maven or Gradle, as we do, the full path will be <kbd>/src/main/resources/static</kbd> from the project root.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Adding Client-Side Web Libraries Through WebJars</h1>
                </header>
            
            <article>
                
<p>Besides using the static folder to provide static assets, there is another mechanism called WebJars.</p>
<p>A <strong>WebJar</strong> is a client-side web library packed as a Java-Archive. Examples of these libraries include JQuery for common JavaScript tasks related to web pages, or <strong>Bootstrap</strong>, a library to build responsive web designs. It can be easily downloaded and deployed as a dependency when using a build tool such as Maven. In addition, transitive dependencies will also be downloaded and provided automatically.</p>
<p>The content structure of a WebJar archive is standardized and includes folder structure as well as certain files that need to be present.</p>
<p class="mce-root"/>
<p>If a WebJar is present on the classpath, Spring Boot will configure your application to map HTTP requests to <kbd>/webjars to the /META-INF/resources/webjars</kbd> folder.</p>
<p>If you include multiple WebJars in your classpath, they will all be available under the same <kbd>/webjars URI</kbd>.</p>
<p>For example, you can include the WebJar of Bootstrap by adding the following dependency to your <kbd>pom.xml</kbd> file:</p>
<pre>&lt;dependency&gt;<br/>    &lt;groupId&gt;org.webjars&lt;/groupId&gt;<br/>    &lt;artifactId&gt;bootstrap&lt;/artifactId&gt;<br/>    &lt;version&gt;4.0.0-2&lt;/version&gt;<br/>&lt;/dependency&gt;</pre>
<p>To access the main CSS file for this library, include the following line in your HTML file:</p>
<pre>&lt;link rel='stylesheet' href='/webjars/bootstrap/4.0.0-2/css/<br/>bootstrap.min.css'&gt;</pre>
<p>As you can see, the library is referenced under the <kbd>/webjars</kbd> folder by its name (bootstrap). After this, the version number is added, followed by the path to the required resource, which depends on the library.</p>
<p>If you don't want to add the library version to the URI, you can add the <kbd>webjar-locator</kbd> dependency to your <kbd>pom.xml</kbd> file:</p>
<pre>&lt;dependency&gt;<br/>    &lt;groupId&gt;org.webjars&lt;/groupId&gt;<br/>    &lt;artifactId&gt;webjars-locator-core&lt;/artifactId&gt;<br/>&lt;/dependency&gt;</pre>
<p>With this dependency in place, you can change the link tag in your HTML file to the following:</p>
<pre>&lt;link rel='stylesheet' href='/webjars/bootstrap/css/bootstrap.min.<br/>css'&gt;</pre>
<p>Please note that after adding the webjars-locator, the mapping for static files in the <kbd>/static</kbd> folder will no longer work.</p>
<div class="packt_infobox"><br/>
If you want to learn more about the WebJar standard, visit <a href="http://www.webjars.org">http://www.webjars.org</a> to find an exhaustive list of libraries including a search engine and snippets generator. There is also more information about the standard and its application in the documentation available on this site.</div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Styling with Bootstrap</h1>
                </header>
            
            <article>
                
<p>The aim is to style a page using Bootstrap and WebJar. <span>The steps for completion are as follows:</span></p>
<ol>
<li>Go to the folder present at <a href="https://bit.ly/2z8QQd6">https://bit.ly/2z8QQd6</a><a href="https://bit.ly/2z8QQd6">.</a></li>
<li>Start the application with <kbd>mvnw spring-boot:run</kbd>.</li>
<li>Navigate the browser to <kbd>http://localhost:8080/hello.html</kbd>.</li>
</ol>
<div class="packt_infobox"><br/>
Notice that the page is unstyled.</div>
<ol start="4">
<li>Navigate the browser to <kbd>http://localhost:8080/webjars/bootstrap/4.0.0-2/css/bootstrap.css</kbd>.</li>
</ol>
<div class="packt_infobox"><br/>
The browser will show an error page, since the resource is missing (<strong>errorCode=404</strong>).</div>
<ol start="5">
<li>Add the following dependency to include the Bootstrap WebJar:</li>
</ol>
<pre style="padding-left: 60px">&lt;dependency&gt;<br/>    &lt;groupId&gt;org.webjars&lt;/groupId&gt;<br/>    &lt;artifactId&gt;bootstrap&lt;/artifactId&gt;<br/>    &lt;version&gt;4.0.0-2&lt;/version&gt;<br/>&lt;/dependency&gt;</pre>
<ol start="6">
<li>Restart the application.</li>
<li>Navigate the browser to <kbd>http://localhost:8080/welcome.html</kbd> again.</li>
</ol>
<div class="packt_infobox"><br/>
The page now has some styling applied to it.</div>
<ol start="8">
<li>Navigate the browser to <kbd>http://localhost:8080/webjars/bootstrap/4.0.0-2/css/bootstrap.css</kbd>.</li>
</ol>
<div class="packt_infobox"><br/>
Instead of the error page, you should now see some CSS.</div>
<p>You will notice that you now have added styling to the web page using Bootstrap and WebJar.</p>
<div class="packt_infobox"><br/>
Go to <a href="https://bit.ly/2Obb4Il">https://bit.ly/2Obb4Il</a> to access the code for the <kbd>WebstarterExerciseApplication.java</kbd> file.</div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Transforming the Template Engine</h1>
                </header>
            
            <article>
                
<p>The following block diagram shows a typical relationship among the various components:</p>
<div class="packt_figref CDPAlignCenter CDPAlign"><img src="Images/6648d38f-798c-4374-a7c6-2988cadbdfcc.png" style="width:15.17em;height:19.83em;" width="491" height="640"/></div>
<p>In web applications, we expect views to be rendered as HTML pages. As the MVC pattern encourages us to separate the model from the view, there has to be an entity that transforms our model data into the final representation.</p>
<p>This is where a template engine comes into play. As the name suggests, a template engine will take a template containing HTML with placeholders for the data derived from the model. It will then render the final HTML that gets sent to the client.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Thymeleaf Snippet</h1>
                </header>
            
            <article>
                
<p>The following block diagram shows a typical relationship among the various components:</p>
<div class="packt_figref CDPAlignCenter CDPAlign"><img src="Images/60e039c9-219b-4787-8484-bb47353d19a8.png" width="574" height="266"/></div>
<p>As an example, imagine the following code snippet:</p>
<pre>&lt;p th:text="${hello}"&gt;Text will be replaced&lt;/p&gt;</pre>
<p>If our model contains an attribute called hello with the content Good Morning!, the template engine will render the following HTML code:</p>
<pre>&lt;p&gt;Good Morning!&lt;/p&gt;</pre>
<p>As with other frameworks, Spring Boot offers an easy way to add a template engine to your application.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Passing Data Along with Models</h1>
                </header>
            
            <article>
                
<p>As we've seen, an element called <kbd>model</kbd> is used to pass data between the controller and the view. Spring Web MVC is automatically passing the model between these components and provides many mechanisms to access and bind attributes. In addition, a lot of basic tasks such as conversion and validation are done by the framework.</p>
<p>The model is bound to the current request and represented by an instance of the <kbd>org.springframework.ui.Model</kbd> class. Any object can be bound to the model. It's also possible to bind individual attributes of the model to method parameters when using annotated request handlers.</p>
<p>We will see how to use the model in <em><a href="ae829ce0-b16f-454e-84c9-37eb73bc9de5.xhtml">Chapter 5</a>: Displaying Information Using Web Pages</em>, when we display dynamic information on web pages.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Spring Web MVC Controller</h1>
                </header>
            
            <article>
                
<p>We will now see what Spring Web MVC includes, allowing us to implement the controllers of our application. The framework handles incoming requests and thus allows us to concentrate on the business logic.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">The @RequestMapping Annotation</h1>
                </header>
            
            <article>
                
<p>We have seen that the <kbd>DispatcherServlet</kbd> uses a <kbd>HandlerMapping</kbd> to determine how incoming requests are handled.</p>
<p>By default, Spring Web MVC will install and use a <kbd>RequestMappingHandlerMapping</kbd> that allows us to use annotations to determine which controller and method to use.</p>
<p>The following block diagram shows a typical relationship between the various components:</p>
<div class="packt_figref CDPAlignCenter CDPAlign"><img src="Images/43043db1-d375-4532-9f84-05772aa85cca.png" style="width:39.67em;height:22.25em;" width="1317" height="740"/></div>
<p class="mce-root"/>
<p class="mce-root"/>
<p>Any component will be inspected for a <kbd>@RequestMapping</kbd> annotation. If this annotation is present, a mapping will be created depending on the path attribute. In addition, the method annotation specifies the HTTP method for the mapping. To make it more obvious that the given Bean is meant to be a controller, there is a special <kbd>@Controller</kbd> annotation that can be used on the class.</p>
<p>Since Spring 4.3, there have been convenience annotations for each HTTP method. These annotations are called <kbd>@GetMapping</kbd>, <kbd>@PostMapping</kbd>, and so on.</p>
<p>If the <kbd>@RequestMapping</kbd> annotation is present on the class level, it is used as a prefix for all methods that are annotated with <kbd>@RequestMapping</kbd> or any of the method-specific annotations:</p>
<pre>@Controller<br/>@RequestMapping("/posts")<br/>public class RequestMappingPostController {<br/>    @RequestMapping(path = "/newest", method = RequestMethod.GET)<br/>    // […]<br/>    //     public String addPost(@RequestBody Post post) {<br/>        // This method will be mapped to<br/>        // POST requests with the path /posts<br/>    }<br/>}</pre>
<div class="packt_infobox"><br/>
Go to <a href="https://bit.ly/2MsHOvc">https://bit.ly/2MsHOvc</a> to access the complete code for the <kbd>@RequestMapping</kbd> annotation example.</div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Additional Annotations and Parameters for Handler Methods</h1>
                </header>
            
            <article>
                
<p>There are additional annotations that can be applied to a handler method. We will take a look at the most important parameters here.</p>
<p class="mce-root"/>
<p class="mce-root"/>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">@RequestParam</h1>
                </header>
            
            <article>
                
<p>A request that is sent to the application can contain any number of parameters in the query. The parameters are delimited from the path by a question mark (<kbd>?</kbd>). These parameters are parsed automatically and can be passed to the handler method by using the <kbd>@RequestParam</kbd> annotation. If required, the value will be converted:</p>
<pre>@GetMapping("/form")<br/>public String setupForm(@RequestParam("formId") int formId) {<br/>  // When requesting /form?formId=1<br/>  // formId will get the value 1<br/>}</pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">@RequestHeader</h1>
                </header>
            
            <article>
                
<p>The <kbd>@RequestHeader</kbd> annotation allows you to inject one or more HTTP headers into method parameters. This is done by annotating one or more method parameters with <kbd>@RequestHeader</kbd>:</p>
<pre>Host                     localhost:8080<br/>Accept                   text/html,application/<br/>xhtml+xml,application/xml;q=0.9<br/>Accept-Language          fr,en-gb;q=0.7,en;q=0.3<br/>Accept-Encoding          gzip,deflate<br/>Accept-Charset           ISO-8859-1,utf-8;q=0.7,*;q=0.7<br/>Keep-Alive               300<br/>@GetMapping("/form")<br/>public String setupForm(@RequestHeader("Keep-Alive") long<br/>keepAlive) {<br/>  // keepAlive will get the value 300<br/>}</pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">@CookieValue</h1>
                </header>
            
            <article>
                
<p>This annotation allows you to retrieve the content of cookies:</p>
<pre>JSESSIONID=2388923038849<br/><br/>@GetMapping("/form")<br/>public String setupForm(@CookieValue("JSESSIONID") String<br/>jSessionId) {<br/>  // jSessionId will get the value 2388923038849<br/>}</pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">@PathVariable</h1>
                </header>
            
            <article>
                
<p>It is possible to use parts of a URL path as a parameter that gets passed into the handler method. This can be done by using the <kbd>@PathVariable</kbd> annotation. If required, the value will be converted:</p>
<pre>@GetMapping("/form/{id}")<br/>public String setupForm(@PathVariable long id) {<br/>  // When requesting /form/1<br/>  // formId will get the value 1<br/>}</pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">@ModelAttribute</h1>
                </header>
            
            <article>
                
<p>When using the <kbd>@ModelAttribute</kbd> annotation on a parameter of a request handler method, you can inject an attribute that is bound to the model.</p>
<p>We will get into more details on how to work with this model in a future chapter:</p>
<pre>@PostMapping("/posts")<br/>public String addPost(@ModelAttribute("post") Post post) {<br/>  // post will get the model attribute named post<br/>}</pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">@RequestBody</h1>
                </header>
            
            <article>
                
<p>Sometimes, you need to access the body of the request. By using <kbd>@RequestBody</kbd> in conjunction with a method parameter, you can inject the request body. The Spring Framework will try and convert the body to the given type. If you're specifying a string, you will get access to the raw body:</p>
<pre>@PostMapping("/posts")<br/>public String addPost(@RequestBody Post post) {<br/>  // post will get the content of the body that is deserialized<br/>  // into an object of type Post<br/>}</pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">@ResponseBody</h1>
                </header>
            
            <article>
                
<p>Usually, a request handler method will return the name of the view to be rendered. If you want to return the rendered response body, you can annotate the method with <kbd>@ResponseBody</kbd>. In this case, the value that is returned will be sent as a response. In case the type of the returned value is not a string, it will be converted before it gets sent:</p>
<pre>@GetMapping("/welcome")<br/>@ResponseBody<br/>public String showWelcomeMessage() {<br/>  return "&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;Hello&lt;/body&gt;&lt;/html&gt;";<br/>}</pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Additional Content – Properties to Configure Web MVC</h1>
                </header>
            
            <article>
                
<p>One of the biggest strengths of Spring Boot is its automatic configuration using predefined values. However, in some cases, you need to alter parts of the configuration. For example, the servlet container will listen on port 8080 by default. This will allow you to install an HTTP server on the same machine. If you don't need a dedicated web server and want your application to be listening on port 80, you can configure the web container that is embedded by Spring Boot by setting <kbd>server. port=80</kbd> in your <kbd>application.properties</kbd> file.</p>
<p>The following table lists some common configuration properties that you can change to fit your needs:</p>
<div class="packt_figref CDPAlignCenter CDPAlign"><img src="Images/a59b9b18-f52a-4564-9ea8-e7a86d9c9ad8.png" style="width:48.75em;height:37.83em;" width="856" height="664"/></div>
<div class="packt_infobox"><br/>
You can find an exhaustive list of all available configuration properties in the Spring documentation at <a href="https://docs.spring.io/spring-boot/docs/current/reference/htmlsingle/#common-application-properties">https://docs.spring.io/spring-boot/docs/current/reference/htmlsingle/#common-application-properties</a>.</div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Filter</h1>
                </header>
            
            <article>
                
<p>We've learnt about filters in a previous section regarding the Servlet API. Filters are organized in a chain and called by the container before the actual servlet is called. Finally, they can process the response in the reverse order.</p>
<p>Spring Boot makes installing a filter very easy. As often is the case in Spring Boot, there are multiple ways to achieve this. First, you have to implement a Bean implementing the <kbd>javax.servlet.filter</kbd> interface. Instead of having to add a configuration into the <kbd>web.xml</kbd>, any Spring Bean that implements the filter interface will be automatically installed.</p>
<p>Take a look at the following code:</p>
<pre>@WebFilter<br/>@Component<br/>@Slf4j<br/>public class LogFilter implements Filter {<br/>    @Override<br/>    public void init(FilterConfig filterConfig) throws<br/>ServletException {<br/>    }<br/><br/>// […]<br/><br/>    @Override<br/>    public void destroy() {<br/>    }<br/>}</pre>
<div class="packt_infobox"><br/>
Go to <a href="https://bit.ly/2xeD5b4">https://bit.ly/2xeD5b4</a> to access the complete code for the Filter code example.</div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Configuring Spring Web MVC</h1>
                </header>
            
            <article>
                
<p>Writing and configuring a web application is always a comprehensive task. Thankfully, Spring Boot again takes care of the heavy lifting. But in many cases, you need to modify or, more importantly, extend the configuration. This includes additional mappings and security configuration.</p>
<p class="mce-root"/>
<p class="mce-root"/>
<p>All available configuration methods are provided by the <kbd>WebMvcConfigurer</kbd> interface. Usually, the configuration methods are passed a configurer object that can then be used to modify a certain aspect.</p>
<p>In prior versions of the Spring Framework, you had to implement a Bean extending the abstract <kbd>WebConfigurerAdapter</kbd> class. The adapter class is responsible for providing default implementations, so you could concentrate on the methods you wanted to customize.</p>
<p>Since Version 5, this is no longer required. Instead, you can now provide an implementation of the <kbd>WebMvcConfigurer</kbd> interface with only the methods you want to override:</p>
<pre>@Configuration<br/>public class WebMVConfig implements WebMvcConfigurer {<br/>    public void addViewControllers(<br/>                       ViewControllerRegistry registry) {<br/>        registry.addViewController("/")<br/>                .setViewName("index");<br/>   }<br/>}</pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Activity: Creating Your First Web MVC Controller</h1>
                </header>
            
            <article>
                
<p><strong>Aim</strong></p>
<p>To set up a Spring Web MVC project, add a static welcome page, and create a controller pointing to the view.</p>
<p><strong>Scenario</strong></p>
<p>You are asked to set up a web application that displays a static welcome page.</p>
<p><strong>Steps for Completion</strong></p>
<ol>
<li>Go to <a href="https://start.spring.io">https://start.spring.io</a> and enter the required dependencies on the following screen:<br/>
Group: <kbd>com.packt.springboot</kbd><br/>
Artifact: <kbd>blogmania</kbd></li>
</ol>
<p class="mce-root"/>
<p>Take a look at this screenshot:</p>
<div class="packt_figref CDPAlignCenter CDPAlign"><img src="Images/0d9271ee-e3d2-4cd6-ac90-abade8eea5ca.png" style="width:72.08em;height:50.00em;" width="1990" height="1378"/></div>
<ol start="2">
<li>Download a ZIP file containing the initial project files.</li>
<li>Unzip the downloaded file to the project folder.</li>
<li>Add the dependency for the Bootstrap Webjars archive.</li>
<li>Create the <kbd>welcome.html</kbd> file.</li>
<li>Add a controller to render the view.</li>
<li>Now start the application by using the Maven command.</li>
<li>Use your browser to navigate to <kbd>http://localhost:8080</kbd> to view the output.</li>
</ol>
<p><strong>Outcome</strong></p>
<p>The resulting Spring Web MVC project and posts are visible on the web page.</p>
<p>Take a look at this screenshot:</p>
<div class="packt_figref CDPAlignCenter CDPAlign"><img src="Images/d7e30ccd-450b-4d42-9978-5ec0c873fab8.png" style="width:70.83em;height:28.33em;" width="800" height="320"/></div>
<div class="packt_infobox"><br/>
Go to <a href="https://bit.ly/2QpmQR9">https://bit.ly/2QpmQR9</a> to access the code for the <kbd>BlogManiaApplicationTests.java</kbd> file. <span>To refer to the detailed steps, go to the <em>Solutions</em> section at the end of </span><span>this book on page 252.<br/></span></div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>In this chapter, we have learnt about the Model-View-Controller (MVC) pattern. It separates the main concerns of a web application into a model, a view, and a controller.</p>
<p>We then distinguished between a request- and a component-based MVC, which differs in how the framework handles incoming requests by either taking care of conversion, validation, and so on, or leaving the developer to handle these aspects, resulting in different code reusability.</p>
<p>Finally, we implemented our first Spring Web MVC application, to handle incoming requests and display a simple page output.</p>
<p>In the next chapter, we will apply the MVC pattern to Spring Boot.</p>


            </article>

            
        </section>
    </div>



  </body></html>