<html><head></head><body>
		<div id="_idContainer156">
			<h1 id="_idParaDest-205" class="chapter-number"><a id="_idTextAnchor205"/>9</h1>
			<h1 id="_idParaDest-206"><a id="_idTextAnchor206"/>Inheritance and Polymorphism</h1>
			<p>In <a href="B19793_08.xhtml#_idTextAnchor168"><span class="No-Break"><em class="italic">Chapter 8</em></span></a>, we learned about classes, objects, and enums. Initially, we explored the relationship between classes and objects and the need to separate the reference type from the object type. We contrasted instance versus class members and saw that using the <strong class="source-inline">static</strong> keyword applies class scope to a member. We discussed the <strong class="source-inline">this</strong> reference and demonstrated that inside an instance method, the <strong class="source-inline">this</strong> reference refers to the object instance responsible for the method call. We also covered various access modifiers: <strong class="source-inline">private</strong>, package-private (no keyword), <strong class="source-inline">protected</strong>, and <strong class="source-inline">public</strong>. These modifiers enable us to apply one of the cornerstones of OOP, namely encapsulation. While encapsulation is commonly referred to as “private data, public methods,” we demonstrated that this does not go far enough due to Java’s call by value mechanism when passing references into and out of methods. We showed how a technique called “defensive copying” can be used to apply proper (advanced) encapsulation. To improve our understanding of what is happening in the background, we detailed the object life cycle and gently touched on garbage collection. We also covered the <strong class="source-inline">instanceof</strong> keyword, which is used to determine the object type a reference is referring to. We covered a variation <a id="_idIndexMarker607"/>of a class, namely <strong class="bold">enumerations</strong> (<strong class="bold">enums</strong>). Enums enable us to limit the number of instances created, thereby facilitating type safety. We covered both simple and complex enums. Lastly, we covered another class variation, namely records, which saves us from typing a lot of <span class="No-Break">boilerplate code.</span></p>
			<p>In this chapter, we will explore inheritance, another core principle of OOP. Initially, we will outline the benefits of inheritance and the Java keywords to use. This leads to polymorphism, another core pillar of OOP. We will explain polymorphism and, with the aid of examples, how polymorphism is achieved. As polymorphism requires “method overriding,” we will explain how to use <strong class="source-inline">instanceof</strong>, to ensure type safety <span class="No-Break">when downcasting.</span></p>
			<p>We will also contrast method overriding with method overloading. We will explain the <strong class="source-inline">super</strong> keyword and how it is used. As promised in <a href="B19793_08.xhtml#_idTextAnchor168"><span class="No-Break"><em class="italic">Chapter 8</em></span></a>, we will revisit <strong class="source-inline">protected</strong>, the most misunderstood of Java’s <span class="No-Break">access modifiers.</span></p>
			<p>After that, we will discuss both the <strong class="source-inline">abstract</strong> and <strong class="source-inline">final</strong> keywords and their place in inheritance. We will also show how <strong class="source-inline">sealed</strong> classes enable us to scope inheritance. In addition, we will cover both <strong class="source-inline">static</strong> and instance blocks in an inheritance hierarchy. Lastly, we will discuss upcasting and downcasting the inheritance tree, and how a simple rule-of-thumb helps prevent <span class="No-Break"><strong class="source-inline">ClassCastException</strong></span><span class="No-Break"> errors.</span></p>
			<p>This chapter covers the following <span class="No-Break">main topics:</span></p>
			<ul>
				<li><span class="No-Break">Understanding inheritance</span></li>
				<li><span class="No-Break">Applying inheritance</span></li>
				<li><span class="No-Break">Exploring polymorphism</span></li>
				<li>Contrasting method overriding and <span class="No-Break">method overloading</span></li>
				<li>Exploring the <span class="No-Break"><strong class="source-inline">super</strong></span><span class="No-Break"> keyword</span></li>
				<li>Revisiting the <strong class="source-inline">protected</strong> <span class="No-Break">access modifier</span></li>
				<li>Explaining the <strong class="source-inline">abstract</strong> and <span class="No-Break"><strong class="source-inline">final</strong></span><span class="No-Break"> keywords</span></li>
				<li>Applying <span class="No-Break"><strong class="source-inline">sealed</strong></span><span class="No-Break"> classes</span></li>
				<li>Understanding instance and <span class="No-Break"><strong class="source-inline">static</strong></span><span class="No-Break"> blocks</span></li>
				<li>Mastering upcasting <span class="No-Break">and downcasting</span></li>
			</ul>
			<h1 id="_idParaDest-207"><a id="_idTextAnchor207"/>Technical requirements</h1>
			<p>The code for this chapter can be found on GitHub <span class="No-Break">at </span><a href="https://github.com/PacktPublishing/Learn-Java-with-Projects/tree/main/ch9"><span class="No-Break">https://github.com/PacktPublishing/Learn-Java-with-Projects/tree/main/ch9</span></a><span class="No-Break">.</span></p>
			<h1 id="_idParaDest-208"><a id="_idTextAnchor208"/>Understanding inheritance</h1>
			<p>There are three core <a id="_idIndexMarker608"/>pillars in Java: polymorphism, inheritance, and encapsulation (data hiding). It is easy to remember them using the acronym “PIE” (<em class="italic">P</em>olymorphism, <em class="italic">I</em>nheritance, and <em class="italic">E</em>ncapsulation). Let us now <span class="No-Break">examine inheritance.</span></p>
			<p>Inheritance is a code reusability mechanism where common properties between related types are exploited by forming relationships between those types. Inheritance relationships in Java are created by extending from a class or by implementing an interface. We will cover interfaces in <a href="B19793_10.xhtml#_idTextAnchor249"><span class="No-Break"><em class="italic">Chapter 10</em></span></a>, so for the moment, we will assume classes throughout. To understand why inheritance in OOP is important, we will examine its advantages (and disadvantages). As we have not covered the terminology used yet, this discussion will be <span class="No-Break">somewhat abstract.</span></p>
			<h2 id="_idParaDest-209"><a id="_idTextAnchor209"/>Advantages of inheritance</h2>
			<p>One principle advantage of inheritance is code reuse. A new class can be written based on an existing class <a id="_idIndexMarker609"/>rather than writing the new class from scratch. In other words, the new class can inherit code that has been already written (and tested). This <a id="_idIndexMarker610"/>is called <em class="italic">code reuse</em> and <span class="No-Break">reduces redundancy.</span></p>
			<p>Inheritance naturally promotes polymorphism, which we discuss later. This feature gives your code flexibility. For example, you could have a method that deals with an <strong class="source-inline">Animal</strong> reference but at runtime, the code executed is in the <strong class="source-inline">Dog</strong> type (or <strong class="source-inline">Cat</strong> or any other type of <strong class="source-inline">Animal</strong> in the hierarchy). In effect, one method works with all <span class="No-Break"><strong class="source-inline">Animal</strong></span><span class="No-Break"> types.</span></p>
			<p>Inheritance organizes code into a hierarchy. This can improve productivity and simplify the maintenance of code as changes made to inherited code are immediately reflected throughout <span class="No-Break">the hierarchy.</span></p>
			<h2 id="_idParaDest-210"><a id="_idTextAnchor210"/>Disadvantages of inheritance</h2>
			<p>Despite its advantages, inheritance does have its disadvantages. Tight coupling between the base (source) type and <a id="_idIndexMarker611"/>the derived (target) type is one such drawback. Any changes made to the base type affect all the <span class="No-Break">derived types.</span></p>
			<p>Code bloat is <a id="_idIndexMarker612"/>another disadvantage. Changes may be made to the base type that many derived types do not need and this can result in an unnecessarily large <span class="No-Break">code base.</span></p>
			<p>Now that we have an appreciation of inheritance and why it is used, let’s discuss the nomenclature (terms) used when <span class="No-Break">discussing inheritance.</span></p>
			<h2 id="_idParaDest-211"><a id="_idTextAnchor211"/>Base class</h2>
			<p>The “base” class is <a id="_idIndexMarker613"/>also known as the “super” or “parent” class. This is where the inherited members <a id="_idIndexMarker614"/>are defined. As a class is a type, the term <em class="italic">type</em> is often used interchangeably for class. Note that in Java, the <em class="italic">Object</em> class is at the top of <span class="No-Break">every hierarchy.</span></p>
			<h2 id="_idParaDest-212"><a id="_idTextAnchor212"/>Subclass</h2>
			<p>The subclass is <a id="_idIndexMarker615"/>also known as the “child” or “derived” class. So, the subclass <a id="_idIndexMarker616"/>inherits functionality (and/or data) from the base class. Again, as a class is a type, the term <em class="italic">subtype</em> is often used interchangeably for subclass. A class can be both a base class and a subclass. Java ensures that <em class="italic">Object</em> is at the top of every (inheritance) hierarchy. Thus, every class we write is implicitly a subtype already (even if you do not <span class="No-Break">say so).</span></p>
			<h2 id="_idParaDest-213"><a id="_idTextAnchor213"/>The “is-a” relationship</h2>
			<p>Inheritance <a id="_idIndexMarker617"/>generates what is called an <em class="italic">“is-a”</em> relationship. <span class="No-Break"><em class="italic">Figure 9</em></span><em class="italic">.1</em> will help us <a id="_idIndexMarker618"/>explain this. We will expand on this diagram as this <span class="No-Break">chapter progresses:</span></p>
			<div>
				<div id="_idContainer134" class="IMG---Figure">
					<img src="image/B19793_09_1.jpg" alt="Figure 9.1 – UML diagram for the Vehicle hierarchy"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.1 – UML diagram for the Vehicle hierarchy</p>
			<p class="callout-heading">Unified Modeling Language (UML)</p>
			<p class="callout">UML is a <a id="_idIndexMarker619"/>modeling language used in software design availing of the maxim that “a picture speaks a thousand words.” UML makes understanding topics such as inheritance very straightforward, so we will present a very brief overview of UML here. Further detail is available <span class="No-Break">here: </span><a href="https://en.wikipedia.org/wiki/Unified_Modeling_Language"><span class="No-Break">https://en.wikipedia.org/wiki/Unified_Modeling_Language</span></a><span class="No-Break">.</span></p>
			<p class="callout">With <span class="No-Break"><em class="italic">Figure 9</em></span><em class="italic">.1</em> in mind, here is an overview of the <span class="No-Break">symbols used:</span></p>
			<ul>
				<li class="callout"><em class="italic">Package name</em>: The package name is at the top <span class="No-Break">left (</span><span class="No-Break"><strong class="source-inline">ch9</strong></span><span class="No-Break">)</span></li>
				<li class="callout"><em class="italic">Classes</em>: Classes are in boxes with three sections – the top box is the class name; the middle box is for the instance/class variables; the bottom box is for <span class="No-Break">the methods</span></li>
				<li class="callout"><em class="italic">Access modifiers</em>: <strong class="source-inline">public</strong> (+), <strong class="source-inline">private</strong> (-), package-private (~), and <span class="No-Break"><strong class="source-inline">protected</strong></span><span class="No-Break"> (#)</span></li>
				<li class="callout"><em class="italic">Static</em>: The underline is used to signify that a member <span class="No-Break">is </span><span class="No-Break"><strong class="source-inline">static</strong></span></li>
				<li class="callout"><em class="italic">Method return type</em>: The last part of the method signature <span class="No-Break">in UML</span></li>
				<li class="callout"><em class="italic">Class inheritance</em>: An arrow with a solid line; for example, <strong class="source-inline">Car</strong> inherits <span class="No-Break">from </span><span class="No-Break"><strong class="source-inline">Vehicle</strong></span></li>
				<li class="callout"><em class="italic">Interfaces</em>: These are shown in boxes with dashed lines (<a href="B19793_10.xhtml#_idTextAnchor249"><span class="No-Break"><em class="italic">Chapter 10</em></span></a><span class="No-Break">)</span></li>
				<li class="callout"><em class="italic">Interface inheritance</em>: An arrow with a dashed line (<a href="B19793_10.xhtml#_idTextAnchor249"><span class="No-Break"><em class="italic">Chapter 10</em></span></a><span class="No-Break">)</span></li>
				<li class="callout"><em class="italic">Association</em>: A solid line; for example, <strong class="source-inline">TestVehicle</strong> is associated with <strong class="source-inline">Vehicle</strong> for the simple reason that we will be creating objects based on the <strong class="source-inline">Vehicle</strong> hierarchy <span class="No-Break">in </span><span class="No-Break"><strong class="source-inline">main()</strong></span></li>
			</ul>
			<p>As shown in <span class="No-Break"><em class="italic">Figure 9</em></span><em class="italic">.1</em>, we have a package, namely <strong class="source-inline">ch9</strong>. There are five classes in the <strong class="source-inline">Vehicle</strong> hierarchy: <strong class="source-inline">Vehicle</strong>, <strong class="source-inline">Car</strong>, <strong class="source-inline">Saloon</strong>, <strong class="source-inline">Convertible</strong>, and <strong class="source-inline">Boat</strong>. In this hierarchy, from a base class viewpoint, <strong class="source-inline">Vehicle</strong> is the base class for <strong class="source-inline">Car</strong> and <strong class="source-inline">Boat</strong>; and <strong class="source-inline">Car</strong> is the <a id="_idIndexMarker620"/>base class for <strong class="source-inline">Saloon</strong> and <strong class="source-inline">Convertible</strong>. Interpreting the <a id="_idIndexMarker621"/>diagram from the sub-class perspective, <strong class="source-inline">Car</strong> and <strong class="source-inline">Boat</strong> are sub-classes of <strong class="source-inline">Vehicle</strong>, whereas <strong class="source-inline">Saloon</strong> and <strong class="source-inline">Convertible</strong> are sub-classes of <strong class="source-inline">Car</strong>. Regardless of which perspective you use, every <strong class="source-inline">Car</strong> “is-a” <strong class="source-inline">Vehicle</strong>, and every <strong class="source-inline">Boat</strong> “is-a” <strong class="source-inline">Vehicle</strong> too. In addition, every <strong class="source-inline">Saloon</strong> “is-a” <strong class="source-inline">Car</strong>, and every <strong class="source-inline">Convertible</strong> “<span class="No-Break">is-a” </span><span class="No-Break"><strong class="source-inline">Car</strong></span><span class="No-Break">.</span></p>
			<p>It also follows that because <strong class="source-inline">Saloon</strong> “is-a” <strong class="source-inline">Car</strong> and <strong class="source-inline">Car</strong> “is-a” <strong class="source-inline">Vehicle</strong>, <strong class="source-inline">Saloon</strong> “is-a” <strong class="source-inline">Vehicle</strong> as well. The same applies to <strong class="source-inline">Convertible</strong>; in other words, <strong class="source-inline">Convertible</strong> “is-a” <strong class="source-inline">Car</strong>, <strong class="source-inline">Car</strong> “is-a” <strong class="source-inline">Vehicle</strong>; therefore, <strong class="source-inline">Convertible</strong> “is-a” <span class="No-Break"><strong class="source-inline">Vehicle</strong></span><span class="No-Break"> also.</span></p>
			<p>However, the “is-a” relationship works in one direction only (reading the diagram from the bottom up). For example, while <em class="italic">every</em> <strong class="source-inline">Car</strong> “is-a” <strong class="source-inline">Vehicle</strong>, <em class="italic">not</em> every <strong class="source-inline">Vehicle</strong> “is-a” <strong class="source-inline">Car</strong>; some are <strong class="source-inline">Boat</strong>s. There is a very good reason for this, which we will explore further when we discuss upcasting <span class="No-Break">and downcasting.</span></p>
			<p>There is one <a id="_idIndexMarker622"/>method in <strong class="source-inline">Vehicle</strong>, namely <strong class="source-inline">toString()</strong>, which, because it is <strong class="source-inline">public</strong>, is inherited by all the subtypes; namely, <strong class="source-inline">Car</strong>, <strong class="source-inline">Saloon</strong>, <strong class="source-inline">Convertible</strong>, and <strong class="source-inline">Boat</strong>. Thus, the version of <strong class="source-inline">toString()</strong> in <strong class="source-inline">Vehicle</strong> is available throughout <a id="_idIndexMarker623"/>the whole hierarchy. Lastly, the other class, <strong class="source-inline">TestVehicle</strong> contains the <strong class="source-inline">main()</strong> method so that we can test <span class="No-Break">the hierarchy.</span></p>
			<p>Now that we understand the concept of inheritance, let’s apply it <span class="No-Break">in code.</span></p>
			<h1 id="_idParaDest-214"><a id="_idTextAnchor214"/>Applying inheritance</h1>
			<p>As we learned in the previous section, inheritance creates an “is-a” relationship hierarchy. This enables <a id="_idIndexMarker624"/>base class functionality to be inherited and therefore available to subclasses, without any extra coding. Java uses two keywords in applying inheritance: <strong class="source-inline">extends</strong> and <strong class="source-inline">implements</strong>. Let’s discuss <span class="No-Break">them now.</span></p>
			<h2 id="_idParaDest-215"><a id="_idTextAnchor215"/>extends</h2>
			<p>This is the principle <a id="_idIndexMarker625"/>keyword that’s used and relates to both classes and interfaces. Regarding classes, we state that <strong class="source-inline">class Sub extends Base {}</strong>. In this case, all of the non-<strong class="source-inline">private</strong> members from the <strong class="source-inline">Base</strong> class will be inherited into the <strong class="source-inline">Sub</strong> class. Note that <strong class="source-inline">private</strong> members and constructors are not inherited – this makes sense as both <strong class="source-inline">private</strong> members and constructors are class-specific. In addition, Java prohibits multiple class inheritance. This means that you cannot extend from more than one class at a time. Regarding interfaces, we state that <strong class="source-inline">interface ChildInt extends </strong><span class="No-Break"><strong class="source-inline">ParentInt {}</strong></span><span class="No-Break">.</span></p>
			<h2 id="_idParaDest-216"><a id="_idTextAnchor216"/>implements</h2>
			<p>While we will <a id="_idIndexMarker626"/>discuss interfaces in detail in <a href="B19793_10.xhtml#_idTextAnchor249"><span class="No-Break"><em class="italic">Chapter 10</em></span></a>, a brief overview here is appropriate. An interface is a construct that enables Java to ensure that if a class implements an interface, the class is, in effect, signing a contract. The contract states, generally speaking, that the class will have code for the <strong class="source-inline">abstract</strong> methods in the interface. An <strong class="source-inline">abstract</strong> method, which we will discuss in more detail later, is a method that has no implementation code; in other words, no <span class="No-Break">curly braces.</span></p>
			<p>Concerning inheritance, unlike classes, Java allows interfaces to extend from more than one interface at a time. So, for example, <strong class="source-inline">interface C extends A, B {}</strong>, where <strong class="source-inline">A</strong>, <strong class="source-inline">B</strong>, and <strong class="source-inline">C</strong> are all interfaces, is fine. Note that, as of Java 8, both the <strong class="source-inline">default</strong> and <strong class="source-inline">static</strong> methods in interfaces have <span class="No-Break">implementation code.</span></p>
			<p>A class implements an interface using the <strong class="source-inline">class Dog implements Walkable</strong> syntax. With this, the <strong class="source-inline">static</strong> and <strong class="source-inline">default</strong> methods in <strong class="source-inline">Walkable</strong> are available <span class="No-Break">to </span><span class="No-Break"><strong class="source-inline">Dog</strong></span><span class="No-Break">.</span></p>
			<p>Now, let’s look at inheritance in action. <span class="No-Break"><em class="italic">Figure 9</em></span><em class="italic">.2</em> shows the Java code for the UML in <span class="No-Break"><em class="italic">Figure 9</em></span><span class="No-Break"><em class="italic">.1</em></span><span class="No-Break">:</span></p>
			<div>
				<div id="_idContainer135" class="IMG---Figure">
					<img src="image/B19793_09_2.jpg" alt="Figure 9.2 – Inheritance in action"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.2 – Inheritance in action</p>
			<p>In this figure, lines 3 and 4 are equivalent. <strong class="source-inline">Vehicle</strong> is at the top of this particular hierarchy and <a id="_idIndexMarker627"/>to ensure that <strong class="source-inline">Object</strong> is inherited by every class, the compiler simply inserts <strong class="source-inline">extends Object</strong> after <strong class="source-inline">class Vehicle</strong>, as per line 3. Lines 5-7 are a custom implementation of the <strong class="source-inline">toString()</strong> method inherited from <strong class="source-inline">Object</strong>. This is known as <em class="italic">overriding</em>, a topic we will discuss in detail shortly. Lines 9-12 represent the rest of the inheritance hierarchy: a <strong class="source-inline">Car</strong> “is-a” <strong class="source-inline">Vehicle</strong>; a <strong class="source-inline">Boat</strong> “is-a” <strong class="source-inline">Vehicle</strong>; a <strong class="source-inline">Saloon</strong> “is-a” <strong class="source-inline">Car</strong>; and a <strong class="source-inline">Convertible</strong> “<span class="No-Break">is-a” </span><span class="No-Break"><strong class="source-inline">Car</strong></span><span class="No-Break">.</span></p>
			<p>On line 16, we create a <strong class="source-inline">Vehicle</strong> object and use a <strong class="source-inline">Vehicle</strong> reference called <strong class="source-inline">vehicle</strong> to refer to it. On line 17, we call the <strong class="source-inline">toString()</strong> method, defined on lines 5-7, <span class="No-Break">outputting </span><span class="No-Break"><strong class="source-inline">Vehicle::toString()</strong></span><span class="No-Break">.</span></p>
			<p>On line 18, we create a <strong class="source-inline">Car</strong> object and use a <strong class="source-inline">Car</strong> reference called <strong class="source-inline">car</strong> to refer to it. On line 20, we simply insert the <strong class="source-inline">car</strong> reference inside <strong class="source-inline">System.out.println()</strong>. When Java encounters <a id="_idIndexMarker628"/>a reference like this inside <strong class="source-inline">System.out.println()</strong>, it looks up the object type (<strong class="source-inline">Car</strong>, in this instance) and calls its <strong class="source-inline">toString()</strong>. As every class inherits from <strong class="source-inline">Object</strong>, and <strong class="source-inline">Object</strong> defines a basic (unfriendly) <strong class="source-inline">toString()</strong>, a version of <strong class="source-inline">toString()</strong> will exist. However, in this hierarchy, <strong class="source-inline">Vehicle</strong> has replaced (overridden) <strong class="source-inline">toString()</strong> inherited from <strong class="source-inline">Object</strong> with its own custom one (lines 5-7). This custom one from <strong class="source-inline">Vehicle</strong> is inherited by <strong class="source-inline">Car</strong>. What happens is that Java checks if there is a custom <strong class="source-inline">toString()</strong> defined in <strong class="source-inline">Car</strong>; as there isn’t one, Java then checks its parent, namely <strong class="source-inline">Vehicle</strong>. If <strong class="source-inline">Vehicle</strong> has no <strong class="source-inline">toString()</strong>, the version from <strong class="source-inline">Object</strong> would be used. Since <strong class="source-inline">toString()</strong> is defined in <strong class="source-inline">Vehicle</strong>, this is the version inherited by <strong class="source-inline">Car</strong> and used on line 20. Thus, the output is, <span class="No-Break">again, </span><span class="No-Break"><strong class="source-inline">Vehicle::toString()</strong></span><span class="No-Break">.</span></p>
			<p>On line 21, we create a <strong class="source-inline">Saloon</strong> object and use a <strong class="source-inline">Saloon</strong> reference called <strong class="source-inline">saloon</strong> to refer to it. Again, on line 22, we simply insert the <strong class="source-inline">saloon</strong> reference inside <strong class="source-inline">System.out.println()</strong>. As <strong class="source-inline">Saloon</strong> has no custom <strong class="source-inline">toString()</strong> defined, and its parent, <strong class="source-inline">Car</strong>, has no custom version either, the one inherited from <strong class="source-inline">Vehicle</strong> is used. This results in <strong class="source-inline">Vehicle::toString()</strong> being output to <span class="No-Break">the screen.</span></p>
			<p>Line 24 is used to demonstrate the output when the <strong class="source-inline">toString()</strong> method from <strong class="source-inline">Object</strong> is used. On line 24, we are creating an instance of <strong class="source-inline">TestVehicle</strong> and calling its <strong class="source-inline">toString()</strong> method. As <strong class="source-inline">TestVehicle</strong> is not explicitly inheriting from any class (using <strong class="source-inline">extends</strong>), it implicitly inherits from <strong class="source-inline">Object</strong>. In addition, as <strong class="source-inline">TestVehicle</strong> is not overriding <strong class="source-inline">toString()</strong> with its own custom version, the one inherited from <strong class="source-inline">Object</strong> is used. This is demonstrated by the output from line 24: <strong class="source-inline">ch9.TestVehicle@378bf509</strong>. The output from the <strong class="source-inline">toString()</strong> method in <strong class="source-inline">Object</strong> is formatted as <strong class="source-inline">package_name.class name@hash code</strong>. The package name in this case is <strong class="source-inline">ch9</strong> (line 1), the class name is <strong class="source-inline">TestVehicle</strong> (line 24), and the hash code is a hexadecimal number that’s used in hashing collections (<a href="B19793_13.xhtml#_idTextAnchor317"><span class="No-Break"><em class="italic">Chapter 13</em></span></a><span class="No-Break">).</span></p>
			<p>Now that we have seen basic inheritance in action, let’s move on to another cornerstone of OOP, <span class="No-Break">namely polymorphism.</span></p>
			<h1 id="_idParaDest-217"><a id="_idTextAnchor217"/>Exploring polymorphism</h1>
			<p>Polymorphism has its origins in the Greek terms poly (many) morphe (forms). Any object that passes <a id="_idIndexMarker629"/>more than one “is-a” test can be considered polymorphic. Therefore, only objects of the <strong class="source-inline">Object</strong> type are not polymorphic as any type passes the “is-a” test for both <strong class="source-inline">Object</strong> <span class="No-Break">and itself.</span></p>
			<p>In this section, we will discuss why separating the reference type from the object type is so important. In addition, we will examine method overriding and its critical role in <span class="No-Break">enabling polymorphism.</span></p>
			<h2 id="_idParaDest-218"><a id="_idTextAnchor218"/>Separating the reference type from the object type</h2>
			<p>Now that we have inheritance hierarchies, we will regularly differentiate the reference type from <a id="_idIndexMarker630"/>the object type. The reference <a id="_idIndexMarker631"/>type can be a class, record, enum or interface. In other words, we have flexibility with regard to the reference type. The object type is more restrictive: the object type is based on non-abstract classes, records, and enums only. In other words, we cannot create objects based on abstract classes <span class="No-Break">or interfaces.</span></p>
			<p>For example, given the hierarchy in <span class="No-Break"><em class="italic">Figure 9</em></span><em class="italic">.2</em>, it is perfectly legal to say <span class="No-Break">the following:</span></p>
			<pre class="source-code">
Vehicle v = new Car();</pre>			<p>This is because every <strong class="source-inline">Car</strong> “is-a” <strong class="source-inline">Vehicle</strong> (reading it right to left, as assignment associates right to left). In this instance, the reference, <strong class="source-inline">v</strong>, is of the <strong class="source-inline">Vehicle</strong> type and it is referring to an object of the <strong class="source-inline">Car</strong> type. This is known as <em class="italic">upcasting</em>, as we are going <em class="italic">up</em> the inheritance tree (again, reading it from right to left, from <strong class="source-inline">Car</strong> <em class="italic">up</em> to <strong class="source-inline">Vehicle</strong>). We are upcasting the <strong class="source-inline">Car</strong> reference, created by <strong class="source-inline">new Car()</strong>, and casting it to a <strong class="source-inline">Vehicle</strong> <span class="No-Break">reference, </span><span class="No-Break"><strong class="source-inline">v</strong></span><span class="No-Break">.</span></p>
			<p>Why does this work? This works because, due to inheritance, every inheritable method available to <strong class="source-inline">Vehicle</strong> will exist in <strong class="source-inline">Car</strong>. That is a guarantee. Whether <strong class="source-inline">Car</strong> has overridden (replaced) any/all <strong class="source-inline">Vehicle</strong> methods with its own custom ones is immaterial. Given that the compiler looks at the reference type (and not the object type), the methods we can call using the <strong class="source-inline">Vehicle</strong> reference, <strong class="source-inline">v</strong>, are defined in <strong class="source-inline">Vehicle</strong> (and <strong class="source-inline">Object</strong>) and will be present in <strong class="source-inline">Car</strong> (the <span class="No-Break">object type).</span></p>
			<p>So, that is the first point to keep in mind - the compiler is always looking at the reference type. As we will see shortly, the object type comes into play at runtime. So, a simple but effective rule of thumb is that <em class="italic">a reference can refer to objects of its own type or objects of subclasses</em>. In effect, a reference can point “across and down” the (<span class="No-Break">UML) hierarchy.</span></p>
			<p>If a reference is ever pointing “up” the hierarchy, that is when you get <strong class="source-inline">ClassCastException</strong> errors. Why is this? Well, a subclass inherits from its parent. In addition <a id="_idIndexMarker632"/>to replacing inherited functionality (overriding), the subclass can also add extra methods. So, if you have <a id="_idIndexMarker633"/>a reference of the subclass type, you can invoke these <em class="italic">extra</em> added methods. But if your object is of the parent type, these methods will not exist! This is a serious issue for the JVM and it throws an exception (<a href="B19793_11.xhtml#_idTextAnchor266"><span class="No-Break"><em class="italic">Chapter </em></span><span class="No-Break"><em class="italic">11</em></span></a><span class="No-Break">) immediately.</span></p>
			<p>So, the reference type determines the methods that can be called on the object. In addition, while the reference type cannot change, the object type it refers <span class="No-Break">to can.</span></p>
			<p>Now, let’s address how to avail <span class="No-Break">of polymorphism.</span></p>
			<h2 id="_idParaDest-219"><a id="_idTextAnchor219"/>Applying polymorphism</h2>
			<p>Polymorphism applies only to instance (non-static) methods, as only instance methods can be overridden. At compile time, the compiler decides which method signature to bind to; however, the object <a id="_idIndexMarker634"/>that will provide the actual method to execute is decided at runtime! That is what polymorphism is. This is why polymorphism is also known as “runtime binding” or “<span class="No-Break">late binding.”</span></p>
			<p class="callout-heading">What if you are accessing a static member?</p>
			<p class="callout">A <strong class="source-inline">static</strong> member (method or data) is associated with the class and therefore not involved in polymorphism. The following applies: if you are accessing any type of data (<strong class="source-inline">static</strong> or non-static) or <strong class="source-inline">static</strong> methods, the JVM uses the reference type. Only if it’s an instance method is the object type <span class="No-Break">used (polymorphism).</span></p>
			<p>Thus, for polymorphism to work, we need instance methods in the base and subclass where the subclass overrides the base version. For this to happen, the subclass must code a method that has the same signature as <span class="No-Break">the parent.</span></p>
			<p>Okay, that’s enough theory – let’s look at an example that reinforces everything we’ve learned <span class="No-Break">thus far.</span></p>
			<h3>Polymorphism in code – example 1</h3>
			<p><span class="No-Break"><em class="italic">Figure 9</em></span><em class="italic">.3</em> shows the <a id="_idIndexMarker635"/>UML for the code <span class="No-Break">to follow:</span></p>
			<div>
				<div id="_idContainer136" class="IMG---Figure">
					<img src="image/B19793_09_3.jpg" alt="Figure 9.3 – UML for polymorphism example"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.3 – UML for polymorphism example</p>
			<p>In this figure, the <strong class="source-inline">Vehicle</strong> class has a <strong class="source-inline">move()</strong> method. It is an instance method, with a return type of <strong class="source-inline">void</strong>. Both <strong class="source-inline">Car</strong> and <strong class="source-inline">Boat</strong> extend <strong class="source-inline">Vehicle</strong> and override <strong class="source-inline">move()</strong>. <strong class="source-inline">Car</strong> adds a method called <strong class="source-inline">wheels()</strong> and <strong class="source-inline">Boat</strong> adds a method called <strong class="source-inline">floats()</strong>. Both <strong class="source-inline">Saloon</strong> and <strong class="source-inline">Convertible</strong> extend <strong class="source-inline">Car</strong>. <strong class="source-inline">Saloon</strong> overrides <strong class="source-inline">move()</strong> but <strong class="source-inline">Convertible</strong> <span class="No-Break">does not.</span></p>
			<p><span class="No-Break"><em class="italic">Figure 9</em></span><em class="italic">.4</em> presents the <a id="_idIndexMarker636"/>code for this UML and demonstrates polymorphism <span class="No-Break">in action:</span></p>
			<p class="callout-heading">@Override annotation</p>
			<p class="callout">An annotation is a<a id="_idIndexMarker637"/> form of metadata that provides information about the program that is not part of the program itself. Annotations are preceded in Java with the <strong class="source-inline">@</strong> symbol and have several uses. For example, annotations are used by the compiler to detect errors or by the runtime to <span class="No-Break">generate code.</span></p>
			<p class="callout">When overriding a base class method, we can insert the <strong class="source-inline">@Override</strong> annotation just prior to the subclass <a id="_idIndexMarker638"/>method. While not mandatory, it is very useful, because, if we apply this annotation, the compiler will ensure that we override the <span class="No-Break">method correctly.</span></p>
			<div>
				<div id="_idContainer137" class="IMG---Figure">
					<img src="image/B19793_09_4.jpg" alt="Figure 9.4 – Polymorphism example"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.4 – Polymorphism example</p>
			<p>In this figure, <strong class="source-inline">Car</strong> and <strong class="source-inline">Boat</strong> both extend <strong class="source-inline">Vehicle</strong>; and <strong class="source-inline">Saloon</strong> and <strong class="source-inline">Convertible</strong> both extend <strong class="source-inline">Car</strong>. Note that the <strong class="source-inline">move()</strong> method in <strong class="source-inline">Vehicle</strong> (line 4) is a non-static/instance <a id="_idIndexMarker639"/>method and therefore polymorphic. In addition, as <strong class="source-inline">move()</strong> is non-<strong class="source-inline">private</strong>, it is inheritable. The <strong class="source-inline">move()</strong> method from  <strong class="source-inline">Vehicle</strong> is overridden by <strong class="source-inline">Car</strong> (line 7), <strong class="source-inline">Boat</strong> (line 11), and <strong class="source-inline">Saloon</strong> (line 15). To highlight this fact, on each of those lines, we have used the <strong class="source-inline">@Override</strong> annotation. This means that the parent <strong class="source-inline">move()</strong> method is overridden by the respective <span class="No-Break">subclass versions.</span></p>
			<p>Line 21 creates a <strong class="source-inline">Car</strong> object and uses a <strong class="source-inline">Vehicle</strong> reference, namely <strong class="source-inline">v</strong>, to refer to it. It is worth repeating <a id="_idIndexMarker640"/>that this upcasting, from <strong class="source-inline">Car</strong> up to <strong class="source-inline">Vehicle</strong>, is only possible because, via inheritance, <em class="italic">every</em> <strong class="source-inline">Car</strong> “is-a” <strong class="source-inline">Vehicle</strong>. Therefore, any method available to the <strong class="source-inline">Vehicle</strong> reference will exist in <strong class="source-inline">Car</strong>. Consequently, as upcasting is never a risk, it is performed implicitly by the compiler; in other words, you do not need to explicitly state the (up)cast in code, <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
Vehicle v = (Vehicle) new Car();</pre>			<h4>Compile time</h4>
			<p>Line 22 makes the polymorphic <strong class="source-inline">v.move()</strong> call. Every time a method call is in code, there are two <a id="_idIndexMarker641"/>perspectives to keep in mind: compile time and runtime. As we know, the compiler concerns itself with the reference type. So, in this case, the compiler <a id="_idIndexMarker642"/>checks the reference, <strong class="source-inline">v</strong>, and determines that it is of type <strong class="source-inline">Vehicle</strong>. The compiler then checks if there is a <strong class="source-inline">move()</strong> method, with that exact signature in the <strong class="source-inline">Vehicle</strong> class, either defined in <strong class="source-inline">Vehicle</strong> or inherited into <strong class="source-inline">Vehicle</strong> (from <strong class="source-inline">Object</strong> in this example). As there is a <strong class="source-inline">move()</strong> method defined in <strong class="source-inline">Vehicle</strong>, the compiler <span class="No-Break">is happy.</span></p>
			<h4>Polymorphism in action</h4>
			<p>At runtime, as <strong class="source-inline">move()</strong> is a non-static, polymorphic method, the object being referred to by the reference, <strong class="source-inline">v</strong>, applies. As <strong class="source-inline">v</strong> is referring to a <strong class="source-inline">Car</strong> object, the <strong class="source-inline">Car</strong> version of <strong class="source-inline">move()</strong> is executed. This <a id="_idIndexMarker643"/>is polymorphism in action! We have one method but many implementations of that method. The compiler ensures that the method exists and dynamically, at runtime, polymorphism kicks in and executes the version in the object being referred to. As <strong class="source-inline">v</strong> is referring to a <strong class="source-inline">Car</strong> object, the output from line 22 <span class="No-Break">is </span><span class="No-Break"><strong class="source-inline">Car::move()</strong></span><span class="No-Break">.</span></p>
			<p>Line 23 reuses the <strong class="source-inline">Vehicle</strong> reference, <strong class="source-inline">v</strong> (which is perfectly valid), to refer to a <strong class="source-inline">Boat</strong> object. As <strong class="source-inline">Boat</strong> “is-a” <strong class="source-inline">Vehicle</strong>, this is fine. Line 24 makes the same polymorphic call to <strong class="source-inline">v.move()</strong> as was the case on line 22. However, this time, <strong class="source-inline">v</strong> is referring to a <strong class="source-inline">Boat</strong> object, and as <strong class="source-inline">Boat</strong> has overridden <strong class="source-inline">move()</strong>, the <strong class="source-inline">Boat</strong> version of <strong class="source-inline">move()</strong> is executed at runtime. Therefore the output <span class="No-Break">is </span><span class="No-Break"><strong class="source-inline">Boat::move()</strong></span><span class="No-Break">.</span></p>
			<p>Line 25 demonstrates that the compiler looks at the reference type. As we know, <strong class="source-inline">v</strong> is of type <strong class="source-inline">Vehicle</strong>. However, <strong class="source-inline">Vehicle</strong> has no <strong class="source-inline">floats()</strong> method; this is a method specific to <strong class="source-inline">Boat</strong>. Therefore, the compiler complains about <strong class="source-inline">v.floats()</strong> on line 25, and hence, the line is <span class="No-Break">commented out.</span></p>
			<p>Line 26 reuses the <strong class="source-inline">Vehicle</strong> reference, <strong class="source-inline">v</strong>, to refer to a <strong class="source-inline">Saloon</strong> object. As <strong class="source-inline">Saloon</strong> “is-a” <strong class="source-inline">Vehicle</strong>, this is fine. Line 27 makes the same polymorphic call to <strong class="source-inline">v.move()</strong> as was the case on lines 22 and 24. As <strong class="source-inline">v</strong> is now referring to a <strong class="source-inline">Saloon</strong> object with <a id="_idIndexMarker644"/>an overridden <strong class="source-inline">move()</strong> method, the <strong class="source-inline">Saloon</strong> version of <strong class="source-inline">move()</strong> is executed polymorphically at runtime. Therefore, the output <span class="No-Break">is </span><span class="No-Break"><strong class="source-inline">Saloon::move()</strong></span><span class="No-Break">.</span></p>
			<p>Line 28 creates a <strong class="source-inline">Convertible</strong> object and uses <strong class="source-inline">v</strong> to refer to it. This is not a problem as <strong class="source-inline">Convertible</strong> “is-a” <strong class="source-inline">Vehicle</strong> (indirectly, via <strong class="source-inline">Car</strong>). In other words, because <strong class="source-inline">Convertible</strong> is-a <strong class="source-inline">Vehicle</strong> and <strong class="source-inline">Vehicle</strong> is-a <strong class="source-inline">Car</strong>, <strong class="source-inline">Convertible</strong> is-a <strong class="source-inline">Car</strong> also. Line 29 makes the same polymorphic call, <strong class="source-inline">v.move()</strong>, as was the case on lines 22, 24, and 27. Note, however, that <strong class="source-inline">Convertible</strong> has not overridden <strong class="source-inline">move()</strong>. <strong class="source-inline">Convertible</strong> has an empty class body. Therefore, the methods in <strong class="source-inline">Convertible</strong> are the <strong class="source-inline">move()</strong> and <strong class="source-inline">wheels()</strong> methods inherited from <strong class="source-inline">Car</strong> and the methods inherited from <strong class="source-inline">Object</strong>, such as <strong class="source-inline">toString()</strong>. So, at runtime, when <strong class="source-inline">v.move()</strong> is called, the JVM executes the version of <strong class="source-inline">move()</strong> in <strong class="source-inline">Car</strong>, resulting in <strong class="source-inline">Car::move()</strong>. You can also look at it this way: the runtime looks for <strong class="source-inline">move()</strong> in <strong class="source-inline">Convertible</strong>, and finds none; the JVM then checks the parent, <strong class="source-inline">Car</strong>, and finds one, which it executes. Note that if <strong class="source-inline">Car</strong> had not provided a <strong class="source-inline">move()</strong> method, its parent, <strong class="source-inline">Vehicle</strong>, would have been next in the search. So, there is an “up the hierarchy, one generation at a time” <span class="No-Break">orderly search.</span></p>
			<h4>Why do we get a ClassCastException error?</h4>
			<p>Line 31 <a id="_idIndexMarker645"/>demonstrates downcasting and a <strong class="source-inline">ClassCastException</strong> error. Exceptions will be discussed in <a href="B19793_11.xhtml#_idTextAnchor266"><span class="No-Break"><em class="italic">Chapter 11</em></span></a>, so we <a id="_idIndexMarker646"/>won’t go into detail here. Downcasting will be discussed in greater detail later in this chapter but this example is too good to pass up! Let’s examine line 31 in <span class="No-Break">greater detail:</span></p>
			<pre class="source-code">
Saloon s = (Saloon) new Vehicle(); // ClassCastException</pre>			<p>The first thing to note is that the cast (<strong class="source-inline">Saloon</strong>) <em class="italic">is</em> required. The compiler will not allow <span class="No-Break">the following:</span></p>
			<pre class="source-code">
Saloon s = new Vehicle(); // Compiler error</pre>			<p>This is a compiler error because every <strong class="source-inline">Vehicle</strong> is not a <strong class="source-inline">Saloon</strong> class; some are <strong class="source-inline">Boat</strong>s. Indeed, even if the <strong class="source-inline">Boat</strong> class were not present, this line would still not compile. Why? Because, reading it right to left, you are going <em class="italic">down</em> the hierarchy from <strong class="source-inline">Vehicle</strong> to <strong class="source-inline">Saloon</strong>. As <strong class="source-inline">Saloon</strong> could (and indeed does) have extra methods not in the <strong class="source-inline">Vehicle</strong> class, this situation must be prevented. For example, the <strong class="source-inline">Saloon</strong> reference, <strong class="source-inline">s</strong>, has access to the <strong class="source-inline">wheels()</strong> method (inherited from <strong class="source-inline">Car</strong>), which is not present <span class="No-Break">in </span><span class="No-Break"><strong class="source-inline">Vehicle</strong></span><span class="No-Break">.</span></p>
			<p>Now, we can <a id="_idIndexMarker647"/>override the compiler by using a (down)cast. This is what line 31 has done with the <strong class="source-inline">(Saloon)</strong> cast. In effect, by inserting <a id="_idIndexMarker648"/>the cast and overriding the compiler error, you are saying to the compiler: “Let me proceed, I know what I am doing.” So, the code compiles with the cast in place. However, at runtime, the JVM realizes that it has a <strong class="source-inline">Saloon</strong> reference referring <em class="italic">up</em> the inheritance tree to a <strong class="source-inline">Vehicle</strong> object. This is a big no-no because <em class="italic">if</em> the JVM allowed the <strong class="source-inline">Saloon</strong> reference <strong class="source-inline">s</strong> to refer to a <strong class="source-inline">Vehicle</strong> object, what would it do with a subsequent <strong class="source-inline">s.wheels()</strong> method call? Remember, we would be looking at a <strong class="source-inline">Vehicle</strong> object, which has no such method! Hence the JVM generates a <span class="No-Break"><strong class="source-inline">ClassCastException</strong></span><span class="No-Break"> error.</span></p>
			<p>Let’s refactor this code to demonstrate polymorphism from <span class="No-Break">another angle.</span></p>
			<h3>Polymorphism in code – example 2</h3>
			<p><span class="No-Break"><em class="italic">Figure 9</em></span><em class="italic">.5</em> shows the <a id="_idIndexMarker649"/>refactored code from <span class="No-Break"><em class="italic">Figure 9</em></span><span class="No-Break"><em class="italic">.4</em></span><span class="No-Break">:</span></p>
			<div>
				<div id="_idContainer138" class="IMG---Figure">
					<img src="image/B19793_09_5.jpg" alt="Figure 9.5 – Refactored polymorphism example"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.5 – Refactored polymorphism example</p>
			<p>Note that, in this figure, the inheritance hierarchy remains untouched from <span class="No-Break"><em class="italic">Figure 9</em></span><em class="italic">.4</em>. The <strong class="source-inline">TestVehicle</strong> class (lines 19-30) has been refactored though. We have introduced <a id="_idIndexMarker650"/>a new method, namely <strong class="source-inline">doAction()</strong> (lines 20-22), that accepts a <strong class="source-inline">Vehicle</strong> reference. In the <strong class="source-inline">doAction()</strong> method, we simply call the <strong class="source-inline">move()</strong> method (line 21). As <strong class="source-inline">Vehicle</strong> has a <strong class="source-inline">move()</strong> method, this <span class="No-Break">is fine.</span></p>
			<p>Line 24 is as before; it creates a <strong class="source-inline">Car</strong> object and upcasts the reference to a <strong class="source-inline">Vehicle </strong>reference, <strong class="source-inline">v</strong>. Thus, <strong class="source-inline">v</strong> is referring to a <strong class="source-inline">Car</strong> object. Line 25 invokes the <strong class="source-inline">doAction()</strong> method, passing in the reference, <strong class="source-inline">v</strong>. This reference, <strong class="source-inline">v</strong>, which is declared on line 24, is copied into the separate (different scope) but similarly named reference, <strong class="source-inline">v</strong>, which is declared on line 20. Now, in <strong class="source-inline">doAction()</strong>, we have a local <strong class="source-inline">v</strong> reference referring to the same <strong class="source-inline">Car</strong> object created on line 24. Thus, when we invoke <strong class="source-inline">v.move()</strong> on line 21, polymorphism kicks in and we get the <strong class="source-inline">Car</strong> version of <strong class="source-inline">move()</strong>, resulting <span class="No-Break">in </span><span class="No-Break"><strong class="source-inline">Car::move()</strong></span><span class="No-Break">.</span></p>
			<p>Line 26 does the same thing in one line of code as was done in the previous two lines of code (lines 24-25). On line 26, the <strong class="source-inline">Boat</strong> object is created, and the method call to <strong class="source-inline">doAction()</strong> results in the upcast to the <strong class="source-inline">Vehicle</strong> reference, <strong class="source-inline">v</strong> (line 20). After that, line 21 executes polymorphically and we get the <strong class="source-inline">Boat</strong> version of <strong class="source-inline">move()</strong>, resulting <span class="No-Break">in </span><span class="No-Break"><strong class="source-inline">Boat::move()</strong></span><span class="No-Break">.</span></p>
			<p>Line 27 is the <a id="_idIndexMarker651"/>same as line 26 except we are creating a <strong class="source-inline">Saloon</strong> object. Thus, the <strong class="source-inline">Vehicle</strong> reference, <strong class="source-inline">v</strong>, in <strong class="source-inline">doAction()</strong> executes the <strong class="source-inline">move()</strong> method as <strong class="source-inline">Saloon</strong>, resulting <span class="No-Break">in </span><span class="No-Break"><strong class="source-inline">Saloon::move()</strong></span><span class="No-Break">.</span></p>
			<p>Line 28 is the same as line 27 except we are creating a <strong class="source-inline">Convertible</strong> object. Thus, the <strong class="source-inline">Vehicle</strong> reference, <strong class="source-inline">v</strong>, in <strong class="source-inline">doAction()</strong> attempts to execute the <strong class="source-inline">move()</strong> method in <strong class="source-inline">Convertible</strong>. As there is none, the parent of <strong class="source-inline">Convertible</strong>, namely <strong class="source-inline">Car</strong>, is checked. <strong class="source-inline">Car</strong> does have a version of <strong class="source-inline">move()</strong>, resulting <span class="No-Break">in </span><span class="No-Break"><strong class="source-inline">Car::move()</strong></span><span class="No-Break">.</span></p>
			<p>To be clear about when polymorphism applies and when it does not, we will revisit a callout box <span class="No-Break">presented earlier.</span></p>
			<h2 id="_idParaDest-220"><a id="_idTextAnchor220"/>JVM – object type versus reference type usage</h2>
			<p>As discussed <a id="_idIndexMarker652"/>briefly in a previous callout, if you <a id="_idIndexMarker653"/>are dealing with any type of data (<strong class="source-inline">static</strong> or non-static), the reference type applies; when dealing with instance methods, the object type applies (polymorphism). <span class="No-Break"><em class="italic">Figure 9</em></span><em class="italic">.6</em> presents a <span class="No-Break">code example:</span></p>
			<div>
				<div id="_idContainer139" class="IMG---Figure">
					<img src="image/B19793_09_6.jpg" alt="Figure 9.6 – When the JVM uses the reference type versus the object type"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.6 – When the JVM uses the reference type versus the object type</p>
			<p>In this <a id="_idIndexMarker654"/>figure, the <strong class="source-inline">Vehicle</strong> class declares an <a id="_idIndexMarker655"/>instance variable, namely <strong class="source-inline">cost</strong> (line 4), and a class variable, namely <strong class="source-inline">age</strong> (line 5). In addition, <strong class="source-inline">Vehicle</strong> also declares an instance method called <strong class="source-inline">move()</strong> (lines 6-8) and a class method called <strong class="source-inline">sm()</strong> (lines 9-11). So, in <strong class="source-inline">Vehicle</strong>, we have both instance and <strong class="source-inline">static</strong> data and instance and <span class="No-Break"><strong class="source-inline">static</strong></span><span class="No-Break"> methods.</span></p>
			<p>The <strong class="source-inline">Car</strong> class extends from <strong class="source-inline">Vehicle</strong> (lines 13-23) and simply replicates <strong class="source-inline">Vehicle</strong>. In other words, <strong class="source-inline">Car</strong> has the same data and methods as its <span class="No-Break">parent, </span><span class="No-Break"><strong class="source-inline">Vehicle</strong></span><span class="No-Break">.</span></p>
			<p>In <strong class="source-inline">Car</strong>, we declare both instance and non-instance variables, namely <strong class="source-inline">cost</strong> and <strong class="source-inline">age</strong>, respectively (lines 14-15). These variables in <strong class="source-inline">Car</strong> have the same types and identifiers as their counterparts in the parent class, <strong class="source-inline">Vehicle</strong>. In other words, <strong class="source-inline">Vehicle</strong> has an instance variable called <strong class="source-inline">cost</strong>, which is a <strong class="source-inline">double</strong>; and <strong class="source-inline">Car</strong> also has an instance variable named <strong class="source-inline">cost</strong>, which is also a <strong class="source-inline">double</strong>. The same occurs with the <strong class="source-inline">age</strong> class variable in <strong class="source-inline">Vehicle</strong> – there is a class variable named <strong class="source-inline">age</strong> in the <strong class="source-inline">Car</strong> subclass also. This is known as <em class="italic">hiding</em> (<span class="No-Break">or </span><span class="No-Break"><em class="italic">shadowing</em></span><span class="No-Break">).</span></p>
			<p><strong class="source-inline">Vehicle</strong> defines <a id="_idIndexMarker656"/>the instance method, <strong class="source-inline">move()</strong> (lines 6-8), which is overridden by the version in <strong class="source-inline">Car</strong> (lines 17-19). As this <a id="_idIndexMarker657"/>is an instance method, polymorphism applies at runtime if <strong class="source-inline">move()</strong> <span class="No-Break">is called.</span></p>
			<p><strong class="source-inline">Vehicle</strong> also defines a class method called <strong class="source-inline">sm()</strong> (lines 9-11), which is hidden (shadowed) by the version of <strong class="source-inline">sm()</strong> in <strong class="source-inline">Car</strong> (<span class="No-Break">lines 20-22).</span></p>
			<p>Line 26 creates a <strong class="source-inline">Car</strong> object and uses a <strong class="source-inline">Vehicle</strong> reference, <strong class="source-inline">v</strong>, to refer <span class="No-Break">to it.</span></p>
			<p>Line 27 outputs <strong class="source-inline">v.cost</strong>. As <strong class="source-inline">cost</strong> is data (an instance variable), the reference type applies. Consequently, we get <strong class="source-inline">100.0</strong>, which is the <strong class="source-inline">cost</strong> instance variable in <strong class="source-inline">Vehicle</strong> (as opposed to <strong class="source-inline">20_000.0</strong>, which is the <strong class="source-inline">cost</strong> instance variable <span class="No-Break">in </span><span class="No-Break"><strong class="source-inline">Car</strong></span><span class="No-Break">).</span></p>
			<p class="callout-heading">Using the class name when accessing a static member</p>
			<p class="callout">Both lines 28 and 29 present syntax that you should <em class="italic">never</em> use: using a reference to access a <strong class="source-inline">static</strong> member. When accessing a <strong class="source-inline">static</strong> member, you should prefix the member with the class name. For example, line 28 should use <strong class="source-inline">Vehicle.age</strong> and line 29 should use <strong class="source-inline">Vehicle.sm()</strong> as this emphasizes the member’s <strong class="source-inline">static</strong> nature. Using references here is confusing as it implies that the member is non-static. We accessed <strong class="source-inline">static</strong> members using the reference for demo <span class="No-Break">purposes only!</span></p>
			<p>Line 28 outputs <strong class="source-inline">v.age</strong>. As <strong class="source-inline">age</strong> is a <strong class="source-inline">static</strong> member, the compiler checks the type for <strong class="source-inline">v</strong> (namely <strong class="source-inline">Vehicle</strong>) and changes <strong class="source-inline">v.code</strong> to <strong class="source-inline">Vehicle.code</strong>. Therefore, <strong class="source-inline">age</strong> from <strong class="source-inline">Vehicle</strong> is used as opposed to <strong class="source-inline">age</strong> from <strong class="source-inline">Car</strong>. In other words, the output is 1, <span class="No-Break">not 2.</span></p>
			<p>Line 29 is the call to <strong class="source-inline">v.sm()</strong>. As <strong class="source-inline">sm()</strong> is also <strong class="source-inline">static</strong>, the compiler translates this into <strong class="source-inline">Vehicle.sm()</strong> and therefore the output <span class="No-Break">is </span><span class="No-Break"><strong class="source-inline">Vehicle::sm()</strong></span><span class="No-Break">.</span></p>
			<p>Lastly, line 30 is the polymorphic call to <strong class="source-inline">move()</strong>, and as a result, the object type, <strong class="source-inline">Car</strong>, is used. This results in <strong class="source-inline">Car::move()</strong> <span class="No-Break">being output.</span></p>
			<p>Now that <a id="_idIndexMarker658"/>we understand polymorphism, let’s <a id="_idIndexMarker659"/>ensure that we understand the difference between two terms that are often confused, namely method overriding and <span class="No-Break">method overloading.</span></p>
			<h1 id="_idParaDest-221"><a id="_idTextAnchor221"/>Contrasting method overriding and method overloading</h1>
			<p>These two terms are often confused but in this section, we will compare and contrast both. We will show <a id="_idIndexMarker660"/>that concerning method overloading, the method signature must be different; whereas concerning method overriding, the method signature must be the same. Recall that the method signature consists of the method name and the parameter types, including their order. The return type and the parameter identifiers are <em class="italic">not</em> part of the method signature. So, for example, take the method from <span class="No-Break"><em class="italic">Figure 9</em></span><span class="No-Break"><em class="italic">.5</em></span><span class="No-Break">:</span></p>
			<pre class="source-code">
public static void doAction(Vehicle v){…}</pre>			<p>The signature <span class="No-Break">is </span><span class="No-Break"><strong class="source-inline">doAction(Vehicle)</strong></span><span class="No-Break">.</span></p>
			<p>With this in mind, we will initially discuss <span class="No-Break">method overloading.</span></p>
			<h2 id="_idParaDest-222"><a id="_idTextAnchor222"/>Method overloading</h2>
			<p>Recall that the method signature consists of the method name and the parameter types. Method overloading is <a id="_idIndexMarker661"/>where you have the same method name but the parameters differ, either in type and/or order. This means that the method signatures are different even though the method names are the same. They have to be – how else will the compiler choose which method to bind to? Thus, method overloading is all about <span class="No-Break">compile time.</span></p>
			<h3>The rules</h3>
			<p>Bearing in mind that the method signatures <em class="italic">must be different</em> (apart from the method name), the rules are <a id="_idIndexMarker662"/><span class="No-Break">quite straightforward:</span></p>
			<ul>
				<li>Overloaded methods must use <em class="italic">DIFFERENT</em> parameter lists; either the types used must be different or the order of the types must <span class="No-Break">be different</span></li>
				<li>As the method signature only relates to the method name and the parameter list, overloaded methods are free to change the return type and the access modifier and use new or broader <span class="No-Break">checked exceptions</span></li>
				<li>An overloaded method can be overloaded in the same type or <span class="No-Break">a subtype</span></li>
			</ul>
			<p>Now, let’s look at an example of method overloading <span class="No-Break">in code.</span></p>
			<h3>Method overloading example</h3>
			<p><span class="No-Break"><em class="italic">Figure 9</em></span><em class="italic">.7</em> presents the <a id="_idIndexMarker663"/><span class="No-Break">example code:</span></p>
			<div>
				<div id="_idContainer140" class="IMG---Figure">
					<img src="image/B19793_09_7.jpg" alt="Figure 9.7 – Method overloading"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.7 – Method overloading</p>
			<p>In this figure, we will first discuss the method overloading between lines 10-17. To help, the method <a id="_idIndexMarker664"/>signatures are in comments on each line. Line 10 defines a <strong class="source-inline">calc</strong> method that takes in an <strong class="source-inline">int</strong> and a <strong class="source-inline">double</strong>, in that order. Therefore, the signature is <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
calc(int, double)</pre>			<p>We are not interested in the return type or the identifiers used for the <strong class="source-inline">int</strong> and <strong class="source-inline">double</strong> parameters. So long as we do not code another <strong class="source-inline">calc(int, double)</strong> method in the <em class="italic">same class</em>, we are okay. Note that if we coded a method with the same signature in a subtype, this is overriding! As the method signatures between lines 11-14 are different, they <span class="No-Break">are fine.</span></p>
			<p>Let’s examine why lines 16 and 17 fail to compile. Line 16 attempts to just change the identifiers used for the parameters. This does not change the method signature. Consequently, this signature is an exact match for the method on line 10 and therefore, the compiler complains. Similarly, line 17 changes the return type (as well as the identifiers in the parameter list). Again, as this signature is a duplicate of the one on line 10, the <span class="No-Break">compiler complains.</span></p>
			<p>The inheritance hierarchy is interesting. We have a parent called <strong class="source-inline">Animal</strong> (lines 2-4) and a subclass class <strong class="source-inline">Cow</strong> (lines 5-8). On line 3, <strong class="source-inline">Animal</strong> defines an <strong class="source-inline">eat()</strong> method. On line 7, <strong class="source-inline">Cow</strong> overloads this method with an <strong class="source-inline">eat(String)</strong> method. The parent <strong class="source-inline">Animal</strong> version accepts no argument, whereas the subtype version accepts <strong class="source-inline">String</strong>. The compiler <span class="No-Break">is happy.</span></p>
			<p>But what about line 6, where <strong class="source-inline">Cow</strong> defines an <strong class="source-inline">eat()</strong> method that accepts no argument? This is overriding the parent version (polymorphism), so there is no conflict. The compiler will <a id="_idIndexMarker665"/>bind to the reference type used, be it <strong class="source-inline">Animal</strong> or <strong class="source-inline">Cow</strong>, as both have an <strong class="source-inline">eat()</strong> method. At runtime, depending on the object type, the JVM will execute the <span class="No-Break">relevant code.</span></p>
			<p>Let’s examine this process to make sure it is clear. Line 20 creates an <strong class="source-inline">Animal</strong> object and uses an <strong class="source-inline">Animal</strong> reference, <strong class="source-inline">aa</strong>, to refer to it. Line 21 calls <strong class="source-inline">aa.eat()</strong>. At compile time, the compiler checks if there is an <strong class="source-inline">eat()</strong> method with that exact signature in <strong class="source-inline">Animal</strong>, as <strong class="source-inline">Animal</strong> is the type for <strong class="source-inline">aa</strong>. As there is, the compiler is happy. At runtime, as the method is an instance method, polymorphism applies and the JVM will execute the <strong class="source-inline">Animal</strong> version (as that is the <span class="No-Break">object type).</span></p>
			<p>Note how line 22 does not compile. This is because there is no <strong class="source-inline">eat(String)</strong> method in <strong class="source-inline">Animal</strong>. Remember, the compiler looks at the reference type only and as <strong class="source-inline">aa</strong> is of type <strong class="source-inline">Animal</strong>, it checks the <span class="No-Break"><strong class="source-inline">Animal</strong></span><span class="No-Break"> class.</span></p>
			<p>Lines 24-26 take things one step further. Line 24 creates a <strong class="source-inline">Cow</strong> object and uses an <strong class="source-inline">Animal</strong> reference called <strong class="source-inline">ac</strong> to refer to it. Line 25 makes the polymorphic call to <strong class="source-inline">eat()</strong>, which will execute the <strong class="source-inline">Cow</strong> version at runtime. Line 26 is interesting and is there to prove that the compiler is looking at the reference type. Even though our object type is <strong class="source-inline">Cow</strong> and <strong class="source-inline">Cow</strong> has an <strong class="source-inline">eat(String)</strong> method, the <strong class="source-inline">ac.eat("Grass")</strong> class still does not compile (because <strong class="source-inline">ac</strong> is of <span class="No-Break">type </span><span class="No-Break"><strong class="source-inline">Animal</strong></span><span class="No-Break">).</span></p>
			<p>So, how do we get access to the <strong class="source-inline">eat(String)</strong> method? We need a <strong class="source-inline">Cow</strong> reference. This is what lines 28-30 demonstrate. Line 30 successfully invokes <strong class="source-inline">cc.eat("Grass")</strong> using the <strong class="source-inline">cc</strong> reference declared on <span class="No-Break">line 28.</span></p>
			<p>What this code demonstrates is that an <strong class="source-inline">Animal</strong> reference only has access to the <strong class="source-inline">eat()</strong> method it <a id="_idIndexMarker666"/>defined. On the other hand, a <strong class="source-inline">Cow</strong> reference has access to both <strong class="source-inline">eat()</strong> and <strong class="source-inline">eat(String)</strong>. The <strong class="source-inline">Cow</strong> type inherited (and overrode) <strong class="source-inline">eat()</strong> and defined <strong class="source-inline">eat(String)</strong> itself. Note that the <strong class="source-inline">Cow</strong> class did not need to override <strong class="source-inline">eat()</strong> to have access to the <span class="No-Break">inherited version.</span></p>
			<h2 id="_idParaDest-223"><a id="_idTextAnchor223"/>Method overriding</h2>
			<p>Method overriding occurs when you have the same method signatures in both a parent and subclass. Method overriding is critical for enabling (runtime) polymorphism. Remember, a method <a id="_idIndexMarker667"/>must first be inherited to be overridden. For example, methods that are defined as <strong class="source-inline">private</strong>, <strong class="source-inline">static</strong>, or <strong class="source-inline">final</strong> are not inherited because <strong class="source-inline">private</strong> methods are local to the class; <strong class="source-inline">static</strong> methods are not polymorphic and marking a method as <strong class="source-inline">final</strong> is stating that “this method is not to <span class="No-Break">be overridden.”</span></p>
			<p>To understand the rules, it is critical to remember that the compiler has compiled the code based on the reference. Therefore, the runtime polymorphic method <em class="italic">must not</em> behave differently from what the compiler verified. For example, the access modifier on the overriding method cannot be <span class="No-Break">more restrictive.</span></p>
			<p>Before we discuss the rules, we must first explain <span class="No-Break">covariant returns.</span></p>
			<h3>Covariant returns</h3>
			<p>When you are overriding a parent method in a subclass, if the return type is a primitive, then the overriding <a id="_idIndexMarker668"/>method’s return type must match. However, if the return type is a non-primitive, then there is one exception to the rule: <span class="No-Break">covariant returns.</span></p>
			<p>What a covariant return means is that if you return a type, <strong class="source-inline">X</strong>, in the parent method, then you can return <strong class="source-inline">X</strong> and any subtype of <strong class="source-inline">X</strong> in the overriding method. For example, if a parent method is returning <strong class="source-inline">Animal</strong>, then the overriding method can return <strong class="source-inline">Animal</strong>, (naturally) as well as any subtype of <strong class="source-inline">Animal</strong>; for <span class="No-Break">example, </span><span class="No-Break"><strong class="source-inline">Cow</strong></span><span class="No-Break">.</span></p>
			<h3>The rules</h3>
			<p>As we discuss <a id="_idIndexMarker669"/>the rules, it is helpful to bear in mind that the compiler checks against the reference type. These overriding rules ensure that the runtime object cannot do something that the compiler (and thus your code) does not expect. The rules are <span class="No-Break">as follows:</span></p>
			<ul>
				<li>The method signatures must match exactly in the parent and subclass; otherwise, you are just overloading <span class="No-Break">the method.</span></li>
				<li>The return types must match also, except for <span class="No-Break">covariant returns.</span></li>
				<li>The access modifier on the overriding method cannot be more restrictive. So, if the parent method defines a method as <strong class="source-inline">public</strong>, the subclass cannot override it with a <strong class="source-inline">private</strong> method. This makes sense, as your code, verified by the compiler, is expecting access to the method. <em class="italic">If</em>, however, you were allowed to <a id="_idIndexMarker670"/>reduce access when overriding, the compiler would have said “It is okay to access this method,” whereas the JVM would not! This rule helps keep the compiler and JVM <span class="No-Break">in sync.</span></li>
				<li>Again, to keep the compiler and JVM in sync, an overriding method cannot throw (generate) new or broader checked exceptions (<a href="B19793_11.xhtml#_idTextAnchor266"><em class="italic">Chapter 11</em></a>). Briefly, an exception is an error and checked exceptions must have code present to handle them. This is enforced by the compiler. If, at runtime, the overriding method threw/generated an exception for which there was no code to handle it, the JVM would be in trouble. So, the compiler steps in and prevents that <span class="No-Break">from happening.</span></li>
			</ul>
			<p>Now, let’s look at an example of method overriding <span class="No-Break">in code.</span></p>
			<h3>Method overriding example</h3>
			<p><span class="No-Break"><em class="italic">Figure 9</em></span><em class="italic">.8</em> presents the <a id="_idIndexMarker671"/><span class="No-Break">example code:</span></p>
			<div>
				<div id="_idContainer141" class="IMG---Figure">
					<img src="image/B19793_09_8.jpg" alt="Figure 9.8 – Method overriding"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.8 – Method overriding</p>
			<p>The code in this <a id="_idIndexMarker672"/>figure demonstrates what you can and cannot do when overriding a method. In the <strong class="source-inline">Dog</strong> class (lines 5-8), we have a <strong class="source-inline">walk()</strong> method that returns nothing (<strong class="source-inline">void</strong>). There is also a <strong class="source-inline">run()</strong> method that <span class="No-Break">returns </span><span class="No-Break"><strong class="source-inline">Dog</strong></span><span class="No-Break">.</span></p>
			<p>The <strong class="source-inline">Terrier</strong> class subclasses from <strong class="source-inline">Dog</strong> (line 9). Therefore, any <strong class="source-inline">Terrier</strong> “is-a” <strong class="source-inline">Dog</strong>. As the two methods in <strong class="source-inline">Dog</strong> are <strong class="source-inline">public</strong>, <strong class="source-inline">Terrier</strong> automatically <span class="No-Break">inherits them.</span></p>
			<p>Let’s examine the lines in <strong class="source-inline">Terrier</strong> <span class="No-Break">in turn.</span></p>
			<p>Line 10 does not compile because, while the method signatures match (both are <strong class="source-inline">walk()</strong>), the return types are different. The parent return type is <strong class="source-inline">void</strong> and thus, the overriding return type must match; it does not, it is <strong class="source-inline">String</strong>, causing the <span class="No-Break">compiler error.</span></p>
			<p>Line 11 does not compile because you cannot weaken the access modifier when overriding. The <strong class="source-inline">walk()</strong> method in <strong class="source-inline">Dog</strong> is <strong class="source-inline">public</strong>, so <strong class="source-inline">walk()</strong> in <strong class="source-inline">Terrier</strong> cannot be <strong class="source-inline">private</strong>. <em class="italic">If</em> this was allowed, then when the JVM went to execute the <strong class="source-inline">walk()</strong> method in <strong class="source-inline">Terrier</strong>, using a <strong class="source-inline">Dog</strong> reference (as on line 24), there would be a serious problem. The compiler, looking at the <strong class="source-inline">public</strong> <strong class="source-inline">Dog</strong> version, said “All is well;” but the JVM would, polymorphically, encounter the <strong class="source-inline">private</strong> version <span class="No-Break">in </span><span class="No-Break"><strong class="source-inline">Terrier</strong></span><span class="No-Break">!</span></p>
			<p>Line 12 fails to compile <a id="_idIndexMarker673"/>because the overridden method did not throw any exceptions but the overriding method is attempting to throw a new checked exception (<strong class="source-inline">IOException</strong>). This is similar to the previous access issue – the compiler will have checked the <strong class="source-inline">walk()</strong> version in <strong class="source-inline">Dog</strong> and as it throws no exceptions (errors), no code is present to handle (cater) for these exceptions. <em class="italic">If</em> the overriding method was allowed to throw new checked exceptions, what would the JVM do with them (as there is no code in place to <span class="No-Break">handle them)?</span></p>
			<p>Line 13 is simply an overload. <strong class="source-inline">Dog</strong> defines a <strong class="source-inline">walk()</strong> method; <strong class="source-inline">Terrier</strong> defines a <strong class="source-inline">walk(int)</strong> method. Two separate method signatures means two separate methods. As the methods have the same name, this is <span class="No-Break">method overloading.</span></p>
			<p>Line 14 is a correct method override. We used the <strong class="source-inline">@Override</strong> annotation to ensure that we have overridden properly (no typos, <span class="No-Break">for example).</span></p>
			<p>Line 16 is an exact duplication of the <strong class="source-inline">run()</strong> method defined on line 7. We just included it for <span class="No-Break">demonstration purposes.</span></p>
			<p>Line 17 demonstrates covariant returns because it defines a <strong class="source-inline">Terrier</strong> return type. This is a valid covariant return because <strong class="source-inline">Terrier</strong> is a subtype of the parent return type, <strong class="source-inline">Dog</strong> (line 7). The code for the overridden method (line 17) simply returns a <span class="No-Break"><strong class="source-inline">Terrier</strong></span><span class="No-Break"> object.</span></p>
			<p>Line 18 is almost identical to line 17 except that the return type is now <strong class="source-inline">Dog</strong>. Thus, there is an upcast going on in the background. The code for <strong class="source-inline">walk()</strong> on line 18 is shorthand for <span class="No-Break">the following:</span></p>
			<pre class="source-code">
Dog d = new Terrier():return d;</pre>
			<p>Now, let’s look at the <strong class="source-inline">main()</strong> method <span class="No-Break">in </span><span class="No-Break"><strong class="source-inline">OverridingTest</strong></span><span class="No-Break">.</span></p>
			<p>Line 23 creates a <strong class="source-inline">Terrier</strong> object that can be accessed via a <strong class="source-inline">Dog</strong> reference, <strong class="source-inline">dt</strong>. Line 24 invokes the polymorphic <strong class="source-inline">walk()</strong> method in <strong class="source-inline">Terrier</strong>. As <strong class="source-inline">Terrier</strong> overrode the <strong class="source-inline">walk()</strong> method it inherited from <strong class="source-inline">Dog</strong>, the <strong class="source-inline">Terrier</strong> version is dynamically executed at runtime, resulting in <strong class="source-inline">Terrier::walk()</strong> <span class="No-Break">being output.</span></p>
			<p>Line 25 executes the <strong class="source-inline">run()</strong> method using the <strong class="source-inline">dt</strong> reference created on line 23. As <strong class="source-inline">run()</strong> is an instance <a id="_idIndexMarker674"/>method where <strong class="source-inline">Terrier</strong> overrode the version inherited from <strong class="source-inline">Dog</strong>, the version in <strong class="source-inline">Terrier</strong> is executed, resulting in the <strong class="source-inline">d</strong> reference (line 25) referring to a <strong class="source-inline">Terrier</strong> object (line 18). This is proven by the use of the <strong class="source-inline">instanceof</strong> operator (line 26). As the <strong class="source-inline">Dog</strong> reference, <strong class="source-inline">d</strong>, is indeed referring to a <strong class="source-inline">Terrier</strong> object, the <strong class="source-inline">if</strong> statement is <strong class="source-inline">true</strong>, resulting in <em class="italic">Terrier object</em> being output to <span class="No-Break">the screen.</span></p>
			<p>That concludes our discussion of method overloading and method overriding. Now, let’s examine a keyword that is pivotal in <span class="No-Break">inheritance: </span><span class="No-Break"><strong class="source-inline">super</strong></span><span class="No-Break">.</span></p>
			<h1 id="_idParaDest-224"><a id="_idTextAnchor224"/>Exploring the super keyword</h1>
			<p>The <strong class="source-inline">super</strong> keyword is used in a subclass in two specific scenarios: to call a parent constructor and to access parent members (typically methods). When an object is constructed, the order of constructor calls <a id="_idIndexMarker675"/>is very important. Bearing in mind that we now have the possibility of having many classes in an inheritance hierarchy, <em class="italic">the order of constructor calls is from the top down</em>. This means that, the parent constructor is <em class="italic">always</em> called before the subclass constructor. If you have a hierarchy where <strong class="source-inline">Toyota</strong> “is-a” <strong class="source-inline">Car</strong> and <strong class="source-inline">Car</strong> “is-a” <strong class="source-inline">Vehicle</strong>, then when you go to create a <strong class="source-inline">Toyota</strong> object, the order of constructor calls is as follows: <strong class="source-inline">Vehicle</strong> is first, <strong class="source-inline">Car</strong> is second, and <strong class="source-inline">Toyota</strong> <span class="No-Break">is last.</span></p>
			<p>There is a good reason for this. Firstly, remember that the constructor’s role is to initialize the instance members of the class. Now, given that the subclass constructor <em class="italic">may use inherited members</em> from its parent when initializing its own members, it stands to reason that the parent must first get a chance to initialize <span class="No-Break">those members.</span></p>
			<p>Let’s discuss the situations where the <strong class="source-inline">super</strong> keyword is very often used. We will then present code, supported by a UML diagram, where both contexts <span class="No-Break">are demonstrated.</span></p>
			<h2 id="_idParaDest-225"><a id="_idTextAnchor225"/>super()</h2>
			<p>When you use <a id="_idIndexMarker676"/>the parentheses after <strong class="source-inline">super</strong>, as in <strong class="source-inline">super()</strong>, you are invoking the parent constructor. If required, you can pass in arguments inside the parentheses as constructors are just (special) methods. There are two rules for the use <span class="No-Break">of </span><span class="No-Break"><strong class="source-inline">super()</strong></span><span class="No-Break">:</span></p>
			<ul>
				<li>The call to <strong class="source-inline">super()</strong> can only appear inside a constructor and not a <span class="No-Break">regular method</span></li>
				<li>If present, the call to <strong class="source-inline">super()</strong> must be the very first line in the constructor (there is one exception – see <span class="No-Break">the callout)</span></li>
			</ul>
			<p>We have coded several constructors so far and none of them had a call to <strong class="source-inline">super()</strong> present. How did that work? Well, if you <em class="italic">do not</em> provide any constructor at all, the default constructor will be synthesized by the compiler for you and its first line of code is <strong class="source-inline">super();</strong>. Please refer back to <span class="No-Break"><em class="italic">Figure 8</em></span><em class="italic">.1</em> and <span class="No-Break"><em class="italic">Figure 8</em></span><em class="italic">.2</em> for examples of this. If you <em class="italic">do</em> provide a constructor, then the compiler will also insert <strong class="source-inline">super();</strong> as the first line (unless the first line is already a call to <strong class="source-inline">super()</strong> or <span class="No-Break"><strong class="source-inline">this()</strong></span><span class="No-Break"> ).</span></p>
			<p class="callout-heading">The first line of any constructor</p>
			<p class="callout">The very first line of any constructor is <strong class="source-inline">this()</strong> or <strong class="source-inline">super()</strong>. You cannot have both. A call to <strong class="source-inline">this()</strong> is a call to another constructor in the same class. From the inheritance hierarchy perspective, this is a sideways call. Remember that the parent constructor must be called before the subclass constructor. Regardless of whether <strong class="source-inline">this()</strong> is present or not, the order of constructor calls is from the top down. Now, if the subclass constructor has a <strong class="source-inline">this()</strong> call present, it is only delaying the call to <strong class="source-inline">super()</strong>. At some point, either explicitly or implicitly, the call to <strong class="source-inline">super()</strong> will execute. Note that, as with <strong class="source-inline">super()</strong>, the call to <strong class="source-inline">this()</strong> can <span class="No-Break">contain arguments.</span></p>
			<p>So, <strong class="source-inline">super()</strong> relates only to constructors and must be the first line of code (assuming <strong class="source-inline">this()</strong> is not there already). Now, let’s examine the <span class="No-Break">other scenario.</span></p>
			<h2 id="_idParaDest-226"><a id="_idTextAnchor226"/>super.</h2>
			<p>To access <a id="_idIndexMarker677"/>a parent member (not the constructor), you can use the <strong class="source-inline">super.</strong> dot notation syntax. As with the <strong class="source-inline">this</strong> keyword, the <strong class="source-inline">super</strong> keyword relates to instances and thus cannot be used from within a <strong class="source-inline">static</strong> context (<strong class="source-inline">static</strong> methods or <strong class="source-inline">static</strong> blocks). This can be very useful when you want to piggyback on parent functionality. For example, the subclass method can invoke its parent version first and then <a id="_idIndexMarker678"/>execute its own version. This is what we will demonstrate in <span class="No-Break">the example.</span></p>
			<p>So, rather than call a parent constructor from a subclass constructor (which is what <strong class="source-inline">super()</strong> is for), <strong class="source-inline">super.</strong> gives us access to the other (<span class="No-Break">non-constructor) members.</span></p>
			<h2 id="_idParaDest-227"><a id="_idTextAnchor227"/>An example of using super</h2>
			<p>Let’s examine <a id="_idIndexMarker679"/>both <strong class="source-inline">super()</strong> and <strong class="source-inline">super.</strong> in code. <span class="No-Break"><em class="italic">Figure 9</em></span><em class="italic">.9</em> presents <a id="_idIndexMarker680"/>the UML <span class="No-Break">inheritance diagram:</span></p>
			<div>
				<div id="_idContainer142" class="IMG---Figure">
					<img src="image/B19793_09_9.jpg" alt="Figure 9.9 – UML for demonstrating super() and super."/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.9 – UML for demonstrating super() and super.</p>
			<p>In this figure, we have <a id="_idIndexMarker681"/>three classes representing a class inheritance hierarchy. <strong class="source-inline">Employee</strong> is at the top of the hierarchy. <strong class="source-inline">Manager</strong> “is-a” <strong class="source-inline">Employee</strong> and <strong class="source-inline">Director</strong> “is-a” <strong class="source-inline">Manager</strong>. Indirectly, <strong class="source-inline">Director</strong> “is-a” <strong class="source-inline">Employee</strong> also. Each of <a id="_idIndexMarker682"/>the classes has <strong class="source-inline">private</strong> instance variables that its respective constructors will initialize, based on the arguments passed into the respective constructor. For example, the <strong class="source-inline">Employee</strong> constructor takes in two parameters, <strong class="source-inline">int</strong> followed by <strong class="source-inline">String</strong>; these parameters will be used to initialize the <strong class="source-inline">Employee</strong> instance variables, namely <strong class="source-inline">empId</strong> (<strong class="source-inline">int</strong>) and <span class="No-Break"><strong class="source-inline">name</strong></span><span class="No-Break"> (</span><span class="No-Break"><strong class="source-inline">String</strong></span><span class="No-Break">).</span></p>
			<p><strong class="source-inline">EmployeeTest</strong> is simply the driver to ensure the code is working as it should. Let’s examine the code. <span class="No-Break"><em class="italic">Figure 9</em></span><em class="italic">.10</em> is the code for the UML in <span class="No-Break"><em class="italic">Figure 9</em></span><span class="No-Break"><em class="italic">.9</em></span><span class="No-Break">:</span></p>
			<div>
				<div id="_idContainer143" class="IMG---Figure">
					<img src="image/B19793_09_10.jpg" alt="Figure 9.10 – Code demonstrating super"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.10 – Code demonstrating super</p>
			<p>In this figure, the <strong class="source-inline">Employee</strong> class initializes <a id="_idIndexMarker683"/>its instance variables (<a id="_idIndexMarker684"/>lines 8-9). The <strong class="source-inline">toString()</strong> method for <strong class="source-inline">Employee</strong> (line 11) returns a <strong class="source-inline">String</strong> outlining the values in the <strong class="source-inline">empId</strong> and <strong class="source-inline">name</strong> instance variables. Line 11 also uses the <strong class="source-inline">@Override</strong> annotation because it is overriding the <strong class="source-inline">toString()</strong> method inherited <span class="No-Break">from </span><span class="No-Break"><strong class="source-inline">Object</strong></span><span class="No-Break">.</span></p>
			<p>The <strong class="source-inline">Manager</strong> class “is-a” <strong class="source-inline">Employee</strong> (line 13). <strong class="source-inline">Manager</strong> contains (is composed of) a <strong class="source-inline">String</strong> instance variable, namely <strong class="source-inline">deptName</strong>. This is known <span class="No-Break">as composition.</span></p>
			<p class="callout-heading">Composition versus inheritance</p>
			<p class="callout">Composition defines a <em class="italic">“has-a”</em> relationship whereas, inheritance defines an <em class="italic">“is-a”</em> relationship. Composition is where an object is “composed” of other objects. For example, <strong class="source-inline">Car</strong> has <strong class="source-inline">Engine</strong>. In <span class="No-Break"><em class="italic">Figure 9</em></span><em class="italic">.10</em>, <strong class="source-inline">Manager</strong> “is-a” <strong class="source-inline">Employee</strong> (line 13), but <strong class="source-inline">Manager</strong> “has-a” department, which is represented by the <strong class="source-inline">String</strong> instance variable <strong class="source-inline">deptName</strong> (<span class="No-Break">line 14).</span></p>
			<p>The <strong class="source-inline">Manager</strong> constructor (lines 16-19) is where things get interesting. Line 17, <strong class="source-inline">super(empId, name)</strong>, is the call to the parent constructor in <strong class="source-inline">Employee</strong> passing up the employee ID (<strong class="source-inline">empId</strong>) and employee name (<strong class="source-inline">name</strong>) that are required by the <strong class="source-inline">Employee</strong> constructor. That is why the <strong class="source-inline">Manager</strong> constructor requires those parameters in the first place – it needs the employee ID and employee name so it can invoke its parent <strong class="source-inline">Employee</strong> constructor<a id="_idIndexMarker685"/>. The <strong class="source-inline">Manager</strong> constructor also <a id="_idIndexMarker686"/>requires the department name so that it can initialize its own instance variable, <strong class="source-inline">deptName</strong>. Thus, when executing a <strong class="source-inline">Manager</strong> constructor, the <strong class="source-inline">Employee</strong> constructor is executed first and then the <strong class="source-inline">Manager</strong> <span class="No-Break">constructor executes.</span></p>
			<p>Note that if line 17 is commented out, the code will not compile. Why? Because the compiler will now insert <strong class="source-inline">super()</strong>; which is attempting to call the <strong class="source-inline">Employee</strong> constructor with no-arguments (the <strong class="source-inline">no-args</strong> constructor, namely <strong class="source-inline">Employee()</strong>). There is no such constructor in <strong class="source-inline">Employee</strong>. Additionally, as <strong class="source-inline">Employee</strong> has already defined a constructor, the compiler will not insert the default (<span class="No-Break"><strong class="source-inline">no-args</strong></span><span class="No-Break">) constructor.</span></p>
			<p>The <strong class="source-inline">Manager</strong> classes’ <strong class="source-inline">toString()</strong> method (lines 21-24), overrides the version inherited from <strong class="source-inline">Employee</strong>. However, <strong class="source-inline">Manager</strong> can still access the <strong class="source-inline">Employee</strong> version, which it does by using <strong class="source-inline">super.toString()</strong> on line 23. Thus, the <strong class="source-inline">toString()</strong> method in <strong class="source-inline">Manager</strong> first executes the <strong class="source-inline">toString()</strong> method in <strong class="source-inline">Employee</strong>, which returns the employee ID and employee name. The <strong class="source-inline">Manager</strong> classes’ <strong class="source-inline">toString()</strong> method then appends its own instance variable, <strong class="source-inline">deptName</strong>, to the overall <strong class="source-inline">String</strong> to <span class="No-Break">be returned.</span></p>
			<p>The <strong class="source-inline">Director</strong> class behaves similarly to <strong class="source-inline">Manager</strong>. The constructor “supers up” (line 30) the required data for the <strong class="source-inline">Manager</strong> constructor; in turn, the <strong class="source-inline">Manager</strong> constructor supers up the required data for the <strong class="source-inline">Employee</strong> constructor. So, when creating a <strong class="source-inline">Director</strong> object, the order of constructor calls is as follows: <strong class="source-inline">Employee</strong> is first; <strong class="source-inline">Manager</strong> is second; <strong class="source-inline">Director</strong> is last. On line 31, <strong class="source-inline">Director</strong> initializes its own <span class="No-Break">instance data.</span></p>
			<p>The <strong class="source-inline">Director</strong> version of <strong class="source-inline">toString()</strong>, on line 33, first calls the <strong class="source-inline">Manager</strong> version of <strong class="source-inline">toString()</strong> using <strong class="source-inline">super.toString()</strong>. The <strong class="source-inline">Manager</strong> version (line 23) then calls the <strong class="source-inline">Employee</strong> classes’ <strong class="source-inline">toString()</strong> method, which is on line 11. So, the employee’s ID and name are the first employee details in the string. Next, the manager data (<strong class="source-inline">deptName</strong>) is appended (after the call to the <strong class="source-inline">Employee</strong> classes’ <strong class="source-inline">toString()</strong> method returns). Lastly, the <strong class="source-inline">Director</strong> data (<strong class="source-inline">budget</strong>) is appended to the string (after the call to the <strong class="source-inline">Manager</strong> classes’ <strong class="source-inline">toString()</strong> method returns). Note that you cannot <a id="_idIndexMarker687"/>bypass a level in the hierarchy; meaning that, <strong class="source-inline">super.super.</strong> is <span class="No-Break">not allowed.</span></p>
			<p><strong class="source-inline">EmployeeTest</strong> is the driver class. In <strong class="source-inline">main()</strong> on line 39, we create a <strong class="source-inline">Director</strong> object that can <a id="_idIndexMarker688"/>be accessed via an <strong class="source-inline">Employee</strong> reference of <strong class="source-inline">emplDir</strong> (implicit upcasting). Using <strong class="source-inline">super()</strong> as outlined, this results in the <strong class="source-inline">Employee</strong> constructor being executed first, followed by the <strong class="source-inline">Manager</strong> constructor, and lastly the <strong class="source-inline">Director</strong> constructor <span class="No-Break">being executed.</span></p>
			<p>Line 40 passes the <strong class="source-inline">emplDir</strong> reference to <strong class="source-inline">System.out.println()</strong>, resulting in a polymorphic call to the <strong class="source-inline">Director</strong> classes’ <strong class="source-inline">toString()</strong> method. Using <strong class="source-inline">super.toString()</strong>, <strong class="source-inline">Director</strong> invokes the <strong class="source-inline">Manager</strong> classes’ <strong class="source-inline">toString()</strong> method, which also has a <strong class="source-inline">super.toString()</strong> method resulting in <strong class="source-inline">Employee</strong> <strong class="source-inline">toString()</strong> being executed first. Then, the <strong class="source-inline">Manager</strong> classes’ <strong class="source-inline">toString()</strong> method finishes, and lastly, the <strong class="source-inline">Director</strong> classes’ <strong class="source-inline">toString()</strong> method finishes. The output <span class="No-Break">shows this:</span></p>
			<pre class="console">
ID: 754, Name: Joe Bloggs, Department: Marketing, Budget:10000.0</pre>
			<p>Regarding the output, <strong class="source-inline">ID: 754, Name: Joe Bloggs</strong> is output from <strong class="source-inline">Employee toString()</strong>, <strong class="source-inline">Department: Marketing</strong> is output from the <strong class="source-inline">Department toString()</strong>, and <strong class="source-inline">Budget: 10000.0</strong> is output from <span class="No-Break"><strong class="source-inline">Director toString()</strong></span><span class="No-Break">.</span></p>
			<p>That concludes our discussion on <strong class="source-inline">super</strong>. Now that we understand inheritance, as promised in <a href="B19793_08.xhtml#_idTextAnchor168"><span class="No-Break"><em class="italic">Chapter 8</em></span></a>, let’s return to the <strong class="source-inline">protected</strong> <span class="No-Break">access modifier.</span></p>
			<h1 id="_idParaDest-228"><a id="_idTextAnchor228"/>Revisiting the protected access modifier</h1>
			<p>Recall that a <strong class="source-inline">protected</strong> member is accessible from within its own package and any subclasses outside of the package: <em class="italic">protected = package + children</em>. On the face of it, this seems very <a id="_idIndexMarker689"/>straightforward. However, some nuances lead to confusion. The subclasses that access the <strong class="source-inline">protected</strong> member (via inheritance), can only do so <em class="italic">in a very specific way</em>. A subclass from outside the package cannot use a superclass reference to access the <strong class="source-inline">protected</strong> member! In addition, an unrelated class from outside the package cannot use a reference to the subclass outside the package either to access the <strong class="source-inline">protected</strong> member. In effect, once the subclass that’s outside the package inherits the <strong class="source-inline">protected</strong> member, that member becomes <strong class="source-inline">private</strong> to the subclass (and subclasses of the subclass). This is quite tricky and definitely needs <span class="No-Break">an example.</span></p>
			<h2 id="_idParaDest-229"><a id="_idTextAnchor229"/>The UML diagram</h2>
			<p> <span class="No-Break"><em class="italic">Figure 9</em></span><em class="italic">.11</em> shows the <a id="_idIndexMarker690"/>UML <a id="_idIndexMarker691"/>diagram for <span class="No-Break">this example:</span></p>
			<div>
				<div id="_idContainer144" class="IMG---Figure">
					<img src="image/B19793_09_11.jpg" alt="Figure 9.11 – UML for “protected” code"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.11 – UML for “protected” code</p>
			<p>In this figure, we have two packages, namely <strong class="source-inline">ch9.pkgA</strong> and <strong class="source-inline">ch9.pkgB</strong>. In <strong class="source-inline">ch9.pkgA</strong>, we have a <strong class="source-inline">Book</strong> class and its subclass, <strong class="source-inline">NonFictionBook</strong>. The <strong class="source-inline">read()</strong> method in <strong class="source-inline">Book</strong> is marked with the <strong class="source-inline">#</strong> symbol, which means it is <strong class="source-inline">protected</strong>. The <strong class="source-inline">Magnifier</strong> class is not related to <strong class="source-inline">Book</strong> and is simply another class in the <span class="No-Break">same package.</span></p>
			<p>In <strong class="source-inline">ch9.pkgB</strong>, <strong class="source-inline">FictionBook</strong> subclasses <strong class="source-inline">Book</strong> from <strong class="source-inline">ch9.pkgA</strong> and provides a <strong class="source-inline">doThings()</strong> method, which we will use to demonstrate what is/is not allowed. In addition, <strong class="source-inline">SpaceFictionBook</strong> subclasses <strong class="source-inline">FictionBook</strong> and overrides the <strong class="source-inline">doThings()</strong> method inherited from <strong class="source-inline">FictionBook</strong>. Lastly, <strong class="source-inline">Reader</strong> is a completely separate class <a id="_idIndexMarker692"/>from the <strong class="source-inline">Book</strong> hierarchy; its <strong class="source-inline">doThings()</strong> method is also a <a id="_idIndexMarker693"/>sample method for <span class="No-Break">demo purposes.</span></p>
			<p>Recall from the previous chapter that we had not fully completed the access modifiers table (as we had not covered inheritance at that point). <em class="italic">Table 9.1</em> represents the completed access modifiers table. Bear in mind that the table represents annotating a member in the <span class="No-Break"><strong class="source-inline">Book</strong></span><span class="No-Break"> class.</span></p>
			<div>
				<div id="_idContainer145" class="IMG---Figure">
					<img src="image/B19793_09_Table_01.jpg" alt="Table 9.1 - Access modifiers table with ‘protected’ row fully filled out"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Table 9.1 - Access modifiers table with ‘protected’ row fully filled out</p>
			<p>Examining the <strong class="source-inline">protected</strong> row, we can now see that subclasses, regardless of the package, can access inherited <span class="No-Break">protected members.</span></p>
			<p>Now let us examine the code for each of the packages in turn. Firstly, we will examine the package that defines the <span class="No-Break"><strong class="source-inline">protected</strong></span><span class="No-Break"> member.</span></p>
			<h2 id="_idParaDest-230"><a id="_idTextAnchor230"/>The package with the protected member</h2>
			<p><span class="No-Break"><em class="italic">Figure 9</em></span><em class="italic">.12</em> shows the <a id="_idIndexMarker694"/>code for the first package, <strong class="source-inline">ch9.pkgA</strong>, from <span class="No-Break"><em class="italic">Figure 9</em></span><span class="No-Break"><em class="italic">.11</em></span><span class="No-Break">:</span></p>
			<div>
				<div id="_idContainer146" class="IMG---Figure">
					<img src="image/B19793_09_12.jpg" alt="Figure 9.12 – Code for “ch9.pkgA” from UML"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.12 – Code for “ch9.pkgA” from UML</p>
			<p>In this figure, we have a class called <strong class="source-inline">Book</strong> (lines 3-5) that defines a <strong class="source-inline">protected</strong> <strong class="source-inline">read()</strong> method (line 4). <strong class="source-inline">NonFictionBook</strong> is a subclass of <strong class="source-inline">Book</strong> and has its own <strong class="source-inline">doThings()</strong> method (lines 7-9). In addition, there is a completely unrelated class to <strong class="source-inline">Book</strong>, <span class="No-Break">namely </span><span class="No-Break"><strong class="source-inline">Magnifier</strong></span><span class="No-Break">.</span></p>
			<p>The first thing to note is that, as the <strong class="source-inline">read()</strong> method is <strong class="source-inline">protected</strong>, other code in the same package can access it, even if the code is <em class="italic">not</em> a subclass. This is demonstrated by line 14, where the <strong class="source-inline">read()</strong> method in <strong class="source-inline">Book</strong> is accessed from <strong class="source-inline">Magnifier</strong>, a completely <span class="No-Break">unrelated class.</span></p>
			<p>Of course, regardless <a id="_idIndexMarker695"/>of the package, subclasses can access the <strong class="source-inline">protected</strong> member. This is shown on line 8, where the <strong class="source-inline">NonFictionBook</strong> subclass invokes <strong class="source-inline">read()</strong>. Remember that line 8 is essentially <strong class="source-inline">this.read()</strong>. So, whichever <strong class="source-inline">NonFictionBook</strong> object is used to invoke <strong class="source-inline">doThings()</strong> on line 7 will be used to invoke the inherited (and <strong class="source-inline">protected</strong>) <strong class="source-inline">read()</strong> method on <span class="No-Break">line 4.</span></p>
			<p>The interesting code is in the other package, namely <strong class="source-inline">ch9.pkgB</strong>. Let’s examine <span class="No-Break">that now.</span></p>
			<h2 id="_idParaDest-231"><a id="_idTextAnchor231"/>The other package</h2>
			<p><span class="No-Break"><em class="italic">Figure 9</em></span><em class="italic">.13</em> presents <a id="_idIndexMarker696"/><span class="No-Break">the code:</span></p>
			<p class="IMG---Figure"> </p>
			<div>
				<div id="_idContainer147" class="IMG---Figure">
					<img src="image/B19793_09_13.jpg" alt="Figure 9.13 – Code for “ch9.pkgB” from UML"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.13 – Code for “ch9.pkgB” from UML</p>
			<p>In this figure, we can see that <strong class="source-inline">FictionBook</strong> “is-a” <strong class="source-inline">Book</strong> (line 5) and <strong class="source-inline">SpaceFictionBook</strong> “is-a” <strong class="source-inline">FictionBook</strong> (line 19). For this hierarchy to be possible, the <strong class="source-inline">Book</strong> class needed to be imported from the other package (line 3). We were only able to import <strong class="source-inline">Book</strong> from another package because <strong class="source-inline">Book</strong> is a <strong class="source-inline">public</strong> class. In addition, we have a completely unrelated class called <strong class="source-inline">Reader</strong> (<span class="No-Break">lines 27-36).</span></p>
			<p>Now, for the fun! Let’s examine the <strong class="source-inline">dothings()</strong> method in <strong class="source-inline">FictionBook</strong> (lines 6-17). Lines 7 and 8 are essentially equivalent and show that subclasses outside the package, when using <em class="italic">inheritance directly</em>, can access <span class="No-Break"><strong class="source-inline">protected</strong></span><span class="No-Break"> members.</span></p>
			<p>Lines 9-10 also show that when inside the subclass outside the package, if you create an instance of that particular subclass (<strong class="source-inline">FictionBook</strong>, in this instance), then all is ok. This makes sense because the two references used to invoke <strong class="source-inline">read()</strong> without issue, namely <strong class="source-inline">this</strong> and <strong class="source-inline">fb</strong>, are both of type <strong class="source-inline">FictionBook</strong>, where the <span class="No-Break">code resides.</span></p>
			<p>Note that line 15, where we instantiate a <strong class="source-inline">Book</strong> object, compiles because the <strong class="source-inline">Book</strong> class (<span class="No-Break"><em class="italic">Figure 9</em></span><em class="italic">.12</em>, line 3) is <strong class="source-inline">public</strong>. The <strong class="source-inline">Book</strong> class did not define a constructor, so the default constructor was created for us. This default constructor takes on the same access as the class, namely <strong class="source-inline">public</strong>, and as a result, we can invoke the constructor from a <span class="No-Break">different package.</span></p>
			<p>Line 16, which does <a id="_idIndexMarker697"/>not compile, is very interesting. When inside the subclass outside the package, you cannot access the <strong class="source-inline">protected</strong> member using the superclass reference – even though the <strong class="source-inline">protected</strong> member resides in that superclass! Remember that, once outside the package, the <strong class="source-inline">protected</strong> member becomes <strong class="source-inline">private</strong> to subclasses (and their subclasses). In other words, you must use inheritance in a very <span class="No-Break">specific way.</span></p>
			<p><strong class="source-inline">SpaceFictionBook</strong> (lines 19-26) shows that access is available to subclasses of the subclass outside the package. Line 21 is the same as line 7, except that they are in two separate classes. As this line compiles, it demonstrates that subclasses of the subclass outside the package have access to the <strong class="source-inline">protected</strong> member in the <span class="No-Break">base class.</span></p>
			<p>Lines 22 and 23 both fail to compile. Line 22 tries to access the <strong class="source-inline">protected</strong> member via a <strong class="source-inline">Book</strong> reference and line 23 tries to access it via a <strong class="source-inline">FictionBook</strong> reference. Both fail. Contrast this with line 24, which uses an instance of the current class, namely <strong class="source-inline">SpaceFictionBook</strong>, which works. Note that line 24 is similar to line 21 in that a <strong class="source-inline">SpaceFictionBook</strong> reference is used in both instances (as line 21 is equivalent to <strong class="source-inline">this.read()</strong>). In addition, line 24 is very similar to lines 9-10. Therefore, when in a subclass outside the package, access the <strong class="source-inline">protected</strong> member directly, as on lines 7, 21; or use a reference to the current subclass, as on lines <span class="No-Break">10, 24.</span></p>
			<p>The <strong class="source-inline">Reader</strong> class (lines 27-36) is a completely separate class from the <strong class="source-inline">Book</strong> hierarchy. Line 30 attempts to access the <strong class="source-inline">protected</strong> member using a reference to the class that defines the <strong class="source-inline">protected</strong> member, namely <strong class="source-inline">Book</strong>, and fails. Line 34 attempts to access the <strong class="source-inline">protected</strong> member using a reference to the subclass outside the package that inherits the <strong class="source-inline">protected</strong> member, namely <strong class="source-inline">FictionBook</strong>, and <span class="No-Break">also fails.</span></p>
			<p>So <strong class="source-inline">protected</strong> is somewhat tricky. While we are revisiting previous topics, it is an ideal opportunity to revisit <strong class="source-inline">switch</strong>. To be more specific, to discuss pattern matching <span class="No-Break">for </span><span class="No-Break"><strong class="source-inline">switch</strong></span><span class="No-Break">.</span></p>
			<h2 id="_idParaDest-232"><a id="_idTextAnchor232"/>Pattern matching for switch</h2>
			<p>As <a id="_idIndexMarker698"/>promised from <a href="B19793_04.xhtml#_idTextAnchor087"><span class="No-Break"><em class="italic">Chapter 4</em></span></a>, now that we understand inheritance and polymorphism, we are going to revisit the <strong class="source-inline">switch</strong>. Given the <span class="No-Break">following code:</span></p>
			<pre class="source-code">
<strong class="source-inline">public static void patternMatchingSwitch(Vehicle v) {</strong><strong class="source-inline">    System.out.println(</strong>
<strong class="source-inline">        switch(v){</strong>
<strong class="source-inline">            </strong><strong class="source-inline">case Boat b -&gt; "It's a Boat";</strong>
<strong class="source-inline">            case Train t -&gt; "It's a Train";</strong>
<strong class="source-inline">            case Car c when c.getNumDoors() == 4  -&gt;</strong>
<strong class="source-inline">                "Saloon "+ c.onRoad(); // custom Car method</strong>
<strong class="source-inline">            case Car c when c.getNumDoors() == 2  -&gt;</strong>
<strong class="source-inline">               "Convertible: " + c.onRoad();</strong>
<strong class="source-inline">            case null, default -&gt; "Invalid type";</strong>
<strong class="source-inline">        }</strong>
<strong class="source-inline">    </strong><strong class="source-inline">);</strong>
<strong class="source-inline">}</strong></pre>
			<p>Assume that <strong class="source-inline">Car</strong>, <strong class="source-inline">Boat</strong>, and <strong class="source-inline">Train</strong> all extend from <strong class="source-inline">Vehicle</strong> and that <strong class="source-inline">Car</strong> has a custom method <strong class="source-inline">onRoad()</strong>. As you can see, in this <strong class="source-inline">switch</strong> expression, the selector expression, <strong class="source-inline">v</strong>, can be any reference type (<strong class="source-inline">Boat</strong>, <strong class="source-inline">Train</strong>, <strong class="source-inline">Car</strong>, and so forth). The <strong class="source-inline">case</strong> labels demonstrate <em class="italic">type patterns and pattern matching</em>; for example, <span class="No-Break"><strong class="source-inline">Boat b</strong></span><span class="No-Break">.</span></p>
			<p>In addition, both <strong class="source-inline">case</strong> labels for <strong class="source-inline">Car</strong> are <a id="_idIndexMarker699"/>known as <em class="italic">guarded patterns</em>. A guarded pattern is a <strong class="source-inline">case</strong> label protected by a “guard” on the right-hand side of a <strong class="source-inline">when</strong> clause. A guard is a conditional expression, evaluating to true or false. Note the use of the custom <strong class="source-inline">Car</strong> method <strong class="source-inline">onRoad()</strong> and the fact that no cast is required, as the cast is done for us in the background (provided we are dealing with <span class="No-Break">a </span><span class="No-Break"><strong class="source-inline">Car</strong></span><span class="No-Break">).</span></p>
			<p>The last <a id="_idIndexMarker700"/>case <strong class="source-inline">label</strong>, containing <strong class="source-inline">default</strong>, ensures exhaustiveness is catered for, thereby keeping the compiler happy. In other words, all possible <strong class="source-inline">Vehicle</strong>s are catered for. Note also the use of <strong class="source-inline">null</strong> as a valid label and the fact that <strong class="source-inline">null</strong> and <strong class="source-inline">default</strong> can be <span class="No-Break">comma separated.</span></p>
			<p>Now, let’s examine the effect on inheritance of two particular keywords, namely <strong class="source-inline">abstract</strong> <span class="No-Break">and </span><span class="No-Break"><strong class="source-inline">final</strong></span><span class="No-Break">.</span></p>
			<h1 id="_idParaDest-233"><a id="_idTextAnchor233"/>Explaining the abstract and final keywords</h1>
			<p>As we know, when coding methods, we can apply the access modifier keywords, namely <strong class="source-inline">private</strong>, <strong class="source-inline">protected</strong>, <strong class="source-inline">public</strong>, and package-private (no keyword). Two other keywords have <a id="_idIndexMarker701"/>special significance regarding inheritance: <strong class="source-inline">abstract</strong> and <strong class="source-inline">final</strong>. Both are opposites of each other, which is why both cannot be <a id="_idIndexMarker702"/>applied to a method at the same time. Let’s discuss them now, starting <span class="No-Break">with </span><span class="No-Break"><strong class="source-inline">abstract</strong></span><span class="No-Break">.</span></p>
			<h2 id="_idParaDest-234"><a id="_idTextAnchor234"/>The abstract keyword</h2>
			<p>The <strong class="source-inline">abstract</strong> keyword is <a id="_idIndexMarker703"/>applied to classes and methods. While <strong class="source-inline">abstract</strong> classes will be discussed more fully in <a href="B19793_10.xhtml#_idTextAnchor249"><span class="No-Break"><em class="italic">Chapter 10</em></span></a>, we will be discussing them here also (for reasons that will soon become obvious). An <strong class="source-inline">abstract</strong> method has no implementation (code). In other words, the method signature, rather than following it with curly braces, <strong class="source-inline">{}</strong>, which represents the implementation, an <strong class="source-inline">abstract</strong> method signature is simply followed by a semi-colon. Marking a method as <strong class="source-inline">abstract</strong> implies <span class="No-Break">the following:</span></p>
			<ul>
				<li>The class must be <span class="No-Break"><strong class="source-inline">abstract</strong></span><span class="No-Break"> also</span></li>
				<li>The first concrete (non-<strong class="source-inline">abstract</strong>) subclass must provide an implementation for the <span class="No-Break"><strong class="source-inline">abstract</strong></span><span class="No-Break"> method</span></li>
			</ul>
			<p>Let’s discuss this in more detail. When you mark a method (or methods) as <strong class="source-inline">abstract</strong>, you are saying that this method has no implementation code. As there is something “missing,” the class itself must be marked as <strong class="source-inline">abstract</strong> also. This tells the compiler that the class is incomplete and as a result, you cannot instantiate (create) an object based on an <strong class="source-inline">abstract</strong> class. In other words, you cannot execute <strong class="source-inline">new</strong> on an abstract class (although a reference is perfectly ok). The whole rationale for <strong class="source-inline">abstract</strong> methods (and thus <strong class="source-inline">abstract</strong> classes) is for them to be overridden by subclasses, where the “missing” implementation code is provided. Now, if the direct subclass does not provide the implementation code for the inherited <strong class="source-inline">abstract</strong> method, that subclass must also be <strong class="source-inline">abstract</strong>. Therefore, the first non-abstract (concrete) subclass of an <strong class="source-inline">abstract</strong> class must provide the implementation code for the <strong class="source-inline">abstract</strong> method. <span class="No-Break"><em class="italic">Figure 9</em></span><em class="italic">.14</em> demonstrates <span class="No-Break">these principles:</span></p>
			<div>
				<div id="_idContainer148" class="IMG---Figure">
					<img src="image/B19793_09_14.jpg" alt="Figure 9.14 – The “abstract” keyword in action"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.14 – The “abstract” keyword in action</p>
			<p>In this figure, we have an <strong class="source-inline">abstract</strong> method, namely <strong class="source-inline">write()</strong>, on line 4. Notice how there are no curly <a id="_idIndexMarker704"/>braces for the method; we just have the semi-colon immediately after the parentheses. As the <strong class="source-inline">Pencil</strong> class (lines 3-5) contains an <strong class="source-inline">abstract</strong> method, the class itself must be <strong class="source-inline">abstract</strong>; which it is (<span class="No-Break">line 3).</span></p>
			<p>On line 6, <strong class="source-inline">CharcoalPencil</strong> attempts to subclass <strong class="source-inline">Pencil</strong>. But because (a) it does not provide an implementation for the <strong class="source-inline">abstract</strong> method <strong class="source-inline">write()</strong>, which it inherited from <strong class="source-inline">Pencil</strong>, and (b) <strong class="source-inline">CharcoalPencil</strong> <em class="italic">itself</em> is not <strong class="source-inline">abstract</strong>, <strong class="source-inline">CharcoalPencil</strong> fails <span class="No-Break">to compile.</span></p>
			<p>Contrast line 6 with line 7. As we saw, line 6 does not compile. However, line 7, <strong class="source-inline">WaterColorPencil</strong>, does compile. Why? Because <strong class="source-inline">WaterColorPencil</strong> is <strong class="source-inline">abstract</strong>; the fact that it does not provide an implementation for the <strong class="source-inline">abstract</strong> method <strong class="source-inline">write()</strong> is <span class="No-Break">no problem.</span></p>
			<p class="callout-heading">Abstract classes do not have to have abstract methods</p>
			<p class="callout">As we know, if you have 1 (or more) <strong class="source-inline">abstract</strong> methods, then the class must be <strong class="source-inline">abstract</strong>. However, the opposite is not true. In other words, an <strong class="source-inline">abstract</strong> class does not have to have any <strong class="source-inline">abstract</strong> methods at all! Note that <strong class="source-inline">WaterColorPencil</strong> (line 7 in <span class="No-Break"><em class="italic">Figure 9</em></span><em class="italic">.14</em>) is an example of such a class. It is <strong class="source-inline">abstract</strong> and yet has no methods at all. This is fine. This could be a design decision whereby, even if the class contains only concrete methods, you simply want this class to be used as a reference type and not as an object type (as you cannot <span class="No-Break"><strong class="source-inline">new</strong></span><span class="No-Break"> it).</span></p>
			<p>The <strong class="source-inline">GraphitePencil</strong> class (lines 8-13) is a concrete, non-abstract class. As it <strong class="source-inline">extends</strong> the <strong class="source-inline">abstract</strong> class, <strong class="source-inline">Pencil</strong>, it must provide an implementation for the <strong class="source-inline">abstract</strong> method <strong class="source-inline">write()</strong>. This is done on lines 10 to 12 and we use the <strong class="source-inline">@Override</strong> annotation to <span class="No-Break">emphasize this.</span></p>
			<p>Line 17 demonstrates <a id="_idIndexMarker705"/>that you cannot instantiate an object of an <strong class="source-inline">abstract</strong> class. The reference part of the <strong class="source-inline">Pencil pp</strong> statement is fine. The issue is with the <strong class="source-inline">new </strong><span class="No-Break"><strong class="source-inline">Pencil()</strong></span><span class="No-Break"> part.</span></p>
			<p>Line 18 shows what is allowed. Again, we are using a <strong class="source-inline">Pencil</strong> reference but this time, we are referring to a <strong class="source-inline">GraphitePencil</strong> object. <strong class="source-inline">GraphitePencil</strong> is a concrete class (line 8). Line 19 polymorphically calls the <strong class="source-inline">write()</strong> method provided by <strong class="source-inline">GraphitePencil</strong> (lines 10-12). Assuming lines 6 and 17 are commented out (so the code will compile), line 19 <span class="No-Break">outputs </span><span class="No-Break"><strong class="source-inline">GraphitePencil::write()</strong></span><span class="No-Break">.</span></p>
			<p>Now that we understand <strong class="source-inline">abstract</strong> methods and classes, let’s examine the <span class="No-Break"><strong class="source-inline">final</strong></span><span class="No-Break"> keyword.</span></p>
			<h2 id="_idParaDest-235"><a id="_idTextAnchor235"/>The final keyword</h2>
			<p>The <strong class="source-inline">final</strong> keyword can be <a id="_idIndexMarker706"/>applied in various contexts. Inheritance is the main focus here, but we will examine other situations also. We will examine each in turn and then look at code that demonstrates them. We will start with <span class="No-Break"><strong class="source-inline">final</strong></span><span class="No-Break"> methods.</span></p>
			<h3>final methods</h3>
			<p>A <strong class="source-inline">final</strong> method cannot <a id="_idIndexMarker707"/>be overridden in a subclass. This prevents any unwanted <a id="_idIndexMarker708"/>changes by subclasses. We can take this a stage further with <span class="No-Break"><strong class="source-inline">final</strong></span><span class="No-Break"> classes.</span></p>
			<h3>final classes</h3>
			<p>A class that is <a id="_idIndexMarker709"/>marked <strong class="source-inline">final</strong> cannot be used as a base type. This means you cannot extend from a <strong class="source-inline">final</strong> class. All the methods in the class are implicitly <strong class="source-inline">final</strong>. Java uses <a id="_idIndexMarker710"/>this in its API to guarantee behavior. For example, the <strong class="source-inline">String</strong> class is <strong class="source-inline">final</strong> so that nobody can extend it and provide a custom implementation. Therefore, Java always knows how strings behave. Now, we will examine <strong class="source-inline">final</strong> <span class="No-Break">method parameters.</span></p>
			<h3>final method parameters</h3>
			<p>A <strong class="source-inline">final</strong> method parameter is a parameter that cannot be changed. However, be aware that the <a id="_idIndexMarker711"/>semantics are subtly different depending on the parameter type. If the parameter type is a primitive, such as <strong class="source-inline">int</strong>, then you cannot change the value of the <span class="No-Break"><strong class="source-inline">int</strong></span><span class="No-Break"> parameter.</span></p>
			<p>However, if the <a id="_idIndexMarker712"/>parameter in question is a reference (as opposed to a primitive), <strong class="source-inline">final</strong> applies to the reference and therefore, it is the reference that cannot be changed. In other words, the object the reference is pointing to is modifiable, but the reference itself is not. What this means is that, for example, if the method accepts a <strong class="source-inline">Dog</strong> reference, namely <strong class="source-inline">dog</strong>, then using the <strong class="source-inline">dog</strong> reference, you can change the properties of the object, such as <strong class="source-inline">dog.setAge(10)</strong>. You cannot, however, change <strong class="source-inline">dog</strong> to refer to a different object, such as <strong class="source-inline">dog = </strong><span class="No-Break"><strong class="source-inline">new Dog()</strong></span><span class="No-Break">.</span></p>
			<h3>final (constants)</h3>
			<p>A constant is a <a id="_idIndexMarker713"/>value that cannot change. It is customary and good practice <a id="_idIndexMarker714"/>to use capital letters as the identifiers for constants, with each word separated by an underscore. This makes them stand out and developers know they cannot change them. One example from the Java API is the <em class="italic">PI</em> constant from the <strong class="source-inline">Math</strong> class (in the auto-imported <strong class="source-inline">java.lang</strong> package). It is <strong class="source-inline">final</strong> so that it cannot be changed. To provide easy access, <em class="italic">PI</em> is also <strong class="source-inline">public</strong> <span class="No-Break">and </span><span class="No-Break"><strong class="source-inline">static</strong></span><span class="No-Break">.</span></p>
			<p>Now, let’s look at a code example to re-enforce the use of <strong class="source-inline">final</strong>. <span class="No-Break"><em class="italic">Figure 9</em></span><em class="italic">.15</em> presents <span class="No-Break">the code:</span></p>
			<div>
				<div id="_idContainer149" class="IMG---Figure">
					<img src="image/B19793_09_15.jpg" alt="Figure 9.15 – The “final” keyword in action"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.15 – The “final” keyword in action</p>
			<p>In this figure, we have a <strong class="source-inline">final</strong> class called <strong class="source-inline">Earth</strong> (line 3). Line 5 demonstrates, via a compiler error, that you <a id="_idIndexMarker715"/>cannot extend from a <span class="No-Break"><strong class="source-inline">final</strong></span><span class="No-Break"> class.</span></p>
			<p>Line 8 defines a <strong class="source-inline">final</strong> method called <strong class="source-inline">write()</strong> in the <strong class="source-inline">Pen</strong> class. Consequently, the <strong class="source-inline">FountainPen</strong> class encounters a compiler error (line 15) when attempting to <span class="No-Break">override </span><span class="No-Break"><strong class="source-inline">write()</strong></span><span class="No-Break">.</span></p>
			<p>Line 11 shows that you <a id="_idIndexMarker716"/>cannot annotate a method as both <strong class="source-inline">abstract</strong> and <strong class="source-inline">final</strong> – <strong class="source-inline">abstract</strong> implies that this method is to be overridden in a subclass; <strong class="source-inline">final</strong> means that this method must not <span class="No-Break">be overridden.</span></p>
			<p>Line 18 declares a constant called <strong class="source-inline">ONE_YEAR</strong> and sets it to <strong class="source-inline">1</strong>. Line 27 attempts to change the constant value – as this is not allowed, the <span class="No-Break">compiler complains.</span></p>
			<p>The <strong class="source-inline">print()</strong> method (lines 19-28) outlines what <strong class="source-inline">final</strong> means for method parameters. The method parameters (line 19) are <strong class="source-inline">final String name</strong> and <strong class="source-inline">final int age</strong>, respectively. <strong class="source-inline">String</strong> is a non-primitive type and therefore <strong class="source-inline">name</strong> is a reference. In other words, the value inside <strong class="source-inline">name</strong> is a memory location (reference) of where the object is on the heap. On the other hand, <strong class="source-inline">age</strong> is simply a primitive <strong class="source-inline">int</strong>, whose value is simply a whole number, such as <strong class="source-inline">1</strong>. It is easy to understand what you can and cannot do with <strong class="source-inline">final</strong> parameters when you view the <em class="italic">value</em> as <strong class="source-inline">final</strong>. Thus, if <strong class="source-inline">1</strong> is in <strong class="source-inline">age</strong>, it cannot be changed and neither can the reference (address) in <strong class="source-inline">name</strong>. However, the object referred to by <strong class="source-inline">name</strong> can <span class="No-Break">be modified.</span></p>
			<p>Line 21 is a compiler error and demonstrates that <strong class="source-inline">final</strong> primitives cannot <span class="No-Break">be changed.</span></p>
			<p>Line 23 shows us that <a id="_idIndexMarker717"/>the object that the reference is referring to can be accessed (and changed if required). Note that, in this particular example, as <strong class="source-inline">String</strong>s <a id="_idIndexMarker718"/>are immutable objects, the <strong class="source-inline">toUpperCase()</strong> method returns the new, uppercase <strong class="source-inline">String</strong>, as opposed to changing the original. We will talk more about <strong class="source-inline">String</strong>s in <a href="B19793_12.xhtml#_idTextAnchor293"><span class="No-Break"><em class="italic">Chapter 12</em></span></a>. The important thing to note is that the compiler had no issue with <span class="No-Break">line 23.</span></p>
			<p>Line 25 attempts to change the <strong class="source-inline">String</strong> reference <strong class="source-inline">name</strong> to refer to a different <strong class="source-inline">String</strong>. As the reference is <strong class="source-inline">final</strong>, the compiler complains. Once again, the separation of reference and object makes things much easier <span class="No-Break">to understand.</span></p>
			<p>At this point, we know how to create (unlimited) inheritance hierarchies (using <strong class="source-inline">extends</strong>). We also know that <strong class="source-inline">final</strong> disables inheritance. What if we wanted a “middle ground,” where we could customize our hierarchy to certain types? This is what sealed classes enable. Let’s discuss <span class="No-Break">them now.</span></p>
			<h1 id="_idParaDest-236"><a id="_idTextAnchor236"/>Applying sealed classes</h1>
			<p>Sealed classes <a id="_idIndexMarker719"/>were introduced in Java 17. What we are going to cover here relates to classes but the same logic applies to interfaces (<a href="B19793_10.xhtml#_idTextAnchor249"><span class="No-Break"><em class="italic">Chapter 10</em></span></a>). With inheritance, you can extend from any class (or interface) using the <strong class="source-inline">extends</strong> keyword, unless the class is <strong class="source-inline">final</strong> <span class="No-Break">of course.</span></p>
			<p class="callout-heading">Note</p>
			<p class="callout">Interfaces cannot be <strong class="source-inline">final</strong> because their whole rationale is to <span class="No-Break">be implemented.</span></p>
			<p>Consider the following scenario: what if you wanted your class to be available for inheritance, but only for certain classes? In other words, you want to scope the subclasses allowed. So far, inheritance, using <strong class="source-inline">extends</strong>, enables every class to become a subclass, whereas <strong class="source-inline">final</strong> prevents a class from <span class="No-Break">having subclasses.</span></p>
			<p>This is where sealed classes are useful – they enable you to specify what subclasses are allowed. Just to reiterate, this also applies to interfaces, where we can specify what classes are allowed to implement <span class="No-Break">the interface.</span></p>
			<p>Before we look at an example, there are some new keywords that we need <span class="No-Break">to understand.</span></p>
			<h2 id="_idParaDest-237"><a id="_idTextAnchor237"/>sealed and permits</h2>
			<p>These keywords <a id="_idIndexMarker720"/>work together. To state that a class is sealed, you <a id="_idIndexMarker721"/>can simply specify that it is just that, <strong class="source-inline">sealed</strong>. Once you do that, however, you must specify which classes can extend from this class. To do that, you use the <strong class="source-inline">permits</strong> keyword, followed by the comma-separated list <span class="No-Break">of classes.</span></p>
			<h2 id="_idParaDest-238"><a id="_idTextAnchor238"/>non-sealed</h2>
			<p>When you <a id="_idIndexMarker722"/>start to scope/restrict a hierarchy, you must use certain keywords when specifying the subclasses. A subclass involved in a sealed hierarchy must state one of <span class="No-Break">the following:</span></p>
			<ul>
				<li>It is also sealed. This means, we have further scoping to perform and therefore <a id="_idIndexMarker723"/>we must use the <strong class="source-inline">sealed</strong>/<strong class="source-inline">permits</strong> pairing on this subclass to specify the <span class="No-Break">subclasses allowed.</span></li>
				<li>It is the <strong class="source-inline">final</strong> class in the hierarchy (no more <span class="No-Break">subclasses allowed).</span></li>
				<li>It ends the scoping. In effect, you want to open up the hierarchy again for extension. To do this, we use the <strong class="source-inline">non-sealed</strong> keyword as <strong class="source-inline">non-sealed</strong> classes can <span class="No-Break">be subclassed.</span></li>
			</ul>
			<p>Now, let’s look at <span class="No-Break">an example.</span></p>
			<h2 id="_idParaDest-239"><a id="_idTextAnchor239"/>Example using sealed, permits, and non-sealed</h2>
			<p><span class="No-Break"><em class="italic">Figure 9</em></span><em class="italic">.16</em> presents a <a id="_idIndexMarker724"/>UML diagram for the code <a id="_idIndexMarker725"/>example <a id="_idIndexMarker726"/>we <span class="No-Break">will use:</span></p>
			<div>
				<div id="_idContainer150" class="IMG---Figure">
					<img src="image/B19793_09_16.jpg" alt="Figure 9.16 – UML diagram for “sealed” classes"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.16 – UML diagram for “sealed” classes</p>
			<p>In this figure, we have a <strong class="source-inline">Vehicle</strong> hierarchy. The parts we are going to restrict (seal) are the <strong class="source-inline">Vehicle</strong>, <strong class="source-inline">Car</strong>, and <strong class="source-inline">Saloon</strong> classes. Therefore, the only class that can subclass <strong class="source-inline">Vehicle</strong> is <strong class="source-inline">Car</strong>; and the only class that can subclass <strong class="source-inline">Car</strong> is <strong class="source-inline">Saloon</strong>. Note that even though the diagram implies <strong class="source-inline">Truck</strong> “is-a” <strong class="source-inline">Vehicle</strong> and <strong class="source-inline">Convertible</strong> “is-a” <strong class="source-inline">Car</strong>, for this example, we will prevent that <span class="No-Break">in code.</span></p>
			<p>The goal of the code is to ensure that the only <strong class="source-inline">Vehicle</strong>s we are interested in are <strong class="source-inline">Car</strong>s and the only <strong class="source-inline">Car</strong>s we are interested in are <strong class="source-inline">Saloon</strong>s. In addition, all <strong class="source-inline">Saloon</strong>s (<strong class="source-inline">Ford</strong> and <strong class="source-inline">Volvo</strong>) are of interest. <span class="No-Break"><em class="italic">Figure 9</em></span><em class="italic">.17</em> presents <span class="No-Break">the code.</span></p>
			<div>
				<div id="_idContainer151" class="IMG---Figure">
					<img src="image/B19793_09_17.jpg" alt="Figure 9.17 – “sealed” code"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.17 – “sealed” code</p>
			<p>In the preceding figure, line 3 states that we have a <strong class="source-inline">sealed</strong> class called <strong class="source-inline">Vehicle</strong> and that the only <a id="_idIndexMarker727"/>subclass allowed (permitted) is <strong class="source-inline">Car</strong>. At this point, the <strong class="source-inline">Car</strong> class must exist; otherwise, the compiler <span class="No-Break">will complain.</span></p>
			<p>Line 4 defines a sealed class called <strong class="source-inline">Car</strong> as a subclass of <strong class="source-inline">Vehicle</strong> (which it must do due to line 3) and that <a id="_idIndexMarker728"/>the only subclass permitted is <strong class="source-inline">Saloon</strong>. Note that when we were defining <strong class="source-inline">Car</strong>, we had to specify that <strong class="source-inline">Car</strong> was either <strong class="source-inline">sealed</strong>, <strong class="source-inline">non-sealed</strong>, <span class="No-Break">or </span><span class="No-Break"><strong class="source-inline">final</strong></span><span class="No-Break">.</span></p>
			<p>Line 5 is the <strong class="source-inline">Truck</strong> class attempting to subclass <strong class="source-inline">Vehicle</strong>. However, as we have sealed <strong class="source-inline">Vehicle</strong> to only <a id="_idIndexMarker729"/>allow <strong class="source-inline">Car</strong> as a subclass, this generates a <span class="No-Break">compiler error.</span></p>
			<p>Line 6 defines <strong class="source-inline">Saloon</strong> as a subclass of <strong class="source-inline">Car</strong> (as expected from line 4). In this instance, we have chosen to open up the hierarchy for further extension (by any class) by stating that <strong class="source-inline">Saloon</strong> is <strong class="source-inline">non-sealed</strong>. Lines 7 and 8 demonstrate that <strong class="source-inline">Saloon</strong> is a non-sealed class by allowing <strong class="source-inline">Volvo</strong> and <strong class="source-inline">Ford</strong> to extend from <span class="No-Break">it, respectively.</span></p>
			<p>Lastly, on line 9, <strong class="source-inline">Convertible</strong> attempts to subclass <strong class="source-inline">Car</strong>. This is not allowed as line 4 states that the only subclass of <strong class="source-inline">Car</strong> allowed <span class="No-Break">is </span><span class="No-Break"><strong class="source-inline">Saloon</strong></span><span class="No-Break">.</span></p>
			<p>Let’s move on now and discuss both instance and <span class="No-Break"><strong class="source-inline">static</strong></span><span class="No-Break"> blocks.</span></p>
			<h1 id="_idParaDest-240"><a id="_idTextAnchor240"/>Understanding instance and static blocks</h1>
			<p>As we know, in Java, a block<a id="_idIndexMarker730"/> is delimited by curly braces, <strong class="source-inline">{}</strong>, and these code blocks are no different. What is different about instance and <strong class="source-inline">static</strong> code blocks is <em class="italic">where</em> these blocks appear – in other words, their scope. Both of these code blocks appear outside every method but inside <span class="No-Break">the class.</span></p>
			<p>We will discuss each in turn and then present a code example to demonstrate them in operation. We will start with <span class="No-Break">instance blocks.</span></p>
			<h2 id="_idParaDest-241"><a id="_idTextAnchor241"/>Instance blocks</h2>
			<p>An instance block<a id="_idIndexMarker731"/> is a set of braces that appear outside of any method but inside the class. Assuming an instance block is present in a class, every time an object is created (using <strong class="source-inline">new</strong>), the instance block is executed. Note that the instance block executes <em class="italic">before</em> the constructor. To be technically accurate, <strong class="source-inline">super()</strong> is executed first so that the parent constructor has a chance to execute; this is followed by the instance block, after which the rest of the constructor executes. Use the “sic” (<em class="italic">s</em>uper, <em class="italic">i</em>nstance block, <em class="italic">c</em>onstructor) acronym to help remember the order. You can think of the compiler inserting the instance block into the constructor code just after the call to <strong class="source-inline">super()</strong>. If more than one instance block exists in a class, they are executed in order of appearance, from top <span class="No-Break">to bottom.</span></p>
			<p>As instance blocks execute as part of every constructor, they are an ideal location for inserting code that you want every constructor to have. In other words, code that is common across all constructors should go into an instance block. This saves you from duplicating code <span class="No-Break">across constructors.</span></p>
			<p>As we know, the parent constructor must execute before the child constructor. The same occurs with instance blocks. In other words, the parent instance blocks must execute before the child instance blocks. We will see this in the <span class="No-Break">code example.</span></p>
			<h2 id="_idParaDest-242"><a id="_idTextAnchor242"/>static blocks</h2>
			<p>A <strong class="source-inline">static</strong> block is a set of braces, preceded by the <strong class="source-inline">static</strong> keyword, that appears outside of any <a id="_idIndexMarker732"/>method but inside the class. The <strong class="source-inline">static</strong> block is only executed once, the very first time the class is loaded. This could occur when the first object of the class is created or the first time a <strong class="source-inline">static</strong> member is accessed. Static blocks execute before instance blocks (as we have to load the class file/bytecode before we can execute a constructor). Once executed, given that the class file is now loaded into memory, the <strong class="source-inline">static</strong> block is never <span class="No-Break">executed again.</span></p>
			<p>As with instance blocks, if more than one <strong class="source-inline">static</strong> block exists in a class, they are executed in order of appearance, from top to bottom. Similarly, as with instance blocks, if inheritance is involved, then the parent <strong class="source-inline">static</strong> blocks execute before the child <span class="No-Break"><strong class="source-inline">static</strong></span><span class="No-Break"> blocks.</span></p>
			<p>This will all make a lot more sense with a code example, where we will be able to compare and contrast both types of code blocks in an <span class="No-Break">inheritance hierarchy.</span></p>
			<p><span class="No-Break"><em class="italic">Figure 9</em></span><em class="italic">.18</em> presents <span class="No-Break">the code:</span></p>
			<div>
				<div id="_idContainer152" class="IMG---Figure">
					<img src="image/B19793_09_18.jpg" alt="Figure 9.18 – Instance and “static” code blocks example"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.18 – Instance and “static” code blocks example</p>
			<p>In this figure, we have a <a id="_idIndexMarker733"/>parent class called <strong class="source-inline">Parent</strong> and a child class called <strong class="source-inline">Child</strong> (it took a while to come up with those names!). Both classes have two instance initialization blocks, two <strong class="source-inline">static</strong> initialization blocks, and a constructor. Notice that the <strong class="source-inline">static</strong> initialization blocks (lines 7, 12, 16, and 21) are all simply blocks of code preceded by the <strong class="source-inline">static</strong> keyword. Also, note their location/scope – outside the methods but inside the class. The same is true for the instance initialization blocks (lines 5, 11, 15, and 20), except that the instance blocks have no keyword <span class="No-Break">preceding them.</span></p>
			<p>The main driver class, <strong class="source-inline">InitializationBlocks</strong>, also has one <strong class="source-inline">static</strong> and one instance initialization block (lines 24 and <span class="No-Break">25, respectively).</span></p>
			<p>Each of these blocks <a id="_idIndexMarker734"/>simply outputs a tracer message so that we know which block of code is currently executing. The tracer messages are annotated with ascending numbers so we can follow the order of execution more easily. <span class="No-Break"><em class="italic">Figure 9</em></span><em class="italic">.19</em>, presents the output from the code in <span class="No-Break"><em class="italic">Figure 9</em></span><span class="No-Break"><em class="italic">.18</em></span><span class="No-Break">:</span></p>
			<div>
				<div id="_idContainer153" class="IMG---Figure">
					<img src="image/B19793_09_19.jpg" alt="Figure 9.19 – Output from the code in Figure 9.18"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.19 – Output from the code in Figure 9.18</p>
			<p class="callout-heading">Note</p>
			<p class="callout">To avoid confusion between numbers representing output in <span class="No-Break"><em class="italic">Figure 9</em></span><em class="italic">.19</em> with line numbers in <span class="No-Break"><em class="italic">Figure 9</em></span><em class="italic">.18</em>, all numbers mentioned here refer to output numbers in <span class="No-Break"><em class="italic">Figure 9</em></span><em class="italic">.19</em>. Any line numbers relating to <span class="No-Break"><em class="italic">Figure 9</em></span><em class="italic">.18</em> will be explicitly annotated <span class="No-Break">as “line....”</span></p>
			<p>All Java <a id="_idIndexMarker735"/>programs start with the <strong class="source-inline">main()</strong> method. Therefore, the JVM has to find, using the <strong class="source-inline">CLASSPATH</strong> environment variable, the <strong class="source-inline">.class</strong> file containing <strong class="source-inline">main()</strong>, namely <strong class="source-inline">InitializationBlocks.class</strong>. As the JVM loads the class, if the class has a parent, it loads the parent first. In this example, as <strong class="source-inline">InitializationBlocks</strong> is not a subclass, this does not apply. However, there is a <strong class="source-inline">static</strong> block and this gives us our first line of output. Note that the instance block for <strong class="source-inline">InitializationBlocks</strong> is never executed. This is because no instance of <strong class="source-inline">InitializationBlocks</strong> was ever created. In other words, there is no <strong class="source-inline">new</strong> <strong class="source-inline">InitializationBlocks()</strong> in <span class="No-Break">the code.</span></p>
			<p>Line 27 simply outputs <strong class="source-inline">"---&gt; Creating first Child object…"</strong>. What is interesting to note is that it is not the first line output to the screen – the output from the <strong class="source-inline">static</strong> block <span class="No-Break">is first.</span></p>
			<p>Line 28 creates a <strong class="source-inline">Child</strong> object. Its output is represented by numbers 2-11. As this is the first time a <strong class="source-inline">Child</strong> object has been created (as no <strong class="source-inline">static</strong> member in <strong class="source-inline">Child</strong> has been accessed before this), the class file for <strong class="source-inline">Child</strong> is loaded. During this process, the JVM realizes that <strong class="source-inline">Child</strong> is a subclass of <strong class="source-inline">Parent</strong>, so it loads the <strong class="source-inline">Parent</strong> class first. Therefore, the <strong class="source-inline">static</strong> blocks in <strong class="source-inline">Parent</strong> are executed first, in order of appearance (2 and 3); followed by the <strong class="source-inline">Child</strong> static blocks, also in order of appearance (4 <span class="No-Break">and 5).</span></p>
			<p>Now that the <strong class="source-inline">static</strong> blocks are done, the instance blocks and constructors are executed. First, the superclass <strong class="source-inline">Parent</strong> instance blocks are executed in order of appearance (6 and 7), followed by the <strong class="source-inline">Parent</strong> constructor (8). Then, the subclass <strong class="source-inline">Child</strong> instance blocks are executed in order of appearance (9 and 10), followed by the <strong class="source-inline">Child</strong> constructor (11). That is a lot of processing from a simple <strong class="source-inline">new Child()</strong> line <span class="No-Break">of code.</span></p>
			<p>Line 29 simply outputs <strong class="source-inline">"---&gt; Creating second </strong><span class="No-Break"><strong class="source-inline">Child object…"</strong></span><span class="No-Break">.</span></p>
			<p>Line 30 creates another <strong class="source-inline">Child</strong> object. As the class was already loaded previously, the <strong class="source-inline">static</strong> blocks will already have run for both <strong class="source-inline">Child</strong> and its superclass, <strong class="source-inline">Parent</strong>. Therefore, they do not run again. So, we run the <strong class="source-inline">Parent</strong> instance blocks (6 and 7), followed by the <strong class="source-inline">Parent</strong> constructor (8). Then, we run the <strong class="source-inline">Child</strong> instance blocks (9 and 10), followed by the <strong class="source-inline">Child</strong> <span class="No-Break">constructor (11).</span></p>
			<p>Note the repetition <a id="_idIndexMarker736"/>of line numbers 6-11 when creating a <strong class="source-inline">Child</strong> object. The <strong class="source-inline">Parent</strong> instance blocks are executed in order; followed by the <strong class="source-inline">Parent</strong> constructor. The <strong class="source-inline">Child</strong> instance blocks and constructor follow in a <span class="No-Break">similar fashion.</span></p>
			<p>That covers <strong class="source-inline">static</strong> and instance initialization blocks. Before we conclude this chapter on inheritance, we would just like to delve a little deeper into one of the topics we touched on earlier: upcasting <span class="No-Break">and downcasting.</span></p>
			<h1 id="_idParaDest-243"><a id="_idTextAnchor243"/>Mastering upcasting and downcasting</h1>
			<p>Earlier, we touched upon why we get <strong class="source-inline">ClassCastException</strong> errors. The rule is that a reference can refer to objects of its own type or objects of subclasses. In effect, a reference can <a id="_idIndexMarker737"/>point across and down the inheritance hierarchy, but never up. If a reference does point up the hierarchy, you will get a <strong class="source-inline">ClassCastException</strong> error. Recall that the reason this occurs is that the subclass reference could have extra methods that any superclass object would have no code for. Whether that is the case or not is immaterial, <em class="italic">could have</em> <span class="No-Break">is enough.</span></p>
			<p>Keep in mind that assignment works from right to left; so, when reading code involving upcasting/downcasting, the direction in the hierarchy is from right to left as well. In addition, remember that the compiler is always looking at the <span class="No-Break">reference type.</span></p>
			<p>Now, let’s discuss, with the aid of code examples, both upcasting and downcasting. Let’s start <span class="No-Break">with upcasting.</span></p>
			<h2 id="_idParaDest-244"><a id="_idTextAnchor244"/>Upcasting</h2>
			<p>With <a id="_idIndexMarker738"/>upcasting, you are going from a more specific type “up to” a more general type. For example, let’s look at the following line <span class="No-Break">of code:</span></p>
			<pre class="source-code">
Vehicle vc = new Car()</pre>			<p>Here, we are going from <strong class="source-inline">Car</strong> <em class="italic">up</em> to <strong class="source-inline">Vehicle</strong>. The more specific type (<strong class="source-inline">Car</strong>) is further down the hierarchy and potentially has extra methods. Due to inheritance, whatever methods the parent reference has access to, the subclass will also have. So, any methods available to the <strong class="source-inline">Vehicle</strong> reference, <strong class="source-inline">vc</strong>, will exist in the <strong class="source-inline">Car</strong> object! Therefore, upcasting is never an issue, and an explicit cast is <span class="No-Break">not required.</span></p>
			<p><span class="No-Break"><em class="italic">Figure 9</em></span><em class="italic">.20</em> presents upcasting <span class="No-Break">in code:</span></p>
			<div>
				<div id="_idContainer154" class="IMG---Figure">
					<img src="image/B19793_09_20.jpg" alt="Figure 9.20 – Upcasting in action"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.20 – Upcasting in action</p>
			<p>In this figure, we have a class called <strong class="source-inline">Machine</strong> (lines 3-5) and a subclass called <strong class="source-inline">Tractor</strong> (lines 6-9). The <strong class="source-inline">on()</strong> method in <strong class="source-inline">Tractor</strong> (line 7) overrides the <strong class="source-inline">on()</strong> method in <strong class="source-inline">Machine</strong> (<span class="No-Break">line 4).</span></p>
			<p>Line 15 involves an <a id="_idIndexMarker739"/>implicit upcast. Reading it right to left (as assignment is right to left), we are going from <strong class="source-inline">Tractor</strong> “up to” <strong class="source-inline">Machine</strong>. This is possible because every <strong class="source-inline">Tractor</strong> “is-a” <strong class="source-inline">Machine</strong>. Thus, line 15 results in a <strong class="source-inline">Machine</strong> reference referring to a <span class="No-Break"><strong class="source-inline">Tractor</strong></span><span class="No-Break"> object.</span></p>
			<p>Line 16 invokes the <strong class="source-inline">doAction()</strong> method while passing in the reference created on line 15, namely <strong class="source-inline">mt</strong>. This <strong class="source-inline">mt</strong> reference is copied (remember Java is call by value) into the <strong class="source-inline">Machine</strong> reference, namely <strong class="source-inline">machine</strong>, on line 11. Thus, the <strong class="source-inline">mt</strong> reference in the <strong class="source-inline">main()</strong> method and the <strong class="source-inline">machine</strong> reference in the <strong class="source-inline">doAction()</strong> method are pointing at the one and same object, which was created on <span class="No-Break">line 15.</span></p>
			<p>Inside the <strong class="source-inline">doAction()</strong> method, we invoke the <strong class="source-inline">on()</strong> method using the <strong class="source-inline">machine</strong> reference (line 12). As the <strong class="source-inline">machine</strong> references type, namely <strong class="source-inline">Machine</strong>, has an <strong class="source-inline">on()</strong> method, the compiler is happy. At runtime, the object that <strong class="source-inline">machine</strong> is referring to, namely <strong class="source-inline">Tractor</strong>, is used. In other words, the <strong class="source-inline">on()</strong> method from <strong class="source-inline">Tractor</strong> is dynamically <span class="No-Break">executed (polymorphically).</span></p>
			<p>Line 17 is just accomplishing <a id="_idIndexMarker740"/>in one line what was coded over lines 15 and 16. With the invocation of <strong class="source-inline">doAction()</strong> on line 17, the upcasting is <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
Machine machine = new Tractor()</pre>			<p>The <strong class="source-inline">Machine</strong> reference, namely <strong class="source-inline">machine</strong>, is provided by the <strong class="source-inline">doAction()</strong> signature (line 11), and the <strong class="source-inline">Tractor</strong> instance creation comes from <span class="No-Break">line 17.</span></p>
			<p>Both lines 16 and 17 result in the same output: <strong class="source-inline">Tractor::on()</strong>. Now, let’s discuss the trickier of the <span class="No-Break">two: downcasting.</span></p>
			<h2 id="_idParaDest-245"><a id="_idTextAnchor245"/>Downcasting</h2>
			<p>With downcasting, you are going from a more general type “down to” a more specific type. For example, let’s look at the following line <span class="No-Break">of code:</span></p>
			<pre class="source-code">
Car cv = (Car) new Vehicle(),</pre>			<p>Reading it from right to left, we are going from <strong class="source-inline">Vehicle</strong> <em class="italic">down</em> to <strong class="source-inline">Car</strong>. Again, the more specific type (<strong class="source-inline">Car</strong>) is further down <a id="_idIndexMarker741"/>the hierarchy and potentially has extra methods. The compiler spots this and complains. We can overrule the compiler by inserting a (down)cast, <strong class="source-inline">(Car)</strong>. This is what we have done here. However, at runtime, this line of code results in a <strong class="source-inline">ClassCastException</strong> error. This is because, on the right-hand side of the assignment statement, we are attempting to create a <strong class="source-inline">Car</strong> reference that will point up the inheritance tree at a <span class="No-Break"><strong class="source-inline">Vehicle</strong></span><span class="No-Break"> object!</span></p>
			<p><span class="No-Break"><em class="italic">Figure 9</em></span><em class="italic">.21</em> presents downcasting <span class="No-Break">in code:</span></p>
			<div>
				<div id="_idContainer155" class="IMG---Figure">
					<img src="image/B19793_09_21.jpg" alt="Figure 9.21 – Downcasting in action"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.21 – Downcasting in action</p>
			<p>The code in this <a id="_idIndexMarker742"/>figure is very similar to the code in <span class="No-Break"><em class="italic">Figure 9</em></span><em class="italic">.20</em>. The inheritance hierarchy is the same. The changes are in the <strong class="source-inline">doAction()</strong> and <strong class="source-inline">main()</strong> methods. Line 12 works normally and we have commented it out to focus <span class="No-Break">on downcasting.</span></p>
			<p>Our goal, as stated on line 14, is to <em class="italic">safely</em> invoke the <strong class="source-inline">Tractor</strong> object’s <strong class="source-inline">drive()</strong> method. Note that this method is specific to <strong class="source-inline">Tractor</strong>. Let’s look at the changes in <span class="No-Break">baby steps.</span></p>
			<p>Firstly, as <strong class="source-inline">drive()</strong> is specific to <strong class="source-inline">Tractor</strong> (and not <strong class="source-inline">Machine</strong>), this means that we need a <strong class="source-inline">Tractor</strong> reference to get the code to compile. The fact that line 15 does not compile demonstrates this – the <strong class="source-inline">machine</strong> reference is of the <strong class="source-inline">Machine</strong> type and <strong class="source-inline">Machine</strong> does not have a <span class="No-Break"><strong class="source-inline">drive()</strong></span><span class="No-Break"> method.</span></p>
			<p>Line 16 addresses the compiler error from line 15. Line 16 compiles because it (down)casts the machine reference to a <strong class="source-inline">Tractor</strong> reference <em class="italic">before</em> it calls the <strong class="source-inline">drive()</strong> method. That is why the extra set of parentheses are needed – method invocation has higher precedence than casting, so we change the order of precedence by using parentheses. Without the extra set of parentheses, we have <strong class="source-inline">(Tractor)machine.drive()</strong>, and this does not compile (for the same reason as line 15 does not compile). However, the extra set of parentheses forces the cast from <strong class="source-inline">Machine</strong> to <strong class="source-inline">Tractor</strong> to be performed first, and thus the compiler looks for <strong class="source-inline">drive()</strong> <span class="No-Break">in </span><span class="No-Break"><strong class="source-inline">Tractor</strong></span><span class="No-Break">.</span></p>
			<p>However, we are still not “out of the woods.” Yes, the compiler is happy, but the JVM is vulnerable to <strong class="source-inline">ClassCastException</strong> errors at runtime. If line 16 were uncommented, then line 22 would cause a <strong class="source-inline">ClassCastException</strong> error at runtime. This is because line 22 passes in a <strong class="source-inline">Machine</strong> object, so inside the <strong class="source-inline">doAction()</strong> method, the <strong class="source-inline">machine</strong> reference is <a id="_idIndexMarker743"/>referring to a <strong class="source-inline">Machine</strong> object. Therefore, on line 16, we would be trying to create a <strong class="source-inline">Tractor</strong> reference to point <em class="italic">up</em> to the <strong class="source-inline">Machine</strong> object, which is a <strong class="source-inline">ClassCastException</strong> all <span class="No-Break">day long.</span></p>
			<p>Line 17 uses the <strong class="source-inline">instanceof</strong> keyword, in conjunction with a type pattern and pattern matching. Line 17 is only true if the reference <strong class="source-inline">machine</strong> refers to a <strong class="source-inline">Tractor</strong> object; when it is, the cast is done for us in the background and <strong class="source-inline">t</strong> is initialized to refer to the <strong class="source-inline">Tractor</strong> object. This is why line 22 outputs nothing – the <strong class="source-inline">Machine</strong> object passed in, fails the <strong class="source-inline">instanceof</strong> test and therefore line 18 is <em class="italic">not</em> executed. However, as line 23 passes in a <strong class="source-inline">Tractor</strong> object, it passes the <strong class="source-inline">instanceof</strong> test. This means that line 18 is executed and <span class="No-Break">outputs </span><span class="No-Break"><strong class="source-inline">Tractor::drive()</strong></span><span class="No-Break">.</span></p>
			<p>That completes another hugely important chapter. Now, let’s apply what we <span class="No-Break">have learned!</span></p>
			<h1 id="_idParaDest-246"><a id="_idTextAnchor246"/>Exercises</h1>
			<p>Our park is full of diversity, not just in the species of dinosaurs but also in the roles of our employees. To model this diversity, we will be incorporating the concept of inheritance into <span class="No-Break">our applications:</span></p>
			<ol>
				<li>Not all dinosaurs are the same. Some are small, others big. Some are herbivores, others carnivores. Create at least three subclasses for different types of dinosaurs that inherit from the base <span class="No-Break"><strong class="source-inline">Dinosaur</strong></span><span class="No-Break"> class.</span><p class="list-inset">If you need inspiration, you can create a <strong class="source-inline">FlyingDinosaur</strong> subclass and an <strong class="source-inline">AquaticDinosaur</strong> subclass from the <strong class="source-inline">Dinosaur</strong> class, each with its unique properties. (This is not the most optimal way to model this, but don’t worry about <span class="No-Break">that now.)</span></p></li>
				<li>Just like our dinosaurs, our employees also have diverse roles. Some are park managers, while others are security officers or veterinarians. Create subclasses for these employee roles that inherit from the <strong class="source-inline">Employee</strong> base class. Come up with at least <span class="No-Break">three subclasses.</span></li>
				<li>Inheritance doesn’t just stop at properties and methods. Even the behavior of some methods can be customized in subclasses. Provide a custom implementation of the <strong class="source-inline">toString()</strong> method in the <strong class="source-inline">Dinosaur</strong> and <strong class="source-inline">Employee</strong> classes (from exercises 1 and 2) and their subclasses to display detailed information about <span class="No-Break">each object.</span></li>
				<li>Also, override the <strong class="source-inline">equals()</strong> method in the <strong class="source-inline">Dinosaur</strong> and <strong class="source-inline">Employee</strong> classes to compare objects of <span class="No-Break">these classes.</span></li>
				<li>Create a class called <strong class="source-inline">App</strong> with a <strong class="source-inline">main</strong> method. In there, add functionality to check if an employee is qualified to work in a specific enclosure, considering the employee’s role and the enclosure’s <span class="No-Break">safety level.</span></li>
				<li>The park offers regular tickets and season tickets. Create a <strong class="source-inline">SeasonTicket</strong> class that extends the <strong class="source-inline">Ticket</strong> class and add properties such as start date and <span class="No-Break">end date.</span></li>
			</ol>
			<h1 id="_idParaDest-247"><a id="_idTextAnchor247"/>Project</h1>
			<p>You will be developing <a id="_idIndexMarker744"/>a more advanced version of the Mesozoic Eden park manager console application. Your task is to implement the concept of polymorphism to handle different types of dinosaurs and employees. By incorporating polymorphism, the application can accommodate an even wider range of dinosaur species and employee roles. The key features of the system should now include <span class="No-Break">the following:</span></p>
			<ul>
				<li>The ability to manage diverse types of dinosaur profiles, representing a variety <span class="No-Break">of species</span></li>
				<li>The ability to manage different types of park employee profiles that represent a variety of roles, such as park rangers, janitors, veterinarians, <span class="No-Break">and more</span></li>
				<li>All previous features, such as editing and removing profiles, real-time dinosaur tracking, employee scheduling, guest admissions, and handling special events, should now accommodate these <span class="No-Break">new varieties</span></li>
			</ul>
			<p>Here’s what you<a id="_idIndexMarker745"/> need to do, broken down into smaller steps if you <span class="No-Break">need it:</span></p>
			<ol>
				<li><strong class="bold">Extend the data structures</strong>: Extend your <strong class="source-inline">Dinosaur</strong> and <strong class="source-inline">Employee</strong> classes into different subclasses to represent different types of dinosaurs and employee roles. Make sure these subclasses demonstrate the principle <span class="No-Break">of polymorphism.</span></li>
				<li><strong class="bold">Enhance initialization</strong>: Upgrade your data initialization so that it supports different types of dinosaurs and employees. This could involve creating arrays or lists of <strong class="source-inline">Dinosaur</strong> and <strong class="source-inline">Employee</strong> objects, where each object could be an instance of <span class="No-Break">any subclass.</span></li>
				<li><strong class="bold">Update the interaction</strong>: Modify your interactive console-based interface to handle the new types of dinosaurs and employees. You might need to add more options <span class="No-Break">or submenus.</span></li>
				<li><strong class="bold">Enhance menu creation</strong>: Your menu should now handle different types of dinosaurs and employees. Make sure each option corresponds to a particular function in <span class="No-Break">the program.</span></li>
				<li><strong class="bold">Handle actions</strong>: Each menu item should trigger a function that is now able to handle different types of dinosaurs and employees. For example, the “Manage Dinosaurs” option could now trigger a function to add, remove, or edit a profile of any <span class="No-Break">dinosaur species.</span></li>
				<li><strong class="bold">Exit the program</strong>: Ensure your program continues to provide an option for the user to exit <span class="No-Break">the program.</span></li>
			</ol>
			<p>The starting<a id="_idIndexMarker746"/> code snippet will remain mostly the same as the previous one. However, when implementing <strong class="source-inline">manageDinosaurs()</strong>, <strong class="source-inline">manageEmployees()</strong>, and other similar functions, you’ll need to handle different types of dinosaurs <span class="No-Break">and employees:</span></p>
			<pre class="source-code">
public void handleMenuChoice(int choice) {    switch (choice) {
        case 1:
            manageDinosaurs();  // This function now needs
              to handle different types of dinosaurs
            break;
        case 2:
            manageEmployees();  // This function now needs
               to handle different types of employees
            break;
        case 3:
            // manageTickets();
            break;
        case 4:
            // checkParkStatus();
            break;
        case 5:
            // handleSpecialEvents();
            break;
        case 6:
            System.out.println("Exiting...");
            System.exit(0);
    }
}</pre>
			<p>The <strong class="source-inline">manageDinosaurs()</strong>, <strong class="source-inline">manageEmployees()</strong>, <strong class="source-inline">manageTickets()</strong>, <strong class="source-inline">checkParkStatus()</strong>, and <strong class="source-inline">handleSpecialEvents()</strong> methods now need to be updated to be<a id="_idIndexMarker747"/> able to handle the <span class="No-Break">increased complexity.</span></p>
			<h1 id="_idParaDest-248"><a id="_idTextAnchor248"/>Summary</h1>
			<p>In this chapter, we examined one of the cornerstones of OOP, namely inheritance. Inheritance defines an “is-a” relationship between the sub- and parent classes – for example, <strong class="source-inline">Fox</strong> “is-a” <strong class="source-inline">Animal</strong>, and <strong class="source-inline">Train</strong> “is-a” <strong class="source-inline">Vehicle</strong>. Inheritance promotes code reuse as inheritable base class members are automatically available to subclasses. Class inheritance is enabled via the <strong class="source-inline">extends</strong> keyword and interface inheritance is enabled via the <span class="No-Break"><strong class="source-inline">implements</strong></span><span class="No-Break"> keyword.</span></p>
			<p>Regarding methods, the subclasses are free to override (replace) the base class implementation. This is how we enable another cornerstone of OOP, <span class="No-Break">namely polymorphism.</span></p>
			<p>Polymorphism is a feature where the instance method from the object is only selected at runtime. Hence, other terms for polymorphism are “late binding,” “runtime binding,” and “dynamic binding,” For polymorphism to work, the signature of the instance method in the subtype must match that of the parent method. The only caveat to that rule is covariant returns, where, in the overriding method, a subtype of the parent return type is allowed. The overriding method, when comparing it with its parent version, must not reduce the access privileges or add extra <span class="No-Break">checked exceptions.</span></p>
			<p>Method overloading, on the other hand, is where the method signatures must be different (apart from the matching method name). Thus, the number of parameters, their types and/or their order, must be different. The return type and parameter names do not matter (as they are not part of the method signature). Method overloading can occur at any level in <span class="No-Break">the hierarchy.</span></p>
			<p>With inheritance, the reference type and object types are often different. As assignment works right to left, when we discuss upcasting and downcasting, we refer to going “up” or “down” the inheritance tree. Upcasting is always safe as the subtype will always have the methods accessible via the supertype reference. Downcasting, however, is not safe and requires a cast for the compiler to be happy. Even at that, if you end up creating a reference that is pointing up the hierarchy tree, you will get a <strong class="source-inline">ClassCastException</strong> error at runtime. Pointing up the hierarchy is not allowed because the subclass reference type could have methods that the parent type object has no <span class="No-Break">code for.</span></p>
			<p>The <strong class="source-inline">super</strong> keyword is used in two situations. The first is to access the parent constructor using <strong class="source-inline">super()</strong>. This call is only allowed as the very first line in any constructor. If not coded explicitly, <strong class="source-inline">super()</strong> will be inserted by the compiler to ensure that the parent constructor executes before the subtype constructor. Construction occurs from the base down because a subtype may rely on parent members and thus, the parent must have a chance to initialize them first. The second scenario is accessing a parent member from subtype code, <span class="No-Break">using </span><span class="No-Break"><strong class="source-inline">super.parentMember</strong></span><span class="No-Break">.</span></p>
			<p>We already know from <a href="B19793_08.xhtml#_idTextAnchor168"><span class="No-Break"><em class="italic">Chapter 8</em></span></a>, that the <strong class="source-inline">protected</strong> access modifier ensures members are available within the package and also to any subclasses, regardless of the package. We revisited this and demonstrated that, when accessing a <strong class="source-inline">protected</strong> member from a subclass in a different package, you have to do so, via inheritance, in a very <span class="No-Break">specific way.</span></p>
			<p>An <strong class="source-inline">abstract</strong> method is a method with no code (implementation). Even though a class does not need to have any <strong class="source-inline">abstract</strong> methods to be <strong class="source-inline">abstract</strong> itself; once the class has even one <strong class="source-inline">abstract</strong> method, the class must be <strong class="source-inline">abstract</strong>. Any subclass of an <strong class="source-inline">abstract</strong> class must provide the implementation code for the <strong class="source-inline">abstract</strong> method(s) inherited, or the subclass must also <span class="No-Break">be </span><span class="No-Break"><strong class="source-inline">abstract</strong></span><span class="No-Break">.</span></p>
			<p>Concerning inheritance, a <strong class="source-inline">final</strong> class cannot be inherited from. A <strong class="source-inline">final</strong> method cannot be overridden. Other uses for <strong class="source-inline">final</strong> are for defining constants and ensuring that (the values of) method parameters <span class="No-Break">are constant.</span></p>
			<p>The use of sealed classes enables us to restrict parts of a hierarchy to certain types. Rather than the general <strong class="source-inline">extends</strong>, which allows a class to subclass any base class it wants; and without turning off inheritance altogether using <strong class="source-inline">final</strong>; sealed classes achieve a custom restriction using the <strong class="source-inline">sealed</strong>, <strong class="source-inline">non-sealed</strong>, and <span class="No-Break"><strong class="source-inline">permits</strong></span><span class="No-Break"> keywords.</span></p>
			<p>Instance and <strong class="source-inline">static</strong> initialization blocks are coded outside the methods but inside the class. The <strong class="source-inline">static</strong> block precedes the block with the <strong class="source-inline">static</strong> keyword. The instance uses no keyword (instance semantics are implied). Both enable initialization at various points. Static initialization occurs just once – the first time a class is loaded. Instance initialization occurs every time a constructor is called. Consequently, instance blocks are perfect locations for inserting code that is common across <span class="No-Break">all constructors.</span></p>
			<p>Lastly, we took a deeper dive into upcasting and downcasting. This helped deepen our understanding as to why upcasting is not an issue, why downcasting needs a cast, and why we get <strong class="source-inline">ClassCastException</strong> errors. In addition, using the <strong class="source-inline">instanceof</strong> operator ensures that we prevent <strong class="source-inline">ClassCastException</strong> errors <span class="No-Break">from occurring.</span></p>
			<p>That completes our discussion on inheritance – this was a big chapter! We will now move on to interfaces and <span class="No-Break"><strong class="source-inline">abstract</strong></span><span class="No-Break"> classes.</span></p>
		</div>
	</body></html>