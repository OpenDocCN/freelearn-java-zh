- en: '*Chapter 6*: Implementing the User Interface – Task-Based'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To accomplish a difficult task, one must first make it easy.
  prefs: []
  type: TYPE_NORMAL
- en: – Marty Rubin
  prefs: []
  type: TYPE_NORMAL
- en: The essence of **Domain-Driven Design** (**DDD**) is about capturing the business
    process and user intent. In the previous chapter, we designed a set of APIs without
    paying much attention to how those APIs would get consumed by their eventual users.
    In this chapter, we will design the GUI for the LC application using the JavaFX
    framework. As part of that, we will examine how this approach of designing APIs
    in isolation can cause an impedance mismatch between the producers and the consumers.
    We will examine the consequences of this impedance mismatch and how task-based
    UIs can help cope with this mismatch.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will cover the following topics in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: API styles
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Bootstrapping the UI
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing the UI
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of the chapter, you will know how to employ DDD principles to help
    you build robust user experiences that are simple and intuitive. You will also
    learn why it may be prudent to design your backend interfaces (APIs) from the
    perspective of the consumer.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You will need access to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: JDK 1.8+ (we have used Java 16 to compile sample sources)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: JavaFX SDK 16 and Scene Builder
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Maven 3.x
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Spring Boot 2.4.x
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: mvvmFX 1.8 ([https://sialcasa.github.io/mvvmFX/](https://sialcasa.github.io/mvvmFX/))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: JUnit 5.7.x (included with Spring Boot)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: TestFX (for UI testing)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: OpenJFX Monocle (for headless UI testing)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Project Lombok (to reduce verbosity)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Before we dive deep into building the GUI solution, let’s do a quick recap of
    where we left the APIs.
  prefs: []
  type: TYPE_NORMAL
- en: API styles
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If you recall from [*Chapter 5*](B16716_05_Final_NM_ePub.xhtml#_idTextAnchor077),
    *Implementing Domain Logic*, we created the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.1 – Commands from the eventstorming session'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16716_Figure_6.1.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.1 – Commands from the eventstorming session
  prefs: []
  type: TYPE_NORMAL
- en: 'If you observe carefully, there seem to be commands at two levels of granularity.
    **Create LC Application** and **Update LC Application** are coarse-grained, whereas
    the others are a lot more focused in terms of their intent. One possible decomposition
    of the coarse-grained commands can be as depicted here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.2 – Decomposed commands'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16716_Figure_6.2.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.2 – Decomposed commands
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition to just being more fine-grained than the commands in the previous
    iteration, the revised commands seem to better capture the user’s intent. This
    may feel like a minor change in semantics, but can have a huge impact on the way
    our solution is used by its ultimate end users. The question then is whether we
    should *always* prefer fine-grained APIs over coarse-grained ones. The answer
    can be a lot more nuanced. When designing APIs and experiences, we see two main
    styles being employed:'
  prefs: []
  type: TYPE_NORMAL
- en: CRUD-based
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Task-based
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let’s look at each of these in a bit more detail.
  prefs: []
  type: TYPE_NORMAL
- en: CRUD-based APIs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`Insert`, `Select`, `Update`, and `Delete`. Similarly, the HTTP protocol has
    `POST`, `GET`, `PUT`, and `DELETE` as verbs to represent these CRUD operations.
    This approach has been extended to the design of our APIs as well. This has resulted
    in the proliferation of both CRUD-based APIs and user experiences. Take a look
    at `CreateLCApplicationCommand` from [*Chapter 5*](B16716_05_Final_NM_ePub.xhtml#_idTextAnchor077),
    *Implementing Domain Logic*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ch6-1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Along similar lines, it would not be uncommon to create a corresponding `UpdateLCApplicationCommand`,
    as depicted here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ch6-2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'While this is very common and also very easy to grasp, it is not without problems.
    Here are some questions that taking this approach raises:'
  prefs: []
  type: TYPE_NORMAL
- en: Are we allowed to change everything listed in the `update` command?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Assuming that everything can change, do they all change at the same time?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How do we know what exactly changed? Should we be doing a diff?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What if all the attributes mentioned above are not included in the `update` command?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What if we need to add attributes in the future?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Is the business intent of what the user wanted to accomplish captured?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In a simple system, the answer to these questions may not matter that much.
    However, as system complexity increases, will this approach remain resilient to
    change? We feel that it merits taking a look at another approach called task-based
    APIs to be able to answer these questions.
  prefs: []
  type: TYPE_NORMAL
- en: Task-based APIs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In a typical organization, individuals perform tasks relevant to their specialization.
    The bigger the organization, the higher the degree of specialization. This approach
    of segregating tasks according to one’s specialization makes sense because it
    mitigates the possibility of stepping on each other’s shoes, especially when getting
    complex pieces of work done. For example, in the LC application process, there
    is a need to establish the value/legality of the product while also determining
    the creditworthiness of the applicant. It makes sense that each of these tasks
    is usually performed by individuals in unrelated departments. It also follows
    that these tasks can be performed independently of the other.
  prefs: []
  type: TYPE_NORMAL
- en: In terms of a business process, if we have a single `CreateLCApplicationCommand`
    command that precedes these operations, individuals in both departments firstly
    have to wait for the entire application to be filled out before either can commence
    their work. Secondly, if either piece of information is updated through a single
    `UpdateLCApplicationCommand` command, it is unclear what changed. This can result
    in a spurious notification being sent to at least one department because of this
    lack of clarity in the process.
  prefs: []
  type: TYPE_NORMAL
- en: Since most work happens in the form of specific tasks, it can work to our advantage
    if our processes and, by extension, our APIs mirror these behaviors.
  prefs: []
  type: TYPE_NORMAL
- en: 'Keeping this in mind, let’s re-examine our revised APIs for the LC application
    process:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.3 – Revised commands'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16716_Figure_6.3.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.3 – Revised commands
  prefs: []
  type: TYPE_NORMAL
- en: While it may have appeared previously that we have simply converted our coarse-grained
    APIs to become more fine-grained, this, in reality, is a better representation
    of the tasks that the user intended to perform. So, in essence, task-based APIs
    are the decomposition of work in a manner that aligns more closely to the users’
    intents. With our new APIs, product validation can commence as soon as `ChangeMerchandise`
    happens. Also, it is unambiguously clear what the user did and what needs to happen
    in reaction to the user’s action. It then begs the question of whether we should
    employ task-based APIs all the time. Let’s look at the implications in more detail.
  prefs: []
  type: TYPE_NORMAL
- en: Task-based or CRUD-based?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'CRUD-based APIs seem to operate at the level of the aggregate. In our example,
    we have the LC aggregate. In the simplest case, this essentially translates to
    four operations aligned with each of the CRUD verbs. However, as we are seeing,
    even in our simplified version, the LC is becoming a fairly complex concept. Having
    to work with just four operations at the level of the LC is cognitively complex.
    With more requirements, this complexity will only continue to increase. For example,
    consider a situation where the business expresses a need to capture a lot more
    information about `merchandise`, where today, this is simply captured in the form
    of free-form text. A more elaborate version of merchandise information is shown
    here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ch6-3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'In our current design, the implications of this change are far-reaching for
    both the provider and the consumer(s). Let’s look at some of the consequences
    in more detail:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B16716_06_Table_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In our current design, the implications of this change are far-reaching for
    both the provider and the consumer(s). Let’s look at some of the consequences
    in more detail.
  prefs: []
  type: TYPE_NORMAL
- en: As we can see, the decision between CRUD-based and task-based interfaces is
    nuanced. We are not suggesting that you should choose one over the other. Which
    style you use will depend on your specific requirements and context. In our experience,
    task-based interfaces treat user intents as first-class citizens and perpetuate
    the spirit of DDD’s ubiquitous language very elegantly. Our preference is to design
    interfaces as task-based where possible because they result in more intuitive
    interfaces that better express the problem domain.
  prefs: []
  type: TYPE_NORMAL
- en: 'As systems evolve, and they begin to support richer user experiences and multiple
    channels, the CRUD-based interface seems to require additional translation layers
    to cater to user experience needs. The visual here depicts a typical layered architecture
    of a solution that supports multiple-user experience channels:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.4 – Layered architecture supporting multiple-user experience channels'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16716_Figure_6.4.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.4 – Layered architecture supporting multiple-user experience channels
  prefs: []
  type: TYPE_NORMAL
- en: 'This setup is usually composed of the following:'
  prefs: []
  type: TYPE_NORMAL
- en: A domain tier comprised of CRUD-based services that simply map closely to database
    entities
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A composite tier comprised of business capabilities that span more than one
    core service
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A **Backend for Frontend** (**BFF**) tier, comprised of channel-specific APIs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note that the composite and BFF tiers exist primarily as a means to map backend
    capabilities to user intent. In an ideal world, where backend APIs reflect user
    intent closely, the need for translations should be minimal (if at all). Our experience
    suggests that such a setup causes business logic to get pushed closer to the user
    channels as opposed to being encapsulated within the confines of well-factored
    business services. In addition, these tiers cause inconsistent experiences across
    channels for the same functionality, given that modern teams are structured along
    tier boundaries.
  prefs: []
  type: TYPE_NORMAL
- en: Important Note
  prefs: []
  type: TYPE_NORMAL
- en: We are not opposed to the use of layered architectures. We recognize that a
    layered architecture can bring modularity, separation of concerns, and other related
    benefits. However, we are opposed to creating additional tiers merely as a means
    to compensate for poorly factored core domain APIs.
  prefs: []
  type: TYPE_NORMAL
- en: A well-factored API tier can have a profound effect on how great user experiences
    are built. However, this is a chapter on implementing the user interface. Let’s
    revert to creating the user interface for the LC application.
  prefs: []
  type: TYPE_NORMAL
- en: Bootstrapping the UI
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will simply be building the UI for the LC application we created in [*Chapter
    5*](B16716_05_Final_NM_ePub.xhtml#_idTextAnchor077), *Implementing Domain Logic*.
    For detailed instructions, refer to the *Bootstrapping the application* section.
    In addition, we will need to add the following dependencies to the `dependencies`
    section of the Maven `pom.xml` file in the root directory of the project:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ch6-4.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'To run UI tests, you will need to add the following dependencies:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ch6-5.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'To be able to run the application from the command line, you will need to add
    `javafx-maven-plugin` to the `plugins` section of your `pom.xml` file, per the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ch6-6.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'To run the application from the command line, use the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Important Note
  prefs: []
  type: TYPE_NORMAL
- en: 'If you are using a JDK greater than version 1.8, the JavaFX libraries may not
    be bundled with the JDK itself. When running the application from your IDE, you
    will likely need to add the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`--module-path=<path-to-javafx-sdk>/lib/ \`'
  prefs: []
  type: TYPE_NORMAL
- en: '`--add-modules=javafx.controls,javafx.graphics,`'
  prefs: []
  type: TYPE_NORMAL
- en: '`javafx.fxml,javafx.media`'
  prefs: []
  type: TYPE_NORMAL
- en: 'We are making use of the mvvmFX framework to assemble the UI. To make this
    work with Spring Boot, the application launcher looks as depicted here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ch6-7.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Important Note
  prefs: []
  type: TYPE_NORMAL
- en: We are required to extend from the `MvvmfxSpringApplication` mvvmFX framework
    class.
  prefs: []
  type: TYPE_NORMAL
- en: Please refer to the `ch06` directory of the accompanying source code repository
    for the complete example.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the UI
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When working with user interfaces, it is fairly customary to use one of these
    presentation patterns:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Model View Controller** (**MVC**)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Model View Presenter** (**MVP**)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Model View View Model** (**MVVM**)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The MVC pattern has been around for the longest time. The idea of separating
    concerns among collaborating model, view, and controller objects is a sound one.
    However, beyond the definition of these objects, actual implementations seem to
    vary wildly – with the controller becoming overly complex in a lot of cases. In
    contrast, MVP and MVVM, while being derivatives of MVC, seem to bring about a
    better separation of concerns between the collaborating objects. MVVM, in particular
    when coupled with data-binding constructs, makes for code that is much more readable,
    maintainable, and testable. In this book, we make use of MVVM because it enables
    test-driven development, which is a strong personal preference for us. Let’s look
    at a quick MVVM primer, as implemented in the mvvmFX framework.
  prefs: []
  type: TYPE_NORMAL
- en: MVVM primer
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Modern UI frameworks started adopting a declarative style to express the view.
    MVVM was designed to remove all GUI code (code-behind) from the view by making
    use of binding expressions. This allowed for a cleaner separation of stylistic
    versus programming concerns. A high-level visual of how this pattern is implemented
    is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.5 – MVVM design pattern'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16716_Figure_6.6.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.5 – MVVM design pattern
  prefs: []
  type: TYPE_NORMAL
- en: 'The pattern comprises the following components:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Model**: Responsible for housing the business logic and managing the state
    of the application.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**View**: Responsible for presenting data to the user and notifying the view-model
    about user interactions through the view delegate.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**View Delegate**: Responsible for keeping the view and the view-model in sync
    as changes are made by the user or on the view-model. It is also responsible for
    transmitting actions performed on the view to the view-model.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**View-Model**: Responsible for handling user interactions on behalf of the
    view. The view-model interacts with the view using the observer pattern (typically,
    one-way or two-way data binding to make it more convenient). The view-model interacts
    with the model for updates and read operations.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a new LC
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s consider the example of creating a new LC. To start the creation of a
    new LC, all we need is for the applicant to provide a friendly client reference.
    This is an easy-to-remember string of free text. A simple rendition of this UI
    is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.7 – Start LC creation screen'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16716_Figure_6.7.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.7 – Start LC creation screen
  prefs: []
  type: TYPE_NORMAL
- en: Let’s examine the implementation and purpose of each component in more detail.
  prefs: []
  type: TYPE_NORMAL
- en: Declarative view
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When working with JavaFX, the view can be rendered using a declarative style
    in FXML format. Important excerpts from the `StartLCView.fxml` file to start creating
    a new LC are shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ch6-8.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The `StartLCView` class acts as the view delegate for the FXML view and is assigned
    using the `fx:controller` attribute of the root element (`javafx.scene.layout.Pane`,
    in this case).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In order to reference the `client-reference` input field in the view delegate,
    we use the `fx:id` annotation (`clientReference`, in this case).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Similarly, the start button is referenced using "`fx:id=startButton"` in the
    view delegate. Furthermore, the `start` method in the view delegate is assigned
    to handle the default action (the button press event for `javafx.scene.control.Button`).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: View delegate
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Next, let’s look at the structure of the `com.premonition.lc.issuance.ui.views.StartLCView`
    view delegate:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ch6-9.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This is the view delegate class for the `StartLCView.fxml` view.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This is the Java binding for the `clientReference` textbox in the view. The
    name of the member needs to match exactly with the value of the `fx:id` attribute
    in the view. Further, it needs to be annotated with the `@javafx.fxml.FXML` annotation.
    The use of the `@FXML` annotation is optional if the member in the view delegate
    is public and matches the name in the view.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Similarly, `startButton` is bound to the corresponding button widget in the
    view.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This is the method for the action handler when `startButton` is pressed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: View-model
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `StartLCViewModel` view-model class for `StartLCView` is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ch6-10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This is the view-model class for `StartLCView`. Note that we are required to
    implement the `de.saxsys.mvvmfx.ViewModel` interface provided by the mvvmFX framework.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We are initializing the `clientReference` property using `SimpleStringProperty`
    provided by JavaFX. There are several other property classes to define more complex
    types. Please refer to the JavaFX documentation for more details.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This is the value of `clientReference` in the view-model. We will look at how
    to associate this with the value of the `clientReference` textbox in the view
    shortly. Note that we are using `StringProperty` provided by JavaFX, which provides
    access to the underlying string value of the client reference.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: JavaFX beans are required to create a special accessor for the property itself
    in addition to the standard getter and setter for the underlying value.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Binding the view to the view-model
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Next, let’s look at how to associate the view to the view-model:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ch6-11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The `mvvmFX` framework requires that the `view delegate` implement the `FXMLView<?`
    `extends` `ViewModelType>`. In this case, the view-model type is `StartLCViewModel`.
    The `mvvmFX` framework supports other view types as well. Please refer to the
    framework documentation for more details.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The framework provides a `@de.saxsys.mvvmfx.InjectViewModel` annotation to allow
    dependency, injecting the view-model into the view delegate.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The framework will invoke all methods annotated with the `@de.saxsys.mvvmfx.Initialize`
    annotation during the initialization process. The annotation can be omitted if
    the method is named `initialize` and is declared public. Please refer to the framework
    documentation for more details.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We have now bound the text property of the `clientReference` textbox in the
    view delegate to the corresponding property in the view-model. Note that this
    is a bidirectional binding, which means that the value in the view and the view-model
    are kept in sync if it changes on either side.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This is another variation of binding in action, where we are making use of a
    unidirectional binding. Here, we are binding the disabled property of the start
    button to the corresponding property on the view-model. We will look at why we
    need to do this shortly.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Enforcing business validations in the UI
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We have a business validation that the client reference for an LC needs to be
    at least four characters in length. This will be enforced on the backend. However,
    to provide a richer user experience, we will also enforce this validation on the
    UI.
  prefs: []
  type: TYPE_NORMAL
- en: Important Note
  prefs: []
  type: TYPE_NORMAL
- en: This may feel contrary to the notion of centralizing business validations on
    the backend. While this may be a noble attempt at implementing the **Don’t Repeat
    Yourself** (**DRY**) principle, in reality, it poses a lot of practical problems.
    Distributed systems expert Udi Dahan has a very interesting take on why this may
    not be such a virtuous thing to pursue. Ted Neward also talks about this in his
    blog, entitled *The Fallacies of Enterprise Computing*.
  prefs: []
  type: TYPE_NORMAL
- en: 'The advantage of using MVVM is that this logic is easily testable in a simple
    unit test of the view-model. Let’s see this in action now:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ch6-12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, let’s look at the implementation for this functionality in the view-model:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ch6-13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We declare a `startDisabled` property in the view-model to manage when the start
    button should be disabled.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The minimum length for a valid client reference is injected into the view-model.
    It is conceivable that this value will be provided as part of the external configuration,
    or possibly from the backend.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We create a binding expression to match the business requirement.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We bind the view-model property to the disabled property of the start button
    in the view delegate.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let’s also look at how to write an end-to-end, headless UI test, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ch6-14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We have written a convenience `@UITest` extension to combine the Spring Framework
    and TestFX testing. Please refer to the accompanying source code with the book
    for more details.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We set up the Spring context to act as the dependency injection provider for
    the mvvmFX framework and its injection annotations (for example, `@InjectViewModel`)
    to work.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We are using the `@Start` annotation provided by the TestFX framework to launch
    the UI.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The TestFX framework injects an instance of the FxRobot UI helper, which we
    can use to access UI elements.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We are using the TestFX framework-provided convenience-matchers for test assertions.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, when we run the application, we can see that the start button is enabled
    when a valid client reference is entered:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.8 – The start button is enabled with a valid client reference'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16716_Figure_6.8.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.8 – The start button is enabled with a valid client reference
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have the start button enabling correctly, let’s implement the actual
    creation of the LC itself by invoking the backend API.
  prefs: []
  type: TYPE_NORMAL
- en: Integrating with the backend
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'LC creation is a complex process, requiring information about a variety of
    items as evidenced when we decomposed the LC creation process. In this section,
    we will integrate the UI with the command to start the creation of a new LC. This
    happens when we press the `StartNewLCApplicationCommand` looks as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ch6-15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: To start a new LC application, we need `applicantId` and `clientReference`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Given that we are using the MVVM pattern, the code to invoke the backend service
    is part of the view-model. Let’s test-drive this functionality:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ch6-16.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The view-model is enhanced accordingly to inject an instance of `BackendService`
    and looks as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ch6-17.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, let’s test to actually make sure that the backend gets invoked only when
    a valid client reference is input:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ch6-18.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We set the logged-in user.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When the client reference is blank, there should be no interactions with the
    backend service.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When a valid value for the client reference is entered, the backend should be
    invoked with the entered value.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The implementation to make this test pass looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ch6-19.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We check that the start button is enabled before invoking the backend.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: These are the actual backend calls with the appropriate values.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, let’s look at how to integrate the backend call from the view. We test
    this in a UI test, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ch6-20.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We inject a mock instance of the backend service.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We stub the call to the backend to return successfully.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We type in a valid value for the client reference.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We click on the **Start** button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We verify that the service was indeed invoked with the correct arguments.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We verify that we have moved to the next screen in the UI (the LC details screen).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let’s also look at what happens when the service invocation fails in another
    test:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ch6-21.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We stub the backend service call to fail with an exception.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We verify that we continue to remain on `start-lc-screen`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The view implementation for this functionality is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ch6-22.jpg)'
  prefs: []
  type: TYPE_IMG
- en: JavaFX, like most frontend frameworks, is single-threaded and requires that
    long-running tasks not be invoked on the UI thread. For this purpose, it provides
    the `javafx.concurrent.Service` abstraction to handle such interactions elegantly
    in a background thread.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The actual invocation of the backend through the view-model happens here.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We show the next screen to enter more LC details here.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Finally, the service implementation itself is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ch6-23.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We inject `org.axonframework.commandhandling.gateway.CommandGateway` provided
    by Axon Framework to invoke the command.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The actual invocation of the backend using the `sendAndWait` method happens
    here. In this case, we are blocking until the backend call completes. There are
    other variations that do not require this kind of blocking. Please refer to the
    Axon Framework documentation for more details.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We have now seen a complete example of how to implement the UI and invoke the
    backend API.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we looked at the nuances of API styles and clarified why it
    is very important to design APIs that capture the users’ intent closely. We looked
    at the differences between CRUD-based and task-based APIs. Finally, we implemented
    the UI making use of the MVVM design pattern and demonstrated how it aids in test-driving
    frontend functionality.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have implemented the creation of a new LC, for implementing the
    subsequent commands we will require access to an existing LC. In the next chapter,
    we will look at how to implement the query side and how to keep it in sync with
    the command side.
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![](img/B16716_06_Table_02.jpg)'
  prefs: []
  type: TYPE_IMG
