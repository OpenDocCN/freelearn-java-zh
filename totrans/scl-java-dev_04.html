<html><head></head><body><div class="chapter" title="Chapter&#xA0;4.&#xA0;Testing Tools"><div class="titlepage"><div><div><h1 class="title"><a id="ch04"/>Chapter 4. Testing Tools</h1></div></div></div><p>No matter which language you are programming in, testing should be performed with great care, as it will not only document your code in a consistent way but will also be of great help for refactoring and maintenance activities, such as fixing bugs.</p><p>The Scala ecosystem largely follows <a id="id195" class="indexterm"/>Java trends towards testing at all levels, but with some differences. At many places, we will <a id="id196" class="indexterm"/>see that Scala is using <span class="strong"><strong>DSLs</strong></span> (<span class="strong"><strong>Domain Specific</strong></span> <span class="strong"><strong>Languages</strong></span>), which makes the testing code very clear to read and understand. As a matter of fact, testing can be a good area to start with when introducing Scala, migrating progressively from an existing Java project.</p><p>In this chapter, we are going to cover some of the major testing tools and their usage through a number of code examples. We have already written a tiny JUnit-like test in Scala in <a class="link" href="ch03.html" title="Chapter 3. Understanding the Scala Ecosystem">Chapter 3</a>, <span class="emphasis"><em>Understanding the Scala Ecosystem</em></span>, so we will go from here and focus on BDD-style tests that belong to <a id="id197" class="indexterm"/>
<span class="strong"><strong>Behavior Driven Development</strong></span> (<span class="strong"><strong>BDD</strong></span>). Agnostic to which technology stack is used, BDD has emerged in these past few years as a compliant choice for writing clear specifications in the <a id="id198" class="indexterm"/>Gherkin language (which is part of the cucumber framework and is explained at <a class="ulink" href="http://cukes.info/gherkin.html">http://cukes.info/gherkin.html</a>) on how code should behave. Already used in Java and many other languages, tests written in that style are often easier to understand and maintain as they are closer to plain English. They are one step closer to the true adoption of BDD that aims at making the business analysts write the test specifications in a structured way, which the programs can understand and implement. They often represent the sole documentation; it is therefore very important to keep them up to date and close to the domain.</p><p>Scala primarily offers two frameworks to write tests, <a id="id199" class="indexterm"/>
<span class="strong"><strong>ScalaTest</strong></span> (<a class="ulink" href="http://www.scalatest.org">www.scalatest.org</a>) and <a id="id200" class="indexterm"/>
<span class="strong"><strong>Specs2</strong></span> (<a class="ulink" href="http://etorreborre.github.io/specs2/">etorreborre.github.io/specs2/</a>). As they are quite similar to each other, we are only going to cover ScalaTest, and interested readers can look through the Specs2 documentation to understand their differences. Moreover, we will take a look at automated property-based testing using the <span class="strong"><strong>ScalaCheck</strong></span> framework (<a class="ulink" href="http://www.scalacheck.org">www.scalacheck.org</a>).</p><div class="section" title="Writing tests with ScalaTest"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec25"/>Writing tests with ScalaTest</h1></div></div></div><p>To be able to quickly start <a id="id201" class="indexterm"/>visualizing some of the tests that can be written with ScalaTest, we can take advantage of the <code class="literal">test-patterns-scala</code> template from the Typesafe Activator that we introduced in the previous chapter. It consists of a number of examples that essentially target the ScalaTest framework.</p><p>Setting up the <code class="literal">test-patterns-scala</code> activator project only requires you to go to the directory where you installed the Typesafe Activator, as we did earlier, and then, either start the GUI through the <code class="literal">&gt; activator ui</code> command, or type <code class="literal">&gt; activator new</code> to create a new project and select the appropriate template when prompted.</p><p>The template project already contains the <a id="id202" class="indexterm"/>
<code class="literal">sbteclipse</code> plugin; therefore, you can generate eclipse-related files by simply entering from a command prompt in the root directory of the project, as follows:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>&gt; activator eclipse</strong></span>
</pre></div><p>Once the eclipse project is successfully created, you may import it into your IDE workspace by selecting <span class="strong"><strong>File</strong></span> | <span class="strong"><strong>Import...</strong></span> | <span class="strong"><strong>General</strong></span> |<span class="strong"><strong>Existing Projects</strong></span>. As a reminder from the previous chapter, you can also create project files for IntelliJ or other IDEs since the Typesafe Activator is just a customized version of SBT.</p><p>You can look into the various test cases in <code class="literal">src/test/scala</code>. As some of the tests use frameworks such as Akka, Spray, or Slick, which we haven't covered yet, we will skip these for now to concentrate on the most straightforward ones.</p><p>In its simplest form, a <code class="literal">ScalaTest</code> <a id="id203" class="indexterm"/>class (which, by the way, might also test Java code and not just Scala code) can be declared by extending <code class="literal">org.scalatest.FunSuite</code>. Each test is represented as a function value, and this is implemented in the <code class="literal">Test01.scala</code> class, as shown in the following code:</p><div class="informalexample"><pre class="programlisting">package scalatest
import org.scalatest.FunSuite

class Test01 extends FunSuite {
  test("Very Basic") {
    assert(1 == 1)
  }
  test("Another Very Basic") {
    assert("Hello World" == "Hello World")
  }
}</pre></div><p>To execute only this single test class, you should enter the following command in the command prompt:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>&gt; activator</strong></span>
<span class="strong"><strong>&gt; test-only &lt;full name of the class to execute&gt;</strong></span>
</pre></div><p>In our case, this command will be as follows:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>&gt; test-only scalatest.Test01   (or scalatest.Test01.scala)</strong></span>
<span class="strong"><strong>[info] Test01:</strong></span>
<span class="strong"><strong>[info] - Very Basic (38 milliseconds)</strong></span>
<span class="strong"><strong>[info] - Another Very Basic (0 milliseconds)</strong></span>
<span class="strong"><strong>[info] ScalaTest</strong></span>
<span class="strong"><strong>[info] Run completed in 912 milliseconds.</strong></span>
<span class="strong"><strong>[info] Total number of tests run: 2</strong></span>
<span class="strong"><strong>[info] Suites: completed 1, aborted 0</strong></span>
<span class="strong"><strong>[info] Tests: succeeded 2, failed 0, canceled 0, ignored 0, pending 0</strong></span>
<span class="strong"><strong>[info] All tests passed.</strong></span>
<span class="strong"><strong>[info] Passed: Total 2, Failed 0, Errors 0, Passed 2</strong></span>
<span class="strong"><strong>[success] Total time: 9 s, completed Nov 11, 2013 6:12:14 PM</strong></span>
</pre></div><p>The example given under <code class="literal">src/test/scala/scalatest/Test02.scala</code> within the <code class="literal">test-patterns-scala</code> project is very similar, but the extra <code class="literal">===</code> instead of <code class="literal">==</code> will give you additional info when the test fails. This is shown as follows:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>class Test02 extends FunSuite {</strong></span>
<span class="strong"><strong>  test("pass") {</strong></span>
<span class="strong"><strong>    assert("abc" === "abc")</strong></span>
<span class="strong"><strong>  }</strong></span>
<span class="strong"><strong>  test("fail and show diff") {</strong></span>
<span class="strong"><strong>    assert("abc" === "abcd") // provide reporting info</strong></span>
<span class="strong"><strong>  }</strong></span>
<span class="strong"><strong>}</strong></span>
</pre></div><p>Once again running the test can be done by entering the following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>&gt; test-only scalatest.Test02</strong></span>
<span class="strong"><strong>[info] Test02:</strong></span>
<span class="strong"><strong>[info] - pass (15 milliseconds)</strong></span>
<span class="strong"><strong>[info] - fail and show diff *** FAILED *** (6 milliseconds)</strong></span>
<span class="strong"><strong>[info]   "abc[]" did not equal "abc[d]" (Test02.scala:10)</strong></span>
<span class="strong"><strong>[info] …</strong></span>
<span class="strong"><strong>[info] *** 1 TEST FAILED ***</strong></span>
<span class="strong"><strong>[error] Failed: Total 2, Failed 1, Errors 0, Passed 1</strong></span>
</pre></div><p>Before fixing the failing test, this time, we can execute the test in the continuous mode, using the <code class="literal">~</code> character in front of <code class="literal">test-only</code> (from the activator prompt), as follows:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>&gt;~test-only scalatest.Test02</strong></span>
</pre></div><p>The continuous mode will make SBT rerun the <a id="id204" class="indexterm"/>
<code class="literal">test-only</code> command each time the <code class="literal">Test02</code> class is edited and saved. This feature of SBT can make you save a significant amount of time by running in the background tests or just programs without having to explicitly write the command. On the first execution of <code class="literal">Test02</code>, you can see some red text indicating <code class="literal">"abc[]" did not equal "abc[d]" (Test02.scala:10)</code>.</p><p>As soon as you correct the <code class="literal">abdc</code> string and save the file, SBT will automatically re-execute the test in the background, and you can see the text turning green.</p><p>The continuous mode works for the other SBT commands as well, such as <code class="literal">~run</code> or <code class="literal">~test</code>.</p><p>
<code class="literal">Test03</code> shows you how to expect or catch exceptions:</p><div class="informalexample"><pre class="programlisting">class Test03 extends FunSuite {
  test("Exception expected, does not fire, FAIL") {
    val msg = "hello"
    intercept[IndexOutOfBoundsException] {
      msg.charAt(0)
    }
  }
  test("Exception expected, fires, PASS") {
    val msg = "hello"
    intercept[IndexOutOfBoundsException] {
      msg.charAt(-1)
    }
  }
}</pre></div><p>The first scenario fails as it was expecting an <code class="literal">IndexOutOfBoundsException</code>, but the code is indeed returning a valid <code class="literal">h</code>, the character at index 0 of the <code class="literal">hello</code> string.</p><p>To be able to run ScalaTest test suites as JUnit test suites (for example, to run them within the IDE or when extending an existing JUnit-based project that is already built in Maven, or when reporting to a build server), we can use the available <code class="literal">JUnitRunner</code> class along with the <code class="literal">@RunWith</code> annotation, as shown in the following sample:</p><div class="informalexample"><pre class="programlisting">import org.junit.runner.RunWith
import org.scalatest.junit.JUnitRunner
import org.scalatest.FunSuite
@RunWith(classOf[JUnitRunner])
class MyTestSuite extends FunSuite {
  // ...
}</pre></div><div class="section" title="BDD-style testing"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec34"/>BDD-style testing</h2></div></div></div><p>
<code class="literal">Test06</code> is an example of a test <a id="id205" class="indexterm"/>written in a different style, namely BDD. In short, you <a id="id206" class="indexterm"/>specify some kind of a user story in almost plain English that describes the behavior <a id="id207" class="indexterm"/>of the scenario you want to test. This can be seen in the following code:</p><div class="informalexample"><pre class="programlisting">class Test06 extends FeatureSpec with GivenWhenThen {

  feature("The user can pop an element off the top of the stack") 
  {
info("As a programmer")
  info("I want to be able to pop items off the stack")
  info("So that I can get them in last-in-first-out order")

  scenario("pop is invoked on a non-empty stack") {

    given("a non-empty stack")
    val stack = new Stack[Int]
    stack.push(1)
    stack.push(2)
    val oldSize = stack.size

  when("when pop is invoked on the stack")
  val result = stack.pop()

  then("the most recently pushed element should be returned")
  assert(result === 2)

  and("the stack should have one less item than before")
  assert(stack.size === oldSize - 1)
  }

  scenario("pop is invoked on an empty stack") {

    given("an empty stack")
    val emptyStack = new Stack[Int]

    when("when pop is invoked on the stack")
    then("NoSuchElementException should be thrown")
    intercept[NoSuchElementException] {
    emptyStack.pop()
    }

  and("the stack should still be empty")
  assert(emptyStack.isEmpty)
  }
}
}</pre></div><p>BDD-style tests represent a higher level of abstraction than JUnit tests, and are more suitable for integration and acceptance testing as well as documentation, for people knowledgeable about the domain. You just need to extend the <code class="literal">FeatureSpec</code> class, optionally with a <code class="literal">GivenWhenThen</code> trait, to describe acceptance requirements. More details about BDD-style tests can be found at <a class="ulink" href="http://en.wikipedia.org/wiki/Behavior-driven_development">http://en.wikipedia.org/wiki/Behavior-driven_development</a>. We just want to illustrate here that it is possible to write the BDD-style tests in Scala, but we won't go further into their details as they are already <a id="id208" class="indexterm"/>largely documented for Java and other programming languages.</p><p>ScalaTest provides a convenient <a id="id209" class="indexterm"/>DSL to write assertions in a way close to plain English. The <code class="literal">org.scalatest.matchers.Matchers</code> trait contains many possible assertions and you should look at its ScalaDoc documentation to see many usage examples. <code class="literal">Test07.scala</code> expresses a very simple matcher, as shown in the following code:</p><div class="informalexample"><pre class="programlisting">package scalatest

import org.scalatest._
import org.scalatest.Matchers

class Test07 extends FlatSpec with Matchers {
"This test" should "pass" in {
    true should be === true
  }
}</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note06"/>Note</h3><p>Although built with Version 2.0 of ScalaTest, the original sample given in the activator project uses the now deprecated <code class="literal">org.scalatest.matchers.ShouldMatchers</code> trait; the preceding code sample achieves the same behavior but is more up to date.</p></div></div><p>Let's write a few more assertions using a Scala Worksheet. Right-click on the <code class="literal">scalatest</code> package that contains all the test files that were previously reviewed and then select <span class="strong"><strong>new</strong></span> | <span class="strong"><strong>Scala Worksheet</strong></span>. We will name this worksheet as <code class="literal">ShouldWork</code>. We can then write and evaluate matchers by <a id="id210" class="indexterm"/>extending a <code class="literal">FlatSpec</code> specification with the <code class="literal">Matchers</code> trait, as shown in the following code:</p><div class="informalexample"><pre class="programlisting">package scalatest
import org.scalatest._
object ShouldWork extends FlatSpec with Matchers {

  true should be === true

}</pre></div><p>Saving this worksheet will not produce <a id="id211" class="indexterm"/>any output as the matcher passes the test. However, try to make it fail by changing one <code class="literal">true</code> to <code class="literal">false</code>. This is shown in the following code:</p><div class="informalexample"><pre class="programlisting">package scalatest
import org.scalatest._

object ShouldWork extends FlatSpec with Matchers {

  true should be === false

}</pre></div><p>This time, we get a full stack trace as part of the evaluation, as shown in the following screenshot:</p><div class="mediaobject"><img src="graphics/3637OS_04_03.jpg" alt="BDD-style testing"/></div><p>We can start evaluating many more <a id="id212" class="indexterm"/>
<code class="literal">should</code> matchers, as shown in the <a id="id213" class="indexterm"/>following code:</p><div class="informalexample"><pre class="programlisting">package scalatest
import org.scalatest._

object ShouldMatchers extends FlatSpec with Matchers {

  true should be === true

  List(1,2,3,4) should have length(4)

  List.empty should be (Nil)

  Map(1-&gt;"Value 1", 2-&gt;"Value 2") should contain key (2)
  Map(1-&gt;"Java", 2-&gt;"Scala") should contain value ("Scala")

  Map(1-&gt;"Java", 2-&gt;"Scala") get 1 should be (Some("Java"))

  Map(1-&gt;"Java", 2-&gt;"Scala") should (contain key (2) and not contain value ("Clojure"))

  3 should (be &gt; (0) and be &lt;= (5))

  new java.io.File(".") should (exist)
}</pre></div><p>The evaluation of the worksheet stops whenever we encounter a test failure. Therefore, we have to fix it in order to be able to progress in the test. This is identical to running the whole testsuite with the SBT <code class="literal">test</code> <a id="id214" class="indexterm"/>command, as we did previously, and as shown in the <a id="id215" class="indexterm"/>following code:</p><div class="informalexample"><pre class="programlisting">object ShouldMatchers extends FlatSpec with Matchers {

"Hello" should be ("Hello")

"Hello" should (equal ("Hej")
               or equal ("Hell")) //&gt; org.scalatest.exceptions.TestFailedException:

"Hello" should not be ("Hello")
}</pre></div><p>In the previous example, the last statement (which is the opposite of the first one) should fail; instead, it is not evaluated.</p></div><div class="section" title="Functional testing"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec35"/>Functional testing</h2></div></div></div><p>ScalaTest is well integrated with <a id="id216" class="indexterm"/>Selenium (it is a tool for automating testing in <a id="id217" class="indexterm"/>browsers and is available at <a class="ulink" href="http://www.seleniumhq.org">www.seleniumhq.org</a>) by providing a <a id="id218" class="indexterm"/>complete DSL, making it straightforward to write functional tests. <code class="literal">Test08</code> is a clear <a id="id219" class="indexterm"/>example of this integration:</p><div class="informalexample"><pre class="programlisting">class Test08 extends FlatSpec with Matchers with WebBrowser {

  implicit val webDriver: WebDriver = new HtmlUnitDriver
go to "http://www.amazon.com"
click on "twotabsearchtextbox"
textField("twotabsearchtextbox").value = "Scala"
submit()
pageTitle should be ("Amazon.com: Scala")
pageSource should include("Scala Cookbook: Recipes")
}</pre></div><p>Let's try to run a similar invocation directly into a worksheet. As worksheets give feedback on every statement evaluation, they are very convenient to directly identify what the problem is, for instance, if a link, a button, or content is not found as expected.</p><p>Just create another worksheet called <span class="strong"><strong>Functional</strong></span> next to the <span class="strong"><strong>ShouldWork</strong></span> worksheet that is already present. Right-click on the <code class="literal">scalatest</code> package and select <span class="strong"><strong>New</strong></span> | <span class="strong"><strong>Scala Worksheet</strong></span>.</p><p>The worksheet can be <a id="id220" class="indexterm"/>filled as follows:</p><div class="informalexample"><pre class="programlisting">package scalatest
import org.scalatest._
import org.scalatest.selenium.WebBrowser
import org.openqa.selenium.htmlunit.HtmlUnitDriver
import org.openqa.selenium.firefox.FirefoxDriver
import org.openqa.selenium.WebDriver
object Functional extends FlatSpec with Matchers with WebBrowser {
implicit val webDriver: WebDriver = new HtmlUnitDriver
  go to "http://www.packtpub.com/"
  textField("keys").value = "Scala"
  submit()
  pageTitle should be ("Search | Packt Publishing")
  pageSource should include("Akka")
}</pre></div><p>Upon the save operation (<span class="emphasis"><em>Ctrl</em></span> + <span class="emphasis"><em>S</em></span>), the worksheet will be evaluated and should probably display some output information for <a id="id221" class="indexterm"/>every statement, except for the last two lines with <code class="literal">should</code> matchers, as they should evaluate to <code class="literal">true</code>.</p><p>Try to change <code class="literal">("Search | Packt Publishing")</code> to a different value, such as <code class="literal">Results</code> or just <code class="literal">Packt Publishing</code>, <a id="id222" class="indexterm"/>and notice how the console output provides handy information on what does not match. This is shown in the following screenshot:</p><div class="mediaobject"><img src="graphics/3637OS_04_04_revised.jpg" alt="Functional testing"/></div><p>This functional test just scratches the surface of what's possible. As we are using the Java Selenium library, in Scala, you can <a id="id223" class="indexterm"/>inherit the power of the Selenium framework that is <a id="id224" class="indexterm"/>available in Java.</p></div><div class="section" title="Mocking with ScalaMock"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec36"/>Mocking with ScalaMock</h2></div></div></div><p>Mocking is a technique by <a id="id225" class="indexterm"/>which you can test code without requiring all of its dependencies <a id="id226" class="indexterm"/>in place. Java offers several frameworks for mocking objects when writing tests. The most well known are JMock, EasyMock, and Mockito. As the Scala language introduces new elements such as traits and functions, the Java-based mocking frameworks are not enough, and this is where ScalaMock (<a class="ulink" href="http://www.scalamock.org">www.scalamock.org</a>) comes into play.</p><p>ScalaMock is a native Scala-mocking <a id="id227" class="indexterm"/>framework that is typically used within ScalaTest (or Specs2), by importing the following dependencies into the SBT (<code class="literal">build.sbt</code>) file:</p><div class="informalexample"><pre class="programlisting">libraryDependencies +="org.scalamock" %% "scalamock-scalatest-support" % "3.0.1" % "test"</pre></div><p>Within Specs2, the following dependencies need to be imported:</p><div class="informalexample"><pre class="programlisting">libraryDependencies +=
"org.scalamock" %% "scalamock-specs2-support" % "3.0.1" % "test"</pre></div><p>Since the release of the Scala Version 2.10, ScalaMock has been rewritten, and the ScalaMock Version 3.<span class="emphasis"><em>x</em></span> is the version that we are going to cover briefly by going through an example of mocking a trait.</p><p>Let's first define the code that we are going to test. It consists of a tiny currency converter (available at <a class="ulink" href="http://www.luketebbs.com/?p=58">http://www.luketebbs.com/?p=58</a>) that fetches currency rates from the European Central Bank. Retrieving and parsing the XML file of currency rates is only a matter of a few lines of code, as follows:</p><div class="informalexample"><pre class="programlisting">trait Currency {
  lazy val rates : Map[String,BigDecimal] = {
  val exchangeRates =
    "http://www.ecb.europa.eu/stats/eurofxref/eurofxref-daily.xml"
  for (
    elem &lt;- xml.XML.load(exchangeRates)\"Cube"\"Cube"\"Cube")
  yield
    (elem\"@currency").text -&gt; BigDecimal((elem\"@rate").text)
  }.toMap ++ Map[String,BigDecimal]("EUR" -&gt; 1)

  def convert(amount:BigDecimal,from:String,to:String) =
    amount / rates(from) * rates(to)
}</pre></div><p>In this example, the currency rates are fetched from a URL using the <code class="literal">xml.XML.load</code> method. As XML is part of the Scala <a id="id228" class="indexterm"/>standard library, there is no need for imports here. The load method parses and returns the XML rates as an immutable structure of type <code class="literal">Elem</code>, <a id="id229" class="indexterm"/>which is a case class that represents XML elements. This is shown in the following code:</p><div class="informalexample"><pre class="programlisting">&lt;gesmes:Envelope 
&gt;
  &lt;gesmes:subject&gt;Reference rates&lt;/gesmes:subject&gt;
    &lt;gesmes:Sender&gt;
      &lt;gesmes:name&gt;European Central Bank&lt;/gesmes:name&gt;
    &lt;/gesmes:Sender&gt;
    &lt;Cube&gt;
      &lt;Cube time="2013-11-15"&gt;
      &lt;Cube currency="USD" rate="1.3460"/&gt;
      &lt;Cube currency="JPY" rate="134.99"/&gt;
      &lt;Cube currency="BGN" rate="1.9558"/&gt;
      &lt;Cube currency="CZK" rate="27.155"/&gt;
      &lt;Cube currency="DKK" rate="7.4588"/&gt;
      &lt;Cube currency="GBP" rate="0.83770"/&gt;
           ...
         ...
    &lt;/Cube&gt;
  &lt;/Cube&gt;
&lt;/gesmes:Envelope&gt;</pre></div><p>Accessing the list of currency rates from this XML document is done through an XPath expression by navigating inside the Cube nodes, hence the <code class="literal">xml.XML.load(exchangeRates) \ "Cube" \ "Cube" \ "Cube"</code> expression. A single for comprehension (the <code class="literal">for (…)</code> <code class="literal">yield (…)</code> construct that we introduced in the previous chapter) is required to loop over the currency rates and return a collection of <code class="literal">key -&gt; value</code> pairs where, in our case, a key will be a string that represents the currency name, and <code class="literal">value</code> will be a BigDecimal value that represents the rate. Notice how the information is extracted from <code class="literal">&lt;Cube currency="USD" rate="1.3460"/&gt;</code> by writing <code class="literal">(elem \ "@currency").text</code> to capture the currency attribute and <code class="literal">(elem \ "@rate").text</code> to capture the rate respectively. The latter will be further processed by creating a new <code class="literal">BigDecimal</code> value from the given string.</p><p>In the end, we get a <code class="literal">Map[String, BigDecimal]</code> that contains all our currencies with their rates. To this value, we add <a id="id230" class="indexterm"/>the mapping for the currency EUR (Euros) that will represent the reference rate one; this is why we use the <code class="literal">++</code> operator to merge two maps, that is, the one we just created together with a new map containing only one  <code class="literal">key -&gt; value</code> element, <code class="literal">Map[String,BigDecimal]("EUR"-&gt; 1).</code>
</p><p>Before mocking, let's write a regular test using ScalaTest with <code class="literal">FlatSpec</code> and <code class="literal">Matchers</code>. We will make use of our <code class="literal">Converter</code> trait, by integrating it into the following <code class="literal">MoneyService</code> class:</p><div class="informalexample"><pre class="programlisting">package se.chap4

class MoneyService(converter:Converter ) {

  def sendMoneyToSweden(amount:BigDecimal,from:String): BigDecimal = {
    val convertedAmount = converter.convert(amount,from,"SEK")
    println(s" $convertedAmount SEK are on their way...")
    convertedAmount
  }

  def sendMoneyToSwedenViaEngland(amount:BigDecimal,from:String): BigDecimal = {
    val englishAmount = converter.convert(amount,from,"GBP")
    println(s" $englishAmount GBP are on their way...")
    val swedishAmount = converter.convert(englishAmount,"GBP","SEK")
    println(s" $swedishAmount SEK are on their way...")
    swedishAmount
  }
}</pre></div><p>A possible test <a id="id231" class="indexterm"/>specification <a id="id232" class="indexterm"/>derived from the <code class="literal">MoneyService</code> class is as follows:</p><div class="informalexample"><pre class="programlisting">package se.chap4

import org.scalatest._
import org.junit.runner.RunWith
import org.scalatest.junit.JUnitRunner

@RunWith(classOf[JUnitRunner])
class MoneyServiceTest extends FlatSpec with Matchers {

"Sending money to Sweden" should "convert into SEK" in {
    val moneyService = 
      new MoneyService(new ECBConverter)
    val amount = 200
    val from = "EUR"
    val result = moneyService.sendMoneyToSweden(amount, from)
    result.toInt should (be &gt; (1700) and be &lt;= (1800))
  }

"Sending money to Sweden via England" should "convert into GBP then SEK" in {
    val moneyService = 
      new MoneyService(new ECBConverter)
    val amount = 200
    val from = "EUR"
    val result = moneyService.sendMoneyToSwedenViaEngland(amount, from)
    result.toInt should (be &gt; (1700) and be &lt;= (1800))
  }
}</pre></div><p>To be able to instantiate the <code class="literal">Converter</code> trait, we use an <code class="literal">ECBConverter</code> class defined in the <code class="literal">Converter.scala</code> file as follows:</p><div class="informalexample"><pre class="programlisting">class ECBConverter extends Converter</pre></div><p>If we execute the test from the SBT command prompt or directly within Eclipse (as a JUnit), we get the following output:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>&gt; test</strong></span>
<span class="strong"><strong>[info] Compiling 1 Scala source to /Users/thomas/projects/internal/HttpSamples/target/scala-2.10/test-classes...</strong></span>
<span class="strong"><strong> 1792.2600 SEK are on their way...</strong></span>
<span class="strong"><strong> 167.70000 GBP are on their way...</strong></span>
<span class="strong"><strong> 1792.2600 SEK are on their way...</strong></span>
<span class="strong"><strong>[info] MoneyServiceTest:</strong></span>
<span class="strong"><strong>[info] Sending money to Sweden</strong></span>
<span class="strong"><strong>[info] - should convert into SEK</strong></span>
<span class="strong"><strong>[info] Sending money to Sweden via England</strong></span>
<span class="strong"><strong>[info] - should convert into GBP then SEK</strong></span>
<span class="strong"><strong>[info] Passed: : Total 2, Failed 0, Errors 0, Passed 2, Skipped 0</strong></span>
<span class="strong"><strong>[success] Total time: 1 s, completed</strong></span>
</pre></div><p>If the URL from which we are <a id="id233" class="indexterm"/>retrieving the currency rates is not always available, or if the currency rates have changed a lot on one particular day and the resulting amount of the conversion is not in the given interval of the assertion <code class="literal">should (be &gt; (1700) and be &lt;= (1800))</code>, then our test <a id="id234" class="indexterm"/>might fail. In that case, mocking the converter in our test seems appropriate, and can be done as follows:</p><div class="informalexample"><pre class="programlisting">package se.chap4

import org.scalatest._
import org.junit.runner.RunWith
import org.scalatest.junit.JUnitRunner
import org.scalamock.scalatest.MockFactory

@RunWith(classOf[JUnitRunner])
class MockMoneyServiceTest extends FlatSpec with MockFactory with Matchers {

"Sending money to Sweden" should "convert into SEK" in {

    val converter = mock[Converter]
    val moneyService = new MoneyService(converter)

    (converter.convert _).expects(BigDecimal("200"),"EUR","SEK").returning(BigDecimal(1750))

    val amount = 200
    val from = "EUR"
    val result = moneyService.sendMoneyToSweden(amount, from)
    result.toInt should be (1750)
  }
}</pre></div><p>The <code class="literal">expects</code> method <a id="id235" class="indexterm"/>contains the arguments that we expect when our code should invoke the <code class="literal">convert</code> method, and the returning method contains our expected output in place of the real return result.</p><p>ScalaMock has many variations on how <a id="id236" class="indexterm"/>to apply the mocking code, and is planning to enhance the mocking syntax using the <span class="strong"><strong>Macros</strong></span> in future releases. In short, <a id="id237" class="indexterm"/>Macros are functions that are called by the <a id="id238" class="indexterm"/>compiler during compilation. It is an experimental feature added in Scala from Version 2.10 that makes it possible for the developer to access the compiler APIs and apply transformations to the <a id="id239" class="indexterm"/>
<span class="strong"><strong>AST</strong></span> (<span class="strong"><strong>Abstract Syntax Tree</strong></span>), that is, the tree representation of a program. Macros are out of the scope of this book, but among other things, they are useful for the Code Generation and DSLs. Their usage will improve the ScalaMock syntax; for instance, you can apply your mock expectations within <code class="literal">inSequence {… }</code> or the <code class="literal">inAnyOrder {… }</code> blocks of code or in nested combinations of these blocks, as illustrated in their documentation, which is available at <a class="ulink" href="http://scalamock.org">scalamock.org</a>. ScalaMock also supports a more Mockito-like style with a <span class="strong"><strong>Record-then-Verify</strong></span> cycle rather than the <span class="strong"><strong>Expectations-First</strong></span> style, which we have been using.</p></div></div></div>
<div class="section" title="Testing with ScalaCheck"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec26"/>Testing with ScalaCheck</h1></div></div></div><p>Having a complete and consistent <a id="id240" class="indexterm"/>test suite that consists of unit, integration, or functional tests is essential in ensuring a good overall quality of your software development. However, sometimes, such a suite is not enough. While testing for example-specific data structures, it often happens that there are too many possible values to test with, which means that there is a very large amount of mocking or production of test data. Automated property-based testing is the aim of ScalaCheck, a Scala library inspired by Haskell that allows generating, more or less randomly, the test data to verify some properties about the code you are testing. This library can be applied to Scala as well as to Java projects.</p><p>To get up and running quickly with ScalaCheck, you can include the appropriate library in the <code class="literal">build.sbt</code> file, as we have often done till now. This is shown as follows:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>resolver += Resolver.sonatypeRepo("releases")</strong></span>

<span class="strong"><strong>libraryDependencies ++= Seq(</strong></span>
<span class="strong"><strong>"org.scalacheck" %% "scalacheck" % "1.11.0" % "test")</strong></span>
</pre></div><p>From the SBT prompt, you may type <code class="literal">reload</code> instead of exiting and relaunching SBT, to get a fresh version of the build file, and then type <code class="literal">update</code> to fetch the new dependency. Once this is done, you may also type <code class="literal">eclipse</code> to update your project with the dependency so that it will be a part of your classpath, and the editor will recognize the ScalaCheck classes.</p><p>Let's first run the <a id="id241" class="indexterm"/>
<code class="literal">StringSpecification</code> test that is proposed by the <span class="strong"><strong>Quick start</strong></span> <a id="id242" class="indexterm"/>page available at <a class="ulink" href="http://www.scalacheck.org">www.scalacheck.org</a>:</p><div class="informalexample"><pre class="programlisting">import org.scalacheck.Properties
import org.scalacheck.Prop.forAll

object StringSpecification extends Properties("String") {

  property("startsWith") = forAll { (a: String, b: String) =&gt;
    (a+b).startsWith(a)
  }

  property("concatenate") = forAll { (a: String, b: String) =&gt;
    (a+b).length &gt; a.length &amp;&amp; (a+b).length &gt; b.length
  }

  property("substring") = forAll { (a: String, b: String, c: String) =&gt;
    (a+b+c).substring(a.length, a.length+b.length) == b
  }

}</pre></div><p>In this code snippet, ScalaCheck produces (randomly) a number of strings and verifies that the properties are correct; the first one is straightforward; it should verify that adding two strings <code class="literal">a</code> and <code class="literal">b</code> should produce a string that starts with <code class="literal">a</code>. It probably sounds obvious that this test will pass, no matter what the values of the strings are, but the second property that verifies the length of the concatenation of the two strings is not always true; feeding both <code class="literal">a</code> and <code class="literal">b</code> with the empty value <code class="literal">""</code> is a counter example that shows that the property is not verified. We can illustrate <a id="id243" class="indexterm"/>that by running the test via SBT as follows:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>&gt; test-only se.chap4.StringSpecification</strong></span>
<span class="strong"><strong>[info] + String.startsWith: OK, passed 100 tests.</strong></span>
<span class="strong"><strong>[info] ! String.concatenate: Falsified after 0 passed tests.</strong></span>
<span class="strong"><strong>[info] &gt; ARG_0: ""</strong></span>
<span class="strong"><strong>[info] &gt; ARG_1: ""</strong></span>
<span class="strong"><strong>[info] + String.substring: OK, passed 100 tests.</strong></span>
<span class="strong"><strong>[error] Failed: : Total 3, Failed 1, Errors 0, Passed 2, Skipped 0</strong></span>
<span class="strong"><strong>[error] Failed tests:</strong></span>
<span class="strong"><strong>[error] 	se.chap4.StringSpecification</strong></span>
<span class="strong"><strong>[error] (test:test-only) sbt.TestsFailedException: Tests unsuccessful</strong></span>
<span class="strong"><strong>[error] Total time: 1 s, completed Nov 19, 2013 4:30:37 PM</strong></span>
<span class="strong"><strong>&gt;</strong></span>
</pre></div><p>ScalaCheck conveniently outputs a counter example, <code class="literal">ARG_0: ""</code> and <code class="literal">ARG_1: ""</code> that makes the test fail.</p><p>We can add a few more tests on more complex objects than just strings. Let's add a new test class named <code class="literal">ConverterSpecification</code> as part of our test suite, to test the <code class="literal">Converter</code> that we have created in the <span class="emphasis"><em>Mocking with ScalaMock</em></span> section:</p><div class="informalexample"><pre class="programlisting">package se.chap4

import org.scalacheck._
import Arbitrary._
import Gen._
import Prop.forAll

object ConverterSpecification extends Properties("Converter") with Converter {

  val currencies = Gen.oneOf("EUR","GBP","SEK","JPY")

  lazy val conversions: Gen[(BigDecimal,String,String)] = for {
    amt &lt;- arbitrary[Int] suchThat {_ &gt;= 0}
    from &lt;- currencies
    to &lt;- currencies
  } yield (amt,from,to)

  property("Conversion to same value") = forAll(currencies) { c:String =&gt;
    val amount = BigDecimal(200)
    val convertedAmount = convert(amount,c,c)
    convertedAmount == amount
  }

  property("Various currencies") = forAll(conversions) { c =&gt;
    val convertedAmount = convert(c._1,c._2,c._3)
    convertedAmount &gt;= 0
  }
}</pre></div><p>If we run the test in SBT, the <a id="id244" class="indexterm"/>following output is displayed:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>&gt; ~test-only se.chap4.ConverterSpecification</strong></span>
<span class="strong"><strong>[info] + Converter.Conversion to same value: OK, passed 100 tests.</strong></span>
<span class="strong"><strong>[info] + Converter.Various currencies: OK, passed 100 tests.</strong></span>
<span class="strong"><strong>[info] Passed: : Total 2, Failed 0, Errors 0, Passed 2, Skipped 0</strong></span>
<span class="strong"><strong>[success] Total time: 1 s, completed Nov 19, 2013 9:40:40 PM</strong></span>
<span class="strong"><strong>1. Waiting for source changes... (press enter to interrupt)</strong></span>
</pre></div><p>In this specification, we added two specific generators; the first one named <code class="literal">currencies</code> is able to generate only a few strings taken from a list of valid currencies that we want to test, as otherwise, a randomly generated string would produce strings that are not part of the <code class="literal">Map</code>. Let's add an invalid item <code class="literal">"DUMMY"</code> to the generated list to verify that the test is failing:</p><div class="informalexample"><pre class="programlisting">val currencies = Gen.oneOf("EUR","GBP","SEK","JPY","DUMMY")</pre></div><p>On saving this, the tests are rerun automatically as we specified the <code class="literal">~</code> sign in front of <code class="literal">test-only</code>. This is shown as follows:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>[info] ! Converter.Conversion to same value: Exception raised on property evaluation.</strong></span>
<span class="strong"><strong>[info] &gt; ARG_0: "DUMMY"</strong></span>
<span class="strong"><strong>[info] &gt; Exception: java.util.NoSuchElementException: key not found: DUMMY</strong></span>
<span class="strong"><strong>[info] ! Converter.Various currencies: Exception raised on property evaluation.</strong></span>
<span class="strong"><strong>[info] &gt; ARG_0: (1,,)</strong></span>
<span class="strong"><strong>[info] &gt; ARG_0_ORIGINAL: (1,DUMMY,SEK)</strong></span>
<span class="strong"><strong>[info] &gt; Exception: java.util.NoSuchElementException: key not found: </strong></span>
<span class="strong"><strong>[error] Error: Total 2, Failed 0, Errors 2, Passed 0, Skipped 0</strong></span>
<span class="strong"><strong>[error] Error during tests:</strong></span>
<span class="strong"><strong>[error] 	se.chap4.ConverterSpecification</strong></span>
<span class="strong"><strong>[error] (test:test-only) sbt.TestsFailedException: Tests unsuccessful</strong></span>
<span class="strong"><strong>[error] Total time: 1 s, completed Nov 19, 2013 9:48:36 PM</strong></span>
<span class="strong"><strong>2. Waiting for source changes... (press enter to interrupt)</strong></span>
</pre></div><p>The second generator named <code class="literal">conversions</code> illustrates the construction of a more complex generator that takes advantage of the power of for comprehensions. In particular, notice the <code class="literal">suchThat {_ &gt;= 0}</code> filter method that makes sure that the arbitrary chosen integer has a positive value. This generator returns a <code class="literal">Tuple3</code> triplet that contains all the necessary values <a id="id245" class="indexterm"/>to test the <code class="literal">Converter.convert</code> <a id="id246" class="indexterm"/>method.</p></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec27"/>Summary</h1></div></div></div><p>In this chapter, we covered some of the major testing frameworks available in Scala, which largely inherit from the rich Java ecosystem. Moreover, by applying property-based testing via ScalaCheck, we explored novel approaches to enhance the testing quality. To further improve the quality of the software, interested readers can look at additional SBT plugins that are listed on the <a class="ulink" href="http://www.scala-sbt.org/">http://www.scala-sbt.org/</a> website, notably <code class="literal">scalastyle-sbt-plugin</code> to check the coding style or the various code-coverage plugins. In the next chapter, we are going to dive into the huge area of web development and take advantage of the power of the Scala language to make the development of portals and web apps a productive and fun activity.</p></div></body></html>