<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Combining Observables</h1>
                </header>
            
            <article>
                
<p>We have covered many operators that suppress, transform, reduce, and collect emissions. These operators can do a lot of work, but what about combining multiple Observables and consolidating them into one? If we want to accomplish more with ReactiveX, we need to take multiple streams of data and events and make them work together, and there are operators and factories to achieve this. These combining operators and factories also work safely with Observables occurring on different threads (discussed in <a href="4f59db87-4b1d-47e6-95e3-ae0a43193c5f.xhtml" target="_blank">Chapter 6</a>, <em>Concurrency and Parallelization</em>).</p>
<p>This is where we start to transition from making RxJava useful to making it powerful. We will cover the following operations to combine Observables:</p>
<ul>
<li>Merging</li>
<li>Concatenating</li>
<li>Ambiguous</li>
<li>Zipping</li>
<li>Combine latest</li>
<li>Grouping</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Merging</h1>
                </header>
            
            <article>
                
<p>A common task done in ReactiveX is taking two or more <kbd>Observable&lt;T&gt;</kbd> instances and merging them into one <kbd>Observable&lt;T&gt;</kbd>. This merged <kbd>Observable&lt;T&gt;</kbd> will subscribe to all of its merged sources simultaneously, making it effective for merging both finite and infinite Observables. There are a few ways that we can leverage this merging behavior using factories as well as operators.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Observable.merge() and mergeWith()</h1>
                </header>
            
            <article>
                
<p>The <kbd>Observable.merge()</kbd> operator will take two or more <kbd>Observable&lt;T&gt;</kbd> sources emitting the same type <kbd>T</kbd> and then consolidate them into a single <kbd>Observable&lt;T&gt;</kbd>.</p>
<p>If we have only two to four <kbd>Observable&lt;T&gt;</kbd> sources to merge, you can pass each one as an argument to the <kbd>Observable.merge()</kbd> factory. In the following code snippet, I have merged two <kbd>Observable&lt;String&gt;</kbd> instances into one <kbd>Observable&lt;String&gt;</kbd>:</p>
<pre style="padding-left: 60px"><span>import </span><span>io.reactivex.</span><span>Observable</span><span>;<br/></span><span><br/></span><span>public class </span><span>Launcher </span><span>{<br/></span><span>      </span><span>public static void </span><span>main</span><span>(</span><span>String</span><span>[] </span><span>args</span><span>) {<br/></span><span><br/></span><span>        </span><span>Observable</span><span>&lt;</span><span>String</span><span>&gt; </span><span>source1 </span><span>=<br/></span><span>          </span><span>Observable</span><span>.</span><span>just</span><span>(</span><span>"Alpha"</span><span>, </span><span>"Beta"</span><span>, </span><span>"Gamma"</span><span>, </span><span>"Delta"</span><span>, <br/></span><span>"Epsilon"</span><span>);<br/></span><span><br/></span><span>        </span><span>Observable</span><span>&lt;</span><span>String</span><span>&gt; </span><span>source2 </span><span>=<br/></span><span>          </span><span>Observable</span><span>.</span><span>just</span><span>(</span><span>"Zeta"</span><span>, </span><span>"Eta"</span><span>, </span><span>"Theta"</span><span>);<br/></span><span><br/></span><span>        </span><span>Observable</span><span>.</span><span>merge</span><span>(</span><span>source1</span><span>, </span><span>source2</span><span>)<br/></span><span>          .</span><span>subscribe</span><span>(</span><span>i </span>-&gt; <span>System</span><span>.</span><span>out</span><span>.</span><span>println</span><span>(</span><span>"RECEIVED: " </span><span>+ </span><span>i</span><span>));<br/></span><span>     }<br/></span><span>}</span></pre>
<p>The output of the preceding program is as follows:</p>
<pre style="padding-left: 30px">    RECEIVED: Alpha<br/>    RECEIVED: Beta<br/>    RECEIVED: Gamma<br/>    RECEIVED: Delta<br/>    RECEIVED: Epsilon<br/>    RECEIVED: Zeta<br/>    RECEIVED: Eta<br/>    RECEIVED: Theta</pre>
<p>Alternatively, you can use <kbd>mergeWith()</kbd>, which is the operator version of <kbd>Observable.merge()</kbd><strong>:</strong></p>
<pre style="padding-left: 30px"><span>    source1</span><span>.</span><span>mergeWith</span><span>(</span><span>source2</span><span>)<br/></span><span>      .</span><span>subscribe</span><span>(</span><span>i </span>-&gt; <span>System</span><span>.</span><span>out</span><span>.</span><span>println</span><span>(</span><span>"RECEIVED: " </span><span>+ </span><span>i</span><span>));</span></pre>
<p>The <kbd>Observable.merge()</kbd> factory and the <kbd>mergeWith()</kbd> operator will subscribe to all the specified sources simultaneously, but will likely fire the emissions in order if they are cold and on the same thread. This is just an implementation detail, and you should use <kbd>Observable.concat()</kbd> if you explicitly want to fire elements of each <kbd>Observable</kbd> sequentially and keep their emissions in a sequential order.</p>
<div class="packt_infobox">You should not rely on ordering when using merge factories and operators even if ordering seems to be preserved. Having said that, the order of emissions from each source Observable is maintained. The way the sources are merged is an implementation detail, so use concatenation factories and operators if you want to guarantee order.</div>
<p>If you have more than four <kbd>Observable&lt;T&gt;</kbd> sources, you can use the <kbd>Observable.mergeArray()</kbd> to pass a varargs of <kbd>Observable[]</kbd> instances that you want to merge, as shown in the following code snippet. Since RxJava 2.0 was written for JDK 6+ and has no access to a <kbd>@SafeVarargs</kbd> annotation, you will likely get some type safety warnings:</p>
<pre style="padding-left: 60px"><span>import</span><span> </span><span>io.reactivex.</span><span>Observable</span><span>;<br/></span><span><br/></span><span>public class </span><span>Launcher </span><span>{<br/></span><span>      </span><span>public static void </span><span>main</span><span>(</span><span>String</span><span>[] </span><span>args</span><span>) {<br/></span><span><br/></span><span>        </span><span>Observable</span><span>&lt;</span><span>String</span><span>&gt; </span><span>source1 </span><span>=<br/></span><span>          </span><span>Observable</span><span>.</span><span>just</span><span>(</span><span>"Alpha"</span><span>, </span><span>"Beta"</span><span>);<br/></span><span><br/></span><span>        </span><span>Observable</span><span>&lt;</span><span>String</span><span>&gt; </span><span>source2 </span><span>=<br/></span><span>          </span><span>Observable</span><span>.</span><span>just</span><span>(</span><span>"Gamma"</span><span>, </span><span>"Delta"</span><span>);<br/></span><span><br/></span><span>        </span><span>Observable</span><span>&lt;</span><span>String</span><span>&gt; </span><span>source3 </span><span>=<br/></span><span>          </span><span>Observable</span><span>.</span><span>just</span><span>(</span><span>"Epsilon"</span><span>, </span><span>"Zeta"</span><span>);<br/></span><span><br/></span><span>        </span><span>Observable</span><span>&lt;</span><span>String</span><span>&gt; </span><span>source4 </span><span>=<br/></span><span>          </span><span>Observable</span><span>.</span><span>just</span><span>(</span><span>"Eta"</span><span>, </span><span>"Theta"</span><span>);<br/></span><span><br/></span><span>        </span><span>Observable</span><span>&lt;</span><span>String</span><span>&gt; </span><span>source5 </span><span>=<br/></span><span>          </span><span>Observable</span><span>.</span><span>just</span><span>(</span><span>"Iota"</span><span>, </span><span>"Kappa"</span><span>);</span><span><br/></span><span><br/></span><span>        </span><span>Observable</span><span>.</span><span>mergeArray</span><span>(</span><span>source1</span><span>, </span><span>source2</span><span>, </span><span>source3</span><span>, </span><span>source4</span><span>, <br/></span><span>source5</span><span>)<br/></span><span>            .</span><span>subscribe</span><span>(</span><span>i </span>-&gt; <span>System</span><span>.</span><span>out</span><span>.</span><span>println</span><span>(</span><span>"RECEIVED: " </span><span>+ </span><span>i</span><span>));<br/></span><span>     }<br/></span><span>}<br/></span></pre>
<p>The output of the preceding code is as follows:</p>
<pre style="padding-left: 30px">    RECEIVED: Alpha<br/>    RECEIVED: Beta<br/>    RECEIVED: Gamma<br/>    RECEIVED: Delta<br/>    RECEIVED: Epsilon<br/>    RECEIVED: Zeta<br/>    RECEIVED: Eta<br/>    RECEIVED: Theta<br/>    RECEIVED: Iota<br/>    RECEIVED: Kappa</pre>
<p>You can pass <kbd>Iterable&lt;Observable&lt;T&gt;&gt;</kbd> to <kbd>Observable.merge()</kbd> as well. It will merge all the <kbd>Observable&lt;T&gt;</kbd> instances in that <kbd>Iterable</kbd>. I could achieve the preceding example in a more type-safe way by putting all these sources in <kbd>List&lt;Observable&lt;T&gt;&gt;</kbd> and passing them to <kbd>Observable.merge()</kbd>:</p>
<pre style="padding-left: 60px"><span>import </span><span>io.reactivex.</span><span>Observable</span><span>;<br/></span><span>import </span><span>java.util.Arrays</span><span>;<br/></span><span>import </span><span>java.util.</span><span>List</span><span>;<br/></span><span><br/></span><span>public class </span><span>Launcher </span><span>{<br/></span><span>      </span><span>public static void </span><span>main</span><span>(</span><span>String</span><span>[] </span><span>args</span><span>) {<br/></span><span><br/></span><span>        </span><span>Observable</span><span>&lt;</span><span>String</span><span>&gt; </span><span>source1 </span><span>=<br/></span><span>          </span><span>Observable</span><span>.</span><span>just</span><span>(</span><span>"Alpha"</span><span>, </span><span>"Beta"</span><span>);<br/></span><span><br/></span><span>        </span><span>Observable</span><span>&lt;</span><span>String</span><span>&gt; </span><span>source2 </span><span>=<br/></span><span>          </span><span>Observable</span><span>.</span><span>just</span><span>(</span><span>"Gamma"</span><span>, </span><span>"Delta"</span><span>);<br/></span><span><br/></span><span>        </span><span>Observable</span><span>&lt;</span><span>String</span><span>&gt; </span><span>source3 </span><span>=<br/></span><span>          </span><span>Observable</span><span>.</span><span>just</span><span>(</span><span>"Epsilon"</span><span>, </span><span>"Zeta"</span><span>);<br/></span><span><br/></span><span>        </span><span>Observable</span><span>&lt;</span><span>String</span><span>&gt; </span><span>source4 </span><span>=<br/></span><span>          </span><span>Observable</span><span>.</span><span>just</span><span>(</span><span>"Eta"</span><span>, </span><span>"Theta"</span><span>);<br/></span><span><br/></span><span>        </span><span>Observable</span><span>&lt;</span><span>String</span><span>&gt; </span><span>source5 </span><span>=<br/></span><span>          </span><span>Observable</span><span>.</span><span>just</span><span>(</span><span>"Iota"</span><span>, </span><span>"Kappa"</span><span>);<br/></span><span><br/></span><span>        </span><span>List</span><span>&lt;</span><span>Observable</span><span>&lt;</span><span>String</span><span>&gt;&gt; </span><span>sources </span><span>=<br/></span><span>          </span><span>Arrays</span><span>.</span><span>asList</span><span>(</span><span>source1</span><span>, </span><span>source2</span><span>, </span><span>source3</span><span>, </span><span>source4</span><span>, </span><span>source5</span><span>);<br/></span><span><br/></span><span>        </span><span>Observable</span><span>.</span><span>merge</span><span>(</span><span>sources</span><span>)<br/></span><span>          .</span><span>subscribe</span><span>(</span><span>i </span>-&gt; <span>System</span><span>.</span><span>out</span><span>.</span><span>println</span><span>(</span><span>"RECEIVED: " </span><span>+ </span><span>i</span><span>));<br/></span><span>      }<br/></span><span>}<br/></span></pre>
<div class="packt_infobox">The reason <kbd>mergeArray()</kbd> gets its own method and is not a <kbd>merge()</kbd> overload instead is to avoid ambiguity with the Java 8 compiler and its treatment with functional types. This is true for all the <kbd>xxxArray()</kbd> operators.</div>
<p>The <kbd>Observable.merge()</kbd> works with infinite Observables. Since it will subscribe to all Observables and fire their emissions as soon as they are available, you can merge multiple infinite sources into a single stream. Here, we merge two <kbd>Observable.interval()</kbd> sources that emit at one second and 300 millisecond intervals, respectively. But before we merge, we do some math with the emitted index to figure out how much time has elapsed and emit it with the source name in a string. We let this process run for three seconds:</p>
<pre style="padding-left: 60px"><span>import</span><span> </span><span>io.reactivex.</span><span>Observable</span><span>;<br/></span><span>import </span><span>java.util.concurrent.</span><span>TimeUnit</span><span>;<br/></span><span><br/></span><span>public class </span><span>Launcher </span><span>{<br/></span><span>      </span><span>public static void </span><span>main</span><span>(</span><span>String</span><span>[] </span><span>args</span><span>) {<br/></span><span><br/></span><span>        </span><span>//emit every second<br/></span><span>        </span><span>Observable</span><span>&lt;</span><span>String</span><span>&gt; </span><span>source1 </span><span>= </span><span>Observable</span><span>.</span><span>interval</span><span>(</span><span>1</span><span>, <br/></span><span>TimeUnit</span><span>.</span><span>SECONDS</span><span>)<br/></span><span>        .</span><span>map</span><span>(</span><span>l </span>-&gt; <span>l </span><span>+ </span><span>1</span><span>) </span><span>// emit elapsed seconds<br/></span><span>        </span><span>.</span><span>map</span><span>(</span><span>l </span>-&gt; <span>"Source1: " </span><span>+ </span><span>l </span><span>+ </span><span>" seconds"</span><span>);<br/></span><span><br/></span><span>        </span><span>//emit every 300 milliseconds<br/></span><span>        </span><span>Observable</span><span>&lt;</span><span>String</span><span>&gt; </span><span>source2 </span><span>=<br/></span><span>          </span><span>Observable</span><span>.</span><span>interval</span><span>(</span><span>300</span><span>, </span><span>TimeUnit</span><span>.</span><span>MILLISECONDS</span><span>)<br/></span><span>        .</span><span>map</span><span>(</span><span>l </span>-&gt; <span>(</span><span>l </span><span>+ </span><span>1</span><span>) </span><span>* </span><span>300</span><span>) </span><span>// emit elapsed milliseconds<br/></span><span>        </span><span>.</span><span>map</span><span>(</span><span>l </span>-&gt; <span>"Source2: " </span><span>+ </span><span>l </span><span>+ </span><span>" milliseconds"</span><span>);<br/><br/>        //merge and subscribe</span><span><br/></span><span>        </span><span>Observable</span><span>.</span><span>merge</span><span>(</span><span>source1</span><span>, </span><span>source2</span><span>)<br/></span><span>.</span><span>subscribe</span><span>(</span><span>System</span><span>.</span><span>out</span>::<span>println</span><span>);<br/>        //keep alive for 3 seconds</span><span><br/></span><span>        </span><span>sleep</span><span>(</span><span>3000</span><span>);<br/></span><span>     }<br/></span><span><br/></span><span>     </span><span>public static void </span><span>sleep</span><span>(</span><span>long </span><span>millis</span><span>) {<br/></span><span>       </span><span>try </span><span>{<br/></span><span>         </span><span>Thread</span><span>.</span><span>sleep</span><span>(</span><span>millis</span><span>);<br/></span><span>       } </span><span>catch </span><span>(</span><span>InterruptedException </span><span>e</span><span>) {<br/></span><span>         </span><span>e</span><span>.</span><span>printStackTrace</span><span>();<br/></span><span>       }<br/></span><span>     }<br/></span><span>}</span></pre>
<p>The output of the preceding code is as follows:</p>
<pre style="padding-left: 30px">    Source2: 300 milliseconds<br/>    Source2: 600 milliseconds<br/>    Source2: 900 milliseconds<br/>    Source1: 1 seconds<br/>    Source2: 1200 milliseconds<br/>    Source2: 1500 milliseconds<br/>    Source2: 1800 milliseconds<br/>    Source1: 2 seconds<br/>    Source2: 2100 milliseconds<br/>    Source2: 2400 milliseconds<br/>    Source2: 2700 milliseconds<br/>    Source1: 3 seconds<br/>    Source2: 3000 milliseconds</pre>
<p>To summarize, <kbd>Observable.merge()</kbd> will combine multiple <kbd>Observable&lt;T&gt;</kbd> sources emitting the same type <kbd>T</kbd> and consolidate into a single <kbd>Observable&lt;T&gt;</kbd>. It works on infinite Observables and does not necessarily guarantee that the emissions come in any order. If you care about the emissions being strictly ordered by having each <kbd>Observable</kbd> source fired sequentially, you will likely want to use <kbd>Observable.concat()</kbd>, which we will cover shortly.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">flatMap()</h1>
                </header>
            
            <article>
                
<p>One of the most powerful and critical operators in RxJava is <kbd>flatMap()</kbd>. If you have to invest time in understanding any RxJava operator, this is the one. It is an operator that performs a dynamic <kbd>Observable.merge()</kbd> by taking each emission and mapping it to an <kbd>Observable</kbd>. Then, it merges the emissions from the resulting Observables into a single stream.</p>
<p>The simplest application of <kbd>flatMap()</kbd> is to map <em>one emission to many emissions</em>. Say, we want to emit the characters from each string coming from <kbd>Observable&lt;String&gt;</kbd><strong>.</strong> We can use <kbd>flatMap()</kbd> to specify a <kbd>Function&lt;T,Observable&lt;R&gt;&gt;</kbd> lambda that maps each string to an <kbd>Observable&lt;String&gt;</kbd><strong>, </strong>which will emit the letters. Note that the mapped <kbd>Observable&lt;R&gt;</kbd> can emit any type <kbd>R</kbd>, different from the source <kbd>T</kbd> emissions.  In this example, it just happened to be <kbd>String</kbd>, like the source:</p>
<pre style="padding-left: 60px"><span>import </span><span>io.reactivex.</span><span>Observable</span><span>;<br/></span><span><br/></span><span>public class </span><span>Launcher </span><span>{<br/></span><span>      </span><span>public static void </span><span>main</span><span>(</span><span>String</span><span>[] </span><span>args</span><span>) {<br/></span><span><br/></span><span>        </span><span>Observable</span><span>&lt;</span><span>String</span><span>&gt; </span><span>source </span><span>=<br/></span><span>          </span><span>Observable</span><span>.</span><span>just</span><span>(</span><span>"Alpha"</span><span>, </span><span>"Beta"</span><span>, </span><span>"Gamma"</span><span>, </span><span>"Delta"</span><span>, <br/></span><span>"Epsilon"</span><span>);<br/></span><span><br/></span><span>        </span><span>source</span><span>.</span><span>flatMap</span><span>(</span><span>s </span>-&gt; <span>Observable</span><span>.</span><span>fromArray</span><span>(</span><span>s</span><span>.</span><span>split</span><span>(</span><span>""</span><span>)))<br/></span><span>          .</span><span>subscribe</span><span>(</span><span>System</span><span>.</span><span>out</span>::<span>println</span><span>);<br/></span><span>      }<br/></span><span>}</span></pre>
<p>The output of the preceding code is as follows:</p>
<pre style="padding-left: 30px">    A<br/>    l<br/>    p<br/>    h<br/>    a<br/>    B<br/>    e<br/>    t<br/>    a<br/>    G<br/>    a<br/>    m<br/>    m<br/>    ...</pre>
<p>We have taken those five string emissions and mapped them (through <kbd>flatMap()</kbd>) to emit the letters from each one. We did this by calling each string's <kbd>split()</kbd> method, and we passed it an empty <kbd>String</kbd> argument <kbd>""</kbd>, which will separate on every character. This returns an array <kbd>String[]</kbd><span> </span>containing all the characters, which we pass to <kbd>Observable.fromArray()</kbd> to emit each one. The <kbd>flatMap()</kbd> expects each emission to yield an <kbd>Observable</kbd>, and it will merge all the resulting Observables and emit their values in a single stream.</p>
<p>Here is another example: let's take a sequence of <kbd>String</kbd> values (each a concatenated series of values separated by <kbd>"/"</kbd>), use  <kbd>flatMap()</kbd> on them, and filter for only numeric values before converting them into <kbd>Integer</kbd> emissions:</p>
<pre style="padding-left: 60px"><span>import </span><span>io.reactivex.</span><span>Observable</span><span>;<br/></span><span><br/></span><span>public class </span><span>Launcher </span><span>{<br/></span><span>      </span><span>public static void </span><span>main</span><span>(</span><span>String</span><span>[] </span><span>args</span><span>) {<br/></span><span><br/></span><span>        </span><span>Observable</span><span>&lt;</span><span>String</span><span>&gt; </span><span>source </span><span>=<br/></span><span>          </span><span>Observable</span><span>.</span><span>just</span><span>(</span><span>"521934/2342/FOXTROT"</span><span>, </span><span>"21962/12112/78886<br/>            /TANGO"</span><span>,<br/></span><span>"283242/4542/WHISKEY/2348562"</span><span>);<br/></span><span><br/></span><span>        </span><span>source</span><span>.</span><span>flatMap</span><span>(</span><span>s </span>-&gt; <span>Observable</span><span>.</span><span>fromArray</span><span>(</span><span>s</span><span>.</span><span>split</span><span>(</span><span>"/"</span><span>)))<br/></span><span>          .</span><span>filter</span><span>(</span><span>s </span>-&gt; <span>s</span><span>.</span><span>matches</span><span>(</span><span>"[0-9]+"</span><span>)) //use regex to filter <br/>            integers<br/></span><span>          .</span><span>map</span><span>(</span><span>Integer</span>::<span>valueOf</span><span>)<br/></span><span>          .</span><span>subscribe</span><span>(</span><span>System</span><span>.</span><span>out</span>::<span>println</span><span>);<br/></span><span>      }<br/></span><span>}</span></pre>
<p>The output of the preceding code is as follows:</p>
<pre style="padding-left: 30px">    521934<br/>    2342<br/>    21962<br/>    12112<br/>    78886<br/>    283242<br/>    4542<br/>    2348562</pre>
<p>We broke up each <kbd>String<strong> </strong></kbd> by the <kbd>/</kbd> character, which yielded an array. We turned that into an <kbd>Observable</kbd> and used <kbd>flatMap()</kbd> on it to emit each <kbd>String</kbd>. We filtered only for String values that are numeric using a regular expression <kbd>[0-9]+</kbd> (eliminating <kbd>FOXTROT</kbd>, <kbd>TANGO</kbd>, and <kbd>WHISKEY</kbd>) and then turned each emission into an <strong><kbd>Integer</kbd>.</strong></p>
<p>Just like <kbd>Observable.merge()</kbd>, you can also map emissions to infinite <kbd>Observables</kbd> and merge them. For instance, we can emit simple <kbd>Integer</kbd> values from <kbd>Observable&lt;Integer&gt;</kbd> but use <kbd>flatMap()</kbd> on them to drive an <kbd>Observable.interval()</kbd>, where each one serves as the period argument. In the following code snippet, we emit the values <kbd>2</kbd>, <kbd>3</kbd>, <kbd>10</kbd>, and <kbd>7</kbd>, which will yield interval Observables that emit at 2 seconds, 3 seconds, 10 seconds, and 7 seconds, respectively. These four Observables will be merged into a single stream:</p>
<pre style="padding-left: 60px"><span>import</span><span> </span><span>io.reactivex.</span><span>Observable</span><span>;<br/></span><span>import </span><span>java.util.concurrent.</span><span>TimeUnit</span><span>;<br/></span><span><br/></span><span>public class </span><span>Launcher </span><span>{<br/></span><span>      </span><span>public static void </span><span>main</span><span>(</span><span>String</span><span>[] </span><span>args</span><span>) {<br/></span><span><br/></span><span>        </span><span>Observable</span><span>&lt;</span><span>Integer</span><span>&gt; </span><span>intervalArguments </span><span>=<br/></span><span>          </span><span>Observable</span><span>.</span><span>just</span><span>(</span><span>2</span><span>, </span><span>3</span><span>, </span><span>10</span><span>, </span><span>7</span><span>);<br/></span><span><br/></span><span>        </span><span>intervalArguments</span><span>.</span><span>flatMap</span><span>(</span><span>i </span>-&gt;<br/><span>Observable</span><span>.</span><span>interval</span><span>(</span><span>i</span><span>, </span><span>TimeUnit</span><span>.</span><span>SECONDS</span><span>)<br/></span><span>            .</span><span>map</span><span>(i2</span><span> </span>-&gt; <span>i </span><span>+ </span><span>"s interval: " </span><span>+ </span><span>((i</span><span> </span><span>+ </span><span>1</span><span>) </span><span>* </span><span>i</span><span>) </span><span>+ </span><span>" seconds <br/>              elapsed"</span><span>)<br/></span><span>          ).</span><span>subscribe</span><span>(</span><span>System</span><span>.</span><span>out</span>::<span>println</span><span>);<br/></span><span><br/></span><span>          </span><span>sleep</span><span>(</span><span>12000</span><span>);<br/></span><span>      }<br/></span><span>      </span><span>public static void </span><span>sleep</span><span>(</span><span>long </span><span>millis</span><span>) {<br/></span><span>        </span><span>try </span><span>{<br/></span><span>          </span><span>Thread</span><span>.</span><span>sleep</span><span>(</span><span>millis</span><span>);<br/></span><span>        } </span><span>catch </span><span>(</span><span>InterruptedException </span><span>e</span><span>) {<br/></span><span>          </span><span>e</span><span>.</span><span>printStackTrace</span><span>();<br/></span><span>        }<br/></span><span>      }<br/></span><span>}</span></pre>
<p>The output of the preceding code is as follows:</p>
<pre style="padding-left: 30px">    2s interval: 2 seconds elapsed<br/>    3s interval: 3 seconds elapsed<br/>    2s interval: 4 seconds elapsed<br/>    2s interval: 6 seconds elapsed<br/>    3s interval: 6 seconds elapsed<br/>    7s interval: 7 seconds elapsed<br/>    2s interval: 8 seconds elapsed<br/>    3s interval: 9 seconds elapsed<br/>    2s interval: 10 seconds elapsed<br/>    10s interval: 10 seconds elapsed<br/>    2s interval: 12 seconds elapsed<br/>    3s interval: 12 seconds elapsed</pre>
<p>The <kbd>Observable.merge()</kbd> operator will accept a fixed number of <kbd>Observable</kbd> sources. But <kbd>flatMap()</kbd> will dynamically keep adding new <kbd>Observable</kbd> sources for each emission that comes in. This means that you can keep merging new incoming Observables over time.</p>
<p>Another quick note about <kbd>flatMap()</kbd> is it can be used in many clever ways. To this day, I keep finding new ways to use it. But another way you can get creative is to evaluate each emission within <kbd>flatMap()</kbd> and figure out what kind of <kbd>Observable</kbd> you want to return. For example, if my previous example emitted an emission of <kbd>0</kbd> to <kbd>flatMap()</kbd>, this will break the resulting <kbd>Observable.interval()</kbd>. But I can use an <kbd>if</kbd> statement to check whether it is <kbd>0</kbd> and return <kbd>Observable.empty()</kbd> instead, as used in the following code snippet:</p>
<pre style="padding-left: 60px"><span>Observable</span><span>&lt;</span><span>Integer</span><span>&gt; </span><span>secondIntervals </span><span>=<br/></span><span>Observable</span><span>.</span><span>just</span><span>(</span><span>2</span><span>, </span><span>0</span><span>, </span><span>3</span><span>, </span><span>10</span><span>, </span><span>7</span><span>);<br/></span><span><br/></span><span>secondIntervals</span><span>.</span><span>flatMap</span><span>(</span><span>i </span>-&gt; <span>{<br/></span><span>if </span><span>(</span><span>i </span><span>== </span><span>0</span><span>)<br/></span><span>return </span><span>Observable</span><span>.</span><span>empty</span><span>();<br/></span><span>else<br/></span><span>return </span><span>Observable</span><span>.</span><span>interval</span><span>(</span><span>i</span><span>, </span><span>TimeUnit</span><span>.</span><span>SECONDS</span><span>)<br/></span><span>.</span><span>map</span><span>(</span><span>l </span>-&gt; <span>i </span><span>+ </span><span>"s interval: " </span><span>+ </span><span>((</span><span>l </span><span>+ </span><span>1</span><span>) </span><span>* </span><span>i</span><span>) </span><span>+ </span><span>" seconds <br/>elapsed"</span><span>);<br/></span><span>}).</span><span>subscribe</span><span>(</span><span>System</span><span>.</span><span>out</span>::<span>println</span><span>);</span></pre>
<p>Of course, this is probably too clever as you can just put <kbd>filter()</kbd> before <kbd>flatMap()</kbd> and filter out emissions that are equal to <kbd>0</kbd>. But the point is that you can evaluate an emission in <kbd>flatMap()</kbd> and determine what kind of <kbd>Observable</kbd> you want to return.</p>
<div class="packt_infobox">
<p>The <kbd>flatMap()</kbd> is also a great way to take a hot Observable UI event stream (such as JavaFX or Android button clicks) and <kbd>flatMap()</kbd> each of those events to an entire process within <kbd>flatMap()</kbd>. The failure and error recovery can be handled entirely within that <kbd>flatMap()</kbd>, so each instance of the process does not disrupt future button clicks.</p>
<p>If you do not want rapid button clicks to produce several redundant instances of a process, you can disable the button using <kbd>doOnNext()</kbd> or leverage <kbd>switchMap()</kbd> to kill previous processes, which we will discuss in <a href="4f59db87-4b1d-47e6-95e3-ae0a43193c5f.xhtml" target="_blank">Chapter 7</a>, <em>Switching, Throttling, Windowing, and Buffering.<br/></em></p>
</div>
<p>Note that there are many flavors and variants of <kbd>flatMap()</kbd>, accepting a number of overloads that we will not get into deeply for the sake of brevity. We can pass a second combiner argument, which is a <kbd>BiFunction&lt;T,U,R&gt;</kbd> lambda, to associate the originally emitted <kbd>T</kbd> value with each flat-mapped <kbd>U</kbd> value and turn both into an <kbd>R</kbd> value. In our earlier example of emitting letters from each string, we can associate each letter with the original string emission it was mapped from:</p>
<pre style="padding-left: 60px"><span>import</span><span> </span><span>io.reactivex.</span><span>Observable</span><span>;<br/></span><span><br/></span><span>public class </span><span>Launcher </span><span>{<br/></span><span>      </span><span>public static void </span><span>main</span><span>(</span><span>String</span><span>[] </span><span>args</span><span>) {<br/></span><span>        </span><span>Observable</span><span>&lt;</span><span>String</span><span>&gt; </span><span>source </span><span>=<br/></span><span>          </span><span>Observable</span><span>.</span><span>just</span><span>(</span><span>"Alpha"</span><span>, </span><span>"Beta"</span><span>, </span><span>"Gamma"</span><span>, </span><span>"Delta"</span><span>, <br/></span><span>"Epsilon"</span><span>);<br/></span><span><br/></span><span>        </span><span>source</span><span>.</span><span>flatMap</span><span>(</span><span>s </span>-&gt; <span>Observable</span><span>.</span><span>fromArray</span><span>(</span><span>s</span><span>.</span><span>split</span><span>(</span><span>""</span><span>)), (</span><span>s</span><span>,</span><span>r</span><span>) </span>-&gt; <br/><span>s </span><span>+ </span><span>"-" </span><span>+ </span><span>r</span><span>)<br/></span><span>            .</span><span>subscribe</span><span>(</span><span>System</span><span>.</span><span>out</span>::<span>println</span><span>);<br/></span><span>      }<br/></span><span>}</span></pre>
<p>The output of the preceding code is as follows:</p>
<pre style="padding-left: 30px">    Alpha-A<br/>    Alpha-l<br/>    Alpha-p<br/>    Alpha-h<br/>    Alpha-a<br/>    Beta-B<br/>    Beta-e<br/>    Beta-t<br/>    Beta-a<br/>    Gamma-G<br/>    ...<br/><br/></pre>
<p>We can also use <kbd>flatMapIterable()</kbd> to map each <kbd>T</kbd> emission into an <kbd>Iterable&lt;R&gt;</kbd> instead of an <kbd>Observable&lt;R&gt;</kbd>. It will then emit all the <kbd>R</kbd> values for each <kbd>Iterable&lt;R&gt;</kbd>, saving us the step and overhead of converting it into an <kbd>Observable</kbd>. There are also <kbd>flatMap()</kbd> variants that map to Singles <kbd>(flatMapSingle())</kbd>, Maybes <strong><kbd>(flatMapMaybe())</kbd></strong>, and Completables <kbd>(flatMapCompletable())</kbd>. A lot of these overloads also apply to <kbd>concatMap()</kbd>, which we will cover next.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Concatenation</h1>
                </header>
            
            <article>
                
<p>Concatenation is remarkably similar to merging, but with an important nuance: it will fire elements of each provided <kbd>Observable</kbd> sequentially and in the order specified. It will not move on to the next <kbd>Observable</kbd> until the current one calls <kbd>onComplete()</kbd>. This makes it great to ensure that merged Observables fire their emissions in a guaranteed order. However, it is often a poor choice for infinite Observables, as an infinite <kbd>Observable</kbd> will indefinitely hold up the queue and forever leave subsequent Observables waiting.</p>
<p>We will cover the factories and operators used for concatenation. You will find that they are much like the merging ones except that they have the sequential behavior.</p>
<div class="packt_tip">You should prefer concatenation when you want to guarantee that Observables fire their emissions in order. If you do not care about ordering, prefer merging instead.</div>
<p> </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Observable.concat() and concatWith()</h1>
                </header>
            
            <article>
                
<p>The <kbd>Observable.concat()</kbd> factory is the concatenation equivalent to <kbd>Observable.merge()</kbd>. It will combine the emissions of multiple Observables, but will fire each one sequentially and only move to the next after <kbd>onComplete()</kbd> is called.</p>
<p>In the following code, we have two source Observables emitting strings. We can use <kbd>Observable.concat()</kbd> to fire the emissions from the first one and then fire the emissions from the second one:</p>
<pre style="padding-left: 60px"><span>import </span><span>io.reactivex.</span><span>Observable</span><span>;<br/></span><span><br/></span><span>public class </span><span>Launcher </span><span>{<br/></span><span>      </span><span>public static void </span><span>main</span><span>(</span><span>String</span><span>[] </span><span>args</span><span>) {<br/></span><span><br/></span><span>        </span><span>Observable</span><span>&lt;</span><span>String</span><span>&gt; </span><span>source1 </span><span>=<br/></span><span>          </span><span>Observable</span><span>.</span><span>just</span><span>(</span><span>"Alpha"</span><span>, </span><span>"Beta"</span><span>, </span><span>"Gamma"</span><span>, </span><span>"Delta"</span><span>, <br/></span><span>"Epsilon"</span><span>);<br/></span><span><br/></span><span>        </span><span>Observable</span><span>&lt;</span><span>String</span><span>&gt; </span><span>source2 </span><span>=<br/></span><span>          </span><span>Observable</span><span>.</span><span>just</span><span>(</span><span>"Zeta"</span><span>, </span><span>"Eta"</span><span>, </span><span>"Theta"</span><span>);<br/></span><span><br/></span><span>        </span><span>Observable</span><span>.</span><span>concat</span><span>(</span><span>source1</span><span>, </span><span>source2</span><span>)<br/></span><span>          .</span><span>subscribe</span><span>(</span><span>i </span>-&gt; <span>System</span><span>.</span><span>out</span><span>.</span><span>println</span><span>(</span><span>"RECEIVED: " </span><span>+ </span><span>i</span><span>));<br/></span><span>      }<br/></span><span>}</span></pre>
<p>The output of the preceding code is as follows:</p>
<pre style="padding-left: 30px">    RECEIVED: Alpha<br/>    RECEIVED: Beta<br/>    RECEIVED: Gamma<br/>    RECEIVED: Delta<br/>    RECEIVED: Epsilon<br/>    RECEIVED: Zeta<br/>    RECEIVED: Eta<br/>    RECEIVED: Theta</pre>
<p>This is the same output as our <kbd>Observable.merge()</kbd> example earlier. But as discussed in the merging section, we should use <kbd>Observable.concat()</kbd> to guarantee emission ordering, as merging does not guarantee it. You can also use the <kbd>concatWith()</kbd> operator to accomplish the same thing, as shown in the following code line:</p>
<pre><span>    </span><span>source1.concatWith(source2)</span><span><br/></span><span>      .</span><span>subscribe</span><span>(</span><span>i </span>-&gt; <span>System</span><span>.</span><span>out</span><span>.</span><span>println</span><span>(</span><span>"RECEIVED: " </span><span>+ </span><span>i</span><span>));</span></pre>
<p>If we use <kbd>Observable.concat()</kbd> with infinite Observables, it will forever emit from the first one it encounters and prevent any following Observables from firing. If we ever want to put an infinite <kbd>Observable</kbd> anywhere in a concatenation operation, it would likely be specified last. This ensures that it does not hold up any Observables following it because there are none. We can also use <kbd>take()</kbd> operators to make infinite Observables finite. </p>
<p>Here, we fire an <kbd>Observable</kbd> that emits every second, but only take two emissions from it. After that, it will call <kbd>onComplete()</kbd> and dispose it. Then, a second <kbd>Observable</kbd> concatenated after it will emit forever (or in this case, when the application quits after five seconds). Since this second <kbd>Observable</kbd>  is the last one specified in <kbd>Observable.concat()</kbd>, it will not hold up any subsequent Observables by being infinite:</p>
<pre style="padding-left: 60px"><span>import </span><span>io.reactivex.</span><span>Observable</span><span>;<br/></span><span>import </span><span>java.util.concurrent.</span><span>TimeUnit</span><span>;<br/></span><span><br/></span><span>public class </span><span>Launcher </span><span>{<br/></span><span>    </span><span>public static void </span><span>main</span><span>(</span><span>String</span><span>[] </span><span>args</span><span>) {<br/></span><span><br/></span><span>        </span><span>//emit every second, but only take 2 emissions<br/></span><span>        </span><span>Observable</span><span>&lt;</span><span>String</span><span>&gt; </span><span>source1 </span><span>=<br/></span><span>          </span><span>Observable</span><span>.</span><span>interval</span><span>(</span><span>1</span><span>, </span><span>TimeUnit</span><span>.</span><span>SECONDS</span><span>)<br/></span><span>            .</span><span>take</span><span>(</span><span>2</span><span>)<br/></span><span>            .</span><span>map</span><span>(</span><span>l </span>-&gt; <span>l </span><span>+ </span><span>1</span><span>) </span><span>// emit elapsed seconds<br/></span><span>            </span><span>.</span><span>map</span><span>(</span><span>l </span>-&gt; <span>"Source1: " </span><span>+ </span><span>l </span><span>+ </span><span>" seconds"</span><span>);</span><span><br/></span><span><br/></span><span>          </span><span>//emit every 300 milliseconds<br/></span><span>          </span><span>Observable</span><span>&lt;</span><span>String</span><span>&gt; </span><span>source2 </span><span>=<br/></span><span>            </span><span>Observable</span><span>.</span><span>interval</span><span>(</span><span>300</span><span>, </span><span>TimeUnit</span><span>.</span><span>MILLISECONDS</span><span>)<br/></span><span>              .</span><span>map</span><span>(</span><span>l </span>-&gt; <span>(</span><span>l </span><span>+ </span><span>1</span><span>) </span><span>* </span><span>300</span><span>) </span><span>// emit elapsed milliseconds<br/></span><span>              </span><span>.</span><span>map</span><span>(</span><span>l </span>-&gt; <span>"Source2: " </span><span>+ </span><span>l </span><span>+ </span><span>" milliseconds"</span><span>);<br/></span><span><br/></span><span>          </span><span>Observable</span><span>.</span><span>concat</span><span>(</span><span>source1</span><span>, </span><span>source2</span><span>)<br/></span><span>            .</span><span>subscribe</span><span>(</span><span>i </span>-&gt; <span>System</span><span>.</span><span>out</span><span>.</span><span>println</span><span>(</span><span>"RECEIVED: " </span><span>+ </span><span>i</span><span>));<br/></span><span><br/></span><span>          </span><span>//keep application alive for 5 seconds<br/></span><span>          </span><span>sleep</span><span>(</span><span>5000</span><span>);<br/></span><span>    }<br/></span><span><br/></span><span>    </span><span>public static void </span><span>sleep</span><span>(</span><span>long </span><span>millis</span><span>) {<br/></span><span>      </span><span>try </span><span>{<br/></span><span>        </span><span>Thread</span><span>.</span><span>sleep</span><span>(</span><span>millis</span><span>);<br/></span><span>      } </span><span>catch </span><span>(</span><span>InterruptedException </span><span>e</span><span>) {<br/></span><span>        </span><span>e</span><span>.</span><span>printStackTrace</span><span>();<br/></span><span>      }<br/></span><span>    }<br/></span><span>}</span></pre>
<p>The output of the preceding code is as follows:</p>
<pre style="padding-left: 60px">RECEIVED: Source1: 1 seconds<br/>RECEIVED: Source1: 2 seconds<br/>RECEIVED: Source2: 300 milliseconds<br/>RECEIVED: Source2: 600 milliseconds<br/>RECEIVED: Source2: 900 milliseconds<br/>RECEIVED: Source2: 1200 milliseconds<br/>RECEIVED: Source2: 1500 milliseconds<br/><br/></pre>
<p>There are concatenation counterparts for arrays and <kbd>Iterable&lt;Observable&lt;T&gt;&gt;</kbd> inputs as well, just like there is for merging. The <kbd>Observable.concatArray()</kbd> factory will fire off each <kbd>Observable</kbd> sequentially in an <kbd>Observable[]</kbd> array. The <kbd>Observable.concat()</kbd> factory will also accept an <kbd>Iterable&lt;Observable&lt;T&gt;&gt;</kbd> and fire off each <kbd>Observable&lt;T<strong>&gt;</strong></kbd> in the same manner.</p>
<p>Note there are a few variants of <kbd>concatMap()</kbd>. Use <kbd>concatMapIterable()</kbd> when you want to map each emission to an <kbd>Iterable&lt;T&gt;</kbd> instead of an <kbd>Observable&lt;T&gt;</kbd><strong>. </strong>It will emit all <kbd>T</kbd> values for each <kbd>Iterable&lt;T&gt;</kbd>, saving you the step and overhead of turning each one into an <kbd>Observable&lt;T&gt;</kbd>. There is also a <kbd>concatMapEager()</kbd> operator that will eagerly subscribe to all <kbd>Observable</kbd> sources it receives and will cache the emissions until it is their turn to emit.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">concatMap()</h1>
                </header>
            
            <article>
                
<p>Just as there is <kbd>flatMap()</kbd>, which dynamically merges Observables derived off each emission, there is a concatenation counterpart called <kbd>concatMap()</kbd><strong>.</strong> You should prefer this operator if you care about ordering and want each <kbd>Observable</kbd> mapped from each emission to finish before starting the next one. More specifically, <kbd>concatMap()</kbd> will merge each mapped <kbd>Observable</kbd> sequentially and fire it one at a time. It will only move to the next Observable when the current one calls <kbd>onComplete()</kbd>. If source emissions produce Observables faster than <kbd>concatMap()</kbd> can emit from them, those Observables will be queued.</p>
<p>Our earlier <kbd>flatMap()</kbd> examples would be better suited for <kbd>concatMap()</kbd> if we explicitly cared about emission order. Although our example here has the same output as the <kbd>flatMap()</kbd> example, we should use <kbd>concatMap()</kbd> when we explicitly care about maintaining ordering and want to process each mapped <kbd>Observable</kbd> sequentially:</p>
<pre style="padding-left: 60px"><span>import </span><span>io.reactivex.</span><span>Observable</span><span>;<br/></span><span><br/></span><span>public class </span><span>Launcher </span><span>{<br/></span><span>    </span><span>public static void </span><span>main</span><span>(</span><span>String</span><span>[] </span><span>args</span><span>) {<br/></span><span><br/></span><span>        </span><span>Observable</span><span>&lt;</span><span>String</span><span>&gt; </span><span>source </span><span>=<br/></span><span>                </span><span>Observable</span><span>.</span><span>just</span><span>(</span><span>"Alpha"</span><span>, </span><span>"Beta"</span><span>, </span><span>"Gamma"</span><span>, </span><span>"Delta"</span><span>, </span><span>"Epsilon"</span><span>);<br/></span><span><br/></span><span>        </span><span>source</span><span>.</span><span>concatMap</span><span>(</span><span>s</span> -&gt; <span>Observable</span><span>.</span><span>fromArray</span><span>(</span><span>s</span><span>.</span><span>split</span><span>(</span><span>""</span><span>)))<br/></span><span>                .</span><span>subscribe</span><span>(</span><span>System</span><span>.</span><span>out</span>::<span>println</span><span>);<br/></span><span>    }<br/></span><span>}<br/></span></pre>
<p>The output will be as follows:</p>
<pre style="padding-left: 60px">A<br/>l<br/>p<br/>h<br/>a<br/>B<br/>e<br/>t<br/>a<br/>G<br/>a<br/>m<br/>m<br/>...</pre>
<p>Again, it is unlikely that you will ever want to use <kbd>concatMap()</kbd> to map to infinite Observables. As you can guess, this would result in subsequent Observables never firing. You will likely want to use <kbd>flatMap()</kbd> instead, and we will see it used in concurrency examples in <a href="4f59db87-4b1d-47e6-95e3-ae0a43193c5f.xhtml">Chapter 6</a>,<span> <em>Concurrency and Parallelization</em></span>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Ambiguous</h1>
                </header>
            
            <article>
                
<p>After covering merging and concatenation, let's get an easy combine operation out of the way. The <kbd>Observable.amb()</kbd> factory (<strong>amb</strong> stands for <strong>ambiguous</strong>) will accept an <kbd>Iterable&lt;Observable&lt;T&gt;&gt;</kbd> and emit the emissions of the first <kbd>Observable</kbd> that emits, while the others are disposed of. The first <kbd>Observable</kbd> with an emission is the one whose emissions go through. This is helpful when you have multiple sources for the same data or events and you want the fastest one to win.</p>
<p>Here, we have two interval sources and we combine them with the <kbd>Observable.amb()</kbd> factory. If one emits every second while the other every 300 milliseconds, the latter is going to win because it will emit first:</p>
<pre style="padding-left: 60px"><span>import </span><span>io.reactivex.</span><span>Observable</span><span>;<br/></span><span>import </span><span>java.util.Arrays</span><span>;<br/></span><span>import </span><span>java.util.concurrent.</span><span>TimeUnit</span><span>;<br/></span><span><br/></span><span>public class </span><span>Launcher </span><span>{<br/></span><span>    </span><span>public static void </span><span>main</span><span>(</span><span>String</span><span>[] </span><span>args</span><span>) {<br/></span><span><br/></span><span>        </span><span>//emit every second<br/></span><span>        </span><span>Observable</span><span>&lt;</span><span>String</span><span>&gt; </span><span>source1 </span><span>=<br/></span><span>                </span><span>Observable</span><span>.</span><span>interval</span><span>(</span><span>1</span><span>, </span><span>TimeUnit</span><span>.</span><span>SECONDS</span><span>)<br/></span><span>                        .</span><span>take</span><span>(</span><span>2</span><span>)<br/></span><span>                        .</span><span>map</span><span>(</span><span>l </span>-&gt; <span>l </span><span>+ </span><span>1</span><span>) </span><span>// emit elapsed seconds<br/></span><span>                        </span><span>.</span><span>map</span><span>(</span><span>l </span>-&gt; <span>"Source1: " </span><span>+ </span><span>l </span><span>+ </span><span>" seconds"</span><span>);<br/></span><span><br/></span><span><br/></span><span>        </span><span>//emit every 300 milliseconds<br/></span><span>        </span><span>Observable</span><span>&lt;</span><span>String</span><span>&gt; </span><span>source2 </span><span>=<br/></span><span>                </span><span>Observable</span><span>.</span><span>interval</span><span>(</span><span>300</span><span>, </span><span>TimeUnit</span><span>.</span><span>MILLISECONDS</span><span>)<br/></span><span>                        .</span><span>map</span><span>(</span><span>l </span>-&gt; <span>(</span><span>l </span><span>+ </span><span>1</span><span>) </span><span>* </span><span>300</span><span>) </span><span>// emit elapsed milliseconds<br/></span><span>                        </span><span>.</span><span>map</span><span>(</span><span>l </span>-&gt; <span>"Source2: " </span><span>+ </span><span>l </span><span>+ </span><span>" milliseconds"</span><span>);<br/></span><span><br/></span><span><br/></span><span>        </span><span>//emit Observable that emits first<br/></span><span>        </span><span>Observable</span><span>.</span><span>amb</span><span>(</span><span>Arrays</span><span>.</span><span>asList</span><span>(</span><span>source1</span><span>, </span><span>source2</span><span>))<br/></span><span>                .</span><span>subscribe</span><span>(</span><span>i </span>-&gt; <span>System</span><span>.</span><span>out</span><span>.</span><span>println</span><span>(</span><span>"RECEIVED: " </span><span>+ </span><span>i</span><span>));<br/></span><span><br/></span><span>        </span><span>//keep application alive for 5 seconds<br/></span><span>        </span><span>sleep</span><span>(</span><span>5000</span><span>);<br/></span><span>    }<br/></span><span><br/></span><span>    </span><span>public static void </span><span>sleep</span><span>(</span><span>long </span><span>millis</span><span>) {<br/></span><span>        </span><span>try </span><span>{<br/></span><span>            </span><span>Thread</span><span>.</span><span>sleep</span><span>(</span><span>millis</span><span>);<br/></span><span>        } </span><span>catch </span><span>(</span><span>InterruptedException </span><span>e</span><span>) {<br/></span><span>            </span><span>e</span><span>.</span><span>printStackTrace</span><span>();<br/></span><span>        }<br/></span><span>    }<br/></span><span>}</span></pre>
<p>The output is as follows:</p>
<pre style="padding-left: 60px">RECEIVED: Source2: 300 milliseconds<br/>RECEIVED: Source2: 600 milliseconds<br/>RECEIVED: Source2: 900 milliseconds<br/>RECEIVED: Source2: 1200 milliseconds<br/>RECEIVED: Source2: 1500 milliseconds<br/>RECEIVED: Source2: 1800 milliseconds<br/>RECEIVED: Source2: 2100 milliseconds<br/>...</pre>
<p>You can also use an <kbd>ambWith()</kbd> operator, which will accomplish the same result:</p>
<pre style="padding-left: 60px"><span>//emit Observable that emits first<br/></span><span>source1</span><span>.</span><span>ambWith</span><span>(</span><span>source2</span><span>)<br/></span><span>        .</span><span>subscribe</span><span>(</span><span>i </span>-&gt; <span>System</span><span>.</span><span>out</span><span>.</span><span>println</span><span>(</span><span>"RECEIVED: " </span><span>+ </span><span>i</span><span>));</span></pre>
<p>You can also use <kbd>Observable.ambArray()</kbd> to specify a <kbd>varargs</kbd> array rather than <kbd>Iterable&lt;Observable&lt;T&gt;&gt;</kbd>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Zipping</h1>
                </header>
            
            <article>
                
<p>Zipping allows you to take an emission from each <kbd>Observable</kbd> source and combine it into a single emission. Each <kbd>Observable</kbd> can emit a different type, but you can combine these different emitted types into a single emission. Here is an example, If we have an <kbd>Observable&lt;String&gt;</kbd> and an <kbd>Observable&lt;Integer&gt;</kbd>, we can zip each <kbd>String</kbd> and <kbd>Integer</kbd> together in a one-to-one pairing and concatenate it with a lambda:</p>
<pre style="padding-left: 60px"><span>import</span><span> </span><span>io.reactivex.</span><span>Observable</span><span>;<br/></span><span><br/></span><span>public class </span><span>Launcher </span><span>{</span><span><br/></span><span>    </span><span>public static void </span><span>main</span><span>(</span><span>String</span><span>[] </span><span>args</span><span>) {<br/></span><span><br/></span><span>        </span><span>Observable</span><span>&lt;</span><span>String</span><span>&gt; </span><span>source1 </span><span>=<br/></span><span>                </span><span>Observable</span><span>.</span><span>just</span><span>(</span><span>"Alpha"</span><span>, </span><span>"Beta"</span><span>, </span><span>"Gamma"</span><span>, </span><span>"Delta"</span><span>, </span><span>"Epsilon"</span><span>);<br/></span><span><br/></span><span>        </span><span>Observable</span><span>&lt;</span><span>Integer</span><span>&gt; </span><span>source2 </span><span>= </span><span>Observable</span><span>.</span><span>range</span><span>(</span><span>1</span><span>,</span><span>6</span><span>);<br/></span><span><br/></span><span>        </span><span>Observable</span><span>.</span><span>zip</span><span>(</span><span>source1</span><span>, </span><span>source2</span><span>, (</span><span>s</span><span>,</span><span>i</span><span>) </span>-&gt; <span>s </span><span>+ </span><span>"-" </span><span>+ </span><span>i</span><span>)<br/></span><span>                .</span><span>subscribe</span><span>(</span><span>System</span><span>.</span><span>out</span>::<span>println</span><span>);<br/></span><span>    }<br/></span><span>}</span></pre>
<p>The output is as follows:</p>
<pre style="padding-left: 60px">Alpha-1<br/>Beta-2<br/>Gamma-3<br/>Delta-4<br/>Epsilon-5</pre>
<p>The <kbd>zip()</kbd> function received both <kbd>Alpha</kbd> and a <kbd>1</kbd> and then paired them up into a concatenated string separated by a dash <kbd>-</kbd> and pushed it forward. Then, it received <kbd>Beta</kbd> and <kbd>2</kbd> and emitted them forward as a concatenation, and so on. An emission from one <kbd>Observable</kbd> must wait to get paired with an emission from the other <kbd>Observable</kbd>. If one <kbd>Observable</kbd> calls <kbd>onComplete()</kbd> and the other still has emissions waiting to get paired, those emissions will simply drop, since they have nothing to couple with. This happened to the <kbd>6</kbd> emission since we only had five string emissions.</p>
<p>You can also accomplish this using a <kbd>zipWith()</kbd> operator, as shown here:</p>
<pre style="padding-left: 60px"><span>source1</span><span>.</span><span>zipWith</span><span>(</span><span>source2</span><span>, (</span><span>s</span><span>,</span><span>i</span><span>) </span>-&gt; <span>s </span><span>+ </span><span>"-" </span><span>+ </span><span>i</span><span>)</span></pre>
<p>You can pass up to nine <kbd>Observable</kbd> instances to the <kbd>Observable.zip()</kbd> factory. If you need more than that, you can pass an <kbd>Iterable&lt;Observable&lt;T&gt;&gt;</kbd> or use <kbd>zipArray()</kbd> to provide an <kbd>Observable[]</kbd> array. Note that if one or more sources are producing emissions faster than another, <kbd>zip()</kbd> will queue up those rapid emissions as they wait on the slower source to provide emissions. This could cause undesirable performance issues as each source <span>queues </span>in memory. If you only care about zipping the latest emission from each source rather than catching up an entire queue, you will want to use <kbd>combineLatest()</kbd>, which we will cover later in this section.</p>
<div class="packt_infobox">Use <kbd>Observable.zipIterable()</kbd> to pass a Boolean <kbd>delayError</kbd> argument to delay errors until all sources terminate and an int <kbd>bufferSize</kbd> to hint an expected number of elements from each source for queue size optimization. You may specify the latter to increase performance in certain scenarios by buffering emissions before they are <span>zipped</span>.</div>
<p>Zipping can also be helpful in slowing down emissions using <kbd>Observable.interval()</kbd>. Here, we zip each string with a 1-second interval. This will slow each string emission by one second, but keep in mind the five string emissions will likely be queued as they wait for an interval emission to pair with:</p>
<pre style="padding-left: 60px"><span>import </span><span>io.reactivex.</span><span>Observable</span><span>;<br/></span><span>import </span><span>java.time.LocalTime</span><span>;<br/></span><span>import </span><span>java.util.concurrent.</span><span>TimeUnit</span><span>;<br/></span><span><br/></span><span>public class </span><span>Launcher </span><span>{<br/></span><span>    </span><span>public static void </span><span>main</span><span>(</span><span>String</span><span>[] </span><span>args</span><span>) {<br/></span><span><br/></span><span>        </span><span>Observable</span><span>&lt;</span><span>String</span><span>&gt; </span><span>strings </span><span>=<br/></span><span>                </span><span>Observable</span><span>.</span><span>just</span><span>(</span><span>"Alpha"</span><span>, </span><span>"Beta"</span><span>, </span><span>"Gamma"</span><span>, </span><span>"Delta"</span><span>, </span><span>"Epsilon"</span><span>);<br/></span><span><br/></span><span>        </span><span>Observable</span><span>&lt;</span><span>Long</span><span>&gt; </span><span>seconds </span><span>=<br/></span><span>                </span><span>Observable</span><span>.</span><span>interval</span><span>(</span><span>1</span><span>, </span><span>TimeUnit</span><span>.</span><span>SECONDS</span><span>);<br/></span><span><br/></span><span>        </span><span>Observable</span><span>.</span><span>zip</span><span>(</span><span>strings</span><span>,</span><span>seconds</span><span>, (</span><span>s</span><span>,</span><span>l</span><span>) </span>-&gt; <span>s</span><span>)<br/></span><span>                .</span><span>subscribe</span><span>(</span><span>s </span>-&gt; <br/><span>System</span><span>.</span><span>out</span><span>.</span><span>println</span><span>(</span><span>"Received " </span><span>+ </span><span>s </span><span>+ <br/></span><span>                                </span><span>" at " </span><span>+ </span><span>LocalTime</span><span>.</span><span>now</span><span>())<br/></span><span>                );<br/></span><span><br/></span><span>        </span><span>sleep</span><span>(</span><span>6000</span><span>);<br/></span><span>    }<br/></span><span>    </span><span>public static void </span><span>sleep</span><span>(</span><span>long </span><span>millis</span><span>) {<br/></span><span>        </span><span>try </span><span>{<br/></span><span>            </span><span>Thread</span><span>.</span><span>sleep</span><span>(</span><span>millis</span><span>);<br/></span><span>        } </span><span>catch </span><span>(</span><span>InterruptedException </span><span>e</span><span>) {<br/></span><span>            </span><span>e</span><span>.</span><span>printStackTrace</span><span>();<br/></span><span>        }<br/></span><span>    }<br/></span><span>}</span></pre>
<p>The output is as follows:</p>
<pre style="padding-left: 60px">Received Alpha at 13:28:28.428<br/>Received Beta at 13:28:29.388<br/>Received Gamma at 13:28:30.389<br/>Received Delta at 13:28:31.389<br/>Received Epsilon at 13:28:32.389</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Combine latest</h1>
                </header>
            
            <article>
                
<p>The <kbd>Observable.combineLatest()</kbd> factory is somewhat similar to <kbd>zip()</kbd>, but for every emission that fires from one of the sources, it will immediately couple up with the latest emission from every other source. It will not queue up unpaired emissions for each source, but rather cache and pair the latest one.</p>
<p>Here, let's use <kbd>Observable.combineLatest()</kbd> between two interval Observables, the first emitting at 300 milliseconds and the other every one second: </p>
<pre style="padding-left: 60px"><span>import</span><span> </span><span>io.reactivex.</span><span>Observable</span><span>;<br/></span><span>import </span><span>java.util.concurrent.</span><span>TimeUnit</span><span>;<br/></span><span><br/></span><span>public class </span><span>Launcher </span><span>{<br/></span><span>    </span><span>public static void </span><span>main</span><span>(</span><span>String</span><span>[] </span><span>args</span><span>) {<br/></span><span><br/></span><span>        </span><span>Observable</span><span>&lt;</span><span>Long</span><span>&gt; </span><span>source1 </span><span>=<br/></span><span>                </span><span>Observable</span><span>.</span><span>interval</span><span>(</span><span>300</span><span>, </span><span>TimeUnit</span><span>.</span><span>MILLISECONDS</span><span>);<br/></span><span><br/></span><span>        </span><span>Observable</span><span>&lt;</span><span>Long</span><span>&gt; </span><span>source2 </span><span>=<br/></span><span>                </span><span>Observable</span><span>.</span><span>interval</span><span>(</span><span>1</span><span>, </span><span>TimeUnit</span><span>.</span><span>SECONDS</span><span>);<br/></span><span><br/></span><span>        </span><span>Observable</span><span>.</span><span>combineLatest</span><span>(</span><span>source1</span><span>, </span><span>source2</span><span>,<br/></span><span>                (</span><span>l1</span><span>,</span><span>l2</span><span>) </span>-&gt; <span>"SOURCE 1: " </span><span>+ </span><span>l1 </span><span>+ </span><span>"  SOURCE 2: " </span><span>+ </span><span>l2</span><span>)<br/></span><span>                .</span><span>subscribe</span><span>(</span><span>System</span><span>.</span><span>out</span>::<span>println</span><span>);<br/></span><span><br/></span><span><br/></span><span>        </span><span>sleep</span><span>(</span><span>3000</span><span>);<br/></span><span>    }<br/></span><span>    </span><span>public static void </span><span>sleep</span><span>(</span><span>long </span><span>millis</span><span>) {<br/></span><span>        </span><span>try </span><span>{<br/></span><span>            </span><span>Thread</span><span>.</span><span>sleep</span><span>(</span><span>millis</span><span>);<br/></span><span>        } </span><span>catch </span><span>(</span><span>InterruptedException </span><span>e</span><span>) {<br/></span><span>            </span><span>e</span><span>.</span><span>printStackTrace</span><span>();<br/></span><span>        }<br/></span><span>    }<br/></span><span>}<br/></span></pre>
<p>The output is as follows:</p>
<pre style="padding-left: 60px">SOURCE 1: 2  SOURCE 2: 0<br/>SOURCE 1: 3  SOURCE 2: 0<br/>SOURCE 1: 4  SOURCE 2: 0<br/>SOURCE 1: 5  SOURCE 2: 0<br/>SOURCE 1: 5  SOURCE 2: 1<br/>SOURCE 1: 6  SOURCE 2: 1<br/>SOURCE 1: 7  SOURCE 2: 1<br/>SOURCE 1: 8  SOURCE 2: 1<br/>SOURCE 1: 9  SOURCE 2: 1<br/>SOURCE 1: 9  SOURCE 2: 2</pre>
<p>There is a lot going on here, but let's try to break it down. <kbd>source1</kbd> is emitting every 300 milliseconds, but the first two emissions do not yet have anything to pair with from <kbd>source2</kbd>, which emits every second, and no emission has occurred yet. Finally, after one second, <kbd>source2</kbd> pushes its first emission <kbd>0</kbd>, and it pairs with the latest emission <kbd>2</kbd> (the third emission) from <kbd>source1</kbd>. Note that the two previous emissions <kbd>0</kbd> and <kbd>1</kbd> from <kbd>source1</kbd> were completely forgotten because the third emission <kbd>2</kbd> is now the latest emission. <kbd>source1</kbd> then pushes <kbd>3</kbd>, <kbd>4</kbd>, and then <kbd>5</kbd> at 300 millisecond intervals, but <kbd>0</kbd> is still the latest emission from <kbd>source2</kbd>, so all three pair with it. Then, <kbd>source2</kbd> emits its second emission <kbd>1</kbd>, and it pairs with <kbd>5</kbd>, the latest emission from <kbd>source2</kbd>.</p>
<p>In simpler terms, when one source fires, it couples with the latest emissions from the others. <kbd>Observable.combineLatest()</kbd> is especially helpful in combining UI inputs, as previous user inputs are frequently irrelevant and only the latest is of concern.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">withLatestFrom()</h1>
                </header>
            
            <article>
                
<p>Similar to <kbd>Observable.combineLatest()</kbd>, but not exactly the same, is the <kbd>withLatestfrom()</kbd> operator. It will map each <kbd>T</kbd> emission with the latest values from other Observables and combine them, but it will only take <em>one</em> emission from each of the other Observables:</p>
<pre style="padding-left: 60px"><span>import</span><span> </span><span>io.reactivex.</span><span>Observable</span><span>;<br/></span><span>import </span><span>java.util.concurrent.</span><span>TimeUnit</span><span>;<br/></span><span><br/></span><span>public class </span><span>Launcher </span><span>{<br/></span><span>    </span><span>public static void </span><span>main</span><span>(</span><span>String</span><span>[] </span><span>args</span><span>) {<br/></span><span><br/></span><span>        </span><span>Observable</span><span>&lt;</span><span>Long</span><span>&gt; </span><span>source1 </span><span>=<br/></span><span>                </span><span>Observable</span><span>.</span><span>interval</span><span>(</span><span>300</span><span>, </span><span>TimeUnit</span><span>.</span><span>MILLISECONDS</span><span>);<br/></span><span><br/></span><span>        </span><span>Observable</span><span>&lt;</span><span>Long</span><span>&gt; </span><span>source2 </span><span>=<br/></span><span>                </span><span>Observable</span><span>.</span><span>interval</span><span>(</span><span>1</span><span>, </span><span>TimeUnit</span><span>.</span><span>SECONDS</span><span>);<br/></span><span><br/></span><span>        </span><span>source2</span><span>.</span><span>withLatestFrom</span><span>(</span><span>source1</span><span>,<br/></span><span>                (</span><span>l1</span><span>,</span><span>l2</span><span>) </span>-&gt; <span>"SOURCE 2: " </span><span>+ </span><span>l1 </span><span>+ </span><span>"  SOURCE 1: " </span><span>+ </span><span>l2<br/></span><span>        </span><span>) .</span><span>subscribe</span><span>(</span><span>System</span><span>.</span><span>out</span>::<span>println</span><span>);<br/></span><span><br/></span><span><br/></span><span>        </span><span>sleep</span><span>(</span><span>3000</span><span>);<br/></span><span>    }<br/></span><span>    </span><span>public static void </span><span>sleep</span><span>(</span><span>long </span><span>millis</span><span>) {<br/></span><span>        </span><span>try </span><span>{<br/></span><span>            </span><span>Thread</span><span>.</span><span>sleep</span><span>(</span><span>millis</span><span>);<br/></span><span>        } </span><span>catch </span><span>(</span><span>InterruptedException </span><span>e</span><span>) {<br/></span><span>            </span><span>e</span><span>.</span><span>printStackTrace</span><span>();<br/></span><span>        }<br/></span><span>    }<br/></span><span>}</span></pre>
<p>The output is as follows:</p>
<pre style="padding-left: 60px">SOURCE 2: 0  SOURCE 1: 2<br/>SOURCE 2: 1  SOURCE 1: 5<br/>SOURCE 2: 2  SOURCE 1: 9</pre>
<p>As you can see here, <kbd>source2</kbd> emits every one second while <kbd>source1</kbd> emits every 300 milliseconds. When you call <kbd>withLatestFrom()</kbd> on <kbd>source2</kbd> and pass it <kbd>source1</kbd>, it will combine with the latest emission from <kbd>source1</kbd> but it does not care about any previous or subsequent emissions.</p>
<p>You can pass up to four <kbd>Observable</kbd> instances of any varying types to <kbd>withLatestFrom()</kbd>. If you need more than that, you can pass it an <kbd>Iterable&lt;Observable&lt;T&gt;&gt;</kbd>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Grouping</h1>
                </header>
            
            <article>
                
<p>A powerful operation that you can achieve with RxJava is to group emissions by a specified key into separate Observables. This can be achieved by calling the <kbd>groupBy()</kbd> operator, which accepts a lambda mapping each emission to a key. It will then return an <kbd>Observable&lt;GroupedObservable&lt;K,T&gt;&gt;</kbd>, which emits a special type of <kbd>Observable</kbd> called <kbd>GroupedObservable</kbd>. <kbd>GroupedObservable&lt;K,T&gt;</kbd> is just like any other <kbd>Observable</kbd><span>,</span> but it has the key <kbd>K</kbd> value accessible as a property. It will emit the <kbd>T</kbd> emissions that are mapped for that given key.</p>
<p>For instance, we can use the <kbd>groupBy()</kbd> operator to group emissions for an <kbd>Observable&lt;String&gt;</kbd> by each String's length. We will subscribe to it in a moment, but here is how we declare it:</p>
<pre style="padding-left: 60px"><span>import</span><span> </span><span>io.reactivex.</span><span>Observable</span><span>;<br/></span><span>import </span><span>io.reactivex.observables.</span><span>GroupedObservable</span><span>;<br/></span><span><br/></span><span>public class </span><span>Launcher </span><span>{<br/></span><span>    </span><span>public static void </span><span>main</span><span>(</span><span>String</span><span>[] </span><span>args</span><span>) {<br/></span><span><br/></span><span>        </span><span>Observable</span><span>&lt;</span><span>String</span><span>&gt; </span><span>source </span><span>= <br/></span><span>Observable</span><span>.</span><span>just</span><span>(</span><span>"Alpha"</span><span>, </span><span>"Beta"</span><span>, </span><span>"Gamma"</span><span>, </span><span>"Delta"</span><span>, </span><span>"Epsilon"</span><span>);<br/></span><span><br/></span><span>        </span><span>Observable</span><span>&lt;</span><span>GroupedObservable</span><span>&lt;</span><span>Integer</span><span>,</span><span>String</span><span>&gt;&gt; </span><span>byLengths </span><span>=<br/></span><span>                </span><span>source</span><span>.</span><span>groupBy</span><span>(</span><span>s </span>-&gt; <span>s</span><span>.</span><span>length</span><span>());</span><span><br/></span><span>    }<br/></span><span>}</span></pre>
<p>We will likely need to use <kbd>flatMap()</kbd> on each <kbd>GroupedObservable</kbd>, but within that <kbd>flatMap()</kbd> operation, we may want to reduce or collect those common-key emissions (since this will return a <kbd>Single</kbd>, we will need to use <kbd>flatMapSingle()</kbd>). Let's call <kbd>toList()</kbd> so that we can emit the emissions as lists grouped by their lengths:</p>
<pre style="padding-left: 60px"><span>import </span><span>io.reactivex.</span><span>Observable</span><span>;<br/></span><span>import </span><span>io.reactivex.observables.</span><span>GroupedObservable</span><span>;<br/></span><span><br/></span><span>public class </span><span>Launcher </span><span>{<br/></span><span>    </span><span>public static void </span><span>main</span><span>(</span><span>String</span><span>[] </span><span>args</span><span>) {<br/></span><span><br/></span><span>        </span><span>Observable</span><span>&lt;</span><span>String</span><span>&gt; </span><span>source </span><span>=<br/></span><span>                </span><span>Observable</span><span>.</span><span>just</span><span>(</span><span>"Alpha"</span><span>, </span><span>"Beta"</span><span>, </span><span>"Gamma"</span><span>, </span><span>"Delta"</span><span>, </span><span>"Epsilon"</span><span>);<br/></span><span><br/></span><span>        </span><span>Observable</span><span>&lt;</span><span>GroupedObservable</span><span>&lt;</span><span>Integer</span><span>,</span><span>String</span><span>&gt;&gt; </span><span>byLengths </span><span>=<br/></span><span>                </span><span>source</span><span>.</span><span>groupBy</span><span>(</span><span>s </span>-&gt; <span>s</span><span>.</span><span>length</span><span>());<br/></span><span><br/></span><span>        </span><span>byLengths</span><span>.</span><span>flatMapSingle</span><span>(</span><span>grp </span>-&gt; <span>grp</span><span>.</span><span>toList</span><span>())<br/></span><span>                .</span><span>subscribe</span><span>(</span><span>System</span><span>.</span><span>out</span>::<span>println</span><span>);</span><span><br/></span><span>    }<br/></span><span>}</span></pre>
<p>The output is as follows:</p>
<pre style="padding-left: 60px">[Beta]<br/>[Alpha, Gamma, Delta]<br/>[Epsilon]</pre>
<p><kbd>Beta</kbd> is the only emission with length four, so it is the only element in the list for that length key. <kbd>Alpha</kbd>, <kbd>Beta</kbd>, and <kbd>Gamma</kbd> all have lengths of five, so they were emitted from the same <kbd>GroupedObservable</kbd><strong> </strong>emitting items for the length five and were collected into the same list. <kbd>Epsilon</kbd> was the only emission with length seven so it was the only element in its list.</p>
<p>Keep in mind that <kbd>GroupedObservable</kbd> also has a <kbd>getKey()</kbd> method, which returns the key value identified with that <kbd>GroupedObservable<span>.</span></kbd> If we wanted to simply concatenate the <kbd>String</kbd> emissions for each <kbd>GroupedObservable</kbd> and then concatenate the <kbd>length</kbd> key in form of it, we could do it like this:</p>
<pre style="padding-left: 60px"><span>import</span><span> </span><span>io.reactivex.</span><span>Observable</span><span>;<br/></span><span>import </span><span>io.reactivex.observables.</span><span>GroupedObservable</span><span>;<br/></span><span><br/></span><span>public class </span><span>Launcher </span><span>{<br/></span><span>    </span><span>public static void </span><span>main</span><span>(</span><span>String</span><span>[] </span><span>args</span><span>) {<br/></span><span><br/></span><span>        </span><span>Observable</span><span>&lt;</span><span>String</span><span>&gt; </span><span>source </span><span>=<br/></span><span>                </span><span>Observable</span><span>.</span><span>just</span><span>(</span><span>"Alpha"</span><span>, </span><span>"Beta"</span><span>, </span><span>"Gamma"</span><span>, </span><span>"Delta"</span><span>, </span><span>"Epsilon"</span><span>);<br/></span><span><br/></span><span>        </span><span>Observable</span><span>&lt;</span><span>GroupedObservable</span><span>&lt;</span><span>Integer</span><span>,</span><span>String</span><span>&gt;&gt; </span><span>byLengths </span><span>=<br/></span><span>                </span><span>source</span><span>.</span><span>groupBy</span><span>(</span><span>s </span>-&gt; <span>s</span><span>.</span><span>length</span><span>());<br/></span><span><br/></span><span>        </span><span>byLengths</span><span>.</span><span>flatMapSingle</span><span>(</span><span>grp </span>-&gt;<br/><span>grp</span><span>.</span><span>reduce</span><span>(</span><span>""</span><span>,(</span><span>x</span><span>,</span><span>y</span><span>) </span>-&gt; <span>x</span><span>.</span><span>equals</span><span>(</span><span>""</span><span>) </span><span>? </span><span>y </span><span>: </span><span>x </span><span>+ </span><span>", " </span><span>+ </span><span>y</span><span>)<br/></span><span>                        .</span><span>map</span><span>(</span><span>s </span>-&gt; <span>grp</span><span>.</span><span>getKey</span><span>() </span><span>+ </span><span>": " </span><span>+ </span><span>s</span><span>)<br/></span><span>        ).</span><span>subscribe</span><span>(</span><span>System</span><span>.</span><span>out</span>::<span>println</span><span>);<br/></span><span>    }<br/></span><span>}</span></pre>
<p>The output is as follows:</p>
<pre style="padding-left: 60px">4: Beta<br/>5: Alpha, Gamma, Delta<br/>7: Epsilon</pre>
<p>Note closely that <span><kbd>GroupedObservables</kbd></span> are a weird combination of a hot and cold <kbd>Observable</kbd>. They are not cold in that they will not replay missed emissions to a second <kbd>Observer</kbd>, but they will cache emissions and flush them to the first <kbd>Observer</kbd>, ensuring none are missed. If you need to replay the emissions, collect them into a list, like we did earlier, and perform your operations against that list. You can also use caching operators, which we will learn about in the next chapter.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>In this chapter, we covered combining Observables in various useful ways. Merging is helpful in combining and simultaneously firing multiple Observables and combining their emissions into a single stream. The <kbd>flatMap()</kbd> operator is especially critical to know, as dynamically merging Observables derived from emissions opens a lot of useful functionality in RxJava. Concatenation is similar to merging, but it fires off the source Observables sequentially rather than all at once. Combining with ambiguous allows us to select the first <kbd>Observable</kbd> to emit and fire its emissions. Zipping allows you to combine emissions from multiple Observables, whereas combine latest combines the latest emissions from each source every time one of them fires. Finally, grouping allows you to split up an <kbd>Observable</kbd> into several <kbd>GroupedObservables</kbd>, <span> </span>each with emissions that have a common key. </p>
<p>Take time to explore combining Observables and experiment to see how they work. They are critical to unlock functionalities in RxJava and quickly express event and data transformations. We will look at some powerful applications with <kbd>flatMap()</kbd> when we cover concurrency in<span> <span><a href="4f59db87-4b1d-47e6-95e3-ae0a43193c5f.xhtml">Chapter 6</a>, <em>Concurrency and Parallelization</em>, where we will also cover how to multitask and parallelize.</span></span></p>


            </article>

            
        </section>
    </body></html>