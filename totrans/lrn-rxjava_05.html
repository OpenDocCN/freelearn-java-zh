<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Multicasting, Replaying, and Caching</h1>
                </header>
            
            <article>
                
<p>We have seen the hot and cold <kbd>Observable</kbd> in action throughout this book, although most of our examples have been cold Observables (even ones using <kbd>Observable.interval()</kbd>). As a matter of fact, there are a lot of subtleties in the hotness and coldness of Observables, which we will look at in this chapter. When you have more than one <kbd>Observer</kbd>, the default behavior is to create a separate stream for each one. This may or may not be desirable, and we need to be aware of when to force an <kbd>Observable</kbd> to be hot by multicasting using a <kbd>ConnectableObservable</kbd>. We got a brief introduction to the <kbd>ConnectableObservable</kbd> in <a href="7fea3844-94e9-442e-9d54-239d146a8250.xhtml">Chapter 2</a>, <em>Observables and Subscribers</em>, but we will look at it in deeper context within an entire <kbd>Observable</kbd> chain of operators.</p>
<p>In this chapter, we will learn about multicasting with <kbd>ConnectableObservable</kbd> in detail and uncover its subtleties. We will also learn about replaying and caching, both of which multicast and leverage the <kbd>ConnectableObservable</kbd>. Finally, we will learn about Subjects, a utility that can be useful for decoupling while multicasting but should be used conservatively for only certain situations. We will cover the different flavors of subjects as well as when and when not to use them.</p>
<p>Here is a broad outline of what to expect:</p>
<ul>
<li>Understanding multicasting</li>
<li>Automatic connection</li>
<li>Replaying and caching</li>
<li>Subjects</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Understanding multicasting</h1>
                </header>
            
            <article>
                
<p>We have used the <kbd>ConnectableObservable</kbd> earlier in <a href="7fea3844-94e9-442e-9d54-239d146a8250.xhtml">Chapter 2</a>, <em>Observables and Subscribers</em>. Remember how cold Observables, such as <kbd>Observable.range()</kbd>, will regenerate emissions for each <kbd>Observer</kbd>? Let's take a look at the following code:</p>
<pre style="padding-left: 60px"><span>import</span><span> </span><span>io.reactivex.</span><span>Observable</span><span>;<br/></span><span><br/></span><span>public class </span><span>Launcher </span><span>{<br/></span><span>    </span><span>public static void </span><span>main</span><span>(</span><span>String</span><span>[] </span><span>args</span><span>) {<br/></span><span><br/></span><span>        </span><span>Observable</span><span>&lt;</span><span>Integer</span><span>&gt; </span><span>threeIntegers  </span><span>= </span><span>Observable</span><span>.</span><span>range</span><span>(</span><span>1</span><span>, </span><span>3</span><span>);<br/></span><span><br/></span><span>        </span><span>threeIntegers</span><span>.</span><span>subscribe</span><span>(</span><span>i </span>-&gt; <span>System</span><span>.</span><span>out</span><span>.</span><span>println</span><span>(</span><span>"Observer One: " </span><span>+ </span><span>i</span><span>));<br/></span><span>        </span><span>threeIntegers</span><span>.</span><span>subscribe</span><span>(</span><span>i </span>-&gt; <span>System</span><span>.</span><span>out</span><span>.</span><span>println</span><span>(</span><span>"Observer Two: " </span><span>+ </span><span>i</span><span>));<br/></span><span>    }<br/></span><span>}</span></pre>
<p>The output is as follows:</p>
<pre style="padding-left: 60px">Observer One: 1<br/>Observer One: 2<br/>Observer One: 3<br/>Observer Two: 1<br/>Observer Two: 2<br/>Observer Two: 3</pre>
<p>Here, <kbd>Observer One</kbd> received all three emissions and called <kbd>onComplete()</kbd>. After that, <kbd>Observer Two</kbd> received the three emissions (which were regenerated again) and called <kbd>onComplete()</kbd>. These were two separate streams of data generated for two separate subscriptions. If we wanted to consolidate them into a single stream of data that pushes each emission to both Observers simultaneously, we can call <kbd>publish()</kbd> on <kbd>Observable</kbd>, which will return a <kbd>ConnectableObservable</kbd>. We can set up the Observers in advance and then call <kbd>connect()</kbd> to start firing the emissions so both Observers receive the same emissions simultaneously. This will be indicated by the printing of each <kbd>Observer</kbd> interleaving here:</p>
<pre style="padding-left: 60px"><span>import </span><span>io.reactivex.</span><span>Observable</span><span>;<br/></span><span>import </span><span>io.reactivex.observables.</span><span>ConnectableObservable</span><span>;<br/></span><span><br/></span><span>public class </span><span>Launcher </span><span>{<br/></span><span>    </span><span>public static void </span><span>main</span><span>(</span><span>String</span><span>[] </span><span>args</span><span>) {<br/></span><span><br/></span><span>        </span><span>ConnectableObservable</span><span>&lt;</span><span>Integer</span><span>&gt; </span><span>threeIntegers </span><span>=<br/></span><span>                </span><span>Observable</span><span>.</span><span>range</span><span>(</span><span>1</span><span>, </span><span>3</span><span>).</span><span>publish</span><span>();<br/></span><span><br/></span><span>        </span><span>threeIntegers</span><span>.</span><span>subscribe</span><span>(</span><span>i </span>-&gt; <span>System</span><span>.</span><span>out</span><span>.</span><span>println</span><span>(</span><span>"Observer One: " </span><span>+ </span><span>i</span><span>));<br/></span><span>        </span><span>threeIntegers</span><span>.</span><span>subscribe</span><span>(</span><span>i </span>-&gt; <span>System</span><span>.</span><span>out</span><span>.</span><span>println</span><span>(</span><span>"Observer Two: " </span><span>+ </span><span>i</span><span>));<br/></span><span><br/></span><span>        </span><span>threeIntegers</span><span>.</span><span>connect</span><span>();<br/></span><span>    }<br/></span><span>}<br/></span></pre>
<p><span>The output is as follows:</span></p>
<pre style="padding-left: 60px">Observer One: 1<br/>Observer Two: 1<br/>Observer One: 2<br/>Observer Two: 2<br/>Observer One: 3<br/>Observer Two: 3</pre>
<p>Using <kbd>ConnectableObservable</kbd> will force emissions from the source to become hot, pushing a single stream of emissions to all Observers at the same time rather than giving a separate stream to each <kbd>Observer</kbd>. This idea of stream consolidation is known as multicasting, but there are nuances to it, especially when operators become involved. Even when you call <kbd>publish()</kbd><strong> </strong>and use a <kbd>ConnectableObservable</kbd>, any operators that follow can create separate streams again. We will take a look at this behavior and how to manage it next.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Multicasting with operators</h1>
                </header>
            
            <article>
                
<p>To see how multicasting works within a chain of operators, we are going to use <kbd>Observable.range()</kbd> and then map each emission to a random integer. Since these random values will be nondeterministic and different for each subscription, this will provide a good means to see whether our multicasting is working because Observers should receive the same numbers.</p>
<p>Let's start with emitting the numbers 1 through 3 and map each one to a random integer between 0 and 100,000. If we have two Observers, we can expect different integers for each one. Note that your output will be different than mine due to the random number generation and just acknowledge that both Observers are receiving different random integers:</p>
<pre style="padding-left: 60px"><span>import</span><span> </span><span>io.reactivex.</span><span>Observable</span><span>;<br/>import java.util.concurrent.ThreadLocalRandom;<br/></span><span><br/></span><span>public class </span><span>Launcher </span><span>{<br/></span><span>    </span><span>public static void </span><span>main</span><span>(</span><span>String</span><span>[] </span><span>args</span><span>) {<br/></span><span><br/></span><span>        </span><span>Observable</span><span>&lt;</span><span>Integer</span><span>&gt; </span><span>threeRandoms </span><span>= </span><span>Observable</span><span>.</span><span>range</span><span>(</span><span>1</span><span>,</span><span>3</span><span>)<br/></span><span>                        .</span><span>map</span><span>(</span><span>i </span>-&gt; <span>randomInt</span><span>());<br/></span><span><br/></span><span>        </span><span>threeRandoms</span><span>.</span><span>subscribe</span><span>(</span><span>i </span>-&gt; <span>System</span><span>.</span><span>out</span><span>.</span><span>println</span><span>(</span><span>"Observer 1: " </span><span>+ </span><span>i</span><span>));<br/></span><span>        </span><span>threeRandoms</span><span>.</span><span>subscribe</span><span>(</span><span>i </span>-&gt; <span>System</span><span>.</span><span>out</span><span>.</span><span>println</span><span>(</span><span>"Observer 2: " </span><span>+ </span><span>i</span><span>));<br/></span><span><br/></span><span>    }<br/></span><span><br/></span><span>    </span><span>public static int </span><span>randomInt</span><span>() {<br/></span><span>        </span><span>return </span><span>ThreadLocalRandom.current().nextInt(100000);<br/></span><span>    }<br/></span><span>}</span></pre>
<p><span>The output is as follows:</span></p>
<pre style="padding-left: 60px">Observer 1: 38895<br/>Observer 1: 36858<br/>Observer 1: 82955<br/>Observer 2: 55957<br/>Observer 2: 47394<br/>Observer 2: 16996</pre>
<p>What happens here is that the <kbd>Observable.range()</kbd> source will yield two separate emission generators, and each will coldly emit a separate stream for each <kbd>Observer</kbd>. Each stream also has its own separate <kbd>map()</kbd> instance, hence each <kbd>Observer</kbd> gets different random integers. You can visually see this structure of two separate streams in the following figure:</p>
<div class="CDPAlignCenter CDPAlign"><img height="268" width="233" class="image-border" src="assets/1177eebf-3c77-4e22-b990-12dcfd877448.png"/></div>
<div class="packt_figref CDPAlignCenter CDPAlign"><strong>Figure 5.1</strong> - Two separate streams of operations are created for each Observer</div>
<p>Say, you want to emit the same three random integers to both Observers. Your first instinct might be to call <kbd>publish()</kbd> after <kbd>Observable.range()</kbd> to yield a <kbd>ConnectableObservable</kbd>. Then, you may call the <kbd>map()</kbd> operator on it, followed by the Observers and a <kbd>connect()</kbd> call. But you will see that this does not achieve our desired result. Each <kbd>Observer</kbd> still gets three separate random integers:</p>
<pre style="padding-left: 60px"><span>import</span><span> </span><span>io.reactivex.</span><span>Observable</span><span>;<br/></span><span>import </span><span>io.reactivex.observables.</span><span>ConnectableObservable</span><span>;<br/>import java.util.concurrent.ThreadLocalRandom;<br/></span><span><br/></span><span>public class </span><span>Launcher </span><span>{<br/></span><span>    </span><span>public static void </span><span>main</span><span>(</span><span>String</span><span>[] </span><span>args</span><span>) {<br/></span><span><br/></span><span>        </span><span>ConnectableObservable</span><span>&lt;</span><span>Integer</span><span>&gt; </span><span>threeInts </span><span>= </span><span>Observable</span><span>.</span><span>range</span><span>(</span><span>1</span><span>,</span><span>3</span><span>).</span><span>publish</span><span>();<br/></span><span><br/></span><span>        </span><span>Observable</span><span>&lt;</span><span>Integer</span><span>&gt; </span><span>threeRandoms </span><span>= </span><span>threeInts</span><span>.</span><span>map</span><span>(</span><span>i </span>-&gt; <span>randomInt</span><span>());<br/></span><span><br/></span><span>        </span><span>threeRandoms</span><span>.</span><span>subscribe</span><span>(</span><span>i </span>-&gt; <span>System</span><span>.</span><span>out</span><span>.</span><span>println</span><span>(</span><span>"Observer 1: " </span><span>+ </span><span>i</span><span>));<br/></span><span>        </span><span>threeRandoms</span><span>.</span><span>subscribe</span><span>(</span><span>i </span>-&gt; <span>System</span><span>.</span><span>out</span><span>.</span><span>println</span><span>(</span><span>"Observer 2: " </span><span>+ </span><span>i</span><span>));<br/></span><span><br/></span><span>        </span><span>threeInts</span><span>.</span><span>connect</span><span>();<br/></span><span>    }<br/></span><span><br/></span><span>    </span><span>public static int </span><span>randomInt</span><span>() {<br/></span><span>        </span><span>return ThreadLocalRandom.current().nextInt(100000);<br/></span><span>    }<br/></span><span>}<br/></span></pre>
<p>The output is as follows:</p>
<pre style="padding-left: 60px">Observer 1: 99350<br/>Observer 2: 96343<br/>Observer 1: 4155<br/>Observer 2: 75273<br/>Observer 1: 14280<br/>Observer 2: 97638</pre>
<p>This occurred because we multicast <em>after</em> <kbd>Observable.range()</kbd>, but the multicasting happens before the <kbd>map()</kbd> operator. Even though we consolidated to one set of emissions coming from <kbd>Observable.range()</kbd>, each <kbd>Observer</kbd> is still going to get a separate stream at <kbd>map()</kbd>. Everything before <kbd>publish()</kbd> was consolidated into a single stream (or more technically, a single proxy <kbd>Observer</kbd>). But after <kbd>publish()</kbd>, it will fork into separate streams for each <kbd>Observer</kbd> again, as shown in the following figure:</p>
<div class="CDPAlignCenter CDPAlign"><img height="307" width="219" class="image-border" src="assets/c5e50532-6875-466d-8773-3a92168cc253.png"/></div>
<div class="CDPAlignCenter CDPAlign packt_figref">Figure 5.2 - Mulitcasting after Observable.range() will consolidate the interval emissions into a single stream before publish(), but will still fork to two separate streams after publish() for each Observer.</div>
<p>If we want to prevent the <kbd>map()</kbd> operator from yielding two separate streams for each <kbd>Observer</kbd>, we need to call <kbd>publish()</kbd> after <kbd>map()</kbd> instead:</p>
<pre style="padding-left: 60px"><span>import </span><span>io.reactivex.</span><span>Observable</span><span>;<br/></span><span>import </span><span>io.reactivex.observables.</span><span>ConnectableObservable</span><span>;<br/>import java.util.concurrent.ThreadLocalRandom;<br/></span><span><br/></span><span>public class </span><span>Launcher </span><span>{<br/></span><span>    </span><span>public static void </span><span>main</span><span>(</span><span>String</span><span>[] </span><span>args</span><span>) {<br/></span><span><br/></span><span>        </span><span>ConnectableObservable</span><span>&lt;</span><span>Integer</span><span>&gt; </span><span>threeRandoms </span><span>= </span><span>Observable</span><span>.</span><span>range</span><span>(</span><span>1</span><span>,</span><span>3</span><span>)<br/></span><span>                .</span><span>map</span><span>(</span><span>i </span>-&gt; <span>randomInt</span><span>()).</span><span>publish</span><span>();<br/></span><span><br/></span><span>        </span><span>threeRandoms</span><span>.</span><span>subscribe</span><span>(</span><span>i </span>-&gt; <span>System</span><span>.</span><span>out</span><span>.</span><span>println</span><span>(</span><span>"Observer 1: " </span><span>+ </span><span>i</span><span>));<br/></span><span>        </span><span>threeRandoms</span><span>.</span><span>subscribe</span><span>(</span><span>i </span>-&gt; <span>System</span><span>.</span><span>out</span><span>.</span><span>println</span><span>(</span><span>"Observer 2: " </span><span>+ </span><span>i</span><span>));<br/></span><span><br/></span><span>        </span><span>threeRandoms</span><span>.</span><span>connect</span><span>();<br/></span><span>    }<br/></span><span><br/></span><span>    </span><span>public static int </span><span>randomInt</span><span>() {<br/></span><span>        </span><span>return ThreadLocalRandom.current().nextInt(100000);<br/></span><span>    }<br/></span><span>}<br/></span></pre>
<p><span>The output is as follows:</span></p>
<pre style="padding-left: 60px">Observer 1: 90125<br/>Observer 2: 90125<br/>Observer 1: 79156<br/>Observer 2: 79156<br/>Observer 1: 76782<br/>Observer 2: 76782</pre>
<p>That is better! Each <kbd>Observer</kbd> got the same three random integers, and we have effectively multicast the entire operation right before the two Observers, as shown in the following figure. We now have a single stream instance throughout the entire chain since <kbd>map()</kbd> is now behind, not in front, of <kbd>publish()</kbd>:</p>
<div class="CDPAlignCenter CDPAlign"><img height="281" width="194" class="image-border" src="assets/5dc580de-2dd5-4c4b-8606-a471a3f8840b.png"/></div>
<div class="packt_figref CDPAlignCenter CDPAlign">Figure 5.3 - A fully multicast operation that guarantees both Observers get the same emissions since all operators are behind the publish() call</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">When to multicast</h1>
                </header>
            
            <article>
                
<p>Multicasting is helpful in preventing redundant work being done by multiple Observers and instead makes all Observers subscribe to a single stream, at least to the point where they have operations in common. You may do this to increase performance, reducing memory and CPU usage, or simply because your business logic requires pushing the same emissions to all Observers.</p>
<p>Data-driven cold Observables should only be multicast when you are doing so for performance reasons and have multiple Observers receiving the same data simultaneously. Remember that multicasting creates hot <kbd>ConnectableObservables</kbd>, and you have to be careful and time the <kbd>connect()</kbd> call so data is not missed by Observers. Typically in your API, keep your cold Observables cold and call <kbd>publish()</kbd> when you need to make them hot.</p>
<p>Even if your source <kbd>Observable</kbd> is hot (such as a UI event in JavaFX or Android), putting operators against that <kbd>Observable</kbd> can cause redundant work and listeners. It is not necessary to multicast when there is only a single <kbd>Observer</kbd> (and multicasting can cause unnecessary overhead). But if there are multiple Observers, you need to find the proxy point where you can multicast and consolidate the upstream operations. This point is typically the boundary where Observers have common operations upstream and diverge into different operations downstream.</p>
<p>For instance, you may have one <kbd>Observer</kbd> that prints the random integers but another one that finds the sum with <kbd>reduce()</kbd>. At this point, that single stream should, in fact, fork into two separate streams because they are no longer redundant and doing different work, as shown in the following <span>code snippet</span>:</p>
<pre style="padding-left: 60px"><span>import</span><span> </span><span>io.reactivex.</span><span>Observable</span><span>;<br/></span><span>import </span><span>io.reactivex.observables.</span><span>ConnectableObservable</span><span>;<br/>import java.util.concurrent.ThreadLocalRandom;<br/></span><span><br/></span><span>public class </span><span>Launcher </span><span>{<br/></span><span>    </span><span>public static void </span><span>main</span><span>(</span><span>String</span><span>[] </span><span>args</span><span>) {<br/></span><span><br/></span><span>        </span><span>ConnectableObservable</span><span>&lt;</span><span>Integer</span><span>&gt; </span><span>threeRandoms </span><span>= </span><span>Observable</span><span>.</span><span>range</span><span>(</span><span>1</span><span>,</span><span>3</span><span>)<br/></span><span>                .</span><span>map</span><span>(</span><span>i </span>-&gt; <span>randomInt</span><span>()).</span><span>publish</span><span>();<br/></span><span><br/></span><span>        </span><span>//Observer 1 - print each random integer<br/></span><span>        </span><span>threeRandoms</span><span>.</span><span>subscribe</span><span>(</span><span>i </span>-&gt; <span>System</span><span>.</span><span>out</span><span>.</span><span>println</span><span>(</span><span>"Observer 1: " </span><span>+ </span><span>i</span><span>));<br/></span><span><br/></span><span>        </span><span>//Observer 2 - sum the random integers, then print<br/></span><span>        </span><span>threeRandoms</span><span>.</span><span>reduce</span><span>(</span><span>0</span><span>, (</span><span>total</span><span>,</span><span>next</span><span>) </span>-&gt; <span>total </span><span>+ </span><span>next</span><span>)<br/></span><span>                .</span><span>subscribe</span><span>(</span><span>i </span>-&gt; <span>System</span><span>.</span><span>out</span><span>.</span><span>println</span><span>(</span><span>"Observer 2: " </span><span>+ </span><span>i</span><span>));<br/></span><span><br/></span><span>        </span><span>threeRandoms</span><span>.</span><span>connect</span><span>();<br/></span><span>    }<br/></span><span><br/></span><span>    </span><span>public static int </span><span>randomInt</span><span>() {<br/></span><span>        </span><span>r</span><span>eturn ThreadLocalRandom.current().nextInt(100000);<br/></span><span>    }<br/></span><span>}</span></pre>
<p><span>The output is as follows:</span></p>
<pre style="padding-left: 60px">Observer 1: 40021<br/>Observer 1: 78962<br/>Observer 1: 46146<br/>Observer 2: 165129</pre>
<p class="CDPAlignCenter CDPAlign CDPAlignLeft">Here is a visual diagram showing the common operations being multicasted:</p>
<div class="CDPAlignCenter CDPAlign"><strong><img height="265" width="158" class="image-border" src="assets/b0fc9938-a5c9-4d07-899c-7346de057c9f.png"/></strong></div>
<div class="packt_figref CDPAlignCenter CDPAlign">Figure 5.4 - Common operations that are shared between both Observers are put behind publish(), but divergent operations happen after publish()</div>
<p>With a thorough understanding of <kbd>ConnectableObservable</kbd> and multicasting under our belt, we will move on to some convenience operators that help streamline multicasting.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Automatic connection</h1>
                </header>
            
            <article>
                
<p>There are definitely times you will want to manually call <kbd>connect()</kbd> on <kbd>ConnectableObservable</kbd> to precisely control when the emissions start firing. There are convenient operators that automatically call <kbd>connect()</kbd> for you, but with this convenience, it is important to have awareness of their subscribe timing behaviors. Allowing an <kbd>Observable</kbd> to dynamically connect can backfire if you are not careful, as emissions can be missed by Observers.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">autoConnect()</h1>
                </header>
            
            <article>
                
<p>The <kbd>autoConnect()</kbd> operator on <kbd>ConnectableObservable</kbd> can be quite handy. For a given <kbd>ConnectableObservable&lt;T&gt;</kbd>, calling <kbd>autoConnect()</kbd> will return an <kbd>Observable&lt;T&gt;</kbd> that will automatically call <kbd>connect()</kbd> after a specified number of Observers are subscribed. Since our previous example had two Observers, we can streamline it by calling <kbd>autoConnect(2)</kbd> immediately after <kbd>publish()</kbd>:</p>
<pre style="padding-left: 60px"><span>import </span><span>io.reactivex.</span><span>Observable</span><span>;<br/>import java.util.concurrent.ThreadLocalRandom;<br/></span><span><br/></span><span>public class </span><span>Launcher </span><span>{<br/></span><span>    </span><span>public static void </span><span>main</span><span>(</span><span>String</span><span>[] </span><span>args</span><span>) {<br/></span><span><br/></span><span>        </span><span>Observable</span><span>&lt;</span><span>Integer</span><span>&gt; </span><span>threeRandoms </span><span>= </span><span>Observable</span><span>.</span><span>range</span><span>(</span><span>1</span><span>,</span><span>3</span><span>)<br/></span><span>                .</span><span>map</span><span>(</span><span>i </span>-&gt; <span>randomInt</span><span>())<br/>                .</span><span>publish</span><span>()<br/>                .</span><span>autoConnect</span><span>(</span><span>2</span><span>);<br/></span><span><br/></span><span>        </span><span>//Observer 1 - print each random integer<br/></span><span>        </span><span>threeRandoms</span><span>.</span><span>subscribe</span><span>(</span><span>i </span>-&gt; <span>System</span><span>.</span><span>out</span><span>.</span><span>println</span><span>(</span><span>"Observer 1: " </span><span>+ </span><span>i</span><span>));<br/></span><span><br/></span><span>        </span><span>//Observer 2 - sum the random integers, then print<br/></span><span>        </span><span>threeRandoms</span><span>.</span><span>reduce</span><span>(</span><span>0</span><span>, (</span><span>total</span><span>,</span><span>next</span><span>) </span>-&gt; <span>total </span><span>+ </span><span>next</span><span>)<br/></span><span>                .</span><span>subscribe</span><span>(</span><span>i </span>-&gt; <span>System</span><span>.</span><span>out</span><span>.</span><span>println</span><span>(</span><span>"Observer 2: " </span><span>+ </span><span>i</span><span>));</span><span><br/></span><span>    }<br/></span><span><br/></span><span>    </span><span>public static int </span><span>randomInt</span><span>() {<br/></span><span>        </span><span>return ThreadLocalRandom.current().nextInt(100000);<br/></span><span>    }<br/></span><span>}</span></pre>
<p><span>The output is as follows:</span></p>
<pre style="padding-left: 60px">Observer 1: 83428<br/>Observer 1: 77336<br/>Observer 1: 64970<br/>Observer 2: 225734</pre>
<p>This saved us the trouble of having to save <kbd>ConnectableObservable</kbd> and call its <kbd>connect()</kbd> method later. Instead, it will start firing when it gets <kbd>2</kbd> subscriptions, which we have planned and specified as an argument in advance. Obviously, this does not work well when you have an unknown number of Observers and you want all of them to receive all emissions.</p>
<p>Even when all downstream Observers finish or dispose, <kbd>autoConnect()</kbd> will persist its subscription to the source. If the source is finite and disposes, it will not subscribe to it again when a new <kbd>Observer</kbd> subscribes downstream. If we add a third <kbd>Observer</kbd> to our example but keep <kbd>autoConnect()</kbd> specified at <kbd>2</kbd> instead of <kbd>3</kbd>, it is likely that the third <kbd>Observer</kbd> is going to miss the emissions:</p>
<pre style="padding-left: 60px"><span>import</span><span> </span><span>io.reactivex.</span><span>Observable</span><span>;<br/>import java.util.concurrent.ThreadLocalRandom;<br/></span><span><br/></span><span>public class </span><span>Launcher </span><span>{<br/></span><span>    </span><span>public static void </span><span>main</span><span>(</span><span>String</span><span>[] </span><span>args</span><span>) {<br/></span><span><br/></span><span>        </span><span>Observable</span><span>&lt;</span><span>Integer</span><span>&gt; </span><span>threeRandoms </span><span>= </span><span>Observable</span><span>.</span><span>range</span><span>(</span><span>1</span><span>,</span><span>3</span><span>)<br/></span><span>                .</span><span>map</span><span>(</span><span>i </span>-&gt; <span>randomInt</span><span>()).</span><span>publish</span><span>().</span><span>autoConnect</span><span>(</span><span>2</span><span>);<br/></span><span><br/></span><span>        </span><span>//Observer 1 - print each random integer<br/></span><span>        </span><span>threeRandoms</span><span>.</span><span>subscribe</span><span>(</span><span>i </span>-&gt; <span>System</span><span>.</span><span>out</span><span>.</span><span>println</span><span>(</span><span>"Observer 1: " </span><span>+ </span><span>i</span><span>));<br/></span><span><br/></span><span>        </span><span>//Observer 2 - sum the random integers, then print<br/></span><span>        </span><span>threeRandoms</span><span>.</span><span>reduce</span><span>(</span><span>0</span><span>, (</span><span>total</span><span>,</span><span>next</span><span>) </span>-&gt; <span>total </span><span>+ </span><span>next</span><span>)<br/></span><span>                .</span><span>subscribe</span><span>(</span><span>i </span>-&gt; <span>System</span><span>.</span><span>out</span><span>.</span><span>println</span><span>(</span><span>"Observer 2: " </span><span>+ </span><span>i</span><span>));<br/></span><span><br/></span><span>        </span><span>//Observer 3 - receives nothing<br/></span><span>        </span><span>threeRandoms</span><span>.</span><span>subscribe</span><span>(i</span><span> -&gt; System.out.println("Observer 3: " + i</span><span>);<br/></span><span>    }<br/></span><span><br/></span><span>    </span><span>public static int </span><span>randomInt</span><span>() {<br/></span><span>        </span><span>return ThreadLocalRandom.current().nextInt(100000);<br/></span><span>    }<br/></span><span>}</span></pre>
<p><span>The output is as follows:</span></p>
<pre style="padding-left: 60px">Observer 1: 8198<br/>Observer 1: 31718<br/>Observer 1: 97915<br/>Observer 2: 137831</pre>
<p>Note that if you pass no argument for <kbd>numberOfSubscribers</kbd>, it will default to <kbd>1</kbd>. This can be helpful if you want it to start firing on the first subscription and do not care about any subsequent Observers missing previous emissions. Here, we <kbd>publish</kbd> and <kbd>autoConnect</kbd> the <kbd>Observable.interval()</kbd>. The first <kbd>Observer</kbd> starts the firing of emissions, and 3 seconds later, another <kbd>Observer</kbd> comes in but misses the first few emissions. But it does receive the live emissions from that point on:</p>
<pre style="padding-left: 60px"><span>import</span><span> </span><span>io.reactivex.</span><span>Observable</span><span>;<br/></span><span>import </span><span>java.util.concurrent.</span><span>TimeUnit</span><span>;<br/></span><span><br/></span><span>public class </span><span>Launcher </span><span>{<br/></span><span>    </span><span>public static void </span><span>main</span><span>(</span><span>String</span><span>[] </span><span>args</span><span>) {<br/></span><span><br/></span><span>        </span><span>Observable</span><span>&lt;</span><span>Long</span><span>&gt; </span><span>seconds </span><span>=<br/></span><span>                </span><span>Observable</span><span>.</span><span>interval</span><span>(</span><span>1</span><span>, </span><span>TimeUnit</span><span>.</span><span>SECONDS</span><span>)<br/></span><span>                        .</span><span>publish</span><span>()<br/></span><span>                        .</span><span>autoConnect</span><span>();<br/></span><span><br/></span><span>        </span><span>//Observer 1<br/></span><span>        </span><span>seconds</span><span>.</span><span>subscribe</span><span>(i</span><span> </span>-&gt; <span>System</span><span>.</span><span>out</span><span>.</span><span>println</span><span>(</span><span>"Observer 1: " </span><span>+ </span><span>i</span><span>));<br/></span><span><br/></span><span>        </span><span>sleep</span><span>(</span><span>3000</span><span>);<br/></span><span><br/></span><span>        </span><span>//Observer 2<br/></span><span>        </span><span>seconds</span><span>.</span><span>subscribe</span><span>(i</span><span> </span>-&gt; <span>System</span><span>.</span><span>out</span><span>.</span><span>println</span><span>(</span><span>"Observer 2: " </span><span>+ </span><span>i</span><span>));<br/></span><span><br/></span><span>        </span><span>sleep</span><span>(</span><span>3000</span><span>);<br/></span><span>    }<br/></span><span>    </span><span>public static void </span><span>sleep</span><span>(</span><span>long </span><span>millis</span><span>) {<br/></span><span>        </span><span>try </span><span>{<br/></span><span>            </span><span>Thread</span><span>.</span><span>sleep</span><span>(</span><span>millis</span><span>);<br/></span><span>        } </span><span>catch </span><span>(</span><span>InterruptedException </span><span>e</span><span>) {<br/></span><span>            </span><span>e</span><span>.</span><span>printStackTrace</span><span>();<br/></span><span>        }<br/></span><span>    }<br/></span><span>}</span></pre>
<p><span>The output is as follows:</span></p>
<pre style="padding-left: 60px">Observer 1: 0<br/>Observer 1: 1<br/>Observer 1: 2<br/>Observer 1: 3<br/>Observer 2: 3<br/>Observer 1: 4<br/>Observer 2: 4<br/>Observer 1: 5<br/>Observer 2: 5</pre>
<p>If you pass <kbd>0</kbd> to <kbd>autoConnect()</kbd> for the <kbd>numberOfSubscribers</kbd> argument, it will start firing immediately and not wait for any <kbd>Observers</kbd>. This can be handy to start firing emissions immediately without waiting for any Observers.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">refCount() and share()</h1>
                </header>
            
            <article>
                
<p>The <kbd>refCount()</kbd> operator on <kbd>ConnectableObservable</kbd> is similar to <kbd>autoConnect(1)</kbd>,<strong> </strong>which fires  after getting one subscription. But there is one important difference; when it has no Observers anymore, it will dispose of itself and start over when a new one comes in. It does not persist the subscription to the source when it has no more Observers, and when another <kbd>Observer</kbd> follows, it will essentially "start over".</p>
<p>Look at this example: we have <kbd>Observable.interval()</kbd> emitting every second, and it is multicast with <kbd>refCount()</kbd>. <kbd>Observer 1</kbd> takes five emissions, and <kbd>Observer 2</kbd> takes two emissions. We stagger their subscriptions with our <kbd>sleep()</kbd> function to put three-second gaps between them. Because these two subscriptions are finite due to the <kbd>take()</kbd> operators, they should be terminated by the time <kbd>Observer 3</kbd> comes in, and there should no longer be any previous Observers. Note how <kbd>Observer 3</kbd> has started over with a fresh set of intervals starting at <kbd>0</kbd>! Let's take a look at the following code snippet:</p>
<pre style="padding-left: 60px"><span>import </span><span>io.reactivex.</span><span>Observable</span><span>;<br/></span><span>import </span><span>java.util.concurrent.</span><span>TimeUnit</span><span>;<br/></span><span><br/></span><span>public class </span><span>Launcher </span><span>{<br/></span><span>    </span><span>public static void </span><span>main</span><span>(</span><span>String</span><span>[] </span><span>args</span><span>) {<br/></span><span><br/></span><span>        </span><span>Observable</span><span>&lt;</span><span>Long</span><span>&gt; </span><span>seconds </span><span>=<br/></span><span>                </span><span>Observable</span><span>.</span><span>interval</span><span>(</span><span>1</span><span>, </span><span>TimeUnit</span><span>.</span><span>SECONDS</span><span>)<br/></span><span>                        .</span><span>publish</span><span>()<br/></span><span>                        .</span><span>refCount</span><span>();<br/></span><span><br/></span><span>        </span><span>//Observer 1<br/></span><span>        </span><span>seconds</span><span>.</span><span>take</span><span>(</span><span>5</span><span>)<br/></span><span>                .</span><span>subscribe</span><span>(</span><span>l </span>-&gt; <span>System</span><span>.</span><span>out</span><span>.</span><span>println</span><span>(</span><span>"Observer 1: " </span><span>+ </span><span>l</span><span>));<br/></span><span><br/></span><span>        </span><span>sleep</span><span>(</span><span>3000</span><span>);<br/></span><span><br/></span><span>        </span><span>//Observer 2<br/></span><span>        </span><span>seconds</span><span>.</span><span>take</span><span>(</span><span>2</span><span>)<br/></span><span>                .</span><span>subscribe</span><span>(</span><span>l </span>-&gt; <span>System</span><span>.</span><span>out</span><span>.</span><span>println</span><span>(</span><span>"Observer 2: " </span><span>+ </span><span>l</span><span>));<br/></span><span><br/></span><span>        </span><span>sleep</span><span>(</span><span>3000</span><span>);<br/></span><span>        </span><span>//there should be no more Observers at this point<br/></span><span><br/></span><span>        //Observer 3<br/></span><span>        </span><span>seconds</span><span>.</span><span>subscribe</span><span>(</span><span>l </span>-&gt; <span>System</span><span>.</span><span>out</span><span>.</span><span>println</span><span>(</span><span>"Observer 3: " </span><span>+ </span><span>l</span><span>));<br/></span><span><br/></span><span>        </span><span>sleep</span><span>(</span><span>3000</span><span>);<br/></span><span>    }<br/></span><span>    </span><span>public static void </span><span>sleep</span><span>(</span><span>long </span><span>millis</span><span>) {<br/></span><span>        </span><span>try </span><span>{<br/></span><span>            </span><span>Thread</span><span>.</span><span>sleep</span><span>(</span><span>millis</span><span>);<br/></span><span>        } </span><span>catch </span><span>(</span><span>InterruptedException </span><span>e</span><span>) {<br/></span><span>            </span><span>e</span><span>.</span><span>printStackTrace</span><span>();<br/></span><span>        }<br/></span><span>    }<br/></span><span>}</span></pre>
<p><span>The output is as follows:</span></p>
<pre style="padding-left: 60px">Observer 1: 0<br/>Observer 1: 1<br/>Observer 1: 2<br/>Observer 1: 3<br/>Observer 2: 3<br/>Observer 1: 4<br/>Observer 2: 4<br/>Observer 3: 0<br/>Observer 3: 1<br/>Observer 3: 2</pre>
<p>Using <kbd>refCount()</kbd> can be helpful to multicast between multiple Observers but dispose of the upstream connection when no downstream Observers are present anymore. You can also use an alias for <kbd>publish().refCount()</kbd> using the <kbd>share()</kbd> operator. This will accomplish the same result:</p>
<pre style="padding-left: 60px"><span>Observable</span><span>&lt;</span><span>Long</span><span>&gt; </span><span>seconds </span><span>=<br/></span><span>        </span><span>Observable</span><span>.</span><span>interval</span><span>(</span><span>1</span><span>, </span><span>TimeUnit</span><span>.</span><span>SECONDS</span><span>)</span><span>.</span><span>share</span><span>();
</span></pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Replaying and caching</h1>
                </header>
            
            <article>
                
<p>Multicasting also allows us to cache values that are shared across multiple Observers. This may sound surprising, but when you think about it long enough, you may realize this makes sense. If we are sharing data across multiple Observers, it makes sense that any caching feature would be shared across Observers too. Replaying and caching data is a multicasting activity, and we will explore how to do it safely and efficiently with RxJava.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Replaying</h1>
                </header>
            
            <article>
                
<p>The <kbd>replay()</kbd> operator is a powerful way to hold onto previous emissions within a certain scope and re-emit them when a new <kbd>Observer</kbd> comes in. It will return a <kbd>ConnectableObservable</kbd> that will both multicast emissions as well as emit previous emissions defined in a scope. Previous emissions it caches will fire immediately to a new <kbd>Observer</kbd> so it is caught up, and then it will fire current emissions from that point forward.</p>
<p>Let's start with a <kbd>replay()</kbd> with no arguments. This will replay all previous emissions to tardy Observers, and then emit current emissions as soon as the tardy <kbd>Observer</kbd> is caught up. If we use <kbd>Observable.interval()</kbd> to emit every second, we can call <kbd>replay()</kbd> on it to multicast and replay previous integer emissions. Since <kbd>replay()</kbd> returns <kbd>ConnectableObservable</kbd>, let's use <kbd>autoConnect()</kbd> so it starts firing on the first subscription. After 3 seconds, we will bring in a second <kbd>Observer</kbd>. Look closely at what happens:</p>
<pre style="padding-left: 60px"><span>import</span><span> </span><span>io.reactivex.</span><span>Observable</span><span>;<br/></span><span>import </span><span>java.util.concurrent.</span><span>TimeUnit</span><span>;<br/></span><span><br/></span><span>public class </span><span>Launcher </span><span>{<br/></span><span>    </span><span>public static void </span><span>main</span><span>(</span><span>String</span><span>[] </span><span>args</span><span>) {<br/></span><span><br/></span><span>        </span><span>Observable</span><span>&lt;</span><span>Long</span><span>&gt; </span><span>seconds </span><span>=<br/></span><span>                </span><span>Observable</span><span>.</span><span>interval</span><span>(</span><span>1</span><span>, </span><span>TimeUnit</span><span>.</span><span>SECONDS</span><span>)<br/></span><span>                    .</span><span>replay</span><span>()<br/></span><span>                    .</span><span>autoConnect</span><span>();<br/></span><span><br/></span><span>        </span><span>//Observer 1<br/></span><span>        </span><span>seconds</span><span>.</span><span>subscribe</span><span>(</span><span>l </span>-&gt; <span>System</span><span>.</span><span>out</span><span>.</span><span>println</span><span>(</span><span>"Observer 1: " </span><span>+ </span><span>l</span><span>));<br/></span><span><br/></span><span>        </span><span>sleep</span><span>(</span><span>3000</span><span>);<br/></span><span><br/></span><span>        </span><span>//Observer 2<br/></span><span>        </span><span>seconds</span><span>.</span><span>subscribe</span><span>(</span><span>l </span>-&gt; <span>System</span><span>.</span><span>out</span><span>.</span><span>println</span><span>(</span><span>"Observer 2: " </span><span>+ </span><span>l</span><span>));<br/></span><span><br/></span><span>        </span><span>sleep</span><span>(</span><span>3000</span><span>);<br/></span><span>    }<br/></span><span>    </span><span>public static void </span><span>sleep</span><span>(</span><span>long </span><span>millis</span><span>) {<br/></span><span>        </span><span>try </span><span>{<br/></span><span>            </span><span>Thread</span><span>.</span><span>sleep</span><span>(</span><span>millis</span><span>);<br/></span><span>        } </span><span>catch </span><span>(</span><span>InterruptedException </span><span>e</span><span>) {<br/></span><span>            </span><span>e</span><span>.</span><span>printStackTrace</span><span>();<br/></span><span>        }<br/></span><span>    }<br/></span><span>}</span></pre>
<p><span>The output is as follows:</span></p>
<pre style="padding-left: 60px">Observer 1: 0<br/>Observer 1: 1<br/>Observer 1: 2<br/>Observer 2: 0<br/>Observer 2: 1<br/>Observer 2: 2<br/>Observer 1: 3<br/>Observer 2: 3<br/>Observer 1: 4<br/>Observer 2: 4<br/>Observer 1: 5<br/>Observer 2: 5</pre>
<p>Did you see that? After 3 seconds, <kbd>Observer 2</kbd> came in and immediately received the first three emissions it missed: <kbd>0</kbd>, <kbd>1</kbd>, and <kbd>2</kbd>. After that, it receives the same emissions as <kbd>Observer 1</kbd> going forward. Just note that this can get expensive with memory, as <kbd>replay()</kbd> will keep caching all emissions it receives. If the source is infinite or you only care about the last previous emissions, you might want to specify a <kbd>bufferSize</kbd> argument to limit only replaying a certain number of last emissions. If we called <kbd>replay(2)</kbd> on our second <kbd>Observer</kbd> to cache the last two emissions, it will not get 0, but it will receive <kbd>1</kbd> and <kbd>2</kbd>. The <kbd>0</kbd> fell out of that window and was released from the cache as soon as <kbd>2</kbd> came in.</p>
<p><span>The output is as follows:</span></p>
<pre style="padding-left: 60px">Observer 1: 0<br/>Observer 1: 1<br/>Observer 1: 2<br/>Observer 2: 1<br/>Observer 2: 2<br/>Observer 1: 3<br/>Observer 2: 3<br/>Observer 1: 4<br/>Observer 2: 4<br/>Observer 1: 5<br/>Observer 2: 5</pre>
<p>Note that if you always want to persist the cached values in your <kbd>replay()</kbd>even if there are no subscriptions, use it in conjunction with <kbd>autoConnect()</kbd>, not <kbd>refCount()</kbd>. If we emit our <kbd>Alpha</kbd> through <kbd>Epsilon</kbd> strings and use <kbd>replay(1).autoConnect()</kbd> to hold on to the last value, our second <kbd>Observer</kbd> will only receive the last value, as expected:</p>
<pre style="padding-left: 60px"><span>import</span><span> </span><span>io.reactivex.</span><span>Observable</span><span>;<br/></span><span><br/></span><span>public class </span><span>Launcher </span><span>{<br/></span><span>    </span><span>public static void </span><span>main</span><span>(</span><span>String</span><span>[] </span><span>args</span><span>) {<br/></span><span><br/></span><span>        </span><span>Observable</span><span>&lt;</span><span>String</span><span>&gt; </span><span>source </span><span>=<br/></span><span>                </span><span>Observable</span><span>.</span><span>just</span><span>(</span><span>"Alpha"</span><span>, </span><span>"Beta"</span><span>, </span><span>"Gamma"</span><span>, <br/></span><span>"Delta"</span><span>, </span><span>"Epsilon"</span><span>)<br/></span><span>                    .</span><span>replay</span><span>(</span><span>1</span><span>)<br/></span><span>                    .</span><span>autoConnect</span><span>();<br/></span><span><br/></span><span>        </span><span>//Observer 1<br/></span><span>        </span><span>source</span><span>.</span><span>subscribe</span><span>(</span><span>l </span>-&gt; <span>System</span><span>.</span><span>out</span><span>.</span><span>println</span><span>(</span><span>"Observer 1: " </span><span>+ </span><span>l</span><span>));</span><span><br/></span><span><br/></span><span>        </span><span>//Observer 2<br/></span><span>        </span><span>source</span><span>.</span><span>subscribe</span><span>(</span><span>l </span>-&gt; <span>System</span><span>.</span><span>out</span><span>.</span><span>println</span><span>(</span><span>"Observer 2: " </span><span>+ </span><span>l</span><span>));</span><span><br/></span><span>    }</span><span><br/></span><span>}</span></pre>
<p><span>The output is as follows:</span></p>
<pre style="padding-left: 60px">Observer 1: Alpha<br/>Observer 1: Beta<br/>Observer 1: Gamma<br/>Observer 1: Delta<br/>Observer 1: Epsilon<br/>Observer 2: Epsilon</pre>
<p>Make a modification here to use <kbd>refCount()</kbd> instead of <kbd>autoConnect()</kbd> and see what happens:</p>
<pre style="padding-left: 60px"><span>Observable</span><span>&lt;</span><span>String</span><span>&gt; </span><span>source </span><span>=<br/></span><span>        </span><span>Observable</span><span>.</span><span>just</span><span>(</span><span>"Alpha"</span><span>, </span><span>"Beta"</span><span>, </span><span>"Gamma"</span><span>, </span><span>"Delta"</span><span>, </span><span>"Epsilon"</span><span>)<br/></span><span>            .</span><span>replay</span><span>(</span><span>1</span><span>)<br/></span><span>            .</span><span>refCount</span><span>();</span></pre>
<p><span>The output is as follows:</span></p>
<pre style="padding-left: 60px">Observer 1: Alpha<br/>Observer 1: Beta<br/>Observer 1: Gamma<br/>Observer 1: Delta<br/>Observer 1: Epsilon<br/>Observer 2: Alpha<br/>Observer 2: Beta<br/>Observer 2: Gamma<br/>Observer 2: Delta<br/>Observer 2: Epsilon</pre>
<p>What happened here is that <kbd>refCount()</kbd> causes the cache (and the entire chain) to dispose of and reset the moment <kbd>Observer 1</kbd> is done, as there are no more Observers. When <kbd>Observer 2</kbd> came in, it starts all over and emits everything just like it is the first Observer, and another cache is built. This may not be desirable, so you may consider using <kbd>autoConnect()</kbd> to persist the  state of <kbd>replay()</kbd> and not have it dispose of when no Observers are present.</p>
<p>There are other overloads for <kbd>replay()</kbd>, particularly a time-based window you can specify. Here, we construct an <kbd>Observable.interval()</kbd> that emits every 300 milliseconds and subscribe to it. We also map each emitted consecutive integer into the elapsed milliseconds. We will replay only the last 1 second of emissions for each new <kbd>Observer</kbd>, which we will bring in after 2 seconds:</p>
<pre style="padding-left: 60px"><span>import</span><span> </span><span>io.reactivex.</span><span>Observable</span><span>;<br/></span><span>import </span><span>java.util.concurrent.</span><span>TimeUnit</span><span>;<br/></span><span><br/></span><span>public class </span><span>Launcher </span><span>{<br/></span><span>    </span><span>public static void </span><span>main</span><span>(</span><span>String</span><span>[] </span><span>args</span><span>) {<br/></span><span><br/></span><span>        </span><span>Observable</span><span>&lt;</span><span>Long</span><span>&gt; </span><span>seconds </span><span>=<br/></span><span>                </span><span>Observable</span><span>.</span><span>interval</span><span>(</span><span>300</span><span>, </span><span>TimeUnit</span><span>.</span><span>MILLISECONDS</span><span>)<br/></span><span>                        .</span><span>map</span><span>(</span><span>l </span>-&gt; <span>(</span><span>l </span><span>+ </span><span>1</span><span>) </span><span>* </span><span>300</span><span>) </span><span>// map to elapsed milliseconds<br/></span><span>                        </span><span>.</span><span>replay</span><span>(</span><span>1</span><span>, </span><span>TimeUnit</span><span>.</span><span>SECONDS</span><span>)<br/></span><span>                        .</span><span>autoConnect</span><span>();<br/></span><span><br/></span><span>        </span><span>//Observer 1<br/></span><span>        </span><span>seconds</span><span>.</span><span>subscribe</span><span>(</span><span>l </span>-&gt; <span>System</span><span>.</span><span>out</span><span>.</span><span>println</span><span>(</span><span>"Observer 1: " </span><span>+ </span><span>l</span><span>));<br/></span><span><br/></span><span>        </span><span>sleep</span><span>(</span><span>2000</span><span>);<br/></span><span><br/></span><span>        </span><span>//Observer 2<br/></span><span>        </span><span>seconds</span><span>.</span><span>subscribe</span><span>(</span><span>l </span>-&gt; <span>System</span><span>.</span><span>out</span><span>.</span><span>println</span><span>(</span><span>"Observer 2: " </span><span>+ </span><span>l</span><span>));<br/></span><span><br/></span><span>        </span><span>sleep</span><span>(</span><span>1000</span><span>);<br/></span><span>    }<br/></span><span>    </span><span>public static void </span><span>sleep</span><span>(</span><span>long </span><span>millis</span><span>) {<br/></span><span>        </span><span>try </span><span>{<br/></span><span>            </span><span>Thread</span><span>.</span><span>sleep</span><span>(</span><span>millis</span><span>);<br/></span><span>        } </span><span>catch </span><span>(</span><span>InterruptedException </span><span>e</span><span>) {<br/></span><span>            </span><span>e</span><span>.</span><span>printStackTrace</span><span>();<br/></span><span>        }<br/></span><span>    }<br/></span><span>}</span></pre>
<p><span>The output is as follows:</span></p>
<pre style="padding-left: 60px">Observer 1: 300<br/>Observer 1: 600<br/>Observer 1: 900<br/>Observer 1: 1200<br/>Observer 1: 1500<br/>Observer 1: 1800<br/>Observer 2: 1500<br/>Observer 2: 1800<br/>Observer 1: 2100<br/>Observer 2: 2100<br/>Observer 1: 2400<br/>Observer 2: 2400<br/>Observer 1: 2700<br/>Observer 2: 2700<br/>Observer 1: 3000<br/>Observer 2: 3000</pre>
<p>Look closely at the output, and you will see that when <kbd>Observer 2</kbd> comes in, it immediately receives emissions that happened in the last second, which were 1500 and 1800. After these two values are replayed, it receives the same emissions as <kbd>Observer 1</kbd> from that point on.</p>
<p>You can also specify a <kbd>bufferSize</kbd> argument on top of a time interval, so only a certain number of last emissions are buffered within that time period. If we modify our example to only replay one emission that occurred within the last second, it should only replay <kbd>1800</kbd> to <kbd>Observer 2</kbd>:</p>
<pre style="padding-left: 60px"><span>Observable</span><span>&lt;</span><span>Long</span><span>&gt; </span><span>seconds </span><span>=<br/></span><span>        </span><span>Observable</span><span>.</span><span>interval</span><span>(</span><span>300</span><span>, </span><span>TimeUnit</span><span>.</span><span>MILLISECONDS</span><span>)<br/></span><span>                .</span><span>map</span><span>(</span><span>l </span>-&gt; <span>(</span><span>l </span><span>+ </span><span>1</span><span>) </span><span>* </span><span>300</span><span>) </span><span>// map to elapsed milliseconds<br/></span><span>                </span><span>.</span><span>replay</span><span>(</span><span>1</span><span>, </span><span>1</span><span>, </span><span>TimeUnit</span><span>.</span><span>SECONDS</span><span>)<br/></span><span>                .</span><span>autoConnect</span><span>();<br/></span></pre>
<p><span>The output is as follows:</span></p>
<pre style="padding-left: 60px">Observer 1: 300<br/>Observer 1: 600<br/>Observer 1: 900<br/>Observer 1: 1200<br/>Observer 1: 1500<br/>Observer 1: 1800<br/>Observer 2: 1800<br/>Observer 1: 2100<br/>Observer 2: 2100<br/>Observer 1: 2400<br/>Observer 2: 2400<br/>Observer 1: 2700<br/>Observer 2: 2700<br/>Observer 1: 3000<br/>Observer 2: 3000</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Caching</h1>
                </header>
            
            <article>
                
<p>When you want to cache all emissions indefinitely for the long term and do not need to control the subscription behavior to the source with <kbd>ConnectableObservable</kbd>, you can use the <kbd>cache()</kbd> operator. It will subscribe to the source on the first downstream <kbd>Observer</kbd> that subscribes and hold all values indefinitely. This makes it an unlikely candidate for infinite Observables or large amounts of data that could tax your memory:</p>
<pre style="padding-left: 60px"><span>import</span><span> </span><span>io.reactivex.</span><span>Observable</span><span>;<br/></span><span><br/></span><span>public class </span><span>Launcher </span><span>{<br/></span><span>    </span><span>public static void </span><span>main</span><span>(</span><span>String</span><span>[] </span><span>args</span><span>) {<br/></span><span><br/></span><span>        </span><span>Observable</span><span>&lt;</span><span>Integer</span><span>&gt; </span><span>cachedRollingTotals </span><span>=<br/></span><span>                </span><span>Observable</span><span>.</span><span>just</span><span>(</span><span>6</span><span>, </span><span>2</span><span>, </span><span>5</span><span>, </span><span>7</span><span>, </span><span>1</span><span>, </span><span>4</span><span>, </span><span>9</span><span>, </span><span>8</span><span>, </span><span>3</span><span>)<br/></span><span>                    .</span><span>scan</span><span>(</span><span>0</span><span>, (</span><span>total</span><span>,</span><span>next</span><span>) </span>-&gt; <span>total </span><span>+ </span><span>next</span><span>)<br/></span><span>                    .</span><span>cache</span><span>();<br/></span><span><br/></span><span>        </span><span>cachedRollingTotals</span><span>.</span><span>subscribe</span><span>(</span><span>System</span><span>.</span><span>out</span>::<span>println</span><span>);<br/></span><span>    }<br/></span><span>}</span></pre>
<p>You can also call <kbd>cacheWithInitialCapacity()</kbd> and specify the number of elements to be expected in the cache. This will optimize the buffer for that size of elements in advance:</p>
<pre style="padding-left: 60px"><span>Observable</span><span>&lt;</span><span>Integer</span><span>&gt; </span><span>cachedRollingTotals </span><span>=<br/></span><span>        </span><span>Observable</span><span>.</span><span>just</span><span>(</span><span>6</span><span>, </span><span>2</span><span>, </span><span>5</span><span>, </span><span>7</span><span>, </span><span>1</span><span>, </span><span>4</span><span>, </span><span>9</span><span>, </span><span>8</span><span>, </span><span>3</span><span>)<br/></span><span>            .</span><span>scan</span><span>(</span><span>0</span><span>, (</span><span>total</span><span>,</span><span>next</span><span>) </span>-&gt; <span>total </span><span>+ </span><span>next</span><span>)<br/></span><span>            .</span><span>cacheWithInitialCapacity</span><span>(</span><span>9</span><span>);</span></pre>
<div class="packt_tip">Again, do not use <kbd>cache()</kbd> unless you really want to hold all elements indefinitely and do not have plans to dispose it at any point. Otherwise, prefer <kbd>replay()</kbd> so you can more finely control cache sizing and windows as well as disposal policies.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Subjects</h1>
                </header>
            
            <article>
                
<p>Before we discuss Subjects, it would be remiss to not highlight, they have use cases but beginners often use them for the wrong ones, and end up in convoluted situations. As you will learn, they are both an <kbd>Observer</kbd> and an <kbd>Observable</kbd><strong>,</strong> acting as a proxy mulitcasting device (kind of like an event bus). They do have their place in reactive programming, but you should strive to exhaust your other options before utilizing them. Erik Meijer, the creator of ReactiveX, described them as the "<em>mutable variables of reactive programming</em>". Just like mutable variables are necessary at times even though you should strive for immutability, Subjects are sometimes a necessary tool to reconcile imperative paradigms with reactive ones.</p>
<p>But before we discuss when to and when not to use them, let's take a look at what they exactly do.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">PublishSubject</h1>
                </header>
            
            <article>
                
<p>There are a couple implementations of <kbd>Subject</kbd>, which is an abstract type that implements both <kbd>Observable</kbd> and <kbd>Observer</kbd>. This means that you can manually call <kbd>onNext()</kbd>, <kbd>onComplete()</kbd>, and <kbd>onError()</kbd> on a <kbd>Subject</kbd><strong>,</strong> and it will, in turn, pass those events downstream toward its Observers.</p>
<p>The simplest <kbd>Subject</kbd> type is the <kbd>PublishSubject</kbd>, which, like all Subjects, hotly broadcasts to its downstream Observers. Other <kbd>Subject</kbd> types add more behaviors, but <kbd>PublishSubject</kbd> is the "vanilla" type, if you will.</p>
<p>We can declare a <kbd>Subject&lt;String&gt;</kbd>, create an <kbd>Observer</kbd> that maps its lengths and subscribes to it, and then call <kbd>onNext()</kbd> to pass three strings. We can also call <kbd>onComplete()</kbd> to communicate that no more events will be passed through this <kbd>Subject</kbd>:</p>
<pre style="padding-left: 60px"><span>import</span><span> </span><span>io.reactivex.subjects.PublishSubject</span><span>;<br/></span><span>import </span><span>io.reactivex.subjects.</span><span>Subject</span><span>;<br/></span><span><br/></span><span>public class </span><span>Launcher </span><span>{<br/></span><span>    </span><span>public static void </span><span>main</span><span>(</span><span>String</span><span>[] </span><span>args</span><span>) {<br/></span><span><br/></span><span>        </span><span>Subject</span><span>&lt;</span><span>String</span><span>&gt; </span><span>subject </span><span>= </span><span>PublishSubject</span><span>.</span><span>create</span><span>();<br/></span><span><br/></span><span>        </span><span>subject</span><span>.</span><span>map</span><span>(</span><span>String</span>::<span>length</span><span>)<br/></span><span>                .</span><span>subscribe</span><span>(</span><span>System</span><span>.</span><span>out</span>::<span>println</span><span>);<br/></span><span><br/></span><span>        </span><span>subject</span><span>.</span><span>onNext</span><span>(</span><span>"Alpha"</span><span>);<br/></span><span>        </span><span>subject</span><span>.</span><span>onNext</span><span>(</span><span>"Beta"</span><span>);<br/></span><span>        </span><span>subject</span><span>.</span><span>onNext</span><span>(</span><span>"Gamma"</span><span>);<br/>        subject.onComplete();<br/></span><span>    }<br/></span><span>}</span></pre>
<p><span>The output is as follows:</span></p>
<pre style="padding-left: 60px">5<br/>4<br/>5</pre>
<p>This shows Subjects act like magical devices that can bridge imperative programming with reactive programming, and you would be right. Next, let's look at cases of when to and when not to use Subjects.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">When to use Subjects</h1>
                </header>
            
            <article>
                
<p>More likely, you will use Subjects to eagerly subscribe to an unknown number of multiple source Observables and consolidate their emissions as a single <kbd>Observable</kbd>. Since Subjects are an <kbd>Observer</kbd>, you can pass them to a <kbd>subscribe()</kbd> method easily. This can be helpful in modularized code bases where decoupling between Observables and Observers takes place and executing <kbd>Observable.merge()</kbd> is not that easy. Here, I use <kbd>Subject</kbd> to merge and multicast two <kbd>Observable</kbd> interval sources:</p>
<pre style="padding-left: 60px"><span>import</span><span> </span><span>io.reactivex.</span><span>Observable</span><span>;<br/></span><span>import </span><span>io.reactivex.subjects.PublishSubject</span><span>;<br/></span><span>import </span><span>io.reactivex.subjects.</span><span>Subject</span><span>;<br/></span><span>import </span><span>java.util.concurrent.</span><span>TimeUnit</span><span>;<br/></span><span><br/></span><span>public class </span><span>Launcher </span><span>{<br/></span><span>    </span><span>public static void </span><span>main</span><span>(</span><span>String</span><span>[] </span><span>args</span><span>) {<br/></span><span><br/></span><span>        </span><span>Observable</span><span>&lt;</span><span>String</span><span>&gt; </span><span>source1 </span><span>=<br/></span><span>                </span><span>Observable</span><span>.</span><span>interval</span><span>(</span><span>1</span><span>, </span><span>TimeUnit</span><span>.</span><span>SECONDS</span><span>)<br/></span><span>                    .</span><span>map</span><span>(</span><span>l </span>-&gt; <span>(</span><span>l </span><span>+ </span><span>1</span><span>) </span><span>+ </span><span>" seconds"</span><span>);<br/></span><span><br/></span><span>        </span><span>Observable</span><span>&lt;</span><span>String</span><span>&gt; </span><span>source2 </span><span>=<br/></span><span>                </span><span>Observable</span><span>.</span><span>interval</span><span>(</span><span>300</span><span>, </span><span>TimeUnit</span><span>.</span><span>MILLISECONDS</span><span>)<br/></span><span>                    .</span><span>map</span><span>(</span><span>l </span>-&gt; <span>((</span><span>l </span><span>+ </span><span>1</span><span>) </span><span>* </span><span>300</span><span>) </span><span>+ </span><span>" milliseconds"</span><span>);<br/></span><span><br/></span><span>        </span><span>Subject</span><span>&lt;</span><span>String</span><span>&gt; </span><span>subject </span><span>= </span><span>PublishSubject</span><span>.</span><span>create</span><span>();<br/></span><span><br/></span><span>        </span><span>subject</span><span>.</span><span>subscribe</span><span>(</span><span>System</span><span>.</span><span>out</span>::<span>println</span><span>);<br/></span><span><br/></span><span>        </span><span>source1</span><span>.</span><span>subscribe</span><span>(</span><span>subject</span><span>);<br/></span><span>        </span><span>source2</span><span>.</span><span>subscribe</span><span>(</span><span>subject</span><span>);<br/></span><span><br/></span><span>        </span><span>sleep</span><span>(</span><span>3000</span><span>);<br/></span><span>    }<br/></span><span><br/></span><span>    </span><span>public static void </span><span>sleep</span><span>(</span><span>long </span><span>millis</span><span>) {<br/></span><span>        </span><span>try </span><span>{<br/></span><span>            </span><span>Thread</span><span>.</span><span>sleep</span><span>(</span><span>millis</span><span>);<br/></span><span>        } </span><span>catch </span><span>(</span><span>InterruptedException </span><span>e</span><span>) {<br/></span><span>            </span><span>e</span><span>.</span><span>printStackTrace</span><span>();<br/></span><span>        }<br/></span><span>    }<br/></span><span>}</span></pre>
<p><span>The output is as follows:</span></p>
<pre style="padding-left: 60px">300 milliseconds<br/>600 milliseconds<br/>900 milliseconds<br/>1 seconds<br/>1200 milliseconds<br/>1500 milliseconds<br/>1800 milliseconds<br/>2 seconds<br/>2100 milliseconds<br/>2400 milliseconds<br/>2700 milliseconds<br/>3 seconds<br/>3000 milliseconds</pre>
<p>Of course, I could use <kbd>Observable.merge()</kbd> to accomplish this (and technically for this case, I should). But when you have modularized code managed through dependency injection or other decoupling mechanisms, you may not have your <kbd>Observable</kbd> sources prepared in advance to put in <kbd>Observable.merge()</kbd>. For example, I could have a JavaFX application that has a refresh event coming from a menu bar, button, or a keystroke combination. I can declare these event sources as Observables and subscribe them to a <kbd>Subject</kbd> in a backing class to consolidate the event streams without any hard coupling.</p>
<p>Another note to make is that the first <kbd>Observable</kbd> to call <kbd>onComplete()</kbd> on <kbd>Subject</kbd> is going to cease other <kbd>Observables</kbd> from pushing their emissions, and downstream cancellation requests are ignored. This means that you will most likely use Subjects for infinite, event-driven (that is, user action-driven) Observables. That being said, we will next look at cases where Subjects become prone to abuse.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">When Subjects go wrong</h1>
                </header>
            
            <article>
                
<p>Hopefully, you will feel that our earlier <kbd>Subject</kbd> example emitting <kbd>Alpha</kbd>, <kbd>Beta</kbd>, and <kbd>Gamma</kbd> is counterintuitive and backward considering how we have architected our reactive applications so far, and you would be right to think that way. We did not define the source emissions until the end after all the Observers are set up, and the process no longer reads left-to-right, top-to-bottom. Since Subjects are hot, executing the <kbd>onNext()</kbd> calls before the Observers are set up would result in these emissions being missed with our <kbd>Subject</kbd>. If you move the <kbd>onNext()</kbd> calls like this, you will not get any output because the <kbd>Observer</kbd> will miss these emissions:</p>
<pre style="padding-left: 60px"><span>import </span><span>io.reactivex.subjects.PublishSubject</span><span>;<br/></span><span>import </span><span>io.reactivex.subjects.</span><span>Subject</span><span>;<br/></span><span><br/></span><span>public class </span><span>Launcher </span><span>{<br/></span><span>    </span><span>public static void </span><span>main</span><span>(</span><span>String</span><span>[] </span><span>args</span><span>) {<br/></span><span><br/></span><span>        </span><span>Subject</span><span>&lt;</span><span>String</span><span>&gt; </span><span>subject </span><span>= </span><span>PublishSubject</span><span>.</span><span>create</span><span>();<br/></span><span><br/></span><span>        </span><span>subject</span><span>.</span><span>onNext</span><span>(</span><span>"Alpha"</span><span>);<br/></span><span>        </span><span>subject</span><span>.</span><span>onNext</span><span>(</span><span>"Beta"</span><span>);<br/></span><span>        </span><span>subject</span><span>.</span><span>onNext</span><span>(</span><span>"Gamma"</span><span>);<br/>        subject.onComplete();<br/></span><span><br/></span><span>        </span><span>subject</span><span>.</span><span>map</span><span>(</span><span>String</span>::<span>length</span><span>)<br/></span><span>                .</span><span>subscribe</span><span>(</span><span>System</span><span>.</span><span>out</span>::<span>println</span><span>);</span><span><br/></span><span>    }<br/></span><span>}</span></pre>
<p>This shows that Subjects can be somewhat haphazard and dangerous, especially if you expose them to your entire code base and any external code can call <kbd>onNext()</kbd> to pass emissions. For instance, say our <kbd>Subject</kbd> was exposed to an external API and something can arbitrarily pass the emission <kbd>Puppy</kbd> on top of <kbd>Alpha</kbd>, <kbd>Beta</kbd>, and <kbd>Gamma</kbd>. If we want our source to only emit these Greek letters, it is prone to receiving accidental or unwanted emissions. Reactive programming only maintains integrity when source Observables are derived from a well-defined and predictable source. Subjects are not disposable either, as they have no public <kbd>dispose()</kbd> method and will not release their sources in the event that <kbd>dispose()</kbd> is called downstream.</p>
<p>It is much better to keep data-driven sources like this cold and to multicast using <kbd>publish()</kbd> or <kbd>replay()</kbd> if you want to make them hot. When you need to use <kbd>Subject</kbd>, cast it down to <kbd>Observable</kbd> or just do not expose it at all. You can also wrap a <kbd>Subject</kbd> inside a class of some sorts and have methods pass the events to it.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Serializing Subjects</h1>
                </header>
            
            <article>
                
<p>A critical <em>gotcha</em> to note with Subjects is this: the <kbd>onSubscribe()</kbd>, <kbd>onNext()</kbd>, <kbd>onError()</kbd>, and <kbd>onComplete()</kbd> calls are not threadsafe!  If you have multiple threads calling these four methods, emissions could start to overlap and break the <kbd>Observable</kbd> contract, which demands that emissions happen sequentially. If this happens, a good practice to adopt is to call <kbd>toSerialized()</kbd> on <kbd>Subject</kbd> to yield a  safely serialized <kbd>Subject</kbd> implementation (backed by the private <kbd>SerializedSubject</kbd>). This will safely sequentialize concurrent event calls so no train wrecks occur downstream:</p>
<pre style="padding-left: 60px"><span>Subject</span><span>&lt;</span><span>String</span><span>&gt; </span><span>subject </span><span>= <br/></span><span>        </span><span>PublishSubject</span><span>.</span><span>&lt;</span><span>String</span><span>&gt;</span><span>create</span><span>().</span><span>toSerialized</span><span>();</span></pre>
<div class="packt_infobox">Unfortunately, due to limitations with the Java compiler (including Java 8), we have to explicitly declare the type parameter <kbd>String</kbd> for our <kbd>create()</kbd> factory earlier. The compiler's type inference does not cascade beyond more than one method invocation, so having two invocations as previously demonstrated would have a compilation error without an explicit type declaration.</div>
<p> </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">BehaviorSubject</h1>
                </header>
            
            <article>
                
<p>There are a few other flavors of Subjects. Aside from the commonly used <kbd>PublishSubject</kbd>, there is also <kbd>BehaviorSubject</kbd>. It behaves almost the same way as <kbd>PublishSubject</kbd>, but it will replay the last emitted item to each new <kbd>Observer</kbd> downstream. This is somewhat like putting <kbd>replay(1).autoConnect()</kbd> after a <kbd>PublishSubject</kbd>, but it consolidates these operations into a single optimized <kbd>Subject</kbd> implementation that subscribes eagerly to the source:</p>
<pre style="padding-left: 60px"><span>import </span><span>io.reactivex.subjects.BehaviorSubject</span><span>;<br/></span><span>import </span><span>io.reactivex.subjects.</span><span>Subject</span><span>;<br/></span><span><br/></span><span>public class </span><span>Launcher </span><span>{<br/></span><span>    </span><span>public static void </span><span>main</span><span>(</span><span>String</span><span>[] </span><span>args</span><span>) {<br/></span><span><br/></span><span>        </span><span>Subject</span><span>&lt;</span><span>String</span><span>&gt; </span><span>subject </span><span>=<br/></span><span>                </span><span>BehaviorSubject</span><span>.</span><span>create</span><span>();<br/></span><span><br/></span><span>        </span><span>subject</span><span>.</span><span>subscribe</span><span>(</span><span>s </span>-&gt; <span>System</span><span>.</span><span>out</span><span>.</span><span>println</span><span>(</span><span>"Observer 1: " </span><span>+ </span><span>s</span><span>));<br/></span><span><br/></span><span>        </span><span>subject</span><span>.</span><span>onNext</span><span>(</span><span>"Alpha"</span><span>);<br/></span><span>        </span><span>subject</span><span>.</span><span>onNext</span><span>(</span><span>"Beta"</span><span>);<br/></span><span>        </span><span>subject</span><span>.</span><span>onNext</span><span>(</span><span>"Gamma"</span><span>);<br/></span><span><br/></span><span>        </span><span>subject</span><span>.</span><span>subscribe</span><span>(</span><span>s </span>-&gt; <span>System</span><span>.</span><span>out</span><span>.</span><span>println</span><span>(</span><span>"Observer 2: " </span><span>+ </span><span>s</span><span>));<br/></span><span>    }<br/></span><span>}</span></pre>
<p>The output is as follows:</p>
<pre style="padding-left: 60px">Observer 1: Alpha<br/>Observer 1: Beta<br/>Observer 1: Gamma<br/>Observer 2: Gamma</pre>
<p>Here, you can see that <kbd>Observer 2</kbd> received the last emission <kbd>Gamma</kbd> even though it missed the three emissions that <kbd>Observer 1</kbd> received. If you find yourself needing a <kbd>Subject</kbd> and want to cache the last emission for new Observers, you will want to use a <kbd>BehaviorSubject</kbd>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">ReplaySubject</h1>
                </header>
            
            <article>
                
<p><kbd>ReplaySubject</kbd> is similar to <kbd>PublishSubject</kbd> followed by a <kbd>cache()</kbd> operator. It immediately captures emissions regardless of the presence of downstream Observers and optimizes the caching to occur inside the <kbd>Subject</kbd> itself:</p>
<pre style="padding-left: 60px"><span>import</span><span> </span><span>io.reactivex.subjects.ReplaySubject</span><span>;<br/></span><span>import </span><span>io.reactivex.subjects.</span><span>Subject</span><span>;<br/></span><span><br/></span><span>public class </span><span>Launcher </span><span>{<br/></span><span>    </span><span>public static void </span><span>main</span><span>(</span><span>String</span><span>[] </span><span>args</span><span>) {<br/></span><span><br/></span><span>        </span><span>Subject</span><span>&lt;</span><span>String</span><span>&gt; </span><span>subject </span><span>=<br/></span><span>                </span><span>ReplaySubject</span><span>.</span><span>create</span><span>();<br/></span><span><br/></span><span>        </span><span>subject</span><span>.</span><span>subscribe</span><span>(</span><span>s </span>-&gt; <span>System</span><span>.</span><span>out</span><span>.</span><span>println</span><span>(</span><span>"Observer 1: " </span><span>+ </span><span>s</span><span>));<br/></span><span><br/></span><span>        </span><span>subject</span><span>.</span><span>onNext</span><span>(</span><span>"Alpha"</span><span>);<br/></span><span>        </span><span>subject</span><span>.</span><span>onNext</span><span>(</span><span>"Beta"</span><span>);<br/></span><span>        </span><span>subject</span><span>.</span><span>onNext</span><span>(</span><span>"Gamma"</span><span>);<br/></span><span>        </span><span>subject</span><span>.</span><span>onComplete</span><span>();<br/></span><span><br/></span><span>        </span><span>subject</span><span>.</span><span>subscribe</span><span>(</span><span>s </span>-&gt; <span>System</span><span>.</span><span>out</span><span>.</span><span>println</span><span>(</span><span>"Observer 2: " </span><span>+ </span><span>s</span><span>));<br/></span><span>    }<br/></span><span>}</span></pre>
<p><span>The output is as follows:</span></p>
<pre style="padding-left: 60px">Observer 1: Alpha<br/>Observer 1: Beta<br/>Observer 1: Gamma<br/>Observer 2: Alpha<br/>Observer 2: Beta<br/>Observer 2: Gamma</pre>
<p>Obviously, just like using a parameterless <kbd>replay()</kbd> or a <kbd>cache()</kbd> operator, you need to be wary of using this with a large volume of emissions or infinite sources because it will cache them all and take up memory.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">AsyncSubject</h1>
                </header>
            
            <article>
                
<p><kbd>AsyncSubject</kbd> has a highly tailored, finite-specific behavior: it will only push the last value it receives, followed by an <kbd>onComplete()</kbd> event:</p>
<pre style="padding-left: 60px"><span>import</span><span> </span><span>io.reactivex.subjects.AsyncSubject</span><span>;<br/></span><span>import </span><span>io.reactivex.subjects.</span><span>Subject</span><span>;<br/></span><span><br/></span><span>public class </span><span>Launcher </span><span>{<br/></span><span>    </span><span>public static void </span><span>main</span><span>(</span><span>String</span><span>[] </span><span>args</span><span>) {<br/></span><span><br/></span><span>        </span><span>Subject</span><span>&lt;</span><span>String</span><span>&gt; </span><span>subject </span><span>=<br/></span><span>                </span><span>AsyncSubject</span><span>.</span><span>create</span><span>();<br/></span><span><br/></span><span>        </span><span>subject</span><span>.</span><span>subscribe</span><span>(</span><span>s </span>-&gt;<br/><span>        System</span><span>.</span><span>out</span><span>.</span><span>println</span><span>(</span><span>"Observer 1: " </span><span>+ </span><span>s</span><span>),<br/></span><span>                </span><span>Throwable</span>::<span>printStackTrace</span><span>,<br/></span><span>                () </span>-&gt; <span>System</span><span>.</span><span>out</span><span>.</span><span>println</span><span>(</span><span>"Observer 1 done!"</span><span>)<br/></span><span>        );<br/></span><span><br/></span><span>        </span><span>subject</span><span>.</span><span>onNext</span><span>(</span><span>"Alpha"</span><span>);<br/></span><span>        </span><span>subject</span><span>.</span><span>onNext</span><span>(</span><span>"Beta"</span><span>);<br/></span><span>        </span><span>subject</span><span>.</span><span>onNext</span><span>(</span><span>"Gamma"</span><span>);<br/></span><span>        </span><span>subject</span><span>.</span><span>onComplete</span><span>();<br/></span><span><br/></span><span>        </span><span>subject</span><span>.</span><span>subscribe</span><span>(</span><span>s </span>-&gt;<br/><span>        System</span><span>.</span><span>out</span><span>.</span><span>println</span><span>(</span><span>"Observer 2: " </span><span>+ </span><span>s</span><span>),<br/></span><span>                </span><span>Throwable</span>::<span>printStackTrace</span><span>,<br/></span><span>                () </span>-&gt; <span>System</span><span>.</span><span>out</span><span>.</span><span>println</span><span>(</span><span>"Observer 2 done!"</span><span>)<br/></span><span>        );<br/></span><span>    }<br/></span><span>}</span></pre>
<p><span>The output is as follows:</span></p>
<pre style="padding-left: 60px">Observer 1: Gamma<br/>Observer 1 done!<br/>Observer 2: Gamma<br/>Observer 2 done!</pre>
<p>As you can tell from the preceding command, the last value to be pushed to <kbd>AsyncSubject</kbd> was <kbd>Gamma</kbd> before <kbd>onComplete()</kbd> was called. Therefore, it only emitted <kbd>Gamma</kbd> to all Observers. This is a <kbd>Subject</kbd> you do not want to use with infinite sources since it only emits when <kbd>onComplete()</kbd> is called.</p>
<p> </p>
<div class="packt_tip"><kbd>AsyncSubject</kbd> resembles <kbd>CompletableFuture</kbd> from Java 8 as it will do a computation that you can choose to observe for completion and get the value. You can also imitate <kbd>AsyncSubject</kbd> using <kbd>takeLast(1).replay(1)</kbd> on an <kbd>Observable</kbd>. Try to use this approach first before resorting to <kbd>AsyncSubject</kbd>.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">UnicastSubject</h1>
                </header>
            
            <article>
                
<p>An interesting and possibly helpful kind of <kbd>Subject</kbd> is <kbd>UnicastSubject</kbd>. A <kbd>UnicastSubject</kbd>, like all Subjects, will be used to observe and subscribe to the sources. But it will buffer all the emissions it receives until an <kbd>Observer</kbd> subscribes to it, and then it will release all these emissions to the <kbd>Observer</kbd> and clear its cache:</p>
<pre style="padding-left: 60px"><span>import</span><span> </span><span>io.reactivex.</span><span>Observable</span><span>;<br/></span><span>import </span><span>io.reactivex.subjects.ReplaySubject</span><span>;<br/></span><span>import </span><span>io.reactivex.subjects.</span><span>Subject</span><span>;<br/></span><span>import </span><span>io.reactivex.subjects.UnicastSubject</span><span>;</span><span><br/></span><span>import </span><span>java.util.concurrent.</span><span>TimeUnit</span><span>;<br/></span><span><br/></span><span>public class </span><span>Launcher </span><span>{<br/></span><span>    </span><span>public static void </span><span>main</span><span>(</span><span>String</span><span>[] </span><span>args</span><span>) {<br/></span><span><br/></span><span>        </span><span>Subject</span><span>&lt;</span><span>String</span><span>&gt; </span><span>subject </span><span>=<br/></span><span>                </span><span>UnicastSubject</span><span>.</span><span>create</span><span>();<br/></span><span><br/></span><span>        </span><span>Observable</span><span>.</span><span>interval</span><span>(</span><span>300</span><span>, </span><span>TimeUnit</span><span>.</span><span>MILLISECONDS</span><span>)<br/></span><span>                .</span><span>map</span><span>(</span><span>l </span>-&gt; <span>((</span><span>l </span><span>+ </span><span>1</span><span>) </span><span>* </span><span>300</span><span>) </span><span>+ </span><span>" milliseconds"</span><span>)<br/></span><span>                .</span><span>subscribe</span><span>(</span><span>subject</span><span>);<br/></span><span><br/></span><span>        </span><span>sleep</span><span>(</span><span>2000</span><span>);<br/></span><span><br/></span><span>        </span><span>subject</span><span>.</span><span>subscribe</span><span>(</span><span>s </span>-&gt; <span>System</span><span>.</span><span>out</span><span>.</span><span>println</span><span>(</span><span>"Observer 1: " </span><span>+ </span><span>s</span><span>));<br/></span><span><br/></span><span>        </span><span>sleep</span><span>(</span><span>2000</span><span>);<br/></span><span><br/></span><span>    }<br/></span><span>    </span><span>public static void </span><span>sleep</span><span>(</span><span>long </span><span>millis</span><span>) {<br/></span><span>        </span><span>try </span><span>{<br/></span><span>            </span><span>Thread</span><span>.</span><span>sleep</span><span>(</span><span>millis</span><span>);<br/></span><span>        } </span><span>catch </span><span>(</span><span>InterruptedException </span><span>e</span><span>) {<br/></span><span>            </span><span>e</span><span>.</span><span>printStackTrace</span><span>();<br/></span><span>        }<br/></span><span>    }<br/></span><span>}</span></pre>
<p><span>The output is as follows:</span></p>
<pre style="padding-left: 60px">Observer 1: 300 milliseconds<br/>Observer 1: 600 milliseconds<br/>Observer 1: 900 milliseconds<br/>Observer 1: 1200 milliseconds<br/>Observer 1: 1500 milliseconds<br/>Observer 1: 1800 milliseconds<br/>Observer 1: 2100 milliseconds<br/>Observer 1: 2400 milliseconds<br/>Observer 1: 2700 milliseconds<br/>Observer 1: 3000 milliseconds<br/>Observer 1: 3300 milliseconds<br/>Observer 1: 3600 milliseconds<br/>Observer 1: 3900 milliseconds</pre>
<p>When you run this code, you will see that after 2 seconds, the first six emissions are released immediately to the <kbd>Observer</kbd> when it subscribes. Then, it will receive live emissions from that point on. But there is one important property of <kbd>UnicastSubject</kbd>; it will only work with one <kbd>Observer</kbd> and will throw an error for any subsequent ones. Logically, this makes sense because it is designed to release buffered emissions from its internal queue once it gets an <kbd>Observer</kbd>. But when these cached emissions are released, they cannot be released again to a second <kbd>Observer</kbd> since they are already gone. If you want a second <kbd>Observer</kbd> to receive missed emissions, you might as well use <kbd>ReplaySubject</kbd>. The benefit of <kbd>UnicastSubject</kbd> is that it clears its buffer, and consequently frees the memory used for that buffer, once it gets an <kbd>Observer</kbd>. </p>
<p>If you want to support more than one <kbd>Observer</kbd> and just let subsequent Observers receive the live emissions without receiving the missed emissions, you can trick it by calling <kbd>publish()</kbd> to create a single <kbd>Observer</kbd> proxy that multicasts to more than one <kbd>Observer</kbd> as shown in the following code snippet:</p>
<pre style="padding-left: 60px"><span>import</span><span> </span><span>io.reactivex.</span><span>Observable</span><span>;<br/></span><span>import </span><span>io.reactivex.subjects.</span><span>Subject</span><span>;<br/></span><span>import </span><span>io.reactivex.subjects.UnicastSubject</span><span>;<br/></span><span>import </span><span>java.util.concurrent.</span><span>TimeUnit</span><span>;<br/></span><span><br/></span><span>public class </span><span>Launcher </span><span>{<br/></span><span>    </span><span>public static void </span><span>main</span><span>(</span><span>String</span><span>[] </span><span>args</span><span>) {<br/></span><span><br/></span><span>        </span><span>Subject</span><span>&lt;</span><span>String</span><span>&gt; </span><span>subject </span><span>=<br/></span><span>                </span><span>UnicastSubject</span><span>.</span><span>create</span><span>();<br/></span><span><br/></span><span>        </span><span>Observable</span><span>.</span><span>interval</span><span>(</span><span>300</span><span>, </span><span>TimeUnit</span><span>.</span><span>MILLISECONDS</span><span>)<br/></span><span>                .</span><span>map</span><span>(</span><span>l </span>-&gt; <span>((</span><span>l </span><span>+ </span><span>1</span><span>) </span><span>* </span><span>300</span><span>) </span><span>+ </span><span>" milliseconds"</span><span>)<br/></span><span>                .</span><span>subscribe</span><span>(</span><span>subject</span><span>);<br/></span><span><br/></span><span>        </span><span>sleep</span><span>(</span><span>2000</span><span>);<br/></span><span><br/></span><span>        </span><span>//multicast to support multiple Observers<br/></span><span>        </span><span>Observable</span><span>&lt;</span><span>String</span><span>&gt; </span><span>multicast </span><span>= </span><span>subject</span><span>.</span><span>publish</span><span>().autoConnect();<br/></span><span><br/></span><span>        </span><span>//bring in first Observer<br/></span><span>        </span><span>multicast.</span><span>subscribe</span><span>(</span><span>s </span>-&gt; <span>System</span><span>.</span><span>out</span><span>.</span><span>println</span><span>(</span><span>"Observer 1: " </span><span>+ </span><span>s</span><span>));<br/></span><span>        </span><span>sleep</span><span>(</span><span>2000</span><span>);<br/></span><span><br/></span><span>        </span><span>//bring in second Observer<br/></span><span>        </span><span>multicast.</span><span>subscribe</span><span>(</span><span>s </span>-&gt; <span>System</span><span>.</span><span>out</span><span>.</span><span>println</span><span>(</span><span>"Observer 2: " </span><span>+ </span><span>s</span><span>));<br/></span><span>        </span><span>sleep</span><span>(</span><span>1000</span><span>);<br/></span><span>    }<br/></span><span>    </span><span>public static void </span><span>sleep</span><span>(</span><span>long </span><span>millis</span><span>) {<br/></span><span>        </span><span>try </span><span>{<br/></span><span>            </span><span>Thread</span><span>.</span><span>sleep</span><span>(</span><span>millis</span><span>);<br/></span><span>        } </span><span>catch </span><span>(</span><span>InterruptedException </span><span>e</span><span>) {<br/></span><span>            </span><span>e</span><span>.</span><span>printStackTrace</span><span>();<br/></span><span>        }<br/></span><span>    }<br/></span><span>}<br/></span></pre>
<p><span>The output is as follows:</span></p>
<pre style="padding-left: 60px">Observer 1: 300 milliseconds<br/>Observer 1: 600 milliseconds<br/>Observer 1: 900 milliseconds<br/>Observer 1: 1200 milliseconds<br/>...<br/>Observer 1: 3900 milliseconds<br/>Observer 1: 4200 milliseconds<br/>Observer 2: 4200 milliseconds<br/>Observer 1: 4500 milliseconds<br/>Observer 2: 4500 milliseconds</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>In this chapter, we covered multicasting using <kbd>ConnectableObservable</kbd> and <kbd>Subject</kbd>. The biggest takeaway is that <kbd>Observable</kbd> operators result in separate streams of events for each <kbd>Observer</kbd> that subscribes. If you want to consolidate these multiple streams into a single stream to prevent redundant work, the best way is to call <kbd>publish()</kbd> on an <kbd>Observable</kbd> to yield <kbd>ConnectableObservable</kbd>. You can then manually call <kbd>connect()</kbd> to fire emissions once your Observers are set up or automatically trigger a connection using <kbd>autoConnect()</kbd><strong> </strong>or <kbd>refCount()</kbd>.</p>
<p>Mutlicasting also enables replaying and caching, so tardy Observers can receive missed emissions. Subjects provide a means to multicast and cache emissions as well, but you should only utilize them if existing operators cannot achieve what you want.</p>
<p>In the next chapter, we will start working with concurrency. This is where RxJava truly shines and is often the selling point of reactive programming.</p>


            </article>

            
        </section>
    </body></html>