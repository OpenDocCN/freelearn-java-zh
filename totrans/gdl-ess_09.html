<html><head></head><body>
<div id="page" style="height:0pt"/><div class="book" title="Chapter&#xA0;9.&#xA0;Polyglot Projects" id="1JFUC1-e78ecbb3ac0544f19c59f96d594821c0"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch09" class="calibre1"/>Chapter 9. Polyglot Projects</h1></div></div></div><p class="calibre8">We are living in an era where one language is not enough. Developers are expected to be polyglot programmers and choose the right tool for a job. While it is always a subjective decision, we try to select languages and ecosystems based on various parameters such as execution speed, developer productivity, available libraries and resources, a team's comfort level with the language, and many more.</p><p class="calibre8">When we are already carrying the cognitive load of working with different languages, Gradle turns out to be our good friend, as we don't have to change our build tool even if we are building projects in other languages. We can even use multiple languages in the same project and Gradle orchestrating the build for the entire project. Apart from the array of JVM-based languages, Gradle also supports C, C++, Objective C and others to produce native applications as well. Gradle is also an official build tool for the Android platform. The list of supported languages is on the rise. Apart from official plugins, there are many community-supported language plugins.</p><p class="calibre8">Although throughout the book we have focused primarily on Java as the language, we could have very well used Groovy or Scala to write the examples. The <code class="literal">java</code> plugin (along with the <code class="literal">java-base</code> plugin, which is applied by the <code class="literal">java</code> plugin to the project) provides the basic functionality for the JVM-based projects. Language specific plugins such as <code class="literal">scala</code> and <code class="literal">groovy</code> extend the <code class="literal">java</code> plugin to support common idioms in a consistent manner. So, once we have used the <code class="literal">java</code> plugin, we are already familiar with what <code class="literal">sourceSet</code> is, how <code class="literal">configuration</code> works, how to add library dependencies, and so on, and this knowledge is readily useful when we use these language plugins. In this chapter, we will see how we can easily add more spice to Java projects by adding Groovy or Scala to the mix.</p></div>

<div class="book" title="Chapter&#xA0;9.&#xA0;Polyglot Projects" id="1JFUC1-e78ecbb3ac0544f19c59f96d594821c0">
<div class="book" title="The polyglot application"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_1"><a id="ch09lvl1sec47" class="calibre1"/>The polyglot application</h1></div></div></div><p class="calibre8">For the<a id="id262" class="calibre1"/> code example, in this chapter, let's build a simple <span class="strong"><strong class="calibre9">Quote of the Day</strong></span> service <a id="id263" class="calibre1"/>that returns a quote based on the day of the year. Since we might have fewer quotes in our store, the service should repeat the quotes in a cyclic fashion. Again, as usual, we will try to keep it as simple as possible to focus more on build aspects rather than the application logic. We will create two separate Gradle projects to implement the exact same functionality, once in Groovy then in Scala.</p><p class="calibre8">Before going into language-specific details, let's start with defining the <code class="literal">QotdService</code> interface, which just declares only one method, <code class="literal">getQuote</code>. The contract is, as long as we pass the same date, we should get the same quote back:</p><div class="informalexample"><pre class="programlisting">package com.packtpub.ge.qotd;

import java.util.Date;

interface QotdService {
  String getQuote(Date day);
}</pre></div><p class="calibre8">The logic to<a id="id264" class="calibre1"/> implement <code class="literal">getQuote</code> can use the <code class="literal">Date</code> object in any manner, such as using the entire date including the time for determining the quote. However, for the sake of simplicity, we will use only the day component of the <code class="literal">Date</code> object in our implementations. Also, because we want our interface to be open for future implementations, we let <code class="literal">getQuote</code> take a <code class="literal">Date</code> object as the parameter.</p><p class="calibre8">This interface is a Java file that we will have in both projects. This is just to demonstrate the integration of Java and Groovy/Scala sources in one project.</p></div></div>
<div class="book" title="Building Groovy projects" id="1KEEU1-e78ecbb3ac0544f19c59f96d594821c0"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch09lvl1sec48" class="calibre1"/>Building Groovy projects</h1></div></div></div><p class="calibre8">Let's first <a id="id265" class="calibre1"/>implement the <code class="literal">QotdService</code> interface in Groovy. Also, we will write some unit tests to make sure that the functionality works as expected. To start the project, let's create the directory structure as follows:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre9">qotd-groovy</strong></span>
<span class="strong"><strong class="calibre9">├── build.gradle</strong></span>
<span class="strong"><strong class="calibre9">└── src</strong></span>
<span class="strong"><strong class="calibre9">    ├── main</strong></span>
<span class="strong"><strong class="calibre9">    │   ├── groovy</strong></span>
<span class="strong"><strong class="calibre9">    │   │   └── com</strong></span>
<span class="strong"><strong class="calibre9">    │   │       └── packtpub</strong></span>
<span class="strong"><strong class="calibre9">    │   │           └── ge</strong></span>
<span class="strong"><strong class="calibre9">    │   │               └── qotd</strong></span>
<span class="strong"><strong class="calibre9">    │   │                   └── GroovyQotdService.groovy</strong></span>
<span class="strong"><strong class="calibre9">    │   └── java</strong></span>
<span class="strong"><strong class="calibre9">    │       └── com</strong></span>
<span class="strong"><strong class="calibre9">    │           └── packtpub</strong></span>
<span class="strong"><strong class="calibre9">    │               └── ge</strong></span>
<span class="strong"><strong class="calibre9">    │                   └── qotd</strong></span>
<span class="strong"><strong class="calibre9">    │                       └── QotdService.java</strong></span>
<span class="strong"><strong class="calibre9">    └── test</strong></span>
<span class="strong"><strong class="calibre9">        └── groovy</strong></span>
<span class="strong"><strong class="calibre9">            └── com</strong></span>
<span class="strong"><strong class="calibre9">                └── packtpub</strong></span>
<span class="strong"><strong class="calibre9">                    └── ge</strong></span>
<span class="strong"><strong class="calibre9">                        └── qotd</strong></span>
<span class="strong"><strong class="calibre9">                            └── GroovyQotdServiceTest.groovy</strong></span>
</pre></div><p class="calibre8">The <code class="literal">src/main/java</code> directory is the default directory for Java sources. Similarly, <code class="literal">src/main/groovy</code> is used by default to compile Groovy source files. Again, it is just a convention, and the source directories' path and name can be easily configured via <code class="literal">sourceSets</code>.</p><p class="calibre8">Let's first write the <a id="id266" class="calibre1"/>build script for our Groovy project. Create a <code class="literal">build.gradle</code> file in the project root with the following content:</p><div class="informalexample"><pre class="programlisting">apply plugin: 'groovy'

repositories {
  mavenCentral()
}

dependencies {
  compile 'org.codehaus.groovy:groovy-all:2.4.5'
  testCompile 'junit:junit:4.11'
}</pre></div><p class="calibre8">Building Groovy project is as simple as building a Java project. Instead of applying the <code class="literal">java</code> plugin, we apply the <code class="literal">groovy</code> plugin, which automatically applies the <code class="literal">java</code> plugin for us. Apart from applying the plugin, we also need to add Groovy as a library dependency so that it is available for compilation and is also available at runtime. We also add <code class="literal">junit</code> in the <code class="literal">testCompile</code> configuration so it is available for unit tests. We declare Maven central as the repository to be used, but this can be changed to any valid repository configuration that can serve our project's dependencies.</p><div class="informalexample" title="Note"><h3 class="title2"><a id="note29" class="calibre1"/>Note</h3><p class="calibre8">Gradle build script is a Groovy DSL, and parts of Gradle are written in Groovy. However, like any other library that Gradle itself depends on at runtime, Groovy is not implicitly available to the project that we are building. Hence, we must explicitly declare Groovy as a project dependency, depending on whether we are using Groovy in production or test sources.</p></div><p class="calibre8">Groovy plugin takes care of compiling Java source files in the project as well. Let's implement the <code class="literal">QotdService</code> interface in Groovy:</p><div class="informalexample"><pre class="programlisting">package com.packtpub.ge.qotd

class GroovyQotdService implements QotdService {
  List quotes

  GroovyQotdService(List quotes) {
    this.quotes = quotes
  }

  @Override
  String getQuote(Date day) {
    quotes[day[Calendar.DAY_OF_YEAR] % quotes.size()]
  }
}</pre></div><p class="calibre8">The implementation<a id="id267" class="calibre1"/> of service accepts a list of quotes in a constructor. The <code class="literal">getQuote</code> method gets quote by the index in the list. To ensure that the computed index always stays within the range of the quote's size, we get the modulus of the day of the year and the list's size.</p><p class="calibre8">To test the service, let's write very basic JUnit test cases in Groovy:</p><div class="informalexample"><pre class="programlisting">package com.packtpub.ge.qotd

import org.junit.Before
import org.junit.Test

import static org.junit.Assert.assertEquals
import static org.junit.Assert.assertNotSame


public class GroovyQotdServiceTest {

  QotdService service
  Date today, tomorrow, dayAfterTomorrow

  def quotes = [
    "Be the change you wish to see in the world" +
      " - Mahatma Gandhi",
    "A person who never made a mistake never tried anything new" +
      " - Albert Einstein"
  ]

  @Before
  public void setup() {
    service = new GroovyQotdService(quotes)
    today = new Date()
    tomorrow = today + 1
    dayAfterTomorrow = tomorrow + 1
  }

  @Test
  void "return same quote for same date"() {
    assertEquals(service.getQuote(today), service.getQuote(today))
  }

  @Test
  void "return different quote for different dates"() {
    assertNotSame(service.getQuote(today),
      service.getQuote(tomorrow))
  }

  @Test
  void "repeat quotes"() {
    assertEquals(service.getQuote(today),
      service.getQuote(dayAfterTomorrow))
  }
}</pre></div><p class="calibre8">We prepare<a id="id268" class="calibre1"/> the test data in setup, and each test case makes sure the contract of the quote service is maintained. As the quote's list contains only two quotes, they should repeat every alternate day.</p><p class="calibre8">We can run the tests from the command line using the following code:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre9">$ gradle test</strong></span>
</pre></div></div>
<div class="book" title="Building Scala projects" id="1LCVG1-e78ecbb3ac0544f19c59f96d594821c0"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch09lvl1sec49" class="calibre1"/>Building Scala projects</h1></div></div></div><p class="calibre8">Following <a id="id269" class="calibre1"/>the last section, most of this section would be very predictable from the application build's standpoint. So let's quickly go through the gist of it. The directory structure is as follows:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre9">qotd-scala</strong></span>
<span class="strong"><strong class="calibre9">├── build.gradle</strong></span>
<span class="strong"><strong class="calibre9">└── src</strong></span>
<span class="strong"><strong class="calibre9">    ├── main</strong></span>
<span class="strong"><strong class="calibre9">    │   ├── java</strong></span>
<span class="strong"><strong class="calibre9">    │   │   └── com/packtpub/ge/qotd</strong></span>
<span class="strong"><strong class="calibre9">    │   │                       └── QotdService.java</strong></span>
<span class="strong"><strong class="calibre9">    │   └── scala</strong></span>
<span class="strong"><strong class="calibre9">    │       └── com/packtpub/ge/qotd</strong></span>
<span class="strong"><strong class="calibre9">    │                           └── ScalaQotdService.scala</strong></span>
<span class="strong"><strong class="calibre9">    └── test</strong></span>
<span class="strong"><strong class="calibre9">        └── scala</strong></span>
<span class="strong"><strong class="calibre9">            └── com/packtpub/ge/qotd</strong></span>
<span class="strong"><strong class="calibre9">                                └── ScalaQotdServiceTest.scala</strong></span>
</pre></div><p class="calibre8">All Scala source files are read from <code class="literal">src/main/scala</code> <code class="literal">and src/test/scala</code>, unless configured using <code class="literal">sourceSets</code>. This time, the only plugin that we need to apply is the <code class="literal">scala</code> plugin, which just like the <code class="literal">groovy</code> plugin, implicitly applies the <code class="literal">java</code> plugin to our project. Let's write the <code class="literal">build.gradle</code> file for this project:</p><div class="informalexample"><pre class="programlisting">apply plugin: 'scala'

repositories {
  mavenCentral()
}

dependencies {
  compile 'org.scala-lang:scala-library:2.11.7'
  testCompile 'org.specs2:specs2-junit_2.11:2.4.15',
    'junit:junit:4.11'
}</pre></div><p class="calibre8">Here, we have to provide <code class="literal">scala-library</code> as a dependency. We also added <code class="literal">specs2</code> as a dependency for the test configuration. We are using JUnit runner for the tests.</p><div class="informalexample" title="Note"><h3 class="title2"><a id="note30" class="calibre1"/>Note</h3><p class="calibre8">The <code class="literal">specs2</code> is<a id="id270" class="calibre1"/> a popular Scala testing library, which supports both unit and acceptance testing and the BDD/TDD style of writing tests. More <a id="id271" class="calibre1"/>information is available at <a class="calibre1" href="http://etorreborre.github.io/specs2/">http://etorreborre.github.io/specs2/</a>.</p></div><p class="calibre8">Moving on to the <a id="id272" class="calibre1"/>service's Scala implementation, we can implement it as follows:</p><div class="informalexample"><pre class="programlisting">package com.packtpub.ge.qotd

import java.util.{Calendar, Date}

class ScalaQotdService(quotes: Seq[String]) extends QotdService {

  def getQuote(day: Date) = {
    val calendar = Calendar.getInstance()
    calendar.setTime(day)

    quotes(calendar.get(Calendar.DAY_OF_YEAR) % quotes.size)
  }
}</pre></div><p class="calibre8">The implementation is not very idiomatic Scala, but that's out of scope of this book. The class takes the quotes <code class="literal">Seq</code> in the constructor and implements the <code class="literal">getQuote</code> method in a similar fashion to the Groovy counterpart.</p><p class="calibre8">Now that the service is implemented, let's verify that it honors the semantics of <code class="literal">QotdService</code> by writing unit tests. For brevity, we will cover only the important test cases:</p><div class="informalexample"><pre class="programlisting">package com.packtpub.ge.qotd

import java.util.{Calendar, Date}

import org.junit.runner.RunWith
import org.specs2.mutable._
import org.specs2.runner.JUnitRunner

@RunWith(classOf[JUnitRunner])
class ScalaQotdServiceTest extends SpecificationWithJUnit {

  def service = new ScalaQotdService(Seq(
    "Be the change you wish to see in the world" +
      " - Mahatma Gandhi",
    "A person who never made a mistake never tried anything new" +
      " - Albert Einstein"
  ))

  val today = new Date()
  val tomorrow = incrementDay(today)
  val dayAfterTomorrow = incrementDay(tomorrow)

  "Quote service" should {
    "return same quote for same day in multiple invocations" in {
      service.getQuote(today) must be(service.getQuote(today))
    }

    "return different quote for different days" in {
      service.getQuote(today) must not be (
        service.getQuote(tomorrow))
    }

    "repeat quote if total quotes are less than days in year" in {
      service.getQuote(today) must be(
        service.getQuote(dayAfterTomorrow))
    }
  }

  def incrementDay(date: Date) = {
    val cal = Calendar.getInstance()
    cal.setTime(date)
    cal.add(Calendar.DATE, 1)
    cal.getTime
  }
}</pre></div><p class="calibre8">The task to <a id="id273" class="calibre1"/>run test cases is just the same as the Groovy counterpart. We can run tests using the following code:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre9">$ gradle test</strong></span>
</pre></div></div>
<div class="book" title="Joint compilation" id="1MBG21-e78ecbb3ac0544f19c59f96d594821c0"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch09lvl1sec50" class="calibre1"/>Joint compilation</h1></div></div></div><p class="calibre8">In the <a id="id274" class="calibre1"/>preceding examples in this chapter, we declared an interface in Java and implemented it in Groovy and Scala respectively. It was possible because the classes compiled by the <code class="literal">java</code> plugin are available to Groovy and Scala classes.</p><p class="calibre8">If we want a Java class to have access to Groovy or Scala classes for its compilation, then we must compile the Java source file using the <span class="strong"><strong class="calibre9">joint compilation</strong></span> supported by the respective plugin. Both the <code class="literal">groovy</code> and <code class="literal">scala</code> plugins support joint compilation and can compile Java sources.</p><p class="calibre8">For referencing Groovy classes in a Java class, the easiest way is to move the corresponding Java source file into <code class="literal">src/main/groovy</code> (or in any of the Groovy <code class="literal">srcDirs</code> configured for <code class="literal">sourceSets</code>), and the Groovy compiler makes Groovy classes available to the Java class while compilation. The same goes for Scala joint compilation. We can put the Java files, which need Scala classes for their compilation, in any of the Scala <code class="literal">srcDirs</code> (<code class="literal">src/main/scala</code> by default).</p></div>
<div class="book" title="References" id="1NA0K1-e78ecbb3ac0544f19c59f96d594821c0"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch09lvl1sec51" class="calibre1"/>References</h1></div></div></div><p class="calibre8">The <a id="id275" class="calibre1"/>detailed official documentation for language plugins, discussed in this chapter, can be found at<a id="id276" class="calibre1"/> the <a id="id277" class="calibre1"/>following URLs:</p><div class="book"><ul class="itemizedlist"><li class="listitem"><span class="strong"><strong class="calibre9">Java plugin</strong></span>: <a class="calibre1" href="https://docs.gradle.org/current/userguide/java_plugin.html">https://docs.gradle.org/current/userguide/java_plugin.html</a></li><li class="listitem"><span class="strong"><strong class="calibre9">Groovy plugin</strong></span>: <a class="calibre1" href="https://docs.gradle.org/current/userguide/groovy_plugin.html">https://docs.gradle.org/current/userguide/groovy_plugin.html</a></li><li class="listitem"><span class="strong"><strong class="calibre9">Scala plugin</strong></span>: <a class="calibre1" href="https://docs.gradle.org/current/userguide/scala_plugin.html">https://docs.gradle.org/current/userguide/scala_plugin.html</a></li></ul></div><p class="calibre8">The links to the official documentation for various languages and other plugins shipped with Gradle can be found at the following URL:</p><p class="calibre8">
<a class="calibre1" href="https://docs.gradle.org/current/userguide/standard_plugins.html">https://docs.gradle.org/current/userguide/standard_plugins.html</a>
</p></div>
<div class="book" title="Summary" id="1O8H61-e78ecbb3ac0544f19c59f96d594821c0"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch09lvl1sec52" class="calibre1"/>Summary</h1></div></div></div><p class="calibre8">We took a simple example problem and implemented a solution in Groovy and Scala to demonstrate how Gradle makes polyglot project development easy. Instead of going into language and plugin-specific details and differences, we tried to focus on the commonality and consistency that Gradle brings to the table.</p></div></body></html>