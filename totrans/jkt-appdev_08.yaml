- en: '8'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Object Relational Mapping with Jakarta Persistence
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Jakarta EE applications frequently need to persist data in a relational database.
    In this chapter, we will cover how to connect to a database and perform **Create,
    Read, Update, and Delete** (**CRUD**) **operations** via **Jakarta Persistence**.
  prefs: []
  type: TYPE_NORMAL
- en: Jakarta Persistence is the standard Jakarta EE **Object Relational Mapping**
    (**ORM**) tool. We will discuss this API in detail in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are the topics covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: The CUSTOMERDB database
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuring Jakarta Persistence
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Persisting data with Jakarta Persistence
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Entity relationships
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Composite primary keys
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Jakarta Persistence Query Language
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Criteria API
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Bean Validation support
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The source code used in this chapter can be found on GitHub at [https://github.com/PacktPublishing/Jakarta-EE-Application-Development/tree/main/ch08_src](https://github.com/PacktPublishing/Jakarta-EE-Application-Development/tree/main/ch08_src).
  prefs: []
  type: TYPE_NORMAL
- en: The CUSTOMERDB database
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our examples in this chapter use a database called `CUSTOMERDB`. This database
    contains tables to track customers and order information for a fictitious store.
    For simplicity, the database uses an in-memory H2 database.
  prefs: []
  type: TYPE_NORMAL
- en: 'A simple utility that automatically starts the database and populates all reference
    tables is included with this book’s example code. The utility can be found under
    `ch08_src/customerdb`. It is a Maven application. Therefore, it can be built from
    the command line via `mvn install`. It creates an executable JAR file with all
    dependencies included. The created JAR file can be found under the `target` directory,
    it can be run from the command line by issuing the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The schema for the `CUSTOMERDB` database is depicted in *Figure 8**.1*.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.1 – CUSTOMERDB database schema (The intend of this schema is to
    show the layout; the readability of the text in the boxes, under the headings,
    is not essential.)](img/B21231_8_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.1 – CUSTOMERDB database schema (The intent of this schema is to show
    the layout; the readability of the text in the boxes, under the headings, is not
    essential.)
  prefs: []
  type: TYPE_NORMAL
- en: As can be seen in the diagram, the database contains tables to store customer
    information including their names, addresses, and email addresses. It also contains
    tables to store order and item information.
  prefs: []
  type: TYPE_NORMAL
- en: The `ADDRESS_TYPES` table stores values such as “Home”, “Mailing” and “Shipping”,
    to distinguish the type of address in the `ADDRESSES` table; similarly, the `TELEPHONE_TYPES`
    table stores the values “Cell”, “Home”, and “Work”. These two tables are prepopulated
    when creating the database, as well as the `US_STATES` table.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: For simplicity, our database only deals with U.S. addresses.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring Jakarta Persistence
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Jakarta Persistence requires a bit of configuration before our code can work
    properly. A data source needs to be defined. The data source specifies information
    on how to reach the **Relational Database Management System** (**RDBMS**) system
    we are connecting to (server, port, database user credentials, etc.). There are
    two ways it can be set up. It can be done via the Jakarta EE implementation configuration,
    but how to do this is dependent on the specific implementation.
  prefs: []
  type: TYPE_NORMAL
- en: It can also be done by annotating an application-scoped CDI bean via the @DataSourceDefinition
    annotation.
  prefs: []
  type: TYPE_NORMAL
- en: There are advantages and disadvantages to each approach. Defining the data source
    as part of the Jakarta EE runtime configuration allows us to deploy our code to
    different environments (development, test, production) without having to make
    any modifications to our code. It also prevents adding any user credentials to
    our source. Using `@DataSourceDefinition` works across Jakarta EE implementations,
    and allows us to test and deploy our code without having to configure our Jakarta
    EE runtime.
  prefs: []
  type: TYPE_NORMAL
- en: For simplicity, our examples use `@DataSourceDefinition`, but for production
    code, configuring the Jakarta EE implementation is probably a better idea.
  prefs: []
  type: TYPE_NORMAL
- en: 'Typically, we use `@DataSourceDefinition` in an application-scoped CDI bean,
    as illustrated in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The value of the `name` attribute in `@DataSourceDefinition` defines the JNDI
    name or our data source. The value of the `url` attribute of `@DataSourceDefinition`
    defines the `user` and `password` attributes of `@DataSourceDefinition` define
    the user credentials needed to log in to our database.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once a data source has been defined, an XML configuration file named `persistence.xml`
    must be deployed in the WAR file containing the aforementioned bean. This file
    must be placed in the `WEB-INF/classes/META-INF/` directory inside the WAR file.
    An example `persistence.xml` configuration file is shown next:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '`persistence.xml` must contain at least one `<persistence-unit>` element. Each
    `<persistence-unit>` element must provide a value for its `name` attribute and
    must contain a `<jta-data-source>` child element whose value is the JNDI name
    of the data source to be used for the persistence unit.'
  prefs: []
  type: TYPE_NORMAL
- en: The value of the `<jta-data-source>` tag must come from a data source configured
    in our Jakarta EE implementation. Notice that in our example, the value of the
    `<jta-data-source>` tag matches the value of the name attribute in the data source
    we defined using `@DataSourceDefinition`.
  prefs: []
  type: TYPE_NORMAL
- en: The value of the `<provider>` tag must be an implementation of the `jakarta.persistence.spi.PersistenceProvider`
    interface. The exact value depends on the Jakarta Persistence implementation being
    used. In our example, we are using GlassFish as our Jakarta EE implementation,
    which includes EclipseLink as its Jakarta Persistence implementation. Therefore,
    we use the EclipseLink-provided PersistenceProvider implementation.
  prefs: []
  type: TYPE_NORMAL
- en: The reason more than one `<persistence-unit>` element is allowed is because
    an application may access more than one database. A `<persistence-unit>` element
    is required for each database the application will access. If the application
    defines more than one `<persistence-unit>` element, then the `@PersistenceContext`
    annotation used to inject `EntityManager` must provide a value for its `unitName`
    element. The value for this element must match the `name` attribute of the corresponding
    `<persistence-unit>` element in `persistence.xml`.
  prefs: []
  type: TYPE_NORMAL
- en: If our `persistence.xml` configuration class defines more than one persistence
    unit, we need to list the Jakarta Persistence entities managed by that persistence
    unit via a `<class>` tag inside each `<persistence-unit>` tag. Listing each Jakarta
    EE entity inside `<persistence-unit>` is a tedious task, but thankfully, most
    projects define a single persistence unit. We can avoid listing each and every
    Jakarta Persistence entity by using the `<exclude-unlisted-classes>` tag with
    a value of `false`, as illustrated in our example.
  prefs: []
  type: TYPE_NORMAL
- en: Persisting data with Jakarta Persistence
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Jakarta Persistence is used to persist data to an RDBMS. Jakarta Persistence
    Entities are regular Java classes; the Jakarta EE runtime knows these classes
    are Entities because they are decorated with the `@Entity` annotation. Let’s look
    at a Jakarta Persistence Entity mapping to the `CUSTOMER` table in the `CUSTOMERDB`
    database:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: In our example code, the `@Entity` annotation lets any other Jakarta EE-compliant
    runtime know that this class is a Jakarta Persistence entity.
  prefs: []
  type: TYPE_NORMAL
- en: The `@Table(name = "CUSTOMERS")` annotation lets the application server know
    what table to map the entity to. The value of the name element contains the name
    of the database table that the entity maps to. This annotation is optional. If
    the name of the class maps the name of the database table (case insensitive),
    then it isn’t necessary to specify what table the entity maps to.
  prefs: []
  type: TYPE_NORMAL
- en: The `@Id` annotation indicates that the `customerId` field maps to the primary
    key.
  prefs: []
  type: TYPE_NORMAL
- en: The `@Column` annotation maps each field to a column in the table. If the name
    of the field matches the name of the database column, then this annotation is
    not needed. This is the reason why the `email` field is not annotated.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `EntityManager` interface is used to persist entities to a database. The
    following example illustrates its usage:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Our example CDI named bean obtains an instance of a class implementing the `jakarta.persistence.EntityManager`
    interface via dependency injection. This is done by decorating the `EntityManager`
    variable with the `@``PersistenceContext` annotation.
  prefs: []
  type: TYPE_NORMAL
- en: An instance of a class implementing the `jakarta.transaction.UserTransaction`
    interface is then injected via the `@Resource` annotation. This object is necessary,
    as without it, invoking calls to persist Entities to the database the code would
    throw a `jakarta.persistence.TransactionRequiredException`.
  prefs: []
  type: TYPE_NORMAL
- en: '`EntityManager` instances perform many database-related tasks including finding
    entities in the database, updating them, and deleting them.'
  prefs: []
  type: TYPE_NORMAL
- en: Since Jakarta Persistence entities are **plain old Java objects** (**POJOs**),
    they can be instantiated via the new operator.
  prefs: []
  type: TYPE_NORMAL
- en: Calls to the `persist()` method on `EntityManager` must be in a transaction,
    therefore it is necessary to start one by calling the `begin()` method on `UserTransaction`.
  prefs: []
  type: TYPE_NORMAL
- en: We then insert two new rows into the `CUSTOMERS` table by calling the `persist()`
    method on `EntityManager` for the two instances of the `Customer` class we populated
    earlier in the code.
  prefs: []
  type: TYPE_NORMAL
- en: After persisting the data contained in the `customer` and `customer2` objects,
    we search the database for a row in the `CUSTOMERS` table with a primary key of
    4\. We do this by invoking the `find()` method on `EntityManager`. This method
    takes the class of `Entity` we are searching for as its first parameter, and the
    primary key of the row corresponding to the object we want to obtain.
  prefs: []
  type: TYPE_NORMAL
- en: The primary key we set for the `customer2` object was 4, therefore what we have
    now is a copy of this object. The last name of this customer was misspelled when
    we originally inserted his data into the database, so we now correct Mr. Johnson’s
    last name by invoking the `setLastName()` method on `customer3`, then update the
    information in the database by invoking `entityManager.persist()`.
  prefs: []
  type: TYPE_NORMAL
- en: We then delete the information for the customer object by invoking `entityManager.remove()`
    and passing the `customer` object as a parameter.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we commit the changes to the database by invoking the `commit()` method
    on `userTransaction`.
  prefs: []
  type: TYPE_NORMAL
- en: Cannot persist detached object exception
  prefs: []
  type: TYPE_NORMAL
- en: Frequently, an application will retrieve a Jakarta Persistence entity via the
    `EntityManager.find()` method, then pass this entity to a business or user interface
    layer, where it will potentially be modified, and later the database data corresponding
    to the entity will be updated. In cases like this, invoking `EntityManager.persist()`
    will result in an exception. In order to update Jakarta Persistence entities this
    way we need to invoke `EntityManager.merge()`. This method takes an instance of
    the Jakarta Persistence entity as its single argument and updates the corresponding
    row in the database with the data stored in it.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve seen how to handle single Jakarta Persistence entities, we’ll
    focus our attention on how to define entity relationships.
  prefs: []
  type: TYPE_NORMAL
- en: Entity relationships
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous section, we saw how to retrieve, insert, update, and delete
    single entities from the database. Entities are rarely isolated – in the vast
    majority of cases, they are related to other entities.
  prefs: []
  type: TYPE_NORMAL
- en: Entities can have one-to-one, one-to-many, many-to-one, and many-to-many relationships.
  prefs: []
  type: TYPE_NORMAL
- en: In the CUSTOMERDB database, for example, there is a `LOGIN_INFO` and the `CUSTOMERS`
    tables. This means that each customer has exactly one corresponding row in the
    login info table. There is also a `CUSTOMERS` table and the `ORDERS` table. This
    is because a customer can place many orders, but each order belongs only to a
    single customer. There is also a `ORDERS` table and the `ITEMS` table. This is
    because an order can contain many items and an item can be in many orders.
  prefs: []
  type: TYPE_NORMAL
- en: In the next few sections, we discuss how to establish relationships between
    Jakarta Persistence entities.
  prefs: []
  type: TYPE_NORMAL
- en: One-to-one relationships
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One-to-one relationships occur when an instance of an entity can have zero or
    one corresponding instance of another entity.
  prefs: []
  type: TYPE_NORMAL
- en: One-to-one entity relationships can be bidirectional (each entity is aware of
    the relationship) or unidirectional (only one of the entities is aware of the
    relationship). In the CUSTOMERDB database, the one-to-one mapping between the
    `LOGIN_INFO` and the `CUSTOMERS` tables is unidirectional, since the `LOGIN_INFO`
    table has a foreign key to the `CUSTOMERS` table, but not the other way around.
    As we will soon see, this fact does not stop us from creating a bidirectional
    one-to-one relationship between the `Customer` entity and the `LoginInfo` entity.
  prefs: []
  type: TYPE_NORMAL
- en: 'The source code for the `LoginInfo` entity, which maps to the `LOGIN_INFO`
    table, is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The code for this entity is very similar to the code for the `Customer` entity;
    it defines fields that map to database columns. Each field whose name does not
    match the database column name is annotated with `@Column`, in addition to that,
    the primary key is annotated with `@Id`.
  prefs: []
  type: TYPE_NORMAL
- en: Where the preceding code gets interesting is in the declaration of the `customer`
    field. As can be seen in the code, the `customer` field is annotated with `@OneToOne`,
    this lets the Jakarta EE runtime know that there is a one-to-one relationship
    between this entity and the `Customer` entity. The customer field is also annotated
    with `@JoinColumn`. This annotation lets the container know what column in the
    `LOGIN_INFO` table is the foreign key corresponding to the primary key on the
    `CUSTOMER` table. Since `LOGIN_INFO`, the table that the `LoginInfo` entity maps
    to, has a foreign key to the `CUSTOMER` table, the `LoginInfo` entity owns the
    relationship. If the relationship was unidirectional, we wouldn’t have to make
    any changes to the `Customer` entity. However, since we would like to have a bidirectional
    relationship between these two entities, we need to add a `LoginInfo` field to
    the `Customer` entity, along with the corresponding getter and setter methods.
  prefs: []
  type: TYPE_NORMAL
- en: 'As we mentioned before, in order to make the one-to-one relationship between
    the `Customer` and `LoginInfo` entities bidirectional, we need to make a few simple
    changes to the `Customer` entity:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The only change we need to make to the `Customer` entity to make the one-to-one
    relationship bidirectional is to add a `LoginInfo` field to it, along with the
    corresponding setter and getter methods. The `loginInfo` field is annotated with
    `@OneToOne`. Since the `Customer` entity does not own the relationship (the table
    it maps to does not have a foreign key to the corresponding table), the `mappedBy`
    element of the `@OneToOne` annotation needs to be added. This element specifies
    what field in the corresponding entity has the other end of the relationship.
    In this particular case, the `customer` field in the `LoginInfo` entity corresponds
    to the other end of this one-to-one relationship.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following Java class illustrates the use of the preceding entity:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we first create an instance of the `LoginInfo` entity and populate
    it with some data. We then obtain an instance of the `Customer` entity from the
    database by invoking the `find()` method of `EntityManager` (data for this entity
    was inserted into the `CUSTOMERS` table in one of the previous examples). We then
    invoke the `setCustomer()` method on the `LoginInfo` entity, passing the customer
    object as a parameter. Finally, we invoke the `EntityManager.persist()` method
    to save the data in the database.
  prefs: []
  type: TYPE_NORMAL
- en: What happens behind the scenes is that the `CUSTOMER_ID` column of the `LOGIN_INFO`
    table gets populated with the primary key of the corresponding row in the `CUSTOMERS`
    table. This can be easily verified by querying the CUSTOMERDB database.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Notice how the call to `EntityManager.find()` to obtain the customer entity
    is inside the same transaction where we call `EntityManager.persist()`. If this
    is not the case the database will not be updated successfully.
  prefs: []
  type: TYPE_NORMAL
- en: One-to-many relationships
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Jakarta Persistence one-to-many entity relationships can be *bidirectional*
    (i.e., one entity contains a many-to-one relationship and the corresponding entity
    contains an inverse one-to-many relationship) or *unidirectional* (one entity
    contains a many-to-one relationship to another entity, which does not have a corresponding
    one-to-many relationship defined).
  prefs: []
  type: TYPE_NORMAL
- en: With SQL, one-to-many relationships are defined by foreign keys in one of the
    tables. The “many” part of the relationship is the one containing a foreign key
    to the “one” part of the relationship. One-to-many relationships defined in an
    RDBMS are typically unidirectional, since making them bidirectional usually results
    in denormalized data.
  prefs: []
  type: TYPE_NORMAL
- en: Just like when defining a unidirectional one-to-many relationship in an RDBMS,
    in Jakarta Persistence the “many” part of the relationship is the one that has
    a reference to the “one” part of the relationship, therefore the annotation used
    to define the relationship is `@ManyToOne`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the CUSTOMERDB database, there is a unidirectional one-to-many relationship
    between customers and orders. We define this relationship in the `Order` entity:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'If we were to define a unidirectional many-to-one relationship between the
    `Orders` entity and the `Customer` entity, we wouldn’t need to make any changes
    to the `Customer` entity. To define a bidirectional one-to-many relationship between
    the two entities, a new field decorated with the `@OneToMany` annotation needs
    to be added to the `Customer` entity, as illustrated in the next example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The only difference between this version of the `Customer` entity and the previous
    one is the addition of the orders field and related getter and setter methods.
    Of special interest is the `@OneToMany` annotation decorating this field. The
    `mappedBy` attribute must match the name of the corresponding field in the entity
    corresponding to the “many” part of the relationship. In simple terms, the value
    of the `mappedBy` attribute must match the name of the field decorated with the
    `@ManyToOne` annotation in the bean at the other side of the relationship.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example code illustrates how to persist one-to-many relationships
    to the database:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Our example instantiates two instances of the `Order` entity, populates them
    with some data, then in a transaction, an instance of the `Customer` entity is
    located, and used as the parameter of the `setCustomer()` method of both instances
    of the `Order` entity. We then persist both `Order` entities by invoking `EntityManager.persist()`
    for each one of them.
  prefs: []
  type: TYPE_NORMAL
- en: Just like when dealing with one-to-one relationships, what happens behind the
    scenes is that the `CUSTOMER_ID` column of the `ORDERS` table in the CUSTOMERDB
    database is populated with the primary key corresponding to the related row in
    the `CUSTOMERS` table.
  prefs: []
  type: TYPE_NORMAL
- en: Since the relationship is bidirectional, we can obtain all orders related to
    a customer by invoking the `getOrders()` method on the `Customer` entity.
  prefs: []
  type: TYPE_NORMAL
- en: Many-to-many relationships
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the CUSTOMERDB database, there is a many-to-many relationship between the
    `ORDERS` table and the `ITEMS` table. We can map this relationship by adding a
    new `Collection<Item>` field to the `Order` entity and decorating it with the
    `@``ManyToMany` annotation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: As we can see in the preceding code, in addition to being annotated with `@ManyToMany`,
    the `items` field is also annotated with `@JoinTable`. As its name suggests, this
    annotation lets the application server know what table is used as a join table
    to create the many-to-many relationship between the two entities.
  prefs: []
  type: TYPE_NORMAL
- en: '`@JoinTable` has three relevant elements: the `name` element, which defines
    the name of the join table, and the `joinColumns` and `inverseJoinColumns` elements,
    which define the columns that serve as foreign keys in the join table pointing
    to the entities’ primary keys. Values for the `joinColumns` and `inverseJoinColumns`
    elements are yet another annotation, the `@JoinColumn` annotation. This annotation
    has two relevant elements, the `name` element, which defines the name of the column
    in the join table, and the `referencedColumnName` element, which defines the name
    of the column in the entity table.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Item` entity is a simple entity mapping to the `ITEMS` table in the CUSTOMERDB
    database:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Just like one-to-one and one-to-many relationships, many-to-many relationships
    can be unidirectional or bidirectional. Since we would like the many-to-many relationship
    between the `Order` and `Item` entities to be bidirectional, we added a `Collection<Order>`
    field and decorated it with the `@ManyToMany` annotation. Since the corresponding
    field in the `Order` entity already has the join table defined, it is not necessary
    to do it again here. The entity containing the `@JoinTable` annotation is said
    to own the relationship, in a many-to-many relationship, either entity can own
    the relationship. In our example, the `Order` entity owns it, since its `Collection<Item>`
    field is decorated with the `@``JoinTable` annotation.
  prefs: []
  type: TYPE_NORMAL
- en: Just like with the one-to-one and one-to-many relationships, the `@ManyToMany`
    annotation on the non-owning side of a bidirectional many-to-many relationship
    must contain a `mappedBy` element indicating what field in the owning entity defines
    the relationship.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have seen the changes necessary to establish a bidirectional many-to-many
    relationship between the `Order` and `Item` entities, we can see the relationship
    in action in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code creates two instances of the `Item` entity and populates
    them with some data. It then adds these two instances to a collection. A transaction
    is then started, the two `Item` instances are persisted in the database. Then
    an instance of the `Order` entity is retrieved from the database. The `setItems()`
    method of the `Order` entity instance is then invoked, passing the collection
    containing the two `Item` instances as a parameter. The `Customer` instance is
    then persisted into the database. At this point, two rows are created behind the
    scenes to the `ORDER_ITEMS` table, which is the join table between the `ORDERS`
    and `ITEMS` tables.
  prefs: []
  type: TYPE_NORMAL
- en: Composite primary keys
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Most tables in the CUSTOMERDB database have a column with the sole purpose of
    serving as a primary key (this type of primary key is sometimes referred to as
    a surrogate primary key or as an artificial primary key). However, some databases
    are not designed this way. Instead, a column in the database that is known to
    be unique across rows is used as the primary key. If there is no column whose
    value is not guaranteed to be unique across rows, then a combination of two or
    more columns is used as the table’s primary key. It is possible to map this kind
    of primary key to Jakarta Persistence entities by using a **primary** **key class**.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is one table in the CUSTOMERDB database that does not have a surrogate
    primary key, this table is the `ORDER_ITEMS` table. This table serves as a join
    table between the `ORDERS` and `ITEMS` tables. In addition to having foreign keys
    for these two tables, this table has an additional column called `ITEM_QTY`, which
    stores the quantity of each item in an order. Since this table does not have a
    surrogate primary key, the Jakarta Persistence entity mapping to it must have
    a custom primary key class. In this table, the combination of the `ORDER_ID` and
    the `ITEM_ID` columns must be unique. Therefore, this is a good combination for
    a composite primary key, as illustrated in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'A custom primary key class must satisfy the following requirements:'
  prefs: []
  type: TYPE_NORMAL
- en: The class must be public
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It must implement `java.io.Serializable`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It must have a public constructor that takes no arguments
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Its fields must be `public` or `protected`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Its field names and types must match those of the entity
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It must override the default `hashCode()` and `equals()` methods defined in
    the `java.lang.Object` class
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The preceding `OrderPK` class meets all of these requirements. It also has a
    convenience constructor that takes two `Long` objects meant to initialize its
    `orderId` and `itemId` fields. This constructor was added for convenience; this
    is not a requirement for the class to be used as a primary key class.
  prefs: []
  type: TYPE_NORMAL
- en: 'When an entity uses a custom primary key class, it must be annotated with `@IdClass`.
    Since the `OrderItem` class uses `OrderItemPK` as its custom primary key class,
    it is annotated with said annotation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: There are two differences between the `OrderItem` entity and the previous entities
    we have seen. The first difference is that this entity is annotated with `@IdClass`,
    indicating the primary key class corresponding to it. The second difference is
    that `OrderItem` has more than one field annotated with `@Id`. Since this entity
    has a composite primary key, each field that is part of the primary key must be
    annotated with this annotation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Obtaining a reference of an entity with a composite primary key is not much
    different than obtaining a reference to an entity with a primary key consisting
    of a single field. The following example demonstrates how to do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: As can be seen in this example, the only difference between locating an entity
    with a composite primary key and an entity with a primary key consisting of a
    single field is that an instance of the custom primary key class must be passed
    as the second argument of the `EntityManager.find()` method; fields for this instance
    must be populated with the appropriate values for each field that is part of the
    primary key.
  prefs: []
  type: TYPE_NORMAL
- en: Jakarta Persistence Query Language
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: All of our examples that obtain entities from the database so far have conveniently
    assumed that the primary key for the entity is known ahead of time. We all know
    that frequently this is not the case. Whenever we need to search for an entity
    by a field other than the entity’s primary key, we can use the **Jakarta Persistence
    Query** **Language** (**JPQL**).
  prefs: []
  type: TYPE_NORMAL
- en: 'JPQL is an SQL-like language used for retrieving, updating, and deleting entities
    in a database. The following example illustrates how to use JPQL to retrieve a
    subset of states from the `US_STATES` table in the CUSTOMERDB database:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code invokes the `EntityManager.createQuery()` method, passing
    a `String` containing a JPQL query as a parameter. This method returns an instance
    of `jakarta.persistence.Query`. The query retrieves all `UsState` entities whose
    names start with the word “New”.
  prefs: []
  type: TYPE_NORMAL
- en: 'As can be seen in the preceding code, JPQL is similar to SQL, however, there
    are some differences that may confuse readers with SQL knowledge. The equivalent
    SQL code for the query in the code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The first difference between JPQL and SQL is that in JPQL, we always reference
    entity names, whereas in SQL table names are referenced. The `s` after the entity
    name in the JPQL query is an alias for the entity. Table aliases are optional
    in SQL, but entity aliases are required in JPQL. Keeping these differences in
    mind, the JPQL query should now be a lot less confusing.
  prefs: []
  type: TYPE_NORMAL
- en: The `:name` in the query is a `setParameter()` method in the instance of `jakarta.persistence.Query`
    returned by the call to `EntityManager.createQuery()`. A JPQL query can have multiple
    named parameters.
  prefs: []
  type: TYPE_NORMAL
- en: To actually run the query and retrieve the entities from the database, we can
    invoke the `getResultList()` method on the instance of `jakarta.persistence.Query`
    obtained from `EntityManager.createQuery()`. This method returns an instance of
    a class implementing the `java.util.List` interface, this list contains the entities
    matching the query criteria. If no entities match the criteria, then an empty
    list is returned.
  prefs: []
  type: TYPE_NORMAL
- en: If we are certain that the query will return exactly one entity, then the `getSingleResult()`
    method may be alternatively called on `Query`, this method returns an `Object`
    that must be cast to the appropriate entity.
  prefs: []
  type: TYPE_NORMAL
- en: The preceding example uses the `LIKE` operator to find entities whose name starts
    with the word “New”. This is accomplished by substituting the query’s named parameter
    with the value `New%`. The percent sign at the end of the parameter value means
    that any number of characters after the word “New” will match the expression.
    The percent sign can be used anywhere in the parameter value, for example, a value
    of `%Dakota` would match any entities whose names end in “Dakota”, while a value
    of `A%a` would match any states whose names start with a capital “A” and end with
    a lowercase “a”. There can be more than one percent sign in a parameter value.
    The underscore sign (`_`) can be used to match a single character, all the rules
    for the percent sign apply to the underscore as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition to the `LIKE` operator, there are other operators that can be used
    to retrieve entities from the database:'
  prefs: []
  type: TYPE_NORMAL
- en: The `=` operator will retrieve entities whose field on the left of the operator
    exactly match the value to the right of the operator
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `>` operator will retrieve entities whose field on the left of the operator
    is greater than the value to the right of the operator
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `<` operator will retrieve entities whose field on the left of the operator
    is less than the value to the right of the operator
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `>=` operator will retrieve entities whose field on the left of the operator
    is greater than or equal to the value to the right of the operator
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `<=` operator will retrieve entities whose field on the left of the operator
    is less than or equal to the value to the right of the operator
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All of the preceding operators work the same way as the equivalent operators
    in SQL. Just like in SQL, these operators can be combined with the “AND” and “OR”
    operators. Conditions combined with the “AND” operator match if both conditions
    are true, while conditions combined with the “OR” operator match if at least one
    of the conditions is true.
  prefs: []
  type: TYPE_NORMAL
- en: If we intend to use a query many times, it can be stored in a `@NamedQuery`
    annotation. This annotation has two elements, a `name` element used to set the
    name of the query; and a `query` element defining the query itself. To execute
    a named query, the `createNamedQuery()` method must be invoked in an instance
    of `EntityManager`. This method takes a `String` containing the query name as
    its sole parameter, and returns an instance of `jakarta.persistence.Query`.
  prefs: []
  type: TYPE_NORMAL
- en: In addition to retrieving entities, JPQL can be used to modify or delete entities.
    However, entity modification and deletion can be done programmatically via the
    `EntityManager` interface, doing so results in code that tends to be more readable
    than when using JPQL. Because of this, we will not cover entity modification and
    deletion via JPQL. Readers interested in writing JPQL queries to modify and delete
    entities, as well as readers wishing to know more about JPQL are encouraged to
    review the Jakarta Persistence 3.1 specification. This specification can be found
    at [https://jakarta.ee/specifications/persistence/3.1/jakarta-persistence-spec-3.1](https://jakarta.ee/specifications/persistence/3.1/jakarta-persistence-spec-3.1).
  prefs: []
  type: TYPE_NORMAL
- en: In addition to JPQL, Jakarta Persistence provides an API we can use to create
    queries, named, appropriately enough, the Criteria API.
  prefs: []
  type: TYPE_NORMAL
- en: Criteria API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Jakarta Persistence **Criteria API** is meant as a complement to JPQL. The
    Criteria API allows us to write Jakarta Persistence queries programmatically,
    without having to rely on JPQL.
  prefs: []
  type: TYPE_NORMAL
- en: The Criteria API offers a few advantages over JPQL – for instance, JPQL queries
    are stored as Strings, and the compiler has no way of validating JPQL syntax.
    Additionally, JPQL is not type safe; we could write a JPQL query in which our
    `where` clause could have a string value for a numeric property, and our code
    would compile and deploy just fine.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code example illustrates how to use the Criteria API in our Jakarta
    EE applications:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The preceding example is equivalent to the JPQL example we saw earlier in this
    chapter. This example, however, takes advantage of the Criteria API instead of
    relying on JPQL.
  prefs: []
  type: TYPE_NORMAL
- en: When writing code using the Criteria API, the first thing we need to do is to
    obtain an instance of a class implementing the `jakarta.persistence.criteria.CriteriaBuilder`
    interface. As we can see in the preceding example, we need to obtain said instance
    by invoking the `getCriteriaBuilder()` method on our `EntityManager`.
  prefs: []
  type: TYPE_NORMAL
- en: From our `CriteriaBuilder` implementation, we need to obtain an instance of
    a class implementing the `jakarta.persistence.criteria.CriteriaQuery` interface.
    We do this by invoking the `createQuery()` method in our `CriteriaBuilder` implementation.
    Notice that `CriteriaQuery` is generically typed. The generic type argument dictates
    the type of result that our `CriteriaQuery` implementation will return upon execution.
    By taking advantage of generics in this way, the Criteria API allows us to write
    type-safe code.
  prefs: []
  type: TYPE_NORMAL
- en: Once we have obtained a `CriteriaQuery` implementation, from it we can obtain
    an instance of a class implementing the `jakarta.persistence.criteria.Root` interface.
    The Root implementation dictates what Jakarta Persistence entity we will be querying
    from. It is analogous to the `FROM` query in JPQL (and SQL).
  prefs: []
  type: TYPE_NORMAL
- en: The next two lines in our example take advantage of another feature of the Jakarta
    Persistence specification, the `jakarta.persistence.metamodel.Metamodel` interface
    by invoking the `getMetamodel()` method on our `EntityManager`.
  prefs: []
  type: TYPE_NORMAL
- en: From our `Metamodel` implementation, we can obtain a generically typed instance
    of the `jakarta.persistence.metamodel.EntityType` interface. The generic type
    argument indicates the Jakarta Persistence entity our `EntityType` implementation
    corresponds to. `EntityType` allows us to browse the persistent attributes of
    our Jakarta Persistence entities at runtime. Which is exactly what we do in the
    next line in our example. In our case, we are getting an instance of `SingularAttribute`,
    which maps to a simple, singular attribute in our Jakarta Persistence entity.
    `EntityType` has methods to obtain attributes that map to collections, sets, lists,
    and maps. Obtaining these types of attributes is very similar to obtaining a `SingularAttribute`,
    therefore we won’t be covering those directly. Please refer to the Jakarta EE
    API documentation at [https://jakarta.ee/specifications/platform/10/apidocs/](https://jakarta.ee/specifications/platform/10/apidocs/)
    for more information.
  prefs: []
  type: TYPE_NORMAL
- en: As we can see in our example, `SingularAttribute` contains two generic type
    arguments. The first argument dictates the Jakarta Persistence entity we are working
    with, and the second one indicates the type of the attribute. We obtain our `SingularAttribute`
    by invoking the `getDeclaredSingularAttribute()` method on our `EntityType` implementation,
    and passing the attribute name (as declared in our Jakarta Persistence entity)
    as a String.
  prefs: []
  type: TYPE_NORMAL
- en: Once we have obtained our `SingularAttribute` implementation, we need to obtain
    an import `jakarta.persistence.criteria.Path` implementation by invoking the `get()`
    method in our `Root` instance, and passing our `SingularAttribute` as a parameter.
  prefs: []
  type: TYPE_NORMAL
- en: In our example, we will get a list of all the “new” states in the United States
    (that is, all states whose names start with “New”). This, of course, is a job
    for a “like” condition. We can do this with the Criteria API by invoking the `like()`
    method on our `CriteriaBuilder` implementation. The `like()` method takes our
    `Path` implementation as its first parameter, and the value to search for as its
    second parameter.
  prefs: []
  type: TYPE_NORMAL
- en: '`CriteriaBuilder` has a number of methods that are analogous to SQL and JPQL
    clauses such as `equals(),` `greaterThan()`, `lessThan()`, `and()`, `or()`, and
    so on and so forth (for the complete list, refer to the online Jakarta EE documentation).
    These methods can be combined to create complex queries via the Criteria API.'
  prefs: []
  type: TYPE_NORMAL
- en: The `like()` method in `CriteriaBuilder` returns an implementation of the `jakarta.persistence.criteria.Predicate`
    interface, which we need to pass to the `where()` method in our `CriteriaQuery`
    implementation. This method returns a new instance of `CriteriaBuilder`, which
    we assign to our `criteriaBuilder` variable.
  prefs: []
  type: TYPE_NORMAL
- en: At this point, we are ready to build our query. When working with the Criteria
    API, we deal with the `jakarta.persistence.TypedQuery` interface, which can be
    thought of as a type-safe version of the `Query` interface we use with JPQL. We
    obtain an instance of `TypedQuery` by invoking the `createQuery()` method in `EntityManager`,
    and passing our `CriteriaQuery` implementation as a parameter.
  prefs: []
  type: TYPE_NORMAL
- en: To obtain our query results as a list, we simply invoke `getResultList()` on
    our `TypedQuery` implementation. It is worth reiterating that the Criteria API
    is type safe, therefore attempting to assign the results of `getResultList()`
    to a List of the wrong type would result in a compilation error.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s look into how we can update data with the Criteria API.
  prefs: []
  type: TYPE_NORMAL
- en: Updating data with the Criteria API
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We can update database data using the Criteria API using the `CriteriaUpdate`
    interface. The following example illustrates how to do so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: What this example is doing is finding all of the database rows with entries
    of a city called “New Yorc” (a typo), and replacing the value with the correct
    spelling of “New York”.
  prefs: []
  type: TYPE_NORMAL
- en: Just like in the previous example, we obtain an instance of a class implementing
    the `CriteriaBuilder` interface by invoking the `getCriteriaBuilder()` method
    on our `EntityManager` instance.
  prefs: []
  type: TYPE_NORMAL
- en: We then obtain an instance of a class implementing `CriteriaUpdate` by invoking
    `createCriteriaUpdate()` on our `CriteriaBuilder` instance.
  prefs: []
  type: TYPE_NORMAL
- en: The next step is to obtain an instance of a class implementing `Root` by invoking
    the `from()` method on our `CriteriaUpdate` instance.
  prefs: []
  type: TYPE_NORMAL
- en: We then invoke the `set()` method on `CriteriaUpdate` to specify the new values
    our rows will have after they have been updated. The first parameter of the `set()`
    method must be a `String` matching the property name in the Entity class, and
    the second parameter must be the new value.
  prefs: []
  type: TYPE_NORMAL
- en: At this point, we build the where clause by invoking the `where()` method on
    `CriteriaUpdate`, and passing the `Predicate` returned by the `equal()` method
    invoked in `CriteriaBuilder`.
  prefs: []
  type: TYPE_NORMAL
- en: Then we get a `Query` implementation by invoking `createQuery()` on `EntityManager`,
    and passing our `CriteriaUpdate` instance as a parameter.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we execute our query as usual by invoking `executeUpdate()` on our
    `Query` implementation.
  prefs: []
  type: TYPE_NORMAL
- en: Deleting data with the Criteria API
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We can delete database data with the Jakarta Persistence Criteria API. This
    can be done with the `CriteriaDelete` interface. The following code snippet illustrates
    its usage:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: To use `CriteriaDelete`, we first obtain an instance of `CriteriaBuilder` as
    usual, then invoke the `createCriteriaDelete()` method on our `CriteriaBuilder`
    instance to obtain an implementation of `CriteriaDelete`.
  prefs: []
  type: TYPE_NORMAL
- en: Once we have an instance of `CriteriaDelete`, we build the `where` clause as
    it is usually done with the Criteria API.
  prefs: []
  type: TYPE_NORMAL
- en: Once we have built our `where` clause, we obtain an implementation of the `Query`
    interface and invoke `executeUpdate()` on it as usual.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve seen how to insert and retrieve database data, we’ll turn our
    attention to data validation via Bean Validation.
  prefs: []
  type: TYPE_NORMAL
- en: Bean Validation support
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Bean Validation is a Jakarta EE specification consisting of a number of annotations
    used to simplify data validation. Jakarta Persistence Bean Validation support
    allows us to annotate our entities with Bean Validation annotations. These annotations
    allow us to easily validate user input and perform data sanitation.
  prefs: []
  type: TYPE_NORMAL
- en: Taking advantage of Bean Validation is very simple. All we need to do is annotate
    our Jakarta Persistence Entity fields or getter methods with any of the validation
    annotations defined in the `jakarta.validation.constraints` package. Once our
    fields are annotated as appropriate, `EntityManager` will prevent non-validating
    data from being persisted.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code example is a modified version of the `Customer` Jakarta
    Persistence entity we saw earlier in this chapter. It has been modified to take
    advantage of Bean Validation in some of its fields:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we used the `@NotNull` annotation to prevent the `firstName`
    and `lastName` of our entity from being persisted with `null` values. We also
    used the `@Size` annotation to restrict the minimum and maximum length of these
    fields.
  prefs: []
  type: TYPE_NORMAL
- en: That is all we need to do to take advantage of bean validation in Jakarta Persistence.
    If our code attempts to persist or update an instance of our entity that does
    not pass the declared validation, an exception of type `jakarta.validation.ConstraintViolationException`
    will be thrown, and the entity will not be persisted.
  prefs: []
  type: TYPE_NORMAL
- en: As we can see Bean Validation pretty much automates data validation, freeing
    us from having to manually write validation code.
  prefs: []
  type: TYPE_NORMAL
- en: In addition to the two annotations discussed in the previous example, the `jakarta.validation.constraints`
    package contains several additional annotations we can use to automate validation
    on our Jakarta Persistence entities. Please refer to the online Jakarta EE 10
    API for the complete list.
  prefs: []
  type: TYPE_NORMAL
- en: Final notes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the examples for this chapter, we demonstrated database access directly from
    CDI named beans serving as controllers. We did this to get the point across without
    bogging ourselves down with details; however, in general, this is not a good practice.
    Database access code should be encapsulated in **Data Access** **Objects** (**DAOs**).
  prefs: []
  type: TYPE_NORMAL
- en: DAO design pattern
  prefs: []
  type: TYPE_NORMAL
- en: For more information on the DAO design pattern, see [http://www.oracle.com/technetwork/java/dao-138818.html](http://www.oracle.com/technetwork/java/dao-138818.html).
  prefs: []
  type: TYPE_NORMAL
- en: Named beans typically assume the role of controllers and/or models when using
    the **Model-View-Controller** (**MVC**) design pattern, a practice so common that
    it has become a de-facto standard for Jakarta EE applications.
  prefs: []
  type: TYPE_NORMAL
- en: MVC design pattern
  prefs: []
  type: TYPE_NORMAL
- en: For more information about the MVC design pattern, see [https://en.wikipedia.org/wiki/Model%E2%80%93view%E2%80%93controller](https://en.wikipedia.org/wiki/Model%E2%80%93view%E2%80%93controller).
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, we chose not to show any user interface code in our examples as
    it was irrelevant to the topic at hand. However, the code downloads for this chapter
    include Jakarta Faces pages that invoke the named beans in this chapter and display
    a confirmation page once the named-bean invocation finishes.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter covered how to access data in a database via Jakarta Persistence,
    the standard object-relational mapping API of Jakarta EE.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we covered the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: How to mark a Java class as a Jakarta Persistence entity by decorating it with
    the `@Entity` annotation, and how to map it to a database table via the `@Table`
    annotation. We also covered how to map entity fields to database columns via the
    `@``Column` annotation.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the `jakarta.persistence.EntityManager` interface to find, persist, and
    update Jakarta Persistence entities.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to define unidirectional and bidirectional one-to-one, one-to-many, and
    many-to-many relationships between Jakarta Persistence entities.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to use composite primary keys by developing custom primary key classes.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to retrieve entities from a database by using the **Jakarta Persistence
    Query Language** (**JPQL**) and the Criteria API.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Bean Validation, which allows us to easily validate input by simply annotating
    our Jakarta Persistence entity fields.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Jakarta Persistence abstracts out database access code and allows us to code
    against Java objects as opposed to database tables. It also works with every popular
    RDBMS system, making our code easily portable across different relational database
    management systems.
  prefs: []
  type: TYPE_NORMAL
