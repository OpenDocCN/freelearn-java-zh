<html><head></head><body><div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">RESTful APIs</h1>
                </header>
            
            <article>
                
<p class="mce-root">In this chapter, we will learn about the basics of REST and how to use Postman and Spring for accessing and writing REST APIs. Lastly, we will build an app with a REST interface.</p>
<p class="mce-root">Postman is a GUI-driven app for interacting with HTTP APIs by constructing requests and reading responses.</p>
<p>By the end of this chapter, you will be able to:</p>
<ul>
<li>Explain the fundamentals of REST</li>
<li>Utilize Postman to access both public and personal REST APIs</li>
<li>Utilize Spring for writing REST APIs</li>
<li>Build an app with a REST interface, based on the blogmania app</li>
</ul>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">What is a RESTful API?</h1>
                </header>
            
            <article>
                
<p>An <strong>Application Programming Interface</strong> (<strong>API</strong>) is an access point to a software meant for machines (or other software products) rather than people. It has become kind of a buzzword lately, even though the concept has been there for decades.</p>
<p>APIs, and more specifically (and more recently) REST APIs, are the backbone of communication services. They are what modern distributed cloud-based applications work through. They are also the way that modern browser user interfaces communicate with their backend services.</p>
<p>For communication services, there are different styles of API. What kinds can you come up with? Examples include the following:</p>
<ul>
<li>RPC</li>
<li>SOAP</li>
<li>REST</li>
</ul>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">REST – Formal Definition</h1>
                </header>
            
            <article>
                
<p>The acronym <strong>REST</strong> stands for <strong>REpresentational State Transfer</strong>. The term was coined in the influential work <em>Architectural Styles and the Design of Network-Based Software Architectures</em>, (University of California, Irvine, 2000) by Roy Fielding. As this was his doctoral dissertation, few people have actually read it, and it is far beyond the scope of a Spring Boot book.</p>
<div class="packt_infobox"><br/>
Fielding's original work can be viewed online at <a href="https://www.ics.uci.edu/~fielding/pubs/dissertation/rest_arch_style.htm">https://www.ics.uci.edu/~fielding/pubs/dissertation/rest_arch_style.htm</a><br/>
for your reference.<br/>
For a more hands-on view, similar to what we will take in this book, you may go to <a href="https://searchmicroservices.techtarget.com/definition/REST-representational-state-transfer">https://searchmicroservices.techtarget.com/definition/REST-representational-state-transfer</a> instead.</div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">The RESTful API – Practitioner's Definition</h1>
                </header>
            
            <article>
                
<p>For a programmer, a slightly relaxed set of rules is sufficient for daily work. On the other hand, we use some fixed defaults where the REST architecture allows different choices:</p>
<ul>
<li>HTTP calls using all the verbs<span>—</span>Calls in RESTful APIs are done using the well-known HTTP protocol. This allows us to use all the infrastructure of the web, such as load balancers or caches. In addition to GET and POST calls, a RESTful API also uses <kbd>PUT</kbd> and <kbd>DELETE</kbd>.</li>
<li>Pass options in the URL or in headers<span>—</span>It is customary to put real data in the body of requests, but only options that influence the search or the requested representation of the response in URL parameters or even HTTP headers.</li>
<li>Answer status as HTTP status code<span>—</span>HTTP offers a wide range of response codes. On the WWW, you mostly see only <span class="packt_screen">200</span> (OK) and <span class="packt_screen">404</span> (Not Found), but there are codes to signify that the request was in a bad format or that a new entity was created.</li>
<li>Request and answer payload in JSON format—JSON is the de facto standard these days. This excludes, of course, binary data such as images, which are transmitted as is.</li>
</ul>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Showing the Yes/No API in Postman</h1>
                </header>
            
            <article>
                
<p>When starting Postman for the first time, you must get past two dialogs: the first prompts you to register, but there is a link to take you to the app without registering. The second creates a collection of queries, and Postman requires at least one such collection, even if you do not intend to save your queries at all.</p>
<p>Once inside the main window, enter <a href="https://yesno.wtf/api">https://yesno.wtf/api</a> into the field for the URL. In front of this field, there is a dropdown for the HTTP method; leave it at GET. After pressing the <span class="packt_screen">Enter</span> key (or the <span class="packt_screen">Send</span> button), the request is performed, and you can see the response status (which should be <span class="packt_screen">200 OK</span>) and the response body in JSON format.</p>
<p>The response body contains a field called <kbd>answer</kbd> which is either <span class="packt_screen">yes</span> or <span class="packt_screen">no</span>. For fun, you can click and follow the link to the image:</p>
<div class="packt_figref CDPAlignCenter CDPAlign"><img src="Images/2ee6d8f8-3067-4123-a0e3-02c1d7192b2d.png" style="width:45.08em;height:34.50em;" width="1003" height="768"/></div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">REST Guiding Principles</h1>
                </header>
            
            <article>
                
<p>Now that you have seen a REST call in action, let's revisit some guiding principles that a good REST API should follow in more detail.</p>
<p>A web browser can navigate to any kind of website. Just like this, a REST client should be able to navigate to a REST API. (Of course, in practice, this is limited by the intelligence of the machine.) This means that, ideally, all you need for an API is the starting point, and then all navigation only follows links that were embedded in a previous response. This principle is called <strong>hypertext</strong> or <strong>hypermedia</strong> - and, yes, that is the <kbd>HT</kbd> part in both <strong>HTML</strong> (<strong>Hypertext Markup Language</strong>) and <strong>HTTP</strong> (<strong>Hypertext Transfer Protocol</strong>).</p>
<p>The second principle is to make proper use of the HTTP verbs. There are quite a few of them, some rather technical and only concerned with the protocol itself, others for very special purposes.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">REST Resource Examples</h1>
                </header>
            
            <article>
                
<p>Take a look at the following table that highlights the main methods:</p>
<div class="packt_figref CDPAlignCenter CDPAlign"><img src="Images/599068f3-d67e-43db-9879-2db79e781491.png" width="2186" height="1003"/></div>
<p>The third principle is to use resources instead of remote procedure calls. This becomes very apparent when it comes to the naming of endpoints: endpoints are not verbs (after all, that is what the HTTP verbs are for), but they are nouns.</p>
<p>To visualize the lifecycle of a resource, take a look at the following diagram:</p>
<div class="packt_figref CDPAlignCenter CDPAlign"><img src="Images/1617a1d2-688e-4fc4-8f5a-4282fc32e844.png" width="1545" height="533"/></div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Utilizing SWAPI</h1>
                </header>
            
            <article>
                
<p>The aim is to view a good REST API in action. We'll be exploring or testing an existing API. Unfortunately, in the beginning, this will be a read-only API, so we will only see GET requests. The API we are using here is <strong>SWAPI</strong>, the <strong>Star Wars API</strong>. It is a REST API that allows you to browse planets, spaceships, vehicles, people, films, and species of the Star Wars universe. This API is public and not access-controlled.</p>
<p>Before beginning, you should open Postman. If your Postman app is freshly installed, you can tell it that you do not want to register at the first prompt. At the second, you have to create a collection (any name is fine, although <strong>Default</strong> may just be a good choice here). You are presented with the main window. Depending on the size of the window, the request history may or may not be displayed.</p>
<p>The steps for completion are as follows:</p>
<ol>
<li>Go to the entry URL of SWAPI: <a href="https://swapi.co/api/">https://swapi.co/api/</a>.</li>
<li>You will see as an answer a set of links to other resources: a resource for people, a resource for planets, and so on. Follow the resource for people.</li>
</ol>
<div class="packt_infobox"><br/>
In <em>step 2</em>, you get a not only people answer, since you accessed a collection resource. There are two things to take note of here: first, it is not a list containing all the people, but only the first ten, with a link to the next ten (if applicable, you may get a link to the previous ten as well). Second, each entry has a link to itself, not only an ID that could be used to construct such a link.</div>
<ol start="3">
<li>Follow the link for Luke.</li>
</ol>
<p style="padding-left: 60px"> The result of <em>step 3</em>, however, is a single entry: a resource that ends with an ID:</p>
<div class="packt_figref CDPAlignCenter CDPAlign"><img src="Images/a2075a66-361e-4534-943b-a85a908a5c48.png" style="width:46.33em;height:35.08em;" width="1007" height="764"/></div>
<p> </p>
<ol start="4">
<li>Have a look in the <strong>Headers</strong> area of the response and find the <strong>Content-Type</strong> header to confirm that the server sent JSON:</li>
</ol>
<div class="packt_figref CDPAlignCenter CDPAlign"><img src="Images/99369fbb-bd37-4699-ba4a-45ea977eb350.png" style="width:41.83em;height:31.67em;" width="1007" height="764"/></div>
<p style="padding-left: 60px">Back in the Body area, you can choose to view the raw answer of the server instead of the pretty-printed version that Postman presents to us.</p>
<ol start="5">
<li>Now, do some research: what is Luke's homeworld?</li>
</ol>
<p>You may find that Luke's homeworld is Tatooine, but the important thing to note here is that you can follow the links and explore the data just as you would on a traditional web page in a browser.</p>
<div class="packt_infobox"><br/>
All of the source code for this chapter, including some Postman collections in JSON format to be imported in Postman, can be found at <a href="https://bit.ly/2QxGni4">https://bit.ly/2QxGni4</a>  in the accompanying GitHub repository.</div>
<p>Take a look at the following Postman screenshot:</p>
<div class="packt_figref CDPAlignCenter CDPAlign"><img src="Images/957ece56-981f-4513-ad9e-9573070f2a45.png" style="width:13.00em;height:35.25em;" width="302" height="814"/></div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">REST Controllers in Spring</h1>
                </header>
            
            <article>
                
<p>Now that we have recapped what REST APIs are, you probably want to know how to use them with Spring. You will see that you already know most of what you need for this. The key is in the little enhancements that Spring provides.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">What makes a REST Controller Different?</h1>
                </header>
            
            <article>
                
<p>You have seen many controller functions in the preceding chapters. Spring is enormously flexible in the signatures that controller functions are allowed to have, both in the parameters they take and the results they return; but in most cases, the return value of such a controller function is not the actual response sent to the browser, but a view name that is then resolved against static content or a view rendered by a template engine.</p>
<p>For a REST controller, this is different— we want to return data instead. We can do this directly or by using an implicit mapper, as you will see. You have already seen in <em><a href="6c057031-8824-460d-bad6-abd27cbb3b21.xhtml">Chapter 4</a>: The MVC Pattern, in the Additional Annotations and Parameters for Handler</em><br/>
<em>Methods</em> section how to return data instead of the view name from a controller—The controller needs to be annotated with <kbd>@ResponseBody</kbd>.</p>
<p>Actually, that's all you need to know for REST controllers.</p>
<p>The rest of this section will show you how to implement all the REST-guiding principles that we introduced previously. These advanced elements are not REST-specific and can sometimes become useful in a normal Spring MVC context, but they are indispensable for implementing REST controllers.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">"Response Body" in Detail</h1>
                </header>
            
            <article>
                
<p>In this section, we will look at short code excerpts to bring the main concepts to you step by step. More complete code that is an extension to the blog application (from the previous chapter) will come a bit later.</p>
<p><span>Let's consider the following piece of code, which is a complete Spring controller class </span><span>in Java (lacking only the imports):</span></p>
<pre>@Controller<br/>public class HelloWorldController {<br/><br/>  @RequestMapping("/api/greeting/string")<br/>  @ResponseBody<br/>  public String string() {<br/>    return "Greeting";<br/>  }<br/>}</pre>
<p>Remember that the <kbd>@Controller</kbd> annotation also marks this class as a Spring component that will be found in the <kbd>classpath</kbd> scanning. The <kbd>@RequestMapping</kbd> annotation marks a method as a method to map to a certain path, given here as its argument. Finally, the <kbd>@ResponseBody</kbd> annotation lets Spring return the literal data of the method's return value instead of mapping it using a view name.</p>
<p class="mce-root"/>
<p>Now, what will the outcome be? You can actually follow that link in your web browser or in Postman, but for this document, we will use a notation that looks like the HTTP communication on the wire, with only some details left off. If you are interested, you can look at this for yourself by using telnet, but mostly it is very convenient for showing both the client's request and the server's response:</p>
<pre>GET /api/greeting HTTP/1.1<br/>Content-Length: 8<br/>Content-Type: text/plain;charset=UTF-8<br/>Greeting</pre>
<p>As you can see, the String return value of our method is also the data that the server sends out. Spring filled out some response headers automatically—it set the Content-Length to <kbd>8</kbd> (this is measured in bytes), and it set the Content-Type (also known as the MIME type or media type) of the response to plain text in UTF-8 encoding. (Encoding is a misnamed charset in many contexts.)</p>
<p>Of course, producing text instead of HTML is good, but the standard format for data exchange in REST controllers these days is JSON, so let's make the controller return this.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Returning JSON Manually</h1>
                </header>
            
            <article>
                
<p>Let's try the straightforward way first. Take a look at the following code:</p>
<pre>@Controller<br/>public class HelloWorldController {<br/><br/>  @RequestMapping("/api/greeting/fakeJson")<br/>  @ResponseBody<br/>  public String fakeJson() {<br/>    return "{\"message\":\"Hello world\"}";<br/>  }<br/>}</pre>
<p>The only thing that changed here is the returned string. It now contains JSON, with a log of backslashes to encode the necessary double quotes within a Java string. The result of the request, then, is as follows:</p>
<pre>GET /api/greeting HTTP/1.1<br/>Content-Length: 25<br/>Content-Type: text/plain;charset=UTF-8<br/>{"message":"Hello world"}</pre>
<p>There are a few things to criticize here. The first thing is that the JSON is cumbersome to write. Java makes this very hard because the embedded double quotes need to be escaped. JSON may be a reasonably easy format, but, still, particularly for bigger data structures than the one returned here, creating it by hand is error-prone.</p>
<p>Second, and more importantly, the content type is still set to plain text! Some clients may ignore the Content-Type header anyway and just expect JSON to be returned, and those clients will work with our faulty server. Well-behaved clients, however, will not recognize it as JSON. They may accept it as text (albeit weird text) or altogether reject it.</p>
<p>Postman, for instance, honors the Content-Type header. By default, it will show the output of a call to this controller as plain text. You may, however, choose JSON by hand, thereby overriding the detected Content-Type.</p>
<p>In rare circumstances, this might be a quick hack to satisfy some required interface, but surely we can do much better!</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Manual JSON, Correct Content-Type</h1>
                </header>
            
            <article>
                
<p>The main problem with the preceding code is that it created an incorrect HTTP response for what we intended:</p>
<pre>@Controller<br/>public class HelloWorldController {<br/><br/>  @RequestMapping(path = "/api/greeting/manualJson",<br/>                  produces = "application/json")<br/>  @ResponseBody<br/>  public String manualJson() {<br/>    return "{\"message\":\"Hello world\"}";<br/>  }<br/>}</pre>
<p>What changed here in this code excerpt is only the <kbd>@RequestMapping</kbd> line. We add a second parameter that produces the annotation, which then gives the value of the Content-Type HTTP header. Actually, it's not the verbatim header, as you'll see in a moment; also, repeating such a value may lead to subtle errors, and you will see a better alternative later on. The path parameter is the same as the implicit value parameter that was used before when we only had one argument for the annotation.</p>
<p>The outcome of this controller has improved greatly:</p>
<pre>GET /api/greeting HTTP/1.1<br/>Content-Length: 25<br/>Content-Type: application/json;charset=UTF-8<br/>{"message":"Hello world"}</pre>
<p>We get the same Content-Length here and in fact the same payload, but the Content-Type header is now pointing to JSON as we wanted! Notice how Spring added the encoding on its own. Now, Postman will, by default, show this as JSON.</p>
<p>Once more, we will go through a demo, using Postman to access a REST resource, but this time accessing our own application instead of something from the internet:</p>
<ul>
<li>Use the "rest-intro" project provided on GitHub, and start the <kbd>RestIntroApplication</kbd> class within it: navigate to the class and then either press <em>Ctrl-Shift-F10</em> or click on any of the green triangles in the gutter of the editor.</li>
<li>Start Postman. You should import the Postman collections that are available on GitHub, so that you can easily use the pre-defined queries. The "REST-Intro" collection contains the requests needed here. Execute the queries <kbd>greeting/string</kbd>, <kbd>greeting/fakeJson</kbd> and <kbd>greeting/manualJson</kbd>:</li>
<li>Show both the <strong>Body</strong> and the <strong>Headers</strong> panes. The first query will return a proper string, the second one returns a hybrid (a string that looks like JSON), and the third will return a proper JSON.</li>
<li>The other drawback remains: hand-written JSON is probably not what we want. Though slightly more complicated in these toy examples, the following sections will show you how to deal with JSON in real life.</li>
</ul>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Mapping Data to JSON</h1>
                </header>
            
            <article>
                
<p>To conclude this section on simple REST controllers, these two methods will return proper JSON, but you will see nothing of that in the code as follows:</p>
<pre>@Controller<br/>public class HelloWorldController {<br/><br/>  /** Produce JSON from a map as return value. Can also be nested.<br/>*/<br/>  @RequestMapping("/api/greeting/mapJson")<br/>  @ResponseBody<br/>  public Map&lt;String, Object&gt; mapJson() {<br/>    Map&lt;String, Object&gt; result = new HashMap&lt;&gt;();<br/>    result.put("message", "Hello from map");<br/>    return result;<br/>  }<br/><br/>  /** The data wrapper that maps to JSON */<br/>  @Data<br/>  @AllArgsConstructor<br/>  static class Message {<br/>    private String message;<br/>  }<br/><br/>  /** Produce JSON from an object as return value. */<br/>  @RequestMapping("/api/greeting/objectJson")<br/>  @ResponseBody<br/>  public Message objectJson() {<br/>    return new Message("Hello from object");<br/>  }<br/>}</pre>
<p>Wow! That was easy.</p>
<p>Both variants produce exactly the same outcome (except for the text itself, that is). It is also the same as in the preceding code, only that for non-string return values, Spring does not automatically add the Content-Length header. This is a bit unfortunate, but since most clients do not make much use of it, it is generally acceptable.</p>
<p>What happened here? Upon finding a complex return type, Spring will look for an <kbd>HttpMessageConverter</kbd> bean in the application context and relay processing to it. A very good library for converting between Java objects and JSON is <em>Jackson</em> by <em>FasterXML</em> (you can find the project homepage at <a href="https://github.com/FasterXML/jackson">https://github.com/ FasterXML/jackson</a>). Spring comes with a specific <kbd>HttpMessageConverter</kbd> implementation called <kbd>MappingJackson2HttpMessageConverter</kbd>, which uses Jackson for the job.</p>
<p>All you have to do to use this implementation is nothing at all. The <kbd>spring-boot-starter- web</kbd> dependency that we use for this Spring MVC project already depends on <kbd>spring-boot-starter-json</kbd> that, in turn, depends on Jackson. Now, Spring's magic kicks in: when Jackson is found in the Java <kbd>classpath</kbd> upon startup, then all the necessary Beans are created automatically. This way, returning JSON just works - out of the box!</p>
<p>The only question that remains is whether you would prefer to create specialized Java classes for all different kinds of JSON payloads that you expect, or whether you would rather go with (nested) maps. One is more type-safe; one is more flexible; the choice is up to you. Throughout this book, we are giving preference to sections of Java that are easy enough to create with Project Lombok, which was introduced in <a href="9c691a93-c936-4976-b836-8ec08d62bffb.xhtml"/><em><a href="9c691a93-c936-4976-b836-8ec08d62bffb.xhtml">Chapter 1</a>: The Spring Project and Framework</em>.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">REST Controllers in Spring</h1>
                </header>
            
            <article>
                
<p>To wrap it up, please remind yourself that most of the annotations that were mentioned can not only go on a method, but also on the class level. The semantics are then that those annotations are for all methods in the class,</p>
<p>Some annotations serve as defaults for all methods. They count if they are not overwritten on the method. An example of this would be <kbd>@RequestBody</kbd>, which turns all methods in a class that are also annotated as mapped into REST endpoints.</p>
<p>Some annotations are additive. The <kbd>@RequestMapping</kbd> annotation is one of those. It does not turn each method into an endpoint, but it gives a common path prefix for all methods that are also endpoints. In an extreme scenario, these methods do not need to specify any path if they only differ in the produced MIME type or the HTTP method.</p>
<p>The combination of <kbd>@Controller</kbd> and a class-level <kbd>@RequestBody</kbd> annotation is so common and useful for REST controllers that there is a specialized annotation just for this case, and it is, rather unsurprisingly, called <kbd>@RestController</kbd>. It is this annotation that will be used throughout this book.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Implementing REST Endpoints </h1>
                </header>
            
            <article>
                
<p>The aim is to implement your first REST endpoint by returning JSON. You have an existing application that needs another endpoint. The project is completely set up, so adding a single class is enough. Before beginning, open the rest-intro project in IntelliJ and make sure that you can start the <kbd>RestIntroApplication</kbd>. <span>The steps for completion are as follows:</span></p>
<ol>
<li>Add a new class – you may call it <kbd>DateTimeController</kbd>.</li>
<li>Annotate it with <kbd>@RestController</kbd>. Use auto-completion or <em>Ctrl+Space</em> in IntelliJ to complete the annotation and add the import.</li>
<li>Add a new inner static class called <kbd>DateTime</kbd> with some String fields such as date and time. Add the appropriate getters and constructor. Lombok will be very helpful here.</li>
</ol>
<ol start="4">
<li>Add a new method that returns an instance of the new data class. It does not need any arguments.</li>
<li>Annotate the method with <kbd>@GetMapping</kbd> and make it react to some path, for instance, to <kbd>/api/datetime</kbd>.</li>
<li>Extract the current time and date, put them into a new instance of <kbd>DateTime</kbd>, and return that. You can use the following code snippet:</li>
</ol>
<pre style="padding-left: 60px">ZonedDateTime now = ZonedDateTime.now();<br/>String date = now.format(DateTimeFormatter.ISO_LOCAL_DATE);<br/>String time = now.format(DateTimeFormatter.ISO_LOCAL_TIME);</pre>
<ol start="7">
<li>Re-run the program and access your new resource with Postman.</li>
</ol>
<p>The answer will, of course, depend on your local time and date, but it will be JSON (application/json) format and look something along the lines of:</p>
<p><strong>{"date":"1989-11-09","time":"19:01:30.123","zone":"Central European Time (CET)","zoneId":"Europe/Berlin","zoneOffset":"+01:00"}</strong></p>
<div class="packt_infobox"><br/>
You can find a possible solution that also returns the time zone in the GitHub repository by going to <a href="https://bit.ly/2qABGIY">https://bit.ly/2qABGIY</a>. Go<br/>
to <a href="https://bit.ly/2xaeSlT">https://bit.ly/2xaeSlT</a> to access the complete code for the <kbd>RestIntroApplicationTests.java</kbd> file.</div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Content Types</h1>
                </header>
            
            <article>
                
<p>We already saw Content-Types in the preceding responses.</p>
<p>All content has some type (or many, mixed). Humans are good at reading and understanding content by just looking at it, but computers work best if they are told beforehand what to expect. For that purpose, and originally as an extension to the internet mail standard, RFC 2046 specifies Media Types (formerly known as MIME types). A list of agreed-upon Media Types is coordinated by the IANA.</p>
<div class="packt_infobox"><br/>
Refer to the following resources for the standards:<br/>
RFC 2046: <a href="https://tools.ietf.org/html/rfc2046">https://tools.ietf.org/html/rfc2046</a>.<br/>
IANA: <a href="http://www.iana.org/assignments/media-types/mediatypes.xhtml">http://www.iana.org/assignments/media-types/mediatypes.xhtml</a>.</div>
<p>The content types most interesting in the web application context are as follows:</p>
<ul>
<li>text/html when HTML pages are returned to the browser</li>
<li>text/css, text/javascript, and image/jpeg for the content linked in web pages</li>
<li>text/plain as a fallback for plain text</li>
<li>application/x-www-form-urlencoded as the default format, where the browser sends data entered in a form to the browser</li>
<li>application/json for AJAX calls</li>
</ul>
<p>The HTTP protocol has two headers that deal with content types:</p>
<ul>
<li><kbd>Accept</kbd> in the <em>request</em> to specify what is accepted as a result. This can be a list of accepted types (</li>
</ul>
<ul>
<li>or the header can be repeated), and it can contain wildcards and weights to specify preferences.<br/>
This header has companions such as Accept-Charset and Accept-Language that are of lesser interest, meaning that you will not be concerned with them generally.</li>
<li><kbd>Content-Type</kbd> in the <em>response</em> to specify what the actual result is. This header has similar companions to the Accept header.</li>
</ul>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Producing Different Content Types</h1>
                </header>
            
            <article>
                
<p>You already saw that the produced content type may change when you return different things from your controller, and that you can also influence the content type manually.</p>
<p>An important principle of REST is that we use the HTTP protocol to its full extent, using the right HTTP methods (or verbs), but also leave content negotiation and caching to the protocol and the intermediary nodes. Therefore, you shall never have two resources called <kbd>/api/customers.json</kbd> and <kbd>/api/customers.xml</kbd> if you need the same logical resource in two different formats.</p>
<div class="packt_infobox"><br/>
Spring, by the way, allows just that if you configure it that way, but this will not be shown here on purpose. It used to be the default in previous versions, but is now deprecated.</div>
<p>The following code seems to specify the same resource twice:</p>
<pre>@RestController<br/>@RequestMapping(path = "/api/greeting")<br/>public class ContentTypeController {<br/><br/>  @Data<br/>  @AllArgsConstructor<br/>  private static class SimpleMessage {<br/>    private String message;<br/>  }<br/><br/>  /** GET a greeting as text/plain content-type */<br/>  @GetMapping(produces = MediaType.TEXT_PLAIN_VALUE)<br/>  public String greetText() {<br/>    return "Hello with plain text";<br/>  }<br/><br/>  /** GET a greeting as application/json content-type */<br/>  @GetMapping(produces = MediaType.APPLICATION_JSON_VALUE)<br/>  public SimpleMessage greetJson() {<br/>    return new SimpleMessage("Hello with JSON");<br/>  }<br/>}</pre>
<p>Note how the path to the resource is only specified at the class level. The two functions only provide GET endpoints, and they do differ— one of them returns a String that will be sent to the client as plain text, and the other one returns a complex object that will be turned into JSON by the mapper. You have already seen the produces option; it is still of String type, but this time, we use predefined constants in the <kbd>MediaType</kbd> class to avoid duplication.</p>
<p>These two endpoints will react to different requests:</p>
<pre>GET /api/greeting HTTP/1.1<br/>Accept: text/plain<br/><br/>Content-Type: text/plain;charset=UTF-8<br/><br/>Hello with plain text<br/><br/>GET /api/greeting HTTP/1.1<br/>Accept: application/json<br/><br/>Content-Type: application/json;charset=UTF-8<br/><br/>{"message":"Hello with JSON"}</pre>
<p>Both requests go to the same resource, but with different Accept headers. As you can see, Spring, by default, added the charset, which is UTF-8 in this case, to the response. That way, the client is able to understand the encoding of the response body. Currently, Spring controllers will return the JSON if no Accept header is given, but you should not rely on such behavior.</p>
<p>All that was needed was the differing product options. The method names are ignored by Spring, and they are different only to avoid a name clash, and also to document our intention.</p>
<p>The content negotiation, and later the dispatch to one of our functions, is done by the <kbd>DispatcherServlet</kbd>, which you already heard about in <em><a href="6c057031-8824-460d-bad6-abd27cbb3b21.xhtml">Chapter 4</a>: The MVC Pattern</em>. If no method can provide the requested (or <strong>accepted</strong>) <kbd>Content-Type</kbd>, then the HTTP status <strong>406 Not Acceptable</strong> is issued to the client.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Responding with XML to the Rest-intro Application</h1>
                </header>
            
            <article>
                
<p>The aim is to demonstrate responding with XML to the rest-intro application. The steps for completion are as follows:</p>
<ol>
<li>Start the <kbd>RestIntroApplication</kbd> in the rest-intro project.</li>
<li>Use Postman to call the resources and show that they indeed return text and JSON, respectively.</li>
</ol>
<div class="packt_infobox"><br/>
You can use the provided Postman collection <strong>Content-Types</strong> for that. Also, try to request XML: Postman will show you an HTTP response status of <strong>406 Not Acceptable</strong>. This was to be expected since we did not provide an endpoint for that representation.<br/>
Note that the application's log remains quite quiet about this in the default settings. Also, note that you can request many other unsupported types, but if you should request text/html, then alongside the 406 status code, you actually do get a bit of HTML showing the error, and you can also view that in the <strong>Preview</strong> pane.</div>
<p class="mce-root"/>
<ol start="3">
<li>Now, add the ability to return XML to the resource! You need to add a new method to <kbd>ContentTypeController</kbd>, which is basically a copy of <kbd>greetJson()</kbd>:</li>
</ol>
<pre style="padding-left: 60px">@GetMapping(produces = MediaType.APPLICATION_XML_VALUE)<br/>public SimpleMessage greetXml() {<br/>  return new SimpleMessage("Hello with XML");<br/>}</pre>
<p style="padding-left: 60px">If you were to run the application with debug logging, you would see that Spring tries to use this new method when you request XML, but fails later on because there is no message converter. To add one, all we need is Jackson XML on the classpath, and the rest will be wired automatically. Add the following dependency to the POM:</p>
<pre style="padding-left: 60px" class="mce-root">&lt;dependency&gt;<br/>     &lt;groupId&gt;com.fasterxml.jackson.dataformat&lt;/groupId&gt;<br/>     &lt;artifactId&gt;jackson-dataformat-xml&lt;/artifactId&gt;<br/>&lt;/dependency&gt;</pre>
<ol start="4">
<li>Now, run the application and demonstrate that we also respond with XML.</li>
</ol>
<p>Similar to the JSON data structure that you know, the answer will now be this:</p>
<pre>&lt;SimpleMessage&gt;<br/>    &lt;message&gt;Hello with XML&lt;/message&gt;<br/>&lt;/SimpleMessage&gt;</pre>
<div class="packt_infobox"><br/>
Go to <a href="https://bit.ly/2Abj4Vb">https://bit.ly/2Abj4Vb</a> to access the complete code for the <kbd>RestIntroApplication.java</kbd> file.</div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Job Aid</h1>
                </header>
            
            <article>
                
<p>You could also just add a second media type to the existing <kbd>greetJson()</kbd>, but then the contained text would be the same, of course. In general, though, you do not want to send different data when different Content-Types are requested. You only want to send different representations.</p>
<p>You can add as many media types to a handler method as you want.</p>
<p>You can also choose not to add any media type at all, as Spring will try to find the best matching handler method that can produce the requested <kbd>Content-Type</kbd>.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Consuming Different Content Types</h1>
                </header>
            
            <article>
                
<p>JSON is by far the most common data exchange format for REST services today. However, it used to be XML. Some flexibility in accepting different formats may mean more clients are able to connect to your service.</p>
<p>Another thing to consider is that web applications can only send JSON with the help of JavaScript. However, a simple HTML form can also issue a POST, but it cannot send JSON. The default format has the <kbd>Content-Type application/x-www-form-urlencoded</kbd>, which is basically a simple string of key/value pairs. If our server can accept this, it can react to actions from a form (you saw this earlier in this chapter). This format may even be preferable in other contexts, since it will not need preflight requests.</p>
<div class="packt_infobox"><br/>
See <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS">https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS</a> for a discussion of Cross-Origin Resource Sharing. In particular, note that "simple requests" do not need preflight, which is an additional request the client would issue to find out allowed methods. Such a simple request may only have a <kbd>Content-Type of application/xwww-form-urlencoded</kbd>, and not JSON. Avoiding preflight requests may speed up a client application considerably on networks with high latency.</div>
<p class="mce-root">Let's see this in code:</p>
<pre class="mce-root">@RestController<br/>@RequestMapping(path = "/api/greeting")<br/>public class ContentTypeController {<br/>  @Data<br/>  // […]<br/>@RequestBody SpecificMessage input) {<br/>    return new SpecificMessage(input.addressee,<br/>            "Re: " + input.message);<br/>  }<br/>}</pre>
<div class="packt_infobox"><br/>
Go to <a href="https://bit.ly/2pVBBz7">https://bit.ly/2pVBBz7</a> to access the complete code.</div>
<p>The mappings use the same endpoint as before, but now utilize the POST method instead. This makes the dispatch possible. The result of calling these is as follows:</p>
<pre>POST /api/greeting HTTP/1.1<br/>Content-Type: application/x-www-form-urlencoded<br/><br/>addressee=Peter<br/><br/>{"addressee":"Peter","message":"Hello Peter"}<br/><br/>POST /api/greeting HTTP/1.1<br/>Content-Type: application/json<br/><br/>{<br/>    "addressee": "Paul",<br/>    "message": "Answer me"<br/>}<br/><br/>{"addressee":"Paul","message":"Re: Answer me"}</pre>
<p>It is (almost) as easy as putting the consumes option on the mapping annotation. For historical reasons, however, form values are handled a bit differently than JSON. For JSON and other formats with a mapper (XML, for instance), we use the <kbd>@RequestBody</kbd> annotation on the Java method's formal parameter. This illustrates quite well that the value for the actual parameter is to be taken from the request body.</p>
<p>For form encoding, each of the expected form values is passed on its own to a parameter that is annotated with <kbd>@RequestParameter</kbd> (which is mapped by the name of the formal parameter, if not overridden). Note that this is the same annotation that we would use to extract URL parameters. In fact, a method that does not have a consumes option on the mapping, but <kbd>@RequestParameter</kbd> annotations will be able to take the values both from form-encoded values in the request body and from URL parameters.</p>
<div class="packt_infobox"><br/>
For GET requests, it is not portable to have a request body. The HTTP specification does not require anybody handling for GET, and intermediate proxies and clients may strip the body if one is sent. Therefore, GET mappings cannot consume anything.<br/>
The only reliable way to pass values to a GET request is via URL parameters such as in <kbd>/api/greeting?addressee=John</kbd>. This is done using the <kbd>@RequestParam</kbd> annotation and, in code, looks the same as accepting a form with POST.</div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">HTTP Status Code and Important Headers</h1>
                </header>
            
            <article>
                
<p>Up until now, we only cared for the body of the response (and the content-type, since it is so closely linked). HTTP, however, has two more very important channels to convey information back to the client: These are the status code and a number of further HTTP headers.</p>
<p>A status code comes with every response from the server. It is a quick way to triage the success of the query, even before looking into the content. The status codes fall into five categories, the important ones in our context being the following:</p>
<ul>
<li>The 2xx range: Everything went well.</li>
<li>The 4xx range: The request was faulty.</li>
<li>The 5xx range: The server had a problem that is not the client's responsibility.</li>
</ul>
<div class="packt_infobox"><br/>
For the full list of return codes, consult external resources such as RFC 7231. Of course, there is no need to use all of them, but choosing wisely can enhance the meaningfulness of your API.</div>
<p>You have already seen some status codes, and we will see some more throughout this book:</p>
<div class="packt_figref CDPAlignCenter CDPAlign"><img src="Images/5c0bf73b-139d-424c-a525-b07b52f65fe0.png" style="width:74.50em;height:40.67em;" width="1105" height="604"/></div>
<p>Headers are too numerous to even scrape the surface here, but the ones you will see here are as follows:</p>
<ul>
<li>Content-Type</li>
<li>Location (with 201 code (see the previous table) or 3xx codes) to point to the real location.</li>
<li>Allow (with 405 code (see the previous table) and for <kbd>OPTION</kbd> requests) to list allowed request methods.</li>
<li>Cache-Control and ETag (and others) for controlling how content should be cached and when to update the values in the caches.</li>
<li>Finally, headers starting with X-… are commonly used for various application-specific purposes.</li>
</ul>
<div class="packt_infobox"><br/>
You can read more about RFC 7231 at <a href="https://tools.ietf.org/html/rfc7231">https://tools.ietf.org/html/rfc7231</a>.</div>
<p>In a nutshell, the HTTP status is as per the following:</p>
<ul>
<li>1XX – Hold on</li>
<li>2XX – Here you go</li>
<li>3XX – Look elsewhere</li>
<li>4XX – You messed up</li>
<li>5XX – I messed up</li>
</ul>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Declarative Status Code</h1>
                </header>
            
            <article>
                
<p>The simplest way to control the response status code is to simply declare it using the <kbd>@ResponseStatus</kbd> annotation:</p>
<pre>@RestController<br/>@RequestMapping(path = "/api/motd")<br/>public class MotdController {<br/>  @PutMapping<br/>  @ResponseStatus(HttpStatus.NO_CONTENT)<br/>  public void storeMotd(@RequestBody Message message) {<br/>     // set the message of the day<br/>     // …<br/>  }<br/>}</pre>
<p>There is no useful information to be sent back from the PUT request, so the method returns void and carries an annotation to return <strong>204 No Content</strong>.</p>
<p>This is the easiest case, and especially useful to get you started. When your demands grow, you may need more fine-grained control and have to influence the response programmatically.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Programmatic Status Code</h1>
                </header>
            
            <article>
                
<p>If the status code is always the same, unconditionally, what's the point of setting it anyway? Most of the time, the return values depend somehow on the input, or on the state of the overall system. If that is the case, we can only decide on which answer to send after checking some conditions.</p>
<p>The key here is to make use of a response entity, that is, a data object wrapping both the returned data and the all the metadata for the HTTP response. Consequently, Spring offers a parameterized type called <kbd>ResponseEntity&lt;T&gt;</kbd>, where T is the data that we want to be sent as JSON. This class comes with a number of static functions wherein each creates a response entity builder to add more information step by step.</p>
<p>Consider the following code fragment:</p>
<pre>@RestController<br/>@RequestMapping("/api/mottos")<br/>public class MottoController {<br/><br/>// […]<br/>      motto.add(message);<br/>      return ResponseEntity.ok()<br/>              .body(new Message("Accepted #" + motto.size()));<br/>    }<br/>  }<br/>}</pre>
<div class="packt_infobox"><br/>
Go to <a href="https://bit.ly/2xeqODe">https://bit.ly/2xeqODe</a> to access the complete code for this section.</div>
<p>The resource <kbd>/api/mottos</kbd> is a REST collection resource. With POST, new messages can be posted to the list of mottos. We do not want a motto to appear twice, so the method checks for uniqueness and has two different paths to create a return value.</p>
<p>If the motto already exists, a new builder (actually called <kbd>BodyBuilder</kbd>, a name that may make you smile a bit, even though it is perfectly reasonable) is created with the <kbd>static status()</kbd> method of the <kbd>ResponseEntity</kbd> class. It takes as its sole argument the required response status. To actually build the response with an empty body, <kbd>build()</kbd> is called.</p>
<p class="mce-root"/>
<p>Otherwise, the <kbd>ok()</kbd> method is used to create the builder; this is a shortcut for a very common status code, and <kbd>status()</kbd> could have been used as well. This time, a body of the correct type is sent along as well. The <kbd>body()</kbd> function can be used once at most and will immediately build the result.</p>
<div class="packt_tip"><br/>
The <kbd>uniqueAppend()</kbd> method had <kbd>ResponseEntity&lt;Message&gt;</kbd> as its return type. But, if you look closely, it is almost like cheating, because a message was only sent in one of the two branches. It just so happens that an empty body is compatible with every generic type.</div>
<p>Spring is enormously flexible in the signatures it accepts for handler mapping functions (go to the Spring documentation under <a href="https://docs.spring.io/spring/docs/current/spring-framework-reference/web.html#mvc-ann-methods">https://docs.spring.io/spring/docs/current/spring-framework-reference/web.html#mvc-ann-methods</a> to verify this claim). The dispatch is done at runtime.</p>
<p>We hit a Java restriction here. We cannot return either a message or a specific error object from the same function and stay within the type system. You will see one way to circumvent this for most applications (error handling). If you really must return different types from one method, you may declare it as returning <kbd>ResponseEntity&lt;?&gt;</kbd> (a practice that static code checkers will likely criticize) or even <kbd>Object</kbd>. You will lose the type checking of the compiler, so be sure to write proper unit tests.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Global Error Handling</h1>
                </header>
            
            <article>
                
<p>The error handling in each method may be quite similar and repetitive. It is often the same for all methods. It may also bury the main intention of the method.</p>
<p>Cross-cutting concerns such as these are often handled by aspects, and Spring uses quite a number of these. However, global error handling is provided through a different mechanism here, which is called an <strong>exception handler</strong>.</p>
<p>A method annotated with <kbd>@ExceptionHandler</kbd> can handle exceptions for many handler mappers within the same controller (or, using <kbd>@ControllerAdvice</kbd>, more globally, which will be explained a bit later).</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">A JavaScript Evaluator</h1>
                </header>
            
            <article>
                
<p>Let's implement a controller that has more than one possible cause for problems, and do so without cluttering the business logic:</p>
<pre>@RestController<br/>public class JavaScriptController {<br/>  @Value<br/>  private static class Message {<br/>    private String message;<br/>  }<br/><br/>   // […]<br/>    Object eval = javaScript.eval(expression);<br/>    return new Message("Evaluation of " + expression +<br/>          " yields " + eval);<br/>  }<br/>}</pre>
<div class="packt_infobox"><br/>
Go to <a href="https://bit.ly/2x9HZWM">https://bit.ly/2x9HZWM</a> to access the complete code for this section.</div>
<p>The controller accepts a JavaScript expression as a parameter and returns the result as a JSON wrapped message. It contains a bit of argument checking before feeding the parameter straight into the built-in JavaScript interpreter. Note that you do not want to do this outside a protected environment because of security implications, but it is fine as an example.</p>
<p>Now, what could possibly go wrong?</p>
<p>One thing is the <kbd>IllegalArgumentException</kbd> that we throw ourselves, and the other is the checked <kbd>ScriptException</kbd> and another unchecked <kbd>ParserException</kbd> that Nashorn may throw. The error handling that we have in place right now only replaces one exception with a more informative one. The exceptions will escape our handler mapping. What will Spring do about it? The answer is that, by default, it will generate a rather helpful error object and a response status code of <strong>500 Internal Server Error</strong>.</p>
<p>That is not quite satisfying, since the error really was on the client's side, and we should properly signal that to the client. To handle the two exceptions, we add two error handlers to the class:</p>
<pre>@RestController<br/>public class JavaScriptController {<br/>  // handle the explicitly thrown runtime exception<br/>  @ExceptionHandler(IllegalArgumentException.class)<br/>  @ResponseStatus(HttpStatus.BAD_REQUEST)<br/>  public String handleArgument(IllegalArgumentException e) {<br/>    return e.getMessage();<br/>  }<br/><br/>  // handle the parser's exceptions<br/>  @ExceptionHandler({ParserException.class, ScriptException.<br/>class})<br/>  @ResponseStatus(HttpStatus.NOT_ACCEPTABLE)<br/>  public String handleParse(Exception e) {<br/>    return e.getMessage();<br/>  }<br/>}</pre>
<p>The <kbd>handleArgument()</kbd> method handles the <kbd>IllegalArgumentException</kbd>, while <kbd>handleParse()</kbd> handles the two Nashorn exceptions. The exception argument is entirely optional and can have any compatible type. Again, the signatures are very flexible, and we could choose to return a <kbd>ResponseEntity&lt;&gt;</kbd> for a specialized error object instead.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Advising Many Controllers at Once</h1>
                </header>
            
            <article>
                
<p><strong>Advices</strong>, in Spring MVC, are methods that declare certain aspects of handler functions. There are three of such advices in Spring, two of which are out of the scope of this introductory book (but you have seen the second briefly in Chapter 4):</p>
<ul>
<li><kbd>@InitBinder</kbd> — to configure automatic conversion from primitive parameters to custom domain objects.</li>
<li><kbd>@ModelAttribute</kbd> — to control common attributes in the controllers model (such as data).</li>
<li><kbd>@ExceptionHandler</kbd> — to convert thrown exceptions to proper responses.</li>
</ul>
<p>All of these are scoped to the controller that they were defined in.</p>
<p>Sometimes, we want a more global approach. For that, we need to define a Spring Bean annotated with <kbd>@ControllerAdvice</kbd>. When we do not need view resolution on our exception handlers, but message conversion on the response bodies instead, we can either put <kbd>@ResponseBody</kbd> in the appropriate places or simply use the <kbd>@RestControllerAdvice</kbd> annotation on the advising class.</p>
<p>Such a controller advice annotation is global for all controllers by default. To narrow it down, there are several options to the annotation to limit the scope to certain packages or even to specific annotations. One very useful example would be as follows:</p>
<pre>// Target all controllers annotated with @RestController<br/>@RestControllerAdvice(annotations = RestController.class)<br/>public class AdviceForAllRestControllers {<br/>   // …<br/>}</pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Controlling Headers</h1>
                </header>
            
            <article>
                
<p>To polish the responses, we may want to control the response headers. The builder we get from the static functions in <kbd>ResponseEntity</kbd> is actually an extension of a <kbd>HeaderBuilder</kbd>, so we can build both headers and a body with it.</p>
<p>In the most basic form, we can use the <kbd>header()</kbd> method on this builder. For some common headers, specialized methods exist. Look at these examples:</p>
<pre>// good GET answer that controls how long the client shall cache<br/>return ResponseEntity.ok()<br/>          .cacheControl(CacheControl.maxAge(1, TimeUnit.HOURS))<br/>          .eTag(Integer.toHexString(message.hashCode()))<br/>          .body(message);</pre>
<pre>// good POST answer that contains Location header<br/>return ResponseEntity<br/>          .created(URI.create("/api/mottos/" + motto.size()))<br/>          .header("X-Copyright", "Packt 2018")<br/>          .build();</pre>
<p>GET requests can profit greatly from caching. For that to work, the server needs to know how long to cache values. Alternatively, sometimes also in conjunction, the client may send along with the request some data from which the server can determine whether the content has changed in the meantime. Without going into the details here, the preceding code adds the Cache-Control and the ETag headers.</p>
<div class="packt_infobox"><br/>
Instead of the normative RFCs, you may want to read the excellent documentation on the Mozilla Development Network (for instance, on ETag at <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/ETag">https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/ETag</a>) when you want to know more about HTTP.</div>
<p>As stated earlier, when posting to a list resource, the new entity will be assigned a new ID that the client cannot know. To relay that information back to the client, we set the Location header with a URL pointing to the newly created entity. Spring supports this by the argument to the <kbd>created()</kbd> function.</p>
<p>Finally, as an example, we set the X-Copyright header. Headers starting with X-… are not standardized and can be used for application-specific purposes.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Returning Different Status Codes</h1>
                </header>
            
            <article>
                
<p>A code review asks you not to throw exceptions that you can easily avoid, so you should alter the code for <kbd>retrieveById()</kbd> to check its argument. (This is a fictional scenario where the style you find in the controller is quite acceptable, but remains a matter of taste.)</p>
<p><span>The aim is to use different strategies for returning different status codes. As we did previously before beginning, open the rest-intro project. Navigate to the <kbd>MottoController</kbd> and notice that it is, in fact, a bit more useful that shown previously in this script: it also has an implementation for GET that uses an <kbd>@ExceptionHandler</kbd> to return a <strong>404 Not Found</strong> message. The steps for completion are as follows:</span></p>
<ol>
<li>Change the return value of <kbd>retrieveById()</kbd> to <kbd>ResponseEntity&lt;Message&gt;</kbd>.</li>
<li>Add a condition to check whether the ID is within the range of accepted indexes (using <kbd>id &lt; 1 || id &gt; motto.size()</kbd>).</li>
<li>For the out-of-bounds case, return a <kbd>ResponseEntity</kbd> with HTTP status <strong>404 Not Found</strong>.</li>
<li>For the within-bounds case, return a <kbd>ResponseEntity</kbd> with HTTP status 200 OK and the correct motto.</li>
<li>Finally, you can remove the <kbd>@ExceptionHandler</kbd> that is now superfluous.</li>
<li>Check with Postman that the endpoint still reacts in the same way.</li>
</ol>
<p>The observed behavior of the program has not changed, but we are using an alternative way to achieve the result.</p>
<div class="packt_infobox"><br/>
You may use <kbd>ResponseEntity.ok()</kbd> to create the response entity builder and then add the body, or just put the body into the <kbd>ok()</kbd> invocation as a shortcut.<br/>
You may use either <kbd>ResponseEntity.notFound()</kbd> or <kbd>ResponseEntity.status(HttpStatus.NOT_FOUND)</kbd> to create the response entity builder. However, while the second alternative returns a proper <kbd>BodyBuilder</kbd>, the first alternative only returns a <kbd>HeaderBuilder</kbd>. This means that you cannot add a body. It is unfortunate that Spring decided to go that way. Go to <a href="https://bit.ly/2CZSx0S">https://bit.ly/2CZSx0S</a> to access the complete code for the <kbd>MottoController.java</kbd> file. You have to use for example the <kbd>mottos #1</kbd> post request first otherwise any request returns a <strong>404</strong> because the list is empty.</div>
<p>You can find a possible solution in the GitHub repository, or you can view the excerpt shown here:</p>
<pre>@Data<br/>@NoArgsConstructor<br/>@AllArgsConstructor<br/>private static class Message {<br/>    private String message;<br/>}<br/><br/>@GetMapping("/{id}")<br/>public ResponseEntity&lt;Message&gt; retrieveById(<br/>            @PathVariable int id) {<br/>    if (id &lt; 1 || id &gt; motto.size()) {<br/>        return ResponseEntity.notFound().build();<br/>    } else {<br/>        return ResponseEntity.ok(motto.get(id - 1));<br/>    }<br/>}</pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Hypermedia with Spring Boot</h1>
                </header>
            
            <article>
                
<p>Hypermedia is an extension to hypertext that allows handling of sound and video. It is a key aspect of REST as it enables the creation of services that decouple the client and server and thus allowing them to develop independently.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">HATEOAS Introduction</h1>
                </header>
            
            <article>
                
<p>Imagine that someone gives you the link to a website. Usually, it is a link to the top-level page on the site or even the only page; usually, you only have this link. As you look at the page, you start to read and explore—you follow links to other pages, read on, and follow other links. You discover the whole site just by following the links.</p>
<p>Should a REST API not be the same? It can be made fully discoverable by following links that are embedded in the answers, so all you ever need is the start URL.</p>
<p>This is generally known as <strong>hypermedia</strong>, or <strong>hypertext</strong>. It is part of the main REST principle in Fielding's original work, and at the same time, the most often violated property in many REST APIs. However, it is not a mere academic proposal; there are APIs that follow this principle closely. Remember the beginning of this chapter, when we discovered the SWAPI Star Wars API from a single entry link?</p>
<p>This principle is known as <strong>Hypermedia As The Engine Of Application State</strong>, or as the unwieldy and unpronounceable acronym <strong>HATEOAS</strong>. Used correctly, it gives the server and client much more flexibility.</p>
<p>Consider the following use cases:</p>
<p>A blog entry has an author. How would you represent this in the REST response? We could just embed the author, losing track of the reverse relation. We could return the author's ID, but how does the client know with which URL to use for this ID? Finally, we can just return a link to the author, solving both problems.</p>
<ul>
<li>The REST answer may contain different links for different regions of the clients. This provides a single point of entry combined with location-based load balancing.</li>
<li>When changing an endpoint, we lose backward compatibility. If, however, the clients are not supposed to access arbitrary URLs buried deeply in our application, but to follow links, we can just change the link list on the entry point.</li>
</ul>
<p>There are many ways to meet the goals of the principle. The main challenge is to produce all the links, particularly in a way that allows maintenance of the software. The Spring HATEOAS subproject simplifies the creation and consumption of HATEOAS resources and offers convenient functions for link creation. In this book, we will only touch the surface of it and add a link back to the entity itself.</p>
<p>Consider the <kbd>ContentTypeController</kbd> and its endpoint, <kbd>/api/greeting</kbd>, which could produce greetings to a person requested in the URL.</p>
<p>When querying the endpoint with <kbd>/api/greeting?addressee=John</kbd>, the answer is as follows:</p>
<pre>{<br/>  "addressee": "John",<br/>  "message": "Hello John"<br/>}</pre>
<p>The addressee was given in the request, and we can see it in the message, too. Now, why would we return the addressee? To make it easier to recreate the link that we used to get the resource. This, however, means that we have to construct the URL from the parameter using our knowledge of the API. Let's turn this into the following answer:</p>
<pre>{<br/>  "message": "Hello John",<br/>  "_links": {<br/>    "self": {<br/>      "href": "http://localhost:8080/api/greeting?addressee=John"<br/>    }<br/>  }<br/>}</pre>
<p>This time, we have a reference to the original link stored alongside the data.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Extending an Application with Spring HATEOAS</h1>
                </header>
            
            <article>
                
<p>In Spring HATEOAS, data objects with the ability to link to others via URL links are called resources (a term which has many overloaded meanings). One way to turn your data into such a resource is to let it extend the <kbd>ResourceSupport</kbd> class. This class provides the necessary mapping to JSON and an <kbd>add()</kbd> method to add a link. Assuming that message is such an object, a link to itself can be created like this:</p>
<pre>message.add(<br/>    linkTo(methodOn(ContentTypeController.class)<br/>        .greetFromPath(addressee))<br/>    .withSelfRel());</pre>
<p>This needs some explaining. Both <kbd>linkTo()</kbd> and <kbd>methodOn()</kbd> are static helper functions in <kbd>ControllerLinkBuilder</kbd>.</p>
<p>The outer expression <kbd>linkTo(…).withSelfRel()</kbd> will create the link itself and give it a relation called self. Other styles of linking than the shown JSON exist. For instance, you may have seen HTML anchors with a <kbd>rel</kbd> attribute.</p>
<p>The inner expression is similar to what can be seen in mocking frameworks. What may look like a call to the actual controller function is indeed against a proxy object. The effect of this and quite some reflection magic is that Spring HATEOAS is able to evaluate the annotations that are present on the referenced method.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Creating a HATEOAS Resource</h1>
                </header>
            
            <article>
                
<p>Now you have started to lay out your REST API and are faced with the requirement to make it HATEOAS compliant. You go ahead and enhance the API using Spring HATEOAS. The aim is to create a HATEOAS resource that exhibits a link to itself.</p>
<p>Before beginning, open the <kbd>hateoas-intro</kbd> project. This is a much stripped-down version of the rest-intro project. Only the <kbd>ContentTypeController</kbd> and a single handler method are left. The steps for completion are as follows:</p>
<ol>
<li>You need one more dependency in the POM. As usual, no version is required, as the version already comes with the Spring Boot parent POM:</li>
</ol>
<pre style="padding-left: 60px">&lt;dependency&gt;<br/>   &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;<br/>   &lt;artifactId&gt;spring-boot-starter-hateoas&lt;/artifactId&gt;<br/>&lt;/dependency&gt;</pre>
<ol start="2">
<li>In the <kbd>ContentTypeController</kbd>, make the <kbd>Message</kbd> class extend Spring's <kbd>ResourceSupport</kbd>. Remove the <kbd>addressee</kbd> field that is not needed anymore.</li>
<li>Fix the code in the <kbd>greetFromPath()</kbd> method and introduce a variable message instead of immediately returning the result of the constructor call. (You can use the shortcut <em>Ctrl-Alt-V</em> to extract a variable.)</li>
<li>Now, before returning the message, add the link with the code snippet you have already seen:</li>
</ol>
<pre style="padding-left: 60px">message.add(linkTo(methodOn(ContentTypeController.class)<br/>    .greetFromPath(addressee)).withSelfRel());</pre>
<ol start="5">
<li>Test the application in Postman now that it is complete.</li>
</ol>
<p>The produced JSON now contains an <kbd>additional _links</kbd> field that contains a reference to the resource itself:</p>
<pre>{<br/>    "message": "Hello John",<br/>    "_links": {<br/>        "self": {<br/>            "href": "http://localhost:8080/api/<br/>greeting?addressee=John"<br/>        }<br/>    }<br/>}</pre>
<div class="packt_infobox"><br/>
Refer to the complete code placed in <a href="https://bit.ly/2PHxyoD">https://bit.ly/2PHxyoD</a>.<br/>
Go to <a href="https://bit.ly/2MsadRU">https://bit.ly/2MsadRU</a> to access the complete code for the <kbd>HateoasIntroApplicationTests.java</kbd> file. You will even find the solution in the <kbd>exercises/hateoas-intro-after</kbd> folder.</div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Activity: Creating a List of Blog Articles as a REST Resource</h1>
                </header>
            
            <article>
                
<p><strong>Prerequisites</strong></p>
<p>We are building this<span> </span>activity<span> </span>upon the<span> </span><kbd>blogmania</kbd><span> </span>application that we built in the previous chapters. It already has a human-facing web frontend. You can find the source code at<span> </span><a href="https://bit.ly/2OxaeoF">https://bit.ly/2OxaeoF</a>. It is the same as we left it in the previous activity that we've covered, so you can reuse that project or create a new one as you wish.</p>
<p><strong>Aim</strong></p>
<p>To create a list of current blog<span> </span>articles<span> </span>that will be available as a REST resource to query with Postman.</p>
<p><strong>Scenario</strong></p>
<p>You have a working application for humans and are asked to add another interface to it, suited for other programs as clients. You decide to do it the RESTful way.</p>
<p><strong>Steps for Completion</strong></p>
<ol>
<li>Take the <kbd>blogmania</kbd> application and find the <kbd>BlogPostController</kbd>.</li>
<li>Write a REST controller that gives a list of all the articles under the URL <kbd>/api/blogposts</kbd>.</li>
<li>Add the full path to each method.</li>
<li>Add one or two dependencies to the class.</li>
<li>Add a mapping function to get all of the blog articles via REST.</li>
</ol>
<ol start="6">
<li>Start the application and use Postman to access <kbd>localhost:8080/api/blogposts</kbd>. We are doing this to see the list of blog articles returned as a JSON list:</li>
</ol>
<div class="packt_figref CDPAlignCenter CDPAlign"><img src="Images/5f85486a-888b-45e4-b58c-54587c5e1e7f.png" style="width:56.75em;height:42.25em;" width="904" height="671"/></div>
<p><strong>Outcome</strong></p>
<p>The list of current blog articles will be available as a REST resource to query with Postman.</p>
<div class="packt_infobox"><br/>
Go to <a href="https://bit.ly/2xezb1A">https://bit.ly/2xezb1A</a> to access the code for the <kbd>BlogPostController.java</kbd> file. Go to <a href="https://bit.ly/2NFjris">https://bit.ly/2NFjris</a> to access the code for the <kbd>BlogPostRestController.java</kbd> file.<br/>
Go to <a href="https://bit.ly/2QrByao">https://bit.ly/2QrByao</a> to access the <kbd>activity/</kbd> folder. <span>To refer to the detailed steps, go to the <em>Solutions</em> section at the end of </span><span>this book on page 260.</span></div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>This chapter built straight on top of the concepts of the previous chapters, expanding your mastery of Spring MVC controllers to different responses. This is flexible enough to return any kind of data but is particularly suited to serve REST APIs. You have learned what REST principles are and how to implement those with Spring. This included returning the most appropriate HTTP status code and various useful HTTP headers.</p>
<p>Right now, everybody can post articles in our blogging app. We need to restrict this access, so we will turn our attention toward security in the next chapter.</p>


            </article>

            
        </section>
    </div>



  </body></html>