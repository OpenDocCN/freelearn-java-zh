<html><head></head><body><div class="chapter" title="Chapter&#xA0;5.&#xA0;Representations &#x2013; RESTful Entities"><div class="titlepage"><div><div><h1 class="title"><a id="ch05"/>Chapter 5. Representations – RESTful Entities</h1></div></div></div><p>Our web service is now responding to requests that produce output by utilizing the <code class="literal">Response</code> class. We saw that there are methods of this class that take an object as a parameter.</p><div class="section" title="Creating a representation class"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec16"/>Creating a representation class</h1></div></div></div><p>We are<a id="id94" class="indexterm"/> going to create the representations that will be produced by the REST resources of our application. A simple Java class is everything needed by Jersey, so it will consider the class as a RESTful representation.</p><p>Given that our web service needs to produce contact-related information in the JSON format, a sample response would look something like the following code:</p><div class="informalexample"><pre class="programlisting">{ id: 1, firstName: "John", lastName: "Doe", phone: "+123-456-789" }</pre></div><p>We will build our representation class around this JSON string. The class will have the necessary properties (<code class="literal">id</code>, <code class="literal">firstName</code>, <code class="literal">lastName</code>, and <code class="literal">phone</code>) along with their getter methods.</p><div class="section" title="How to do it…"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec27"/>How to do it…</h2></div></div></div><p>Perform the following steps for creating a representation class:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Create a new package called <code class="literal">com.dwbook.phonebook.representations</code> and create a <code class="literal">Contact</code> class in it.</li><li class="listitem">Add the aforementioned contact properties as final members, also implementing their getters and a constructor:<div class="informalexample"><pre class="programlisting">package com.dwbook.phonebook.representations;

public class Contact {
  private final int id;
  private final String firstName;
  private final String lastName;
  private final String phone;
  
  public Contact() {
    this.id = 0;
    this.firstName = null;
    this.lastName = null;
    this.phone = null;
  }
  
  public Contact(int id, String firstName, String lastName,String phone) {
    this.id = id;
    this.firstName = firstName;
    this.lastName = lastName;
    this.phone = phone;
  }
  
  public int getId() {
    return id;
  }
  public String getFirstName() {
    return firstName;
  }
  public String getLastName() {
    return lastName;
  }
  public String getPhone() {
    return phone;
  }
}</pre></div></li></ol></div></div><div class="section" title="How it works…"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec28"/>How it works…</h2></div></div></div><p>The<a id="id95" class="indexterm"/> representation class for contacts is now ready. All that was required was just a plain Java class with the same properties as the JSON object that we wish our application to generate. In order for this to work though, the appropriate public getter methods are needed.</p><p>Our properties were declared final in order to be immutable, and for this reason, we also created a constructor that initializes the properties accordingly.</p><p>Instances of this class may now be used in our Jersey-based REST resources as the output. Jackson will handle the transformation from POJO to JSON transparently.</p></div><div class="section" title="There's more…"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec29"/>There's more…</h2></div></div></div><p>Any POJO can be used as a representation. Jackson constructs the JSON string recursively according <a id="id96" class="indexterm"/>to the getter methods of each class and their return type.</p><div class="section" title="The Jackson Java JSON processor"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl3sec13"/>The Jackson Java JSON processor</h3></div></div></div><p>Jackson<a id="id97" class="indexterm"/> is a powerful open source JSON data binder/parser and processor that facilitates the transformation of plain old Java objects to the JSON format and vice versa. Jersey uses Jackson for its transformation needs and is part of the <code class="literal">dropwizard-core</code> module; so, it is already included in our project setup.</p></div><div class="section" title="JSON arrays"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl3sec14"/>JSON arrays</h3></div></div></div><p>Any <a id="id98" class="indexterm"/>instance of the <code class="literal">java.util.List</code> type will be converted to a JSON array. For example, if we wanted to store multiple phone numbers for a contact, we would have declared <code class="literal">private final List&lt;String&gt; phoneNumbers</code> in the representation class (with the appropriate modifications to the class constructor and the getter).</p><p>This would lead to JSON representations of the following format:</p><div class="informalexample"><pre class="programlisting">{ id: 1, firstName: "John", lastName: "Doe", phoneNumbers: ["+123-456-789", "+234-567-890", "+345-678-901"] }</pre></div></div><div class="section" title="Ignoring properties"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl3sec15"/>Ignoring properties</h3></div></div></div><p>You can <a id="id99" class="indexterm"/>prevent a property from being a part of the JSON representation<a id="id100" class="indexterm"/> by adding the <code class="literal">@JsonIgnore</code> annotation to its getter.</p><p>This will cause Jackson to ignore a getter method that otherwise would be treated as a JSON property.</p></div></div></div></div>
<div class="section" title="Serving representations through the Resource class"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec17"/>Serving representations through the Resource class</h1></div></div></div><p>Consider<a id="id101" class="indexterm"/> the <code class="literal">ContactResource#getContact()</code> method<a id="id102" class="indexterm"/> we previously implemented. We use the <code class="literal">Response#ok(Object entity)</code> method<a id="id103" class="indexterm"/> in order to build the response to be sent to the client, passing <a id="id104" class="indexterm"/>it to <code class="literal">String</code> as a parameter, as shown in the following code:</p><div class="informalexample"><pre class="programlisting">return Response.ok("{id: " + id + ", name: \"Dummy Name\", phone: \"+0123456789\" }").build();</pre></div><p>Now, we have our <code class="literal">Representation</code> class ready, and we are going to utilize it and pass instances <a id="id105" class="indexterm"/>of it to the <code class="literal">#ok()</code> method.</p><div class="section" title="How to do it…"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec30"/>How to do it…</h2></div></div></div><p>Perform the following steps to learn the serving of representation through the  resource class:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Update<a id="id106" class="indexterm"/> the <code class="literal">ContactResource#getContact()</code> method accordingly in order to pass a <code class="literal">Contact</code> object in the <code class="literal">#ok()</code> method instead of <code class="literal">String</code>, as shown in the following code. You will need to import the <code class="literal">Contact</code> class first (<code class="literal">import com.dwbook.phonebook.representations.Contact</code>):<div class="informalexample"><pre class="programlisting">@GET
@Path("/{id}")
public Response getContact(@PathParam("id") int id) {
  // retrieve information about the contact with the provided id
  // ...
    return Response
    .ok( new Contact( id, "John", "Doe", "+123456789") )
    .build();
}</pre></div></li><li class="listitem">Next, modify the method's signature, splitting<a id="id107" class="indexterm"/> the <code class="literal">name</code> variable to <code class="literal">firstName</code> and <code class="literal">lastName</code> in order to be consistent with the <code class="literal">Contact</code> class:<div class="informalexample"><pre class="programlisting">  @PUT
  @Path("/{id}")
  public Response updateContact(
      @PathParam("id") int id,
      @FormParam("firstName") String firstName,
      @FormParam("lastName") String lastName,
      @FormParam("phone") String phone) {
    // update the contact with the provided ID
    // ...
    return Response
        <span class="strong"><strong>.ok( new Contact(id, firstName, lastName, phone) )</strong></span>
        .build();
  }</pre></div></li><li class="listitem">Rebuild (<code class="literal">mvn package</code>) and run the application again:<div class="informalexample"><pre class="programlisting">$ java -jar target/dwbook-phonebook-1.0-SNAPSHOT.jar server config.yaml</pre></div></li><li class="listitem">Navigate to <code class="literal">http://localhost:8080/contact/123</code> or perform a PUT request to the same URL. You will see that the response that the server is sending to our request is a<a id="id108" class="indexterm"/> JSON representation of the object we are passing to the <code class="literal">Response#ok()</code> method.</li></ol></div></div><div class="section" title="How it works…"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec31"/>How it works…</h2></div></div></div><p>We define the response sent to the client by using the <code class="literal">Response#ok()</code> method, which accepts an object as a parameter. Until now, we have been passing JSON strings directly. This is not an <a id="id109" class="indexterm"/>efficient way, as our application <a id="id110" class="indexterm"/>will be handling actual objects (the <code class="literal">Contact</code> instances), and there is no reason for manually creating JSON representations of them when this can be done automatically by Jackson.</p></div><div class="section" title="There's more..."><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec32"/>There's more...</h2></div></div></div><p>We are now using our <code class="literal">representation</code> class in order to map its properties to the response we are producing. We can also use the same class to map our input parameters. For instance, we <a id="id111" class="indexterm"/>could modify the <code class="literal">ContactResource#updateContact()</code> and <code class="literal">ContactResource#createContact()</code>methods<a id="id112" class="indexterm"/> to expect a <code class="literal">Contact</code> object as a parameter instead of using each of its properties explicitly.</p><div class="section" title="Using cURL to perform HTTP requests"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl3sec16"/>Using cURL to perform HTTP requests</h3></div></div></div><p>Using your<a id="id113" class="indexterm"/> browser, you can only perform <a id="id114" class="indexterm"/>GET requests. In order to effectively test our application though, we will need a tool capable of performing HTTP requests with the POST, PUT, and DELETE methods. cURL (<a class="ulink" href="http://curl.haxx.se/">http://curl.haxx.se/</a>) is a <a id="id115" class="indexterm"/>command-line tool that we can use to better comprehend the examples. You can download it from <a class="ulink" href="http://curl.haxx.se/download.html">http://curl.haxx.se/download.html</a> by choosing the package that is compatible with your platform.</p><p>Performing <a id="id116" class="indexterm"/>a GET request is as simple as the cURL. The following example will call the <code class="literal">#getContact()</code> method:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ curl  http://localhost:8080/contact/123</strong></span>
</pre></div><div class="mediaobject"><img src="graphics/9530OS_05_01.jpg" alt="Using cURL to perform HTTP requests"/></div><p>The JSON string you are seeing in the second line is the server's response.</p><p>In order to perform a PUT request to update a contact, we will need to use the <code class="literal">-X</code> flag followed by the method name (that is <code class="literal">curl -X PUT</code> …). To send data to the server along with our request, a contact's information in this case, use the <code class="literal">-d</code> flag as well along with the data. Note that since the <code class="literal">#updateContact()</code> method's parameters are mapped to request <a id="id117" class="indexterm"/>parameters (with <code class="literal">@FormParam</code>), we need to <a id="id118" class="indexterm"/>send the data URL encoded. Take a look at the following screenshot:</p><div class="mediaobject"><img src="graphics/9530OS_05_02.jpg" alt="Using cURL to perform HTTP requests"/></div><p>If we <a id="id119" class="indexterm"/>want to see a verbose output that<a id="id120" class="indexterm"/> includes the request's and response's headers, we can use the <code class="literal">-v</code> (long name --verbose) flag. Also, in case we need to set the value of a request header, we can use the <code class="literal">-H</code> (long name --header) flag followed by the header information:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ curl --header "Content-Type: application/json" http://localhost:8080/contact/1</strong></span>
</pre></div></div></div></div>
<div class="section" title="Mapping the request data to representations"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec18"/>Mapping the request data to representations</h1></div></div></div><p>The current <a id="id121" class="indexterm"/>way of reading the web service <a id="id122" class="indexterm"/>properties by mentioning each one of <a id="id123" class="indexterm"/>them (annotated) in the signatures of the <code class="literal">#createContact()</code> and <code class="literal">#updateContact()</code> methods is fine; however, it is not efficient<a id="id124" class="indexterm"/> in case of significant amount of input data. Imagine a case where we would need to add several additional properties in the <code class="literal">Contact</code> class. We would have to also update the method signatures as well, making them less readable and finally unmanageable. Generally, it is preferred to map the request data to the representation directly. To achieve this, we will update the relevant methods accordingly, removing the properties and adding a <code class="literal">contact</code> instance instead. Jackson will take care of the rest.</p><div class="section" title="How to do it…"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec33"/>How to do it…</h2></div></div></div><p>Perform the following steps to map the request data:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Update the <code class="literal">ContactResource#createContact()</code> method<a id="id125" class="indexterm"/>, replacing its parameters with a single <code class="literal">contact</code> object:<div class="informalexample"><pre class="programlisting">@POST
public Response createContact(Contact contact) {
  // store the new contact 
  // ...
  return Response
      .created(null)
      .build();
}</pre></div></li><li class="listitem">Update<a id="id126" class="indexterm"/> the <code class="literal">ContactResource#updateContact()</code> method, replacing its parameters with a <a id="id127" class="indexterm"/>single <code class="literal">contact</code> object:<div class="informalexample"><pre class="programlisting">@PUT
@Path("/{id}")
public Response updateContact(
    @PathParam("id") int id,
    Contact contact) {
  // update the contact with the provided ID
    // ...
  return Response
      .ok(new Contact(id, contact.getFirstName(), contact.getLastName(), contact.getPhone()))
      .build();
}</pre></div></li><li class="listitem">Rebuild and run the application again. The application is now able to handle HTTP POST and PUT requests to the <code class="literal">/contact</code> and <code class="literal">/contact/{id}</code> endpoints respectively, having JSON strings on the request body instead of the named parameters. Note that the <code class="literal">Content-Type</code> header of the request will be set to <code class="literal">application/json</code>.</li></ol></div></div><div class="section" title="How it works…"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec34"/>How it works…</h2></div></div></div><p>By declaring a <code class="literal">Contact</code> instance as the parameter on a method that handles requests (that is, a method with Jersey annotations bound to URI), we force Jersey to parse the request body and deserialize (using Jackson) it to a <code class="literal">Contact</code> object.</p><p>The PUT request we performed in the previous example can now be performed by sending the JSON data to the server and setting the appropriate header, as shown in the following line of code:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ curl --header "Content-Type: application/json" -X PUT -d '{"firstName": "FOO", "lastName":"BAR", "phone":"987654321"}' http://localhost:8080/contact/123</strong></span>
</pre></div><div class="mediaobject"><img src="graphics/9530OS_05_03.jpg" alt="How it works…"/></div><p>In<a id="id128" class="indexterm"/> case a POST request is performed on <code class="literal">http://localhost:8080/contact</code> with the <code class="literal">{"firstName": "Alexandros", "lastName": "Dallas", "phone": "+3012345678"}</code> JSON data as the request's body and<a id="id129" class="indexterm"/> the <code class="literal">Content-Type</code> header: <code class="literal">application/json</code>, the <code class="literal">contact</code> object within the <code class="literal">#createContact()</code> method will have its<a id="id130" class="indexterm"/> properties initialized accordingly, thanks to Jackson and its appropriate JAX-RS entity providers. Entity providers are components that process the payload that is included in an HTTP request and transform it to an object. This is similar to the transformation that happens when a <code class="literal">resource</code> method is returning an <a id="id131" class="indexterm"/>object and is transformed to a JSON object.</p></div></div></body></html>