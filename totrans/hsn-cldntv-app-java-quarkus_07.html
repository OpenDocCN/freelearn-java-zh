<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Managing Data Persistence with Quarkus</h1>
                </header>
            
            <article>
                
<p class="mce-root">So far, we have developed some basic applications using in-memory structures that can be accessed through REST channels. But this is just the beginning. In real-world examples, you don't just rely on in-memory data; instead, you persist your data structure either on a relational database or somewhere else, such as in NoSQL storage. Therefore, in this chapter, we will leverage the essential skills we need in order to build applications in Quarkus that persist data into a relational database. We will also learn how to use an <strong>Object Relational Mapping</strong> (<strong>ORM</strong>) tool such as Hibernate ORM to map a database as storage and how to simplify its usage with the <strong>Hibernate ORM with Panache</strong> extension.</p>
<p>In this chapter, we will cover the following topics:</p>
<ul>
<li class="mce-root">Adding an ORM layer to the customer service</li>
<li class="mce-root">Configuring and running an application to reach an RDBMS</li>
<li class="mce-root">Taking both services (application and database) into the cloud</li>
<li class="mce-root">Adding Hibernate ORM with Panache on top of your application to simplify the ORM</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Technical requirements</h1>
                </header>
            
            <article>
                
<p>You can find the source code for the project in this chapter on GitHub at <a href="https://github.com/PacktPublishing/Hands-On-Cloud-Native-Applications-with-Java-and-Quarkus/tree/master/Chapter05">https://github.com/PacktPublishing/Hands-On-Cloud-Native-Applications-with-Java-and-Quarkus/tree/master/Chapter05</a>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Adding an ORM layer to our applications</h1>
                </header>
            
            <article>
                
<p>If you've ever worked on an Enterprise project before, you will know that almost every Java application uses an ORM tool to map an external database. The advantages of mapping a database structure with Java objects are as follows:</p>
<ul>
<li><strong>Database neutrality</strong>: Your code will not be database-specific, so you don't need to adapt your code to a specific database SQL syntax, which may vary between vendors.</li>
<li><strong>Developer friendly workflow</strong>: You don't need to write complex SQL structures to access your data <span>â€“ you</span> simply need to refer to Java fields.</li>
</ul>
<p>On the other hand, it's also true that, by writing native SQL statements, you can be truly aware of what your code is actually doing. Also, in most cases, you can achieve maximum performance benefits by writing direct SQL statements. For this reason, most ORM tools include an option to execute native SQL statements to bypass the standard ORM logic.</p>
<p>In the Quarkus toolkit, you can use the <kbd>quarkus-hibernate-orm</kbd> extension to map your Java classes as entity objects. Hibernate ORM sits between the Java application data access layer and the relational database. You can use Hibernate ORM APIs to perform operations such as query, delete, store, and on domain data.</p>
<p>First of all, let's define the domain model for our application. We will start with the simple <strong>Customer</strong> object since we already know what it is. To make our example a bit more interesting, we will add another object, called <strong>Orders</strong>, that is related to our <strong>Customer</strong> object. To be precise, we will declare a <strong>one-to-many</strong> relationship between a <strong>Customer</strong> and its <strong>Orders</strong>:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/4acb8b92-fd0f-44da-b3d6-666191e02670.png" style=""/></div>
<p>To get started, let's check the first example for this chapter, which is located in the <kbd>Chapter05/hibernate</kbd> folder in this book's GitHub repository. We recommend importing the project into your IDE before moving on.</p>
<p>If you inspect the <kbd>pom.xml</kbd> file of this project, you will find several new extensions included in it:</p>
<ul>
<li><kbd>quarkus-hibernate-orm</kbd>: This extension is the core dependency that we need in order to use Hibernate's ORM tool in our application.</li>
<li><kbd>quarkus-agroal</kbd>: This extension buys us the Agroal connection pool, which will handle JDBC connection management for us.</li>
<li><kbd>quarkus-jdbc-postgresql</kbd>: This extension contains the JDBC modules that we need in order to connect to the PostgreSQL database.</li>
<li><kbd>quarkus-resteasy-jsonb</kbd>: This extension is needed so that we can create JSON items at runtime and produce a JSON response.</li>
</ul>
<p>The following code shows the additional dependencies as XML elements:</p>
<pre>&lt;dependency&gt;<br/>       &lt;groupId&gt;io.quarkus&lt;/groupId&gt;<br/>       &lt;artifactId&gt;quarkus-hibernate-orm&lt;/artifactId&gt;<br/>&lt;/dependency&gt;<br/>&lt;dependency&gt;<br/>       &lt;groupId&gt;io.quarkus&lt;/groupId&gt;<br/>       &lt;artifactId&gt;quarkus-agroal&lt;/artifactId&gt;<br/>&lt;/dependency&gt;<br/>&lt;dependency&gt;<br/>       &lt;groupId&gt;io.quarkus&lt;/groupId&gt;<br/>       &lt;artifactId&gt;quarkus-jdbc-postgresql&lt;/artifactId&gt;<br/>&lt;/dependency&gt;<br/>&lt;dependency&gt;<br/>       &lt;groupId&gt;io.quarkus&lt;/groupId&gt;<br/>       &lt;artifactId&gt;quarkus-resteasy-jsonb&lt;/artifactId&gt;<br/>&lt;/dependency&gt;</pre>
<p>Now that we've looked at the project's configuration, let's inspect the single components that make up our application.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Defining the entity layer</h1>
                </header>
            
            <article>
                
<p>The first thing we need to check is the list of entity objects that will map the database tables. The first one is the <kbd>Customer @Entity</kbd> class, as follows:</p>
<pre>@Entity<br/>@NamedQuery(name = <span>"Customers.findAll"</span>,<br/>        query = <span>"SELECT c FROM Customer c ORDER BY c.id"</span>,<br/>        hints = @QueryHint(name = <span>"org.hibernate.cacheable"</span>, value = <br/>        <span>"true"</span>) )<br/><span>public class </span>Customer {<br/>    @Id<br/>    @SequenceGenerator(<br/>            name = <span>"customerSequence"</span>,<br/>            sequenceName = <span>"customerId_seq"</span>,<br/>            allocationSize = <span>1</span>,<br/>            initialValue = <span>1</span>)<br/>    @GeneratedValue(strategy = GenerationType.SEQUENCE, generator = <br/>     <span>"customerSequence"</span>)<br/>    <span>private </span>Long <span>id</span>;<br/><br/>    @Column(length = <span>40</span>)<br/>    <span>private </span>String <span>name</span>;<br/><br/>    @Column(length = <span>40</span>)<br/>    <span>private </span>String <span>surname</span>;<br/><br/>    @OneToMany(mappedBy = <span>"customer"</span>)<br/>    @JsonbTransient<br/>    <span>public </span>List&lt;Orders&gt; <span>orders</span>;<br/><br/> // Getters / Setters omitted for brevity<br/>}</pre>
<p>Let's go through the single annotations we have included in the entity class:</p>
<ul>
<li>The <kbd>@Entity</kbd> annotation makes this class eligible for persistence. It can be coupled with the <kbd>@Table</kbd> annotation to define the corresponding database table to a map. If it's not included, like in our case, it will map a database table with the same name.</li>
<li>The <kbd>@NamedQuery</kbd> annotation (placed at the class level) is a statically defined SQL statement featuring a query string. Using named queries in your code improves how your code is organized since it separates the JPA query language from the Java code. It also avoids the bad practice of embedding string literals directly in your SQL, thus enforcing the use of parameters instead.</li>
<li>The <kbd>@Id</kbd> annotation specifies the primary key of an entity, which will be unique for every record.</li>
<li>The <kbd>@SequenceGenerator</kbd> annotation is used to delegate the creation of a sequence as a unique identifier for primary keys. You will need to check that your database is capable of handling sequences. On the other hand, although this isn't the default option, this is considered a safer alternative since the identifier can be generated prior to executing the <kbd>INSERT</kbd> statement.</li>
<li>The <kbd>@Column</kbd> annotation is used to tell Hibernate ORM that the Java field maps a database column. Note that we have also specified a constraint in terms of the size of the column. Since we will let Hibernate ORM create our database structures from Java code, all the constraints that are declared in the Java class will effectively turn into database constraints.</li>
<li>Finally, we had to apply two annotations on top of the <kbd>orders</kbd> field:
<ul>
<li>The <kbd>@OneToMany</kbd> annotation defines a one-to-many relationship with the <kbd>Orders</kbd> table (that is, one customer is associated with many orders).</li>
<li>The <kbd>@JsonbTransient</kbd> annotation prevents <span class="st">mapping the field to the JSON representation (since the reverse mapping for this relationship is included in the <kbd>Orders</kbd> class, mapping this field to JSON would cause a <kbd>StackOverflow</kbd> error)</span>.</li>
</ul>
</li>
</ul>
<div class="packt_tip">In our code example, we have omitted the getter/setter methods for the sake of brevity. These are, however, needed by Hibernate ORM to perform entity reads and writes against the database. In the <em>Making data persistence easier with Hibernate Panache</em> section later in this chapter, we will learn how to make our code leaner and cleaner by extending the <kbd>PanacheEntity</kbd> API.</div>
<p>The <kbd>Customer</kbd> entity, in turn, references the following <kbd>Orders</kbd> class, which provides the other side of the one-to-many annotation:</p>
<pre>@Entity<br/>@NamedQuery(name = <span>"Orders.findAll"</span>,<br/>        query = <span>"SELECT o FROM Orders o WHERE o.customer.id = :customerId ORDER BY o.item"</span>)<br/><span>public class </span>Orders {<br/>    @Id<br/>    @SequenceGenerator(<br/>            name = <span>"orderSequence"</span>,<br/>            sequenceName = <span>"orderId_seq"</span>,<br/>            allocationSize = <span>1</span>,<br/>            initialValue = <span>1</span>)<br/>    @GeneratedValue(strategy = GenerationType.SEQUENCE, generator = <br/>     <span>"orderSequence"</span>)<br/>    <span>public </span>Long <span>id</span>;<br/><br/>    @Column(length = <span>40</span>)<br/>    <span>public </span>String <span>item</span>;<br/><br/>    @Column<br/>    <span>public </span>Long <span>price</span>;<br/><br/>    @ManyToOne<br/>    @JoinColumn(name = <span>"customer_id"</span>) <br/>    @JsonbTransient<br/>    <span>public </span>Customer <span>customer</span>;<br/><br/> // Getters / Setters omitted for brevity<br/>}</pre>
<p>It's worth noting that the named query for this class is slightly more elaborated since <kbd>Orders.findAll</kbd> <kbd>NamedQuery</kbd> uses a parameter in order to filter the orders by a specific customer.</p>
<p>Since the <kbd>Customer</kbd> structure and the <kbd>Orders</kbd> structure make up a bidirectional association, we need to map the corresponding <kbd>Customer</kbd> field to the <kbd>@javax.persistence.ManyToOne</kbd> annotation.</p>
<p>We also have included the <kbd>@javax.persistence.JoinColumn</kbd> annotation to indicate that this entity is the owner of the relationship. In database terms, this means that the corresponding table has a column with a foreign key for the referenced table. Now that we have a class where data will be stored, let's inspect the <kbd>Repository</kbd> class, which is used to access data from the RDBMS.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Coding the repository classes</h1>
                </header>
            
            <article>
                
<p>In order to access our <kbd>Customer</kbd> data, we are still relying on the <kbd>CustomerRepository</kbd> class, which needs to be adjusted. First and foremost, we have injected an instance of the <kbd>EntityManager</kbd> interface <span class="ILfuVd"><span class="e24Kjd">in order to manage the persistence of entity instances:</span></span></p>
<pre><span>@ApplicationScoped<br/></span><span>public class </span>CustomerRepository {<br/><br/>    <span>@Inject<br/></span><span>    </span>EntityManager <span>entityManager</span>;<br/><br/>}</pre>
<p>Once we have a reference to <kbd>EntityManager</kbd>, we can use it to perform CRUD operations on the rest of the class:</p>
<pre><span>public </span>List&lt;Customer&gt; findAll() {<br/>        <span>return </span><span>entityManager</span>.createNamedQuery(<span>"Customers.findAll"</span>, <br/>         Customer.<span>class</span>)<br/>                .getResultList();<br/>}<br/><br/><span>public </span>Customer findCustomerById(Long id) {<br/>        Customer customer = <span>entityManager</span>.find(Customer.<span>class</span>, id);<br/><br/>        <span>if </span>(customer == <span>null</span>) {<br/>            <span>throw new </span>WebApplicationException(<span>"Customer with id of " </span>+ <br/>             id + <span>" does not exist."</span>, <span>404</span>);<br/>        }<br/>        <span>return </span>customer;<br/>}<br/><br/>@Transactional<br/><span>public void </span>updateCustomer(Customer customer) {<br/>        Customer customerToUpdate = findCustomerById(customer.<br/>         getId());<br/>        customerToUpdate.setName(customer.getName());<br/>        customerToUpdate.setSurname(customer.getSurname());<br/>}<br/><br/>@Transactional<br/><span>public void </span>createCustomer(Customer customer) {<br/>        <span>entityManager</span>.persist(customer);<br/>}<br/><br/>@Transactional<br/><span>public void </span>deleteCustomer(Long customerId) {<br/>        Customer c = findCustomerById(customerId);<br/>        <span>entityManager</span>.remove(c);<br/>}</pre>
<p>It's important to note that we have marked all methods that are performing write operations with the <kbd>@javax.transaction.Transactional</kbd> annotation. This is the simplest way to demarcate transaction boundaries in a Quarkus application, just like we used to do in Java Enterprise applications. In practice, a <kbd>@Transactional</kbd> method will run in the context of the caller's transaction, if any. Otherwise, it will start a new transaction before running the method.</p>
<p>Next, we created a <kbd>Repository</kbd> class, which is also used to manage orders. The <kbd>OrderRepository</kbd> class is pretty much equivalent to the <kbd>CustomerRepository</kbd> class, except for the fact that the <kbd>findAll</kbd> method will filter through the orders of a specific customer:</p>
<pre><span>@ApplicationScoped<br/></span><span>public class </span>OrderRepository {<br/><br/>    <span>@Inject<br/></span><span>    </span>EntityManager <span>entityManager</span>;<br/><br/>    <span>public </span>List&lt;Orders&gt; findAll(Long customerId) {<br/><br/>      return  (List&lt;Orders&gt;) <br/>        <span>entityManager</span>.createNamedQuery(<span>"Orders.findAll"</span>)<br/>                .setParameter(<span>"customerId"</span>, customerId)<br/>                .getResultList();<br/>    }<br/><br/>    <span>public </span>Orders findOrderById(Long id) {<br/><br/>        Orders order = <span>entityManager</span>.find(Orders.<span>class</span>, id);<br/>        <span>if </span>(order == <span>null</span>) {<br/>            <span>throw new </span>WebApplicationException(<span>"Order with id of " </span>+ id <br/>             + <span>" does not exist."</span>, <span>404</span>);<br/>        }<br/>        <span>return </span>order;<br/>    }<br/>    @Transactional<br/>    <span>public void </span>updateOrder(Orders order) {<br/>        Orders orderToUpdate = findOrderById(order.getId());<br/>        orderToUpdate.setItem(order.getItem());<br/>        orderToUpdate.setPrice(order.getPrice());<br/>    }<br/>    @Transactional<br/>    <span>public void </span>createOrder(Orders order, Customer c) {<br/>        order.setCustomer(c);<br/>        <span>entityManager</span>.persist(order);<br/><br/>    }<br/>    @Transactional<br/>    <span>public void </span>deleteOrder(Long orderId) {<br/>        Orders o = findOrderById(orderId);<br/>        <span>entityManager</span>.remove(o);<br/>    }<br/>}</pre>
<p>Now that we've discussed <kbd>Repository</kbd> and entity classes, let's check out the REST endpoint, which makes the application responsive.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Defining REST endpoints</h1>
                </header>
            
            <article>
                
<p>Our application defines one REST endpoint for each <kbd>Repository</kbd> class. We already coded <kbd>CustomerEndpoint</kbd> in the previous chapter, which was blissfully unaware of whether it was using storage or not. Therefore, half of the work has already been done. We've only added <kbd>OrderEndpoint</kbd> here, which maps CRUD HTTP operations accordingly:</p>
<pre><span>@Path</span>(<span>"orders"</span>)<br/><span>@ApplicationScoped<br/></span><span>@Produces</span>(<span>"application/json"</span>)<br/><span>@Consumes</span>(<span>"application/json"</span>)<br/><span>public class </span>OrderEndpoint {<br/><br/>    <span>@Inject </span>OrderRepository <span>orderRepository</span>;<br/>    <span>@Inject </span>CustomerRepository <span>customerRepository</span>;<br/><br/>    <span>@GET<br/></span><span>    </span><span>public </span>List&lt;Orders&gt; getAll(<span>@QueryParam</span>(<span>"customerId"</span>) Long <br/>     customerId) {<br/>        <span>return </span><span>orderRepository</span>.findAll(customerId);<br/>    }<br/><br/>    <span>@POST<br/></span><span>    @Path</span>(<span>"/{customer}"</span>)<br/>    <span>public </span>Response create(Orders order, <span>@PathParam</span>(<span>"customer"</span>) Long <br/>     customerId) {<br/>        Customer c = <span>customerRepository</span>.findCustomerById(customerId);<br/>        <span>orderRepository</span>.createOrder(order,c);<br/>        <span>return </span>Response.<span>status</span>(<span>201</span>).build();<br/><br/>    }<br/><br/>    <span>@PUT<br/></span><span>    </span><span>public </span>Response update(Orders order) {<br/>        <span>orderRepository</span>.updateOrder(order);<br/>        <span>return </span>Response.<span>status</span>(<span>204</span>).build();<br/>    }<br/>    <span>@DELETE<br/></span><span>    @Path</span>(<span>"/{order}"</span>)<br/>    <span>public </span>Response delete(<span>@PathParam</span>(<span>"order"</span>) Long orderId) {<br/>        <span>orderRepository</span>.deleteOrder(orderId);<br/>        <span>return </span>Response.<span>status</span>(<span>204</span>).build();<br/>    }<br/><br/>}</pre>
<p>Our <kbd>OrderEndpoint</kbd> is slightly more elaborate since it needs to filter through each order operation by <kbd>Customer</kbd> ID in the <kbd>getAll</kbd> method. We also used the <kbd>@PathParam</kbd> annotation across the code to move the <kbd>Customer</kbd> and <kbd>Orders</kbd> data from the client to the REST endpoint.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Connecting to the database</h1>
                </header>
            
            <article>
                
<p>Database connections are made through Quarkus' main configuration file (<kbd>application.properties</kbd>), which needs, at the very least, the JDBC settings for the database. We will be using PostgreSQL as storage so that the JDBC URL and driver comply with PostgreSQL JDBC's specifications. The following configuration will be used to access the <kbd>quarkusdb</kbd> database, which uses the <kbd>quarkus/quarkus</kbd> credentials:</p>
<pre><span>quarkus.datasource.url=jdbc:postgresql://${POSTGRESQL_SERVICE_HOST:localhost}:${POSTGRESQL_SERVICE_PORT:5432}/quarkusdb<br/></span><span>quarkus.datasource.driver</span>=<span>org.postgresql.Driver<br/></span><span>quarkus.datasource.username</span>=<span>quarkus<br/></span><span>quarkus.datasource.password</span>=<span>quarkus<br/></span></pre>
<div class="packt_tip">Note that we are using two environment variables (<kbd>POSTGRESQL_SERVICE_HOST</kbd> and <kbd>POSTGRESQL_SERVICE_PORT</kbd>) to define the database host and port. If they're left undefined, they will be set to <kbd>localhost</kbd> and <kbd>5432</kbd>. This configuration will come in handy when we switch our application from the local filesystem to the cloud.</div>
<p>Next, we configured Hibernate ORM to use the <strong>drop and create</strong> strategy at boot. This is ideal for developing or testing applications as it will drop and regenerate the schema and database objects from the Java Entity each time we start the application:</p>
<pre><span>quarkus.hibernate-orm.database.generation</span>=<span>drop-and-create</span></pre>
<p>Additionally, we have included the Agroal connection pool settings to define the pool's initial size, the minimum number of connections to be kept available in memory, and the maximum number of simultaneous connections which can be opened:</p>
<pre><span>quarkus.datasource.initial-size=1<br/>quarkus.datasource.min-size=2<br/>quarkus.datasource.max-size=8</span></pre>
<p>Finally, it can be useful to have some pre-inserted rows in our schema for testing purposes. Hence, we have set the location where the script (<kbd>import.sql</kbd>) is located using the following property:</p>
<pre><span>quarkus.hibernate-orm.sql-load-script</span><span>=</span><span>import.sql</span></pre>
<p>The following content in the <kbd>import.sql</kbd> script adds two rows to the <kbd>Customer</kbd> table:</p>
<pre><span>INSERT INTO </span>customer (id, name, surname) <span>VALUES </span>( nextval(<span>'customerId_seq'</span>), <span>'John'</span>,<span>'Doe'</span>);<br/><span>INSERT INTO </span>customer (id, name, surname) <span>VALUES </span>( nextval(<span>'customerId_seq'</span>), <span>'Fred'</span>,<span>'Smith'</span>);</pre>
<p>The preceding SQL script can be found in the <kbd>src/main/resources</kbd> folder.</p>
<p>Now that we've inspected our service, we will check the test class, which verifies CRUD operations automatically. Then, we will take a look at the web interface so that we can test the code through a browser.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Coding a test class</h1>
                </header>
            
            <article>
                
<p>Our basic <kbd>Test</kbd> class assumes that we already have a couple of <kbd>Customer</kbd> objects available. Therefore, once we verify their count with a <kbd>GET</kbd> request, we will test all CRUD operations on the <kbd>Orders</kbd> subordinate entity, as illustrated in the following code:</p>
<pre><span>// Test GET<br/></span><span>given</span>()<br/>        .when().get(<span>"/customers"</span>)<br/>        .then()<br/>        .statusCode(<span>200</span>)<br/>        .body(<span>"$.size()"</span>, is(<span>2</span>));<br/><br/>// Create a JSON Object for the Order<br/>JsonObject objOrder = Json.<span>createObjectBuilder</span>()<br/>        .add(<span>"item"</span>, <span>"bike"</span>)<br/>        .add(<span>"price"</span>, <span>new </span>Long(<span>100</span>))<br/>        .build();<br/><br/><br/><span>// Test POST Order for Customer #1<br/></span><span>given</span>()<br/>        .contentType(<span>"application/json"</span>)<br/>        .body(objOrder.toString())<br/>        .when()<br/>        .post(<span>"/orders/1"</span>)<br/>        .then()<br/>        .statusCode(<span>201</span>);<br/><br/><span>// Create new JSON for Order #1<br/></span>objOrder = Json.<span>createObjectBuilder</span>()<br/>        .add(<span>"id"</span>, <span>new </span>Long(<span>1</span>))<br/>        .add(<span>"item"</span>, <span>"mountain bike"</span>)<br/>        .add(<span>"price"</span>, <span>new </span>Long(<span>100</span>))<br/>        .build();<br/><br/><span>// Test UPDATE Order #1<br/></span><span>given</span>()<br/>        .contentType(<span>"application/json"</span>)<br/>        .body(objOrder.toString())<br/>        .when()<br/>        .put(<span>"/orders"</span>)<br/>        .then()<br/>        .statusCode(<span>204</span>);<br/><br/><span>// Test GET for Order #1<br/></span><span>given</span>()<br/>        .when().get(<span>"/orders?customerId=1"</span>)<br/>        .then()<br/>        .statusCode(<span>200</span>)<br/>        .body(<span>containsString</span>(<span>"mountain bike"</span>));<br/><br/><span>// Test DELETE Order #1<br/></span><span>given</span>()<br/>        .when().delete(<span>"/orders/1"</span>)<br/>        .then()<br/>        .statusCode(<span>204</span>);</pre>
<p>This test class shouldn't be too complex at this point. We are basically testing that the two customers are available in the database using the <kbd>org.hamcrest.CoreMatchers.is</kbd> construct. Then, we are performing a complete round of operations on the <kbd>Orders</kbd> entity by creating one item, updating it, querying it, and finally deleting it.</p>
<p>Before running the test, we need an available database where data is going to be persisted. The recommended approach, if you haven't got an active PostgreSQL instance, is to start a <kbd>docker</kbd> image using the following shell:</p>
<pre><strong>$ docker run --ulimit memlock=-1:-1 -it --rm=true --memory-swappiness=0 --name quarkus_test -e POSTGRES_USER=quarkus -e POSTGRES_PASSWORD=quarkus -e POSTGRES_DB=quarkusdb -p 5432:5432 postgres:10.5</strong></pre>
<p>Please note that, in addition to the database user, password, and DB settings, we are also enforcing our container via the <kbd>--ulimit memlock=-1:-1</kbd> setting in order to do unlimited memlocking to prevent swapping. We are also forwarding the database's address and port to all IPv4/IPv6 addresses that are available on the local machine.</p>
<p>The following output will be emitted when the <kbd>docker</kbd> process is started:</p>
<pre><strong>2019-07-09 14:05:56.235 UTC [1] LOG:  listening on IPv4 address "0.0.0.0", port 5432</strong><br/><strong>2019-07-09 14:05:56.235 UTC [1] LOG:  listening on IPv6 address "::", port 5432</strong><br/><strong>2019-07-09 14:05:56.333 UTC [1] LOG:  listening on Unix socket "/var/run/postgresql/.s.PGSQL.5432"</strong><br/><strong>2019-07-09 14:05:56.434 UTC [60] LOG:  database system was shut down at 2019-07-09 14:05:56 UTC</strong><br/><strong>2019-07-09 14:05:56.516 UTC [1] LOG:  database system is ready to accept connections</strong></pre>
<p>Now, you can launch the test class with the following command:</p>
<pre><strong>$ mvn compile test</strong></pre>
<p>The expected output should confirm that the test ran successfully:</p>
<pre><strong>[INFO] Running com.packt.quarkus.chapter5.CustomerEndpointTest</strong><br/><strong>. . . .</strong><br/><strong>[INFO] Tests run: 1, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 11.846 s - in com.packt.quarkus.chapter5.CustomerEndpointTest</strong></pre>
<p>Now, we will check the static web pages of the project that we have added so that we can access and manage our service.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Adding a web interface to our application</h1>
                </header>
            
            <article>
                
<p>Our service includes two static web pages to manage the customer service and the orders for each customer. As you know from our previous chapter, static pages are found in the <kbd>src/main/resources/META-INF/resources</kbd> file of your project by default. We can reuse the same <kbd>index.html</kbd> page from the previous chapter, which will be our landing page for our application. One enhancement you will find, though, is an action named <span class="packt_screen">Add Order</span>, which redirects our users to the <kbd>order.html</kbd> page, which passes a query parameter of the <kbd>Customer</kbd> information:</p>
<pre><span>&lt;</span><span>div </span><span>class</span><span>="divTable blueTable"</span><span>&gt;</span><br/>    <span>&lt;</span><span>div </span><span>class</span><span>="divTableHeading"</span><span>&gt;</span><br/>        <span>&lt;</span><span>div  </span><span>class</span><span>="divTableHead"</span><span>&gt;</span>Customer Name<span>&lt;/</span><span>div</span><span>&gt;</span><br/>        <span>&lt;</span><span>div  </span><span>class</span><span>="divTableHead"</span><span>&gt;</span>Customer Address<span>&lt;/</span><span>div</span><span>&gt;</span><br/>        <span>&lt;</span><span>div  </span><span>class</span><span>="divTableHead"</span><span>&gt;</span>Action<span>&lt;/</span><span>div</span><span>&gt;</span><br/>    <span>&lt;/</span><span>div</span><span>&gt;</span><br/>    <span>&lt;</span><span>div </span><span>class</span><span>="divTableRow" </span><span>ng-repeat</span><span>="customer in customers"</span><span>&gt;</span><br/>        <span>&lt;</span><span>div </span><span>class</span><span>="divTableCell"</span><span>&gt;</span>{{ customer.name }}<span>&lt;/</span><span>div</span><span>&gt;</span><br/>        <span>&lt;</span><span>div </span><span>class</span><span>="divTableCell"</span><span>&gt;</span>{{ customer.surname }}<span>&lt;/</span><span>div</span><span>&gt;</span><br/>        <span>&lt;</span><span>div </span><span>class</span><span>="divTableCell"</span><span>&gt;</span><br/>            <span>&lt;</span><span>a </span><span>ng-href</span><span>="/order.html?customerId={{ customer.id <br/>             }}&amp;customerName={{ customer.name }}&amp;<br/>               customerSurname={{ customer.surname }}" </span><span><br/>               class</span><span>="myButton"</span><span>&gt;</span>Orders<span>&lt;/</span><span>a</span><span>&gt;</span><br/>            <span>&lt;</span><span>a </span><span>ng-click</span><span>="edit( customer )" </span><span>class</span><span>="myButton"</span><span>&gt;</span>Edit<span>&lt;/</span><span>a</span><span>&gt;</span><br/>            <span>&lt;</span><span>a </span><span>ng-click</span><span>="remove( customer )" <br/>        </span><span>class</span><span>="myButton"</span><span>&gt;</span>Remove<span>&lt;/</span><span>a</span><span>&gt;</span><br/>        <span>&lt;/</span><span>div</span><span>&gt;</span><br/>    <span>&lt;/</span><span>div</span><span>&gt;</span><br/><span>&lt;/</span><span>div</span><span>&gt;</span></pre>
<p>The <kbd>order.html</kbd> page has its own AngularJS Controller that is in charge of displaying the set of <kbd>Orders</kbd> for the <kbd>Customer</kbd> selected, allowing us to read, create, modify, or delete existing orders. The following is the first part of the Angular Controller, which defines the module and Controller names, and collects the form parameters:</p>
<pre>var app = angular.module("orderManagement", []);<br/>angular.module('orderManagement').constant('SERVER_URL', '/orders');<br/><br/>//Controller Part<br/>app.controller("orderManagementController", function($scope, $http, SERVER_URL) {<br/><br/> var customerId = getParameterByName('customerId');<br/> var customerName = getParameterByName('customerName');<br/> var customerSurname = getParameterByName('customerSurname');<br/><br/> document.getElementById("info").innerHTML = customerName + " " + customerSurname;<br/><br/> $scope.orders = [];<br/><br/> $scope.form = {<br/> customerId: customerId,<br/> isNew: true,<br/> item: "",<br/> price: 0<br/> };<br/> //Now load the data from server<br/> reloadData();</pre>
<p>In the second part of our JavaScript code, we have included a <kbd>$scope.update</kbd> function to insert/edit new <kbd>Orders</kbd>, a <kbd>$scope.remove</kbd> function to delete existing orders, and a <kbd>reloadData</kbd> function to retrieve the list of <kbd>Orders</kbd> for that <kbd>Customer</kbd>, as shown in the following code:</p>
<pre> //HTTP POST/PUT methods for add/edit orders<br/> $scope.update = function() {<br/><br/> var method = "";<br/> var url = "";<br/> var data = {};<br/> if ($scope.form.isNew == true) {<br/> // add orders - POST operation<br/> method = "POST";<br/> url = SERVER_URL + "/" + customerId;<br/> data.item = $scope.form.item;<br/> data.price = $scope.form.price;<br/><br/> } else {<br/> // it's edit operation - PUT operation<br/> method = "PUT";<br/> url = SERVER_URL;<br/><br/> data.item = $scope.form.item;<br/> data.price = $scope.form.price;<br/><br/> }<br/><br/> if (isNaN(data.price)) {<br/> alert('Price must be a Number!');<br/> return false;<br/> }<br/><br/> $http({<br/> method: method,<br/> url: url,<br/> data: angular.toJson(data),<br/> headers: {<br/> 'Content-Type': 'application/json'<br/> }<br/> }).then(_success, _error);<br/> };<br/><br/><br/> //HTTP DELETE- delete order by id<br/> $scope.remove = function(order) {<br/> $http({<br/> method: 'DELETE',<br/> url: SERVER_URL + "/" + order.id<br/> }).then(_success, _error);<br/> };<br/><br/> //In case of edit orders, populate form with order data<br/> $scope.edit = function(order) {<br/> $scope.form.item = order.item;<br/> $scope.form.price = order.price;<br/> $scope.form.isNew = false;<br/> };<br/> /* Private Methods */<br/> //HTTP GET- get all orders collection<br/> function reloadData() {<br/> $http({<br/> method: 'GET',<br/> url: SERVER_URL,<br/> params: {<br/> customerId: customerId<br/> }<br/> }).then(function successCallback(response) {<br/> $scope.orders = response.data;<br/> }, function errorCallback(response) {<br/> console.log(response.statusText);<br/> });<br/> }<br/><br/> function _success(response) {<br/> reloadData();<br/> clearForm()<br/> }<br/><br/> function _error(response) {<br/> alert(response.data.message || response.statusText);<br/> }<br/> //Clear the form<br/> function clearForm() {<br/> $scope.form.item = "";<br/> $scope.form.price = "";<br/> $scope.form.isNew = true;<br/> }<br/>});</pre>
<p>For the sake of brevity, we haven't included the full HTML page but you can find it in this book's GitHub repository (as we mentioned in the <em>Technical requirements</em> section at the beginning of this chapter).</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Running the application</h1>
                </header>
            
            <article>
                
<p class="mce-root">The application can be executed from the same shell where we ran our test (so that we still retain the <kbd>DB_HOST</kbd> environment variable):</p>
<pre><strong>mvn quarkus:dev</strong></pre>
<p>You should expect the following output in the console:</p>
<pre><strong>Listening for transport dt_socket at address: 5005</strong><br/><strong>2019-07-14 18:41:32,974 INFO  [io.qua.dep.QuarkusAugmentor] (main) Beginning quarkus augmentation</strong><br/><strong>2019-07-14 18:41:33,789 INFO  [io.qua.dep.QuarkusAugmentor] (main) Quarkus augmentation completed in 815ms</strong><br/><strong>2019-07-14 18:41:35,153 INFO  [io.quarkus] (main) Quarkus 0.19.0 started in 2.369s. Listening on: http://[::]:8080</strong><br/><strong>2019-07-14 18:41:35,154 INFO  [io.quarkus] (main) Installed features: [agroal, cdi, hibernate-orm, jdbc-postgresql, narayana-jta, resteasy, resteasy-jsonb]</strong></pre>
<p class="mce-root">Now, go to the landing page using the following URL: <kbd>http://localhost:8080</kbd>. Here, you will see a prefilled list of customers:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/9f32f679-dac7-4607-9dab-c25bbd7bb617.png" style=""/></div>
<p>Try adding some orders for customers by clicking on the <span class="packt_screen">Orders</span> button. You will be taken to the following UI, where you can read, modify, delete, and store new orders for each customer:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/e6e8ea23-d473-45dd-86f0-54f15ef572c9.png" style=""/></div>
<p>Great! The application works as expected. Can it be improved further? From a performance point of view, the throughput of the application could be improved if we cached data that is frequently accessed. The next section will show you how you can accomplish this using Hibernate ORM's caching mechanisms.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Caching entity data</h1>
                </header>
            
            <article>
                
<p>Caching entities can be easily configured in Hibernate ORM through its advanced caching mechanism. Three kinds of cache are available out of the box:</p>
<ul>
<li>The <strong>first-level cache</strong> is a transaction-level cache that's used to track the state of the entities during the current session. It's enabled by default.</li>
<li>The <strong>second-level cache</strong> is used to cache entities across various Hibernate ORM sessions. This makes it a <kbd>SessionFactory</kbd>-level cache.</li>
<li>The <strong>query cache</strong> is used to cache Hibernate ORM queries and their results.</li>
</ul>
<p>The second-level cache and query cache are not enabled by default due to the large amount of memory they could potentially consume. To make an entity eligible to cache its data, you can annotate it with the <kbd>@javax.persistence.Cacheable</kbd> annotation, as shown in the following code:</p>
<pre>@Cacheable<br/>@Entity<br/><span>public class </span>Customer {<br/><span><br/></span>}</pre>
<div class="paragraph">
<p>In this scenario, the customer's field values are cached, except for collections and relationships with other entities. This means that the entity, once cached, can be searched by its primary key without querying the database.</p>
</div>
<p>The results of HQL queries can also be cached. This can be quite useful when you want to execute queries for read-mostly entity objects. The simplest way to make an HQL query cacheable is to add a <kbd>@javax.persistence.QueryHint</kbd> annotation to <kbd>@NamedQuery</kbd>, with the <kbd>org.hibernate.cacheable</kbd> attribute set to <kbd>true</kbd>, as follows:</p>
<pre>@Cacheable<br/>@Entity<br/>@NamedQuery(name = <span>"Customers.findAll"</span><span>,<br/></span><span>        </span>query = <span>"SELECT c FROM Customer c ORDER BY c.id"</span><span>,<br/></span><span>        </span>hints = @QueryHint(name = <span>"org.hibernate.cacheable"</span><span>, </span>value = <br/>        <span>"true"</span>) )<br/><span>public class </span>Customer {   <span><br/></span>}</pre>
<p>You can easily verify the preceding assertion by turning on SQL logging in your <kbd>application.properties</kbd> file, as shown here:</p>
<pre><span>quarkus.hibernate-orm.log.sql</span><span>=</span><span>true</span><span><br/></span></pre>
<p>Then, if you run the application, you should be able to see a <strong>single</strong> SQL statement you can use to query the <kbd>Customer</kbd> list in the console, no matter how many times you have requested the page:</p>
<pre>Hibernate: <br/>    select<br/>        customer0_.id as id1_0_,<br/>        customer0_.name as name2_0_,<br/>        customer0_.surname as surname3_0_ <br/>    from</pre>
<pre>        Customer customer0_ <br/>    order by<br/>        customer0_.id</pre>
<p>Great! You have reached the first milestone, that is, running the application on your local filesystem and caching frequently used SQL statements in Hibernate ORM's <strong>second-level cache</strong> (<strong>2LC</strong>). Now, it's time to take our application to the cloud!</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Taking an application to the cloud</h1>
                </header>
            
            <article>
                
<p>Having tested the application through the local JVM, it's time to bring it natively into the cloud. The interesting part of this process will be connecting the Quarkus application with the PostgreSQL application on OpenShift without touching even one line of code! Let's look at how we can achieve this:</p>
<ol>
<li>Start your Minishift instance and create a new project named <kbd>quarkus-hibernate</kbd>:</li>
</ol>
<pre style="padding-left: 60px"><strong>oc new-project quarkus-hibernate</strong></pre>
<ol start="2">
<li>Next, we will be adding a PostgreSQL application to our project. A PostgreSQL image stream is included in the <kbd>openshift</kbd> namespace by default, which you can check with the following command:</li>
</ol>
<pre style="padding-left: 60px"><strong>oc get is -n openshift | grep postgresql</strong></pre>
<p>You should see the following output in your console:</p>
<pre style="padding-left: 60px"><strong>postgresql   172.30.1.1:5000/openshift/postgresql   latest,10,9.2 + 3 more...    6 hours ago</strong></pre>
<p>To create the PostgreSQL application, the following configuration variables need to be set:</p>
<ul>
<li><kbd>POSTGRESQL_USER</kbd>: Username for the PostgreSQL account to be created</li>
<li><kbd>POSTGRESQL_PASSWORD</kbd>: Password for the user account</li>
<li><kbd>POSTGRESQL_DATABASE</kbd>: Database name</li>
</ul>
<p>We will be using the same parameters we defined in the <kbd>application.properties</kbd> file so that we can bootstrap our application with the following command:</p>
<pre><strong>oc new-app -e POSTGRESQL_USER=quarkus -e POSTGRESQL_PASSWORD=quarkus -e POSTGRESQL_DATABASE=quarkusdb postgresql</strong></pre>
<p>In your console logs, check that the following output has been produced:</p>
<pre><strong>--&gt; Creating resources ...</strong><br/><strong>     imagestreamtag.image.openshift.io "postgresql:10" created</strong><br/><strong>     deploymentconfig.apps.openshift.io "postgresql" created</strong><br/><strong>     service "postgresql" created</strong><br/><strong> --&gt; Success</strong><br/><strong>     Application is not exposed. You can expose services to the <br/>    outside world by executing one or more of the commands below:</strong><br/><strong>      'oc expose svc/postgresql'</strong><br/><strong>     Run 'oc status' to view your app.</strong></pre>
<p>Let's take a look at the list of available services (<kbd>oc get services</kbd>) to verify whether <kbd>postgresql</kbd> is available:</p>
<pre>NAME                TYPE        CLUSTER-IP       EXTERNAL-IP   PORT(S)    AGE<br/>postgresql          ClusterIP   172.30.154.130   &lt;none&gt;        5432/TCP   14m</pre>
<p>As you can see, the service is now active at the cluster IP address <kbd>172.30.154.130</kbd>. Luckily, we don't need to hardcode this address in our application code since we will be using the service name, <kbd>postgresql</kbd>, which works like an alias of the cluster address.</p>
<p>Now, we will create a binary build of our project so that it can be deployed into Minishift. Impatient users can just execute the <kbd>deploy-openshift.sh</kbd> script, which is available on GitHub in the root folder of this chapter. Within it, you will find the following commented list of commands:</p>
<pre># Build native application<br/><strong>mvn package -Pnative -Dnative-image.docker-build=true -DskipTests=true</strong><br/><br/># Create a new Binary Build named "quarkus-hibernate"<br/><strong>oc new-build --binary --name=quarkus-hibernate -l app=quarkus-hibernate</strong><br/><br/># Set the dockerfilePath attribute into the Build Configuration<br/><strong>oc patch bc/quarkus-hibernate -p '{"spec":{"strategy":{"dockerStrategy":{"dockerfilePath":"src/main/docker/Dockerfile.native"}}}}'</strong><br/><br/># Start the build, uploading content from the local folder: <br/><strong>oc start-build quarkus-hibernate --from-dir=. --follow</strong><br/><br/># Create a new Application, using as Input the "quarkus-hibernate" image stream:<br/><strong>oc new-app --image-stream=quarkus-hibernate:latest</strong><br/><br/># Expose the Service through a Route:<br/><strong>oc expose svc/quarkus-hibernate</strong></pre>
<p>At the end of this process, you should be able to see the following route available through the <kbd>oc get routes</kbd> command:</p>
<pre><strong>NAME                HOST/PORT                                                  PATH      SERVICES            PORT       TERMINATION   WILDCARD</strong><br/><strong>quarkus-hibernate   quarkus-hibernate-quarkus-hibernate.192.168.42.30.nip.io             quarkus-hibernate   8080-tcp                 None</strong></pre>
<p>The overall status of the applications can be also checked from the web console of your project:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/0d455dab-3759-4c8c-b958-4b76759df252.png" style=""/></div>
<p>You can now navigate to the external route of the application (the actual route address will vary, depending on your network configuration. In our example, it's <span class="packt_screen">http://quarkus-hibernate-quarkus-hibernate.192.168.42.30.nip.io</span>) and check that the application works smoothly on the cloud.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Making data persistence easier using Panache API</h1>
                </header>
            
            <article>
                
<p>Hibernate ORM is the standard way to map database structures into Java objects. The main downside of using an ORM tool is that even a simple database structure requires lots of boilerplate code (such as getter and setters methods). Also, you have to include basic query methods in your repository classes, which makes the work quite repetitive. In this section, we will learn how to use Hibernate Panache to simplify and accelerate the development of our applications.</p>
<p>To get started with Hibernate ORM with Panache, let's check the second example for this chapter, which is located in the <kbd>Chapter05/hibernate-panache</kbd> folder in this book's GitHub repository. We recommend importing the project into your IDE before you move on.</p>
<p>If you take a look at the project's configuration, you will see that we have included <kbd>quarkus-hibernate-orm-panache</kbd> in the <kbd>pom.xml</kbd> file:</p>
<pre>&lt;dependency&gt;<br/>       &lt;groupId&gt;io.quarkus&lt;/groupId&gt;<br/>       &lt;artifactId&gt;quarkus-hibernate-orm-panache&lt;/artifactId&gt;<br/>&lt;/dependency&gt;</pre>
<p>This is the only configuration that we need to use Hibernate Panache. Now comes the funny part. There are two strategies for plugging Panache into your entity:</p>
<ul>
<li>Extending the <kbd>io.quarkus.hibernate.orm.panache.PanacheEntity</kbd> class: This is the simplest option as you will get an ID field that is auto-generated.</li>
<li>Extending <kbd>io.quarkus.hibernate.orm.panache.PanacheEntityBase</kbd>: This option can be used if you require a custom ID strategy.</li>
</ul>
<p>Since we are using a <kbd>SequenceGenerator</kbd> strategy for our ID field, we will use the latter option. Following is the <kbd>Customer</kbd> class, which has been rewritten so that it extends <kbd>PanacheEntityBase</kbd>:</p>
<pre>@Entity<br/>@NamedQuery(name = "Customers.findAll",<br/>         query = "SELECT c FROM Customer c ORDER BY c.id" )<br/>public class Customer extends PanacheEntityBase {<br/>     @Id<br/>     @SequenceGenerator(<br/>             name = "customerSequence",<br/>             sequenceName = "customerId_seq",<br/>             allocationSize = 1,<br/>             initialValue = 1)<br/>     @GeneratedValue(strategy = GenerationType.SEQUENCE, generator = <br/>      "customerSequence")<br/>     public Long id;<br/> <br/>     @Column(length = 40)<br/>     public String name;<br/><br/>     @Column(length = 40)<br/>     public String surname;<br/><br/>     @OneToMany(mappedBy = "customer")<br/>     @JsonbTransient<br/>     public List&lt;Orders&gt; orders;<br/>}</pre>
<p>As you can see, the code has been reduced quite a lot as we haven't used a getter/setter field. Instead, some fields have been exposed as <kbd>public</kbd> so that they can be accessed directly by the classes. The <kbd>Orders</kbd> entity has been rewritten using the same pattern:</p>
<pre>@Entity<br/>@NamedQuery(name = "Orders.findAll",<br/>         query = "SELECT o FROM Orders o WHERE o.customer.id = :id ORDER BY o.item")<br/>public class Orders extends PanacheEntityBase {<br/>     @Id<br/>     @SequenceGenerator(<br/>             name = "orderSequence",<br/>             sequenceName = "orderId_seq",<br/>             allocationSize = 1,<br/>             initialValue = 1)<br/>     @GeneratedValue(strategy = GenerationType.SEQUENCE, generator = <br/>      "orderSequence")<br/>     public Long id;<br/> <br/>     @Column(length = 40)<br/>     public String item;<br/> <br/>     @Column<br/>     public Long price;<br/> <br/>     @ManyToOne<br/>     @JoinColumn(name = "customer_id")<br/>     @JsonbTransient<br/>     public Customer customer;<br/> <br/>}</pre>
<p>So far, we have seen some of the benefits that are provided by Hibernate Panache. Another aspect worth mentioning is that by extending <kbd>PanacheEntityBase</kbd> (or <kbd>PanacheEntity</kbd>), you will be able to use a set of static methods directly on your entity. Following is a table containing the most common methods you can trigger on your entity:</p>
<table border="1" style="border-collapse: collapse;width: 100%">
<tbody>
<tr style="height: 10px">
<td style="height: 10px;width: 25.1059%"><strong>Method</strong></td>
<td style="height: 10px;width: 71.8941%"><strong>Description</strong></td>
</tr>
<tr style="height: 10px">
<td style="height: 10px;width: 25.1059%"><kbd>count</kbd></td>
<td style="height: 10px;width: 71.8941%">Counts this entity from the database (with an optional query and parameters)</td>
</tr>
<tr style="height: 10px">
<td style="height: 10px;width: 25.1059%"><kbd>delete</kbd></td>
<td style="height: 10px;width: 71.8941%">Delete this entity from the database if it has already been persisted.</td>
</tr>
<tr style="height: 10px">
<td style="height: 10px;width: 25.1059%"><kbd>flush</kbd></td>
<td style="height: 10px;width: 71.8941%">Flushes all pending changes to the database</td>
</tr>
<tr style="height: 10px">
<td style="height: 10px;width: 25.1059%"><kbd>findById</kbd></td>
<td style="height: 10px;width: 71.8941%">Finds an entity of this type by ID</td>
</tr>
<tr style="height: 10px">
<td style="height: 10px;width: 25.1059%"><kbd>find</kbd></td>
<td style="height: 10px;width: 71.8941%">Finds entities using a query with optional parameters and a sort strategy</td>
</tr>
<tr style="height: 10px">
<td style="height: 10px;width: 25.1059%"><kbd>findAll</kbd></td>
<td style="height: 10px;width: 71.8941%">Finds all the entities of this type</td>
</tr>
<tr style="height: 10px">
<td style="height: 10px;width: 25.1059%"><kbd>list</kbd></td>
<td style="height: 10px;width: 71.8941%">Shortcut for <kbd>find().list()</kbd></td>
</tr>
<tr style="height: 10px">
<td style="height: 10px;width: 25.1059%"><kbd>listAll</kbd></td>
<td style="height: 10px;width: 71.8941%">Shortcut for <kbd>findAll().list()</kbd></td>
</tr>
<tr style="height: 10px">
<td style="height: 10px;width: 25.1059%"><kbd>deleteAll</kbd></td>
<td style="height: 10px;width: 71.8941%">Deletes all the entities of this type</td>
</tr>
<tr style="height: 10px">
<td style="height: 10px;width: 25.1059%"><kbd>delete</kbd></td>
<td style="height: 10px;width: 71.8941%">Deletes entities using a query with optional parameters</td>
</tr>
<tr style="height: 10px">
<td style="height: 10px;width: 25.1059%"><kbd>persist</kbd></td>
<td style="height: 10px;width: 71.8941%">Persists all given entities</td>
</tr>
</tbody>
</table>
<p> </p>
<p>The following shows the <kbd>CustomerRepository</kbd> class, which leverages the new field and methods that are available in the <kbd>Customer</kbd> entity:</p>
<pre>public class CustomerRepository {<br/> <br/>     public List&lt;Customer&gt; findAll() {<br/>         return Customer.listAll(Sort.by("id"));<br/>     }<br/> <br/>     public Customer findCustomerById(Long id) {<br/>         Customer customer = Customer.findById(id);<br/> <br/>         if (customer == null) {<br/>             throw new WebApplicationException("Customer with id <br/>              of " +  id + " does not exist.", 404);<br/>         }<br/>         return customer;<br/>     }<br/>     @Transactional<br/>     public void updateCustomer(Customer customer) {<br/>         Customer customerToUpdate = findCustomerById(customer.id);<br/>         customerToUpdate.name = customer.name;<br/>         customerToUpdate.surname = customer.surname;<br/>     }<br/>     @Transactional<br/>     public void createCustomer(Customer customer) {<br/>         customer.persist();<br/>     }<br/>     @Transactional<br/>     public void deleteCustomer(Long customerId) {<br/>         Customer customer = findCustomerById(customerId);<br/>         customer.delete();<br/>     }<br/> }</pre>
<p>The most obvious advantage is that you don't need <kbd>EntityManager</kbd> as a proxy to manage your entity class anymore. Instead, you can directly invoke static methods that are available in your entity, thus dramatically reducing the verbosity of your <kbd>Repository</kbd> class.</p>
<p>For the sake of completeness, let's have a look at the <kbd>OrderRepository</kbd> class, which has been adapted to use Panache objects as well:</p>
<pre>public class OrderRepository {<br/> <br/>     public List&lt;Orders&gt; findAll(Long customerId) {<br/>         return Orders.list("id", customerId);<br/>     }<br/> <br/>     public Orders findOrderById(Long id) {<br/>         Orders order = Orders.findById(id);<br/>         if (order == null) {<br/>             throw new WebApplicationException("Order with id of<br/>             " + id  + " does not exist.", 404);<br/>         }<br/>         return order;<br/>     }<br/>     @Transactional<br/>     public void updateOrder(Orders order) {<br/>         Orders orderToUpdate = findOrderById(order.id);<br/>         orderToUpdate.item = order.item;<br/>         orderToUpdate.price = order.price;<br/>     }<br/>     @Transactional<br/>     public void createOrder(Orders order, Customer c) {<br/>         order.customer = c;<br/>         order.persist();<br/>     }<br/>     @Transactional<br/>     public void deleteOrder(Long orderId) {<br/>         Orders order = findOrderById(orderId);<br/>         order.delete();<br/>     }<br/> }</pre>
<p>Nothing else has been changed in your application since switching to Hibernate Panache is completely transparent for our REST endpoint and the web interfaces. Build and run the application as usual with the following command:</p>
<pre><strong>mvn compile quarkus:dev</strong></pre>
<p>On the console, you should see that the application has started and the two initial customers have been added:</p>
<pre>Hibernate: <br/>    INSERT INTO customer (id, name, surname) VALUES ( nextval('customerId_seq'), 'John','Doe')<br/>Hibernate: <br/>    INSERT INTO customer (id, name, surname) VALUES ( nextval('customerId_seq'), 'Fred','Smith')<br/>2019-11-28 10:44:02,887 INFO  [io.quarkus] (main) Quarkus 1.0.0.Final started in 2.278s. Listening on: http://[::]:8080<br/>2019-11-28 10:44:02,888 INFO  [io.quarkus] (main) Installed features: [agroal, cdi, hibernate-orm, jdbc-postgresql, narayana-jta, resteasy, resteasy-jsonb]</pre>
<p>Now, enjoy your simplified CRUD application powered by Hibernate ORM with Panache!</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>In this chapter, we looked at data persistence and covered the well-known Hibernate ORM framework. If you have some years' Enterprise programming under your belt, you shouldn't have found it challenging to apply the same concepts to Quarkus. Now, your overall skills include configuring an RDBMS-based application using Hibernate and its simplified paradigm called Panache. We have also learned how to deploy and connect both RDBMS and our application on the cloud on an OpenShift cluster.</p>
<p>To summarize, we have mastered the major pillars of Enterprise programming (moving from REST services to servlets, CDI, and data persistence).</p>
<p>In the next chapter, we'll learn how we can complement the standard Enterprise API with the MicroProfile API in Quarkus. </p>


            </article>

            
        </section>
    </body></html>