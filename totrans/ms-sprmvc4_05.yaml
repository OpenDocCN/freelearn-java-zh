- en: Chapter 5. Crafting a RESTful Application
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第5章. 构建RESTful应用程序
- en: In this chapter, we will have a look at the main principles of a RESTful architecture.
    Then, with the help of very handy tools, we will design a friendly API, leveraging
    Jackson's capabilities to serialize our model in JSON.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨RESTful架构的主要原则。然后，借助非常实用的工具，我们将设计一个友好的API，利用Jackson的能力将我们的模型序列化为JSON。
- en: We will document our application with the appropriate error codes and HTTP verbs
    and automatically generate a neat frontend for our application by using Swagger
    UI.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用适当的错误代码和HTTP动词来记录我们的应用程序，并通过使用Swagger UI自动生成我们应用程序的整洁前端。
- en: Finally, we will look at the other forms of serialization and learn more about
    the content negotiation mechanism of Spring MVC.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将探讨其他形式的序列化，并更多地了解Spring MVC的内容协商机制。
- en: What is REST?
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是REST？
- en: '**REST** (**Representational State Transfer**) is an architectural style that
    defines best practices for creating scalable web services leveraging the capabilities
    of the HTTP protocol.'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: '**REST**（**表征状态转移**）是一种架构风格，它定义了利用HTTP协议功能创建可扩展Web服务的最佳实践。'
- en: 'A RESTful web service should naturally exhibit the following properties:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 一个RESTful Web服务应该自然表现出以下属性：
- en: '**Client-server**: The UI is separated from data storage'
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**客户端-服务器**：用户界面与数据存储分离'
- en: '**Stateless**: Each request contains enough information for the server to operate
    without maintaining any state'
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**无状态**：每个请求都包含足够的信息，使服务器能够在不维护任何状态的情况下操作'
- en: '**Cacheable**: The server''s responses contain enough information to allow
    the clients to make sensible decisions about data storage'
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可缓存**：服务器的响应包含足够的信息，使客户端能够就数据存储做出合理的决策'
- en: '**Uniform interface**: URIs uniquely identify resources and hyperlinks allow
    the API to be discovered'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**统一接口**：URI唯一标识资源，超链接允许API被发现'
- en: '**Layered**: Each resource of the API provides a sensible level of detail'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**分层**：API中的每个资源都提供合理的详细程度'
- en: The advantage of such an architecture is that it is simple to maintain and easy
    to discover. It also scales well because there is no need to maintain a persistent
    connection between the server and the client, which eliminates the need for load
    balancing or sticky sessions. Finally, the service is more efficient because the
    information is neatly laid out and easy to cache.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 这种架构的优势在于它易于维护和发现。它也具有良好的可扩展性，因为不需要在服务器和客户端之间维护持久连接，这消除了负载均衡或粘性会话的需求。最后，服务效率更高，因为信息布局整齐，易于缓存。
- en: Let's see how we can design better APIs incrementally by using Richardson's
    maturity model.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何通过使用理查森成熟度模型逐步设计更好的API。
- en: Richardson's maturity model
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理查森成熟度模型
- en: Leonard Richardson is famous for having defined four levels, ranked from 0 to
    3, that describe the level of "RESTfulness" of a web API. Each level requires
    additional work and investment in the API but also provides additional benefits.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 伦纳德·理查森因定义了四个级别而闻名，这些级别按0到3的顺序排列，描述了Web API的“RESTfulness”程度。每个级别都需要对API进行额外的工作和投资，但也提供了额外的收益。
- en: Level 0 – HTTP
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第0级 – HTTP
- en: Level 0 is really easy to reach; you just have to make your resource available
    on a network through the HTTP protocol. You can use any data representation you
    find best suited for your use case (XML, JSON, and so on).
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 第0级非常容易达到；你只需通过HTTP协议在网络中将你的资源可用。你可以使用最适合你用例的数据表示（XML、JSON等）。
- en: Level 1 – Resources
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第1级 – 资源
- en: 'Most people think of resources when they hear the term REST. A resource is
    a unique identifier for an element of our model, a user or a tweet, for instance.
    With HTTP, a resource is obviously associated with a unified resource identifier
    URI, as shown in this example:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 当人们听到REST这个术语时，大多数人会想到资源。资源是我们模型中元素的唯一标识符，例如用户或推文。使用HTTP时，资源显然与统一资源标识符URI相关联，如本例所示：
- en: '`/users` contains the list of all our users'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/users` 包含我们所有用户的列表'
- en: '`/user/42` contains a specific user'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/user/42` 包含一个特定的用户'
- en: '`/user/42/tweets` contains the list of all the tweets associated to this particular
    user'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/user/42/tweets` 包含与该特定用户关联的所有推文的列表'
- en: Maybe your API could allow access to a particular tweet related to a user with
    `/user/42/tweet/3` or maybe each tweet is uniquely identified, in which case you
    might prefer `/tweet/3`.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 也许你的API可以通过`/user/42/tweet/3`允许访问与用户相关的特定推文，或者也许每个推文都是唯一的，在这种情况下，你可能更喜欢`/tweet/3`。
- en: The goal of this level is to deal with the complexity of an application by exposing
    multiple specialized resources.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 此级别的目标是通过对多个专用资源进行暴露来处理应用程序的复杂性。
- en: There is no rule regarding the type of response that your server can return.
    You might want to include only scarce information when you list all the resources
    with `/users` and give more details when a specific resource is requested. Some
    APIs even let you list the fields you are interested in before serving them to
    you.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 关于服务器可以返回的响应类型没有规则。当您使用`/users`列出所有资源时，可能只想包含少量信息，而在请求特定资源时提供更多细节。一些API甚至允许您在提供之前列出感兴趣的字段。
- en: 'It really is up to you to define the form of your API, keeping one simple rule
    in mind: the principle of least astonishment. Give your users what they expect
    and your API will already be in good shape.'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，您需要根据一个简单的规则来定义您的API的形式：最小惊讶原则。提供用户期望的内容，您的API就已经处于良好状态。
- en: Level 2 – HTTP verbs
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第2级 – HTTP动词
- en: This level is about using the HTTP verbs to identify possible actions on the
    resources. This is a very good way to describe what can be done with your API
    since the HTTP verbs are a well-known standard among developers.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 此级别是关于使用HTTP动词来识别对资源的可能操作。这是描述您可以使用API做什么的一个非常好的方法，因为HTTP动词在开发者中是一个众所周知的标准。
- en: 'The main verbs are listed here:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 主要动词列表如下：
- en: '`GET`: This reads data on a particular URI.'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GET`：此操作读取特定URI上的数据。'
- en: '`HEAD`: This does the same as `GET` without the response body. This is useful
    for getting metadata on a resource (cache information and so on).'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`HEAD`：此操作与`GET`相同，但没有响应体。这对于获取资源的元数据（缓存信息等）很有用。'
- en: '`DELETE`: This deletes a resource.'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DELETE`：此操作用于删除资源。'
- en: '`PUT`: This updates or creates a resource.'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PUT`：此操作用于更新或创建资源。'
- en: '`POST`: This updates or creates a resource.'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`POST`：此操作用于更新或创建资源。'
- en: '`PATCH`: This partially updates a resource.'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PATCH`：此操作用于部分更新资源。'
- en: '`OPTIONS`: This returns the list of methods that the server supports on a particular
    resource.'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`OPTIONS`：此操作返回服务器在特定资源上支持的方法列表。'
- en: 'Most applications that allow **Create Read Update Delete** (**CRUD**) operations
    get by with only three verbs: `GET`, `DELETE`, and `POST`. The more verbs you
    implement, the richer and more semantic your API becomes. It helps third parties
    to interact with your service by allowing them to type a few commands and see
    what happens.'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数允许**创建、读取、更新、删除**（**CRUD**）操作的应用程序仅使用三个动词：`GET`、`DELETE`和`POST`。您实现的动词越多，您的API就越丰富、语义越强。这有助于第三方通过允许他们输入几个命令并查看结果来与您的服务交互。
- en: The `OPTIONS` and `HEAD` verbs are rarely seen because they work on the metadata
    level and are typically not vital to any application.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '`OPTIONS`和`HEAD`操作很少见，因为它们在元数据级别工作，通常对任何应用程序都不是至关重要的。'
- en: At first sight, the `PUT` and `POST` verbs appear to do the same thing. The
    main difference is that the `PUT` verb is said to be idempotent, which means that
    sending the same request multiple times should result in the same server state.
    The implication of that rule is essentially that the `PUT` verb should operate
    on a given URI and contain enough information for the request to succeed.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 初看之下，`PUT`和`POST`操作似乎做的是同一件事。主要区别在于，`PUT`操作被认为是幂等的，这意味着发送相同的请求多次应该导致服务器状态相同。该规则的含义基本上是`PUT`操作应该在给定的URI上操作，并包含足够的信息以确保请求成功。
- en: For instance, a client can use `PUT` data on `/user/42`, and the result will
    be either an update or a creation, depending on whether the entity existed prior
    to the request.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，客户端可以使用`PUT`数据在`/user/42`上，结果将取决于实体在请求之前是否存在，要么是更新要么是创建。
- en: On the other hand, `POST` should be used when you don't exactly know what URI
    you should write to. You could send `POST` to `/users` without specifying an ID
    in the request and expect the user to be created. You could also send `POST` to
    the same `/users` resource, this time specifying a user ID inside the request
    entity and expect the server to update the corresponding user.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，当您不确定应该写入哪个URI时，应使用`POST`。您可以在不指定请求ID的情况下将`POST`发送到`/users`，并期望创建用户。您也可以将`POST`发送到相同的`/users`资源，这次在请求实体中指定用户ID，并期望服务器更新相应的用户。
- en: As you can see, both of these options work. One frequent use case is to use
    `POST` for creation (because, most of the time, the server should be in charge
    of the IDs) and to use `PUT` to update a resource whose ID is already known.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，这两种方法都有效。一个常见的用例是使用`POST`进行创建（因为，大多数情况下，服务器应该负责ID），并使用`PUT`来更新已知ID的资源。
- en: The server might also allow a resource to be modified partially (without the
    client sending the full contents of the resource). It should respond to the `PATCH`
    method in that case.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器也可能允许部分修改资源（而不需要客户端发送资源的全部内容）。在这种情况下，它应该对`PATCH`方法做出响应。
- en: At this level, I also encourage you to use meaningful HTTP codes when providing
    responses. We will see the most common codes in a moment.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个层面上，我也鼓励你在提供响应时使用有意义的HTTP状态码。我们将在稍后看到最常见的状态码。
- en: Level 3 – Hypermedia controls
  id: totrans-45
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第3级 – 超媒体控制
- en: 'Hypermedia controls are also known as **Hypertext As The Engine Of Application
    State** (**HATEOAS**). Behind this barbarous acronym lies the most important property
    of a RESTful service: making it discoverable through the use of hypertext links.
    This is essentially the server telling the client what its options are, using
    the response headers or the response entity.'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 超媒体控制也被称为**应用状态引擎的超文本**（**HATEOAS**）。在这可怕的缩写背后是RESTful服务最重要的属性：通过使用超文本链接使其可发现。这本质上就是服务器告诉客户端它的选项，使用响应头或响应实体。
- en: For instance, after the creation of a resource with `PUT`, the server should
    return a response with the code `201 CREATED` and send a `Location` header containing
    the URI of the created resource.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在创建资源后使用`PUT`，服务器应该返回一个包含代码`201 CREATED`的响应，并发送一个包含创建资源URI的`Location`头。
- en: 'There is no standard that defines how the link to the other parts of the API
    should look. Spring Data REST, a Spring project that allows you to create a RESTful
    backend with minimal configuration, typically outputs this:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 没有标准定义链接到API其他部分的链接应该是什么样子。Spring Data REST，这是一个允许你通过最小配置创建RESTful后端的Spring项目，通常输出如下：
- en: '[PRE0]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Then, go to `/users`:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，转到`/users`：
- en: '[PRE1]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This gives you a good idea of what you can do with the API, doesn't it?
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 这让你对可以使用API做什么有了很好的了解，不是吗？
- en: API versioning
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: API版本控制
- en: If third-party clients use your API, you could consider versioning your API
    to avoid breaking changes when you update your application.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 如果第三方客户端使用你的API，你可以在更新应用程序时考虑对API进行版本控制，以避免破坏性更改。
- en: Versioning an API is often a matter of making a set of stable resources available
    under subdomains. For instance, GitLab maintains three versions of its API. They
    are accessible under `https://example/api/v3`, and so on. Like a lot of architectural
    decisions in software, versioning is a tradeoff.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 对API进行版本控制通常是一个在子域名下提供一组稳定资源的问题。例如，GitLab维护其API的三个版本。它们可以通过`https://example/api/v3`等访问。像软件中的许多架构决策一样，版本控制是一个权衡。
- en: It will require more work to design such an API and identify breaking changes
    in the API. Often, the addition of new fields will not be as problematic as removing
    or transforming the API entity results or requests.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 设计这样的API并识别API中的破坏性更改需要更多的工作。通常，添加新字段不会像删除或转换API实体结果或请求那样有问题。
- en: Most of the time, you will be in charge of both the API and the client, thereby
    removing the need for such sophistication.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数情况下，你将负责API和客户端，从而消除了这种复杂性的需要。
- en: Note
  id: totrans-58
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'See this blog post for a more in-depth discussion about API versioning:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 请参阅这篇博客文章，了解更多关于API版本控制的深入讨论：
- en: '[http://www.troyhunt.com/2014/02/your-api-versioning-is-wrong-which-is.html](http://www.troyhunt.com/2014/02/your-api-versioning-is-wrong-which-is.html)'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://www.troyhunt.com/2014/02/your-api-versioning-is-wrong-which-is.html](http://www.troyhunt.com/2014/02/your-api-versioning-is-wrong-which-is.html)'
- en: Useful HTTP codes
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 有用的HTTP状态码
- en: 'Another important aspect of a good RESTful API is to use HTTP codes in a sensible
    way. The HTTP specification defines a lot of standard codes. They should cover
    99 percent of what a good API needs to communicate to its users. The following
    list contains the most important codes, the ones every API should use and every
    developer should know:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 一个好的RESTful API的另一个重要方面是合理地使用HTTP状态码。HTTP规范定义了许多标准状态码。它们应该覆盖API需要与用户通信的99%。以下列表包含了最重要的状态码，每个API都应该使用，每个开发者都应该了解：
- en: '| Code | Meaning | Usage |'
  id: totrans-63
  prefs: []
  type: TYPE_TB
  zh: '| 状态码 | 含义 | 用途 |'
- en: '| --- | --- | --- |'
  id: totrans-64
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| **2xx - Success** | **These codes are used when everything goes well.** |
      |'
  id: totrans-65
  prefs: []
  type: TYPE_TB
  zh: '| **2xx - 成功** | **这些状态码在一切顺利时使用。** |   |'
- en: '| `200` | Everything is okay. | The request succeeded. |'
  id: totrans-66
  prefs: []
  type: TYPE_TB
  zh: '| `200` | 一切正常 | 请求成功。|'
- en: '| `201` | A resource has been created. | The successful creation of a resource.
    The response should include a list of locations associated with the creation.
    |'
  id: totrans-67
  prefs: []
  type: TYPE_TB
  zh: '| `201` | 资源已创建 | 资源成功创建。响应应包括与创建相关联的位置列表。|'
- en: '| `204` | There is no content to return. | The server has successfully handled
    the request but there is no content to return. |'
  id: totrans-68
  prefs: []
  type: TYPE_TB
  zh: '| `204` | 没有内容可返回 | 服务器已成功处理请求，但没有内容可返回。|'
- en: '| **3xx - Redirection** | **These codes are used when further action is needed
    on the client to fulfill the request**. |   |'
  id: totrans-69
  prefs: []
  type: TYPE_TB
  zh: '| **3xx - 重定向** | **这些代码用于需要客户端进一步操作以完成请求的情况**。|'
- en: '| `301` | Moved permanently | The resource has a changed URI and its new location
    is indicated in the `Location` header. |'
  id: totrans-70
  prefs: []
  type: TYPE_TB
  zh: '| `301` | 永久移动 | 资源有一个更改的 URI，其新位置在 `Location` 标头中指示。|'
- en: '| `304` | The resource has not been modified. | The resource has not changed
    since the last time. This response must include the date, ETag, and cache information.
    |'
  id: totrans-71
  prefs: []
  type: TYPE_TB
  zh: '| `304` | 资源未修改 | 自上次修改以来，资源没有变化。此响应必须包含日期、ETag 和缓存信息。|'
- en: '| **4xx - Client error** | **The request was not successfully performed because
    of a mistake made by the client**. |   |'
  id: totrans-72
  prefs: []
  type: TYPE_TB
  zh: '| **4xx - 客户端错误** | **请求未成功执行是因为客户端的错误**。|'
- en: '| `400` | Bad request | The data sent by the client could not be understood.
    |'
  id: totrans-73
  prefs: []
  type: TYPE_TB
  zh: '| `400` | 错误请求 | 客户端发送的数据无法理解。|'
- en: '| `403` | Forbidden | The request was understood but not allowed. This can
    be enriched with information describing the error. |'
  id: totrans-74
  prefs: []
  type: TYPE_TB
  zh: '| `403` | 禁止 | 请求已理解但未允许。可以添加描述错误的信息。|'
- en: '| `404` | Not found | Nothing matches this URI. This can be used instead of
    403 if information about security shouldn''t be disclosed. |'
  id: totrans-75
  prefs: []
  type: TYPE_TB
  zh: '| `404` | 未找到 | 没有匹配此 URI 的内容。如果不应公开安全信息，则可以使用 403。|'
- en: '| `409` | Conflict | The request conflicts with another modification. The response
    should include information on how to resolve the conflict. |'
  id: totrans-76
  prefs: []
  type: TYPE_TB
  zh: '| `409` | 冲突 | 请求与另一个修改冲突。响应应包括解决冲突的信息。|'
- en: '| **5xx - Server error** | **An error occurred on the server side**. |   |'
  id: totrans-77
  prefs: []
  type: TYPE_TB
  zh: '| **5xx - 服务器错误** | **服务器端发生错误**。|'
- en: '| `500` | An internal server error | The server unexpectedly failed to process
    the request. |'
  id: totrans-78
  prefs: []
  type: TYPE_TB
  zh: '| `500` | 内部服务器错误 | 服务器意外失败处理请求。|'
- en: Note
  id: totrans-79
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: For a more detailed list, see [http://www.restapitutorial.com/httpstatuscodes.html](http://www.restapitutorial.com/httpstatuscodes.html).
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 更详细的信息列表，请参阅 [http://www.restapitutorial.com/httpstatuscodes.html](http://www.restapitutorial.com/httpstatuscodes.html)。
- en: Client is the king
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 客户端是王
- en: We will allow third-party clients to retrieve the search results via a REST
    API. These results will be available either in JSON or XML.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将允许第三方客户端通过 REST API 获取搜索结果。这些结果将以 JSON 或 XML 格式提供。
- en: We want to handle requests of the `/api/search/mixed;keywords=springFramework`
    form. This is really similar to the search form we already made, except that the
    request path begins with `api`. Every URI found in this namespace should return
    binary results.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望处理形如 `/api/search/mixed;keywords=springFramework` 的请求。这实际上与我们已制作的搜索表单非常相似，只是请求路径以
    `api` 开头。在这个命名空间中找到的每个 URI 都应返回二进制结果。
- en: 'Let''s create a new `SearchApiController` class in the `search.api` package:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在 `search.api` 包中创建一个新的 `SearchApiController` 类：
- en: '[PRE2]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'This is quite similar to our previous controller, with three subtle differences:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 这与我们的前一个控制器非常相似，但有三个细微的区别：
- en: The controller class is annotated with a `@RequestMapping` annotation. This
    will be our base address and will prefix every other mapping declared in this
    controller.
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 控制器类使用 `@RequestMapping` 注解。这将是我们的基础地址，并将作为此控制器中声明的其他每个映射的前缀。
- en: We no longer redirect to a view but return a plain object in the search method.
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们不再将请求重定向到视图，而是在搜索方法中返回一个纯对象。
- en: The controller is annotated with `@RestController` instead of `@Controller`.
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 控制器使用 `@RestController` 注解而不是 `@Controller`。
- en: The `RestController` is a shortcut to declare controllers that will return each
    response as if it were annotated with the `@ResponseBody` annotation. It tells
    Spring to serialize the return type to the appropriate format, which is JSON by
    default.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '`RestController` 是声明将每个响应作为如果它被 `@ResponseBody` 注解一样处理的快捷方式。它告诉 Spring 将返回类型序列化为适当的格式，默认为
    JSON。'
- en: When working with a REST API, a good practice is to always specify the method
    you will respond to. It's rather unlikely that a request can be handled the same
    way for a `GET` or a `POST` method.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 当与 REST API 一起工作时，一个好的做法是始终指定您将响应的方法。一个请求以相同的方式处理 `GET` 或 `POST` 方法的情况相当不可能。
- en: 'If you go to `http://localhost:8080/api/search/mixed;keywords=springFramework`,
    you should get a really large result, as follows:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您访问 `http://localhost:8080/api/search/mixed;keywords=springFramework`，您应该会得到一个非常大的结果，如下所示：
- en: '![Client is the king](img/2117_5_1.jpg)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
  zh: '![客户端为王](img/2117_5_1.jpg)'
- en: Indeed, Spring handled the serialization of the whole `Tweet` class' attributes
    automatically, using Jackson.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，Spring 使用 Jackson 自动处理了整个 `Tweet` 类的所有属性的序列化。
- en: Debugging a RESTful API
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调试 RESTful API
- en: With your browser, you will only be able to perform `GET` requests on a specific
    API. The good tools will make your developments much simpler. There are lots of
    tools to test a RESTful API. I will just list the one I use and love.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 使用您的浏览器，您只能在特定的 API 上执行 `GET` 请求。好的工具将使您的开发变得更加简单。有很多工具可以测试 RESTful API。我只会列出我使用并喜爱的工具。
- en: A JSON formatting extension
  id: totrans-97
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: JSON 格式化扩展
- en: Often, you will just test the `GET` method and your first reflex will be to
    copy the address into your browser to check the result. In that case, you have
    the possibility to get more than plain text with extensions such as JSON Formatter
    for Chrome or JSONView for Firefox.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，您只会测试 `GET` 方法，您的第一个反应可能是将地址复制到浏览器中检查结果。在这种情况下，您可以使用像 Chrome 的 JSON Formatter
    或 Firefox 的 JSONView 这样的扩展程序来获取更多内容，而不仅仅是纯文本。
- en: A RESTful client in your browser
  id: totrans-99
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 浏览器中的 RESTful 客户端
- en: The browser is the natural tool for dealing with HTTP requests. However, using
    the address bar will rarely allow you to test your API in detail.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 浏览器是处理 HTTP 请求的自然工具。然而，使用地址栏很少允许您详细测试您的 API。
- en: Postman is an extension for Chrome, and RESTClient is its Firefox counterpart.
    They both have similar features, such as creating and sharing collections of queries,
    modification of the headers, and handling authentication (basic, digest, and OAuth).
    At the time of writing, only RESTClient handles OAuth2.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: Postman 是 Chrome 的扩展程序，RESTClient 是其 Firefox 的对应程序。它们都具有类似的功能，例如创建和共享查询集合、修改头部信息以及处理身份验证（基本、摘要和
    OAuth）。在撰写本文时，只有 RESTClient 支持 OAuth2。
- en: httpie
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: httpie
- en: '**httpie** is a command line utility à la curl but oriented towards REST querying.
    It allows you to type commands such as this:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '**httpie** 是一个类似于 curl 的命令行工具，但面向 REST 查询。它允许您输入如下命令：'
- en: '[PRE3]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'It''s a lot friendlier than this ugly version:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 它比这个丑陋的版本友好得多：
- en: '[PRE4]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Customizing the JSON output
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自定义 JSON 输出
- en: Using our tools we are able to easily see the request generated by our server.
    It is huge. By default, Jackson, the JSON serialization library used by Spring
    Boot, will serialize everything that is accessible with a getter method.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 使用我们的工具，我们可以轻松地看到服务器生成的请求。它非常庞大。默认情况下，Spring Boot 使用的 JSON 序列化库 Jackson 将使用
    getter 方法可访问的所有内容进行序列化。
- en: 'We would like something lighter, such as this:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望有一种更轻量级的方法，例如：
- en: '[PRE5]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The easiest way to customize which fields will be serialized is by adding annotations
    to our beans. You can either use the `@JsonIgnoreProperties` annotation at the
    class level to ignore a set of properties or add `@JsonIgnore` on the getters
    of the properties you wish to ignore.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 通过向我们的 bean 添加注解，可以最轻松地自定义哪些字段将被序列化。您可以在类级别使用 `@JsonIgnoreProperties` 注解来忽略一组属性，或者在对希望忽略的属性的
    getter 上添加 `@JsonIgnore`。
- en: In our case, the `Tweet` class is not one of our own. It is part of Spring Social
    Twitter, and we do not have the ability to annotate it.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的案例中，`Tweet` 类不是我们自己的。它是 Spring Social Twitter 的一部分，我们没有能力对其进行注解。
- en: Using the model classes directly for serialization is rarely a good option.
    It would tie your model to your serialization library, which should remain an
    implementation detail.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 直接使用模型类进行序列化很少是一个好选择。这会将您的模型绑定到您的序列化库，而序列化库应该保持为实现细节。
- en: 'When dealing with unmodifiable code, Jackson provides two options:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 当处理不可修改的代码时，Jackson 提供了两种选项：
- en: Creating a new class dedicated to serialization.
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个专门用于序列化的新类。
- en: Using mixins, which are simple classes that will be linked to your model. These
    will be declared in your code and can be annotated with any Jackson annotation.
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用混合类，这些是简单的类，将被链接到您的模型。这些将在您的代码中声明，并可以使用任何 Jackson 注解进行注解。
- en: Since we only need to perform some simple transformation on the fields of our
    model (a lot of hiding and a little renaming), we could opt for the mixins.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们只需要对我们的模型字段执行一些简单的转换（很多隐藏和一点重命名），我们可以选择使用混入。
- en: It's a good, non-invasive way to rename and exclude fields on the fly with a
    simple class or interface.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个很好的、非侵入性的方法，可以通过简单的类或接口即时重命名和排除字段。
- en: Another option to specify subsets of fields used in different parts of the application
    is to annotate them with the `@JsonView` annotation. This won't be covered in
    this chapter, but I encourage you to check out this excellent blog post [https://spring.io/blog/2014/12/02/latest-jackson-integration-improvements-in-spring](
    https://spring.io/blog/2014/12/02/latest-jackson-integration-improvements-in-spring).
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个指定应用程序不同部分使用的字段子集的选项是使用 `@JsonView` 注解来注释它们。这在本章中不会涉及，但我鼓励你查看这篇优秀的博客文章 [https://spring.io/blog/2014/12/02/latest-jackson-integration-improvements-in-spring](https://spring.io/blog/2014/12/02/latest-jackson-integration-improvements-in-spring)。
- en: 'We want to be in control of the output of our APIs, so let''s just create a
    new class called `LightTweet` that can be constructed from a tweet:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望控制我们 API 的输出，所以让我们创建一个新的类叫做 `LightTweet`，它可以由一条推文构建：
- en: '[PRE6]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'We now need to make our `SearchService` class return the `LightTweets` class
    instead of tweets:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要让我们的 `SearchService` 类返回 `LightTweets` 类而不是推文：
- en: '[PRE7]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This will impact the return type of the `SearchApiController` class as well
    as the tweets model attribute in the `SearchController` class. Make the necessary
    modification in those two classes.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 这将影响 `SearchApiController` 类的返回类型以及 `SearchController` 类中的 tweets 模型属性。在这两个类中做出必要的修改。
- en: 'We also need to change the code of the `resultPage.html` file because some
    properties changed (we no longer have a nested `user` property):'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要更改 `resultPage.html` 文件的代码，因为一些属性已经改变（我们不再有嵌套的 `user` 属性）：
- en: '[PRE8]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'We''re almost done. If you restart your application and go to `http://localhost:8080/api/search/mixed;keywords=springFramework`,
    you''ll see that the date format is not the one we expected:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 我们几乎完成了。如果你重新启动你的应用程序并转到 `http://localhost:8080/api/search/mixed;keywords=springFramework`，你会看到日期格式不是我们预期的：
- en: '![Customizing the JSON output](img/2117_05_02.jpg)'
  id: totrans-128
  prefs: []
  type: TYPE_IMG
  zh: '![自定义 JSON 输出](img/2117_05_02.jpg)'
- en: 'That''s because Jackson doesn''t have built-in support for JSR-310 dates. Luckily,
    this is easy to fix. Simply add the following library to the dependencies in the
    `build.gradle` file:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为 Jackson 没有内置对 JSR-310 日期的支持。幸运的是，这很容易修复。只需将以下库添加到 `build.gradle` 文件的依赖项中即可：
- en: '[PRE9]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This indeed changes the date format, but it now outputs an array instead of
    a formatted date.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 这确实改变了日期格式，但现在它输出的是一个数组而不是格式化的日期。
- en: To change that, we need to understand what the library did. It includes a new
    Jackson module called JSR-310 Module. A Jackson module is an extension point to
    customize serialization and deserialization. This one will automatically be registered
    by Spring Boot at startup in the `JacksonAutoConfiguration` class, which will
    create a default Jackson `ObjectMapper` method with support for well-known modules.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 要改变这一点，我们需要了解库做了什么。它包括一个名为 JSR-310 模块的新的 Jackson 模块。Jackson 模块是一个扩展点，用于自定义序列化和反序列化。这个模块将在启动时自动由
    Spring Boot 在 `JacksonAutoConfiguration` 类中注册，这将创建一个默认的 Jackson `ObjectMapper`
    方法，支持已知的模块。
- en: We can see that the former module adds a bunch of serializers and deserializers
    for all the new classes defined in JSR-310\. This will try to convert every date
    to an ISO format, whenever possible. See [https://github.com/FasterXML/jackson-datatype-jsr310](https://github.com/FasterXML/jackson-datatype-jsr310).
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，前一个模块为 JSR-310 中定义的所有新类添加了一堆序列化和反序列化器。这将尽可能尝试将每个日期转换为 ISO 格式。请参阅 [https://github.com/FasterXML/jackson-datatype-jsr310](https://github.com/FasterXML/jackson-datatype-jsr310)。
- en: If we take a closer look at `LocalDateTimeSerializer`, for instance, we can
    see that it actually has two modes and can switch between the two with a serialization
    feature called `WRITE_DATES_AS_TIMESTAMPS`.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果我们仔细看看 `LocalDateTimeSerializer`，我们可以看到它实际上有两种模式，并且可以通过一个名为 `WRITE_DATES_AS_TIMESTAMPS`
    的序列化功能在这两种模式之间切换。
- en: 'To define this property, we need to customize Spring''s default object mapper.
    As we can gather from looking at the auto configuration, Spring MVC provides a
    utility class to create the `ObjectMapper` method that we can use. Add the following
    bean to your `WebConfiguration` class:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 要定义这个属性，我们需要自定义 Spring 的默认对象映射器。正如我们可以从自动配置中看到的那样，Spring MVC 提供了一个实用类来创建我们可以使用的
    `ObjectMapper` 方法。将以下 bean 添加到你的 `WebConfiguration` 类中：
- en: '[PRE10]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'This time, we are done and the dates are properly formatted, as you can see
    here:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，我们已经完成了，日期格式正确，如你所见：
- en: '![Customizing the JSON output](img/2117_05_03.jpg)'
  id: totrans-138
  prefs: []
  type: TYPE_IMG
  zh: '![自定义JSON输出](img/2117_05_03.jpg)'
- en: A user management API
  id: totrans-139
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 用户管理API
- en: 'Our search API is quite good, but let''s do something more interesting. Like
    a lot of web applications, we will need a user management module to identify our
    users. For that, we will create a new `user` package. In this package, we will
    add a model class as follows:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的网络搜索API相当不错，但让我们做一些更有趣的事情。像许多网络应用程序一样，我们需要一个用户管理模块来识别我们的用户。为此，我们将创建一个新的`user`包。在这个包中，我们将添加一个如下所示的模式类：
- en: '[PRE11]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Since we do not want to use a database just yet, we will create a `UserRepository`
    class in the same package, backed by a simple `Map`:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们目前不想使用数据库，我们将在同一包中创建一个`UserRepository`类，它由一个简单的`Map`支持：
- en: '[PRE12]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Finally, in the `user.api` package, we will create a very naive controller
    implementation:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在`user.api`包中，我们将创建一个非常简单的控制器实现：
- en: '[PRE13]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: We implemented all the classic CRUD operations with a RESTful repository by
    using the user's e-mail address as a unique identifier.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过使用用户的电子邮件地址作为唯一标识符，使用RESTful仓库实现了所有经典的CRUD操作。
- en: In this scenario, you will quickly face problems as Spring strips contents found
    after a dot. The solution is very similar to what we use to support semicolons
    in URLs in the URL mapping with matrix variables section in [Chapter 4](ch04.html
    "Chapter 4. File Upload and Error Handling"), *File Upload and Error Handling*.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，你将很快遇到问题，因为Spring会删除点号后面的内容。解决方案与我们在[第4章](ch04.html "第4章。文件上传和错误处理")中使用的类似，即在URL映射的矩阵变量部分支持分号。
- en: 'Add the `useRegisteredSuffixPatternMatch` property that is set to false in
    the `configurePathMatch()` method that we have already defined in the `WebConfiguration`
    class:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们已经在`WebConfiguration`类中定义的`configurePathMatch()`方法中添加`useRegisteredSuffixPatternMatch`属性，并将其设置为false：
- en: '[PRE14]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Now that we've got our API, we can start interacting with it.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经有了我们的API，我们可以开始与之交互。
- en: 'Here are a few sample commands with httpie:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一些使用httpie的示例命令：
- en: '[PRE15]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This is good but not great. Status codes are not yet handled. We will need more
    RESTfulness to climb up the Richardson ladder.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 这很好，但还不够出色。状态码尚未处理。我们需要更多的RESTful来攀登理查森的阶梯。
- en: Status codes and exception handling
  id: totrans-154
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 状态码和异常处理
- en: 'The first thing we want to do is to correctly handle response statuses. By
    default, Spring automatically deals with some statuses:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先想做的事情是正确处理响应状态。默认情况下，Spring自动处理一些状态：
- en: '`500 Server Error`: This indicates that an exception occurred while handling
    the request.'
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`500 服务器错误`：这表示在处理请求时发生了异常。'
- en: '`405 Method not Supported`: This comes up when you use an incorrect method
    on an existing handler.'
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`405 方法不支持`：当你在一个现有的处理程序上使用不正确的方法时出现。'
- en: '`404 Not Found`: This comes up when the handler does not exist.'
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`404 未找到`：当处理程序不存在时出现。'
- en: '`400 Bad Request`: This indicates that the request body or parameter does not
    match the server''s expectation.'
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`400 错误请求`：这表示请求体或参数与服务器的期望不匹配。'
- en: '`200 OK`: It is thrown for any request handled without an error.'
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`200 正常`：对于没有错误处理的任何请求都会抛出。'
- en: 'With Spring MVC, there are two ways to return status codes:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Spring MVC，有两种方式来返回状态码：
- en: Returning a `ResponseEntity` class from a REST controller
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从REST控制器返回`ResponseEntity`类
- en: Throwing an exception that will be caught in dedicated handlers
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 抛出一个将在专用处理程序中被捕获的异常
- en: Status code with ResponseEntity
  id: totrans-164
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 带有ResponseEntity的状态码
- en: The HTTP protocol specifies that we should return a `201 Created` status when
    we create a new user. With our API, this can happen with a `POST` method. We also
    need to throw some 404 errors on operation while working on an entity that does
    not exist.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP协议指定，在创建新用户时，我们应该返回一个`201 已创建`状态。在我们的API中，这可以通过`POST`方法实现。我们还需要在操作实体不存在时抛出一些404错误。
- en: 'Spring MVC has a class that associates an HTTP status with a response entity.
    It is called `ResponseEntity`. Let''s update our `UserApiController` class to
    handle error codes:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: Spring MVC有一个类将HTTP状态与响应实体关联。它被称为`ResponseEntity`。让我们更新我们的`UserApiController`类来处理错误代码：
- en: '[PRE16]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: You can see that we evolve towards the first level of RESTfulness but there
    is a lot of boilerplate code involved.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到我们正在向RESTful的第一级进化，但其中涉及了很多样板代码。
- en: Status codes with exceptions
  id: totrans-169
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 带有异常的状态码
- en: 'Another way to handle errors in our API is to throw exceptions. There are two
    ways to map exceptions with Spring MVC:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的 API 中处理错误的另一种方式是抛出异常。使用 Spring MVC 映射异常有两种方式：
- en: Using `@ExceptionHandler` at the class level, like we did for `IOException`
    in our upload controller in [Chapter 4](ch04.html "Chapter 4. File Upload and
    Error Handling"), *File Upload and Error Handling*
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在类级别使用 `@ExceptionHandler`，就像我们在第四章中为 `IOException` 在上传控制器中做的那样，[第四章：文件上传和错误处理](ch04.html
    "第四章：文件上传和错误处理")
- en: Using `@ControllerAdvice` to catch global exceptions thrown by all controllers
    or a subset of your controllers
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `@ControllerAdvice` 来捕获所有控制器或控制器子集抛出的全局异常
- en: These two options help you make some business-oriented decisions and define
    a set of practices within your application.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个选项帮助你做出一些面向业务的决定，并在你的应用程序中定义一系列实践。
- en: To associate these handlers with HTTP status codes, we can either inject the
    response in the annotated method and use the `HttpServletResponse.sendError()`
    method or just annotate the method with the `@ResponseStatus` annotation.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将这些处理器与 HTTP 状态码关联起来，我们可以在注解方法中注入响应并使用 `HttpServletResponse.sendError()` 方法，或者只是注解方法为
    `@ResponseStatus` 注解。
- en: We will define our own exception, `EntityNotFoundException`. Our business repositories
    will throw this exception when the entity the user is working on cannot be found.
    This will help relieve the API code.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将定义自己的异常，`EntityNotFoundException`。我们的业务仓库在用户正在工作的实体找不到时将抛出这个异常。这将有助于减轻 API
    代码的负担。
- en: 'Here is the code for the exception. We can put it in a new package called `error`:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是异常的代码。我们可以将它放在一个名为 `error` 的新包中：
- en: '[PRE17]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Our repository will now throw exceptions in various locations. We will also
    differentiate between saving and updating a user:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的数据仓库现在将在多个位置抛出异常。我们还将区分保存和更新用户：
- en: '[PRE18]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Our controller becomes simpler since it doesn''t have to handle the 404 status.
    We now throw the `EntityNotFound` exception from our controller methods:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们的控制器不需要处理 404 状态，它变得更加简单。我们现在从我们的控制器方法中抛出 `EntityNotFound` 异常：
- en: '[PRE19]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'If we don''t handle this exception, Spring will throw a 500 error by default.
    To handle it we will create a small class in the error package, right next to
    our `EntityNotFoundException` class. It will be called `EntityNotFoundMapper`
    class and will be in charge of handling the exception:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们不处理这个异常，Spring 默认会抛出一个 500 错误。为了处理它，我们将在错误包中创建一个小的类，紧挨着我们的 `EntityNotFoundException`
    类。它将被命名为 `EntityNotFoundMapper` 类，并负责处理这个异常：
- en: '[PRE20]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The `@ControllerAdvice` annotation allows us to add some behaviors to a set
    of controllers by annotating a bean. Those controller advice can handle exceptions
    but also declare model attributes with `@ModelAttribute` or validator policies
    with `@InitBinder`.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '`@ControllerAdvice` 注解允许我们通过注解一个 Bean 来向一组控制器添加一些行为。这些控制器建议可以处理异常，也可以使用 `@ModelAttribute`
    声明模型属性或使用 `@InitBinder` 声明验证策略。'
- en: With the code we just wrote, we handle all the `EntityNotFoundException` class
    thrown by our controllers in one place and associate it with the 404 status. That
    way, we can abstract this notion and ensure that our application will handle it
    consistently in all controllers.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 通过我们刚刚编写的代码，我们在一个地方处理了由我们的控制器抛出的所有 `EntityNotFoundException` 类，并将其与 404 状态关联起来。这样，我们可以抽象这个概念，并确保我们的应用程序在所有控制器中一致地处理它。
- en: We are not going to deal with hyperlinks in our API at our level. Instead, I
    encourage you to have a look at Spring HATEOAS and Spring Data REST, which provide
    very elegant solutions to make your resources more discoverable.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的级别，我们不会处理 API 中的超链接。相反，我鼓励你查看 Spring HATEOAS 和 Spring Data REST，它们提供了非常优雅的解决方案，使你的资源更容易被发现。
- en: Documentation with Swagger
  id: totrans-187
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Swagger 进行文档化
- en: 'Swagger is a really awesome project that will allow you to document and interact
    with your API within an HTML5 webpage. The following screenshot illustrates the
    API documentation:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: Swagger 是一个非常棒的项目，它允许你在 HTML5 网页内对 API 进行文档化和交互。以下截图展示了 API 文档：
- en: '![Documentation with Swagger](img/2117_05_04.jpg)'
  id: totrans-189
  prefs: []
  type: TYPE_IMG
  zh: '![使用 Swagger 进行文档化](img/2117_05_04.jpg)'
- en: Swagger used to be big (written in Scala) and somewhat complicated to configure
    with a Spring setup. Since version 2.0, the library has been rewritten and a really
    neat project called `spring-fox` will allow for easy integration.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: Swagger 以前很大（用 Scala 编写）并且与 Spring 配置相对复杂。从 2.0 版本开始，库已经被重写，一个名为 `spring-fox`
    的非常棒的项目将允许轻松集成。
- en: Note
  id: totrans-191
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '`spring-fox`, formerly known as `swagger-springmvc`, has been in existence
    for more than three years and is still a very active project.'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '`spring-fox`，之前被称为`swagger-springmvc`，已经存在了三年多，并且仍然是一个非常活跃的项目。'
- en: 'Add the following dependencies to your build file:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下依赖项添加到您的构建文件中：
- en: '[PRE21]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The first one will provide an annotation to enable Swagger in your application
    as well as an API to describe your resources with annotations. Swagger will then
    generate a JSON representation of your API.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个将提供一个注释来启用您的应用程序中的Swagger，以及一个API，使用注释来描述您的资源。然后Swagger将生成API的JSON表示。
- en: The second is a WebJar that contains static resources consuming the generated
    JSON through a web client.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个是一个WebJar，它包含通过Web客户端消耗生成的JSON的静态资源。
- en: 'The only thing you need to do now is add the `@EnableSwagger2` annotation to
    your `WebConfiguration` class:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您需要做的唯一一件事是将`@EnableSwagger2`注释添加到您的`WebConfiguration`类中：
- en: '[PRE22]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The `swagger-ui.jar` file we just added contains an HTML file in `META-INF/resources`.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚添加的`swagger-ui.jar`文件包含一个位于`META-INF/resources`的HTML文件。
- en: It will automatically be served by Spring Boot when you go to `http://localhost:8080/swagger-ui.html`.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 当您访问`http://localhost:8080/swagger-ui.html`时，它将自动由Spring Boot提供服务。
- en: By default, Springfox will scan your whole classpath and show all the request
    mappings declared in your application.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，Springfox将扫描您的整个类路径，并显示您应用程序中声明的所有请求映射。
- en: 'In our case, we only want to expose the API:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的案例中，我们只想公开API：
- en: '[PRE23]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Springfox works with groups of `Docket`s that you have to define as beans in
    your configuration classes. They are logical grouping for RESTful resources. An
    application can have many of them.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: Springfox与一组`Docket`s协同工作，您需要在配置类中将它们定义为bean。它们是RESTful资源的逻辑分组。一个应用程序可以有多个这样的分组。
- en: Have a look at the documentation ([http://springfox.github.io/springfox](http://springfox.github.io/springfox))
    to see all the different setups available.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 查看文档([http://springfox.github.io/springfox](http://springfox.github.io/springfox))以了解所有可用的不同设置。
- en: Generating XML
  id: totrans-206
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 生成XML
- en: RESTful APIs sometimes return responses in different media types (JSON, XML,
    and so on). The mechanism responsible for choosing the correct media type is known
    as content negotiation in Spring.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: RESTful API有时会以不同的媒体类型（JSON、XML等）返回响应。负责选择正确媒体类型的机制称为Spring中的内容协商。
- en: By default, in Spring MVC, the `ContentNegotiatingViewResolver` bean will be
    in charge of resolving the correct content according to the content negotiation
    policies defined in your application.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，在Spring MVC中，`ContentNegotiatingViewResolver` bean将负责根据您应用程序中定义的内容协商策略解析正确的内容。
- en: You can have a look at `ContentNegotiationManagerFactoryBean` to see how these
    policies are applied within Spring MVC.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以查看`ContentNegotiationManagerFactoryBean`以了解这些策略如何在Spring MVC中应用。
- en: 'Content type can be resolved with the following strategies:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 内容类型可以通过以下策略解决：
- en: According to the `Accept` header sent by the client
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 根据客户端发送的`Accept`头
- en: With a parameter such as `?format=json`
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用参数例如`?format=json`
- en: With a path extension such as `/myResource.json` or `/myResource.xml`
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用路径扩展名，例如`/myResource.json`或`/myResource.xml`
- en: You can customize these strategies in your Spring configuration by overriding
    the `configureContentNegotiation()` method of the `WebMvcConfigurerAdapter` class.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过覆盖`WebMvcConfigurerAdapter`类的`configureContentNegotiation()`方法来自定义Spring配置中的这些策略。
- en: By default, Spring will use the `Accept` header and the path extension.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，Spring将使用`Accept`头和路径扩展名。
- en: 'To enable XML serialization with Spring Boot, you can add the following dependency
    to your classpath:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 要启用Spring Boot的XML序列化，您可以将以下依赖项添加到类路径中：
- en: '[PRE24]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'If you explore your API with your browser and go to `http://localhost:8080/api/users`,
    you will see the result as XML, as follows:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您使用浏览器探索API并访问`http://localhost:8080/api/users`，您将看到以下结果作为XML：
- en: '![Generating XML](img/2117_05_05.jpg)'
  id: totrans-219
  prefs: []
  type: TYPE_IMG
  zh: '![生成XML](img/2117_05_05.jpg)'
- en: 'That''s because your browser doesn''t usually request JSON, but XML is second
    after HTML. This is shown in the following screenshot:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为您的浏览器通常不会请求JSON，但XML是HTML之后的第二选择。这在上面的屏幕截图中有显示：
- en: '![Generating XML](img/2117_05_06.jpg)'
  id: totrans-221
  prefs: []
  type: TYPE_IMG
  zh: '![生成XML](img/2117_05_06.jpg)'
- en: To get JSON back, you can either go to `http://localhost:8080/api/users.json`
    or send the appropriate `Accept` header with Postman or httpie.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取JSON，您可以访问`http://localhost:8080/api/users.json`，或者使用Postman或httpie发送适当的`Accept`头。
- en: The check point
  id: totrans-223
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检查点
- en: In this chapter, we added a search `ApiController` class. Because the tweets
    returned by the Twitter API were not adapted to our usage, we introduced a `LightTweet`
    class to transform them into a friendlier format.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们添加了一个搜索`ApiController`类。因为Twitter API返回的推文没有适应我们的使用，我们引入了一个`LightTweet`类来将它们转换成更友好的格式。
- en: We also developed a user API. The `User` class is the model. The users are stored
    and retrieved via the `UserRepository` class, and the `UserApiController` class
    exposes HTTP endpoints to perform CRUD operations on the users. We also added
    a generic exception and a mapper to associate the exception to an HTTP status.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还开发了一个用户API。`User`类是模型。用户通过`UserRepository`类存储和检索，`UserApiController`类公开HTTP端点以对用户执行CRUD操作。我们还添加了一个通用的异常和一个映射器，将异常关联到HTTP状态。
- en: 'In the configuration, we added a bean that documents our API, thanks to Swagger,
    and we customized the serialization of our JSR-310 dates. Our code base should
    look like the following:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 在配置中，我们添加了一个由Swagger文档化的bean，并自定义了我们的JSR-310日期的序列化。我们的代码库应该看起来像以下这样：
- en: '![The check point](img/2117_05_07.jpg)'
  id: totrans-227
  prefs: []
  type: TYPE_IMG
  zh: '![检查点](img/2117_05_07.jpg)'
- en: Summary
  id: totrans-228
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we have seen how to create a RESTful API with Spring MVC. This
    kind of backend yields great benefits in terms of performance and maintenance
    and can do wonders when coupled with a JavaScript MVC framework such as Backbone,
    Angular JS, or React.js.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们看到了如何使用Spring MVC创建RESTful API。这种后端在性能和维护方面提供了巨大的好处，并且当与Backbone、Angular
    JS或React.js等JavaScript MVC框架结合使用时，可以产生神奇的效果。
- en: We saw how to handle errors and exceptions properly and learned how to leverage
    the HTTP status to make a better API.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到了如何正确处理错误和异常，并学习了如何利用HTTP状态来制作更好的API。
- en: Finally we added automatic documentation with Swagger and added the ability
    to produce both XML and JSON.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们添加了自动文档（Swagger），并增加了生成XML和JSON的能力。
- en: In the next chapter, we will learn how to secure our application as well as
    use the Twitter API to sign our users up.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习如何确保我们的应用程序的安全，以及如何使用Twitter API来注册我们的用户。
