- en: Chapter 5. Crafting a RESTful Application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will have a look at the main principles of a RESTful architecture.
    Then, with the help of very handy tools, we will design a friendly API, leveraging
    Jackson's capabilities to serialize our model in JSON.
  prefs: []
  type: TYPE_NORMAL
- en: We will document our application with the appropriate error codes and HTTP verbs
    and automatically generate a neat frontend for our application by using Swagger
    UI.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we will look at the other forms of serialization and learn more about
    the content negotiation mechanism of Spring MVC.
  prefs: []
  type: TYPE_NORMAL
- en: What is REST?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**REST** (**Representational State Transfer**) is an architectural style that
    defines best practices for creating scalable web services leveraging the capabilities
    of the HTTP protocol.'
  prefs: []
  type: TYPE_NORMAL
- en: 'A RESTful web service should naturally exhibit the following properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Client-server**: The UI is separated from data storage'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Stateless**: Each request contains enough information for the server to operate
    without maintaining any state'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Cacheable**: The server''s responses contain enough information to allow
    the clients to make sensible decisions about data storage'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Uniform interface**: URIs uniquely identify resources and hyperlinks allow
    the API to be discovered'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Layered**: Each resource of the API provides a sensible level of detail'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The advantage of such an architecture is that it is simple to maintain and easy
    to discover. It also scales well because there is no need to maintain a persistent
    connection between the server and the client, which eliminates the need for load
    balancing or sticky sessions. Finally, the service is more efficient because the
    information is neatly laid out and easy to cache.
  prefs: []
  type: TYPE_NORMAL
- en: Let's see how we can design better APIs incrementally by using Richardson's
    maturity model.
  prefs: []
  type: TYPE_NORMAL
- en: Richardson's maturity model
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Leonard Richardson is famous for having defined four levels, ranked from 0 to
    3, that describe the level of "RESTfulness" of a web API. Each level requires
    additional work and investment in the API but also provides additional benefits.
  prefs: []
  type: TYPE_NORMAL
- en: Level 0 – HTTP
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Level 0 is really easy to reach; you just have to make your resource available
    on a network through the HTTP protocol. You can use any data representation you
    find best suited for your use case (XML, JSON, and so on).
  prefs: []
  type: TYPE_NORMAL
- en: Level 1 – Resources
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Most people think of resources when they hear the term REST. A resource is
    a unique identifier for an element of our model, a user or a tweet, for instance.
    With HTTP, a resource is obviously associated with a unified resource identifier
    URI, as shown in this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '`/users` contains the list of all our users'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/user/42` contains a specific user'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/user/42/tweets` contains the list of all the tweets associated to this particular
    user'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Maybe your API could allow access to a particular tweet related to a user with
    `/user/42/tweet/3` or maybe each tweet is uniquely identified, in which case you
    might prefer `/tweet/3`.
  prefs: []
  type: TYPE_NORMAL
- en: The goal of this level is to deal with the complexity of an application by exposing
    multiple specialized resources.
  prefs: []
  type: TYPE_NORMAL
- en: There is no rule regarding the type of response that your server can return.
    You might want to include only scarce information when you list all the resources
    with `/users` and give more details when a specific resource is requested. Some
    APIs even let you list the fields you are interested in before serving them to
    you.
  prefs: []
  type: TYPE_NORMAL
- en: 'It really is up to you to define the form of your API, keeping one simple rule
    in mind: the principle of least astonishment. Give your users what they expect
    and your API will already be in good shape.'
  prefs: []
  type: TYPE_NORMAL
- en: Level 2 – HTTP verbs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This level is about using the HTTP verbs to identify possible actions on the
    resources. This is a very good way to describe what can be done with your API
    since the HTTP verbs are a well-known standard among developers.
  prefs: []
  type: TYPE_NORMAL
- en: 'The main verbs are listed here:'
  prefs: []
  type: TYPE_NORMAL
- en: '`GET`: This reads data on a particular URI.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`HEAD`: This does the same as `GET` without the response body. This is useful
    for getting metadata on a resource (cache information and so on).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`DELETE`: This deletes a resource.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PUT`: This updates or creates a resource.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`POST`: This updates or creates a resource.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PATCH`: This partially updates a resource.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`OPTIONS`: This returns the list of methods that the server supports on a particular
    resource.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Most applications that allow **Create Read Update Delete** (**CRUD**) operations
    get by with only three verbs: `GET`, `DELETE`, and `POST`. The more verbs you
    implement, the richer and more semantic your API becomes. It helps third parties
    to interact with your service by allowing them to type a few commands and see
    what happens.'
  prefs: []
  type: TYPE_NORMAL
- en: The `OPTIONS` and `HEAD` verbs are rarely seen because they work on the metadata
    level and are typically not vital to any application.
  prefs: []
  type: TYPE_NORMAL
- en: At first sight, the `PUT` and `POST` verbs appear to do the same thing. The
    main difference is that the `PUT` verb is said to be idempotent, which means that
    sending the same request multiple times should result in the same server state.
    The implication of that rule is essentially that the `PUT` verb should operate
    on a given URI and contain enough information for the request to succeed.
  prefs: []
  type: TYPE_NORMAL
- en: For instance, a client can use `PUT` data on `/user/42`, and the result will
    be either an update or a creation, depending on whether the entity existed prior
    to the request.
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, `POST` should be used when you don't exactly know what URI
    you should write to. You could send `POST` to `/users` without specifying an ID
    in the request and expect the user to be created. You could also send `POST` to
    the same `/users` resource, this time specifying a user ID inside the request
    entity and expect the server to update the corresponding user.
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, both of these options work. One frequent use case is to use
    `POST` for creation (because, most of the time, the server should be in charge
    of the IDs) and to use `PUT` to update a resource whose ID is already known.
  prefs: []
  type: TYPE_NORMAL
- en: The server might also allow a resource to be modified partially (without the
    client sending the full contents of the resource). It should respond to the `PATCH`
    method in that case.
  prefs: []
  type: TYPE_NORMAL
- en: At this level, I also encourage you to use meaningful HTTP codes when providing
    responses. We will see the most common codes in a moment.
  prefs: []
  type: TYPE_NORMAL
- en: Level 3 – Hypermedia controls
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Hypermedia controls are also known as **Hypertext As The Engine Of Application
    State** (**HATEOAS**). Behind this barbarous acronym lies the most important property
    of a RESTful service: making it discoverable through the use of hypertext links.
    This is essentially the server telling the client what its options are, using
    the response headers or the response entity.'
  prefs: []
  type: TYPE_NORMAL
- en: For instance, after the creation of a resource with `PUT`, the server should
    return a response with the code `201 CREATED` and send a `Location` header containing
    the URI of the created resource.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is no standard that defines how the link to the other parts of the API
    should look. Spring Data REST, a Spring project that allows you to create a RESTful
    backend with minimal configuration, typically outputs this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, go to `/users`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: This gives you a good idea of what you can do with the API, doesn't it?
  prefs: []
  type: TYPE_NORMAL
- en: API versioning
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If third-party clients use your API, you could consider versioning your API
    to avoid breaking changes when you update your application.
  prefs: []
  type: TYPE_NORMAL
- en: Versioning an API is often a matter of making a set of stable resources available
    under subdomains. For instance, GitLab maintains three versions of its API. They
    are accessible under `https://example/api/v3`, and so on. Like a lot of architectural
    decisions in software, versioning is a tradeoff.
  prefs: []
  type: TYPE_NORMAL
- en: It will require more work to design such an API and identify breaking changes
    in the API. Often, the addition of new fields will not be as problematic as removing
    or transforming the API entity results or requests.
  prefs: []
  type: TYPE_NORMAL
- en: Most of the time, you will be in charge of both the API and the client, thereby
    removing the need for such sophistication.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'See this blog post for a more in-depth discussion about API versioning:'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://www.troyhunt.com/2014/02/your-api-versioning-is-wrong-which-is.html](http://www.troyhunt.com/2014/02/your-api-versioning-is-wrong-which-is.html)'
  prefs: []
  type: TYPE_NORMAL
- en: Useful HTTP codes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Another important aspect of a good RESTful API is to use HTTP codes in a sensible
    way. The HTTP specification defines a lot of standard codes. They should cover
    99 percent of what a good API needs to communicate to its users. The following
    list contains the most important codes, the ones every API should use and every
    developer should know:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Code | Meaning | Usage |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| **2xx - Success** | **These codes are used when everything goes well.** |
      |'
  prefs: []
  type: TYPE_TB
- en: '| `200` | Everything is okay. | The request succeeded. |'
  prefs: []
  type: TYPE_TB
- en: '| `201` | A resource has been created. | The successful creation of a resource.
    The response should include a list of locations associated with the creation.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `204` | There is no content to return. | The server has successfully handled
    the request but there is no content to return. |'
  prefs: []
  type: TYPE_TB
- en: '| **3xx - Redirection** | **These codes are used when further action is needed
    on the client to fulfill the request**. |   |'
  prefs: []
  type: TYPE_TB
- en: '| `301` | Moved permanently | The resource has a changed URI and its new location
    is indicated in the `Location` header. |'
  prefs: []
  type: TYPE_TB
- en: '| `304` | The resource has not been modified. | The resource has not changed
    since the last time. This response must include the date, ETag, and cache information.
    |'
  prefs: []
  type: TYPE_TB
- en: '| **4xx - Client error** | **The request was not successfully performed because
    of a mistake made by the client**. |   |'
  prefs: []
  type: TYPE_TB
- en: '| `400` | Bad request | The data sent by the client could not be understood.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `403` | Forbidden | The request was understood but not allowed. This can
    be enriched with information describing the error. |'
  prefs: []
  type: TYPE_TB
- en: '| `404` | Not found | Nothing matches this URI. This can be used instead of
    403 if information about security shouldn''t be disclosed. |'
  prefs: []
  type: TYPE_TB
- en: '| `409` | Conflict | The request conflicts with another modification. The response
    should include information on how to resolve the conflict. |'
  prefs: []
  type: TYPE_TB
- en: '| **5xx - Server error** | **An error occurred on the server side**. |   |'
  prefs: []
  type: TYPE_TB
- en: '| `500` | An internal server error | The server unexpectedly failed to process
    the request. |'
  prefs: []
  type: TYPE_TB
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For a more detailed list, see [http://www.restapitutorial.com/httpstatuscodes.html](http://www.restapitutorial.com/httpstatuscodes.html).
  prefs: []
  type: TYPE_NORMAL
- en: Client is the king
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will allow third-party clients to retrieve the search results via a REST
    API. These results will be available either in JSON or XML.
  prefs: []
  type: TYPE_NORMAL
- en: We want to handle requests of the `/api/search/mixed;keywords=springFramework`
    form. This is really similar to the search form we already made, except that the
    request path begins with `api`. Every URI found in this namespace should return
    binary results.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create a new `SearchApiController` class in the `search.api` package:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'This is quite similar to our previous controller, with three subtle differences:'
  prefs: []
  type: TYPE_NORMAL
- en: The controller class is annotated with a `@RequestMapping` annotation. This
    will be our base address and will prefix every other mapping declared in this
    controller.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We no longer redirect to a view but return a plain object in the search method.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The controller is annotated with `@RestController` instead of `@Controller`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `RestController` is a shortcut to declare controllers that will return each
    response as if it were annotated with the `@ResponseBody` annotation. It tells
    Spring to serialize the return type to the appropriate format, which is JSON by
    default.
  prefs: []
  type: TYPE_NORMAL
- en: When working with a REST API, a good practice is to always specify the method
    you will respond to. It's rather unlikely that a request can be handled the same
    way for a `GET` or a `POST` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you go to `http://localhost:8080/api/search/mixed;keywords=springFramework`,
    you should get a really large result, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Client is the king](img/2117_5_1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Indeed, Spring handled the serialization of the whole `Tweet` class' attributes
    automatically, using Jackson.
  prefs: []
  type: TYPE_NORMAL
- en: Debugging a RESTful API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With your browser, you will only be able to perform `GET` requests on a specific
    API. The good tools will make your developments much simpler. There are lots of
    tools to test a RESTful API. I will just list the one I use and love.
  prefs: []
  type: TYPE_NORMAL
- en: A JSON formatting extension
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Often, you will just test the `GET` method and your first reflex will be to
    copy the address into your browser to check the result. In that case, you have
    the possibility to get more than plain text with extensions such as JSON Formatter
    for Chrome or JSONView for Firefox.
  prefs: []
  type: TYPE_NORMAL
- en: A RESTful client in your browser
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The browser is the natural tool for dealing with HTTP requests. However, using
    the address bar will rarely allow you to test your API in detail.
  prefs: []
  type: TYPE_NORMAL
- en: Postman is an extension for Chrome, and RESTClient is its Firefox counterpart.
    They both have similar features, such as creating and sharing collections of queries,
    modification of the headers, and handling authentication (basic, digest, and OAuth).
    At the time of writing, only RESTClient handles OAuth2.
  prefs: []
  type: TYPE_NORMAL
- en: httpie
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**httpie** is a command line utility à la curl but oriented towards REST querying.
    It allows you to type commands such as this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'It''s a lot friendlier than this ugly version:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Customizing the JSON output
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Using our tools we are able to easily see the request generated by our server.
    It is huge. By default, Jackson, the JSON serialization library used by Spring
    Boot, will serialize everything that is accessible with a getter method.
  prefs: []
  type: TYPE_NORMAL
- en: 'We would like something lighter, such as this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The easiest way to customize which fields will be serialized is by adding annotations
    to our beans. You can either use the `@JsonIgnoreProperties` annotation at the
    class level to ignore a set of properties or add `@JsonIgnore` on the getters
    of the properties you wish to ignore.
  prefs: []
  type: TYPE_NORMAL
- en: In our case, the `Tweet` class is not one of our own. It is part of Spring Social
    Twitter, and we do not have the ability to annotate it.
  prefs: []
  type: TYPE_NORMAL
- en: Using the model classes directly for serialization is rarely a good option.
    It would tie your model to your serialization library, which should remain an
    implementation detail.
  prefs: []
  type: TYPE_NORMAL
- en: 'When dealing with unmodifiable code, Jackson provides two options:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating a new class dedicated to serialization.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using mixins, which are simple classes that will be linked to your model. These
    will be declared in your code and can be annotated with any Jackson annotation.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Since we only need to perform some simple transformation on the fields of our
    model (a lot of hiding and a little renaming), we could opt for the mixins.
  prefs: []
  type: TYPE_NORMAL
- en: It's a good, non-invasive way to rename and exclude fields on the fly with a
    simple class or interface.
  prefs: []
  type: TYPE_NORMAL
- en: Another option to specify subsets of fields used in different parts of the application
    is to annotate them with the `@JsonView` annotation. This won't be covered in
    this chapter, but I encourage you to check out this excellent blog post [https://spring.io/blog/2014/12/02/latest-jackson-integration-improvements-in-spring](
    https://spring.io/blog/2014/12/02/latest-jackson-integration-improvements-in-spring).
  prefs: []
  type: TYPE_NORMAL
- en: 'We want to be in control of the output of our APIs, so let''s just create a
    new class called `LightTweet` that can be constructed from a tweet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'We now need to make our `SearchService` class return the `LightTweets` class
    instead of tweets:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: This will impact the return type of the `SearchApiController` class as well
    as the tweets model attribute in the `SearchController` class. Make the necessary
    modification in those two classes.
  prefs: []
  type: TYPE_NORMAL
- en: 'We also need to change the code of the `resultPage.html` file because some
    properties changed (we no longer have a nested `user` property):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'We''re almost done. If you restart your application and go to `http://localhost:8080/api/search/mixed;keywords=springFramework`,
    you''ll see that the date format is not the one we expected:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Customizing the JSON output](img/2117_05_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'That''s because Jackson doesn''t have built-in support for JSR-310 dates. Luckily,
    this is easy to fix. Simply add the following library to the dependencies in the
    `build.gradle` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: This indeed changes the date format, but it now outputs an array instead of
    a formatted date.
  prefs: []
  type: TYPE_NORMAL
- en: To change that, we need to understand what the library did. It includes a new
    Jackson module called JSR-310 Module. A Jackson module is an extension point to
    customize serialization and deserialization. This one will automatically be registered
    by Spring Boot at startup in the `JacksonAutoConfiguration` class, which will
    create a default Jackson `ObjectMapper` method with support for well-known modules.
  prefs: []
  type: TYPE_NORMAL
- en: We can see that the former module adds a bunch of serializers and deserializers
    for all the new classes defined in JSR-310\. This will try to convert every date
    to an ISO format, whenever possible. See [https://github.com/FasterXML/jackson-datatype-jsr310](https://github.com/FasterXML/jackson-datatype-jsr310).
  prefs: []
  type: TYPE_NORMAL
- en: If we take a closer look at `LocalDateTimeSerializer`, for instance, we can
    see that it actually has two modes and can switch between the two with a serialization
    feature called `WRITE_DATES_AS_TIMESTAMPS`.
  prefs: []
  type: TYPE_NORMAL
- en: 'To define this property, we need to customize Spring''s default object mapper.
    As we can gather from looking at the auto configuration, Spring MVC provides a
    utility class to create the `ObjectMapper` method that we can use. Add the following
    bean to your `WebConfiguration` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'This time, we are done and the dates are properly formatted, as you can see
    here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Customizing the JSON output](img/2117_05_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: A user management API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Our search API is quite good, but let''s do something more interesting. Like
    a lot of web applications, we will need a user management module to identify our
    users. For that, we will create a new `user` package. In this package, we will
    add a model class as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Since we do not want to use a database just yet, we will create a `UserRepository`
    class in the same package, backed by a simple `Map`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, in the `user.api` package, we will create a very naive controller
    implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: We implemented all the classic CRUD operations with a RESTful repository by
    using the user's e-mail address as a unique identifier.
  prefs: []
  type: TYPE_NORMAL
- en: In this scenario, you will quickly face problems as Spring strips contents found
    after a dot. The solution is very similar to what we use to support semicolons
    in URLs in the URL mapping with matrix variables section in [Chapter 4](ch04.html
    "Chapter 4. File Upload and Error Handling"), *File Upload and Error Handling*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the `useRegisteredSuffixPatternMatch` property that is set to false in
    the `configurePathMatch()` method that we have already defined in the `WebConfiguration`
    class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Now that we've got our API, we can start interacting with it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are a few sample commands with httpie:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: This is good but not great. Status codes are not yet handled. We will need more
    RESTfulness to climb up the Richardson ladder.
  prefs: []
  type: TYPE_NORMAL
- en: Status codes and exception handling
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The first thing we want to do is to correctly handle response statuses. By
    default, Spring automatically deals with some statuses:'
  prefs: []
  type: TYPE_NORMAL
- en: '`500 Server Error`: This indicates that an exception occurred while handling
    the request.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`405 Method not Supported`: This comes up when you use an incorrect method
    on an existing handler.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`404 Not Found`: This comes up when the handler does not exist.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`400 Bad Request`: This indicates that the request body or parameter does not
    match the server''s expectation.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`200 OK`: It is thrown for any request handled without an error.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'With Spring MVC, there are two ways to return status codes:'
  prefs: []
  type: TYPE_NORMAL
- en: Returning a `ResponseEntity` class from a REST controller
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Throwing an exception that will be caught in dedicated handlers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Status code with ResponseEntity
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The HTTP protocol specifies that we should return a `201 Created` status when
    we create a new user. With our API, this can happen with a `POST` method. We also
    need to throw some 404 errors on operation while working on an entity that does
    not exist.
  prefs: []
  type: TYPE_NORMAL
- en: 'Spring MVC has a class that associates an HTTP status with a response entity.
    It is called `ResponseEntity`. Let''s update our `UserApiController` class to
    handle error codes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: You can see that we evolve towards the first level of RESTfulness but there
    is a lot of boilerplate code involved.
  prefs: []
  type: TYPE_NORMAL
- en: Status codes with exceptions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Another way to handle errors in our API is to throw exceptions. There are two
    ways to map exceptions with Spring MVC:'
  prefs: []
  type: TYPE_NORMAL
- en: Using `@ExceptionHandler` at the class level, like we did for `IOException`
    in our upload controller in [Chapter 4](ch04.html "Chapter 4. File Upload and
    Error Handling"), *File Upload and Error Handling*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using `@ControllerAdvice` to catch global exceptions thrown by all controllers
    or a subset of your controllers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These two options help you make some business-oriented decisions and define
    a set of practices within your application.
  prefs: []
  type: TYPE_NORMAL
- en: To associate these handlers with HTTP status codes, we can either inject the
    response in the annotated method and use the `HttpServletResponse.sendError()`
    method or just annotate the method with the `@ResponseStatus` annotation.
  prefs: []
  type: TYPE_NORMAL
- en: We will define our own exception, `EntityNotFoundException`. Our business repositories
    will throw this exception when the entity the user is working on cannot be found.
    This will help relieve the API code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the code for the exception. We can put it in a new package called `error`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Our repository will now throw exceptions in various locations. We will also
    differentiate between saving and updating a user:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Our controller becomes simpler since it doesn''t have to handle the 404 status.
    We now throw the `EntityNotFound` exception from our controller methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'If we don''t handle this exception, Spring will throw a 500 error by default.
    To handle it we will create a small class in the error package, right next to
    our `EntityNotFoundException` class. It will be called `EntityNotFoundMapper`
    class and will be in charge of handling the exception:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The `@ControllerAdvice` annotation allows us to add some behaviors to a set
    of controllers by annotating a bean. Those controller advice can handle exceptions
    but also declare model attributes with `@ModelAttribute` or validator policies
    with `@InitBinder`.
  prefs: []
  type: TYPE_NORMAL
- en: With the code we just wrote, we handle all the `EntityNotFoundException` class
    thrown by our controllers in one place and associate it with the 404 status. That
    way, we can abstract this notion and ensure that our application will handle it
    consistently in all controllers.
  prefs: []
  type: TYPE_NORMAL
- en: We are not going to deal with hyperlinks in our API at our level. Instead, I
    encourage you to have a look at Spring HATEOAS and Spring Data REST, which provide
    very elegant solutions to make your resources more discoverable.
  prefs: []
  type: TYPE_NORMAL
- en: Documentation with Swagger
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Swagger is a really awesome project that will allow you to document and interact
    with your API within an HTML5 webpage. The following screenshot illustrates the
    API documentation:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Documentation with Swagger](img/2117_05_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Swagger used to be big (written in Scala) and somewhat complicated to configure
    with a Spring setup. Since version 2.0, the library has been rewritten and a really
    neat project called `spring-fox` will allow for easy integration.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`spring-fox`, formerly known as `swagger-springmvc`, has been in existence
    for more than three years and is still a very active project.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following dependencies to your build file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: The first one will provide an annotation to enable Swagger in your application
    as well as an API to describe your resources with annotations. Swagger will then
    generate a JSON representation of your API.
  prefs: []
  type: TYPE_NORMAL
- en: The second is a WebJar that contains static resources consuming the generated
    JSON through a web client.
  prefs: []
  type: TYPE_NORMAL
- en: 'The only thing you need to do now is add the `@EnableSwagger2` annotation to
    your `WebConfiguration` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: The `swagger-ui.jar` file we just added contains an HTML file in `META-INF/resources`.
  prefs: []
  type: TYPE_NORMAL
- en: It will automatically be served by Spring Boot when you go to `http://localhost:8080/swagger-ui.html`.
  prefs: []
  type: TYPE_NORMAL
- en: By default, Springfox will scan your whole classpath and show all the request
    mappings declared in your application.
  prefs: []
  type: TYPE_NORMAL
- en: 'In our case, we only want to expose the API:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Springfox works with groups of `Docket`s that you have to define as beans in
    your configuration classes. They are logical grouping for RESTful resources. An
    application can have many of them.
  prefs: []
  type: TYPE_NORMAL
- en: Have a look at the documentation ([http://springfox.github.io/springfox](http://springfox.github.io/springfox))
    to see all the different setups available.
  prefs: []
  type: TYPE_NORMAL
- en: Generating XML
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: RESTful APIs sometimes return responses in different media types (JSON, XML,
    and so on). The mechanism responsible for choosing the correct media type is known
    as content negotiation in Spring.
  prefs: []
  type: TYPE_NORMAL
- en: By default, in Spring MVC, the `ContentNegotiatingViewResolver` bean will be
    in charge of resolving the correct content according to the content negotiation
    policies defined in your application.
  prefs: []
  type: TYPE_NORMAL
- en: You can have a look at `ContentNegotiationManagerFactoryBean` to see how these
    policies are applied within Spring MVC.
  prefs: []
  type: TYPE_NORMAL
- en: 'Content type can be resolved with the following strategies:'
  prefs: []
  type: TYPE_NORMAL
- en: According to the `Accept` header sent by the client
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With a parameter such as `?format=json`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With a path extension such as `/myResource.json` or `/myResource.xml`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can customize these strategies in your Spring configuration by overriding
    the `configureContentNegotiation()` method of the `WebMvcConfigurerAdapter` class.
  prefs: []
  type: TYPE_NORMAL
- en: By default, Spring will use the `Accept` header and the path extension.
  prefs: []
  type: TYPE_NORMAL
- en: 'To enable XML serialization with Spring Boot, you can add the following dependency
    to your classpath:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'If you explore your API with your browser and go to `http://localhost:8080/api/users`,
    you will see the result as XML, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Generating XML](img/2117_05_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'That''s because your browser doesn''t usually request JSON, but XML is second
    after HTML. This is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Generating XML](img/2117_05_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: To get JSON back, you can either go to `http://localhost:8080/api/users.json`
    or send the appropriate `Accept` header with Postman or httpie.
  prefs: []
  type: TYPE_NORMAL
- en: The check point
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we added a search `ApiController` class. Because the tweets
    returned by the Twitter API were not adapted to our usage, we introduced a `LightTweet`
    class to transform them into a friendlier format.
  prefs: []
  type: TYPE_NORMAL
- en: We also developed a user API. The `User` class is the model. The users are stored
    and retrieved via the `UserRepository` class, and the `UserApiController` class
    exposes HTTP endpoints to perform CRUD operations on the users. We also added
    a generic exception and a mapper to associate the exception to an HTTP status.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the configuration, we added a bean that documents our API, thanks to Swagger,
    and we customized the serialization of our JSR-310 dates. Our code base should
    look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The check point](img/2117_05_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have seen how to create a RESTful API with Spring MVC. This
    kind of backend yields great benefits in terms of performance and maintenance
    and can do wonders when coupled with a JavaScript MVC framework such as Backbone,
    Angular JS, or React.js.
  prefs: []
  type: TYPE_NORMAL
- en: We saw how to handle errors and exceptions properly and learned how to leverage
    the HTTP status to make a better API.
  prefs: []
  type: TYPE_NORMAL
- en: Finally we added automatic documentation with Swagger and added the ability
    to produce both XML and JSON.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will learn how to secure our application as well as
    use the Twitter API to sign our users up.
  prefs: []
  type: TYPE_NORMAL
