- en: '4'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Language Fundamentals – Data Types and Variables
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we are comfortable (I hope) with basic Java tooling, we are ready to
    look at the language itself. As you are already a developer, there is no need
    to cover low-level concepts, such as what a variable is, in this chapter. So,
    this chapter will take advantage of what you already know and introduce you to
    the data types available in Java and the operations we can perform on them.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, you will learn about the following:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: Type safety
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The eight primitive data types
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Literal values
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `String` data type
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Naming identifiers
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Constants
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Operations on data
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Casting
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Overflow and underflow
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The math class
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here are the tools required to run the examples in this chapter:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: Java 17
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Text Editor
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Maven 3.8.6 or a newer version
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can find the code from this chapter in the GitHub repo at [https://github.com/PacktPublishing/Transitioning-to-Java/tree/chapter04](https://github.com/PacktPublishing/Transitioning-to-Java/tree/chapter04).
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: Ubuntu and other Linux distributions may have a version of Maven already installed.
    If it is not version 3.8.6 or greater, you must replace it with the newest version.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: Primitive data types
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Primitive data types** create value variables. This means that once you declare
    variables in a program, you can use them in your code. However, before being represented
    by reference variables, classes must be instantiated into objects. But the values
    do not need to be instantiated.'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `CompoundInterest` program, we needed to instantiate the `CompoundInterestCalculation`
    class before we can use it, as shown here:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'On the other hand, when we needed variables to hold `principal`, `annualInterestRate`,
    `compoundPerTimeUnit`, and `time`, we simply declared them, as shown in the following
    code line – we are directly assigning a value to the variable. We did not add
    the `new` operator, which is responsible for converting classes into objects.
    Primitive data types are ready to go:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: There are eight primitive types in Java. Before we look at them, let us quickly
    see what type safety means.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: Type safety
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Depending on the language you are coming from on your path to Java, the concept
    of **type safety** may or may not be something you are familiar with. One form
    of type safety means that every variable must show its type when declared, and
    this type cannot change. You cannot assign an integer variable to a string. If
    you do this, you will get an error message as an exception. This is static typing.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: The alternative to static typing is dynamic typing. Here, it is not necessary
    to declare the type of the variable. Java infers the type from what you assign.
    It is frequently and incorrectly assumed that dynamic typing is not type-safe.
    This is not necessarily true.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: How you declare a variable is not at the heart of type safety. Instead, it is
    how the language handles, at runtime, what happens if a variable’s type does not
    match the type required.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a Python script that demonstrates that Python is type-safe even though
    it uses dynamic typing:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In this example, the `print_hi` function is expecting to receive a variable
    named `name`. The first line of code in this function performs a math operation
    using the `name` variable.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: 'In the code that is calling `print_hi`, we are declaring a variable, `x`, as
    a string. We know this because we are assigning a string to it. In this small
    snippet of code, it should appear obvious that this will generate an error. It
    does, and here is the error:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Python only detects this problem at runtime, but it is an error that will end
    the program. This means that despite the argument that dynamically typed languages
    are not type-safe, we have just seen that this is not the case. Python is effectively
    type-safe.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: 'Java, on the other hand, is a statically typed language. Here is the same code
    in Java:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Notice that `print_hi` clearly expects a string, but in the `perform` method,
    we are passing an integer. When we run this code with Maven, we will get the following
    error message:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: In Python, you determine the variable type by where and how you use it. The
    Python `print_hi` method does not indicate the type of `name`. Only when we see
    the math expression in the function do we recognize that `name` must be an integer
    to work. The statically typed Java, by virtue of requiring the type as part of
    every declaration, makes it easier to spot type errors.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: While we are comparing to Python – an excellent language – note that there is
    a significant difference in each language’s compiler. The Java compiler can incrementally
    compile a program. The editor in an IDE can detect errors while you type by compiling
    the code one line at a time. Languages with no incremental compiler, such as Python,
    can only report errors in an IDE when you compile or run the code.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: Which approach is better? I leave that up to you to decide.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: However, static typing leads to more verbose programs. This means you must enter
    more code in a Java program compared to Python. On the other hand, static typing
    makes tracking down type errors easier and enhances the readability of the code.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: One last point about Python – in version 3, the language developers introduced
    type annotations. These appear in Python code as if you are statically typing
    a variable. But this is not the case, as the compiler ignores these annotations.
    They exist to support type checkers, such as what the **PyCharm** IDE can do.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: Before we look at the data types we use when declaring variables, let us take
    a moment to look at literal values.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: Literal values
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A `42`, Java treats this as an integer. Should the literal value exceed the
    range of an integer when assigned to an integer, you will get an `integer number
    to large` compiler error. If you assign the literal value to a `long` integer,
    you must add the letter `L` to the number, such as `14960000000000L`.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: When we write large numbers, we frequently use a separator every three digits
    to improve legibility. If you want a separator to make the source code easier
    to read, you can only use the underscore. You cannot use a comma or any other
    character as a separator. The value `14960000000000L` can be entered as `14_960_000_000_000L`.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们书写大数字时，我们经常每三位数字使用一个分隔符来提高可读性。如果你想使用分隔符使源代码更容易阅读，你只能使用下划线。你不能使用逗号或其他任何字符作为分隔符。值`14960000000000L`可以输入为`14_960_000_000_000L`。
- en: 'When working with literal floating-point numbers, the default primitive type
    is double. If you are assigning a literal double that does not have any decimal
    places, then add one, rather than adding it like so:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 当处理字面浮点数时，默认的原始类型是double。如果你正在分配一个没有小数位的字面double值，那么添加一个，而不是像这样添加：
- en: '[PRE6]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Enter it in the following manner:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 按以下方式输入：
- en: '[PRE7]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Alternatively, you could use the suffix `D` for double and `F` for float. You
    can write all literal suffixes in upper or lowercase, as shown here:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，你可以使用后缀`D`表示double和`F`表示float。你可以像这里一样用大写或小写写所有字面后缀：
- en: '[PRE8]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Now, let us move on to the primitive data types.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们继续讨论原始数据类型。
- en: Integers
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 整数
- en: There are four members of the integer family – `byte`, `short`, `int`, and `long`.
    The difference is the number of bytes they use to contain a value. Java, like
    most languages, encodes integers using two’s complement. This means that the range
    of values for any of the integer types goes from negative to positive values.
    Like Python, Java does not have unsigned integers, while C, C++, and C# do.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 整数家族有四个成员 – `byte`、`short`、`int`和`long`。它们之间的区别是它们用来存储值的字节数。Java，像大多数语言一样，使用二进制补码来编码整数。这意味着任何整数类型的值范围从负值到正值。像Python一样，Java没有无符号整数，而C、C++和C#有。
- en: 'In the following table, you will find the size in bytes, the allowable range,
    and how to declare, assign, or declare and initialize all the members of the integer
    family:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的表中，你可以找到大小（以字节为单位）、允许的范围以及如何声明、分配或声明和初始化整数家族的所有成员：
- en: '![Table 4.1 – Specs for integers and how we can use them'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '![表4.1 – 整数规格及其使用方法](img/Table_4.1_B19088.jpg)'
- en: '](img/Table_4.1_B19088.jpg)'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Table_4.1_B19088.jpg)'
- en: Table 4.1 – Specs for integers and how we can use them
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 表4.1 – 整数规格及其使用方法
- en: The integer data type on most computers is related to the size of a CPU’s registers.
    The JVM is a 32-bit virtual machine, meaning that its registers are 32 bits or
    4 bytes wide. While the JVM program is implemented as a 64-bit application, it
    remains an implementation of a 32-bit computer.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数计算机上的整数数据类型与CPU寄存器的大小有关。JVM是一个32位虚拟机，这意味着它的寄存器是32位或4字节宽。虽然JVM程序被实现为一个64位应用程序，但它仍然是32位计算机的实现。
- en: Floating point
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 浮点数
- en: Like most languages, Java uses a subset of the **IEEE standard binary floating-point
    numbers** to represent a floating-point value in memory. In the *Further reading*
    section, you can find links to websites that delve into this physical format.
    From our perspective, the main interest we have is in accuracy.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 与大多数语言一样，Java使用IEEE标准二进制浮点数的一个子集来在内存中表示浮点值。在*进一步阅读*部分，你可以找到深入探讨这种物理格式的网站链接。从我们的角度来看，我们主要感兴趣的是精度。
- en: Accuracy is defined as representing a value exactly. We describe integers as
    accurate because every decimal integer number can be converted into a binary number.
    We call the conversion a **lossless conversion**.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 精度定义为精确表示一个值。我们称整数是精确的，因为每个十进制整数都可以转换成二进制数。我们称这种转换为一个**无损转换**。
- en: Not all decimal floating-point values map to a fixed-length binary value, though.
    One of the best examples is 0.1 in decimal. This is 1 divided by 10\. If we divide
    binary 1 (1) by binary 10 (1010), the result will be an infinitely repeating sequence
    of 0.00110011001100110011 . . . What this means is that floating point does not
    have the same accuracy as integers. The IEEE 754 standard deals with this issue,
    but you must always know that floating-point values are approximations. We call
    this a `float` and `double`. The measure of accuracy when we convert from decimal
    to binary floating point and back is referred to as the precision of the result.
    If a number exceeds the precision, it is considered an approximation of the actual
    result.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following table, you will find the size in bytes, the allowable range,
    and how to declare, assign, or declare and initialize all the members of the floating-point
    family. This information is critical in deciding whether to use double or float:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: '![Table 4.2 – Specs for floating point and how we can use it'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Table_4.2_B19088.jpg)'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: Table 4.2 – Specs for floating point and how we can use it
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: We usually interpret precision as the number of valid numbers to the right of
    the decimal place. Float uses 23 bits, and double uses 53 bits. Therefore, thinking
    in terms of the number of digits is a crude way to define precision; it is about
    the length of the mantissa as per the IEEE 754 standard. Simply put, doubles,
    by virtue of their larger mantissa, have a larger range of values and a higher
    level of precision than float.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: You may now think you should only be using double rather than using float. After
    all, we all want our results to be as accurate as possible. But the fact that
    doubles are twice the size in bytes, 64 as opposed to 32, has a performance penalty.
    In deciding whether to use double or float, consider the range of values and the
    precision required. For example, the float will be sufficient if the range of
    values is small and the number of decimal places after the decimal point will
    never exceed approximately six. The math operations you may perform will also
    influence your choice. Addition and subtraction are not concerns, but multiplication
    and division may have an impact.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: The Java compiler can recognize when you assign a floating-point value to an
    integer variable. You will get a possible lossy conversion from `double` to `int`
    error if you do. Later in this chapter, we will look at casting to convert from
    one numeric data type to another.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: We are now finished with the numeric types – integers and floating points. Now,
    let’s look at the non-numeric types.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: Boolean
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `false` and one means `true`. In Java, the set of values that you can assign
    to a Boolean is the `true` and `false` keywords. The result of all logical operations,
    such as *Is x greater than y?*, expressed as `x > y`, always returns a Boolean
    value.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: In Python, you can cast an integer to or from a Boolean value. The C language
    does not have a Boolean type, so the language uses the integer values of zero
    for `false` and not zero for `true`. C++ has a Boolean type, but it is just a
    subset of integers with the zero and one values represented by the `true` and
    `false` keywords. C++ treats integers as Booleans, the same way C does.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: In Java, a Boolean is a distinct type. You cannot use an integer in place of
    either `true` or `false`. This means you cannot use the result of a calculation
    that may be either zero or not zero, where you require a Boolean type.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following table, you will find the set of allowable values and how to
    declare, assign, declare, and initialize Booleans. Technically, you only need
    a single bit to represent `true` or `false`. However, there is no machine language
    or bytecode instruction that can read just one bit. The Java language architects
    have left the size in bytes of a Boolean up to the specific implementation of
    Java:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: '![Table 4.3 – Specs for Boolean and how we can use it'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Table_4.3_B19088.jpg)'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: Table 4.3 – Specs for Boolean and how we can use it
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: The CPU retrieves data from memory in units of bytes, typically 4 bytes at a
    time, as this is the word size of the CPU. It cannot directly read a single bit
    in RAM. Once retrieved and stored in a CPU register, the CPU can determine the
    state of any bit in a byte. This means that a Boolean can be no smaller than a
    byte. Java does not define the number of bytes the same way integers and floating
    points are. The number of bytes a Boolean uses depends on the implementation of
    the virtual machine. This can mean that the implementation of Java by one organization
    may use a different number of bytes compared to another.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: Booleans are at the heart of decision-making and iteration for many organizations.
    Now, let’s move on to the data type used to represent the characters of our written
    language.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: char
  id: totrans-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `char` data type contains the numeric value for 2-byte Unicode characters.
    Unicode UTF-8 is a variable-length character encoding from 2 to 4 bytes per character.
    Currently, Java only supports 2-byte encoding. The first 128 characters are identical
    to the first 128 characters found in ASCII encoding.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: In C and C++, a char is a subset of integers, and you can use it as an integer.
    Python does not have a character type but uses strings with a length of 1 for
    a single character. In Java, a char is a unique data type; you cannot use it for
    an integer as C and C++ allow. You can cast a `char` to an integer or cast an
    integer to a char.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: Take note that a single quotation mark around a single character implies a char.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following table, you will find the set of allowable values and how to
    declare, assign, or declare and initialize a char:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: '![Table 4.4 – Specs for char and how we can use it'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Table_4.4_B19088.jpg)'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: Table 4.4 – Specs for char and how we can use it
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: 'There is one more table to look at and that is the default value assigned to
    variables that are not initialized when declared. Variables can be declared as
    fields in a class or as local variables in a method. Here are the default values
    for fields:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: '| **Type** | **Default value** |'
  id: totrans-97
  prefs: []
  type: TYPE_TB
- en: '| `boolean` | `false` |'
  id: totrans-98
  prefs: []
  type: TYPE_TB
- en: '| `byte` | 0 |'
  id: totrans-99
  prefs: []
  type: TYPE_TB
- en: '| `short` | 0 |'
  id: totrans-100
  prefs: []
  type: TYPE_TB
- en: '| `int` | 0 |'
  id: totrans-101
  prefs: []
  type: TYPE_TB
- en: '| `long` | 0 |'
  id: totrans-102
  prefs: []
  type: TYPE_TB
- en: '| `float` | 0.0f |'
  id: totrans-103
  prefs: []
  type: TYPE_TB
- en: '| `double` | 0.0d |'
  id: totrans-104
  prefs: []
  type: TYPE_TB
- en: '| `char` | \u0000 (Unicode equivalent to null) |'
  id: totrans-105
  prefs: []
  type: TYPE_TB
- en: '| Reference to objects | null |'
  id: totrans-106
  prefs: []
  type: TYPE_TB
- en: Table 4.5 – Default values for fields
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: There is no default value for variables declared in a method. Any code that
    tries to read a local variable that has not been assigned an initial value will
    result in a compile-time error.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: We have now gone over the eight primitive types. There is one more type that
    you can use, similar to a primitive, but it is not primitive. Let’s meet `String`.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: A special case – String
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A string, with a *lowercase s*, is a list of characters that usually represent
    a word we may write or speak. `String`, with a *capital S*, is a class that contains
    a list of zero or more characters and numerous operations that you can perform
    on them. As a class, it normally must be instantiated into an object. As developers
    commonly use `String` objects, Java can perform the instantiation implicitly whenever
    you use the assignment operator (`=`) with a `String` variable. When referring
    to this data type, we always capitalize the first letter. This way, we know that
    we are referring to the `String` class. We will cover classes and objects in more
    depth in the coming chapter.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us examine `String` and how we use it. We begin with the specification
    table:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: '![Table 4.6 – Specs for String and how we can use it'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Table_4.6_B19088.jpg)'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: Table 4.6 – Specs for String and how we can use it
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: In this table, `String`. The first, called a `String` object. A reference is
    like a pointer in other languages, but you cannot manipulate it as you can in
    C or C++. The **length** of this object in memory includes overhead for the object
    in addition to the characters in the actual text you are storing.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: Classes become objects in memory by using the `new` operator in Java, as shown
    in the previous table. Developers use `String` objects frequently, and Java simplifies
    its usage by implicitly instantiating it when assigned a value. You can use `new`
    as shown, but this is rarely written this way. Instead, `String` appears to work
    like a primitive value for the convenience of programmers.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: With the eight primitive types defined along with the one special case, we can
    now move on to how we can use them in our code.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: Naming identifiers
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An **identifier** in any language is simply the name we assign to a variable,
    class, or method. We will first focus on naming variables, and in [*Chapter 5*](B19088_05.xhtml#_idTextAnchor106),
    *Language Fundamentals – Classes*, we will look at naming classes and methods.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: 'There are very few rules in Java related to naming identifiers, but for those
    that are, the compiler enforces them. These are as follows:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: 'The first character of an identifier can be one of the following:'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dollar sign (`$`)
  id: totrans-123
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Underscore (`_`)
  id: totrans-124
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Alpha character (`A`–`Z`, `a`–`z`)
  id: totrans-125
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Subsequent characters can be any of the previously mentioned ones and numbers.
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Once you adhere to the rules, the choice of naming is up to you. This is because
    Java has conventions for naming. A convention is not a rule, and the compiler
    does not validate them. Instead, conventions are techniques the programming community
    recommends for a given language. While working in a team, your fellow members
    expect you to follow these conventions. Here are the conventions for naming variables:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: The name of a variable should be a noun; variables are things and not actions.
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The first character should be lowercase. The convention for class identifiers
    requires that its first character be a capital letter.
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When using a name made up of more than one word, use camel case. Each word in
    the identifier should be lowercase except for the first character. Each subsequent
    word in the identifier after the first word must begin with a capital letter.
    It is acceptable if you prefer using the underscore to represent a space in a
    multi-word identifier rather than camel case. For this usage, all characters should
    be lowercase.
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Do not use abbreviations; use whole words.
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Avoid single-character identifiers. There are a limited number of cases where
    a single character is acceptable, such as for a loop index variable. Otherwise,
    use meaningful names.
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This table describes the naming conventions for a variable:'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '| **Convention** | **Acceptable** | **Unacceptable** |'
  id: totrans-134
  prefs: []
  type: TYPE_TB
- en: '| Noun | `double salary;` | `double receive;` |'
  id: totrans-135
  prefs: []
  type: TYPE_TB
- en: '| First character lowercase | `int cars;` | `int Cars;` |'
  id: totrans-136
  prefs: []
  type: TYPE_TB
- en: '| Camel case | `int platesOfPasta;` | `int platesofpasta;` |'
  id: totrans-137
  prefs: []
  type: TYPE_TB
- en: '| Underscore separator | `int plates_of_pasta;` | `int plates_Of_Pasta;` |'
  id: totrans-138
  prefs: []
  type: TYPE_TB
- en: '| Abbreviations | Never acceptable | `int lol;` representing layers of lacquer
    |'
  id: totrans-139
  prefs: []
  type: TYPE_TB
- en: Table 4.7 – Naming conventions
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: You should not use the dollar sign; the compiler uses it to create identifiers.
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You should not use the underscore as the first character as in other languages,
    such as C++, because it means the same as the dollar sign as the first character
    in Java.
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Once past the first character, you can use any letter of the alphabet, any number,
    an underscore, or the dollar sign.
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now let us look at the length of identifiers compared to other languages in
    the following table:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: '| **Language** | **Maximum # of** **significant characters** |'
  id: totrans-145
  prefs: []
  type: TYPE_TB
- en: '| Python | 79 |'
  id: totrans-146
  prefs: []
  type: TYPE_TB
- en: '| Standard C | 31 |'
  id: totrans-147
  prefs: []
  type: TYPE_TB
- en: '| Standard C++ | 1,024 |'
  id: totrans-148
  prefs: []
  type: TYPE_TB
- en: '| Microsoft C++ | 2,048 |'
  id: totrans-149
  prefs: []
  type: TYPE_TB
- en: '| GNU C++ | Unlimited |'
  id: totrans-150
  prefs: []
  type: TYPE_TB
- en: '| Java | Unlimited |'
  id: totrans-151
  prefs: []
  type: TYPE_TB
- en: Table 4.8 – Maximum length of identifiers
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: While Java and **GNU C++** have no restriction on the number of characters in
    the name of an identifier, you should be reasonable in the number of characters
    you use.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: Coming up with a meaningful name for identifiers is an important task for making
    your code readable, so give it some thought. Now, let us look at data that, once
    assigned a value, cannot be changed.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: Constants
  id: totrans-155
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A constant can be any data type declared with the `final` keyword. It must have
    a value assigned when declared, for example, `final double TAX_RATE =` `0.05;`.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: If you declare a field in a class as `final`, then you may also assign its value
    in the class constructor. Once a value is assigned to a constant, however, it
    cannot be changed.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: The naming rules for constants are the same as identifiers. What differs are
    the conventions. Constants are nouns written in uppercase. You can use the underscore
    to separate words in the identifier, as shown in `TAX_RATE` in the previous example.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: Operators
  id: totrans-159
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Java supports the common set of operators found in almost every language, as
    shown in the following table:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: '| **Action** | **Operator** | **Assignment** |'
  id: totrans-161
  prefs: []
  type: TYPE_TB
- en: '| Addition | x = x + y | x += y |'
  id: totrans-162
  prefs: []
  type: TYPE_TB
- en: '| Subtraction | x = x – y | x -= y |'
  id: totrans-163
  prefs: []
  type: TYPE_TB
- en: '| Multiplication | x = x * y | x *= y |'
  id: totrans-164
  prefs: []
  type: TYPE_TB
- en: '| Division | x = x / y | x /= y |'
  id: totrans-165
  prefs: []
  type: TYPE_TB
- en: '| Modulus (remainder) | x = x % y | x %= y |'
  id: totrans-166
  prefs: []
  type: TYPE_TB
- en: '| Increment | ++x or x++ | N/A |'
  id: totrans-167
  prefs: []
  type: TYPE_TB
- en: '| Decrement | --x or x-- | N/A |'
  id: totrans-168
  prefs: []
  type: TYPE_TB
- en: Table 4.9 – Basic math operators
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: Java follows the standard rules of precedence, except for the increment and
    decrement operators. If the operator is on the left-hand side of the variable,
    then Java conducts the operation before any other. This, technically, gives it
    the highest precedence. Placed on the right-hand side, it has the lowest precedence,
    and Java performs it after all other operations are complete. We will review the
    logical operators when we look at logical operations in the next chapter.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: String operator
  id: totrans-171
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`String` does not have a numeric value, and you cannot use a `String` object
    in a calculation. As you would expect, `int numberOfDogs = 23;` does not mean
    the same as `String numberOfDogs = "``23 ";`.'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: You cannot use a `String` variable in an arithmetic expression. If the characters
    in `String` match what is allowable for a number, then you must convert `String`
    into a numeric variable first and then use it in an arithmetic expression.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: 'However, the plus (`+`) operator is permitted along with `String`. When used
    with `String`, it means to concatenate or join multiple `String` values into one,
    as shown here:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'You can also use concatenation to combine `String` with any of the eight primitive
    types. This will automatically convert the primitive to `String`, as shown here:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The `String` message will contain the following:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'You cannot assign a numeric type directly to `String`. You must concatenate
    it to `String` or use the `String.valueOf` method; it is a simpler approach. Concatenating
    a primitive to any string, such as the empty String shown here, will work:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Alternatively, you can use the following:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Where you see the literal values, you can also use a primitive, as shown here:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: There is just one operator you can use with String, which is for concatenation
    rather than a mathematical function.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: Casting
  id: totrans-187
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Casting provides the ability to cast or convert one data type to another. When
    coding with primitives, there are two types of casting – implicit and explicit.
    First, look at this chart, which shows the primitives by order of their range
    of values:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: '| **Largest** |  |  |  |  | **Smallest** |'
  id: totrans-189
  prefs: []
  type: TYPE_TB
- en: '| `double` | `float` | `long` | `int` | `short` | `byte` |'
  id: totrans-190
  prefs: []
  type: TYPE_TB
- en: Table 4.10 – Relative number of bytes between types
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: 'What this means is that when assigning a primitive of one type on the chart
    to a primitive higher on the chart, Java will perform an implicit cast, as shown
    here:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'This is a lossless conversion. You may try the assignment in the other direction,
    as follows:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'You will get the following error:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'If you need to convert from a data type larger than the data type of the destination
    variable, you must do an explicit cast. For example, when converting from a floating
    point to an integer, Java will cut the fractional component. No rounding; it just
    disappears, as shown here:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: With casting, there is no error, but the value in `fruit` will be `34`.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: 'If the value on the right-hand side exceeds the range of the type you are casting
    to, when it is an integer type, then, like an **overflow**, discussed in the next
    section, it will wrap around, as shown here:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The value in `fruit` will be `1464`.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: The syntax for casting Java places the type to cast in parentheses. Python,
    C, and C++ are cast by placing the value in parentheses, while C# follows the
    same model as Java.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: In *Table 4.10*, you did not see the `char` type. Its sole purpose in the language
    is to represent a UTF-8 code that Java will render as a character on the screen.
    You can assign a character to a `char` variable, or you can assign an integer.
    If the integer you assign is outside the allowable range, then you will need to
    cast, and an overflow wrap will occur.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are some examples of declaring a `char` variable:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: All three of these will become the letter `A`.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: We have seen that promotion occurs implicitly, moving from one data type to
    another data type higher on the chart. To move in the other direction, you must
    cast.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: Overflow and underflow
  id: totrans-210
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: An overflow and an **underflow** can occur when working with floating-point
    types. Only an overflow can occur with integer and char types. Here is how Java
    behaves in these situations.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: Integer overflow
  id: totrans-212
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: An overflow occurs when a value is outside the range of allowable values. For
    floating-point values, an overflow results in the special value infinity, and
    either plus or minus is the result.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: 'Overflow with integers results in a wraparound. For example, in the following
    code snippet, we are assigning a value to a short data type. This value is 1 greater
    than the allowable upper range of `short`:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The following is the output of this code fragment:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Floating-point overflow
  id: totrans-218
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Unlike the integer types, floating-point types do not wrap when overflow occurs.
    Instead, Java assigns the special value `Infinity`.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: 'Using a double as an example, we can use the `Double` class, discussed in the
    next section, as the static constant that contains the maximum allowed value for
    a double. When we assign a value to a double that exceeds the maximum allowable
    value:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The following will be the output for this:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The nature of the floating point is such that a minor increase over the maximum
    value does not result in an overflow. As shown in the previous example, a significant
    increase over the maximum value will generate `Infinity`. Take the following example:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Both expressions return the same answer:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Floating-point underflow
  id: totrans-228
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Underflow occurs when the floating-point value cannot represent exceedingly
    small fractions. Like overflow, this condition does not occur immediately after
    a value falls below the minimum value for the floating point. A meaningful change
    that lowers a value below the minimum will trigger an underflow. In this example,
    we begin by assigning the smallest allowed value to a double. When we divide it
    by 2, it becomes even smaller but now is smaller than the minimum value:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'When run, the result is as follows:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'This is the minimum value of a double. Say we try to assign an even smaller
    value by dividing the minimum value by 2, as we have done here:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Then, the result will be the following:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: This is the value that the code returns when a float or double underflows.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
- en: You should always be wary of overflow and, in the case of floating point, underflow.
    Now, let us look at a family of classes that provide class support for the primitive
    data types.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
- en: Wrapper classes
  id: totrans-239
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Java, like most languages, has an array data type – you can have an array of
    integers, Booleans, or primitives. You can have an array of objects, such as the
    String. Every element in the array must be the same type. Many of the object-oriented
    capabilities in Java require the use of objects and not primitives. For example,
    Java has a library of data structures called collections that provides greater
    functionality than a basic array. These collections can only store or collect
    objects. You cannot have a collection of `int`, `double`, or any of the other
    primitives.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
- en: A `String` class, you do not need to use `new` to create a wrapper object. Wrappers
    have methods to convert from String to primitives. They also contain information
    about the primitives. We already had a peek at this when I used `Double.MIN_VALUE`
    and `Double.MAX_VALUE`.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a table of all the primitives and their matching wrapper classes. Aside
    from static variables, these wrappers also have static methods to convert to and
    from `String`:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
- en: '| **Primitive** **data type** | **Wrapper class** |'
  id: totrans-243
  prefs: []
  type: TYPE_TB
- en: '| `byte` | Byte |'
  id: totrans-244
  prefs: []
  type: TYPE_TB
- en: '| `short` | Short |'
  id: totrans-245
  prefs: []
  type: TYPE_TB
- en: '| `int` | Integer |'
  id: totrans-246
  prefs: []
  type: TYPE_TB
- en: '| `long` | Long |'
  id: totrans-247
  prefs: []
  type: TYPE_TB
- en: '| `float` | Float |'
  id: totrans-248
  prefs: []
  type: TYPE_TB
- en: '| `double` | Double |'
  id: totrans-249
  prefs: []
  type: TYPE_TB
- en: '| `boolean` | Boolean |'
  id: totrans-250
  prefs: []
  type: TYPE_TB
- en: '| `char` | Character |'
  id: totrans-251
  prefs: []
  type: TYPE_TB
- en: Table 4.11 – Primitives and wrappers
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
- en: 'These classes, like String, do not have to be explicitly instantiated. This
    means that you could write the following:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'But you can also just assign the integer value, as shown here:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Java refers to this as **autoboxing**. A second feature, called **unboxing**,
    permits the reading of a wrapper class as if it were a primitive.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
- en: 'Here we see an object, `number`, assigned to a primitive:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: This now allows us to use objects as primitives. Every wrapper also contains
    several useful methods we will explore as we delve more into the language.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
- en: The math library
  id: totrans-261
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Earlier in this chapter, we examined the operators available for working with
    primitive data types. There are many operations you may wish to perform that do
    not have a matching symbol, such as raising a value by a power. There are languages
    that use the caret (`^`) or double asterisk (`**`) to denote raising to a power.
    In Python, you would write the following:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The result will be `25`. Java does not have a symbol for this operation. Instead,
    we must use a method that belongs to the math class, as shown here:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'We have already seen this in the program that calculated compound interest;
    take a look again:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: The math library has an extensive selection of math operations. See the link
    in the *Further reading* section to learn about all the choices available to you.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-269
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The heart of every program you will write is the data that your program operates
    on. In this chapter, we have learned about the eight primitive types. There is
    `byte`, particularly useful if you are writing software to interact with other
    devices. `short`, `int`, and `long` are useful when what you need to describe
    has no fractions. When there are fractions, however, you can use floating-point
    types – `float` and `double`. The `char` type is the building block for strings.
    If you want to keep track of what is true or false, you should use the `boolean`
    type.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
- en: As you move forward into Java, always keep in mind the available data types.
    Just as important is to understand what will happen if a value is out of range.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
- en: Having identified the types, we moved to identify variables with meaningful
    names. We discussed how we assign data to these variables, and how we use them
    was an important part of this chapter.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
- en: We left the primitives briefly to look at classes that are closely associated
    with primitives. There was `String` – home to characters that make up text that
    we can read. The wrapper classes provided runtime information about their matching
    primitives and are freely interchangeable with primitives, when you need an object
    rather than a primitive.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
- en: Coming up, we will look at classes focusing on access control, packages, and
    how we construct a class.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  id: totrans-275
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*The IEEE 754* *Format*: [http://mathcenter.oxford.emory.edu/site/cs170/ieee754/](http://mathcenter.oxford.emory.edu/site/cs170/ieee754/)'
  id: totrans-276
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Demystifying Floating Point* *Precision*: [https://blog.demofox.org/2017/11/21/floating-point-precision/](https://blog.demofox.org/2017/11/21/floating-point-precision/)'
  id: totrans-277
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Class* *Math*: [https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/lang/Math.html](https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/lang/Math.html)'
  id: totrans-278
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
