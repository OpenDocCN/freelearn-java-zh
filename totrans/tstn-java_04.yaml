- en: '4'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '4'
- en: Language Fundamentals – Data Types and Variables
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 语言基础 – 数据类型和变量
- en: Now that we are comfortable (I hope) with basic Java tooling, we are ready to
    look at the language itself. As you are already a developer, there is no need
    to cover low-level concepts, such as what a variable is, in this chapter. So,
    this chapter will take advantage of what you already know and introduce you to
    the data types available in Java and the operations we can perform on them.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经对基本的Java工具感到舒适（希望如此），我们可以开始研究这门语言本身了。既然你已经是一名开发者，在这个章节中就没有必要再介绍低级概念，比如什么是变量。因此，这个章节将利用你已有的知识，并介绍Java中可用的数据类型以及我们可以对这些类型执行的操作。
- en: 'In this chapter, you will learn about the following:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将学习以下内容：
- en: Type safety
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类型安全
- en: The eight primitive data types
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 八种原始数据类型
- en: Literal values
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文字值
- en: The `String` data type
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`String`数据类型'
- en: Naming identifiers
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标识符命名
- en: Constants
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 常量
- en: Operations on data
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据操作
- en: Casting
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类型转换
- en: Overflow and underflow
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 溢出和下溢
- en: The math class
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数学类
- en: Technical requirements
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'Here are the tools required to run the examples in this chapter:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是运行本章示例所需的工具：
- en: Java 17
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Java 17
- en: Text Editor
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文本编辑器
- en: Maven 3.8.6 or a newer version
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Maven 3.8.6或更高版本
- en: You can find the code from this chapter in the GitHub repo at [https://github.com/PacktPublishing/Transitioning-to-Java/tree/chapter04](https://github.com/PacktPublishing/Transitioning-to-Java/tree/chapter04).
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在GitHub仓库中找到本章的代码，网址为[https://github.com/PacktPublishing/Transitioning-to-Java/tree/chapter04](https://github.com/PacktPublishing/Transitioning-to-Java/tree/chapter04)。
- en: Note
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Ubuntu and other Linux distributions may have a version of Maven already installed.
    If it is not version 3.8.6 or greater, you must replace it with the newest version.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: Ubuntu和其他Linux发行版可能已经安装了Maven的一个版本。如果它不是3.8.6或更高版本，你必须用最新版本替换它。
- en: Primitive data types
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 原始数据类型
- en: '**Primitive data types** create value variables. This means that once you declare
    variables in a program, you can use them in your code. However, before being represented
    by reference variables, classes must be instantiated into objects. But the values
    do not need to be instantiated.'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '**原始数据类型**创建值变量。这意味着一旦你在程序中声明了变量，你就可以在代码中使用它们。然而，在由引用变量表示之前，类必须被实例化为对象。但值不需要实例化。'
- en: 'In the `CompoundInterest` program, we needed to instantiate the `CompoundInterestCalculation`
    class before we can use it, as shown here:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在`CompoundInterest`程序中，我们需要在可以使用它之前实例化`CompoundInterestCalculation`类，如下所示：
- en: '[PRE0]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'On the other hand, when we needed variables to hold `principal`, `annualInterestRate`,
    `compoundPerTimeUnit`, and `time`, we simply declared them, as shown in the following
    code line – we are directly assigning a value to the variable. We did not add
    the `new` operator, which is responsible for converting classes into objects.
    Primitive data types are ready to go:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，当我们需要变量来保存`principal`、`annualInterestRate`、`compoundPerTimeUnit`和`time`时，我们只需声明它们，如下面的代码行所示——我们直接将值赋给变量。我们没有添加`new`运算符，它负责将类转换为对象。原始数据类型是现成的：
- en: '[PRE1]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: There are eight primitive types in Java. Before we look at them, let us quickly
    see what type safety means.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: Java中有八个原始类型。在我们查看它们之前，让我们快速了解一下类型安全是什么意思。
- en: Type safety
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 类型安全
- en: Depending on the language you are coming from on your path to Java, the concept
    of **type safety** may or may not be something you are familiar with. One form
    of type safety means that every variable must show its type when declared, and
    this type cannot change. You cannot assign an integer variable to a string. If
    you do this, you will get an error message as an exception. This is static typing.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 根据你从Java路径中来的语言，类型安全的概念可能或可能不是你所熟悉的。类型安全的一种形式意味着每个变量在声明时都必须显示其类型，并且这种类型不能改变。你不能将整数变量赋值给字符串。如果你这样做，你会得到一个错误消息作为异常。这是静态类型。
- en: The alternative to static typing is dynamic typing. Here, it is not necessary
    to declare the type of the variable. Java infers the type from what you assign.
    It is frequently and incorrectly assumed that dynamic typing is not type-safe.
    This is not necessarily true.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 静态类型的一个替代方案是动态类型。在这里，没有必要声明变量的类型。Java会从你分配的内容中推断类型。人们经常错误地认为动态类型不安全。这并不一定正确。
- en: How you declare a variable is not at the heart of type safety. Instead, it is
    how the language handles, at runtime, what happens if a variable’s type does not
    match the type required.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 你如何声明变量并不是类型安全的核心。相反，它是语言在运行时如何处理变量类型不匹配的情况。
- en: 'Here is a Python script that demonstrates that Python is type-safe even though
    it uses dynamic typing:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个演示 Python 即使使用动态类型也是类型安全的 Python 脚本：
- en: '[PRE2]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In this example, the `print_hi` function is expecting to receive a variable
    named `name`. The first line of code in this function performs a math operation
    using the `name` variable.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`print_hi` 函数期望接收一个名为 `name` 的变量。该函数的第一行代码使用 `name` 变量执行一个数学运算。
- en: 'In the code that is calling `print_hi`, we are declaring a variable, `x`, as
    a string. We know this because we are assigning a string to it. In this small
    snippet of code, it should appear obvious that this will generate an error. It
    does, and here is the error:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在调用 `print_hi` 的代码中，我们声明了一个变量 `x` 为字符串。我们知道这一点，因为我们将其赋值为字符串。在这段小代码片段中，很明显这将生成一个错误。确实如此，以下是错误信息：
- en: '[PRE3]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Python only detects this problem at runtime, but it is an error that will end
    the program. This means that despite the argument that dynamically typed languages
    are not type-safe, we have just seen that this is not the case. Python is effectively
    type-safe.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: Python 只在运行时检测这个问题，但这是一个会导致程序终止的错误。这意味着尽管动态类型语言不是类型安全的论点，但我们刚刚看到这并不是真的。Python
    事实上是类型安全的。
- en: 'Java, on the other hand, is a statically typed language. Here is the same code
    in Java:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，Java 是一种静态类型语言。以下是 Java 中的相同代码：
- en: '[PRE4]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Notice that `print_hi` clearly expects a string, but in the `perform` method,
    we are passing an integer. When we run this code with Maven, we will get the following
    error message:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到 `print_hi` 明确期望一个字符串，但在 `perform` 方法中，我们传递了一个整数。当我们使用 Maven 运行此代码时，我们将得到以下错误信息：
- en: '[PRE5]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: In Python, you determine the variable type by where and how you use it. The
    Python `print_hi` method does not indicate the type of `name`. Only when we see
    the math expression in the function do we recognize that `name` must be an integer
    to work. The statically typed Java, by virtue of requiring the type as part of
    every declaration, makes it easier to spot type errors.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Python 中，你通过变量的使用位置和方式来确定变量类型。Python 的 `print_hi` 方法没有指示 `name` 的类型。只有当我们看到函数中的数学表达式时，我们才会意识到
    `name` 必须是整数才能工作。由于静态类型 Java 要求在每次声明时都必须包含类型，这使得发现类型错误更加容易。
- en: While we are comparing to Python – an excellent language – note that there is
    a significant difference in each language’s compiler. The Java compiler can incrementally
    compile a program. The editor in an IDE can detect errors while you type by compiling
    the code one line at a time. Languages with no incremental compiler, such as Python,
    can only report errors in an IDE when you compile or run the code.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们与 Python – 一种优秀的语言 – 进行比较时，请注意每种语言的编译器之间存在着显著差异。Java 编译器可以增量编译程序。IDE 中的编辑器可以通过逐行编译代码来检测你在输入时的错误。没有增量编译器的语言，如
    Python，只能在 IDE 中编译或运行代码时报告错误。
- en: Which approach is better? I leave that up to you to decide.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 哪种方法更好？这由你决定。
- en: However, static typing leads to more verbose programs. This means you must enter
    more code in a Java program compared to Python. On the other hand, static typing
    makes tracking down type errors easier and enhances the readability of the code.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，静态类型会导致程序更加冗长。这意味着与 Python 相比，你必须在 Java 程序中输入更多的代码。另一方面，静态类型使得追踪类型错误更加容易，并增强了代码的可读性。
- en: One last point about Python – in version 3, the language developers introduced
    type annotations. These appear in Python code as if you are statically typing
    a variable. But this is not the case, as the compiler ignores these annotations.
    They exist to support type checkers, such as what the **PyCharm** IDE can do.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 关于 Python 的最后一个要点 – 在 3.0 版本中，语言开发者引入了类型注解。这些注解在 Python 代码中看起来就像你在静态类型一个变量一样。但这并不是真的，因为编译器会忽略这些注解。它们的存在是为了支持类型检查器，例如
    **PyCharm** IDE 可以做到的。
- en: Before we look at the data types we use when declaring variables, let us take
    a moment to look at literal values.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们查看声明变量时使用的数据类型之前，让我们花一点时间看看文字值。
- en: Literal values
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 文字值
- en: A `42`, Java treats this as an integer. Should the literal value exceed the
    range of an integer when assigned to an integer, you will get an `integer number
    to large` compiler error. If you assign the literal value to a `long` integer,
    you must add the letter `L` to the number, such as `14960000000000L`.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: Java 将 `42` 视为一个整数。如果将文字值赋给整数时超过了整数的范围，你将得到一个 `integer number to large` 编译器错误。如果你将文字值赋给
    `long` 整数，必须在数字后添加字母 `L`，例如 `14960000000000L`。
- en: When we write large numbers, we frequently use a separator every three digits
    to improve legibility. If you want a separator to make the source code easier
    to read, you can only use the underscore. You cannot use a comma or any other
    character as a separator. The value `14960000000000L` can be entered as `14_960_000_000_000L`.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们书写大数字时，我们经常每三位数字使用一个分隔符来提高可读性。如果你想使用分隔符使源代码更容易阅读，你只能使用下划线。你不能使用逗号或其他任何字符作为分隔符。值`14960000000000L`可以输入为`14_960_000_000_000L`。
- en: 'When working with literal floating-point numbers, the default primitive type
    is double. If you are assigning a literal double that does not have any decimal
    places, then add one, rather than adding it like so:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 当处理字面浮点数时，默认的原始类型是double。如果你正在分配一个没有小数位的字面double值，那么添加一个，而不是像这样添加：
- en: '[PRE6]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Enter it in the following manner:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 按以下方式输入：
- en: '[PRE7]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Alternatively, you could use the suffix `D` for double and `F` for float. You
    can write all literal suffixes in upper or lowercase, as shown here:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，你可以使用后缀`D`表示double和`F`表示float。你可以像这里一样用大写或小写写所有字面后缀：
- en: '[PRE8]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Now, let us move on to the primitive data types.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们继续讨论原始数据类型。
- en: Integers
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 整数
- en: There are four members of the integer family – `byte`, `short`, `int`, and `long`.
    The difference is the number of bytes they use to contain a value. Java, like
    most languages, encodes integers using two’s complement. This means that the range
    of values for any of the integer types goes from negative to positive values.
    Like Python, Java does not have unsigned integers, while C, C++, and C# do.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 整数家族有四个成员 – `byte`、`short`、`int`和`long`。它们之间的区别是它们用来存储值的字节数。Java，像大多数语言一样，使用二进制补码来编码整数。这意味着任何整数类型的值范围从负值到正值。像Python一样，Java没有无符号整数，而C、C++和C#有。
- en: 'In the following table, you will find the size in bytes, the allowable range,
    and how to declare, assign, or declare and initialize all the members of the integer
    family:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的表中，你可以找到大小（以字节为单位）、允许的范围以及如何声明、分配或声明和初始化整数家族的所有成员：
- en: '![Table 4.1 – Specs for integers and how we can use them'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '![表4.1 – 整数规格及其使用方法](img/Table_4.1_B19088.jpg)'
- en: '](img/Table_4.1_B19088.jpg)'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Table_4.1_B19088.jpg)'
- en: Table 4.1 – Specs for integers and how we can use them
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 表4.1 – 整数规格及其使用方法
- en: The integer data type on most computers is related to the size of a CPU’s registers.
    The JVM is a 32-bit virtual machine, meaning that its registers are 32 bits or
    4 bytes wide. While the JVM program is implemented as a 64-bit application, it
    remains an implementation of a 32-bit computer.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数计算机上的整数数据类型与CPU寄存器的大小有关。JVM是一个32位虚拟机，这意味着它的寄存器是32位或4字节宽。虽然JVM程序被实现为一个64位应用程序，但它仍然是32位计算机的实现。
- en: Floating point
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 浮点数
- en: Like most languages, Java uses a subset of the **IEEE standard binary floating-point
    numbers** to represent a floating-point value in memory. In the *Further reading*
    section, you can find links to websites that delve into this physical format.
    From our perspective, the main interest we have is in accuracy.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 与大多数语言一样，Java使用IEEE标准二进制浮点数的一个子集来在内存中表示浮点值。在*进一步阅读*部分，你可以找到深入探讨这种物理格式的网站链接。从我们的角度来看，我们主要感兴趣的是精度。
- en: Accuracy is defined as representing a value exactly. We describe integers as
    accurate because every decimal integer number can be converted into a binary number.
    We call the conversion a **lossless conversion**.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 精度定义为精确表示一个值。我们称整数是精确的，因为每个十进制整数都可以转换成二进制数。我们称这种转换为一个**无损转换**。
- en: Not all decimal floating-point values map to a fixed-length binary value, though.
    One of the best examples is 0.1 in decimal. This is 1 divided by 10\. If we divide
    binary 1 (1) by binary 10 (1010), the result will be an infinitely repeating sequence
    of 0.00110011001100110011 . . . What this means is that floating point does not
    have the same accuracy as integers. The IEEE 754 standard deals with this issue,
    but you must always know that floating-point values are approximations. We call
    this a `float` and `double`. The measure of accuracy when we convert from decimal
    to binary floating point and back is referred to as the precision of the result.
    If a number exceeds the precision, it is considered an approximation of the actual
    result.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 并非所有十进制浮点值都能映射到固定长度的二进制值。最好的例子是十进制中的0.1。这是10除以1。如果我们用二进制的1（1）除以二进制的10（1010），结果将是一个无限重复的序列0.00110011001100110011……这意味着浮点数没有整数那样的精度。IEEE
    754标准处理这个问题，但你必须始终知道浮点值是近似值。我们称之为`float`和`double`。从十进制到二进制浮点数以及返回的精度称为结果的精度。如果一个数字超过了精度，它被认为是实际结果的近似值。
- en: 'In the following table, you will find the size in bytes, the allowable range,
    and how to declare, assign, or declare and initialize all the members of the floating-point
    family. This information is critical in deciding whether to use double or float:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下表中，你可以找到大小（以字节为单位）、允许的范围以及如何声明、分配或声明并初始化浮点数家族的所有成员。这些信息对于决定是否使用双精度浮点数或浮点数至关重要：
- en: '![Table 4.2 – Specs for floating point and how we can use it'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '![Table_4.2 – Specs for floating point and how we can use it](img/Table_4.2_B19088.jpg)'
- en: '](img/Table_4.2_B19088.jpg)'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '![Table_4.2_B19088.jpg](img/Table_4.2_B19088.jpg)'
- en: Table 4.2 – Specs for floating point and how we can use it
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 表4.2 – 浮点数规格及其使用方法
- en: We usually interpret precision as the number of valid numbers to the right of
    the decimal place. Float uses 23 bits, and double uses 53 bits. Therefore, thinking
    in terms of the number of digits is a crude way to define precision; it is about
    the length of the mantissa as per the IEEE 754 standard. Simply put, doubles,
    by virtue of their larger mantissa, have a larger range of values and a higher
    level of precision than float.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通常将精度解释为小数点右边有效数字的数量。浮点数使用23位，双精度浮点数使用53位。因此，从数字的位数来定义精度是一种粗略的方法；根据IEEE 754标准，它是指尾数的长度。简单来说，由于双精度浮点数的尾数更长，所以它具有更大的值域和更高的精度，比浮点数要高。
- en: You may now think you should only be using double rather than using float. After
    all, we all want our results to be as accurate as possible. But the fact that
    doubles are twice the size in bytes, 64 as opposed to 32, has a performance penalty.
    In deciding whether to use double or float, consider the range of values and the
    precision required. For example, the float will be sufficient if the range of
    values is small and the number of decimal places after the decimal point will
    never exceed approximately six. The math operations you may perform will also
    influence your choice. Addition and subtraction are not concerns, but multiplication
    and division may have an impact.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在可能认为你应该只使用双精度浮点数而不是使用浮点数。毕竟，我们都希望我们的结果尽可能准确。但双精度浮点数在字节大小上是浮点数的两倍，64位而不是32位，这会有性能损失。在决定是否使用双精度浮点数或浮点数时，考虑值域和所需的精度。例如，如果值域较小，小数点后的位数永远不会超过大约六位，那么浮点数就足够了。你可能会进行的数学运算也会影响你的选择。加法和减法不是问题，但乘法和除法可能会有影响。
- en: The Java compiler can recognize when you assign a floating-point value to an
    integer variable. You will get a possible lossy conversion from `double` to `int`
    error if you do. Later in this chapter, we will look at casting to convert from
    one numeric data type to another.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: Java编译器可以识别当你将浮点值分配给整型变量时。如果你这样做，你会得到从`double`到`int`的可能丢失转换错误。在本章的后面部分，我们将探讨类型转换，以将一个数值数据类型转换为另一个。
- en: We are now finished with the numeric types – integers and floating points. Now,
    let’s look at the non-numeric types.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经完成了数值类型——整数和浮点数。现在，让我们看看非数值类型。
- en: Boolean
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 布尔
- en: The `false` and one means `true`. In Java, the set of values that you can assign
    to a Boolean is the `true` and `false` keywords. The result of all logical operations,
    such as *Is x greater than y?*, expressed as `x > y`, always returns a Boolean
    value.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '`false`和1表示`true`。在Java中，你可以分配给布尔值的集合是`true`和`false`关键字。所有逻辑运算的结果，例如*“x是否大于y”？*，用`x
    > y`表示，总是返回一个布尔值。'
- en: In Python, you can cast an integer to or from a Boolean value. The C language
    does not have a Boolean type, so the language uses the integer values of zero
    for `false` and not zero for `true`. C++ has a Boolean type, but it is just a
    subset of integers with the zero and one values represented by the `true` and
    `false` keywords. C++ treats integers as Booleans, the same way C does.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Python 中，你可以将整数强制转换为布尔值或将布尔值强制转换为整数。C 语言没有布尔类型，因此该语言使用零表示 `false` 和非零表示 `true`。C++
    有布尔类型，但它只是整数的一个子集，其中零和一分别由 `true` 和 `false` 关键字表示。C++ 将整数视为布尔值，与 C 的处理方式相同。
- en: In Java, a Boolean is a distinct type. You cannot use an integer in place of
    either `true` or `false`. This means you cannot use the result of a calculation
    that may be either zero or not zero, where you require a Boolean type.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Java 中，布尔是一个独立的数据类型。你不能用整数代替 `true` 或 `false`。这意味着你不能使用可能为零或非零的计算结果，其中你需要布尔类型。
- en: 'In the following table, you will find the set of allowable values and how to
    declare, assign, declare, and initialize Booleans. Technically, you only need
    a single bit to represent `true` or `false`. However, there is no machine language
    or bytecode instruction that can read just one bit. The Java language architects
    have left the size in bytes of a Boolean up to the specific implementation of
    Java:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下表中，你可以找到允许的值集合以及如何声明、赋值、声明和初始化布尔值。技术上，你只需要一个位来表示 `true` 或 `false`。然而，没有机器语言或字节码指令可以读取单个位。Java
    语言架构师将布尔类型的字节大小留给了 Java 的具体实现：
- en: '![Table 4.3 – Specs for Boolean and how we can use it'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '![表 4.3 – 布尔类型的规格及其使用方法'
- en: '](img/Table_4.3_B19088.jpg)'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/Table_4.3_B19088.jpg]'
- en: Table 4.3 – Specs for Boolean and how we can use it
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 表 4.3 – 布尔类型的规格及其使用方法
- en: The CPU retrieves data from memory in units of bytes, typically 4 bytes at a
    time, as this is the word size of the CPU. It cannot directly read a single bit
    in RAM. Once retrieved and stored in a CPU register, the CPU can determine the
    state of any bit in a byte. This means that a Boolean can be no smaller than a
    byte. Java does not define the number of bytes the same way integers and floating
    points are. The number of bytes a Boolean uses depends on the implementation of
    the virtual machine. This can mean that the implementation of Java by one organization
    may use a different number of bytes compared to another.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: CPU 以字节为单位从内存中检索数据，通常是每次 4 个字节，因为这通常是 CPU 的字大小。它不能直接读取 RAM 中的单个位。一旦检索并存储在 CPU
    寄存器中，CPU 就可以确定字节中任何位的状态。这意味着布尔值不能小于一个字节。Java 没有像整数和浮点数那样定义字节的大小。布尔值使用的字节数取决于虚拟机的实现。这意味着一个组织对
    Java 的实现可能使用的字节数与另一个组织不同。
- en: Booleans are at the heart of decision-making and iteration for many organizations.
    Now, let’s move on to the data type used to represent the characters of our written
    language.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 布尔值是许多组织决策和迭代的核心。现在，让我们继续了解用于表示我们书面语言字符的数据类型。
- en: char
  id: totrans-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`char`'
- en: The `char` data type contains the numeric value for 2-byte Unicode characters.
    Unicode UTF-8 is a variable-length character encoding from 2 to 4 bytes per character.
    Currently, Java only supports 2-byte encoding. The first 128 characters are identical
    to the first 128 characters found in ASCII encoding.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '`char` 数据类型包含 2 字节 Unicode 字符的数值。Unicode UTF-8 是一种可变长度的字符编码，每个字符占用 2 到 4 个字节。目前，Java
    只支持 2 字节编码。前 128 个字符与 ASCII 编码中的前 128 个字符相同。'
- en: In C and C++, a char is a subset of integers, and you can use it as an integer.
    Python does not have a character type but uses strings with a length of 1 for
    a single character. In Java, a char is a unique data type; you cannot use it for
    an integer as C and C++ allow. You can cast a `char` to an integer or cast an
    integer to a char.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在 C 和 C++ 中，`char` 是整数的一个子集，你可以将其用作整数。Python 没有字符类型，但使用长度为 1 的字符串来表示单个字符。在 Java
    中，`char` 是一个独特的数据类型；你不能像 C 和 C++ 那样将其用作整数。你可以将 `char` 强制转换为整数或将整数强制转换为 `char`。
- en: Take note that a single quotation mark around a single character implies a char.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，单个字符周围的单引号表示一个 `char`。
- en: 'In the following table, you will find the set of allowable values and how to
    declare, assign, or declare and initialize a char:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下表中，你可以找到允许的值集合以及如何声明、赋值或声明并初始化 `char`：
- en: '![Table 4.4 – Specs for char and how we can use it'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '![表 4.4 – `char` 的规格及其使用方法'
- en: '](img/Table_4.4_B19088.jpg)'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/Table_4.4_B19088.jpg]'
- en: Table 4.4 – Specs for char and how we can use it
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 表 4.4 – `char` 的规格及其使用方法
- en: 'There is one more table to look at and that is the default value assigned to
    variables that are not initialized when declared. Variables can be declared as
    fields in a class or as local variables in a method. Here are the default values
    for fields:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 还有另一个表格需要查看，那就是在声明时未初始化的变量的默认值。变量可以作为类中的字段或作为方法中的局部变量声明。以下是字段的默认值：
- en: '| **Type** | **Default value** |'
  id: totrans-97
  prefs: []
  type: TYPE_TB
  zh: '| **类型** | **默认值** |'
- en: '| `boolean` | `false` |'
  id: totrans-98
  prefs: []
  type: TYPE_TB
  zh: '| `boolean` | `false` |'
- en: '| `byte` | 0 |'
  id: totrans-99
  prefs: []
  type: TYPE_TB
  zh: '| `byte` | 0 |'
- en: '| `short` | 0 |'
  id: totrans-100
  prefs: []
  type: TYPE_TB
  zh: '| `short` | 0 |'
- en: '| `int` | 0 |'
  id: totrans-101
  prefs: []
  type: TYPE_TB
  zh: '| `int` | 0 |'
- en: '| `long` | 0 |'
  id: totrans-102
  prefs: []
  type: TYPE_TB
  zh: '| `long` | 0 |'
- en: '| `float` | 0.0f |'
  id: totrans-103
  prefs: []
  type: TYPE_TB
  zh: '| `float` | 0.0f |'
- en: '| `double` | 0.0d |'
  id: totrans-104
  prefs: []
  type: TYPE_TB
  zh: '| `double` | 0.0d |'
- en: '| `char` | \u0000 (Unicode equivalent to null) |'
  id: totrans-105
  prefs: []
  type: TYPE_TB
  zh: '| `char` | \u0000（Unicode等效于null）|'
- en: '| Reference to objects | null |'
  id: totrans-106
  prefs: []
  type: TYPE_TB
  zh: '| 对象引用 | null |'
- en: Table 4.5 – Default values for fields
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 表4.5 – 字段默认值
- en: There is no default value for variables declared in a method. Any code that
    tries to read a local variable that has not been assigned an initial value will
    result in a compile-time error.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在方法中声明的变量没有默认值。任何尝试读取未分配初始值的局部变量的代码都会导致编译时错误。
- en: We have now gone over the eight primitive types. There is one more type that
    you can use, similar to a primitive, but it is not primitive. Let’s meet `String`.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经介绍了八个原始类型，还有一个特殊类型可以使用，类似于原始类型，但它不是原始类型。让我们来认识一下`String`。
- en: A special case – String
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 特殊情况 - 字符串
- en: A string, with a *lowercase s*, is a list of characters that usually represent
    a word we may write or speak. `String`, with a *capital S*, is a class that contains
    a list of zero or more characters and numerous operations that you can perform
    on them. As a class, it normally must be instantiated into an object. As developers
    commonly use `String` objects, Java can perform the instantiation implicitly whenever
    you use the assignment operator (`=`) with a `String` variable. When referring
    to this data type, we always capitalize the first letter. This way, we know that
    we are referring to the `String` class. We will cover classes and objects in more
    depth in the coming chapter.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串，小写`s`，是一系列字符，通常代表我们可以书写或说出的单词。`String`，大写`S`，是一个包含零个或多个字符并可以对其执行许多操作的类。作为一个类，它通常必须实例化为一个对象。由于开发人员经常使用`String`对象，Java可以在使用赋值运算符（`=`）与`String`变量赋值时隐式地实例化它。当我们引用这种数据类型时，我们总是将第一个字母大写。这样，我们知道我们正在引用`String`类。我们将在下一章更深入地介绍类和对象。
- en: 'Let us examine `String` and how we use it. We begin with the specification
    table:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考察`String`及其使用方法。我们首先从规范表开始：
- en: '![Table 4.6 – Specs for String and how we can use it'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '![Table 4.6 – Specs for String and how we can use it](img/Table_4.6_B19088.jpg)'
- en: '](img/Table_4.6_B19088.jpg)'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '![Table 4.6 – Specs for String and how we can use it](img/Table_4.6_B19088.jpg)'
- en: Table 4.6 – Specs for String and how we can use it
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 表4.6 – 字符串规范及其使用方法
- en: In this table, `String`. The first, called a `String` object. A reference is
    like a pointer in other languages, but you cannot manipulate it as you can in
    C or C++. The **length** of this object in memory includes overhead for the object
    in addition to the characters in the actual text you are storing.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在此表中，`String`。第一个，称为`String`对象。引用类似于其他语言中的指针，但你不能像在C或C++中那样操作它。此对象在内存中的长度包括对象开销以及你实际存储的文本中的字符。
- en: Classes become objects in memory by using the `new` operator in Java, as shown
    in the previous table. Developers use `String` objects frequently, and Java simplifies
    its usage by implicitly instantiating it when assigned a value. You can use `new`
    as shown, but this is rarely written this way. Instead, `String` appears to work
    like a primitive value for the convenience of programmers.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java中，通过使用`new`运算符，类在内存中成为对象，如前表所示。开发人员经常使用`String`对象，Java通过在赋值时隐式实例化它来简化其使用。你可以像这样使用`new`，但很少这样写。相反，`String`似乎像原始值一样工作，以方便程序员。
- en: With the eight primitive types defined along with the one special case, we can
    now move on to how we can use them in our code.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在定义了八个原始类型和一个特殊案例之后，我们现在可以继续探讨如何在我们的代码中使用它们。
- en: Naming identifiers
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 标识符命名
- en: An **identifier** in any language is simply the name we assign to a variable,
    class, or method. We will first focus on naming variables, and in [*Chapter 5*](B19088_05.xhtml#_idTextAnchor106),
    *Language Fundamentals – Classes*, we will look at naming classes and methods.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 任何语言中的**标识符**只是我们分配给变量、类或方法的名称。我们首先将关注命名变量，在[*第五章*](B19088_05.xhtml#_idTextAnchor106)“语言基础
    - 类”，我们将探讨命名类和方法。
- en: 'There are very few rules in Java related to naming identifiers, but for those
    that are, the compiler enforces them. These are as follows:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: Java关于标识符命名的规则非常少，但对于那些有的规则，编译器会强制执行。这些规则如下：
- en: 'The first character of an identifier can be one of the following:'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标识符的第一个字符可以是以下之一：
- en: Dollar sign (`$`)
  id: totrans-123
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 美元符号 (`$`)
- en: Underscore (`_`)
  id: totrans-124
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 下划线 (`_`)
- en: Alpha character (`A`–`Z`, `a`–`z`)
  id: totrans-125
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: Alpha 字符 (`A`–`Z`, `a`–`z`)
- en: Subsequent characters can be any of the previously mentioned ones and numbers.
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 后续字符可以是之前提到的任何字符和数字。
- en: 'Once you adhere to the rules, the choice of naming is up to you. This is because
    Java has conventions for naming. A convention is not a rule, and the compiler
    does not validate them. Instead, conventions are techniques the programming community
    recommends for a given language. While working in a team, your fellow members
    expect you to follow these conventions. Here are the conventions for naming variables:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你遵守了规则，命名选择就取决于你了。这是因为 Java 有命名约定。约定不是规则，编译器不会验证它们。相反，约定是编程社区为特定语言推荐的技术。在团队工作中，你的同事期望你遵循这些约定。以下是命名变量的约定：
- en: The name of a variable should be a noun; variables are things and not actions.
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 变量的名称应该是名词；变量是事物而不是动作。
- en: The first character should be lowercase. The convention for class identifiers
    requires that its first character be a capital letter.
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一个字符应该是小写字母。对于类标识符的约定要求其第一个字符为大写字母。
- en: When using a name made up of more than one word, use camel case. Each word in
    the identifier should be lowercase except for the first character. Each subsequent
    word in the identifier after the first word must begin with a capital letter.
    It is acceptable if you prefer using the underscore to represent a space in a
    multi-word identifier rather than camel case. For this usage, all characters should
    be lowercase.
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当使用由多个单词组成的名称时，使用驼峰式命名。标识符中的每个单词应该小写，除了第一个单词的首字母。标识符中第一个单词之后的每个后续单词必须以大写字母开头。如果你更喜欢使用下划线在多单词标识符中表示空格而不是驼峰式命名，这是可以接受的。对于这种用法，所有字符都应该小写。
- en: Do not use abbreviations; use whole words.
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不要使用缩写；使用完整的单词。
- en: Avoid single-character identifiers. There are a limited number of cases where
    a single character is acceptable, such as for a loop index variable. Otherwise,
    use meaningful names.
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 避免使用单字符标识符。在有限的情况下，单字符是可接受的，例如用于循环索引变量。否则，使用有意义的名称。
- en: 'This table describes the naming conventions for a variable:'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 此表描述了变量的命名约定：
- en: '| **Convention** | **Acceptable** | **Unacceptable** |'
  id: totrans-134
  prefs: []
  type: TYPE_TB
  zh: '| **约定** | **可接受** | **不可接受** |'
- en: '| Noun | `double salary;` | `double receive;` |'
  id: totrans-135
  prefs: []
  type: TYPE_TB
  zh: '| 名词 | `double salary;` | `double receive;` |'
- en: '| First character lowercase | `int cars;` | `int Cars;` |'
  id: totrans-136
  prefs: []
  type: TYPE_TB
  zh: '| 第一个字符小写 | `int cars;` | `int Cars;` |'
- en: '| Camel case | `int platesOfPasta;` | `int platesofpasta;` |'
  id: totrans-137
  prefs: []
  type: TYPE_TB
  zh: '| 驼峰式命名 | `int platesOfPasta;` | `int platesofpasta;` |'
- en: '| Underscore separator | `int plates_of_pasta;` | `int plates_Of_Pasta;` |'
  id: totrans-138
  prefs: []
  type: TYPE_TB
  zh: '| 下划线分隔符 | `int plates_of_pasta;` | `int plates_Of_Pasta;` |'
- en: '| Abbreviations | Never acceptable | `int lol;` representing layers of lacquer
    |'
  id: totrans-139
  prefs: []
  type: TYPE_TB
  zh: '| 缩写 | 从不接受 | `int lol;` 代表清漆层 |'
- en: Table 4.7 – Naming conventions
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 表 4.7 – 命名约定
- en: You should not use the dollar sign; the compiler uses it to create identifiers.
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你不应该使用美元符号；编译器使用它来创建标识符。
- en: You should not use the underscore as the first character as in other languages,
    such as C++, because it means the same as the dollar sign as the first character
    in Java.
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你不应该像其他语言（如 C++）那样将下划线用作第一个字符，因为在 Java 中，它和美元符号作为第一个字符的含义相同。
- en: Once past the first character, you can use any letter of the alphabet, any number,
    an underscore, or the dollar sign.
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一旦超过第一个字符，你可以使用字母表中的任何字母、任何数字、下划线或美元符号。
- en: 'Now let us look at the length of identifiers compared to other languages in
    the following table:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看看以下表格中标识符长度与其他语言的比较：
- en: '| **Language** | **Maximum # of** **significant characters** |'
  id: totrans-145
  prefs: []
  type: TYPE_TB
  zh: '| **语言** | **最大有效字符数** |'
- en: '| Python | 79 |'
  id: totrans-146
  prefs: []
  type: TYPE_TB
  zh: '| Python | 79 |'
- en: '| Standard C | 31 |'
  id: totrans-147
  prefs: []
  type: TYPE_TB
  zh: '| 标准C | 31 |'
- en: '| Standard C++ | 1,024 |'
  id: totrans-148
  prefs: []
  type: TYPE_TB
  zh: '| 标准C++ | 1,024 |'
- en: '| Microsoft C++ | 2,048 |'
  id: totrans-149
  prefs: []
  type: TYPE_TB
  zh: '| 微软 C++ | 2,048 |'
- en: '| GNU C++ | Unlimited |'
  id: totrans-150
  prefs: []
  type: TYPE_TB
  zh: '| GNU C++ | 无限制 |'
- en: '| Java | Unlimited |'
  id: totrans-151
  prefs: []
  type: TYPE_TB
  zh: '| Java | 无限制 |'
- en: Table 4.8 – Maximum length of identifiers
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 表 4.8 – 标识符最大长度
- en: While Java and **GNU C++** have no restriction on the number of characters in
    the name of an identifier, you should be reasonable in the number of characters
    you use.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 Java 和 **GNU C++** 对标识符名称中的字符数没有限制，但你应该合理地使用字符数。
- en: Coming up with a meaningful name for identifiers is an important task for making
    your code readable, so give it some thought. Now, let us look at data that, once
    assigned a value, cannot be changed.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 为标识符想出一个有意义的名字是使你的代码可读的重要任务，所以请多加思考。现在，让我们看看一旦赋值后就不能更改的数据。
- en: Constants
  id: totrans-155
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 常量
- en: A constant can be any data type declared with the `final` keyword. It must have
    a value assigned when declared, for example, `final double TAX_RATE =` `0.05;`.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 常量可以是使用`final`关键字声明的任何数据类型。它必须在声明时赋值，例如，`final double TAX_RATE =` `0.05;`。
- en: If you declare a field in a class as `final`, then you may also assign its value
    in the class constructor. Once a value is assigned to a constant, however, it
    cannot be changed.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在一个类的字段中声明为`final`，那么你还可以在类构造函数中为其赋值。然而，一旦常量被赋值，它的值就不能更改。
- en: The naming rules for constants are the same as identifiers. What differs are
    the conventions. Constants are nouns written in uppercase. You can use the underscore
    to separate words in the identifier, as shown in `TAX_RATE` in the previous example.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 常量的命名规则与标识符相同。不同的是约定。常量是使用大写字母书写的名词。你可以在标识符中用下划线分隔单词，如前例中的`TAX_RATE`所示。
- en: Operators
  id: totrans-159
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 运算符
- en: 'Java supports the common set of operators found in almost every language, as
    shown in the following table:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: Java支持几乎在每种语言中都找到的常见运算符集合，如下表所示：
- en: '| **Action** | **Operator** | **Assignment** |'
  id: totrans-161
  prefs: []
  type: TYPE_TB
  zh: '| **操作** | **运算符** | **赋值** |'
- en: '| Addition | x = x + y | x += y |'
  id: totrans-162
  prefs: []
  type: TYPE_TB
  zh: '| 加法 | x = x + y | x += y |'
- en: '| Subtraction | x = x – y | x -= y |'
  id: totrans-163
  prefs: []
  type: TYPE_TB
  zh: '| 减法 | x = x – y | x -= y |'
- en: '| Multiplication | x = x * y | x *= y |'
  id: totrans-164
  prefs: []
  type: TYPE_TB
  zh: '| 乘法 | x = x * y | x *= y |'
- en: '| Division | x = x / y | x /= y |'
  id: totrans-165
  prefs: []
  type: TYPE_TB
  zh: '| 除法 | x = x / y | x /= y |'
- en: '| Modulus (remainder) | x = x % y | x %= y |'
  id: totrans-166
  prefs: []
  type: TYPE_TB
  zh: '| 取模（余数） | x = x % y | x %= y |'
- en: '| Increment | ++x or x++ | N/A |'
  id: totrans-167
  prefs: []
  type: TYPE_TB
  zh: '| 增量 | ++x 或 x++ | N/A |'
- en: '| Decrement | --x or x-- | N/A |'
  id: totrans-168
  prefs: []
  type: TYPE_TB
  zh: '| 减量 | --x 或 x-- | N/A |'
- en: Table 4.9 – Basic math operators
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 表4.9 – 基本数学运算符
- en: Java follows the standard rules of precedence, except for the increment and
    decrement operators. If the operator is on the left-hand side of the variable,
    then Java conducts the operation before any other. This, technically, gives it
    the highest precedence. Placed on the right-hand side, it has the lowest precedence,
    and Java performs it after all other operations are complete. We will review the
    logical operators when we look at logical operations in the next chapter.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: Java遵循标准的优先级规则，除了增量或减量运算符。如果运算符在变量的左侧，那么Java会在其他任何操作之前执行该操作。技术上，这给了它最高的优先级。放在右侧，它具有最低的优先级，Java会在所有其他操作完成后执行它。我们将在下一章讨论逻辑运算时回顾逻辑运算符。
- en: String operator
  id: totrans-171
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 字符串运算符
- en: '`String` does not have a numeric value, and you cannot use a `String` object
    in a calculation. As you would expect, `int numberOfDogs = 23;` does not mean
    the same as `String numberOfDogs = "``23 ";`.'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '`String`没有数值，你不能在计算中使用`String`对象。正如你所期望的，`int numberOfDogs = 23;`并不意味着与`String
    numberOfDogs = "``23 ";`相同。'
- en: You cannot use a `String` variable in an arithmetic expression. If the characters
    in `String` match what is allowable for a number, then you must convert `String`
    into a numeric variable first and then use it in an arithmetic expression.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 你不能在算术表达式中使用`String`变量。如果`String`中的字符与数字允许的字符匹配，那么你必须先将`String`转换为数字变量，然后再在算术表达式中使用它。
- en: 'However, the plus (`+`) operator is permitted along with `String`. When used
    with `String`, it means to concatenate or join multiple `String` values into one,
    as shown here:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，加号（`+`）运算符与`String`一起使用是被允许的。当与`String`一起使用时，它意味着将多个`String`值连接或合并为一个，如下所示：
- en: '[PRE9]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'You can also use concatenation to combine `String` with any of the eight primitive
    types. This will automatically convert the primitive to `String`, as shown here:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以使用连接将`String`与任何八个原始数据类型结合。这将自动将原始数据类型转换为`String`，如下所示：
- en: '[PRE10]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The `String` message will contain the following:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '`String`消息将包含以下内容：'
- en: '[PRE11]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'You cannot assign a numeric type directly to `String`. You must concatenate
    it to `String` or use the `String.valueOf` method; it is a simpler approach. Concatenating
    a primitive to any string, such as the empty String shown here, will work:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 你不能直接将数字类型赋值给`String`。你必须将它连接到`String`或使用`String.valueOf`方法；这是一个更简单的方法。将原始数据类型连接到任何字符串，例如这里显示的空字符串，将有效：
- en: '[PRE12]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Alternatively, you can use the following:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，你也可以使用以下方法：
- en: '[PRE13]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Where you see the literal values, you can also use a primitive, as shown here:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 在你看到字面值的地方，你也可以使用原始数据类型，如下所示：
- en: '[PRE14]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: There is just one operator you can use with String, which is for concatenation
    rather than a mathematical function.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以用一个操作符与String一起使用，那就是用于连接而不是数学函数。
- en: Casting
  id: totrans-187
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 类型转换
- en: 'Casting provides the ability to cast or convert one data type to another. When
    coding with primitives, there are two types of casting – implicit and explicit.
    First, look at this chart, which shows the primitives by order of their range
    of values:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 类型转换提供了一种将一种数据类型转换为另一种数据类型的能力。当使用原始数据类型编码时，有两种类型的类型转换 – 隐式和显式。首先，看看这个图表，它按值范围顺序显示了原始数据类型：
- en: '| **Largest** |  |  |  |  | **Smallest** |'
  id: totrans-189
  prefs: []
  type: TYPE_TB
  zh: '| **最大值** |  |  |  |  | **最小值** |'
- en: '| `double` | `float` | `long` | `int` | `short` | `byte` |'
  id: totrans-190
  prefs: []
  type: TYPE_TB
  zh: '| `double` | `float` | `long` | `int` | `short` | `byte` |'
- en: Table 4.10 – Relative number of bytes between types
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 表4.10 – 类型之间的相对字节数
- en: 'What this means is that when assigning a primitive of one type on the chart
    to a primitive higher on the chart, Java will perform an implicit cast, as shown
    here:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着当将图表中的一种类型的原始数据类型赋值给图表中更高类型的原始数据类型时，Java将执行隐式转换，如下所示：
- en: '[PRE15]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'This is a lossless conversion. You may try the assignment in the other direction,
    as follows:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个无损转换。你可以尝试反向赋值，如下所示：
- en: '[PRE16]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'You will get the following error:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 你将得到以下错误：
- en: '[PRE17]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'If you need to convert from a data type larger than the data type of the destination
    variable, you must do an explicit cast. For example, when converting from a floating
    point to an integer, Java will cut the fractional component. No rounding; it just
    disappears, as shown here:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要将一个大于目标变量数据类型的值转换，你必须进行显式转换。例如，当从浮点数转换为整数时，Java将截断小数部分。没有四舍五入；它只是消失，如下所示：
- en: '[PRE18]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: With casting, there is no error, but the value in `fruit` will be `34`.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 使用类型转换时没有错误，但`fruit`中的值将是`34`。
- en: 'If the value on the right-hand side exceeds the range of the type you are casting
    to, when it is an integer type, then, like an **overflow**, discussed in the next
    section, it will wrap around, as shown here:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 如果右侧的值超出了你要转换到的类型的范围，当它是一个整型时，就像下一节中讨论的溢出一样，它将回绕，如下所示：
- en: '[PRE19]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The value in `fruit` will be `1464`.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '`fruit`中的值将是`1464`。'
- en: The syntax for casting Java places the type to cast in parentheses. Python,
    C, and C++ are cast by placing the value in parentheses, while C# follows the
    same model as Java.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: Java类型转换的语法是将要转换的类型放在括号内。Python、C和C++通过将值放在括号内进行转换，而C#遵循与Java相同的模式。
- en: In *Table 4.10*, you did not see the `char` type. Its sole purpose in the language
    is to represent a UTF-8 code that Java will render as a character on the screen.
    You can assign a character to a `char` variable, or you can assign an integer.
    If the integer you assign is outside the allowable range, then you will need to
    cast, and an overflow wrap will occur.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 在*表4.10*中，你没有看到`char`类型。在语言中，它的唯一目的是表示Java将渲染为屏幕上的字符的UTF-8代码。你可以将一个字符赋给`char`变量，或者你可以赋一个整数。如果你赋的整数超出了允许的范围，那么你需要进行类型转换，并且会发生溢出回绕。
- en: 'Here are some examples of declaring a `char` variable:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一些声明`char`变量的例子：
- en: '[PRE20]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: All three of these will become the letter `A`.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 这三个都会变成字母`A`。
- en: We have seen that promotion occurs implicitly, moving from one data type to
    another data type higher on the chart. To move in the other direction, you must
    cast.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到，提升（promotion）是隐式发生的，从图表中的一个数据类型移动到另一个范围更高的数据类型。要向相反方向移动，你必须进行类型转换。
- en: Overflow and underflow
  id: totrans-210
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 溢出和下溢
- en: An overflow and an **underflow** can occur when working with floating-point
    types. Only an overflow can occur with integer and char types. Here is how Java
    behaves in these situations.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 当处理浮点类型时，可能会发生溢出和下溢。只有整数和`char`类型可能会发生溢出。以下是Java在这些情况下的行为。
- en: Integer overflow
  id: totrans-212
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 整数溢出
- en: An overflow occurs when a value is outside the range of allowable values. For
    floating-point values, an overflow results in the special value infinity, and
    either plus or minus is the result.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个值超出允许值的范围时，会发生溢出。对于浮点值，溢出会导致特殊值无穷大，结果可以是正无穷或负无穷。
- en: 'Overflow with integers results in a wraparound. For example, in the following
    code snippet, we are assigning a value to a short data type. This value is 1 greater
    than the allowable upper range of `short`:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 整数溢出会导致回绕。例如，在下面的代码片段中，我们正在将一个值赋给一个短整型数据类型。这个值比`short`的可允许的上限大1：
- en: '[PRE21]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The following is the output of this code fragment:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的代码片段是这段代码的输出：
- en: '[PRE22]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Floating-point overflow
  id: totrans-218
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 浮点数溢出
- en: Unlike the integer types, floating-point types do not wrap when overflow occurs.
    Instead, Java assigns the special value `Infinity`.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 与整型不同，浮点型在溢出时不会回绕。相反，Java 赋予特殊的值 `Infinity`。
- en: 'Using a double as an example, we can use the `Double` class, discussed in the
    next section, as the static constant that contains the maximum allowed value for
    a double. When we assign a value to a double that exceeds the maximum allowable
    value:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 以双精度浮点数为例，我们可以使用下一节中讨论的 `Double` 类，作为包含双精度浮点数允许的最大值的静态常量。当我们给双精度浮点数赋值超过最大允许值时：
- en: '[PRE23]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The following will be the output for this:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 以下将是输出结果：
- en: '[PRE24]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The nature of the floating point is such that a minor increase over the maximum
    value does not result in an overflow. As shown in the previous example, a significant
    increase over the maximum value will generate `Infinity`. Take the following example:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 浮点数的性质是这样的，即使超过最大值的一点点增加也不会导致溢出。正如前一个例子所示，超过最大值的显著增加将生成 `Infinity`。以下是一个例子：
- en: '[PRE25]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Both expressions return the same answer:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个表达式返回相同的答案：
- en: '[PRE26]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Floating-point underflow
  id: totrans-228
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 浮点数下溢
- en: 'Underflow occurs when the floating-point value cannot represent exceedingly
    small fractions. Like overflow, this condition does not occur immediately after
    a value falls below the minimum value for the floating point. A meaningful change
    that lowers a value below the minimum will trigger an underflow. In this example,
    we begin by assigning the smallest allowed value to a double. When we divide it
    by 2, it becomes even smaller but now is smaller than the minimum value:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 下溢发生在浮点值无法表示极小分数时。就像溢出一样，这种情况不会在值低于浮点数最小值后立即发生。一个有意义的变化，将值降低到最小值以下将触发下溢。在这个例子中，我们首先将允许的最小值赋给一个双精度浮点数。当我们除以2时，它变得更小，但现在小于最小值：
- en: '[PRE27]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'When run, the result is as follows:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 运行后的结果是：
- en: '[PRE28]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'This is the minimum value of a double. Say we try to assign an even smaller
    value by dividing the minimum value by 2, as we have done here:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 这是双精度的最小值。比如说我们尝试通过除以2来赋予一个更小的值，就像我们在这里做的那样：
- en: '[PRE29]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Then, the result will be the following:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，结果将是以下内容：
- en: '[PRE30]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: This is the value that the code returns when a float or double underflows.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 这是代码在浮点或双精度浮点数下溢时返回的值。
- en: You should always be wary of overflow and, in the case of floating point, underflow.
    Now, let us look at a family of classes that provide class support for the primitive
    data types.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该始终警惕溢出，在浮点数的情况下，还要警惕下溢。现在，让我们看看一组提供基本数据类型类支持的类。
- en: Wrapper classes
  id: totrans-239
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 包装类
- en: Java, like most languages, has an array data type – you can have an array of
    integers, Booleans, or primitives. You can have an array of objects, such as the
    String. Every element in the array must be the same type. Many of the object-oriented
    capabilities in Java require the use of objects and not primitives. For example,
    Java has a library of data structures called collections that provides greater
    functionality than a basic array. These collections can only store or collect
    objects. You cannot have a collection of `int`, `double`, or any of the other
    primitives.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: Java，像大多数语言一样，有一个数组数据类型——你可以有一个整数数组、布尔数组或基本类型数组。你可以有一个对象数组，例如 String。数组中的每个元素都必须是相同的类型。Java
    中许多面向对象的功能需要使用对象而不是基本类型。例如，Java 有一个名为集合的数据结构库，它提供了比基本数组更强大的功能。这些集合只能存储或收集对象。你不能有一个
    `int`、`double` 或其他基本类型的集合。
- en: A `String` class, you do not need to use `new` to create a wrapper object. Wrappers
    have methods to convert from String to primitives. They also contain information
    about the primitives. We already had a peek at this when I used `Double.MIN_VALUE`
    and `Double.MAX_VALUE`.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: '`String` 类，你不需要使用 `new` 来创建包装对象。包装器有从字符串转换为基本类型的方法。它们还包含有关基本类型的信息。当我使用 `Double.MIN_VALUE`
    和 `Double.MAX_VALUE` 时，我们已经瞥见了这一点。'
- en: 'Here is a table of all the primitives and their matching wrapper classes. Aside
    from static variables, these wrappers also have static methods to convert to and
    from `String`:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是所有基本类型及其匹配的包装类的一个表。除了静态变量之外，这些包装器还有将值转换为和从 `String` 转换的静态方法：
- en: '| **Primitive** **data type** | **Wrapper class** |'
  id: totrans-243
  prefs: []
  type: TYPE_TB
  zh: '| **基本数据类型** | **包装类** |'
- en: '| `byte` | Byte |'
  id: totrans-244
  prefs: []
  type: TYPE_TB
  zh: '| `byte` | 字节型 |'
- en: '| `short` | Short |'
  id: totrans-245
  prefs: []
  type: TYPE_TB
  zh: '| `short` | 短整型 |'
- en: '| `int` | Integer |'
  id: totrans-246
  prefs: []
  type: TYPE_TB
  zh: '| `int` | 整型 |'
- en: '| `long` | Long |'
  id: totrans-247
  prefs: []
  type: TYPE_TB
  zh: '| `long` | 长整型 |'
- en: '| `float` | Float |'
  id: totrans-248
  prefs: []
  type: TYPE_TB
  zh: '| `float` | 单精度浮点型 |'
- en: '| `double` | Double |'
  id: totrans-249
  prefs: []
  type: TYPE_TB
  zh: '| `double` | 双精度浮点型 |'
- en: '| `boolean` | Boolean |'
  id: totrans-250
  prefs: []
  type: TYPE_TB
  zh: '| `boolean` | 布尔型 |'
- en: '| `char` | Character |'
  id: totrans-251
  prefs: []
  type: TYPE_TB
  zh: '| `char` | 字符 |'
- en: Table 4.11 – Primitives and wrappers
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 表 4.11 – 基本类型和包装器
- en: 'These classes, like String, do not have to be explicitly instantiated. This
    means that you could write the following:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 这些类，如 String，不需要显式实例化。这意味着你可以写如下：
- en: '[PRE31]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'But you can also just assign the integer value, as shown here:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 但你也可以直接分配整数值，如下所示：
- en: '[PRE32]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Java refers to this as **autoboxing**. A second feature, called **unboxing**,
    permits the reading of a wrapper class as if it were a primitive.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: Java 将此称为**自动装箱**。第二个特性，称为**自动拆箱**，允许将包装类读取为原始类型。
- en: 'Here we see an object, `number`, assigned to a primitive:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们看到一个对象`number`被分配给一个原始类型：
- en: '[PRE33]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: This now allows us to use objects as primitives. Every wrapper also contains
    several useful methods we will explore as we delve more into the language.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 这现在允许我们使用对象作为原始类型。每个包装类都包含几个有用的方法，我们将随着对语言的深入研究来探索这些方法。
- en: The math library
  id: totrans-261
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数学库
- en: 'Earlier in this chapter, we examined the operators available for working with
    primitive data types. There are many operations you may wish to perform that do
    not have a matching symbol, such as raising a value by a power. There are languages
    that use the caret (`^`) or double asterisk (`**`) to denote raising to a power.
    In Python, you would write the following:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章前面，我们检查了可用于处理原始数据类型的运算符。有许多你可能希望执行的操作没有对应的符号，例如对一个值进行幂运算。有些语言使用 caret (`^`)
    或双星号 (`**`) 来表示幂运算。在 Python 中，你会写如下：
- en: '[PRE34]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The result will be `25`. Java does not have a symbol for this operation. Instead,
    we must use a method that belongs to the math class, as shown here:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 结果将是`25`。Java 没有这个操作的符号。相反，我们必须使用属于数学类的方法，如下所示：
- en: '[PRE35]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'We have already seen this in the program that calculated compound interest;
    take a look again:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在计算复利的程序中看到了这一点；再看看：
- en: '[PRE36]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: The math library has an extensive selection of math operations. See the link
    in the *Further reading* section to learn about all the choices available to you.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 数学库提供了广泛的数学运算。请参阅*进一步阅读*部分中的链接，了解所有可用的选择。
- en: Summary
  id: totrans-269
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: The heart of every program you will write is the data that your program operates
    on. In this chapter, we have learned about the eight primitive types. There is
    `byte`, particularly useful if you are writing software to interact with other
    devices. `short`, `int`, and `long` are useful when what you need to describe
    has no fractions. When there are fractions, however, you can use floating-point
    types – `float` and `double`. The `char` type is the building block for strings.
    If you want to keep track of what is true or false, you should use the `boolean`
    type.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 你将要编写的每个程序的核心是程序操作的数据。在本章中，我们学习了关于八个原始类型。有`byte`，如果你正在编写与其它设备交互的软件特别有用。`short`、`int`和`long`在需要描述没有分数时很有用。然而，当有分数时，你可以使用浮点类型——`float`和`double`。`char`类型是字符串的构建块。如果你想跟踪什么是真或假，你应该使用`boolean`类型。
- en: As you move forward into Java, always keep in mind the available data types.
    Just as important is to understand what will happen if a value is out of range.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 在你继续学习 Java 的过程中，始终牢记可用的数据类型。同样重要的是要了解如果值超出范围会发生什么。
- en: Having identified the types, we moved to identify variables with meaningful
    names. We discussed how we assign data to these variables, and how we use them
    was an important part of this chapter.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 确定了类型之后，我们转向识别具有有意义的名称的变量。我们讨论了如何将这些数据分配给这些变量，以及如何使用它们是本章的一个重要部分。
- en: We left the primitives briefly to look at classes that are closely associated
    with primitives. There was `String` – home to characters that make up text that
    we can read. The wrapper classes provided runtime information about their matching
    primitives and are freely interchangeable with primitives, when you need an object
    rather than a primitive.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 我们简要地离开了原始类型，来看看与原始类型紧密相关的类。有`String`——包含我们可以阅读的文本的字符。包装类提供了关于其匹配原始类型的运行时信息，并且可以与原始类型自由互换，当你需要一个对象而不是原始类型时。
- en: Coming up, we will look at classes focusing on access control, packages, and
    how we construct a class.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将探讨关注访问控制、包以及如何构建类的类。
- en: Further reading
  id: totrans-275
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: '*The IEEE 754* *Format*: [http://mathcenter.oxford.emory.edu/site/cs170/ieee754/](http://mathcenter.oxford.emory.edu/site/cs170/ieee754/)'
  id: totrans-276
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*IEEE 754 格式*：[http://mathcenter.oxford.emory.edu/site/cs170/ieee754/](http://mathcenter.oxford.emory.edu/site/cs170/ieee754/)'
- en: '*Demystifying Floating Point* *Precision*: [https://blog.demofox.org/2017/11/21/floating-point-precision/](https://blog.demofox.org/2017/11/21/floating-point-precision/)'
  id: totrans-277
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*揭秘浮点数* *精度*: [https://blog.demofox.org/2017/11/21/floating-point-precision/](https://blog.demofox.org/2017/11/21/floating-point-precision/)'
- en: '*Class* *Math*: [https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/lang/Math.html](https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/lang/Math.html)'
  id: totrans-278
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*类* *数学*: [https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/lang/Math.html](https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/lang/Math.html)'
