- en: '6'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Data Persistence and NoSQL Database Integration with Spring Data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: SQL and NoSQL databases offer a flexible and scalable approach to data storage
    and retrieval that can be better suited to certain use cases compared to traditional
    relational databases. NoSQL databases are designed for horizontal scale-out, flexibility,
    performance, high availability, and global distribution. However, with this, you
    lose the consistency, ACID compliance, and expressiveness of a full SQL implementation
    that a relational database can provide.
  prefs: []
  type: TYPE_NORMAL
- en: It’s important to note that NoSQL databases are not a one-size-fits-all solution,
    and their suitability depends on the requirements of your application. In some
    cases, a combination of SQL and NoSQL databases might be the best approach to
    meet different data storage and retrieval needs within an organization.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will use some of the most popular NoSQL databases. Each
    of them has a different approach to data access, but Spring Boot facilitates the
    developer experience in all of them.
  prefs: []
  type: TYPE_NORMAL
- en: First, we will learn how to use MongoDB, a document-oriented database that stores
    data in JSON-like objects. We will cover the basics of data access in MongoDB,
    as well as other advanced scenarios, such as indexing, transactions, and optimistic
    concurrency persistence.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will learn how to use Apache Cassandra. It is a wide-column store database,
    meaning that it stores data in tables with flexible schema and supports column-family
    data models. We will learn how to perform advanced queries, as well as how to
    manage optimistic concurrency persistency within it.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Connecting your application to MongoDB
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using Testcontainers with MongoDB
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Data indexing and sharding in MongoDB
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using transactions in MongoDB
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Managing concurrency with MongoDB
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Connecting your application to Apache Cassandra
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using Testcontainers with Apache Cassandra
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using Apache Cassandra templates
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Managing concurrency with Apache Cassandra
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For this chapter, you will need a MongoDB server and an Apache Cassandra server.
    In both cases, the easiest way to deploy them in your local environment is by
    using Docker. You can get Docker from its product page at [https://www.docker.com/products/docker-desktop/](https://www.docker.com/products/docker-desktop/).
    I will explain how to install MongoDB and Cassandra using Docker in the respective
    recipes.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you wish to install MongoDB on your computer, you can follow the installation
    instructions on the product page: [https://www.mongodb.com/try/download/community](https://www.mongodb.com/try/download/community).'
  prefs: []
  type: TYPE_NORMAL
- en: If you need to access MongoDB, you can use MongoDB Shell or MongoDB Compass,
    both of which can be found at [https://www.mongodb.com/try/download/tools](https://www.mongodb.com/try/download/tools).
    I will be using MongoDB Shell in this chapter, so I recommend installing it.
  prefs: []
  type: TYPE_NORMAL
- en: For Cassandra, you can follow the instructions at [https://cassandra.apache.org/doc/latest/cassandra/getting_started/installing.html](https://cassandra.apache.org/doc/latest/cassandra/getting_started/installing.html).
  prefs: []
  type: TYPE_NORMAL
- en: 'All the recipes that will be demonstrated in this chapter can be found at:
    [https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook/tree/main/chapter6](https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook/tree/main/chapter6).'
  prefs: []
  type: TYPE_NORMAL
- en: Connecting your application to MongoDB
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will learn how to deploy a MongoDB server in Docker. Next,
    we will create a Spring Boot application and connect it to our MongoDB server
    using Spring Data MongoDB. Finally, we will initialize the database and perform
    some queries against the data that’s been loaded.
  prefs: []
  type: TYPE_NORMAL
- en: We will use the scenario of football teams and players to demonstrate the different
    approaches to managing data in MongoDB compared to relational databases such as
    PostgreSQL.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For this recipe, we will use a MongoDB database. The easiest way to deploy it
    on your computer is by using Docker. You can download Docker from the product
    page at [https://www.docker.com/products/docker-desktop/](https://www.docker.com/products/docker-desktop/).
  prefs: []
  type: TYPE_NORMAL
- en: Once you have installed Docker, you can run a single instance of MongoDB or
    execute a cluster running in a replica set. Here, you will deploy a cluster running
    in a replica set. This is not necessary for this recipe but will be necessary
    for the following recipes as it is necessary to support transactions. I’ve prepared
    a script to facilitate the deployment of the cluster. This script deploys the
    cluster using `docker-compose`; once deployed, it initializes the replica set.
    You can find the script in this book’s GitHub repository at [https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook/](https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook/),
    in the `chapter3/recipe3-2/start` folder.
  prefs: []
  type: TYPE_NORMAL
- en: You will need MongoDB Shell to connect to the MongoDB server. You can download
    it from [https://www.mongodb.com/try/download/shell](https://www.mongodb.com/try/download/shell).
  prefs: []
  type: TYPE_NORMAL
- en: 'You will also need the *mongoimport* tool to import some data into the database.
    It is part of MongoDB’s database tools. Follow the instructions on the product
    page to install it: [https://www.mongodb.com/docs/database-tools/installation/installation/](https://www.mongodb.com/docs/database-tools/installation/installation/).'
  prefs: []
  type: TYPE_NORMAL
- en: 'The data, once loaded, will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Each team has a list of players. Keep this structure in mind to better understand
    this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: You can use *MongoDB Shell* to connect to the database. We will use it to create
    a database and initialize it with some data. You can find a script to load the
    data in this book’s GitHub repository at [https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook/](https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook/).
    The script and the data are in the `chapter3/recipe3-1/start/data` folder.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s create a project using Spring Data MongoDB and create a repository to
    connect to our database. The database manages football teams, which include players.
    We will create some queries to get teams and players, and we will implement operations
    to make changes to our data. Follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a project using the *Spring Initializr* tool. Open [https://start.spring.io](https://start.spring.io)
    and use the same parameters that you did in the *Creating a RESTful API* recipe
    of [*Chapter 1*](B21646_01.xhtml#_idTextAnchor020), except change the following
    options:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For `footballmdb`
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: For **Dependencies**, select **Spring Web** and **Spring** **Data MongoDB**
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Download the template that was generated with the *Spring Initializr* tool and
    unzip the content to your working directory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'First, we will configure Spring Data MongoDB to connect to our database. For
    that purpose, create an `application.yml` file in the `resources` folder. It should
    look like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, create a class named `Team` and annotate it with `@Document(collection
    = teams)`. It should look like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note that we also decorated the attribute ID with `@Id` and we are using `List<Player>`
    in our class. We will have a single collection of data in MongoDB called `teams`.
    Each team will contain players.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Next, create the `Player` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `Player` class does not require any special annotation as it’s data that
    will be embedded in the `Team` document.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now, create a repository to manage the teams persisted in MongoDB:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'As it happens with `JpaRepository`, just by extending our `TeamRepository`
    interface from `MongoRepository`, we already have basic methods to manipulate
    `Team` documents in MongoDB. We will use this repository now. To do that, create
    a new service named `FootballService`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we can create a new method in our service that retrieves a team using
    its `Id` value. This method in the service can use the `findById` method in `TeamRepository`,
    which is available by extending from `MongoRepository`:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We can also create a method to find the teams with a name that contains a string:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we will create a method to find a player. For this, we will need to look
    into the teams to find the player. It can be implemented by using the `@``Query`
    annotation:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: As you can see, the query’s `value` attribute is not SQL – it’s in `fields`
    attribute corresponds to the fields we want to retrieve from the document – in
    this case, just the `players` field of the document. This method will return a
    `Team` object with only one player.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let’s see how we can use this method. To do so, create a method in `FootballService`
    named `findPlayerById`:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We will use the `save` method of `MongoRepository` to *upsert* teams and `delete`/`deleteById`
    to make changes in the database:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`saveTeam` in the `FootballService` class:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, create a method to delete a team by its ID:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: In this recipe, we implemented a service that uses `MongoRepository` to perform
    the basic operations to interact with our MongoDB database. I’ve created a RESTful
    API to expose the methods that were implemented by the `FootballService` service
    that was created in this recipe. I’ve also created a script to make the requests
    to the RESTful API. You can find all this in this book’s GitHub repository, in
    the `chapter6/reciper6-1/end` folder.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When the application starts, Spring Data MongoDB scans the application looking
    for `MongoRepository` interfaces. Then, it generates the implementation for the
    methods defined in the repository and registers the interface implementation as
    a bean to make it available for the rest of the application. To infer the implementation
    of the interface, it uses the naming convention of the methods; see https://docs.spring.io/spring-data/mongodb/docs/current/reference/html/#repository-query-keywords
    for more details. Spring Data MongoDB also scans for methods with the `@Query`
    annotation to generate the implementation for those methods.
  prefs: []
  type: TYPE_NORMAL
- en: Regarding the `@Query` annotation, Spring Data MongoDB can do certain validations,
    but you should keep in mind that MongoDB is schema-flexible by design. This means
    that it doesn’t assume that a field should or shouldn’t exist. It will return
    a `null` value instead. Keep in mind that if the results are different from what
    you expected, there is probably a typo in your query.
  prefs: []
  type: TYPE_NORMAL
- en: 'In `findPlayerById`, we implemented a query to return an element of an array
    in a document. It is important to understand the data that’s returned by MongoDB.
    When we want to find player `430530`, it returns the container document, a `Team`
    object with an `id` value of 1882891, with just the property players, and an array
    of just one element – that is, the player with ID `430530`. It looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: I’ve included players in the team collection for learning purposes. If you have
    a similar scenario and you expect to perform a lot of queries while searching
    for an element of an array in a collection, you might prefer to have a MongoDB
    collection for that array. In this case, I would store players in their own collection.
    It will perform and scale much better.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, `MongoRepository` provides three methods to save data:'
  prefs: []
  type: TYPE_NORMAL
- en: '`save`: This method inserts a document if it doesn’t exist and replaces it
    if it does exist. This behavior is also known as *upsert*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`saveAll`: This method behaves in the same way as `save`, but it allows you
    to persist a list of documents at the same time.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`insert`: This method adds a new document to the collection. So, if the document
    already exists, it will fail. This method is optimized for inserting operations
    as it doesn’t check the previous existence of the document.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `save` and `saveAll` methods replace the document entirely if it already
    exists. If you only want to update certain properties of your entity, also known
    as partial document updates, you will need to use Mongo templates.
  prefs: []
  type: TYPE_NORMAL
- en: There’s more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'I recommend looking to `MongoTemplate` for more advanced scenarios, such as
    when you need partial updates. Here’s an example of it if you only want to update
    the team name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, it allows you to define the `where` criteria to query the object
    and allows the *update* operation, defining which fields you want to update. Here,
    `MongoTemplate` is the core component used by Spring Data MongoDB to create the
    implementation of `MongoRepository` interfaces.
  prefs: []
  type: TYPE_NORMAL
- en: Using Testcontainers with MongoDB
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When creating integration tests that depend on MongoDB, we have two options:
    using an in-memory database server embedded in our application or using Testcontainers.
    The in-memory database server can have slight differences from our production
    system. For that reason, I recommend using Testcontainers; it allows you to use
    a real MongoDB database hosted in Docker with all features enabled.'
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we’ll learn how to set up a MongoDB Testcontainer and how to
    execute some initialization scripts so that we can insert test data into the database.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Executing Testcontainers requires a Docker-API compatible runtime. You can
    install Docker by following the instructions on the official web page: [https://www.docker.com/products/docker-desktop/](https://www.docker.com/products/docker-desktop/).'
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we’ll add tests for the project we created in the *Connecting
    your application to MongoDB* recipe. I’ve created a working version of that recipe
    in case you haven’t completed it yet. You can find it in this book’s GitHub repository
    at [https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook](https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook),
    in the `chapter6/recipe6-2/start` folder. In this folder, you will also find a
    file named `teams.json`. This will be used to initialize the data for the tests.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s enhance our project by creating automated tests with Testcontainers:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we’ll need to include the Testcontainers dependencies. For that, open
    the `pom.xml` file and add the following dependencies:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: As we’ll need to initialize the data in the database during the test execution,
    copy the `team.json` file described in the *Getting ready* section into the `tests/resources/mongo`
    folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Next, create a test class. Let’s name it `FootballServiceTest`, and annotate
    the class with `@SpringBootTest` and `@Testcontainers`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We’ll continue setting up the test class by creating the MongoDB container.
    As we’ll see in the next step, we’ll need to initialize the database with some
    data. For that, we’ll copy the `teams.json` file described in *Step 2* to the
    container. We’ll create the container and pass the file as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '@BeforeAll'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: static void startContainer() throws IOException, InterruptedException {
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: mongoDBContainer.start();
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: importFile("teams");
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: static void importFile(String fileName) throws IOException, InterruptedException
    {
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Container.ExecResult res = mongoDBContainer.execInContainer("mongoimport", "--db=football",
    "--collection=" + fileName, "--jsonArray", fileName + ".json");
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: if (res.getExitCode() > 0){
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: throw new RuntimeException("MongoDB not properly initialized");
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we should configure the context so that it uses the MongoDB database hosted
    in Testcontainers. For that, we’ll use the `@``DynamicPropertySource` annotation:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now that the MongoDB repository has been configured, we can continue with the
    normal test implementation. Let’s inject `FootballService` into the test class
    and implement a simple test that will retrieve a `Team` object:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: You can implement the tests for the rest of the functionality. I’ve created
    some basic tests for the `FootballService` class. You can find them in this book’s
    GitHub repository at [https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook](https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook),
    in the `chapter6/recipe6-2/end` folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As we saw in the *PostgreSQL integration tests with Testcontainers* recipe of
    [*Chapter 5*](B21646_05.xhtml#_idTextAnchor203), by adding the `@Testcontainers`
    annotation, all the containers that are declared as static are available for all
    the tests in the class and stopped after the last test is executed. In this recipe,
    we used the specialized `MongoDBContainer` container; it provides the URL of the
    server, which we can use to configure the test context. This configuration is
    performed by using the `@DynamicPropertySource` annotation, as we saw in *Step
    6*.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we learned how to copy files to the container and execute programs
    inside it. All the files in the `resources` folder are available at runtime. We
    copied the `teams.json` file to the container and then used the `mongoimport`
    tool to import the data into MongoDB. This tool is available in the MongoDB Docker
    image. One advantage of executing this tool in the container is that it’s not
    necessary to specify the database server address.
  prefs: []
  type: TYPE_NORMAL
- en: Data indexing and sharding in MongoDB
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will manage football matches and their timeline – that is,
    the events that occur during the game. An event may involve one or two players
    and we must consider that the players’ fans want to access all actions where their
    favorite players are involved. We will also consider that the number of matches
    and their events is growing every day, so we need to prepare our application to
    support all the load.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we’ll introduce some key concepts to make your application performant
    and scalable. MongoDB, like relational databases, enables you to create indexes
    that optimize data access. If you plan to access certain data using the same parameters,
    it is worth creating indexes to optimize data read. Of course, you will require
    more storage and memory, and write operations will be impacted. So, you will need
    to plan and analyze your application needs.
  prefs: []
  type: TYPE_NORMAL
- en: As the size of your data increases, you will need to scale your MongoDB database.
    **Sharding** is a database architecture and partitioning technique that’s used
    to horizontally partition data across multiple servers or nodes in a distributed
    system. With sharding, you can scale out your database by adding more servers
    and distributing the data across them using shards. A shard ensures that all data
    in the same shard will be on the same server.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will use indexing and sharding in our football application
    while taking advantage of the features provided by Spring Data MongoDB. We will
    use other interesting features of Spring Data MongoDB, such as referring documents
    from other documents.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will use the same tools that we did in the first recipe, *Connecting your
    application to MongoDB* – that is, Docker, MongoDB, and MongoDB tools such as
    *Mongo Shell* and *mongoimport*.
  prefs: []
  type: TYPE_NORMAL
- en: We will reuse the code from the *Connecting your application to MongoDB* recipe.
    If you haven’t completed it yet, don’t worry – I’ve prepared a working version
    in this book’s GitHub repository at [https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook/](https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook/).
    It can be found in `chapter6/recipe6-` `3/start`. I’ve also created a script to
    load data into the database using the *mongoimport* tool. This can be found in
    the `chapter6/recipe6-3/start/data` folder.
  prefs: []
  type: TYPE_NORMAL
- en: 'The data is a bit different compared to what was provided in the *Connecting
    your application to MongoDB* recipe. I moved the players to their own MongoDB
    collection, and I added new collections to manage the matches and match events.
    If you want to keep the data from the previous recipe, I recommend that you create
    a new database for this recipe. You can do so by simply changing the `--db` parameter
    when calling the `mongoimport` tool. The calls will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'First, we will host the players’ data in their own MongoDB collection. Players
    will be important entities for the new requirements, so they deserve their own
    collection. Then, we will create the document classes for matches and events.
    We will learn how to use Spring Data MongoDB annotations to configure MongoDB
    *indexes* and *shards*. Follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s start by configuring players in their own MongoDB collection. Annotate
    the `Player` class with `@Document`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Annotate the `id` field with the `@Id` annotation. We’re doing this as it will
    be the document identifier.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Now, remove the `players` field from `Team`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Next, create the classes for matches and their events. For matches, we will
    create a class named `Match`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note that we started using two new annotations, `@Indexed` and `@DBRef`. They
    will be fully explained in the *How it works...* section of this recipe.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'For the match events, we will create a class named `MatchEvent`:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: With that, we have introduced the `@Sharded` and `@``Field` annotations.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: To be able to use the new classes, we will create a repository for each class
    – that is, `PlayerRepository`, `MatchRepository`, and `MatchEventRepository`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let’s look at `MatchEventRepository` in detail. It will implement the operations
    we need for our requirements:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Return all events in a match
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Return all player events in a match:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: 'At this point, we could run our application as Spring Data MongoDB components
    are in place. However, not all of the indexes have been created yet. If we want
    to create them as part of our application, we need to create a configuration class
    that extends `AbstractMongoClientConfiguration`, instructing Spring Mongo DB to
    create the indexes automatically:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now, we can create a service using these repositories to implement the new requirements
    of our application while connecting to MongoDB in an optimized way. I’ve created
    a service and a RESTful controller to demonstrate the use of these repositories.
    I’ve also added a few more tests using Testcontainers. You can find them in this
    book’s GitHub repository at [https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook/](https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook/),
    in the `chapter6/recipe6-3/end` folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: First, I will explain the impact of the annotations that were used in this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `@DBRef` annotation is a way to reference another document but keep in
    mind that this is a mechanism that’s implemented by Spring Data MongoDB, not by
    the database engine itself. In MongoDB, the concept of reference integrity doesn’t
    exist, and it should be managed at the application level. Here, `@DBRef` represents
    a document as an object with three fields:'
  prefs: []
  type: TYPE_NORMAL
- en: '`$ref`: This contains the collection being referenced'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`$id`: This contains the ID of the document being referenced'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`$db`: This contains the database of the document being referenced'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For example, here, you have a reference to team `1882891`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Spring Data MongoDB can use this annotation to automatically retrieve the referenced
    document. We can specify this behavior using the `lazy` attribute. By default,
    it is `true`, meaning that Spring Data MongoDB won’t retrieve it automatically.
    If you set it to `false`, it will retrieve the referenced document automatically.
    We used this for the match document to automatically retrieve the information
    from the two teams playing the match.
  prefs: []
  type: TYPE_NORMAL
- en: The `@Indexed` annotation, as you may have figured out, creates an index in
    MongoDB. Then, the queries that use the indexed fields will perform faster for
    read operations.
  prefs: []
  type: TYPE_NORMAL
- en: The `@Sharded` annotation tells MongoDB how the collections should be distributed
    across shards. A server in a cluster can host one or more shards. We can also
    see a shard as a way to specify which documents will be hosted on the same server.
    In our case, we are interested in retrieving the events by match. This is the
    reason we configured `match` as the shard key. Selecting a good sharding key is
    crucial to make our application performant and scalable as it will impact the
    way the workload will be distributed across the servers.
  prefs: []
  type: TYPE_NORMAL
- en: When a query is performed in a sharded collection, MongoDB should identify if
    the request can be performed in a single shard or whether it will need to distribute
    the query across shards. It will gather the results from shards, aggregate them,
    and then return the results to the client. If you intentionally need to scale
    out a query horizontally, this is an excellent mechanism. It may happen that a
    request doesn’t need to be distributed and could be executed in a single shard,
    but because of a wrong shard key selection, it is executed as a distributed query.
    The consequence is that it will consume more resources than expected because more
    servers will perform an unnecessary query, so the results have to be aggregated.
  prefs: []
  type: TYPE_NORMAL
- en: Sharding involves dividing a database into smaller parts, called shards, that
    can be hosted on a single server. A server can host multiple shards, and the shards
    are replicated across servers for availability. The number of servers can automatically
    increase or decrease, depending on the load. Sharding is useful for managing large
    datasets and large clusters, which are typically deployed in the cloud. For example,
    **MongoDB Atlas** can be hosted on cloud providers such as **Azure**, **Amazon
    Web Services** (**AWS**), and **Google Cloud Platform** (**GCP**), allowing the
    number of servers to be adjusted to meet real demand. However, in cases where
    the database is hosted in a single container on a computer, as in our example,
    sharding won’t provide any significant benefits. In larger deployments, sharding
    is a crucial feature for achieving our goals.
  prefs: []
  type: TYPE_NORMAL
- en: We didn’t explicitly create an index for `match` in `MatchEvent`, but it is
    implicitly created since it is the sharding key.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we used the `@Field` annotation. This is used to map a field in our
    document class to a different field in MongoDB. In our case, we mapped the `time`
    field in our class to the `event_time` field in MongoDB.
  prefs: []
  type: TYPE_NORMAL
- en: There’s more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Some decisions should be made when designing the data layer with MongoDB or
    other document-oriented databases. For example, should we mix different types
    of objects in the same collection, or should we keep each type of document in
    different collections?
  prefs: []
  type: TYPE_NORMAL
- en: Having different types of objects in the same collection can make sense if they
    share some common fields and you want to perform queries by those fields, or you
    want to aggregate data from different objects. For the rest of the scenarios,
    it is probably better to have each type of document in its own collection. It
    helps create indexes and facilitate the creation of shards.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this recipe, we didn’t mix different types of documents, but that is the
    reason why Spring Data MongoDB introduces a field named `_class` when it persists
    a document. For instance, this is the document that’s persisted when creating
    a new team:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Another decision to make is whether we should embed some data in a document
    or if that data should be in its own document. In the *Connecting your application
    to MongoDB* recipe, we embedded the players into their team, while in this recipe,
    we moved that information to its own collection. It may depend on the importance
    or independence of the embeddable document. In this recipe, the players required
    their own document as they can be directly referenced from other documents, such
    as match events.
  prefs: []
  type: TYPE_NORMAL
- en: There could be other reasons, such as the expected write concurrency over the
    embedded entity. For instance, we could embed the events in the matches. However,
    during a match, we could assume that there will be a high number of events happening.
    That operation would require a high number of write operations on the match document,
    which will require more consistency management.
  prefs: []
  type: TYPE_NORMAL
- en: Using transactions in MongoDB
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We want to create a new service where users can purchase a virtual token that
    can be used to obtain virtual goods in this new game. The main goods are cards
    with player pictures and other information, a kind of virtual sticker.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two operations that we need to implement: the token purchase and
    the cards purchase. For the token purchase, there is a payment validation. Cards
    can only be purchased with tokens. Of course, the users will be able to purchase
    cards if they have enough tokens.'
  prefs: []
  type: TYPE_NORMAL
- en: Since we need to ensure consistency regarding the token and cards balance, we
    will need to use transactions with our MongoDB repository.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will learn more about MongoDB transactions and how they differ
    from relational database transactions.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will use the same tools that we did in the *Connecting your application to
    MongoDB* recipe – that is, Docker and MongoDB.
  prefs: []
  type: TYPE_NORMAL
- en: We will reuse the code from the *Data indexing and sharding in MongoDB* recipe.
    If you haven’t completed it yet, don’t worry – I’ve prepared a working version
    in this book’s GitHub repository at [https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook/](https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook/).
    It can be found in the `chapter6/recipe6-4/start` folder.
  prefs: []
  type: TYPE_NORMAL
- en: MongoDB transactions
  prefs: []
  type: TYPE_NORMAL
- en: MongoDB transactions are not supported in standalone servers. In the *Connecting
    your application to MongoDB* recipe, I provided a script to deploy a cluster using
    a replica set.
  prefs: []
  type: TYPE_NORMAL
- en: In the *Deploying a MongoDB cluster in Testcontainers* recipe, we’ll cover how
    to deploy multiple servers with containers to be able to test MongoDB transactions.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will need to create a data model to support users and cards in our new service.
    Later, we will create a service that will use MongoDB transactions to perform
    operations involving users and cards consistently. We will configure our application
    so that it supports transactions as well. Follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s start by creating the classes that will manage the objects to be stored
    in MongoDB:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'First, we will create a class named `User`:'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we will create a class named `Card`:'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we need to create the corresponding `MongoRepository` interfaces. Let’s
    go:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create an interface named `UserRepository`:'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'And another interface named `CardRepository`:'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we need to create a service class that will manage the business logic
    of our application. To do that, create a class named `UserService`. Remember to
    annotate the class with `@Service`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This service will need the new repositories we created – that is, `UserRepository`
    and `CardRepository`, as well as `PlayerRepository`, which we created in the *Data
    indexing and sharding in MongoDB* recipe. We will need `MongoTemplate` as well.
    We will create a constructor with these repositories, after which the Spring Boot
    dependency manager will inject them:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we’ll implement our business logic:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a method for purchasing tokens named `buyTokens`:'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a method for purchasing cards named `buyCards`:'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To allow transactions in our application, we need to register a `MongoTransactionManager`
    bean. To do so, in our `MongoConfig` class, add the following method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now, our application can use transactions to execute operations atomically.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: By default, MongoDB native transactions are disabled in Spring Data MongoDB.
    That is the reason why we needed to register `MongoTransactionManager`. Once configured,
    when we annotate a method with `@Transactional`, it will create a transaction.
  prefs: []
  type: TYPE_NORMAL
- en: It is very important to note that transactions provide atomic operations, meaning
    that all of them are saved or none of them are, but they don’t support isolation.
    The `buyCards` method will save all `cards` and the changes on `user` or it will
    save none of them.
  prefs: []
  type: TYPE_NORMAL
- en: An important difference compared to transactions in relational databases is
    that there is no locking or isolation. If we make changes to the same `User` document
    that is modified in `buyCards` in another request, it will raise a **write conflict
    exception**. MongoDB is designed for performance and scalability at the cost of
    losing features from ACID transactions. We’ll learn how to manage concurrency
    in more detail in the *Managing concurrency with* *MongoDB* recipe.
  prefs: []
  type: TYPE_NORMAL
- en: As you’ve probably realized, the `buyTokens` method does not use transactions.
    The main reason is that it doesn’t need to. All operations in a single document
    are considered isolated and atomic. Since the only field that’s updated is `tokens`,
    we used the `inc` operation to modify the value. The advantage of this operator
    is that it’s performed atomically in the server, even in high-concurrency environments.
    If we use transactions in operations involving a single document, it could raise
    write conflicts exceptions if two requests are updating the same document. This
    behavior could seem counter-intuitive if you compare it to the behavior of transactions
    in relational databases.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In addition to `$inc`, there are other atomic operations in MongoDB worth knowing
    about for concurrent scenarios. They can be applied to fields and arrays. See
    [https://www.mongodb.com/docs/v7.0/reference/operator/update/](https://www.mongodb.com/docs/v7.0/reference/operator/update/)
    for more details.
  prefs: []
  type: TYPE_NORMAL
- en: Deploying a MongoDB cluster in Testcontainers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: MongoDB transactions are only supported in multiple server clusters. However,
    `MongoDBContainer`, as explained in the *Using Testcontainers with MongoDB* recipe
    uses a single server deployment. Therefore, we cannot use it for the integration
    tests of the new feature to buy cards as it requires transactions.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we’ll learn how to set up multiple Testcontainers and configure
    a MongoDB cluster. With that, we’ll be able to implement integration tests for
    the buy cards feature.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This recipe will implement the integration tests for the *Using transactions
    in MongoDB* recipe. If you haven’t completed it yet, don’t worry – I’ve prepared
    a version from which you can start this recipe. You can find it in this book’s
    GitHub repository at [https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook](https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook),
    in `chapter6/recipe6-5/start`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this recipe, we’ll set up the MongoDB cluster using Testcontainers and test
    the features involving transactions. Let’s get started!
  prefs: []
  type: TYPE_NORMAL
- en: 'Since the new buy cards feature is the, we’ll create a new test class named
    `UserServiceTest` and set up everything in this class. Since it uses Testcontainers,
    we’ll annotate the class with `@Testcontainers`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we’ll create the MongoDB cluster. It will consist of three MongoDB containers
    deployed in the same network:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Declare a `Network` static field. This class is part of the Testcontainers
    library and allows us to define a Docker network:'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, create three static `GenericContainer` fields with the following properties:'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Each field will have the latest `mongo` Docker image.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Each field will have the same network.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The three containers will expose port `27017`.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Each container will have a different network alias: `mongo1`, `mongo2`, and
    `mongo3`.'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The three containers will start with a `mongod` command that initializes the
    MongoDB cluster, with the only difference being the binding IP hostname. Each
    container will use its network alias.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here, we have the first field, `mongoDBContainer1`:'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The other fields, `mongoDBContainer2`, and `mongoDBContainer3`, are declared
    as `mongoDBContainer1`, except we must change `mongo1` to `mongo2` and `mongo3`,
    respectively.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now that the three MongoDB containers have been declared, the next step is
    to start the containers and initiate the MongoDB replica set. We need to execute
    the following MongoDB command in one of the servers:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'I’ve created a utility method named `buildMongoEvalCommand` to format the commands
    so that they’re ready to be executed in MongoDB. We’ll execute the MongoDB replica
    set initialization before any test execution. For that, we’ll use the `@``BeforeAll`
    annotation:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '@DynamicPropertySource'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: static void setMongoDbProperties(DynamicPropertyRegistry registry) {
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: registry.add("spring.data.mongodb.uri", () -> {
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: String mongoUri = "mongodb://" + mongoDBContainer1.getHost() + ":" + mongoDBContainer1.getMappedPort(27017)
    + "/?directConnect=true";
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: return mongoUri;
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '});'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'buyCards method of the UserService class:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Some code snippets have been simplified or omitted for clarity. You can find
    more details in this book’s GitHub repository at [https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook](https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `MongoDBContainer` container, which is available as a module in the Testcontainers
    project, only works as a single server deployment. For that reason, instead of
    using `MongoDBContainer`, we used `GenericContainer`. After that, we adapted to
    Testcontainers so that we could set up the script explained in the *Getting ready*
    section of the *Connecting your application to MongoDB* recipe. To do so, we did
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Created a Docker network.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deployed at least three MongoDB servers in containers.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Initialized the MongoDB replica set. A replica set is a group of Mongo processes
    that work together to maintain the same dataset. We can consider this a cluster.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'As you may have noticed, we used the `directConnection` setting when connecting
    to the MongoDB cluster. This setting means that we connect directly to one specific
    node of the cluster. When connecting to a replica set, normally, the connection
    string specifies all cluster nodes and the client connects to the most appropriate
    one. The reason we use `directConnection` is because the nodes can discover each
    other using the network alias. After all, they are in the same network and can
    use DNS names. However, the application we developed runs on our development computer,
    which hosts the containers, but it’s in a different network and cannot find the
    nodes by name. If we were in the same network, the MongoDB connection string would
    look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: In this case, the client will connect to the appropriate node. To execute transactions,
    it’s necessary to connect to the primary server. The application we developed
    may fail when performing these transactions because it’s not connected to the
    primary server.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The `buildMongoEvalCommand` method has been adapted from the original `MongoDBContainer`
    container from the `Testcontainer` project. You can find the original code at
    [https://github.com/testcontainers/testcontainers-java/blob/main/modules/mongodb/src/main/java/org/testcontainers/containers/MongoDBContainer.java](https://github.com/testcontainers/testcontainers-java/blob/main/modules/mongodb/src/main/java/org/testcontainers/containers/MongoDBContainer.java).
  prefs: []
  type: TYPE_NORMAL
- en: Managing concurrency with MongoDB
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will implement a feature to exchange player cards between
    users. Some cards are more difficult to get, which results in them having a higher
    demand. So, while many users try to find them, only one may get it. This is a
    scenario of high concurrency.
  prefs: []
  type: TYPE_NORMAL
- en: 'A user can exchange or buy another user’s card using a certain number of tokens.
    The process we will implement consists of the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: First, we need to check that the buyer has the tokens they promised.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, we’ll subtract the number of tokens from the buyer and add them to the
    seller.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, we will change the card owner.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: MongoDB supports optimistic concurrency control through a document’s versioning
    system. Each document has a version number (often called a *revision* or *version*
    field) that is incremented whenever the document is modified. When multiple clients
    attempt to update the same document simultaneously, the version numbers are used
    to detect conflicts, and the changes are rejected if there is a conflict.
  prefs: []
  type: TYPE_NORMAL
- en: We will add version support to `cards` and `users` as we need to control that
    the users haven’t spent the tokens on another thing and that the cards are not
    exchanged with another user.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will use the same tools that we used in the *Connecting your application
    to MongoDB* recipe – that is, Docker and MongoDB.
  prefs: []
  type: TYPE_NORMAL
- en: We will reuse the code from the *Deploying a MongoDB cluster in Testcontainers*
    recipe. If you haven’t completed it yet, don’t worry – I’ve prepared a working
    version in this book’s GitHub repository at [https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook/](https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook/).
    It can be found in the `chapter6/recipe6-4/start` folder.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s add version control support to our `Card` and `User` documents and implement
    a card exchange transaction with optimistic concurrency control:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we will modify the classes involved in our feature so that they support
    optimistic concurrency. We’ll do this by adding a new field annotated with `@Version`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Modify the `User` class by adding a new `Long` field named `version`:'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: And the same `version` field to the `Card` class.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Next, we will create a new service named `TradingService`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here, `CardRepository` and `UserRepository` are added as dependencies in the
    constructor as we will need them to implement the card exchange business logic.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now, we will create two methods to implement the business logic. One will be
    annotated with `@Transactional` to control that all changes are atomic, and another
    one to control concurrency exceptions:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The business logic method should look as follows:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: 'The method to control concurrency should look like this:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: With this mechanism, we can control the concurrency operations that are performed
    on our documents. You can now implement a RESTful API that will use this business
    logic. I’ve prepared a working sample in this book’s GitHub repository at [https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook/](https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook/).
    It can be found in `chapter6/recipe6-6/end`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'By adding the `@Version` annotation, the save operations not only check that
    the `id` value is the same, but also the field annotated with `version`. The generated
    query looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: If this operation fails, it throws an `OptimisticLockingFailureException` exception.
  prefs: []
  type: TYPE_NORMAL
- en: Depending on the business requirements, we could retry the operations or just
    abandon them, as we did in our scenario. If a user already sold the card you want,
    you should look for another one.
  prefs: []
  type: TYPE_NORMAL
- en: Since we needed to modify three different documents, we used a transaction.
    We used the `@Transactional` annotation for declarative transaction management.
    If we want to roll back changes that have been performed in that transaction,
    we need to throw an exception. That is why we let Spring Data MongoDB throw `OptimisticLockingFailureException`
    in the `exchangeCardInternal` method and capture it in `exchangeCard`.
  prefs: []
  type: TYPE_NORMAL
- en: Connecting your application to Apache Cassandra
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we want to create a system that allows users to post comments
    related to matches, players, or match events. We decided to use Apache Cassandra
    due to its high scalability and low-latency capabilities.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we’ll learn how to connect our Spring Boot application to an
    Apache Cassandra server using Spring Data for Apache Cassandra repositories.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For this recipe, we will use an Apache Cassandra database. The easiest way
    to deploy Apache Cassandra on your computer is by using a container hosted in
    Docker. You can perform this task by executing the following `docker` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: This command will download the latest Apache Cassandra Docker image, if you
    don’t have one yet on your computer, and will start a Cassandra server listening
    on port `9042`.
  prefs: []
  type: TYPE_NORMAL
- en: 'After starting the server, you will need to create a `cqlsh` script inside
    the container:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: You may need to wait a few seconds for the Cassandra server to finish initializing
    before creating the Keyspace.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s create a project with Apache Cassandra support. We will use the already
    familiar Spring Data concept of `Repository` to connect to Apache Cassandra:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we will create a new Spring Boot project using the *Spring Initializr*
    tool. As usual, open [https://start.spring.io](https://start.spring.io). We will
    use the same parameters we used in [*Chapter 1*](B21646_01.xhtml#_idTextAnchor020),
    in the *Creating a RESTful API* recipe, except we’ll use the following parameters:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For `footballcdb`
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: For **Dependencies**, select **Spring Web** and **Spring Data for** **Apache
    Cassandra**
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Next, we will create a class named `Comment`. This represents the data for our
    new feature.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We need to annotate the class with `@Table` and the fields with `@PrimaryKeyColumn`
    if they form part of the primary key. We can use `@Column` if we want to map a
    field to a different column name in Cassandra:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We need to create a new `Repository` for `Comment` that extends from `CassandraRepository`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: As is usual with Spring Data’s `Repository`, it provides some methods to manipulate
    `Comment` entities, such as `findById`, `findAll`, `save`, and others.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'As we will retrieve the comments when showing other entities, such as matches
    or players, we’ll need to create a method in `CommentRepository` to get the comments
    by the type of target and the target itself:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note that as with other repositories in Spring Data, it can implement the interface
    by inferring the query from the method name.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: It is important to annotate the method with the `@AllowFiltering` annotation
    as we are not retrieving the data via the primary key.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'We can now create a service using `CommentRepository` to implement our application
    requirements. We’ll name the service `CommentService` and ensure it has the following
    content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we must create the functionality. We will create a method to create a
    comment and a couple of methods to retrieve all comments:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We’ll use a record to receive the comment data:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: 'Let’s define the `postComment` method so that we can create a new comment:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we can create a method to retrieve all comments:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: 'We can retrieve all comments in general, but it makes more sense to retrieve
    the comments related to another entity. For instance, it’s more common to get
    comments about a player:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, we need to configure the application so that it can connect to our
    Cassandra server. In the *Getting ready* section of this recipe, I provided instructions
    to deploy it on your computer by using Docker, including how to create a Keyspace.
    To configure the application, create an `application.yml` file in the `resources`
    folder. Add the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We now have the components that are required to provide the comments functionality.
    We created `CassandraRepository` and we connected to a Cassandra server. I’ve
    created a RESTful API to consume this service. You can find it in this book’s
    GitHub repository at [https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook/](https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook/).
    It can be found in `chapter6/recipe6-7/end`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As we saw with other Spring Data projects, when you create an interface extending
    from `CassandraRepository`, Spring Data for Apache Cassandra generates an implementation
    and registers the implementation as a *bean* to make it available for the rest
    of the components.
  prefs: []
  type: TYPE_NORMAL
- en: It can generate the implementation using the naming convention and using the
    `@Query` annotation. Both ways generate an implementation using Cassandra templates,
    something that will be detailed in the next recipe.
  prefs: []
  type: TYPE_NORMAL
- en: We haven’t covered CQL yet, a syntactically similar language to SQL, but with
    important differences as Cassandra is a NoSQL technology. For instance, it doesn’t
    support **JOIN** queries.
  prefs: []
  type: TYPE_NORMAL
- en: Note that in the `findByTargetTypeAndTargetId` method, we used `@AllowFiltering`.
    Cassandra is a NoSQL database that’s designed for high availability and scalability
    but it achieves these features by limiting the types of queries it can handle
    efficiently. Cassandra is optimized for fast retrieval of data based on the primary
    key or clustering columns. When you query data in Cassandra, it’s expected that
    you provide at least the primary key components to locate the data efficiently.
  prefs: []
  type: TYPE_NORMAL
- en: However, in some cases, you may need to perform queries that filter data on
    non-primary key columns. These types of queries are not efficient in Cassandra
    as they may require a full table scan and can be very slow on large datasets.
    You can use the `@AllowFiltering` annotation to explicitly indicate to Spring
    Data for Apache Cassandra that you’re aware of the performance implications and
    that you want to perform such a query despite its potential inefficiency.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'It is recommended that you get familiar with CQL if you plan to work with Cassandra.
    You can find more information about it on the project page: [https://cassandra.apache.org/doc/stable/cassandra/cql/](https://cassandra.apache.org/doc/stable/cassandra/cql/).'
  prefs: []
  type: TYPE_NORMAL
- en: Using Testcontainers with Cassandra
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To ensure the reliability of our application, we need to run integration tests
    with our Cassandra project. Similar to MongoDB, we have two options for running
    tests with Cassandra – either by using an in-memory embedded Cassandra server
    or Testcontainers. However, I recommend using Testcontainers with a Cassandra
    server as this eliminates any potential compatibility issues since it uses a real
    Cassandra instance.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will learn how to use the Testcontainers Cassandra module
    to create integration tests for our Comments service.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this recipe, we will create an integration test for the Comments service
    that we created in the *Connecting your application to Apache Cassandra* recipe.
    If you haven’t completed this recipe yet, you can use the project that I have
    prepared. You can find it in this book’s GitHub repository at [https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook/](https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook/),
    in the `chapter6/recipe6-8/start` folder.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Are you ready to take your application to the next level? Let’s start preparing
    it so that it can run Testcontainers and see how we can improve it!
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ll start by adding the Testcontainers dependencies to our `pom.xml` file
    – that is, the general Testcontainers dependency and the Cassandra Testcontainers
    module:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, create a file named `createKeyspace.cql` in the test `resources` folder.
    This file should contain the Cassandra Keyspace creation command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we can create a test class for our `CommentService`. You can name the
    test class `CommentServiceTest`. Before we start creating the test, we’ll need
    to set up the Testcontainer. For that, do the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Annotate the test class with `@Testcontainers`:'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Declare a static `CassandraContainer` field:'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Here, we’ll specify the Cassandra Docker image. We’ll use the default `cassandra`
    image.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: We must apply the Cassandra script to be executed during the container initialization
    process – that is, `createKeyspace.cql`, which we defined in *Step 2*.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We must also expose the port where Cassandra listens for connections – that
    is, port `9042`:'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'The last Testcontainers configuration involves setting the Cassandra connection
    setting in the application context. For that, we’ll use `@DynamicPropertySource`
    and the properties that were provided by the `cassandraContainer` field we declared
    previously:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can create our integration test. Let’s name it `postCommentTest`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `org.testcontainers:cassandra` dependency contains the `CassandraContainer`
    class, which provides most of the functionality required to set up the Testcontainer
    for our integration test. It allows us to specify the Docker image we want to
    use.
  prefs: []
  type: TYPE_NORMAL
- en: Here, `withInitScript` executes CQL scripts in Cassandra by taking a file from
    the test’s classpath. This simplifies execution as file copying and client tool
    availability are not a concern. We used this functionality to create the Keyspace,
    as we did in the *Getting ready* section of the *Connecting your application to
    Apache* *Cassandra* recipe.
  prefs: []
  type: TYPE_NORMAL
- en: We don’t need to manually check if the Container service is ready to accept
    connections. Testcontainers automatically waits until the service is ready to
    initiate the tests.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we used the properties exposed by the `CassandraContainer` class to
    configure the connection. We used the `getContactPoint` method to get the server
    host address, the `getPort` method to get the port exposed by the container, and
    the `getLocalDatacenter` method to get the simulated datacenter name.
  prefs: []
  type: TYPE_NORMAL
- en: Using Apache Cassandra templates
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We may want to access our data hosted in Cassandra in a more flexible way than
    the one provided by `CassandraRepository`. For instance, we may want to retrieve
    data from our comments system using a dynamic or complex query, execute operations
    in batch, or access a low-level feature. In those cases, it is more convenient
    to use a Cassandra template as it provides more low-level access to Cassandra’s
    features.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will implement functionality that will dynamically search
    comments using different parameters, such as a date range, tags, and so on. For
    that, we’ll use **Cassandra templates**.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will use the same tools that we did in the *Connecting your application to
    Apache Cassandra* recipe – that is, Docker and Apache Cassandra.
  prefs: []
  type: TYPE_NORMAL
- en: To complete this recipe, you’ll need the project you created for the *Using
    Testcontainers with Cassandra* recipe. If you haven’t completed that recipe yet,
    don’t worry – you can use a full version of the project that I’ve prepared in
    this book’s GitHub repository at [https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook/](https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook/).
    It can be found in the `chapter6/recipe6-9/start` folder.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this recipe, we’ll enhance the Comment service we created in the previous
    recipe with new search functionality so that users can use as many parameters
    as they want:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we need to inject `CassandraTemplate` into our `CommentService` class.
    To do that, modify the constructor so that it makes the Spring Dependency Container
    inject `CassandraTemplate`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, add a new overloading for the `getComments` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This method has two types of parameters: mandatory and optional.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: We assume that users will always retrieve comments associated with a target
    entity – for instance, a player or a match. For that reason, the `targetType`
    and `targetId` parameters are mandatory.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The rest of the parameters are optional; hence they are defined as `Optional<T>`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'In this new method, we will use the `QueryBuilder` component to create our
    query:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here, we selected the `comment` table by using `selectFrom`, and we set the
    mandatory columns, `targetType`, and `targetId`, by using `whereColumn`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The rest of the optional fields will use `whereColumn`, but only if they are
    provided:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, we can use the query with `CassandraTemplate` by using the `select`
    method. Let’s do it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here, we used `allowFiltering`. Since we are not using the primary key, we need
    to tell Cassandra that we assume that the query is potentially inefficient.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: We implemented the new feature for our Comment service to perform dynamic queries
    using `CassandraTemplate`. Now, you can create a RESTful API interface to interact
    with the new feature. I’ve created a sample RESTful API that uses the new feature
    and prepared integration tests for the Comments service. You can find these in
    this book’s GitHub repository at [https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook/](https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook/),
    in the `chapter6/recipe6-9/end` folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Spring Data for Apache Cassandra registers a `CassandraTemplate` bean in the
    Spring Boot Dependency Container. It is used internally to implement the repositories
    described in the *Connecting your application to Apache Cassandra* recipe. By
    doing this, it can be injected into our components by Spring Boot.
  prefs: []
  type: TYPE_NORMAL
- en: You can compose a CQL string by concatenating the predicates, but this is prone
    to introducing typos in queries. That’s why we used `QueryBuilder`. As I explained
    in the *Connecting your application to Apache Cassandra* recipe, we need to set
    `allowFiltering` when we make queries that don’t use the table primary key.
  prefs: []
  type: TYPE_NORMAL
- en: There’s more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We can do the same query by building a string with a dynamic CQL statement.
    This would look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: Managing concurrency with Apache Cassandra
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We want to enhance our comments system by adding a new feature: upvoting comments.
    We will add a counter to our comments showing the positive votes that have been
    received.'
  prefs: []
  type: TYPE_NORMAL
- en: This simple requirement can be complex in a high-concurrency scenario. If multiple
    users are upvoting a comment, it may happen that we aren’t updating the latest
    version of the comment. To tackle this scenario, we will use an optimistic concurrency
    approach with Cassandra.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will use the same tools that we did in the *Connecting your application to
    Apache Cassandra* recipe – that is, Docker and Apache Cassandra.
  prefs: []
  type: TYPE_NORMAL
- en: The starting point will be the project we created for the *Using Apache Cassandra
    Templates* recipe. If you haven’t completed it yet, don’t worry – you can use
    a full version of the project that I’ve prepared in this book’s GitHub repository
    at [https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook/](https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook/).
    It can be found in the `chapter6/recipe6-10/start` folder.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this recipe, we will implement the upvoting feature using optimistic concurrency.
    But before that, we’ll need to prepare our comment entity. Let’s get started:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The first thing we’ll need to do is create a new field that will store the
    number of upvotes received by a comment. So, let’s modify the `Comment` class
    by adding a new field named `upvotes`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We’ll need to modify the table schema in the Cassandra server. For that, we’ll
    need to connect to the server and execute a `cqlsh` command. The easiest way to
    do this is by connecting to the Docker container. The following command will open
    an interactive session in `cqlsh`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now, you can exit `cqlsh` by executing the `quit;` command.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: It isn’t possible to assign default values in Cassandra. If you have existing
    comments in your database, Cassandra will return a `null` value for field upvotes.
    So, we’ll need to manage this scenario accordingly.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now, it’s time to use the new field in a new operation. We’ll implement that
    operation in our `CommentService` service by creating a new method named `upvoteComment`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we’ll retrieve the first comment. We can use the existing `CommentRepository`
    or `CassandraTemplate`. We’ll use `CommentRepository` as it is simpler:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we need to update the upvotes field, but we’ll keep the current value:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we’ll use the current value to create the condition. Only if we are updating
    the current value will we apply the change:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we need to check if the result was what we expected:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: If the result is not what we expected, we can retry the operation a few times
    while waiting a few milliseconds between executions, but this will depend on the
    requirements of the application.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Now, you can implement a RESTful API for this new functionality. I’ve prepared
    a sample RESTful API and integration tests in this book’s GitHub repository at
    [https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook/](https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook/),
    in the `chapter6/recipe6-10/end` folder.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The key to optimistic concurrency management in Cassandra is the conditional
    update command. In CQL, Cassandra provides an `IF` clause that we can use in `CassandraTemplate`.
    With this `IF` clause, you can conditionally update data, but only if certain
    conditions are met, which includes checking the current state of the data.
  prefs: []
  type: TYPE_NORMAL
- en: We could create a `version` field in the comments table to implement a mechanism,
    as we saw in the *Managing concurrency with MongoDB* recipe. However, Spring Data
    for Apache Cassandra does not provide any special capability to manage this automatically,
    so we would need to implement it ourselves. In addition, we don’t expect any other
    change in the `comment` entity, so we can use upvotes to control if the row has
    been modified. The `upvotes` field is our `version` field.
  prefs: []
  type: TYPE_NORMAL
- en: 'Part 3: Application Optimization'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In large-scale applications, it’s necessary to understand where the bottlenecks
    are and how they can be improved. In this part, we’ll follow a systematic approach
    to optimizing and measuring the improvements that we apply. We’ll also use advanced
    techniques such as reactive programming and event-driven design.
  prefs: []
  type: TYPE_NORMAL
- en: 'This part has the following chapters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[*Chapter 7*](B21646_07.xhtml#_idTextAnchor326), *Finding Bottlenecks and Optimizing
    Your Application*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 8*](B21646_08.xhtml#_idTextAnchor365), *Spring Reactive and Spring
    Cloud Stream*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
