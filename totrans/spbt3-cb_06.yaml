- en: '6'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '6'
- en: Data Persistence and NoSQL Database Integration with Spring Data
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据持久性和Spring Data与NoSQL数据库集成
- en: SQL and NoSQL databases offer a flexible and scalable approach to data storage
    and retrieval that can be better suited to certain use cases compared to traditional
    relational databases. NoSQL databases are designed for horizontal scale-out, flexibility,
    performance, high availability, and global distribution. However, with this, you
    lose the consistency, ACID compliance, and expressiveness of a full SQL implementation
    that a relational database can provide.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: SQL和NoSQL数据库提供了一种灵活且可扩展的数据存储和检索方法，与传统的数据库相比，它们可能更适合某些用例。NoSQL数据库旨在实现水平扩展、灵活性、性能、高可用性和全球分布。然而，因此您会失去关系型数据库可以提供的完整SQL实现的致性、ACID合规性和表达性。
- en: It’s important to note that NoSQL databases are not a one-size-fits-all solution,
    and their suitability depends on the requirements of your application. In some
    cases, a combination of SQL and NoSQL databases might be the best approach to
    meet different data storage and retrieval needs within an organization.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要注意，NoSQL数据库不是一刀切解决方案，它们的适用性取决于您应用程序的需求。在某些情况下，SQL和NoSQL数据库的组合可能是满足组织内不同数据存储和检索需求的最佳方法。
- en: In this chapter, we will use some of the most popular NoSQL databases. Each
    of them has a different approach to data access, but Spring Boot facilitates the
    developer experience in all of them.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将使用一些最受欢迎的NoSQL数据库。它们各自对数据访问有不同的方法，但Spring Boot在所有这些数据库中都简化了开发体验。
- en: First, we will learn how to use MongoDB, a document-oriented database that stores
    data in JSON-like objects. We will cover the basics of data access in MongoDB,
    as well as other advanced scenarios, such as indexing, transactions, and optimistic
    concurrency persistence.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将学习如何使用MongoDB，这是一个面向文档的数据库，它以类似JSON的对象存储数据。我们将涵盖MongoDB中的数据访问基础，以及其他高级场景，例如索引、事务和乐观并发持久性。
- en: Next, we will learn how to use Apache Cassandra. It is a wide-column store database,
    meaning that it stores data in tables with flexible schema and supports column-family
    data models. We will learn how to perform advanced queries, as well as how to
    manage optimistic concurrency persistency within it.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将学习如何使用Apache Cassandra。它是一个宽列存储数据库，这意味着它以灵活的模式存储数据在表中，并支持列族数据模型。我们将学习如何执行高级查询，以及如何在其中管理乐观并发持久性。
- en: 'In this chapter, we will cover the following recipes:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下菜谱：
- en: Connecting your application to MongoDB
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将您的应用程序连接到MongoDB
- en: Using Testcontainers with MongoDB
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Testcontainers与MongoDB
- en: Data indexing and sharding in MongoDB
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: MongoDB中的数据索引和分片
- en: Using transactions in MongoDB
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在MongoDB中使用事务
- en: Managing concurrency with MongoDB
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用MongoDB管理并发
- en: Connecting your application to Apache Cassandra
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将您的应用程序连接到Apache Cassandra
- en: Using Testcontainers with Apache Cassandra
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Testcontainers与Apache Cassandra
- en: Using Apache Cassandra templates
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Apache Cassandra模板
- en: Managing concurrency with Apache Cassandra
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Apache Cassandra管理并发
- en: Technical requirements
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: For this chapter, you will need a MongoDB server and an Apache Cassandra server.
    In both cases, the easiest way to deploy them in your local environment is by
    using Docker. You can get Docker from its product page at [https://www.docker.com/products/docker-desktop/](https://www.docker.com/products/docker-desktop/).
    I will explain how to install MongoDB and Cassandra using Docker in the respective
    recipes.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本章，您需要一个MongoDB服务器和一个Apache Cassandra服务器。在两种情况下，在您的本地环境中部署它们的最简单方法是通过使用Docker。您可以从其产品页面[https://www.docker.com/products/docker-desktop/](https://www.docker.com/products/docker-desktop/)获取Docker。我将在相应的菜谱中解释如何使用Docker安装MongoDB和Cassandra。
- en: 'If you wish to install MongoDB on your computer, you can follow the installation
    instructions on the product page: [https://www.mongodb.com/try/download/community](https://www.mongodb.com/try/download/community).'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想在您的计算机上安装MongoDB，可以遵循产品页面上的安装说明：[https://www.mongodb.com/try/download/community](https://www.mongodb.com/try/download/community)。
- en: If you need to access MongoDB, you can use MongoDB Shell or MongoDB Compass,
    both of which can be found at [https://www.mongodb.com/try/download/tools](https://www.mongodb.com/try/download/tools).
    I will be using MongoDB Shell in this chapter, so I recommend installing it.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您需要访问MongoDB，您可以使用MongoDB Shell或MongoDB Compass，这两个都可以在[https://www.mongodb.com/try/download/tools](https://www.mongodb.com/try/download/tools)找到。我将在本章中使用MongoDB
    Shell，因此我建议您安装它。
- en: For Cassandra, you can follow the instructions at [https://cassandra.apache.org/doc/latest/cassandra/getting_started/installing.html](https://cassandra.apache.org/doc/latest/cassandra/getting_started/installing.html).
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Cassandra，您可以遵循[https://cassandra.apache.org/doc/latest/cassandra/getting_started/installing.html](https://cassandra.apache.org/doc/latest/cassandra/getting_started/installing.html)中的说明。
- en: 'All the recipes that will be demonstrated in this chapter can be found at:
    [https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook/tree/main/chapter6](https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook/tree/main/chapter6).'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将展示的所有菜谱都可以在[https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook/tree/main/chapter6](https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook/tree/main/chapter6)找到。
- en: Connecting your application to MongoDB
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将您的应用程序连接到MongoDB
- en: In this recipe, we will learn how to deploy a MongoDB server in Docker. Next,
    we will create a Spring Boot application and connect it to our MongoDB server
    using Spring Data MongoDB. Finally, we will initialize the database and perform
    some queries against the data that’s been loaded.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将学习如何在Docker中部署MongoDB服务器。接下来，我们将创建一个Spring Boot应用程序，并使用Spring Data
    MongoDB将其连接到我们的MongoDB服务器。最后，我们将初始化数据库并对已加载的数据执行一些查询。
- en: We will use the scenario of football teams and players to demonstrate the different
    approaches to managing data in MongoDB compared to relational databases such as
    PostgreSQL.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过足球队伍和球员的场景来展示在MongoDB中管理数据的不同方法，与诸如PostgreSQL这样的关系型数据库相比。
- en: Getting ready
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: For this recipe, we will use a MongoDB database. The easiest way to deploy it
    on your computer is by using Docker. You can download Docker from the product
    page at [https://www.docker.com/products/docker-desktop/](https://www.docker.com/products/docker-desktop/).
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个菜谱，我们将使用MongoDB数据库。在您的计算机上部署它的最简单方法是使用Docker。您可以从[https://www.docker.com/products/docker-desktop/](https://www.docker.com/products/docker-desktop/)的产品页面下载Docker。
- en: Once you have installed Docker, you can run a single instance of MongoDB or
    execute a cluster running in a replica set. Here, you will deploy a cluster running
    in a replica set. This is not necessary for this recipe but will be necessary
    for the following recipes as it is necessary to support transactions. I’ve prepared
    a script to facilitate the deployment of the cluster. This script deploys the
    cluster using `docker-compose`; once deployed, it initializes the replica set.
    You can find the script in this book’s GitHub repository at [https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook/](https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook/),
    in the `chapter3/recipe3-2/start` folder.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 安装Docker后，您可以运行一个MongoDB的单实例或执行一个运行在副本集中的集群。在这里，您将部署一个运行在副本集中的集群。对于这个菜谱来说这不是必要的，但对于后续的菜谱来说却是必要的，因为它需要支持事务。我已经准备了一个脚本以简化集群的部署。这个脚本使用`docker-compose`部署集群；一旦部署，它将初始化副本集。您可以在本书的GitHub仓库[https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook/](https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook/)中的`chapter3/recipe3-2/start`文件夹中找到这个脚本。
- en: You will need MongoDB Shell to connect to the MongoDB server. You can download
    it from [https://www.mongodb.com/try/download/shell](https://www.mongodb.com/try/download/shell).
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要MongoDB Shell来连接到MongoDB服务器。您可以从[https://www.mongodb.com/try/download/shell](https://www.mongodb.com/try/download/shell)下载它。
- en: 'You will also need the *mongoimport* tool to import some data into the database.
    It is part of MongoDB’s database tools. Follow the instructions on the product
    page to install it: [https://www.mongodb.com/docs/database-tools/installation/installation/](https://www.mongodb.com/docs/database-tools/installation/installation/).'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 您还需要*mongoimport*工具将一些数据导入数据库。它是MongoDB数据库工具的一部分。按照产品页面上的说明进行安装：[https://www.mongodb.com/docs/database-tools/installation/installation/](https://www.mongodb.com/docs/database-tools/installation/installation/)。
- en: 'The data, once loaded, will look like this:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 数据加载后，将看起来像这样：
- en: '[PRE0]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Each team has a list of players. Keep this structure in mind to better understand
    this recipe.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 每个队伍都有一个球员列表。记住这个结构，以便更好地理解这个菜谱。
- en: You can use *MongoDB Shell* to connect to the database. We will use it to create
    a database and initialize it with some data. You can find a script to load the
    data in this book’s GitHub repository at [https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook/](https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook/).
    The script and the data are in the `chapter3/recipe3-1/start/data` folder.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用*MongoDB Shell*连接到数据库。我们将使用它来创建一个数据库，并用一些数据初始化它。您可以在本书的GitHub仓库[https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook/](https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook/)中找到加载数据的脚本。脚本和数据位于`chapter3/recipe3-1/start/data`文件夹中。
- en: How to do it...
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Let’s create a project using Spring Data MongoDB and create a repository to
    connect to our database. The database manages football teams, which include players.
    We will create some queries to get teams and players, and we will implement operations
    to make changes to our data. Follow these steps:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用 Spring Data MongoDB 创建一个项目，并创建一个存储库来连接到我们的数据库。数据库管理足球团队，包括球员。我们将创建一些查询来获取团队和球员，并将实现操作来更改我们的数据。按照以下步骤操作：
- en: 'Create a project using the *Spring Initializr* tool. Open [https://start.spring.io](https://start.spring.io)
    and use the same parameters that you did in the *Creating a RESTful API* recipe
    of [*Chapter 1*](B21646_01.xhtml#_idTextAnchor020), except change the following
    options:'
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 *Spring Initializr* 工具创建一个项目。打开 [https://start.spring.io](https://start.spring.io)
    并使用与 [*第 1 章*](B21646_01.xhtml#_idTextAnchor020) 中 *创建 RESTful API* 菜谱相同的参数，除了以下选项：
- en: For `footballmdb`
  id: totrans-38
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于 `footballmdb`
- en: For **Dependencies**, select **Spring Web** and **Spring** **Data MongoDB**
  id: totrans-39
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于 **依赖项**，选择 **Spring Web** 和 **Spring Data MongoDB**
- en: Download the template that was generated with the *Spring Initializr* tool and
    unzip the content to your working directory.
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下载使用 *Spring Initializr* 工具生成的模板，并将其内容解压缩到您的工作目录中。
- en: 'First, we will configure Spring Data MongoDB to connect to our database. For
    that purpose, create an `application.yml` file in the `resources` folder. It should
    look like this:'
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们将配置 Spring Data MongoDB 以连接到我们的数据库。为此，在 `resources` 文件夹中创建一个 `application.yml`
    文件。它应该看起来像这样：
- en: '[PRE1]'
  id: totrans-42
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Now, create a class named `Team` and annotate it with `@Document(collection
    = teams)`. It should look like this:'
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，创建一个名为 `Team` 的类，并使用 `@Document(collection = teams)` 进行注解。它应该看起来像这样：
- en: '[PRE2]'
  id: totrans-44
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Note that we also decorated the attribute ID with `@Id` and we are using `List<Player>`
    in our class. We will have a single collection of data in MongoDB called `teams`.
    Each team will contain players.
  id: totrans-45
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意，我们还用 `@Id` 装饰了属性 ID，并在我们的类中使用 `List<Player>`。在 MongoDB 中，我们将有一个名为 `teams`
    的单个数据集合。每个团队将包含球员。
- en: 'Next, create the `Player` class:'
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，创建 `Player` 类：
- en: '[PRE3]'
  id: totrans-47
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The `Player` class does not require any special annotation as it’s data that
    will be embedded in the `Team` document.
  id: totrans-48
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`Player` 类不需要任何特殊注解，因为它的数据将被嵌入到 `Team` 文档中。'
- en: 'Now, create a repository to manage the teams persisted in MongoDB:'
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，创建一个用于管理在 MongoDB 中持久化的团队的存储库：
- en: '[PRE4]'
  id: totrans-50
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'As it happens with `JpaRepository`, just by extending our `TeamRepository`
    interface from `MongoRepository`, we already have basic methods to manipulate
    `Team` documents in MongoDB. We will use this repository now. To do that, create
    a new service named `FootballService`:'
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 就像 `JpaRepository` 一样，只需通过从 `MongoRepository` 扩展我们的 `TeamRepository` 接口，我们就已经有了在
    MongoDB 中操作 `Team` 文档的基本方法。我们现在将使用这个存储库。为此，创建一个名为 `FootballService` 的新服务：
- en: '[PRE5]'
  id: totrans-52
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Now, we can create a new method in our service that retrieves a team using
    its `Id` value. This method in the service can use the `findById` method in `TeamRepository`,
    which is available by extending from `MongoRepository`:'
  id: totrans-53
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在，我们可以在我们的服务中创建一个新的方法，用于通过其 `Id` 值检索一个团队。这个服务中的方法可以使用 `TeamRepository` 中的 `findById`
    方法，该方法是通过对 `MongoRepository` 进行扩展而可用的：
- en: '[PRE6]'
  id: totrans-54
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'We can also create a method to find the teams with a name that contains a string:'
  id: totrans-55
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们还可以创建一个方法来查找包含字符串的团队名称：
- en: '[PRE7]'
  id: totrans-56
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Now, we will create a method to find a player. For this, we will need to look
    into the teams to find the player. It can be implemented by using the `@``Query`
    annotation:'
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将创建一个用于查找球员的方法。为此，我们需要查看团队以找到球员。可以通过使用 `@Query` 注解来实现：
- en: '[PRE8]'
  id: totrans-58
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: As you can see, the query’s `value` attribute is not SQL – it’s in `fields`
    attribute corresponds to the fields we want to retrieve from the document – in
    this case, just the `players` field of the document. This method will return a
    `Team` object with only one player.
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如您所见，查询的 `value` 属性不是 SQL，它在 `fields` 属性中对应于我们想要从文档中检索的字段——在这种情况下，只是文档的 `players`
    字段。此方法将返回一个只包含一个球员的 `Team` 对象。
- en: 'Let’s see how we can use this method. To do so, create a method in `FootballService`
    named `findPlayerById`:'
  id: totrans-60
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 让我们看看如何使用这个方法。为此，在 `FootballService` 中创建一个名为 `findPlayerById` 的方法：
- en: '[PRE9]'
  id: totrans-61
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'We will use the `save` method of `MongoRepository` to *upsert* teams and `delete`/`deleteById`
    to make changes in the database:'
  id: totrans-62
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们将使用 `MongoRepository` 的 `save` 方法来 *upsert* 团队，以及使用 `delete`/`deleteById`
    来在数据库中做出更改：
- en: '`saveTeam` in the `FootballService` class:'
  id: totrans-63
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FootballService` 类中的 `saveTeam`：'
- en: '[PRE10]'
  id: totrans-64
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Now, create a method to delete a team by its ID:'
  id: totrans-65
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 现在，创建一个通过其 ID 删除团队的方法：
- en: '[PRE11]'
  id: totrans-66
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: In this recipe, we implemented a service that uses `MongoRepository` to perform
    the basic operations to interact with our MongoDB database. I’ve created a RESTful
    API to expose the methods that were implemented by the `FootballService` service
    that was created in this recipe. I’ve also created a script to make the requests
    to the RESTful API. You can find all this in this book’s GitHub repository, in
    the `chapter6/reciper6-1/end` folder.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们实现了一个使用 `MongoRepository` 来执行与我们的 MongoDB 数据库交互的基本操作的服务。我已经创建了一个 RESTful
    API 来公开由本菜谱中创建的 `FootballService` 服务实现的方法。我还创建了一个脚本来向 RESTful API 发送请求。您可以在本书的
    GitHub 仓库中找到所有这些内容，在 `chapter6/reciper6-1/end` 文件夹中。
- en: How it works...
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: When the application starts, Spring Data MongoDB scans the application looking
    for `MongoRepository` interfaces. Then, it generates the implementation for the
    methods defined in the repository and registers the interface implementation as
    a bean to make it available for the rest of the application. To infer the implementation
    of the interface, it uses the naming convention of the methods; see https://docs.spring.io/spring-data/mongodb/docs/current/reference/html/#repository-query-keywords
    for more details. Spring Data MongoDB also scans for methods with the `@Query`
    annotation to generate the implementation for those methods.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 当应用程序启动时，Spring Data MongoDB 会扫描应用程序以查找 `MongoRepository` 接口。然后，它为存储库中定义的方法生成实现，并将接口实现注册为
    bean 以使其对应用程序的其余部分可用。为了推断接口的实现，它使用方法的命名约定；有关更多详细信息，请参阅 https://docs.spring.io/spring-data/mongodb/docs/current/reference/html/#repository-query-keywords。Spring
    Data MongoDB 还会扫描带有 `@Query` 注解的方法以生成这些方法的实现。
- en: Regarding the `@Query` annotation, Spring Data MongoDB can do certain validations,
    but you should keep in mind that MongoDB is schema-flexible by design. This means
    that it doesn’t assume that a field should or shouldn’t exist. It will return
    a `null` value instead. Keep in mind that if the results are different from what
    you expected, there is probably a typo in your query.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 关于 `@Query` 注解，Spring Data MongoDB 可以执行某些验证，但你应该记住 MongoDB 是按设计灵活的。这意味着它不假设某个字段应该存在或不存在。它将返回一个
    `null` 值。请注意，如果结果与您预期的不同，您的查询可能存在拼写错误。
- en: 'In `findPlayerById`, we implemented a query to return an element of an array
    in a document. It is important to understand the data that’s returned by MongoDB.
    When we want to find player `430530`, it returns the container document, a `Team`
    object with an `id` value of 1882891, with just the property players, and an array
    of just one element – that is, the player with ID `430530`. It looks like this:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `findPlayerById` 中，我们实现了一个查询以返回文档中的数组元素。理解 MongoDB 返回的数据非常重要。当我们想要找到球员 `430530`
    时，它返回一个容器文档，一个具有 `id` 值为 1882891 的 `Team` 对象，仅包含属性 `players` 和一个仅包含一个元素的数组 - 即具有
    ID `430530` 的球员。它看起来像这样：
- en: '[PRE12]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Note
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: I’ve included players in the team collection for learning purposes. If you have
    a similar scenario and you expect to perform a lot of queries while searching
    for an element of an array in a collection, you might prefer to have a MongoDB
    collection for that array. In this case, I would store players in their own collection.
    It will perform and scale much better.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 我为了学习目的在团队集合中包含了球员。如果您有类似的场景，并且您在集合中搜索数组元素时预期将执行大量查询，您可能更喜欢为该数组拥有一个 MongoDB
    集合。在这种情况下，我会将球员存储在它们自己的集合中。这将执行得更好，并且可扩展性更强。
- en: 'Here, `MongoRepository` provides three methods to save data:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`MongoRepository` 提供了三种方法来保存数据：
- en: '`save`: This method inserts a document if it doesn’t exist and replaces it
    if it does exist. This behavior is also known as *upsert*.'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`save`: 此方法如果文档不存在则插入文档，如果文档已存在则替换它。这种行为也称为 *upsert*。'
- en: '`saveAll`: This method behaves in the same way as `save`, but it allows you
    to persist a list of documents at the same time.'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`saveAll`: 此方法的行为与 `save` 相同，但它允许您同时持久化多个文档。'
- en: '`insert`: This method adds a new document to the collection. So, if the document
    already exists, it will fail. This method is optimized for inserting operations
    as it doesn’t check the previous existence of the document.'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`insert`: 此方法向集合中添加一个新的文档。因此，如果文档已存在，它将失败。此方法针对插入操作进行了优化，因为它不会检查文档的先前存在。'
- en: The `save` and `saveAll` methods replace the document entirely if it already
    exists. If you only want to update certain properties of your entity, also known
    as partial document updates, you will need to use Mongo templates.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '`save` 和 `saveAll` 方法会完全替换已存在的文档。如果你只想更新实体的一些属性，也称为部分文档更新，你需要使用 Mongo 模板。'
- en: There’s more...
  id: totrans-80
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多...
- en: 'I recommend looking to `MongoTemplate` for more advanced scenarios, such as
    when you need partial updates. Here’s an example of it if you only want to update
    the team name:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 我建议在更高级的场景中查看 `MongoTemplate`，例如当你需要部分更新时。以下是一个示例，如果你只想更新团队名称：
- en: '[PRE13]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: As you can see, it allows you to define the `where` criteria to query the object
    and allows the *update* operation, defining which fields you want to update. Here,
    `MongoTemplate` is the core component used by Spring Data MongoDB to create the
    implementation of `MongoRepository` interfaces.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，它允许你定义查询对象的 `where` 条件，并允许 *更新* 操作，定义你想要更新的字段。在这里，`MongoTemplate` 是 Spring
    Data MongoDB 用于创建 `MongoRepository` 接口实现的核心理念组件。
- en: Using Testcontainers with MongoDB
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Testcontainers 与 MongoDB
- en: 'When creating integration tests that depend on MongoDB, we have two options:
    using an in-memory database server embedded in our application or using Testcontainers.
    The in-memory database server can have slight differences from our production
    system. For that reason, I recommend using Testcontainers; it allows you to use
    a real MongoDB database hosted in Docker with all features enabled.'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 当创建依赖于 MongoDB 的集成测试时，我们有两种选择：在我们的应用程序中嵌入一个内存数据库服务器或使用 Testcontainers。内存数据库服务器可能与我们的生产系统略有不同。出于这个原因，我建议使用
    Testcontainers；它允许你使用一个在 Docker 中托管并启用所有功能的真实 MongoDB 数据库。
- en: In this recipe, we’ll learn how to set up a MongoDB Testcontainer and how to
    execute some initialization scripts so that we can insert test data into the database.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将学习如何设置 MongoDB Testcontainer 以及如何执行一些初始化脚本，以便我们可以将测试数据插入到数据库中。
- en: Getting ready
  id: totrans-87
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Executing Testcontainers requires a Docker-API compatible runtime. You can
    install Docker by following the instructions on the official web page: [https://www.docker.com/products/docker-desktop/](https://www.docker.com/products/docker-desktop/).'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 执行 Testcontainers 需要一个与 Docker-API 兼容的运行时。你可以通过遵循官方网页上的说明来安装 Docker：[https://www.docker.com/products/docker-desktop/](https://www.docker.com/products/docker-desktop/)。
- en: In this recipe, we’ll add tests for the project we created in the *Connecting
    your application to MongoDB* recipe. I’ve created a working version of that recipe
    in case you haven’t completed it yet. You can find it in this book’s GitHub repository
    at [https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook](https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook),
    in the `chapter6/recipe6-2/start` folder. In this folder, you will also find a
    file named `teams.json`. This will be used to initialize the data for the tests.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将为在 *将你的应用程序连接到 MongoDB* 菜谱中创建的项目添加测试。我已创建了一个可工作的版本，以防你还没有完成它。你可以在本书的
    GitHub 仓库中找到它，在 [https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook](https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook)
    的 `chapter6/recipe6-2/start` 文件夹中。在这个文件夹中，你还会找到一个名为 `teams.json` 的文件。这将用于初始化测试数据。
- en: How to do it...
  id: totrans-90
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Let’s enhance our project by creating automated tests with Testcontainers:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过使用 Testcontainers 创建自动化测试来增强我们的项目：
- en: 'First, we’ll need to include the Testcontainers dependencies. For that, open
    the `pom.xml` file and add the following dependencies:'
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们需要包含 Testcontainers 依赖项。为此，打开 `pom.xml` 文件并添加以下依赖项：
- en: '[PRE14]'
  id: totrans-93
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: As we’ll need to initialize the data in the database during the test execution,
    copy the `team.json` file described in the *Getting ready* section into the `tests/resources/mongo`
    folder.
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于我们需要在测试执行期间初始化数据库中的数据，将 *准备阶段* 中描述的 `team.json` 文件复制到 `tests/resources/mongo`
    文件夹中。
- en: 'Next, create a test class. Let’s name it `FootballServiceTest`, and annotate
    the class with `@SpringBootTest` and `@Testcontainers`:'
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，创建一个测试类。让我们称它为 `FootballServiceTest`，并使用 `@SpringBootTest` 和 `@Testcontainers`
    注解该类：
- en: '[PRE15]'
  id: totrans-96
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'We’ll continue setting up the test class by creating the MongoDB container.
    As we’ll see in the next step, we’ll need to initialize the database with some
    data. For that, we’ll copy the `teams.json` file described in *Step 2* to the
    container. We’ll create the container and pass the file as follows:'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将继续设置测试类，通过创建 MongoDB 容器。正如我们将在下一步看到的，我们需要用一些数据初始化数据库。为此，我们将把 *步骤 2* 中描述的
    `teams.json` 文件复制到容器中。我们将创建容器并按以下方式传递文件：
- en: '[PRE16]'
  id: totrans-98
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '@BeforeAll'
  id: totrans-99
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '@BeforeAll'
- en: static void startContainer() throws IOException, InterruptedException {
  id: totrans-100
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: static void startContainer() throws IOException, InterruptedException {
- en: mongoDBContainer.start();
  id: totrans-101
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: mongoDBContainer.start();
- en: importFile("teams");
  id: totrans-102
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: importFile("teams");
- en: '}'
  id: totrans-103
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '}'
- en: static void importFile(String fileName) throws IOException, InterruptedException
    {
  id: totrans-104
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: static void importFile(String fileName) throws IOException, InterruptedException
    {
- en: Container.ExecResult res = mongoDBContainer.execInContainer("mongoimport", "--db=football",
    "--collection=" + fileName, "--jsonArray", fileName + ".json");
  id: totrans-105
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Container.ExecResult res = mongoDBContainer.execInContainer("mongoimport", "--db=football",
    "--collection=" + fileName, "--jsonArray", fileName + ".json");
- en: if (res.getExitCode() > 0){
  id: totrans-106
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: if (res.getExitCode() > 0){
- en: throw new RuntimeException("MongoDB not properly initialized");
  id: totrans-107
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: throw new RuntimeException("MongoDB not properly initialized");
- en: '}'
  id: totrans-108
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-109
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '}'
- en: '[PRE17]'
  id: totrans-110
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Now, we should configure the context so that it uses the MongoDB database hosted
    in Testcontainers. For that, we’ll use the `@``DynamicPropertySource` annotation:'
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们应该配置上下文，使其使用在Testcontainers中托管的MongoDB数据库。为此，我们将使用`@DynamicPropertySource`注解：
- en: '[PRE18]'
  id: totrans-112
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Now that the MongoDB repository has been configured, we can continue with the
    normal test implementation. Let’s inject `FootballService` into the test class
    and implement a simple test that will retrieve a `Team` object:'
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在MongoDB仓库已经配置好了，我们可以继续进行正常的测试实现。让我们将`FootballService`注入到测试类中，并实现一个简单的测试，用于检索`Team`对象：
- en: '[PRE19]'
  id: totrans-114
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: You can implement the tests for the rest of the functionality. I’ve created
    some basic tests for the `FootballService` class. You can find them in this book’s
    GitHub repository at [https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook](https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook),
    in the `chapter6/recipe6-2/end` folder.
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您可以实现其余功能的测试。我为`FootballService`类创建了一些基本的测试。您可以在本书的GitHub仓库中找到它们，网址为[https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook](https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook)，在`chapter6/recipe6-2/end`文件夹中。
- en: How it works...
  id: totrans-116
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: As we saw in the *PostgreSQL integration tests with Testcontainers* recipe of
    [*Chapter 5*](B21646_05.xhtml#_idTextAnchor203), by adding the `@Testcontainers`
    annotation, all the containers that are declared as static are available for all
    the tests in the class and stopped after the last test is executed. In this recipe,
    we used the specialized `MongoDBContainer` container; it provides the URL of the
    server, which we can use to configure the test context. This configuration is
    performed by using the `@DynamicPropertySource` annotation, as we saw in *Step
    6*.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在[*第5章*](B21646_05.xhtml#_idTextAnchor203)的*使用Testcontainers进行PostgreSQL集成测试*配方中看到的，通过添加`@Testcontainers`注解，所有声明为静态的容器都可用于类中的所有测试，并在最后一个测试执行后停止。在这个配方中，我们使用了专门的`MongoDBContainer`容器；它提供了服务器的URL，我们可以用它来配置测试上下文。这种配置是通过使用`@DynamicPropertySource`注解来完成的，正如我们在*步骤6*中看到的。
- en: In this recipe, we learned how to copy files to the container and execute programs
    inside it. All the files in the `resources` folder are available at runtime. We
    copied the `teams.json` file to the container and then used the `mongoimport`
    tool to import the data into MongoDB. This tool is available in the MongoDB Docker
    image. One advantage of executing this tool in the container is that it’s not
    necessary to specify the database server address.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，我们学习了如何将文件复制到容器中并在其中执行程序。`resources`文件夹中的所有文件都在运行时可用。我们将`teams.json`文件复制到容器中，然后使用`mongoimport`工具将数据导入MongoDB。这个工具在MongoDB
    Docker镜像中可用。在容器中执行此工具的一个优点是不需要指定数据库服务器地址。
- en: Data indexing and sharding in MongoDB
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: MongoDB中的数据索引和分片
- en: In this recipe, we will manage football matches and their timeline – that is,
    the events that occur during the game. An event may involve one or two players
    and we must consider that the players’ fans want to access all actions where their
    favorite players are involved. We will also consider that the number of matches
    and their events is growing every day, so we need to prepare our application to
    support all the load.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，我们将管理足球比赛及其时间线——即比赛期间发生的事件。一个事件可能涉及一名或两名球员，我们必须考虑到球员的粉丝想要访问所有涉及他们最喜欢的球员的行动。我们还将考虑比赛及其事件的数量每天都在增长，因此我们需要准备我们的应用程序以支持所有负载。
- en: In this recipe, we’ll introduce some key concepts to make your application performant
    and scalable. MongoDB, like relational databases, enables you to create indexes
    that optimize data access. If you plan to access certain data using the same parameters,
    it is worth creating indexes to optimize data read. Of course, you will require
    more storage and memory, and write operations will be impacted. So, you will need
    to plan and analyze your application needs.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将介绍一些关键概念，以使您的应用程序具有高性能和可扩展性。MongoDB，就像关系数据库一样，允许您创建索引以优化数据访问。如果您计划使用相同的参数访问某些数据，创建索引以优化数据读取是值得的。当然，您将需要更多的存储和内存，并且写操作将受到影响。因此，您需要计划和分析您的应用程序需求。
- en: As the size of your data increases, you will need to scale your MongoDB database.
    **Sharding** is a database architecture and partitioning technique that’s used
    to horizontally partition data across multiple servers or nodes in a distributed
    system. With sharding, you can scale out your database by adding more servers
    and distributing the data across them using shards. A shard ensures that all data
    in the same shard will be on the same server.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 随着您数据量的增加，您将需要扩展您的MongoDB数据库。**分片**是一种数据库架构和分区技术，用于在分布式系统中的多个服务器或节点上水平分区数据。通过分片，您可以通过添加更多服务器并将数据分布到它们上（使用分片）来扩展数据库。分片确保同一分片中的所有数据都将位于同一服务器上。
- en: In this recipe, we will use indexing and sharding in our football application
    while taking advantage of the features provided by Spring Data MongoDB. We will
    use other interesting features of Spring Data MongoDB, such as referring documents
    from other documents.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将使用索引和分片在我们的足球应用程序中，同时利用Spring Data MongoDB提供的功能。我们将使用Spring Data MongoDB的其他有趣功能，例如从其他文档引用文档。
- en: Getting ready
  id: totrans-124
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: We will use the same tools that we did in the first recipe, *Connecting your
    application to MongoDB* – that is, Docker, MongoDB, and MongoDB tools such as
    *Mongo Shell* and *mongoimport*.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用与第一个菜谱中相同工具，*将您的应用程序连接到MongoDB* —— 也就是说，Docker、MongoDB以及MongoDB工具，如*Mongo
    Shell*和*mongoimport*。
- en: We will reuse the code from the *Connecting your application to MongoDB* recipe.
    If you haven’t completed it yet, don’t worry – I’ve prepared a working version
    in this book’s GitHub repository at [https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook/](https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook/).
    It can be found in `chapter6/recipe6-` `3/start`. I’ve also created a script to
    load data into the database using the *mongoimport* tool. This can be found in
    the `chapter6/recipe6-3/start/data` folder.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将重用*将您的应用程序连接到MongoDB*菜谱中的代码。如果您还没有完成它，不要担心——我已经在这个书的GitHub仓库中准备了一个工作版本，网址为[https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook/](https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook/)。您可以在`chapter6/recipe6-`
    `3/start`中找到它。我还创建了一个脚本，用于使用*mongoimport*工具将数据加载到数据库中。您可以在`chapter6/recipe6-3/start/data`文件夹中找到它。
- en: 'The data is a bit different compared to what was provided in the *Connecting
    your application to MongoDB* recipe. I moved the players to their own MongoDB
    collection, and I added new collections to manage the matches and match events.
    If you want to keep the data from the previous recipe, I recommend that you create
    a new database for this recipe. You can do so by simply changing the `--db` parameter
    when calling the `mongoimport` tool. The calls will look like this:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 与*将您的应用程序连接到MongoDB*菜谱中提供的数据相比，数据略有不同。我将球员移动到了他们自己的MongoDB集合中，并添加了新的集合来管理比赛和比赛事件。如果您想保留上一个菜谱中的数据，我建议您为这个菜谱创建一个新的数据库。您可以通过简单地更改调用*mongoimport*工具时的`--db`参数来实现这一点。调用将如下所示：
- en: '[PRE20]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: How to do it...
  id: totrans-129
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'First, we will host the players’ data in their own MongoDB collection. Players
    will be important entities for the new requirements, so they deserve their own
    collection. Then, we will create the document classes for matches and events.
    We will learn how to use Spring Data MongoDB annotations to configure MongoDB
    *indexes* and *shards*. Follow these steps:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将把球员的数据托管在他们自己的MongoDB集合中。球员对于新的需求来说将是重要的实体，因此他们应拥有自己的集合。然后，我们将创建比赛和事件的文档类。我们将学习如何使用Spring
    Data MongoDB注解来配置MongoDB *索引*和*分片*。按照以下步骤操作：
- en: 'Let’s start by configuring players in their own MongoDB collection. Annotate
    the `Player` class with `@Document`:'
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们从配置球员自己的MongoDB集合开始。使用`@Document`注释`Player`类：
- en: '[PRE21]'
  id: totrans-132
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Annotate the `id` field with the `@Id` annotation. We’re doing this as it will
    be the document identifier.
  id: totrans-133
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 使用`@Id`注解注释`id`字段。我们这样做是因为它将是文档标识符。
- en: Now, remove the `players` field from `Team`.
  id: totrans-134
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在，从 `Team` 中删除 `players` 字段。
- en: 'Next, create the classes for matches and their events. For matches, we will
    create a class named `Match`:'
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，创建比赛及其事件的类。对于比赛，我们将创建一个名为 `Match` 的类：
- en: '[PRE22]'
  id: totrans-136
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Note that we started using two new annotations, `@Indexed` and `@DBRef`. They
    will be fully explained in the *How it works...* section of this recipe.
  id: totrans-137
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意，我们开始使用两个新的注解，`@Indexed` 和 `@DBRef`。它们将在本食谱的 *How it works...* 部分中完全解释。
- en: 'For the match events, we will create a class named `MatchEvent`:'
  id: totrans-138
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 对于比赛事件，我们将创建一个名为 `MatchEvent` 的类：
- en: '[PRE23]'
  id: totrans-139
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: With that, we have introduced the `@Sharded` and `@``Field` annotations.
  id: totrans-140
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 通过这样，我们介绍了 `@Sharded` 和 `@Field` 注解。
- en: To be able to use the new classes, we will create a repository for each class
    – that is, `PlayerRepository`, `MatchRepository`, and `MatchEventRepository`.
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了能够使用新类，我们将为每个类创建一个存储库——即 `PlayerRepository`、`MatchRepository` 和 `MatchEventRepository`。
- en: 'Let’s look at `MatchEventRepository` in detail. It will implement the operations
    we need for our requirements:'
  id: totrans-142
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 让我们详细看看 `MatchEventRepository`。它将实现我们所需的要求：
- en: Return all events in a match
  id: totrans-143
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 返回比赛中的所有事件
- en: 'Return all player events in a match:'
  id: totrans-144
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 返回比赛中的所有球员事件：
- en: '[PRE24]'
  id: totrans-145
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'At this point, we could run our application as Spring Data MongoDB components
    are in place. However, not all of the indexes have been created yet. If we want
    to create them as part of our application, we need to create a configuration class
    that extends `AbstractMongoClientConfiguration`, instructing Spring Mongo DB to
    create the indexes automatically:'
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 到目前为止，我们可以运行我们的应用程序，因为 Spring Data MongoDB 组件已经就绪。然而，并非所有索引都已被创建。如果我们想在应用程序中创建它们，我们需要创建一个配置类，该类扩展
    `AbstractMongoClientConfiguration`，指示 Spring Mongo DB 自动创建索引：
- en: '[PRE25]'
  id: totrans-147
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Now, we can create a service using these repositories to implement the new requirements
    of our application while connecting to MongoDB in an optimized way. I’ve created
    a service and a RESTful controller to demonstrate the use of these repositories.
    I’ve also added a few more tests using Testcontainers. You can find them in this
    book’s GitHub repository at [https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook/](https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook/),
    in the `chapter6/recipe6-3/end` folder.
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以使用这些存储库创建一个服务，以实现我们应用程序的新要求，同时以优化的方式连接到 MongoDB。我已经创建了一个服务和 RESTful 控制器来演示这些存储库的使用。我还使用
    Testcontainers 添加了一些测试。您可以在本书的 GitHub 仓库中找到它们，网址为 [https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook/](https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook/)，在
    `chapter6/recipe6-3/end` 文件夹中。
- en: How it works...
  id: totrans-149
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: How it works...
- en: First, I will explain the impact of the annotations that were used in this recipe.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我将解释在这个食谱中使用到的注解的影响。
- en: 'The `@DBRef` annotation is a way to reference another document but keep in
    mind that this is a mechanism that’s implemented by Spring Data MongoDB, not by
    the database engine itself. In MongoDB, the concept of reference integrity doesn’t
    exist, and it should be managed at the application level. Here, `@DBRef` represents
    a document as an object with three fields:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '`@DBRef` 注解是引用另一个文档的一种方式，但请记住，这是一个由 Spring Data MongoDB 实现的机制，而不是由数据库引擎本身实现的。在
    MongoDB 中，引用完整性的概念不存在，它应该在应用程序级别进行管理。在这里，`@DBRef` 将文档表示为一个具有三个字段的对象：'
- en: '`$ref`: This contains the collection being referenced'
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$ref`：这包含被引用的集合'
- en: '`$id`: This contains the ID of the document being referenced'
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$id`：这包含被引用文档的 ID'
- en: '`$db`: This contains the database of the document being referenced'
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$db`：这包含被引用文档的数据库'
- en: 'For example, here, you have a reference to team `1882891`:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，这里有一个对团队 `1882891` 的引用：
- en: '[PRE26]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Spring Data MongoDB can use this annotation to automatically retrieve the referenced
    document. We can specify this behavior using the `lazy` attribute. By default,
    it is `true`, meaning that Spring Data MongoDB won’t retrieve it automatically.
    If you set it to `false`, it will retrieve the referenced document automatically.
    We used this for the match document to automatically retrieve the information
    from the two teams playing the match.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Data MongoDB 可以使用这个注解来自动检索引用的文档。我们可以使用 `lazy` 属性来指定这种行为。默认情况下，它是 `true`，这意味着
    Spring Data MongoDB 不会自动检索它。如果您将其设置为 `false`，它将自动检索引用的文档。我们使用这个注解来检索比赛文档，以自动检索比赛两支队伍的信息。
- en: The `@Indexed` annotation, as you may have figured out, creates an index in
    MongoDB. Then, the queries that use the indexed fields will perform faster for
    read operations.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '`@Indexed` 注解，正如你可能已经猜到的，在 MongoDB 中创建了一个索引。然后，使用索引字段的查询将更快地执行读操作。'
- en: The `@Sharded` annotation tells MongoDB how the collections should be distributed
    across shards. A server in a cluster can host one or more shards. We can also
    see a shard as a way to specify which documents will be hosted on the same server.
    In our case, we are interested in retrieving the events by match. This is the
    reason we configured `match` as the shard key. Selecting a good sharding key is
    crucial to make our application performant and scalable as it will impact the
    way the workload will be distributed across the servers.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '`@Sharded` 注解告诉 MongoDB 如何将集合分布到各个分片中。集群中的服务器可以托管一个或多个分片。我们也可以将分片视为指定哪些文档将托管在同一个服务器上的方式。在我们的案例中，我们感兴趣的是通过匹配检索事件。这就是我们配置
    `match` 作为分片键的原因。选择一个好的分片键对于使我们的应用程序性能良好和可扩展至关重要，因为它将影响工作负载在服务器之间的分布方式。'
- en: When a query is performed in a sharded collection, MongoDB should identify if
    the request can be performed in a single shard or whether it will need to distribute
    the query across shards. It will gather the results from shards, aggregate them,
    and then return the results to the client. If you intentionally need to scale
    out a query horizontally, this is an excellent mechanism. It may happen that a
    request doesn’t need to be distributed and could be executed in a single shard,
    but because of a wrong shard key selection, it is executed as a distributed query.
    The consequence is that it will consume more resources than expected because more
    servers will perform an unnecessary query, so the results have to be aggregated.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 当在一个分片集合中执行查询时，MongoDB 应该确定该请求是否可以在单个分片中执行，或者是否需要将查询分散到多个分片。它将从分片中收集结果，进行聚合，然后将结果返回给客户端。如果你故意需要水平扩展查询，这是一个非常好的机制。可能发生的情况是，请求不需要分散，可以在单个分片中执行，但由于分片键选择错误，它被当作分布式查询执行。结果是，它将消耗比预期更多的资源，因为更多的服务器将执行不必要的查询，因此需要聚合结果。
- en: Sharding involves dividing a database into smaller parts, called shards, that
    can be hosted on a single server. A server can host multiple shards, and the shards
    are replicated across servers for availability. The number of servers can automatically
    increase or decrease, depending on the load. Sharding is useful for managing large
    datasets and large clusters, which are typically deployed in the cloud. For example,
    **MongoDB Atlas** can be hosted on cloud providers such as **Azure**, **Amazon
    Web Services** (**AWS**), and **Google Cloud Platform** (**GCP**), allowing the
    number of servers to be adjusted to meet real demand. However, in cases where
    the database is hosted in a single container on a computer, as in our example,
    sharding won’t provide any significant benefits. In larger deployments, sharding
    is a crucial feature for achieving our goals.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 分片涉及将数据库划分为更小的部分，称为分片，这些分片可以托管在单个服务器上。一个服务器可以托管多个分片，并且分片会在服务器之间进行复制以提高可用性。服务器的数量可以根据负载自动增加或减少。分片对于管理大型数据集和大型集群非常有用，这些集群通常部署在云中。例如，**MongoDB
    Atlas** 可以托管在云提供商，如 **Azure**、**Amazon Web Services**（**AWS**）和**Google Cloud
    Platform**（**GCP**）上，允许调整服务器的数量以满足实际需求。然而，在数据库托管在计算机上的单个容器中，如我们的示例中，分片不会提供任何显著的好处。在更大的部署中，分片是实现我们目标的关键特性。
- en: We didn’t explicitly create an index for `match` in `MatchEvent`, but it is
    implicitly created since it is the sharding key.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 我们没有在 `MatchEvent` 中显式创建 `match` 的索引，但由于它是分片键，它被隐式创建。
- en: Finally, we used the `@Field` annotation. This is used to map a field in our
    document class to a different field in MongoDB. In our case, we mapped the `time`
    field in our class to the `event_time` field in MongoDB.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们使用了 `@Field` 注解。这用于将我们的文档类中的一个字段映射到 MongoDB 中的不同字段。在我们的案例中，我们将类中的 `time`
    字段映射到 MongoDB 中的 `event_time` 字段。
- en: There’s more...
  id: totrans-164
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Some decisions should be made when designing the data layer with MongoDB or
    other document-oriented databases. For example, should we mix different types
    of objects in the same collection, or should we keep each type of document in
    different collections?
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用 MongoDB 或其他面向文档的数据库设计数据层时，应做出一些决策。例如，我们应该在同一个集合中混合不同类型的对象，还是应该将每种类型的文档保存在不同的集合中？
- en: Having different types of objects in the same collection can make sense if they
    share some common fields and you want to perform queries by those fields, or you
    want to aggregate data from different objects. For the rest of the scenarios,
    it is probably better to have each type of document in its own collection. It
    helps create indexes and facilitate the creation of shards.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在同一个集合中拥有不同类型的对象，如果它们共享一些公共字段并且您想通过这些字段执行查询，或者您想从不同的对象中聚合数据，这是有意义的。对于其他场景，可能更好的是将每种类型的文档放在其自己的集合中。这有助于创建索引并促进分片创建。
- en: 'In this recipe, we didn’t mix different types of documents, but that is the
    reason why Spring Data MongoDB introduces a field named `_class` when it persists
    a document. For instance, this is the document that’s persisted when creating
    a new team:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们没有混合不同类型的文档，这也是Spring Data MongoDB在持久化文档时引入名为`_class`的字段的原因。例如，这是在创建新队伍时持久化的文档：
- en: '[PRE27]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Another decision to make is whether we should embed some data in a document
    or if that data should be in its own document. In the *Connecting your application
    to MongoDB* recipe, we embedded the players into their team, while in this recipe,
    we moved that information to its own collection. It may depend on the importance
    or independence of the embeddable document. In this recipe, the players required
    their own document as they can be directly referenced from other documents, such
    as match events.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个需要做出的决定是，我们是否应该在文档中嵌入一些数据，或者这些数据应该在其自己的文档中。在*将您的应用程序连接到MongoDB*菜谱中，我们将球员嵌入到他们的队伍中，而在这个菜谱中，我们将该信息移动到其自己的集合中。这可能取决于可嵌入文档的重要性或独立性。在这个菜谱中，球员需要自己的文档，因为它们可以直接从其他文档中引用，例如比赛事件。
- en: There could be other reasons, such as the expected write concurrency over the
    embedded entity. For instance, we could embed the events in the matches. However,
    during a match, we could assume that there will be a high number of events happening.
    That operation would require a high number of write operations on the match document,
    which will require more consistency management.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 可能还有其他原因，例如对嵌入式实体的预期写并发性。例如，我们可以在比赛中嵌入事件。然而，在比赛期间，我们可以假设会有大量事件发生。这个操作将需要在比赛文档上进行大量写操作，这将需要更多的一致性管理。
- en: Using transactions in MongoDB
  id: totrans-171
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在MongoDB中使用事务
- en: We want to create a new service where users can purchase a virtual token that
    can be used to obtain virtual goods in this new game. The main goods are cards
    with player pictures and other information, a kind of virtual sticker.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望创建一个新的服务，用户可以购买一个虚拟代币，该代币可以用来获取这个新游戏中的虚拟商品。主要商品是带有玩家图片和其他信息的卡片，一种虚拟贴纸。
- en: 'There are two operations that we need to implement: the token purchase and
    the cards purchase. For the token purchase, there is a payment validation. Cards
    can only be purchased with tokens. Of course, the users will be able to purchase
    cards if they have enough tokens.'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要实现两个操作：代币购买和卡片购买。对于代币购买，有一个支付验证。卡片只能用代币购买。当然，如果用户有足够的代币，他们也将能够购买卡片。
- en: Since we need to ensure consistency regarding the token and cards balance, we
    will need to use transactions with our MongoDB repository.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们需要确保代币和卡片余额的一致性，我们将需要使用事务与我们的MongoDB存储库一起使用。
- en: In this recipe, we will learn more about MongoDB transactions and how they differ
    from relational database transactions.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将了解更多的MongoDB事务以及它们与关系型数据库事务的不同之处。
- en: Getting ready
  id: totrans-176
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: We will use the same tools that we did in the *Connecting your application to
    MongoDB* recipe – that is, Docker and MongoDB.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用与*将您的应用程序连接到MongoDB*菜谱中相同的工具——即Docker和MongoDB。
- en: We will reuse the code from the *Data indexing and sharding in MongoDB* recipe.
    If you haven’t completed it yet, don’t worry – I’ve prepared a working version
    in this book’s GitHub repository at [https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook/](https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook/).
    It can be found in the `chapter6/recipe6-4/start` folder.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将重用*在MongoDB中数据索引和分片*菜谱中的代码。如果您还没有完成它，不要担心——我已经在这个书的GitHub仓库中准备了一个工作版本，在[https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook/](https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook/)。它可以在`chapter6/recipe6-4/start`文件夹中找到。
- en: MongoDB transactions
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: MongoDB事务
- en: MongoDB transactions are not supported in standalone servers. In the *Connecting
    your application to MongoDB* recipe, I provided a script to deploy a cluster using
    a replica set.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: In the *Deploying a MongoDB cluster in Testcontainers* recipe, we’ll cover how
    to deploy multiple servers with containers to be able to test MongoDB transactions.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-182
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will need to create a data model to support users and cards in our new service.
    Later, we will create a service that will use MongoDB transactions to perform
    operations involving users and cards consistently. We will configure our application
    so that it supports transactions as well. Follow these steps:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s start by creating the classes that will manage the objects to be stored
    in MongoDB:'
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'First, we will create a class named `User`:'
  id: totrans-185
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-186
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Next, we will create a class named `Card`:'
  id: totrans-187
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-188
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Next, we need to create the corresponding `MongoRepository` interfaces. Let’s
    go:'
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create an interface named `UserRepository`:'
  id: totrans-190
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-191
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'And another interface named `CardRepository`:'
  id: totrans-192
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-193
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Now, we need to create a service class that will manage the business logic
    of our application. To do that, create a class named `UserService`. Remember to
    annotate the class with `@Service`:'
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-195
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'This service will need the new repositories we created – that is, `UserRepository`
    and `CardRepository`, as well as `PlayerRepository`, which we created in the *Data
    indexing and sharding in MongoDB* recipe. We will need `MongoTemplate` as well.
    We will create a constructor with these repositories, after which the Spring Boot
    dependency manager will inject them:'
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-197
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Next, we’ll implement our business logic:'
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a method for purchasing tokens named `buyTokens`:'
  id: totrans-199
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-200
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Create a method for purchasing cards named `buyCards`:'
  id: totrans-201
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-202
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'To allow transactions in our application, we need to register a `MongoTransactionManager`
    bean. To do so, in our `MongoConfig` class, add the following method:'
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-204
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Now, our application can use transactions to execute operations atomically.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  id: totrans-206
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: By default, MongoDB native transactions are disabled in Spring Data MongoDB.
    That is the reason why we needed to register `MongoTransactionManager`. Once configured,
    when we annotate a method with `@Transactional`, it will create a transaction.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: It is very important to note that transactions provide atomic operations, meaning
    that all of them are saved or none of them are, but they don’t support isolation.
    The `buyCards` method will save all `cards` and the changes on `user` or it will
    save none of them.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: An important difference compared to transactions in relational databases is
    that there is no locking or isolation. If we make changes to the same `User` document
    that is modified in `buyCards` in another request, it will raise a **write conflict
    exception**. MongoDB is designed for performance and scalability at the cost of
    losing features from ACID transactions. We’ll learn how to manage concurrency
    in more detail in the *Managing concurrency with* *MongoDB* recipe.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: As you’ve probably realized, the `buyTokens` method does not use transactions.
    The main reason is that it doesn’t need to. All operations in a single document
    are considered isolated and atomic. Since the only field that’s updated is `tokens`,
    we used the `inc` operation to modify the value. The advantage of this operator
    is that it’s performed atomically in the server, even in high-concurrency environments.
    If we use transactions in operations involving a single document, it could raise
    write conflicts exceptions if two requests are updating the same document. This
    behavior could seem counter-intuitive if you compare it to the behavior of transactions
    in relational databases.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 如您可能已经意识到的那样，`buyTokens` 方法不使用事务。主要原因是不需要这样做。单个文档中的所有操作都被视为隔离和原子的。由于唯一更新的字段是
    `tokens`，我们使用了 `inc` 操作来修改值。这个操作器的优点是它在服务器上以原子方式执行，即使在高并发环境中也是如此。如果我们对涉及单个文档的操作使用事务，当两个请求正在更新同一文档时，可能会引发写冲突异常。如果您将其与关系型数据库中事务的行为进行比较，这种行为可能会显得有些反直觉。
- en: See also
  id: totrans-211
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 相关内容
- en: In addition to `$inc`, there are other atomic operations in MongoDB worth knowing
    about for concurrent scenarios. They can be applied to fields and arrays. See
    [https://www.mongodb.com/docs/v7.0/reference/operator/update/](https://www.mongodb.com/docs/v7.0/reference/operator/update/)
    for more details.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 除了 `$inc` 之外，MongoDB 中还有其他适用于并发场景的原子操作值得了解。它们可以应用于字段和数组。有关更多详细信息，请参阅 [https://www.mongodb.com/docs/v7.0/reference/operator/update/](https://www.mongodb.com/docs/v7.0/reference/operator/update/)。
- en: Deploying a MongoDB cluster in Testcontainers
  id: totrans-213
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 Testcontainers 中部署 MongoDB 集群
- en: MongoDB transactions are only supported in multiple server clusters. However,
    `MongoDBContainer`, as explained in the *Using Testcontainers with MongoDB* recipe
    uses a single server deployment. Therefore, we cannot use it for the integration
    tests of the new feature to buy cards as it requires transactions.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: MongoDB 事务仅在多服务器集群中受支持。然而，正如 *使用 Testcontainers 与 MongoDB* 配方中解释的那样，`MongoDBContainer`
    使用的是单个服务器部署。因此，我们无法用它来对新功能的购买卡片集成测试进行测试，因为它需要事务。
- en: In this recipe, we’ll learn how to set up multiple Testcontainers and configure
    a MongoDB cluster. With that, we’ll be able to implement integration tests for
    the buy cards feature.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，我们将学习如何设置多个 Testcontainers 并配置 MongoDB 集群。有了这个，我们将能够实现购买卡片功能的集成测试。
- en: Getting ready
  id: totrans-216
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: This recipe will implement the integration tests for the *Using transactions
    in MongoDB* recipe. If you haven’t completed it yet, don’t worry – I’ve prepared
    a version from which you can start this recipe. You can find it in this book’s
    GitHub repository at [https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook](https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook),
    in `chapter6/recipe6-5/start`.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 这个配方将实现 *在 MongoDB 中使用事务* 配方的集成测试。如果您还没有完成它，不用担心——我已经准备了一个版本，您可以从这个版本开始这个配方。您可以在本书的
    GitHub 仓库中找到它，网址为 [https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook](https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook)，在
    `chapter6/recipe6-5/start` 目录下。
- en: How to do it...
  id: totrans-218
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: In this recipe, we’ll set up the MongoDB cluster using Testcontainers and test
    the features involving transactions. Let’s get started!
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，我们将使用 Testcontainers 设置 MongoDB 集群并测试涉及事务的功能。让我们开始吧！
- en: 'Since the new buy cards feature is the, we’ll create a new test class named
    `UserServiceTest` and set up everything in this class. Since it uses Testcontainers,
    we’ll annotate the class with `@Testcontainers`:'
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于新的购买卡片功能是，我们将创建一个新的测试类 `UserServiceTest` 并在这个类中设置一切。由于它使用 Testcontainers，我们将使用
    `@Testcontainers` 注解这个类：
- en: '[PRE37]'
  id: totrans-221
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Next, we’ll create the MongoDB cluster. It will consist of three MongoDB containers
    deployed in the same network:'
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将创建 MongoDB 集群。它将由三个在同一网络中部署的 MongoDB 容器组成：
- en: 'Declare a `Network` static field. This class is part of the Testcontainers
    library and allows us to define a Docker network:'
  id: totrans-223
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明一个 `Network` 静态字段。这个类是 Testcontainers 库的一部分，它允许我们定义一个 Docker 网络：
- en: '[PRE38]'
  id: totrans-224
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Now, create three static `GenericContainer` fields with the following properties:'
  id: totrans-225
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，创建三个具有以下属性的静态 `GenericContainer` 字段：
- en: Each field will have the latest `mongo` Docker image.
  id: totrans-226
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个字段将使用最新的 `mongo` Docker 镜像。
- en: Each field will have the same network.
  id: totrans-227
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个字段将具有相同的网络。
- en: The three containers will expose port `27017`.
  id: totrans-228
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这三个容器将公开端口 `27017`。
- en: 'Each container will have a different network alias: `mongo1`, `mongo2`, and
    `mongo3`.'
  id: totrans-229
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个容器将具有不同的网络别名：`mongo1`、`mongo2` 和 `mongo3`。
- en: The three containers will start with a `mongod` command that initializes the
    MongoDB cluster, with the only difference being the binding IP hostname. Each
    container will use its network alias.
  id: totrans-230
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 三个容器将以`mongod`命令启动，该命令初始化MongoDB集群，唯一的区别是绑定IP主机名。每个容器将使用其网络别名。
- en: 'Here, we have the first field, `mongoDBContainer1`:'
  id: totrans-231
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这里，我们有第一个字段，`mongoDBContainer1`：
- en: '[PRE39]'
  id: totrans-232
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: The other fields, `mongoDBContainer2`, and `mongoDBContainer3`, are declared
    as `mongoDBContainer1`, except we must change `mongo1` to `mongo2` and `mongo3`,
    respectively.
  id: totrans-233
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 其他字段，`mongoDBContainer2`和`mongoDBContainer3`，与`mongoDBContainer1`声明相同，但我们必须将`mongo1`分别更改为`mongo2`和`mongo3`。
- en: 'Now that the three MongoDB containers have been declared, the next step is
    to start the containers and initiate the MongoDB replica set. We need to execute
    the following MongoDB command in one of the servers:'
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在已经声明了三个MongoDB容器，下一步是启动容器并初始化MongoDB副本集。我们需要在服务器上执行以下MongoDB命令：
- en: '[PRE40]'
  id: totrans-235
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'I’ve created a utility method named `buildMongoEvalCommand` to format the commands
    so that they’re ready to be executed in MongoDB. We’ll execute the MongoDB replica
    set initialization before any test execution. For that, we’ll use the `@``BeforeAll`
    annotation:'
  id: totrans-236
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我创建了一个名为`buildMongoEvalCommand`的实用方法，用于格式化命令，以便它们可以在MongoDB中执行。我们将在任何测试执行之前执行MongoDB副本集初始化。为此，我们将使用`@BeforeAll`注解：
- en: '[PRE41]'
  id: totrans-237
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '@DynamicPropertySource'
  id: totrans-238
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '@DynamicPropertySource'
- en: static void setMongoDbProperties(DynamicPropertyRegistry registry) {
  id: totrans-239
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: static void setMongoDbProperties(DynamicPropertyRegistry registry) {
- en: registry.add("spring.data.mongodb.uri", () -> {
  id: totrans-240
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: registry.add("spring.data.mongodb.uri", () -> {
- en: String mongoUri = "mongodb://" + mongoDBContainer1.getHost() + ":" + mongoDBContainer1.getMappedPort(27017)
    + "/?directConnect=true";
  id: totrans-241
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: String mongoUri = "mongodb://" + mongoDBContainer1.getHost() + ":" + mongoDBContainer1.getMappedPort(27017)
    + "/?directConnect=true";
- en: return mongoUri;
  id: totrans-242
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: return mongoUri;
- en: '});'
  id: totrans-243
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '});'
- en: 'buyCards method of the UserService class:'
  id: totrans-244
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: UserService类的buyCards方法：
- en: '[PRE42]'
  id: totrans-245
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Some code snippets have been simplified or omitted for clarity. You can find
    more details in this book’s GitHub repository at [https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook](https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook).
  id: totrans-246
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 为了清晰起见，一些代码片段已被简化或省略。您可以在本书的GitHub仓库中找到更多详细信息：[https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook](https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook)。
- en: '[PRE43]'
  id: totrans-247
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: How it works...
  id: totrans-248
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'The `MongoDBContainer` container, which is available as a module in the Testcontainers
    project, only works as a single server deployment. For that reason, instead of
    using `MongoDBContainer`, we used `GenericContainer`. After that, we adapted to
    Testcontainers so that we could set up the script explained in the *Getting ready*
    section of the *Connecting your application to MongoDB* recipe. To do so, we did
    the following:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 可在Testcontainers项目中作为模块使用的`MongoDBContainer`容器仅作为单服务器部署工作。因此，我们不是使用`MongoDBContainer`，而是使用了`GenericContainer`。之后，我们适应了Testcontainers，以便我们可以设置*连接你的应用程序到MongoDB*食谱中*准备就绪*部分中解释的脚本。为此，我们做了以下操作：
- en: Created a Docker network.
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建了一个Docker网络。
- en: Deployed at least three MongoDB servers in containers.
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在容器中部署了至少三个MongoDB服务器。
- en: Initialized the MongoDB replica set. A replica set is a group of Mongo processes
    that work together to maintain the same dataset. We can consider this a cluster.
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 初始化了MongoDB副本集。副本集是一组Mongo进程，它们协同工作以维护相同的数据集。我们可以将其视为一个集群。
- en: 'As you may have noticed, we used the `directConnection` setting when connecting
    to the MongoDB cluster. This setting means that we connect directly to one specific
    node of the cluster. When connecting to a replica set, normally, the connection
    string specifies all cluster nodes and the client connects to the most appropriate
    one. The reason we use `directConnection` is because the nodes can discover each
    other using the network alias. After all, they are in the same network and can
    use DNS names. However, the application we developed runs on our development computer,
    which hosts the containers, but it’s in a different network and cannot find the
    nodes by name. If we were in the same network, the MongoDB connection string would
    look like this:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 如您可能已经注意到的，我们在连接到MongoDB集群时使用了`directConnection`设置。此设置意味着我们直接连接到集群中的一个特定节点。当连接到副本集时，通常，连接字符串指定所有集群节点，客户端连接到最合适的节点。我们使用`directConnection`的原因是节点可以使用网络别名相互发现。毕竟，它们在同一个网络中，可以使用DNS名称。然而，我们开发的应用程序运行在我们的开发计算机上，该计算机托管容器，但它位于不同的网络中，无法通过名称找到节点。如果我们处于同一个网络中，MongoDB连接字符串将如下所示：
- en: '[PRE44]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: In this case, the client will connect to the appropriate node. To execute transactions,
    it’s necessary to connect to the primary server. The application we developed
    may fail when performing these transactions because it’s not connected to the
    primary server.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，客户端将连接到适当的节点。要执行事务，必须连接到主服务器。我们开发的应用程序在执行这些事务时可能会失败，因为它没有连接到主服务器。
- en: Note
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The `buildMongoEvalCommand` method has been adapted from the original `MongoDBContainer`
    container from the `Testcontainer` project. You can find the original code at
    [https://github.com/testcontainers/testcontainers-java/blob/main/modules/mongodb/src/main/java/org/testcontainers/containers/MongoDBContainer.java](https://github.com/testcontainers/testcontainers-java/blob/main/modules/mongodb/src/main/java/org/testcontainers/containers/MongoDBContainer.java).
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: '`buildMongoEvalCommand` 方法已从 `Testcontainer` 项目的原始 `MongoDBContainer` 容器中改编而来。您可以在
    [https://github.com/testcontainers/testcontainers-java/blob/main/modules/mongodb/src/main/java/org/testcontainers/containers/MongoDBContainer.java](https://github.com/testcontainers/testcontainers-java/blob/main/modules/mongodb/src/main/java/org/testcontainers/containers/MongoDBContainer.java)
    找到原始代码。'
- en: Managing concurrency with MongoDB
  id: totrans-258
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 MongoDB 管理并发
- en: In this recipe, we will implement a feature to exchange player cards between
    users. Some cards are more difficult to get, which results in them having a higher
    demand. So, while many users try to find them, only one may get it. This is a
    scenario of high concurrency.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将实现一个在用户之间交换玩家卡片的功能。有些卡片更难获得，这导致它们有更高的需求。因此，虽然许多用户试图找到它们，但只有一个人可能得到它。这是一个高并发的场景。
- en: 'A user can exchange or buy another user’s card using a certain number of tokens.
    The process we will implement consists of the following steps:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 用户可以使用一定数量的代币交换或购买另一个用户的卡片。我们将实施的过程包括以下步骤：
- en: First, we need to check that the buyer has the tokens they promised.
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们需要检查买家是否有他们承诺的代币。
- en: Then, we’ll subtract the number of tokens from the buyer and add them to the
    seller.
  id: totrans-262
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们将从买家那里减去代币数量，并添加给卖家。
- en: Finally, we will change the card owner.
  id: totrans-263
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们将更改卡片的所有者。
- en: MongoDB supports optimistic concurrency control through a document’s versioning
    system. Each document has a version number (often called a *revision* or *version*
    field) that is incremented whenever the document is modified. When multiple clients
    attempt to update the same document simultaneously, the version numbers are used
    to detect conflicts, and the changes are rejected if there is a conflict.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: MongoDB 通过文档的版本控制系统支持乐观并发控制。每个文档都有一个版本号（通常称为 *修订* 或 *版本* 字段），每当文档被修改时，该版本号都会递增。当多个客户端同时尝试更新同一文档时，使用版本号来检测冲突，如果存在冲突，则拒绝更改。
- en: We will add version support to `cards` and `users` as we need to control that
    the users haven’t spent the tokens on another thing and that the cards are not
    exchanged with another user.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 随着我们需要控制用户没有在其他事物上花费代币以及卡片没有被与其他用户交换，我们将为 `cards` 和 `users` 添加版本支持。
- en: Getting ready
  id: totrans-266
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪
- en: We will use the same tools that we used in the *Connecting your application
    to MongoDB* recipe – that is, Docker and MongoDB.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用在 *将您的应用程序连接到 MongoDB* 菜谱中使用的相同工具 - 那就是Docker和MongoDB。
- en: We will reuse the code from the *Deploying a MongoDB cluster in Testcontainers*
    recipe. If you haven’t completed it yet, don’t worry – I’ve prepared a working
    version in this book’s GitHub repository at [https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook/](https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook/).
    It can be found in the `chapter6/recipe6-4/start` folder.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将重用 *在 Testcontainers 中部署 MongoDB 集群* 菜谱中的代码。如果您还没有完成它，不要担心 - 我已经在这个书的 GitHub
    仓库中准备了一个工作版本，在 [https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook/](https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook/)。您可以在
    `chapter6/recipe6-4/start` 文件夹中找到它。
- en: How to do it...
  id: totrans-269
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Let’s add version control support to our `Card` and `User` documents and implement
    a card exchange transaction with optimistic concurrency control:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们为我们的 `Card` 和 `User` 文档添加版本控制支持，并实现一个具有乐观并发控制的卡片交换事务：
- en: 'First, we will modify the classes involved in our feature so that they support
    optimistic concurrency. We’ll do this by adding a new field annotated with `@Version`:'
  id: totrans-271
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们将修改涉及我们功能的类，以便它们支持乐观并发。我们将通过添加一个带有 `@Version` 注解的新字段来实现这一点：
- en: 'Modify the `User` class by adding a new `Long` field named `version`:'
  id: totrans-272
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过添加一个名为 `version` 的新 `Long` 字段来修改 `User` 类：
- en: '[PRE45]'
  id: totrans-273
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: And the same `version` field to the `Card` class.
  id: totrans-274
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 并且将相同的 `version` 字段添加到 `Card` 类中。
- en: 'Next, we will create a new service named `TradingService`:'
  id: totrans-275
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将创建一个名为 `TradingService` 的新服务：
- en: '[PRE46]'
  id: totrans-276
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Here, `CardRepository` and `UserRepository` are added as dependencies in the
    constructor as we will need them to implement the card exchange business logic.
  id: totrans-277
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这里，`CardRepository` 和 `UserRepository` 被添加到构造函数中，因为我们将在实现卡片交换业务逻辑时需要它们。
- en: 'Now, we will create two methods to implement the business logic. One will be
    annotated with `@Transactional` to control that all changes are atomic, and another
    one to control concurrency exceptions:'
  id: totrans-278
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将创建两个方法来实现业务逻辑。一个将使用 `@Transactional` 注解来控制所有更改的原子性，另一个用于控制并发异常：
- en: 'The business logic method should look as follows:'
  id: totrans-279
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 业务逻辑方法应该看起来如下：
- en: '[PRE47]'
  id: totrans-280
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'The method to control concurrency should look like this:'
  id: totrans-281
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 控制并发的函数应该看起来像这样：
- en: '[PRE48]'
  id: totrans-282
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: With this mechanism, we can control the concurrency operations that are performed
    on our documents. You can now implement a RESTful API that will use this business
    logic. I’ve prepared a working sample in this book’s GitHub repository at [https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook/](https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook/).
    It can be found in `chapter6/recipe6-6/end`.
  id: totrans-283
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 通过这个机制，我们可以控制对我们的文档执行的并发操作。现在，您可以实现一个 RESTful API，该 API 将使用这个业务逻辑。我在本书的 GitHub
    仓库中准备了一个工作示例，网址为 [https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook/](https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook/)。它可以在
    `chapter6/recipe6-6/end` 中找到。
- en: How it works...
  id: totrans-284
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 作用原理...
- en: 'By adding the `@Version` annotation, the save operations not only check that
    the `id` value is the same, but also the field annotated with `version`. The generated
    query looks like this:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 通过添加 `@Version` 注解，保存操作不仅检查 `id` 值是否相同，还检查注解了 `version` 的字段。生成的查询看起来像这样：
- en: '[PRE49]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: If this operation fails, it throws an `OptimisticLockingFailureException` exception.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这个操作失败，它将抛出 `OptimisticLockingFailureException` 异常。
- en: Depending on the business requirements, we could retry the operations or just
    abandon them, as we did in our scenario. If a user already sold the card you want,
    you should look for another one.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 根据业务需求，我们可能需要重试操作或直接放弃它们，就像我们在场景中做的那样。如果用户已经卖出了您想要的卡片，您应该寻找另一张。
- en: Since we needed to modify three different documents, we used a transaction.
    We used the `@Transactional` annotation for declarative transaction management.
    If we want to roll back changes that have been performed in that transaction,
    we need to throw an exception. That is why we let Spring Data MongoDB throw `OptimisticLockingFailureException`
    in the `exchangeCardInternal` method and capture it in `exchangeCard`.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们需要修改三个不同的文档，我们使用了事务。我们使用 `@Transactional` 注解进行声明式事务管理。如果我们想回滚该事务中已执行的改变，我们需要抛出异常。这就是为什么我们在
    `exchangeCardInternal` 方法中让 Spring Data MongoDB 抛出 `OptimisticLockingFailureException`
    并在 `exchangeCard` 中捕获它的原因。
- en: Connecting your application to Apache Cassandra
  id: totrans-290
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将您的应用程序连接到 Apache Cassandra
- en: In this recipe, we want to create a system that allows users to post comments
    related to matches, players, or match events. We decided to use Apache Cassandra
    due to its high scalability and low-latency capabilities.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们希望创建一个系统，允许用户发布与比赛、球员或比赛事件相关的评论。我们决定使用 Apache Cassandra，因为它具有高可扩展性和低延迟能力。
- en: In this recipe, we’ll learn how to connect our Spring Boot application to an
    Apache Cassandra server using Spring Data for Apache Cassandra repositories.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将学习如何使用 Spring Data for Apache Cassandra 存储库将我们的 Spring Boot 应用程序连接到
    Apache Cassandra 服务器。
- en: Getting ready
  id: totrans-293
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'For this recipe, we will use an Apache Cassandra database. The easiest way
    to deploy Apache Cassandra on your computer is by using a container hosted in
    Docker. You can perform this task by executing the following `docker` command:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个菜谱，我们将使用 Apache Cassandra 数据库。在您的电脑上部署 Apache Cassandra 最简单的方法是使用 Docker
    容器。您可以通过执行以下 `docker` 命令来完成此任务：
- en: '[PRE50]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: This command will download the latest Apache Cassandra Docker image, if you
    don’t have one yet on your computer, and will start a Cassandra server listening
    on port `9042`.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令将下载最新的 Apache Cassandra Docker 镜像，如果您电脑上还没有，并且将启动一个监听端口 `9042` 的 Cassandra
    服务器。
- en: 'After starting the server, you will need to create a `cqlsh` script inside
    the container:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 在启动服务器后，您需要在容器内创建一个 `cqlsh` 脚本：
- en: '[PRE51]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: You may need to wait a few seconds for the Cassandra server to finish initializing
    before creating the Keyspace.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建 Keyspace 之前，您可能需要等待几秒钟，以便 Cassandra 服务器完成初始化。
- en: How to do it...
  id: totrans-300
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Let’s create a project with Apache Cassandra support. We will use the already
    familiar Spring Data concept of `Repository` to connect to Apache Cassandra:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个支持 Apache Cassandra 的项目。我们将使用已经熟悉的 Spring Data 的 `Repository` 概念来连接到
    Apache Cassandra：
- en: 'First, we will create a new Spring Boot project using the *Spring Initializr*
    tool. As usual, open [https://start.spring.io](https://start.spring.io). We will
    use the same parameters we used in [*Chapter 1*](B21646_01.xhtml#_idTextAnchor020),
    in the *Creating a RESTful API* recipe, except we’ll use the following parameters:'
  id: totrans-302
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For `footballcdb`
  id: totrans-303
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: For **Dependencies**, select **Spring Web** and **Spring Data for** **Apache
    Cassandra**
  id: totrans-304
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Next, we will create a class named `Comment`. This represents the data for our
    new feature.
  id: totrans-305
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We need to annotate the class with `@Table` and the fields with `@PrimaryKeyColumn`
    if they form part of the primary key. We can use `@Column` if we want to map a
    field to a different column name in Cassandra:'
  id: totrans-306
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE52]'
  id: totrans-307
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'We need to create a new `Repository` for `Comment` that extends from `CassandraRepository`:'
  id: totrans-308
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  id: totrans-309
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: As is usual with Spring Data’s `Repository`, it provides some methods to manipulate
    `Comment` entities, such as `findById`, `findAll`, `save`, and others.
  id: totrans-310
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'As we will retrieve the comments when showing other entities, such as matches
    or players, we’ll need to create a method in `CommentRepository` to get the comments
    by the type of target and the target itself:'
  id: totrans-311
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  id: totrans-312
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Note that as with other repositories in Spring Data, it can implement the interface
    by inferring the query from the method name.
  id: totrans-313
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: It is important to annotate the method with the `@AllowFiltering` annotation
    as we are not retrieving the data via the primary key.
  id: totrans-314
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'We can now create a service using `CommentRepository` to implement our application
    requirements. We’ll name the service `CommentService` and ensure it has the following
    content:'
  id: totrans-315
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  id: totrans-316
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Now, we must create the functionality. We will create a method to create a
    comment and a couple of methods to retrieve all comments:'
  id: totrans-317
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We’ll use a record to receive the comment data:'
  id: totrans-318
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE56]'
  id: totrans-319
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Let’s define the `postComment` method so that we can create a new comment:'
  id: totrans-320
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE57]'
  id: totrans-321
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Now, we can create a method to retrieve all comments:'
  id: totrans-322
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE58]'
  id: totrans-323
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'We can retrieve all comments in general, but it makes more sense to retrieve
    the comments related to another entity. For instance, it’s more common to get
    comments about a player:'
  id: totrans-324
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE59]'
  id: totrans-325
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Finally, we need to configure the application so that it can connect to our
    Cassandra server. In the *Getting ready* section of this recipe, I provided instructions
    to deploy it on your computer by using Docker, including how to create a Keyspace.
    To configure the application, create an `application.yml` file in the `resources`
    folder. Add the following content:'
  id: totrans-326
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  id: totrans-327
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE60]'
- en: We now have the components that are required to provide the comments functionality.
    We created `CassandraRepository` and we connected to a Cassandra server. I’ve
    created a RESTful API to consume this service. You can find it in this book’s
    GitHub repository at [https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook/](https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook/).
    It can be found in `chapter6/recipe6-7/end`.
  id: totrans-328
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  id: totrans-329
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As we saw with other Spring Data projects, when you create an interface extending
    from `CassandraRepository`, Spring Data for Apache Cassandra generates an implementation
    and registers the implementation as a *bean* to make it available for the rest
    of the components.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
- en: It can generate the implementation using the naming convention and using the
    `@Query` annotation. Both ways generate an implementation using Cassandra templates,
    something that will be detailed in the next recipe.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
- en: We haven’t covered CQL yet, a syntactically similar language to SQL, but with
    important differences as Cassandra is a NoSQL technology. For instance, it doesn’t
    support **JOIN** queries.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
- en: Note that in the `findByTargetTypeAndTargetId` method, we used `@AllowFiltering`.
    Cassandra is a NoSQL database that’s designed for high availability and scalability
    but it achieves these features by limiting the types of queries it can handle
    efficiently. Cassandra is optimized for fast retrieval of data based on the primary
    key or clustering columns. When you query data in Cassandra, it’s expected that
    you provide at least the primary key components to locate the data efficiently.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
- en: However, in some cases, you may need to perform queries that filter data on
    non-primary key columns. These types of queries are not efficient in Cassandra
    as they may require a full table scan and can be very slow on large datasets.
    You can use the `@AllowFiltering` annotation to explicitly indicate to Spring
    Data for Apache Cassandra that you’re aware of the performance implications and
    that you want to perform such a query despite its potential inefficiency.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
- en: See also
  id: totrans-335
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'It is recommended that you get familiar with CQL if you plan to work with Cassandra.
    You can find more information about it on the project page: [https://cassandra.apache.org/doc/stable/cassandra/cql/](https://cassandra.apache.org/doc/stable/cassandra/cql/).'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
- en: Using Testcontainers with Cassandra
  id: totrans-337
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To ensure the reliability of our application, we need to run integration tests
    with our Cassandra project. Similar to MongoDB, we have two options for running
    tests with Cassandra – either by using an in-memory embedded Cassandra server
    or Testcontainers. However, I recommend using Testcontainers with a Cassandra
    server as this eliminates any potential compatibility issues since it uses a real
    Cassandra instance.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will learn how to use the Testcontainers Cassandra module
    to create integration tests for our Comments service.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-340
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this recipe, we will create an integration test for the Comments service
    that we created in the *Connecting your application to Apache Cassandra* recipe.
    If you haven’t completed this recipe yet, you can use the project that I have
    prepared. You can find it in this book’s GitHub repository at [https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook/](https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook/),
    in the `chapter6/recipe6-8/start` folder.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-342
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Are you ready to take your application to the next level? Let’s start preparing
    it so that it can run Testcontainers and see how we can improve it!
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ll start by adding the Testcontainers dependencies to our `pom.xml` file
    – that is, the general Testcontainers dependency and the Cassandra Testcontainers
    module:'
  id: totrans-344
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE61]'
  id: totrans-345
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Next, create a file named `createKeyspace.cql` in the test `resources` folder.
    This file should contain the Cassandra Keyspace creation command:'
  id: totrans-346
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE62]'
  id: totrans-347
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Now, we can create a test class for our `CommentService`. You can name the
    test class `CommentServiceTest`. Before we start creating the test, we’ll need
    to set up the Testcontainer. For that, do the following:'
  id: totrans-348
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Annotate the test class with `@Testcontainers`:'
  id: totrans-349
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE63]'
  id: totrans-350
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Declare a static `CassandraContainer` field:'
  id: totrans-351
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Here, we’ll specify the Cassandra Docker image. We’ll use the default `cassandra`
    image.
  id: totrans-352
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: We must apply the Cassandra script to be executed during the container initialization
    process – that is, `createKeyspace.cql`, which we defined in *Step 2*.
  id: totrans-353
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We must also expose the port where Cassandra listens for connections – that
    is, port `9042`:'
  id: totrans-354
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE64]'
  id: totrans-355
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE64]'
- en: '[PRE65]'
  id: totrans-356
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'The last Testcontainers configuration involves setting the Cassandra connection
    setting in the application context. For that, we’ll use `@DynamicPropertySource`
    and the properties that were provided by the `cassandraContainer` field we declared
    previously:'
  id: totrans-357
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE66]'
  id: totrans-358
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Now, we can create our integration test. Let’s name it `postCommentTest`:'
  id: totrans-359
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE67]'
  id: totrans-360
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE67]'
- en: How it works...
  id: totrans-361
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `org.testcontainers:cassandra` dependency contains the `CassandraContainer`
    class, which provides most of the functionality required to set up the Testcontainer
    for our integration test. It allows us to specify the Docker image we want to
    use.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
- en: Here, `withInitScript` executes CQL scripts in Cassandra by taking a file from
    the test’s classpath. This simplifies execution as file copying and client tool
    availability are not a concern. We used this functionality to create the Keyspace,
    as we did in the *Getting ready* section of the *Connecting your application to
    Apache* *Cassandra* recipe.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
- en: We don’t need to manually check if the Container service is ready to accept
    connections. Testcontainers automatically waits until the service is ready to
    initiate the tests.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we used the properties exposed by the `CassandraContainer` class to
    configure the connection. We used the `getContactPoint` method to get the server
    host address, the `getPort` method to get the port exposed by the container, and
    the `getLocalDatacenter` method to get the simulated datacenter name.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
- en: Using Apache Cassandra templates
  id: totrans-366
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We may want to access our data hosted in Cassandra in a more flexible way than
    the one provided by `CassandraRepository`. For instance, we may want to retrieve
    data from our comments system using a dynamic or complex query, execute operations
    in batch, or access a low-level feature. In those cases, it is more convenient
    to use a Cassandra template as it provides more low-level access to Cassandra’s
    features.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will implement functionality that will dynamically search
    comments using different parameters, such as a date range, tags, and so on. For
    that, we’ll use **Cassandra templates**.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-369
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will use the same tools that we did in the *Connecting your application to
    Apache Cassandra* recipe – that is, Docker and Apache Cassandra.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
- en: To complete this recipe, you’ll need the project you created for the *Using
    Testcontainers with Cassandra* recipe. If you haven’t completed that recipe yet,
    don’t worry – you can use a full version of the project that I’ve prepared in
    this book’s GitHub repository at [https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook/](https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook/).
    It can be found in the `chapter6/recipe6-9/start` folder.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-372
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this recipe, we’ll enhance the Comment service we created in the previous
    recipe with new search functionality so that users can use as many parameters
    as they want:'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we need to inject `CassandraTemplate` into our `CommentService` class.
    To do that, modify the constructor so that it makes the Spring Dependency Container
    inject `CassandraTemplate`:'
  id: totrans-374
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE68]'
  id: totrans-375
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Now, add a new overloading for the `getComments` method:'
  id: totrans-376
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE69]'
  id: totrans-377
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'This method has two types of parameters: mandatory and optional.'
  id: totrans-378
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: We assume that users will always retrieve comments associated with a target
    entity – for instance, a player or a match. For that reason, the `targetType`
    and `targetId` parameters are mandatory.
  id: totrans-379
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The rest of the parameters are optional; hence they are defined as `Optional<T>`.
  id: totrans-380
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'In this new method, we will use the `QueryBuilder` component to create our
    query:'
  id: totrans-381
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE70]'
  id: totrans-382
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE70]'
- en: Here, we selected the `comment` table by using `selectFrom`, and we set the
    mandatory columns, `targetType`, and `targetId`, by using `whereColumn`.
  id: totrans-383
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The rest of the optional fields will use `whereColumn`, but only if they are
    provided:'
  id: totrans-384
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE71]'
  id: totrans-385
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'Finally, we can use the query with `CassandraTemplate` by using the `select`
    method. Let’s do it:'
  id: totrans-386
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE72]'
  id: totrans-387
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE72]'
- en: Here, we used `allowFiltering`. Since we are not using the primary key, we need
    to tell Cassandra that we assume that the query is potentially inefficient.
  id: totrans-388
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: We implemented the new feature for our Comment service to perform dynamic queries
    using `CassandraTemplate`. Now, you can create a RESTful API interface to interact
    with the new feature. I’ve created a sample RESTful API that uses the new feature
    and prepared integration tests for the Comments service. You can find these in
    this book’s GitHub repository at [https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook/](https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook/),
    in the `chapter6/recipe6-9/end` folder.
  id: totrans-389
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  id: totrans-390
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Spring Data for Apache Cassandra registers a `CassandraTemplate` bean in the
    Spring Boot Dependency Container. It is used internally to implement the repositories
    described in the *Connecting your application to Apache Cassandra* recipe. By
    doing this, it can be injected into our components by Spring Boot.
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
- en: You can compose a CQL string by concatenating the predicates, but this is prone
    to introducing typos in queries. That’s why we used `QueryBuilder`. As I explained
    in the *Connecting your application to Apache Cassandra* recipe, we need to set
    `allowFiltering` when we make queries that don’t use the table primary key.
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
- en: There’s more...
  id: totrans-393
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We can do the same query by building a string with a dynamic CQL statement.
    This would look like this:'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  id: totrans-395
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: Managing concurrency with Apache Cassandra
  id: totrans-396
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We want to enhance our comments system by adding a new feature: upvoting comments.
    We will add a counter to our comments showing the positive votes that have been
    received.'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
- en: This simple requirement can be complex in a high-concurrency scenario. If multiple
    users are upvoting a comment, it may happen that we aren’t updating the latest
    version of the comment. To tackle this scenario, we will use an optimistic concurrency
    approach with Cassandra.
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-399
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will use the same tools that we did in the *Connecting your application to
    Apache Cassandra* recipe – that is, Docker and Apache Cassandra.
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
- en: The starting point will be the project we created for the *Using Apache Cassandra
    Templates* recipe. If you haven’t completed it yet, don’t worry – you can use
    a full version of the project that I’ve prepared in this book’s GitHub repository
    at [https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook/](https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook/).
    It can be found in the `chapter6/recipe6-10/start` folder.
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-402
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this recipe, we will implement the upvoting feature using optimistic concurrency.
    But before that, we’ll need to prepare our comment entity. Let’s get started:'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
- en: 'The first thing we’ll need to do is create a new field that will store the
    number of upvotes received by a comment. So, let’s modify the `Comment` class
    by adding a new field named `upvotes`:'
  id: totrans-404
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE74]'
  id: totrans-405
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE74]'
- en: We’ll need to modify the table schema in the Cassandra server. For that, we’ll
    need to connect to the server and execute a `cqlsh` command. The easiest way to
    do this is by connecting to the Docker container. The following command will open
    an interactive session in `cqlsh`
  id: totrans-406
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE75]'
  id: totrans-407
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE75]'
- en: Now, you can exit `cqlsh` by executing the `quit;` command.
  id: totrans-408
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: It isn’t possible to assign default values in Cassandra. If you have existing
    comments in your database, Cassandra will return a `null` value for field upvotes.
    So, we’ll need to manage this scenario accordingly.
  id: totrans-409
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now, it’s time to use the new field in a new operation. We’ll implement that
    operation in our `CommentService` service by creating a new method named `upvoteComment`:'
  id: totrans-410
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE76]'
  id: totrans-411
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'Next, we’ll retrieve the first comment. We can use the existing `CommentRepository`
    or `CassandraTemplate`. We’ll use `CommentRepository` as it is simpler:'
  id: totrans-412
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE77]'
  id: totrans-413
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'Now, we need to update the upvotes field, but we’ll keep the current value:'
  id: totrans-414
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE78]'
  id: totrans-415
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'Next, we’ll use the current value to create the condition. Only if we are updating
    the current value will we apply the change:'
  id: totrans-416
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE79]'
  id: totrans-417
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'Now, we need to check if the result was what we expected:'
  id: totrans-418
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在，我们需要检查结果是否是我们所期望的：
- en: '[PRE80]'
  id: totrans-419
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE80]'
- en: If the result is not what we expected, we can retry the operation a few times
    while waiting a few milliseconds between executions, but this will depend on the
    requirements of the application.
  id: totrans-420
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果结果不是我们所期望的，我们可以在执行之间等待几毫秒的情况下重试操作几次，但这将取决于应用程序的要求。
- en: Now, you can implement a RESTful API for this new functionality. I’ve prepared
    a sample RESTful API and integration tests in this book’s GitHub repository at
    [https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook/](https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook/),
    in the `chapter6/recipe6-10/end` folder.
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您可以为此新功能实现一个RESTful API。我已经在本书的GitHub仓库中准备了一个示例RESTful API和集成测试，该仓库位于[https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook/](https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook/)，在`chapter6/recipe6-10/end`文件夹中。
- en: How it works...
  id: totrans-422
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The key to optimistic concurrency management in Cassandra is the conditional
    update command. In CQL, Cassandra provides an `IF` clause that we can use in `CassandraTemplate`.
    With this `IF` clause, you can conditionally update data, but only if certain
    conditions are met, which includes checking the current state of the data.
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 在Cassandra中，乐观并发管理的关键是条件更新命令。在CQL中，Cassandra提供了一个`IF`子句，我们可以在`CassandraTemplate`中使用它。使用这个`IF`子句，您可以在满足某些条件的情况下有条件地更新数据，这些条件包括检查数据的当前状态。
- en: We could create a `version` field in the comments table to implement a mechanism,
    as we saw in the *Managing concurrency with MongoDB* recipe. However, Spring Data
    for Apache Cassandra does not provide any special capability to manage this automatically,
    so we would need to implement it ourselves. In addition, we don’t expect any other
    change in the `comment` entity, so we can use upvotes to control if the row has
    been modified. The `upvotes` field is our `version` field.
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在评论表中创建一个`version`字段来实现一个机制，就像我们在*使用MongoDB管理并发*配方中看到的那样。然而，Spring Data
    for Apache Cassandra没有提供任何特殊的能力来自动管理这一点，因此我们需要自己实现它。此外，我们预计`comment`实体不会有任何其他变化，因此我们可以使用点赞来控制行是否已被修改。`upvotes`字段是我们的`version`字段。
- en: 'Part 3: Application Optimization'
  id: totrans-425
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第三部分：应用程序优化
- en: In large-scale applications, it’s necessary to understand where the bottlenecks
    are and how they can be improved. In this part, we’ll follow a systematic approach
    to optimizing and measuring the improvements that we apply. We’ll also use advanced
    techniques such as reactive programming and event-driven design.
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 在大规模应用程序中，了解瓶颈在哪里以及如何改进它们是必要的。在本部分中，我们将遵循一种系统性的方法来优化和衡量我们应用的改进。我们还将使用诸如响应式编程和事件驱动设计等高级技术。
- en: 'This part has the following chapters:'
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 本部分包含以下章节：
- en: '[*Chapter 7*](B21646_07.xhtml#_idTextAnchor326), *Finding Bottlenecks and Optimizing
    Your Application*'
  id: totrans-428
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第7章*](B21646_07.xhtml#_idTextAnchor326)，*寻找瓶颈和优化您的应用程序*'
- en: '[*Chapter 8*](B21646_08.xhtml#_idTextAnchor365), *Spring Reactive and Spring
    Cloud Stream*'
  id: totrans-429
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第8章*](B21646_08.xhtml#_idTextAnchor365)，*Spring Reactive和Spring Cloud Stream*'
