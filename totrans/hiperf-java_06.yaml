- en: '6'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Strategic Object Creation and Immutability
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter continues our quest to find ways to get the most performance out
    of our Java applications. Creating objects is a core part of all Java applications,
    so the goal is not to eradicate that; rather, it is to take a strategic approach
    to object creation.
  prefs: []
  type: TYPE_NORMAL
- en: How and when we create objects can play a crucial role in application performance.
    Object creation impacts not only performance but also overall efficiency, garbage
    collection, and memory use. This chapter intends to provide you with the knowledge
    and skills you’ll need to implement an object creation strategy.
  prefs: []
  type: TYPE_NORMAL
- en: A core part of object creation strategies is the concept of object immutability.
    This chapter presents information and examples on how to make objects immutable
    and explains why you should consider it.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter covers the following main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Minimizing object creation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Object immutability
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Garbage collection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Design patterns
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of this chapter, you should have an understanding and appreciation
    for the importance of strategic object creation and the powerful concept of object
    immutability. This understanding will help you improve the performance of your
    Java applications.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To follow the examples and instructions in this chapter, you will need to be
    able to load, edit, and run Java code. If you haven’t set up your development
    environment, please refer to [*Chapter 1*](B21942_01.xhtml#_idTextAnchor014).
  prefs: []
  type: TYPE_NORMAL
- en: 'The code for this chapter can be found here: [https://github.com/PacktPublishing/High-Performance-with-Java/tree/main/Chapter06](https://github.com/PacktPublishing/High-Performance-with-Java/tree/main/Chapter06).'
  prefs: []
  type: TYPE_NORMAL
- en: Minimizing object creation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Minimizing object creation is a critical concern when we are striving for high-performance
    applications. Every time we create an object, we use memory and processing resources.
    Although modern systems have an impressive array of memory capacity and processing
    capabilities, they are not limitless.
  prefs: []
  type: TYPE_NORMAL
- en: To ensure we handle this concern correctly, we should seek to understand the
    life cycle of a Java object, how object creation impacts memory, and what object
    pooling is. We should also experiment with different object initialization approaches
    and ways to reduce system overhead. That is the aim of this section. Let’s start
    our exploration of minimizing object creation by looking at the life cycle of
    Java objects.
  prefs: []
  type: TYPE_NORMAL
- en: Java object life cycle
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The notion of an object in the Java programming language is nothing new. When
    considering high-performance Java applications, we need to consider the overall
    life cycle of our objects. The creation, use, and deletion of objects have a direct
    impact on the overall performance of our applications. The following figure depicts
    a typical object’s life cycle:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.1 – Java object life cycle](img/B21942_06_1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.1 – Java object life cycle
  prefs: []
  type: TYPE_NORMAL
- en: 'As illustrated in *Figure 6**.1*, the first step of an object’s life cycle
    is object creation. When a new object is created, it is said to be `new` keyword
    to allocate memory on the heap so that we can store our object’s data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The next phase of an object’s life cycle is its use and reference. This is where
    we execute the object’s methods and reference its properties.
  prefs: []
  type: TYPE_NORMAL
- en: The third phase is garbage collection. Once we stop using an object and it can
    no longer be referenced, the **Java Virtual Machine’s** (**JVM’s**) garbage collector
    will reclaim the memory the out-of-scope object is using.
  prefs: []
  type: TYPE_NORMAL
- en: The last phase of an object’s life cycle is when it is destroyed. The garbage
    collector takes care of this for us. Once the object is destroyed, it is no longer
    accessible to the application.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding an object’s life cycle is a prerequisite to being able to create
    and adopt an object creation strategy.
  prefs: []
  type: TYPE_NORMAL
- en: Memory
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We implicitly understand that objects require memory to exist and that the more
    objects our applications use at one time, the more memory that is required. To
    support high performance, we should strive to understand how Java manages memory
    specific to object creation. To aid in our understanding, let’s look at three.
  prefs: []
  type: TYPE_NORMAL
- en: Stack versus heap memory
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Stacks** and **heaps** are both used for memory allocation, are used for
    different purposes, and behave differently. Let’s start by defining a stack.'
  prefs: []
  type: TYPE_NORMAL
- en: Stack
  prefs: []
  type: TYPE_NORMAL
- en: A stack is the region of memory where a static collection of elements using
    a **last in, first out** (**LIFO**) model is stored.
  prefs: []
  type: TYPE_NORMAL
- en: Next, let’s look at what a heap is so that we can compare it to a stack and
    determine how both of them impact performance.
  prefs: []
  type: TYPE_NORMAL
- en: Heap
  prefs: []
  type: TYPE_NORMAL
- en: A heap is an area of memory that’s used for dynamic memory allocation. Objects
    are allocated on the heap when we use the `new` keyword in our applications.
  prefs: []
  type: TYPE_NORMAL
- en: Java uses both stacks and heaps and, as you’ve learned, they are used differently.
    Let’s look more deeply at stacks. We typically use stacks to store our application’s
    local variables, as well as reference information for our methods. Stacks use
    **LIFO** for efficient access to local variables and method calls. Limiting factors
    of stacks include their limited lifespan and size. This makes the use of stacks
    for long-term object storage impractical.
  prefs: []
  type: TYPE_NORMAL
- en: We push objects onto the heap when we use Java’s `new` keyword. Heaps provide
    us with dynamic memory allocation. When we use a heap, our objects can exist outside
    the scope of the methods that created them. This necessitates the use of the JVM’s
    garbage collector to remove items from the heap that are unreachable.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following table summarizes the differences between stacks and heaps in
    Java:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Characteristic** | **Stack** | **Heap** |'
  prefs: []
  type: TYPE_TB
- en: '| Storage | Local variables | Objects and their methods and properties |'
  prefs: []
  type: TYPE_TB
- en: '| Memory management | LIFO order | Managed by the JVM garbage collector |'
  prefs: []
  type: TYPE_TB
- en: '| Size | Limited | Larger than stacks |'
  prefs: []
  type: TYPE_TB
- en: '| Lifetime | Variables exist until the declaring method ends | Objects exist
    until they are no longer reachable |'
  prefs: []
  type: TYPE_TB
- en: '| Performance | Fast allocation and deallocation | Slower than stacks |'
  prefs: []
  type: TYPE_TB
- en: Table 6.1 – Stack and heap comparison
  prefs: []
  type: TYPE_NORMAL
- en: 'The key differences between stacks and heaps are their scope of use, how the
    memory is managed, access speed, and storage size. In addition, there are risks
    of errors at runtime. For example, a stack can run out of memory, which leads
    to a `StackOverflowError` error. If a heap runs out of memory, an `OutOfMemoryError`
    error can be thrown. We need to handle those errors. Let’s look at an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we used `try`-`catch` blocks to trap the errors. Also, it is
    important to know that these errors are instances of `Error`, not `Exception`.
    So, these are indeed errors, not exceptions.
  prefs: []
  type: TYPE_NORMAL
- en: Memory management with garbage collection
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: One of the most prized features of the Java programming language is its **garbage
    collection**. This automatic memory deallocation can take a lot of responsibility
    off the developer’s shoulders, but there are some disadvantages as well. Let’s
    take a deeper look at Java’s seemingly straightforward garbage collection.
  prefs: []
  type: TYPE_NORMAL
- en: Java’s garbage collector identifies objects that are no longer reachable in
    the application. Once identified, those objects are removed and the memory they
    used is deallocated, making it available to the application.
  prefs: []
  type: TYPE_NORMAL
- en: While we can applaud the garbage collector’s efforts and appreciate the memory
    it frees up for our applications, there can be an impact on performance. When
    we have frequent garbage collection cycles, pauses and reduced responsiveness
    can be introduced at runtime. Mitigation strategies include minimizing object
    creation and implementing timely object disposal. These strategies can reduce
    the frequency of garbage collection.
  prefs: []
  type: TYPE_NORMAL
- en: We will look at how to implement these strategies later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Optimization techniques
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'There are several strategies that we can adopt to help optimize memory usage
    in our Java applications:'
  prefs: []
  type: TYPE_NORMAL
- en: Limit object creation; only create them when absolutely needed
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Avoid creating objects within loops
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use local variables and object pooling (covered in [*Chapter 4*](B21942_04.xhtml#_idTextAnchor074))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implement object immutability (covered later in the *Object immutability* section
    of this chapter)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use profiling tools for memory usage (see [*Chapter 14*](B21942_14.xhtml#_idTextAnchor250))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is important to take a purposeful and informed approach to memory management
    in our Java applications. To do this, we need to understand memory limitations
    and how memory is allocated and deallocated.
  prefs: []
  type: TYPE_NORMAL
- en: Object pooling
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As you may recall from [*Chapter 4*](B21942_04.xhtml#_idTextAnchor074), object
    pooling is an important design pattern we can use to create a set of objects that
    can be kept in a pool, ready for use, instead of allocating them when we need
    them and deallocating them when they go out of scope. Object pooling helps us
    to efficiently manage system resources by reusing objects. The benefits are especially
    noticeable when our objects are large and take significant time to create.
  prefs: []
  type: TYPE_NORMAL
- en: Initialization approaches
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There is more than one way to create objects in Java and our initialization
    approach can significantly impact the overall performance of our Java applications
    and how our memory is used. Let’s look at four approaches: direct, lazy, pooling,
    and builder.'
  prefs: []
  type: TYPE_NORMAL
- en: Direct initialization
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The most common method that’s used to create a new object is the **direct initialization**
    method. As shown in the following example, it’s straightforward. We use constructors
    or initializers with this method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The benefits of this method are that it is easy to understand and program. It
    can also be used in many scenarios where objects need to be created. The disadvantages
    of this method include that it can lead to unnecessary object creation, which
    is the opposite of our goal to minimize object creation. This is especially evident
    when the direct initialization method is used inside loops or in methods that
    are called frequently. Another disadvantage is that the objects that are created
    using this method cannot be reused.
  prefs: []
  type: TYPE_NORMAL
- en: Lazy initialization
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The strategy of delaying an object’s creation until it is needed by the application
    is referred to as **lazy initialization**. As illustrated in the following code
    snippet, the object isn’t created unless a specific condition exists:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: An advantage of this method is that object creation is minimized until it is
    required. Additionally, memory usage is reduced when we conditionally create several
    objects. However, this strategy results in increased code complexity and can introduce
    synchronization issues when dealing with multi-threaded environments.
  prefs: []
  type: TYPE_NORMAL
- en: Object pooling
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We can also use object pooling to create a pool of pre-initialized objects
    that can be used multiple times, taking them from and returning them to the pool
    as needed. The following code snippet shows how that code would be structured:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: You can revisit [*Chapter 4*](B21942_04.xhtml#_idTextAnchor074) for greater
    detail on object pooling.
  prefs: []
  type: TYPE_NORMAL
- en: Builder pattern
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Another increasingly popular method of object creation is using the builder
    pattern. This is a design pattern that treats object construction and its representation
    separately. This method empowers us to create multi-attribute objects one step
    at a time. The following code snippet illustrates the build pattern concept:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: One benefit of this method is that it introduces object construction flexibility.
    This can be very useful when you’re creating complex objects. Another benefit
    is that it permits us to set selected attributes by having a complex constructor.
    The primary disadvantage of the builder pattern method is that it requires us
    to define a separate builder class for each type of object that’s used in our
    applications. This can significantly increase our code’s complexity and decrease
    its readability and maintainability.
  prefs: []
  type: TYPE_NORMAL
- en: Overhead reduction
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When we consider the goal of minimizing object creation, we should consider
    object pooling, object cloning, and object serialization. We touched on object
    pooling earlier in this chapter and provided in-depth coverage in [*Chapter 4*](B21942_04.xhtml#_idTextAnchor074).
    We will save our discussion on object cloning until later in this chapter. For
    now, know that it can be associated with overhead reduction.
  prefs: []
  type: TYPE_NORMAL
- en: The third concept is object serialization. Fortunately, Java allows us to convert
    objects to and from binary form. We typically use this for object persistence
    and can also use it to create copies of objects with reduced overhead.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s an example of how we can serialize (convert into binary) and deserialize
    (convert back to an object):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Reducing overhead when creating objects should be a key consideration when our
    applications are expected to have high performance.
  prefs: []
  type: TYPE_NORMAL
- en: Object immutability
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let’s continue learning how to minimize object creation to increase the performance
    of our Java applications. **Object immutability** refers to an object that cannot
    be modified once it has been instantiated. Immutability can be considered a property
    or characteristic of an object. The advantages of making objects **immutable**
    include system predictability and performance.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s start with a brief overview of object immutability.
  prefs: []
  type: TYPE_NORMAL
- en: Immutability overview
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Object immutability is not a new concept, but it is an important one. The general
    premise is that we create an object with all the desired attributes and behaviors,
    and then prevent it from being **mutated** (changed) throughout the object’s life
    cycle.
  prefs: []
  type: TYPE_NORMAL
- en: Immutable objects and considered safe because they cannot be changed. This means
    that we can share these objects in multi-threaded environments without the requirement
    for synchronization. So, concurrent programming is simplified. You will learn
    more about concurrency in [*Chapter 9*](B21942_09.xhtml#_idTextAnchor159).
  prefs: []
  type: TYPE_NORMAL
- en: Immutable objects are known to have an immutable state, be safe for sharing,
    have predictable behavior, and align with functional programming principles.
  prefs: []
  type: TYPE_NORMAL
- en: Best practices
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Creating immutable objects requires more than simply setting an attribute; it
    requires adherence to certain best practices. We want our immutable objects to
    be robust, the code to be maintainable, and positively contribute to the application’s
    overall performance.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding these best practices is key to proper implementation.
  prefs: []
  type: TYPE_NORMAL
- en: Declare as final
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The first best practice for creating immutable objects is to ensure all attributes
    are declared as `final`. The following code shows how to declare the class as
    `final`, as well as the two variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Adhering to this best practice ensures the attributes cannot be changed once
    the object is created. This can also help us detect any attempts to change the
    object at runtime.
  prefs: []
  type: TYPE_NORMAL
- en: Complete constructor
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The second best practice is simply to ensure that all attributes of a class
    are initialized in the constructor. It is important to initialize all fields within
    the constructor. The goal is to ensure that the object is fully defined when it
    is created. Remember, we won’t be able to make changes to the object later.
  prefs: []
  type: TYPE_NORMAL
- en: Avoid setters
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'When you’ve been a Java developer for a considerable time, you’ll likely create
    setters and getters in your classes automatically. We don’t use a checklist; it
    just becomes a habit. In the case of immutable objects, we don’t want to give
    our applications the ability to call a setter since no changes should be made
    to the object after it’s created. The following code snippet shows how to create
    a standard class with a constructor. There is a getter method, but no setters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Since we shouldn’t be calling any setters on immutable objects, it’s important
    not to include them in our classes.
  prefs: []
  type: TYPE_NORMAL
- en: Defensive copies
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'When we return a reference from an immutable object to an internal mutable
    object, it’s important to return a **defensive copy**. This prevents any external
    modification. The following code snippet demonstrates how we should implement
    this best practice:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Using this approach helps ensure that the object’s state remains immutable.
  prefs: []
  type: TYPE_NORMAL
- en: Annotation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Our last best practice when it comes to creating immutable objects is to use
    the `@Immutable` annotation. Here, we are using the **Project** **Lombok** library:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: When we use this annotation, we can benefit from auto-generated code making
    us more efficient. Note that this annotation may not be available in later versions
    of Lombok.
  prefs: []
  type: TYPE_NORMAL
- en: Performance advantages
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As you have learned so far, object immutability offers several benefits to
    us and our applications. One category of benefits is performance. Here’s a list
    of performance advantages:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Predicable state**: When using immutable objects, we can rely on their state
    to remain constant throughout their lifespan.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Garbage collection efficiency**: Using immutable objects reduces how often
    object collection and disposal functions have to run.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Safe caching**: We can safely cache immutable objects and even share them
    among multiple threads without data corruption concerns.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Reduced overhead**: Because immutable objects are thread-safe, we don’t need
    to use synchronization mechanisms in multi-thread environments.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Easier parallelization**: We can simplify concurrent programming and parallel
    programming when we use immutable objects.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Functional programming advantage**: As mentioned previously, immutable objects
    align with functional programming. In that programming paradigm, functions produce
    predictable results without side effects.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding the performance advantages of using object immutability can encourage
    us to adopt this approach, which can result in sufficiently more performant Java
    applications.
  prefs: []
  type: TYPE_NORMAL
- en: Custom classes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We previously reviewed best practices for implementing immutable objects. In
    addition to those best practices, we should implement the `equals` and `hashCode`
    methods. Let’s look at that in code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, when we want to perform equality testing and ensure compatibility
    with certain data structures, we can override the `equals` and `hashCode` methods
    in our custom immutable classes. When we do this, we must ensure we consider all
    attributes that can contribute to equality.
  prefs: []
  type: TYPE_NORMAL
- en: String classes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As you likely know, strings are a commonly used data type and they are, by their
    very nature, immutable. Let’s look at how strings work as immutable objects so
    that we can better understand how to design immutable objects.
  prefs: []
  type: TYPE_NORMAL
- en: 'Strings are indeed immutable and even when we think we are modifying them,
    Java is creating a new object. As an example, consider the following lines of
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, when we call the `concat` method on the first string, a new
    string object is created.
  prefs: []
  type: TYPE_NORMAL
- en: 'String immutability provides us with several advantages, such as thread safety,
    predictable behavior, and efficiency with string manipulations. Under the hood,
    Java maintains a string pool, also referred to as an intern pool, to store unique
    string literals. This is another advantage of string immutability. Let’s look
    at this in code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: A fifth advantage of string immutability is security. This means we can confidently
    use strings for sensitive data, such as banking information, passwords, and cryptographic
    keys, because unintentional modification is prevented.
  prefs: []
  type: TYPE_NORMAL
- en: Garbage collection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have already established that memory management is important when our goal
    is to have our Java applications perform at a high level. We also looked at how
    garbage completion works and what its benefits are.
  prefs: []
  type: TYPE_NORMAL
- en: Garbage collection implications
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The automatic nature of Java’s garbage collection results in many developers
    ignoring it. They take garbage collection for granted and do not implement any
    best practices. This is okay for small projects that are not data- or memory-intensive.
    Let’s look at two ways that garbage collection can impact our applications and
    memory management:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Application pauses**: Frequent garbage collection cycles can result in our
    application pausing. The type of garbage collection and heap size are key determiners
    for the length of these pauses.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Memory overhead**: Garbage collection increases memory overhead. CPU cycles
    and memory resources are impacted each time garbage collection runs.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'There are several approaches we can take to help mitigate the impact garbage
    collection has on our applications:'
  prefs: []
  type: TYPE_NORMAL
- en: Take a purposeful approach to managing the life cycle of our objects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Avoid unnecessary object creation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reuse objects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implement object pooling
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use immutable objects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the next section, we will look at how object cloning relates to garbage collection.
  prefs: []
  type: TYPE_NORMAL
- en: Object cloning
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As you might assume, **object cloning** is when we create a new object that
    is a duplicate of an existing one. Its relevance to garbage collection is due
    to its potential impact on how objects are managed and disposed of. The type of
    impact is influenced by the type of cloning used. Let’s look at two types of cloning:
    shallow and deep.'
  prefs: []
  type: TYPE_NORMAL
- en: Shallow cloning
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The process of **shallow cloning** involves creating a new object by copying
    the contents of the original object. It’s important to note that if the original
    object contains any references to other objects, the clone will point to the same
    objects. This is an expected behavior; we are cloning all the objects so that
    they include references, but not the referenced objects. Let’s look at a brief
    example in code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, when we clone a `Corgi` object, the new Corgi will share the
    same `authenticityCertificate` as the original. If that field is mutable, then
    changes that are made to it through one reference will take effect in both the
    original and cloned Corgi objects.
  prefs: []
  type: TYPE_NORMAL
- en: Deep cloning
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'When we create a **deep clone**, we still create a new object, but it also
    recursively copies all objects that are referenced by the original object. This
    method of cloning ensures that the new object and its sub-objects are independent
    of the original object. Let’s look at this in code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, when we clone a `Corgi` object, it is a new `Corgi` object and
    a new `Address` object is created. With this method, we can make changes to one
    object without impacting the other.
  prefs: []
  type: TYPE_NORMAL
- en: Design patterns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Design patterns are time-tested solutions to common software problems. They
    can be considered a set of best practices and are widely used for Java development.
    Concerning strategic object creation and immutability, two design patterns deserve
    our attention:'
  prefs: []
  type: TYPE_NORMAL
- en: Singleton pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Factory pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What a design pattern is not
  prefs: []
  type: TYPE_NORMAL
- en: Design patterns are structured approaches to solving known problems. They are
    not algorithms, templates, libraries, or even code snippets. Instead, they offer
    high-level guidance that we can follow.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s look at each of these patterns so that we understand how their use can
    help improve the performance of our Java applications.
  prefs: []
  type: TYPE_NORMAL
- en: Singleton pattern
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The **singleton design pattern** ensures that there is only one instance of
    a class and then provides global access to that instance. This pattern is often
    used when an application is managing database connections, resource management,
    logging, caching, or configuration settings.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s look at a simple implementation approach for this pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code is a standard example. As you can see, this class prohibits
    more than one instance from being created. Additionally, the `getInstance()` method
    is how we provide global access to the instance of the `Singleton` class.
  prefs: []
  type: TYPE_NORMAL
- en: Factory pattern
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The **factory design pattern** involves a superclass and an interface for creating
    objects in it. This pattern permits subclasses to alter what can be created. It
    promotes loose coupling between the superclass and the subclasses being created.
    The most common components of this pattern are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Abstract factory**: This is an interface that declares the method that’s
    used to create objects.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Concrete factory**: This is a class that implements the abstract factory
    interface. It creates concrete objects.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Product**: This is the object that’s created by the factory.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Concrete product**: This is the class that implements the product interface.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The advantages of using this pattern include separation of concerns, code reusability,
    flexibility, and encapsulation. Next, we will look at several code snippets that
    illustrate simple implementation examples.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, here is an example of an abstract product:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let’s look at an example of concrete products:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The following code snippet illustrates how to implement an abstract factory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Lastly, the following code demonstrates how to implement concrete factories:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The factory pattern can be a valuable tool when you need flexibility when it
    comes to creating objects based on specific requirements or conditions.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter focused on strategic object creation and immutability, two closely
    related and equally important topics. We looked at various aspects of these topics
    to help improve the performance of our Java applications. Specifically, we looked
    at minimizing object creation, object immutability, garbage collection, and design
    patterns. You should now have a better understanding and deep appreciation for
    the importance of strategic object creation, as well as its best practices and
    implementation strategies. You should also have a firm grasp of the concept of
    object immutability.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, *String Objects*, we will take a deeper look into string
    objects while covering topics such as proper string pooling, lazy initialization,
    and string operation strategies.
  prefs: []
  type: TYPE_NORMAL
