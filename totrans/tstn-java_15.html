<html><head></head><body>
		<div id="_idContainer087">
			<h1 id="_idParaDest-271" class="chapter-number"><a id="_idTextAnchor301"/>15</h1>
			<h1 id="_idParaDest-272"><a id="_idTextAnchor302"/>Jakarta Faces Application</h1>
			<p>Jakarta Faces, now just called Faces, is one of two client rendering techniques available in web applications. The <a id="_idIndexMarker944"/>other is <strong class="bold">Jakarta Server Pages</strong> (<strong class="bold">JSP</strong>). In this chapter, we will examine a Faces web application that, like our Swing and JavaFX examples, allows you to perform three common <span class="No-Break">finance calculations.</span></p>
			<p>The JSP rendering approach permits the placement of Java source code on an HTML page. Before a JSP page can be rendered, the file is converted into a servlet by the application server. If you have 50 JSP pages, then there will be 50 servlets on the application server. The typical approach in designing an application is to use JSP for rendering by mixing standard HTML, expression language code to access data or call Java methods, and Java source code. These files end with a <strong class="source-inline">.jsp</strong> extension. While you can do processing on the page, the common approach is to have a JSP page call upon a servlet for processing and to decide which JSP page to return to <span class="No-Break">the browser.</span></p>
			<p>The Faces approach is quite different. First off, the framework provides the Faces servlet. All requests for a <strong class="source-inline">.jsf</strong> page are processed by this servlet. While a JSP application is usually a combination of <strong class="source-inline">.jsp</strong> pages and servlets, a Faces application does not <a id="_idIndexMarker945"/>require any servlets, though they can be used. In the place of servlets, Faces allows you to use a <strong class="bold">plain old Java object</strong> (<strong class="bold">POJO</strong>) for any processing the page requires. We will see that, with minor changes, we can use our <strong class="source-inline">Calculations</strong> and <strong class="source-inline">FinanceBean</strong> classes from <a href="B19088_13.xhtml#_idTextAnchor254"><span class="No-Break"><em class="italic">Chapter 13</em></span></a>, <em class="italic">Desktop Graphical User Interface Coding with Swing and JavaFX</em>, by adding some annotations to <span class="No-Break">the code.</span></p>
			<p>A Faces page <a id="_idIndexMarker946"/>contains Facelets along with any standard HTML tag. Facelets is the <strong class="bold">view declaration language</strong> (<strong class="bold">VDL</strong>). As we will see shortly, a Faces page looks like an HTML page but uses custom tags called Facelets to describe how the page is rendered. This is significant because these Facelets are calling upon methods in the Faces framework that return standard HTML and JavaScript. This means that you can create your own custom tags and matching Java code. There are companies that provide libraries of Facelets that you can use by simply adding the library to your Maven <strong class="source-inline">pom</strong> file. See the <em class="italic">Further reading</em> section for examples of these <span class="No-Break">third-party libraries.</span></p>
			<p>We will <a id="_idIndexMarker947"/>interact with most objects by employing <strong class="bold">Context Dependency Injection</strong> (<strong class="bold">CDI</strong>). When a class is annotated for CDI, you no longer need to instantiate the object with <strong class="source-inline">new</strong>. Instead, the CDI framework instantiates an object upon first use and determines whether it needs to be garbage collected or not. We can <a id="_idIndexMarker948"/>also use <strong class="bold">Bean Validation</strong> (<strong class="bold">BV</strong>) in a CDI bean. This allows you, using annotations, to define how to determine whether an assignment of data through a setter method is valid. No need for an <span class="No-Break"><strong class="source-inline">if</strong></span><span class="No-Break"> statement.</span></p>
			<p>This chapter will now take you through how our Financial Calculator is written using Faces, CDI, and BV. We will examine the <span class="No-Break">following topics:</span></p>
			<ul>
				<li>Configuring a <span class="No-Break">Faces application</span></li>
				<li>Creating an object managed by CDI and validated <span class="No-Break">with BV</span></li>
				<li>Using XHTML, Facelets, and Jakarta Expression Language for <span class="No-Break">rendering pages</span></li>
				<li>Understanding the life cycle of a <span class="No-Break">Faces page</span></li>
			</ul>
			<p>By the end of this chapter, you will understand how a Faces web application is constructed. With this knowledge, you will be able to evaluate other web application frameworks, such as Spring <span class="No-Break">and Vaadin.</span></p>
			<h1 id="_idParaDest-273"><a id="_idTextAnchor303"/>Technical requirements</h1>
			<p>For this chapter, you’ll need <span class="No-Break">the following:</span></p>
			<ul>
				<li><span class="No-Break">Java 17</span></li>
				<li>A <span class="No-Break">text editor</span></li>
				<li>Maven 3.8.6 or a newer <span class="No-Break">version installed</span></li>
				<li>GlassFish 7.0 <span class="No-Break">application server</span></li>
				<li><span class="No-Break">Web browser</span></li>
			</ul>
			<p>Sample code for this chapter is available <span class="No-Break">at </span><a href="https://github.com/PacktPublishing/Transitioning-to-Java/tree/chapter15"><span class="No-Break">https://github.com/PacktPublishing/Transitioning-to-Java/tree/chapter15</span></a><span class="No-Break">.</span></p>
			<h1 id="_idParaDest-274"><a id="_idTextAnchor304"/>Configuring a Faces application</h1>
			<p>Here is what <a id="_idIndexMarker949"/>the web version of the Financial Calculator app <span class="No-Break">looks like:</span></p>
			<div>
				<div id="_idContainer083" class="IMG---Figure">
					<img src="image/B19088_15_01.jpg" alt="Figure 15.1 – The Financial Calculator web page"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 15.1 – The Financial Calculator web page</p>
			<p>Configuring a Faces project begins with the same setup as any basic web application, such as what we saw in the previous chapter. The Maven folder setup is identical. In the <strong class="source-inline">WEB-INF</strong> folder, we have three required XML configuration files and one that is optional. Let us begin <span class="No-Break">with </span><span class="No-Break"><strong class="source-inline">beans.xml</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
&lt;beans xmlns="https://jakarta.ee/xml/ns/jakartaee"
    xmlns:xsi=http://www.w3.org/2001/XMLSchema-instance
    xsi:schemaLocation="https://jakarta.ee/xml/ns/jakartaee
    https://jakarta.ee/xml/ns/jakartaee/beans_3_0.xsd"
       <strong class="bold">bean-discovery-mode="annotated"</strong>&gt;
&lt;/beans&gt;</pre>
			<p>This looks strange because there is only one tag, <strong class="source-inline">beans</strong>. Before the widespread usage of annotations, listing every bean or class was necessary to enable CDI. The <strong class="source-inline">bean-discovery-mode</strong> tag defines any bean with a CDI annotation is now subject to the CDI. Prior to Jakarta EE 10, the discovery mode to use was <strong class="source-inline">all</strong>. The current best practice is to use <strong class="source-inline">annotated</strong> rather <span class="No-Break">than </span><span class="No-Break"><strong class="source-inline">all</strong></span><span class="No-Break">.</span></p>
			<p>The next configuration file is <strong class="source-inline">faces-config.xml</strong>. In this file, you can define application properties. Some of these properties can be navigation rules to determine to which page should a submit request go next, bean objects that should be instantiated, and message <a id="_idIndexMarker950"/>bundles for i18n support. In this example, we are only using this file to define the message bundle for <span class="No-Break">this application:</span></p>
			<pre class="source-code">
&lt;faces-config version="4.0"
     xmlns="https://jakarta.ee/xml/ns/jakartaee"
     xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
     xsi:schemaLocation=
           "https://jakarta.ee/xml/ns/jakartaee
            https://jakarta.ee/xml/ns/jakartaee/
                                web-facesconfig_4_0.xsd"&gt;
    &lt;application&gt;
        &lt;resource-bundle&gt;
            &lt;base-name&gt;
                com.kenfogel.bundles.MessagesBundle
            &lt;/base-name&gt;
            &lt;var&gt;msgs&lt;/var&gt;
        &lt;/resource-bundle&gt;
    &lt;/application&gt;
&lt;/faces-config&gt;</pre>
			<p>You can see in <strong class="source-inline">base-name</strong> the package and base file name for the message bundles. Under <strong class="source-inline">var</strong> you can see the name of the identifier we can use on a Faces XHTML page. Bundles in Faces are identical to how we created resource bundles that are configured for desktop applications with a key followed by a value. To refer to a value from a message bundle, we use expression language such <span class="No-Break">as </span><span class="No-Break"><strong class="source-inline">#{msgs.result}</strong></span><span class="No-Break">.</span></p>
			<p>The last required <a id="_idIndexMarker951"/>configuration file is the <strong class="source-inline">web.xml</strong> file. It can fulfill the same responsibilities as we saw in the previous chapter. In addition, we can modify how Faces performs. For simplicity, I have removed the opening and closing tags as they are identical to the previous <span class="No-Break">chapter’s version.</span></p>
			<p>The first param, <strong class="source-inline">PROJECT_STAGE</strong>, configures the framework error handling. Using the <strong class="source-inline">Development</strong> error messages carries more information than a small code of slower performance. Typically, you will change this to <strong class="source-inline">Production</strong> when the code <span class="No-Break">is complete:</span></p>
			<pre class="source-code">
&lt;context-param&gt;
    &lt;param-name&gt;jakarta.faces.PROJECT_STAGE&lt;/param-name&gt;
    &lt;param-value&gt;Development&lt;/param-value&gt;
&lt;/context-param&gt;</pre>
			<p>The next param determines whether comments in the Faces page will be in the HTML sent to the browser <span class="No-Break">or not:</span></p>
			<pre class="source-code">
&lt;context-param&gt;
   &lt;param-name&gt;
       jakarta.faces.FACELETS_SKIP_COMMENTS
   &lt;/param-name&gt;
   &lt;param-value&gt;true&lt;/param-value&gt;
&lt;/context-param&gt;</pre>
			<p>The server will destroy a session object and send it for garbage collection if it is explicitly destroyed or the session timeout <span class="No-Break">is reached:</span></p>
			<pre class="source-code">
&lt;session-config&gt;
   &lt;session-timeout&gt;
      30
   &lt;/session-timeout&gt;
&lt;/session-config&gt;</pre>
			<p>When referring to a website by its name rather than a specific page, then this is the page that will be displayed. In Faces, it should always be a <strong class="source-inline">.</strong><span class="No-Break"><strong class="source-inline">xhtml</strong></span><span class="No-Break"> file:</span></p>
			<pre class="source-code">
&lt;welcome-file-list&gt;
   &lt;welcome-file&gt;index.xhtml&lt;/welcome-file&gt;
&lt;/welcome-file-list&gt;</pre>
			<p>The last and <a id="_idIndexMarker952"/>optional configuration file is <strong class="source-inline">glassfish-web.xml</strong>. We can provide configuration information for database connection pooling, security information, and other items that the application server is responsible for in this file. In my example projects, I have removed this file as we do not <span class="No-Break">require it.</span></p>
			<p>With a project organized and configuration files in place, we are ready to start on our application. Before we concern ourselves with the web page design, we need to set up the POJOs that our application will require and configure them to work under the care <span class="No-Break">of CDI.</span></p>
			<h1 id="_idParaDest-275"><a id="_idTextAnchor305"/>Creating an object managed by Context Dependency Injection and validated with Bean Validation</h1>
			<p>Only two <a id="_idIndexMarker953"/>Java classes are <a id="_idIndexMarker954"/>used in this program, and they are nearly identical to what we used in <a href="B19088_13.xhtml#_idTextAnchor254"><span class="No-Break"><em class="italic">Chapter 13</em></span></a>, <em class="italic">Desktop Graphical User Interface Coding with Swing and JavaFX</em>. They <a id="_idIndexMarker955"/>are both subject to CDI, and the data class also uses BV. Rather than show the entire code for these beans we saw in <a href="B19088_13.xhtml#_idTextAnchor254"><span class="No-Break"><em class="italic">Chapter 13</em></span></a>, we will only look at what needs to <span class="No-Break">be changed.</span></p>
			<h2 id="_idParaDest-276"><a id="_idTextAnchor306"/>FinanceBean</h2>
			<p>The <a id="_idIndexMarker956"/>first annotation, <strong class="source-inline">@Named</strong>, defines this class as under the control of CDI. Before CDI was widely <a id="_idIndexMarker957"/>used, JSF had its own CDI-like implementation that used the <strong class="source-inline">@ManagedBean</strong> annotation. This is considered obsolete and should no longer be used. The name in the parenthesis, <strong class="source-inline">money</strong>, is an alias we can use in the <span class="No-Break">expression language:</span></p>
			<pre class="source-code">
@Named("money")</pre>
			<h2 id="_idParaDest-277"><a id="_idTextAnchor307"/>Scopes</h2>
			<p>When an <a id="_idIndexMarker958"/>object managed by CDI in a Jakarta application is created or destroyed, and other classes may access it, it is referred to as the Scope. There are the <span class="No-Break">following types:</span></p>
			<ul>
				<li><strong class="source-inline">@RequestScoped</strong>: This <a id="_idIndexMarker959"/>means that the server will create a new object for every request, and the previous object from a previous request is sent out for garbage collection for <span class="No-Break">each user.</span></li>
				<li><strong class="source-inline">@SessionScoped</strong>: This <a id="_idIndexMarker960"/>means that objects created upon the first request remain in place and are only destroyed explicitly or when the session timer ends for <span class="No-Break">each user.</span></li>
				<li><strong class="source-inline">@ApplicationScoped</strong>: These <a id="_idIndexMarker961"/>objects are available to every session for <span class="No-Break">all users.</span></li>
				<li><strong class="source-inline">@ViewScoped</strong>: This <a id="_idIndexMarker962"/>is the final scope. Beans created with this scope are tied to a Faces page. As long as you do not change the view, such as by having a link or button that calls upon another page, then the bean <span class="No-Break">remains valid.</span></li>
			</ul>
			<p>Now back to <span class="No-Break">the code:</span></p>
			<pre class="source-code">
@RequestScoped
public class FinanceBean implements Serializable {
    private static final Logger LOG =
        Logger.getLogger(FinanceBean.class.getName());</pre>
			<p>Each of the BigDecimal variables has been declared with BV annotations. In this example, we are setting a minimum and maximum value. The <strong class="source-inline">message</strong> attribute is the key to a <a id="_idIndexMarker963"/>separate message bundle that is named <strong class="source-inline">ValidationMessages</strong>. Just like ordinary bundles, you need a default and then one for each supported language. These validation bundles are expected to be found in the <strong class="source-inline">resources</strong> folder and not in any folders <span class="No-Break">below it:</span></p>
			<pre class="source-code">
    @DecimalMin(value = "1.00",
            message = "{com.kenfogel.minInput}")
    @DecimalMax(value = "100000.00",
            message = "{com.kenfogel.maxInput}")
    private BigDecimal inputValue;
    @DecimalMin(value = "0.00",
          message = "{com.kenfogel.minInput}")
    @DecimalMax(value = "1.00",
          message = "{com.kenfogel.maxInput}")
    private BigDecimal rate;
    @DecimalMin(value = "1.00",
           message = "{com.kenfogel.minInput}")
    @DecimalMax(value = "300.00",
           message = "{com.kenfogel.maxInput}")
    private BigDecimal term;
    private BigDecimal result;</pre>
			<p>Here are two new fields not found in the original <strong class="source-inline">FinanceBean</strong> class. The first is the <strong class="source-inline">calculationType</strong> field that defines which of the three calculation formulas are used. It is also used to update the name of <strong class="source-inline">Label</strong> of the first <span class="No-Break">input field:</span></p>
			<pre class="source-code">
    private String calculationType;</pre>
			<p>The new text must be shown in the first input label when the calculation type changes. This will be read from the <span class="No-Break">resource bundle:</span></p>
			<pre class="source-code">
    private final ResourceBundle msgs;
    public FinanceBean() {
        result = BigDecimal.ZERO;
        inputValue = BigDecimal.ZERO;
        rate = BigDecimal.ZERO;
        term = BigDecimal.ZERO;</pre>
			<p>Here in <a id="_idIndexMarker964"/>the constructor, we define the calculation as <strong class="source-inline">loan</strong> and <span class="No-Break">initialize </span><span class="No-Break"><strong class="source-inline">msgs</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
        calculationType = "loan";
        msgs = ResourceBundle.getBundle(
              "com.kenfogel.bundles.MessagesBundle");
   }</pre>
			<p>The remaining methods in this data class are just the usual getters <span class="No-Break">and setters.</span></p>
			<p>One last point about CDI and BV is that they can be used in any type of Java application that includes the CDI and/or BV library. That library is part of Jakarta, so there is no specific reference to it in the <strong class="source-inline">pom</strong> file. To use just CDI, BV, or both in your application, add the following to your <span class="No-Break"><strong class="source-inline">pom</strong></span><span class="No-Break"> file:</span></p>
			<pre class="source-code">
&lt;dependency&gt;
    &lt;groupId&gt;jakarta.enterprise&lt;/groupId&gt;
    &lt;artifactId&gt;jakarta.enterprise.cdi-api&lt;/artifactId&gt;
    &lt;version&gt;4.0.1&lt;/version&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;jakarta.validation&lt;/groupId&gt;
    &lt;artifactId&gt;jakarta.validation-api&lt;/artifactId&gt;
    &lt;version&gt;3.0.2&lt;/version&gt;
&lt;/dependency&gt;</pre>
			<p>With a <a id="_idIndexMarker965"/>data bean called a backing bean in Faces, in place, we can now look at the <span class="No-Break"><strong class="source-inline">Calculations</strong></span><span class="No-Break"> class.</span></p>
			<h2 id="_idParaDest-278"><a id="_idTextAnchor308"/>Calculations</h2>
			<p>The <strong class="source-inline">Calculations</strong> class is also mostly unchanged. The formulas in all three calculation methods are the same. The first change is that the <strong class="source-inline">FinanceBean</strong> object is now a <a id="_idIndexMarker966"/>class field that is instantiated by CDI rather than a parameter passed to each method. The second change is that calls for a calculation are made to a method that, in turn, selects the appropriate calculation method. Let us look at <span class="No-Break">this now.</span></p>
			<p>The class begins with the annotation that defines this as a CDI-managed bean. The scope is <strong class="source-inline">@RequestScope</strong>. A CDI bean is instantiated either when it is injected into another class, as we will see next, or upon first use on a <span class="No-Break">Faces page:</span></p>
			<pre class="source-code">
@Named("calculate")
@RequestScoped
public class Calculations implements Serializable {
    private static final Logger LOG =
      Logger.getLogger(Calculations.class.getName());</pre>
			<p>With the <strong class="source-inline">@Inject</strong> annotation, CDI will check whether this object currently exists. If it does, then a reference to it is assigned to a variable named <strong class="source-inline">money</strong>. If it does not exist, then it will be instantiated before passing the reference <span class="No-Break">into </span><span class="No-Break"><strong class="source-inline">money</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
    @Inject
    FinanceBean money;</pre>
			<p>This method will be called from the <span class="No-Break">Faces page:</span></p>
			<pre class="source-code">
    public String performCalculation() {
        switch (money.getCalculationType()) {
            case "loan" -&gt;
                loanCalculation();
            case "savings" -&gt;
                futureValueCalculation();
            case "goal" -&gt;
                savingsGoalCalculation();
        }
        return null;
    }</pre>
			<p>This is <a id="_idIndexMarker967"/>the start of one of the calculations that uses the class field to get the user input and where the result will <span class="No-Break">be stored:</span></p>
			<pre class="source-code">
    public void loanCalculation()
            throws ArithmeticException {
        // Divide APR by 12
        var monthlyRate = money.getRate().divide(
              new BigDecimal("12"), MathContext.DECIMAL64);</pre>
			<p>We have only scratched the surface of CDI and BV. See <em class="italic">Further reading</em> to find additional information on these features. Now let’s move on to Faces rendering of <span class="No-Break">web pages.</span></p>
			<h1 id="_idParaDest-279"><a id="_idTextAnchor309"/>Using XHTML, Facelets, and Expression Language for rendering pages</h1>
			<p>Faces <a id="_idIndexMarker968"/>applications use files with an <strong class="source-inline">xhtml</strong> extension. This <a id="_idIndexMarker969"/>extension means that either HTML <a id="_idIndexMarker970"/>or custom <a id="_idIndexMarker971"/>tags, called Facelets, must adhere to the rules of XML. This means that every tag must be closed. HTML allows for tags such as <strong class="source-inline">&lt;br&gt;</strong> and <strong class="source-inline">&lt;p&gt;,</strong> while to use these tags in XHTML, there must be an opening tag followed by a closing tag. Tags can also be self-closing by ending in a forward slash such as <strong class="source-inline">&lt;br/&gt;</strong> <span class="No-Break">or </span><span class="No-Break"><strong class="source-inline">&lt;p/&gt;</strong></span><span class="No-Break">.</span></p>
			<p>Let us look at the <strong class="source-inline">index.xhtml</strong> file that is responsible for the <span class="No-Break">user interface.</span></p>
			<p>We begin by declaring that this file is in the <span class="No-Break">XHTML format:</span></p>
			<pre class="source-code">
&lt;!DOCTYPE xhtml&gt;</pre>
			<p>XML documents <a id="_idIndexMarker972"/>are checked to ensure all tags are valid. The <a id="_idIndexMarker973"/>five namespaces listed <a id="_idIndexMarker974"/>here represent the common set of tags available <span class="No-Break">in Faces:</span></p>
			<pre class="source-code">
&lt;html xmlns:faces="jakarta.faces"
      xmlns:ui="jakarta.faces.facelets"
      xmlns:f="jakarta.faces.core"
      xmlns:h="jakarta.faces.html"
      xmlns:pt="jakarta.faces.passthrough" &gt;</pre>
			<p>Here we see our first Facelet, the <strong class="source-inline">h:head</strong> tag. When this file is processed by the Faces framework, each Facelet is a call to a Java method that returns a valid HTML string and, if <span class="No-Break">needed, JavaScript:</span></p>
			<pre class="source-code">
    &lt;h:head&gt;</pre>
			<p>Here we see our first Expression Language statement. In this case, we are retrieving the text from the messages bundle defined in the <strong class="source-inline">faces-config.xml</strong> file. Notice also that we are using an HTML tag and a title, and these tags are preserved in the HTML generated from processing the Faces page. In any situation where a Facelet matches an HTML tag, you should always use <span class="No-Break">the Facelet:</span></p>
			<pre class="source-code">
        &lt;title&gt;#{msgs.title}&lt;/title&gt;
        &lt;h:outputStylesheet library="css" name="main.css"/&gt;
    &lt;/h:head&gt;
    &lt;h:body&gt;
        &lt;h:form&gt;
            &lt;h1&gt;#{msgs.heading}&lt;/h1&gt;</pre>
			<p>Here we can see the Facelets for radio button input. When we call upon a method in expression <a id="_idIndexMarker975"/>language without ending the call with <a id="_idIndexMarker976"/>parenthesis, we are indicating that we want <a id="_idIndexMarker977"/>either <strong class="source-inline">getCalculationType()</strong> or <strong class="source-inline">setCalculationType()</strong>. We must use a method’s full name followed by parenthesis if it is not a setter <span class="No-Break">or getter:</span></p>
			<pre class="source-code">
            &lt;h:selectOneRadio
                value="#{money.calculationType}"
                immediate="true" styleClass="radiocenter" &gt;
                &lt;f:selectItem itemValue="loan"
                    itemLabel="#{msgs.loan_radio}"
                    styleclass="radiocenter"/&gt;
                &lt;f:selectItem itemValue="savings"
                     itemLabel="#{msgs.savings_radio}"
                     styleclass="radiocenter"/&gt;
                &lt;f:selectItem itemValue="goal"
                     itemLabel="#{msgs.goal_radio}"
                     styleclass="radiocenter" /&gt;</pre>
			<p>The common use of radio buttons is to provide a choice required when the form is submitted. In the design of this application, I wanted the fields to be cleared and the form rendered again. This re-rendering will also change the text of the input label of the first label. The <strong class="source-inline">valueChange</strong> event indicates that an Ajax partial submit will occur that will call upon the <strong class="source-inline">money.clear()</strong> method to reset all values to zero. The <strong class="source-inline">render="@form"</strong> attribute will result in the page <span class="No-Break">being re-rendered:</span></p>
			<pre class="source-code">
                &lt;f:ajax event="valueChange" render="@form"
                      action="#{money.clear()}"/&gt;
            &lt;/h:selectOneRadio&gt;</pre>
			<p>Here we are using <strong class="source-inline">panelGrid</strong>, which creates an HTML table. You indicate the number of columns, while the number of rows is determined by the number of either HTML tags or Facelets. The first value every two rows is a non-breaking space. This will consume a cell in the table but <span class="No-Break">display nothing:</span></p>
			<pre class="source-code">
            &lt;h:panelGrid columns="2" &gt;
                &lt;h:outputLabel value="&amp;#160;"/&gt;</pre>
			<p>The second <a id="_idIndexMarker978"/>value is <strong class="source-inline">h:message</strong>. This Facelet <a id="_idIndexMarker979"/>defaults to a blank entry. If an error occurs <a id="_idIndexMarker980"/>such as invalid input or a value out of range, then a message will appear above the input field. You can use either a <strong class="source-inline">style</strong> attribute to write the CSS in this attribute or use <strong class="source-inline">styleclass</strong> to refer to a class in the <span class="No-Break">CSS file:</span></p>
			<pre class="source-code">
                &lt;h:message id = "inputError"
                   for="inputValue"
                   style="white-space:nowrap; color:red;
                   font-size: 100%;"/&gt;</pre>
			<p>Here is what will appear if the user enters invalid or unconverted input. The appearance of these messages, along with everything else on a Faces page, can be styled <span class="No-Break">with CSS:</span></p>
			<div>
				<div id="_idContainer084" class="IMG---Figure">
					<img src="image/B19088_15_02.jpg" alt="Figure 15.2 – The h:message output"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 15.2 – The h:message output</p>
			<p>The text for this input label is retrieved from <strong class="source-inline">FinanceBean</strong> rather than from a message bundle directly. This is how the label can change based on the radio <span class="No-Break">button choice.</span></p>
			<p>Each <strong class="source-inline">h:inputText</strong> field contains a <strong class="source-inline">f:ajax</strong> Facelet. This will issue a partial submit, allowing the string you entered to be converted to <strong class="source-inline">BigDecimal</strong> and then checked whether it is in range. Otherwise, these checks will only occur when a <strong class="bold">Submit</strong> button is pressed. There is nothing more annoying than filling in a form only to discover several input errors after the <strong class="bold">Submit</strong> button <span class="No-Break">is pressed.</span></p>
			<p>The Faces framework takes care of the conversion from <strong class="source-inline">String</strong> to <strong class="source-inline">BigDecimal</strong>. If this fails due to the presence of invalid characters, the matching <strong class="source-inline">h:message</strong> field will appear <a id="_idIndexMarker981"/>with a message from the message bundle <a id="_idIndexMarker982"/>file. The <strong class="source-inline">converterMessage</strong> attribute <a id="_idIndexMarker983"/>contains the key value for <span class="No-Break">the bundle:</span></p>
			<pre class="source-code">
                &lt;h:outputLabel id = "inputLabel"
                    value="#{money.getInputLabel()}"
                    for="inputValue" /&gt;
                &lt;h:inputText value="#{money.inputValue}"
                  id="inputValue"
                  converterMessage="#{msgs.invalidInput}" &gt;
                  &lt;f:ajax event="blur"
                    render="inputError" /&gt;
                &lt;/h:inputText&gt;
                &lt;h:outputLabel value="&amp;#160;"/&gt;
                &lt;h:message id="interestError"
                    for="interestValue"
                    style="white-space:nowrap;
                    color:red; font-size: 100%; " /&gt;
                &lt;h:outputLabel value="#{msgs.interest}"
                    for="interestValue"/&gt;
                &lt;h:inputText value="#{money.rate}"
                 id="interestValue"
                  converterMessage="#{msgs.invalidInput}" &gt;
                     &lt;f:ajax event="blur"
                         render="interestError" /&gt;
                &lt;/h:inputText&gt;</pre>
			<p>There are two more rows on this form that I have removed in the text as they are nearly identical to the <span class="No-Break">previous one.</span></p>
			<p>At the <a id="_idIndexMarker984"/>bottom of our form are two <a id="_idIndexMarker985"/>buttons. One invokes the <strong class="source-inline">Calculations</strong> class <a id="_idIndexMarker986"/>to generate the answer, while the second resets all the fields and makes <strong class="source-inline">Load</strong> the choice in the <span class="No-Break">radio button:</span></p>
			<pre class="source-code">
              &lt;h:commandButton type="submit"
                action="#{calculate.performCalculation()}"
                value="#{msgs.submit}"  styleClass="btn" /&gt;
               &lt;h:commandButton type="reset"
                 value="#{msgs.clear}" styleClass="btn2" &gt;
                    &lt;f:ajax event="click" execute="@this"
                    render="@form" /&gt;
                &lt;/h:commandButton&gt;
            &lt;/h:panelGrid&gt;
        &lt;/h:form&gt;</pre>
			<p>This is a basic application, but it should give you a sense of how Faces <span class="No-Break">applications work.</span></p>
			<h2 id="_idParaDest-280"><a id="_idTextAnchor310"/>Deploying a Faces web application</h2>
			<p>Like every <a id="_idIndexMarker987"/>sample program in this book that is built with Maven, all you need to do is open a terminal/console window in the <strong class="source-inline">project</strong> folder. At the prompt, you just need to enter <strong class="source-inline">mvn</strong>. Assuming that there are no errors, you should find your project in the <span class="No-Break">target folder.</span></p>
			<p>You can copy this file and paste it into the <strong class="source-inline">autodeploy</strong> folder discussed in the previous chapter. The other option is to deploy the application from the <span class="No-Break">GlassFish console:</span></p>
			<div>
				<div id="_idContainer085" class="IMG---Figure">
					<img src="image/B19088_15_03.jpg" alt="Figure 15.3 – Deploying from the server"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 15.3 – Deploying from the server</p>
			<p>Selecting <strong class="bold">Deploy an Application</strong> will bring you to a form where you can upload your application <a id="_idIndexMarker988"/>to the server. With our application up and running, let us take a deeper look into what happens when we interact with a <span class="No-Break">Faces page.</span></p>
			<h1 id="_idParaDest-281"><a id="_idTextAnchor311"/>Understanding the life cycle of a Faces page</h1>
			<p>In <a href="B19088_14.xhtml#_idTextAnchor281"><span class="No-Break"><em class="italic">Chapter 14</em></span></a>, <em class="italic">Server-Side Coding with Jakarta</em>, we saw the basic life cycle of web apps that employ servlets. Simply put, a submit request is made to a servlet, the servlet receives data <a id="_idIndexMarker989"/>from the page in the form of a request object, and you code whatever tasks are necessary, and then a response is returned either from the servlet or as an HTML or JSP page. Faces works differently <span class="No-Break">from this.</span></p>
			<p>There are six parts to the life cycle of a Faces page that begins with a request for a <strong class="source-inline">.jsf</strong> page. Here is a diagram that shows the steps in the Faces <span class="No-Break">life cycle:</span></p>
			<div>
				<div id="_idContainer086" class="IMG---Figure">
					<img src="image/B19088_15_04.jpg" alt="Figure 15.4 – The Faces life cycle"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 15.4 – The Faces life cycle</p>
			<p>Let’s review <span class="No-Break">each part:</span></p>
			<ul>
				<li><strong class="bold">Restore View</strong>: When a <a id="_idIndexMarker990"/>request arrives, it is checked for a query string. If it is not present, then this is likely the first time this page is requested. This means that the page can be rendered without the need to go through any of the <span class="No-Break">other phases.</span></li>
				<li><strong class="bold">Apply Request Values</strong>: In this phase, the contents of the query string are assigned <strong class="source-inline">String</strong> variables. This allows for validating and converting the data before it <a id="_idIndexMarker991"/>is assigned to the bean associated with this request. Beans that are associated with a page are called <span class="No-Break">backing beans.</span></li>
				<li><strong class="bold">Process Validations</strong>: In this phase, the data in each field in the query string is first converted <a id="_idIndexMarker992"/>to the matching type in the backing bean. As all input is in string form, it must be converted to the type found in the backing bean. There are standard converters, such as turning <strong class="source-inline">String</strong> to <strong class="source-inline">BigDecimal</strong> or <strong class="source-inline">double</strong>. You can also write your own custom converters. If anything goes wrong in the conversion, the remaining phases are ignored, and <a id="_idIndexMarker993"/>the <strong class="bold">Render Response</strong> phase is invoked. This is where <strong class="source-inline">h:message</strong> is invoked to present an <span class="No-Break">error message.</span></li>
			</ul>
			<p>After the conversion comes validation. There are standard validator facelets as well as letting you write a custom validator. BV, if used, is also invoked here. If the validation fails, then, like a failed conversion, the life cycle jumps to <span class="No-Break">Render Response.</span></p>
			<ul>
				<li><strong class="bold">Update Model Values</strong>: In <a id="_idIndexMarker994"/>this phase, after a successful conversion and validation, the values are assigned to the <span class="No-Break">backing bean.</span></li>
				<li><strong class="bold">Invoke Application</strong>: Many <a id="_idIndexMarker995"/>tags have an action attribute that allows you to call upon methods in a backing bean. With the data now in the backing bean, these methods can <span class="No-Break">be called.</span></li>
				<li><strong class="bold">Render Response</strong>: Here, the <a id="_idIndexMarker996"/>Faces page is rendered as HTML <span class="No-Break">and JavaScript.</span></li>
			</ul>
			<p>It is possible to write a phase listener class that you can use to add additional tasks in most phases. Understanding the life cycle is critical to developing <span class="No-Break">Faces pages.</span></p>
			<h1 id="_idParaDest-282"><a id="_idTextAnchor312"/>Summary</h1>
			<p>This chapter was a brief introduction to Jakarta Faces, the supporting frameworks such as CDI and BV, and how to deploy an application. Looking at the life cycle should give you an understanding of what the Faces servlet is doing. While web page rendering is most commonly the domain of JavaScript frameworks, Faces should be considered as an alternative to the JavaScript approach. Its integration with CDI and BV makes it a solid foundation for web apps. BV can ensure that all validation is done on the server. This does not preclude using validation in JS. However, with a simple tool such as <strong class="source-inline">curl</strong>, you could easily submit invalid data if validation only occurred on the client side <span class="No-Break">in JS.</span></p>
			<p>In our next and final chapter, we will look at how Java applications can be packaged for easy deployment to a server or distributed for easy use as a <span class="No-Break">desktop application.</span></p>
			<h1 id="_idParaDest-283"><a id="_idTextAnchor313"/>Further reading</h1>
			<ul>
				<li>PrimeFaces – Facelet <span class="No-Break">library: </span><a href="https://www.primefaces.org/"><span class="No-Break">https://www.primefaces.org/</span></a></li>
				<li>OmniFaces – Faces utility <span class="No-Break">methods: </span><a href="https://omnifaces.org/"><span class="No-Break">https://omnifaces.org/</span></a></li>
				<li><span class="No-Break">Spring: </span><a href="https://spring.io/"><span class="No-Break">https://spring.io/</span></a></li>
				<li><span class="No-Break">Vaadin: </span><a href="https://vaadin.com/"><span class="No-Break">https://vaadin.com/</span></a></li>
				<li>Jakarta <span class="No-Break">Tutorial: </span><a href="https://eclipse-ee4j.github.io/jakartaee-tutorial/"><span class="No-Break">https://eclipse-ee4j.github.io/jakartaee-tutorial/</span></a></li>
			</ul>
		</div>
	

		<div id="_idContainer088" class="Content">
			<h1 id="_idParaDest-284"><a id="_idTextAnchor314"/>Part 4:Packaging Java Code</h1>
			<p>This part is about how you distribute your code. You will learn how to create a custom Java runtime and package it with an application in a single file installer. The distribution of an entire environment, including Java, an application server, and your app using Docker, the first step to cloud deployment, is the <span class="No-Break">final topic.</span></p>
			<p>This part contains the <span class="No-Break">following chapter:</span></p>
			<ul>
				<li><a href="B19088_16.xhtml#_idTextAnchor315"><em class="italic">Chapter 16</em></a>, <em class="italic">Deploying Java in Standalone Packages and Containers</em></li>
			</ul>
		</div>
		<div>
			<div id="_idContainer089">
			</div>
		</div>
		<div>
			<div id="_idContainer090">
			</div>
		</div>
	</body></html>