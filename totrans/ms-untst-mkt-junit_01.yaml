- en: Chapter 1. JUnit 4 – a Total Recall
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter covers the unit testing concept, the JUnit 4 framework, the Eclipse
    setup, and the advanced features of JUnit 4\. In JUnit 4, you will be introduced
    to the JUnit framework briefly to get you up and running. We will discuss the
    concept surrounding JUnit essentials, annotations, assertion, the `@RunWith` annotation,
    and exception handling so that you have an adequate background on how JUnit 4
    works. Advanced readers can skip to the next section.
  prefs: []
  type: TYPE_NORMAL
- en: In JUnit 4++, we will explore the advanced topics of JUnit 4 and deep dive into
    parameterized tests, Hamcrest matchers and `assertThat`, the assumption, theory,
    timeout, categories, rules, test suites, and tests order.
  prefs: []
  type: TYPE_NORMAL
- en: Defining unit testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A test is an assessment of our knowledge, a proof of concept, or an examination
    of data. A class test is an examination of our knowledge to ascertain whether
    we can go to the next level. For software, it is the validation of functional
    and nonfunctional requirements before it is shipped to a customer.
  prefs: []
  type: TYPE_NORMAL
- en: Unit testing code means validation or performing the sanity check of code. Sanity
    check is a basic test to quickly evaluate whether the result of a calculation
    can possibly be true. It is a simple check to see whether the produced material
    is coherent.
  prefs: []
  type: TYPE_NORMAL
- en: It's a common practice to unit test the code using print statements in the main
    method or by executing the application. Neither of them is the correct approach.
    Mixing up production code with tests is not a good practice. Testing logic in
    the production code is a code smell, though it doesn't break the code under the
    test. However, this increases the complexity of the code and can create severe
    maintenance problem or cause system failure if anything gets misconfigured. Print
    statements or logging statements are executed in the production system and print
    unnecessary information. They increase execution time and reduce code readability.
    Also, junk logging information can hide a real problem, for instance, you may
    overlook a critical deadlock or a hung thread warning because of excessive logging
    of junk.
  prefs: []
  type: TYPE_NORMAL
- en: Unit testing is a common practice in **test-driven development** (**TDD**).
    TDD is an evolutionary development approach. It offers test-first development
    where the production code is written only to satisfy a test, and the code is refactored
    to improve its quality. In TDD, unit tests drive the design. You write code to
    satisfy a failing test, so it limits the code you write to only what is needed.
    The tests provide a fast, automated regression for refactoring and new enhancements.
  prefs: []
  type: TYPE_NORMAL
- en: Kent Beck is the originator of Extreme Programming and TDD. He has authored
    many books and papers.
  prefs: []
  type: TYPE_NORMAL
- en: 'Generally, all tests are included in the same project but under a different
    directory/folder. Thus, a `org.packt.Bar.java` class will have a `org.packt.BarTest.java`
    test. These will be in the same package (`org.packt`) but will be organized in
    the: `src/org/foo/Bar.java` and `test/org/foo/BarTest.java` directories, respectively.'
  prefs: []
  type: TYPE_NORMAL
- en: Our customers do not execute the unit tests, so we don't deliver the test source
    folder to them. Having the code and test in the same package allows the test to
    access protected and default methods/properties. This is particularly useful while
    working with the legacy code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Java code can be unit tested using a code-driven unit testing framework. The
    following are a few of the available code-driven unit testing frameworks for Java:'
  prefs: []
  type: TYPE_NORMAL
- en: SpryTest
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Jtest
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: JUnit
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: TestNG
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: JUnit is the most popular and widely used unit testing framework for Java. We
    will explore JUnit 4 in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Working with JUnit 4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**JUnit** is a unit testing framework for Java. It allows developers to unit
    test the code elegantly. Apparently, TestNG is cleaner than JUnit, but JUnit is
    far more popular than TestNG. JUnit has a better mocking framework support such
    as Mockito, which offers a custom JUnit 4 runner.'
  prefs: []
  type: TYPE_NORMAL
- en: The latest version of JUnit (4.11) can be downloaded from [https://github.com/junit-team/junit/wiki/Download-and-Install](https://github.com/junit-team/junit/wiki/Download-and-Install).
  prefs: []
  type: TYPE_NORMAL
- en: 'JUnit 4 is an annotation-based, flexible framework. Its predecessor has many
    downsides. The following are the advantages of JUnit 4 over its predecessor:'
  prefs: []
  type: TYPE_NORMAL
- en: Instead of inheriting from `junit.framework.Testcase`, any class can be a test
    class
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `setUp` and `tearDown` methods are replaced by the `@before` and `@after`
    annotations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Any public method annotated as `@test` can be a test method
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this chapter, we will use **Eclipse** to execute the JUnit tests; in the
    following chapters, we will be using **Ant**, **Maven**, and **Gradle** to execute
    tools. Eclipse is an integrated development environment, and can be used to develop
    applications in Java. It can be downloaded from [http://www.eclipse.org/downloads/](http://www.eclipse.org/downloads/).
    As of today, the latest IDE version is KEPLER (4.3).
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Since 2006, Eclipse releases a project annually. It started with the name **Callisto**
    (starts with a C). Lexicographically, Eclipse project names go like C, E, G, H,
    I, J, K, and L.
  prefs: []
  type: TYPE_NORMAL
- en: In 2014, they will release the **Luna** (which starts with L) version. Between
    2006 and now, they released **Europa** (E), **Ganymede** (G), **Galileo** (G),
    **Helios** (H), **Indigo** (I), **Juno** (J), and **Kepler** (K).
  prefs: []
  type: TYPE_NORMAL
- en: In the following section, we will set up Eclipse and execute our first JUnit
    test.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up Eclipse
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You can skip this section if you know how to install Eclipse and add JUnit
    JAR to the `classpath` project. The following are the steps to set up Eclipse:'
  prefs: []
  type: TYPE_NORMAL
- en: Visit [http://www.eclipse.org/downloads/](http://www.eclipse.org/downloads/).
    From the dropdown, select the operating system—**Windows**, **Mac**, or **Linux**—and
    then click on the hardware architecture hyperlink, that is, **32 Bit** or **64
    Bit**, and download the binary, as shown in the following screenshot:![Setting
    up Eclipse](img/00002.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Extract the binary and launch Eclipse, for example, click on `Eclipse.exe` in
    Windows to launch Eclipse.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new workspace (for example, in Windows, enter `C:\dev\junit` or in
    Linux or Mac enter `/user/local/junit`; Eclipse will create the directories).
    Once the workspace is open, press *Ctrl* + *N* or navigate to **File** | **New**;
    it will open a wizard. Select **Java Project** and click on **Next**. Enter `JUnitTests`
    as the project name and click on **Finish**. This will create a Java project named
    `JUnitTests`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Download the `junit.jar` and `hamcrest-core.jar` packages from [https://github.com/junit-team/junit/wiki/Download-and-Install](https://github.com/junit-team/junit/wiki/Download-and-Install)
    and copy the jars to the `JUnitTests` project folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You can add the JAR to the `classpath` project in two ways; either right-click
    on both JAR, select **Build Path**, and then click on **Add to build path**. Or,
    right-click on the project and select the **Properties** menu item. Click on **Java
    build path** on the left-hand side and open the **Libraries** tab. Then, click
    on the **Add JARs...** button, and it will open a pop-up window. Expand the **JUnitTests**
    project from the pop up, select the two JAR (`junit.jar` and `hamcrest-core.jar`),
    and add them to **Libraries**. We are now ready with the Eclipse setup.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Running the first unit test
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: JUnit 4 is an annotation-based framework. It doesn't force you to extend the
    `TestCase` class. Any Java class can act as a test. In this section, we will uncover
    the JUnit 4 annotations, assertions, and exceptions.
  prefs: []
  type: TYPE_NORMAL
- en: We will examine the annotations before writing our first test.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring annotations
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `@Test` annotation represents a test. Any `public` method can be annotated
    with the`@Test` annotation with `@Test` to make it a test method. There's no need
    to start the method name with test.
  prefs: []
  type: TYPE_NORMAL
- en: 'We need data to verify a piece of code. For example, if a method takes a list
    of students and sorts them based on the marks obtained, then we have to build
    a list of students to test the method. This is called data setup. To perform the
    data setup, JUnit 3 defines a `setUp()`method in the `TestCase` class. A test
    class can override the `setUp()` method. The method signature is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: JUnit 4 provides a `@Before` annotation. If we annotate any `public void` method
    of any name with `@Before`, then that method gets executed before every test execution.
  prefs: []
  type: TYPE_NORMAL
- en: Similarly, any method annotated with `@After` gets executed after each test
    method execution. JUnit 3 has a `tearDown()` method for this purpose.
  prefs: []
  type: TYPE_NORMAL
- en: 'JUnit 4 provides two more annotations: `@BeforeClass` and `@AfterClass`. They
    are executed only once per test class. The `@BeforeClass` and `@AfterClass` annotations
    can be used with any public static void methods. The `@BeforeClass` annotation
    is executed before the first test and the `@AfterClass` annotation is executed
    after the last test. The following example explains the annotation usage and the
    execution sequence of the annotated methods.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s write our first test by performing the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: We will create a test class under a test source package. Create a **Source folder**
    named `test` and create a `SanityTest.java` Java class under package `com.packtpub.junit.recap`.![Exploring
    annotations](img/00003.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It is a good practice to create test classes with a `Test` suffix. So, a `MyClass`
    class will have a `MyClassTest` test class. Some code coverage tools ignore tests
    if they don't end with a `Test` suffix.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Add the following code to the `SanityTest` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Downloading the example code**'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: You can download the example code files for all Packt books you have purchased
    from your account at [http://www.packtpub.com](http://www.packtpub.com). If you
    purchased this book elsewhere, you can visit [http://www.packtpub.com/support](http://www.packtpub.com/support)
    and register to have the files e-mailed directly to you.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: In the preceding class, we created six methods. Two test methods are annotated
    with `@Test`. Note that two methods (`beforeClass` and `afterClass`) are `static`
    and the other four are nonstatic. A static method annotated with `@BeforeClass`
    is invoked only once, that is, before the test class is instantiated, and `@AfterClass`
    is invoked after the class is done with all the execution.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Run the test. Press *Alt* + *Shift* + *X* and *T* or navigate to **Run** | **Run
    As** | **JUnit Test**. You will see the following console (`System.out.println`)
    output:![Exploring annotations](img/00004.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Check whether the `before` and `after` methods are executed before and after
    every test run. However, the order of the test method execution may vary. In some
    runs, `someTest` may be executed before `someTest2` or vice versa. The `afterClass`
    and `beforeClass` methods are executed only once.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Congratulations! We successfully ran our first JUnit 4 test.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`@Before` and `@After` can be applied to any `public void` methods. `@AfterClass`
    and `@BeforeClass` can be applied to only `public static void` methods.'
  prefs: []
  type: TYPE_NORMAL
- en: Verifying test conditions with Assertion
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Assertion is a tool (a predicate) used to verify a programming assumption (expectation)
    with an actual outcome of a program implementation; for example, a programmer
    can expect that the addition of two positive numbers will result in a positive
    number. So, he or she can write a program to add two numbers and assert the expected
    result with the actual result.
  prefs: []
  type: TYPE_NORMAL
- en: The `org.junit.Assert` package provides static overloaded methods to assert
    expected and actual values for all primitive types, objects, and arrays.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are the useful assert methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '`assertTrue(condition)` or `assertTrue(failure message, condition)`: If the
    condition becomes false, the assertion fails and `AssertionError` is thrown. When
    a failure message is passed, the failure message is thrown.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`assertFalse(condition)` or `assertFalse(failure message, condition)`: If the
    condition becomes true, the assertion fails and `AssertionError` is thrown.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`assertNull`: This checks whether the object is null, otherwise throws `AssertionError`
    if the argument is not null.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`assertNotNull`: This checks whether the argument is not null; otherwise, it
    throws `AssertionError`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`assertEquals(string message, object expected, object actual)`, or `assertEquals(object
    expected, object actual)`, or `assertEquals(primitive expected, primitive actual)`:
    This method exhibits an interesting behavior if primitive values are passed and
    then the values are compared. If objects are passed, then the `equals()` method
    is invoked. Moreover, if the actual value doesn''t match the expected value, `AssertionError`
    is thrown.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`assertSame(object expected, object actual)`: This supports only objects and
    checks the object reference using the == operator. If two different objects are
    passed, then `AssertionError` is thrown.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`assertNotSame`: This is just the opposite of `assertSame`. It fails when the
    two argument references are the same.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: Sometimes `double` can lead to surprising results due to the representation
    that Java uses to store doubles. Any operation on a double value can lead to an
    unexpected result. Assert doesn't rely on double comparison; so, `assertEquals(double
    expected, double actual)` is deprecated.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Declare a `double` variable `sum = .999+ .98`. The `sum` variable should add
    the values and store 1.98, but when you print the value in your machine, you will
    get `1.9889999999999999` as the output. So, if you assert `sum` with a `double`
    value 1.98, the test will fail.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The `assert` method provides an overloaded method for the `double` value assertion,
    that is, `assertEquals(double expected, double actual, double delta)`. During
    comparison, if the difference between the expected and the actual value is less
    than the delta value, the result is considered passed.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: For monetary calculations, it is recommended to use `BigDecimal` instead of
    doubles.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'We will use the `assert` methods in the test as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a `AssertTest` test class under `com.packtpub.junit.recap`. Add the
    following lines to the class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the preceding code, `assertTrueAndFalseTest` sends `true` to `assertTrue`
    and `false` to `assertFalse`. So, the test should not fail.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: In `assertNullAndNotNullTest`, we are passing `null` to `assertNull` and a non-null
    `String` to `assertNotNull`; so, this test should not fail.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Run the tests. They should be green.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'We will examine `assertEquals` and add the following test and static import
    the `assertEquals` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the preceding code, we defined two `Integer` objects, `i` and `j`, and they
    are initialized with 5\. Now, when we pass them to `assertEquals`, the test passes,
    as the `assertEquals` method calls `i.equals(j)` and not `i == j`. Hence, only
    the values are compared, not the references.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The `assertEquals` method works on all primitive types and objects. To verify
    a double value, either use the overloaded `assertEquals(actual, expected, delta)`
    method or just use `BigDecimal` instead of using `Double`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Add a test to verify the `assertNotSame` behavior and static import the `assertNotSame`
    method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `assertNotSame` method fails only when the expected object and the actual
    object refers to the same memory location. Here, `i` and `j` hold the same value
    but the memory references are different.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Add a test to verify the `assertSame` behavior and static import the `assertSame`
    method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `assertSame` method passes only when the expected object and the actual
    object refer to the same memory location. Here, `i` and `j` hold the same value
    and refer to the same location.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Working with exception handling
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To test an error condition, exception handling feature is important. For example,
    an API needs three objects; if any argument is null, then the API should throw
    an exception. This can be easily tested. If the API doesn't throw an exception,
    the test will fail.
  prefs: []
  type: TYPE_NORMAL
- en: The `@Test` annotation takes the `expected=<<Exception class name>>.class` argument.
  prefs: []
  type: TYPE_NORMAL
- en: 'If the expected exception class doesn''t match the exception thrown from the
    code, the test fails. Consider the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: This is only one solution. There are several other methods that are generally
    considered to be better solutions. Utilizing `@Rule` in JUnit 4.8+ and assigning
    `ExpectedException` is a stronger solution because you can inspect the message
    as well as the type. We have covered `@Rule` in the *Working with JUnit 4++ section*
    of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring the @RunWith annotation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Test runners execute the JUnit tests. Eclipse has a built-in native graphical
    runner. JUnit 4 provides tools to define the suite to be run and to display its
    results.
  prefs: []
  type: TYPE_NORMAL
- en: When a class is annotated with `@RunWith` or the class extends a class annotated
    with `@RunWith`, JUnit will invoke the class that it references to run the tests
    on that class, instead of using the built-in runner. The `@RunWith` annotation
    is used to change the nature of the test class. It can be used to run a test as
    a parameterized test or even a Spring test, or it can be a Mockito runner to initialize
    the mock objects annotated with a `@Mock` annotation.
  prefs: []
  type: TYPE_NORMAL
- en: The `@RunWith` annotation takes an argument. The argument must be a class extended
    from `org.junit.runner.Runner`.
  prefs: []
  type: TYPE_NORMAL
- en: '`JUnit4.class` is an example of a runner. This class aliases the current default
    JUnit 4 class runner.'
  prefs: []
  type: TYPE_NORMAL
- en: '`Suite` is a standard runner that allows us to build a suite that contains
    tests from many packages. The following is an example of `@RunWith`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Working with JUnit 4++
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This section explores the advanced features of the JUnit 4 framework and includes
    the following topics: parameterized test, Hamcrest matchers and assertThat, assumption,
    theory, timeout, categories, rules, test suites, and tests order.'
  prefs: []
  type: TYPE_NORMAL
- en: Ignoring a test
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Suppose a failing test blocks you to check-in a mission critical code, and you
    come to know that the owner of the code is on a vacation. What do you do? You
    try to fix the test or just comment out or delete the test to proceed with your
    check-in (committing files to a source control such as SVN), or you wait until
    the test is fixed.
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes we comment out tests because the feature is not developed. JUnit came
    up with a solution for this. Instead of commenting a test, we can just ignore
    it by annotating the test method with `@Ignore`. Commenting out a test or code
    is bad as it does nothing but increases the code size and reduces its readability.
    Also, when you comment out a test, then the test report doesn't tell you anything
    about the commented-out test; however, if you ignore a test, then the test report
    will tell you that something needs to be fixed as some tests are ignored. So,
    you can keep track of the ignored test.
  prefs: []
  type: TYPE_NORMAL
- en: 'Use `@Ignore("Reason: why do you want to ignore?")`. Giving a proper description
    explains the intention behind ignoring the test. The following is an example of,
    where a test method is ignored because the holiday calculation is not working:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is a screenshot from Eclipse:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Ignoring a test](img/00005.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: You can place the `@Ignore` annotation on a test class, effectively ignoring
    all the contained tests.
  prefs: []
  type: TYPE_NORMAL
- en: Executing tests in order
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: JUnit was designed to allow execution in a random order, but typically they
    are executed in a linear fashion and the order is not guaranteed. The JUnit runner
    depends on reflection to execute the tests. Usually, the test execution order
    doesn't vary from run to run; actually, the randomness is environment-specific
    and varies from JVM to JVM. So, it's better that you never assume they'll be executed
    in the same order and depend on other tests, but sometimes we need to depend on
    the order.
  prefs: []
  type: TYPE_NORMAL
- en: For example, when you want to write slow tests to insert a row into a database,
    then first update the row and finally delete the row. Here, unless the insert
    function is executed, delete or update functions cannot run.
  prefs: []
  type: TYPE_NORMAL
- en: JUnit 4.11 provides us with an `@FixMethodOrder` annotation to specify the execution
    order. It takes `enum MethodSorters`.
  prefs: []
  type: TYPE_NORMAL
- en: 'To change the execution order, annotate your test class using `@FixMethodOrder`
    and specify one of the following available `enum MethodSorters` constant:'
  prefs: []
  type: TYPE_NORMAL
- en: '`MethodSorters.JVM`: This leaves the test methods in the order returned by
    the JVM. This order may vary from run to run.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`MethodSorters.NAME_ASCENDING`: This sorts the test methods by the method name
    in the lexicographic order.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`MethodSorters.DEFAULT`: This is the default value that doesn''t guarantee
    the execution order.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will write a few tests to verify this behavior.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add a `TestExecutionOrder` test and create tests, as shown in the following
    code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the tests. The execution order may vary, but if we annotate the class with
    `@FixMethodOrder(MethodSorters.NAME_ASCENDING)`, the tests will be executed in
    the ascending order as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The following Eclipse screenshot displays the test execution in the ascending
    order:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Executing tests in order](img/00006.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Learning assumptions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In multisite projects, sporadically, a date or time zone tests fail in a local
    CI server but run fine in other servers in a different time zone. We can choose
    to not run those automatic tests in our local server.
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes our tests fail due to a bug in a third-party code or external software,
    but we know that after some specific build or version, the bug will be fixed.
    Should we comment out the code and wait until the build is available?
  prefs: []
  type: TYPE_NORMAL
- en: In many projects, **Jenkins** (for test automation) and **SONAR** (for code-quality
    metrics) run in a server. It has been observed that due to low resources, the
    automatic tests run forever when SONAR is processing and the tests run simultaneously.
  prefs: []
  type: TYPE_NORMAL
- en: JUnit has the answer to all these issues. It recommends using an `org.junit.Assume`
    class.
  prefs: []
  type: TYPE_NORMAL
- en: Like `Assert`, `Assume` offers many static methods, such as `assumeTrue(condition)`,
    `assumeFalse(condition)`, `assumeNotNull(condition)`, and `assumeThat(condition)`.
    Before executing a test, we can check our assumption using the `assumeXXX` methods.
    If our assumption fails, then the `assumeXXX` methods throw `AssumptionViolatedException`,
    and the JUnit runner ignores the tests with failing assumptions.
  prefs: []
  type: TYPE_NORMAL
- en: So, basically, if our assumption is not true, the tests are just ignored. We
    can assume that the tests are run in the EST time zone; if the tests are run somewhere
    else, they will be ignored automatically. Similarly, we can assume that the third-party
    code version is higher than the build/version 123; if the build version is lower,
    the tests will be ignored.
  prefs: []
  type: TYPE_NORMAL
- en: Let's write the code to validate our assumption about `Assume`.
  prefs: []
  type: TYPE_NORMAL
- en: Here, we will try to solve the SONAR server issue. We will assume that SONAR
    is not running. If SONAR runs during the test execution, the assumption will fail
    and the tests will be ignored.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create an `Assumption` test class. The following is the body of the class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Here, for simplicity, we added a `isSonarRunning` variable to replicate a SONAR
    server facade. In the actual code, we can call an API to get the value. We will
    set the variable to `false`. Then, in the test, we will reset the value to `true`.
    This means SONAR is running. So, our assumption that SONAR is not running is false;
    hence, the test will be ignored.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shows that the test is ignored. We didn''t annotate
    the test using `@Ignore`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Learning assumptions](img/00007.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'When we change the value of the `isSonarRunning` variable to `false,` as given
    in the following code snippet, the test will be executed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Continuous integration tools such as Jenkins can run multiple tools such as
    Sonar to acquire code-quality metrics. It's always a good practice to have a build
    pipeline where the code quality is only checked after the tests pass. This prevents
    the CPU-intensive tasks from occurring at the same time.
  prefs: []
  type: TYPE_NORMAL
- en: Assumption is also used in the `@Before` methods, but be careful not to overuse
    it. Assumption is good for use with TDD where one writes pretests ahead of time.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring the test suite
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To run multiple test cases, JUnit 4 provides `Suite.class` and the `@Suite.SuiteClasses`
    annotation. This annotation takes an array (comma separated) of test classes.
  prefs: []
  type: TYPE_NORMAL
- en: Create a `TestSuite` class and annotate the class with `@RunWith(Suite.class)`.
    This annotation will force Eclipse to use the suite runner.
  prefs: []
  type: TYPE_NORMAL
- en: Next, annotate the class with `@Suite.SuiteClasses({ AssertTest.class, TestExecutionOrder.class,
    Assumption.class })` and pass comma-separated test class names.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is the code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'During execution, the suite will execute all the tests. The following is a
    screenshot of the suite run. Check whether it runs seven tests out of the three
    test fixtures: `AssertTest`, `TestExecutionOrder`, and `Assumption`.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Exploring the test suite](img/00008.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: A test suite is created for group-related tests such as a group of data access,
    API usage tests, or a group of input validation logic tests.
  prefs: []
  type: TYPE_NORMAL
- en: Asserting with assertThat
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Joe Walnes created the `assertThat(Object actual, Matcher matcher)` method.
    General consensus is that `assertThat` is readable and more useful than `assertEquals`.
    The syntax of the `assertThat` method is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Here, `Object` is the actual value received and `Matcher` is an implementation
    of the `org.hamcrest.Matcher` interface. This interface comes from a separate
    library called `hamcrest.jar`.
  prefs: []
  type: TYPE_NORMAL
- en: A matcher enables a partial or an exact match for an expectation, whereas `assertEquals`
    uses an exact match. `Matcher` provides utility methods such as `is`, `either`,
    `or`, `not` , and `hasItem`. The `Matcher` methods use the **builder pattern**
    so that we can combine one or more matchers to build a composite matcher chain.
    Just like `StringBuilder`, it builds a string in multiple steps.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are a few examples of matchers and `assertThat`:'
  prefs: []
  type: TYPE_NORMAL
- en: '`assertThat(calculatedTax, is(not(thirtyPercent)) );`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`assertThat(phdStudentList, hasItem(DrJohn) );`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`assertThat(manchesterUnitedClub, both( is(EPL_Champion)).and(is(UEFA_Champions_League_Champion))
    );`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The preceding examples are more English than a JUnit test code. So, anyone can
    understand the intent of the code and test, and a matcher improves readability.
  prefs: []
  type: TYPE_NORMAL
- en: Hamcrest provides a utility matcher class called `org.hamcrest.CoreMatchers`.
  prefs: []
  type: TYPE_NORMAL
- en: A few utility methods of `CoreMatchers` are `allOf`, `anyOf`, `both`, `either`,
    `describedAs`, `everyItem`, `is`, `isA`, `anything`, `hasItem`, `hasItems`, `equalTo`,
    `any`, `instanceOf`, `not`, `nullValue`, `notNullValue`, `sameInstance`, `theInstance`
    ,`startsWith`, `endsWith`, and `containsString`. All these methods return a matcher.
  prefs: []
  type: TYPE_NORMAL
- en: We worked with `assertEquals`; so, let's start with `equalTo`. The `equalTo`
    method is equivalent to `assertEquals`.
  prefs: []
  type: TYPE_NORMAL
- en: Comparing matchers – equalTo, is, and not
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Create a `AssertThatTest.java` JUnit test and static import `org.hamcrest.CoreMatchers.*;`
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Set the `age` variable to `30` and then likewise for `assertEquals` and call
    `equalTo`, which here is `Matcher`. The `equalTo` method takes a value. If the
    `Matcher` value doesn't match the actual value, then `assertThat` throws an `AssertionError`
    exception.
  prefs: []
  type: TYPE_NORMAL
- en: 'Set the `age` variable value to `29` and rerun the test. The following error
    will occur:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Comparing matchers – equalTo, is, and not](img/00009.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The `is(a)` attribute takes a value and returns a Boolean and behaves similar
    to `equalTo(a)`. The `is(a)` attribute is the same as `is(equalTo(a))`.
  prefs: []
  type: TYPE_NORMAL
- en: The `not` attribute takes a value or a matcher. In the preceding code, we used
    `assertThat(age, is(not(33)));`. This expression is nothing but `age is not 33`
    and is more readable than the `assert` methods.
  prefs: []
  type: TYPE_NORMAL
- en: Working with compound value matchers – either, both, anyOf, allOf, and not
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In this section, we will use `either`, `both`, `anyOf`, `allOf`, and `not`.
    Add the following test to the `AssertThatTest.java` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, a `marks` double variable is initialized with a value
    of `100.00`. This variable value is asserted with an `either` matcher.
  prefs: []
  type: TYPE_NORMAL
- en: Basically, using `either`, we can compare two values against an actual or calculated
    value. If any of them match, then the assertion is passed. If none of them match,
    then `AssertionError` is thrown.
  prefs: []
  type: TYPE_NORMAL
- en: The `either(Matcher)` method takes a matcher and returns a `CombinableEitherMatcher`
    class. The `CombinableEitherMatcher` class has a `or(Matcher other)` method so
    that `either` and `or` can be combined.
  prefs: []
  type: TYPE_NORMAL
- en: The `or(Matcher other)` method is translated to `return (new CombinableMatcher(first)).or(other);`
    and finally to `new CombinableMatcher(new AnyOf(templatedListWith(other)));`.
  prefs: []
  type: TYPE_NORMAL
- en: Using `both`, we can compare two values against an actual or calculated value.
    If any of them don't match, then the `AssertionError` exception is thrown. If
    both of them match, then the assertion is passed.
  prefs: []
  type: TYPE_NORMAL
- en: A numeric value such as a math score cannot be equal to both 60 and 80\. However,
    we can negate the expression. If the math score is 80, then using the `both` matcher
    we can write the expression as `assertThat (mathScore , both (not(60)). and(not
    (90)))`.
  prefs: []
  type: TYPE_NORMAL
- en: The `anyOf` matcher is more like `either` with multiple values. Using `anyOf`,
    we can compare multiple values against an actual or calculated value. If any of
    them match, then the assertion is passed. If none of them match, then the `AssertionError`
    exception is thrown.
  prefs: []
  type: TYPE_NORMAL
- en: The `allOf` matcher is more like `both` with multiple values. Using `allOf`,
    we can compare multiple values against an actual or calculated value. If any of
    them don't match, then the `AssertionError` exception is thrown. Similar to `both`,
    we can use `allOf` along with `not` to check whether a value does or doesn't belong
    to a set.
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding example, using `allOf` and `not`, we checked whether the `marks`
    attribute is not `1`, `100`, or `30`.
  prefs: []
  type: TYPE_NORMAL
- en: Working with collection matchers – hasItem and hasItems
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In the previous section, we asserted a value against multiple values. In this
    section, we will assert a collection of values against a value or numerous values.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following example. A salary list is populated with three values:
    `50.00`, `200.00`, and `500.00`. Use `hasItem` to check whether a value exists
    in a collection, and use `hasItems` to check whether multiple values exist in
    a collection, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The `hasItem` matcher has two versions: one takes a value and the other takes
    a matcher. So, we can check a value in a collection using `hasItem`, or check
    whether a value doesn''t exist in a collection using `not` and `hasItem`. The
    `hasItems` matcher operates on a set of values.'
  prefs: []
  type: TYPE_NORMAL
- en: Exploring string matchers – startsWith, endsWith, and containsString
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In this section, we will explore the string matchers. `CoreMatchers` has three
    built-in string matcher methods. In the following example, a `String` variable
    name is assigned a value and then we assert that the name starts with a specific
    value, contains a value, and ends with a value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The `startsWith` matcher operates on string only. It checks whether the string
    starts with the given string. The `endsWith` matcher checks whether the string
    ends with the given string. The `containsString` matcher checks whether the string
    contains another string.
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes, a method calls to return a JSON response. Using `containsString`,
    a specific value can be asserted.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that `startsWith`, `endsWith`, and `containsStrings` are not the only string
    matchers. Other built-in matchers such as `both`, `either`, `anyOf`, and so on,
    can be applied to a `String` object.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring built-in matchers
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`JUnitMatchers` has built-in matcher methods, but all of these methods are
    deprecated. Use Hamcrest matchers instead of using `JUnitMatchers`.'
  prefs: []
  type: TYPE_NORMAL
- en: Building a custom matcher
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Note that when `matcher.matches()` returns `false`, the description is built
    from the actual value and the matcher. The `appendDescriptionOf()` method calls
    the `describeTo()` method of the matcher to build the error message.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, `matcher.describeMismatch(actual, description)` appends the string
    `but: was <<actual>>`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `lessThanOrEqual` class needs to compare two objects, so the `Matcher`
    class should be operated on the `Comparable` objects. Create a generic class that
    operates with any type that implements the `Comparable` interface, as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now we need to implement the `describeTo` and `matches` methods. The `assertThat`
    method will pass the actual value to the matcher''s `matches(Object o)` method,
    and `lessThanOrEqual` will accept a value to compare with the actual. So, in the
    `matches` method, we need two comparable objects: one passed as a parameter and
    the other passed to a matcher object. The expected value is passed during the
    `matcher` object instantiation as follows:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We will store the `expectedValue` during the `Matcher` object creation and
    use it in the `matches()` method to compare the `expectedValue` with the `actual`
    as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The preceding `LessThanOrEqual` class should return `true` only if `expectedValue.compareTo(actual)
    >= 0` and then the `describeTo()` method appends the string `"less than or equals
    (<=) "+ expectedValue` text to the `description,` so that if the assertion fails,
    then the "`less than or equals (<=) "+ expectedValue` message will be shown.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The `assertThat` method takes a matcher but `new LessThanOrEqual(expectedValue)`
    doesn''t look good. We will create a `static` method in the `LessThanOrEqual`
    class to create a new object of `LessThanOrEqual`. Call this method from the `assertThat`
    method as follows:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `@Factory` annotation isn't necessary but needed for a Hamcrest tool. When
    we create many custom matchers, then it becomes annoying to import them all individually.
    Hamcrest ships with a `org.hamcrest.generator.config.XmlConfigurator` command-line
    tool that picks up predicates annotated with the `@Factory` annotation and collects
    them in a `Matcher` class for easy importing.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Static import the `LessThanOrEqual` class and add a test to `AssertThatTest.java`
    to validate the custom matcher, as shown in the following code:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This test should pass.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'How about testing the code with a greater value? In Java, `Integer.MAX_VALUE`
    holds the maximum integer value and `Integer.MIN_VALUE` holds the minimum integer
    value. If we expect that the maximum value will be greater than or equal to the
    minimum value, then the assertion should fail. Consider the following code snippet:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This will throw the following error:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Building a custom matcher](img/00010.jpeg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Creating parameterized tests
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Parameterized tests are used for multiple iterations over a single input to
    stress the object in test. The primary reason is to reduce the amount of test
    code.
  prefs: []
  type: TYPE_NORMAL
- en: In TDD, the code is written to satisfy a failing test. The production code logic
    is built from a set of test cases and different input values. For example, if
    we need to build a class that will return the factorial of a number, then we will
    pass different sets of data and verify that our implementation passes the validation.
  prefs: []
  type: TYPE_NORMAL
- en: We know that the factorial of 0 is 1, the factorial of 1 is 1, the factorial
    of 2 is 2, the factorial of 3 is 6, the factorial of 4 is 24, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: So, if we write tests such as `factorial_of_1_is_1` and `factorial_of_4_is_24`,
    then the test class will be polluted very easily. How many methods will we write?
  prefs: []
  type: TYPE_NORMAL
- en: 'We can create two arrays: one with the expected values and the other with the
    original numbers. Then, we can loop through the arrays and assert the result.
    We don''t have to do this because the JUnit 4 framework provides us with a similar
    solution. It gives us a `Parameterized` runner.'
  prefs: []
  type: TYPE_NORMAL
- en: We read about the `@RunWith` annotation in the preceding section. `Parameterized`
    is a special type of runner and can be used with the `@RunWith` annotation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameterized comes with two flavors: constructor and method.'
  prefs: []
  type: TYPE_NORMAL
- en: Working with parameterized constructors
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Perform the following steps to build a parameterized test with a constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a source folder `src` and add a `Factorial.java` class under `src/ com.packtpub.junit.recap`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Implement the factorial algorithm. Add the following code to the `Factorial.java`
    class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add a `ParameterizedFactorialTest.java` test under `test/ com.packtpub.junit.recap`
    and annotate the class with `@RunWith(Parameterized.class)` as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Add a method to create a dataset for factorial algorithm. The method should
    return `Collection` of the `Object[]` method. We need a collection of two dimensional
    arrays to hold the numbers and factorial values. To define the data parameters,
    annotate the method with `@Parameters`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Check whether the arrays hold the number and the expected factorial result (0's
    factorial is 1, 5's factorial is 120, and so on).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The `Parameterized` runner needs a constructor to pass the collection of data.
    For each row in the collection, the 0^(th) array element will be passed as the
    1^(st) constructor argument, the next index will be passed as 2^(nd) argument,
    and so on, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the test class, we added two members to hold the number and the expected
    factorial value. In the constructor, set these values. The `Parameterized` runner
    will loop through the data collection (annotated with a `@Parameters` annotation)
    and pass the values to the constructor.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: For example, it will pass 0 as input and 1 as expected, then 1 as input and
    1 as expected, and so on.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now, we need to add a test method to assert the number and the factorial as
    follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We created a `Factorial` object and passed the number to get the actual result
    and then asserted the actual value with `expectedResult`. Here, the runner will
    create seven instances of the test class and execute the test method.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The following screenshot shows the result of the test run taken from Eclipse:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Working with parameterized constructors](img/00011.jpeg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Note that the seven tests run and the tests names are [0] factorial[0], [1]
    factorial[1], and so on till [6].
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: If the dataset returns an empty collection, the test doesn't fail; actually,
    nothing happens.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'If the number of parameters in the object array and the constructor argument
    don''t match, then a `java.lang.IllegalArgumentException: wrong number of arguments`
    exception is thrown. For example, { 0, 1, 3 } will throw an exception as 3 arguments
    are passed, but constructor can accept only 2.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'If the constructor is not defined but the data set contains a value, then the
    `java.lang.IllegalArgumentException: wrong number of arguments` exception is thrown.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Working with parameterized methods
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We learned about the parameterized constructor; now we will run the parameterized
    test excluding the constructor. Follow the ensuing steps to run the test using
    the `@Parameter` annotation:'
  prefs: []
  type: TYPE_NORMAL
- en: Add a `ParameterizeParamFactorialTest.java` test class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Copy the content from the constructor test and delete the constructor. Change
    the class members to public, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If we run the test, it will fail as the reflection process won''t find the
    matching constructor. JUnit provides an annotation to loop through the dataset
    and set the values to the class members. `@Parameter(value=index)` takes a value.
    The value is the array index of the data collection object array. Make sure that
    the `number` and `expectedResult` variables are `public`; otherwise, the security
    exception will be thrown. Annotate them with the following parameters:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Eclipse has a bug that chops off the name.
  prefs: []
  type: TYPE_NORMAL
- en: Working with timeouts
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: JUnit tests are automated to get quick feedback after a change in the code.
    If a test runs for a long time, it violates the quick feedback principle. JUnit
    provides a timeout value (in milliseconds) in the `@Test` annotation to make sure
    that if a test runs longer than the specified value, the test fails.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is an example of a timeout:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, the test will fail automatically after 10 milliseconds. The following
    is an Eclipse screenshot that shows the error:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Working with timeouts](img/00012.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Exploring JUnit theories
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A theory is a kind of a JUnit test but different from the typical example-based
    JUnit tests, where we assert a specific data set and expect a specific outcome.
    JUnit theories are an alternative to JUnit's parameterized tests. A JUnit theory
    encapsulates the tester's understanding of an object's universal behavior. This
    means whatever a theory asserts is expected to be true for all data sets. Theories
    are useful for finding bugs in boundary-value cases.
  prefs: []
  type: TYPE_NORMAL
- en: Parameterized tests allow us to write flexible data-driven tests and separate
    data from the test methods. Theories are similar to parameterized tests—both allow
    us to specify the test data outside of the test case.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameterized tests are good but they have the following drawbacks:'
  prefs: []
  type: TYPE_NORMAL
- en: Parameters are declared as member variables. They pollute the test class and
    unnecessarily make the system complex.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Parameters need to be passed to the single constructor or variables need to
    be annotated, simply making the class incomprehensible.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Test data cannot be externalized.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Theory comes up with many annotations and a runner class. Let''s examine the
    important annotations and classes in theory, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`@Theory`: Like `@Test`, this annotation identifies a theory test to run. The
    `@Test` annotation doesn''t work with a theory runner.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@DataPoint`: This annotation identifies a single set of test data (similar
    to `@Parameters`), that is, either a static variable or a method.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@DataPoints`: This annotation identifies multiple sets of test data, generally
    an array.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@ParametersSuppliedBy`: This annotation provides the parameters to the test
    cases.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Theories`: This annotation is a JUnit runner for the theory-based test cases
    and extends `org.junit.runners.BlockJUnit4ClassRunner`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ParameterSupplier`: This is an abstract class that gives us the handle on
    the parameters that we can supply to the test case.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We will start with a simple theory and then explore more. Perform the following
    steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a `MyTheoryTest.java` class and annotate the class with `@RunWith(Theories.class)`.
    To run a theory, this special runner is required. Consider the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now run the test. It will fail with the `java.lang.Exception: No runnable methods`
    error because no theory is defined yet. Like the `@Test` annotation, we will define
    a method and annotate it with `@Theory` as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Run the theory, and it will be executed with no error. So, our theory setup
    is ready.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Define a `public static` `String` with a `name` variable and annotate this
    variable with `@DataPoint`. Now execute the test, nothing special happens. If
    a theory method (annotated with `@Theory`) takes an argument and a variable annotated
    with `@DataPoint` matches the type, then the variable is passed to the theory
    during execution. So, change the `sanity` method and add a `String` argument to
    pass `@DataPoint to the sanity()` method, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now run the theory. It will pass the `@DataPoint` name to the `sanity(String
    aName)` method during execution and the name will be printed to the console.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now, add another static `@DataPoint`, call it `mike`, and rename the `name`
    variable to `jack`, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'During theory execution, both the `@DataPoint` variables will be passed to
    the `sanity(String aName)` method. The output will be as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Exploring JUnit theories](img/00013.jpeg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'Now, slightly modify the `sanity()` method—rename the `aName` argument to `firstName`
    and add a second `String` argument, `lastName`. So now the `sanity` method takes
    the `String` arguments, `fistName` and `lastName`. Print these variables using
    the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'When executed, the output will be as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Exploring JUnit theories](img/00014.jpeg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: So, 2 x 2 = 4 combinations are used. When the multiple `@DataPoint` annotations
    are defined in a test, the theories apply to all possible well-typed combinations
    of data points for the test arguments.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'So far we have only examined single-dimension variables. The `@DataPoints`
    annotation is used to provide a set of data. Add a static `char` array to hold
    the character variables and add a `Theory` method to accept two characters. It
    will execute the theory with 9 (3 ^ 2) possible combinations as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The following is the output:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Exploring JUnit theories](img/00015.jpeg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Externalizing data using @ParametersSuppliedBy and ParameterSupplier
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'So far, we have covered how to set up test data using `@DataPoint` and `@DataPoints`.
    Now, we will use external classes to supply data in our tests using `@ParametersSuppliedBy`
    and `ParameterSupplier`. To do this, perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Create an `Adder.java` class. This class will have two overloaded `add()` methods
    to add numbers and strings. We will unit test the methods using theory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The following is the `Adder` class:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create an `ExternalTheoryTest.java` theory as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We will not use `@DataPoints` to create data. Instead, we will create a separate
    class to supply numbers to validate the `add` operation. JUnit provides a `ParameterSupplier`
    class for this purpose. `ParameterSupplier` is an abstract class, and it forces
    you to define a method as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`PotentialAssignment` is an abstract class that JUnit theories use to provide
    test data to test methods in a consistent manner. It has a static `forValue` method
    that you can use to get an instance of `PotentialAssignment`.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Create a `NumberSupplier` class to supply different types of numbers: `float`,
    `int`, `double`, `long`, and so on. Extend the `ParameterSupplier` class as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Check whether the overridden method creates a list of `PotentialAssignment`
    values of different numbers.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now, modify the theory to add two numbers. Add a theory method as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Check the `adds_numbers` method; two `Number` arguments `num1` and `num2` are
    annotated with `@ParametersSuppliedBy(NumberSupplier.class)`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: When this theory is executed, the `NumberSupplier` class will pass a list.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Execute the theory; it will print the following result:![Externalizing data
    using @ParametersSuppliedBy and ParameterSupplier](img/00016.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, we can check our `Adder` functionality. Modify the theory to assert the
    result.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create an instance of the `Adder` class and call the `add` method by passing
    `num1` and `num2`. Add the two numbers and `assert` the value with the results
    of `Adder`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The `assertEquals(double, double)` method is deprecated as the double value
    calculation results in an unpredictable result. So, the `assert` class adds another
    version of `assertEquals` for `doubles`; it takes three arguments: actual, expected,
    and a delta. If the difference between the `actual` and the `expected` value is
    greater than or equal to delta, then the assertion passes as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `Adder` class has an `add` method for `String`. Create a `StringSupplier`
    class to supply `String` values to our theory and modify the theory class to verify
    the `add (String, String)` method behavior. You can assert the `Strings` as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`String expected = str1+str2;`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`assertEquals(expected, actual);`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Here, `str1` and `str2` are the two method arguments of the theory.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Dealing with JUnit rules
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Rules allow very flexible addition or redefinition of the behavior of each test
    method in a test class. Rules are like **Aspect Oriented Programming** (**AOP**);
    we can do useful things before and/or after the actual test execution. You can
    find more information about AOP at [http://en.wikipedia.org/wiki/Aspect-oriented_programming](http://en.wikipedia.org/wiki/Aspect-oriented_programming).
  prefs: []
  type: TYPE_NORMAL
- en: We can use the inbuilt rules or define our custom rule.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we will look at the inbuilt rules and create our custom Verifier
    and WatchMan rule.
  prefs: []
  type: TYPE_NORMAL
- en: Playing with the timeout rule
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The timeout rule applies the same timeout to all the test methods in a class.
    Earlier, we used the timeout in the `@Test` annotation as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the syntax of the timeout rule:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: When we run this test, it times out after 20 milliseconds. Note that the timeout
    is applied globally to all methods.
  prefs: []
  type: TYPE_NORMAL
- en: Working with the ExpectedException rule
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `ExpectedException` rule is an important rule for handling exceptions. It
    allows you to assert the expected exception type and the exception message, for
    example, your code may throw a generic exception (such as `IllegalStateException`)
    for all failure conditions, but you can assert the generic exception message to
    verify the exact cause.
  prefs: []
  type: TYPE_NORMAL
- en: Earlier, we used `@Test(expected=Exception class)` to test the error conditions.
  prefs: []
  type: TYPE_NORMAL
- en: The `ExpectedException` rule allows in-test specification of expected exception
    types and messages.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code snippet explains how an exception rule can be used to verify
    the exception class and the exception message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: The `expect` object sets the expected exception class and `expectMessage` sets
    the expected message in the exception. If the message or exception class doesn't
    match the rule's expectation, the test fails. The `ExpectedException` object thrown
    is reset on each test.
  prefs: []
  type: TYPE_NORMAL
- en: Unfolding the TemporaryFolder rule
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `TemporaryFolder` rule allows the creation of files and folders that are
    guaranteed to be deleted when the test method finishes (whether it passes or fails).
    Consider the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: Exploring the ErrorCollector rule
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `ErrorCollector` rule allows the execution of a test to continue after
    the first problem is found (for example, to collect all the incorrect rows in
    a table and report them all at once) as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: In this example, none of the verification passes but the test still finishes
    its execution, and at the end, notifies all errors.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is the log—the arrows indicate the errors—and also note that
    only one test method is being executed but Eclipse indicates three failures:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Exploring the ErrorCollector rule](img/00017.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Working with the Verifier rule
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Verifier is a base class of `ErrorCollector`, which can otherwise turn passing
    tests into failing tests if a verification check fails. The following example
    demonstrates the `Verifier` rule:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: Verifier's `verify` method is executed after each test execution. If the `verify`
    method defines any assertions, and that assertion fails, then the test is marked
    as failed.
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding example, the test should not fail as the test method doesn't
    perform any comparison; however, it still fails. It fails because the Verifier
    rule checks that after every test execution, the `errorMsg` string should be set
    as null, but the test method sets the value to `Giving a value`; hence, the verification
    fails.
  prefs: []
  type: TYPE_NORMAL
- en: Learning the TestWatcher rule
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`TestWatcher` (and the deprecated `TestWatchman`) are base classes for rules
    that take note of the testing action, without modifying it. Consider the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: We created a `TestWatcher` class to listen to every test execution, collected
    the failure, and success instances, and at the end, printed the result in the
    `afterClass()` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is the error shown on the console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: Working with the TestName rule
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `TestName` rule makes the current test name available inside test methods.
    The `TestName` rule can be used in conjunction with the `TestWatcher` rule to
    make a unit testing framework compile a unit testing report.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following test snippet shows that the test name is asserted inside the
    test:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: The following section uses the `TestName` rule to get the method name before
    test execution.
  prefs: []
  type: TYPE_NORMAL
- en: Handling external resources
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Sometimes JUnit tests need to communicate with external resources such as files
    or databases or server sockets. Dealing with external resources is always messy
    because you need to set up state and tear it down later. The `ExternalResource`
    rule provides a mechanism that makes resource handling a bit more convenient.
  prefs: []
  type: TYPE_NORMAL
- en: Previously, when you had to create files in a test case or work with server
    sockets, you had to set up a temporary directory, or open a socket in a `@Before`
    method and later delete the file or close the server in an `@After` method. But
    now, JUnit provides a simple AOP-like mechanism called the `ExternalResource`
    rule that makes this setup and cleanup work the responsibility of the resource.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example demonstrates the `ExternalResource` capabilities. The
    `Resource` class represents an external resource and prints the output in the
    console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'The following test class creates `ExternalResource` and handles the resource
    lifecycle:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: The anonymous `ExternalResource` class overrides the `before` and `after` methods
    of the `ExternalResource` class. In the `before` method, it starts the resource
    and prints the test method name using the `TestName` rule. In the `after` method,
    it just closes the resource.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is the test run output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: Note that the resource is opened before test execution and closed after the
    test. The test name is printed using the `TestName` rule.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring JUnit categories
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `Categories` runner runs only the classes and methods that are annotated
    with either the category given with the `@IncludeCategory` annotation or a subtype
    of that category. Either classes or interfaces can be used as categories. Subtyping
    works, so if you use `@IncludeCategory(SuperClass.class)`, a test marked `@Category({SubClass.class})`
    will be run.
  prefs: []
  type: TYPE_NORMAL
- en: We can exclude categories by using the `@ExcludeCategory` annotation.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can define two interfaces using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This JUnit refresher chapter covers both the basic and advanced usage of JUnit.
  prefs: []
  type: TYPE_NORMAL
- en: The basic section covers the annotation based on JUnit 4 testing, assertion,
    the @RunWith annotation, exception handling, and the Eclipse setup for running
    the JUnit tests.
  prefs: []
  type: TYPE_NORMAL
- en: The advanced section covers parameterized tests, matchers and `assertThat`,
    a custom `lessThanOrEqual()` matcher, assumption, theory, a custom NumberSupplier
    class, timeout, categories, TestName, ExpectedException, TemporaryFolder, ErrorCollector,
    Verifier and TestWatcher rules, test suites, and executing tests in order.
  prefs: []
  type: TYPE_NORMAL
- en: By now, you will be able to write and execute JUnit 4 tests and be familiar
    with the advanced concepts of JUnit 4.
  prefs: []
  type: TYPE_NORMAL
- en: '[Chapter 2](part0018_split_000.html#page "Chapter 2. Automating JUnit Tests"),
    *Automating JUnit Tests*, focuses on getting you quickly started with project-building
    tools and test automation. It provides an overview of continuous integration,
    explores the incremental Gradle build and Maven build lifecycle, Ant scripting,
    and Jenkins automation using Gradle, Maven, and Ant scripts.'
  prefs: []
  type: TYPE_NORMAL
