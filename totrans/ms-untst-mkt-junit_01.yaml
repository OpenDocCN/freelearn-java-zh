- en: Chapter 1. JUnit 4 – a Total Recall
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第1章。JUnit 4 – 全部回忆
- en: This chapter covers the unit testing concept, the JUnit 4 framework, the Eclipse
    setup, and the advanced features of JUnit 4\. In JUnit 4, you will be introduced
    to the JUnit framework briefly to get you up and running. We will discuss the
    concept surrounding JUnit essentials, annotations, assertion, the `@RunWith` annotation,
    and exception handling so that you have an adequate background on how JUnit 4
    works. Advanced readers can skip to the next section.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖了单元测试的概念、JUnit 4框架、Eclipse设置以及JUnit 4的高级特性。在JUnit 4中，我们将简要介绍JUnit框架，以便您能够快速上手。我们将讨论围绕JUnit基本概念、注解、断言、`@RunWith`注解和异常处理的概念，以便您对JUnit
    4的工作原理有足够的了解。高级读者可以跳到下一节。
- en: In JUnit 4++, we will explore the advanced topics of JUnit 4 and deep dive into
    parameterized tests, Hamcrest matchers and `assertThat`, the assumption, theory,
    timeout, categories, rules, test suites, and tests order.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在JUnit 4++中，我们将探讨JUnit 4的高级主题，深入探讨参数化测试、Hamcrest匹配器和`assertThat`、假设、理论、超时、类别、规则、测试套件和测试顺序。
- en: Defining unit testing
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义单元测试
- en: A test is an assessment of our knowledge, a proof of concept, or an examination
    of data. A class test is an examination of our knowledge to ascertain whether
    we can go to the next level. For software, it is the validation of functional
    and nonfunctional requirements before it is shipped to a customer.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 测试是对我们知识的评估，是对概念验证，或是对数据的检验。类测试是对我们知识的检验，以确定我们是否可以进入下一个层次。对于软件来说，它是在将软件交付给客户之前对功能和非功能需求的验证。
- en: Unit testing code means validation or performing the sanity check of code. Sanity
    check is a basic test to quickly evaluate whether the result of a calculation
    can possibly be true. It is a simple check to see whether the produced material
    is coherent.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试代码意味着验证或执行代码的合理性检查。合理性检查是一种基本的测试，用于快速评估计算结果是否可能为真。它是一种简单的检查，用于查看产生的材料是否连贯。
- en: It's a common practice to unit test the code using print statements in the main
    method or by executing the application. Neither of them is the correct approach.
    Mixing up production code with tests is not a good practice. Testing logic in
    the production code is a code smell, though it doesn't break the code under the
    test. However, this increases the complexity of the code and can create severe
    maintenance problem or cause system failure if anything gets misconfigured. Print
    statements or logging statements are executed in the production system and print
    unnecessary information. They increase execution time and reduce code readability.
    Also, junk logging information can hide a real problem, for instance, you may
    overlook a critical deadlock or a hung thread warning because of excessive logging
    of junk.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 使用主方法中的打印语句或执行应用程序来进行单元测试是一种常见的做法。但这两种方法都不是正确的方法。将生产代码与测试代码混合不是好的做法。在生产代码中测试逻辑是一种代码恶臭，尽管它不会破坏测试中的代码。然而，这增加了代码的复杂性，并可能导致严重的维护问题或系统故障，如果配置出现错误。在生产系统中执行打印语句或日志语句会打印出不必要的信
    息。它们增加了执行时间并降低了代码的可读性。此外，垃圾日志信息可能会隐藏一个真正的问题，例如，由于过度记录垃圾信息，你可能会忽略一个关键的死锁或挂起线程警告。
- en: Unit testing is a common practice in **test-driven development** (**TDD**).
    TDD is an evolutionary development approach. It offers test-first development
    where the production code is written only to satisfy a test, and the code is refactored
    to improve its quality. In TDD, unit tests drive the design. You write code to
    satisfy a failing test, so it limits the code you write to only what is needed.
    The tests provide a fast, automated regression for refactoring and new enhancements.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试是**测试驱动开发**（**TDD**）中的常见做法。TDD是一种进化式开发方法。它提供了一种先测试后开发的模式，其中生产代码仅编写以满足测试，代码被重构以提高其质量。在TDD中，单元测试驱动设计。你编写代码以满足失败的测试，因此它限制了你需要编写的代码，只编写所需的代码。测试提供了快速、自动化的重构和新增强的回归。
- en: Kent Beck is the originator of Extreme Programming and TDD. He has authored
    many books and papers.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: Kent Beck是极限编程和TDD的创始人。他著有许多书籍和论文。
- en: 'Generally, all tests are included in the same project but under a different
    directory/folder. Thus, a `org.packt.Bar.java` class will have a `org.packt.BarTest.java`
    test. These will be in the same package (`org.packt`) but will be organized in
    the: `src/org/foo/Bar.java` and `test/org/foo/BarTest.java` directories, respectively.'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，所有测试都包含在同一个项目中，但位于不同的目录/文件夹下。因此，一个 `org.packt.Bar.java` 类将有一个 `org.packt.BarTest.java`
    测试类。这些将在同一个包 (`org.packt`) 中，但分别组织在：`src/org/foo/Bar.java` 和 `test/org/foo/BarTest.java`
    目录中。
- en: Our customers do not execute the unit tests, so we don't deliver the test source
    folder to them. Having the code and test in the same package allows the test to
    access protected and default methods/properties. This is particularly useful while
    working with the legacy code.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的客户不执行单元测试，所以我们不会向他们提供测试源文件夹。将代码和测试放在同一个包中允许测试访问受保护的和方法/属性。这在处理遗留代码时尤其有用。
- en: 'Java code can be unit tested using a code-driven unit testing framework. The
    following are a few of the available code-driven unit testing frameworks for Java:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用代码驱动的单元测试框架对 Java 代码进行单元测试。以下是 Java 可用的几个代码驱动的单元测试框架：
- en: SpryTest
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SpryTest
- en: Jtest
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Jtest
- en: JUnit
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JUnit
- en: TestNG
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: TestNG
- en: JUnit is the most popular and widely used unit testing framework for Java. We
    will explore JUnit 4 in the next section.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: JUnit 是最流行且广泛使用的 Java 单元测试框架。我们将在下一节中探讨 JUnit 4。
- en: Working with JUnit 4
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 JUnit 4
- en: '**JUnit** is a unit testing framework for Java. It allows developers to unit
    test the code elegantly. Apparently, TestNG is cleaner than JUnit, but JUnit is
    far more popular than TestNG. JUnit has a better mocking framework support such
    as Mockito, which offers a custom JUnit 4 runner.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '**JUnit** 是一个 Java 单元测试框架。它允许开发者优雅地进行单元测试。显然，TestNG 比JUnit更简洁，但JUnit比TestNG更受欢迎。JUnit
    有更好的模拟框架支持，如 Mockito，它提供了一个自定义的 JUnit 4 运行器。'
- en: The latest version of JUnit (4.11) can be downloaded from [https://github.com/junit-team/junit/wiki/Download-and-Install](https://github.com/junit-team/junit/wiki/Download-and-Install).
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: JUnit 的最新版本（4.11）可以从 [https://github.com/junit-team/junit/wiki/Download-and-Install](https://github.com/junit-team/junit/wiki/Download-and-Install)
    下载。
- en: 'JUnit 4 is an annotation-based, flexible framework. Its predecessor has many
    downsides. The following are the advantages of JUnit 4 over its predecessor:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: JUnit 4 是一个基于注解的、灵活的框架。其前身存在许多缺点。以下是 JUnit 4 相比其前身的一些优势：
- en: Instead of inheriting from `junit.framework.Testcase`, any class can be a test
    class
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不需要从 `junit.framework.Testcase` 继承，任何类都可以成为测试类
- en: The `setUp` and `tearDown` methods are replaced by the `@before` and `@after`
    annotations
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`setUp` 和 `tearDown` 方法被 `@before` 和 `@after` 注解所取代'
- en: Any public method annotated as `@test` can be a test method
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任何被标注为 `@test` 的公共方法都可以作为测试方法
- en: In this chapter, we will use **Eclipse** to execute the JUnit tests; in the
    following chapters, we will be using **Ant**, **Maven**, and **Gradle** to execute
    tools. Eclipse is an integrated development environment, and can be used to develop
    applications in Java. It can be downloaded from [http://www.eclipse.org/downloads/](http://www.eclipse.org/downloads/).
    As of today, the latest IDE version is KEPLER (4.3).
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将使用 **Eclipse** 来执行 JUnit 测试；在接下来的章节中，我们将使用 **Ant**、**Maven** 和 **Gradle**
    来执行工具。Eclipse 是一个集成开发环境，可以用来开发 Java 应用程序。可以从 [http://www.eclipse.org/downloads/](http://www.eclipse.org/downloads/)
    下载。截至今天，最新的 IDE 版本是 KEPLER（4.3）。
- en: Note
  id: totrans-25
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Since 2006, Eclipse releases a project annually. It started with the name **Callisto**
    (starts with a C). Lexicographically, Eclipse project names go like C, E, G, H,
    I, J, K, and L.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 自 2006 年以来，Eclipse 每年发布一个项目。它以 **Callisto**（以 C 开头）命名。按字典顺序，Eclipse 项目名称依次为
    C、E、G、H、I、J、K 和 L。
- en: In 2014, they will release the **Luna** (which starts with L) version. Between
    2006 and now, they released **Europa** (E), **Ganymede** (G), **Galileo** (G),
    **Helios** (H), **Indigo** (I), **Juno** (J), and **Kepler** (K).
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 2014 年，他们将发布 **Luna**（以 L 开头）版本。从 2006 年到如今，他们发布了 **Europa**（E）、**Ganymede**（G）、**Galileo**（G）、**Helios**（H）、**Indigo**（I）、**Juno**（J）和
    **Kepler**（K）。
- en: In the following section, we will set up Eclipse and execute our first JUnit
    test.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将设置 Eclipse 并执行我们的第一个 JUnit 测试。
- en: Setting up Eclipse
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置 Eclipse
- en: 'You can skip this section if you know how to install Eclipse and add JUnit
    JAR to the `classpath` project. The following are the steps to set up Eclipse:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你已经知道如何安装 Eclipse 并将 JUnit JAR 添加到 `classpath` 项目中，可以跳过这一节。以下是设置 Eclipse 的步骤：
- en: Visit [http://www.eclipse.org/downloads/](http://www.eclipse.org/downloads/).
    From the dropdown, select the operating system—**Windows**, **Mac**, or **Linux**—and
    then click on the hardware architecture hyperlink, that is, **32 Bit** or **64
    Bit**, and download the binary, as shown in the following screenshot:![Setting
    up Eclipse](img/00002.jpeg)
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 访问[http://www.eclipse.org/downloads/](http://www.eclipse.org/downloads/)。从下拉菜单中选择操作系统—**Windows**、**Mac**或**Linux**—然后点击硬件架构超链接，即**32位**或**64位**，下载二进制文件，如图所示：![设置Eclipse](img/00002.jpeg)
- en: Extract the binary and launch Eclipse, for example, click on `Eclipse.exe` in
    Windows to launch Eclipse.
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 提取二进制文件并启动Eclipse，例如，在Windows上点击`Eclipse.exe`来启动Eclipse。
- en: Create a new workspace (for example, in Windows, enter `C:\dev\junit` or in
    Linux or Mac enter `/user/local/junit`; Eclipse will create the directories).
    Once the workspace is open, press *Ctrl* + *N* or navigate to **File** | **New**;
    it will open a wizard. Select **Java Project** and click on **Next**. Enter `JUnitTests`
    as the project name and click on **Finish**. This will create a Java project named
    `JUnitTests`.
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的工作空间（例如，在Windows上，输入`C:\dev\junit`或在Linux或Mac上输入`/user/local/junit`；Eclipse将创建目录）。一旦工作空间打开，按*Ctrl*
    + *N*或导航到**文件** | **新建**；它将打开一个向导。选择**Java项目**并点击**下一步**。输入`JUnitTests`作为项目名称并点击**完成**。这将创建一个名为`JUnitTests`的Java项目。
- en: Download the `junit.jar` and `hamcrest-core.jar` packages from [https://github.com/junit-team/junit/wiki/Download-and-Install](https://github.com/junit-team/junit/wiki/Download-and-Install)
    and copy the jars to the `JUnitTests` project folder.
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从[https://github.com/junit-team/junit/wiki/Download-and-Install](https://github.com/junit-team/junit/wiki/Download-and-Install)下载`junit.jar`和`hamcrest-core.jar`包，并将jar文件复制到`JUnitTests`项目文件夹中。
- en: You can add the JAR to the `classpath` project in two ways; either right-click
    on both JAR, select **Build Path**, and then click on **Add to build path**. Or,
    right-click on the project and select the **Properties** menu item. Click on **Java
    build path** on the left-hand side and open the **Libraries** tab. Then, click
    on the **Add JARs...** button, and it will open a pop-up window. Expand the **JUnitTests**
    project from the pop up, select the two JAR (`junit.jar` and `hamcrest-core.jar`),
    and add them to **Libraries**. We are now ready with the Eclipse setup.
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您可以通过两种方式将JAR添加到`classpath`项目；要么在两个JAR上右键单击，选择**构建路径**，然后点击**添加到构建路径**。或者，在项目上右键单击并选择**属性**菜单项。在左侧点击**Java构建路径**并打开**库**标签。然后，点击**添加JARs...**按钮，它将打开一个弹出窗口。从弹出窗口中展开**JUnitTests**项目，选择两个JAR（`junit.jar`和`hamcrest-core.jar`），并将它们添加到**库**中。我们现在已经准备好了Eclipse的设置。
- en: Running the first unit test
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 运行第一个单元测试
- en: JUnit 4 is an annotation-based framework. It doesn't force you to extend the
    `TestCase` class. Any Java class can act as a test. In this section, we will uncover
    the JUnit 4 annotations, assertions, and exceptions.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: JUnit 4是一个基于注解的框架。它不会强制你扩展`TestCase`类。任何Java类都可以作为测试。在本节中，我们将揭示JUnit 4的注解、断言和异常。
- en: We will examine the annotations before writing our first test.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写第一个测试之前，我们将检查注解。
- en: Exploring annotations
  id: totrans-39
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 探索注解
- en: The `@Test` annotation represents a test. Any `public` method can be annotated
    with the`@Test` annotation with `@Test` to make it a test method. There's no need
    to start the method name with test.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '`@Test`注解表示一个测试。任何`public`方法都可以通过添加`@Test`注解来使其成为测试方法，不需要以`test`开头作为方法名。'
- en: 'We need data to verify a piece of code. For example, if a method takes a list
    of students and sorts them based on the marks obtained, then we have to build
    a list of students to test the method. This is called data setup. To perform the
    data setup, JUnit 3 defines a `setUp()`method in the `TestCase` class. A test
    class can override the `setUp()` method. The method signature is as follows:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要数据来验证一段代码。例如，如果一个方法接受一个学生列表并根据获得的分数进行排序，那么我们必须构建一个学生列表来测试该方法。这被称为数据设置。为了执行数据设置，JUnit
    3在`TestCase`类中定义了一个`setUp()`方法。测试类可以重写`setUp()`方法。方法签名如下：
- en: '[PRE0]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: JUnit 4 provides a `@Before` annotation. If we annotate any `public void` method
    of any name with `@Before`, then that method gets executed before every test execution.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: JUnit 4提供了一个`@Before`注解。如果我们用`@Before`注解任何名为`public void`的方法，那么该方法将在每个测试执行之前执行。
- en: Similarly, any method annotated with `@After` gets executed after each test
    method execution. JUnit 3 has a `tearDown()` method for this purpose.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，任何带有`@After`注解的方法都会在每个测试方法执行后执行。JUnit 3为此目的提供了一个`tearDown()`方法。
- en: 'JUnit 4 provides two more annotations: `@BeforeClass` and `@AfterClass`. They
    are executed only once per test class. The `@BeforeClass` and `@AfterClass` annotations
    can be used with any public static void methods. The `@BeforeClass` annotation
    is executed before the first test and the `@AfterClass` annotation is executed
    after the last test. The following example explains the annotation usage and the
    execution sequence of the annotated methods.'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: JUnit 4 提供了两个额外的注解：`@BeforeClass` 和 `@AfterClass`。它们在每个测试类中只执行一次。`@BeforeClass`
    和 `@AfterClass` 注解可以与任何公共静态 `void` 方法一起使用。`@BeforeClass` 注解在第一个测试之前执行，`@AfterClass`
    注解在最后一个测试之后执行。以下示例解释了注解的使用和注解方法的执行顺序。
- en: 'Let''s write our first test by performing the following steps:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们按照以下步骤编写第一个测试：
- en: We will create a test class under a test source package. Create a **Source folder**
    named `test` and create a `SanityTest.java` Java class under package `com.packtpub.junit.recap`.![Exploring
    annotations](img/00003.jpeg)
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将在测试源包下创建一个测试类。创建一个名为 `test` 的**源文件夹**，并在包 `com.packtpub.junit.recap` 下创建一个
    `SanityTest.java` Java 类。![探索注解](img/00003.jpeg)
- en: It is a good practice to create test classes with a `Test` suffix. So, a `MyClass`
    class will have a `MyClassTest` test class. Some code coverage tools ignore tests
    if they don't end with a `Test` suffix.
  id: totrans-48
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 创建以 `Test` 后缀结尾的测试类是一种良好的实践。因此，一个 `MyClass` 类将有一个 `MyClassTest` 测试类。一些代码覆盖率工具会忽略不以
    `Test` 后缀结尾的测试。
- en: 'Add the following code to the `SanityTest` class:'
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下代码添加到 `SanityTest` 类中：
- en: '[PRE1]'
  id: totrans-50
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Tip
  id: totrans-51
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**Downloading the example code**'
  id: totrans-52
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**下载示例代码**'
- en: You can download the example code files for all Packt books you have purchased
    from your account at [http://www.packtpub.com](http://www.packtpub.com). If you
    purchased this book elsewhere, you can visit [http://www.packtpub.com/support](http://www.packtpub.com/support)
    and register to have the files e-mailed directly to you.
  id: totrans-53
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 您可以从您在 [http://www.packtpub.com](http://www.packtpub.com) 的账户中下载您购买的所有 Packt
    书籍的示例代码文件。如果您在其他地方购买了这本书，您可以访问 [http://www.packtpub.com/support](http://www.packtpub.com/support)
    并注册，以便将文件直接通过电子邮件发送给您。
- en: In the preceding class, we created six methods. Two test methods are annotated
    with `@Test`. Note that two methods (`beforeClass` and `afterClass`) are `static`
    and the other four are nonstatic. A static method annotated with `@BeforeClass`
    is invoked only once, that is, before the test class is instantiated, and `@AfterClass`
    is invoked after the class is done with all the execution.
  id: totrans-54
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在前面的类中，我们创建了六个方法。两个测试方法用 `@Test` 注解。请注意，两个方法（`beforeClass` 和 `afterClass`）是静态的，其他四个是非静态的。用
    `@BeforeClass` 注解的静态方法仅在测试类实例化之前调用一次，即 `@AfterClass` 在类完成所有执行后调用。
- en: Run the test. Press *Alt* + *Shift* + *X* and *T* or navigate to **Run** | **Run
    As** | **JUnit Test**. You will see the following console (`System.out.println`)
    output:![Exploring annotations](img/00004.jpeg)
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行测试。按 *Alt* + *Shift* + *X* 和 *T* 或导航到 **运行** | **运行方式** | **JUnit 测试**。你将看到以下控制台（`System.out.println`）输出：![探索注解](img/00004.jpeg)
- en: Check whether the `before` and `after` methods are executed before and after
    every test run. However, the order of the test method execution may vary. In some
    runs, `someTest` may be executed before `someTest2` or vice versa. The `afterClass`
    and `beforeClass` methods are executed only once.
  id: totrans-56
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 检查 `before` 和 `after` 方法是否在每个测试运行前后执行。然而，测试方法执行的顺序可能会变化。在某些运行中，`someTest` 可能会在
    `someTest2` 之前执行，反之亦然。`afterClass` 和 `beforeClass` 方法只执行一次。
- en: Congratulations! We successfully ran our first JUnit 4 test.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜！我们成功运行了第一个 JUnit 4 测试。
- en: Note
  id: totrans-58
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '`@Before` and `@After` can be applied to any `public void` methods. `@AfterClass`
    and `@BeforeClass` can be applied to only `public static void` methods.'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '`@Before` 和 `@After` 可以应用于任何 `public void` 方法。`@AfterClass` 和 `@BeforeClass`
    只能应用于 `public static void` 方法。'
- en: Verifying test conditions with Assertion
  id: totrans-60
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用断言验证测试条件
- en: Assertion is a tool (a predicate) used to verify a programming assumption (expectation)
    with an actual outcome of a program implementation; for example, a programmer
    can expect that the addition of two positive numbers will result in a positive
    number. So, he or she can write a program to add two numbers and assert the expected
    result with the actual result.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 断言是一种工具（一个谓词），用于验证程序实现的实际结果与编程假设（期望）的一致性；例如，程序员可以期望两个正数的相加将得到一个正数。因此，他或她可以编写一个程序来相加两个数，并用实际结果断言期望的结果。
- en: The `org.junit.Assert` package provides static overloaded methods to assert
    expected and actual values for all primitive types, objects, and arrays.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '`org.junit.Assert` 包提供了静态重载方法，用于断言所有原始类型、对象和数组的预期和实际值。'
- en: 'The following are the useful assert methods:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是有用的断言方法：
- en: '`assertTrue(condition)` or `assertTrue(failure message, condition)`: If the
    condition becomes false, the assertion fails and `AssertionError` is thrown. When
    a failure message is passed, the failure message is thrown.'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`assertTrue(condition)` 或 `assertTrue(failure message, condition)`：如果条件变为假，断言失败并抛出
    `AssertionError`。当传递失败消息时，将抛出失败消息。'
- en: '`assertFalse(condition)` or `assertFalse(failure message, condition)`: If the
    condition becomes true, the assertion fails and `AssertionError` is thrown.'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`assertFalse(condition)` 或 `assertFalse(failure message, condition)`：如果条件变为真，断言失败并抛出
    `AssertionError`。'
- en: '`assertNull`: This checks whether the object is null, otherwise throws `AssertionError`
    if the argument is not null.'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`assertNull`：这个方法检查对象是否为空，如果参数不为空，则抛出 `AssertionError`。'
- en: '`assertNotNull`: This checks whether the argument is not null; otherwise, it
    throws `AssertionError`.'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`assertNotNull`：这个方法检查参数是否不为空；否则，如果参数不为空，则抛出 `AssertionError`。'
- en: '`assertEquals(string message, object expected, object actual)`, or `assertEquals(object
    expected, object actual)`, or `assertEquals(primitive expected, primitive actual)`:
    This method exhibits an interesting behavior if primitive values are passed and
    then the values are compared. If objects are passed, then the `equals()` method
    is invoked. Moreover, if the actual value doesn''t match the expected value, `AssertionError`
    is thrown.'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`assertEquals(string message, object expected, object actual)`，或 `assertEquals(object
    expected, object actual)`，或 `assertEquals(primitive expected, primitive actual)`：如果传递了原始值并比较这些值，则此方法表现出有趣的行为。如果传递了对象，则调用
    `equals()` 方法。此外，如果实际值与预期值不匹配，则抛出 `AssertionError`。'
- en: '`assertSame(object expected, object actual)`: This supports only objects and
    checks the object reference using the == operator. If two different objects are
    passed, then `AssertionError` is thrown.'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`assertSame(object expected, object actual)`: 这个方法只支持对象，并使用 `==` 操作符检查对象引用。如果传递了两个不同的对象，则抛出
    `AssertionError`。'
- en: '`assertNotSame`: This is just the opposite of `assertSame`. It fails when the
    two argument references are the same.'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`assertNotSame`：这是 `assertSame` 的反义词。当两个参数引用相同时，它将失败。'
- en: Note
  id: totrans-71
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Sometimes `double` can lead to surprising results due to the representation
    that Java uses to store doubles. Any operation on a double value can lead to an
    unexpected result. Assert doesn't rely on double comparison; so, `assertEquals(double
    expected, double actual)` is deprecated.
  id: totrans-72
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 有时 `double` 由于 Java 存储双精度浮点数的方式，可能会导致令人惊讶的结果。任何对双精度浮点数值的操作都可能导致意外结果。断言不依赖于双精度比较；因此，`assertEquals(double
    expected, double actual)` 已被弃用。
- en: Declare a `double` variable `sum = .999+ .98`. The `sum` variable should add
    the values and store 1.98, but when you print the value in your machine, you will
    get `1.9889999999999999` as the output. So, if you assert `sum` with a `double`
    value 1.98, the test will fail.
  id: totrans-73
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 声明一个 `double` 变量 `sum = .999 + .98`。`sum` 变量应该将值相加并存储 1.98，但当你打印机器上的值时，你会得到
    `1.9889999999999999` 作为输出。所以，如果你用 `double` 值 1.98 断言 `sum`，测试将失败。
- en: The `assert` method provides an overloaded method for the `double` value assertion,
    that is, `assertEquals(double expected, double actual, double delta)`. During
    comparison, if the difference between the expected and the actual value is less
    than the delta value, the result is considered passed.
  id: totrans-74
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`assert` 方法提供了一个重载方法用于 `double` 值断言，即 `assertEquals(double expected, double
    actual, double delta)`。在比较过程中，如果预期值和实际值之间的差异小于 delta 值，则结果被认为是通过的。'
- en: For monetary calculations, it is recommended to use `BigDecimal` instead of
    doubles.
  id: totrans-75
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 对于货币计算，建议使用 `BigDecimal` 而不是双精度浮点数。
- en: 'We will use the `assert` methods in the test as follows:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在测试中使用 `assert` 方法如下：
- en: 'Create a `AssertTest` test class under `com.packtpub.junit.recap`. Add the
    following lines to the class:'
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `com.packtpub.junit.recap` 下创建一个 `AssertTest` 测试类。将以下行添加到该类中：
- en: '[PRE2]'
  id: totrans-78
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In the preceding code, `assertTrueAndFalseTest` sends `true` to `assertTrue`
    and `false` to `assertFalse`. So, the test should not fail.
  id: totrans-79
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在前面的代码中，`assertTrueAndFalseTest` 向 `assertTrue` 发送 `true`，向 `assertFalse` 发送
    `false`。因此，测试不应该失败。
- en: In `assertNullAndNotNullTest`, we are passing `null` to `assertNull` and a non-null
    `String` to `assertNotNull`; so, this test should not fail.
  id: totrans-80
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在 `assertNullAndNotNullTest` 中，我们向 `assertNull` 传递 `null`，向 `assertNotNull`
    传递非空 `String`；因此，这个测试不应该失败。
- en: Run the tests. They should be green.
  id: totrans-81
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 运行测试。它们应该是绿色的。
- en: 'We will examine `assertEquals` and add the following test and static import
    the `assertEquals` method:'
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将检查`assertEquals`并添加以下测试和静态导入`assertEquals`方法：
- en: '[PRE3]'
  id: totrans-83
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: In the preceding code, we defined two `Integer` objects, `i` and `j`, and they
    are initialized with 5\. Now, when we pass them to `assertEquals`, the test passes,
    as the `assertEquals` method calls `i.equals(j)` and not `i == j`. Hence, only
    the values are compared, not the references.
  id: totrans-84
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们定义了两个`Integer`对象，`i`和`j`，并将它们初始化为5。现在，当我们将它们传递给`assertEquals`时，测试通过，因为`assertEquals`方法调用`i.equals(j)`而不是`i
    == j`。因此，只比较值，而不是引用。
- en: The `assertEquals` method works on all primitive types and objects. To verify
    a double value, either use the overloaded `assertEquals(actual, expected, delta)`
    method or just use `BigDecimal` instead of using `Double`.
  id: totrans-85
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`assertEquals`方法适用于所有原始类型和对象。要验证双精度值，可以使用重载的`assertEquals(actual, expected,
    delta)`方法，或者直接使用`BigDecimal`而不是使用`Double`。'
- en: 'Add a test to verify the `assertNotSame` behavior and static import the `assertNotSame`
    method:'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个测试以验证`assertNotSame`的行为并静态导入`assertNotSame`方法：
- en: '[PRE4]'
  id: totrans-87
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The `assertNotSame` method fails only when the expected object and the actual
    object refers to the same memory location. Here, `i` and `j` hold the same value
    but the memory references are different.
  id: totrans-88
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`assertNotSame`方法仅在预期对象和实际对象引用相同的内存位置时失败。在这里，`i`和`j`持有相同的值，但内存引用不同。'
- en: 'Add a test to verify the `assertSame` behavior and static import the `assertSame`
    method:'
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个测试以验证`assertSame`的行为并静态导入`assertSame`方法：
- en: '[PRE5]'
  id: totrans-90
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The `assertSame` method passes only when the expected object and the actual
    object refer to the same memory location. Here, `i` and `j` hold the same value
    and refer to the same location.
  id: totrans-91
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`assertSame`方法仅在预期对象和实际对象引用相同的内存位置时通过。在这里，`i`和`j`持有相同的值并指向相同的地址。'
- en: Working with exception handling
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 与异常处理一起工作
- en: To test an error condition, exception handling feature is important. For example,
    an API needs three objects; if any argument is null, then the API should throw
    an exception. This can be easily tested. If the API doesn't throw an exception,
    the test will fail.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 要测试错误条件，异常处理功能很重要。例如，一个API需要三个对象；如果任何参数为null，则API应该抛出异常。这可以很容易地测试。如果API没有抛出异常，测试将失败。
- en: The `@Test` annotation takes the `expected=<<Exception class name>>.class` argument.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '`@Test`注解接受`expected=<<Exception class name>>.class`参数。'
- en: 'If the expected exception class doesn''t match the exception thrown from the
    code, the test fails. Consider the following code:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 如果预期的异常类与代码抛出的异常不匹配，测试将失败。考虑以下代码：
- en: '[PRE6]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This is only one solution. There are several other methods that are generally
    considered to be better solutions. Utilizing `@Rule` in JUnit 4.8+ and assigning
    `ExpectedException` is a stronger solution because you can inspect the message
    as well as the type. We have covered `@Rule` in the *Working with JUnit 4++ section*
    of this chapter.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是一个解决方案。还有几种其他方法通常被认为是更好的解决方案。在JUnit 4.8+中使用`@Rule`并分配`ExpectedException`是一个更强的解决方案，因为你可以检查消息以及类型。我们在本章的*与JUnit
    4++一起工作*部分中介绍了`@Rule`。
- en: Exploring the @RunWith annotation
  id: totrans-98
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 探索`@RunWith`注解
- en: Test runners execute the JUnit tests. Eclipse has a built-in native graphical
    runner. JUnit 4 provides tools to define the suite to be run and to display its
    results.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 测试运行器执行JUnit测试。Eclipse有一个内置的本地图形运行器。JUnit 4提供定义要运行的套件和显示其结果的工具。
- en: When a class is annotated with `@RunWith` or the class extends a class annotated
    with `@RunWith`, JUnit will invoke the class that it references to run the tests
    on that class, instead of using the built-in runner. The `@RunWith` annotation
    is used to change the nature of the test class. It can be used to run a test as
    a parameterized test or even a Spring test, or it can be a Mockito runner to initialize
    the mock objects annotated with a `@Mock` annotation.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个类被`@RunWith`注解或类扩展了一个被`@RunWith`注解的类时，JUnit将调用它引用的类来运行该类的测试，而不是使用内置的运行器。`@RunWith`注解用于改变测试类的性质。它可以用来运行参数化测试，甚至是Spring测试，或者它可以是Mockito运行器，用于初始化带有`@Mock`注解的模拟对象。
- en: The `@RunWith` annotation takes an argument. The argument must be a class extended
    from `org.junit.runner.Runner`.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '`@RunWith`注解接受一个参数。该参数必须是一个从`org.junit.runner.Runner`扩展的类。'
- en: '`JUnit4.class` is an example of a runner. This class aliases the current default
    JUnit 4 class runner.'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '`JUnit4.class`是一个运行器的例子。这个类将当前默认的JUnit 4类运行器别名为。'
- en: '`Suite` is a standard runner that allows us to build a suite that contains
    tests from many packages. The following is an example of `@RunWith`:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '`Suite`是一个标准运行器，允许我们构建包含来自多个包的测试的套件。以下是一个`@RunWith`的示例：'
- en: '[PRE7]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Working with JUnit 4++
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用JUnit 4++
- en: 'This section explores the advanced features of the JUnit 4 framework and includes
    the following topics: parameterized test, Hamcrest matchers and assertThat, assumption,
    theory, timeout, categories, rules, test suites, and tests order.'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 本节探讨了JUnit 4框架的高级特性，包括以下主题：参数化测试、Hamcrest匹配器和assertThat、假设、理论、超时、类别、规则、测试套件和测试顺序。
- en: Ignoring a test
  id: totrans-107
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 忽略一个测试
- en: Suppose a failing test blocks you to check-in a mission critical code, and you
    come to know that the owner of the code is on a vacation. What do you do? You
    try to fix the test or just comment out or delete the test to proceed with your
    check-in (committing files to a source control such as SVN), or you wait until
    the test is fixed.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 假设一个失败的测试阻止你检查一个关键任务代码，而你又得知代码的所有者正在度假。你该怎么办？你尝试修复测试，或者只是注释掉或删除测试以继续你的检查（将文件提交到源控制如SVN），或者你等待直到测试被修复。
- en: Sometimes we comment out tests because the feature is not developed. JUnit came
    up with a solution for this. Instead of commenting a test, we can just ignore
    it by annotating the test method with `@Ignore`. Commenting out a test or code
    is bad as it does nothing but increases the code size and reduces its readability.
    Also, when you comment out a test, then the test report doesn't tell you anything
    about the commented-out test; however, if you ignore a test, then the test report
    will tell you that something needs to be fixed as some tests are ignored. So,
    you can keep track of the ignored test.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 有时我们注释掉测试是因为功能尚未开发。JUnit为此提供了解决方案。我们不必注释测试，只需通过使用`@Ignore`注解测试方法来忽略它。注释掉测试或代码是糟糕的，因为它除了增加代码大小并降低其可读性外，什么都不做。此外，当你注释掉测试时，测试报告不会告诉你关于注释掉的测试的任何信息；然而，如果你忽略一个测试，那么测试报告会告诉你需要修复某些被忽略的测试。因此，你可以跟踪被忽略的测试。
- en: 'Use `@Ignore("Reason: why do you want to ignore?")`. Giving a proper description
    explains the intention behind ignoring the test. The following is an example of,
    where a test method is ignored because the holiday calculation is not working:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '使用`@Ignore("Reason: why do you want to ignore?")`。给出适当的描述可以解释忽略测试的意图。以下是一个示例，其中测试方法被忽略是因为假日计算不工作：'
- en: '[PRE8]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The following is a screenshot from Eclipse:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是从Eclipse中截取的屏幕截图：
- en: '![Ignoring a test](img/00005.jpeg)'
  id: totrans-113
  prefs: []
  type: TYPE_IMG
  zh: '![忽略一个测试](img/00005.jpeg)'
- en: You can place the `@Ignore` annotation on a test class, effectively ignoring
    all the contained tests.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在测试类上放置`@Ignore`注解，从而有效地忽略所有包含的测试。
- en: Executing tests in order
  id: totrans-115
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 按顺序执行测试
- en: JUnit was designed to allow execution in a random order, but typically they
    are executed in a linear fashion and the order is not guaranteed. The JUnit runner
    depends on reflection to execute the tests. Usually, the test execution order
    doesn't vary from run to run; actually, the randomness is environment-specific
    and varies from JVM to JVM. So, it's better that you never assume they'll be executed
    in the same order and depend on other tests, but sometimes we need to depend on
    the order.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: JUnit被设计为允许随机执行，但通常它们是按线性方式执行的，顺序没有保证。JUnit运行器依赖于反射来执行测试。通常，测试执行顺序不会随运行而变化；实际上，随机性是环境特定的，并且从JVM到JVM会有所不同。因此，最好不要假设它们将以相同的顺序执行并依赖于其他测试，但有时我们需要依赖顺序。
- en: For example, when you want to write slow tests to insert a row into a database,
    then first update the row and finally delete the row. Here, unless the insert
    function is executed, delete or update functions cannot run.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，当你想编写慢速测试以向数据库中插入一行时，首先更新该行，最后删除该行。在这里，除非插入函数被执行，否则删除或更新函数无法运行。
- en: JUnit 4.11 provides us with an `@FixMethodOrder` annotation to specify the execution
    order. It takes `enum MethodSorters`.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: JUnit 4.11为我们提供了一个`@FixMethodOrder`注解来指定执行顺序。它接受`enum MethodSorters`。
- en: 'To change the execution order, annotate your test class using `@FixMethodOrder`
    and specify one of the following available `enum MethodSorters` constant:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 要更改执行顺序，使用`@FixMethodOrder`注解你的测试类并指定以下可用的`enum MethodSorters`常量之一：
- en: '`MethodSorters.JVM`: This leaves the test methods in the order returned by
    the JVM. This order may vary from run to run.'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MethodSorters.JVM`：这会保留由JVM返回的测试方法顺序。这个顺序可能每次运行都会变化。'
- en: '`MethodSorters.NAME_ASCENDING`: This sorts the test methods by the method name
    in the lexicographic order.'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MethodSorters.NAME_ASCENDING`: 这将按字典顺序对测试方法进行排序。'
- en: '`MethodSorters.DEFAULT`: This is the default value that doesn''t guarantee
    the execution order.'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MethodSorters.DEFAULT`: 这是默认值，但不保证执行顺序。'
- en: We will write a few tests to verify this behavior.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将编写一些测试来验证这种行为。
- en: 'Add a `TestExecutionOrder` test and create tests, as shown in the following
    code snippet:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 添加一个 `TestExecutionOrder` 测试并创建测试，如下面的代码片段所示：
- en: '[PRE9]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Run the tests. The execution order may vary, but if we annotate the class with
    `@FixMethodOrder(MethodSorters.NAME_ASCENDING)`, the tests will be executed in
    the ascending order as follows:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 运行测试。执行顺序可能会变化，但如果我们用 `@FixMethodOrder(MethodSorters.NAME_ASCENDING)` 注解类，测试将按以下顺序执行：
- en: '[PRE10]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The following Eclipse screenshot displays the test execution in the ascending
    order:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 以下 Eclipse 截图显示了按顺序执行的测试：
- en: '![Executing tests in order](img/00006.jpeg)'
  id: totrans-129
  prefs: []
  type: TYPE_IMG
  zh: '![按顺序执行测试](img/00006.jpeg)'
- en: Learning assumptions
  id: totrans-130
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 学习假设
- en: In multisite projects, sporadically, a date or time zone tests fail in a local
    CI server but run fine in other servers in a different time zone. We can choose
    to not run those automatic tests in our local server.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在多站点项目中，偶尔，日期或时区测试在本地 CI 服务器上失败，但在不同时区的其他服务器上运行良好。我们可以选择不在本地服务器上运行那些自动测试。
- en: Sometimes our tests fail due to a bug in a third-party code or external software,
    but we know that after some specific build or version, the bug will be fixed.
    Should we comment out the code and wait until the build is available?
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 有时我们的测试会因为第三方代码或外部软件中的错误而失败，但我们知道在某个特定的构建或版本之后，错误将被修复。我们应该注释掉代码并等待构建可用吗？
- en: In many projects, **Jenkins** (for test automation) and **SONAR** (for code-quality
    metrics) run in a server. It has been observed that due to low resources, the
    automatic tests run forever when SONAR is processing and the tests run simultaneously.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多项目中，**Jenkins**（用于测试自动化）和**SONAR**（用于代码质量指标）在服务器上运行。观察到由于资源不足，当 SONAR 处理时，自动测试会无限期地运行，并且测试会同时进行。
- en: JUnit has the answer to all these issues. It recommends using an `org.junit.Assume`
    class.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: JUnit 对所有这些问题都有答案。它建议使用 `org.junit.Assume` 类。
- en: Like `Assert`, `Assume` offers many static methods, such as `assumeTrue(condition)`,
    `assumeFalse(condition)`, `assumeNotNull(condition)`, and `assumeThat(condition)`.
    Before executing a test, we can check our assumption using the `assumeXXX` methods.
    If our assumption fails, then the `assumeXXX` methods throw `AssumptionViolatedException`,
    and the JUnit runner ignores the tests with failing assumptions.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 与 `Assert` 类似，`Assume` 提供了许多静态方法，例如 `assumeTrue(condition)`、`assumeFalse(condition)`、`assumeNotNull(condition)`
    和 `assumeThat(condition)`。在执行测试之前，我们可以使用 `assumeXXX` 方法检查我们的假设。如果我们的假设失败，那么 `assumeXXX`
    方法将抛出 `AssumptionViolatedException`，JUnit 运行器将忽略有失败假设的测试。
- en: So, basically, if our assumption is not true, the tests are just ignored. We
    can assume that the tests are run in the EST time zone; if the tests are run somewhere
    else, they will be ignored automatically. Similarly, we can assume that the third-party
    code version is higher than the build/version 123; if the build version is lower,
    the tests will be ignored.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，基本上，如果我们的假设不正确，测试将被忽略。我们可以假设测试是在 EST 时区运行的；如果测试在其他地方运行，它们将被自动忽略。同样，我们可以假设第三方代码版本高于构建/版本
    123；如果构建版本较低，测试将被忽略。
- en: Let's write the code to validate our assumption about `Assume`.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们编写代码来验证我们对 `Assume` 的假设。
- en: Here, we will try to solve the SONAR server issue. We will assume that SONAR
    is not running. If SONAR runs during the test execution, the assumption will fail
    and the tests will be ignored.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将尝试解决 SONAR 服务器问题。我们将假设 SONAR 没有运行。如果测试执行期间 SONAR 正在运行，假设将失败，测试将被忽略。
- en: 'Create an `Assumption` test class. The following is the body of the class:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个 `Assumption` 测试类。以下是该类的主体：
- en: '[PRE11]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Here, for simplicity, we added a `isSonarRunning` variable to replicate a SONAR
    server facade. In the actual code, we can call an API to get the value. We will
    set the variable to `false`. Then, in the test, we will reset the value to `true`.
    This means SONAR is running. So, our assumption that SONAR is not running is false;
    hence, the test will be ignored.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，为了简单起见，我们添加了一个 `isSonarRunning` 变量来复制一个 SONAR 服务器外观。在实际代码中，我们可以调用一个 API 来获取值。我们将变量设置为
    `false`。然后，在测试中，我们将重置该值为 `true`。这意味着 SONAR 正在运行。因此，我们的假设 SONAR 没有运行是错误的；因此，测试将被忽略。
- en: 'The following screenshot shows that the test is ignored. We didn''t annotate
    the test using `@Ignore`:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 以下屏幕截图显示测试被忽略。我们没有使用 `@Ignore` 注解测试：
- en: '![Learning assumptions](img/00007.jpeg)'
  id: totrans-143
  prefs: []
  type: TYPE_IMG
  zh: '![学习假设](img/00007.jpeg)'
- en: 'When we change the value of the `isSonarRunning` variable to `false,` as given
    in the following code snippet, the test will be executed:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们将 `isSonarRunning` 变量的值更改为 `false` 时，如以下代码片段所示，测试将被执行：
- en: '[PRE12]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Continuous integration tools such as Jenkins can run multiple tools such as
    Sonar to acquire code-quality metrics. It's always a good practice to have a build
    pipeline where the code quality is only checked after the tests pass. This prevents
    the CPU-intensive tasks from occurring at the same time.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '持续集成工具，如 Jenkins，可以运行多个工具，如 Sonar，以获取代码质量指标。始终是一个好习惯，在测试通过之后才检查代码质量，这样可以防止在同时进行
    CPU 密集型任务。 '
- en: Assumption is also used in the `@Before` methods, but be careful not to overuse
    it. Assumption is good for use with TDD where one writes pretests ahead of time.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 假设（Assumption）也用于 `@Before` 方法中，但请注意不要过度使用它。假设在 TDD（测试驱动开发）中很有用，因为它允许提前编写预测试。
- en: Exploring the test suite
  id: totrans-148
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 探索测试套件
- en: To run multiple test cases, JUnit 4 provides `Suite.class` and the `@Suite.SuiteClasses`
    annotation. This annotation takes an array (comma separated) of test classes.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行多个测试用例，JUnit 4 提供了 `Suite.class` 和 `@Suite.SuiteClasses` 注解。此注解接受一个数组（以逗号分隔）的测试类。
- en: Create a `TestSuite` class and annotate the class with `@RunWith(Suite.class)`.
    This annotation will force Eclipse to use the suite runner.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个 `TestSuite` 类，并使用 `@RunWith(Suite.class)` 注解该类。此注解将强制 Eclipse 使用套件运行器。
- en: Next, annotate the class with `@Suite.SuiteClasses({ AssertTest.class, TestExecutionOrder.class,
    Assumption.class })` and pass comma-separated test class names.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，使用 `@Suite.SuiteClasses({ AssertTest.class, TestExecutionOrder.class, Assumption.class
    })` 注解类，并传递以逗号分隔的测试类名称。
- en: 'The following is the code snippet:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个代码片段：
- en: '[PRE13]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'During execution, the suite will execute all the tests. The following is a
    screenshot of the suite run. Check whether it runs seven tests out of the three
    test fixtures: `AssertTest`, `TestExecutionOrder`, and `Assumption`.'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在执行过程中，套件将执行所有测试。以下是一个套件运行的屏幕截图。检查它是否从三个测试固定装置 `AssertTest`、`TestExecutionOrder`
    和 `Assumption` 中运行了七个测试。
- en: '![Exploring the test suite](img/00008.jpeg)'
  id: totrans-155
  prefs: []
  type: TYPE_IMG
  zh: '![探索测试套件](img/00008.jpeg)'
- en: A test suite is created for group-related tests such as a group of data access,
    API usage tests, or a group of input validation logic tests.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 为相关测试组创建测试套件，例如数据访问、API 使用测试组或输入验证逻辑测试组。
- en: Asserting with assertThat
  id: totrans-157
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 `assertThat` 进行断言
- en: 'Joe Walnes created the `assertThat(Object actual, Matcher matcher)` method.
    General consensus is that `assertThat` is readable and more useful than `assertEquals`.
    The syntax of the `assertThat` method is as follows:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: Joe Walnes 创建了 `assertThat(Object actual, Matcher matcher)` 方法。普遍认为 `assertThat`
    比 `assertEquals` 更易读且更有用。`assertThat` 方法的语法如下：
- en: '[PRE14]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Here, `Object` is the actual value received and `Matcher` is an implementation
    of the `org.hamcrest.Matcher` interface. This interface comes from a separate
    library called `hamcrest.jar`.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`Object` 是实际接收到的值，而 `Matcher` 是 `org.hamcrest.Matcher` 接口的一个实现。此接口来自一个名为
    `hamcrest.jar` 的独立库。
- en: A matcher enables a partial or an exact match for an expectation, whereas `assertEquals`
    uses an exact match. `Matcher` provides utility methods such as `is`, `either`,
    `or`, `not` , and `hasItem`. The `Matcher` methods use the **builder pattern**
    so that we can combine one or more matchers to build a composite matcher chain.
    Just like `StringBuilder`, it builds a string in multiple steps.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 匹配器允许对期望进行部分或精确匹配，而 `assertEquals` 使用精确匹配。`Matcher` 提供了如 `is`、`either`、`or`、`not`
    和 `hasItem` 等实用方法。`Matcher` 方法使用 **建造者模式**，这样我们就可以组合一个或多个匹配器来构建复合匹配器链。就像 `StringBuilder`
    一样，它通过多个步骤构建字符串。
- en: 'The following are a few examples of matchers and `assertThat`:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些匹配器和 `assertThat` 的示例：
- en: '`assertThat(calculatedTax, is(not(thirtyPercent)) );`'
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`assertThat(calculatedTax, is(not(thirtyPercent)) );`'
- en: '`assertThat(phdStudentList, hasItem(DrJohn) );`'
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`assertThat(phdStudentList, hasItem(DrJohn) );`'
- en: '`assertThat(manchesterUnitedClub, both( is(EPL_Champion)).and(is(UEFA_Champions_League_Champion))
    );`'
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`assertThat(manchesterUnitedClub, both( is(EPL_Champion)).and(is(UEFA_Champions_League_Champion))
    );`'
- en: The preceding examples are more English than a JUnit test code. So, anyone can
    understand the intent of the code and test, and a matcher improves readability.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的例子比 JUnit 测试代码更像是英语。因此，任何人都可以理解代码和测试的意图，而匹配器提高了可读性。
- en: Hamcrest provides a utility matcher class called `org.hamcrest.CoreMatchers`.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: Hamcrest提供了一个名为`org.hamcrest.CoreMatchers`的实用匹配器类。
- en: A few utility methods of `CoreMatchers` are `allOf`, `anyOf`, `both`, `either`,
    `describedAs`, `everyItem`, `is`, `isA`, `anything`, `hasItem`, `hasItems`, `equalTo`,
    `any`, `instanceOf`, `not`, `nullValue`, `notNullValue`, `sameInstance`, `theInstance`
    ,`startsWith`, `endsWith`, and `containsString`. All these methods return a matcher.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '`CoreMatchers`的一些实用方法包括`allOf`、`anyOf`、`both`、`either`、`describedAs`、`everyItem`、`is`、`isA`、`anything`、`hasItem`、`hasItems`、`equalTo`、`any`、`instanceOf`、`not`、`nullValue`、`notNullValue`、`sameInstance`、`theInstance`、`startsWith`、`endsWith`和`containsString`。所有这些方法都返回一个匹配器。'
- en: We worked with `assertEquals`; so, let's start with `equalTo`. The `equalTo`
    method is equivalent to `assertEquals`.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用了`assertEquals`；因此，让我们从`equalTo`开始。`equalTo`方法等同于`assertEquals`。
- en: Comparing matchers – equalTo, is, and not
  id: totrans-170
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 比较匹配器 - equalTo、is 和 not
- en: 'Create a `AssertThatTest.java` JUnit test and static import `org.hamcrest.CoreMatchers.*;`
    as follows:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个`AssertThatTest.java` JUnit 测试并静态导入`org.hamcrest.CoreMatchers.*;`如下：
- en: '[PRE15]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Set the `age` variable to `30` and then likewise for `assertEquals` and call
    `equalTo`, which here is `Matcher`. The `equalTo` method takes a value. If the
    `Matcher` value doesn't match the actual value, then `assertThat` throws an `AssertionError`
    exception.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 将`age`变量设置为`30`，然后同样为`assertEquals`调用`equalTo`，这里它是`Matcher`。`equalTo`方法接受一个值。如果`Matcher`值与实际值不匹配，则`assertThat`抛出`AssertionError`异常。
- en: 'Set the `age` variable value to `29` and rerun the test. The following error
    will occur:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 将`age`变量的值设置为`29`并重新运行测试。以下错误将会发生：
- en: '![Comparing matchers – equalTo, is, and not](img/00009.jpeg)'
  id: totrans-175
  prefs: []
  type: TYPE_IMG
  zh: '![比较匹配器 - equalTo、is 和 not](img/00009.jpeg)'
- en: The `is(a)` attribute takes a value and returns a Boolean and behaves similar
    to `equalTo(a)`. The `is(a)` attribute is the same as `is(equalTo(a))`.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '`is(a)`属性接受一个值并返回一个布尔值，其行为类似于`equalTo(a)`。`is(a)`属性等同于`is(equalTo(a))`。'
- en: The `not` attribute takes a value or a matcher. In the preceding code, we used
    `assertThat(age, is(not(33)));`. This expression is nothing but `age is not 33`
    and is more readable than the `assert` methods.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '`not`属性接受一个值或一个匹配器。在上面的代码中，我们使用了`assertThat(age, is(not(33)))`。这个表达式不过是`age
    is not 33`，并且比`assert`方法更易读。'
- en: Working with compound value matchers – either, both, anyOf, allOf, and not
  id: totrans-178
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 处理复合值匹配器 - either、both、anyOf、allOf 和 not
- en: 'In this section, we will use `either`, `both`, `anyOf`, `allOf`, and `not`.
    Add the following test to the `AssertThatTest.java` file:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将使用`either`、`both`、`anyOf`、`allOf`和`not`。将以下测试添加到`AssertThatTest.java`文件中：
- en: '[PRE16]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: In the preceding example, a `marks` double variable is initialized with a value
    of `100.00`. This variable value is asserted with an `either` matcher.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，一个名为`marks`的双变量被初始化为`100.00`的值。这个变量的值通过一个`either`匹配器进行断言。
- en: Basically, using `either`, we can compare two values against an actual or calculated
    value. If any of them match, then the assertion is passed. If none of them match,
    then `AssertionError` is thrown.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上，使用`either`，我们可以将两个值与实际或计算出的值进行比较。如果其中任何一个匹配，则断言通过。如果没有一个匹配，则抛出`AssertionError`异常。
- en: The `either(Matcher)` method takes a matcher and returns a `CombinableEitherMatcher`
    class. The `CombinableEitherMatcher` class has a `or(Matcher other)` method so
    that `either` and `or` can be combined.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '`either(Matcher)`方法接受一个匹配器并返回一个`CombinableEitherMatcher`类。`CombinableEitherMatcher`类有一个`or(Matcher
    other)`方法，这样`either`和`or`就可以组合使用。'
- en: The `or(Matcher other)` method is translated to `return (new CombinableMatcher(first)).or(other);`
    and finally to `new CombinableMatcher(new AnyOf(templatedListWith(other)));`.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '`or(Matcher other)`方法被翻译为`return (new CombinableMatcher(first)).or(other);`，最后变为`new
    CombinableMatcher(new AnyOf(templatedListWith(other)))`。'
- en: Using `both`, we can compare two values against an actual or calculated value.
    If any of them don't match, then the `AssertionError` exception is thrown. If
    both of them match, then the assertion is passed.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`both`，我们可以将两个值与实际或计算出的值进行比较。如果其中任何一个不匹配，则抛出`AssertionError`异常。如果两个都匹配，则断言通过。
- en: A numeric value such as a math score cannot be equal to both 60 and 80\. However,
    we can negate the expression. If the math score is 80, then using the `both` matcher
    we can write the expression as `assertThat (mathScore , both (not(60)). and(not
    (90)))`.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 一个如数学分数这样的数值不能同时等于60和80。然而，我们可以否定这个表达式。如果数学分数是80，那么使用`both`匹配器，我们可以将表达式写为`assertThat(mathScore,
    both(not(60)).and(not(90)))`。
- en: The `anyOf` matcher is more like `either` with multiple values. Using `anyOf`,
    we can compare multiple values against an actual or calculated value. If any of
    them match, then the assertion is passed. If none of them match, then the `AssertionError`
    exception is thrown.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '`anyOf` 匹配器更像是具有多个值的 `either`。使用 `anyOf`，我们可以将多个值与实际或计算值进行比较。如果其中任何一个匹配，则断言通过。如果没有一个匹配，则抛出
    `AssertionError` 异常。'
- en: The `allOf` matcher is more like `both` with multiple values. Using `allOf`,
    we can compare multiple values against an actual or calculated value. If any of
    them don't match, then the `AssertionError` exception is thrown. Similar to `both`,
    we can use `allOf` along with `not` to check whether a value does or doesn't belong
    to a set.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '`allOf` 匹配器更像是具有多个值的 `both`。使用 `allOf`，我们可以将多个值与实际或计算值进行比较。如果其中任何一个不匹配，则抛出
    `AssertionError` 异常。类似于 `both`，我们可以使用 `allOf` 与 `not` 一起检查一个值是否属于集合。'
- en: In the preceding example, using `allOf` and `not`, we checked whether the `marks`
    attribute is not `1`, `100`, or `30`.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，使用 `allOf` 和 `not`，我们检查了 `marks` 属性是否不是 `1`、`100` 或 `30`。
- en: Working with collection matchers – hasItem and hasItems
  id: totrans-190
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用集合匹配器 – hasItem 和 hasItems
- en: In the previous section, we asserted a value against multiple values. In this
    section, we will assert a collection of values against a value or numerous values.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们针对多个值进行了断言。在本节中，我们将对一组值与一个值或多个值进行断言。
- en: 'Consider the following example. A salary list is populated with three values:
    `50.00`, `200.00`, and `500.00`. Use `hasItem` to check whether a value exists
    in a collection, and use `hasItems` to check whether multiple values exist in
    a collection, as shown in the following code:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下示例。一个工资列表被填充了三个值：`50.00`、`200.00` 和 `500.00`。使用 `hasItem` 检查一个值是否存在于集合中，并使用
    `hasItems` 检查多个值是否存在于集合中，如下面的代码所示：
- en: '[PRE17]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The `hasItem` matcher has two versions: one takes a value and the other takes
    a matcher. So, we can check a value in a collection using `hasItem`, or check
    whether a value doesn''t exist in a collection using `not` and `hasItem`. The
    `hasItems` matcher operates on a set of values.'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '`hasItem` 匹配器有两个版本：一个接受一个值，另一个接受匹配器。因此，我们可以使用 `hasItem` 检查集合中的一个值，或者使用 `not`
    和 `hasItem` 检查一个值是否不存在于集合中。`hasItems` 匹配器对一组值进行操作。'
- en: Exploring string matchers – startsWith, endsWith, and containsString
  id: totrans-195
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 探索字符串匹配器 – startsWith、endsWith 和 containsString
- en: 'In this section, we will explore the string matchers. `CoreMatchers` has three
    built-in string matcher methods. In the following example, a `String` variable
    name is assigned a value and then we assert that the name starts with a specific
    value, contains a value, and ends with a value:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探索字符串匹配器。`CoreMatchers` 有三个内置的字符串匹配器方法。在以下示例中，一个 `String` 变量 `name`
    被赋予一个值，然后我们断言该名称以特定值开头、包含一个值和以一个值结尾：
- en: '[PRE18]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The `startsWith` matcher operates on string only. It checks whether the string
    starts with the given string. The `endsWith` matcher checks whether the string
    ends with the given string. The `containsString` matcher checks whether the string
    contains another string.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '`startsWith` 匹配器仅对字符串进行操作。它检查字符串是否以给定的字符串开头。`endsWith` 匹配器检查字符串是否以给定的字符串结尾。`containsString`
    匹配器检查字符串是否包含另一个字符串。'
- en: Sometimes, a method calls to return a JSON response. Using `containsString`,
    a specific value can be asserted.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，一个方法调用返回一个 JSON 响应。使用 `containsString`，可以断言一个特定的值。
- en: Note
  id: totrans-200
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Note that `startsWith`, `endsWith`, and `containsStrings` are not the only string
    matchers. Other built-in matchers such as `both`, `either`, `anyOf`, and so on,
    can be applied to a `String` object.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`startsWith`、`endsWith` 和 `containsStrings` 并不是唯一的字符串匹配器。其他内置匹配器，如 `both`、`either`、`anyOf`
    等等，也可以应用于 `String` 对象。
- en: Exploring built-in matchers
  id: totrans-202
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 探索内置匹配器
- en: '`JUnitMatchers` has built-in matcher methods, but all of these methods are
    deprecated. Use Hamcrest matchers instead of using `JUnitMatchers`.'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '`JUnitMatchers` 有内置的匹配器方法，但所有这些方法都已弃用。请使用 Hamcrest 匹配器代替 `JUnitMatchers`。'
- en: Building a custom matcher
  id: totrans-204
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 构建自定义匹配器
- en: '[PRE19]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '[PRE20]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Note that when `matcher.matches()` returns `false`, the description is built
    from the actual value and the matcher. The `appendDescriptionOf()` method calls
    the `describeTo()` method of the matcher to build the error message.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，当 `matcher.matches()` 返回 `false` 时，描述是由实际值和匹配器构建的。`appendDescriptionOf()`
    方法调用匹配器的 `describeTo()` 方法来构建错误消息。
- en: 'Finally, `matcher.describeMismatch(actual, description)` appends the string
    `but: was <<actual>>`.'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '最后，`matcher.describeMismatch(actual, description)` 将字符串 `but: was <<actual>>`
    追加到描述中。'
- en: 'The `lessThanOrEqual` class needs to compare two objects, so the `Matcher`
    class should be operated on the `Comparable` objects. Create a generic class that
    operates with any type that implements the `Comparable` interface, as follows:'
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`lessThanOrEqual` 类需要比较两个对象，因此 `Matcher` 类应该在 `Comparable` 对象上操作。创建一个通用的类，它可以操作实现
    `Comparable` 接口的任何类型，如下所示：'
- en: '[PRE21]'
  id: totrans-210
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Now we need to implement the `describeTo` and `matches` methods. The `assertThat`
    method will pass the actual value to the matcher''s `matches(Object o)` method,
    and `lessThanOrEqual` will accept a value to compare with the actual. So, in the
    `matches` method, we need two comparable objects: one passed as a parameter and
    the other passed to a matcher object. The expected value is passed during the
    `matcher` object instantiation as follows:'
  id: totrans-211
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 现在我们需要实现 `describeTo` 和 `matches` 方法。`assertThat` 方法将实际值传递给匹配器的 `matches(Object
    o)` 方法，`lessThanOrEqual` 将接受一个与实际值比较的值。因此，在 `matches` 方法中，我们需要两个可比较的对象：一个作为参数传递，另一个传递给匹配器对象。期望值在
    `matcher` 对象实例化期间传递，如下所示：
- en: '[PRE22]'
  id: totrans-212
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'We will store the `expectedValue` during the `Matcher` object creation and
    use it in the `matches()` method to compare the `expectedValue` with the `actual`
    as follows:'
  id: totrans-213
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们将在创建 `Matcher` 对象期间存储 `expectedValue` 并在 `matches()` 方法中使用它来比较 `expectedValue`
    与 `actual`，如下所示：
- en: '[PRE23]'
  id: totrans-214
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The preceding `LessThanOrEqual` class should return `true` only if `expectedValue.compareTo(actual)
    >= 0` and then the `describeTo()` method appends the string `"less than or equals
    (<=) "+ expectedValue` text to the `description,` so that if the assertion fails,
    then the "`less than or equals (<=) "+ expectedValue` message will be shown.
  id: totrans-215
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 前面的 `LessThanOrEqual` 类应该仅在 `expectedValue.compareTo(actual) >= 0` 时返回 `true`，然后
    `describeTo()` 方法将字符串 `"less than or equals (<=) "+ expectedValue` 添加到 `description`
    中，这样如果断言失败，则将显示消息 "`less than or equals (<=) "+ expectedValue`"。
- en: 'The `assertThat` method takes a matcher but `new LessThanOrEqual(expectedValue)`
    doesn''t look good. We will create a `static` method in the `LessThanOrEqual`
    class to create a new object of `LessThanOrEqual`. Call this method from the `assertThat`
    method as follows:'
  id: totrans-216
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`assertThat` 方法接受一个匹配器，但 `new LessThanOrEqual(expectedValue)` 的样子看起来并不好。我们将在
    `LessThanOrEqual` 类中创建一个 `static` 方法来创建一个新的 `LessThanOrEqual` 对象。如下从 `assertThat`
    方法调用此方法：'
- en: '[PRE24]'
  id: totrans-217
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The `@Factory` annotation isn't necessary but needed for a Hamcrest tool. When
    we create many custom matchers, then it becomes annoying to import them all individually.
    Hamcrest ships with a `org.hamcrest.generator.config.XmlConfigurator` command-line
    tool that picks up predicates annotated with the `@Factory` annotation and collects
    them in a `Matcher` class for easy importing.
  id: totrans-218
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`@Factory` 注解不是必需的，但对于 Hamcrest 工具是必需的。当我们创建许多自定义匹配器时，逐个导入它们会变得很烦人。Hamcrest
    随带一个 `org.hamcrest.generator.config.XmlConfigurator` 命令行工具，该工具拾取带有 `@Factory`
    注解的谓词，并将它们收集到一个 `Matcher` 类中以方便导入。'
- en: 'Static import the `LessThanOrEqual` class and add a test to `AssertThatTest.java`
    to validate the custom matcher, as shown in the following code:'
  id: totrans-219
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 静态导入 `LessThanOrEqual` 类，并将测试添加到 `AssertThatTest.java` 中以验证自定义匹配器，如下所示：
- en: '[PRE25]'
  id: totrans-220
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: This test should pass.
  id: totrans-221
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这个测试应该通过。
- en: 'How about testing the code with a greater value? In Java, `Integer.MAX_VALUE`
    holds the maximum integer value and `Integer.MIN_VALUE` holds the minimum integer
    value. If we expect that the maximum value will be greater than or equal to the
    minimum value, then the assertion should fail. Consider the following code snippet:'
  id: totrans-222
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用更大的值测试代码怎么样？在 Java 中，`Integer.MAX_VALUE` 存储最大整数值，`Integer.MIN_VALUE` 存储最小整数值。如果我们期望最大值将大于或等于最小值，那么断言应该失败。考虑以下代码片段：
- en: '[PRE26]'
  id: totrans-223
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'This will throw the following error:'
  id: totrans-224
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这将抛出以下错误：
- en: '![Building a custom matcher](img/00010.jpeg)'
  id: totrans-225
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![构建自定义匹配器](img/00010.jpeg)'
- en: Creating parameterized tests
  id: totrans-226
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建参数化测试
- en: Parameterized tests are used for multiple iterations over a single input to
    stress the object in test. The primary reason is to reduce the amount of test
    code.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 参数化测试用于对单个输入进行多次迭代以在测试中压力测试对象。主要原因是减少测试代码的数量。
- en: In TDD, the code is written to satisfy a failing test. The production code logic
    is built from a set of test cases and different input values. For example, if
    we need to build a class that will return the factorial of a number, then we will
    pass different sets of data and verify that our implementation passes the validation.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 在 TDD 中，代码是为了满足失败的测试而编写的。生产代码逻辑是从一系列测试用例和不同的输入值构建的。例如，如果我们需要构建一个将返回数字阶乘的类，那么我们将传递不同的数据集并验证我们的实现是否通过验证。
- en: We know that the factorial of 0 is 1, the factorial of 1 is 1, the factorial
    of 2 is 2, the factorial of 3 is 6, the factorial of 4 is 24, and so on.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 我们知道 0 的阶乘是 1，1 的阶乘是 1，2 的阶乘是 2，3 的阶乘是 6，4 的阶乘是 24，依此类推。
- en: So, if we write tests such as `factorial_of_1_is_1` and `factorial_of_4_is_24`,
    then the test class will be polluted very easily. How many methods will we write?
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果我们编写像 `factorial_of_1_is_1` 和 `factorial_of_4_is_24` 这样的测试，那么测试类将很容易被污染。我们将编写多少个方法？
- en: 'We can create two arrays: one with the expected values and the other with the
    original numbers. Then, we can loop through the arrays and assert the result.
    We don''t have to do this because the JUnit 4 framework provides us with a similar
    solution. It gives us a `Parameterized` runner.'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以创建两个数组：一个包含期望值，另一个包含原始数字。然后，我们可以遍历数组并断言结果。我们不必这样做，因为 JUnit 4 框架为我们提供了一个类似的解决方案。它为我们提供了一个
    `Parameterized` 运行器。
- en: We read about the `@RunWith` annotation in the preceding section. `Parameterized`
    is a special type of runner and can be used with the `@RunWith` annotation.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在前面的小节中了解了 `@RunWith` 注解。`Parameterized` 是一种特殊的运行器，可以与 `@RunWith` 注解一起使用。
- en: 'Parameterized comes with two flavors: constructor and method.'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 参数化有两种类型：构造函数和方法。
- en: Working with parameterized constructors
  id: totrans-234
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用参数化构造函数
- en: 'Perform the following steps to build a parameterized test with a constructor:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤使用构造函数构建参数化测试：
- en: Create a source folder `src` and add a `Factorial.java` class under `src/ com.packtpub.junit.recap`.
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个源文件夹 `src`，并在 `src/ com.packtpub.junit.recap` 下添加一个 `Factorial.java` 类。
- en: 'Implement the factorial algorithm. Add the following code to the `Factorial.java`
    class:'
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现阶乘算法。将以下代码添加到 `Factorial.java` 类中：
- en: '[PRE27]'
  id: totrans-238
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Add a `ParameterizedFactorialTest.java` test under `test/ com.packtpub.junit.recap`
    and annotate the class with `@RunWith(Parameterized.class)` as follows:'
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `test/ com.packtpub.junit.recap` 下添加一个 `ParameterizedFactorialTest.java` 测试，并用
    `@RunWith(Parameterized.class)` 注解该类，如下所示：
- en: '[PRE28]'
  id: totrans-240
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Add a method to create a dataset for factorial algorithm. The method should
    return `Collection` of the `Object[]` method. We need a collection of two dimensional
    arrays to hold the numbers and factorial values. To define the data parameters,
    annotate the method with `@Parameters`.
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个创建阶乘算法数据集的方法。该方法应返回 `Collection` 的 `Object[]` 方法。我们需要一个二维数组集合来保存数字和阶乘值。为了定义数据参数，用
    `@Parameters` 注解该方法。
- en: '[PRE29]'
  id: totrans-242
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '[PRE30]'
  id: totrans-243
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Check whether the arrays hold the number and the expected factorial result (0's
    factorial is 1, 5's factorial is 120, and so on).
  id: totrans-244
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 检查数组是否包含数字和期望的阶乘结果（0 的阶乘是 1，5 的阶乘是 120，依此类推）。
- en: 'The `Parameterized` runner needs a constructor to pass the collection of data.
    For each row in the collection, the 0^(th) array element will be passed as the
    1^(st) constructor argument, the next index will be passed as 2^(nd) argument,
    and so on, as follows:'
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Parameterized` 运行器需要一个构造函数来传递数据集合。对于集合中的每一行，0^(th) 数组元素将作为 1^(st) 构造函数参数传递，下一个索引将作为
    2^(nd) 参数传递，依此类推，如下所示：'
- en: '[PRE31]'
  id: totrans-246
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: In the test class, we added two members to hold the number and the expected
    factorial value. In the constructor, set these values. The `Parameterized` runner
    will loop through the data collection (annotated with a `@Parameters` annotation)
    and pass the values to the constructor.
  id: totrans-247
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在测试类中，我们添加了两个成员来保存数字和期望的阶乘值。在构造函数中设置这些值。`Parameterized` 运行器将遍历数据集合（用 `@Parameters`
    注解），并将值传递给构造函数。
- en: For example, it will pass 0 as input and 1 as expected, then 1 as input and
    1 as expected, and so on.
  id: totrans-248
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 例如，它将以 0 作为输入并期望得到 1，然后以 1 作为输入并期望得到 1，依此类推。
- en: 'Now, we need to add a test method to assert the number and the factorial as
    follows:'
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们需要添加一个测试方法来断言数字和阶乘，如下所示：
- en: '[PRE32]'
  id: totrans-250
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: We created a `Factorial` object and passed the number to get the actual result
    and then asserted the actual value with `expectedResult`. Here, the runner will
    create seven instances of the test class and execute the test method.
  id: totrans-251
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们创建了一个 `Factorial` 对象，并将数字传递给它以获取实际结果，然后使用 `expectedResult` 断言实际值。在这里，运行者将创建测试类的七个实例并执行测试方法。
- en: 'The following screenshot shows the result of the test run taken from Eclipse:'
  id: totrans-252
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 以下截图显示了从 Eclipse 中获取的测试运行结果：
- en: '![Working with parameterized constructors](img/00011.jpeg)'
  id: totrans-253
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![使用参数化构造函数](img/00011.jpeg)'
- en: Note that the seven tests run and the tests names are [0] factorial[0], [1]
    factorial[1], and so on till [6].
  id: totrans-254
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意，运行了七个测试，测试名称为 [0] factorial[0]，[1] factorial[1]，等等，直到 [6]。
- en: Note
  id: totrans-255
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: If the dataset returns an empty collection, the test doesn't fail; actually,
    nothing happens.
  id: totrans-256
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果数据集返回一个空集合，测试不会失败；实际上，什么也不会发生。
- en: 'If the number of parameters in the object array and the constructor argument
    don''t match, then a `java.lang.IllegalArgumentException: wrong number of arguments`
    exception is thrown. For example, { 0, 1, 3 } will throw an exception as 3 arguments
    are passed, but constructor can accept only 2.'
  id: totrans-257
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '如果对象数组和构造函数参数的数量不匹配，则抛出`java.lang.IllegalArgumentException: wrong number of
    arguments`异常。例如，{ 0, 1, 3 }将抛出异常，因为传递了3个参数，但构造函数只能接受2个。'
- en: 'If the constructor is not defined but the data set contains a value, then the
    `java.lang.IllegalArgumentException: wrong number of arguments` exception is thrown.'
  id: totrans-258
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '如果构造函数未定义但数据集包含值，则抛出`java.lang.IllegalArgumentException: wrong number of arguments`异常。'
- en: Working with parameterized methods
  id: totrans-259
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用参数化方法
- en: 'We learned about the parameterized constructor; now we will run the parameterized
    test excluding the constructor. Follow the ensuing steps to run the test using
    the `@Parameter` annotation:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 我们学习了参数化构造函数；现在我们将运行参数化测试，但不包括构造函数。按照以下步骤使用`@Parameter`注解运行测试：
- en: Add a `ParameterizeParamFactorialTest.java` test class.
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个`ParameterizeParamFactorialTest.java`测试类。
- en: 'Copy the content from the constructor test and delete the constructor. Change
    the class members to public, as follows:'
  id: totrans-262
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从构造函数测试复制内容并删除构造函数。将类成员更改为`public`，如下所示：
- en: '[PRE33]'
  id: totrans-263
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'If we run the test, it will fail as the reflection process won''t find the
    matching constructor. JUnit provides an annotation to loop through the dataset
    and set the values to the class members. `@Parameter(value=index)` takes a value.
    The value is the array index of the data collection object array. Make sure that
    the `number` and `expectedResult` variables are `public`; otherwise, the security
    exception will be thrown. Annotate them with the following parameters:'
  id: totrans-264
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们运行测试，它将失败，因为反射过程找不到匹配的构造函数。JUnit 提供了一个注解来遍历数据集并将值设置到类成员中。`@Parameter(value=index)`接受一个值。该值是数据收集对象数组的数组索引。确保`number`和`expectedResult`变量是`public`的；否则，将抛出安全异常。用以下参数注解它们：
- en: '[PRE34]'
  id: totrans-265
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Eclipse has a bug that chops off the name.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: Eclipse 有一个错误，会截断名称。
- en: Working with timeouts
  id: totrans-267
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 处理超时
- en: JUnit tests are automated to get quick feedback after a change in the code.
    If a test runs for a long time, it violates the quick feedback principle. JUnit
    provides a timeout value (in milliseconds) in the `@Test` annotation to make sure
    that if a test runs longer than the specified value, the test fails.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: JUnit 测试在代码更改后自动执行以获得快速反馈。如果测试运行时间过长，则违反了快速反馈原则。JUnit 在`@Test`注解中提供了一个超时值（以毫秒为单位），以确保如果测试运行时间超过指定值，则测试失败。
- en: 'The following is an example of a timeout:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个超时的示例：
- en: '[PRE35]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Here, the test will fail automatically after 10 milliseconds. The following
    is an Eclipse screenshot that shows the error:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，测试将在10毫秒后自动失败。以下是一个 Eclipse 截图，显示了错误：
- en: '![Working with timeouts](img/00012.jpeg)'
  id: totrans-272
  prefs: []
  type: TYPE_IMG
  zh: '![处理超时](img/00012.jpeg)'
- en: Exploring JUnit theories
  id: totrans-273
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 探索 JUnit 理论
- en: A theory is a kind of a JUnit test but different from the typical example-based
    JUnit tests, where we assert a specific data set and expect a specific outcome.
    JUnit theories are an alternative to JUnit's parameterized tests. A JUnit theory
    encapsulates the tester's understanding of an object's universal behavior. This
    means whatever a theory asserts is expected to be true for all data sets. Theories
    are useful for finding bugs in boundary-value cases.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 理论是一种 JUnit 测试，但与典型的基于示例的 JUnit 测试不同，在典型的测试中，我们断言特定的数据集并期望特定的结果。JUnit 理论是 JUnit
    参数化测试的替代方案。JUnit 理论封装了测试者对对象通用行为的理解。这意味着理论断言的任何内容都应适用于所有数据集。理论对于在边界值情况下查找错误很有用。
- en: Parameterized tests allow us to write flexible data-driven tests and separate
    data from the test methods. Theories are similar to parameterized tests—both allow
    us to specify the test data outside of the test case.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 参数化测试允许我们编写灵活的数据驱动测试，并将数据与测试方法分离。理论类似于参数化测试——两者都允许我们在测试用例之外指定测试数据。
- en: 'Parameterized tests are good but they have the following drawbacks:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 参数化测试很好，但它们有以下缺点：
- en: Parameters are declared as member variables. They pollute the test class and
    unnecessarily make the system complex.
  id: totrans-277
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 参数被声明为成员变量。它们污染了测试类，并使系统变得不必要地复杂。
- en: Parameters need to be passed to the single constructor or variables need to
    be annotated, simply making the class incomprehensible.
  id: totrans-278
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 参数需要传递给单个构造函数或变量需要注解，这使类变得难以理解。
- en: Test data cannot be externalized.
  id: totrans-279
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试数据不能外部化。
- en: 'Theory comes up with many annotations and a runner class. Let''s examine the
    important annotations and classes in theory, as follows:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 理论提供了许多注解和一个运行器类。让我们检查理论中的重要注解和类，如下所示：
- en: '`@Theory`: Like `@Test`, this annotation identifies a theory test to run. The
    `@Test` annotation doesn''t work with a theory runner.'
  id: totrans-281
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@Theory`：与`@Test`类似，这个注解标识了一个要运行的理论测试。`@Test`注解与理论运行器不兼容。'
- en: '`@DataPoint`: This annotation identifies a single set of test data (similar
    to `@Parameters`), that is, either a static variable or a method.'
  id: totrans-282
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@DataPoint`：这个注解标识一组单个测试数据（类似于`@Parameters`），即静态变量或方法。'
- en: '`@DataPoints`: This annotation identifies multiple sets of test data, generally
    an array.'
  id: totrans-283
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@DataPoints`：这个注解标识多组测试数据，通常是一个数组。'
- en: '`@ParametersSuppliedBy`: This annotation provides the parameters to the test
    cases.'
  id: totrans-284
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@ParametersSuppliedBy`：这个注解为测试用例提供参数。'
- en: '`Theories`: This annotation is a JUnit runner for the theory-based test cases
    and extends `org.junit.runners.BlockJUnit4ClassRunner`.'
  id: totrans-285
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Theories`：这个注解是针对基于理论的测试用例的JUnit运行器，并扩展了`org.junit.runners.BlockJUnit4ClassRunner`。'
- en: '`ParameterSupplier`: This is an abstract class that gives us the handle on
    the parameters that we can supply to the test case.'
  id: totrans-286
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ParameterSupplier`：这是一个抽象类，它为我们提供了可以提供给测试用例的参数的句柄。'
- en: 'We will start with a simple theory and then explore more. Perform the following
    steps:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从简单的理论开始，然后探索更多。执行以下步骤：
- en: 'Create a `MyTheoryTest.java` class and annotate the class with `@RunWith(Theories.class)`.
    To run a theory, this special runner is required. Consider the following code:'
  id: totrans-288
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`MyTheoryTest.java`类，并用`@RunWith(Theories.class)`注解该类。要运行一个理论，需要这个特殊的运行器。考虑以下代码：
- en: '[PRE36]'
  id: totrans-289
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Now run the test. It will fail with the `java.lang.Exception: No runnable methods`
    error because no theory is defined yet. Like the `@Test` annotation, we will define
    a method and annotate it with `@Theory` as follows:'
  id: totrans-290
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '现在运行测试。它将因为`java.lang.Exception: No runnable methods`错误而失败，因为没有定义任何理论。像`@Test`注解一样，我们将定义一个方法并用`@Theory`注解它，如下所示：'
- en: '[PRE37]'
  id: totrans-291
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Run the theory, and it will be executed with no error. So, our theory setup
    is ready.
  id: totrans-292
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 运行理论，它将无错误地执行。因此，我们的理论设置已准备就绪。
- en: 'Define a `public static` `String` with a `name` variable and annotate this
    variable with `@DataPoint`. Now execute the test, nothing special happens. If
    a theory method (annotated with `@Theory`) takes an argument and a variable annotated
    with `@DataPoint` matches the type, then the variable is passed to the theory
    during execution. So, change the `sanity` method and add a `String` argument to
    pass `@DataPoint to the sanity()` method, as follows:'
  id: totrans-293
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个`public static` `String`类型的`name`变量，并用`@DataPoint`注解这个变量。现在执行测试，没有发生任何特别的事情。如果一个理论方法（用`@Theory`注解）接受一个参数，并且用`@DataPoint`注解的变量与该类型匹配，那么该变量将在执行期间传递给理论。因此，修改`sanity`方法并添加一个`String`参数以将`@DataPoint`传递给`sanity()`方法，如下所示：
- en: '[PRE38]'
  id: totrans-294
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Now run the theory. It will pass the `@DataPoint` name to the `sanity(String
    aName)` method during execution and the name will be printed to the console.
  id: totrans-295
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在运行理论。在执行过程中，它将`@DataPoint`名称传递给`sanity(String aName)`方法，并且名称将被打印到控制台。
- en: 'Now, add another static `@DataPoint`, call it `mike`, and rename the `name`
    variable to `jack`, as follows:'
  id: totrans-296
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，添加另一个静态的`@DataPoint`，命名为`mike`，并将`name`变量重命名为`jack`，如下所示：
- en: '[PRE39]'
  id: totrans-297
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'During theory execution, both the `@DataPoint` variables will be passed to
    the `sanity(String aName)` method. The output will be as follows:'
  id: totrans-298
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在理论执行期间，两个`@DataPoint`变量都将传递给`sanity(String aName)`方法。输出将如下所示：
- en: '![Exploring JUnit theories](img/00013.jpeg)'
  id: totrans-299
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![探索JUnit理论](img/00013.jpeg)'
- en: 'Now, slightly modify the `sanity()` method—rename the `aName` argument to `firstName`
    and add a second `String` argument, `lastName`. So now the `sanity` method takes
    the `String` arguments, `fistName` and `lastName`. Print these variables using
    the following code:'
  id: totrans-300
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，稍微修改一下`sanity()`方法——将`aName`参数重命名为`firstName`并添加第二个`String`参数，`lastName`。因此，现在`sanity`方法接受`String`参数`firstName`和`lastName`。使用以下代码打印这些变量：
- en: '[PRE40]'
  id: totrans-301
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'When executed, the output will be as follows:'
  id: totrans-302
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当执行时，输出将如下所示：
- en: '![Exploring JUnit theories](img/00014.jpeg)'
  id: totrans-303
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![探索JUnit理论](img/00014.jpeg)'
- en: So, 2 x 2 = 4 combinations are used. When the multiple `@DataPoint` annotations
    are defined in a test, the theories apply to all possible well-typed combinations
    of data points for the test arguments.
  id: totrans-304
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 因此，使用了2 x 2 = 4种组合。当在测试中定义多个`@DataPoint`注解时，理论适用于测试参数的所有可能的良好类型的数据点组合。
- en: 'So far we have only examined single-dimension variables. The `@DataPoints`
    annotation is used to provide a set of data. Add a static `char` array to hold
    the character variables and add a `Theory` method to accept two characters. It
    will execute the theory with 9 (3 ^ 2) possible combinations as follows:'
  id: totrans-305
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-306
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'The following is the output:'
  id: totrans-307
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Exploring JUnit theories](img/00015.jpeg)'
  id: totrans-308
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Externalizing data using @ParametersSuppliedBy and ParameterSupplier
  id: totrans-309
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'So far, we have covered how to set up test data using `@DataPoint` and `@DataPoints`.
    Now, we will use external classes to supply data in our tests using `@ParametersSuppliedBy`
    and `ParameterSupplier`. To do this, perform the following steps:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
- en: Create an `Adder.java` class. This class will have two overloaded `add()` methods
    to add numbers and strings. We will unit test the methods using theory.
  id: totrans-311
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The following is the `Adder` class:'
  id: totrans-312
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-313
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Create an `ExternalTheoryTest.java` theory as follows:'
  id: totrans-314
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-315
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'We will not use `@DataPoints` to create data. Instead, we will create a separate
    class to supply numbers to validate the `add` operation. JUnit provides a `ParameterSupplier`
    class for this purpose. `ParameterSupplier` is an abstract class, and it forces
    you to define a method as follows:'
  id: totrans-316
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-317
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '`PotentialAssignment` is an abstract class that JUnit theories use to provide
    test data to test methods in a consistent manner. It has a static `forValue` method
    that you can use to get an instance of `PotentialAssignment`.'
  id: totrans-318
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Create a `NumberSupplier` class to supply different types of numbers: `float`,
    `int`, `double`, `long`, and so on. Extend the `ParameterSupplier` class as follows:'
  id: totrans-319
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-320
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Check whether the overridden method creates a list of `PotentialAssignment`
    values of different numbers.
  id: totrans-321
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now, modify the theory to add two numbers. Add a theory method as follows:'
  id: totrans-322
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-323
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Check the `adds_numbers` method; two `Number` arguments `num1` and `num2` are
    annotated with `@ParametersSuppliedBy(NumberSupplier.class)`.
  id: totrans-324
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: When this theory is executed, the `NumberSupplier` class will pass a list.
  id: totrans-325
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Execute the theory; it will print the following result:![Externalizing data
    using @ParametersSuppliedBy and ParameterSupplier](img/00016.jpeg)
  id: totrans-326
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, we can check our `Adder` functionality. Modify the theory to assert the
    result.
  id: totrans-327
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create an instance of the `Adder` class and call the `add` method by passing
    `num1` and `num2`. Add the two numbers and `assert` the value with the results
    of `Adder`.
  id: totrans-328
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The `assertEquals(double, double)` method is deprecated as the double value
    calculation results in an unpredictable result. So, the `assert` class adds another
    version of `assertEquals` for `doubles`; it takes three arguments: actual, expected,
    and a delta. If the difference between the `actual` and the `expected` value is
    greater than or equal to delta, then the assertion passes as follows:'
  id: totrans-329
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-330
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'The `Adder` class has an `add` method for `String`. Create a `StringSupplier`
    class to supply `String` values to our theory and modify the theory class to verify
    the `add (String, String)` method behavior. You can assert the `Strings` as follows:'
  id: totrans-331
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`String expected = str1+str2;`'
  id: totrans-332
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`assertEquals(expected, actual);`'
  id: totrans-333
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Here, `str1` and `str2` are the two method arguments of the theory.
  id: totrans-334
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Dealing with JUnit rules
  id: totrans-335
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Rules allow very flexible addition or redefinition of the behavior of each test
    method in a test class. Rules are like **Aspect Oriented Programming** (**AOP**);
    we can do useful things before and/or after the actual test execution. You can
    find more information about AOP at [http://en.wikipedia.org/wiki/Aspect-oriented_programming](http://en.wikipedia.org/wiki/Aspect-oriented_programming).
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
- en: We can use the inbuilt rules or define our custom rule.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we will look at the inbuilt rules and create our custom Verifier
    and WatchMan rule.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
- en: Playing with the timeout rule
  id: totrans-339
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The timeout rule applies the same timeout to all the test methods in a class.
    Earlier, we used the timeout in the `@Test` annotation as follows:'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'The following is the syntax of the timeout rule:'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-343
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: When we run this test, it times out after 20 milliseconds. Note that the timeout
    is applied globally to all methods.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
- en: Working with the ExpectedException rule
  id: totrans-345
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `ExpectedException` rule is an important rule for handling exceptions. It
    allows you to assert the expected exception type and the exception message, for
    example, your code may throw a generic exception (such as `IllegalStateException`)
    for all failure conditions, but you can assert the generic exception message to
    verify the exact cause.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
- en: Earlier, we used `@Test(expected=Exception class)` to test the error conditions.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
- en: The `ExpectedException` rule allows in-test specification of expected exception
    types and messages.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code snippet explains how an exception rule can be used to verify
    the exception class and the exception message:'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  id: totrans-350
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: The `expect` object sets the expected exception class and `expectMessage` sets
    the expected message in the exception. If the message or exception class doesn't
    match the rule's expectation, the test fails. The `ExpectedException` object thrown
    is reset on each test.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
- en: Unfolding the TemporaryFolder rule
  id: totrans-352
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `TemporaryFolder` rule allows the creation of files and folders that are
    guaranteed to be deleted when the test method finishes (whether it passes or fails).
    Consider the following code:'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  id: totrans-354
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Exploring the ErrorCollector rule
  id: totrans-355
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `ErrorCollector` rule allows the execution of a test to continue after
    the first problem is found (for example, to collect all the incorrect rows in
    a table and report them all at once) as follows:'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  id: totrans-357
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: In this example, none of the verification passes but the test still finishes
    its execution, and at the end, notifies all errors.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is the log—the arrows indicate the errors—and also note that
    only one test method is being executed but Eclipse indicates three failures:'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
- en: '![Exploring the ErrorCollector rule](img/00017.jpeg)'
  id: totrans-360
  prefs: []
  type: TYPE_IMG
- en: Working with the Verifier rule
  id: totrans-361
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Verifier is a base class of `ErrorCollector`, which can otherwise turn passing
    tests into failing tests if a verification check fails. The following example
    demonstrates the `Verifier` rule:'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  id: totrans-363
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Verifier's `verify` method is executed after each test execution. If the `verify`
    method defines any assertions, and that assertion fails, then the test is marked
    as failed.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding example, the test should not fail as the test method doesn't
    perform any comparison; however, it still fails. It fails because the Verifier
    rule checks that after every test execution, the `errorMsg` string should be set
    as null, but the test method sets the value to `Giving a value`; hence, the verification
    fails.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
- en: Learning the TestWatcher rule
  id: totrans-366
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`TestWatcher` (and the deprecated `TestWatchman`) are base classes for rules
    that take note of the testing action, without modifying it. Consider the following
    code:'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  id: totrans-368
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: We created a `TestWatcher` class to listen to every test execution, collected
    the failure, and success instances, and at the end, printed the result in the
    `afterClass()` method.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is the error shown on the console:'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  id: totrans-371
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Working with the TestName rule
  id: totrans-372
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `TestName` rule makes the current test name available inside test methods.
    The `TestName` rule can be used in conjunction with the `TestWatcher` rule to
    make a unit testing framework compile a unit testing report.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
- en: 'The following test snippet shows that the test name is asserted inside the
    test:'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  id: totrans-375
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: The following section uses the `TestName` rule to get the method name before
    test execution.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
- en: Handling external resources
  id: totrans-377
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Sometimes JUnit tests need to communicate with external resources such as files
    or databases or server sockets. Dealing with external resources is always messy
    because you need to set up state and tear it down later. The `ExternalResource`
    rule provides a mechanism that makes resource handling a bit more convenient.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
- en: Previously, when you had to create files in a test case or work with server
    sockets, you had to set up a temporary directory, or open a socket in a `@Before`
    method and later delete the file or close the server in an `@After` method. But
    now, JUnit provides a simple AOP-like mechanism called the `ExternalResource`
    rule that makes this setup and cleanup work the responsibility of the resource.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example demonstrates the `ExternalResource` capabilities. The
    `Resource` class represents an external resource and prints the output in the
    console:'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  id: totrans-381
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'The following test class creates `ExternalResource` and handles the resource
    lifecycle:'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  id: totrans-383
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: The anonymous `ExternalResource` class overrides the `before` and `after` methods
    of the `ExternalResource` class. In the `before` method, it starts the resource
    and prints the test method name using the `TestName` rule. In the `after` method,
    it just closes the resource.
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is the test run output:'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  id: totrans-386
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: Note that the resource is opened before test execution and closed after the
    test. The test name is printed using the `TestName` rule.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
- en: Exploring JUnit categories
  id: totrans-388
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `Categories` runner runs only the classes and methods that are annotated
    with either the category given with the `@IncludeCategory` annotation or a subtype
    of that category. Either classes or interfaces can be used as categories. Subtyping
    works, so if you use `@IncludeCategory(SuperClass.class)`, a test marked `@Category({SubClass.class})`
    will be run.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
- en: We can exclude categories by using the `@ExcludeCategory` annotation.
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
- en: 'We can define two interfaces using the following code:'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  id: totrans-392
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: Summary
  id: totrans-393
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This JUnit refresher chapter covers both the basic and advanced usage of JUnit.
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
- en: The basic section covers the annotation based on JUnit 4 testing, assertion,
    the @RunWith annotation, exception handling, and the Eclipse setup for running
    the JUnit tests.
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
- en: The advanced section covers parameterized tests, matchers and `assertThat`,
    a custom `lessThanOrEqual()` matcher, assumption, theory, a custom NumberSupplier
    class, timeout, categories, TestName, ExpectedException, TemporaryFolder, ErrorCollector,
    Verifier and TestWatcher rules, test suites, and executing tests in order.
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
- en: By now, you will be able to write and execute JUnit 4 tests and be familiar
    with the advanced concepts of JUnit 4.
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
- en: '[Chapter 2](part0018_split_000.html#page "Chapter 2. Automating JUnit Tests"),
    *Automating JUnit Tests*, focuses on getting you quickly started with project-building
    tools and test automation. It provides an overview of continuous integration,
    explores the incremental Gradle build and Maven build lifecycle, Ant scripting,
    and Jenkins automation using Gradle, Maven, and Ant scripts.'
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
