- en: Making Use of the ProcessHandle API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we discovered the **Java Microbenchmark Harness** (**JMH**).
    We explored performance tests and how to write them using JMH, the Java library
    for writing benchmarks for the Java Virtual Machine. We started with an overview
    of microbenchmarking, then looked at microbenchmarking with Maven, reviewed benchmarking
    options, and concluded with techniques for avoiding microbenchmarking pitfalls.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will focus on the updates to the `Process` class and the
    new `java.lang.ProcessHandle` API. Prior to Java 9, managing processes in Java
    was never easy, because Java was rarely used to automate the controlling of other
    processes. The API was insufficient with some features lacking and some tasks
    needed to be solved in a system specific manner. For example, in Java 8, giving
    a process access to its own **process identifier** (**PID**) was an unnecessarily
    difficult task.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, the reader will gain all the knowledge that is needed to write
    an application that manages other processes and utilizes the modern process management
    API of Java.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will cover the following topics in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: What is and how to use the new `ProcessHandle` interface
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to get the PID of the current process
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to list different processes that run in the operating system
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to effectively wait for an external process to finish
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to terminate external processes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What are processes?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will review what processes are in the context of Java application
    programming. If you are already familiar with processes, you might consider skipping
    this section.
  prefs: []
  type: TYPE_NORMAL
- en: Processes are executional units in the operating system. When you start a program,
    you start a process. When the machine boots the code, the first thing it does
    is, execute the boot process. This process then starts other processes that become
    the child of the boot process. These child processes may start other processes.
    This way, when the machine runs there are trees of processes running. When the
    machine does something, it is done in some code executing inside some process.
    The operating system also runs as several processes that execute simultaneously.
    Applications are executed as one or more processes. Most of the applications run
    as a single process but as an example, the Chrome browser starts several processes
    to do all the rendering and network communication operations that finally function
    as a browser.
  prefs: []
  type: TYPE_NORMAL
- en: To get a better idea about what processes are, start the task manager on Windows
    or the Activity Monitor on OS X and click on the Process tab. You will see the
    different processes that currently exist on the machine. Using these tools, you
    can look at the parameters of the processes, or you can kill an individual process.
  prefs: []
  type: TYPE_NORMAL
- en: The individual processes have their memory allocated for their work and they
    are not allowed to freely access each other's memory.
  prefs: []
  type: TYPE_NORMAL
- en: The execution unit scheduled by the operating system is a thread. A process
    consists of one or more threads. These threads are scheduled by the operating
    system scheduler and are executed in time slots.
  prefs: []
  type: TYPE_NORMAL
- en: With every operating system, processes have a process identifier, which is a
    number that identifies the process. No two processes can be active at a time,
    sharing the same PID. When we want to identify an active process in the operating
    system we use the PID. On Linux and other Unix-like operating systems, the `kill`
    command terminates a process. The argument to be passed to this program is the
    PID of the process, to terminate. Termination can be graceful. It is something
    like asking the process to exit. If the process decides not to, it can keep running.
    Programs can be prepared to stop upon such requests. For example, a Java application
    may add a `Thread` object calling the `Runtime.getRuntime().addShutdownHook(Thread
    t)` method. The thread passed is supposed to start when the process is asked to
    stop and the thread can perform all tasks that the program has to do before it
    exits. However, there is no guarantee that it does start. It depends on the actual
    implementation.
  prefs: []
  type: TYPE_NORMAL
- en: The new ProcessHandle interface
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are two new interfaces and also their implementations in Java 9 supporting
    the handling of operating system processes. One of them is `ProcessHandle`, the
    other one is `ProcessHandle.Info`, a nested interface of the prior.
  prefs: []
  type: TYPE_NORMAL
- en: A `ProcessHandle` object identifies an operating system process and provides
    methods to manage the process. In prior versions of Java, this was possible only
    using operating system specific methods using the PID to identify the process.
    The major problem with this approach is that the PID is unique only while the
    process is active. When a process finishes, the operating system is free to reuse
    the PID for a new process. When we know only the PID of a process and check to
    see if the process is still running, what we are really doing is checking if there
    is an active process with that PID. Our process may be alive when we check it,
    but the next time our program queries the process state, it might be a different
    process.
  prefs: []
  type: TYPE_NORMAL
- en: The desktop and server operating systems try not to reuse the PID values for
    as long as possible. On some embedded systems the operating system may only use
    16-bit to store the PID. When only 16-bit values are used, there is a greater
    chance that the PIDs will be reused. We can avoid this problem using the `ProcessHandle`
    API. We can receive a `ProcessHandle` and can call the `handle.isAlive()` method.
    This method will return `false` when the process finishes. This works even if
    the PID was reused.
  prefs: []
  type: TYPE_NORMAL
- en: Getting the PID of the current process
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We can gain access to the PID of the processes via the handle. The `handle.getPid()`method
    returns a `Long` representing the numerical value of the PID. Since it is safer
    to access the processes through the handle, the importance of this method is limited.
    It may come in handy when our code wants to give information about itself to some
    other management tool. It is a common practice for programs to create a file that
    has the numeric PID as the name of the file. It may be a requirement that a certain
    program does not run in multiple processes. In that case, the code writes its
    own PID file to a specific directory. If a PID file with that name already exists,
    processing stops. If the previous process crashed and terminated without deleting
    the PID file, then the system manager can easily delete the file and start the
    new process. If the program hangs, then the system manager can easily kill the
    dead process if s/he knows the PID.
  prefs: []
  type: TYPE_NORMAL
- en: To get the PID of the current process, the call chain `ProcessHandle.current().
    getPid()` can be used.
  prefs: []
  type: TYPE_NORMAL
- en: Getting information about a process
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To get information about a process, we need access to the `Info` object of the
    process. This is available through a `ProcessHandle`. We use a call to the `handle.info()`
    method to return it.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Info` interface defines query methods that deliver information about the
    process. These are:'
  prefs: []
  type: TYPE_NORMAL
- en: '`command()` returns an `Optional<String>` containing the command that was used
    to start the process'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`arguments()` returns an `Optional<String[]>` that contains the arguments that
    were used on the command-line after the command to start the process'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`commandLine()` returns an `Optional<String>` that contains the whole command-line'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`startInstant()` returns an `Optional<Instant>`, which essentially represents
    the time the process was started'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`totalCpuDuration()` returns an `Optional<Duration>`, which represents the
    CPU time used by the process since it was started'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`user()` returns an `Optional<String>` that holds the name of the user the
    process belongs to'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The values returned by these methods are all `Optional` because there is no
    guarantee that the actual operating system or the Java implementation can return
    the information. However, on most operating systems it should work and the returned
    values should be present.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following sample code displays the information on a given process:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the console output for the preceding code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/01c7d993-eb46-489a-a822-2446f98f5f41.png)'
  prefs: []
  type: TYPE_IMG
- en: Listing processes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Prior to Java 9, we did not have the means to obtain a list of active processes.
    With Java 9 it is now possible to get the processes in a stream. There are three
    methods that return a `Stream<ProcessHandle>`. One lists the child processes.
    The other lists all the descendants; the children and the children of those recursively.
    The third lists all the processes.
  prefs: []
  type: TYPE_NORMAL
- en: Listing children
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To get the stream of process handles that can be used to control the children,
    the static method `processHandle.children()` should be used. This will create
    a snapshot of the children processes of the process represented by `processHandle`
    and create the `Stream`. Since processes are dynamic there is no guarantee that
    during the code execution, while our program attends to the handles, that all
    children processes are still active. Some of them may terminate and our process
    may spawn new children, perhaps from a different thread. Thus the code should
    not assume that each of the `ProcessHandle` elements of the stream represents
    an active and running process.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following program starts 10 command prompts in Windows and then counts
    the number of children processes and prints it to standard output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Executing the program will result in the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/428546ae-2d8a-4920-b3e9-2d9bc9857f80.png)'
  prefs: []
  type: TYPE_IMG
- en: Listing descendants
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Listing the descendants is very similar to listing children, but if we call
    the `processHandle.descendants()` method then the `Stream` will contain all the
    children processes and the children processes of those processes and so on. The
    following program starts command prompts with command-line arguments so that they
    also spawn another `cmd.exe` that terminates:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Running the command a few times will result in the following, non-deterministic
    output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/436363b5-24ff-40dd-85fe-8142b6a03b20.png)'
  prefs: []
  type: TYPE_IMG
- en: The output clearly demonstrates that when the `Stream` of the descendants is
    created not all processes are alive. The sample code starts 10 processes and each
    of them starts another. The `Stream` does not have 20 elements because some of
    these sub-processes were terminated during processing.
  prefs: []
  type: TYPE_NORMAL
- en: Listing all processes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Listing all the processes is slightly different from listing descendants and
    children. The method `allProcess()` is static and returns a `Stream` of handles
    of all processes that are active in the operating system at the time of execution.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following sample code prints the process commands to the console that seem
    to be Java processes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the program lists all the process commands that have the string
    `java` inside:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/54047251-3202-4d28-a69c-408420319f40.png)'
  prefs: []
  type: TYPE_IMG
- en: Your actual output may, of course, be different.
  prefs: []
  type: TYPE_NORMAL
- en: Waiting for processes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When a process starts another process, it may wait for the process many times
    because it needs the result of the other program. If the structure of the task
    can be organized in a way that the parent program can do something else while
    waiting for the child process to finish, then the parent process can invoke the
    `isAlive()` method on the process handle. Many times, the parent process has nothing
    to do until the spawned process finishes. Old applications implemented loops that
    called the `Thread.sleep()` method so CPU was not excessively wasted and from
    time to time the process was checked to see if it was still alive. Java 9 offers
    a much better approach to the waiting process.
  prefs: []
  type: TYPE_NORMAL
- en: The `ProcessHandle` interface has a method called `onExit` that returns a `CompletableFuture`.
    This class was introduced in Java 8 and makes it possible to wait for a task to
    be finished without looping. If we have the handle to a process we can simply
    call the `handle.onExit().join()` method to wait until the process finishes. The
    `get()` method of the returned `CompletableFuture` will return the `ProcessHandle`
    instance that was used to create it in the first place.
  prefs: []
  type: TYPE_NORMAL
- en: We can call the `onExit()` method on the handle many times and each time it
    will return a different `CompletableFuture` object, each related to the same process.
    We can call the `cancel()` method on the object but it will only cancel the `CompletableFuture`
    object and not the process and also does not have any effect on the other `CompletableFuture`
    objects that were created from the same `ProcessHandle` instance.
  prefs: []
  type: TYPE_NORMAL
- en: Terminating processes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To terminate a process we can call the `destroy()` method or the `destroyForcibly()`
    method on the `ProcessHandle` instance. Both of these methods will terminate the
    process. The `destroy()` method is expected to terminate the process gracefully
    executing the process shutdown sequence. In this case the shutdown hooks added
    to the run time are executed if the actual implementation supports the graceful,
    normal termination of processes. The `destroyForcibly()` method will enforce process
    termination, and in this case the shutdown sequence will not be executed.
  prefs: []
  type: TYPE_NORMAL
- en: If the process managed by the handle is not alive then nothing happens when
    the code calls any of these methods. If there are any `CompletableFuture` objects
    created calling the `onExit()` method on the handle then they will be completed
    after the call to the `destroy()` or `destroyForcefully()` method when the process
    has terminated. This means that the `CompletableFuture` object will return from
    a `join()` or some similar method after some time when the process termination
    is complete and not immediately after `destroy()` or `destroyForcefully()` returned.
  prefs: []
  type: TYPE_NORMAL
- en: It is also important to note that process termination may depend on many things.
    If the actual process that is waiting to terminate another does not have the right
    to terminate the other process then the request will fail. In this case the return
    value of the method is `false`. It is also important to understand that a return
    value of `true` does not mean that the process has actually terminated. It only
    means that the termination request was accepted by the operating system and that
    the operating system will terminate the process at some point in the future. This
    will actually happen rather soon, but not instantaneously and thus it should not
    be a surprise if the method `isAlive()` returns `true` for some time after the
    method `destroy()` or `destroyForcefully()` returned the value `true`.
  prefs: []
  type: TYPE_NORMAL
- en: The difference between `destroy()` and `destroyForcefully()` is implementation
    specific. The Java standard does not state that `destroy()` does terminate the
    process letting the shutdown sequence be executed. It only *requests the process
    be killed. Whether the process represented by this ProcessHandle object is* *normally
    terminated* *or not is implementation dependent* ([http://download.java.net/java/jdk9/docs/api/java/lang/ProcessHandle.html#supportsNormalTermination--](http://download.java.net/java/jdk9/docs/api/java/lang/ProcessHandle.html#supportsNormalTermination--))*.*
  prefs: []
  type: TYPE_NORMAL
- en: To learn more about `ProcessHandle` interface, visit [http://download.java.net/java/jdk9/docs/api/java/lang/ProcessHandle.html](http://download.java.net/java/jdk9/docs/api/java/lang/ProcessHandle.html).
  prefs: []
  type: TYPE_NORMAL
- en: This is because some operating systems do not implement the graceful process
    termination feature. In such situations, the implementation of `destroy()` is
    the same as calling `destroyForcefully()`.The system specific implementation of
    the interface `ProcessHandle` must implement the method `supportsNormalTermination()`
    that is `true` only if the implementation supports normal (not forceful) process
    termination. The method is expected to return the same value for all invocations
    in an actual implementation and should not change the return value during the
    execution of a JVM instance. There is no need to call the method multiple times.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following examples demonstrate process starting, process termination, and
    waiting for the process to terminate. In our example, we use two classes. This
    first class demonstrates the `.sleep()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The second class in our example calls the `WaitForChildToBeTerminated` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code starts 10 processes, each executing the program that sleeps
    `10` seconds. Then it forcibly destroys the processes, more specifically, the
    operating system is asked to destroy them. Our example joins the `CompletableFuture`
    that is composed from the array of `CompletableFuture` objects, which are created
    using the handles of the individual processes.
  prefs: []
  type: TYPE_NORMAL
- en: When all the processes are finished then it prints out the measured time in
    milliseconds. The time interval starts when the processes are created and the
    process creation loop finished. The end of the measured time interval is when
    the processes are recognized by the JVM returning from the `join()` method.
  prefs: []
  type: TYPE_NORMAL
- en: The sample code sets the sleeping time to 10 seconds. This is a more noticeable
    time period. Running the code twice and deleting the line that destroys the processes
    can result a much slower printout. Actually the measured and printed elapsed times
    will also show that terminating the processes has an effect.
  prefs: []
  type: TYPE_NORMAL
- en: A small process controller application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To summarize and put into use all that we have learned in this chapter we look
    at a sample process control application. The functionality of the application
    is very simple. It reads from a series of configuration file(s) parameters how
    to start some processes and then if any of them stops, it tries to restart the
    process.
  prefs: []
  type: TYPE_NORMAL
- en: Even a real life application can be created from this demo version. You can
    extend the set of parameters of the process with environment variable specifications.
    You can add default directory for the process, input and output redirection or
    even how much CPU a process is allowed to consume without the controlling application
    killing and restarting it.
  prefs: []
  type: TYPE_NORMAL
- en: The application consists of four classes.
  prefs: []
  type: TYPE_NORMAL
- en: '`Main`: This class that contains the public static void main method and is
    used to start up the daemon.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Parameters`: This class contains the configuration parameters for a process.
    In this simple case it will only contain one field, the `commandLine`. If the
    application gets extended this class will contain the default directory, the redirections,
    and CPU use limiting data.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ParamsAndHandle`: This class that is nothing else than a data tuple holding
    a reference to a `Parameters` object and also a process handle. When a process
    dies and gets restarted the process handle is replaced by the new handle, but
    the reference to the `Parameters` object never changes, it is configuration.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ControlDaemon`: This class implements the interface `Runnable` and is started
    as a separate thread.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the code we will use most of the process API we discussed in the previous
    sections, *Terminating processes* and we will use a lot of threading code and
    stream operations. Understanding the threading work of the JVM is important independent
    of the process management also. It has, however emphasized importance when used
    together with the process API.
  prefs: []
  type: TYPE_NORMAL
- en: Main class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The main method takes the name of the directory from the command line argument.
    It treats this as relative to the current working directory. It uses a separate
    method from the same class to read the set of configurations from the files in
    the directory and then starts the control daemon. The following code if the `main`
    method of the program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Although this is a daemon, we are starting it as a normal thread and not as
    a daemon thread. When a thread is set to be a daemon thread it will not keep the
    JVM alive. When all other non-daemon threads stop, the JVM will just exit and
    the daemon threads will be stopped. In our case, the daemon thread we execute
    is the only one that keeps the code running. After that was started the main thread
    has nothing more to do, but the JVM should stay alive, until it is killed by the
    operator issuing a Unix `kill` command or pressing *Control* + *C* on the command
    line.
  prefs: []
  type: TYPE_NORMAL
- en: 'Getting the list of the files that are in the directory specified and getting
    the parameters from the file is simple using the new `Files` and `Paths` classes
    from the JDK:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: We get a stream of the files in the form of `Path` objects, map it to `File`
    objects, then we filter out the directories if there are any in the configuration
    directory and map the remaining plain files to `Parameters` objects using the
    static method `fromFile` of the `Parameters` class. Finally, we return a `Set`
    of the objects.
  prefs: []
  type: TYPE_NORMAL
- en: Parameters class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Our `Parameters` class has a field and a constructor as listed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The parameter class has two methods. The first method, `getCommandLineStrings`,
    gets the command line strings from the properties. This array contains the command
    and the command line parameters. If it was not defined in the file then we return
    an empty array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The second method is the `static fromFile` that reads the properties from a
    properties file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: If the set of parameters handled by the program is extended then this class
    should also be modified.
  prefs: []
  type: TYPE_NORMAL
- en: The ParamsAndHandle class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `ParamsAndHandle` is a very simple class that holds two fields. One for
    the parameters and the other is the handle to the process handle that is used
    to access the process started using the parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Since the class is closely tied to the `ControlDaemon` class from where it is
    used there is no mutator or accessor associated with the field. We see the two
    classes as something inside the same encapsulation boundaries. The `toHandle`
    method is there so that we can use it as a method handle, as we will see in the
    next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: The ControlDaemon class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `ControlDaemon` class implements the `Runnable` interface and is started
    as a separate thread. The constructor gets the set of the parameters that were
    read from the properties files and converts them to a set of `ParamsAndHandle`
    objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Because the processes are not started at this point, the handles are all `null`.
    The `run()` method starts the processes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Processing goes through the set of parameters and uses the method (implemented
    in this class later) to start the processes. The handles to each process get to
    the `ParamsAndHandle` object. After that, the `keepProcessesAlive` method is called
    and waits for the processes to finish. When a process stops it gets restarted.
    If it cannot be restarted it will be removed from the set.
  prefs: []
  type: TYPE_NORMAL
- en: The `allMyProcesses` method (also implemented in this class) returns a `CompletableFuture`
    that gets completed when all the started processes have stopped. Some of the processes
    may have been restarted by the time the `join()` method returns. As long as there
    is at least one process running, the thread should run.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using the `CompletableFuture` to wait for the processes and the `while` loop,
    we use minimal CPU to keep the thread alive so long as long there is at least
    one process we manage running, presumably even after a few restarts. We have to
    keep this thread alive even if it does not use CPU and executes no code most of
    the time to let the `keepProcessesAlive()` method do its work using `CompletableFutures`.
    The method is shown in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The `keepProcessesAlive()` method calls the `anyOfMyProcesses()` method that
    returns a `CompletableFuture`, which is completed when any of the managed processes
    exits. The method schedules to execute the lambda passed as an argument to the
    `thenAccept()` method for the time the `CompletableFuture` is completed. The lambda
    does two things:'
  prefs: []
  type: TYPE_NORMAL
- en: Restarts the processes that are stopped (probably only one)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Calls the `keepProcessesAlive()` method
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is important to understand that this call is not performed from within the
    `keepProcessesAlive()` method itself. This is not a recursive call. This is scheduled
    as a `CompletableFuture` action. We are not implementing a loop in a recursive
    call, because we would run out of stack space. We ask the JVM executors to execute
    this method again when the processes are restarted.
  prefs: []
  type: TYPE_NORMAL
- en: It is important to know that the JVM uses the default `ForkJoinPool` to schedule
    these tasks and this pool contains daemon threads. That is the reason we have
    to wait and keep the method running because that is the only non-daemon thread
    that prevents the JVM from exiting.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next method is `restartProcesses()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: This method starts the processes that are in our set of managed processes and
    which are not alive. If any of the restarts fail it removes the failing processes
    from the set. (Be aware not to remove it in the loop to avoid `ConcurrentModificationException`.)
  prefs: []
  type: TYPE_NORMAL
- en: 'The `anyOfMyProcesses()` and `allMyProcesses()` methods are using the auxiliary
    `completableFuturesOfTheProcessesand()` method and are straight forward:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The `completableFuturesOfTheProcesses()` method returns an array of `CompletableFutures`
    created from the currently running managed processes calling their `onExit()`
    method. This is done in a compact and easy to read functional programming style,
    as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The set is converted to a `stream`, mapped to a `stream` of `ProcessHandle`
    objects (this is why we needed the `toHandle()` method in the `ParamsAndHandle`
    class). Then the handles are mapped to `CompletableFuture` stream using the `onExit()`
    method and finally we collect it to a list and convert to an array.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our last method to complete our sample application is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: This method starts the process using a `ProcessBuilder` and returns the `ProcessHandle`
    so that we can replace the old one in our set and manage the new process.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter we discussed how Java 9 better enables us to manage processes.
    Prior to Java 9, process management from within Java required OS specific implementations
    and was less than optimal in terms of CPU use and coding practice. The modern
    API, with new classes like `ProcessHandle,` makes it possible to handle almost
    all aspects of processes. We listed the new API, and had simple example codes
    for the use of each of them. In the second half of the chapter we put together
    a whole application managing processes where the learned API was put into practice.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will take a detailed look at the new Java Stack Walking
    API released with Java 9\. We will use code samples to illustrate how to use the
    API.
  prefs: []
  type: TYPE_NORMAL
