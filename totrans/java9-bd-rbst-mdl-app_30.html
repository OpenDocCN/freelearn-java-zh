<html><head></head><body><div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">What is Next?</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">At last, we have come to our final chapter together. We've built a number of different types of application, attempting to highlight and demonstrate different parts of the Java platform, especially those new to Java 9. As we've discussed, it's impossible to write something with <strong class="calibre8">only</strong> new-in-Java-9 technologies and APIs, so we also saw a variety of interesting items from Java 7 and 8. As Java 9 is finally shipping, it makes sense to look ahead to see what Java's future might hold for us, but it's also wise to look around and see what other languages are offering so that we can decide if our next Java will actually <strong class="calibre8">be</strong> Java. In this chapter, we'll do just that.</p>
<p class="mce-root">We will cover the following topics in this chapter:</p>
<ul class="calibre13">
<li class="calibre14">Recapping topics we previously covered</li>
<li class="calibre14">What we can expect in the future</li>
</ul>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Looking back</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">Before looking forward to Java 10 and beyond, let's quickly recap some of the things we've covered in this book:</p>
<ul class="calibre13">
<li class="calibre14">The Java Platform Module System, perhaps the largest, most anticipated addition to the platform in this release. We saw how to create a module and discussed its implications on the runtime system.</li>
<li class="calibre14">We walked through the new process management APIs in Java 9 and learned how to view processes, and even kill them, if needed.</li>
<li class="calibre14">We looked at some of the major functional interfaces introduced in Java 8, discussing how they could be used, and showing how code might look with and without the lambdas that these interfaces support.</li>
<li class="calibre14">We discussed Java 8's <kbd class="calibre16">Optional&lt;T&gt;</kbd> at length, showing how to create instances of the class, the various methods it exposes, and how one might use it.</li>
<li class="calibre14">We spent a good deal of time building JavaFX-based applications, demonstrating various tips and tricks, working around several <strong class="calibre3">gotchas</strong>, and so on.</li>
<li class="calibre14">Using the Java NIO File and Path APIs, we walked the filesystem, looking for duplicate files.</li>
<li class="calibre14">We implemented data persistence using the Java Persistence API, demonstrating how to use the API in a Java SE environment, how to define entities, and so on.</li>
<li class="calibre14">We built a calculator using the Java 8 Date/Time APIs, exposing the functionality as both a library and a command-line utility.</li>
<li class="calibre14">As part of that effort, we briefly compared a few command-line utility frameworks (specifically focusing on Crest and Airline), before settling on Crest and demonstrating how to create and consume command-line options.</li>
<li class="calibre14">While we didn't focus on it in every chapter, we did take a break to discuss and demonstrate unit testing.</li>
<li class="calibre14">We learned about <strong class="calibre3">Service Provider Interfaces</strong> (<strong class="calibre3">SPIs</strong>) as a means to provide multiple alternate implementations for an interface that can be loaded dynamically at runtime.</li>
<li class="calibre14">We implemented a couple of REST services, demonstrating not only the basic functionality of JAX-RS, how to deploy it in a Java SE environment, and POJO mapping, but also some more advanced features including server-sent events and securing endpoints using <kbd class="calibre16">Filter</kbd>.</li>
<li class="calibre14">We built a couple of Android applications and discussed and demonstrated activities, fragments, services, content providers, asynchronous messaging, and background tasks.</li>
<li class="calibre14">We saw OAuth2 authentication flows in action, including how to set up credentials using the Google OAuth provider and the Java code necessary to drive the process.</li>
<li class="calibre14">We discovered JSON Web Tokens, a cryptographically secure way to pass data back and forth between, for example, a client and a server, and saw their very basic use as part of an authentication system.</li>
<li class="calibre14">We toured the JavaMail API, learning a bit of the history and workings of common email protocols, such as POP3 and SMTP.</li>
<li class="calibre14">We learned about job scheduling using the Quartz scheduler library.</li>
<li class="calibre14">We saw how to specify constraints for our data in a declarative manner, then how to validate data in the light of those constraints using the Bean Validation API.</li>
<li class="calibre14">Changing gears completely, we built a moderately sophisticated application using the feature-rich NetBeans Rich Client Platform.</li>
<li class="calibre14">We looked briefly at world document databases with MongoDB.</li>
<li class="calibre14">And we learned about dependency injection and how to use it with the CDI specification.</li>
</ul>
<p class="mce-root">That's quite a list, and that doesn't cover all of it. One of the stated purposes of the book is to discuss and demonstrate the new features of Java 9. There are almost 100 <strong class="calibre8">Java Enhancement Proposals</strong> (<strong class="calibre8">JEPs</strong>) shipping with the release, making some of them difficult, at best, to demonstrate, but we've done our best.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Looking forward</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">With Java 9 done, then, the natural question is, <strong class="calibre8">What is next?</strong> As you might expect, the engineers at companies such as Oracle, Red Hat, IBM, Azul Systems, and others have been thinking about this question even while Java 9 was being planned and developed. While it is next to impossible to say what Java 10 will hold with any certainty (remember it took three major releases to get the module system done), we do have several items that are currently being discussed and designed, with the hope of shipping them in the next release. Over the next few pages, we'll explore some of these to get an early look at what our life as Java developers might be like in a couple of years.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Project Valhalla</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">Project Valhalla is an <em class="calibre20">incubation grounds for advanced language-VM co-development projects</em>. It is being led by Oracle engineer, Brian Goetz. As of this writing, there are three planned features for Valhalla. They are value types, generic specialization, and reified generics.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Value types</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">The goal of this effort is to update the Java Virtual Machine, and, if possible, the Java language, to support small, immutable, <strong class="calibre8">identity-less</strong> value types. Currently, if you instantiate a new <kbd class="calibre16">Object</kbd>, it is given an identifier by the JVM, which allows the <strong class="calibre8">variable</strong> instance to be referenced.</p>
<p class="mce-root">For example, if you create a new integer, <kbd class="calibre16">new Integer(42)</kbd>, a variable with the identity of <kbd class="calibre16">java.lang.Integer@68f29546</kbd>, but the value of <kbd class="calibre16">42</kbd>, the value of this variable will never change, and that's all we, as developers, typically care about. However, the JVM doesn't really know that, so it has to maintain the identity of the variable, with all of the overhead that entails. According to Goetz, that means every instance of this object will require up to 24 additional bytes to store the instance. If you have a large array of these, for example, that can be a significant amount of memory to manage and, eventually, to garbage-collect.</p>
<p class="mce-root">What the JVM engineers hope to achieve, then, is a way to <strong class="calibre8">gently extend</strong> the Java Virtual Machine byte code and the Java language itself to support the notion of a small, immutable aggregate type (think of a class with 0 or more properties) that lacks identity, which will result, it is hoped, in "memory-and locality-efficient programming idioms without sacrificing encapsulation". Their hope is that Java developers will be able to create these new types and treat them as just another primitive. If they do their jobs correctly, Goetz says, the feature can be summarized as <strong class="calibre8">Codes like a class, works like an int!</strong></p>
<p class="mce-root">The current proposal, as of April 2017 (<a href="http://cr.openjdk.java.net/~jrose/values/shady-values.html" class="pcalibre pcalibre3 pcalibre1 calibre12 pcalibre2"><span class="calibre5">http://cr.openjdk.java.net/~jrose/values/shady-values.html</span></a>), offers the following code snippet as an example of how one might define a value type:</p>
<pre class="calibre21">    @jvm.internal.value.DeriveValueType 
    public final class DoubleComplex { 
      public final double re, im; 
      private DoubleComplex(double re, double im) { 
        this.re = re; this.im = im; 
      } 
      ... // toString/equals/hashCode, accessors,<br class="calibre2"/>       math functions, etc. 
    } </pre>
<p class="mce-root">When instantiated, instances of this type could be created on the stack, rather than the heap, and use much less memory. This is a very low-level and technical discussion, which is far beyond the scope of this book, but if you are interested in more details, I would suggest reading the page linked earlier, or the effort's initial announcement at <a href="http://cr.openjdk.java.net/~jrose/values/values-0.html" class="pcalibre pcalibre3 pcalibre1 calibre12 pcalibre2"><span class="calibre5">http://cr.openjdk.java.net/~jrose/values/values-0.html</span></a>.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Generic specialization</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">Generic specialization is, perhaps, a bit easier to understand. Currently, generic type variables can hold only reference types. For example, you can create a <kbd class="calibre16">List&lt;Integer&gt;</kbd>, but not a <kbd class="calibre16">List&lt;int&gt;</kbd>. There are some pretty complex reasons why this is so, but being able to use primitives, and value types, would make collections more efficient in terms of memory and computation. You can read more about this feature in this document from, again, Brian Goetz--<a href="http://cr.openjdk.java.net/~briangoetz/valhalla/specialization.html" class="pcalibre pcalibre3 pcalibre1 calibre12 pcalibre2">http://cr.openjdk.java.net/~briangoetz/valhalla/specialization.html</a>. Jesper de Jong also has a good write-up about the complexities of primitives in generic type variables here:</p>
<p class="mce-root"><a href="http://www.jesperdj.com/2015/10/12/project-valhalla-generic-specialization/" class="pcalibre pcalibre3 pcalibre1 calibre12 pcalibre2"><span class="calibre5">http://www.jesperdj.com/2015/10/12/project-valhalla-generic-specialization/</span></a></p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Reified generics</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">The term <strong class="calibre8">reified generics</strong> is one that, more often than not, it seems, causes very vocal, animated reactions. Currently, if you declare a variable to be of type <kbd class="calibre16">List&lt;Integer&gt;</kbd>, the byte code generated has no real notion of the parameterized type, so it's not discoverable at runtime. If you were to examine the variable at runtime, you would see no mention of <kbd class="calibre16">Integer</kbd>. You could, of course, look at the types of each element, but, even then, you can't be sure of the type of the <kbd class="calibre16">List</kbd>, as there is nothing enforcing that <strong class="calibre8">only</strong> the <kbd class="calibre16">Integer</kbd> can be added to the <kbd class="calibre16">List</kbd>.</p>
<p class="mce-root">Java developers have been clamoring for reified generics, or, put simply, generics that retain their type information at runtime since generics were introduced in Java 5. As you might guess, making Java's generics reified is no trivial task, but, finally, we have a formal effort to see if it can be done and, if it can be done, to find a backwards-compatible way that doesn't have, for example, negative performance characteristics.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Project Panama</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">While not yet targeted for any particular Java release, Project Panama offers some hope for those who use, or hope to use, third-party, native libraries. Currently, the primary way of exposing native libraries (that is, OS-specific libraries written in, say, C or C++) to the JVM is via the <strong class="calibre8">Java Native Interface</strong> (<strong class="calibre8">JNI</strong>). The problem with JNI, or at least one of them, is that it requires that every Java programmer who wants to expose a native library to the JVM also become a C programmer, which means not only the C language itself, but also the related build tools for each supported platform.</p>
<p class="mce-root">Project Panama hopes to ameliorate that issue by offering the Java developer a new means of exposing native libraries without needing a deep understanding of the library language's ecosystem, or the JVM's. The JEP for Project Panama (<a href="http://openjdk.java.net/jeps/191" class="pcalibre pcalibre3 pcalibre1 calibre12 pcalibre2"><span class="calibre5">http://openjdk.java.net/jeps/191</span></a>) lists these design goals:</p>
<ul class="calibre13">
<li class="calibre14">A metadata system to describe native library calls (call protocol, argument list structure, argument types, return type) and the native memory structure (size, layout, typing, life cycle).</li>
<li class="calibre14">Mechanisms to discover and load native libraries. These capabilities may be provided by the current <kbd class="calibre16">System.loadLibrary</kbd> or may include additional enhancements for locating platform or version-specific binaries appropriate to the host system.</li>
<li class="calibre14">Mechanisms for binding, based on metadata, a given library/function coordinate to a Java endpoint, likely via a user-defined interface backed by plumbing to make the native downcall.</li>
<li class="calibre14">Mechanisms for binding, based on metadata, a specific memory structure (layout, endianness, logical types) to a Java endpoint, either via a user-defined interface or a user-defined class, in both cases backed by plumbing to manage a real block of native memory.</li>
<li class="calibre14">Appropriate support code to marshal Java data types to native data types and vice-versa. This will, in some cases, require the creation of FFI-specific types to support bit widths and numeric signs that Java can't represent.</li>
</ul>
<p class="mce-root">JNI has been available for quite some time, and it's finally getting some long overdue attention.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Project Amber</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">Project Amber's goal is to <strong class="calibre8">explore and incubate smaller, productivity-oriented Java language features</strong>. The current list includes local-variable type inference, enhanced enums, and lambda leftovers.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Local-Variable Type Inference</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">As we have seen countless times in this book alone, when you declare a variable in Java, you have to declare the type twice, once on the left-hand and once on the right-hand side, plus a variable name:</p>
<pre class="calibre21">    AtomicInteger atomicInt = new AtomicInteger(42); </pre>
<p class="mce-root">The problem here is that this code is verbose and repetitive. The Local-Variable Type Inference effort hopes to fix that, enabling something like this:</p>
<pre class="calibre21">    var atomicInt = new AtomicInteger(42); </pre>
<p class="mce-root">This code is more concise, making it more readable. Notice the addition of the <kbd class="calibre16">val</kbd> keyword. Typically, the compiler knows that a line of code, for example, is a variable declaration when it sees <kbd class="calibre16">&lt;type&gt; &lt;name&gt; = ...</kbd>. Since the effort would remove the need for a type on the left-hand side of the declaration, we need a cue for the compiler, which the authors of this JEP propose as <kbd class="calibre16">var</kbd>.</p>
<p class="mce-root">There is also some discussion around simplifying the declaration of immutable, or <kbd class="calibre16">final</kbd>, variables. Among the proposals are <kbd class="calibre16">final var</kbd> as well as <kbd class="calibre16">val</kbd>, as seen in other languages such as Scala. At the time of writing, no decision that has been made on which proposal will make the final cut.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Enhanced enums</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">Enhanced enums will augment <em class="calibre20">the expressiveness of the enum construct in the Java Language by allowing type-variables in enums (generic enums), and performing sharper type-checking for enum constants.</em> (<a href="http://openjdk.java.net/jeps/301" class="pcalibre pcalibre3 pcalibre1 calibre12 pcalibre2"><span class="calibre5">http://openjdk.java.net/jeps/301</span></a>). What this means is that enums will finally support a parameterized type, allowing something like this (taken from the JEP at the link mentioned previously):</p>
<pre class="calibre21">    enum Primitive&lt;X&gt; { 
      INT&lt;Integer&gt;(Integer.class, 0) { 
        int mod(int x, int y) { return x % y; } 
        int add(int x, int y) { return x + y; } 
      }, 
      FLOAT&lt;Float&gt;(Float.class, 0f)  { 
        long add(long x, long y) { return x + y; } 
      }, ... ; 
 
      final Class&lt;X&gt; boxClass; 
      final X defaultValue; 
 
      Primitive(Class&lt;X&gt; boxClass, X defaultValue) { 
        this.boxClass = boxClass; 
        this.defaultValue = defaultValue; 
      } 
    } </pre>
<p class="mce-root">Note that, in addition to specifying a generic type for each <kbd class="calibre16">enum</kbd> value, we can also define type-specific methods for each <kbd class="calibre16">enum</kbd> type. This will make it much easier to define a set of predefined constants, but also to define type-safe and type-aware methods for each of the constants.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Lambda leftovers</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">There are currently two items labeled as <kbd class="calibre16">leftovers</kbd> from the lambda work in Java 8. The first is the use of the underscore for unused parameters in lambda declarations. For example, in this very contrived example, all we care about are the <kbd class="calibre16">Map</kbd> values:</p>
<pre class="calibre21">    Map&lt;String, Integer&gt; numbers = new HashMap&lt;&gt;(); 
    numbers.forEach((k, v) -&gt; System.out.println(v*2)); </pre>
<p class="mce-root">That results in things like this in the IDE:</p>
<div class="mce-root1"><img class="image-border89" src="Images/53d98b02-af2f-406b-ad54-765bcbd59ee1.png" width="555" height="120"/></div>
<p class="mce-root">Once the use of the underscore is allowed, this code will look like this:</p>
<pre class="calibre21">    numbers.forEach((_, v) -&gt; System.out.println(v*2)); </pre>
<p class="mce-root">This allows better static checking of unused variables, allowing tools (and developers) to more easily identify such parameters and either correct or mark them.</p>
<p class="mce-root">The other leftover is allowing lambda parameters to shadow variables from the enclosing scope. If you were to try that now, you would get the same error if you tried to redefine a variable inside a statement block--<strong class="calibre8">variable is already defined</strong>:</p>
<pre class="calibre21">    Map&lt;String, Integer&gt; numbers = new HashMap&lt;&gt;(); 
    String key = someMethod(); 
    numbers.forEach((key, value) -&gt;  
      System.out.println(value*2)); // error </pre>
<p class="mce-root">With this change, the preceding code would compile and run just fine.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Looking around</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">The JVM has supported alternative languages for years. Some of the better known ones include Groovy and Scala. Both of these languages have influenced Java in one way or another over the years, but, like any language, they are not without their problems. Many feel that Groovy doesn't perform as well as Java (though the <kbd class="calibre16">invokedynamic</kbd> bytecode instruction is supposed to have addressed that), and many find Groovy's more dynamic nature less appealing. Scala, on the other hand, suffers (fairly or not, depending on who you ask) from the perception that it's too complex. Compilation time is also a common complaint. Also, many organizations are quite happily using both, so they are definitely worth considering to see if they will work in your environment and for your needs.</p>
<p class="mce-root">While those may be great languages, we are taking some time here to see what's next, and there are at least two languages that seem to stand out from the crowd--Ceylon and Kotlin. We can't give each of these languages an exhaustive treatment, but, over the next few pages, we'll take a quick look at the languages to see what they offer JVM developers now, and, perhaps, see how they might influence future changes to the Java language.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Ceylon</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">Ceylon, a language sponsored by Red Hat, first appeared around 2011. Led by Gavin King of the Hibernate and Seam Framework fame, the team set out to solve, at a language and library level, some of the pain points they had experienced over the years in developing their own frameworks and libraries. While they confess to being <strong class="calibre8">unapologetic fans</strong> of the Java language, they also readily acknowledge that the language is not perfect, especially with regard to some of the standard libraries, and aim to fix those flaws in Ceylon. The goals of the language include readability, predictability, toolability, modularity, and metaprogrammability (<a href="https://ceylon-lang.org/blog/2012/01/10/goals" class="pcalibre pcalibre3 pcalibre1 calibre12 pcalibre2"><span class="calibre5">https://ceylon-lang.org/blog/2012/01/10/goals</span></a>).</p>
<p class="mce-root">One of the biggest differences you are likely to notice when getting started with Ceylon is that the idea of modules is already baked into the language. In many ways, it looks very similar to Java 9's module declaration, which is as follows:</p>
<pre class="calibre21">    module com.example.foo "1.0" { 
      import com.example.bar "2.1"; 
    } </pre>
<p class="mce-root">There is, however, a very obvious difference--Ceylon modules <strong class="calibre8">do</strong> have version information, which allows various modules to depend on different versions of a module that may already be in the system.</p>
<p class="mce-root">There is at least one more rather significant difference between Ceylon and, say, Java--Ceylon has a build tool built in. While there is, for example, a Maven plugin, the preferred approach is to use Ceylon's native tooling to build and run the project:</p>
<pre class="calibre21">$ ceylonb new hello-world 
Enter project folder name [helloworld]: ceylon-helloworld 
Enter module name [com.example.helloworld]: 
Enter module version [1.0.0]: 
Would you like to generate Eclipse project files? (y/n) [y]: n 
Would you like to generate an ant build.xml? (y/n) [y]: n 
$ cd ceylon-helloworld 
$ ceylonb compile 
Note: Created module com.example.helloworld/1.0.0 
$ ceylonb run com.example.helloworld/1.0.0 
Hello, World! </pre>
<p class="mce-root">Other than the module system, what might Ceylon offer a Java developer? One of the more immediately useful and practical features is improved null-handling support. Just as we have to do in Java, we still have to check for null in Ceylon, but the language offers a much nicer approach, and it all starts with the type system.</p>
<p class="mce-root">One of the complaints about Scala (whether its truly warranted or not) is that the type system is too complicated. Regardless of whether or not you agree, it seems clear that there's certainly room for improvement over what Java offers (even the Java language architects agree as evidenced by, for example, the proposed local variable type inference proposal). Ceylon offers a very powerful addition to the type system--union types and intersection types.</p>
<p class="mce-root">Union types allow a variable to have more than one type, but only one at a time. Where this comes into play in discussing nulls is that <kbd class="calibre16">String? foo = ...</kbd> , which declares a variable of type <kbd class="calibre16">String</kbd> that is nullable, is actually the same as <kbd class="calibre16">String|Null foo = ...</kbd>.</p>
<p class="mce-root">This declares a variable, foo, whose type is either <kbd class="calibre16">String</kbd> or <kbd class="calibre16">Null</kbd>, but not both. The <kbd class="calibre16">?</kbd> syntax is just syntactic sugar over the union type declaration (<kbd class="calibre16">A | B</kbd> or <kbd class="calibre16">A</kbd> or <kbd class="calibre16">B</kbd>). If we have a method, then that takes this union type; we know that the variable is nullable, so we need to check it using the following code snippet:</p>
<pre class="calibre21">    void bar (String? Foo) { 
      if (exists foo) { 
        print (foo); 
      } 
    } </pre>
<p class="mce-root">Since this is a union type, we can also do this:</p>
<pre class="calibre21">    void bar (String? Foo) { 
      if (is String foo) { 
        print (foo); 
      } 
    } </pre>
<p class="mce-root">Note that, once we've tested with <kbd class="calibre16">exists</kbd> or <kbd class="calibre16">is</kbd>, we can assume that the variable is not null and is a <kbd class="calibre16">String</kbd>. The compiler won't complain, and we won't have an unexpected <kbd class="calibre16">NullPointerException</kbd> at runtime (they actually don't exist in Ceylon as the compiler requires that you be very explicit in your handling of nullable variables). This type of compiler awareness of null and type checks is called <strong class="calibre8">flow-sensitive</strong> typing. Once you've verified the type of something, the compiler knows and remembers, so to speak, the results of that check for that remainder of that scope so you can write cleaner, more concise code.</p>
<p class="mce-root">While union types are either A or B, intersection types are A <strong class="calibre8">and</strong> B. For a completely arbitrary example, let's say you have a method whose parameter must be, say, <kbd class="calibre16">Serializable</kbd> <strong class="calibre8">and</strong> <kbd class="calibre16">Closeable</kbd>. In Java, you'd have to check manually by writing the following lines of code:</p>
<pre class="calibre21">    public void someMethod (Object object) { 
      if (!(object instanceof Serializable) ||  
        !(object instanceof Closeable)) { 
        // throw Exception 
      } 
    } </pre>
<p class="mce-root">With intersection types, Ceylon would let us write this:</p>
<pre class="calibre21">    void someMethod(Serializable&amp;Closeable object) { 
      // ... 
    } </pre>
<p class="mce-root">If we try to call that method with something that doesn't implement <strong class="calibre8">both</strong> interfaces, or, say, extends one class and implements the other interfaces, then we get an error at <strong class="calibre8">compile time</strong>. That's very powerful.</p>
<p class="mce-root">Before adopting a new language, or even a library, in an enterprise, one often looks to see who else is using it. Are there notable adoption stories? Are there other companies confident enough in the technology to build a production system using it? Unfortunately, the Ceylon website (at the time of writing) is very thin on the details of adoption outside Red Hat, so it's hard to answer that question. However, Red Hat is spending a good deal of money designing the language and building tooling and a community around it, so it should be a safe bet. It is, of course, a decision your enterprise will have to make after careful consideration. You can find out more about Ceylon at <a href="https://ceylon-lang.org" class="pcalibre pcalibre3 pcalibre1 calibre12 pcalibre2"><span class="calibre5">https://ceylon-lang.org</span></a>.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Kotlin</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">Another up-and-coming language is Kotlin. It is a statically-typed language from JetBrains, the makers of IntelliJ IDEA, that targets both the JVM and Javascript. It even has nascent support to compile directly to machine code via LLVM for those environments, such as iOS, embedded systems, and so on, where a virtual machine is not desired or allowed.</p>
<p class="mce-root">Kotlin was started in 2010, and open sourced in 2012, as a means to address some common issues JetBrains was facing in large-scale Java development. Having surveyed the then-current language landscape, their engineers felt that none of those languages adequately addressed their concerns. Scala, considered for years now by many to be the <strong class="calibre8">next Java</strong>, was, for example, deemed to be too slow in compiling, despite having an acceptable feature set, so JetBrains began designing their own, eventually releasing 1.0 in February of 2016.</p>
<p class="mce-root">The design goals of the Kotlin team include expressiveness, scalability, and interoperability. They aim to allow developers to write less code that does more in a clearer fashion via language and library features, and in a language that is 100% interoperable with Java. They have added features such as coroutines to enable Kotlin-based systems to scale quickly and easily.</p>
<p class="mce-root">With all of that said, what does Kotlin look like and why should we, as Java developers, be interested? Let's start with variables.</p>
<p class="mce-root">As you'll recall, Java has both primitive (<kbd class="calibre16">int</kbd>, <kbd class="calibre16">double</kbd>, <kbd class="calibre16">float</kbd>, <kbd class="calibre16">char</kbd>, and so on) and reference, or <strong class="calibre8">wrapper</strong> types (<kbd class="calibre16">Integer</kbd>, <kbd class="calibre16">Double</kbd>, <kbd class="calibre16">Float</kbd>, <kbd class="calibre16">String</kbd>, and so on). As we've discussed in this chapter, the JVM engineers are working on ways to ameliorate some of the behavioral and capability differences this dichotomy brings. Kotlin avoids this altogether, as every value is an object, so there's no concern over <kbd class="calibre16">List&lt;int&gt;</kbd> versus <kbd class="calibre16">List&lt;Integer&gt;</kbd>.</p>
<p class="mce-root">Furthermore, Kotlin already supports local variable type inference, as well as immutablity. For example, consider the following Java code as an example:</p>
<pre class="calibre21">    Integer a = new Integer(1); 
    final String s = "This is a string literal"; </pre>
<p class="mce-root">The preceding lines of code could be written like this in Kotlin:</p>
<pre class="calibre21">    var a = 1; 
    val s = "This is a string literal"; </pre>
<p class="mce-root">Notice the use of the <kbd class="calibre16">var</kbd> and <kbd class="calibre16">val</kbd> keywords. As discussed earlier with regard to future Java language changes, these keywords allow us to declare mutable and immutable variables (respectively). Also notice that we need not declare the type of the variable, as the compiler handles that for us. In certain situations, we may need to explicitly declare the type, for example, in situations where the compiler might guess incorrectly or when it just does not have enough information to make a guess, at which point, it will stop compiling and present an error message. In those situations, we can declare the type this way:</p>
<pre class="calibre21">    var a: Int  = 1; 
    val s: String = "This is a string literal"; </pre>
<p class="mce-root">With Java 8, as we've seen, we have <kbd class="calibre16">Optional&lt;T&gt;</kbd> to help deal with null values. Kotlin has null support as well, but it's built into the language. By default, all variables in Kotlin are <strong class="calibre8">not</strong> nullable. That is to say, if the compiler can tell that you are attempting to assign a null value to a variable, or if it can't determine whether or not a value might be null (for example, a return value from a Java API), you'll get a compiler error. To indicate that a value is null-capable, you add a <kbd class="calibre16">?</kbd> to the variable declaration as follows:</p>
<pre class="calibre21">    var var1 : String = null; // error 
    var var2 : String? = null; // ok </pre>
<p class="mce-root">Kotlin also offers improved null-handling support in method calls. Suppose, for example, you want to get a user's city. In Java, you may do something like this:</p>
<pre class="calibre21">    String city = null; 
    User user = getUser(); 
    if (user != null) { 
      Address address = user.getAddress(); 
      if (address != null) { 
        city address.getCity(); 
      } 
    } </pre>
<p class="mce-root">In Kotlin, that can be expressed in a single line, as follows:</p>
<pre class="calibre21">    var city : String? = getUser()?.getAddress()?.getCity(); </pre>
<p class="mce-root">If, at any point, one of the methods returns null, the method call chain ends, and null is assigned to the variable city. Kotlin doesn't stop there with null handling. It provides, for an example, the <kbd class="calibre16">let</kbd> function that can serve as a shortcut for if-not-null checks. For example, consider the following lines of code:</p>
<pre class="calibre21">    if (city != null) { 
      System.out.println(city.toUpperCase()); 
    } </pre>
<p class="mce-root">The preceding lines of code become this in Kotlin:</p>
<pre class="calibre21">    city?.let { 
      println(city.toUpperCase()) 
    } </pre>
<p class="mce-root">This could, of course, be written as <kbd class="calibre16">city?.toUpperCase()</kbd>. What this should demonstrate, though, is the ability to safely use a nullable variable in an arbitrarily large, complex block of code. It's also worth noting that, inside the <kbd class="calibre16">let</kbd> block, the compiler knows that <kbd class="calibre16">city</kbd> is not null so no further null checks are necessary.</p>
<p class="mce-root">Hidden, perhaps, in the preceding example is Kotlin's support for lambdas, without which, it seems, no modern language is worth considering. Kotlin does, indeed, have full support for lambdas, higher order functions, underscores as lambda parameter names, and so on. Its support and syntax are very similar to Java's, so Java developers should be very comfortable with Kotlin's lambdas.</p>
<p class="mce-root">The big question is, of course, <strong class="calibre8">Is Kotlin ready for prime time?</strong> JetBrains definitely thinks so, as they have it in use in many of their applications, both internal and external. Other notable users include Pinterest, Gradle, Evernote, Uber, Pivotal, Atlassian, and Basecamp. Kotlin is even officially supported by Google (in Android Studio) for Android development, so it's definitely a production-grade language.</p>
<p class="mce-root">There's much, much more to this great new language, of course, and space won't allow us to discuss all of it, but you can browse through <a href="https://kotlinlang.org" class="pcalibre pcalibre3 pcalibre1 calibre12 pcalibre2"><span class="calibre5">https://kotlinlang.org</span></a> to learn more and see if Kotlin is a good fit for your organization.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">There is much more that can be discussed of course, about Java 10 and these two languages, and the myriad of other projects happening in and around the Java Virtual Machine. After over 20 years of development, Java--the language <strong class="calibre8">and</strong> the environment--is still going strong. In the pages of this book, I've tried to demonstrate some of these great advancements in the language, giving you a variety of starting points for your own projects, sample code to study and reuse, and explanations of various libraries, APIs, and technologies that may be helpful in your day-to-day work. I hope you've enjoyed the examples and explanations as much as I've enjoyed preparing them, and, more importantly, I hope they help you build the Next Big Thing.</p>
<p class="mce-root">Good luck!</p>


            </article>

            
        </section>
    </div>



  </body></html>