["```java\nnpm i npx. It executes the create-react-app React package directly.\nNow, let’s create an `ecomm-ui` application using the following command:\n\n```", "```java\n\nOnce it has been installed successfully, you can go to the app directory and start the installed application using `create-react-app` by running the following command:\n\n```", "```java\n\nThe `code .` command opens the `ecomm-ui` app project in VS Code. You can then use the following command in the terminal in VS Code to start the development server:\n\n```", "```java\n\n Once the server has started successfully, it will open a new tab on your default browser at `localhost:3000`, as shown in the following screenshot:\n![Figure 7.1 – Default UI app created by the create-react-app utility](img/Figure_07.1_B19349.jpg)\n\nFigure 7.1 – Default UI app created by the create-react-app utility\nOur bootstrapped React UI is up and running, but before you can build an e-commerce UI app on top of it, you need to understand the basic concepts and files generated by `create-react-app`.\nExploring the basic structures and files\nA scaffolded React app contains the following directories and files inside the root project directory:\n\n```", "```java\n\nLet’s understand the main parts, as follows:\n\n*   `node_modules`: You don’t need to make any changes here. Node-based applications keep a local copy of all the dependent packages here.\n*   `public`: This directory contains all the static assets of an app, including `index.html`, images, favicon icon, and `robots.txt`.\n*   `src`: This directory contains all the dynamic code, including React code and **Cascading Style Sheets** (**CSS**) (including **Syntactically Awesome Style Sheets** (**Sass**), **Leaner Style Sheets** (**Less**), and so on). It also contains the test code.\n*   `package.json`: This `scripts`), and dependent packages (inside `dependencies` and `dev-dependencies`).\n\nYou can remove the `serviceWorker.js` file (if generated), the `logo.svg` file, and test files from the `src` directory for now as we are not going to use them in this chapter.\nLet’s discuss the `package.json` file in the next subsection.\nUnderstanding the package.json file\nYou can also view the `package.json` file that contains all the dependencies under the `dependencies` and `dev-dependencies` fields. It is similar in nature to the `build.gradle` file.\nThe main React libraries are `react` and `react-dom`, mentioned in the dependencies field; these are for React and the VDOM, respectively.\n`package.json` also contains a script field that contains all the commands you can execute on this application. We have used the `yarn start` command to start the application in development mode. Similarly, you can execute other commands, as shown in the following code block, with `yarn` and `npm`:\n\n```", "```java\n\n`react-scripts` is a CLI package installed by the `create-react-app` utility. It contains many dependencies, a few of the primary ones of which are listed here:\n\n*   `webpack.config.js` configuration.\n*   **Jest** ([https://jestjs.io](https://jestjs.io)): Jest is a JavaScript testing framework maintained by Facebook.\n*   **ESLint** ([https://eslint.org](https://eslint.org)): ESLint is a linter that allows you to maintain code quality. It is very similar to *Checkstyle* in the Java world.\n*   **Babel** ([https://babeljs.io](https://babeljs.io)): Babel is a JavaScript transcompiler tool that converts JavaScript code to backward-compatible JavaScript code. The latest JavaScript draft version is **ECMAScript 2020**, also referred to as **ES10**. The latest JavaScript stable version is **ECMAScript 2018** (**ES9**). Babel allows you to generate optimized backward-compatible code from JavaScript code written using the latest versions.\n\nYou can find `react-scripts` under the `dependencies` field in `package.json`. Let’s understand each of these commands, as follows:\n\n*   `start`: This command allows you to start the development server in a node environment. It also provides the hot reload feature, which means any changes to the React code would be reflected in the application, without a restart being required. Therefore, if there are any linting or code issues, they will show up accordingly in the console (terminal window) and web browser.\n*   `build`: This command packages the React application code for production deployment. It does the bundling of the JavaScript files in one, the CSS files into another, and then minifies and optimizes the code files. You can then deploy this bundle on any web server.\n*   `test`: This command executes a test using the test runner (the Jest tool). It executes all test files with extensions such as `.test.js` or `.spec.js`.\n*   `eject`: React comes with default build configurations such as webpack, Babel, and so on. The build configuration has the best practices already implemented to optimize the built app. This `eject` command allows you to eject the hidden configuration, after which you can override and customize the build configuration. However, you should do this with the utmost care because this is a one-way activity, and you can’t reverse it.\n\nLet’s take a closer look at how React works in the next subsection.\nBootstrapping a React app\nA web page is nothing but an HTML document. HTML documents contain the DOM, a tree-like structure of HTML elements. Any changes to the DOM are reflected in the rendering of the HTML document in the browser. Making changes in the actual DOM— and, specifically to the nth level—is a heavy operation in terms of traversal and rendering the DOM, because each change is done on the whole DOM, and this is a time- and memory-consuming operation.\nReact uses a VDOM to make these operations lightweight. A VDOM is an in-memory copy of the actual DOM. React maintains the VDOM using the `react-dom` package. Therefore, when you initialize the React app, you first pass the root HTML `ID` element to the `ReactDOM` object’s `render` function. React writes the VDOM under this root element after its first render.\nAfter the first render, only the necessary changes are written to the actual DOM based on the changes in React components and their state. The React components’ `render` function returns the markup in JSX syntax. Then, React transforms it to HTML markup and compares the generated VDOM with the actual HTML DOM, and only makes the necessary changes to the actual DOM. This process then continues till the components get changed. Let’s explore how the first render takes place.\nThe `pubic/index.html` file contains the main HTML file. This is an application skeleton that contains the web app’s `title`, `meta` elements, and a `body` element. It also contains a `div` element (under `body`) with an `ID` as `root`. You pass this root element to the `render` function of `ReactDOM` in `index.js`, in the `src` directory. This is the entry point of the React app. Let’s have a look at its code, as follows:\n\n```", "```java\n\n[https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/dev/Chapter07/ecomm-ui/src/index.js](https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/dev/Chapter07/ecomm-ui/src/index.js)\nHere, React uses the `ReactDOM` object from the `react-dom` package to render the page. First it creates the root object by calling the `createRoot` method and passing the `root` element. The `document.getElementById('root')` method fetches `<div id= \"root\">` from inside the `<body>` element of `index.html`.\nThe `render()` function of the `root` object contains an argument: element of type `ReactNode`. You pass an `<App />` tag component wrapped with React’s strict mode component as an element argument.\nApp components can be a single component or a parent component with single or multilayer child components. A single component won’t contain any other React component; it simply contains the JSX, and that’s it. However, parent components may contain one or more child components, and those child components may contain one or more child components, and so on. For example, an `App` component may have `header`, `footer`, and `content` components. A `content` component may have a `cart` component, and then the `cart` component may have items inside it.\nA `<React.StrictMode>` component is a special React component that gets rendered twice in development mode to check for best practices, deprecated methods, and potential risks in your React components, and prints warnings and suggestions in the console log. It has no impact on the production build because it only works in development mode.\nThe `render()` function transforms the JSX of the `App` component to HTML and adds it inside the `<div id=\"root\">` tag, then it compares the VDOM with the real DOM and makes the necessary changes in the real DOM. This is how React components get rendered on the browser.\nYou now understand that React components are key here. Let’s deep dive into them in the next section.\nExploring React components and other features\nEach page in an app is built up using React components — for example, the **Product Listing** page of Amazon can broadly be divided into *Header*, *Footer*, *Content*, *Product List*, *Filter and Sorting options*, and *Product Card* components. You can create components in React in two ways: by using JavaScript classes or functions.\nLet’s create an example header component in React with both a function and a class.\nYou can either write a plain old JavaScript function or an `Header` component using a JavaScript arrow function:\n\n```", "```java\n\nLet’s create the same `Header` component using a JavaScript class, as follows:\n\n```", "```java\n\nLet’s understand both components point by point, as follows:\n\n*   Both return JSX that looks like HTML, which gets rendered after transformation (from JSX to HTML).\n*   Both export the function and class respectively so that they can be imported by other components.\n*   Both have props—one as an argument and one bound with this scope, which is part of `React.Component`. Props represent the attributes and their values—for example, here, a `title` attribute is used. When it gets rendered, it is replaced by the `title` attribute’s value.\n*   The class needs a `render()` function, whereas the function simply needs a `return` statement.\n\nLet’s see how the `Header` component could be used. You can use this `Header` component as you would use any other HTML tag in your JSX code, as shown next:\n\n```", "```java\n\n Here, `title` is the property of `Header` component. It describes how properties (props) of components are passed. When this `Header` component gets rendered, it will show the `title` value wrapped in an `<``H1>` element.\nLet’s explore the JSX next. This is how you use the `props`: you add an attribute (such as `title`) to its value while using the component. Inside the component, you can access these attributes (properties) by using `props` directly or using the `{ title }` de-structuring form in functional components and by using `this.props` in the class components.\nExploring JSX\nReact components would return the JSX. You can write HTML code to design the components because JSX is very similar to HTML, except for the HTML attributes. Therefore, you need to make sure to update attributes such as `class` to `className`, `for` to `htmlFor`, `fill-rule` to `fillRule`, and so on. The advantage of using the `React.StrictMode` component is that you get a warning and a suggestion to use the correct JSX attribute names if you use HTML attributes or have a typo.\nYou can also put any JavaScript expressions inside JSX or an element’s attributes to make the component dynamic by using the expression wrapped in curly braces (`{}`).\nLet’s have a look at some example code to understand both JSX and expressions. The following JSX code snippet has been taken from the `CartItem` component. Check out the highlighted code for expressions; the rest of the code is JSX, which is very similar to HTML:\n\n```", "```java\n\nThe preceding code fragment represents a cart item that shows the product image, product name, author, and `class` attribute name is changed to `className` because it is JSX. `Link` is a part of the `react-router-dom` library.\nYou are done with the cart item’s design part. Now, you need a mechanism to populate the values and add the event handling in it. This is where a JSX expression helps you.\nYou use `item` — an object that represents the cart item, and `author` — a variable that contains the author’s name. Both are part of the React component’s state. You will learn more about the state in the next subsection, but for the time being you can think of them as variables defined in the `CartItem` component. Once you write the JSX (read HTML), dynamic values (from variables) and interaction (for events) can be defined using the expressions wrapped inside curly braces (`{}`).\nLet’s understand each of the expressions as follows:\n\n*   `src={item?.imageUrl}`: You get the item (product) image URL as part of the API response. You simply assign it to the `src` attribute of the `img` tag. Note that the dot operator (`.`) allows you to access the property of an object. The code may throw an error if you try to read the property of any `null` or `undefined` object. You can avoid that by using the `?.` operator. Then, the property (in this case, `imageUrl`) will only be read if an object (in this case, `item`) is not `null` or `undefined`.\n*   `to={\"/products/\" + item.id}`: Here, links to an attribute are formed by using the object item’s `id` property.\n*   `{item?.name}`: Here, the name of the product is displayed using the name property of the `item` object.\n*   `Author: {author}`: The author value is displayed using the `author` variable.\n*   `onClick={() => removeItem(item.id)}`: This is the way you associate a user-defined function with an event. Here, `removeItem()` will be called by passing the item object’s `id` property on the click of a button. If you are not passing any argument or using multiple statements, then you can directly pass the function name instead of using the arrow function—for example, `onClick={removeItem}`.\n\nNext, we will deep dive into the state of React components. Let’s see how this works.\nUnderstanding React hooks\nComponents are dynamic and contain a state. The state represents the data and metadata held by the component at a given point in time. There are two levels of state: a global (app-level) state and a local (component-level) state.\nEarlier (prior to React version 16.8), the state was only supported in components defined using classes. Now, React supports the state in both functional and class components. React supports the state in functional components using `useState()`, `useContext()`, and so on.\nWhat are hooks?\nHooks are special React built-in functions or user-defined functions that can be stateful and are used to manage the side effects of React functional components. Popular and frequently used hooks are `useState()` and `useEffect()`.\nReact introduced hooks (a set of functions) in the 16.8 version, which introduced many features to functional components that were earlier not supported, including state and events such as `componentDidMount` (a lifecycle method in the class that indicates a component was mounted), and you can now perform certain operations such as loading data using APIs, among other things.\nLet’s discuss React hooks next.\nEach hook in React represents a special feature that you can use in functional components. Let’s discuss the most popular and common hooks one by one, as follows:\n\n*   `useState`: `useState()` allows you to define and maintain the state. Let’s examine how you use this hook. First, you import the `useState()` hook at the top of the component code file, as follows:\n\n    ```", "```java\n\nNext, inside your component’s arrow function code, define the state before the `return` statement, as shown next:\n\n```", "```java\n\n You need to define both state and state setter functions in an array while declaring the state. Here, the `total` state is defined with its setter function. You can use any type of state, such as an `object`, `array`, `string`, or `number`. The total state is of type `number`; therefore, it is initialized with `0`. `setTotal()` is a setter function. The setter function allows you to update the state (`total` here)—for example, you could update the total state by calling `setTotal(100)`, in which case the `total` state would be changed from `0` to `100`.\nReact tracks the state’s setter function and whenever it is called. React updates the state of the component and re-renders the component. The naming convention of the setter function is to prefix the state name with `set` and make the state’s first letter a capital letter. Therefore, we have used the `setTotal()` name for the `total` state. You’ll use `useState()` for local state management in most components.\n\n*   `useEffect`: You use a `useEffect()` hook when you want to do something after rendering a component. This gets called after each render. You can also use it when you want to load the initial data from an API or add an event listener. However, if an API call should be made once, then you can pass the empty array (`[]`) dependency while calling it. You’ll find multiple instances of `useEffect` in the `ecomm-ui` code when an empty array is passed for a single call.\n\nReact recommends using multiple `useEffect` functions inside components for separating the concern. Also, make sure it returns an arrow function for cleanup. For example, when you add the event listener for any component, it should return an arrow function that removes the event listener.\n\n*   `useContext`: You can pass props from one component to another. Sometimes, you must use props drilling to the nth level. React also provides an alternative way to define these props so that they can be used in any component in a tree without using prop drilling. You would use it for props that are common across components, such as `theme` or `isUserLoggedIn`.\n*   React provides a `createContext()` function to create a context. It returns a provider and consumer to provide access to its values and changes respectively (see the next code block). However, `useContext` can easily make use of the context by removing the usage of the consumer, which is returned by `createContext()`. The following code snippet depicts `useContext` usage:\n\n    ```", "```java\n\nYou can simplify the `ProductList` component’s `return` block in the previous code snippet (check the highlighted code) with `useContext`, as follows:\n\n```", "```java\n\nThis is how you can use `createContext` and `useContext` hooks.\n\n*   `useReducer`: This is an advanced version of the `useState` hook that not only allows you to use a component’s state but also provides better controls to manage its state by taking the `reducer` function as a first argument. It takes the initial state as a second argument. Check out its syntax, as seen in the following code block:\n\n    ```", "```java\n\nThe `reducer` function is a special function that takes state and action as arguments and returns a new state. We’ll explore this more when we build the `CartContext` component later in this chapter.\nNow that you have learned the basic concepts of React, let’s add some styling to the `ecomm-ui` application using Tailwind CSS.\nStyling components using Tailwind\n`npm`, as shown in the following command (executing it from the project root directory):\n\n```", "```java\n\n Here, version 3.2.7 of Tailwind CSS was installed.\nNext, let’s configure Tailwind CSS. The `npx tailwindcss init` command generates the Tailwind CSS configuration file with the default empty values:\n\n```", "```java\n\nThe previous command generates the following file:\n\n```", "```java\n\n[https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/blob/main/Chapter07/ecomm-ui/tailwind.config.js](https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/blob/main/Chapter07/ecomm-ui/tailwind.config.js)\nNow, we can modify the Tailwind CSS configuration to purge unused styles in production.\nConfiguration to remove unused styles in production\nYou would like to keep the style sheet size down in a production environment because this improves the performance of the application. You can purge unnecessary styles by adding the following filters to the `content` block of the `tailwind.config.js` file. Then, Tailwind can tree-shake unused styles while building the production build. Generated CSS files only contain the used styles in files matching the given filters. The code is illustrated in the following snippet:\n\n```", "```java\n\nNext, we will add Tailwind to React.\nIncluding Tailwind in React\nOpen the `src/index.css` file that `create-react-app` generates for you by default and import Tailwind’s `base`, `components`, and `utilities` styles, replacing the original file contents as follows:\n\n```", "```java\n\n[https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/dev/Chapter07/ecomm-ui/src/index.css](https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/dev/Chapter07/ecomm-ui/src/index.css)\nThese statements import the styles generated by the build based on the Tailwind configuration when you execute the build.\nFinally, make sure that the CSS file is imported in the `src/index.js` file, as shown in following code:\n\n```", "```java\n\nDone! Next, execute `yarn start` to use Tailwind CSS in the `ecomm-ui` app.\nHowever, before that, you are going to add the basic structure to your web app – the header, container (content), and footer.\nAdding basic structural React components\nBefore adding the `Header`, `Footer`, and `Container` components, you need to remove the following files created by `create-react-app`:\n\n*   `App.css`\n*   `logo.svg`\n\nDon’t forget to remove these file references from `/``src/App.js` too.\nThen, create a `components` directory under `/src`. You will create all new components under this directory, as shown in *Figure 7**.2*. Let’s create three new components, as follows:\n\n*   `Header`: This will be displayed at the top and contains header items such as the app name and **Login/Logout** button\n*   `Container`: This will contain the main content, such as the product list\n*   `Footer`: This will be displayed at the bottom and contains footer items such as the copyright information\n\nThe basic structure can be seen in the following screenshot:\n![Figure 7.2 – Basic structure of the app containing the Header, Footer, and Container components](img/Figure_07.2_B19349.jpg)\n\nFigure 7.2 – Basic structure of the app containing the Header, Footer, and Container components\nLet’s add these basic components. First, let’s create a `Header` component, as shown in the following code snippet:\n\n```", "```java\n\nSimilarly, create a `Footer` component, as shown in the following code snippet:\n\n```", "```java\n\nNext, create a `Container` component, as shown in the following code snippet:\n\n```", "```java\n\nAnd finally, modify the `/src/App.js` file as shown in the following code snippet:\n\n```", "```java\n\nThis is how you can create and use new components. These components are in their simplest form and are kept as such to be understood more easily. However, you can find refined and improved versions of these components on GitHub, as follows:\n\n*   *Header component* *source*: [https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/dev/Chapter07/ecomm-ui/src/components/Header.js](https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/dev/Chapter07/ecomm-ui/src/components/Header.js)\n*   *Footer component* *source*: [https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/dev/Chapter07/ecomm-ui/src/components/Footer.js](https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/dev/Chapter07/ecomm-ui/src/components/Footer.js)\n*   The `Container` component (which contains the actual content in the center) could be replaced with the `switch` component from `react-router-dom`, which would display the components based on a given `route`, such as `cart`, `orders`, and `login`.\n\nNow, you can start writing the actual `ecomm-ui` components next.\nDesigning the e-commerce app components\nDesign is not only a key part of UX and UI work, but is also important for frontend developers. Based on the design, you can create reusable and maintainable components. Our example e-commerce app is a simple application that does not need much attention. You will create the following components in this application:\n\n*   **Product listing component**: A component that displays all the products and acts as a home page. Each product in the list will be displayed as a card with the product name, price, and two buttons—**Buy now** and **Add to bag**. The following screenshot displays the **Product listing** page, which shows the product information along with an image of each product:\n\n![Figure 7.3 – Product listing page (home page)](img/Figure_07.3_B19349.jpg)\n\nFigure 7.3 – Product listing page (home page)\n\n*   **Product detail component**: This component displays the details of a product when clicked. It displays the product image, product name, product description, tags, and the **Buy now** and **Add to bag** buttons, as shown next:\n\n![Figure 7.4 – Product detail page](img/Figure_07.4_B19349.jpg)\n\nFigure 7.4 – Product detail page\n\n*   **Login component**: Login components allow a user to log in to an app by using their username and password, as illustrated in the following screenshot. This component displays an error message when a login attempt fails. Click on **Cancel** to go back to the **Product listing** page. The **Product listing** page shows a list of products a customer can buy.\n\n![Figure 7.5 – Login page](img/Figure_07.5_B19349.jpg)\n\nFigure 7.5 – Login page\n\n*   `Cart` component lists all the items that have been added to the cart. Each item displays the given product image, name, description, price, quantity, and total. It also provides a button to decrease or increase the quantity, and a button to remove the item from the cart.\n\n**Product name** is a link that takes the user back to the **Product detail** page. The **Continue** **shopping** button takes the user to the **Product listing** page. The **CHECKOUT** button performs the checkout process. On successful checkout, an order is generated and the user is redirected to the **Orders** page.\n![Figure 7.6 – Cart page](img/Figure_07.6_B19349.jpg)\n\nFigure 7.6 – Cart page\n\n*   **Orders component**: The **Orders** page shows all orders placed by the user in a tabular form. The **Orders** table displays the order date, ordered items, order status, and order amount for each order.\n\nThe order date will be displayed in the user’s local time, but on the server it will be in **Universal Coordinated Time** (**UTC**) format. Order items will be displayed in an order list, with their quantity and unit price in brackets, as illustrated in the following screenshot:\n![Figure 7.7 – Order page](img/Figure_07.7_B19349.jpg)\n\nFigure 7.7 – Order page\nLet’s start coding these components. First, you will code the **Product listing** page, which fetches the products from the backend server using the REST API.\nConsuming APIs using Fetch\nLet’s create the first component — that is, the `src/components` directory with the name `ProductList.js`. This is the parent component of the **Product** **Listing** page.\nThis component fetches the products from the backend server and passes them to the child component, `Products` (it creates a new `Products.js` file under the `src/components` directory).\n`Products` contains the logic responsible for looping through the fetched product list. Each iteration renders the card UI of each product. This product card component is represented using `ProductCard`, another component. Therefore, let’s create a `ProductCard.js` file, under `src/components`.\nYou can write the product card code inside `products` (`product list` component), but to single out the responsibilities, it’s better to create a new component.\nThe `ProductCard` component has a **Buy now** button and an **Add to bag** link. These links should only work if the user is logged in, else it should redirect the user to the login page.\nYou now have an idea about the **Product Listing** page component tree structure. Now, our first task is to have an API client that fetches products we can render in these components.\nWriting the product API client\nYou are going to use the `Fetch` browser built-in library as a REST API client. You can also use a third-party library such as `axios`. `Fetch` can do the job for this example app and reduce the number of third-party dependencies.\nYou can create a configuration file for API clients settings. Let’s name it `Config.js` and place it in the `src/api` directory.\n`Config` is a JavaScript class that contains constants such as URLs and common methods such as `DefaultHeaders()` and `tokenExpired()`. Check out its code in the following snippet:\n\n```", "```java\n\n[https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/dev/Chapter07/ecomm-ui/src/api/Config.js](https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/dev/Chapter07/ecomm-ui/src/api/Config.js)\nHere, you can see that we have created constants that are formed using environment variables. The `defaultHeaders()` function returns the common headers used in all API calls, and `headersWithAuthorization()` returns common headers with the `Authorization` header. `headersWithAuthorization()` uses object destruction to retrieve the default headers. The `Authorization` header is fetched from the local storage, which is set when a user is logged in successfully and is removed once the user logs out.\nIt also has a `tokenExpired()` function that simply checks the expiration time for a token stored in local storage. This expiration time is extracted from the access token (**JSON Web Token**, or **JWT**). It returns true if the expiration time is past the current time. Check out this function’s code in the following code snippet:\n\n```", "```java\n\nThe `Config` class also contains a `storeAccessToken()` function that simply stores the access token and expiration time in local storage. It uses a `getExpiration()` function to extract the expiration time from the access token. Put simply, this function first extracts the payload from the token string and then decodes the payload and converts it to JSON. Finally, it returns the expiration time if a payload is a valid object, else it returns `0`. You can find these functions in the following code block:\nRelevant code of src/api/Config.js\n\n```", "```java\n\nNext, let’s make use of this `Config` class in the `src/api/ProductClient.js` file, as shown in the following code block. This file will act as the API client for product-related APIs:\n\n```", "```java\n\n[https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/dev/Chapter07/ecomm-ui/src/api/ProductClient.js](https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/dev/Chapter07/ecomm-ui/src/api/ProductClient.js)\n`ProductClient` is a class, and a `config` instance is instantiated in its constructor. This class contains two asynchronous functions for fetching the products: `fetchList()` and `fetch()`. The former fetches all products, and the latter is for fetching a single product based on its ID. `fetchList()` makes use of the `fetch` browser function to fetch the product list. You pass the URL as the first argument input and request an initialization object that contains the HTTP method, mode, and headers as the second argument. The `fetch` browser call returns a promise that you use to handle the request. First, you resolve both the promises – the response and response JSON and then check `response.ok`. `response.ok` returns true for a status in the `200` to `299` range. Upon a successful response, the `fetchList()` method returns an object with `data` and `success` fields as `true`. Upon an unsuccessful response, it returns success as `false` and shows an error response in the `data` field.\nSimilarly, you can write a `fetch` function to retrieve the product by `ID`. Everything will be the same except the URL, as you can see in the following code block:\nRemaining code of src/api/ProductClient.js\n\n```", "```java\n\nHere, the `handleError()` function checks the type of the error (using `error. constructor`) and, based on that, returns the appropriate error message.\nPlease note that other API clients such as `CartClient`, `CustomerClient`, and `OrderClient` are developed in a similar fashion. The code is available at the following locations:\n\n*   `CartClient`: [https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/dev/Chapter07/ecomm-ui/src/api/CartClient.js](https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/dev/Chapter07/ecomm-ui/src/api/CartClient.js)\n*   `CustomerClient`: [https://github.com/PacktPublishing/Modern-API-Development-with-Spring-and-Spring-Boot/blob/main/Chapter07/ecomm-ui/src/api/CustomerClient.js](https://github.com/PacktPublishing/Modern-API-Development-with-Spring-and-Spring-Boot/blob/main/Chapter07/ecomm-ui/src/api/CustomerClient.js)\n*   `OrderClient`: [https://github.com/PacktPublishing/Modern-API-Development-with-Spring-and-Spring-Boot/blob/main/Chapter07/ecomm-ui/src/api/OrderClient.js](https://github.com/PacktPublishing/Modern-API-Development-with-Spring-and-Spring-Boot/blob/main/Chapter07/ecomm-ui/src/api/OrderClient.js)\n\nNow, we can use `ProductClient` to fetch the products from the backend using REST APIs. Let’s code the `ProductList` component and its child components.\nCoding the Product Listing page\n`ProductList` is a straightforward component that loads the products after their first render using `ProductClient`. You know that for this purpose, `useEffect` hooks should be used. Let’s code it as follows:\n\n```", "```java\n\n[https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/dev/Chapter07/ecomm-ui/src/components/ProductList.js](https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/dev/Chapter07/ecomm-ui/src/components/ProductList.js)\nThe `ProductList` component uses `auth` as a prop. It contains authentication information such as a token. The `ProductList` component is used as the main `App` component, and `auth` is passed to the `ProductList` component by it.\nPlease note that you have passed an empty array (`[]`) as a dependency to make sure that the API is called only once. You are using a `useState` hook to store the product list (`productList`) and message states (`noRecMsg`—no record) via setter methods.\nWhy does the cart need to be fetched in ProductList?\nThe `ProductList` component and its child components are available for non-authenticated users. Once the user clicks on the **Buy now** button or the **Add to bag** link, it will ask the user to log in. Once logged in, the user can add items to the cart. It is quite possible that the user might already have some items in the cart. Therefore, when you add an item to the cart, the quantity of existing products should be increased, and if a clicked item does not exist in the cart, then it should be added to the cart.\n`Cart` is a separate component altogether; this means you can’t access the cart unless you do cart prop drilling from the `App` component to both the `Cart` and `ProductCard` components or have a `useContext` hook for the cart. We have built a custom store to maintain the cart state, very similar to **Redux** (a library used to maintain the state in React app). We’ll learn more about this library later in this chapter. Dispatch is an action that updates the cart items received from the backend server to the cart context.\nNext, create a JSX template and pass the fetched `productList` component to the child component, `Products`, for further rendering, as illustrated in the following code snippet:\nRemaining code of src/components/ProductList.js\n\n```", "```java\n\nHere, it also passes the `auth` object as a prop to `Products`.\nLet’s have a look at the `Products` code, as follows:\n\n```", "```java\n\n[https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/dev/Chapter07/ecomm-ui/src/components/Products.js](https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/dev/Chapter07/ecomm-ui/src/components/Products.js)\nPut simply, the code does the job of iterating the product list passed by the `ProductList` component and passes each item with the `product` props to the `ProductCard` component along with the `auth` object.\nYou can observe the usage of two React concepts here, as follows:\n\n*   The code uses a `<></>` fragment, which is an empty tag. Ideally, this is used when a component returns more than one top-level tag because React needs only one top-level tag in each component. Then, you can wrap those tags with a fragment. You can also use `<React.Fragment>` in place of an empty tag after importing `React` from the `react` package.\n*   Another usage is for the `key` props in the `ProductCard` component. When you generate components based on a collection, React requires the `key` props to uniquely identify them. This will allow React to identify which item is changed, removed, or added. We have used the item ID here. If you don’t have an ID in your collection, you can also use the `index`, as shown in the following code example:\n\n    ```", "```java\n\nNow, let’s have a look at the last child component of the `ProductList` component: `ProductCard`. The `ProductCard` component simply passes `Product` values to JSX template expressions for rendering.\nWe have added some extra code to add the functionality associated with the **Add to bag** and **Buy now** click events.\nConfiguring routing\nYou are creating an SPA. Here, routing is not available by default. Routing is the mechanism that provides the routing to an SPA, which means that with each new page, the browser URL will reflect the change and allow you to bookmark the page. SPA routing also maintains the browser history. You are going to use the `react-router-dom` package for routing management. You need to add the `react-router-dom` package to use routing, as shown in the following code snippet. Make sure to execute it from the project root directory:\n\n```", "```java\n\n The routing will be configured in the `App` component because it is the `root` component of the `ecomm-ui` application. In the `ProductList` component, you are going to use the `Link` component and the `useNavigate()` hook from the `react-router-dom` package. Let’s examine them, as follows:\n\n*   `Link`: This is like a `<a>` HTML anchor tag. Instead of a `href` attribute, it uses a `to` attribute to link the URL. The `route` library maintains the links; therefore, it knows which component to render when a link is passed in with a `to` attribute when `Link` is clicked.\n*   `useNavigate()`: This allows navigation inside the component and accesses the state of the router. You would use the `navigate(\"/path\")` function if `navigate` is declared as `const navigate = useNavigate()` to navigate from one component to another, as shown in the `checkLogin()` function of the `ProductCard` component.\n\nLet’s continue with the development of the next product-based component: `ProductCard`.\nDeveloping the ProductCard component\nFirst, let’s import the required packages. Then, declare the state (using `useCartContext` and `useState`) and variables. Please note that the following code snippet has `auth` and `product` as props:\n\n```", "```java\n\n[https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/dev/Chapter07/ecomm-ui/src/components/ProductCard.js](https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/dev/Chapter07/ecomm-ui/src/components/ProductCard.js)\nTo begin, you write the `add()` asynchronous function that adds the product to the cart. It first checks whether the user is logged in or not. If not, it redirects the user to the login page. `checkLogin()` uses the `useNavigate` hook’s push method to redirect. The token property of `auth` is used to identify whether the user is logged in or not.\nOnce it has identified that the user is logged in, it calls the `callAddItemApi` function to add a product to the cart. The `callAddItemApi` function first finds out whether the product exists in the cart or not. If it exists, it finds out the quantity and adds one more to it. The `callAddItemApi` function then calls the REST API using the `CartClient` to add a new item or update the quantity in the existing cart item.\nFinally, the `add` function calls `dispatch` to update the state of `cartItems` in the cart context.\nThe following code snippet contains the same logic:\n// Continue code of src/components/ProductCard.js\n\n```", "```java\n\nHere, the `add` function is called when the `buy` function shown in the following code snippet will be called when the user clicks on the **Buy** **now** button:\n\n```", "```java\n\nHere, the `buy` function is very similar to the `add` function. Contrary to the `add` function, on a successful response from `callAddItemApi`, the `buy` function redirects the user to the cart page using a `useNavigate` hook instance.\nLet’s have a look at a JSX template. In the following code snippet, the `className` attribute values have been stripped for better readability:\n\n```", "```java\n\n[https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/dev/Chapter07/ecomm-ui/src/components/ProductCard.js](https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/dev/Chapter07/ecomm-ui/src/components/ProductCard.js)\nThe `onClick` event has been bound to `buy` and `add` for the `Link`. The `to` attribute of `Link` contains the path that points to the `ProductDetail` component. This path also contains the path parameter ID. You can use this parameter to perform certain operations on it. Similarly, you can also pass the query parameters the way you do in the browser URL.\nWhen the user clicks on the product name, the user is redirected to the `ProductDetail` component (`ProductDetail.js`). Let’s develop this next.\nDeveloping the ProductDetail component\nThe `ProductDetail` component is like the `ProductCard` component, except that it loads the product details from the backend by using the ID from the path.\nLet’s see how this is done. Only code related to the `Fetch` product has been shown in the following snippet. The rest of the code is the same as for the `ProductCard` component. However, you can refer to the full code in the GitHub repository:\n\n```", "```java\n\n[https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/dev/Chapter07/ecomm-ui/src/components/ProductDetail.js](https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/dev/Chapter07/ecomm-ui/src/components/ProductDetail.js)\nYou have used `useParams()` from the `react-router-dom` package to retrieve the product ID passed from the `ProductCard` component. This `id` property is then used to fetch the product from the backend server using the `ProductClient` component. Upon a successful response, the retrieved product detail is set in the state product using the `setProduct` state function.\nWe are done with the development of product-based components such as `ProductList`, `Products`, `ProductCard`, and `ProductDetail`. We will now focus on authentication functionality so that we can later work on the `cart` and `orders` components, which require an authenticated user.\nImplementing authentication\nBefore you jump into the `Login` component development, you will want to figure out how to manage a token received from a successful login response and how to make sure that if the access token has expired, then a refresh token request should be fired before making any call that requires authentication.\nThe browser allows you to store tokens or any other information in cookies, session storage, and local storage. From the server side, we haven’t opted for cookie or stateful communication, therefore we are left with the remaining two options. Session storage is preferable for more secure applications because it is specific to a given tab, and it gets cleared as soon as you click on the **Refresh** button or close the tab. We want to manage login persistence between different tabs and page refresh; therefore, we’ll opt for local storage of the browser.\nOn top of that, you can also store them in the state in the same way you will manage the cart state. However, this will be very similar to session storage. Let’s leave that option for now.\nCreating a custom useToken hook\nYou have now used different React hooks. Let’s move a step forward and create a custom hook. First, create a new `hooks` directory under the `src` directory, and create a `useToken.js` file in it.\nThen, add the following code to it:\n\n```", "```java\n\n[https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/dev/Chapter07/ecomm-ui/src/hooks/useToken.js](https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/dev/Chapter07/ecomm-ui/src/hooks/useToken.js)\nHere, you are using a `useState` hook to maintain the token state. The token state is initialized while declaring the token state by calling the `getToken` function in the constructor of `useState`. Now, you need to provide a mechanism that should update the initial token state whenever there is a change in action, such as login or logout. You can create a new function, `saveToken`, for this purpose.\nBoth the `getToken` and `saveToken` functions use `localStorage` to retrieve and update the token respectively. Finally, both the token state and the `saveToken` function (in the form of `setToken`) are returned for their usage.\nNext, you create another REST API client for authentication. Let’s add another client, `Auth.js` ([https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/dev/Chapter07/ecomm-ui/src/api/Auth.js](https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/dev/Chapter07/ecomm-ui/src/api/Auth.js)), in the `src/api` directory.\nThis `Auth.js` client is very similar to other API clients. It has three functions that perform the `login`, `logout`, and `refresh` access token operations by using the backend server REST APIs, outlined as follows:\n\n*   The login operation sets the access token, refresh token, user ID, and username in the `responseToken` key of the local storage by using the state arguments passed by the `App` component. The `App` component, as usual, uses the `useToken` custom hook. The login operation also sets the access token’s expiration time.\n*   The refresh access token operation updates the access token and its expiration time.\n*   The logout operation removes the tokens and sets the expiration time to zero.\n\nYou are done with the prerequisite work for implementing the login functionality and can now move on to creating the `Login` component.\nWriting the Login component\nLet’s create a new `Login.js` file under the `src/components` directory and then add the following code:\n\n```", "```java\n\n[https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/dev/Chapter07/ecomm-ui/src/components/Login.js](https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/dev/Chapter07/ecomm-ui/src/components/Login.js)\nBefore you start understanding the code, it’s useful to know that `PropTypes` provides a way to check the type of passed props. Here, we have made sure that the auth prop is an object and a required prop. You may see messages in the console if typing fails during argument passing or assignments. Normally, you add this `props` check at the end of a file (see bottom of the source code), but here it has been added at the top for better readability.\nThis component contains two props: `auth` and `uri`. The `auth` prop represents the authentication client, and `uri` is a string that sends the user back to the appropriate page after a successful login.\n`Login.js` has two functions: `handleSubmit` and `cancel`. The `cancel` function just sends the user back to the previous page or the home page. The `handleSubmit` function makes use of the authentication client and calls the login API with the username and password.\nThe `handleSubmit` function is called when a form is submitted (i.e., when the user clicks on the `cancel` function is called when the user clicks on the `username` and `password` states. These are set on `onChange` events respectively (refer to the `Login.js` code file on GitHub for truncated JSX content). The `e.target.value` argument represents the user input value in the input field. The `e` instance represents the event and `target` represents the target input field for the respective event.\nSo, now you know the complete flow: the user logs in and the app sets the required token and information in local storage. The API client uses this information to call the authenticated APIs. The `logout` operation, which is a part of the `Header` component ([https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/dev/Chapter07/ecomm-ui/src/components/Header.js](https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/dev/Chapter07/ecomm-ui/src/components/Header.js)), calls the Auth client’s `logout` function, which calls the remove refresh token backend server’s REST API and removes the authentication information from the local storage.\nAfter authentication implementation, you need to write one more piece of code before you jump to writing the `Cart` component: cart context. Let’s do that now.\nWriting the custom cart context\nYou can use the Redux library for centralizing and maintaining an application’s global state. However, you are going to use a Redux-like custom hook to maintain the state for the cart. This uses the `createContext`, `useReducer`, and `useContext` hooks from the React library.\nYou already know that `createContext` returns `Provider` and `Consumer`. Therefore, when you create a `CartContext` using `createContext`, it will provide `CartContext.Provider`. You won’t use `Consumer`, as you are going to use a `useContext` hook.\nNext, you need a cart state (`cartItems`) that you pass to the value in `CartContext.Provider` so that it will be available in the component that uses  `CartContext`. Now, we just need a `reducer` function. A `reducer` function accepts two arguments: `state` and `action`. Based on the provided action, it updates (mutates) the state and returns the updated state.\nNow, let’s jump into the code and see how it turns out. Have a look at the following snippet:\n\n```", "```java\n\n[https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/dev/Chapter07/ecomm-ui/src/hooks/CartContext.js](https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/dev/Chapter07/ecomm-ui/src/hooks/CartContext.js)\nFirst, you have created a `CartContext` with a `createContext` hook. Then, you have declared a function that uses a `useContext` hook and returns the value field’s value declared in the `CartContext.Provider` tag.\nNext, you need a `reducer` function that uses the action and state. Therefore, we first define action types such as `UPDATE_CART` and then write functions that return an action object that contains both the action type and argument value, such as `updateCart`. Finally, you can write a `reducer` function that takes `state` and `action` as arguments and, based on the passed action type, will mutate the state and return the updated state.\nNext, you define a `CartContextProvider` function that returns the `CartContext.Provider` component. Here, you use the reducer function in `useReducer` hook, and in its second argument, you pass the empty array as an initial state. The `useReducer` hook returns to the `state` and `dispatch` functions. The `dispatch` function takes the action object as an argument. You can use the function that returns the action object, such `updateCart` and `addItem`. You wrap the state (`cartItems`) and dispatcher function (`dispatch`) in the `cartData` object and pass it to the value attribute in the `CartContext.Provider` component. Finally, it exports both the `CartContextProvider` and `useCartContext` functions.\nYou are going to use `CartContextProvider` as a component wrapper in the `App` component. This makes `cartData` (`cartItems` and `dispatch`) available to all components inside `CartContextProvider`, which can be accessed and used via `useCartContext`.\nNow, finally, you can write the `Cart` component in the next subsection.\nWriting the Cart component\nThe `Cart` component is a parent component because it can have multiple items (`CartItem` components) in it. Let’s create a new `cart.js` file in the `src/components` directory and add the following code to it:\n\n```", "```java\n\n[https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/dev/Chapter07/ecomm-ui/src/components/Cart.js](https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/dev/Chapter07/ecomm-ui/src/components/Cart.js)\nHere, you used the `useCartContext` that was created in the previous subsection. You also use import functions such as `updateCart` that return the action object (consumed by the `dispatch` function). Apart from the `CartClient` Fetch-based API client, you also used `OrderClient` and `CustomerClient` here for cart checkout operations.\nLet’s add functions for calculating the total (`calTotal`) and increasing the quantity (`increaseQty`) of a given product ID, as shown next:\n\n```", "```java\n\nHere, the `increaseQty` function first finds whether the given ID exists among the cart items or not. If it exists, then it increases the quantity of a product by `1`. Finally, it calls the REST API to update the cart items and uses the response to update the cart by calling the `refreshCart` function.\nLet’s add a `decreaseQty` function, which is like `increaseQty` but rather decreases the quantity by one. Also, the `deleteItem` function will remove a given cart item from the cart. The code is shown in the following snippet:\n\n```", "```java\n\nHere, the `decreaseQty` function does one extra step in comparison to `increaseQty` — it removes the item if the existing quantity is `1` by calling the `deleteItem` function.\nThe `deleteItem` function first finds the product based on a given ID. If it exists, then it calls the REST API to remove the product from the cart and updates the cart item state by calling the `dispatch` function with the `action` object returned by the `removeItem` function.\nLet’s define the `refreshCart` and `useEffect` functions, as shown in the following code snippet:\n\n```", "```java\n\nThe `refreshCart` function updates the total and dispatches the `updateCart` action. `useEffect` loads the cart items from the backend server and calls `refreshCart` to update the `cartItems` global state.\nLet’s add the last function of the `Cart` component to perform the checkout operation, as shown in the following code snippet:\n\n```", "```java\n\n[https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/dev/Chapter07/ecomm-ui/src/components/Cart.js](https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/dev/Chapter07/ecomm-ui/src/components/Cart.js)\nHere, the `checkout` function first fetches the customer information and forms a payload for placing the order. On a successful `POST` order API response, the user is redirected to the `Orders` component.\nFinally, the `Cart` component returns a JSX template, which is taken from CodePen user `abdelrhman` .\nIn the JSX template, you will find that when the `CartItem` component that you create next. You pass the `removeItem`, `increaseQty`, and `decreaseQty` functions as props to it.\nLet’s write the `CartItem` component by creating a new file (`src/components/ CartItem.js`) and adding the following code:\n\n```", "```java\n\n[https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/dev/Chapter07/ecomm-ui/src/components/CartItem.js](https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/dev/Chapter07/ecomm-ui/src/components/CartItem.js)\nHere, you maintain the state of the total that is a product of the quantity and the unit price (`calTotal` function), and use the `updateQty` helper function to perform the increase or decrease quantity operations. The `useEffect` hook also calls `calTotal` to update the total on the **Cart** page.\nNow, you can write the last component (page) of this application in the next subsection: the `Order` component.\nWriting the Order component\nThe `Order` component contains the order details fetched from the backend server. It shows the date, status, amount, and items in a tabular format. It loads the order details on the first render with the `useEffect` hook and then the `orders` state is used in the JSX expression to display it.\nLet’s create a new file, `Orders.js`, in the `src/components` directory and add the following code to it:\n\n```", "```java\n\n[https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/dev/Chapter07/ecomm-ui/src/components/Orders.js](https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/dev/Chapter07/ecomm-ui/src/components/Orders.js)\nHere, the code is straightforward. It simply displays the information fetched from the `orders` state.\nNow, we can update the root component to complete the flow and test the application after starting it again with the `yarn` `start` command.\nWriting the root (App) component\nThe `App` component is a root component of the React application. It contains routing information and the application layout with all the parent components, such as the product list and orders components.\nUpdate the `App.js` file available in the project `src` directory with the following code:\n\n```", "```java\n\n[https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/dev/Chapter07/ecomm-ui/src/App.js](https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/dev/Chapter07/ecomm-ui/src/App.js)\nHere, the first `import` statement imports the required components from `react-router-dom`. There are other imports that you can check on the GitHub repository (the link is given at the bottom of the preceding code block). Then, the `useToken()` hook and the `Auth` authentication REST API client are used for authentication purposes. You create functions that return `loginComponent` and `productListComponent`.\nThe `App.js` JSX template is different from what we have used till now. It uses the `BrowserRouter` (`Router`), `Route`, and `Routes` components from the `react-router-dom` package. You define all the `Route` components inside the `BrowserRouter` component. Here, we are also using the `Routes` component because we want to render components exclusively. `Route` also allows you to render the `NotFound` component (the typical *404 – not found* page) if no path matches. The `Route` component allows you to define the path and component to be rendered. You used the `element` property to represent the component that you want to render based on the given `path`. The following code snippet contains the logic explained here:\n\n```", "```java\n\nAll components are wrapped inside `CartContextProvider` to allow `cartItems` and `dispatch` to be accessible in all components provided they use the `useCartContext` custom hook.\nYou are done with the major development work. Let’s run the code using the instructions given in the next section.\nRunning the application\nYou need a backend server for testing the UI because the UI fires REST APIs to get the data. You are going to use code from [*Chapter 6*](B19349_06.xhtml#_idTextAnchor148).\nGo to the home directory of the [*Chapter 6*](B19349_06.xhtml#_idTextAnchor148) code. You can build the code by running `gradlew clean build` from the root of the `Chapter06` project and run the backend using the following command:\n\n```", "```java\n\n Make sure to use Java 17 in the path.\nOnce the backend is up and running, you can open another terminal and start the `ecomm-ui` app by executing the following command from the `Chapter07/ecomm` project root directory:\n\n```", "```java\n\n If the application starts successfully, the UI will be accessible at `http://localhost:3000`. You can open `http://localhost:3000` in your favorite browser.\nOnce the product listing page loads, you can log in to the example e-commerce UI app with the username/password (`scott/tiger`) and perform all the operations such as checkout, orders, and so on.\nLet’s review what you have learned and summarize this chapter in the next section.\nSummary\nIn this chapter, you have learned some basic concepts of React and created different types of components using them. You have also learned how to use the browser’s built-in Fetch API to consume the REST APIs. You acquired the following skills in React: developing a component-based UI, implementing routing, consuming REST APIs, implementing functional components with hooks, writing custom hooks, and building a global state store with a React context API and a `useReducer` hook.\nThe concepts and skills you acquired in this chapter have laid a solid foundation for modern frontend development and advance you toward gaining a 360-degree perspective of application development.\nIn the next chapter, you will learn about writing automated tests for REST-based web services.\nQuestions\n\n1.  What is the difference between props and state?\n2.  What is an event and how can you bind events in a React component?\n3.  What is a higher-order component?\n\nAnswers\n\n1.  Props are special objects that you use to pass the values/objects/functions from the parent component to a child component, whereas state belongs to a component – it could be global or local to the component. From a functional component perspective, you use the `useState` hook for local state and `useContext` for global state.\n2.  In general, events are objects generated by the browser on input such as `keydown` or `onclick`. React uses `SyntheticEvent` to ensure that the browser’s native events work identically across all browsers. `SyntheticEvent` wraps on top of the native event. You used the `onChange={(e) => setUserName(e.target.value)}` code in the login component. Here, `e` is `SyntheticEvent` and `target` is one of its attributes. The `onChange` event is bound in JSX that calls `setUserName` when the input value is changed. You can also use the same JavaScript technique to bind events such as `window.` `addEventListener(\"click\", handleClick)`.\n\nIdeally, you would do this in the `useEffect` hook; however, the event should be removed as a part of the cleanup. That can also be done in `useEffect` when you return the arrow function that removes the binding, for example, `return () => { window. removeEventListener(\"click\", handleClick); }`. You can find this example in the `Header.js` file in the `src/components` directory.\n\n1.  In JavaScript, higher-order functions take a function as an argument and/or return a function, such as that of an array (map, filter, and so on). Similarly, in React, **higher-order components** (**HOCs**) are a pattern that involves the use of composition with an existing component and returns a new component. Basically, you write a new function that takes a component as an argument and returns it. An HOC allows you to reuse the existing component and its logic.\n\nIn the `ecomm-ui` application, the `ProductCard` and `ProductDetail` components are similar in nature, and you can use an HOC to reuse the logic.\nFurther reading\n\n*   *React 18* *Design Patterns and Best Practices - Fourth* *Edition*: [https://www.packtpub.com/product/react-18-design-patterns-and-best-practices-fourth-edition/9781803233109](https://www.packtpub.com/product/react-18-design-patterns-and-best-practices-fourth-edition/9781803233109)\n*   React documentation: [https://reactjs.org/docs/getting-started.html](https://reactjs.org/docs/getting-started.html)\n*   React Router guide: [https://reactrouter.com/en/main](https://reactrouter.com/en/main)\n\n```"]