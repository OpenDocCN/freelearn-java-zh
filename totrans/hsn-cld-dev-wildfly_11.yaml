- en: Adding Resilience Using Hystrix
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Hystrix增加弹性
- en: In this chapter, we will learn how to deal with network failures, which are
    inevitable in a distributed environment. In order to do that, we will introduce
    the **circuit breaker** architectural pattern and cover when it should be used,
    and what its benefits are. We will look at its Netflix implementation, **Hystrix**.
    We will also cover how it is implemented and how it can be used. As an example,
    we will use Hystrix to add resilience and fault tolerance to our sample application.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习如何处理分布式环境中不可避免的网络故障。为了做到这一点，我们将介绍**断路器**架构模式，并讨论何时应该使用它以及它的好处。我们将查看其Netflix实现，**Hystrix**。我们还将介绍其实现方式和如何使用它。作为一个例子，我们将使用Hystrix为我们的示例应用程序添加弹性和容错性。
- en: Unreliable network
  id: totrans-2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 不可靠的网络
- en: When you develop your services for distributed environments, you must take into
    consideration that invocations of the services will be performed over the network.
    As a result, the application must be prepared to deal with network failures, which
    will certainly happen.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在分布式环境中开发你的服务时，你必须考虑到服务的调用将通过网络进行。因此，应用程序必须准备好处理网络故障，这肯定会发生。
- en: This problem is further enhanced by the fact that a single misbehaving service
    can poison a large number of services. Let's take a look at the number of scenarios,
    that can make this possible.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 由于单个表现不佳的服务可以毒害大量服务，这个问题进一步加剧。让我们看看可能使这种情况成为可能的场景数量。
- en: Dependent services
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 依赖服务
- en: In large distributed systems, each service would have a large number of dependencies
    on other services. It requires only one dependency to fail to make the service
    irresponsible. Also, a service will go down too, becoming unavailable for other
    services that depend on it. Such a situation is known as cascading failures (Further
    reading, link 1).
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在大型分布式系统中，每个服务都会对其他服务有大量的依赖。只需要一个依赖失败，就会使服务变得不负责任。此外，服务也会崩溃，使其对依赖它的其他服务不可用。这种情况被称为级联故障（进一步阅读，链接1）。
- en: However, that's not all. In a production-ready environment when there are a
    lot of calls being performed, a service that has latency problems will quickly
    block all available threads and make all other services unreachable.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这还不是全部。在一个生产就绪的环境中，当有很多调用正在进行时，一个有延迟问题的服务会迅速阻塞所有可用的线程，并使所有其他服务不可达。
- en: Clearly, if we want to design a robust distributed system, we will need to have
    a tool that will enable users to deal with the problems described previously.
    The tool that we will use is the Hystrix library.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，如果我们想设计一个健壮的分布式系统，我们需要一个工具，该工具将使用户能够处理之前描述的问题。我们将使用的工具是Hystrix库。
- en: Hystrix is a library developed by Netflix to deal with service failures and
    to provide robustness for its sophisticated distributed architecture. Let's find
    out how Hystrix deals with the problems previously described.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: Hystrix是由Netflix开发的一个库，用于处理服务故障并为复杂的分布式架构提供鲁棒性。让我们来看看Hystrix是如何处理之前描述的问题的。
- en: The circuit breaker pattern
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 断路器模式
- en: 'The architectural design pattern created to deal with the problems described
    previously is the circuit breaker pattern. The main idea behind it is simple:
    wrap the invocation code into the command, which will perform the invocation,
    and calculate the status of the remote service. If the service is declared unreachable
    by the metrics used by the command, then the next invocations are rejected immediately.
    After a given time, new connections will be tried again, and, if successful, the
    command will start performing invocations to the service again.'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 为了处理之前描述的问题，创建的架构设计模式是断路器模式。其背后的主要思想很简单：将调用代码封装在命令中，该命令将执行调用并计算远程服务的状态。如果服务被命令使用的指标声明为不可达，则立即拒绝后续调用。在给定时间后，将再次尝试建立新的连接，如果成功，命令将再次开始对服务进行调用。
- en: The name of the pattern was taken from the electrical circuit breaker, a device
    used to protect the electrical circuit from the damage that may result from the
    excess electrical current. If the current in the circuit is too high then the
    circuit breaker opens, preventing the current from flowing. In order to make the
    circuit operate again, the circuit breaker has to be closed.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 该模式的名称来源于电路断路器，这是一种用于保护电路免受过电流可能造成的损害的设备。如果电路中的电流过高，则断路器打开，阻止电流流动。为了使电路再次运行，必须关闭断路器。
- en: Owing to its archetype, the software circuit breaker has inherited the electrical
    nomenclature. If the targeted service is healthy and the invocations are forwarded
    to it directly, we will be talking about closed breaker. If the health metrics
    are exceed, the invocations are not performed, and the circuit breaker will be
    opened.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 由于其原型，软件断路器继承了电气术语。如果目标服务是健康的，并且调用直接转发到它，我们将谈论闭合断路器。如果健康指标超过，调用将不会执行，断路器将打开。
- en: Obviously, the library that is responsible for the implementation of the circuit
    breaker has to provide algorithms that decide whether the remote service is healthy,
    how and when to open the circuit, and what to do if a circuit breaker is closed.
    Let's discuss how Hystrix does it.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，负责实现断路器的库必须提供算法来决定远程服务是否健康，何时以及如何打开电路，以及断路器关闭时应该做什么。让我们讨论一下Hystrix是如何做到这一点的。
- en: The Hystrix circuit breaker
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Hystrix断路器
- en: 'The following diagram presents the behavior of the Hystrix circuit breaker:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表展示了Hystrix断路器的行为：
- en: '![](img/e996a749-765d-456b-beb2-05277a18ce1f.png)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e996a749-765d-456b-beb2-05277a18ce1f.png)'
- en: During the invocation of the remote service, Hystrix checks whether the circuit
    breaker is open. This decision is made based on the statistics gathered from the
    recent invocations. If the percentage of failures in the last time window is lower
    than the configured threshold, then the circuit is open and the invocation is
    performed.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在调用远程服务期间，Hystrix检查断路器是否打开。这个决定是基于从最近调用中收集的统计数据做出的。如果最后时间窗口中的失败百分比低于配置的阈值，那么电路是打开的，调用将被执行。
- en: After the invocation is performed, the circuit breaker stores its result (success/failure)
    in the statistics. The statistics are gathered for the configured time window,
    which is further divided into the number of buckets, with only one bucket being
    discarded at a time so that the data for the given window is not discarded all
    at once.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在执行调用之后，断路器将它的结果（成功/失败）存储在统计数据中。这些统计数据是在配置的时间窗口内收集的，这个窗口进一步被分成多个桶，每次只丢弃一个桶，这样就不会一次性丢弃给定窗口内的所有数据。
- en: What happens when the circuit is open? Firstly, the algorithm checks whether
    the configured sleep time has passed. If it is the case, then only one request
    is allowed to be executed. This stage of a circuit breaker is called half-open
    and its purpose is to check whether the invoked service is healthy again. If the
    invocation succeeds, then a circuit breaker is opened again and the metrics are
    reset. If, on the other hand, the sleep time has not exceeded or the one invocation
    in a half-open state has failed, then the circuit breaker is opened again and
    the sleep time is reset.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 当电路打开时会发生什么？首先，算法检查配置的睡眠时间是否已经过去。如果是这样，那么只允许执行一个请求。这个断路器阶段被称为半开，其目的是检查被调用的服务是否再次健康。如果调用成功，那么断路器再次打开，并重置指标。另一方面，如果睡眠时间没有超过，或者半开状态中的一个调用失败了，那么断路器再次打开，并重置睡眠时间。
- en: So, we now know the Hystrix circuit breaker algorithm and how it reacts to statistics
    on successful and failed invocation. However, how do we actually define failure?
    There are three cases when the invocation is marked as failed. First, the configured
    invocation timeout has been exceeded. Second, the client library has thrown an
    exception. Third, the number of threads available for a given dependency has been
    exceeded.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们现在知道了Hystrix断路器算法以及它是如何对成功和失败的调用统计做出反应的。然而，我们实际上是如何定义失败的？当调用被标记为失败时，有三种情况。首先，配置的调用超时已经超过。其次，客户端库抛出了异常。第三，给定依赖项可用的线程数已超过。
- en: The last point is an implementation of the bulkheading algorithm. Let's learn
    more about it.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一点是大头板算法的实现。让我们更深入地了解它。
- en: Bulkheading
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 大头板
- en: In order to prevent a situation in which one of the dependencies uses the whole
    thread pool of an application, Hystrix keeps the thread pool for each dependency.
    If one of the dependencies becomes latent, it will keep all its threads busy and
    will reject further invocations, resulting in an increased failure count. Such
    a strategy is called **bulkheading**.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 为了防止依赖项之一使用应用程序的整个线程池的情况，Hystrix为每个依赖项保留线程池。如果其中一个依赖项变得迟钝，它将保持所有线程忙碌，并拒绝进一步的调用，从而导致失败计数增加。这种策略被称为**大头板**。
- en: 'This time, the nomenclature is taken from ship engineering: the hull of the
    ship is divided into isolated bulkheads so that the hull damage in one place results
    in only one bulkhead being filled with water. Similarly, providing a thread pool
    for each of the dependencies results in only a dedicated thread pool being used
    if one of the services is misbehaving.'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，术语来自船舶工程：船体被分成隔离的舱壁，以便一个地方的船体损坏只会导致一个舱壁被水填满。同样，为每个依赖项提供一个线程池，如果其中一个服务表现不佳，只会使用一个专门的线程池。
- en: In complex distributed environments, it is often the case that the application
    has many dependencies, each of which depends on other client libraries. Often,
    such libraries are black boxes provided by a third-party company, making them
    hard to debug. In addition, increasing the number of those libraries increases
    the risk that one of them will *poison* the whole application. With bulkheading,
    you can easily mitigate this risk.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在复杂的分布式环境中，通常应用程序有许多依赖项，每个依赖项都依赖于其他客户端库。通常，这些库是由第三方公司提供的黑盒库，这使得它们难以调试。此外，增加这些库的数量会增加其中一个库“毒害”整个应用程序的风险。通过隔离舱壁（bulkheading），你可以轻松地减轻这种风险。
- en: The state of each client can be easily tracked by the status of its thread pool.
    If monitoring shows that one of the thread pools is full, it is an indicator that
    it should be examined. If the underlying problem is fixed, the thread pool will
    clear up and the service will continue its operation.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 每个客户端的状态可以通过其线程池的状态轻松跟踪。如果监控显示某个线程池已满，这表明应该对其进行检查。如果底层问题得到解决，线程池将清理并继续服务的操作。
- en: The dependencies that share the same thread pool are configurable. As a result,
    you are able to tune bulkheading behavior according to your architecture. Such
    a configuration is done using Hystrix group mechanism, which we will show you
    in the examples later in this chapter.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 共享相同线程池的依赖项是可配置的。因此，你可以根据你的架构调整隔离舱壁的行为。这种配置是通过Hystrix分组机制完成的，我们将在本章后面的示例中向你展示。
- en: So, we already know that the invocation may fail or be forced to fail by Hystrix.
    But, what happens in that scenario? The mechanism that is supposed to deal with
    invocation failures is called **fallbacks**. Let's learn more about it now.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们已经知道调用可能会失败或被Hystrix强制失败。但在那种情况下会发生什么？处理调用失败机制的机制称为**备用**。现在让我们更深入地了解它。
- en: Fallbacks
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 备用
- en: Hystrix implements a fallbacks mechanism, which allows you to execute your code
    whenever the failure of the invocation happens. The command allows you to implement
    a fallback method, which will be executed during the failure. The method is executed
    regardless of the cause of the failure—the same method will be executed in case
    of timeout or thread pool overflow.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: Hystrix实现了一个备用机制，允许你在调用失败时执行你的代码。命令允许你实现一个备用方法，该方法将在失败时执行。该方法无论失败的原因如何都会执行——在超时或线程池溢出时都会执行相同的方法。
- en: The fallback method doesn't have to be implemented. If fallback is not implemented,
    the exception thrown by Hystrix will be propagated down the stack trace.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 备用方法不必实现。如果未实现备用，Hystrix抛出的异常将被传播到堆栈跟踪中。
- en: If, on the other hand, you decide to implement the fallback, you have a number
    of strategies for doing that. Let's take a look at a few examples.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 如果，另一方面，你决定实现备用，你有一系列策略可以这样做。让我们看看几个例子。
- en: If you are using a service that is used to read a data, you can return an empty
    answer in case of invocation failure. In such a scenario, no data will be available
    in case of service failure. This solution hides the underlying failure and immediately
    returns the response. The problem is, obviously, that the requested data is unavailable.
    You can deal with that by implementing the local cache and return the latest response
    in case of failure. In this scenario, the failure will be hidden and the data
    will be available. It won't be up to date for the time of failure, but it will
    allow your system to continue its operation.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在使用用于读取数据的服务的，在调用失败的情况下可以返回一个空答案。在这种情况下，如果服务失败，将没有数据可用。这种解决方案隐藏了底层失败并立即返回响应。问题是，显然，请求的数据不可用。你可以通过实现本地缓存并在失败的情况下返回最新的响应来处理这种情况。在这种情况下，失败将被隐藏，数据将可用。它可能不会在失败时是最新的，但它将允许你的系统继续其操作。
- en: Let's suppose now that you are using the authorization service to decide whether
    the user is authorized to perform some further operations. In this case, you can
    implement the fallback, which will always return the same response. However, what
    should this response be? As usual, it depends on your use case. In some scenarios,
    you may want to avoid a situation when a user who has paid for a service is unable
    to use it. In this scenario, you would return the successful authorization each
    time. The drawback is that a number of users will be able to use content that
    they haven't paid for at the time of authorization service failure. In other scenarios,
    you may need to deny authorization for all users. Surely the temporary allow-all
    strategy is not suitable for the bank application. In this case, you would have
    to deny the authorization for all users.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 假设现在你正在使用授权服务来决定用户是否有权执行一些进一步的操作。在这种情况下，你可以实现回退机制，该机制将始终返回相同的响应。然而，这个响应应该是什么？像往常一样，这取决于你的用例。在某些场景中，你可能想避免用户已经付费但无法使用服务的情况。在这种情况下，你将每次都返回成功的授权。缺点是，在授权服务失败时，许多用户将能够使用他们当时未付费的内容。在其他场景中，你可能需要拒绝所有用户的授权。当然，临时的允许所有策略并不适合银行应用程序。在这种情况下，你必须拒绝所有用户的授权。
- en: 'Finally, in some scenarios, not writing the fallback is a good strategy. Let''s
    suppose that you are implementing an invocation that is supposed to modify some
    data as a part of transactional operations. In this scenario, the propagated exception
    is the strategy that we want: the whole operation will be stopped, and the exception
    will be propagated to the transaction manager, which will roll back the transaction.'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在某些场景中，不编写回退是一种好的策略。假设你正在实现一个调用，该调用应作为事务操作的一部分修改某些数据。在这种情况下，传播的异常是我们想要的策略：整个操作将停止，异常将被传播到事务管理器，这将回滚事务。
- en: In this section, we have only hinted at a number of possible fallback implementation
    strategies. As you may have noticed, the specific implementation (or lack of)
    depends directly on your service's business requirements. The key point to remember
    is that Hystrix won't allow the network failure to compromise the behavior of
    your application, and if a failure occurs it will allow you to deal with it using
    the fallback mechanism.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们只简要介绍了许多可能的回退实现策略。正如你可能已经注意到的，具体的实现（或缺乏）直接取决于你的服务业务需求。要记住的关键点是，Hystrix不会允许网络故障损害你应用程序的行为，如果发生故障，它将允许你使用回退机制来处理它。
- en: The whole algorithm
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 整个算法
- en: 'Finally, we are ready to sum up the behavior of the Hystrix library:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们准备总结Hystrix库的行为：
- en: '![](img/59d5a430-7e6f-4c83-b2c5-bf683668b833.png)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/59d5a430-7e6f-4c83-b2c5-bf683668b833.png)'
- en: At the beginning, the user constructs the command and starts its execution.
    Hystrix checks whether the circuit breaker associated with this command is closed.
    If the circuit breaker is open, then the invocation will be rejected immediately
    and the fallback will be executed (if implemented). If the circuit breaker is
    closed, then the thread-pool is checked. If there are no available threads in
    the thread-pool, then the invocation fails; optionally, the fallback is executed
    and the failure is reported to the circuit breaker. If, on the other hand, there
    are threads available, then the invocation starts. If the invocation misses its
    timeout, then the failure is reported to the circuit breaker and the optional
    fallback is executed.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始时，用户构建命令并启动其执行。Hystrix检查与此命令关联的断路器是否关闭。如果断路器是打开的，那么调用将立即被拒绝，并执行回退（如果已实现）。如果断路器是关闭的，那么将检查线程池。如果没有可用的线程在线程池中，那么调用将失败；可选地执行回退并将失败报告给断路器。另一方面，如果有可用的线程，那么调用开始。如果调用错过了超时，那么错误会被报告给断路器，并可选地执行回退。
- en: In this scenario, the thread may be blocked. Hystrix will time it out, but will
    have to wait for the client library to *return the thread*. If the invocation
    finishes and fails, then the failure is reported to the circuit breaker and optionally
    the fallback is executed.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种场景中，线程可能会被阻塞。Hystrix会超时，但必须等待客户端库*返回线程*。如果调用完成并失败，那么错误会被报告给断路器，并且可以选择执行回退。
- en: Finally, if the execution succeeds, then the success is reported to the circuit
    breaker and the response is returned as the result of the command execution.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，如果执行成功，则将成功报告给断路器，并将响应作为命令执行的结果返回。
- en: You have already learned the basics of the Hystrix's circuit breaker implementation.
    Now it is time to learn its basic API, which we will use later in this chapter.
    Let's do it now.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 您已经学习了 Hystrix 断路器实现的基础知识。现在是时候学习其基本 API 了，我们将在本章后面使用它。让我们现在就来做。
- en: Using Hystrix
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Hystrix
- en: In order to learn Hystrix behavior in practice, we are going to extend customer-gateway
    service so that it uses Hystrix for its invocations. Later, we are going to make
    one of our services artificially unresponsive and see how Hystrix behaves. Let's
    start.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在实践中学习 Hystrix 的行为，我们将扩展客户网关服务，使其调用时使用 Hystrix。稍后，我们将使我们的其中一个服务人工无响应，并观察 Hystrix
    的行为。让我们开始吧。
- en: 'Examples reference: `chapter11/customer-gateway-hystrix`.'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 示例参考：`chapter11/customer-gateway-hystrix`。
- en: 'Firstly, we are going to add Hystrix dependency to the `pom.xml`:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将向 `pom.xml` 中添加 Hystrix 依赖项：
- en: '[PRE0]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The circuit breaker command is implemented by extending the `com.netflix.hystrix.HystrixCommand`
    class. Let''s take a look at its usage at the concrete example of our `PricingProxy`:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 断路器命令是通过扩展 `com.netflix.hystrix.HystrixCommand` 类实现的。让我们看看我们的 `PricingProxy`
    的具体示例中的使用情况：
- en: '[PRE1]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The command has to extend the abstract `HystrixCommand` class (1). The class
    has to be parameterized with a type that will be returned as the command result.
    In our example, it will be the JAX-RS response class—the same as we used in our
    raw invocation.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 命令必须扩展抽象类 `HystrixCommand`（1）。该类必须使用一个类型参数化，该类型将作为命令结果返回。在我们的例子中，它将是 JAX-RS
    响应类——与我们用于原始调用的相同。
- en: The class takes the itemId parameter as an argument (2), which will be used
    in the invocation.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 该类将 itemId 参数作为参数（2），该参数将在调用中使用。
- en: 'As you can see in the constructor code, we have provided `HystrixCommandGroupKey`
    parameter to it (3). `HystrixCommand` constructors allow you to provide a combination
    of three arguments: `HystrixCommandGroupKey`, `HystrixThreadPoolKey`, and the
    timeout. The two enum parameters are used for command grouping: the commands with
    the same group key will belong to the same group and will be grouped together
    for the purpose of reporting, alerting, and monitoring. The thread pool key specifies
    the commands that belong to the same Hystrix thread pool used by the bulkhead
    algorithm. When the thread pool key is not enabled, the group key is used as the
    thread pool identifier.'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 如您在构造函数代码中所见，我们向其中提供了 `HystrixCommandGroupKey` 参数（3）。`HystrixCommand` 构造函数允许您提供三个参数的组合：`HystrixCommandGroupKey`、`HystrixThreadPoolKey`
    和超时。这两个枚举参数用于命令分组：具有相同组键的命令将属于同一组，并将为了报告、警报和监控的目的分组在一起。线程池键指定了属于同一 Hystrix 线程池的命令。当线程池键未启用时，组键用作线程池标识符。
- en: As a result, in our example all the `pricingService` invocation commands will
    belong to the same group and will use their own thread pool. The third argument
    in the `HystrixCommand` constructors is the timeout of the invocation. If one
    is not provided, the default timeout is used.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在我们的例子中，所有 `pricingService` 调用命令都将属于同一组，并将使用它们自己的线程池。`HystrixCommand` 构造函数中的第三个参数是调用的超时时间。如果没有提供，则使用默认超时。
- en: We have to extend the `run` method of the HystrixCommand class (4). This method
    will be invoked when the command is executed. As you can see (5), the content
    of the method is the same as the code of the proxy in our raw invocation.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须扩展 `HystrixCommand` 类的 `run` 方法（4）。当命令执行时，将调用此方法。如您所见（5），方法的内容与我们的原始调用中的代理代码相同。
- en: 'Now, let''s take a look at how to execute the command:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看如何执行命令：
- en: '[PRE2]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The getPrice method of the proxy (1) creates the command object (2) and invokes
    the `execute()` method on it. This results in the execution of the whole circuit
    breaker algorithm described in the theoretical section. Let''s invoke the catalog/item
    method now and measure the time of its invocation:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 代理的 `getPrice` 方法（1）创建命令对象（2），并在其上调用 `execute()` 方法。这导致执行理论部分中描述的整个断路器算法。现在，让我们调用
    catalog/item 方法并测量其调用时间：
- en: '![](img/24ceacfb-1a49-4b81-9ac9-8ee020ca99f6.png)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![](img/24ceacfb-1a49-4b81-9ac9-8ee020ca99f6.png)'
- en: There is no difference; the invocation is executed immediately without any errors.
    Now, let's make `pricingService` artificially unresponsive.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 没有区别；调用立即执行，没有任何错误。现在，让我们使 `pricingService` 人工无响应。
- en: 'Examples reference: `chapter11/pricing-service-misbehave`.'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 示例参考：`chapter11/pricing-service-misbehave`。
- en: 'In order to do that we are going to make the service wait a specified amount
    of time before returning a result:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 为了做到这一点，我们将在返回结果之前让服务等待指定的时间：
- en: '[PRE3]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Let''s deploy the new service to the cloud and retry an invocation. The result
    is as follows:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将新服务部署到云中并重试一次调用。结果如下：
- en: '![](img/fbf54914-1a83-4df2-8f3b-b8323b9ee14a.png)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/fbf54914-1a83-4df2-8f3b-b8323b9ee14a.png)'
- en: As you will have noticed in the preceding screenshot, the invocation has resulted
    in failure. The circuit breaker was open, and there was a thread available in
    the thread pool. As a result, the invocation was performed, but it exceeded the
    default Hystrix timeout which equals 1 second.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您在前面的屏幕截图中所注意到的，调用导致了失败。断路器处于开启状态，线程池中有一个可用的线程。因此，调用被执行，但超出了默认的Hystrix超时时间，该时间等于1秒。
- en: 'To confirm this, let''s look at the logs:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确认这一点，让我们查看日志：
- en: '![](img/235847c7-f59c-4d56-8e6b-56f10812c723.png)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/235847c7-f59c-4d56-8e6b-56f10812c723.png)'
- en: 'Hystrix does not lie here: the timeout was exceeded and we have implemented
    no fallback. We will do in a second, but before that let''s learn how to modify
    Hystrix properties.'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: Hystrix在这里没有撒谎：超时已超过，我们尚未实现回退。我们将在下一秒做到这一点，但在那之前，让我们学习如何修改Hystrix属性。
- en: 'If you want to modify the configuration of `HystrixCommand`, you have to use
    the constructor with the `Setter` argument. This class allows you to configure
    all the constructor arguments described previously. Apart from that, the class
    allows you to provide the configuration properties for different aspects of the
    circuit breaker behavior. The exhaustive list of such properties is described
    in the Hystrix documentation. Here, we will present a few example modifications.
    Let''s start with the circuit breaker timeout:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想修改`HystrixCommand`的配置，您必须使用带有`Setter`参数的构造函数。这个类允许您配置之前描述的所有构造函数参数。除此之外，该类还允许您为断路器行为的不同方面提供配置属性。此类属性的详尽列表在Hystrix文档中描述。在这里，我们将展示一些示例修改。让我们从断路器超时开始：
- en: '[PRE4]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The preceding code modifies our command class in order to shorten the invocation
    timeout to 500 milliseconds. The `Setter` class is used, and the `CommandGroupKey`
    is set in the same way as in the examples before (1). In order to modify the configuration,
    we have added `HystrixCommandProperites.Setter` with the appropriate configuration
    (2). Now, let''s take a look at the following result:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码修改了我们的命令类，以将调用超时缩短到500毫秒。使用`Setter`类，并且`CommandGroupKey`的设置方式与之前的示例相同（1）。为了修改配置，我们添加了带有适当配置的`HystrixCommandProperites.Setter`（2）。现在，让我们看一下以下结果：
- en: '![](img/b642354c-a033-4faa-b6a7-dc81f264acfd.png)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/b642354c-a033-4faa-b6a7-dc81f264acfd.png)'
- en: 'Let''s reconfigure the application to note the behavior of the bulkheading
    algorithm; we will increase the timeout and reduce the number of threads:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们重新配置应用程序以记录舱壁算法的行为；我们将增加超时时间并减少线程数量：
- en: '[PRE5]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: In order to do that, another setter (this time, the `HystrixThreadPoolProperties`
    setter) has to be created (1).
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 为了做到这一点，必须创建另一个setter（这次是`HystrixThreadPoolProperties` setter）（1）。
- en: 'The result is as follows:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 结果如下：
- en: '![](img/0d847f23-0177-4987-99a0-26f5fe5a5b0e.png)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/0d847f23-0177-4987-99a0-26f5fe5a5b0e.png)'
- en: As you will have noticed in the preceding screenshot, the first three invocations
    have obtained their threads and were blocked. The fourth thread returned immediately
    as there are no more threads in the thread pool.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您在前面的屏幕截图中所注意到的，前三个调用已经获取了它们的线程并且被阻塞。第四个线程立即返回，因为线程池中没有更多的线程了。
- en: 'Finally, let''s open the circuit. If we run the code in a bash loop and look
    into the log, we will note the following result:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们打开电路。如果我们在一个bash循环中运行代码并查看日志，我们将注意到以下结果：
- en: '![](img/fa07b7cd-d85a-4ffb-8fe4-587a161b1b18.png)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/fa07b7cd-d85a-4ffb-8fe4-587a161b1b18.png)'
- en: 'Finally, let''s implement the fallback:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们实现回退：
- en: '[PRE6]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: In order to implement the fallback, you have to override the `getFallback` method
    (1). In our example, we have returned the `SERVICE_UNAVAILABLE` exception whenever
    the `paymentService` is unreachable (2).
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现回退，您必须重写`getFallback`方法（1）。在我们的例子中，每当`paymentService`不可达时，我们都返回`SERVICE_UNAVAILABLE`异常（2）。
- en: 'We can now reimplement the `PetstoreService` so that it creates a meaningful
    exception whenever such situations occur:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以重新实现`PetstoreService`，使其在发生此类情况时创建有意义的异常：
- en: '[PRE7]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'This will be the result of an invocation:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 这将是调用的结果：
- en: '![](img/a240fd13-0050-4fd1-b2ca-65ff68725d2e.png)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a240fd13-0050-4fd1-b2ca-65ff68725d2e.png)'
- en: Summary
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we covered the basic theory behind the circuit breaker pattern.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了断路器模式背后的基本理论。
- en: In the practical part of this chapter, we extended our pet store application
    to provide the buying functionality. We then covered the basics of the Hystrix
    API and used it to implement resilient connections with our external payment service.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的实践部分，我们将我们的宠物商店应用扩展以提供购买功能。然后，我们介绍了 Hystrix API 的基础知识，并使用它来实现与外部支付服务的弹性连接。
- en: Later, we used our own mock implementation of misbehaving a payment service
    to present the behavior of the circuit breaker algorithm.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们使用我们自己的模拟支付服务异常实现的示例来展示断路器算法的行为。
- en: Further reading
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: '[https://github.com/Netflix/Hystrix/wiki](https://github.com/Netflix/Hystrix/wiki)'
  id: totrans-95
  prefs:
  - PREF_UL
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[https://github.com/Netflix/Hystrix/wiki](https://github.com/Netflix/Hystrix/wiki)'
- en: '[http://netflix.github.io/Hystrix/javadoc/](http://netflix.github.io/Hystrix/javadoc/)'
  id: totrans-96
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[http://netflix.github.io/Hystrix/javadoc/](http://netflix.github.io/Hystrix/javadoc/)'
