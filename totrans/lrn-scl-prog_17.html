<html><head></head><body><div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Assessments</h1>
                </header>
            
            <article>
                


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Chapter 1</h1>
                </header>
            
            <article>
                
<ol>
<li><strong>Describe two ways to make it possible for some resource, <kbd>R</kbd></strong>, <strong>to be used together with the <kbd>scala.util.Using</kbd> resource management utility.</strong> </li>
</ol>
<p style="padding-left: 90px">Let <kbd>R</kbd> extend <span><kbd>java.lang.AutoCloseable</kbd>. This will allow existing implicit conversion from <kbd>AutoCloseable</kbd> into <kbd>Resource</kbd> to be applied to <kbd>R</kbd></span>.</p>
<p style="padding-left: 90px">Provide an implicit implementation of <kbd>Resource[R]</kbd>.</p>
<ol start="2">
<li><strong>How can</strong> <kbd>Set</kbd> <strong>and</strong> <kbd>List</kbd> <strong>be compared?</strong></li>
</ol>
<p style="padding-left: 90px">Equality is not defined between <kbd>Set</kbd> and <kbd>List</kbd>, hence we have to use the <kbd>sameElements</kbd> method in one of two ways, directly on <kbd>List</kbd> or on the iterator of <kbd>Set</kbd>, as shown in the following snippet:</p>
<pre style="padding-left: 60px"><span>val </span><span>set </span>= <span>Set</span>(<span>1</span><span>,</span><span>2</span><span>,</span><span>3</span>)<br/><span>val </span><span>list </span>= <span>List</span>(<span>1</span><span>,</span><span>2</span><span>,</span><span>3</span>)<br/><br/><span>set </span>== <span>list </span><span>// false<br/></span><span><br/></span><span>set</span>.iterator.sameElements(<span>list</span>) <span>// true<br/></span><span><br/></span><span>list</span>.sameElements(<span>set</span>) <span>// true<br/></span></pre>
<p style="padding-left: 90px">Another possibility is to utilize the <kbd>corresponds</kbd> operation in combination with the equality checking function. This works similar in either direction:</p>
<pre style="padding-left: 60px">scala&gt; set.corresponds(list)(_ == _)<br/>res2: Boolean = true<br/>scala&gt; list.corresponds(set)(_ == _)<br/>res3: Boolean = true</pre>
<ol start="3">
<li><strong>Name the default concrete implementation for an immutable</strong> <kbd>Seq</kbd><strong>.</strong></li>
</ol>
<p style="padding-left: 90px"><kbd>scala.collection.immutable.List</kbd></p>
<ol start="4">
<li><strong>Name the default concrete implementation for an immutable indexed</strong> <kbd>Seq</kbd><strong>.</strong></li>
</ol>
<p style="padding-left: 90px"><kbd><span>scala.collection.immutable.Vector</span></kbd></p>
<ol start="5">
<li><strong>Name the default concrete implementation for a mutable</strong> <kbd>Seq</kbd><strong>.</strong></li>
</ol>
<p style="padding-left: 90px"><kbd><span>scala.collection.mutable.ArrayBuffer</span></kbd></p>
<ol start="6">
<li><strong>Name the default concrete implementation for a mutable</strong> <kbd>IndexedSeq</kbd><strong>.</strong></li>
</ol>
<p style="padding-left: 90px"><kbd><span>scala.collection.mutable.ArrayBuffer</span></kbd></p>
<ol start="7">
<li><strong>It is sometimes said that</strong> <kbd>List.flatMap</kbd> <strong>is more powerful than it is expected to be. Can you try to explain why? </strong></li>
</ol>
<p style="padding-left: 90px"><span><kbd>flatMap</kbd> is defined on </span><span><kbd>IterableOnce</kbd> and hence</span><span> takes a function returning <kbd>IterableOnce</kbd> as its argument. Because of this, it is possible to mix different types while <kbd>flatMap</kbd> pings. Consider the following example where <kbd>List</kbd> is able to <kbd>flatMap</kbd> the collection with <kbd>Set[Int]</kbd> and  as its elements:</span></p>
<pre style="padding-left: 60px">scala&gt; List(1,2,3,4,5,6).flatMap(i =&gt; if (i&lt;3) Set.fill(i)(i) else Seq.fill(i)(i))<br/>res28: List[Int] = List(1, 2, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 5, 6, 6, 6, 6, 6, 6)</pre>
<ol start="8">
<li><strong>Describe a way to map over a collection multiple times using different functions but without producing intermediate collections.</strong></li>
</ol>
<p style="padding-left: 90px"><span>Create a view, map over the view as required, and force conversion back to the original representation type:</span></p>
<pre style="padding-left: 60px">scala&gt; List(1,2,3,4,5).view.flatMap(List.fill(_)("a")).map(_.toUpperCase).toList<br/>res33: List[String] = List(A, A, A, A, A, A, A, A, A, A, A, A, A, A, A)</pre>
<p> </p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Chapter 2</h1>
                </header>
            
            <article>
                
<ol>
<li><strong>Which type constraints can you name?</strong></li>
</ol>
<p style="padding-left: 120px">There are two constraints: the <span>lower bound or subtype relation and the upper bound or supertype </span><span>relation.</span></p>
<ol start="2">
<li class="mce-root"><strong>What implicit type constraints are added to a type if there are no type constraints defined on it by the developer?</strong></li>
</ol>
<p style="padding-left: 90px">For missing upper bound, the compiler adds <kbd>Any</kbd> as a constraint, and, for missing lower bound–<kbd>Nothing</kbd>.</p>
<ol start="3">
<li><strong>Which operators can be used to refer to the nested type of some type?</strong></li>
</ol>
<p style="padding-left: 90px">There are two operators. The notion <kbd>A#B</kbd> refers to the nested type of the <kbd>A</kbd> type. The notion of <kbd>a.B</kbd> refers to the <kbd>B</kbd> subtype of the instance <kbd>a</kbd>.</p>
<ol start="4">
<li class="mce-root"><strong>Which type can be used as an infix type?</strong></li>
</ol>
<p style="padding-left: 90px">Any type which is parameterized by exactly two type parameters.</p>
<ol start="5">
<li class="mce-root"><strong>Why is the use of structural types discouraged in Scala?</strong></li>
</ol>
<p style="padding-left: 90px">Use of structural types often leads to generated byte code, which accesses methods via reflection, which is slower than normal method calls.</p>
<ol start="6">
<li><strong>What is expressed via variance?</strong></li>
</ol>
<p style="padding-left: 90px">The correlation between subtyping relations of parameterized and parameterizing types.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Chapter 3</h1>
                </header>
            
            <article>
                
<ol>
<li><strong>What will be a type of the following function in curried form: <kbd>(Int, String) =&gt; (Long, Boolean, Int) =&gt; String</kbd>?</strong></li>
</ol>
<p style="padding-left: 90px"><kbd>Int =&gt; (String =&gt; ((Long, Boolean, Int) =&gt; String))</kbd> or simplified <kbd>Int =&gt; String =&gt; (Long, Boolean, Int) =&gt; String</kbd></p>
<ol start="2">
<li><strong>Describe the difference between a partially applied function and a partial function.</strong></li>
</ol>
<p style="padding-left: 90px">A partial function is not defined for some of the possible input values. A partially applied function has some of its parameters fixed to specific values.</p>
<ol start="3">
<li><strong>Define a signature and implement a function, <kbd>uncurry</kbd></strong>, <strong>for a curried function of three arguments, <kbd>A =&gt; B =&gt; C =&gt; R</kbd></strong>.</li>
</ol>
<p style="padding-left: 90px"><kbd>def uncurry[A,B,C,R](in: A =&gt; B =&gt; C =&gt; R): (A,B,C) =&gt; R = (a,b,c) =&gt; in(a)(b)(c)</kbd></p>
<ol start="4">
<li><strong>Implement a head-recursive function for the factorial calculation (n! = n * (n-1) * (n-2) * ... * 1.</strong></li>
</ol>
<p style="padding-left: 90px"><kbd>def factorial(n: Long): Long = if (n &lt; 2) n else n * factorial(n-1)</kbd></p>
<ol start="5">
<li><strong>Implement a tail-recursive function for a factorial calculation.</strong></li>
</ol>
<pre style="padding-left: 60px">def factorial(n: Long): Long = {<br/>  def f(n: Long, acc: Long): Long = if (n &lt; 2) acc else f(n-1, n * acc)<br/>  f(n,1)<br/>}</pre>
<ol start="6">
<li><strong>Implement a recursive function for a factorial calculation using trampolining.</strong></li>
</ol>
<pre style="padding-left: 60px">import util.control.TailCalls._<br/>def factorial(n: Long): TailRec[Long] = if (n&lt;2) done(n) else tailcall(factorial(n-1)).map(_ * n)</pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Chapter 4</h1>
                </header>
            
            <article>
                
<ol>
<li><strong>Describe a case where an implicit parameter is also an implicit conversion.</strong></li>
</ol>
<p style="padding-left: 90px">This is the case if an implicit parameter is a function: <kbd>def func[A, T](a: A)(implicit adapter: A =&gt; T): T  = adapter(a)</kbd>.</p>
<ol start="2">
<li><strong>Replace the following definition that uses view bounds with one using context bounds: <kbd>def compare[T &lt;% Comparable[T]](x: T, y: T) = x &lt; y</kbd></strong>.</li>
</ol>
<pre style="padding-left: 60px">type ComparableContext[T] = T =&gt; Comparable[T]<br/>def compare[T : ComparableContext](x: T, y: T) = x &lt; y</pre>
<ol start="3">
<li><strong>Why are type classes sometimes said to separate behavior and data?</strong></li>
</ol>
<p style="padding-left: 90px">Because type class instances define logic to work and the data comes from the values the type class is applied to.</p>
<p style="padding-left: 90px">It is<span> </span>easy to change the example of possible conflicts in lexical scope so that one of the implicits wins over others and all others can be uncommented without having conflicts anymore. Make this change. For example, it can be done by changing one of the definitions of <kbd>val</kbd>s to the definition of an <kbd>object</kbd>:</p>
<pre style="padding-left: 60px"><span>package object </span>resolution {<br/>  // change // implicit val a: TS = new TS("val in package object") // (1)<br/>  // to     //<br/>  <span>implicit object</span> TSO <span>extends </span>TS(<span>"object in package object"</span>) <span>// (1)<br/></span>}</pre>
<p style="padding-left: 90px">Then, the TSO will be more specific than the rest of the values because of static resolution rules and will be selected by the compiler for the application.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Chapter 5</h1>
                </header>
            
            <article>
                
<ol>
<li><strong>Define an invariant property for<span> </span><span>sorting a list.</span></strong></li>
</ol>
<pre style="padding-left: 60px"><span>def </span>invariant[<span>T</span>: <span>Ordering</span>: Arbitrary]: Prop =<br/>  <span>forAll</span>((l: <span>List</span>[<span>T</span>]) =&gt; l.sorted.length == l.length)<br/><br/>scala&gt; invariant[Long].check<br/>+ OK, passed 100 tests.<br/><br/>scala&gt; invariant[String].check<br/>+ OK, passed 100 tests.</pre>
<ol start="2">
<li><strong>Define an idempotent property for sorting a list.</strong></li>
</ol>
<pre style="padding-left: 60px"><span>def </span>idempotent[<span>T</span>: <span>Ordering</span>: Arbitrary]: Prop =<br/>  <span>forAll</span>((l: <span>List</span>[<span>T</span>]) =&gt; l.sorted.sorted == l.sorted)<br/><br/>scala&gt; idempotent[Long].check<br/>+ OK, passed 100 tests.<br/><br/>scala&gt; idempotent[String].check<br/>+ OK, passed 100 tests.</pre>
<ol start="3">
<li><strong>Define an inductive property for sorting a list.</strong></li>
</ol>
<pre style="padding-left: 60px"><span>def </span>inductive[<span>T</span>: <span>Ordering</span>: Arbitrary]: Prop = {<br/>  <span>def </span>ordered(l: <span>List</span>[<span>T</span>]): Boolean =<br/>    (l.length &lt; <span>2</span>) || <br/>      (ordered(l.tail) &amp;&amp; <span>implicitly</span>[<span>Ordering</span>[<span>T</span>]].lteq(l.head, l.tail.head))<br/>  <span>forAll</span>((l: <span>List</span>[<span>T</span>]) =&gt; ordered(l.sorted))<br/>}<br/><br/>scala&gt; inductive[Int].check<br/>+ OK, passed 100 tests.<br/><br/>scala&gt; inductive[String].check<br/>+ OK, passed 100 tests.</pre>
<ol start="4">
<li><strong>Define a generator for <kbd>List[Lists[Int]]</kbd> so that elements of the nested list are positive.</strong></li>
</ol>
<pre style="padding-left: 60px"><span>val </span><span>genListListInt </span>= Gen.<span>listOf</span>(Gen.<span>listOf</span>(Gen.<span>posNum</span>[Int]))<br/><br/>scala&gt; genListListInt.sample<br/>res35: Option[List[List[Int]]] = Some(List(List(60, 99, 5, 68, 52, 98, 31, 29, 30, 3, 91, 54, 88, 49, 97, 2, 92, 28, 75, 100, 100, 38, 16, 2, 86, 41, 4, 7, 43, 70, 21, 72, 90, 59, 69, 43, 88, 35, 57, 67, 88, 37, 4, 97, 51, 76, 69, 79, 33, 53, 18), List(85, 23, 4, 97, 7, 50, 36, 24, 94), List(97, 9, 25, 34, 29, 82, 59, 24, 94, 42, 34, 80, 7, 79, 44, 54, 61, 84, 32, 14, 9, 17, 95, 98), List(4, 70, 13, 18, 42, 74, 63, 21, 58, 4, 32, 61, 52, 77, 57, 40, 37, 54, 11), List(9, 22, 33, 19, 56, 29, 45, 34, 61, 48, 42, 56, 64, 96, 56, 77, 58, 90, 30, 48, 32, 49, 80, 58, 65, 5, 24, 88, 27, 44, 15, 5, 65, 11, 14, 80, 30, 5, 23, 31, 38, 55, 1, 94, 15, 89, 69, 23, 35, 45, 38, 96, 11, 35, 22, 90, 46, 39, 69, 11, 26, 53, 18, 23, 8, 85, 22, 12, 49, 79, 63, 39, 1, 89, 68, 91, 24...</pre>
<ol start="5">
<li><strong>Define a generator for <kbd>Map[UUID, () =&gt; String].</kbd></strong></li>
</ol>
<pre style="padding-left: 60px"><span>val </span><span>pairGen </span>= <span>for </span>{<br/>  uuid &lt;- Gen.<span>uuid<br/></span><span>  </span>function0 &lt;- Gen.<span>function0</span>(Gen.<span>asciiStr</span>)<br/>} <span>yield </span>(uuid, function0)<br/><br/><span>val </span><span>mapGen </span>= Gen.<span>mapOf</span>(<span>pairGen</span>)<br/>mapGen: org.scalacheck.Gen[Map[java.util.UUID,() =&gt; String]] = org.scalacheck.Gen$$anon$1@16ca4e8d<br/><br/>scala&gt; mapGen.sample<br/>res36: Option[Map[java.util.UUID,() =&gt; String]] = Some(Map(31395a9b-78af-4f4a-9bf3-c19b3fb245b6 -&gt; org.scalacheck.Gen$$$Lambda$2361/1400300928@178b18c, ...</pre>
<p style="padding-left: 90px">Please note that <kbd>Gen.function0</kbd> generates a function of zero arguments that just return random values generated by the provided generator.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Chapter 6</h1>
                </header>
            
            <article>
                
<ol>
<li><strong>What would be the proper effect to represent getting each of the following:</strong></li>
</ol>
<ul>
<li style="padding-left: 60px"><strong>The first element of some</strong> <kbd>List</kbd>: <kbd>Option[?]</kbd> with <kbd>None</kbd> representing an empty list does not have a head element</li>
<li style="padding-left: 60px"><strong>A list of tweets</strong>: <kbd>Future[List[Tweet]]</kbd> as the operation will probably take some time as it goes over the network</li>
<li style="padding-left: 60px"><strong>User information from the database <span>for a given</span></strong> <kbd>userId</kbd>: <kbd>Future[Option[?]]</kbd> with <kbd>Future</kbd> denoting the network call and <kbd>Option</kbd> denoting no user account for a given <kbd><span>userId</span></kbd></li>
</ul>
<ol start="2">
<li><strong>What is a range of possible values of the following expression:</strong> <kbd>Option(scala.util.Random.nextInt(10)).fold(9)(_-1) </kbd></li>
</ol>
<p style="padding-left: 90px">An inclusive [-1;9]</p>
<ol start="3">
<li class="mce-root"><strong>What will be the result of the following expression: </strong></li>
</ol>
<pre style="padding-left: 60px"><span>Try</span>[Int](<span>throw new </span>OutOfMemoryError()).filter(_ &gt; <span>10</span>).recover {<br/>  <span>case </span>_: OutOfMemoryError =&gt; <span>100<br/></span>}(20)</pre>
<p style="padding-left: 90px">The <kbd>Try</kbd> constructor will not catch an <kbd>OutOfMemoryError</kbd>, hence the given expression will throw the <kbd>OutOfMemoryError</kbd>.</p>
<ol start="4">
<li><strong>Describe the result of the following expression:</strong></li>
</ol>
<pre style="padding-left: 60px"><span>Future</span>[Int](<span>throw new </span>OutOfMemoryError()).filter(_ &gt; <span>10</span>).recover {<br/>  <span>case </span>_: OutOfMemoryError =&gt; <span>100<br/></span>}</pre>
<p style="padding-left: 90px">The result of the expression will be <kbd>Future(&lt;not completed&gt;)</kbd> which will eventually throw an <kbd>OutOfMemoryError</kbd>, as in the previous case.</p>
<p class="mce-root"/>
<ol start="5">
<li><strong>Given the following function:</strong></li>
</ol>
<pre><span>def </span>either(i: Int): Boolean = <br/><span>  Either</span>.<span>cond</span>(i &gt; <span>10</span>, i * <span>10</span>, <span>new </span>IllegalArgumentException(<span>"Give me more"</span>)).forall(_ &lt; <span>100</span>)</pre>
<ol start="6">
<li><strong>What would be the result of the following call:</strong> <kbd>either(1)</kbd> ? </li>
</ol>
<p style="padding-left: 30px">The result will be <kbd>true</kbd> because <kbd>Either.cond</kbd> evaluates to <kbd>Left</kbd> for <kbd>i == 2</kbd> and <kbd>Left.forall</kbd> evaluates to <kbd>true</kbd> for any <kbd>Left</kbd>.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Chapter 7</h1>
                </header>
            
            <article>
                
<ol>
<li><strong>Why is the property of associativity essential for the monoid to be useful in a distributed setup?</strong></li>
</ol>
<p style="padding-left: 90px"><span>In a distributed setup, we're usually talking about folding and reusing datasets with parts of the data being processed by different computers. Monoidal operations are applied on remote machines. Regardless of the order in which they were sent from the master machine, network delays, different load patterns, and hardware settings will influence the order in which they will be returned. It is important to be able to apply an operation on the intermediate results already at hand without waiting for the first operations to complete.</span></p>
<ol start="2">
<li><strong><span>Implement a monoid for</span><span> </span><kbd>Boolean</kbd><span> </span><span>under</span><span> </span><kbd>OR</kbd></strong>.</li>
</ol>
<p style="padding-left: 90px">The implementation is as follows:</p>
<pre style="padding-left: 60px"><span>implicit val </span><span>booleanOr</span>: Monoid[Boolean] = <span>new </span>Monoid[Boolean] {<br/>  <span>override def </span>identity: Boolean = <span>false<br/></span><span>  override def </span>op(l: Boolean, r: Boolean): Boolean = l || r<br/>}</pre>
<p style="padding-left: 90px"><span>The property is as follows::<br/></span></p>
<pre style="padding-left: 60px"><span>property</span>(<span>"boolean under or"</span>) = {<br/>  <span>import </span>Assessment.<span>booleanOr<br/></span><span>  </span><span>monoidProp</span>[Boolean]<br/>}</pre>
<ol start="3">
<li><strong>Implement a monoid for<span> </span><kbd>Boolean</kbd><span> </span>under<span> </span><kbd>AND.</kbd></strong></li>
</ol>
<p style="padding-left: 90px">The implementation is as follows:</p>
<pre style="padding-left: 60px"><span>implicit val </span><span>booleanAnd</span>: Monoid[Boolean] = <span>new </span>Monoid[Boolean] {<br/>  <span>override def </span>identity: Boolean = <span>true<br/></span><span>  override def </span>op(l: Boolean, r: Boolean): Boolean = l &amp;&amp; r<br/>}</pre>
<p style="padding-left: 90px">The property is as follows:</p>
<pre style="padding-left: 60px"><span>property</span>(<span>"boolean under and"</span>) = {<br/>  <span>import </span>Assessment.<span>booleanAnd<br/></span><span>  </span><span>monoidProp</span>[Boolean]<br/>}</pre>
<ol start="4">
<li><strong>Given <kbd>Monoid[A]</kbd>, implement<span> </span><kbd>Monoid[Option[A]].</kbd></strong></li>
</ol>
<p style="padding-left: 90px">The implementation is as follows:</p>
<pre style="padding-left: 60px"><span>implicit def </span>option[<span>A </span>: Monoid]: Monoid[Option[<span>A</span>]] = <span>new </span>Monoid[Option[<span>A</span>]] {<br/>  <span>override def </span>identity: Option[<span>A</span>] = None<br/>  <span>override def </span>op(l: Option[<span>A</span>], r: Option[<span>A</span>]): Option[<span>A</span>] = (l, r) <span>match </span>{<br/>    <span>case </span>(<span>Some</span>(la), <span>Some</span>(lb)) =&gt; <span>Option</span>(<span>implicitly</span>[Monoid[<span>A</span>]].op(la, lb))<br/>    <span>case </span>_ =&gt; l orElse r<br/>  }<br/>}</pre>
<p style="padding-left: 90px">The property is as follows:</p>
<pre style="padding-left: 60px"><span>property</span>(<span>"Option[Int] under addition"</span>) = {<br/>  <span>import </span>Monoid.<span>intAddition<br/></span><span>  </span><span>import </span>Assessment.<span>option<br/></span><span>  monoidProp</span>[Option[Int]]<br/>}<br/><br/><span>property</span>(<span>"Option[String] under concatenation"</span>) = {<br/>  <span>import </span>Monoid.<span>stringConcatenation<br/></span><span>  </span><span>import </span>Assessment.<span>option<br/></span><span>  monoidProp</span>[Option[<span>String</span>]]<br/>}</pre>
<ol start="5">
<li><strong><span>Given <kbd>Monoid[R]</kbd>, implement <kbd>Monoid[Either[L, R]].</kbd></span></strong></li>
</ol>
<p style="padding-left: 90px">The implementation is as follows:</p>
<pre style="padding-left: 60px"><span>def </span>either[<span>L</span>, <span>R </span>: Monoid]: Monoid[Either[<span>L</span>, <span>R</span>]] = <span>new </span>Monoid[Either[<span>L</span>, <span>R</span>]] {<br/>  <span>private val </span><span>ma </span>= <span>implicitly</span>[Monoid[<span>R</span>]]<br/>  <span>override def </span>identity: Either[<span>L</span>, <span>R</span>] = <span>Right</span>(<span>ma</span>.identity)<br/>  <span>override def </span>op(l: Either[<span>L</span>, <span>R</span>], r: Either[<span>L</span>, <span>R</span>]): Either[<span>L</span>, <span>R</span>] = (l, r) <span>match </span>{<br/>    <span>case </span>(l @ <span>Left</span>(_), _) =&gt; l<br/>    <span>case </span>(_, l @ <span>Left</span>(_)) =&gt; l<br/>    <span>case </span>(<span>Right</span>(la), <span>Right</span>(lb)) =&gt; <span>Right</span>(<span>ma</span>.op(la, lb))<br/>  }<br/>}</pre>
<p style="padding-left: 90px">The property is as follows:</p>
<pre style="padding-left: 60px"><span>property</span>(<span>"Either[Int] under multiplication"</span>) = {<br/>  <span>import </span>Monoid.<span>intMultiplication<br/></span><span>  </span><span>implicit val </span>monoid: Monoid[<span>Either</span>[Unit, Int]] = Assessment.<span>either</span>[Unit, Int]<br/>  <span>monoidProp</span>[<span>Either</span>[Unit, Int]]<br/>}<br/><br/><span>property</span>(<span>"Either[Boolean] under OR"</span>) = {<br/>  <span>import </span>Assessment.<span>booleanOr<br/></span><span>  </span><span>implicit val </span>monoid: Monoid[<span>Either</span>[<span>String</span>, Boolean]] = Assessment.<span>either</span>[<span>String</span>, Boolean]<br/>  <span>monoidProp</span>[<span>Either</span>[<span>String</span>, Boolean]]<br/>}</pre>
<ol start="6">
<li><strong>Generalize two previous implementations for any effect parameterized by<span> </span><kbd>A</kbd> or describe why it is not possible.</strong></li>
</ol>
<p style="padding-left: 90px">Unfortunately, it is not possible to implement such a monoid in general because the implementation would require two aspects:</p>
<ul>
<li style="padding-left: 90px">An identity element for the new monoid</li>
<li style="padding-left: 90px">A possibility to check whether an effect is empty and retrieve an element if it is not</li>
</ul>
<p style="padding-left: 90px">It is possible to pass an identity element as an argument to the constructor, but then there is no way to work with existing effects as required by the second point.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Chapter 8</h1>
                </header>
            
            <article>
                
<ol start="1">
<li><strong>Implement</strong> <kbd>Functor[Try]</kbd>.</li>
</ol>
<pre style="padding-left: 60px"><span>implicit val </span><span>tryFunctor</span>: Functor[Try] = <span>new </span>Functor[Try] {<br/>  <span>override def </span>map[<span>A</span>, <span>B</span>](in: Try[<span>A</span>])(f: <span>A </span>=&gt; <span>B</span>): Try[<span>B</span>] = in.map(f)<br/>  <span>override def </span>mapC[<span>A</span>, <span>B</span>](f: <span>A </span>=&gt; <span>B</span>): Try[<span>A</span>] =&gt; Try[<span>B</span>] = fa =&gt; map(fa)(f)<br/>}</pre>
<p> </p>
<ol start="2">
<li><strong>Implement</strong> <kbd>Applicative[Try]</kbd>.</li>
</ol>
<pre style="padding-left: 60px"><span>implicit val </span><span>tryApplicative</span>: Applicative[Try] = <span>new </span>Applicative[Try] {<br/>  <span>override def </span><span>apply</span>[<span>A</span><span>, </span><span>B</span>](a: Try[<span>A</span>])(f: Try[<span>A </span>=&gt; <span>B</span>]): Try[<span>B</span>] = (a<span>, </span>f) <span>match </span>{<br/>    <span>case </span>(<span>Success</span>(a)<span>, </span><span>Success</span>(f)) =&gt; <span>Try</span>(f(a))<br/>    <span>case </span>(<span>Failure</span>(ex)<span>, </span>_) =&gt; <span>Failure</span>(ex)<br/>    <span>case </span>(_<span>, </span><span>Failure</span>(ex)) =&gt; <span>Failure</span>(ex)<br/>  }<br/>  <span>override def </span><span>unit</span>[<span>A</span>](a: =&gt; <span>A</span>): Try[<span>A</span>] = <span>Success</span>(a)<br/>}</pre>
<p> </p>
<ol start="3">
<li><strong>Implement </strong> <kbd>Applicative[Either]</kbd>.</li>
</ol>
<pre style="padding-left: 60px"><span>implicit def </span><span>eitherApplicative</span>[<span>L</span>] = <span>new </span>Applicative[({ <span>type </span><span>T</span>[<span>A</span>] = <span>Either</span>[<span>L</span><span>, </span><span>A</span>] })#<span>T</span>] {<br/>  <span>override def </span><span>apply</span>[<span>A</span><span>, </span><span>B</span>](a: <span>Either</span>[<span>L</span><span>, </span><span>A</span>])(f: <span>Either</span>[<span>L</span><span>, </span><span>A </span>=&gt; <span>B</span>]): <span>Either</span>[<span>L</span><span>, </span><span>B</span>] = (a<span>, </span>f) <span>match </span>{<br/>    <span>case </span>(<span>Right</span>(a)<span>, </span><span>Right</span>(f)) =&gt; <span>Right</span>(f(a))<br/>    <span>case </span>(<span>Left</span>(l)<span>, </span>_) =&gt; <span>Left</span>(l)<br/>    <span>case </span>(_<span>, </span><span>Left</span>(l)) =&gt; <span>Left</span>(l)<br/>  }<br/>  <span>override def </span><span>unit</span>[<span>A</span>](a: =&gt; <span>A</span>): <span>Either</span>[<span>L</span><span>, </span><span>A</span>] = <span>Right</span>(a)<br/>}</pre>
<p> </p>
<ol start="4">
<li><strong>Implement</strong> <kbd>Traversable[Try]</kbd>.</li>
</ol>
<pre style="padding-left: 60px"><span>implicit val </span><span>tryTraversable </span>= <span>new </span>Traversable[Try] {<br/>  <span>override def </span><span>map</span>[<span>A</span><span>, </span><span>B</span>](in: Try[<span>A</span>])(f: <span>A </span>=&gt; <span>B</span>): Try[<span>B</span>] = Functor.<span>tryFunctor</span>.map(in)(f)<br/>  <span>override def </span><span>traverse</span>[<span>A</span><span>, </span><span>B</span><span>, </span><span>G</span>[_] : Applicative](a: Try[<span>A</span>])(f: <span>A </span>=&gt; <span>G</span>[<span>B</span>]): <span>G</span>[Try[<span>B</span>]] = {<br/>    <span>val </span>G = <span>implicitly</span>[Applicative[<span>G</span>]]<br/>    a <span>match </span>{<br/>      <span>case </span><span>Success</span>(s) =&gt; G.map(f(s))(Success.<span>apply</span>)<br/>      <span>case </span><span>Failure</span>(ex) =&gt; G.unit(<span>Failure</span>(ex)) <span>// re-wrap the ex to change the type of Failure<br/></span><span>    </span>}<br/>  }<br/>}</pre>
<ol start="5">
<li><strong>Implement</strong> <kbd>Traversable[Either]</kbd>.</li>
</ol>
<pre style="padding-left: 60px"><span>implicit def </span><span>eitherTraversable</span>[<span>L</span>] = <span>new </span>Traversable[({ <span>type </span><span>T</span>[<span>A</span>] = <span>Either</span>[<span>L</span><span>, </span><span>A</span>] })#<span>T</span>] {<br/>  <span>override def </span><span>map</span>[<span>A</span><span>, </span><span>B</span>](in: <span>Either</span>[<span>L</span><span>, </span><span>A</span>])(f: <span>A </span>=&gt; <span>B</span>): <span>Either</span>[<span>L</span><span>, </span><span>B</span>] = <br/>    Functor.<span>eitherFunctor</span>[<span>L</span>].map(in)(f)<br/>  <span>override def </span><span>traverse</span>[<span>A</span><span>, </span><span>B</span><span>, </span><span>G</span>[_] : Applicative](a: <span>Either</span>[<span>L</span><span>, </span><span>A</span>])(f: <span>A </span>=&gt; <span>G</span>[<span>B</span>]): <span>G</span>[<span>Either</span>[<span>L</span><span>, </span><span>B</span>]] = {<br/>    <span>val </span>G = <span>implicitly</span>[Applicative[<span>G</span>]]<br/>    a <span>match </span>{<br/>      <span>case </span><span>Right</span>(s) =&gt; G.map(f(s))(<span>Right</span>.<span>apply</span>)<br/>      <span>case </span><span>Left</span>(l) =&gt; G.unit(<span>Left</span>(l)) <span>// re-wrap the l to change the type of Failure<br/></span><span>    </span>}<br/>  }<br/>}</pre>
<ol start="6">
<li><strong>Implement </strong><kbd>Traversable.compose</kbd>.</li>
</ol>
<pre style="padding-left: 60px"><span>trait </span>Traversable[<span>F</span>[_]] <span>extends </span>Functor[<span>F</span>] {<br/>  <span>def </span><span>traverse</span>[<span>A</span><span>,</span><span>B</span><span>,</span><span>G</span>[_]: Applicative](a: <span>F</span>[<span>A</span>])(f: <span>A </span>=&gt; <span>G</span>[<span>B</span>]): <span>G</span>[<span>F</span>[<span>B</span>]]<br/>  <span>def </span><span>sequence</span>[<span>A</span><span>,</span><span>G</span>[_]: Applicative](a: <span>F</span>[<span>G</span>[<span>A</span>]]): <span>G</span>[<span>F</span>[<span>A</span>]] = traverse(a)(<span>identity</span>)<br/><br/>  <span>def </span><span>compose</span>[<span>H</span>[_]](<span>implicit </span>H: Traversable[<span>H</span>]): Traversable[({<span>type </span><span>f</span>[<span>x</span>] = <span>F</span>[<span>H</span>[<span>x</span>]]})#<span>f</span>] = {<br/>    <span>val </span>F = <span>this<br/></span><span>    new </span>Traversable[({<span>type </span><span>f</span>[<span>x</span>] = <span>F</span>[<span>H</span>[<span>x</span>]]})#<span>f</span>] {<br/>      <span>override def </span><span>traverse</span>[<span>A</span><span>, </span><span>B</span><span>, </span><span>G</span>[_] : Applicative](fa: <span>F</span>[<span>H</span>[<span>A</span>]])(f: <span>A </span>=&gt; <span>G</span>[<span>B</span>]) =<br/>        F.traverse(fa)((ga: <span>H</span>[<span>A</span>]) =&gt; H.traverse(ga)(f))<br/><br/>      <span>override def </span><span>map</span>[<span>A</span><span>, </span><span>B</span>](in: <span>F</span>[<span>H</span>[<span>A</span>]])(f: <span>A </span>=&gt; <span>B</span>): <span>F</span>[<span>H</span>[<span>B</span>]] =<br/>        F.map(in)((ga: <span>H</span>[<span>A</span>]) =&gt; H.map(ga)(f))<br/>    }<br/>  }<br/>}</pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Chapter 9</h1>
                </header>
            
            <article>
                
<ol start="1">
<li><strong>Implement <kbd><span>Monad[Try]</span></kbd></strong>.</li>
</ol>
<pre style="padding-left: 90px"><span>implicit val </span><span>tryMonad </span>= <span>new </span>Monad[Try] {<br/>  <span>override def </span><span>unit</span>[<span>A</span>](a: =&gt; <span>A</span>): Try[<span>A</span>] = <span>Success</span>(a)<br/><br/>  <span>override def </span><span>flatMap</span>[<span>A</span><span>, </span><span>B</span>](a: Try[<span>A</span>])(f: <span>A </span>=&gt; Try[<span>B</span>]): Try[<span>B</span>] = a <span>match </span>{<br/>    <span>case </span><span>Success</span>(value) =&gt; f(value)<br/>    <span>case </span><span>Failure</span>(ex) =&gt; <span>Failure</span>(ex)<br/>  }<br/>}</pre>
<ol start="2">
<li><strong>Prove the right identity law for the<span> </span><kbd>State</kbd><span> </span>monad.</strong></li>
</ol>
<p style="padding-left: 90px">Let's start with the property definition we had in this chapter:</p>
<pre style="padding-left: 60px"><span>val </span>rightIdentity = <span>forAll </span>{ (a: <span>A</span><span>, </span>f: <span>A </span>=&gt; <span>M</span>[<span>B</span>]) =&gt;<br/>  M.flatMap(M.unit(a))(f) == f(a)<br/>}</pre>
<p style="padding-left: 90px">Let <kbd>f(a) = a =&gt; State(s =&gt; (b, s2))</kbd></p>
<p style="padding-left: 90px">First, we substitute the definition of unit with the result of the call. Hence, <kbd>M.flatMap(M.unit(a))(f)</kbd> becomes <kbd><span>M.flatMap(</span><span>State(s =&gt; (a, s)))(f)</span></kbd>.</p>
<p style="padding-left: 90px">Next, we substitute <kbd>M.flatMap</kbd> with <kbd>compose</kbd>, which gives us <kbd><span>State(s =&gt; (a, s)).compose(f).</span></kbd></p>
<p style="padding-left: 90px">Next, we'll use the lemma proved in this chapter to substitute the <kbd>compose</kbd> call with the definition of it:</p>
<pre style="padding-left: 90px"><span>State(s =&gt; { <br/>  val </span>(a<span>, </span>nextState) = (a, s)<br/>  f(a).run(nextState)<br/>}</pre>
<p style="padding-left: 90px">By application of <kbd>f</kbd>, the previous code can be simplified to <kbd><span>State(s =&gt;</span> <span>State(s =&gt; (b, s2))</span>.run(s)</kbd> and further to <kbd><span>State(s =&gt; (b, s2)</span></kbd>. <strong>(1)</strong></p>
<p style="padding-left: 90px">The right side of the equation, <kbd>f(a)</kbd>, is by definition equal to <span><kbd>State(s =&gt; (b, s2))</kbd>. <strong>(2)</strong></span></p>
<p style="padding-left: 90px">We have (1) == (2) and hence proved the right identity law for the state monad.</p>
<ol start="3">
<li><strong>Pick one of the monads we defined in this chapter and implement the<span> </span><kbd>go</kbd><span> </span>function that will encode the notion of sinking the boat with a 1% probability.</strong></li>
</ol>
<p style="padding-left: 90px"><kbd>Option</kbd> will represent the notion of the sunk boat: </p>
<pre style="padding-left: 60px"><span>import </span>Monad.<span>optionMonad<br/></span><span><br/></span><span>def </span><span>go</span>(speed: <span>Float, </span>time: <span>Float</span>)(boat: Boat): Option[Boat] = <br/>  <span>if </span>(Random.nextInt(<span>100</span>) == <span>0</span>) None<br/>  <span>else </span><span>Option</span>(boat.go(speed<span>, </span>time))<br/><br/><span>println</span>(<span>move</span>(<span>go</span><span>, </span><span>turn</span>[Option])(<span>Option</span>(<span>boat</span>)))</pre>
<ol start="4">
<li><strong>Please do the same but encode the notion of a motor breaking in 1% of the moves, leaving the boat immobilized.</strong></li>
</ol>
<p style="padding-left: 90px">Both <kbd>Try</kbd> and right-biased <kbd>Either</kbd> can be used to encode the case of the broken motor. </p>
<p style="padding-left: 90px">Following is the implementation with <kbd>Try</kbd>:</p>
<pre style="padding-left: 90px"><span>import </span>Monad.<span>tryMonad<br/></span><span><br/></span><span>def </span><span>go</span>(speed: <span>Float, </span>time: <span>Float</span>)(boat: Boat): Try[Boat] =<br/>  <span>if </span>(Random.nextInt(<span>100</span>) == <span>0</span>) <span>Failure</span>(<span>new </span>Exception(<span>"Motor malfunction"</span>))<br/>  <span>else </span><span>Success</span>(boat.go(speed<span>, </span>time))<br/><br/><span>println</span>(<span>move</span>(<span>go</span><span>, </span><span>turn</span>[Try])(<span>Success</span>(<span>boat</span>)))</pre>
<p style="padding-left: 90px">Following is the implementation with <kbd>Either</kbd>:</p>
<pre style="padding-left: 90px"><span>import </span>Monad.<span>eitherMonad<br/></span><span>type </span><span>ErrorOr</span>[<span>B</span>] = <span>Either</span>[<span>String</span><span>, </span><span>B</span>]<br/><br/><span>def </span><span>go</span>(speed: <span>Float, </span>time: <span>Float</span>)(boat: Boat): <span>ErrorOr</span>[Boat] =<br/>  <span>if </span>(Random.nextInt(<span>100</span>) == <span>0</span>) <span>Left</span>(<span>"Motor malfunction"</span>)<br/>  <span>else </span><span>Right</span>(boat.go(speed<span>, </span>time))<br/><br/><span>println</span>(<span>move</span>(<span>go</span><span>, </span><span>turn</span>[<span>ErrorOr</span>])(<span>Right</span>(<span>boat</span>)))</pre>
<ol start="5">
<li><strong>Describe the essence of monads we defined in this chapter using<span> (loosely)</span><span> the </span>following template: The state monad passes state between chained computation. The computation itself accepts the outcome of the previous calculation and returns the result along with the new state.</strong></li>
</ol>
<p style="padding-left: 90px">The option monad allows the chaining of computations which might return no result. The computations are carried over until the last one or until the first one returns no result. </p>
<p style="padding-left: 90px">The try monad does the same as the option monad but instead of having a special <em>no result</em> value, which aborts the whole computation chain, it has a notion of <em>failure</em> represented by a <kbd>Failure</kbd> case class.</p>
<p style="padding-left: 90px">Either monad has similar semantics to the option and try monads but, in this case, the notion of aborting the sequence of steps is carried on by the Left type and the notion of continuing the sequence, by the <kbd>Right</kbd> type.</p>
<ol start="6">
<li><strong><span>Define a </span><kbd>go</kbd><span> method that both tracks the boat's position and takes the possibility of sinking the boat using the structure with the following type: <kbd>type WriterOption[B] = Writer[Vector[(Double, Double)], Option[Boat]]</kbd></span></strong>.</li>
</ol>
<pre style="padding-left: 90px"><span>object </span>WriterOptionExample <span>extends </span>App {<br/>  <span>type </span><span>WriterOption</span>[<span>B</span>] = Writer[<span>Vector</span>[(<span>Double, Double</span>)]<span>, </span>Option[<span>B</span>]]<br/>  <span>import </span>WriterExample.<span>vectorMonoid<br/></span><span><br/>  // this implementation delegates to the logic we've implemented in the chapter<br/></span><span>  </span><span>def </span><span>go</span>(speed: <span>Float, </span>time: <span>Float</span>)(boat: Boat): <span>WriterOption</span>[Boat] = {<br/>    <span>val </span>b: Option[Boat] = OptionExample.<span>go</span>(speed<span>, </span>time)(boat)<br/>    <span>val </span>c: <span>WriterTracking</span>[Boat] = WriterExample.<span>go</span>(speed<span>, </span>time)(boat)<br/>    <span>Writer</span>((b<span>, </span>c.run._2))<br/>  }<br/><br/>  // constructor - basically unit for the combined monad<br/>  <span>private def </span><span>writerOption</span>[<span>A</span>](a: <span>A</span>) =<br/>    <span>Writer</span>[<span>Vector</span>[(<span>Double, Double</span>)]<span>, </span>Option[<span>A</span>]](<span>Option</span>(a))<br/><br/>  // we need a monad of the appropriate type<br/>  <span>implicit val </span><span>readerWriterMonad </span>= <span>new </span>Monad[<span>WriterOption</span>] {<br/>    <span>override def </span><span>flatMap</span>[<span>A</span><span>, </span><span>B</span>](wr: <span>WriterOption</span>[<span>A</span>])(f: <span>A </span>=&gt; <span>WriterOption</span>[<span>B</span>]): <span>WriterOption</span>[<span>B</span>] =<br/>      wr.compose {<br/>        <span>case </span><span>Some</span>(a) =&gt; f(a)<br/>        <span>case </span>None =&gt; <span>Writer</span>(Option.<span>empty</span>[<span>B</span>])<br/>      }<br/><br/>    <span>override def </span><span>unit</span>[<span>A</span>](a: =&gt; <span>A</span>): <span>WriterOption</span>[<span>A</span>] = <span>writerOption</span>(a)<br/>  }<br/>  // tracks boat movement until it is done navigating or sank<br/>  <span>println</span>(<span>move</span>(<span>go</span><span>, </span><span>turn</span>)(<span>writerOption</span>(<span>boat</span>)).run)<br/>}</pre>
<ol start="7">
<li><strong>Compare the answer to Question 6 and the way we combined applications in the previous chapter.</strong></li>
</ol>
<p style="padding-left: 90px">In <a href="d31b3592-80b3-4b50-8c32-b41dd9862ecd.xhtml">Chapter 8</a>, <em>Dealing with Effects</em>, we implemented a generic combinator for applications. In this implementation involving monads, we needed to know how to dissect the options effect in order to be able to implement the combination logic. Please read <a href="5503a5a0-2aaa-44f2-be25-64e34977f6ff.xhtml">Chapter 10</a>,  <em>A Look at Monad Transformers and Free Monad</em>, for more details.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Chapter 10</h1>
                </header>
            
            <article>
                
<ol start="1">
<li><strong>Why does the type of monad transformer reflect the type of the stack "upside-down"?</strong></li>
</ol>
<p style="padding-left: 90px">It is impossible to define a monad composition in general, only in a way specific to the internal effect of the stack. Because of this, the name of the effect is fixed in the name of the transformer and the outer effect becomes a type parameter.</p>
<ol start="2">
<li><strong>Why is it possible to reuse existing monads for the top layer of the stack?</strong></li>
</ol>
<p style="padding-left: 90px">The return type of the Kleisli arrow fits well with the type of the stack. For this reason, it is possible to produce the result of the proper type by utilizing the <kbd>flatMap</kbd> method of the outer monad.</p>
<ol start="3">
<li><strong>Why is it impossible to reuse existing monads for the bottom layer of the stack?</strong></li>
</ol>
<p style="padding-left: 90px">The argument type of the arrow expects a plain argument. Consequently, we need to extract the effect-free value from the context of internal effect. This is only possible in a specific <span>way but not in general. </span></p>
<ol start="4">
<li><strong>Implement the<span> </span><kbd>TryT</kbd><span> </span>monad transformer.</strong></li>
</ol>
<pre style="padding-left: 90px"><span>private def </span><span>noResultTryT</span>[<span>F</span>[_] : Monad<span>, </span><span>T</span>](ex: <span>Throwable</span>): <span>F</span>[Try[<span>T</span>]] = <br/><span>  Monad</span>[<span>F</span>].unit(<span>Failure</span>[<span>T</span>](ex))<br/><br/><span>implicit class </span>TryT[<span>F</span>[_] : Monad<span>, </span><span>A</span>](<span>val </span>value: <span>F</span>[Try[<span>A</span>]]) {<br/>  <span>def </span><span>compose</span>[<span>B</span>](f: <span>A </span>=&gt; TryT[<span>F</span><span>, </span><span>B</span>]): TryT[<span>F</span><span>, </span><span>B</span>] = {<br/>    <span>val </span>result = value.flatMap {<br/>      <span>case </span><span>Failure</span>(ex) =&gt; <span>noResultTryT</span>[<span>F</span><span>, </span><span>B</span>](ex)<br/>      <span>case </span><span>Success</span>(a) =&gt; f(a).value<br/>    }<br/>    <span>new </span>TryT(result)<br/>  }<br/><br/>  <span>def </span><span>isSuccess</span>: <span>F</span>[<span>Boolean</span>] = <span>Monad</span>[<span>F</span>].map(value)(_.isSuccess)<br/>}<br/><br/><span>def </span><span>tryTunit</span>[<span>F</span>[_] : Monad<span>, </span><span>A</span>](a: =&gt; <span>A</span>) = <span>new </span>TryT(<span>Monad</span>[<span>F</span>].unit(<span>Try</span>(a)))<br/><br/><span>implicit def </span><span>TryTMonad</span>[<span>F</span>[_] : Monad]: Monad[TryT[<span>F</span><span>, </span>?]] = <span>new </span>Monad[TryT[<span>F</span><span>, </span>?]] {<br/>  <span>override def </span><span>unit</span>[<span>A</span>](a: =&gt; <span>A</span>): TryT[<span>F</span><span>, </span><span>A</span>] = <span>Monad</span>[<span>F</span>].unit(<span>Monad</span>[Try].unit(a))<br/>  <span>override def </span><span>flatMap</span>[<span>A</span><span>, </span><span>B</span>](a: TryT[<span>F</span><span>, </span><span>A</span>])(f: <span>A </span>=&gt; TryT[<span>F</span><span>, </span><span>B</span>]): TryT[<span>F</span><span>, </span><span>B</span>] = a.compose(f)<br/>}</pre>
<ol start="5">
<li><strong>Use the<span> </span><kbd>TryT</kbd><span> </span>monad transformer instead of<span> </span><kbd>EitherT</kbd> with the example functions from this chapter.</strong></li>
</ol>
<pre style="padding-left: 90px"><span>object </span>Ch10FutureTryFishing <span>extends </span>FishingApi[TryT[Future<span>, </span>?]] <span>with </span>App {<br/>  <span>val </span><span>buyBateImpl</span>: <span>String </span>=&gt; Future[<span>Bate</span>] = <span>???<br/></span><span>  </span><span>val </span><span>castLineImpl</span>: <span>Bate </span>=&gt; Try[<span>Line</span>] = <span>???<br/></span><span>  </span><span>val </span><span>hookFishImpl</span>: <span>Line </span>=&gt; Future[<span>Fish</span>] = <span>???<br/></span><span><br/></span><span>  </span><span>override val </span><span>buyBate</span>: <span>String </span>=&gt; TryT[Future<span>, </span><span>Bate</span>] = <br/>    (name: <span>String</span>) =&gt; <span>buyBateImpl</span>(name).map(<span>Try</span>(_))<br/>  <span>override val </span><span>castLine</span>: <span>Bate </span>=&gt; TryT[Future<span>, </span><span>Line</span>] = <br/><span>    castLineImpl</span>.andThen(Future.<span>successful</span>(_))<br/>  <span>override val </span><span>hookFish</span>: <span>Line </span>=&gt; TryT[Future<span>, </span><span>Fish</span>] = <br/>    (line: <span>Line</span>) =&gt; <span>hookFishImpl</span>(line).map(<span>Try</span>(_))<br/><br/>  <span>val </span><span>result</span>: Future[Try[<span>Fish</span>]] = goFishing(<span>tryTunit</span>[Future<span>, </span><span>String</span>](<span>"Crankbait"</span>)).value<br/>}</pre>
<ol start="6">
<li><strong>Implement another take on the monad transformer stack, this time with this layers placed upside-down:<span> </span></strong><kbd>EitherT[OptionT[Future, A], String, A]</kbd>.</li>
</ol>
<pre style="padding-left: 60px"><span>type </span><span>Inner</span>[<span>A</span>] = OptionT[Future<span>, </span><span>A</span>]<br/><span>type </span><span>Outer</span>[<span>F</span>[_]<span>, </span><span>A</span>] = EitherT[<span>F</span><span>, </span><span>String</span><span>, </span><span>A</span>]<br/><span>type </span><span>Stack</span>[<span>A</span>] = <span>Outer</span>[<span>Inner</span><span>, </span><span>A</span>]<br/><br/><span>object </span>Ch10EitherTOptionTFutureFishing <span>extends </span>FishingApi[<span>Stack</span>[?]] <span>with </span>App {<br/><br/>  <span>val </span><span>buyBateImpl</span>: <span>String </span>=&gt; Future[<span>Bate</span>] = <span>???<br/></span><span>  </span><span>val </span><span>castLineImpl</span>: <span>Bate </span>=&gt; <span>Either</span>[<span>String</span><span>, </span><span>Line</span>] = <span>???<br/></span><span>  </span><span>val </span><span>hookFishImpl</span>: <span>Line </span>=&gt; Future[<span>Fish</span>] = <span>???<br/></span><span><br/></span><span>  </span><span>override val </span><span>castLine</span>: <span>Bate </span>=&gt; <span>Stack</span>[<span>Line</span>] =<br/>    (bate: <span>Bate</span>) =&gt; <span>new </span>OptionT(Future.<span>successful</span>(<span>Option</span>(<span>castLineImpl</span>(bate))))<br/><br/>  <span>override val </span><span>buyBate</span>: <span>String </span>=&gt; <span>Stack</span>[<span>Bate</span>] =<br/>    (name: <span>String</span>) =&gt; <span>new </span>OptionT(<span>buyBateImpl</span>(name).map(l =&gt; <span>Option</span>(<span>Right</span>(l)): Option[<span>Either</span>[<span>String</span><span>, </span><span>Bate</span>]]))<br/><br/>  <span>override val </span><span>hookFish</span>: <span>Line </span>=&gt; <span>Stack</span>[<span>Fish</span>] =<br/>    (line: <span>Line</span>) =&gt; <span>new </span>OptionT(<span>hookFishImpl</span>(line).map(l =&gt; <span>Option</span>(<span>Right</span>(l)): Option[<span>Either</span>[<span>String</span><span>, </span><span>Fish</span>]]))<br/><br/>  val input: EitherT[Inner, String, String] = eitherTunit[Inner, String, String]("Crankbait")<br/>  val outerResult: Inner[Either[String, Fish]] = goFishing(input).value<br/>  val innerResult: Future[Option[Either[String, Fish]]] = outerResult.value<br/><br/>}</pre>
<ol start="7">
<li><strong>Add an action to release the caught fish to the free monad example we developed in the chapter.</strong></li>
</ol>
<p style="padding-left: 90px">Only the changed parts of the example are shown here. Please see the accompanying code to see the example with incorporated changes:</p>
<pre style="padding-left: 60px">final case class ReleaseFish[A](fish: Fish, f: Unit =&gt; A) extends Action[A]<br/><br/>def releaseFish(fish: Fish): Free[Action, Unit] = Join(ReleaseFish(fish, _ =&gt; Done(())))<br/><br/>implicit val actionFunctor: Functor[Action] = new Functor[Action] {<br/>  override def map[A, B](in: Action[A])(f: A =&gt; B): Action[B] = in match {<br/>    ... // other actions as before  <br/>    case ReleaseFish(fish, a) =&gt; ReleaseFish(fish, x =&gt; f(a(x)))<br/>  }<br/>}<br/><br/>def catchFish(bateName: String): Free[Action, _] = for {<br/>    bate &lt;- buyBate(bateName)<br/>    line &lt;- castLine(bate)<br/>    fish &lt;- hookFish(line)<br/>    _ &lt;- releaseFish(fish)<br/>} yield ()<br/><br/>def goFishingLogging[A](actions: Free[Action, A], unit: Unit): A = actions match {<br/>    ... // the rest as in the chapter code<br/>    case Join(ReleaseFish(fish, f)) =&gt;<br/>      goFishingLogging(f(()), log(s"Releasing the fish $fish"))<br/>}<br/><br/>def goFishingAcc[A](actions: Free[Action, A], log: List[AnyVal]): List[AnyVal] = actions match {<br/>    ...<br/>    // the rest as in the chapter code<br/>    case Join(ReleaseFish(fish, f)) =&gt;<br/>      goFishingAcc(f(()), fish.copy(name = fish.name + " released") :: log)<br/>}</pre>
<p style="padding-left: 60px">We need to extend the action model and a function, add a helper lifting method, add the additional step to the definition of the process, and augment both interpreters to support the new action.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Chapter 11</h1>
                </header>
            
            <article>
                
<ol start="1">
<li><strong>Name two ways in which an actor can change itself in response to the received message.</strong></li>
</ol>
<p style="padding-left: 90px">An actor can mutate its internal state using a var field. This is a classical object-oriented approach.</p>
<p style="padding-left: 90px">Another way is to use context and become close over some value which will become part of the new state. The context.become can also be used to change the behavior of the actor completely. This is a more functional approach because both state and behavior are in fact immutable.</p>
<ol start="2">
<li><strong>What is the purpose of <kbd>ActorRef</kbd>?</strong></li>
</ol>
<p style="padding-left: 90px">The ActorRef provides a means to address an actor via the actor path. It also encapsulates an actor's mailbox and a dispatcher. Actors in Akka communicate via ActorReference.</p>
<ol start="3">
<li><strong>Look up in the official documentation the description of the system guardian. What is the main purpose of it?</strong></li>
</ol>
<p style="padding-left: 90px">The main purpose of the system guardian is to supervise system level actors. It is also used to ensure a proper shutdown order so that system level actors are available for user-defined actors until the user guardian is terminated.</p>
<ol start="4">
<li><strong>Describe the advantages and disadvantages of using Akka FSM.</strong></li>
</ol>
<p style="padding-left: 90px">Akka FSM allows for the modeling of actor behavior as a state machine defining separate state transitions and data for these states.</p>
<p style="padding-left: 90px">Akka FSM couples business logic to the particular implementation and makes it hard to test and debug.</p>
<ol start="5">
<li><strong>In how many ways can an actor in another actor system be accessed? Describe them.</strong></li>
</ol>
<p style="padding-left: 90px">There are two ways to access an actor in a remote system – remote deployment and remote lookup. With remote deployment, a new actor is created in the remote system. The remote deployment can be done explicitly in the code or by providing a deployment configuration. Remote lookup allows for the selection of an existing actor in a remote system using the same approach as used for the lookup locally.</p>
<ol start="6">
<li><strong>Why does testing actors require a special toolkit?</strong></li>
</ol>
<p style="padding-left: 90px">Actors are highly non-deterministic. The state of the actor is inaccessible. The only way to properly test an actor is by sending messages to it and waiting for its responses. Sometimes a whole actor hierarchy needs to be created for this purpose. </p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Chapter 12</h1>
                </header>
            
            <article>
                
<ol start="1">
<li><strong>What is the meaning of the <kbd>Behavior[Tpe]</kbd> definition?</strong></li>
</ol>
<p style="padding-left: 90px"><kbd>Behavior[Tpe]</kbd> explicitly specifies that this actor is capable of handling messages that are subtypes of <kbd>Tpe</kbd>. By recursion, we can conclude that the returned behavior also will be <kbd>Behavior[Tpe].</kbd></p>
<ol start="2">
<li><strong>How do you get access to the scheduler in the actor's behavior?</strong></li>
</ol>
<p style="padding-left: 90px">The schedule is accessible via the behavior constructor, <kbd>Behaviors.withTimers.</kbd></p>
<ol start="3">
<li><strong>Describe possible ways an actor can be stopped.</strong></li>
</ol>
<p style="padding-left: 90px">An actor can be stopped by the parent using the parent's actor context: <kbd>context.stop(child)</kbd>.</p>
<p style="padding-left: 90px">An actor can also stop itself by returning respective behavior: <kbd>Behaviors.stopped</kbd>.</p>
<p style="padding-left: 90px">An actor can also be stopped if an exception was thrown by the actor's logic and the <kbd>SupervisorStrategy</kbd> defined for this actor is <kbd>stop</kbd>.</p>
<ol start="4">
<li><strong>What is the difference between a local and a cluster receptionist?</strong></li>
</ol>
<p style="padding-left: 90px">There are different implementations but there is no noticeable difference for the developer.</p>
<ol start="5">
<li><strong>What supervision possibilities exist and how are they defined?</strong></li>
</ol>
<p style="padding-left: 90px">There are three supervision strategies: stop, restart, and resume. They are defined by wrapping an actor in supervising behavior using <kbd>Behaviors.supervise</kbd>.</p>
<ol start="6">
<li><strong>Why should stashing be used judiciously?</strong></li>
</ol>
<p style="padding-left: 90px">Current stashing implementation buffers messages in memory and can lead to <kbd>OutOfMemory</kbd> or <span><kbd>StashOverflowException</kbd>, depending on the stash size. If messages are unstashed, the actor will not produce other incoming messages until all stashed bits are processed, which might make it </span>unresponsive.</p>
<ol start="7">
<li><strong>What is a preferred way to test actor logic in isolation?</strong></li>
</ol>
<p style="padding-left: 90px">Synchronous testing using BehaviorTestKit provides better possibilities to test actor logic in isolation.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Chapter 13</h1>
                </header>
            
            <article>
                
<ol start="1">
<li><strong>Name two different modes associated with "classic" streams. Why are they problematic?</strong></li>
</ol>
<p style="padding-left: 90px">The two modes are push and pull. Push is problematic in the case of a slow consumer because it can lead to dropped stream elements or memory overflow. Pull is suboptimal in the case of a slow producer because it can lead to blocking or extensive resource consumption.</p>
<ol start="2">
<li><strong>Why are Reactive Streams considered to work in dynamic pull-push mode?</strong></li>
</ol>
<p style="padding-left: 90px">Reactive Streams introduce the notion of non-blocking back pressure. The consumer reports the demand it has and the producer pushes data in batches according to this demand. When the consumer is faster, the demand is always there so the producer is always pushing data as soon as it is available. If there is a producer which is faster, there is always data available and the consumer just pulls it as soon as it has some demand. The flow automatically switches between these modes.</p>
<ol start="3">
<li><strong>What are the typical building blocks of Akka Stream's graph?</strong></li>
</ol>
<p style="padding-left: 90px">A flow is a stage with exactly one input and one output. Fan-In has multiple inputs and one output. Fan-Out is the opposite with multiple outputs and one input. BidiFlow represents bi-directional flow with two inputs and two outputs.</p>
<ol start="4">
<li><strong>How do you convert a graph into a runnable graph?</strong></li>
</ol>
<p style="padding-left: 90px">A graph can be connected into a runnable graph by connecting a source and a sink to it.</p>
<ol start="5">
<li><strong>What is the main goal of having materialization as a separate explicit step?</strong></li>
</ol>
<p style="padding-left: 90px">Before the materialization step, any graph can be considered to be just a blueprint of the stream and hence can be freely shared and reused.</p>
<ol start="6">
<li><strong>Describe the effects of applying different supervision strategies.</strong></li>
</ol>
<p style="padding-left: 90px">There are three different supervision strategies.</p>
<p style="padding-left: 90px">Stop interrupts the stream in the failed processing stage. The failure propagates downstream and cancellation propagates upstream.</p>
<p style="padding-left: 90px">Resume drops the current element and continues streaming.</p>
<p style="padding-left: 90px">Restart drops the current element, cleans the internal state of the processing stage (usually by re-creating it), and continues steaming.</p>
<ol start="7">
<li><strong>Which main abstractions provide Akka Streams TestKit? Why are they useful?</strong></li>
</ol>
<p style="padding-left: 90px">Two main abstractions provided by Akka Streams TestKit are TestSink and TestSource. They allow the control and verification of assumptions about stream flow on different levels, for example, a high messaging level or low reactive-streams level. They also make it possible to use a nice DSL to drive the test and to formulate expectations about the outcomes.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Chapter 14</h1>
                </header>
            
            <article>
                
<ol start="1">
<li><strong>What is a database migration?</strong></li>
</ol>
<p style="padding-left: 90px">The database migration  (or schema migration) is the automatic management of updates to the database schema. The changes to the schema are incremental, usually reversible, and applied in the moment the database schema needs to be changed in order to reflect changes in the application code.</p>
<ol start="2">
<li><strong><span>Describe what could be an alternative approach to discarding an order completely, in the case of insufficient stock for some articles? </span></strong></li>
</ol>
<p style="padding-left: 90px">One of the alternatives could be to satisfy orders for all articles for which there are sufficient stock. This could be implemented by running each inventory update in a separate transaction and combining the results of all of them that succeeded.</p>
<p style="padding-left: 90px">Yet another alternative would be to satisfy orders as fully as possible. This approach would require selecting rows for update, calculating new possible states, and applying them in the same transaction.</p>
<ol start="3">
<li><strong>Describe the conceptual difference between http4s and Akka HTTP in regard to defining routes.</strong></li>
</ol>
<p style="padding-left: 90px">http4s defines routes as a partial function that pattern matches over the request. Akka HTTP route definition is constructed from nested directives. The requests follow the path through matching directives top-down.</p>
<ol start="4">
<li><strong>Can you name a reason why event-sourced data storage can scale better than a traditional relational database?</strong></li>
</ol>
<p style="padding-left: 90px">Concurrent updates require much more locking and synchronization than append-only operations.</p>
<ol start="5">
<li><strong>Implement a<span> </span><kbd>GET /articles/:name</kbd><span> </span>call with http4s and doobie.</strong></li>
</ol>
<p style="padding-left: 90px">1. Add new route definition:</p>
<p style="padding-left: 90px"> <kbd>case GET -&gt; Root / "articles" / name =&gt; renderInventory(repo.getArticle(name))</kbd></p>
<p style="padding-left: 90px">2. Extend the repository <kbd>getArticle</kbd> method:</p>
<pre style="padding-left: 90px"><span>def </span>getArticle(name: <span>String</span>): Stream[IO, <span>Inventory</span>] =<br/>  <span>sql"SELECT name, count FROM article where name = </span><span>$</span>name<span>"<br/></span><span>    </span>.query[(<span>String</span>, Int)].stream.transact(transactor)<br/>    .fold(<span>Map</span>.<span>empty</span>[<span>String</span>, Int])(_ + _)</pre>
<p style="padding-left: 90px">See the source code in GitHub for the refactored version, which reuses the parameterless definition of <kbd>getInventory.</kbd></p>
<ol start="6">
<li><strong><span>Implement the </span><kbd>GET /articles/:name</kbd><span> call with Akka HTTP and Akka Persistence.</span></strong></li>
</ol>
<p style="padding-left: 90px">1. Add a new query definition:</p>
<pre style="padding-left: 60px"><span>final case class </span>GetArticle(name: <span>String</span>) <span>extends </span>Query</pre>
<p style="padding-left: 90px">2. Add a query handler in <kbd>InventoryActor</kbd>:</p>
<pre style="padding-left: 60px"><span>case </span><span>GetArticle</span>(name) =&gt;<br/>  sender() ! <span>Inventory</span>(<span>inventory</span>.state.filter(_._1 == name))</pre>
<p style="padding-left: 60px">3. Add the route definition:</p>
<pre style="padding-left: 60px">  pathPrefix(<span>"articles"</span>) {<br/>      path(Segment) { name =&gt;<br/>          get {<br/>            complete((inventory ? <span>GetArticle</span>(name)).mapTo[Inventory])<br/>          }<br/>      }<br/>  }</pre>
<p style="padding-left: 90px">The GitHub repository contains this route definition embedded in the previously defined <kbd>lazy val articlesRoutes: Route</kbd>. </p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Chapter 15</h1>
                </header>
            
            <article>
                
<ol>
<li><strong>How do you map the endpoint with the query parameter to a REST call?</strong></li>
</ol>
<pre><span>def answer(parameter: Int): ServiceCall[NotUsed, Done]<br/><br/>override def </span>descriptor: Descriptor = {<br/>  <span>import </span>Service._<br/>  <span>named</span>(<span>"Answer"</span>).withCalls(<br/>    <span>restCall</span>(Method.<span>POST</span>, <span>"/answer?parameter"</span>, answer _)<br/>  )<br/>}</pre>
<ol start="2">
<li><strong>What is the recommended serialization format for persistent entities?</strong></li>
</ol>
<p style="padding-left: 90px">Lagom's recommended serialization format is JSON.</p>
<ol start="3">
<li><strong>Can you explain why clustering is required in order to use persistence in Lagom?</strong></li>
</ol>
<p style="padding-left: 90px">Lagom's persistence is implemented on top of Akka persistence. Akka requires each persistent actor to have a unique persistence ID. In a microservice landscape, each service is supposed to have multiple instances at the same time. Without clustering, there will be multiple persistent actors with the same ID storing events into the same database, which will corrupt data. By utilizing clustering and cluster sharding, Akka makes sure there is only one persistent actor in the cluster across all instances of the service.</p>
<ol start="4">
<li><strong>Describe one possible data model that could be used to make the <kbd>Manager</kbd> to the persistent entity.</strong></li>
</ol>
<pre style="padding-left: 60px"><span>trait </span>ManagerCommand<br/><span>final case class </span>AddCookies(count: Int) <span>extends </span>ManagerCommand <span>with </span>ReplyType[Int]<br/><span>final case class </span>RemoveCookies(count: Int) <span>extends </span>ManagerCommand <span>with </span>ReplyType[Int]<br/><br/><span>trait </span>ManagerEvent<br/><span>final case class </span>NumberOfCookiesChanged(count: Int) <span>extends </span>ManagerEvent <span>with </span>AggregateEvent[NumberOfCookiesChanged] {<br/>  <span>override def </span>aggregateTag: AggregateEventTag[NumberOfCookiesChanged] = <span>AggregateEventTag</span>[NumberOfCookiesChanged](<span>"NumberOfCookiesChanged"</span>)<br/>}<br/><span>sealed trait </span>ManagerState {<br/>  <span>def </span>cookies: Int<br/>}<br/><span>final case class </span>MixingState(cookies: Int) <span>extends </span>ManagerState</pre>
<ol start="5">
<li><strong>Outline an alternative way to implement the Baker service.</strong></li>
</ol>
<p style="padding-left: 90px">The <kbd>Baker</kbd> service could also be implemented message passing style similar to the <kbd>Chef</kbd> service.</p>
<ol start="6">
<li><strong>Can you identify a design bug in the current implementation of the Chef?</strong></li>
</ol>
<p style="padding-left: 90px">The <kbd>Chef</kbd> does not trigger mixing for unbalanced mixing events after recovery.</p>
<ol start="7">
<li><strong>The <kbd>Manager</kbd> implementation stores a number of cookies in memory and this number will be lost at the moment the service restarts. Can you name another reason why it is a bad idea to hold the number of cookies in a local variable?</strong></li>
</ol>
<p style="padding-left: 90px">In a production environment, there will be multiple instances of the service running. Each of them will have its own internal state.</p>


            </article>

            
        </section>
    </div>



  </body></html>