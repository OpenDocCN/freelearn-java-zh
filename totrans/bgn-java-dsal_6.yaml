- en: Graphs, Prime Numbers, and Complexity Classes
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 图、素数和复杂度类
- en: Graph problems are very common in computer science, and their applications pervade
    many real-life applications. Everything that can be represented by entities and
    their relationships can ultimately be modeled by a graph. How we connect with
    friends on social media, how route-planning applications are able to find the
    shortest route, and how e-commerce websites are able to provide us with recommendations
    are all examples of problems modeled by graphs.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 图问题在计算机科学中非常常见，它们的应用渗透到许多现实生活中的应用。所有可以用实体及其关系表示的事物最终都可以用图来建模。我们在社交媒体上如何与朋友互动，路线规划应用如何找到最短路径，以及电子商务网站如何提供推荐都是用图建模的问题示例。
- en: A graph is a structure composed of a set of objects in which some pairs of objects
    are related. The objects are modeled by the mathematical abstraction of vertices
    (sometimes also called nodes), and the pairwise relationships are modeled by the
    mathematical abstraction of edges (sometimes also called arcs).
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 图是由一组对象组成的结构，其中某些对象对之间存在关系。这些对象由顶点的数学抽象（有时也称为节点）来表示，而成对关系由边的数学抽象（有时也称为弧）来表示。
- en: Edges can be directed or undirected. A directed edge is an edge which has a
    direction associated with it. A graph that is composed of directed edges is called
    a directed graph. A graph that is composed of undirected edges is called an undirected
    graph. In a directed edge, it is common to call the start of the edge the head
    and the end of the edge the tail. In a directed graph, the out-degree of a vertex
    is the number of edges whose head is adjacent to it. The in-degree of a vertex
    is the number of edges whose tail is adjacent to it.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 边可以是有向的或无向的。一个有向边是指与它相关联有方向的边。由有向边组成的图称为有向图。由无向边组成的图称为无向图。在有向边中，通常将边的起点称为头，将终点称为尾。在有向图中，一个顶点的出度是指与它相邻的头边的数量。一个顶点的入度是指与它相邻的尾边的数量。
- en: '*Figure 6.1* gives an example of a directed graph with six nodes and eight
    edges, as follows:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: '*图6.1* 给出了一个包含六个节点和八条边的有向图的示例，如下所示：'
- en: '![](img/bc8a9fae-e427-4835-a3d5-69a984df089b.png)'
  id: totrans-5
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/bc8a9fae-e427-4835-a3d5-69a984df089b.png)'
- en: 'Figure 6.1: A directed graph'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.1：一个有向图
- en: '*Figure 6.2* gives an example of an undirected graph with five nodes and seven
    edges, as follows:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: '*图6.2* 给出了一个包含五个节点和七条边的无向图的示例，如下所示：'
- en: '![](img/298ca250-bda8-4e99-972c-3fa860ae7598.png)'
  id: totrans-8
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/298ca250-bda8-4e99-972c-3fa860ae7598.png)'
- en: 'Figure 6.2: An undirected graph'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.2：一个无向图
- en: Before we dive into how to represent a graph in a computer program, it is important
    to describe how the runtime of graph algorithms is usually characterized. As previously
    stated, a graph, *G*, can be seen as a set of vertices and edges, that is, *G
    = (V, E)*. As such, the size of the input is usually measured in terms of the
    number of vertices (*|V|*) and the number of edges (*|E|*). So, instead of relying
    solely on a single input size, *N*, the runtime of graph algorithms usually refers
    to both *|V|* and *|E|*. In big O notation, it is common to use *V* to denote
    *|V|* and *E* to denote *|E|*. For example, an algorithm that runs in time proportional
    to the number of vertices multiplied by the number of edges is said to run in
    time *O(VE)*.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入探讨如何在计算机程序中表示图之前，描述图算法的运行时间通常是如何表征的是非常重要的。如前所述，一个图，*G*，可以看作是一组顶点和边，即 *G
    = (V, E)*。因此，输入的大小通常以顶点数（*|V|*）和边数（*|E|*）来衡量。所以，而不是仅仅依赖于单个输入大小 *N*，图算法的运行时间通常指的是
    *|V|* 和 *|E|*。在大的 O 表示法中，通常使用 *V* 来表示 *|V|*，使用 *E* 来表示 *|E|*。例如，运行时间与顶点数乘以边数成比例的算法被称为运行时间
    *O(VE)*。
- en: Representing Graphs
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 表示图
- en: 'There are usually two standard ways to represent a graph *G = (V, E)* in a
    computer program:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在计算机程序中通常有两种标准方式来表示图 *G = (V, E)*：
- en: As a collection of adjacency lists
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为邻接表的集合
- en: As an adjacency matrix
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为邻接矩阵
- en: You can use either way to represent both directed and undirected graphs. We'll
    start by looking at the adjacency list representation.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用这两种方式来表示有向和无向图。我们将首先查看邻接表表示法。
- en: Adjacency List Representation
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 邻接表表示法
- en: 'The adjacency list representation of a graph consists of an array of *|V|*
    lists, one for each vertex in *V*. For each vertex *u* in *V*, there''s a list
    containing all vertices *v* so that there is an edge connecting *u* and *v* in
    *E*. *Figure 6.3* shows the adjacency list representation of the directed graph
    in *Figure 6.1*:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 图的邻接表表示由一个包含 *|V|* 个列表的数组组成，每个列表对应于 *V* 中的一个顶点。对于 *V* 中的每个顶点 *u*，都有一个包含所有顶点
    *v* 的列表，使得在 *E* 中存在连接 *u* 和 *v* 的边。*图 6.3* 展示了 *图 6.1* 中有向图的邻接表表示：
- en: '![](img/c6f058c4-8d1a-4696-89bc-6eca0d572fd3.png)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c6f058c4-8d1a-4696-89bc-6eca0d572fd3.png)'
- en: 'Figure 6.3: Adjacency list representation of the directed graph in Figure 6.1'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.3：图 6.1 中有向图的邻接表表示
- en: For undirected graphs, we follow a similar strategy and build the adjacency
    list as if it were a directed graph with two edges between each pair of vertices
    *u* and *v*, which are *(u, v)* and *(v, u)*.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 对于无向图，我们遵循类似的策略，并构建邻接表，就像它是一个有向图，其中每对顶点 *u* 和 *v* 之间有两个边，分别是 *(u, v)* 和 *(v,
    u)*。
- en: '*Figure 6.4* shows the adjacency list representation of the undirected graph
    in *Figure 6.2*:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6.4* 展示了 *图 6.2* 中的无向图的邻接表表示：'
- en: '![](img/cce9c0c2-0290-4236-b3ec-ec499b019aae.png)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![](img/cce9c0c2-0290-4236-b3ec-ec499b019aae.png)'
- en: 'Figure 6.4: Adjacency list representation of the undirected graph in Figure
    6.2'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.4：图 6.2 中无向图的邻接表表示
- en: If *G* is a directed graph, the sum of the lengths of all the adjacency lists
    is *|E|*, as each edge constitutes a single node in one of the adjacency lists.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 *G* 是一个有向图，所有邻接表长度的总和是 *|E|*，因为每条边构成邻接表中的一个单独节点。
- en: If *G* is an undirected graph, the sum of the lengths of all the adjacency lists
    is *2*|E|*, since each edge *(u, v)* appears twice, that is, once in *u*'s and
    once in *v*'s adjacency list.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 *G* 是一个无向图，所有邻接表长度的总和是 *2*|E|*，因为每条边 *(u, v)* 出现两次，即一次在 *u* 的邻接表中，一次在 *v*
    的邻接表中。
- en: For both types of graphs, the adjacency list representation has the property
    of requiring an amount of memory equal to *O(V + E)*.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这两种类型的图，邻接表表示具有需要与 *O(V + E)* 相等的内存量的特性。
- en: 'The following code snippet shows how to create a graph using the adjacency
    list representation in Java:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段展示了如何使用 Java 中的邻接表表示创建图：
- en: '[PRE0]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Snippet 6.1: Implementation of an adjacency list representation of a graph.
    Source class name: Adjacencylistgraph'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 片段 6.1：图的邻接表表示实现。源类名：Adjacencylistgraph
- en: Go to [https://goo.gl/Jrb2jH](https://goo.gl/Jrb2jH) to access this code.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 前往 [https://goo.gl/Jrb2jH](https://goo.gl/Jrb2jH) 访问此代码。
- en: It is common for one to have weighted graphs, that is, graphs in which each
    edge has an associated weight. The adjacency list representation is robust enough
    to support different graph variants, since we can store different edge representations
    in the adjacency lists.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 对于加权图，即每条边都有一个相关权重的图，这是很常见的。邻接表表示足够健壮，可以支持不同的图变体，因为我们可以在邻接表中存储不同的边表示。
- en: We can store different edge representations in adjacency lists because we store
    the edges themselves, thereby allowing customizable representations.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在邻接表中存储不同的边表示，因为我们存储了边本身，从而允许自定义表示。
- en: Writing a Java Code to Add Weights to the Directed Graph
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写 Java 代码向有向图添加权重
- en: The aim is to adapt the implementation of the `AdjacencyListGraph` class to
    support weights on edges.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 目标是修改 `AdjacencyListGraph` 类的实现以支持边的权重。
- en: 'The steps should be the following:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 步骤应该是以下这些：
- en: Understand *Snippet 6.1* showing how we can implement the adjacency list representation
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 理解 *片段 6.1* 展示了如何实现邻接表表示
- en: Adapt the implementation so that the array list can store the weights
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改实现方式，以便数组列表可以存储权重
- en: '[PRE1]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Snippet 6.2: Implementation of an adjacency list representation of a weighted
    graph. Source class name: Adjacencylistweightedgraph'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 片段 6.2：加权图的邻接表表示实现。源类名：Adjacencylistweightedgraph
- en: Go to [https://goo.gl/uoazxy](https://goo.gl/uoazxy) to access this code.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 前往 [https://goo.gl/uoazxy](https://goo.gl/uoazxy) 访问此代码。
- en: Adjacency Matrix Representation
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 邻接矩阵表示
- en: The adjacency list representation of a graph provides a compact way to represent
    sparse graphs, for example, those for which *|E|* is much less than *|V|²*. Even
    though it is a representation that is useful for a lot of algorithms (which we
    will visit later), it does not support some features. For example, one cannot
    quickly tell whether there is an edge connecting two given vertices. In order
    to determine if *u* and *v* are connected, one has to go through the adjacency
    list of *u* to find an edge connecting it to *v*. Since the adjacency list of
    *u* can have at most *E* edges, this procedure runs in *O(E)* time. One alternative
    representation that remedies this disadvantage at the cost of using asymptotically
    more memory is the adjacency matrix representation.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 图的邻接表表示法提供了一种紧凑的方式来表示稀疏图，例如那些*|E|*远小于*|V|²*的图。尽管这种表示法对许多算法（我们将在后面讨论）很有用，但它不支持一些特性。例如，无法快速判断两个给定的顶点之间是否存在边。为了确定*u*和*v*是否相连，必须遍历*u*的邻接表以找到连接到*v*的边。由于*u*的邻接表最多有*E*条边，这个过程的时间复杂度为*O(E)*。一种替代的表示法是邻接矩阵表示法，它以使用更多内存的代价来弥补这一缺点。
- en: The main disadvantage of adjacency list representation of a weighted graph representation
    is that we can't quickly determine if a given edge *(u, v)* is present in the
    graph.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 加权图邻接表表示法的主要缺点是我们无法快速确定给定的边*(u, v)*是否存在于图中。
- en: 'In this representation, a graph *G = (V, E)* is represented by a *|V| x |V|*
    matrix *A = (a[ij])*, where *a[ij]* equals *1* if there''s an edge *(i, j)* and
    *0* otherwise. The following table shows the adjacency matrix representation of
    the directed graph of *Figure 6.1*:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种表示法中，图*G = (V, E)*由一个*|V| x |V|*矩阵*A = (a[ij])*表示，其中*a[ij]*等于*1*如果存在边*(i,
    j)*，否则为*0*。以下表格展示了*图6.1*的有向图的邻接矩阵表示法：
- en: '![](img/190d01d6-1224-455b-b4e8-b88fdaaec6bb.png)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![](img/190d01d6-1224-455b-b4e8-b88fdaaec6bb.png)'
- en: 'Table 6.1: Adjacency matrix representation of the directed graph of Figure
    6.1'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 表6.1：*图6.1*的有向图的邻接矩阵表示法
- en: 'The following table shows the adjacency matrix representation of the undirected graph
    of *Figure 6.2*:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 以下表格展示了*图6.2*的无向图的邻接矩阵表示法：
- en: '![](img/52459e9a-347f-43b9-98b6-fd7b932b3f5c.png)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![](img/52459e9a-347f-43b9-98b6-fd7b932b3f5c.png)'
- en: 'Table 6.2: Adjacency matrix representation of the undirected graph of Figure
    6.2'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 表6.2：*图6.2*的无向图的邻接矩阵表示法
- en: The adjacency matrix representation of a graph requires *O(V²)* memory, independent
    of the number of edges in the graph. One thing to note on the adjacency matrix
    representation of undirected graphs is that the matrix is symmetrical along the
    main diagonal, since *(u, v)* and *(v, u)* represent the same edge. As such, the
    adjacency matrix of an undirected graph is its own transpose *(A = A^T)*. Taking
    advantage of this symmetry, one can cut on the memory needed to store the graph
    almost in half, as you don't need the array of each vertex to have size *V*. If
    *i* tracks the index of vertices in *V*, the size of *array[i]* can decrease by
    one as *i* increases by one.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 图的邻接矩阵表示法需要*O(V²)*的内存，与图中边的数量无关。在无向图的邻接矩阵表示法中需要注意的一点是，矩阵沿主对角线是对称的，因为*(u, v)*和*(v,
    u)*代表同一条边。因此，无向图的邻接矩阵是其自身的转置*(A = A^T)*。利用这种对称性，可以将存储图所需的内存几乎减半，因为不需要每个顶点的数组大小为*V*。如果*i*跟踪*V*中顶点的索引，那么随着*i*的增加，*array[i]*的大小可以减少一个。
- en: 'The following code shows how to create a graph using the adjacency matrix representation
    in Java:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码展示了如何在Java中使用邻接矩阵表示法创建一个图：
- en: '[PRE2]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Snippet 6.3: Implementation of an adjacency matrix representation of a directed
    graph. Source class name: AdjacencyMatrixGraph'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 程序片段6.3：有向图邻接矩阵表示法的实现。源代码类名：AdjacencyMatrixGraph
- en: Go to [https://goo.gl/EGyZJj](https://goo.gl/EGyZJj) to access this code.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 前往[https://goo.gl/EGyZJj](https://goo.gl/EGyZJj)访问此代码。
- en: The adjacency matrix representation is also robust enough to support different
    graph variants. In order to support weighted graphs, for example, one can store
    the weight of the edge in *a[ij]*, instead of just one. The adjacency list representation
    is asymptotically at least as space-efficient as the adjacency matrix representation,
    but adjacency matrices are simpler, so they might be preferable when the graphs
    are reasonably small or dense. As previously stated, a sparse graph is one in
    which *|E|* is much less than *|V|²*, whereas a dense graph is one in which *|E|*
    is closer to *|V|²*. The adjacency list representation is more memory-efficient
    for sparse graphs. For dense graphs, an adjacency matrix representation is better
    suited, as it possibly takes less memory due to list pointers.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 邻接矩阵表示也足够健壮，可以支持不同的图变体。例如，为了支持加权图，可以在 *a[ij]* 中存储边的权重，而不仅仅是存储一个。邻接表表示在空间效率上至少与邻接矩阵表示一样，但邻接矩阵更简单，因此当图相对较小或密集时，它们可能更可取。如前所述，稀疏图是指
    *|E|* 远小于 *|V|²* 的图，而密集图是指 *|E|* 接近 *|V|²* 的图。对于稀疏图，邻接表表示更节省内存。对于密集图，邻接矩阵表示更适合，因为它可能由于列表指针而占用更少的内存。
- en: 'Activity: Building the Adjacency Matrix Representation of a Weighted Undirected
    Graph'
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 活动：构建加权无向图的邻接矩阵表示
- en: '**Scenario**'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '**场景**'
- en: Creating an adjacency matrix for a weighted undirected graph to be used for
    social networking website.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 为社交网站创建一个用于加权无向图的邻接矩阵。
- en: '**Aim**'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '**目标**'
- en: To write a code in Java for implementing the adjacency matrix representation
    of a weighted undirected graph.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 编写一个Java代码来实现加权无向图的邻接矩阵表示。
- en: '**Prerequisites**'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '**先决条件**'
- en: 'For this activity, you have to implement methods `addEdge()` and `edgeWeight()`
    of class `AdjacencyMatrixWeightedUndirected` available at the following URL:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个活动，你必须实现位于以下URL的 `AdjacencyMatrixWeightedUndirected` 类的 `addEdge()` 和 `edgeWeight()`
    方法：
- en: '[https://github.com/TrainingByPackt/Data-Structures-and-Algorithms-in-Java/blob/master/src/main/java/com/packt/datastructuresandalg/lesson6/activity/weightedundirected/AdjacencyMatrixWeightedUndirected.java](https://github.com/TrainingByPackt/Data-Structures-and-Algorithms-in-Java/blob/master/src/main/java/com/packt/datastructuresandalg/lesson6/activity/weightedundirected/AdjacencyMatrixWeightedUndirected.java)'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/TrainingByPackt/Data-Structures-and-Algorithms-in-Java/blob/master/src/main/java/com/packt/datastructuresandalg/lesson6/activity/weightedundirected/AdjacencyMatrixWeightedUndirected.java](https://github.com/TrainingByPackt/Data-Structures-and-Algorithms-in-Java/blob/master/src/main/java/com/packt/datastructuresandalg/lesson6/activity/weightedundirected/AdjacencyMatrixWeightedUndirected.java)'
- en: The methods should add an edge and return the edge weight between two vertices, respectively.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 这些方法应该添加一条边并返回两个顶点之间的边权重。
- en: '**Steps for Completion**'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '**完成步骤**'
- en: Start storing the weights of edges in each cell of the matrix. Since we're dealing
    with undirected graphs, both *(u, v)* and *(v, u)* refer to the same edge, so
    we need to update both accordingly.
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 开始在每个矩阵的单元格中存储边的权重。由于我们处理的是无向图，所以 *(u, v)* 和 *(v, u)* 都指代同一条边，因此我们需要相应地更新两者。
- en: It is also possible to not repeat the weight assignment. We just have to be
    careful and always choose one of *(u, v)* or *(v, u)* when referring to that edge.
    One possible strategy is to always use *(min(u, v), max(u, v))*. Using that strategy,
    we also don't need to store the full matrix, thereby saving some space.
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 也可以不重复权重分配。我们只需小心，在引用那条边时始终选择 *(u, v)* 或 *(v, u)* 中的一个。一个可能的策略是始终使用 *(min(u,
    v), max(u, v))*. 使用该策略，我们也不需要存储完整的矩阵，从而节省一些空间。
- en: In this first section, we learned two different ways of representing a graph
    in a computer program. We briefly examined the pros and cons of each representation,
    and we will take a look at their usefulness when implementing graph algorithms
    in the following sections.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们学习了两种不同的方式在计算机程序中表示图。我们简要地考察了每种表示的优点和缺点，并在接下来的章节中我们将探讨它们在实现图算法时的有用性。
- en: Traversing a Graph
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 图的遍历
- en: A common activity on a graph is visiting each vertex of it in a given order.
    We will start by introducing the breadth-first search, and then follow with depth-first
    search. Both of these techniques form the archetype for many important graph algorithms, as
    we will see later with the cycle detection and Dijkstra's algorithm for single-source shortest
    paths.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 图上的一个常见活动是以给定顺序访问图中的每个顶点。我们将首先介绍广度优先搜索，然后是深度优先搜索。这两种技术都是许多重要图算法的原型，我们将在后面的循环检测和单源最短路径的Dijkstra算法中看到。
- en: Breadth-First Search
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 广度优先搜索
- en: Given a graph *G = (V, E)* and a source vertex s, breadth-first search explores
    the edges of *G* systematically to discover every vertex that is reachable from
    *s*. While doing so, it computes the smallest number of edges from *s* to each
    reachable vertex, making it suitable to solve the single-source shortest path
    problem on unweighted graphs, or graphs whose edges all have the same weight.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 给定一个图*G = (V, E)*和一个源顶点s，广度优先搜索系统地探索*G*的边，以发现从*s*可达的每个顶点。在此过程中，它计算从*s*到每个可达顶点的最小边数，这使得它适合解决无权图或所有边都具有相同权重的图上的单源最短路径问题。
- en: '**Breadth-First Search** (**BFS**) is named so because it expands the frontier
    between discovered and undiscovered vertices uniformly across the breadth of the
    frontier. In that sense, the algorithm first explores vertices at distance *k*
    from *s* before discovering vertices at distance *k + 1*. To keep track of progress,
    breadth-first search identifies each vertex as undiscovered, discovered, or expanded.
    All vertices start out undiscovered. A vertex is discovered the first time it
    is encountered during search, and is expanded when all the vertices adjacent to
    it have been discovered.'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '**广度优先搜索**（**BFS**）之所以命名为BFS，是因为它在搜索前沿的宽度上均匀地扩展了已发现和未发现顶点之间的边界。从这个意义上说，算法首先探索距离*s*为*k*的顶点，然后再发现距离*k
    + 1*的顶点。为了跟踪进度，广度优先搜索将每个顶点标识为未发现、已发现或已扩展。所有顶点最初都是未发现的。顶点在第一次遇到搜索时被发现，当所有相邻的顶点都被发现时，它被扩展。'
- en: BFS constructs a breadth-first tree, rooted at source vertex *s*. Whenever the
    search discovers an undiscovered vertex *v* when scanning the outward edges of
    already discovered vertex *u*, the vertex *v* and the edge *(**u, v**)* are added
    to the tree. Therefore, *u* becomes the parent of *v* in the breadth-first tree.
    Since a vertex is discovered at most once, it has at most one parent.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: BFS构建一个以源顶点*s*为根的广度优先树。每当搜索在已发现的顶点*u*的外向边扫描时发现一个未发现的顶点*v*，顶点*v*和边**(u, v)**将被添加到树中。因此，*u*成为广度优先树中*v*的父节点。由于一个顶点最多被发现一次，它最多有一个父节点。
- en: 'In order to illustrate this, let''s look at a run of breadth-first searches
    for the directed graph of *Figure 6.1*, starting at node 2, in the following table:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明这一点，让我们看一下以下表中从*图6.1*的定向图开始的广度优先搜索的运行，起始节点为2：
- en: '![](img/bacec7ef-7200-40aa-b815-4b0fd60114cb.png)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/bacec7ef-7200-40aa-b815-4b0fd60114cb.png)'
- en: 'Table 6.3: A Run of BFS on the directed graph of Figure 6.1, starting at node
    2'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 表6.3：在图6.1中，从节点2开始的BFS运行
- en: There are a lot of insights to take from the breadth-first tree. For instance,
    the path from the root to a given node in the tree is the shortest path (in terms
    of edges) from those two vertices. Another thing to note is that vertices that
    are not in the breadth-first tree (as is the case of 0) are unreachable from the
    root vertex.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 从广度优先树中可以得出很多见解。例如，从根到树中给定节点的路径是从这两个顶点之间的最短路径（以边数计）。另一个需要注意的事项是，不在广度优先树中的顶点（例如0）是从根顶点不可达的。
- en: We previously saw how to perform the breadth-first search on trees. BFS on graphs
    is similar, but we need to keep track of explored nodes so that we don't get stuck
    in cycles. In order to implement breadth-first search, we will assume that our
    graph is represented using adjacency lists.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前看到了如何在树上执行广度优先搜索。图上的BFS与之类似，但我们需要跟踪已探索的节点，以免陷入循环。为了实现广度优先搜索，我们将假设我们的图使用邻接表表示。
- en: 'We will attach certain attributes to each vertex in the graph that will allow
    us to guide our search and later construct the breadth-first tree. We will also
    use a first-in, first-out queue (covered in [Chapter 2](ab7975d0-4b38-437d-9ff5-8f6c20199874.xhtml),
    *Sorting Algorithms and Fundamental Data Structures*) to manage the set of discovered
    vertices. The following code snippet illustrates the implementation of breadth-first
    search:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将给图中的每个顶点附加某些属性，这将允许我们引导搜索并在以后构建广度优先树。我们还将使用一个先进先出队列（在第2章中介绍，*排序算法和基本数据结构*）来管理已发现的顶点集。以下代码片段说明了广度优先搜索的实现：
- en: '[PRE3]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Snippet 6.4: Implementation of breadth-first search. Source class name: BFS.Graph'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 代码片段6.4：广度优先搜索的实现。源类名：BFS.Graph
- en: Go to [https://goo.gl/VqrQWM](https://goo.gl/VqrQWM) to access this code.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 前往[https://goo.gl/VqrQWM](https://goo.gl/VqrQWM)访问此代码。
- en: 'Let''s focus on the implementation of the BFS function. We will start by initializing
    a couple of auxiliary arrays: `parent` and `visited`. The first one will hold,
    at `parent[i]`, the parent of node `i` in the breadth-first tree. The second one
    will tell us, at `visited[i]`, whether or not vertex `i` has been discovered.
    We start by discovering the starting node and adding it to a queue. The queue
    will keep those vertices that have been discovered but not yet expanded. As such,
    while there are still elements in the queue, we will take its first element, go
    through its adjacent vertices, and discover those that haven''t already been discovered,
    adding them to the queue.'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们专注于 BFS 函数的实现。我们首先初始化几个辅助数组：`parent` 和 `visited`。第一个数组将保存 `parent[i]`，表示在广度优先树中节点
    `i` 的父节点。第二个数组将告诉我们 `visited[i]`，表示顶点 `i` 是否已被发现。我们首先发现起始节点并将其添加到队列中。队列将保持那些已发现但尚未扩展的顶点。因此，当队列中仍有元素时，我们将取其第一个元素，遍历其相邻顶点，并发现那些尚未被发现的顶点，将它们添加到队列中。
- en: When the queue becomes empty, we're sure of having expanded all vertices that
    are reachable from the starting vertex.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 当队列变为空时，我们确信已经扩展了从起始顶点可达的所有顶点。
- en: In the previous implementation, we've returned the array of parent nodes of
    the breadth-first tree in the `bfs()` function, allowing us to reconstruct the
    paths. If not necessary, you could just return the size of paths, or any other
    information we might be interested in extracting from the breadth-first search
    traversal.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的实现中，我们在 `bfs()` 函数中返回了广度优先树的父节点数组，这使得我们可以重建路径。如果不需要，你只需返回路径的大小，或者从广度优先搜索遍历中提取的任何其他信息即可。
- en: In the `bfs()` method, we're sure of enqueuing, and hence dequeuing, each vertex
    at most once. As such, the total time dedicated to queue operations is *O(V)*.
    After dequeuing each vertex, we scan its adjacency list. Since we dequeue each
    vertex at most once, we scan each adjacency list at most once. As the sum of lengths
    of all the adjacency lists is *O(E)*, the total time spent in scanning adjacency
    lists is *O(E)*. Therefore, the BFS procedure has an initialization time of *O(V)*
    and a total running time of *O(V + E)*, running in linear time to the size of
    the adjacency list representation of *G*.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `bfs()` 方法中，我们确信每个顶点最多入队和出队一次。因此，队列操作的总时间复杂度是 *O(V)*。出队每个顶点后，我们扫描其邻接表。由于我们每个顶点最多出队一次，我们最多扫描每个邻接表一次。由于所有邻接表长度的总和是
    *O(E)*，扫描邻接表的总时间复杂度是 *O(E)*。因此，BFS 程序的初始化时间是 *O(V)*，总运行时间是 *O(V + E)*，其运行时间与 *G*
    的邻接表表示的大小成线性关系。
- en: As we will see in later sections, the BFS procedure is the archetype for many
    important graph algorithms.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们将在后面的章节中看到的，BFS 程序是许多重要图算法的原型。
- en: Depth-First Search
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 深度优先搜索
- en: Given a graph *G = (V, E)* and a source vertex s, depth-first search explores
    the edges of the graph by going "deeper" in the graph whenever possible. **Depth-First
    Search** (**DFS**) explores edges adjacent to the most recently discovered vertex
    *v* that still has unexplored edges whose head is adjacent to it. Once all of
    *v*'s edges have been explored, the search "backtracks" to explore edges, leaving
    the vertex from which *v* was discovered. The process continues until all vertices
    that are reachable from the original source vertex have been discovered.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 给定一个图 *G = (V, E)* 和一个源顶点 s，深度优先搜索通过尽可能地在图中“深入”来探索图的边。**深度优先搜索**（**DFS**）探索与最近发现的顶点
    *v* 相邻且其头节点也相邻的未探索边。一旦 *v* 的所有边都被探索过，搜索将“回溯”以探索边，离开从 *v* 被发现的那个顶点。这个过程会一直持续到从原始源顶点可达的所有顶点都被发现。
- en: If any undiscovered vertices remain, then DFS selects one of them as a new source,
    and it repeats the search from that source. While it may seem odd that BFS limits
    itself to vertices reachable from a single source whereas DFS considers multiple
    sources, the reason behind it is related to the applications of these searches.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 如果还有未发现的顶点，那么 DFS 会从中选择一个作为新的源点，并从该源点重复搜索。虽然 BFS 限制自己只考虑从单个源点可达的顶点，而 DFS 考虑多个源点可能看起来有些奇怪，但背后的原因与这些搜索的应用有关。
- en: BFS is usually used to find shortest-path distances while DFS is often used
    as a subroutine in another algorithm, which we shall see when we explore the cycle
    detection problem.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: BFS 通常用于查找最短路径距离，而 DFS 经常被用作其他算法的子程序，我们将在探索循环检测问题时看到这一点。
- en: Similar to BFS, when we discover a vertex *v* during the scan of the adjacency
    list of an already discovered vertex, we record its parent attribute. Since we
    mentioned that we explore different sources, the parent subgraph produced by DFS
    is, unlike the breadth-first tree, a forest (that is, a set of trees).
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 与BFS类似，当我们扫描已发现顶点的邻接表时发现顶点 *v*，我们记录其父属性。由于我们提到我们探索不同的来源，DFS产生的父子图与广度优先树不同，它是一个森林（即一组树）。
- en: 'In order to illustrate this, let''s look  at a run of DFS for the directed
    graph of *Figure 6.1*, starting at *node 2*, in the following table:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明这一点，让我们看看以下表格中从 *node 2* 开始的DFS对 *Figure 6.1* 的有向图的运行情况：
- en: '![](img/cf3f6f30-0e1b-496c-98fd-d08a5d877fac.png)![](img/c4409456-7b0c-43ac-b420-25981eed3d0f.png)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
  zh: '![](img/cf3f6f30-0e1b-496c-98fd-d08a5d877fac.png)![](img/c4409456-7b0c-43ac-b420-25981eed3d0f.png)'
- en: 'Table 6.4: A run of DFS on the directed graph of Figure 6.1, starting at node
    2'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: Table 6.4：从节点2开始对Figure 6.1的有向图执行DFS的运行情况
- en: Note that the results of DFS may depend on the order in which the vertices are examined.
    In the previous case, we started with 2 and always went for the lowest-numbered
    vertex in the adjacency list of a vertex first. If we had started with vertex
    0, we would have a different forest. In practice, we can usually use any DFS result
    with equivalent results.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，DFS的结果可能取决于顶点检查的顺序。在前面的例子中，我们从2开始，总是先访问顶点邻接表中的编号最小的顶点。如果我们从顶点0开始，我们将得到不同的森林。在实践中，我们通常可以使用任何具有等效结果的DFS结果。
- en: We previously saw how to perform DFS on trees. DFS on graphs is similar, but
    we need to keep track of explored nodes so that we don't get stuck in cycles.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前看到了如何在树上执行DFS。图上的DFS类似，但我们需要跟踪已探索的节点，以避免陷入循环。
- en: 'In order to implement DFS, we will assume that our graph is represented using
    adjacency lists. We will attach certain attributes to each vertex in the graph,
    which will allow us to guide our search and later construct the depth-first forest.
    The following code snippet illustrates the implementation of depth-first search:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现DFS，我们将假设我们的图使用邻接表表示。我们将为图中的每个顶点附加某些属性，这将允许我们引导搜索并在以后构建深度优先森林。以下代码片段说明了深度优先搜索的实现：
- en: '[PRE4]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Snippet 6.5: Implementation of depth-first search. Source class name:dfs.Graph.'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 'Snippet 6.5: 深度优先搜索的实现。源类名：dfs.Graph。'
- en: Go to [https://goo.gl/saZYQp](https://goo.gl/saZYQp) to access this code.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 前往 [https://goo.gl/saZYQp](https://goo.gl/saZYQp) 访问此代码。
- en: The DFS procedure works by initializing all vertices as not visited, and setting
    their parents to *-1* (meaning that they have no parent). Then, we find the first
    undiscovered vertex and visit it. In each visit, we start by recording the vertex
    as visited and then going through its adjacency list. There, we are looking for
    vertices not yet discovered. Once we find one, we visit it. Looking at the previous
    implementation, we see that the loops inside DFS take time *O(V)*, as they run
    for each vertex in the graph. We can also see that the `dfsVisit()` method is
    called exactly once for each vertex. During the execution of `dfsVisit()`, the
    loop scanning the adjacency list executes in time proportional to the size of
    the vertex's adjacency list. Since we said before that `dfsVisit()` is called
    exactly once for each vertex, the total time spent in the loop is proportional
    to the sum of the sizes of all adjacency lists, that is, *O(E)*. Therefore, the
    total running time of DFS is *O(V + E)*.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: DFS过程通过将所有顶点初始化为未访问状态，并将它们的父设置为 *-1*（表示它们没有父节点）来工作。然后，我们找到第一个未发现的顶点并访问它。在每次访问中，我们首先记录顶点为已访问，然后遍历其邻接表。在那里，我们在寻找尚未发现的顶点。一旦找到，我们就访问它。查看前面的实现，我们看到DFS内部的循环时间复杂度为
    *O(V)*，因为它们为图中的每个顶点运行。我们还可以看到`dfsVisit()`方法对每个顶点恰好调用一次。在`dfsVisit()`执行过程中，扫描邻接表的循环执行时间与顶点邻接表的大小成比例。由于我们之前提到`dfsVisit()`对每个顶点恰好调用一次，循环中花费的总时间与所有邻接表大小的总和成比例，即
    *O(E)*。因此，DFS的总运行时间为 *O(V + E)*。
- en: In the DFS method, we're returning the parent array, but the return type of
    this routine is usually adapted depending on the larger task that a more general
    algorithm that uses DFS is trying to achieve. We'll see DFS adapted to our specific
    needs in the next section.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在DFS方法中，我们返回父数组，但此例程的返回类型通常根据使用DFS的更通用算法试图实现的大任务而调整。我们将在下一节中看到DFS如何适应我们的特定需求。
- en: Cycle Detection
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 循环检测
- en: 'A useful application of DFS is determining whether or not a graph is acyclic
    (that is, it does not contain cycles). In order to do so, it''s important to define
    four types of edges in terms of the depth-first forest produced by DFS. They are
    as follows:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: DFS 的一个有用应用是确定一个图是否是无环的（即不包含环）。为了做到这一点，根据 DFS 生成的深度优先森林定义四种类型的边非常重要。它们如下：
- en: '**Tree edges**: They are edges in the depth-first forest. An edge can only
    be a tree edge if it was the one explored when first discovering a vertex.'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**树边**：它们是深度优先森林中的边。一条边只有在首次发现一个顶点时被探索时才能成为树边。'
- en: '**Back edges**: They are edges connecting a vertex to an ancestor in a depth-first
    tree. Self-loops (which may occur in directed graphs) are back edges.'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**回边**：它们是连接深度优先树中一个顶点到其祖先的边。自环（可能出现在有向图中）是回边。'
- en: '**Forward edges**: They are edges that do not belong to a depth-first tree
    but connect a vertex to one of its descendants in a depth-first tree. Forward
    edges are therefore edges that weren''t used when performing the DFS, but connect vertices
    *u* and *v* in a depth-first tree provided that *v* is a descendant of *u* in
    the tree.'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**前向边**：它们是不属于深度优先树但连接深度优先树中一个顶点及其后代的边。因此，前向边是在执行 DFS 时未使用的边，但它们在深度优先树中连接顶点
    *u* 和 *v*，前提是 *v* 是树中 *u* 的后代。'
- en: '**Cross edges**: They are all other edges. They can go between vertices in
    the same depth-first tree or they can go between vertices in different depth-first trees.
    They are therefore edges that weren''t used when performing the depth-first search,
    but connect vertices that don''t share an ancestor relationship in the same tree
    or vertices in different trees.'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**交叉边**：它们是所有其他边。它们可以在同一深度优先树中的顶点之间，也可以在不同深度优先树中的顶点之间。因此，它们是在执行深度优先搜索时未使用的边，但连接了在同一树中不共享祖先关系的顶点或不同树中的顶点。'
- en: Having classified edges, it is possible to show that a directed graph is acyclic
    if and only if a DFS does not produce back edges. If a depth-first search produces
    a back edge *(u, v)*, then vertex *v* is an ancestor of vertex *u* in the depth-first
    forest. Therefore, *G* contains a path from *v* to *u*, and *(u, v)* completes
    a cycle. This algorithm is generalizable for undirected graphs. In undirected
    graphs, if we find a back edge *(u, v)* and *v* is not the parent of u in the
    depth-first forest, then we are in the presence of a cycle.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在对边进行分类后，可以证明一个有向图是无环的当且仅当 DFS 不会产生回边。如果深度优先搜索产生回边 *(u, v)*，则顶点 *v* 是深度优先森林中顶点
    *u* 的祖先。因此，*G* 包含从 *v* 到 *u* 的路径，并且 *(u, v)* 完成了环。此算法可推广到无向图。在无向图中，如果我们找到一个回边
    *(u, v)* 且 *v* 不是深度优先森林中 *u* 的父节点，那么我们就在一个环中。
- en: 'Activity: Using BFS to Find the Shortest Path Out of a Maze'
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 活动：使用 BFS 寻找迷宫的出口最短路径
- en: '**Scenario**'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '**场景**'
- en: 'Our maze is an *H* by *W* rectangle, represented by an array of size *H* of
    *W*-sized strings. Each character in a string can either be ''**#**'' or ''**.**''.
    ''**#**'' represents a wall, which we cannot cross, and ''.'' represents a free
    space, which we can cross. The border of the maze is always filled with ''**#**''
    except for one square, which represents the exit. For example, the following is
    a valid maze:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的游戏迷宫是一个 *H* 乘以 *W* 的矩形，由一个大小为 *H* 的 *W* 大小字符串数组表示。字符串中的每个字符可以是 '**#**' 或
    '**.**'。 '**#**' 代表墙壁，我们不能穿越，而 '.' 代表空地，我们可以穿越。迷宫的边缘总是填充着 '**#**'，除了一个代表出口的方块。例如，以下是一个有效的迷宫：
- en: '![](img/e1acfab2-ecc2-454a-b528-150e46593c6b.png)'
  id: totrans-115
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e1acfab2-ecc2-454a-b528-150e46593c6b.png)'
- en: Find the total number of steps to exit the maze, when supplied with a starting
    point *(i, j)* (with *(0, 0)* being the upper-left point and *(H, W)* being the
    lower-right point).
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 当提供起始点 *(i, j)*（其中 *(0, 0)* 是左上角点，*(H, W)* 是右下角点）时，找到走出迷宫的总步数。
- en: '**Aim**'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '**目标**'
- en: To use BFS to find the shortest path out of a given maze.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 BFS 寻找给定迷宫的出口最短路径。
- en: '**Prerequisites**'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '**先决条件**'
- en: 'Implement the `distToExit()` method of the `Maze` class in the source code, which
    returns the integer distance from that point to the exit of the maze. It is available
    at the following URL:'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在源代码中实现 `Maze` 类的 `distToExit()` 方法，该方法返回从该点到迷宫出口的整数距离。它可在以下网址找到：
- en: '[https://github.com/TrainingByPackt/Data-Structures-and-Algorithms-in-Java/blob/master/src/main/java/com/packt/datastructuresandalg/lesson6/activity/maze/Maze.java](https://github.com/TrainingByPackt/Data-Structures-and-Algorithms-in-Java/blob/master/src/main/java/com/packt/datastructuresandalg/lesson6/activity/maze/Maze.java)'
  id: totrans-121
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '[https://github.com/TrainingByPackt/Data-Structures-and-Algorithms-in-Java/blob/master/src/main/java/com/packt/datastructuresandalg/lesson6/activity/maze/Maze.java](https://github.com/TrainingByPackt/Data-Structures-and-Algorithms-in-Java/blob/master/src/main/java/com/packt/datastructuresandalg/lesson6/activity/maze/Maze.java)'
- en: Assume that the points supplied to `distToExit()` are valid (that is, they're not
    inside walls)
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 假设提供给 `distToExit()` 的点是有效的（也就是说，它们不在墙壁内）
- en: Remember that we can only move in the cardinal directions (North, South,
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 记住，我们只能沿四个基本方向（北、南、东、西）移动
- en: East, and West)
  id: totrans-124
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 东，和西）
- en: '**Steps for Completion**'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '**完成步骤**'
- en: Encode the maze representation to a graph representation
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将迷宫表示编码为图表示
- en: Apply the BFS implementation shown in the preceding section (with a small modification
    to account for distances), or you can build the graph as you go
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 应用前一小节中展示的 BFS 实现（对距离进行微小修改），或者你可以边走边构建图
- en: Since you know that there are at most four outward edges for a given vertex, compute
    their positions as you go
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于你知道对于给定的顶点最多有四个外向边，因此边走边计算它们的位子
- en: In this section, we've introduced two different ways to traverse a graph—**breadth-first search**
    (**BFS**) and **depth-first search** (**DFS**). We've seen how to use BFS to find
    the single-source shortest path in unweighted graphs and how to use DFS to find
    cycles in a graph. In the next section, we will be looking at two different algorithms
    to find shortest paths in a graph.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们介绍了两种不同的图遍历方法——**广度优先搜索**（**BFS**）和**深度优先搜索**（**DFS**）。我们看到了如何使用 BFS
    在无权图中找到单源最短路径，以及如何使用 DFS 在图中找到环。在下一节中，我们将探讨两种不同的算法来找到图中的最短路径。
- en: Calculating Shortest Paths
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 计算最短路径
- en: The shortest path is a path between two vertices so that the sum of the weights
    of the edges that constitute the path is minimized. The shortest path problem
    has many applications in the real world, from finding directions on mapping applications
    to minimizing the moves to solve a puzzle.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 最短路径是两个顶点之间的路径，使得构成该路径的边的权重之和最小化。最短路径问题在现实世界中有很多应用，从在地图应用中查找方向到最小化解决谜题的移动。
- en: 'In this section, we shall look at two different strategies for computing shortest
    paths: one that finds the shortest paths from a single source to every other vertex
    in the graph, and another that finds shortest paths between all pairs of vertices
    in a graph.'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨两种不同的策略来计算最短路径：一种是从单个源点到图中每个其他顶点的最短路径，另一种是在图中找到所有顶点对之间的最短路径。
- en: 'Single Source Shortest Path: Dijkstra''s Algorithm'
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 单源最短路径：Dijkstra 算法
- en: When we explored BFS, we saw that it was able to solve the shortest path problem
    for unweighted graphs, or graphs whose edges have the same (positive) weight.
    What if we are dealing with weighted graphs? Can we do better? We shall see that
    Dijkstra's algorithm provides an improvement over the ideas presented in BFS and
    that it is an efficient algorithm for solving the single-source shortest path
    problem. One restriction for working with Dijkstra's algorithm is that edges'
    weights have to be positive. This is usually not a big issue since most graphs
    represent entities modeled by edges with positive weights. Nonetheless, there
    are algorithms capable of solving the problem for negative weights. Since the
    use case for negative edges is less common, those algorithms are outside the scope
    of this book.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们探索 BFS 时，我们看到它能够解决无权图或边具有相同（正）权重的图的最短路径问题。如果我们处理的是带权图呢？我们能做得更好吗？我们将看到 Dijkstra
    算法在 BFS 中提出的思想上提供了改进，并且它是一个解决单源最短路径问题的有效算法。使用 Dijkstra 算法的一个限制是边的权重必须是正的。这通常不是一个大问题，因为大多数图用具有正权重的边来表示实体。尽管如此，还有一些算法能够解决负权值的问题。由于负边的使用场景较少见，这些算法超出了本书的范围。
- en: 'Dijkstra''s algorithm, conceived by Edsger W. Dijkstra in 1956, maintains a
    set *S* of vertices whose final shortest-path weights from the source *s* have
    already been determined. The algorithm repeatedly selects the vertex *u* with
    the minimum shortest-path estimate, adds it to set *S*, and uses the outward edges
    from that vertex to update the estimates from vertices not yet in set *S*. In
    order to see this in action, let''s consider the directed graph of *Figure 6.5*:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: Dijkstra 算法由 Edsger W. Dijkstra 在 1956 年构思，它维护一个集合 *S*，其中包含从源 *s* 到其最终最短路径权重的顶点已经确定。该算法反复选择具有最小最短路径估计的顶点
    *u*，将其添加到集合 *S* 中，并使用该顶点的向外边缘来更新尚未在集合 *S* 中的顶点的估计。为了看到这一过程，让我们考虑 *图6.5* 的有向图：
- en: '![](img/49a7ece1-feb6-4021-82f2-b3215990b169.png)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
  zh: '![](img/49a7ece1-feb6-4021-82f2-b3215990b169.png)'
- en: 'Figure 6.5: A sample weighted directed graph'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.5：一个示例加权有向图
- en: 'The graph is composed of five vertices (*A*, *B*, *C*, *D*, and *E*) and 10
    edges. We''re interested in finding the shortest paths, starting at vertex *A*.
    Note that A is already marked as *0*, meaning that the current distance from *A*
    to *A* is zero. The other vertices don''t have distances associated with them
    yet. It is common to use an estimate of infinity as the starting estimate for
    the distance of nodes not yet seen. The following table shows a run of Dijkstra''s
    algorithm for the graph of *Figure 6.5*, identifying the current vertex being
    selected and how it updates the estimates for vertices not yet seen:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 该图由五个顶点（*A*、*B*、*C*、*D* 和 *E*）和 10 条边组成。我们感兴趣的是找到从顶点 *A* 开始的最短路径。请注意，A 已经标记为
    *0*，这意味着从 *A* 到 *A* 的当前距离为零。其他顶点还没有与它们关联的距离。通常使用无穷大作为尚未看到的节点距离的起始估计。以下表格显示了 Dijkstra
    算法在 *图6.5* 图上的运行情况，标识了当前被选中的顶点以及它如何更新尚未在集合 *S* 中的顶点的估计：
- en: '| **Step** | **Explanation** |'
  id: totrans-139
  prefs: []
  type: TYPE_TB
  zh: '| **步骤** | **说明** |'
- en: '| ![](img/be27917f-9d33-4854-862c-e55345bfa5f3.png) | Vertex *A* is the vertex
    with the lowest estimate weight, so it is selected as the next vertex whose edges
    are to be considered to improve our current estimates. |'
  id: totrans-140
  prefs: []
  type: TYPE_TB
  zh: '| ![](img/be27917f-9d33-4854-862c-e55345bfa5f3.png) | 顶点 *A* 是具有最低估计权重的顶点，因此它被选中作为下一个顶点，其边缘将被考虑以改进当前的估计。|'
- en: '| ![](img/f281522a-9f4a-4233-88de-ae382eea15d9.png) | We use the outward edges
    from vertex *A* to update our estimates for vertices *B* and *D*. Afterwards,
    we add *A* to set *S*, avoiding a repeated visit to it. From the edges not yet
    visited, the one with the lowest estimate is now *D*, which shall be selected
    to visit next. Note that we also mark those edges that belong to our estimate
    shortest path in bold. |'
  id: totrans-141
  prefs: []
  type: TYPE_TB
  zh: '| ![](img/f281522a-9f4a-4233-88de-ae382eea15d9.png) | 我们使用从顶点 *A* 出发的向外边缘来更新顶点
    *B* 和 *D* 的估计。之后，我们将 *A* 添加到集合 *S* 中，避免重复访问它。在尚未访问的边缘中，现在具有最低估计的是 *D*，它将被选中进行访问。请注意，我们也用粗体标记了属于我们估计最短路径的边缘。|'
- en: '| ![](img/2cf9e89a-77d0-4d16-8268-421869d67694.png) | By exploring the outward
    edges from vertex *D*, we were able to improve our estimate for vertex *B*, so
    we update it accordingly and now consider a different edge for the shortest path. We
    were also able to discover vertices *C* and *E*, which become potential candidates
    to visit next. Since *E* is the one with the shorter estimate weight, we visit
    it next. |'
  id: totrans-142
  prefs: []
  type: TYPE_TB
  zh: '| ![](img/2cf9e89a-77d0-4d16-8268-421869d67694.png) | 通过探索从顶点 *D* 出发的向外边缘，我们能够改进顶点
    *B* 的估计，因此我们相应地更新它，并现在考虑不同的边缘来寻找最短路径。我们还能够发现顶点 *C* 和 *E*，它们成为下一个要访问的潜在候选者。由于 *E*
    具有较短的估计权重，我们接下来访问它。|'
- en: '| ![](img/b9a16349-a972-458e-bae1-cb32d60615b2.png) | Using an outward edge
    from vertex *E*, we were able to improve our estimate for vertex *C*, and now
    look at vertex *B* as our next vertex to visit. Note that those vertices that
    belong to set *S* (shown in black in the figure) already have their shortest path
    computed. The value inside them is the weight of the shortest path from *A* to
    them, and you can follow the edges in bold to build the shortest path. |'
  id: totrans-143
  prefs: []
  type: TYPE_TB
  zh: '| ![](img/b9a16349-a972-458e-bae1-cb32d60615b2.png) | 使用从顶点 *E* 出发的向外边缘，我们能够改进顶点
    *C* 的估计，现在将 *B* 作为下一个要访问的顶点。请注意，那些属于集合 *S* 的顶点（如图中黑色所示）已经计算了最短路径。它们内部的价值是从 *A*
    到它们的短路径的权重，你可以跟随粗体边缘来构建最短路径。|'
- en: '| ![](img/b93ca2a6-5f6e-48d5-ac55-275628ef8363.png) | From vertex *B*, we were
    able to once again improve our estimate for the shortest path to vertex *C*. Since
    vertex *C* is the only vertex not yet in set *S*, it is the one visited next.
    |'
  id: totrans-144
  prefs: []
  type: TYPE_TB
  zh: '| ![](img/b93ca2a6-5f6e-48d5-ac55-275628ef8363.png) | 从顶点 *B*，我们能够再次改进到顶点 *C*
    的最短路径估计。由于顶点 *C* 是唯一尚未在集合 *S* 中的顶点，因此它是下一个被访问的顶点。|'
- en: '| ![](img/81e5d6e5-6186-454c-8908-a5c5ff1342f3.png) | Since vertex *C* has
    no outward edges to vertices not yet in *S*, we conclude the run of our algorithm,
    and have successfully computed the shortest paths from *A* to every other vertex
    in the graph. |'
  id: totrans-145
  prefs: []
  type: TYPE_TB
  zh: '| ![](img/81e5d6e5-6186-454c-8908-a5c5ff1342f3.png) | 由于顶点 *C* 没有指向尚未在 *S*
    中的顶点的出边，我们得出算法运行的结论，并成功计算了从 *A* 到图中每个其他顶点的最短路径。|'
- en: 'Table 6.5: A run of Dijkstra''s algorithm for the weighted directed graph of
    Figure 6.5'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 表 6.5：Dijkstra 算法在图 6.5 的加权有向图上的运行
- en: 'Now that we''ve seen a run of Dijkstra''s algorithm, let''s try to put it in
    code and analyze its runtime performance. We will use an adjacency list representation
    for our graph, as it helps us when trying to explore the outward edges of a given
    vertex. The following code snippet shows a possible implementation of Dijkstra''s
    algorithm as previously described:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经看到了 Dijkstra 算法的一次运行，让我们尝试将其放入代码中并分析其运行时间性能。我们将使用邻接表表示我们的图，因为它有助于我们探索给定顶点的出边。以下代码片段显示了
    Dijkstra 算法的一种可能实现，如之前所述：
- en: '[PRE5]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Snippet 6.6: Implementation of Dijkstra''s algorithm. Source class name: Dijkstra'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 6.6 段：Dijkstra 算法的实现。源类名：Dijkstra
- en: Go to [https://goo.gl/P7p5Ce](https://goo.gl/P7p5Ce) to access this code.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 前往 [https://goo.gl/P7p5Ce](https://goo.gl/P7p5Ce) 访问此代码。
- en: 'The Dijkstra method starts by initializing two sets:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: Dijkstra 方法首先初始化两个集合：
- en: One for visited vertices
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个用于已访问顶点
- en: One for unvisited vertices
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个用于未访问顶点
- en: The set of visited vertices corresponds to the set we previously named as *S*,
    and we use the one of not visited vertices to keep track of vertices to explore.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 已访问顶点的集合对应于我们之前命名为 *S* 的集合，我们使用未访问顶点的集合来跟踪要探索的顶点。
- en: We then initialize each vertex with an estimated distance equal to `Integer.MAX_VALUE`,
    representing a value of "infinity" for our use case. We also use a parent array
    to keep track of parent vertices in the shortest path, so that we can later recreate
    the path from the source to each vertex.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 我们然后初始化每个顶点的估计距离等于 `Integer.MAX_VALUE`，代表我们用例中的“无穷大”值。我们还使用一个父数组来跟踪最短路径中的父顶点，这样我们就可以稍后从源顶点重新创建路径。
- en: The main loop runs for each vertex, while we still have vertices not yet visited.
    For each run, it selects the "best" vertex to explore. In this case, the "best"
    vertex is the one with the smallest distance of the vertices not visited so far
    (the `getBestEstimate()` function simply scans all vertices in the `notVisited()`
    set for the one satisfying the requirement).
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 主循环对每个顶点运行，直到我们还有未访问的顶点。对于每次运行，它选择要探索的“最佳”顶点。在这种情况下，“最佳”顶点是到目前为止未访问顶点中距离最小的顶点（`getBestEstimate()`
    函数简单地扫描 `notVisited()` 集合中的所有顶点，以找到满足要求的顶点）。
- en: Then, it adds the vertex to the set of visited vertices and updates the estimate
    distances for not visited vertices. When we run out of vertices to visit, we build
    our paths by recursively visiting the parent array.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，它将顶点添加到已访问顶点的集合中，并更新未访问顶点的估计距离。当我们没有更多顶点要访问时，我们通过递归访问父数组来构建我们的路径。
- en: Analyzing the runtime of the previous implementation, we can see that we have
    an initialization step that's proportional to the number of vertices in the graph,
    hence running in *O(V)*.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 分析前一个实现的运行时间，我们可以看到有一个与图中顶点数量成正比的初始化步骤，因此以 *O(V)* 运行。
- en: The main loop of the algorithm runs once for each vertex, so it is bounded by
    at least *O(V)*. Inside the main loop, we determine the next vertex to visit and
    then scan its adjacency list to update the estimate distances. Updating the distances
    takes time proportional to *O(1)*, and since we scan each vertex's adjacency list
    only once, we take time proportional to *O(E)*, updating estimate distances. We're
    left with the time spent selecting the next vertex to visit. Unfortunately, the
    `getBestEstimate()` method needs to scan through all the unvisited vertices, and
    is therefore bounded by *O(V)*. The total running time of our implementation of
    Dijkstra's algorithm is therefore *O(V²+E)*.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 算法的主体循环对每个顶点运行一次，因此它至少被限制在 *O(V)*。在主体循环内部，我们确定下一个要访问的顶点，然后扫描其邻接表以更新估计距离。更新距离所需的时间与
    *O(1)* 成正比，并且由于我们只扫描每个顶点的邻接表一次，所以我们花费的时间与 *O(E)* 成正比，更新估计距离。我们剩下选择下一个要访问的顶点所需的时间。不幸的是，`getBestEstimate()`
    方法需要扫描所有未访问的顶点，因此它被限制在 *O(V)*。因此，我们实现 Dijkstra 算法的总运行时间是 *O(V²+E)*。
- en: Even though some parts of our implementation seem difficult to optimize, it
    looks like we can do better when selecting the next vertex to visit. If we could
    have access to a data structure that was capable of storing our vertices sorted
    by lower estimated distance and provided efficient insert and remove operations,
    then we could reduce the *O(V)* time spent inside the `getBestEstimate` method.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们实现中的某些部分看起来难以优化，但看起来在选择下一个要访问的顶点时，我们可以做得更好。如果我们能够访问一个能够按较低估计距离排序我们的顶点并且提供高效插入和删除操作的数据结构，那么我们就可以减少在
    `getBestEstimate` 方法中花费的 *O(V)* 时间。
- en: 'In [Chapter 4](da07fa18-a8ce-4d4c-91eb-9dc893de7273.xhtml), *Algorithm Design
    Paradigms*, we briefly discussed a data structure used in Huffman coding named
    the  priority queue, which is just what we need for this job. The following code
    snippet implements a more efficient version of Dijkstra''s algorithm, using a
    priority queue:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第4章](da07fa18-a8ce-4d4c-91eb-9dc893de7273.xhtml) *算法设计范式* 中，我们简要讨论了在霍夫曼编码（Huffman
    coding）中使用的名为优先队列（priority queue）的数据结构，这正是我们这项工作所需要的。以下代码片段实现了一个更高效的迪杰斯特拉算法版本，使用了优先队列：
- en: '[PRE6]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Snippet 6.7: Implementation of Dijkstra''s algorithm using a priority queue.
    Source class name: DijkstraWithPQ'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 代码片段6.7：使用优先队列实现迪杰斯特拉算法。源类名：DijkstraWithPQ
- en: Go to [https://goo.gl/3rtZCQ](https://goo.gl/3rtZCQ) to access this code.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 前往 [https://goo.gl/3rtZCQ](https://goo.gl/3rtZCQ) 访问此代码。
- en: In this second implementation, we no longer keep sets for visited and not visited
    vertices. Instead, we rely on a priority queue that will be storing our distance
    estimates while we run the algorithm.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个第二个实现中，我们不再保留已访问和未访问顶点的集合。相反，我们依赖于一个在运行算法时将存储我们的距离估计的优先队列。
- en: When we are exploring the outward edges from a given vertex, we therefore add
    a new entry to the priority queue in case we are able to improve our distance
    estimate.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，当我们从一个给定的顶点探索向外延伸的边时，如果我们能够改进我们的距离估计，我们就会向优先队列中添加一个新的条目。
- en: Adding and removing an element from our priority queue takes *O(logN)* time,
    *N* being the number of elements in the queue. Do note that we can have the same
    vertex inserted more than once in the priority queue. That's why we check if we've
    visited it before expanding its edges.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 从我们的优先队列中添加或删除一个元素需要 *O(logN)* 时间，其中 *N* 是队列中的元素数量。请注意，我们可以在优先队列中插入相同的顶点多次。这就是为什么我们在扩展其边之前检查我们是否已经访问过它。
- en: Since we will visit the instance for that vertex with shorter estimate distance,
    it's safe to ignore the ones that come after it. However, that means that operations
    on our priority queue are not bounded by *O(logV)*, but *O(log E)* instead (assuming
    that there's a connected graph).
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们将访问具有较短估计距离的顶点的实例，因此可以安全地忽略其后的那些。然而，这意味着我们的优先队列操作不受 *O(logV)* 的限制，而是 *O(log
    E)*（假设存在一个连通图）。
- en: Therefore, the total runtime of this implementation is *O((V + E)logE)*. It's
    still possible to improve this running time by using a priority queue implementation
    with better asymptotic bounds (such as a Fibonacci heap), but its implementation
    is out of the scope of this book.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，这个实现的总体运行时间是 *O((V + E)logE)*。通过使用具有更好渐近界限的优先队列实现（例如斐波那契堆），我们仍然可以改进这个运行时间，但其实现超出了本书的范围。
- en: 'One last thing to note about Dijkstra''s algorithm is how it borrows ideas
    from BFS (the algorithm structure is very similar to Dijkstra''s, but we end up
    using a priority queue instead of a normal queue) and that it is a very good example
    of a greedy algorithm: Dijkstra''s algorithm makes the locally optimum choice
    (for example, it chooses the vertex with the minimum estimated distance) in order
    to arrive at a global optimum.'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 关于迪杰斯特拉算法的最后一件事是它如何借鉴了BFS（算法结构非常类似于迪杰斯特拉算法，但我们最终使用的是优先队列而不是普通队列）的想法，并且它是一个非常好的贪婪算法的例子：迪杰斯特拉算法通过做出局部最优的选择（例如，它选择具有最小估计距离的顶点）来达到全局最优。
- en: 'All Pairs Shortest Paths: Floyd-Warshall Algorithm'
  id: totrans-171
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 所有对最短路径：弗洛伊德-沃舍尔算法（Floyd-Warshall Algorithm）
- en: Sometimes, it might be necessary to compute the shortest paths between all pairs
    of vertices. For example, we might be interested in building a table of distances.
    One way to do that is to perform a single source shortest path for every vertex
    of the graph. If you use Dijkstra's algorithm for that, we end up with a runtime
    of *O(V*(V + E)logE)*.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，可能需要计算图中所有顶点对之间的最短路径。例如，我们可能对构建一个距离表感兴趣。实现这一目标的一种方法是对图中的每个顶点执行单源最短路径算法。如果你使用迪杰斯特拉算法（Dijkstra's
    algorithm）来做这件事，我们最终得到的运行时间是 *O(V*(V + E)logE)*。
- en: In this subsection, we shall explore an algorithm capable of solving the all
    pairs shortest paths problem in *O(V³)* time, with a remarkably simple and elegant
    implementation.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: The algorithm we are about to study, more commonly referred to as the Floyd-Warshall
    algorithm, was published in its current form by Robert Floyd in 1962\. However,
    in its essence, it follows the same ideas published by Bernard Roy in 1959 and
    Stephen Warshall in 1962.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: The algorithm uses the adjacency matrix representation and follows a dynamic
    programming approach. The basic idea behind it is that, when we're trying to compute
    the shortest-path distance between vertex *i* and vertex *j*, we try to use an
    intermediate vertex, *k*. We want to use an intermediate vertex so that doing
    the path from *i* to *k* and then from *k* to *j* shortens the currently computed
    shortest path between *i* and *j*. If we find such a vertex, then the best path
    we're able to compute so far between *i* and *j* must go through *k*. All that
    we need to do is, for each *k*, see if using it improves the shortest path between
    *i* and *j*, for all possible *i* and *j*.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to see that in practice, let''s use the directed graph of *Figure
    6.5* that we used to illustrate Dijkstra''s algorithm. The graph of *Figure 6.5*
    has the adjacency matrix representation of the following table:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: '|  | **A** | **B** | **C** | **D** | **E** |'
  id: totrans-177
  prefs: []
  type: TYPE_TB
- en: '| **A** | 0 | 10 | ∞ | 5 | ∞ |'
  id: totrans-178
  prefs: []
  type: TYPE_TB
- en: '| **B** | ∞ | 0 | 1 | 2 | ∞ |'
  id: totrans-179
  prefs: []
  type: TYPE_TB
- en: '| **C** | ∞ | ∞ | 0 | ∞ | 4 |'
  id: totrans-180
  prefs: []
  type: TYPE_TB
- en: '| **D** | ∞ | 3 | 9 | 0 | 2 |'
  id: totrans-181
  prefs: []
  type: TYPE_TB
- en: '| **E** | ∞ | ∞ | 6 | ∞ | 0 |'
  id: totrans-182
  prefs: []
  type: TYPE_TB
- en: 'Table 6.6: Adjacency matrix representation of the directed graph of Figure
    6.5'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: 'The adjacency matrix representation serves as the starting point for the Floyd-Warshall
    algorithm, and we iterate through it until we''re left with a matrix of the weights
    of the shortest paths between each pair of vertices. In order to do so, let''s
    start with vertex *A*, considering it as an intermediate vertex for shortest paths.
    Unfortunately, vertex *A* doesn''t have inward edges, meaning that it can''t be
    used as an intermediate vertex for shortest paths. Using vertex *B*, we can improve
    the distance from *A* to *C (10 + 1 < ∞)*, and we can use it to go from *A* to
    *D*, but not improve the overall distance. We can also use it to improve the distance
    from *D* to *C (3 + 1 < 9)*. Therefore, after considering *B* as an intermediate
    vertex, we''re left with the distance matrix of the following table:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: '|  | **A** | **B** | **C** | **D** | **E** |'
  id: totrans-185
  prefs: []
  type: TYPE_TB
- en: '| **A** | 0 | 10 | 11 | 5 | ∞ |'
  id: totrans-186
  prefs: []
  type: TYPE_TB
- en: '| **B** | ∞ | 0 | 1 | 2 | ∞ |'
  id: totrans-187
  prefs: []
  type: TYPE_TB
- en: '| **C** | ∞ | ∞ | 0 | ∞ | 4 |'
  id: totrans-188
  prefs: []
  type: TYPE_TB
- en: '| **D** | **∞** | 3 | 4 | 0 | 2 |'
  id: totrans-189
  prefs: []
  type: TYPE_TB
- en: '| **E** | ∞ | ∞ | 6 | ∞ | 0 |'
  id: totrans-190
  prefs: []
  type: TYPE_TB
- en: 'Table 6.7: Distance matrix after considering B as an intermediate vertex'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we are going to look at vertex *C*. Using vertex *C*, we can improve the
    distance from *A* to *E (11 + 4 < ∞)* and *B* to *E (1 + 4 < ∞)*:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: '|  | **A** | **B** | **C** | **D** | **E** |'
  id: totrans-193
  prefs: []
  type: TYPE_TB
- en: '| **A** | 0 | 10 | 11 | 5 | 15 |'
  id: totrans-194
  prefs: []
  type: TYPE_TB
- en: '| **B** | ∞ | 0 | 1 | 2 | 5 |'
  id: totrans-195
  prefs: []
  type: TYPE_TB
- en: '| **C** | ∞ | ∞ | 0 | ∞ | 4 |'
  id: totrans-196
  prefs: []
  type: TYPE_TB
- en: '| **D** | ∞ | 3 | 4 | 0 | 2 |'
  id: totrans-197
  prefs: []
  type: TYPE_TB
  zh: '| **D** | ∞ | 3 | 4 | 0 | 2 |'
- en: '| **E** | ∞ | ∞ | 6 | ∞ | 0 |'
  id: totrans-198
  prefs: []
  type: TYPE_TB
  zh: '| **E** | ∞ | ∞ | 6 | ∞ | 0 |'
- en: 'Table 6.8: Distance matrix after considering C as an intermediate vertex'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 表6.8：考虑C作为中间顶点后的距离矩阵
- en: 'Using vertex *D*, we can improve the distance from *A* to *B (5 + 3 < 10)*,
    *A* to *C (5 + 4 < 11)*, *A *to *E (5 + 2 < 15)*, and *B* to *E (2 + 2 < 5)*:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 使用顶点*D*，我们可以改善从*A*到*B*（5 + 3 < 10）、从*A*到*C*（5 + 4 < 11）、从*A*到*E*（5 + 2 < 15）以及从*B*到*E*（2
    + 2 < 5）的距离：
- en: '|  | **A** | **B** | **C** | **D** | **E** |'
  id: totrans-201
  prefs: []
  type: TYPE_TB
  zh: '|  | **A** | **B** | **C** | **D** | **E** |'
- en: '| **A** | 0 | 8 | 9 | 5 | 7 |'
  id: totrans-202
  prefs: []
  type: TYPE_TB
  zh: '| **A** | 0 | 8 | 9 | 5 | 7 |'
- en: '| **B** | ∞ | 0 | 1 | 2 | 4 |'
  id: totrans-203
  prefs: []
  type: TYPE_TB
  zh: '| **B** | ∞ | 0 | 1 | 2 | 4 |'
- en: '| **C** | ∞ | ∞ | 0 | ∞ | 4 |'
  id: totrans-204
  prefs: []
  type: TYPE_TB
  zh: '| **C** | ∞ | ∞ | 0 | ∞ | 4 |'
- en: '| **D** | ∞ | 3 | 4 | 0 | 2 |'
  id: totrans-205
  prefs: []
  type: TYPE_TB
  zh: '| **D** | ∞ | 3 | 4 | 0 | 2 |'
- en: '| **E** | ∞ | ∞ | 6 | ∞ | 0 |'
  id: totrans-206
  prefs: []
  type: TYPE_TB
  zh: '| **E** | ∞ | ∞ | 6 | ∞ | 0 |'
- en: 'Table 6.9: Distance matrix after considering D as an intermediate vertex'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 表6.9：考虑D作为中间顶点后的距离矩阵
- en: 'Using vertex *E*, we cannot improve any distance, so *Table 6.9* already has
    the weights for the shortest paths between all pairs of vertices. Implementing
    the Floyd-Warshall algorithm is very simple, as the following code snippet demonstrates:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 使用顶点*E*，我们无法改善任何距离，因此*表6.9*已经包含了所有顶点对之间最短路径的权重。实现Floyd-Warshall算法非常简单，如下代码片段所示：
- en: '[PRE7]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Snippet 6.8: Implementation of Floyd Warshall''s algorithm. Source class name: FloydWarshall'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 碎片6.8：Floyd-Warshall算法的实现。源类名：FloydWarshall
- en: Go to [https://goo.gl/SQxdL2](https://goo.gl/SQxdL2) to access this code.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 前往[https://goo.gl/SQxdL2](https://goo.gl/SQxdL2)访问此代码。
- en: Looking at the implementation, the runtime of *O(V³)* becomes obvious. One alternative
    to the Floyd-Warshall algorithm is running Dijkstra's algorithm for each vertex
    in the graph (so that we end up with all pairwise shortest paths). Given that
    its complexity is closer to multiple applications of Dijkstra's algorithm for
    dense graphs, the Floyd-Warshall algorithm is frequently used in practice.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 观察实现过程，*O(V³)*的时间复杂度变得明显。Floyd-Warshall算法的一个替代方案是对图中的每个顶点运行Dijkstra算法（这样我们最终会得到所有成对的最短路径）。鉴于其复杂度接近于对稠密图多次应用Dijkstra算法，Floyd-Warshall算法在实践中经常被使用。
- en: 'Activity: Improving Floyd-Warshall''s Algorithm to Reconstruct the Shortest
    Path'
  id: totrans-213
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 活动：改进Floyd-Warshall算法以重建最短路径
- en: '**Scenario**'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '**场景**'
- en: Improve Floyd-Warshall's algorithm so that we're able to reconstruct the shortest path
    between two given nodes after running the algorithm, using the predecessor matrix.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 改进Floyd-Warshall算法，以便在运行算法后能够使用前驱矩阵重建两个给定节点之间的最短路径。
- en: '**Aim**'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: '**目标**'
- en: To construct a shortest path between the two vertices using the predecessor
    matrix.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 使用前驱矩阵构建两个顶点之间的最短路径。
- en: '**Prerequisite**'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '**先决条件**'
- en: The predecessor matrix is used to compute the shortest path between two given
    vertices. Each cell of the predecessor matrix *P[ij]* should be either empty (meaning
    that there is no path between *i* and *j*), or equal to some index *k* (meaning
    that vertex *k* is the one that precedes *j* in the shortest path between *i*
    and *j*). As such, we need to update our predecessor matrix whenever we use an
    intermediate vertex.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 前驱矩阵用于计算两个给定顶点之间的最短路径。前驱矩阵的每个单元格*P[ij]*应该是空的（表示*i*和*j*之间没有路径），或者等于某个索引*k*（表示顶点*k*是*i*和*j*之间最短路径中的前驱顶点）。因此，每当使用中间顶点时，我们需要更新我们的前驱矩阵。
- en: 'Implement the `run()` method of the Floyd-Warshall class that shall compute
    the shortest paths for the current graph and populate the path matrix, used later
    in the `path()` method to return the path between two given vertices. The method
    is available at the following URL:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 实现Floyd-Warshall类的`run()`方法，该方法应计算当前图的最短路径并填充路径矩阵，该矩阵随后在`path()`方法中使用，以返回两个给定顶点之间的路径。该方法可在以下URL找到：
- en: '[https://github.com/TrainingByPackt/Data-Structures-and-Algorithms-in-Java/blob/master/src/main/java/com/packt/datastructuresandalg/lesson6/activity/floydwarshall/FloydWarshall.java](https://github.com/TrainingByPackt/Data-Structures-and-Algorithms-in-Java/blob/master/src/main/java/com/packt/datastructuresandalg/lesson6/activity/floydwarshall/FloydWarshall.java)'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/TrainingByPackt/Data-Structures-and-Algorithms-in-Java/blob/master/src/main/java/com/packt/datastructuresandalg/lesson6/activity/floydwarshall/FloydWarshall.java](https://github.com/TrainingByPackt/Data-Structures-and-Algorithms-in-Java/blob/master/src/main/java/com/packt/datastructuresandalg/lesson6/activity/floydwarshall/FloydWarshall.java)'
- en: '**Steps for Completion**'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: '**完成步骤**'
- en: Adapt the implementation shown in *Snippet 6.8* of the Floyd-Warshall algorithm
    to update the path matrix
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将Floyd-Warshall算法的*碎片6.8*中的实现进行修改，以更新路径矩阵
- en: Use it to reconstruct the paths similarly to what we have previously shown in the
    implementation of Dijkstra's algorithm
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用它来重建路径，类似于我们在迪杰斯特拉算法实现中之前所展示的
- en: 'In this section, we''ve introduced the shortest paths problem and visited two
    different algorithms to solve it: one for single source shortest paths (Dijkstra''s
    algorithm), and another for all pairs shortest paths (Floyd-Warshall). We''ve
    shown how different implementations of Dijkstra''s algorithm can affect its running
    time. For both algorithms, we''ve also shown how to reconstruct shortest paths
    using a parent array and a predecessor matrix, respectively.'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们介绍了最短路径问题，并探讨了两种不同的算法来解决它：一个用于单源最短路径（迪杰斯特拉算法），另一个用于所有对最短路径（弗洛伊德-沃舍尔算法）。我们展示了不同的迪杰斯特拉算法实现如何影响其运行时间。对于这两个算法，我们也展示了如何分别使用父数组和中继矩阵重建最短路径。
- en: Prime Numbers in Algorithms
  id: totrans-226
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 算法中的素数
- en: A prime number is a natural number greater than one whose only divisors are
    one and the number itself.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 素数是一个大于1的自然数，其唯一的因数是1和它本身。
- en: 'Prime numbers play a very important role in the fundamental theorem of arithmetic:
    every natural number greater than one is either a prime or a product of primes.
    Nowadays, number-theoretic algorithms are widely used, mainly due to cryptographic
    schemes based on large prime numbers. Most of those cryptographic schemes are
    based on the fact that we can efficiently find large primes, but we cannot factor
    the product of those large primes efficiently. As seen before, prime numbers play
    an important role in the implementation of hash tables.'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 素数在算术基本定理中扮演着非常重要的角色：每个大于1的自然数要么是素数，要么是素数的乘积。如今，数论算法被广泛使用，主要归功于基于大素数的加密方案。大多数这些加密方案都是基于这样一个事实：我们可以高效地找到大素数，但我们不能高效地分解这些大素数的乘积。正如之前所看到的，素数在哈希表的实现中扮演着重要的角色。
- en: Sieve of Eratosthenes
  id: totrans-229
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 埃拉托斯特尼筛法
- en: The sieve of Eratosthenes is a simple and ancient algorithm to find all prime
    numbers up to a given limit. If we want to find all prime numbers up to *N*, we
    start by creating a list of consecutive integers from *2* to *N (2, 3, 4, 5… N)*,
    initially unmarked. Let's use *p* to denote the smallest unmarked number. Then,
    we select the smallest unmarked number *p* that is larger than the last *p*. In
    the first iteration, *p* will be two. Afterwards, by increments of *p*, we mark
    elements in the list from *2p* until *Mp* so that *Mp <= N.*
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 埃拉托斯特尼筛法是一个简单而古老的算法，用于找到给定限制内的所有素数。如果我们想找到所有小于等于*N*的素数，我们首先创建一个从*2*到*N*（2，3，4，5…N）的连续整数列表，最初未标记。让我们用*p*来表示最小的未标记数。然后，我们选择比最后一个*p*更大的最小的未标记数*p*。在第一次迭代中，*p*将是2。之后，通过*p*的增量，我们在列表中标记从*2p*到*Mp*的元素，使得*Mp
    <= N.*
- en: We repeat this strategy until it is impossible to mark more numbers in the list.
    At the end of the run, all the unmarked numbers are prime numbers. It is easy
    to see that all unmarked numbers will be the ones for which we couldn't find a
    divisor other than the number itself and 1, and are therefore prime numbers.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 我们重复此策略，直到无法在列表中标记更多数字为止。在运行结束时，所有未标记的数字都是素数。很容易看出，所有未标记的数字都是我们找不到除数（除了数字本身和1）的数字，因此是素数。
- en: Prime Factorization
  id: totrans-232
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 素数分解
- en: Prime factorization is determining the prime factors of a given number. It is
    very difficult to build a general-purpose algorithm for this computationally hard
    problem. A general purpose algorithm that is commonly used to factorize primes
    was introduced in [Chapter 1](52b469c2-7203-4188-9e37-6ab0bf659ca7.xhtml), *Algorithms
    and Complexities*. Its basic idea is to iterate through possible factors attempting
    to divide the number.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 素数分解是确定给定数的素数因子。为这个计算上困难的问题构建一个通用算法是非常困难的。一个常用的通用算法，用于分解素数，在[第1章](52b469c2-7203-4188-9e37-6ab0bf659ca7.xhtml)，*算法与复杂性*中介绍。其基本思想是遍历可能的因数，尝试除以该数。
- en: Start with 2; while the number is divisible by 2, keep dividing it, and add
    2 to the list of factors. Afterwards, the number must be odd, so start a loop
    that checks for possible factors from 3 to the square root of the number.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 从2开始；当数字能被2整除时，继续除以它，并将2添加到因数列表中。之后，数字必须是奇数，因此开始一个循环，检查从3到数字的平方根的可能因数。
- en: Since we've already covered even numbers, you can do increments of 2 in this
    loop (there's no need to check 4, 6, 8, and so on once you've already checked
    2). Once you find a suitable divisor, add the number to the list of factors and
    divide it until it is possible. At the end of this step, if we are left with a
    number greater than 2, then it is a prime number and therefore a prime factor
    of itself.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们已经涵盖了偶数，你可以在循环中执行2的增量（一旦检查了2，就没有必要检查4、6、8等等）。一旦找到合适的除数，将数字添加到因子列表中，并除以它直到可能为止。在这个步骤结束时，如果我们剩下大于2的数字，那么它是一个质数，因此也是它自己的质因数。
- en: 'Activity: Implementing the Sieve of Eratosthenes'
  id: totrans-236
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 活动：实现埃拉托斯特尼筛法
- en: '**Scenario**'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: '**场景**'
- en: Implementing the sieve of Eratosthenes algorithm to find all prime numbers up
    to a given limit.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 实现埃拉托斯特尼筛法算法以找到给定限制范围内的所有质数。
- en: '**Aim**'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: '**目标**'
- en: To develop a code in Java for implementing the sieve of Eratosthenes.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 开发一个Java代码来实现埃拉托斯特尼筛法。
- en: '**Prerequisites**'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: '**先决条件**'
- en: 'Implement the `isPrime()` method of the `SieveOfEratosthenes` class that should
    return `true` if the number is prime, and `false` otherwise. It is available at
    the following URL:'
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现 `SieveOfEratosthenes` 类的 `isPrime()` 方法，该方法应返回 `true` 如果数字是质数，否则返回 `false`。它可在以下URL找到：
- en: '[https://github.com/TrainingByPackt/Data-Structures-and-Algorithms-in-Java/blob/master/src/main/java/com/packt/datastructuresandalg/lesson7/activity/sieve/SieveOfEratosthenes.java](https://github.com/TrainingByPackt/Data-Structures-and-Algorithms-in-Java/blob/master/src/main/java/com/packt/datastructuresandalg/lesson7/activity/sieve/SieveOfEratosthenes.java)'
  id: totrans-243
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '[https://github.com/TrainingByPackt/Data-Structures-and-Algorithms-in-Java/blob/master/src/main/java/com/packt/datastructuresandalg/lesson7/activity/sieve/SieveOfEratosthenes.java](https://github.com/TrainingByPackt/Data-Structures-and-Algorithms-in-Java/blob/master/src/main/java/com/packt/datastructuresandalg/lesson7/activity/sieve/SieveOfEratosthenes.java)'
- en: Consider building the sieve in the class constructor
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 考虑在类构造函数中构建筛子。
- en: Other Concepts in Graphs
  id: totrans-245
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 图中的其他概念
- en: In this chapter, we covered ways of representing and traversing a graph and
    looked at shortest path algorithms. Graphs are also an optimal data structure
    for some problems we haven't mentioned yet. This section aims to introduce some
    of them.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了表示和遍历图的方法，并探讨了最短路径算法。图也是解决一些尚未提到的某些问题的最优数据结构。本节旨在介绍其中的一些。
- en: Minimum Spanning Trees
  id: totrans-247
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 最小生成树
- en: A minimum spanning tree of a graph is a subset of the set of edges *E* of a
    connected graph that connects all vertices together, without any cycles and with
    the minimum total edge weight. It is a tree because every two vertices in it are
    connected by exactly one path.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 图的最小生成树是连接图中所有顶点的边集 *E* 的一个子集，它没有循环，并且具有最小的总边权重。因为它中的每两个顶点都恰好由一条路径连接，所以它是一个树。
- en: In order to understand the applicability of minimum spanning trees, consider
    the problem of a telecommunications company that is moving into a new neighborhood.
    The company wants to connect all the houses, but also wants to minimize the length
    of cable that it uses in order to cut costs. One way to solve the problem is by
    computing the minimum spanning tree of a graph whose vertices are the houses of
    the neighborhood, and the edges between houses are weighted according to the distance
    between them.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 为了理解最小生成树的应用，考虑一个电信公司进入新社区的问题。该公司希望连接所有房屋，但同时也希望最小化使用的电缆长度以降低成本。解决该问题的一种方法是通过计算一个图的最小生成树，该图的顶点是社区的房屋，房屋之间的边根据它们之间的距离进行加权。
- en: There are many algorithms to solve the minimum spanning tree problem. Two of
    the most famous are Prim's and Kruskal's.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多算法可以解决最小生成树问题。其中最著名的是普里姆（Prim）和克鲁斯卡尔（Kruskal）算法。
- en: Prim's algorithm is a greedy algorithm that repeatedly selects the edge of smaller
    weights that connect some edge not yet in the spanning tree with some edge already
    in the spanning tree. Its runtime depends on the implementation, but it's possible
    to achieve a runtime of *O(VlogE)*. It can be implemented similarly to Dijkstra's
    algorithm. We start with one vertex chosen arbitrarily to be part of the tree.
    All edges that connect to this "starting" vertex are added to a set of candidate
    edges that are sorted according to the edges' weights. While we still have vertices
    to add to the tree, we repeatedly select the edge with the smaller weight from
    the list of candidate edges that connects to a vertex not yet in the tree, and
    repeat the process for the new vertex.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 普里姆算法是一种贪心算法，它反复选择连接某些尚未包含在生成树中的边与某些已包含在生成树中的边的较小权重的边。其运行时间取决于实现方式，但可能实现 *O(VlogE)*
    的运行时间。它可以类似于迪杰斯特拉算法实现。我们从一个任意选择的顶点开始，将其作为树的一部分。所有连接到这个“起始”顶点的边都被添加到一个按边权重排序的候选边集合中。当我们仍然需要向树中添加顶点时，我们从候选边列表中选择具有较小权重的边，该边连接到一个尚未包含在树中的顶点，然后对新顶点重复此过程。
- en: Kruskal's algorithm is also a greedy algorithm that uses a disjoint-set data
    structure. A disjoint-set data structure, or union-find data structure, is a data
    structure that tracks elements that are partitioned into a number of non-overlapping
    subsets. It provides an efficient way to merge two sets and check whether two
    elements belong to the same set.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 克鲁斯卡尔算法也是一种使用并查集数据结构的贪心算法。并查集数据结构，或称为集合归并查找数据结构，是一种跟踪被划分为若干个非重叠子集的元素的数据结构。它提供了一种高效的方法来合并两个集合并检查两个元素是否属于同一个集合。
- en: The idea of Kruskal's algorithm is to reduce a forest (for example, a set of
    trees) to a single tree, using a disjoint-set data structure to keep track of
    trees. We start with one tree for each vertex, including only one vertex. While
    we have more than one tree, we select the edge of the smallest weight that connects
    two different trees (we don't want to produce a cycle), and join the two trees
    together. At the end, the resultant tree will be the one whose total edge weight
    is minimized. The running time of Kruskal's algorithm is also *O(VlogE)*.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 克鲁斯卡尔算法的思想是将森林（例如，一组树）减少到一棵树，使用并查集数据结构来跟踪树。我们从一个顶点开始，每个顶点有一棵树，只包含一个顶点。当我们有多个树时，我们选择连接两个不同树的具有最小权重的边（我们不希望产生循环），并将这两棵树合并在一起。最后，结果树将是总边权重最小化的树。克鲁斯卡尔算法的运行时间也是
    *O(VlogE)*。
- en: A* Search
  id: totrans-254
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: A* 搜索
- en: The *A** search algorithm is a very common algorithm when solving path-finding
    problems. It also solves the shortest path problem, enhancing Dijkstra's algorithm
    with the introduction of a heuristic to guide the search. A heuristic is a practical
    estimate of a given cost, not guaranteed to be optimal or perfect, but sufficient
    for the immediate goals, or to guide a search. Its basic idea is that, when adding
    this heuristic to the estimated distance already computed for a node, one can
    guide the search towards the goal and avoid visiting certain vertices.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: A* 搜索算法是在解决路径查找问题时非常常见的一种算法。它也解决了最短路径问题，通过引入启发式方法来增强迪杰斯特拉算法。启发式是一种对给定成本的实用估计，不保证是最优或完美的，但对于立即目标或引导搜索是足够的。其基本思想是，当将此启发式添加到已计算出的节点估计距离时，可以引导搜索朝向目标，并避免访问某些顶点。
- en: For example, if we use the Euclidean distance (for example, the straight line
    distance between two points) from our location to the exit of a given maze, we
    can guide the search towards that and avoid visiting certain unnecessary positions.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果我们使用欧几里得距离（例如，两点之间的直线距离）从我们的位置到给定迷宫的出口，我们可以引导搜索朝那个方向进行，避免访问某些不必要的位置。
- en: Maximum Flow
  id: totrans-257
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 最大流
- en: Some directed weighted graphs can be seen as flow networks. In a flow network,
    edge weights represent capacities and each edge receives a flow that can't exceed
    the edge's capacity. The labels on the edges represent the used and total capacity
    of the edge. The maximum flow attempts to find a feasible flow through the network
    that is maximum, considering a single source (where the initial flow starts) and
    single sink (where the flow ends). The maximum flow problem allows one to solve
    related problems like pair wise assignment. There are various algorithms to solve
    the maximum flow problem. Three of the most famous ones are the FordFulkerson
    algorithm, the Edmonds-Karp algorithm, and Dinic's algorithm.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 一些有向加权图可以看作是流网络。在流网络中，边权重代表容量，每条边接收的流量不能超过边的容量。边上的标签代表边的已用容量和总容量。最大流试图在考虑单个源（初始流量开始的地方）和单个汇（流量结束的地方）的情况下，在网络中找到最大可行流。最大流问题允许解决相关问题，如成对分配。有各种算法可以解决最大流问题。其中最著名的三个是Ford-Fulkerson算法、Edmonds-Karp算法和Dinic算法。
- en: The idea behind the Ford-Fulkerson algorithm is to repeatedly find augmenting
    paths in the flow network. An augmenting path is a path that still has an available
    capacity. While it is possible to find augmenting paths, one can add a flow through
    the path equal to its capacity and repeat the process. Ford-Fulkerson algorithm
    runs in *O(Ef)*, *f* being the maximum flow of the graph. The Edmonds-Karp algorithm
    improves on the Ford-Fulkerson algorithm by always selecting the augmenting path
    that is shortest. The runtime complexity of the Edmonds-Karp algorithm is *O(VE²)*,
    independent of the maximum flow value. Dinic's algorithm runs in *O(V²E)* time,
    also building on shortest augmenting paths, but uses some concepts that make it
    more suitable for sparse graphs.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: Ford-Fulkerson算法背后的思想是在流网络中反复寻找增广路径。增广路径是仍然有可用容量的路径。虽然可以找到增广路径，但可以通过路径的容量添加流量，并重复此过程。Ford-Fulkerson算法的运行时间是*O(Ef)*，其中*f*是图的流的最大值。Edmonds-Karp算法通过始终选择最短的增广路径来改进Ford-Fulkerson算法。Edmonds-Karp算法的运行时间复杂度是*O(VE²)*，与最大流值无关。Dinic算法在*O(V²E)*时间内运行，也基于最短增广路径，但使用了一些使其更适合稀疏图的概念。
- en: Understanding Complexity Classes of Problems
  id: totrans-260
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解问题的复杂度类别
- en: Nearly all of the algorithms introduced so far run in polynomial time (for instance,
    on inputs of size *n*, their worst-case running time is *O(n^k)* for constant
    *k*). However, there are problems that simply cannot be solved or for which a
    polynomial-time algorithm hasn't been found yet.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止介绍的所有算法几乎都在多项式时间内运行（例如，对于大小为*n*的输入，它们的最坏情况下运行时间是常数*k*的*O(n^k)*）。然而，有些问题根本无法解决，或者还没有找到多项式时间算法。
- en: An example of a problem that cannot be solved is the halting problem. The halting
    problem is the problem of determining, from the description of a computer program
    and an input, whether the program will finish running or continue to run forever.
    Alan Turing proved that a general algorithm to solve the halting problem for all
    pairs of (program, input) cannot exist.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 一个无法解决的问题的例子是停机问题。停机问题是从计算机程序和输入的描述中确定程序是否会完成运行或继续无限运行的问题。艾伦·图灵证明了对于所有（程序，输入）对，不存在解决停机问题的通用算法。
- en: It is common to call problems solvable by polynomial-time algorithms (for instance,
    those whose worst-case running time is *O(n^k)* for constant *k*) as "tractable",
    or "easy", and problems that require a super-polynomial-time algorithm (for instance,
    those whose running time is not bounded above by any polynomial) as "intractable",
    or "hard".
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 通常将可以用多项式时间算法解决的问题（例如，那些最坏情况下运行时间为常数*k*的*O(n^k)*）称为“可解的”或“简单的”，而需要超多项式时间算法解决的问题（例如，其运行时间不受任何多项式的上界限制）称为“不可解的”或“困难的”。
- en: There is a class of problems, called **NP-Complete** (**NPC**) problems, and
    no one has yet found a polynomial-time algorithm to solve them. However, no one
    has yet been able to prove that no polynomial-time algorithm can exist for any
    of them.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 存在一类称为**NP-完全**（**NPC**）的问题，还没有人找到解决它们的算法。然而，还没有人能够证明对于它们中的任何一个，都不存在多项式时间算法。
- en: There is another class of problems, called **NP** problems, whose solutions
    are verifiable in polynomial time. This means that, given a problem, and a possible
    solution to it, one can verify if the solution is correct in polynomial time.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 另一类问题被称为**NP**问题，其解决方案可以在多项式时间内验证。这意味着，给定一个问题及其一个可能的解决方案，可以在多项式时间内验证该解决方案是否正确。
- en: All problems in P are also in NP. NPC consists of problems that belong to the
    NP class and to the NP-hard class. A problem is NP-hard if an algorithm for solving
    it can be translated into one for solving a NP problem.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: P类中的所有问题也都在NP类中。NPC包括属于NP类和NP-hard类的问题。一个问题是NP-hard，如果解决它的算法可以被转换成解决NP问题的算法。
- en: One of the deepest open research problems in theoretical computer science is
    whether *P* is really different from NP (for instance, *P != NP*).
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 理论计算机科学中最深奥的未解研究问题之一是P是否真的与NP不同（例如，*P != NP*）。
- en: 'Examples of NPC problems are as follows:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: NPC问题的例子如下：
- en: Finding the longest path in the graph
  id: totrans-269
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在图中找到最长路径
- en: Finding a path in a graph that visits all vertices exactly once (known as a Hamiltonian
    path)
  id: totrans-270
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在图中找到一条路径，该路径访问所有顶点恰好一次（称为哈密顿路径）
- en: A common example of an NP-hard problem is finding the shortest path in a graph that
    visits all vertices exactly once and returns to the starting point. The problem consists
    of finding the Hamiltonian cycle of the smallest weight, and is often described
    as the traveling salesman problem as it models the problem of a salesman that
    needs to visit all cities and return to his hometown.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 一个常见的NP-hard问题示例是在图中找到一条路径，该路径访问所有顶点恰好一次并返回起点。这个问题包括找到最小权重的哈密顿回路，通常描述为旅行商问题，因为它模拟了需要访问所有城市并返回家乡的旅行商的问题。
- en: Summary
  id: totrans-272
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we have introduced graphs, formalized what they are and shown
    two different ways to represent them in computer programs. Afterwards, we took
    a look at ways of traversing graphs, using them as building blocks for building
    more complex algorithms on top. Then, we looked at two different algorithms for
    finding shortest paths in a graph.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了图，正式化了它们的定义，并展示了在计算机程序中用两种不同的方式表示它们。之后，我们探讨了遍历图的方法，将它们作为构建更复杂算法的基石。然后，我们研究了两种在图中找到最短路径的不同算法。
- en: At the end of this book, we provide pointers for curious students to study on
    their own. The world of data structures and algorithms is vast and requires a
    type of mathematical reasoning for which some study and practice is required.
    However, one of the most rewarding feelings in the life of a software engineer
    is coming up with a clever algorithms to solve a complex problems.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的结尾，我们为好奇的学生提供了自学指南。数据结构和算法的世界是广阔的，需要一种数学推理能力，这需要一些学习和实践。然而，对于软件工程师来说，生活中最有成就感的事情之一就是想出巧妙的算法来解决复杂问题。
