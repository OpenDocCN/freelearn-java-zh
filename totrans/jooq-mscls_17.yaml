- en: '*Chapter 13*: Exploiting SQL Functions'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'From mathematical and statistical computations to string and date-time manipulations,
    respectively, to different types of aggregations, rankings, and groupings, SQL
    built-in functions are quite handy in many scenarios. There are different categories
    of functions depending on their goal and usage and, as you''ll see, jOOQ has accorded
    major attention to their support. Based on these categories, our agenda for this
    chapter follows these points:'
  prefs: []
  type: TYPE_NORMAL
- en: Regular functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Aggregate functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Window functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Aggregates as window functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Aggregate functions and `ORDER BY`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ordered set aggregate functions (`WITHIN GROUP`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Grouping, filtering, distinctness, and functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Grouping sets
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's get started!
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The code for this chapter can be found on GitHub at [https://github.com/PacktPublishing/jOOQ-Masterclass/tree/master/Chapter13](https://github.com/PacktPublishing/jOOQ-Masterclass/tree/master/Chapter13).
  prefs: []
  type: TYPE_NORMAL
- en: Regular functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Being a SQL user, you've probably worked with a lot of regular or common SQL
    functions such as functions for dealing with `NULL` values, numeric functions,
    string functions, date-time functions, and so on. While the jOOQ manual represents
    a comprehensive source of information structured as a nomenclature of all the
    supported SQL built-in functions, we are trying to complete a series of examples
    designed to get you familiar with the jOOQ syntax in different scenarios. Let's
    start by talking about SQL functions for dealing with `NULL` values.
  prefs: []
  type: TYPE_NORMAL
- en: Just in case you need a quick overview about some simple and common `NULL` stuff,
    then quickly check out the `someNullsStuffGoodToKnow()` method available in the
    bundled code.
  prefs: []
  type: TYPE_NORMAL
- en: SQL functions for dealing with NULLs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: SQL provides several functions for handling `NULL` values in our queries. Next,
    let's cover `COALESCE()`, `DECODE()`, `IIF()`, `NULLIF()`, `NVL()`, and `NVL2()`
    functions. Let's start with `COALESCE()`.
  prefs: []
  type: TYPE_NORMAL
- en: COALESCE()
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: One of the most popular functions for dealing with `NULL` values is `COALESCE()`.
    This function returns the first non-null value from its list of *n* arguments.
  prefs: []
  type: TYPE_NORMAL
- en: 'For instance, let''s assume that for each `DEPARTMENT`, we want to compute
    a deduction of 25% from `CASH`, `ACCOUNTS_RECEIVABLE`, or `INVENTORIES`, and a
    deduction of 25% from `ACCRUED_LIABILITIES`, `ACCOUNTS_PAYABLE`, or `ST_BORROWING`.
    Since this order is strict, if one of these is a `NULL` value, we go for the next
    one, and so on. If all are `NULL`, then we replace `NULL` with 0\. Relying on
    the jOOQ `coalesce()` method, we can write the query as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Notice the explicit usage of `inline()` for inlining the integer 0\. As long
    as you know that this integer is a constant, there is no need to rely on `val()`
    for rendering a bind variable (placeholder). Using `inline()` fits pretty well
    for SQL functions, which typically rely on constant arguments or mathematical
    formulas having constant terms that can be easily inlined. If you need a quick
    reminder of `inline()` versus `val()`, then consider a quick revisit of [*Chapter
    3*](B16833_03.xhtml#_idTextAnchor040), *jOOQ Core Concepts*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Besides `coalesce(Field<T> field, Field<?>... fields)` used here, jOOQ provides
    two other flavors: `coalesce(Field<T> field, T value)` and `coalesce(T value,
    T... values)`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is another example that relies on the `coalesce()` method to fill the
    gaps in the `DEPARTMENT.FORECAST_PROFIT` column. Each `FORECAST_PROFIT` value
    that is `NULL` is filled by the following query:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: So, for each row having `FORECAST_PROFIT` equal to `NULL`, we use a custom interpolation
    formula represented by the average of all the non-null `FORECAST_PROFIT` values
    where the profit (`PROFIT`) is greater than the profit of the current row.
  prefs: []
  type: TYPE_NORMAL
- en: Next, let's talk about `DECODE()`.
  prefs: []
  type: TYPE_NORMAL
- en: DECODE()
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In some dialects (for instance, in Oracle), we have the `DECODE()` function
    that acts as an if-then-else logic in queries. Having `DECODE(x, a, r`1`, r`2`)`
    is equivalent to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Or, since `DECODE` makes `NULL` safe comparisons, it's more like `IF x IS NOT
    DISTINCT FROM a THEN …`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s attempt to compute a financial index as ((`DEPARTMENT.LOCAL_BUDGET`
    * 0.25) * 2) / 100\. Since `DEPARTMENT.LOCAL_BUDGET` can be `NULL`, we prefer
    to replace such occurrences with 0\. Relying on the jOOQ `decode()` method, we
    have the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'The `DECODE()` part can be perceived like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'But don''t conclude from here that `DECODE()` accepts only this simple logic.
    Actually, the `DECODE()` syntax is more complex and looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'In this syntax, the following applies:'
  prefs: []
  type: TYPE_NORMAL
- en: '`x` is compared with the other argument, `a`1`, a`2`, …, a`n.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`a`1`, a`2`, …,` or `a`n is sequentially compared with the first argument;
    if any comparison `x = a`1`, x = a`2`, …, x = a`n returns `true`, then the `DECODE()`
    function terminates by returning the result.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`r`1`, r`2`, …,` or `r`n is the result corresponding to `x`i `= a`i`, i = (1…n)`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`d` is an expression that should be returned if no match for `x`i`=a`i`, i
    = (1…n)` was found.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Since jOOQ emulates `DECODE()` using `CASE` expressions, you can safely use
    it in all dialects supported by jOOQ, so let''s see another example here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: So, in this case, if the department name is *Advertising*, *Accounting*, or
    *Logistics*, then it is replaced with a meaningful description; otherwise, we
    simply return the current name.
  prefs: []
  type: TYPE_NORMAL
- en: 'Moreover, `DECODE()` can be used with `ORDER BY`, `GROUP BY`, or next to aggregate
    functions as well. While more examples can be seen in the bundled code, here is
    another one of using `DECODE()` with `GROUP BY` for counting `BUY_PRICE` larger/equal/smaller
    than half of `MSRP`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'And here is another example of using imbricated `DECODE()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'For given `sign(a, b)`, it returns 1 if `a` > `b`, 0 if `a` = `b`, and -1 if
    `a` < `b`. So, this code can be easily interpreted based on the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.1 – Output'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16833_Figure_13.1.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 13.1 – Output
  prefs: []
  type: TYPE_NORMAL
- en: More examples are available in the *Functions* bundled code.
  prefs: []
  type: TYPE_NORMAL
- en: IIF()
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `IIF()` function implements the if-then-else logic via three arguments,
    as follows (this acts as the `NVL2()` function presented later):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: It evaluates the first argument (`boolean_expr`) and returns the second argument
    (`value_for_true_case`) and third one (`value_for_false_case`), respectively.
  prefs: []
  type: TYPE_NORMAL
- en: 'For instance, the following usage of the jOOQ `iif()` function evaluates the
    `DEPARTMENT.LOCAL_BUDGET.isNull()` expression and outputs the text *NO BUDGET*
    or *HAS BUDGET*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: More examples, including imbricated `IIF()` usage, are available in the bundled
    code.
  prefs: []
  type: TYPE_NORMAL
- en: NULLIF()
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `NULLIF(expr1, expr2)` function returns `NULL` if the arguments are equal.
    Otherwise, it returns the first argument (`expr1`).
  prefs: []
  type: TYPE_NORMAL
- en: For instance, in legacy databases, it is a common practice to have a mixture
    of `NULL` and empty strings for missing values. We have intentionally created
    such a case in the `OFFICE` table for `OFFICE.COUNTRY`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since empty strings are not `NULL` values, using `ISNULL()` will not return
    them even if, for us, `NULL` values and empty strings may have the same mining.
    Using the jOOQ `nullif()` method is a handy approach for finding all missing data
    (`NULL` values and empty strings), as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: These examples are available in the *Functions* bundled code.
  prefs: []
  type: TYPE_NORMAL
- en: IFNULL() and ISNULL()
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `IFNULL(expr1, expr2)` and `ISNULL(expr1, expr2)` functions take two arguments
    and return the first one if it is not `NULL`. Otherwise, they return the second
    argument. The former is similar to Oracle's `NVL()` function presented later,
    while the latter is specific to SQL Server. Both of them are emulated by jOOQ
    via `CASE` expressions for all dialects that don't support them natively.
  prefs: []
  type: TYPE_NORMAL
- en: 'For instance, the following snippet of code produces 0 for each `NULL` value
    of `DEPARTMENT.LOCAL_BUDGET` via both jOOQ methods, `ifnull()` and `isnull()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is another example that fetches the customer''s postal code or address:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: More examples are available in the *Functions* bundled code.
  prefs: []
  type: TYPE_NORMAL
- en: NVL() and NVL2()
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Some dialects (for example, Oracle) support two functions named `NVL()` and
    `NVL2()`. Both of them are emulated by jOOQ for all dialects that don't support
    them natively. The former acts like `IFNULL()`, while the latter acts like `IIF()`.
    So, `NVL(expr1, expr2)` produces the first argument if it is not `NULL`; otherwise,
    it produces the second argument.
  prefs: []
  type: TYPE_NORMAL
- en: 'For instance, let''s use the jOOQ `nvl()` method for applying the variance
    formula used in finance to calculate the difference between a forecast and an
    actual result for `DEPARTMENT.FORECAST_PROFIT` and `DEPARTMENT.PROFIT` as ((`ACTUAL
    PROFIT` ÷ `FORECAST PROFIT`) - 1) * 100, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: If `PROFIT` is `NULL`, then we replace it with 0, and if `FORECAST_PROFIT` is
    `NULL`, then we replace it with a default profit of 10,000\. Challenge yourself
    to write this query via `ISNULL()` as well.
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, `NVL2(expr1, expr2, expr3)` evaluates the first argument
    (`expr1`). If `expr1` is not `NULL`, then it returns the second argument (`expr2`);
    otherwise, it returns the third argument (`expr3`).
  prefs: []
  type: TYPE_NORMAL
- en: 'For instance, each `EMPLOYEE` has a salary and an optional `COMMISSION` (a
    missing commission is `NULL`). Let''s fetch salary + commission via jOOQ `nvl2()`
    and `iif()`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: 'All three columns—`iif1`, `iif2`, and `nvl2`—should contain the same data.
    Regrettably, `NVL` can perform better than `COALESCE` in some Oracle cases. For
    more details, consider reading this article: [https://connor-mcdonald.com/2018/02/13/nvl-vs-coalesce/](https://connor-mcdonald.com/2018/02/13/nvl-vs-coalesce/).
    You can check out all the examples from this section in the *Functions* bundled
    code. Next, let''s talk about numeric functions.'
  prefs: []
  type: TYPE_NORMAL
- en: Numeric functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: jOOQ supports a comprehensive list of numeric functions, including `ABS()`,
    `SIN()`, `COS()`, `EXP()`, `FLOOR()`, `GREATEST()`, `LEAST()`, `LN()`, `POWER()`,
    `SIGN()`, `SQRT()`, and much more. Mainly, jOOQ exposes a set of methods that
    mirrors the names of these SQL functions and supports the proper number and type
    of arguments.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since you can find all these functions listed and exemplified in the jOOQ manual,
    let''s try here two examples of combining several of them to accomplish a common
    goal. For instance, a famous formula for computing the Fibonacci number is the
    Binet formula (notice that no recursion is required!):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE107]'
  prefs: []
  type: TYPE_PRE
- en: 'Writing this formula in jOOQ/SQL requires us to use the `power()` numeric function
    as follows (`n` is the number to compute):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE108]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE109]'
  prefs: []
  type: TYPE_PRE
- en: 'How about computing the distance between two points expressed as `(latitude1,
    longitude1)`, respectively `(latitude2, longitude2)`? Of course, exactly as in
    the case of the Fibonacci number, such computations are commonly done outside
    the database (directly in Java) or in a UDF or stored procedure, but trying to
    solve them in a `SELECT` statement is a good opportunity to quickly practice some
    numeric functions and get familiar with jOOQ syntax. So, here we go with the required
    math:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE110]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE111]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE112]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE113]'
  prefs: []
  type: TYPE_PRE
- en: 'This time, we need the jOOQ `power()`, `sin()`, `cos()`, `atn2()`, and `sqrt()`
    numeric methods, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE114]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE115]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE116]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE117]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE118]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE119]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE120]'
  prefs: []
  type: TYPE_PRE
- en: You can practice these examples in the *Functions* bundled code.
  prefs: []
  type: TYPE_NORMAL
- en: String functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Exactly as in case of SQL numeric functions, jOOQ supports an impressive set
    of SQL string functions, including `ASCII()`, `CONCAT()`, `OVERLAY()`, `LOWER()`,
    `UPPER()`, `LTRIM()`, `RTRIM()`, and so on. You can find each of them exemplified
    in the jOOQ manual, so here, let''s try to use several string functions to obtain
    an output, as in this screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.2 – Applying several SQL string functions'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16833_Figure_13.2.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 13.2 – Applying several SQL string functions
  prefs: []
  type: TYPE_NORMAL
- en: 'Transforming what we have in what we want can be expressed in jOOQ via several
    methods, including `concat()`, `upper()`, `space()`, `substring()`, `lower()`,
    and `rpad()`—of course, you can optimize or write the following query in different
    ways:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE121]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE122]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE123]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE124]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE125]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE126]'
  prefs: []
  type: TYPE_PRE
- en: You can check out this example next to several examples of splitting a string
    by a delimiter in the *Functions* bundled code.
  prefs: []
  type: TYPE_NORMAL
- en: Date-time functions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The last category of functions covered in this section includes date-time functions.
    Mainly, jOOQ exposes a wide range of date-time functions that can be roughly categorized
    as functions that operate with `java.sql.Date`, `java.sql.Time`, and `java.sql.Timestamp`,
    and functions that operate with Java 8 date-time, `java.time.LocalDate`, `java.time.LocalDateTime`,
    and `java.time.OffsetTime`. jOOQ can't use the `java.time.Duration` or `Period`
    classes as they work differently from standard SQL intervals, though of course,
    converters and bindings can be applied.
  prefs: []
  type: TYPE_NORMAL
- en: Moreover, jOOQ comes with a substitute for JDBC missing `java.sql.Interval`
    data type, named `org.jooq.types.Interval`, having three implementations as `DayToSecond`,
    `YearToMonth`, and `YearToSecond`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are a few examples that are pretty simple and intuitive. This first example
    fetches the current date as `java.sql.Date` and `java.time.LocalDate`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE127]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE128]'
  prefs: []
  type: TYPE_PRE
- en: 'This next example converts an ISO *8601* `DATE` string literal into a `java.sql.Date`
    data type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE129]'
  prefs: []
  type: TYPE_PRE
- en: 'Adding an interval of 10 days to a `Date` and a `LocalDate` can be done like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE130]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE131]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE132]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE133]'
  prefs: []
  type: TYPE_PRE
- en: 'Or, adding an interval of 3 months can be done like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE134]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE135]'
  prefs: []
  type: TYPE_PRE
- en: 'Extracting the day of week (1 = Sunday, 2 = Monday, ..., 7 = Saturday) via
    the SQL `EXTRACT()` and jOOQ `dayOfWeek()` functions can be done like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE136]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE137]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE138]'
  prefs: []
  type: TYPE_PRE
- en: You can check out more examples in the *Functions* bundled code. In the next
    section, let's tackle aggregate functions.
  prefs: []
  type: TYPE_NORMAL
- en: Aggregate functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The most common aggregate functions (in an arbitrary order) are `AVG()`, `COUNT()`,
    `MAX()`, `MIN()`, and `SUM()`, including their `DISTINCT` variants. I''m pretty
    sure that you are very familiar with these aggregates and you''ve used them in
    many of your queries. For instance, here are two `SELECT` statements that compute
    the popular harmonic and geometric means for sales grouped by fiscal year. Here,
    we use the jOOQ `sum()` and `avg()` functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE139]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE140]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE141]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE142]'
  prefs: []
  type: TYPE_PRE
- en: 'And here, we compute the geometric mean:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE143]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE144]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE145]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE146]'
  prefs: []
  type: TYPE_PRE
- en: But as you know (or as you'll find out shortly), there are many other aggregates
    that have the same goal of performing some calculations across a set of rows and
    returning a single output row. Again, jOOQ exposes dedicated methods whose names
    mirror the aggregates' names or represent suggestive shortcuts.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, let''s see several aggregate functions that are less popular and are
    commonly used in statistics, finance, science, and other fields. One of them is
    dedicated to computing Standard Deviation, ([https://en.wikipedia.org/wiki/Standard_deviation](https://en.wikipedia.org/wiki/Standard_deviation)).
    In jOOQ, we have `stddevSamp()` for Sample and `stddevPop()` for Population. Here
    is an example of computing SSD, PSD, and emulation of PSD via population variance
    (introduced next) for sales grouped by fiscal year:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE147]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE148]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE149]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE150]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE151]'
  prefs: []
  type: TYPE_PRE
- en: 'Both SSD and PSD are supported in MySQL, PostgreSQL, SQL Server, Oracle, and
    many other dialects and are useful in different kinds of problems, from finance,
    statistics, forecasting, and so on. For instance, in statistics, we have the standard
    score (or so-called z-score) that represents the number of SDs placed above or
    below the population mean for a certain observation and having the formula z =
    (x - µ) / σ (z is z-score, x is the observation, µ is the mean, and σ is the SD).
    You can read further information on this here: [https://en.wikipedia.org/wiki/Standard_score](https://en.wikipedia.org/wiki/Standard_score).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, considering that we store the number of sales (`DAILY_ACTIVITY.SALES`)
    and visitors (`DAILY_ACTIVITY.VISITORS`) in `DAILY_ACTIVITY` and we want to get
    some information about this data, since there is no direct comparison between
    sales and visitors, we have to come up with some meaningful representation, and
    this can be provided by z-scores. By relying on Common Table Expressions (**CTEs**)
    and SD, we can express in jOOQ the following query (of course, in production,
    using a stored procedure may be a better choice for such queries):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE152]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE153]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE154]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE155]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE156]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE157]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE158]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE159]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE160]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE161]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE162]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE163]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE164]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE165]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE166]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE167]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE168]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE169]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE170]'
  prefs: []
  type: TYPE_PRE
- en: Among the results produced by this query, we remark the z-score of sales on
    *2004-01-06*, which is 2.00\. In the context of z-score analysis, this output
    is definitely worth a deeper investigation (typically, z-scores > 1.96 or < -1.96
    are considered outliers that should be further investigated). Of course, this
    is not our goal, so let's jump to another aggregate.
  prefs: []
  type: TYPE_NORMAL
- en: 'Going further through statistical aggregates, we have variance, which is defined
    as the average of the squared differences from the mean or the average squared
    deviations from the mean ([https://en.wikipedia.org/wiki/Variance](https://en.wikipedia.org/wiki/Variance)).
    In jOOQ, we have sample variance via `varSamp()` and population variance via `varPop()`,
    as illustrated in this code example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE171]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE172]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE173]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE174]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE175]'
  prefs: []
  type: TYPE_PRE
- en: 'Both of them are supported in MySQL, PostgreSQL, SQL Server, Oracle, and many
    other dialects, but just for fun, you can emulate sample variance via the `COUNT()`
    and `SUM()` aggregates as has been done in the following code snippet—just another
    opportunity to practice these aggregates:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE176]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE177]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE178]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE179]'
  prefs: []
  type: TYPE_PRE
- en: Next, we have linear regression (or correlation) functions applied for determining
    regression relationships between the dependent (denoted as Y) and independent
    (denoted as X) variable expressions ([https://en.wikipedia.org/wiki/Regression_analysis](https://en.wikipedia.org/wiki/Regression_analysis)).
    In jOOQ, we have `regrSXX()`,`regrSXY()`, `regrSYY()`, `regrAvgX``()`, `regrAvgXY()`,
    `regrCount()`, `regrIntercept()`, `regrR2()`, and `regrSlope()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'For instance, in the case of `regrSXY(y, x)`, `y` is the dependent variable
    expression and `x` is the independent variable expression. If `y` is `PRODUCT.BUY_PRICE`
    and `x` is `PRODUCT.MSRP`, then the linear regression per `PRODUCT_LINE` looks
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE180]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE181]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE182]'
  prefs: []
  type: TYPE_PRE
- en: 'The functions listed earlier (including `regrSXY()`) are supported in all dialects,
    but they can be easily emulated as well. For instance, `regrSXY()` can be emulated
    as `(SUM(X*Y)-SUM(X) * SUM(Y)/COUNT(*))`, as illustrated here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE183]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE184]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE185]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE186]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE187]'
  prefs: []
  type: TYPE_PRE
- en: In addition, `regrSXY()` can also be emulated as `SUM(1) * COVAR_POP(expr1,
    expr2)`, where `COVAR_POP()` represents the population covariance and `SUM(1)`
    is actually `REGR_COUNT(expr1, expr2)`. You can see this example in the bundled
    code next to many other emulations for `REGR_FOO()` functions and an example of
    calculating `y = slope * x – intercept` via `regrSlope()` and `regrIntercept()`,
    linear regression coefficients, but also via `sum()`, `avg()`, and `max()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'After population covariance ([https://en.wikipedia.org/wiki/Covariance](https://en.wikipedia.org/wiki/Covariance)),
    `COVAR_POP()`, we have sample covariance, `COVAR_SAMP()`, which can be called
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE188]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE189]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE190]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE191]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE192]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE193]'
  prefs: []
  type: TYPE_PRE
- en: If your database doesn't support the covariance functions (for instance, MySQL
    or SQL Server), then you can emulate them via common aggregates—`COVAR_SAMP()`
    as `(SUM(x*y) - SUM(x) * SUM(y) / COUNT(*)) / (COUNT(*) - 1)`, and `COVAR_POP()`
    as `(SUM(x*y) - SUM(x) * SUM(y) / COUNT(*)) / COUNT(*)`. You can find examples
    in the *AggregateFunctions* bundled code.
  prefs: []
  type: TYPE_NORMAL
- en: 'An interesting function that is not supported by most databases (Exasol is
    one of the exceptions) but is provided by jOOQ is the synthetic `product()` function.
    This function represents multiplicative aggregation emulated via `exp(sum(log(arg)))`
    for positive numbers, and it performs some extra work for zero and negative numbers.
    For instance, in finance, there is an index named Compounded Month Growth Rate
    (CMGR) that is computed based on monthly revenue growth, as we have in `SALE.REVENUE_GROWTH`.
    The formula is `(PRODUCT (1 + SALE.REVENUE_GROWTH))) ^ (1 / COUNT())`, and we''ve
    applied it for each year here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE194]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE195]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE196]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE197]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE198]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE199]'
  prefs: []
  type: TYPE_PRE
- en: We also multiply everything by 100 to obtain the result as a percent. You can
    find this example in the *AggregateFunctions* bundled code, next to other aggregation
    functions such as `BOOL_AND()`, `EVERY()`, `BOOL_OR()`, and functions for bitwise
    operations.
  prefs: []
  type: TYPE_NORMAL
- en: 'When you have to use an aggregate function that is partially supported or not
    supported by jOOQ, you can rely on the `aggregate()`/ `aggregateDistinct()` methods.
    Of course, your database must support the called aggregate function. For instance,
    jOOQ doesn''t support the Oracle `APPROX_COUNT_DISTINCT()` aggregation function,
    which represents an alternative to the `COUNT (DISTINCT expr)` function. This
    is useful for approximating the number of distinct values while processing large
    amounts of data significantly faster than the traditional `COUNT` function, with
    negligible deviation from the exact number. Here is a usage of the `(String name,
    Class<T> type, Field<?>... arguments`) aggregate, which is just one of the provided
    flavors (check out the documentation for more):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE200]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE201]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE202]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE203]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE204]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE205]'
  prefs: []
  type: TYPE_PRE
- en: You can find this example in the *AggregateFunctions* bundled code for Oracle.
  prefs: []
  type: TYPE_NORMAL
- en: Window functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Window functions are extremely useful and powerful; therefore, they represent
    a must-know topic for every developer that interacts with a database via SQL.
    In a nutshell, the best way to quickly overview window functions is to start from
    a famous diagram representing a comparison between an aggregation function and
    a window function that highlights the main difference between them, as represented
    here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.3 – Aggregate functions versus window functions'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16833_Figure_13.3.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 13.3 – Aggregate functions versus window functions
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see, both the aggregate function and the window function calculate
    something on a set of rows, but a window function doesn''t aggregate or group
    these rows into a single output row. A window function relies on the following
    syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE206]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE207]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE208]'
  prefs: []
  type: TYPE_PRE
- en: 'This syntax can be explained as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Obviously, `window_function_name` represents the window function name, such
    as `ROW_NUMBER()`, `RANK()`, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: '`expression` identifies the column (or target expression) on which this window
    function will operate.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `OVER` clause signals that this is a window function, and it consists of
    three clauses: `Partition`, `Order`, and `Frame`. By adding the `OVER` clause
    to any aggregate function, you transform it into a window function.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Partition` clause is optional, and its goal is to divide the rows into
    partitions. Next, the window function will operate on each partition. It has the
    following syntax: `PARTITION BY expr1, expr2, ...`. If `PARTITION BY` is omitted,
    then the entire result set represents a single partition. To be entirely accurate,
    if `PARTITION BY` is omitted, then all the data produced by `FROM`/`WHERE`/`GROUP
    BY`/`HAVING` represents a single partition.'
  prefs: []
  type: TYPE_NORMAL
- en: The `Order` clause is also optional, and it handles the order of rows in a partition.
    Its syntax is `ORDER BY expression [ASC | DESC] [NULLS {FIRST| LAST}] ,...`.
  prefs: []
  type: TYPE_NORMAL
- en: The `Frame` clause demarcates a subset of the current partition. The common
    syntax is `mode BETWEEN start_of_frame AND end_of_frame [frame_exclusion]`.
  prefs: []
  type: TYPE_NORMAL
- en: '`mode` instructs the database about how to treat the input rows. Three possible
    values indicate the type of relationship between the frame rows and the current
    row: `ROWS`, `GROUPS`, and `RANGE`.'
  prefs: []
  type: TYPE_NORMAL
- en: ROWS
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `ROWS` mode specifies that the offsets of the frame rows and the current
    row are row numbers (the database sees each input row as an individual unit of
    work). In this context, `start_of_frame` and `end_of_frame` determine which rows
    the window frame starts and ends with.
  prefs: []
  type: TYPE_NORMAL
- en: In this context, `start_of_frame` can be `N PRECEDING`, which means that the
    frame starts at nth rows before the currently evaluated row (in jOOQ, `rowsPreceding(n)`),
    `UNBOUNDED PRECEDING`, which means that the frame starts at the first row of the
    current partition (in jOOQ, `rowsUnboundedPreceding()`), and `CURRENT ROW` (jOOQ
    `rowsCurrentRow()`).
  prefs: []
  type: TYPE_NORMAL
- en: The `end_of_frame` value can be `CURRENT ROW` (previously described), `N FOLLOWING`,
    which means that the frame ends at the nth row after the currently evaluated row
    (in jOOQ, `rowsFollowing(n)`), and `UNBOUNDED FOLLOWING`, which means that the
    frame ends at the last row of the current partition (in jOOQ, `rowsUnboundedFollowing()`).
  prefs: []
  type: TYPE_NORMAL
- en: 'Check out the following diagram containing some examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.4 – ROWS mode examples'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16833_Figure_13.4.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 13.4 – ROWS mode examples
  prefs: []
  type: TYPE_NORMAL
- en: What's in gray represents the included rows.
  prefs: []
  type: TYPE_NORMAL
- en: GROUPS
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `GROUPS` mode instructs the database that the rows with duplicate sorting
    values should be grouped together. So, `GROUPS` is useful when duplicate values
    are present.
  prefs: []
  type: TYPE_NORMAL
- en: In this context, `start_of_frame` and `end_of_frame` accept the same values
    as `ROWS`. But, in the case of `start_of_frame`, `CURRENT_ROW` points to the first
    row in a group that contains the current row, while in the case of `end_of_frame`,
    it points to the last row in a group that contains the current row. Moreover,
    `N PRECEDING`/`FOLLOWING` refers to groups that should be considered as the number
    of groups before, respectively, after the current group. On the other hand, `UNBOUNDED
    PRECEDING`/`FOLLOWING` has the same meaning as in the case of `ROWS`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Check out the following diagram containing some examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.5 – GROUPS mode examples'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16833_Figure_13.5.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 13.5 – GROUPS mode examples
  prefs: []
  type: TYPE_NORMAL
- en: There are three groups (G1, G2, and G3) represented in different shades of gray.
  prefs: []
  type: TYPE_NORMAL
- en: RANGE
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `RANGE` mode doesn't tie rows as `ROWS`/`GROUPS`. This mode works on a given
    range of values of the sorting column. This time, for `start_of_frame` and `end_of_frame`,
    we don't specify the number of rows/groups; instead, we specify the maximum difference
    of values that the window frame should contain. Both values must be expressed
    in the same units (or, meaning) as the sorting column is.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this context, for `start_of_frame`,we have the following: (this time, `N`
    is a value in the same unit as the sorting column is) `N PRECEDING` (in jOOQ,
    `rangePreceding(n)`), `UNBOUNDED PRECEDING` (in jOOQ, `rangeUnboundedPreceding()`),
    and `CURRENT ROW` (in jOOQ, `rangeCurrentRow()`). For `end_of_frame`, we have
    `CURRENT ROW`, `UNBOUNDED FOLLOWING` (in jOOQ, `rangeUnboundedFollowing()`), `N
    FOLLOWING` (in jOOQ, `rangeFollowing(n)`).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Check out the following diagram containing some examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.6 – RANGE mode examples'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16833_Figure_13.6.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 13.6 – RANGE mode examples
  prefs: []
  type: TYPE_NORMAL
- en: What's in gray represents the included rows.
  prefs: []
  type: TYPE_NORMAL
- en: BETWEEN start_of_frame AND end_of_frame
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Especially for the `BETWEEN start_of_frame AND end_of_frame` construction, jOOQ
    comes with `fooBetweenCurrentRow()`, `fooBetweenFollowing(n)`, `fooBetweenPreceding(n)`,
    `fooBetweenUnboundedFollowing()`, and `fooBetweenUnboundedPreceding()`. In all
    these methods, `foo` can be replaced with `rows`, `groups`, or `range`.
  prefs: []
  type: TYPE_NORMAL
- en: In addition, for creating compound frames, jOOQ provides `andCurrentRow()`,
    `andFollowing(n)`, `andPreceding(n)`, `andUnboundedFollowing()`, and `andUnboundedPreceding()`.
  prefs: []
  type: TYPE_NORMAL
- en: frame_exclusion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Via the `frame_exclusion` optional part, we can exclude certain rows from the
    window frame. `frame_exclusion` works exactly the same for all three modes. Possible
    values are listed here:'
  prefs: []
  type: TYPE_NORMAL
- en: '`EXCLUDE CURRENT ROW`—Exclude the current row (in jOOQ, `excludeCurrentRow()`).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`EXCLUDE GROUP`—Exclude the current row but also exclude all peer rows (for
    instance, exclude all rows having the same value in the sorting column). In jOOQ,
    we have the `excludeGroup()` method.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`EXCLUDE TIES`—Exclude all peer rows, but not the current row (in jOOQ, `excludeTies()`).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`EXCLUDE NO OTHERS`—This is the default, and it means to exclude nothing (in
    jOOQ, `excludeNoOthers()`).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To better visualize these options, check out the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.7 – Examples of excluding rows'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16833_Figure_13.7.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 13.7 – Examples of excluding rows
  prefs: []
  type: TYPE_NORMAL
- en: 'Speaking about the logical order of operations in SQL, we notice here that
    window functions are placed between `HAVING` and `SELECT`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.8 – Logical order of operations in SQL'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16833_Figure_13.8.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 13.8 – Logical order of operations in SQL
  prefs: []
  type: TYPE_NORMAL
- en: Also, I think is useful to explain that window functions can act upon data produced
    by all the previous steps *1-5*, and can be declared in all the following steps
    *7-12* (effectively only in 7 and 10). Before jumping into some window functions
    examples, let's quickly cover a less-known but quite useful SQL clause.
  prefs: []
  type: TYPE_NORMAL
- en: The QUALIFY clause
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Some databases (for instance, Snowflake) support a clause named `QUALIFY`.
    Via this clause, we can filter (apply a predicate) the results of window functions.
    Mainly, a `SELECT … QUALIFY` clause is evaluated after window functions are computed,
    so after `QUALIFY` is `QUALIFY <predicate>`, and in the following screenshot,
    you can see how it makes the difference (this query returns every 10th product
    from the `PRODUCT` table via the `ROW_NUMBER()` window function):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.9 – Logical order of operations in SQL'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16833_Figure_13.9.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 13.9 – Logical order of operations in SQL
  prefs: []
  type: TYPE_NORMAL
- en: By using the `QUALIFY` clause, we eliminate the subquery and the code is less
    verbose. Even if this clause has poor native support among database vendors, jOOQ
    emulates it for all the supported dialects. Cool, right?! During this chapter,
    you'll see more examples of using the `QUALIFY` clause.
  prefs: []
  type: TYPE_NORMAL
- en: Working with ROW_NUMBER()
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`ROW_NUMBER()` is a ranking window function that assigns a sequential number
    to each row (it starts from 1). A simple example is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.10 – Simple example of ROW_NUMBER()'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16833_Figure_13.10.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 13.10 – Simple example of ROW_NUMBER()
  prefs: []
  type: TYPE_NORMAL
- en: You already saw an example of paginating database views via `ROW_NUMBER()` in
    [*Chapter 12*](B16833_12.xhtml#_idTextAnchor226), *Pagination and Dynamic Queries*,
    so you should have no problem understanding the next two examples.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s assume that we want to compute the median ([https://en.wikipedia.org/wiki/Median](https://en.wikipedia.org/wiki/Median))
    of `PRODUCT.QUANTITY_IN_STOCK`. In Oracle and PostgreSQL, this can be done via
    the built-in `median()` aggregate function, but in MySQL and SQL Server, we have
    to emulate it somehow, and a good approach consists of using `ROW_NUMBER()`, as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE209]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE210]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE211]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE212]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE213]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE214]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE215]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE216]'
  prefs: []
  type: TYPE_PRE
- en: 'That was easy! Next, let''s try to solve a different kind of problem, and let''s
    focus on the `ORDER` table. Each order has a `REQUIRED_DATE` and `STATUS` value
    as `Shipped`, `Cancelled`, and so on. Let''s assume that we want to see the clusters
    (also known as islands) represented by continuous periods of time where the score
    (`STATUS`, in this case) stayed the same. An output sample can be seen here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.11 – Clusters'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16833_Figure_13.11.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 13.11 – Clusters
  prefs: []
  type: TYPE_NORMAL
- en: 'If we have a requirement to solve this problem via `ROW_NUMBER()` and to express
    it in jOOQ, then we may come up with this query:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE217]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE218]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE219]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE220]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE221]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE222]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE223]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE224]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE225]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE226]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE227]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE228]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE229]'
  prefs: []
  type: TYPE_PRE
- en: You can practice these examples in the *RowNumber* bundled code.
  prefs: []
  type: TYPE_NORMAL
- en: Working with RANK()
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`RANK()` is a ranking window function that assigns a rank to each row within
    the partition of a result set. The rank of a row is computed as *1 + the number
    of ranks before it*. The columns having the same values get the same ranks; therefore,
    if multiple rows have the same rank, then the rank of the next row is not consecutive.
    Think of a competition where two athletes share the first place (or the gold medal)
    and there is no second place (so, no silver medal). A simple example is provided
    here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.12 – Simple example of RANK()'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16833_Figure_13.12.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 13.12 – Simple example of RANK()
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is another example that ranks `ORDER` by year and months of `ORDER.ORDER_DATE`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE230]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE231]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE232]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE233]'
  prefs: []
  type: TYPE_PRE
- en: The `year()` and `month()` shortcuts are provided by jOOQ to avoid the usage
    of the SQL `EXTRACT()` function. For instance, `year(ORDER.ORDER_DATE)` can be
    written as `extract(ORDER.ORDER_DATE, DatePart.YEAR)` as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'How about ranking `YEAR` is the partition? This can be expressed in jOOQ like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE234]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE235]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE236]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE237]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE238]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE239]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, let''s see an example that ranks the products. Since a partition can
    be defined via multiple columns, we can easily rank the products by `PRODUCT_VENDOR`
    and `PRODUCT_SCALE`, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE240]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE241]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE242]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE243]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE244]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE245]'
  prefs: []
  type: TYPE_PRE
- en: You can practice these examples and more in *Rank*.
  prefs: []
  type: TYPE_NORMAL
- en: Working with DENSE_RANK()
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`DENSE_RANK()` is a window function that assigns a rank to each row within
    a partition or result set with no gaps in ranking values. A simple example is
    shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.13 – Simple example of DENSE_RANK()'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16833_Figure_13.13.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 13.13 – Simple example of DENSE_RANK()
  prefs: []
  type: TYPE_NORMAL
- en: 'In [*Chapter 12*](B16833_12.xhtml#_idTextAnchor226), *Pagination and Dynamic
    Queries*, you already saw an example of using `DENSE_RANK()` for paginating `JOIN`
    statements. Next, let''s have another case of ranking employees (`EMPLOYEE`) in
    offices (`OFFICE`) by their salary (`EMPLOYEE.SALARY`), as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE246]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE247]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE248]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE249]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE250]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE251]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE252]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE253]'
  prefs: []
  type: TYPE_PRE
- en: 'An output fragment looks like this (notice that the employees having the same
    salary get the same rank):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.14 – Output'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16833_Figure_13.14.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 13.14 – Output
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, let''s use `DENSE_RANK()` for selecting the highest salary from each
    office, including duplicates. This time, let''s use the `QUALIFY` clause as well.
    The code is illustrated in the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE254]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE255]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE256]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE257]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE258]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE259]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE260]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE261]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE262]'
  prefs: []
  type: TYPE_PRE
- en: 'Before going further, here is a nice read: [https://blog.jooq.org/2014/08/12/the-difference-between-row_number-rank-and-dense_rank/](https://blog.jooq.org/2014/08/12/the-difference-between-row_number-rank-and-dense_rank/).
    You can check out these examples in the *DenseRank* bundled code.'
  prefs: []
  type: TYPE_NORMAL
- en: Working with PERCENT_RANK()
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `PERCENT_RANK()` window function calculates the percentile rankings `((rank
    - 1) / (total_rows - 1))` of rows in a result set and returns a value between
    0 exclusive and 1 inclusive. The first row in the result set always has the percent
    rank equal to 0\. This function doesn't count `NULL` values and is nondeterministic.
    Usually, the final result is multiplied by 100 to express as a percentage.
  prefs: []
  type: TYPE_NORMAL
- en: 'The best way to understand this function is via an example. Let''s assume that
    we want to compute the percentile rank for employees in each office by their salaries.
    The query expressed in jOOQ will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE263]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE264]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE265]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE266]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE267]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE268]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE269]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE270]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE271]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE272]'
  prefs: []
  type: TYPE_PRE
- en: 'The following screenshot represents a snippet of the result:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.15 – Percent rank output'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16833_Figure_13.15.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 13.15 – Percent rank output
  prefs: []
  type: TYPE_NORMAL
- en: So, how do we interpret this output? A percentile rank is commonly defined as
    the proportion of results (or scores) in a distribution that a certain result
    (or score) is greater than or equal to (sometimes only greater than counts). For
    example, if you get a result/score of 90 on a certain test and this result/score
    was greater than (or equal to) the results/scores of 75% of the participants taking
    the test, then your percentile rank is 75\. You would be in the 75th percentile.
  prefs: []
  type: TYPE_NORMAL
- en: In other words, in office 1, we can say that 40% of employees have salaries
    lower than *Anthony Bow* (check the third row), so *Anthony Bow* is in the 40th
    percentile. Also, in office 1, *Diane Murphy* has the highest salary since 100%
    of employees have salaries lower than her salary (check the sixth row). When the
    current row is the first in the partition then there is no previous data to consider,
    therefore the percentile rank is 0\. An interesting case is *George Vanauf* (last
    row) having a percentile rank of 0%. Because his salary (*$55,000*) is equal to
    the salary of *Foon Yue Tseng*, we can say that nobody has a salary lower than
    his.
  prefs: []
  type: TYPE_NORMAL
- en: 'A common use case for `PERCENT_RANK()` is to categorize data into custom groups
    (also known as custom binning). For example, let''s consider that we want to count
    departments having a low (smaller than the 20th percentile), medium (between the
    20th and 80th percentile), and high (greater than 80th percentile) profit. Here''s
    the code we''d use to calculate this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE273]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE274]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE275]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE276]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE277]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE278]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE279]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE280]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE281]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE282]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE283]'
  prefs: []
  type: TYPE_PRE
- en: You can practice these examples—and more—in the *PercentRank* bundled code.
  prefs: []
  type: TYPE_NORMAL
- en: Working with CUME_DIST()
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`CUME_DIST()` is a window function that computes the cumulative distribution
    of a value within a set of values. In other words, `CUME_DIST()` divides the number
    of rows having values less than or equal to the current row''s value by the total
    number of rows. The returned value is greater than zero and less than or equal
    to one (0 < `CUME_DIST()` <= 1). The columns having repeated values get the same
    `CUME_DIST()` value. A simple example is provided here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.16 – Simple example of CUME_DIST()'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16833_Figure_13.16.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 13.16 – Simple example of CUME_DIST()
  prefs: []
  type: TYPE_NORMAL
- en: 'So, we have a result set of 23 rows. For the first row (denoted as A), `CUME_DIST()`
    finds the number of rows having a value less than or equal to *50000*. The result
    is 4\. Then, the function divides 4 by the total number of rows, which is 23:
    4/23\. The result is 0.17 or 17%. The same logic is applied to the next rows.'
  prefs: []
  type: TYPE_NORMAL
- en: 'How about fetching the top 25% of sales in *2003* and *2004*? This can be solved
    via `CUME_DIST()` and the handy `QUALIFY` clause, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE284]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE285]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE286]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE287]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE288]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE289]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE290]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE291]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE292]'
  prefs: []
  type: TYPE_PRE
- en: You can practice these examples in the *CumeDist* bundled code.
  prefs: []
  type: TYPE_NORMAL
- en: Working with LEAD()/LAG()
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`LEAD()` is a window function that looks forward a specified number of rows
    (offset, by default 1) and accesses that row from the current row. `LAG()` works
    the same as `LEAD()`, but it looks back. For both, we can optionally specify a
    default value to be returned when there is no subsequent row (`LEAD()`) or there
    is no preceding row `(LAG()`) instead of returning `NULL`. A simple example is
    provided here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.17 – Simple example of LEAD() and LAG()'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16833_Figure_13.17.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 13.17 – Simple example of LEAD() and LAG()
  prefs: []
  type: TYPE_NORMAL
- en: Besides the `lead`/`lag``(Field<T> field)` syntax used in this example, jOOQ
    also exposes `lead`/`lag(Field<T> field, int offset)`, `lead``/lag(Field<T> field,
    int offset, Field<T> defaultValue)`, and `lead/lag``(Field<T> field, int offset,
    T defaultValue)`. In this example, `lead`/`lag(ORDER.ORDER_DATE)` uses an offset
    of 1, so is the same thing as `lead`/`lag(ORDER.ORDER_DATE, 1)`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example that, for each employee, displays the salary and next salary
    using the office as a partition of `LEAD()`. When `LEAD()` reaches the end of
    the partition, we use 0 instead of `NULL`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE293]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE294]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE295]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE296]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE297]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE298]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE299]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE300]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE301]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, let''s tackle an example of calculating the Month-Over-Month (MOM) growth
    rate. This financial indicator is useful for benchmarking the business, and we
    already have it in the `SALE.REVENUE_GROWTH` column. But here is the query that
    can calculate it via the `LAG()` function for the year *2004*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE302]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE303]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE304]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE305]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE306]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE307]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE308]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE309]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE310]'
  prefs: []
  type: TYPE_PRE
- en: For more examples, including an example of funneling drop-off metrics and one
    about time-series analysis, please check out the *LeadLag* bundled code.
  prefs: []
  type: TYPE_NORMAL
- en: Working with NTILE()
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`NTILE(n)` is a window function commonly used for distributing the number of
    rows in the specified `n` number of groups or buckets. Each bucket has a number
    (starting at 1) that indicates the bucket to which this row belongs. A simple
    example is provided here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.18 – Simple example of NTILE()'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16833_Figure_13.18.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 13.18 – Simple example of NTILE()
  prefs: []
  type: TYPE_NORMAL
- en: So, in this example, we've distributed `EMPLOYEE.SALARY` in 10 buckets. `NTILE()`
    strives to determine how many rows should be in each bucket in order to provide
    the number of buckets and to keep them approximately equal.
  prefs: []
  type: TYPE_NORMAL
- en: Among its use cases, `NTILE()` is useful for calculating Recency, Frequency,
    and Monetary (RFM) indices ([https://en.wikipedia.org/wiki/RFM_(market_research)](https://en.wikipedia.org/wiki/RFM_(market_research))).
    In short, the RFM analysis is basically an indexing technique that relies on past
    purchase behavior to determine different segments of customers.
  prefs: []
  type: TYPE_NORMAL
- en: In our case, the past purchase behavior of each customer (`ORDER.CUSTOMER_NUMBER`)
    is stored in the `ORDER` table, especially in `ORDER.ORDER_ID`, `ORDER.ORDER_DATE`,
    and `ORDER.AMOUNT`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Based on this information, we attempt to divide customers into four equal groups
    based on the distribution of values for R, F, and M. Four equal groups across
    RFM variables produce 43=64 potential segments. The result consists of a table
    having a score between 1 and 4 for each of the quantiles (R, F, and M). The query
    speaks for itself, as we can see here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE311]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE312]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE313]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE314]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE315]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE316]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE317]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE318]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE319]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE320]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE321]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE322]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE323]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE324]'
  prefs: []
  type: TYPE_PRE
- en: 'A sample output is provided here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.19 – RFM sample'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16833_Figure_13.19.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 13.19 – RFM sample
  prefs: []
  type: TYPE_NORMAL
- en: By combining the RFM result as R*100+F*10+M, we can obtain an aggregate score.
    This is available next to more examples in the *Ntile* bundled code.
  prefs: []
  type: TYPE_NORMAL
- en: Working with FIRST_VALUE() and LAST_VALUE()
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`FIRST_VALUE(expr)` returns the value of the specified expression (`expr`)
    with respect to the first row in the window frame.'
  prefs: []
  type: TYPE_NORMAL
- en: '`NTH_VALUE(expr, offset)` returns the value of the specified expression (`expr`)
    with respect to the offset row in the window frame.'
  prefs: []
  type: TYPE_NORMAL
- en: '`LAST_VALUE(expr)` returns the value of the specified expression (`expr`) with
    respect to the last row in the window frame.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s assume that our goal is to obtain the cheapest and most expensive product
    per product line, as in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.20 – Cheapest and most expensive product per product line'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16833_Figure_13.20.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 13.20 – Cheapest and most expensive product per product line
  prefs: []
  type: TYPE_NORMAL
- en: 'Accomplishing this task via `FIRST_VALUE()` and `LAST_VALUE()` can be done
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE325]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE326]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE327]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE328]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE329]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE330]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE331]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE332]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE333]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE334]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE335]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE336]'
  prefs: []
  type: TYPE_PRE
- en: If the window frame is not specified, then the default window frame depends
    on the presence of `ORDER BY`. If `ORDER BY` is present, then the window frame
    is `RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW`. If `ORDER BY` is not present,
    then the window frame is `RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING`.
  prefs: []
  type: TYPE_NORMAL
- en: Having this in mind, in our case, `FIRST_VALUE()` can rely on the default window
    frame to return the first row of the partition, which is the smallest price. On
    the other hand, `LAST_VALUE()` must explicitly define the window frame as `RANGE
    BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING` to return the highest price.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is another example of fetching the second most expensive product by product
    line via `NTH_VALUE()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE337]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE338]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE339]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE340]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE341]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE342]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE343]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE344]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE345]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding query orders `BUY_PRICE` in descending order for fetching the
    second most expensive product by product line. But this is mainly the second row
    from the bottom, therefore we can rely on the `FROM LAST` clause (in jOOQ, `fromLast()`)
    to express it, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE346]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE347]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE348]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE349]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE350]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE351]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE352]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE353]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE354]'
  prefs: []
  type: TYPE_PRE
- en: This query works fine in Oracle, which supports `FROM FIRST` (`fromFirst()`),
    `FROM LAST` (`fromLast()`), `IGNORE NULLS` (`ignoreNulls()`), and `RESPECT NULLS`
    (`respectNulls()`).
  prefs: []
  type: TYPE_NORMAL
- en: You can practice these examples in the *FirstLastNth* bundled code.
  prefs: []
  type: TYPE_NORMAL
- en: Working with RATIO_TO_REPORT()
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`RATIO_TO_REPORT(expr)` computes the ratio of the specified value to the sum
    of values in the set. If the given `expr` value is evaluated as `null`, then this
    function returns `null`. A simple example is provided here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.21 – Simple example of RATIO_TO_REPORT()'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16833_Figure_13.21.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 13.21 – Simple example of RATIO_TO_REPORT()
  prefs: []
  type: TYPE_NORMAL
- en: 'For instance, for the first row, the ratio is computed as 51241.54 / 369418.38,
    where 369418.38 is the sum of all sales. After applying the `round()` function,
    the result is 0.14 or 14%, but if we want to compute the ratio of the current
    sale per fiscal year, we can do it via `PARTITION BY`, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE355]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE356]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE357]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE358]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE359]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s compute the ratio of the current sum of salaries per employee and express
    it in percentages, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE360]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE361]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE362]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE363]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE364]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE365]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE366]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE367]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE368]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE369]'
  prefs: []
  type: TYPE_PRE
- en: You can check out these examples in the *RatioToReport* bundled code.
  prefs: []
  type: TYPE_NORMAL
- en: Aggregates as window functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Aggregate functions can be used as window functions as well. For instance,
    let''s use the `SUM()` aggregate function as a window function for computing the
    sum of the successfully transferred amount per customer until each caching date,
    as illustrated in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.22 – Sum of the transferred amount until each caching date'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16833_Figure_13.22.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 13.22 – Sum of the transferred amount until each caching date
  prefs: []
  type: TYPE_NORMAL
- en: 'The jOOQ query can be expressed like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE370]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE371]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE372]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE373]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE374]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE375]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE376]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE377]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE378]'
  prefs: []
  type: TYPE_PRE
- en: 'Or, let''s use the `AVG()` aggregate function as a window function for computing
    the average of prices for the preceding three ordered products on each order,
    as illustrated in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.23 – Average of prices for the preceding three ordered products
    on each order'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16833_Figure_13.23.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 13.23 – Average of prices for the preceding three ordered products on
    each order
  prefs: []
  type: TYPE_NORMAL
- en: 'The query looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE379]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE380]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE381]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE382]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE383]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE384]'
  prefs: []
  type: TYPE_PRE
- en: 'How about calculating a running average flavor—in other words, create a report
    that shows every transaction in *March 2005* for *Visa Electron* cards? Additionally,
    this report shows the daily average transaction amount relying on a 3-day moving
    average. The code to accomplish this is shown in the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE385]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE386]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE387]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE388]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE389]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE390]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE391]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE392]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE393]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE394]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE395]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE396]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE397]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE398]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE399]'
  prefs: []
  type: TYPE_PRE
- en: 'As Lukas Eder mentioned: "*What''s most mind-blowing about aggregate window
    functions is that even user-defined aggregate functions can be used as window
    functions!*"'
  prefs: []
  type: TYPE_NORMAL
- en: You can check out more examples (for instance, in the *PostgreSQL* bundled code,
    you can find queries for *How many other employees have the same salary as me?*
    and *How many sales are better by 5,000 or less?*) in the *AggregateWindowFunctions*
    bundled code.
  prefs: []
  type: TYPE_NORMAL
- en: Aggregate functions and ORDER BY
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Certain aggregate functions output significantly different results depending
    on their input order. By default, this ordering is not specified, but it can be
    controlled via an optional `ORDER BY` clause as an argument. So, in the presence
    of `ORDER BY` on these aggregate function calls, we can fetch ordered aggregated
    results. Let's see how we can use such functions in jOOQ and start with a category
    of functions having their names suffixed with `AGG`, such as `ARRAY_AGG()`, `JSON_ARRAYAGG()`,
    `XML_AGG()`, `MULTISET_AGG()` (covered in [*Chapter 8*](B16833_08.xhtml#_idTextAnchor128),
    *Fetching and Mapping*), and so on.
  prefs: []
  type: TYPE_NORMAL
- en: FOO_AGG()
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For instance, `ARRAY_AGG()` is a function that aggregates data into an array
    and, in the presence of `ORDER BY`, it aggregates data into an array conforming
    to the specified order. Here is an example of using `ARRAY_AGG()` to aggregate
    `EMPLOYEE.FIRST_NAME` in descending order by `EMPLOYEE.FIRST_NAME` and `LAST_NAME`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE400]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE401]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE402]'
  prefs: []
  type: TYPE_PRE
- en: 'For PostgreSQL, jOOQ renders this SQL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE403]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE404]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE405]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE406]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE407]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE408]'
  prefs: []
  type: TYPE_PRE
- en: The result is an array as [*Yoshimi*, *William*, *Tom*, *Steve*, *Peter*,…],
    wrapped as `Result<Record1<String[]>>` (extract `String[]` via `get(0).value1()`).
    Do not confuse `ARRAY_AGG()` with jOOQ's `fetchArray()`. In the case of `ARRAY_AGG()`,
    the array is built by the database, while in the case of `fetchArray()`, the array
    is built by jOOQ after fetching the result set.
  prefs: []
  type: TYPE_NORMAL
- en: Another two aggregation functions that accept `ORDER BY` are `JSON_ARRAYAGG()`
    and `XML_AGG()`. You should be familiar with these functions from [*Chapter 8*](B16833_08.xhtml#_idTextAnchor128),
    *Fetching and Mapping*, but you can also see several simple examples in the code
    bundled with this section.
  prefs: []
  type: TYPE_NORMAL
- en: COLLECT()
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'An interesting method that accepts `ORDER BY` is Oracle''s `COLLECT()` method.
    While `ARRAY_AGG()` represents the standard SQL function for aggregating data
    into an array, the `COLLECT()` function is specific to Oracle and produces a structurally
    typed array. Let''s assume the following Oracle user-defined type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE409]'
  prefs: []
  type: TYPE_PRE
- en: 'The jOOQ Code Generator will produce for this user-defined type the `SalaryArrRecord`
    class in `jooq.generated.udt.records`. Via this UDT record, we can collect in
    descending order by salary and ascending order by job title the employees'' salaries,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE410]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE411]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE412]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE413]'
  prefs: []
  type: TYPE_PRE
- en: 'jOOQ fetches `Result<Record1<SalaryArrRecord>>` via the following SQL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE414]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE415]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE416]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE417]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE418]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE419]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE420]'
  prefs: []
  type: TYPE_PRE
- en: 'By calling `get(0).value1().toArray(Integer[]::new)`, you can access the array
    of salaries. Or, by calling `get(0).value1().get(5)`, you can access the fifth
    salary. Relying on `fetchOneInto()`/`fetchSingleInto()` is also an option, as
    illustrated here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE421]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE422]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE423]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE424]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE425]'
  prefs: []
  type: TYPE_PRE
- en: Now, you can access the array of salaries as `result.toArray(Integer[]::new)`,
    and via `result.get(5)`, you can access the fifth salary.
  prefs: []
  type: TYPE_NORMAL
- en: GROUP_CONCAT()
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Another cool aggregate function that accepts an `ORDER BY` clause is the `GROUP_CONCAT()`
    function (very popular in MySQL), useful to get the aggregated concatenation for
    a field. jOOQ emulates this function in Oracle, PostgreSQL, SQL Server, and other
    dialects that don't support it natively.
  prefs: []
  type: TYPE_NORMAL
- en: 'For instance, let''s use `GROUP_CONCAT()` to fetch a string containing employees''
    names in descending order by salary, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE426]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE427]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE428]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE429]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE430]'
  prefs: []
  type: TYPE_PRE
- en: 'The output will be something like this: *Diane Murphy*; *Mary Patterson*; *Jeff
    Firrelli*; ….'
  prefs: []
  type: TYPE_NORMAL
- en: Oracle's KEEP() clause
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here''s a quick one—have you seen in a query an aggregate function like this:
    `SUM(some_value) KEEP (DENSE_RANK FIRST ORDER BY some_date)`? Or this analytic
    variant: `SUM(some_value) KEEP (DENSE_RANK LAST ORDER BY some_date) OVER (PARTITION
    BY some_partition)`?'
  prefs: []
  type: TYPE_NORMAL
- en: If you did, then you know that what you saw is Oracle's `KEEP()` clause at work,
    or—in other words—the SQL `FIRST()` and `LAST()` functions prefixed by the `KEEP()`
    clause for semantic clarity, and `DENSE_RANK()` for indicating that Oracle should
    aggregate only on Olympic rank (those rows with the maximum (`LAST()`) or minimum
    (`FIRST()`) dense rank with respect to a given sorting), respectively suffixed
    by `ORDER BY()` and, optionally, by `OVER(PARTITION BY())`. Both `LAST()` and
    `FIRST()` can be treated as aggregates (if you omit the `OVER()` clause) or as
    analytic functions.
  prefs: []
  type: TYPE_NORMAL
- en: 'But let''s have a scenario based on `CUSTOMER` and `ORDER` tables. Each customer
    (`CUSTOMER.CUSTOMER_NUMBER`) has one or more order, and let''s assume that we
    want to fetch the `ORDER.ORDER_DATE` value closest to 2004-June-06 (or any other
    date, including the current date) for each `CUSTOMER` type. This can be easily
    accomplished in a query, as here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE431]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE432]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE433]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE434]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE435]'
  prefs: []
  type: TYPE_PRE
- en: 'How about selecting `ORDER.SHIPPED_DATE` and `ORDER.STATUS` as well? One approach
    could be to rely on the `ROW_NUMBER()` window function and the `QUALIFY()` clause,
    as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE436]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE437]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE438]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE439]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE440]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE441]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE442]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE443]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see in the bundled code, another approach could be to rely on `SELECT
    DISTINCT ON` (as *@dmitrygusev* suggested on Twitter) or on an anti-join, but
    if we write our query for Oracle, then most probably you''ll go for the `KEEP()`
    clause, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE444]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE445]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE446]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE447]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE448]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE449]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE450]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE451]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE452]'
  prefs: []
  type: TYPE_PRE
- en: 'Or, you could do this by exploiting the Oracle''s `ROWID` pseudo-column, as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE453]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE454]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE455]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE456]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE457]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE458]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE459]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE460]'
  prefs: []
  type: TYPE_PRE
- en: You can practice these examples in the *AggregateFunctionsOrderBy* bundled code.
  prefs: []
  type: TYPE_NORMAL
- en: Ordered set aggregate functions (WITHIN GROUP)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*Ordered set aggregate functions* allow operations on a set of rows sorted
    with `ORDER BY` via the `WITHIN GROUP` clause. Commonly, such functions are used
    for performing computations that depend on a certain row ordering. Here, we can
    quickly mention *hypothetical set* functions such as `RANK()`, `DENSE_RANK()`,
    `PERCENT_RANK()`, or `CUME_DIST()`, and *inverse distribution functions* such
    as `PERCENTILE_CONT()`, `PERCENTILE_DISC()`, or `MODE()`. A particular case is
    represented by `LISTAGG()`, which is covered at the end of this section.'
  prefs: []
  type: TYPE_NORMAL
- en: Hypothetical set functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A hypothetical set function calculates something for a hypothetical value (let's
    denote it as `hv`). In this context, `DENSE_RANK()` computes the rank of `hv`
    without gaps, while `RANK()` does the same thing but with gaps. `CUME_DIST()`
    computes the cumulative distribution of `hv` (the relative rank of a row from
    1/n to 1), while `PERCENT_RANK()` computes the percent rank of `hv` (the relative
    rank of a row from 0 to 1).
  prefs: []
  type: TYPE_NORMAL
- en: 'For instance, let''s assume that we want to compute the rank without gaps for
    the hypothetical value (*2004*, *10000*), where *2004* is `SALE.FISCAL_YEAR` and
    *10000* is `SALE.SALE_`. Next, for the existing data, we want to obtain all ranks
    without gaps less than the rank of this hypothetical value. For the first part
    of the problem, we rely on the `DENSE_RANK()` hypothetical set function, while
    for the second part, on the `DENSE_RANK()` window function, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE461]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE462]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE463]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE464]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE465]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE466]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE467]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s consider another example that uses the `PERCENT_RANK()` hypothetical
    set function. This time, let''s assume that we plan to have a salary of *$61,000*
    for new sales reps, but before doing that, we want to know the percentage of current
    sales reps having salaries higher than *$61,000*. This can be done like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE468]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE469]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE470]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE471]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE472]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE473]'
  prefs: []
  type: TYPE_PRE
- en: 'Moreover, we want to know the percentage of sales reps'' salaries that are
    higher than *$61,000*. For this, we need the distinct salaries, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE474]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE475]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE476]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE477]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE478]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE479]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE480]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE481]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE482]'
  prefs: []
  type: TYPE_PRE
- en: You can practice these examples next to other `RANK()` and `CUME_DIST()` hypothetical
    set functions in the *OrderedSetAggregateFunctions* bundled code.
  prefs: []
  type: TYPE_NORMAL
- en: Inverse distribution functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Briefly, the inverse distribution functions compute *percentiles*. There are
    two distribution models: a discrete model (computed via `PERCENTILE_DISC()`) and
    a continuous model (computed via `PERCENTILE_CONT()`).'
  prefs: []
  type: TYPE_NORMAL
- en: PERCENTILE_DISC() and PERCENTILE_CONT()
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: But what does it actually mean to compute *percentiles*? Loosely speaking, consider
    a certain percent, `P` (this percent is a float value between 0 inclusive and
    1 inclusive), and an ordering field, `F`. In this context, the percentile computation
    represents the value below which `P` percent of the `F` values fall.
  prefs: []
  type: TYPE_NORMAL
- en: 'For instance, let''s consider the `SALES` table, and we want to find the 25th
    percentile sale. In this case, `P` = 0.25, and the ordering field is `SALE.SALE_`.
    Applying `PERCENTILE_DISC()` and `PERCENTILE_CONT()` results in this query:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE483]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE484]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE485]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE486]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE487]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE488]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE489]'
  prefs: []
  type: TYPE_PRE
- en: In the bundled code, you can see this query extended for the 50th, 75th, and
    100th percentile. The resulting value (for instance, 2974.43) represents the sale
    below which 25% of the sales fall. In this case, `PERCENTILE_DISC()` and `PERCENTILE_CONT()`
    return the same value (2974.43), but this is not always the case. Remember that
    `PERCENTILE_DISC()` works on a discrete model, while `PERCENTILE_CONT()` works
    on a continuous model. In other words, if there is no value (sale) in the sales
    (also referred to as population) that fall exactly in the specified percentile,
    `PERCENTILE_CONT()` must interpolate it assuming continuous distribution. Basically,
    `PERCENTILE_CONT()` interpolates the value (sale) from the two values (sales)
    that are immediately after and before the needed one. For instance, if we repeat
    the previous example for the 11th percentile, then `PERCENTILE_DISC()` returns
    1676.14, which is an existent sale, while `PERCENTILE_CONT()` returns 1843.88,
    which is an interpolated value that doesn't exist in the database.
  prefs: []
  type: TYPE_NORMAL
- en: 'While Oracle supports `PERCENTILE_DISC()` and `PERCENTILE_CONT()` as ordered
    set aggregate functions and window function variants, PostgreSQL supports them
    only as ordered set aggregate functions, SQL Server supports only the window function
    variants, and MySQL doesn''t support them at all. Emulating them is not quite
    simple, but this great article by Lukas Eder is a must-read in this direction:
    [https://blog.jooq.org/2019/01/28/how-to-emulate-percentile_disc-in-mysql-and-other-rdbms/](https://blog.jooq.org/2019/01/28/how-to-emulate-percentile_disc-in-mysql-and-other-rdbms/).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s see an example of using `PERCENTILE_DISC()` as the window function
    variant and `PERCENTILE_CONT()` as the ordered set aggregate function. This time,
    the focus is on `EMPLOYEE.SALARY`. First, we want to compute the 50th percentile
    of salaries per office via `PERCENTILE_DISC()`. Second, we want to keep only those
    50th percentiles less than the general 50th percentile calculated via `PERCENTILE_CONT()`.
    The code is illustrated in the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE490]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE491]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE492]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE493]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE494]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE495]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE496]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE497]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE498]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE499]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE500]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE501]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE502]'
  prefs: []
  type: TYPE_PRE
- en: You can practice these examples in the *OrderedSetAggregateFunctions* bundled
    code.
  prefs: []
  type: TYPE_NORMAL
- en: The MODE() function
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Mainly, the `MODE()` function works on a set of values to produce a result
    (referred to as the *mode*) representing the value that appears with the greatest
    frequency. The `MODE()` function comes in two flavors, as outlined here:'
  prefs: []
  type: TYPE_NORMAL
- en: '`MODE(field)` aggregate function'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`MODE WITHIN GROUP (ORDER BY [order clause])` ordered set aggregate function'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If multiple results (modes) are available, then `MODE()` returns only one value.
    If there is a given ordering, then the first value will be chosen.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `MODE()` aggregate function is emulated by jOOQ in PostgreSQL and Oracle
    and is not supported in MySQL and SQL Server. For instance, let''s assume that
    we want to find out in which month of the year we have the most sales, and for
    this, we may come up with the following query (notice that an explicit `ORDER
    BY` clause for `MODE()` is not allowed):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE503]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE504]'
  prefs: []
  type: TYPE_PRE
- en: 'Running this query in PostgreSQL reveals that jOOQ emulates the `MODE()` aggregate
    function via the ordered set aggregate function, which is supported by PostgreSQL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE505]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE506]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE507]'
  prefs: []
  type: TYPE_PRE
- en: 'In this case, if multiple modes are available, then the first one is returned
    with respect to the ascending ordering. On the other hand, for the Oracle case,
    jOOQ uses the `STATS_MODE()` function, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE508]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE509]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE510]'
  prefs: []
  type: TYPE_PRE
- en: 'In the following case, there is no ordering in the generated SQL, and if multiple
    modes are available, then only one is returned. On the other hand, the `MODE()`
    ordered set aggregate function is supported only by PostgreSQL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE511]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE512]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE513]'
  prefs: []
  type: TYPE_PRE
- en: If multiple results (modes) are available, then `MODE()` returns only one value
    representing the highest value (in this particular case, the month closest to
    December inclusive) since we have used a descending order.
  prefs: []
  type: TYPE_NORMAL
- en: 'Nevertheless, how to return all modes (if more are available)? Commonly, statisticians
    refer to a bimodal distribution if two modes are available, to a trimodal distribution
    if three modes are available, and so on. Emulating `MODE()` to return all modes
    can be done in several ways. Here is one way (in the bundled code, you can see
    one more):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE514]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE515]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE516]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE517]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE518]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE519]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE520]'
  prefs: []
  type: TYPE_PRE
- en: 'But having 1,000 cases where the value of `X` is `''foo''` and 999 cases where
    the value is `''buzz''`, `MODE()` is `''foo''`. By adding two more instances of
    `''buzz''`, `MODE()` switches to `''buzz''`. Maybe a good idea would be to allow
    for some variation in the values via a percent. In other words, the emulation
    of `MODE()` using a percentage of the total number of occurrences can be done
    like so (here, 75%):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE521]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE522]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE523]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE524]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE525]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE526]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE527]'
  prefs: []
  type: TYPE_PRE
- en: You can practice these examples in the *OrderedSetAggregateFunctions* bundled
    code.
  prefs: []
  type: TYPE_NORMAL
- en: LISTAGG()
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The last ordered set aggregate function discussed in this section is `LISTAGG()`.
    This function is used for aggregating a given list of values into a string delimited
    via a separator (for instance, it is useful for producing CSV files). The SQL
    standard imposes the presence of the separator and `WITHIN GROUP` clause. Nevertheless,
    some databases treat these standards as being optional and apply certain defaults
    or expose an undefined behavior if the `WITHIN GROUP` clause is omitted. jOOQ
    provides `listAgg(Field<?> field)` having no explicit separator, and `listAgg(Field<?>
    field, String separator)`. The `WITHIN GROUP` clause cannot be omitted. jOOQ emulates
    this function for dialects that don't support it, such as MySQL (emulates it via
    `GROUP_CONCAT()`, so a comma is a default separator), PostgreSQL (emulates it
    via `STRING_AGG()`, so no default separator), and SQL Server (same as in PostgreSQL)
    via proprietary syntax that offers similar functionality. Oracle supports `LISTAGG()`
    and there is no default separator.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are two simple examples with and without an explicit separator that produces
    a list of employees names'' in ascending order by salary as `Result<Record1<String>>`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE528]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE529]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE530]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE531]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE532]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE533]'
  prefs: []
  type: TYPE_PRE
- en: Fetching directly, the `String` can be achieved via `fetchOneInto(String.class)`.
  prefs: []
  type: TYPE_NORMAL
- en: '`LISTAGG()` can be used in combination with `GROUP BY` and `ORDER BY`, as in
    the following example that fetches a list of employees per job title:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE534]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE535]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE536]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE537]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE538]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE539]'
  prefs: []
  type: TYPE_PRE
- en: 'Moreover, `LISTAGG()` supports a window function variant as well, as shown
    here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE540]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE541]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE542]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE543]'
  prefs: []
  type: TYPE_PRE
- en: 'And here is a fun fact from Lukas Eder: "`LISTAGG()` *is not a true ordered
    set aggregate function. It should use the same* `ORDER BY` *syntax as* `ARRAY_AGG`."
    See the discussion here: [https://twitter.com/lukaseder/status/1237662156553883648](https://twitter.com/lukaseder/status/1237662156553883648).'
  prefs: []
  type: TYPE_NORMAL
- en: You can practice these examples and more in *OrderedSetAggregateFunctions*.
  prefs: []
  type: TYPE_NORMAL
- en: Grouping, filtering, distinctness, and functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, *grouping* refers to the usage of `GROUP BY` with functions,
    *filtering* refers to the usage of the `FILTER` clause with functions, and *distinctness*
    refers to aggregate functions on distinct values.
  prefs: []
  type: TYPE_NORMAL
- en: Grouping
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As you already know, `GROUP BY` is a SQL clause useful for arranging rows in
    groups via one (or more) column given as an argument. Rows that land in a group
    have matching values in the given columns/expressions. Typical use cases apply
    aggregate functions on groups of data produced by `GROUP BY`.
  prefs: []
  type: TYPE_NORMAL
- en: Important Note
  prefs: []
  type: TYPE_NORMAL
- en: Especially when dealing with multiple dialects, it is correct to list all non-aggregated
    columns from the `SELECT` clause in the `GROUP BY` clause. This way, you avoid
    potentially indeterminate/random behavior and errors across dialects (some of
    them will not ask you to do this (for example, MySQL), while others will (for
    example, Oracle)).
  prefs: []
  type: TYPE_NORMAL
- en: 'jOOQ supports `GROUP BY` in all dialects, therefore here is an example of fetching
    offices (`OFFICE`) having fewer than three employees:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE544]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE545]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE546]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE547]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE548]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE549]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE550]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is another example that computes the sum of sales per employee per year,
    and after that, it computes the average of these sums per employee:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE551]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE552]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE553]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE554]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE555]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE556]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE557]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE558]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE559]'
  prefs: []
  type: TYPE_PRE
- en: You can find more examples of using `GROUP BY` in *GroupByDistinctFilter*.
  prefs: []
  type: TYPE_NORMAL
- en: Filtering
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If we want to refine a query by applying aggregations against a limited set
    of the values in a column, then we can use `CASE` expressions, as in this example,
    which sum the salaries of sales reps and the rest of the employees:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE560]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE561]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE562]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE563]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE564]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE565]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, `CASE` is flexible but it''s a bit tedious. A more straightforward
    solution is represented by the `FILTER` clause, exposed by jOOQ via the `filterWhere()`
    method, and emulated for every dialect that doesn''t support it (usually via `CASE`
    expressions). The previous query can be expressed via `FILTER`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE566]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE567]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE568]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE569]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE570]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE571]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE572]'
  prefs: []
  type: TYPE_PRE
- en: 'Or, here is an example of removing `NULL` values for `ARRAY_AGG()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE573]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE574]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE575]'
  prefs: []
  type: TYPE_PRE
- en: 'Another use case for `FILTER` is related to pivoting rows to columns. For instance,
    check out this query, which produces the sales per month and per year:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE576]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE577]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE578]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE579]'
  prefs: []
  type: TYPE_PRE
- en: 'The query returns the correct result but in an unexpected form. Its vertical
    form having one value per row is not quite readable for users. Most probably,
    a user will be more familiar with a form having one row per year and a dedicated
    column per month. So, turning the rows of a year into columns should solve the
    problem, and this can be accomplished in several ways, including the `FILTER`
    clause, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE580]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE581]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE582]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE583]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE584]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE585]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE586]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE587]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE588]'
  prefs: []
  type: TYPE_PRE
- en: 'The `FILTER` clause can be considered with aggregate functions used as window
    functions as well. In such cases, `filterWhere()` comes between the aggregate
    function and the `OVER()` clause. For instance, the following query sums the salaries
    of employees per office only for employees that don''t get a commission:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE589]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE590]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE591]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE592]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE593]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE594]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE595]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE596]'
  prefs: []
  type: TYPE_PRE
- en: 'Moreover, the `FILTER` clause can be used with ordered set aggregate functions.
    This way, we can remove rows that don''t pass the filter before the aggregation
    takes place. Here is an example of filtering employees having salaries higher
    than *$80,000* and collecting the result via `LISTAGG()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE597]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE598]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE599]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE600]'
  prefs: []
  type: TYPE_PRE
- en: 'Since you are here, I am sure that you''ll love this article by Lukas Eder
    about calculating multiple aggregate functions in a single query: [https://blog.jooq.org/2017/04/20/how-to-calculate-multiple-aggregate-functions-in-a-single-query/](https://blog.jooq.org/2017/04/20/how-to-calculate-multiple-aggregate-functions-in-a-single-query/).'
  prefs: []
  type: TYPE_NORMAL
- en: You can practice the examples and more in the *GroupByDistinctFilter* bundled
    code.
  prefs: []
  type: TYPE_NORMAL
- en: Distinctness
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Most aggregate functions come with a variant for applying them to a distinct
    set of values. While you can find all of them in the jOOQ documentation, let's
    quickly list here `countDistinct()`, `sumDistinct()`, `avgDistinct()`, `productDistinct()`,
    `groupConcatDistinct``()`, `arrayAggDistinct()`, and `collectDistinct()`. For
    completeness' sake, we also have `minDistinct()` and `maxDistinct()`. When a function
    is not supported by jOOQ, we can still call it via the general `aggregateDistinct()`
    function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example of using `countDistinct()` for fetching employees having
    sales in at least 3 distinct years:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE601]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE602]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE603]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE604]'
  prefs: []
  type: TYPE_PRE
- en: More examples are available in the *GroupByDistinctFilter* bundled code.
  prefs: []
  type: TYPE_NORMAL
- en: Grouping sets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For those not familiar with *grouping sets*, let''s briefly follow a scenario
    meant to quickly introduce and cover this notion. Consider the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.24 – Two queries using a grouping set each'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16833_Figure_13.24.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 13.24 – Two queries using a grouping set each
  prefs: []
  type: TYPE_NORMAL
- en: The `groupBy(SALE.EMPLOYEE_NUMBER)` construction from the left-hand side (respectively,
    `groupBy(SALE.FISCAL_YEAR)` from the right-hand side) is referred to as a *grouping
    set*. A grouping set can contain none (empty grouping set), one, or more columns.
    In our case, both grouping sets contain one column.
  prefs: []
  type: TYPE_NORMAL
- en: 'Getting a unified result set of these two result sets containing the aggregated
    data of both grouping sets can be done via the `UNION ALL` operator, as illustrated
    here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.25 – Union grouping sets'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16833_Figure_13.25.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 13.25 – Union grouping sets
  prefs: []
  type: TYPE_NORMAL
- en: 'But, as you can see, even for only two grouping sets, this query is quite lengthy.
    Moreover, it needs to resolve two `SELECT` statements before combining their results
    into a single result set. Here is where the `GROUPING SETS(column_list)` clause
    of `GROUP BY` enters the scene. This clause represents a handy shorthand for a
    series of `UNION`-ed queries, and it can be used in the following example of rewriting
    the previous query:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE605]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE606]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE607]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE608]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE609]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE610]'
  prefs: []
  type: TYPE_PRE
- en: Cool, right?! Nevertheless, there is an issue that should be considered. `GROUPING
    SETS()` will generate `NULL` values for each dimension at the subtotal levels.
    In other words, it is quite hard to distinguish between a real `NULL` value (present
    in the original data) and a generated `NULL` value. But this job is the responsibility
    of the `GROUPING()` function, which returns 0 for `NULL` values in the original
    data and, respectively, 1 for generated `NULL` values that indicate a subtotal.
  prefs: []
  type: TYPE_NORMAL
- en: 'For instance, if we write a query in the `groupBy(groupingSets(OFFICE.CITY,
    OFFICE.COUNTRY))` clause, then we will need to distinguish between generated `NULL`
    values and `NULL` values of `OFFICE.CITY` and, respectively, `OFFICE.COUNTRY`.
    By using `GROUPING()` to form a condition of a `CASE` expression, we can achieve
    this, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE611]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE612]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE613]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE614]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE615]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE616]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE617]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE618]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE619]'
  prefs: []
  type: TYPE_PRE
- en: 'In this query, we replaced every generated `NULL` value with the text `{generated}`,
    while the `NULL` values on the original data will be fetched as `NULL` values.
    So, we now have a clear picture of `NULL` values'' provenience, as illustrated
    here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.26 – No grouping (left-hand side) versus grouping (right-hand side)'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16833_Figure_13.26.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 13.26 – No grouping (left-hand side) versus grouping (right-hand side)
  prefs: []
  type: TYPE_NORMAL
- en: 'Most probably, `{null}` and `{generated}` will not be very attractive for our
    clients, so we can tune this query a little bit to be more friendly by replacing
    `{null}` with `"Unspecified"` and `{generated}` with `"-"`, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE620]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE621]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE622]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE623]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE624]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE625]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE626]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE627]'
  prefs: []
  type: TYPE_PRE
- en: Next to `GROUPING SETS()`, we have `ROLLUP` and `CUBE`. These two extensions
    of the `GROUP BY` clause are syntactic sugar of `GROUPING SETS()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `ROLLUP` group is a series of grouping sets. For instance, `GROUP BY ROLLUP
    (x, y, z)` is equivalent to `GROUP BY GROUPING SETS ((x, y, z), (x, y), (x), ())`.
    `ROLLUP` is typically applied for aggregates of hierarchical data such as sales
    by year > quarter > month > week, or offices internal budget per territory > state
    > country > city, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE628]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE629]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE630]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE631]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE632]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE633]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE634]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE635]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE636]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE637]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE638]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE639]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE640]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE641]'
  prefs: []
  type: TYPE_PRE
- en: 'And the output is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.27 – ROLLUP output'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16833_Figure_13.27.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 13.27 – ROLLUP output
  prefs: []
  type: TYPE_NORMAL
- en: As with `ROLLUP`, a `CUBE` group can also be perceived as a series of grouping
    sets. However, `CUBE` calculates all permutations of the cubed grouping expression
    along with the grand total. So, for *n* elements, `CUBE` produces 2n grouping
    sets. For instance `GROUP BY CUBE (x, y, x)` is equivalent to `GROUP BY GROUPING
    SETS ((x, y, z), (x, y), (x, z), (y, z), (x), (y), (z), ())`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s apply `CUBE` for computing the sum of the internal budget for offices
    by state, country, and city. The query is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE642]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE643]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE644]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE645]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE646]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE647]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE648]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE649]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE650]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE651]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE652]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE653]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, let''s talk about the `GROUPING_ID()` function. This function computes
    the decimal equivalent of the binary value obtained by concatenating the values
    returned by the `GROUPING()` functions applied to all the columns of the `GROUP
    BY` clause. Here is an example of using `GROUPING_ID()` via jOOQ `groupingId()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE654]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE655]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE656]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE657]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE658]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE659]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE660]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE661]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE662]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE663]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE664]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE665]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE666]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE667]'
  prefs: []
  type: TYPE_PRE
- en: 'The following screenshot shows a sample output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.28 – GROUPING_ID() output'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16833_Figure_13.28.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 13.28 – GROUPING_ID() output
  prefs: []
  type: TYPE_NORMAL
- en: '`GROUPING_ID()` can also be used in `HAVING` for creating conditions, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE668]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE669]'
  prefs: []
  type: TYPE_PRE
- en: The complete query is available in the *GroupingRollupCube* bundled code.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Working with SQL functions is such fun! They truly boost the SQL world and
    allow us to solve so many problems during data manipulation. As you saw in this
    chapter, jOOQ provides comprehensive support to SQL functions, covering regular
    and aggregate functions to the mighty window functions, ordered set aggregate
    functions (`WITHIN GROUP`), and so on. While we''re on this topic, allow me to
    recommend the following article as a great read: [https://blog.jooq.org/how-to-find-the-closest-subset-sum-with-sql/](https://blog.jooq.org/how-to-find-the-closest-subset-sum-with-sql/).
    In the next chapter, we tackle virtual tables (vtables).'
  prefs: []
  type: TYPE_NORMAL
