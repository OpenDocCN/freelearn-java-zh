- en: '*Chapter 13*: Exploiting SQL Functions'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第13章*：利用SQL函数'
- en: 'From mathematical and statistical computations to string and date-time manipulations,
    respectively, to different types of aggregations, rankings, and groupings, SQL
    built-in functions are quite handy in many scenarios. There are different categories
    of functions depending on their goal and usage and, as you''ll see, jOOQ has accorded
    major attention to their support. Based on these categories, our agenda for this
    chapter follows these points:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 从数学和统计计算到字符串和日期时间的操作，再到不同类型的聚合、排名和分组，SQL内置函数在许多场景下都非常实用。根据它们的目标和用途，有不同的函数类别，正如你将看到的，jOOQ对这些支持给予了主要关注。基于这些类别，本章的议程遵循以下要点：
- en: Regular functions
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 常规函数
- en: Aggregate functions
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 聚合函数
- en: Window functions
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 窗口函数
- en: Aggregates as window functions
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 聚合作为窗口函数
- en: Aggregate functions and `ORDER BY`
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 聚合函数和`ORDER BY`
- en: Ordered set aggregate functions (`WITHIN GROUP`)
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有序集聚合函数（`WITHIN GROUP`）
- en: Grouping, filtering, distinctness, and functions
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分组、过滤、唯一性和函数
- en: Grouping sets
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分组集
- en: Let's get started!
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始吧！
- en: Technical requirements
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: The code for this chapter can be found on GitHub at [https://github.com/PacktPublishing/jOOQ-Masterclass/tree/master/Chapter13](https://github.com/PacktPublishing/jOOQ-Masterclass/tree/master/Chapter13).
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码可以在GitHub上找到，地址为[https://github.com/PacktPublishing/jOOQ-Masterclass/tree/master/Chapter13](https://github.com/PacktPublishing/jOOQ-Masterclass/tree/master/Chapter13)。
- en: Regular functions
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 常规函数
- en: Being a SQL user, you've probably worked with a lot of regular or common SQL
    functions such as functions for dealing with `NULL` values, numeric functions,
    string functions, date-time functions, and so on. While the jOOQ manual represents
    a comprehensive source of information structured as a nomenclature of all the
    supported SQL built-in functions, we are trying to complete a series of examples
    designed to get you familiar with the jOOQ syntax in different scenarios. Let's
    start by talking about SQL functions for dealing with `NULL` values.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 作为SQL用户，你可能已经使用过很多常规或常见的SQL函数，例如处理`NULL`值的函数、数值函数、字符串函数、日期时间函数等等。虽然jOOQ手册代表了一个结构化的信息源，列出了所有支持的SQL内置函数的命名法，但我们正在尝试完成一系列示例，旨在让你熟悉在不同场景下的jOOQ语法。让我们先从处理`NULL`值的SQL函数开始讨论。
- en: Just in case you need a quick overview about some simple and common `NULL` stuff,
    then quickly check out the `someNullsStuffGoodToKnow()` method available in the
    bundled code.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要快速了解一些简单和常见的`NULL`相关内容，那么可以快速查看捆绑代码中可用的`someNullsStuffGoodToKnow()`方法。
- en: SQL functions for dealing with NULLs
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 处理`NULL`值的SQL函数
- en: SQL provides several functions for handling `NULL` values in our queries. Next,
    let's cover `COALESCE()`, `DECODE()`, `IIF()`, `NULLIF()`, `NVL()`, and `NVL2()`
    functions. Let's start with `COALESCE()`.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: SQL为我们查询中处理`NULL`值提供了几个函数。接下来，让我们介绍`COALESCE()`、`DECODE()`、`IIF()`、`NULLIF()`、`NVL()`和`NVL2()`函数。让我们从`COALESCE()`开始。
- en: COALESCE()
  id: totrans-18
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: COALESCE()
- en: One of the most popular functions for dealing with `NULL` values is `COALESCE()`.
    This function returns the first non-null value from its list of *n* arguments.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 处理`NULL`值最受欢迎的函数之一是`COALESCE()`。这个函数从其*n*个参数列表中返回第一个非空值。
- en: 'For instance, let''s assume that for each `DEPARTMENT`, we want to compute
    a deduction of 25% from `CASH`, `ACCOUNTS_RECEIVABLE`, or `INVENTORIES`, and a
    deduction of 25% from `ACCRUED_LIABILITIES`, `ACCOUNTS_PAYABLE`, or `ST_BORROWING`.
    Since this order is strict, if one of these is a `NULL` value, we go for the next
    one, and so on. If all are `NULL`, then we replace `NULL` with 0\. Relying on
    the jOOQ `coalesce()` method, we can write the query as follows:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设我们想要为每个`DEPARTMENT`计算从`CASH`、`ACCOUNTS_RECEIVABLE`或`INVENTORIES`中扣除25%，以及从`ACCRUED_LIABILITIES`、`ACCOUNTS_PAYABLE`或`ST_BORROWING`中扣除25%。由于这个顺序是严格的，如果其中一个是`NULL`值，我们就选择下一个，依此类推。如果所有都是`NULL`，那么我们将`NULL`替换为0。依靠jOOQ的`coalesce()`方法，我们可以将查询编写如下：
- en: '[PRE0]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '[PRE1]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '[PRE2]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '[PRE3]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '[PRE4]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '[PRE5]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '[PRE6]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '[PRE7]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '[PRE8]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '[PRE9]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Notice the explicit usage of `inline()` for inlining the integer 0\. As long
    as you know that this integer is a constant, there is no need to rely on `val()`
    for rendering a bind variable (placeholder). Using `inline()` fits pretty well
    for SQL functions, which typically rely on constant arguments or mathematical
    formulas having constant terms that can be easily inlined. If you need a quick
    reminder of `inline()` versus `val()`, then consider a quick revisit of [*Chapter
    3*](B16833_03.xhtml#_idTextAnchor040), *jOOQ Core Concepts*.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 注意显式使用`inline()`来内联整数0。只要你知道这个整数是一个常数，就没有必要依赖`val()`来渲染绑定变量（占位符）。使用`inline()`非常适合SQL函数，这些函数通常依赖于常数参数或具有可以轻松内联的常数项的数学公式。如果你需要快速回顾`inline()`与`val()`的区别，那么请快速回顾[*第3章*](B16833_03.xhtml#_idTextAnchor040)，*jOOQ核心概念*。
- en: 'Besides `coalesce(Field<T> field, Field<?>... fields)` used here, jOOQ provides
    two other flavors: `coalesce(Field<T> field, T value)` and `coalesce(T value,
    T... values)`.'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这里使用的`coalesce(Field<T> field, Field<?>... fields)`之外，jOOQ还提供了两种其他风味：`coalesce(Field<T>
    field, T value)`和`coalesce(T value, T... values)`。
- en: 'Here is another example that relies on the `coalesce()` method to fill the
    gaps in the `DEPARTMENT.FORECAST_PROFIT` column. Each `FORECAST_PROFIT` value
    that is `NULL` is filled by the following query:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是另一个例子，它依赖于`coalesce()`方法来填补`DEPARTMENT.FORECAST_PROFIT`列中的空白。每个`FORECAST_PROFIT`值为`NULL`的值由以下查询填充：
- en: '[PRE10]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '[PRE11]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '[PRE12]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '[PRE13]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '[PRE14]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '[PRE15]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '[PRE16]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '[PRE17]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '[PRE18]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '[PRE19]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '[PRE20]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: So, for each row having `FORECAST_PROFIT` equal to `NULL`, we use a custom interpolation
    formula represented by the average of all the non-null `FORECAST_PROFIT` values
    where the profit (`PROFIT`) is greater than the profit of the current row.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，对于每个`FORECAST_PROFIT`等于`NULL`的行，我们使用一个自定义插值公式，该公式表示所有非空`FORECAST_PROFIT`值的平均值，其中利润(`PROFIT`)大于当前行的利润。
- en: Next, let's talk about `DECODE()`.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们谈谈`DECODE()`。
- en: DECODE()
  id: totrans-47
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: DECODE()
- en: 'In some dialects (for instance, in Oracle), we have the `DECODE()` function
    that acts as an if-then-else logic in queries. Having `DECODE(x, a, r`1`, r`2`)`
    is equivalent to the following:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些方言（例如，在Oracle中），我们有`DECODE()`函数，它在查询中充当if-then-else逻辑。`DECODE(x, a, r`1`,
    r`2`)`等同于以下代码：
- en: '[PRE21]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '[PRE22]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '[PRE23]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '[PRE24]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '[PRE25]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Or, since `DECODE` makes `NULL` safe comparisons, it's more like `IF x IS NOT
    DISTINCT FROM a THEN …`.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，由于`DECODE`使`NULL`安全比较，它更像是`IF x IS NOT DISTINCT FROM a THEN …`。
- en: 'Let''s attempt to compute a financial index as ((`DEPARTMENT.LOCAL_BUDGET`
    * 0.25) * 2) / 100\. Since `DEPARTMENT.LOCAL_BUDGET` can be `NULL`, we prefer
    to replace such occurrences with 0\. Relying on the jOOQ `decode()` method, we
    have the following:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试计算一个财务指数，公式为((`DEPARTMENT.LOCAL_BUDGET` * 0.25) * 2) / 100。由于`DEPARTMENT.LOCAL_BUDGET`可能为`NULL`，我们更愿意用0来替换这种出现。依靠jOOQ的`decode()`方法，我们有以下代码：
- en: '[PRE26]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '[PRE27]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '[PRE28]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '[PRE29]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '[PRE30]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '[PRE31]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The `DECODE()` part can be perceived like this:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '`DECODE()`部分可以这样理解：'
- en: '[PRE32]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '[PRE33]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '[PRE34]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '[PRE35]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '[PRE36]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'But don''t conclude from here that `DECODE()` accepts only this simple logic.
    Actually, the `DECODE()` syntax is more complex and looks like this:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 但不要从这里得出结论，认为`DECODE()`只接受这种简单的逻辑。实际上，`DECODE()`的语法更复杂，看起来像这样：
- en: '[PRE37]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'In this syntax, the following applies:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种语法中，以下规则适用：
- en: '`x` is compared with the other argument, `a`1`, a`2`, …, a`n.'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`x`与另一个参数`a`1`, `a`2`, …, `a`n进行比较。'
- en: '`a`1`, a`2`, …,` or `a`n is sequentially compared with the first argument;
    if any comparison `x = a`1`, x = a`2`, …, x = a`n returns `true`, then the `DECODE()`
    function terminates by returning the result.'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`a`1`, `a`2`, …, `a`n依次与第一个参数进行比较；如果任何比较`x = a`1`, `x = a`2`, …, `x = a`n返回`true`，则`DECODE()`函数通过返回结果终止。'
- en: '`r`1`, r`2`, …,` or `r`n is the result corresponding to `x`i `= a`i`, i = (1…n)`.'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`r`1`, `r`2`, …, `r`n是对应于`x`i `= a`i`，i = (1…n)`的结果。'
- en: '`d` is an expression that should be returned if no match for `x`i`=a`i`, i
    = (1…n)` was found.'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`d`是一个表达式，如果未找到`x`i`=a`i`，i = (1…n)`的匹配项，则应返回该表达式。'
- en: 'Since jOOQ emulates `DECODE()` using `CASE` expressions, you can safely use
    it in all dialects supported by jOOQ, so let''s see another example here:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 由于jOOQ使用`CASE`表达式来模拟`DECODE()`，因此可以在jOOQ支持的所有方言中使用它，所以这里再看一个例子：
- en: '[PRE38]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '[PRE39]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '[PRE40]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '[PRE41]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '[PRE42]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '[PRE43]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '[PRE44]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '[PRE45]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: '[PRE46]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: So, in this case, if the department name is *Advertising*, *Accounting*, or
    *Logistics*, then it is replaced with a meaningful description; otherwise, we
    simply return the current name.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在这种情况下，如果部门名称是*广告*，*会计*或*物流*，则将其替换为有意义的描述；否则，我们简单地返回当前名称。
- en: 'Moreover, `DECODE()` can be used with `ORDER BY`, `GROUP BY`, or next to aggregate
    functions as well. While more examples can be seen in the bundled code, here is
    another one of using `DECODE()` with `GROUP BY` for counting `BUY_PRICE` larger/equal/smaller
    than half of `MSRP`:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，`DECODE()` 可以与 `ORDER BY`、`GROUP BY` 或聚合函数一起使用。虽然更多示例可以在捆绑的代码中看到，但这里还有一个使用
    `DECODE()` 与 `GROUP BY` 来计算 `BUY_PRICE` 大于/等于/小于 `MSRP` 一半的示例：
- en: '[PRE47]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: '[PRE48]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: '[PRE49]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: '[PRE50]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: '[PRE51]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: '[PRE52]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: '[PRE53]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: '[PRE54]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: '[PRE55]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: '[PRE56]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'And here is another example of using imbricated `DECODE()`:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是使用嵌套 `DECODE()` 的另一个示例：
- en: '[PRE57]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: '[PRE58]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: '[PRE59]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: '[PRE60]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: '[PRE61]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: '[PRE62]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: '[PRE63]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: '[PRE64]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: '[PRE65]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: '[PRE66]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: '[PRE67]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: '[PRE68]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'For given `sign(a, b)`, it returns 1 if `a` > `b`, 0 if `a` = `b`, and -1 if
    `a` < `b`. So, this code can be easily interpreted based on the following output:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 对于给定的 `sign(a, b)`，如果 `a` > `b` 则返回 1，如果 `a` = `b` 则返回 0，如果 `a` < `b` 则返回 -1。因此，根据以下输出，此代码可以很容易地解释：
- en: '![Figure 13.1 – Output'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 13.1 – 输出](img/B16833_Figure_13.1.jpg)'
- en: '](img/B16833_Figure_13.1.jpg)'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 13.1 – 输出](img/B16833_Figure_13.1.jpg)'
- en: Figure 13.1 – Output
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.1 – 输出
- en: More examples are available in the *Functions* bundled code.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 更多示例可以在 *函数* 捆绑代码中找到。
- en: IIF()
  id: totrans-115
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: IIF()
- en: 'The `IIF()` function implements the if-then-else logic via three arguments,
    as follows (this acts as the `NVL2()` function presented later):'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '`IIF()` 函数通过三个参数实现 if-then-else 逻辑，如下所示（这类似于稍后介绍的 `NVL2()` 函数）：'
- en: '[PRE69]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: It evaluates the first argument (`boolean_expr`) and returns the second argument
    (`value_for_true_case`) and third one (`value_for_false_case`), respectively.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 它评估第一个参数（`boolean_expr`），并分别返回第二个参数（`value_for_true_case`）和第三个参数（`value_for_false_case`）。
- en: 'For instance, the following usage of the jOOQ `iif()` function evaluates the
    `DEPARTMENT.LOCAL_BUDGET.isNull()` expression and outputs the text *NO BUDGET*
    or *HAS BUDGET*:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，以下 jOOQ `iif()` 函数的使用评估了 `DEPARTMENT.LOCAL_BUDGET.isNull()` 表达式，并输出文本 *没有预算*
    或 *有预算*：
- en: '[PRE70]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: '[PRE71]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: '[PRE72]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: '[PRE73]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: More examples, including imbricated `IIF()` usage, are available in the bundled
    code.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 包含嵌套 `IIF()` 使用在内的更多示例可以在捆绑的代码中找到。
- en: NULLIF()
  id: totrans-125
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: NULLIF()
- en: The `NULLIF(expr1, expr2)` function returns `NULL` if the arguments are equal.
    Otherwise, it returns the first argument (`expr1`).
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '`NULLIF(expr1, expr2)` 函数如果参数相等则返回 `NULL`。否则，它返回第一个参数（`expr1`）。'
- en: For instance, in legacy databases, it is a common practice to have a mixture
    of `NULL` and empty strings for missing values. We have intentionally created
    such a case in the `OFFICE` table for `OFFICE.COUNTRY`.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在传统数据库中，混合使用 `NULL` 和空字符串作为缺失值是一种常见做法。我们故意在 `OFFICE` 表的 `OFFICE.COUNTRY`
    上创建了这样的案例。
- en: 'Since empty strings are not `NULL` values, using `ISNULL()` will not return
    them even if, for us, `NULL` values and empty strings may have the same mining.
    Using the jOOQ `nullif()` method is a handy approach for finding all missing data
    (`NULL` values and empty strings), as follows:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 由于空字符串不是 `NULL` 值，即使对我们来说 `NULL` 值和空字符串可能有相同的挖掘，使用 `ISNULL()` 也不会返回它们。使用 jOOQ
    的 `nullif()` 方法是查找所有缺失数据（`NULL` 值和空字符串）的便捷方法，如下所示：
- en: '[PRE74]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: '[PRE75]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: '[PRE76]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: '[PRE77]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: These examples are available in the *Functions* bundled code.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 这些示例可以在 *函数* 捆绑代码中找到。
- en: IFNULL() and ISNULL()
  id: totrans-134
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: IFNULL() 和 ISNULL()
- en: The `IFNULL(expr1, expr2)` and `ISNULL(expr1, expr2)` functions take two arguments
    and return the first one if it is not `NULL`. Otherwise, they return the second
    argument. The former is similar to Oracle's `NVL()` function presented later,
    while the latter is specific to SQL Server. Both of them are emulated by jOOQ
    via `CASE` expressions for all dialects that don't support them natively.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '`IFNULL(expr1, expr2)` 和 `ISNULL(expr1, expr2)` 函数接受两个参数，如果第一个参数不是 `NULL` 则返回第一个参数。否则，它们返回第二个参数。前者类似于稍后介绍的
    Oracle 的 `NVL()` 函数，而后者是 SQL Server 的特定函数。这两个函数都通过 `CASE` 表达式由 jOOQ 在所有原生不支持它们的方言中进行了模拟。'
- en: 'For instance, the following snippet of code produces 0 for each `NULL` value
    of `DEPARTMENT.LOCAL_BUDGET` via both jOOQ methods, `ifnull()` and `isnull()`:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，以下代码片段通过 jOOQ 的 `ifnull()` 和 `isnull()` 方法为 `DEPARTMENT.LOCAL_BUDGET` 的每个
    `NULL` 值生成 0：
- en: '[PRE78]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: '[PRE79]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: '[PRE80]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: '[PRE81]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: '[PRE82]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'Here is another example that fetches the customer''s postal code or address:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是另一个获取客户邮政编码或地址的示例：
- en: '[PRE83]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: '[PRE84]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: '[PRE85]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: '[PRE86]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: '[PRE87]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: '[PRE88]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: More examples are available in the *Functions* bundled code.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 更多示例可以在 *函数* 捆绑代码中找到。
- en: NVL() and NVL2()
  id: totrans-150
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: NVL() 和 NVL2()
- en: Some dialects (for example, Oracle) support two functions named `NVL()` and
    `NVL2()`. Both of them are emulated by jOOQ for all dialects that don't support
    them natively. The former acts like `IFNULL()`, while the latter acts like `IIF()`.
    So, `NVL(expr1, expr2)` produces the first argument if it is not `NULL`; otherwise,
    it produces the second argument.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 一些方言（例如，Oracle）支持名为 `NVL()` 和 `NVL2()` 的两个函数。jOOQ 为所有原生不支持它们的方言进行了模拟。前者类似于稍后介绍的
    Oracle 的 `NVL()` 函数，而后者类似于 `IIF()`。因此，`NVL(expr1, expr2)` 如果第一个参数不是 `NULL` 则产生第一个参数；否则，它产生第二个参数。
- en: 'For instance, let''s use the jOOQ `nvl()` method for applying the variance
    formula used in finance to calculate the difference between a forecast and an
    actual result for `DEPARTMENT.FORECAST_PROFIT` and `DEPARTMENT.PROFIT` as ((`ACTUAL
    PROFIT` ÷ `FORECAST PROFIT`) - 1) * 100, as follows:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，让我们使用jOOQ的`nvl()`方法来应用在金融中使用的方差公式，以计算`DEPARTMENT.FORECAST_PROFIT`和`DEPARTMENT.PROFIT`之间的预测与实际结果差异，如下所示：
- en: '[PRE89]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: '[PRE90]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: '[PRE91]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: '[PRE92]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: '[PRE93]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: '[PRE94]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: If `PROFIT` is `NULL`, then we replace it with 0, and if `FORECAST_PROFIT` is
    `NULL`, then we replace it with a default profit of 10,000\. Challenge yourself
    to write this query via `ISNULL()` as well.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`PROFIT`是`NULL`，则我们将其替换为0，如果`FORECAST_PROFIT`是`NULL`，则我们将其替换为默认利润10,000。挑战自己通过`ISNULL()`编写这个查询。
- en: On the other hand, `NVL2(expr1, expr2, expr3)` evaluates the first argument
    (`expr1`). If `expr1` is not `NULL`, then it returns the second argument (`expr2`);
    otherwise, it returns the third argument (`expr3`).
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，`NVL2(expr1, expr2, expr3)`评估第一个参数（`expr1`）。如果`expr1`不是`NULL`，则返回第二个参数（`expr2`）；否则，返回第三个参数（`expr3`）。
- en: 'For instance, each `EMPLOYEE` has a salary and an optional `COMMISSION` (a
    missing commission is `NULL`). Let''s fetch salary + commission via jOOQ `nvl2()`
    and `iif()`, as follows:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，每个`EMPLOYEE`都有一个工资和一个可选的`COMMISSION`（缺失的佣金是`NULL`）。让我们通过jOOQ的`nvl2()`和`iif()`来获取工资+佣金，如下所示：
- en: '[PRE95]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: '[PRE96]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: '[PRE97]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: '[PRE98]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: '[PRE99]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: '[PRE100]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: '[PRE101]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: '[PRE102]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: '[PRE103]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: '[PRE104]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: '[PRE105]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: '[PRE106]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: 'All three columns—`iif1`, `iif2`, and `nvl2`—should contain the same data.
    Regrettably, `NVL` can perform better than `COALESCE` in some Oracle cases. For
    more details, consider reading this article: [https://connor-mcdonald.com/2018/02/13/nvl-vs-coalesce/](https://connor-mcdonald.com/2018/02/13/nvl-vs-coalesce/).
    You can check out all the examples from this section in the *Functions* bundled
    code. Next, let''s talk about numeric functions.'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这三列—`iif1`、`iif2`和`nvl2`—应包含相同的数据。遗憾的是，在某些Oracle情况下，`NVL`可能比`COALESCE`表现得更好。更多详情，请考虑阅读这篇文章：[https://connor-mcdonald.com/2018/02/13/nvl-vs-coalesce/](https://connor-mcdonald.com/2018/02/13/nvl-vs-coalesce/).
    你可以检查本节中*函数*捆绑代码的所有示例。接下来，让我们谈谈数值函数。
- en: Numeric functions
  id: totrans-175
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数值函数
- en: jOOQ supports a comprehensive list of numeric functions, including `ABS()`,
    `SIN()`, `COS()`, `EXP()`, `FLOOR()`, `GREATEST()`, `LEAST()`, `LN()`, `POWER()`,
    `SIGN()`, `SQRT()`, and much more. Mainly, jOOQ exposes a set of methods that
    mirrors the names of these SQL functions and supports the proper number and type
    of arguments.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: jOOQ支持一系列全面的数值函数，包括`ABS()`、`SIN()`、`COS()`、`EXP()`、`FLOOR()`、`GREATEST()`、`LEAST()`、`LN()`、`POWER()`、`SIGN()`、`SQRT()`等等。主要的是，jOOQ公开了一组方法，这些方法的名称与这些SQL函数相匹配，并支持适当的参数数量和类型。
- en: 'Since you can find all these functions listed and exemplified in the jOOQ manual,
    let''s try here two examples of combining several of them to accomplish a common
    goal. For instance, a famous formula for computing the Fibonacci number is the
    Binet formula (notice that no recursion is required!):'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 由于你可以在jOOQ手册中找到并举例说明所有这些函数，让我们在这里尝试两个结合几个函数以实现共同目标的例子。例如，计算斐波那契数的著名公式是Binet公式（注意不需要递归！）：
- en: '[PRE107]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: 'Writing this formula in jOOQ/SQL requires us to use the `power()` numeric function
    as follows (`n` is the number to compute):'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在jOOQ/SQL中编写这个公式需要我们使用`power()`数值函数，如下所示（`n`是要计算的数字）：
- en: '[PRE108]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: '[PRE109]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: 'How about computing the distance between two points expressed as `(latitude1,
    longitude1)`, respectively `(latitude2, longitude2)`? Of course, exactly as in
    the case of the Fibonacci number, such computations are commonly done outside
    the database (directly in Java) or in a UDF or stored procedure, but trying to
    solve them in a `SELECT` statement is a good opportunity to quickly practice some
    numeric functions and get familiar with jOOQ syntax. So, here we go with the required
    math:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 那么计算表示为`(latitude1, longitude1)`和`(latitude2, longitude2)`的两个点之间的距离呢？当然，就像计算斐波那契数的情况一样，这样的计算通常在数据库外部（直接在Java中）或UDF或存储过程中完成，但尝试在`SELECT`语句中解决它们是快速练习一些数值函数并熟悉jOOQ语法的良好机会。所以，我们开始所需的数学计算：
- en: '[PRE110]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: '[PRE111]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: '[PRE112]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: '[PRE113]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: 'This time, we need the jOOQ `power()`, `sin()`, `cos()`, `atn2()`, and `sqrt()`
    numeric methods, as shown here:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，我们需要jOOQ的`power()`、`sin()`、`cos()`、`atn2()`和`sqrt()`数值方法，如下所示：
- en: '[PRE114]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: '[PRE115]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: '[PRE116]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: '[PRE117]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: '[PRE118]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: '[PRE119]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: '[PRE120]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: You can practice these examples in the *Functions* bundled code.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在*函数*捆绑代码中练习这些示例。
- en: String functions
  id: totrans-196
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 字符串函数
- en: 'Exactly as in case of SQL numeric functions, jOOQ supports an impressive set
    of SQL string functions, including `ASCII()`, `CONCAT()`, `OVERLAY()`, `LOWER()`,
    `UPPER()`, `LTRIM()`, `RTRIM()`, and so on. You can find each of them exemplified
    in the jOOQ manual, so here, let''s try to use several string functions to obtain
    an output, as in this screenshot:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 正如SQL数值函数的情况一样，jOOQ支持一组令人印象深刻的SQL字符串函数，包括`ASCII()`、`CONCAT()`、`OVERLAY()`、`LOWER()`、`UPPER()`、`LTRIM()`、`RTRIM()`等。你可以在jOOQ手册中找到每个函数的示例，所以在这里，让我们尝试使用几个字符串函数来获取输出，如图所示：
- en: '![Figure 13.2 – Applying several SQL string functions'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '![图13.2 – 应用多个SQL字符串函数]'
- en: '](img/B16833_Figure_13.2.jpg)'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '![图13.2]'
- en: Figure 13.2 – Applying several SQL string functions
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '![图13.2 – 应用多个SQL字符串函数]'
- en: 'Transforming what we have in what we want can be expressed in jOOQ via several
    methods, including `concat()`, `upper()`, `space()`, `substring()`, `lower()`,
    and `rpad()`—of course, you can optimize or write the following query in different
    ways:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 将我们拥有的东西转换为想要的东西可以通过jOOQ的几种方法表达，包括`concat()`、`upper()`、`space()`、`substring()`、`lower()`和`rpad()`——当然，你可以以不同的方式优化或编写以下查询：
- en: '[PRE121]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: '[PRE122]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE122]'
- en: '[PRE123]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE123]'
- en: '[PRE124]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE124]'
- en: '[PRE125]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE125]'
- en: '[PRE126]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE126]'
- en: You can check out this example next to several examples of splitting a string
    by a delimiter in the *Functions* bundled code.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在*函数*捆绑代码旁边查看几个通过分隔符拆分字符串的示例。
- en: Date-time functions
  id: totrans-209
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 日期时间函数
- en: The last category of functions covered in this section includes date-time functions.
    Mainly, jOOQ exposes a wide range of date-time functions that can be roughly categorized
    as functions that operate with `java.sql.Date`, `java.sql.Time`, and `java.sql.Timestamp`,
    and functions that operate with Java 8 date-time, `java.time.LocalDate`, `java.time.LocalDateTime`,
    and `java.time.OffsetTime`. jOOQ can't use the `java.time.Duration` or `Period`
    classes as they work differently from standard SQL intervals, though of course,
    converters and bindings can be applied.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 本节最后讨论的函数类别包括日期时间函数。主要的是，jOOQ公开了一系列日期时间函数，可以大致分为操作`java.sql.Date`、`java.sql.Time`和`java.sql.Timestamp`的函数，以及操作Java
    8日期时间的函数，`java.time.LocalDate`、`java.time.LocalDateTime`和`java.time.OffsetTime`。尽管如此，jOOQ不能使用`java.time.Duration`或`Period`类，因为它们与标准SQL间隔的工作方式不同。
- en: Moreover, jOOQ comes with a substitute for JDBC missing `java.sql.Interval`
    data type, named `org.jooq.types.Interval`, having three implementations as `DayToSecond`,
    `YearToMonth`, and `YearToSecond`.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，jOOQ提供了一个替代JDBC缺少的`java.sql.Interval`数据类型，名为`org.jooq.types.Interval`，有三个实现：`DayToSecond`、`YearToMonth`和`YearToSecond`。
- en: 'Here are a few examples that are pretty simple and intuitive. This first example
    fetches the current date as `java.sql.Date` and `java.time.LocalDate`:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些相当简单直观的示例。第一个示例通过`java.sql.Date`和`java.time.LocalDate`获取当前日期：
- en: '[PRE127]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE127]'
- en: '[PRE128]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE128]'
- en: 'This next example converts an ISO *8601* `DATE` string literal into a `java.sql.Date`
    data type:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个示例将ISO *8601* `DATE`字符串字面值转换为`java.sql.Date`数据类型：
- en: '[PRE129]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE129]'
- en: 'Adding an interval of 10 days to a `Date` and a `LocalDate` can be done like
    this:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 向`Date`和`LocalDate`添加10天的间隔可以这样操作：
- en: '[PRE130]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE130]'
- en: '[PRE131]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE131]'
- en: '[PRE132]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE132]'
- en: '[PRE133]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE133]'
- en: 'Or, adding an interval of 3 months can be done like this:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，添加3个月的间隔可以这样操作：
- en: '[PRE134]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE134]'
- en: '[PRE135]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE135]'
- en: 'Extracting the day of week (1 = Sunday, 2 = Monday, ..., 7 = Saturday) via
    the SQL `EXTRACT()` and jOOQ `dayOfWeek()` functions can be done like this:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 通过SQL的`EXTRACT()`和jOOQ的`dayOfWeek()`函数提取星期几（1 = 星期日，2 = 星期一，...，7 = 星期六）可以这样操作：
- en: '[PRE136]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE136]'
- en: '[PRE137]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE137]'
- en: '[PRE138]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE138]'
- en: You can check out more examples in the *Functions* bundled code. In the next
    section, let's tackle aggregate functions.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在*函数*捆绑代码中查看更多示例。在下一节中，我们将讨论聚合函数。
- en: Aggregate functions
  id: totrans-230
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 聚合函数
- en: 'The most common aggregate functions (in an arbitrary order) are `AVG()`, `COUNT()`,
    `MAX()`, `MIN()`, and `SUM()`, including their `DISTINCT` variants. I''m pretty
    sure that you are very familiar with these aggregates and you''ve used them in
    many of your queries. For instance, here are two `SELECT` statements that compute
    the popular harmonic and geometric means for sales grouped by fiscal year. Here,
    we use the jOOQ `sum()` and `avg()` functions:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 最常见的聚合函数（按任意顺序）是`AVG()`、`COUNT()`、`MAX()`、`MIN()`和`SUM()`，包括它们的`DISTINCT`变体。我非常确信你对这些聚合函数非常熟悉，并且你在许多查询中已经使用过它们。例如，这里有两个计算按财政年度分组的销售流行调和几何平均值的`SELECT`语句。在这里，我们使用了jOOQ的`sum()`和`avg()`函数：
- en: '[PRE139]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE139]'
- en: '[PRE140]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE140]'
- en: '[PRE141]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE141]'
- en: '[PRE142]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE142]'
- en: 'And here, we compute the geometric mean:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 而在这里，我们计算几何平均值：
- en: '[PRE143]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE143]'
- en: '[PRE144]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE144]'
- en: '[PRE145]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE145]'
- en: '[PRE146]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE146]'
- en: But as you know (or as you'll find out shortly), there are many other aggregates
    that have the same goal of performing some calculations across a set of rows and
    returning a single output row. Again, jOOQ exposes dedicated methods whose names
    mirror the aggregates' names or represent suggestive shortcuts.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 但正如你所知（或者你很快就会了解到），还有许多其他汇总具有相同的目标，即对一组行执行某些计算并返回单个输出行。同样，jOOQ公开了具有与汇总名称相同名称或表示建议快捷方式的方法。
- en: 'Next, let''s see several aggregate functions that are less popular and are
    commonly used in statistics, finance, science, and other fields. One of them is
    dedicated to computing Standard Deviation, ([https://en.wikipedia.org/wiki/Standard_deviation](https://en.wikipedia.org/wiki/Standard_deviation)).
    In jOOQ, we have `stddevSamp()` for Sample and `stddevPop()` for Population. Here
    is an example of computing SSD, PSD, and emulation of PSD via population variance
    (introduced next) for sales grouped by fiscal year:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看看一些不太流行但在统计学、金融、科学和其他领域常用的汇总函数。其中之一是用于计算标准差的，([https://en.wikipedia.org/wiki/Standard_deviation](https://en.wikipedia.org/wiki/Standard_deviation))。在jOOQ中，我们有`stddevSamp()`用于样本和`stddevPop()`用于总体。以下是一个计算SSD、PSD以及通过总体方差（接下来将介绍）对按财政年度分组的销售进行PSD仿真的示例：
- en: '[PRE147]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE147]'
- en: '[PRE148]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE148]'
- en: '[PRE149]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE149]'
- en: '[PRE150]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE150]'
- en: '[PRE151]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE151]'
- en: 'Both SSD and PSD are supported in MySQL, PostgreSQL, SQL Server, Oracle, and
    many other dialects and are useful in different kinds of problems, from finance,
    statistics, forecasting, and so on. For instance, in statistics, we have the standard
    score (or so-called z-score) that represents the number of SDs placed above or
    below the population mean for a certain observation and having the formula z =
    (x - µ) / σ (z is z-score, x is the observation, µ is the mean, and σ is the SD).
    You can read further information on this here: [https://en.wikipedia.org/wiki/Standard_score](https://en.wikipedia.org/wiki/Standard_score).'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: SSD和PSD在MySQL、PostgreSQL、SQL Server、Oracle以及许多其他方言中都得到支持，并在各种问题中非常有用，从金融、统计学、预测等等。例如，在统计学中，我们有标准分数（或所谓的z分数），它表示某个观察值相对于总体平均值的SD数，其公式为z
    = (x - µ) / σ（z是z分数，x是观察值，µ是平均值，σ是SD）。您可以在这里了解更多信息：[https://en.wikipedia.org/wiki/Standard_score](https://en.wikipedia.org/wiki/Standard_score)。
- en: 'Now, considering that we store the number of sales (`DAILY_ACTIVITY.SALES`)
    and visitors (`DAILY_ACTIVITY.VISITORS`) in `DAILY_ACTIVITY` and we want to get
    some information about this data, since there is no direct comparison between
    sales and visitors, we have to come up with some meaningful representation, and
    this can be provided by z-scores. By relying on Common Table Expressions (**CTEs**)
    and SD, we can express in jOOQ the following query (of course, in production,
    using a stored procedure may be a better choice for such queries):'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，考虑到我们在`DAILY_ACTIVITY`中存储了销售数量（`DAILY_ACTIVITY.SALES`）和访客数量（`DAILY_ACTIVITY.VISITORS`），并且我们想要获取有关这些数据的一些信息，由于销售和访客之间没有直接比较，我们必须提出一些有意义的表示，而这可以通过z分数来实现。通过依赖公用表表达式（**CTEs**）和SD，我们可以在jOOQ中表达以下查询（当然，在生产环境中，使用存储过程可能是此类查询的更好选择）：
- en: '[PRE152]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE152]'
- en: '[PRE153]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE153]'
- en: '[PRE154]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE154]'
- en: '[PRE155]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE155]'
- en: '[PRE156]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE156]'
- en: '[PRE157]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE157]'
- en: '[PRE158]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE158]'
- en: '[PRE159]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE159]'
- en: '[PRE160]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE160]'
- en: '[PRE161]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE161]'
- en: '[PRE162]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE162]'
- en: '[PRE163]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE163]'
- en: '[PRE164]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE164]'
- en: '[PRE165]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE165]'
- en: '[PRE166]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE166]'
- en: '[PRE167]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE167]'
- en: '[PRE168]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE168]'
- en: '[PRE169]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE169]'
- en: '[PRE170]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE170]'
- en: Among the results produced by this query, we remark the z-score of sales on
    *2004-01-06*, which is 2.00\. In the context of z-score analysis, this output
    is definitely worth a deeper investigation (typically, z-scores > 1.96 or < -1.96
    are considered outliers that should be further investigated). Of course, this
    is not our goal, so let's jump to another aggregate.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 在此查询产生的结果中，我们注意到2004-01-06的销售z分数为2.00。在z分数分析的情况下，这个输出肯定值得深入调查（通常，z分数大于1.96或小于-1.96被视为需要进一步调查的异常值）。当然，这并不是我们的目标，所以让我们跳到另一个汇总。
- en: 'Going further through statistical aggregates, we have variance, which is defined
    as the average of the squared differences from the mean or the average squared
    deviations from the mean ([https://en.wikipedia.org/wiki/Variance](https://en.wikipedia.org/wiki/Variance)).
    In jOOQ, we have sample variance via `varSamp()` and population variance via `varPop()`,
    as illustrated in this code example:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 通过对统计汇总的进一步分析，我们得到了方差，它被定义为平均的平方差（即与平均值的平方差的平均值）或平均平方偏差（[https://en.wikipedia.org/wiki/Variance](https://en.wikipedia.org/wiki/Variance)）。在jOOQ中，我们通过`varSamp()`方法获得样本方差，通过`varPop()`方法获得总体方差，如以下代码示例所示：
- en: '[PRE171]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE171]'
- en: '[PRE172]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE172]'
- en: '[PRE173]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE173]'
- en: '[PRE174]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE174]'
- en: '[PRE175]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE175]'
- en: 'Both of them are supported in MySQL, PostgreSQL, SQL Server, Oracle, and many
    other dialects, but just for fun, you can emulate sample variance via the `COUNT()`
    and `SUM()` aggregates as has been done in the following code snippet—just another
    opportunity to practice these aggregates:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 它们都在 MySQL、PostgreSQL、SQL Server、Oracle 以及许多其他方言中得到支持，但为了好玩，你可以通过以下代码片段中的 `COUNT()`
    和 `SUM()` 聚合来模拟样本方差——这又是一个练习这些聚合的机会：
- en: '[PRE176]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE176]'
- en: '[PRE177]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE177]'
- en: '[PRE178]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE178]'
- en: '[PRE179]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE179]'
- en: Next, we have linear regression (or correlation) functions applied for determining
    regression relationships between the dependent (denoted as Y) and independent
    (denoted as X) variable expressions ([https://en.wikipedia.org/wiki/Regression_analysis](https://en.wikipedia.org/wiki/Regression_analysis)).
    In jOOQ, we have `regrSXX()`,`regrSXY()`, `regrSYY()`, `regrAvgX``()`, `regrAvgXY()`,
    `regrCount()`, `regrIntercept()`, `regrR2()`, and `regrSlope()`.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们有线性回归（或相关）函数，用于确定因变量（表示为 Y）和自变量（表示为 X）表达式之间的回归关系([https://en.wikipedia.org/wiki/Regression_analysis](https://en.wikipedia.org/wiki/Regression_analysis))。在
    jOOQ 中，我们有 `regrSXX()`、`regrSXY()`、`regrSYY()`、`regrAvgX()`、`regrAvgXY()`、`regrCount()`、`regrIntercept()`、`regrR2()`
    和 `regrSlope()`。
- en: 'For instance, in the case of `regrSXY(y, x)`, `y` is the dependent variable
    expression and `x` is the independent variable expression. If `y` is `PRODUCT.BUY_PRICE`
    and `x` is `PRODUCT.MSRP`, then the linear regression per `PRODUCT_LINE` looks
    like this:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在 `regrSXY(y, x)` 的情况下，`y` 是因变量表达式，而 `x` 是自变量表达式。如果 `y` 是 `PRODUCT.BUY_PRICE`
    而 `x` 是 `PRODUCT.MSRP`，那么按 `PRODUCT_LINE` 进行的线性回归看起来是这样的：
- en: '[PRE180]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE180]'
- en: '[PRE181]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE181]'
- en: '[PRE182]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE182]'
- en: 'The functions listed earlier (including `regrSXY()`) are supported in all dialects,
    but they can be easily emulated as well. For instance, `regrSXY()` can be emulated
    as `(SUM(X*Y)-SUM(X) * SUM(Y)/COUNT(*))`, as illustrated here:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 列出的函数（包括 `regrSXY()`）在所有方言中都得到支持，但也可以很容易地模拟。例如，`regrSXY()` 可以模拟为 `(SUM(X*Y)-SUM(X)
    * SUM(Y)/COUNT(*))`，如这里所示：
- en: '[PRE183]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE183]'
- en: '[PRE184]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE184]'
- en: '[PRE185]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE185]'
- en: '[PRE186]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE186]'
- en: '[PRE187]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE187]'
- en: In addition, `regrSXY()` can also be emulated as `SUM(1) * COVAR_POP(expr1,
    expr2)`, where `COVAR_POP()` represents the population covariance and `SUM(1)`
    is actually `REGR_COUNT(expr1, expr2)`. You can see this example in the bundled
    code next to many other emulations for `REGR_FOO()` functions and an example of
    calculating `y = slope * x – intercept` via `regrSlope()` and `regrIntercept()`,
    linear regression coefficients, but also via `sum()`, `avg()`, and `max()`.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，`regrSXY()` 还可以模拟为 `SUM(1) * COVAR_POP(expr1, expr2)`，其中 `COVAR_POP()` 代表总体协方差，而
    `SUM(1)` 实际上是 `REGR_COUNT(expr1, expr2)`。你可以在包含许多其他 `REGR_FOO()` 函数模拟和通过 `regrSlope()`
    和 `regrIntercept()` 计算的 `y = slope * x – intercept` 示例旁边的捆绑代码中看到这个例子，线性回归系数，也可以通过
    `sum()`、`avg()` 和 `max()`。
- en: 'After population covariance ([https://en.wikipedia.org/wiki/Covariance](https://en.wikipedia.org/wiki/Covariance)),
    `COVAR_POP()`, we have sample covariance, `COVAR_SAMP()`, which can be called
    like this:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 在人口协方差([https://en.wikipedia.org/wiki/Covariance](https://en.wikipedia.org/wiki/Covariance))之后，我们有样本协方差，`COVAR_SAMP()`，它可以这样调用：
- en: '[PRE188]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE188]'
- en: '[PRE189]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE189]'
- en: '[PRE190]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE190]'
- en: '[PRE191]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE191]'
- en: '[PRE192]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE192]'
- en: '[PRE193]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE193]'
- en: If your database doesn't support the covariance functions (for instance, MySQL
    or SQL Server), then you can emulate them via common aggregates—`COVAR_SAMP()`
    as `(SUM(x*y) - SUM(x) * SUM(y) / COUNT(*)) / (COUNT(*) - 1)`, and `COVAR_POP()`
    as `(SUM(x*y) - SUM(x) * SUM(y) / COUNT(*)) / COUNT(*)`. You can find examples
    in the *AggregateFunctions* bundled code.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的数据库不支持协方差函数（例如，MySQL 或 SQL Server），那么你可以通过常见的聚合来模拟它们——`COVAR_SAMP()` 作为
    `(SUM(x*y) - SUM(x) * SUM(y) / COUNT(*)) / (COUNT(*) - 1)`，而 `COVAR_POP()` 作为
    `(SUM(x*y) - SUM(x) * SUM(y) / COUNT(*)) / COUNT(*)`。你可以在 `AggregateFunctions`
    包含的代码中找到示例。
- en: 'An interesting function that is not supported by most databases (Exasol is
    one of the exceptions) but is provided by jOOQ is the synthetic `product()` function.
    This function represents multiplicative aggregation emulated via `exp(sum(log(arg)))`
    for positive numbers, and it performs some extra work for zero and negative numbers.
    For instance, in finance, there is an index named Compounded Month Growth Rate
    (CMGR) that is computed based on monthly revenue growth, as we have in `SALE.REVENUE_GROWTH`.
    The formula is `(PRODUCT (1 + SALE.REVENUE_GROWTH))) ^ (1 / COUNT())`, and we''ve
    applied it for each year here:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 一个大多数数据库（Exasol 是其中之一）不支持但由 jOOQ 提供的有趣函数是合成的 `product()` 函数。此函数表示通过 `exp(sum(log(arg)))`
    对正数进行乘法聚合，并为零和负数执行一些额外的工作。例如，在金融领域，有一个名为复合月增长率（CMGR）的指数，它是基于月收入增长率计算的，正如我们在 `SALE.REVENUE_GROWTH`
    中所做的那样。公式是 `(PRODUCT (1 + SALE.REVENUE_GROWTH))) ^ (1 / COUNT())`，并且我们在这里为每年的数据应用了它：
- en: '[PRE194]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE194]'
- en: '[PRE195]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE195]'
- en: '[PRE196]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE196]'
- en: '[PRE197]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE197]'
- en: '[PRE198]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE198]'
- en: '[PRE199]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE199]'
- en: We also multiply everything by 100 to obtain the result as a percent. You can
    find this example in the *AggregateFunctions* bundled code, next to other aggregation
    functions such as `BOOL_AND()`, `EVERY()`, `BOOL_OR()`, and functions for bitwise
    operations.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还把所有东西乘以 100，以获得作为百分比的输出。您可以在 *AggregateFunctions* 打包代码中找到此示例，它位于其他聚合函数旁边，如
    `BOOL_AND()`、`EVERY()`、`BOOL_OR()` 和位运算函数。
- en: 'When you have to use an aggregate function that is partially supported or not
    supported by jOOQ, you can rely on the `aggregate()`/ `aggregateDistinct()` methods.
    Of course, your database must support the called aggregate function. For instance,
    jOOQ doesn''t support the Oracle `APPROX_COUNT_DISTINCT()` aggregation function,
    which represents an alternative to the `COUNT (DISTINCT expr)` function. This
    is useful for approximating the number of distinct values while processing large
    amounts of data significantly faster than the traditional `COUNT` function, with
    negligible deviation from the exact number. Here is a usage of the `(String name,
    Class<T> type, Field<?>... arguments`) aggregate, which is just one of the provided
    flavors (check out the documentation for more):'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 当您必须使用 jOOQ 部分支持或不支持的聚合函数时，您可以使用 `aggregate()`/ `aggregateDistinct()` 方法。当然，您的数据库必须支持所调用的聚合函数。例如，jOOQ
    不支持 Oracle 的 `APPROX_COUNT_DISTINCT()` 聚合函数，它是 `COUNT (DISTINCT expr)` 函数的替代品。这在处理大量数据时非常有用，可以显著快于传统的
    `COUNT` 函数，且与精确数值的偏差可以忽略不计。以下是一个使用 `(String name, Class<T> type, Field<?>... arguments)`
    聚合的示例，这仅仅是提供的一种风味（请参阅文档以获取更多信息）：
- en: '[PRE200]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE200]'
- en: '[PRE201]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE201]'
- en: '[PRE202]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE202]'
- en: '[PRE203]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE203]'
- en: '[PRE204]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE204]'
- en: '[PRE205]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE205]'
- en: You can find this example in the *AggregateFunctions* bundled code for Oracle.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在 Oracle 的 *AggregateFunctions* 打包代码中找到此示例。
- en: Window functions
  id: totrans-317
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 窗口函数
- en: 'Window functions are extremely useful and powerful; therefore, they represent
    a must-know topic for every developer that interacts with a database via SQL.
    In a nutshell, the best way to quickly overview window functions is to start from
    a famous diagram representing a comparison between an aggregation function and
    a window function that highlights the main difference between them, as represented
    here:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 窗口函数非常实用且强大；因此，它们是每个通过 SQL 与数据库交互的开发者必须了解的主题。简而言之，快速概述窗口函数的最好方法是从一个著名的图表开始，该图表展示了聚合函数与窗口函数之间的比较，突出了它们之间的主要区别，如图所示：
- en: '![Figure 13.3 – Aggregate functions versus window functions'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 13.3 – 聚合函数与窗口函数的比较]'
- en: '](img/B16833_Figure_13.3.jpg)'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/B16833_Figure_13.3.jpg]'
- en: Figure 13.3 – Aggregate functions versus window functions
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.3 – 聚合函数与窗口函数的比较
- en: 'As you can see, both the aggregate function and the window function calculate
    something on a set of rows, but a window function doesn''t aggregate or group
    these rows into a single output row. A window function relies on the following
    syntax:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，聚合函数和窗口函数都在一组行上计算某些内容，但窗口函数不会将这些行聚合或分组成一个单一的输出行。窗口函数依赖于以下语法：
- en: '[PRE206]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE206]'
- en: '[PRE207]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE207]'
- en: '[PRE208]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE208]'
- en: 'This syntax can be explained as follows:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 这个语法可以这样解释：
- en: Obviously, `window_function_name` represents the window function name, such
    as `ROW_NUMBER()`, `RANK()`, and so on.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，`window_function_name` 代表窗口函数的名称，例如 `ROW_NUMBER()`、`RANK()` 等等。
- en: '`expression` identifies the column (or target expression) on which this window
    function will operate.'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: '`expression` 用来标识这个窗口函数将要操作的列（或目标表达式）。'
- en: 'The `OVER` clause signals that this is a window function, and it consists of
    three clauses: `Partition`, `Order`, and `Frame`. By adding the `OVER` clause
    to any aggregate function, you transform it into a window function.'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: '`OVER` 子句表示这是一个窗口函数，它由三个子句组成：`Partition`、`Order` 和 `Frame`。通过向任何聚合函数添加 `OVER`
    子句，您将其转换为窗口函数。'
- en: 'The `Partition` clause is optional, and its goal is to divide the rows into
    partitions. Next, the window function will operate on each partition. It has the
    following syntax: `PARTITION BY expr1, expr2, ...`. If `PARTITION BY` is omitted,
    then the entire result set represents a single partition. To be entirely accurate,
    if `PARTITION BY` is omitted, then all the data produced by `FROM`/`WHERE`/`GROUP
    BY`/`HAVING` represents a single partition.'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: '`Partition` 子句是可选的，其目的是将行划分为分区。接下来，窗口函数将对每个分区进行操作。它的语法如下：`PARTITION BY expr1,
    expr2, ...`。如果省略 `PARTITION BY`，则整个结果集代表一个单一的分区。为了完全准确，如果省略 `PARTITION BY`，则 `FROM`/`WHERE`/`GROUP
    BY`/`HAVING` 产生的所有数据代表一个单一的分区。'
- en: The `Order` clause is also optional, and it handles the order of rows in a partition.
    Its syntax is `ORDER BY expression [ASC | DESC] [NULLS {FIRST| LAST}] ,...`.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: '`Order` 子句也是可选的，它处理分区中行的顺序。其语法是 `ORDER BY 表达式 [ASC | DESC] [NULLS {FIRST| LAST}]
    ,...`。'
- en: The `Frame` clause demarcates a subset of the current partition. The common
    syntax is `mode BETWEEN start_of_frame AND end_of_frame [frame_exclusion]`.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: '`Frame` 子句定义了当前分区的子集。常见的语法是 `mode BETWEEN start_of_frame AND end_of_frame [frame_exclusion]`。'
- en: '`mode` instructs the database about how to treat the input rows. Three possible
    values indicate the type of relationship between the frame rows and the current
    row: `ROWS`, `GROUPS`, and `RANGE`.'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: '`mode` 指示数据库如何处理输入行。三个可能的值表示框架行与当前行之间的关系类型：`ROWS`、`GROUPS` 和 `RANGE`。'
- en: ROWS
  id: totrans-334
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ROWS
- en: The `ROWS` mode specifies that the offsets of the frame rows and the current
    row are row numbers (the database sees each input row as an individual unit of
    work). In this context, `start_of_frame` and `end_of_frame` determine which rows
    the window frame starts and ends with.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: '`ROWS` 模式指定框架行和当前行的偏移量是行号（数据库将每个输入行视为一个独立的工作单元）。在此上下文中，`start_of_frame` 和 `end_of_frame`
    确定窗口框架开始和结束的行。'
- en: In this context, `start_of_frame` can be `N PRECEDING`, which means that the
    frame starts at nth rows before the currently evaluated row (in jOOQ, `rowsPreceding(n)`),
    `UNBOUNDED PRECEDING`, which means that the frame starts at the first row of the
    current partition (in jOOQ, `rowsUnboundedPreceding()`), and `CURRENT ROW` (jOOQ
    `rowsCurrentRow()`).
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 在此上下文中，`start_of_frame` 可以是 `N PRECEDING`，这意味着框架从当前评估行的第 n 行之前开始（在 jOOQ 中，`rowsPreceding(n)`），`UNBOUNDED
    PRECEDING`，这意味着框架从当前分区的第一行开始（在 jOOQ 中，`rowsUnboundedPreceding()`），以及 `CURRENT
    ROW`（jOOQ `rowsCurrentRow()`）。
- en: The `end_of_frame` value can be `CURRENT ROW` (previously described), `N FOLLOWING`,
    which means that the frame ends at the nth row after the currently evaluated row
    (in jOOQ, `rowsFollowing(n)`), and `UNBOUNDED FOLLOWING`, which means that the
    frame ends at the last row of the current partition (in jOOQ, `rowsUnboundedFollowing()`).
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: '`end_of_frame` 的值可以是 `CURRENT ROW`（之前描述过），`N FOLLOWING`，这意味着框架在当前评估行的第 n 行之后结束（在
    jOOQ 中，`rowsFollowing(n)`），以及 `UNBOUNDED FOLLOWING`，这意味着框架在当前分区的最后一行结束（在 jOOQ
    中，`rowsUnboundedFollowing()`）。'
- en: 'Check out the following diagram containing some examples:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 查看以下包含一些示例的图：
- en: '![Figure 13.4 – ROWS mode examples'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 13.4 – ROWS 模式示例'
- en: '](img/B16833_Figure_13.4.jpg)'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16833_Figure_13.4.jpg)'
- en: Figure 13.4 – ROWS mode examples
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.4 – ROWS 模式示例
- en: What's in gray represents the included rows.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 灰色部分表示包含的行。
- en: GROUPS
  id: totrans-343
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: GROUPS
- en: The `GROUPS` mode instructs the database that the rows with duplicate sorting
    values should be grouped together. So, `GROUPS` is useful when duplicate values
    are present.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: '`GROUPS` 模式指示数据库将具有重复排序值的行分组在一起。因此，当存在重复值时，`GROUPS` 是有用的。'
- en: In this context, `start_of_frame` and `end_of_frame` accept the same values
    as `ROWS`. But, in the case of `start_of_frame`, `CURRENT_ROW` points to the first
    row in a group that contains the current row, while in the case of `end_of_frame`,
    it points to the last row in a group that contains the current row. Moreover,
    `N PRECEDING`/`FOLLOWING` refers to groups that should be considered as the number
    of groups before, respectively, after the current group. On the other hand, `UNBOUNDED
    PRECEDING`/`FOLLOWING` has the same meaning as in the case of `ROWS`.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 在此上下文中，`start_of_frame` 和 `end_of_frame` 接受与 `ROWS` 相同的值。但是，在 `start_of_frame`
    的情况下，`CURRENT_ROW` 指向包含当前行的组中的第一行，而在 `end_of_frame` 的情况下，它指向包含当前行的组中的最后一行。此外，`N
    PRECEDING`/`FOLLOWING` 指的是应考虑为当前组之前、之后组的数量。另一方面，`UNBOUNDED PRECEDING`/`FOLLOWING`
    与 `ROWS` 的情况具有相同的意义。
- en: 'Check out the following diagram containing some examples:'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 查看以下包含一些示例的图：
- en: '![Figure 13.5 – GROUPS mode examples'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 13.5 – GROUPS 模式示例'
- en: '](img/B16833_Figure_13.5.jpg)'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16833_Figure_13.5.jpg)'
- en: Figure 13.5 – GROUPS mode examples
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.5 – GROUPS 模式示例
- en: There are three groups (G1, G2, and G3) represented in different shades of gray.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 有三个组（G1、G2 和 G3）以不同的灰色阴影表示。
- en: RANGE
  id: totrans-351
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: RANGE
- en: The `RANGE` mode doesn't tie rows as `ROWS`/`GROUPS`. This mode works on a given
    range of values of the sorting column. This time, for `start_of_frame` and `end_of_frame`,
    we don't specify the number of rows/groups; instead, we specify the maximum difference
    of values that the window frame should contain. Both values must be expressed
    in the same units (or, meaning) as the sorting column is.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: '`RANGE`模式不将行绑定为`ROWS`/`GROUPS`。此模式在排序列的给定值范围内工作。这次，对于`start_of_frame`和`end_of_frame`，我们不指定行/组的数量；相反，我们指定窗口框架应包含的值的最大差异。这两个值必须以与排序列相同的单位（或意义）表示。'
- en: 'In this context, for `start_of_frame`,we have the following: (this time, `N`
    is a value in the same unit as the sorting column is) `N PRECEDING` (in jOOQ,
    `rangePreceding(n)`), `UNBOUNDED PRECEDING` (in jOOQ, `rangeUnboundedPreceding()`),
    and `CURRENT ROW` (in jOOQ, `rangeCurrentRow()`). For `end_of_frame`, we have
    `CURRENT ROW`, `UNBOUNDED FOLLOWING` (in jOOQ, `rangeUnboundedFollowing()`), `N
    FOLLOWING` (in jOOQ, `rangeFollowing(n)`).'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 在此上下文中，对于`start_of_frame`，我们有以下内容：（这次，`N`是排序列的相同单位中的值）`N PRECEDING`（在jOOQ中，`rangePreceding(n)`），`UNBOUNDED
    PRECEDING`（在jOOQ中，`rangeUnboundedPreceding()`），和`CURRENT ROW`（在jOOQ中，`rangeCurrentRow()`）。对于`end_of_frame`，我们有`CURRENT
    ROW`，`UNBOUNDED FOLLOWING`（在jOOQ中，`rangeUnboundedFollowing()`），`N FOLLOWING`（在jOOQ中，`rangeFollowing(n)`）。
- en: 'Check out the following diagram containing some examples:'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 查看以下包含一些示例的图表：
- en: '![Figure 13.6 – RANGE mode examples'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: '![图13.6 – RANGE模式示例'
- en: '](img/B16833_Figure_13.6.jpg)'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16833_Figure_13.6.jpg)'
- en: Figure 13.6 – RANGE mode examples
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.6 – RANGE模式示例
- en: What's in gray represents the included rows.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 灰色部分表示包含的行。
- en: BETWEEN start_of_frame AND end_of_frame
  id: totrans-359
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: BETWEEN start_of_frame AND end_of_frame
- en: Especially for the `BETWEEN start_of_frame AND end_of_frame` construction, jOOQ
    comes with `fooBetweenCurrentRow()`, `fooBetweenFollowing(n)`, `fooBetweenPreceding(n)`,
    `fooBetweenUnboundedFollowing()`, and `fooBetweenUnboundedPreceding()`. In all
    these methods, `foo` can be replaced with `rows`, `groups`, or `range`.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 尤其是对于`BETWEEN start_of_frame AND end_of_frame`结构，jOOQ提供了`fooBetweenCurrentRow()`，`fooBetweenFollowing(n)`，`fooBetweenPreceding(n)`，`fooBetweenUnboundedFollowing()`，和`fooBetweenUnboundedPreceding()`。在这些方法中，`foo`可以用`rows`，`groups`或`range`替换。
- en: In addition, for creating compound frames, jOOQ provides `andCurrentRow()`,
    `andFollowing(n)`, `andPreceding(n)`, `andUnboundedFollowing()`, and `andUnboundedPreceding()`.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，为了创建复合框架，jOOQ提供了`andCurrentRow()`，`andFollowing(n)`，`andPreceding(n)`，`andUnboundedFollowing()`，和`andUnboundedPreceding()`。
- en: frame_exclusion
  id: totrans-362
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: frame_exclusion
- en: 'Via the `frame_exclusion` optional part, we can exclude certain rows from the
    window frame. `frame_exclusion` works exactly the same for all three modes. Possible
    values are listed here:'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 通过`frame_exclusion`可选部分，我们可以排除窗口框架中的某些行。`frame_exclusion`在所有三种模式下工作方式完全相同。可能的值在此列出：
- en: '`EXCLUDE CURRENT ROW`—Exclude the current row (in jOOQ, `excludeCurrentRow()`).'
  id: totrans-364
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`EXCLUDE CURRENT ROW`—排除当前行（在jOOQ中，`excludeCurrentRow()`）。'
- en: '`EXCLUDE GROUP`—Exclude the current row but also exclude all peer rows (for
    instance, exclude all rows having the same value in the sorting column). In jOOQ,
    we have the `excludeGroup()` method.'
  id: totrans-365
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`EXCLUDE GROUP`—排除当前行，同时也排除所有同等级的行（例如，排除所有在排序列中具有相同值的行）。在jOOQ中，我们有`excludeGroup()`方法。'
- en: '`EXCLUDE TIES`—Exclude all peer rows, but not the current row (in jOOQ, `excludeTies()`).'
  id: totrans-366
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`EXCLUDE TIES`—排除所有同等级的行，但不排除当前行（在jOOQ中，`excludeTies()`）。'
- en: '`EXCLUDE NO OTHERS`—This is the default, and it means to exclude nothing (in
    jOOQ, `excludeNoOthers()`).'
  id: totrans-367
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`EXCLUDE NO OTHERS`—这是默认设置，意味着不排除任何内容（在jOOQ中，`excludeNoOthers()`）。'
- en: 'To better visualize these options, check out the following diagram:'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地可视化这些选项，请查看以下图表：
- en: '![Figure 13.7 – Examples of excluding rows'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: '![图13.7 – 排除行示例'
- en: '](img/B16833_Figure_13.7.jpg)'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16833_Figure_13.7.jpg)'
- en: Figure 13.7 – Examples of excluding rows
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.7 – 排除行示例
- en: 'Speaking about the logical order of operations in SQL, we notice here that
    window functions are placed between `HAVING` and `SELECT`:'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 谈到SQL中的操作逻辑顺序，我们注意到这里窗口函数位于`HAVING`和`SELECT`之间：
- en: '![Figure 13.8 – Logical order of operations in SQL'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: '![图13.8 – SQL中的操作逻辑顺序'
- en: '](img/B16833_Figure_13.8.jpg)'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16833_Figure_13.8.jpg)'
- en: Figure 13.8 – Logical order of operations in SQL
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.8 – SQL中的操作逻辑顺序
- en: Also, I think is useful to explain that window functions can act upon data produced
    by all the previous steps *1-5*, and can be declared in all the following steps
    *7-12* (effectively only in 7 and 10). Before jumping into some window functions
    examples, let's quickly cover a less-known but quite useful SQL clause.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我认为解释窗口函数可以作用于所有前一步骤生成的数据 *1-5*，并且可以在所有后续步骤 *7-12* 中声明（实际上只在 7 和 10 中有效）是有用的。在深入探讨一些窗口函数示例之前，让我们快速了解一下一个不太为人所知但相当有用的
    SQL 子句。
- en: The QUALIFY clause
  id: totrans-377
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`QUALIFY` 子句'
- en: 'Some databases (for instance, Snowflake) support a clause named `QUALIFY`.
    Via this clause, we can filter (apply a predicate) the results of window functions.
    Mainly, a `SELECT … QUALIFY` clause is evaluated after window functions are computed,
    so after `QUALIFY` is `QUALIFY <predicate>`, and in the following screenshot,
    you can see how it makes the difference (this query returns every 10th product
    from the `PRODUCT` table via the `ROW_NUMBER()` window function):'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 一些数据库（例如，Snowflake）支持一个名为 `QUALIFY` 的子句。通过这个子句，我们可以过滤（应用谓词）窗口函数的结果。主要的是，`SELECT
    … QUALIFY` 子句在窗口函数计算后评估，所以 `QUALIFY` 后面是 `<predicate>`，在下面的屏幕截图中，你可以看到它如何产生差异（这个查询通过
    `ROW_NUMBER()` 窗口函数返回 `PRODUCT` 表的每 10 个产品）：
- en: '![Figure 13.9 – Logical order of operations in SQL'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 13.9 – SQL 中的操作顺序'
- en: '](img/B16833_Figure_13.9.jpg)'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16833_Figure_13.9.jpg)'
- en: Figure 13.9 – Logical order of operations in SQL
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.9 – SQL 中的操作顺序
- en: By using the `QUALIFY` clause, we eliminate the subquery and the code is less
    verbose. Even if this clause has poor native support among database vendors, jOOQ
    emulates it for all the supported dialects. Cool, right?! During this chapter,
    you'll see more examples of using the `QUALIFY` clause.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用 `QUALIFY` 子句，我们消除了子查询，代码也更简洁。即使这个子句在数据库供应商中具有较差的原生支持，jOOQ 仍然为所有支持的方言模拟它。酷吧？！在本章中，你将看到更多使用
    `QUALIFY` 子句的示例。
- en: Working with ROW_NUMBER()
  id: totrans-383
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 ROW_NUMBER()
- en: '`ROW_NUMBER()` is a ranking window function that assigns a sequential number
    to each row (it starts from 1). A simple example is shown here:'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: '`ROW_NUMBER()` 是一个排名窗口函数，它为每一行分配一个顺序号（它从 1 开始）。这里有一个简单的示例：'
- en: '![Figure 13.10 – Simple example of ROW_NUMBER()'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 13.10 – ROW_NUMBER() 的简单示例'
- en: '](img/B16833_Figure_13.10.jpg)'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16833_Figure_13.10.jpg)'
- en: Figure 13.10 – Simple example of ROW_NUMBER()
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.10 – ROW_NUMBER() 的简单示例
- en: You already saw an example of paginating database views via `ROW_NUMBER()` in
    [*Chapter 12*](B16833_12.xhtml#_idTextAnchor226), *Pagination and Dynamic Queries*,
    so you should have no problem understanding the next two examples.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经在 [*第 12 章*](B16833_12.xhtml#_idTextAnchor226) 的 *分页和动态查询* 中看到了通过 `ROW_NUMBER()`
    分页数据库视图的示例，所以你应该没有问题理解接下来的两个示例。
- en: 'Let''s assume that we want to compute the median ([https://en.wikipedia.org/wiki/Median](https://en.wikipedia.org/wiki/Median))
    of `PRODUCT.QUANTITY_IN_STOCK`. In Oracle and PostgreSQL, this can be done via
    the built-in `median()` aggregate function, but in MySQL and SQL Server, we have
    to emulate it somehow, and a good approach consists of using `ROW_NUMBER()`, as
    follows:'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想要计算 `PRODUCT.QUANTITY_IN_STOCK` 的中位数 ([https://zh.wikipedia.org/wiki/中位数](https://zh.wikipedia.org/wiki/中位数))。在
    Oracle 和 PostgreSQL 中，这可以通过内置的 `median()` 聚合函数完成，但在 MySQL 和 SQL Server 中，我们必须以某种方式模拟它，而一种好的方法就是使用
    `ROW_NUMBER()`，如下所示：
- en: '[PRE209]'
  id: totrans-390
  prefs: []
  type: TYPE_PRE
  zh: '[PRE209]'
- en: '[PRE210]'
  id: totrans-391
  prefs: []
  type: TYPE_PRE
  zh: '[PRE210]'
- en: '[PRE211]'
  id: totrans-392
  prefs: []
  type: TYPE_PRE
  zh: '[PRE211]'
- en: '[PRE212]'
  id: totrans-393
  prefs: []
  type: TYPE_PRE
  zh: '[PRE212]'
- en: '[PRE213]'
  id: totrans-394
  prefs: []
  type: TYPE_PRE
  zh: '[PRE213]'
- en: '[PRE214]'
  id: totrans-395
  prefs: []
  type: TYPE_PRE
  zh: '[PRE214]'
- en: '[PRE215]'
  id: totrans-396
  prefs: []
  type: TYPE_PRE
  zh: '[PRE215]'
- en: '[PRE216]'
  id: totrans-397
  prefs: []
  type: TYPE_PRE
  zh: '[PRE216]'
- en: 'That was easy! Next, let''s try to solve a different kind of problem, and let''s
    focus on the `ORDER` table. Each order has a `REQUIRED_DATE` and `STATUS` value
    as `Shipped`, `Cancelled`, and so on. Let''s assume that we want to see the clusters
    (also known as islands) represented by continuous periods of time where the score
    (`STATUS`, in this case) stayed the same. An output sample can be seen here:'
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 这很简单！接下来，让我们尝试解决不同类型的问题，并关注 `ORDER` 表。每个订单都有一个 `REQUIRED_DATE` 和 `STATUS` 值，如
    `Shipped`、`Cancelled` 等。假设我们想看到由连续时间段表示的集群（也称为岛屿），其中分数（在这种情况下为 `STATUS`）保持不变。一个输出样本如下所示：
- en: '![Figure 13.11 – Clusters'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 13.11 – 集群'
- en: '](img/B16833_Figure_13.11.jpg)'
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16833_Figure_13.11.jpg)'
- en: Figure 13.11 – Clusters
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.11 – 集群
- en: 'If we have a requirement to solve this problem via `ROW_NUMBER()` and to express
    it in jOOQ, then we may come up with this query:'
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们需要通过 `ROW_NUMBER()` 解决这个问题并在 jOOQ 中表达它，那么我们可能会提出这个查询：
- en: '[PRE217]'
  id: totrans-403
  prefs: []
  type: TYPE_PRE
  zh: '[PRE217]'
- en: '[PRE218]'
  id: totrans-404
  prefs: []
  type: TYPE_PRE
  zh: '[PRE218]'
- en: '[PRE219]'
  id: totrans-405
  prefs: []
  type: TYPE_PRE
  zh: '[PRE219]'
- en: '[PRE220]'
  id: totrans-406
  prefs: []
  type: TYPE_PRE
  zh: '[PRE220]'
- en: '[PRE221]'
  id: totrans-407
  prefs: []
  type: TYPE_PRE
  zh: '[PRE221]'
- en: '[PRE222]'
  id: totrans-408
  prefs: []
  type: TYPE_PRE
  zh: '[PRE222]'
- en: '[PRE223]'
  id: totrans-409
  prefs: []
  type: TYPE_PRE
  zh: '[PRE223]'
- en: '[PRE224]'
  id: totrans-410
  prefs: []
  type: TYPE_PRE
  zh: '[PRE224]'
- en: '[PRE225]'
  id: totrans-411
  prefs: []
  type: TYPE_PRE
  zh: '[PRE225]'
- en: '[PRE226]'
  id: totrans-412
  prefs: []
  type: TYPE_PRE
  zh: '[PRE226]'
- en: '[PRE227]'
  id: totrans-413
  prefs: []
  type: TYPE_PRE
  zh: '[PRE227]'
- en: '[PRE228]'
  id: totrans-414
  prefs: []
  type: TYPE_PRE
  zh: '[PRE228]'
- en: '[PRE229]'
  id: totrans-415
  prefs: []
  type: TYPE_PRE
  zh: '[PRE229]'
- en: You can practice these examples in the *RowNumber* bundled code.
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在捆绑的 *RowNumber* 代码中练习这些示例。
- en: Working with RANK()
  id: totrans-417
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 RANK()
- en: '`RANK()` is a ranking window function that assigns a rank to each row within
    the partition of a result set. The rank of a row is computed as *1 + the number
    of ranks before it*. The columns having the same values get the same ranks; therefore,
    if multiple rows have the same rank, then the rank of the next row is not consecutive.
    Think of a competition where two athletes share the first place (or the gold medal)
    and there is no second place (so, no silver medal). A simple example is provided
    here:'
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: '`RANK()`是一个排名窗口函数，它为结果集分区内的每一行分配一个排名。行的排名计算为*1 + 它之前的排名数量*。具有相同值的列获得相同的排名；因此，如果有多个行具有相同的排名，则下一行的排名不是连续的。想象一下一场比赛中两位运动员共享第一名（或金牌）而没有第二名（因此没有银牌）的情况。这里提供了一个简单的示例：'
- en: '![Figure 13.12 – Simple example of RANK()'
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: '![图13.12 – RANK()的简单示例'
- en: '](img/B16833_Figure_13.12.jpg)'
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: '![图13.12 – 图13.12.jpg'
- en: Figure 13.12 – Simple example of RANK()
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.12 – RANK()的简单示例
- en: 'Here is another example that ranks `ORDER` by year and months of `ORDER.ORDER_DATE`:'
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 这里还有一个按年份和`ORDER.ORDER_DATE`的月份对`ORDER`进行排名的示例：
- en: '[PRE230]'
  id: totrans-423
  prefs: []
  type: TYPE_PRE
  zh: '[PRE230]'
- en: '[PRE231]'
  id: totrans-424
  prefs: []
  type: TYPE_PRE
  zh: '[PRE231]'
- en: '[PRE232]'
  id: totrans-425
  prefs: []
  type: TYPE_PRE
  zh: '[PRE232]'
- en: '[PRE233]'
  id: totrans-426
  prefs: []
  type: TYPE_PRE
  zh: '[PRE233]'
- en: The `year()` and `month()` shortcuts are provided by jOOQ to avoid the usage
    of the SQL `EXTRACT()` function. For instance, `year(ORDER.ORDER_DATE)` can be
    written as `extract(ORDER.ORDER_DATE, DatePart.YEAR)` as well.
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: '`year()`和`month()`快捷方式由jOOQ提供，以避免使用SQL `EXTRACT()`函数。例如，`year(ORDER.ORDER_DATE)`可以写成`extract(ORDER.ORDER_DATE,
    DatePart.YEAR)`。'
- en: 'How about ranking `YEAR` is the partition? This can be expressed in jOOQ like
    this:'
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，将`YEAR`作为分区如何？这可以用jOOQ表示如下：
- en: '[PRE234]'
  id: totrans-429
  prefs: []
  type: TYPE_PRE
  zh: '[PRE234]'
- en: '[PRE235]'
  id: totrans-430
  prefs: []
  type: TYPE_PRE
  zh: '[PRE235]'
- en: '[PRE236]'
  id: totrans-431
  prefs: []
  type: TYPE_PRE
  zh: '[PRE236]'
- en: '[PRE237]'
  id: totrans-432
  prefs: []
  type: TYPE_PRE
  zh: '[PRE237]'
- en: '[PRE238]'
  id: totrans-433
  prefs: []
  type: TYPE_PRE
  zh: '[PRE238]'
- en: '[PRE239]'
  id: totrans-434
  prefs: []
  type: TYPE_PRE
  zh: '[PRE239]'
- en: 'Finally, let''s see an example that ranks the products. Since a partition can
    be defined via multiple columns, we can easily rank the products by `PRODUCT_VENDOR`
    and `PRODUCT_SCALE`, as shown here:'
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们看看一个对产品进行排名的示例。由于可以通过多个列定义分区，我们可以轻松地按`PRODUCT_VENDOR`和`PRODUCT_SCALE`对产品进行排名，如下所示：
- en: '[PRE240]'
  id: totrans-436
  prefs: []
  type: TYPE_PRE
  zh: '[PRE240]'
- en: '[PRE241]'
  id: totrans-437
  prefs: []
  type: TYPE_PRE
  zh: '[PRE241]'
- en: '[PRE242]'
  id: totrans-438
  prefs: []
  type: TYPE_PRE
  zh: '[PRE242]'
- en: '[PRE243]'
  id: totrans-439
  prefs: []
  type: TYPE_PRE
  zh: '[PRE243]'
- en: '[PRE244]'
  id: totrans-440
  prefs: []
  type: TYPE_PRE
  zh: '[PRE244]'
- en: '[PRE245]'
  id: totrans-441
  prefs: []
  type: TYPE_PRE
  zh: '[PRE245]'
- en: You can practice these examples and more in *Rank*.
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在*Rank*中练习这些示例和更多内容。
- en: Working with DENSE_RANK()
  id: totrans-443
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用DENSE_RANK()
- en: '`DENSE_RANK()` is a window function that assigns a rank to each row within
    a partition or result set with no gaps in ranking values. A simple example is
    shown here:'
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: '`DENSE_RANK()`是一个窗口函数，它为分区或结果集中的每一行分配一个排名，排名值之间没有间隔。这里提供了一个简单的示例：'
- en: '![Figure 13.13 – Simple example of DENSE_RANK()'
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: '![图13.13 – DENSE_RANK()的简单示例'
- en: '](img/B16833_Figure_13.13.jpg)'
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: '![图13.13 – 图13.13.jpg'
- en: Figure 13.13 – Simple example of DENSE_RANK()
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.13 – DENSE_RANK()的简单示例
- en: 'In [*Chapter 12*](B16833_12.xhtml#_idTextAnchor226), *Pagination and Dynamic
    Queries*, you already saw an example of using `DENSE_RANK()` for paginating `JOIN`
    statements. Next, let''s have another case of ranking employees (`EMPLOYEE`) in
    offices (`OFFICE`) by their salary (`EMPLOYEE.SALARY`), as follows:'
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第12章*](B16833_12.xhtml#_idTextAnchor226)，*分页和动态查询*中，您已经看到了使用`DENSE_RANK()`进行分页`JOIN`语句的示例。接下来，让我们看看另一个按办公室（`EMPLOYEE`）的薪水（`EMPLOYEE.SALARY`）对员工进行排名的情况，如下所示：
- en: '[PRE246]'
  id: totrans-449
  prefs: []
  type: TYPE_PRE
  zh: '[PRE246]'
- en: '[PRE247]'
  id: totrans-450
  prefs: []
  type: TYPE_PRE
  zh: '[PRE247]'
- en: '[PRE248]'
  id: totrans-451
  prefs: []
  type: TYPE_PRE
  zh: '[PRE248]'
- en: '[PRE249]'
  id: totrans-452
  prefs: []
  type: TYPE_PRE
  zh: '[PRE249]'
- en: '[PRE250]'
  id: totrans-453
  prefs: []
  type: TYPE_PRE
  zh: '[PRE250]'
- en: '[PRE251]'
  id: totrans-454
  prefs: []
  type: TYPE_PRE
  zh: '[PRE251]'
- en: '[PRE252]'
  id: totrans-455
  prefs: []
  type: TYPE_PRE
  zh: '[PRE252]'
- en: '[PRE253]'
  id: totrans-456
  prefs: []
  type: TYPE_PRE
  zh: '[PRE253]'
- en: 'An output fragment looks like this (notice that the employees having the same
    salary get the same rank):'
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: 输出片段看起来像这样（注意具有相同薪水的员工具有相同的排名）：
- en: '![Figure 13.14 – Output'
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: '![图13.14 – 输出'
- en: '](img/B16833_Figure_13.14.jpg)'
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/B16833_Figure_13.14.jpg)'
- en: Figure 13.14 – Output
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.14 – 输出
- en: 'Finally, let''s use `DENSE_RANK()` for selecting the highest salary from each
    office, including duplicates. This time, let''s use the `QUALIFY` clause as well.
    The code is illustrated in the following snippet:'
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们使用`DENSE_RANK()`来选择每个办公室的最高薪水，包括重复项。这次，让我们也使用`QUALIFY`子句。代码如下所示：
- en: '[PRE254]'
  id: totrans-462
  prefs: []
  type: TYPE_PRE
  zh: '[PRE254]'
- en: '[PRE255]'
  id: totrans-463
  prefs: []
  type: TYPE_PRE
  zh: '[PRE255]'
- en: '[PRE256]'
  id: totrans-464
  prefs: []
  type: TYPE_PRE
  zh: '[PRE256]'
- en: '[PRE257]'
  id: totrans-465
  prefs: []
  type: TYPE_PRE
  zh: '[PRE257]'
- en: '[PRE258]'
  id: totrans-466
  prefs: []
  type: TYPE_PRE
  zh: '[PRE258]'
- en: '[PRE259]'
  id: totrans-467
  prefs: []
  type: TYPE_PRE
  zh: '[PRE259]'
- en: '[PRE260]'
  id: totrans-468
  prefs: []
  type: TYPE_PRE
  zh: '[PRE260]'
- en: '[PRE261]'
  id: totrans-469
  prefs: []
  type: TYPE_PRE
  zh: '[PRE261]'
- en: '[PRE262]'
  id: totrans-470
  prefs: []
  type: TYPE_PRE
  zh: '[PRE262]'
- en: 'Before going further, here is a nice read: [https://blog.jooq.org/2014/08/12/the-difference-between-row_number-rank-and-dense_rank/](https://blog.jooq.org/2014/08/12/the-difference-between-row_number-rank-and-dense_rank/).
    You can check out these examples in the *DenseRank* bundled code.'
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前，这里有一篇不错的阅读材料：[https://blog.jooq.org/2014/08/12/the-difference-between-row_number-rank-and-dense_rank/](https://blog.jooq.org/2014/08/12/the-difference-between-row_number-rank-and-dense_rank/)。您可以在*DenseRank*捆绑代码中查看这些示例。
- en: Working with PERCENT_RANK()
  id: totrans-472
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用PERCENT_RANK()
- en: The `PERCENT_RANK()` window function calculates the percentile rankings `((rank
    - 1) / (total_rows - 1))` of rows in a result set and returns a value between
    0 exclusive and 1 inclusive. The first row in the result set always has the percent
    rank equal to 0\. This function doesn't count `NULL` values and is nondeterministic.
    Usually, the final result is multiplied by 100 to express as a percentage.
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: '`PERCENT_RANK()`窗口函数计算结果集中行的百分位数排名`((rank - 1) / (total_rows - 1))`，并返回介于0（不包括）和1（包括）之间的值。结果集中的第一行始终具有等于0的百分排名。此函数不计`NULL`值，并且是非确定的。通常，最终结果乘以100以表示为百分比。'
- en: 'The best way to understand this function is via an example. Let''s assume that
    we want to compute the percentile rank for employees in each office by their salaries.
    The query expressed in jOOQ will look like this:'
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: 通过示例了解此函数的最佳方式。假设我们想要计算每个办公室员工的薪资百分位排名。用 jOOQ 表达的查询将如下所示：
- en: '[PRE263]'
  id: totrans-475
  prefs: []
  type: TYPE_PRE
  zh: '[PRE263]'
- en: '[PRE264]'
  id: totrans-476
  prefs: []
  type: TYPE_PRE
  zh: '[PRE264]'
- en: '[PRE265]'
  id: totrans-477
  prefs: []
  type: TYPE_PRE
  zh: '[PRE265]'
- en: '[PRE266]'
  id: totrans-478
  prefs: []
  type: TYPE_PRE
  zh: '[PRE266]'
- en: '[PRE267]'
  id: totrans-479
  prefs: []
  type: TYPE_PRE
  zh: '[PRE267]'
- en: '[PRE268]'
  id: totrans-480
  prefs: []
  type: TYPE_PRE
  zh: '[PRE268]'
- en: '[PRE269]'
  id: totrans-481
  prefs: []
  type: TYPE_PRE
  zh: '[PRE269]'
- en: '[PRE270]'
  id: totrans-482
  prefs: []
  type: TYPE_PRE
  zh: '[PRE270]'
- en: '[PRE271]'
  id: totrans-483
  prefs: []
  type: TYPE_PRE
  zh: '[PRE271]'
- en: '[PRE272]'
  id: totrans-484
  prefs: []
  type: TYPE_PRE
  zh: '[PRE272]'
- en: 'The following screenshot represents a snippet of the result:'
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图表示结果的一个片段：
- en: '![Figure 13.15 – Percent rank output'
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 13.15 – 百分位排名输出'
- en: '](img/B16833_Figure_13.15.jpg)'
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16833_Figure_13.15.jpg)'
- en: Figure 13.15 – Percent rank output
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.15 – 百分位排名输出
- en: So, how do we interpret this output? A percentile rank is commonly defined as
    the proportion of results (or scores) in a distribution that a certain result
    (or score) is greater than or equal to (sometimes only greater than counts). For
    example, if you get a result/score of 90 on a certain test and this result/score
    was greater than (or equal to) the results/scores of 75% of the participants taking
    the test, then your percentile rank is 75\. You would be in the 75th percentile.
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，我们如何解释这个输出？百分位排名通常定义为在分布中，某个结果（或分数）大于或等于（有时仅大于）的结果（或分数）的比例。例如，如果你在某个测试中得到了
    90 分，而这个分数大于（或等于）参加测试的 75% 的参与者的分数，那么你的百分位排名是 75。你将处于第 75 个百分位。
- en: In other words, in office 1, we can say that 40% of employees have salaries
    lower than *Anthony Bow* (check the third row), so *Anthony Bow* is in the 40th
    percentile. Also, in office 1, *Diane Murphy* has the highest salary since 100%
    of employees have salaries lower than her salary (check the sixth row). When the
    current row is the first in the partition then there is no previous data to consider,
    therefore the percentile rank is 0\. An interesting case is *George Vanauf* (last
    row) having a percentile rank of 0%. Because his salary (*$55,000*) is equal to
    the salary of *Foon Yue Tseng*, we can say that nobody has a salary lower than
    his.
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，在办公室 1 中，我们可以说 40% 的员工薪资低于 *Anthony Bow*（查看第三行），因此 *Anthony Bow* 处于第 40
    个百分位。同样，在办公室 1 中，*Diane Murphy* 的薪资最高，因为 100% 的员工薪资低于她的薪资（查看第六行）。当当前行是分区中的第一行时，没有先前数据需要考虑，因此百分位排名为
    0。一个有趣的案例是 *George Vanauf*（最后一行），其百分位排名为 0%。因为他的薪资（*$55,000*）与 *Foon Yue Tseng*
    的薪资相同，我们可以这样说，没有人有比他更低的薪资。
- en: 'A common use case for `PERCENT_RANK()` is to categorize data into custom groups
    (also known as custom binning). For example, let''s consider that we want to count
    departments having a low (smaller than the 20th percentile), medium (between the
    20th and 80th percentile), and high (greater than 80th percentile) profit. Here''s
    the code we''d use to calculate this:'
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
  zh: '`PERCENT_RANK()` 函数的一个常见用途是将数据分类到自定义组（也称为自定义分箱）。例如，让我们考虑我们想要计算利润低（低于第 20 个百分位数）、中等（介于第
    20 个和第 80 个百分位数之间）和高（高于第 80 个百分位数）的部门。以下是计算此数据的代码：'
- en: '[PRE273]'
  id: totrans-492
  prefs: []
  type: TYPE_PRE
  zh: '[PRE273]'
- en: '[PRE274]'
  id: totrans-493
  prefs: []
  type: TYPE_PRE
  zh: '[PRE274]'
- en: '[PRE275]'
  id: totrans-494
  prefs: []
  type: TYPE_PRE
  zh: '[PRE275]'
- en: '[PRE276]'
  id: totrans-495
  prefs: []
  type: TYPE_PRE
  zh: '[PRE276]'
- en: '[PRE277]'
  id: totrans-496
  prefs: []
  type: TYPE_PRE
  zh: '[PRE277]'
- en: '[PRE278]'
  id: totrans-497
  prefs: []
  type: TYPE_PRE
  zh: '[PRE278]'
- en: '[PRE279]'
  id: totrans-498
  prefs: []
  type: TYPE_PRE
  zh: '[PRE279]'
- en: '[PRE280]'
  id: totrans-499
  prefs: []
  type: TYPE_PRE
  zh: '[PRE280]'
- en: '[PRE281]'
  id: totrans-500
  prefs: []
  type: TYPE_PRE
  zh: '[PRE281]'
- en: '[PRE282]'
  id: totrans-501
  prefs: []
  type: TYPE_PRE
  zh: '[PRE282]'
- en: '[PRE283]'
  id: totrans-502
  prefs: []
  type: TYPE_PRE
  zh: '[PRE283]'
- en: You can practice these examples—and more—in the *PercentRank* bundled code.
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 *PercentRank* 包含的代码中练习这些示例——以及更多。
- en: Working with CUME_DIST()
  id: totrans-504
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 `CUME_DIST()`
- en: '`CUME_DIST()` is a window function that computes the cumulative distribution
    of a value within a set of values. In other words, `CUME_DIST()` divides the number
    of rows having values less than or equal to the current row''s value by the total
    number of rows. The returned value is greater than zero and less than or equal
    to one (0 < `CUME_DIST()` <= 1). The columns having repeated values get the same
    `CUME_DIST()` value. A simple example is provided here:'
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
  zh: '`CUME_DIST()` 是一个窗口函数，它计算值在值集中的累积分布。换句话说，`CUME_DIST()` 将具有值的行数除以当前行值的总行数。返回的值大于零且小于或等于一（0
    < `CUME_DIST()` <= 1）。具有重复值的列将获得相同的 `CUME_DIST()` 值。这里提供了一个简单的示例：'
- en: '![Figure 13.16 – Simple example of CUME_DIST()'
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 13.16 – `CUME_DIST()` 的简单示例'
- en: '](img/B16833_Figure_13.16.jpg)'
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16833_Figure_13.16.jpg)'
- en: Figure 13.16 – Simple example of CUME_DIST()
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.16 – `CUME_DIST()` 的简单示例
- en: 'So, we have a result set of 23 rows. For the first row (denoted as A), `CUME_DIST()`
    finds the number of rows having a value less than or equal to *50000*. The result
    is 4\. Then, the function divides 4 by the total number of rows, which is 23:
    4/23\. The result is 0.17 or 17%. The same logic is applied to the next rows.'
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们有一个包含 23 行的结果集。对于第一行（标记为 A），`CUME_DIST()` 函数找到值小于或等于 *50000* 的行数。结果是 4。然后，该函数将
    4 除以总行数，即 23：4/23。结果是 0.17 或 17%。相同的逻辑应用于下一行。
- en: 'How about fetching the top 25% of sales in *2003* and *2004*? This can be solved
    via `CUME_DIST()` and the handy `QUALIFY` clause, as follows:'
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
  zh: 如何获取2003年和2004年销售的前25%？这可以通过`CUME_DIST()`和方便的`QUALIFY`子句来解决，如下所示：
- en: '[PRE284]'
  id: totrans-511
  prefs: []
  type: TYPE_PRE
  zh: '[PRE284]'
- en: '[PRE285]'
  id: totrans-512
  prefs: []
  type: TYPE_PRE
  zh: '[PRE285]'
- en: '[PRE286]'
  id: totrans-513
  prefs: []
  type: TYPE_PRE
  zh: '[PRE286]'
- en: '[PRE287]'
  id: totrans-514
  prefs: []
  type: TYPE_PRE
  zh: '[PRE287]'
- en: '[PRE288]'
  id: totrans-515
  prefs: []
  type: TYPE_PRE
  zh: '[PRE288]'
- en: '[PRE289]'
  id: totrans-516
  prefs: []
  type: TYPE_PRE
  zh: '[PRE289]'
- en: '[PRE290]'
  id: totrans-517
  prefs: []
  type: TYPE_PRE
  zh: '[PRE290]'
- en: '[PRE291]'
  id: totrans-518
  prefs: []
  type: TYPE_PRE
  zh: '[PRE291]'
- en: '[PRE292]'
  id: totrans-519
  prefs: []
  type: TYPE_PRE
  zh: '[PRE292]'
- en: You can practice these examples in the *CumeDist* bundled code.
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在捆绑的*CumeDist*代码中练习这些示例。
- en: Working with LEAD()/LAG()
  id: totrans-521
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用LEAD()/LAG()
- en: '`LEAD()` is a window function that looks forward a specified number of rows
    (offset, by default 1) and accesses that row from the current row. `LAG()` works
    the same as `LEAD()`, but it looks back. For both, we can optionally specify a
    default value to be returned when there is no subsequent row (`LEAD()`) or there
    is no preceding row `(LAG()`) instead of returning `NULL`. A simple example is
    provided here:'
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
  zh: '`LEAD()`是一个窗口函数，它向前查看指定数量的行（默认为1）并从当前行访问该行。`LAG()`与`LEAD()`的工作方式相同，但它向后查看。对于这两个函数，我们可以选择指定一个默认值，当没有后续行（`LEAD()`）或没有前导行（`LAG()`）时返回该默认值而不是返回`NULL`。这里提供了一个简单的示例：'
- en: '![Figure 13.17 – Simple example of LEAD() and LAG()'
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
  zh: '![图13.17 – LEAD()和LAG()的简单示例'
- en: '](img/B16833_Figure_13.17.jpg)'
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16833_Figure_13.17.jpg)'
- en: Figure 13.17 – Simple example of LEAD() and LAG()
  id: totrans-525
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.17 – LEAD()和LAG()的简单示例
- en: Besides the `lead`/`lag``(Field<T> field)` syntax used in this example, jOOQ
    also exposes `lead`/`lag(Field<T> field, int offset)`, `lead``/lag(Field<T> field,
    int offset, Field<T> defaultValue)`, and `lead/lag``(Field<T> field, int offset,
    T defaultValue)`. In this example, `lead`/`lag(ORDER.ORDER_DATE)` uses an offset
    of 1, so is the same thing as `lead`/`lag(ORDER.ORDER_DATE, 1)`.
  id: totrans-526
  prefs: []
  type: TYPE_NORMAL
  zh: 除了在这个示例中使用的`lead`/`lag`(Field<T> field)`语法外，jOOQ还公开了`lead`/`lag(Field<T> field,
    int offset)`、`lead`/`lag(Field<T> field, int offset, Field<T> defaultValue)`和`lead/lag`(Field<T>
    field, int offset, T defaultValue)`。在这个示例中，`lead`/`lag(ORDER.ORDER_DATE)`使用偏移量1，所以与`lead`/`lag(ORDER.ORDER_DATE,
    1)`是同一件事。
- en: 'Here is an example that, for each employee, displays the salary and next salary
    using the office as a partition of `LEAD()`. When `LEAD()` reaches the end of
    the partition, we use 0 instead of `NULL`:'
  id: totrans-527
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个示例，对于每个员工，使用办公室作为`LEAD()`的分区来显示工资和下一份工资。当`LEAD()`达到分区的末尾时，我们使用0而不是`NULL`：
- en: '[PRE293]'
  id: totrans-528
  prefs: []
  type: TYPE_PRE
  zh: '[PRE293]'
- en: '[PRE294]'
  id: totrans-529
  prefs: []
  type: TYPE_PRE
  zh: '[PRE294]'
- en: '[PRE295]'
  id: totrans-530
  prefs: []
  type: TYPE_PRE
  zh: '[PRE295]'
- en: '[PRE296]'
  id: totrans-531
  prefs: []
  type: TYPE_PRE
  zh: '[PRE296]'
- en: '[PRE297]'
  id: totrans-532
  prefs: []
  type: TYPE_PRE
  zh: '[PRE297]'
- en: '[PRE298]'
  id: totrans-533
  prefs: []
  type: TYPE_PRE
  zh: '[PRE298]'
- en: '[PRE299]'
  id: totrans-534
  prefs: []
  type: TYPE_PRE
  zh: '[PRE299]'
- en: '[PRE300]'
  id: totrans-535
  prefs: []
  type: TYPE_PRE
  zh: '[PRE300]'
- en: '[PRE301]'
  id: totrans-536
  prefs: []
  type: TYPE_PRE
  zh: '[PRE301]'
- en: 'Next, let''s tackle an example of calculating the Month-Over-Month (MOM) growth
    rate. This financial indicator is useful for benchmarking the business, and we
    already have it in the `SALE.REVENUE_GROWTH` column. But here is the query that
    can calculate it via the `LAG()` function for the year *2004*:'
  id: totrans-537
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们解决一个计算月度（MOM）增长率的示例。这个财务指标对于基准测试业务非常有用，我们已经在`SALE.REVENUE_GROWTH`列中有了它。但这里是通过`LAG()`函数计算2004年*的查询：
- en: '[PRE302]'
  id: totrans-538
  prefs: []
  type: TYPE_PRE
  zh: '[PRE302]'
- en: '[PRE303]'
  id: totrans-539
  prefs: []
  type: TYPE_PRE
  zh: '[PRE303]'
- en: '[PRE304]'
  id: totrans-540
  prefs: []
  type: TYPE_PRE
  zh: '[PRE304]'
- en: '[PRE305]'
  id: totrans-541
  prefs: []
  type: TYPE_PRE
  zh: '[PRE305]'
- en: '[PRE306]'
  id: totrans-542
  prefs: []
  type: TYPE_PRE
  zh: '[PRE306]'
- en: '[PRE307]'
  id: totrans-543
  prefs: []
  type: TYPE_PRE
  zh: '[PRE307]'
- en: '[PRE308]'
  id: totrans-544
  prefs: []
  type: TYPE_PRE
  zh: '[PRE308]'
- en: '[PRE309]'
  id: totrans-545
  prefs: []
  type: TYPE_PRE
  zh: '[PRE309]'
- en: '[PRE310]'
  id: totrans-546
  prefs: []
  type: TYPE_PRE
  zh: '[PRE310]'
- en: For more examples, including an example of funneling drop-off metrics and one
    about time-series analysis, please check out the *LeadLag* bundled code.
  id: totrans-547
  prefs: []
  type: TYPE_NORMAL
  zh: 对于更多示例，包括关于漏斗流失指标和时间序列分析的示例，请查看捆绑的*LeadLag*代码。
- en: Working with NTILE()
  id: totrans-548
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用NTILE()
- en: '`NTILE(n)` is a window function commonly used for distributing the number of
    rows in the specified `n` number of groups or buckets. Each bucket has a number
    (starting at 1) that indicates the bucket to which this row belongs. A simple
    example is provided here:'
  id: totrans-549
  prefs: []
  type: TYPE_NORMAL
  zh: '`NTILE(n)`是一个窗口函数，通常用于将指定`n`个组或桶中的行数进行分配。每个桶都有一个数字（从1开始），表示该行属于哪个桶。这里提供了一个简单的示例：'
- en: '![Figure 13.18 – Simple example of NTILE()'
  id: totrans-550
  prefs: []
  type: TYPE_NORMAL
  zh: '![图13.18 – NTILE()的简单示例'
- en: '](img/B16833_Figure_13.18.jpg)'
  id: totrans-551
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16833_Figure_13.18.jpg)'
- en: Figure 13.18 – Simple example of NTILE()
  id: totrans-552
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.18 – NTILE()的简单示例
- en: So, in this example, we've distributed `EMPLOYEE.SALARY` in 10 buckets. `NTILE()`
    strives to determine how many rows should be in each bucket in order to provide
    the number of buckets and to keep them approximately equal.
  id: totrans-553
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在这个示例中，我们将`EMPLOYEE.SALARY`分布在10个桶中。`NTILE()`努力确定每个桶应该有多少行，以便提供桶的数量并使它们大致相等。
- en: Among its use cases, `NTILE()` is useful for calculating Recency, Frequency,
    and Monetary (RFM) indices ([https://en.wikipedia.org/wiki/RFM_(market_research)](https://en.wikipedia.org/wiki/RFM_(market_research))).
    In short, the RFM analysis is basically an indexing technique that relies on past
    purchase behavior to determine different segments of customers.
  id: totrans-554
  prefs: []
  type: TYPE_NORMAL
  zh: 在其用例中，`NTILE()`对于计算最近度、频率和货币（RFM）指数非常有用（[https://en.wikipedia.org/wiki/RFM_(market_research)](https://en.wikipedia.org/wiki/RFM_(market_research))).
    简而言之，RFM分析基本上是一种索引技术，它依赖于过去的购买行为来确定不同的客户细分市场。
- en: In our case, the past purchase behavior of each customer (`ORDER.CUSTOMER_NUMBER`)
    is stored in the `ORDER` table, especially in `ORDER.ORDER_ID`, `ORDER.ORDER_DATE`,
    and `ORDER.AMOUNT`.
  id: totrans-555
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的案例中，每个客户的过去购买行为（`ORDER.CUSTOMER_NUMBER`）存储在`ORDER`表中，特别是在`ORDER.ORDER_ID`、`ORDER.ORDER_DATE`和`ORDER.AMOUNT`中。
- en: 'Based on this information, we attempt to divide customers into four equal groups
    based on the distribution of values for R, F, and M. Four equal groups across
    RFM variables produce 43=64 potential segments. The result consists of a table
    having a score between 1 and 4 for each of the quantiles (R, F, and M). The query
    speaks for itself, as we can see here:'
  id: totrans-556
  prefs: []
  type: TYPE_NORMAL
  zh: 根据这些信息，我们尝试根据R、F和M的值分布将客户分为四个相等的组。RFM变量上的四个相等组产生43=64个潜在细分市场。结果是一个表格，其中每个分位数（R、F和M）都有一个介于1和4之间的分数。查询本身就可以说明一切，如下所示：
- en: '[PRE311]'
  id: totrans-557
  prefs: []
  type: TYPE_PRE
  zh: '[PRE311]'
- en: '[PRE312]'
  id: totrans-558
  prefs: []
  type: TYPE_PRE
  zh: '[PRE312]'
- en: '[PRE313]'
  id: totrans-559
  prefs: []
  type: TYPE_PRE
  zh: '[PRE313]'
- en: '[PRE314]'
  id: totrans-560
  prefs: []
  type: TYPE_PRE
  zh: '[PRE314]'
- en: '[PRE315]'
  id: totrans-561
  prefs: []
  type: TYPE_PRE
  zh: '[PRE315]'
- en: '[PRE316]'
  id: totrans-562
  prefs: []
  type: TYPE_PRE
  zh: '[PRE316]'
- en: '[PRE317]'
  id: totrans-563
  prefs: []
  type: TYPE_PRE
  zh: '[PRE317]'
- en: '[PRE318]'
  id: totrans-564
  prefs: []
  type: TYPE_PRE
  zh: '[PRE318]'
- en: '[PRE319]'
  id: totrans-565
  prefs: []
  type: TYPE_PRE
  zh: '[PRE319]'
- en: '[PRE320]'
  id: totrans-566
  prefs: []
  type: TYPE_PRE
  zh: '[PRE320]'
- en: '[PRE321]'
  id: totrans-567
  prefs: []
  type: TYPE_PRE
  zh: '[PRE321]'
- en: '[PRE322]'
  id: totrans-568
  prefs: []
  type: TYPE_PRE
  zh: '[PRE322]'
- en: '[PRE323]'
  id: totrans-569
  prefs: []
  type: TYPE_PRE
  zh: '[PRE323]'
- en: '[PRE324]'
  id: totrans-570
  prefs: []
  type: TYPE_PRE
  zh: '[PRE324]'
- en: 'A sample output is provided here:'
  id: totrans-571
  prefs: []
  type: TYPE_NORMAL
  zh: 这里提供了一个示例输出：
- en: '![Figure 13.19 – RFM sample'
  id: totrans-572
  prefs: []
  type: TYPE_NORMAL
  zh: '![图13.19 – RFM示例'
- en: '](img/B16833_Figure_13.19.jpg)'
  id: totrans-573
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/B16833_Figure_13.19.jpg)'
- en: Figure 13.19 – RFM sample
  id: totrans-574
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.19 – RFM示例
- en: By combining the RFM result as R*100+F*10+M, we can obtain an aggregate score.
    This is available next to more examples in the *Ntile* bundled code.
  id: totrans-575
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将RFM结果组合为R*100+F*10+M，我们可以获得一个综合评分。这在*Ntile*捆绑代码中的更多示例旁边可用。
- en: Working with FIRST_VALUE() and LAST_VALUE()
  id: totrans-576
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用FIRST_VALUE()和LAST_VALUE()
- en: '`FIRST_VALUE(expr)` returns the value of the specified expression (`expr`)
    with respect to the first row in the window frame.'
  id: totrans-577
  prefs: []
  type: TYPE_NORMAL
  zh: '`FIRST_VALUE(expr)`返回相对于窗口帧中第一行的指定表达式(`expr`)的值。'
- en: '`NTH_VALUE(expr, offset)` returns the value of the specified expression (`expr`)
    with respect to the offset row in the window frame.'
  id: totrans-578
  prefs: []
  type: TYPE_NORMAL
  zh: '`NTH_VALUE(expr, offset)`返回相对于窗口帧中偏移行指定的表达式(`expr`)的值。'
- en: '`LAST_VALUE(expr)` returns the value of the specified expression (`expr`) with
    respect to the last row in the window frame.'
  id: totrans-579
  prefs: []
  type: TYPE_NORMAL
  zh: '`LAST_VALUE(expr)`返回相对于窗口帧中最后一行的指定表达式(`expr`)的值。'
- en: 'Let''s assume that our goal is to obtain the cheapest and most expensive product
    per product line, as in the following screenshot:'
  id: totrans-580
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们的目标是获取每个产品线的最便宜和最贵的产品，如下面的截图所示：
- en: '![Figure 13.20 – Cheapest and most expensive product per product line'
  id: totrans-581
  prefs: []
  type: TYPE_NORMAL
  zh: '![图13.20 – 每个产品线的最便宜和最贵的产品'
- en: '](img/B16833_Figure_13.20.jpg)'
  id: totrans-582
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/B16833_Figure_13.20.jpg)'
- en: Figure 13.20 – Cheapest and most expensive product per product line
  id: totrans-583
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.20 – 每个产品线的最便宜和最贵的产品
- en: 'Accomplishing this task via `FIRST_VALUE()` and `LAST_VALUE()` can be done
    like this:'
  id: totrans-584
  prefs: []
  type: TYPE_NORMAL
  zh: 通过`FIRST_VALUE()`和`LAST_VALUE()`完成此任务可以这样做：
- en: '[PRE325]'
  id: totrans-585
  prefs: []
  type: TYPE_PRE
  zh: '[PRE325]'
- en: '[PRE326]'
  id: totrans-586
  prefs: []
  type: TYPE_PRE
  zh: '[PRE326]'
- en: '[PRE327]'
  id: totrans-587
  prefs: []
  type: TYPE_PRE
  zh: '[PRE327]'
- en: '[PRE328]'
  id: totrans-588
  prefs: []
  type: TYPE_PRE
  zh: '[PRE328]'
- en: '[PRE329]'
  id: totrans-589
  prefs: []
  type: TYPE_PRE
  zh: '[PRE329]'
- en: '[PRE330]'
  id: totrans-590
  prefs: []
  type: TYPE_PRE
  zh: '[PRE330]'
- en: '[PRE331]'
  id: totrans-591
  prefs: []
  type: TYPE_PRE
  zh: '[PRE331]'
- en: '[PRE332]'
  id: totrans-592
  prefs: []
  type: TYPE_PRE
  zh: '[PRE332]'
- en: '[PRE333]'
  id: totrans-593
  prefs: []
  type: TYPE_PRE
  zh: '[PRE333]'
- en: '[PRE334]'
  id: totrans-594
  prefs: []
  type: TYPE_PRE
  zh: '[PRE334]'
- en: '[PRE335]'
  id: totrans-595
  prefs: []
  type: TYPE_PRE
  zh: '[PRE335]'
- en: '[PRE336]'
  id: totrans-596
  prefs: []
  type: TYPE_PRE
  zh: '[PRE336]'
- en: If the window frame is not specified, then the default window frame depends
    on the presence of `ORDER BY`. If `ORDER BY` is present, then the window frame
    is `RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW`. If `ORDER BY` is not present,
    then the window frame is `RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING`.
  id: totrans-597
  prefs: []
  type: TYPE_NORMAL
  zh: 如果未指定窗口帧，则默认窗口帧取决于`ORDER BY`的存在。如果存在`ORDER BY`，则窗口帧为`RANGE BETWEEN UNBOUNDED
    PRECEDING AND CURRENT ROW`。如果不存在`ORDER BY`，则窗口帧为`RANGE BETWEEN UNBOUNDED PRECEDING
    AND UNBOUNDED FOLLOWING`。
- en: Having this in mind, in our case, `FIRST_VALUE()` can rely on the default window
    frame to return the first row of the partition, which is the smallest price. On
    the other hand, `LAST_VALUE()` must explicitly define the window frame as `RANGE
    BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING` to return the highest price.
  id: totrans-598
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到这一点，在我们的情况下，`FIRST_VALUE()`可以依赖于默认的窗口帧来返回分区中的第一行，即最低价格。另一方面，`LAST_VALUE()`必须明确定义窗口帧为`RANGE
    BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING`以返回最高价格。
- en: 'Here is another example of fetching the second most expensive product by product
    line via `NTH_VALUE()`:'
  id: totrans-599
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是另一个通过`NTH_VALUE()`获取每个产品线的第二贵产品的示例：
- en: '[PRE337]'
  id: totrans-600
  prefs: []
  type: TYPE_PRE
  zh: '[PRE337]'
- en: '[PRE338]'
  id: totrans-601
  prefs: []
  type: TYPE_PRE
  zh: '[PRE338]'
- en: '[PRE339]'
  id: totrans-602
  prefs: []
  type: TYPE_PRE
  zh: '[PRE339]'
- en: '[PRE340]'
  id: totrans-603
  prefs: []
  type: TYPE_PRE
  zh: '[PRE340]'
- en: '[PRE341]'
  id: totrans-604
  prefs: []
  type: TYPE_PRE
  zh: '[PRE341]'
- en: '[PRE342]'
  id: totrans-605
  prefs: []
  type: TYPE_PRE
  zh: '[PRE342]'
- en: '[PRE343]'
  id: totrans-606
  prefs: []
  type: TYPE_PRE
  zh: '[PRE343]'
- en: '[PRE344]'
  id: totrans-607
  prefs: []
  type: TYPE_PRE
  zh: '[PRE344]'
- en: '[PRE345]'
  id: totrans-608
  prefs: []
  type: TYPE_PRE
  zh: '[PRE345]'
- en: 'The preceding query orders `BUY_PRICE` in descending order for fetching the
    second most expensive product by product line. But this is mainly the second row
    from the bottom, therefore we can rely on the `FROM LAST` clause (in jOOQ, `fromLast()`)
    to express it, as follows:'
  id: totrans-609
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的查询按降序对`BUY_PRICE`进行排序，以获取每个产品线的第二贵产品。但这主要是从底部开始的第二行，因此我们可以依赖于`FROM LAST`子句（在jOOQ中为`fromLast()`)来表达它，如下所示：
- en: '[PRE346]'
  id: totrans-610
  prefs: []
  type: TYPE_PRE
  zh: '[PRE346]'
- en: '[PRE347]'
  id: totrans-611
  prefs: []
  type: TYPE_PRE
  zh: '[PRE347]'
- en: '[PRE348]'
  id: totrans-612
  prefs: []
  type: TYPE_PRE
  zh: '[PRE348]'
- en: '[PRE349]'
  id: totrans-613
  prefs: []
  type: TYPE_PRE
  zh: '[PRE349]'
- en: '[PRE350]'
  id: totrans-614
  prefs: []
  type: TYPE_PRE
  zh: '[PRE350]'
- en: '[PRE351]'
  id: totrans-615
  prefs: []
  type: TYPE_PRE
  zh: '[PRE351]'
- en: '[PRE352]'
  id: totrans-616
  prefs: []
  type: TYPE_PRE
  zh: '[PRE352]'
- en: '[PRE353]'
  id: totrans-617
  prefs: []
  type: TYPE_PRE
  zh: '[PRE353]'
- en: '[PRE354]'
  id: totrans-618
  prefs: []
  type: TYPE_PRE
  zh: '[PRE354]'
- en: This query works fine in Oracle, which supports `FROM FIRST` (`fromFirst()`),
    `FROM LAST` (`fromLast()`), `IGNORE NULLS` (`ignoreNulls()`), and `RESPECT NULLS`
    (`respectNulls()`).
  id: totrans-619
  prefs: []
  type: TYPE_NORMAL
  zh: 此查询在Oracle中运行良好，Oracle支持`FROM FIRST` (`fromFirst()`), `FROM LAST` (`fromLast()`),
    `IGNORE NULLS` (`ignoreNulls()`), 和 `RESPECT NULLS` (`respectNulls()`).
- en: You can practice these examples in the *FirstLastNth* bundled code.
  id: totrans-620
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在*FirstLastNth*捆绑代码中练习这些示例。
- en: Working with RATIO_TO_REPORT()
  id: totrans-621
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用RATIO_TO_REPORT()
- en: '`RATIO_TO_REPORT(expr)` computes the ratio of the specified value to the sum
    of values in the set. If the given `expr` value is evaluated as `null`, then this
    function returns `null`. A simple example is provided here:'
  id: totrans-622
  prefs: []
  type: TYPE_NORMAL
  zh: '`RATIO_TO_REPORT(expr)`计算指定值与集合中值的总和的比率。如果给定的`expr`值评估为`null`，则此函数返回`null`。这里提供了一个简单的示例：'
- en: '![Figure 13.21 – Simple example of RATIO_TO_REPORT()'
  id: totrans-623
  prefs: []
  type: TYPE_NORMAL
  zh: '![图13.21 – RATIO_TO_REPORT()的简单示例](img/B16833_Figure_13.22.jpg)'
- en: '](img/B16833_Figure_13.21.jpg)'
  id: totrans-624
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16833_Figure_13.21.jpg)'
- en: Figure 13.21 – Simple example of RATIO_TO_REPORT()
  id: totrans-625
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.21 – RATIO_TO_REPORT()的简单示例
- en: 'For instance, for the first row, the ratio is computed as 51241.54 / 369418.38,
    where 369418.38 is the sum of all sales. After applying the `round()` function,
    the result is 0.14 or 14%, but if we want to compute the ratio of the current
    sale per fiscal year, we can do it via `PARTITION BY`, as shown here:'
  id: totrans-626
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，对于第一行，比率为51241.54 / 369418.38，其中369418.38是所有销售额的总和。在应用`round()`函数后，结果为0.14或14%，但如果我们想计算当前财年销售额的比率，可以通过`PARTITION
    BY`来实现，如下所示：
- en: '[PRE355]'
  id: totrans-627
  prefs: []
  type: TYPE_PRE
  zh: '[PRE355]'
- en: '[PRE356]'
  id: totrans-628
  prefs: []
  type: TYPE_PRE
  zh: '[PRE356]'
- en: '[PRE357]'
  id: totrans-629
  prefs: []
  type: TYPE_PRE
  zh: '[PRE357]'
- en: '[PRE358]'
  id: totrans-630
  prefs: []
  type: TYPE_PRE
  zh: '[PRE358]'
- en: '[PRE359]'
  id: totrans-631
  prefs: []
  type: TYPE_PRE
  zh: '[PRE359]'
- en: 'Let''s compute the ratio of the current sum of salaries per employee and express
    it in percentages, like so:'
  id: totrans-632
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们计算每个员工当前工资总和的比率，并以百分比的形式表示，如下所示：
- en: '[PRE360]'
  id: totrans-633
  prefs: []
  type: TYPE_PRE
  zh: '[PRE360]'
- en: '[PRE361]'
  id: totrans-634
  prefs: []
  type: TYPE_PRE
  zh: '[PRE361]'
- en: '[PRE362]'
  id: totrans-635
  prefs: []
  type: TYPE_PRE
  zh: '[PRE362]'
- en: '[PRE363]'
  id: totrans-636
  prefs: []
  type: TYPE_PRE
  zh: '[PRE363]'
- en: '[PRE364]'
  id: totrans-637
  prefs: []
  type: TYPE_PRE
  zh: '[PRE364]'
- en: '[PRE365]'
  id: totrans-638
  prefs: []
  type: TYPE_PRE
  zh: '[PRE365]'
- en: '[PRE366]'
  id: totrans-639
  prefs: []
  type: TYPE_PRE
  zh: '[PRE366]'
- en: '[PRE367]'
  id: totrans-640
  prefs: []
  type: TYPE_PRE
  zh: '[PRE367]'
- en: '[PRE368]'
  id: totrans-641
  prefs: []
  type: TYPE_PRE
  zh: '[PRE368]'
- en: '[PRE369]'
  id: totrans-642
  prefs: []
  type: TYPE_PRE
  zh: '[PRE369]'
- en: You can check out these examples in the *RatioToReport* bundled code.
  id: totrans-643
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在捆绑的*RatioToReport*代码中查看这些示例。
- en: Aggregates as window functions
  id: totrans-644
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 聚合函数作为窗口函数
- en: 'Aggregate functions can be used as window functions as well. For instance,
    let''s use the `SUM()` aggregate function as a window function for computing the
    sum of the successfully transferred amount per customer until each caching date,
    as illustrated in the following screenshot:'
  id: totrans-645
  prefs: []
  type: TYPE_NORMAL
  zh: 聚合函数也可以用作窗口函数。例如，让我们使用`SUM()`聚合函数作为窗口函数来计算每个客户在每个缓存日期成功转移的金额总和，如下面的截图所示：
- en: '![Figure 13.22 – Sum of the transferred amount until each caching date'
  id: totrans-646
  prefs: []
  type: TYPE_NORMAL
  zh: '![图13.22 – 到每个缓存日期为止转移金额的总和'
- en: '](img/B16833_Figure_13.22.jpg)'
  id: totrans-647
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16833_Figure_13.22.jpg)'
- en: Figure 13.22 – Sum of the transferred amount until each caching date
  id: totrans-648
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.22 – 到每个缓存日期为止转移金额的总和
- en: 'The jOOQ query can be expressed like this:'
  id: totrans-649
  prefs: []
  type: TYPE_NORMAL
  zh: jOOQ查询可以表达如下：
- en: '[PRE370]'
  id: totrans-650
  prefs: []
  type: TYPE_PRE
  zh: '[PRE370]'
- en: '[PRE371]'
  id: totrans-651
  prefs: []
  type: TYPE_PRE
  zh: '[PRE371]'
- en: '[PRE372]'
  id: totrans-652
  prefs: []
  type: TYPE_PRE
  zh: '[PRE372]'
- en: '[PRE373]'
  id: totrans-653
  prefs: []
  type: TYPE_PRE
  zh: '[PRE373]'
- en: '[PRE374]'
  id: totrans-654
  prefs: []
  type: TYPE_PRE
  zh: '[PRE374]'
- en: '[PRE375]'
  id: totrans-655
  prefs: []
  type: TYPE_PRE
  zh: '[PRE375]'
- en: '[PRE376]'
  id: totrans-656
  prefs: []
  type: TYPE_PRE
  zh: '[PRE376]'
- en: '[PRE377]'
  id: totrans-657
  prefs: []
  type: TYPE_PRE
  zh: '[PRE377]'
- en: '[PRE378]'
  id: totrans-658
  prefs: []
  type: TYPE_PRE
  zh: '[PRE378]'
- en: 'Or, let''s use the `AVG()` aggregate function as a window function for computing
    the average of prices for the preceding three ordered products on each order,
    as illustrated in the following screenshot:'
  id: totrans-659
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，让我们使用`AVG()`聚合函数作为窗口函数来计算每个订单前三个排序产品的平均价格，如下面的截图所示：
- en: '![Figure 13.23 – Average of prices for the preceding three ordered products
    on each order'
  id: totrans-660
  prefs: []
  type: TYPE_NORMAL
  zh: '![图13.23 – 每个订单前三个排序产品的平均价格'
- en: '](img/B16833_Figure_13.23.jpg)'
  id: totrans-661
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16833_Figure_13.23.jpg)'
- en: Figure 13.23 – Average of prices for the preceding three ordered products on
    each order
  id: totrans-662
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.23 – 每个订单前三个排序产品的平均价格
- en: 'The query looks like this:'
  id: totrans-663
  prefs: []
  type: TYPE_NORMAL
  zh: 查询看起来是这样的：
- en: '[PRE379]'
  id: totrans-664
  prefs: []
  type: TYPE_PRE
  zh: '[PRE379]'
- en: '[PRE380]'
  id: totrans-665
  prefs: []
  type: TYPE_PRE
  zh: '[PRE380]'
- en: '[PRE381]'
  id: totrans-666
  prefs: []
  type: TYPE_PRE
  zh: '[PRE381]'
- en: '[PRE382]'
  id: totrans-667
  prefs: []
  type: TYPE_PRE
  zh: '[PRE382]'
- en: '[PRE383]'
  id: totrans-668
  prefs: []
  type: TYPE_PRE
  zh: '[PRE383]'
- en: '[PRE384]'
  id: totrans-669
  prefs: []
  type: TYPE_PRE
  zh: '[PRE384]'
- en: 'How about calculating a running average flavor—in other words, create a report
    that shows every transaction in *March 2005* for *Visa Electron* cards? Additionally,
    this report shows the daily average transaction amount relying on a 3-day moving
    average. The code to accomplish this is shown in the following snippet:'
  id: totrans-670
  prefs: []
  type: TYPE_NORMAL
  zh: 关于计算运行平均口味的事情——换句话说，创建一个报告，显示2005年3月*Visa Electron*卡上的每笔交易？此外，此报告显示基于3天移动平均的每日平均交易金额。完成此操作的代码如下所示：
- en: '[PRE385]'
  id: totrans-671
  prefs: []
  type: TYPE_PRE
  zh: '[PRE385]'
- en: '[PRE386]'
  id: totrans-672
  prefs: []
  type: TYPE_PRE
  zh: '[PRE386]'
- en: '[PRE387]'
  id: totrans-673
  prefs: []
  type: TYPE_PRE
  zh: '[PRE387]'
- en: '[PRE388]'
  id: totrans-674
  prefs: []
  type: TYPE_PRE
  zh: '[PRE388]'
- en: '[PRE389]'
  id: totrans-675
  prefs: []
  type: TYPE_PRE
  zh: '[PRE389]'
- en: '[PRE390]'
  id: totrans-676
  prefs: []
  type: TYPE_PRE
  zh: '[PRE390]'
- en: '[PRE391]'
  id: totrans-677
  prefs: []
  type: TYPE_PRE
  zh: '[PRE391]'
- en: '[PRE392]'
  id: totrans-678
  prefs: []
  type: TYPE_PRE
  zh: '[PRE392]'
- en: '[PRE393]'
  id: totrans-679
  prefs: []
  type: TYPE_PRE
  zh: '[PRE393]'
- en: '[PRE394]'
  id: totrans-680
  prefs: []
  type: TYPE_PRE
  zh: '[PRE394]'
- en: '[PRE395]'
  id: totrans-681
  prefs: []
  type: TYPE_PRE
  zh: '[PRE395]'
- en: '[PRE396]'
  id: totrans-682
  prefs: []
  type: TYPE_PRE
  zh: '[PRE396]'
- en: '[PRE397]'
  id: totrans-683
  prefs: []
  type: TYPE_PRE
  zh: '[PRE397]'
- en: '[PRE398]'
  id: totrans-684
  prefs: []
  type: TYPE_PRE
  zh: '[PRE398]'
- en: '[PRE399]'
  id: totrans-685
  prefs: []
  type: TYPE_PRE
  zh: '[PRE399]'
- en: 'As Lukas Eder mentioned: "*What''s most mind-blowing about aggregate window
    functions is that even user-defined aggregate functions can be used as window
    functions!*"'
  id: totrans-686
  prefs: []
  type: TYPE_NORMAL
  zh: 如卢卡斯·埃德（Lukas Eder）所说：“*关于聚合窗口函数最令人震惊的是，甚至用户定义的聚合函数也可以用作窗口函数!*”
- en: You can check out more examples (for instance, in the *PostgreSQL* bundled code,
    you can find queries for *How many other employees have the same salary as me?*
    and *How many sales are better by 5,000 or less?*) in the *AggregateWindowFunctions*
    bundled code.
  id: totrans-687
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在捆绑的*PostgreSQL*代码中查看更多示例（例如，您可以找到关于*有多少其他员工的薪水与我相同？*和*有多少销售额比5000或更少？*的查询），在*AggregateWindowFunctions*捆绑代码中。
- en: Aggregate functions and ORDER BY
  id: totrans-688
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 聚合函数和ORDER BY
- en: Certain aggregate functions output significantly different results depending
    on their input order. By default, this ordering is not specified, but it can be
    controlled via an optional `ORDER BY` clause as an argument. So, in the presence
    of `ORDER BY` on these aggregate function calls, we can fetch ordered aggregated
    results. Let's see how we can use such functions in jOOQ and start with a category
    of functions having their names suffixed with `AGG`, such as `ARRAY_AGG()`, `JSON_ARRAYAGG()`,
    `XML_AGG()`, `MULTISET_AGG()` (covered in [*Chapter 8*](B16833_08.xhtml#_idTextAnchor128),
    *Fetching and Mapping*), and so on.
  id: totrans-689
  prefs: []
  type: TYPE_NORMAL
  zh: 某些聚合函数根据它们的输入顺序输出显著不同的结果。默认情况下，这种排序没有指定，但可以通过可选的`ORDER BY`子句作为参数来控制。因此，在这些聚合函数调用中存在`ORDER
    BY`时，我们可以获取排序后的聚合结果。让我们看看如何在jOOQ中使用这些函数，并从以`AGG`结尾的函数类别开始，例如`ARRAY_AGG()`、`JSON_ARRAYAGG()`、`XML_AGG()`、`MULTISET_AGG()`（在[*第8章*](B16833_08.xhtml#_idTextAnchor128)，*获取和映射*）等。
- en: FOO_AGG()
  id: totrans-690
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: FOO_AGG()
- en: 'For instance, `ARRAY_AGG()` is a function that aggregates data into an array
    and, in the presence of `ORDER BY`, it aggregates data into an array conforming
    to the specified order. Here is an example of using `ARRAY_AGG()` to aggregate
    `EMPLOYEE.FIRST_NAME` in descending order by `EMPLOYEE.FIRST_NAME` and `LAST_NAME`:'
  id: totrans-691
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，`ARRAY_AGG()` 是一个将数据聚合到数组中的函数，在存在 `ORDER BY` 的情况下，它将数据聚合到符合指定顺序的数组中。以下是一个使用
    `ARRAY_AGG()` 按降序聚合 `EMPLOYEE.FIRST_NAME` 和 `EMPLOYEE.LAST_NAME` 的示例：
- en: '[PRE400]'
  id: totrans-692
  prefs: []
  type: TYPE_PRE
  zh: '[PRE400]'
- en: '[PRE401]'
  id: totrans-693
  prefs: []
  type: TYPE_PRE
  zh: '[PRE401]'
- en: '[PRE402]'
  id: totrans-694
  prefs: []
  type: TYPE_PRE
  zh: '[PRE402]'
- en: 'For PostgreSQL, jOOQ renders this SQL:'
  id: totrans-695
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 PostgreSQL，jOOQ 生成的 SQL 如下：
- en: '[PRE403]'
  id: totrans-696
  prefs: []
  type: TYPE_PRE
  zh: '[PRE403]'
- en: '[PRE404]'
  id: totrans-697
  prefs: []
  type: TYPE_PRE
  zh: '[PRE404]'
- en: '[PRE405]'
  id: totrans-698
  prefs: []
  type: TYPE_PRE
  zh: '[PRE405]'
- en: '[PRE406]'
  id: totrans-699
  prefs: []
  type: TYPE_PRE
  zh: '[PRE406]'
- en: '[PRE407]'
  id: totrans-700
  prefs: []
  type: TYPE_PRE
  zh: '[PRE407]'
- en: '[PRE408]'
  id: totrans-701
  prefs: []
  type: TYPE_PRE
  zh: '[PRE408]'
- en: The result is an array as [*Yoshimi*, *William*, *Tom*, *Steve*, *Peter*,…],
    wrapped as `Result<Record1<String[]>>` (extract `String[]` via `get(0).value1()`).
    Do not confuse `ARRAY_AGG()` with jOOQ's `fetchArray()`. In the case of `ARRAY_AGG()`,
    the array is built by the database, while in the case of `fetchArray()`, the array
    is built by jOOQ after fetching the result set.
  id: totrans-702
  prefs: []
  type: TYPE_NORMAL
  zh: 结果是一个数组，如 [*Yoshimi*，*William*，*Tom*，*Steve*，*Peter*，…]，被包装为 `Result<Record1<String[]>>`（通过
    `get(0).value1()` 提取 `String[]`）。不要将 `ARRAY_AGG()` 与 jOOQ 的 `fetchArray()` 混淆。在
    `ARRAY_AGG()` 的情况下，数组是由数据库构建的，而在 `fetchArray()` 的情况下，数组是在获取结果集后由 jOOQ 构建的。
- en: Another two aggregation functions that accept `ORDER BY` are `JSON_ARRAYAGG()`
    and `XML_AGG()`. You should be familiar with these functions from [*Chapter 8*](B16833_08.xhtml#_idTextAnchor128),
    *Fetching and Mapping*, but you can also see several simple examples in the code
    bundled with this section.
  id: totrans-703
  prefs: []
  type: TYPE_NORMAL
  zh: 另外两个接受 `ORDER BY` 的聚合函数是 `JSON_ARRAYAGG()` 和 `XML_AGG()`。你应该熟悉这些函数来自 [*第8章*](B16833_08.xhtml#_idTextAnchor128)，*获取和映射*，但你也可以在本节附带代码中看到几个简单的示例。
- en: COLLECT()
  id: totrans-704
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: COLLECT()
- en: 'An interesting method that accepts `ORDER BY` is Oracle''s `COLLECT()` method.
    While `ARRAY_AGG()` represents the standard SQL function for aggregating data
    into an array, the `COLLECT()` function is specific to Oracle and produces a structurally
    typed array. Let''s assume the following Oracle user-defined type:'
  id: totrans-705
  prefs: []
  type: TYPE_NORMAL
  zh: 一个接受 `ORDER BY` 的有趣方法是 Oracle 的 `COLLECT()` 方法。虽然 `ARRAY_AGG()` 代表了将数据聚合到数组中的标准
    SQL 函数，但 `COLLECT()` 函数是 Oracle 特有的，并生成一个结构化类型的数组。让我们假设以下 Oracle 用户定义的类型：
- en: '[PRE409]'
  id: totrans-706
  prefs: []
  type: TYPE_PRE
  zh: '[PRE409]'
- en: 'The jOOQ Code Generator will produce for this user-defined type the `SalaryArrRecord`
    class in `jooq.generated.udt.records`. Via this UDT record, we can collect in
    descending order by salary and ascending order by job title the employees'' salaries,
    as follows:'
  id: totrans-707
  prefs: []
  type: TYPE_NORMAL
  zh: jOOQ 代码生成器将为这个用户定义的类型生成 `SalaryArrRecord` 类，位于 `jooq.generated.udt.records`
    中。通过这个 UDT 记录，我们可以按薪资降序和按职位升序收集员工的薪资，如下所示：
- en: '[PRE410]'
  id: totrans-708
  prefs: []
  type: TYPE_PRE
  zh: '[PRE410]'
- en: '[PRE411]'
  id: totrans-709
  prefs: []
  type: TYPE_PRE
  zh: '[PRE411]'
- en: '[PRE412]'
  id: totrans-710
  prefs: []
  type: TYPE_PRE
  zh: '[PRE412]'
- en: '[PRE413]'
  id: totrans-711
  prefs: []
  type: TYPE_PRE
  zh: '[PRE413]'
- en: 'jOOQ fetches `Result<Record1<SalaryArrRecord>>` via the following SQL:'
  id: totrans-712
  prefs: []
  type: TYPE_NORMAL
  zh: jOOQ 通过以下 SQL 获取 `Result<Record1<SalaryArrRecord>>`：
- en: '[PRE414]'
  id: totrans-713
  prefs: []
  type: TYPE_PRE
  zh: '[PRE414]'
- en: '[PRE415]'
  id: totrans-714
  prefs: []
  type: TYPE_PRE
  zh: '[PRE415]'
- en: '[PRE416]'
  id: totrans-715
  prefs: []
  type: TYPE_PRE
  zh: '[PRE416]'
- en: '[PRE417]'
  id: totrans-716
  prefs: []
  type: TYPE_PRE
  zh: '[PRE417]'
- en: '[PRE418]'
  id: totrans-717
  prefs: []
  type: TYPE_PRE
  zh: '[PRE418]'
- en: '[PRE419]'
  id: totrans-718
  prefs: []
  type: TYPE_PRE
  zh: '[PRE419]'
- en: '[PRE420]'
  id: totrans-719
  prefs: []
  type: TYPE_PRE
  zh: '[PRE420]'
- en: 'By calling `get(0).value1().toArray(Integer[]::new)`, you can access the array
    of salaries. Or, by calling `get(0).value1().get(5)`, you can access the fifth
    salary. Relying on `fetchOneInto()`/`fetchSingleInto()` is also an option, as
    illustrated here:'
  id: totrans-720
  prefs: []
  type: TYPE_NORMAL
  zh: 通过调用 `get(0).value1().toArray(Integer[]::new)`，你可以访问薪资数组。或者，通过调用 `get(0).value1().get(5)`，你可以访问第五个薪资。依赖
    `fetchOneInto()`/`fetchSingleInto()` 也是一种选择，如下所示：
- en: '[PRE421]'
  id: totrans-721
  prefs: []
  type: TYPE_PRE
  zh: '[PRE421]'
- en: '[PRE422]'
  id: totrans-722
  prefs: []
  type: TYPE_PRE
  zh: '[PRE422]'
- en: '[PRE423]'
  id: totrans-723
  prefs: []
  type: TYPE_PRE
  zh: '[PRE423]'
- en: '[PRE424]'
  id: totrans-724
  prefs: []
  type: TYPE_PRE
  zh: '[PRE424]'
- en: '[PRE425]'
  id: totrans-725
  prefs: []
  type: TYPE_PRE
  zh: '[PRE425]'
- en: Now, you can access the array of salaries as `result.toArray(Integer[]::new)`,
    and via `result.get(5)`, you can access the fifth salary.
  id: totrans-726
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以通过 `result.toArray(Integer[]::new)` 访问薪资数组，并通过 `result.get(5)` 访问第五个薪资。
- en: GROUP_CONCAT()
  id: totrans-727
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: GROUP_CONCAT()
- en: Another cool aggregate function that accepts an `ORDER BY` clause is the `GROUP_CONCAT()`
    function (very popular in MySQL), useful to get the aggregated concatenation for
    a field. jOOQ emulates this function in Oracle, PostgreSQL, SQL Server, and other
    dialects that don't support it natively.
  id: totrans-728
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个接受 `ORDER BY` 子句的酷炫聚合函数是 `GROUP_CONCAT()` 函数（在 MySQL 中非常流行），用于获取字段的聚合拼接结果。jOOQ
    在 Oracle、PostgreSQL、SQL Server 以及其他不支持原生此功能的方言中模拟了这个函数。
- en: 'For instance, let''s use `GROUP_CONCAT()` to fetch a string containing employees''
    names in descending order by salary, as follows:'
  id: totrans-729
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，让我们使用 `GROUP_CONCAT()` 来获取按薪资降序排列的员工姓名的字符串，如下所示：
- en: '[PRE426]'
  id: totrans-730
  prefs: []
  type: TYPE_PRE
  zh: '[PRE426]'
- en: '[PRE427]'
  id: totrans-731
  prefs: []
  type: TYPE_PRE
  zh: '[PRE427]'
- en: '[PRE428]'
  id: totrans-732
  prefs: []
  type: TYPE_PRE
  zh: '[PRE428]'
- en: '[PRE429]'
  id: totrans-733
  prefs: []
  type: TYPE_PRE
  zh: '[PRE429]'
- en: '[PRE430]'
  id: totrans-734
  prefs: []
  type: TYPE_PRE
  zh: '[PRE430]'
- en: 'The output will be something like this: *Diane Murphy*; *Mary Patterson*; *Jeff
    Firrelli*; ….'
  id: totrans-735
  prefs: []
  type: TYPE_NORMAL
  zh: 输出将类似于这样：*Diane Murphy*；*Mary Patterson*；*Jeff Firrelli*；…。
- en: Oracle's KEEP() clause
  id: totrans-736
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Oracle 的 KEEP() 子句
- en: 'Here''s a quick one—have you seen in a query an aggregate function like this:
    `SUM(some_value) KEEP (DENSE_RANK FIRST ORDER BY some_date)`? Or this analytic
    variant: `SUM(some_value) KEEP (DENSE_RANK LAST ORDER BY some_date) OVER (PARTITION
    BY some_partition)`?'
  id: totrans-737
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一点快速提示——你在查询中看到过这样的聚合函数吗：`SUM(some_value) KEEP (DENSE_RANK FIRST ORDER BY
    some_date)`？或者这个分析变体：`SUM(some_value) KEEP (DENSE_RANK LAST ORDER BY some_date)
    OVER (PARTITION BY some_partition)`？
- en: If you did, then you know that what you saw is Oracle's `KEEP()` clause at work,
    or—in other words—the SQL `FIRST()` and `LAST()` functions prefixed by the `KEEP()`
    clause for semantic clarity, and `DENSE_RANK()` for indicating that Oracle should
    aggregate only on Olympic rank (those rows with the maximum (`LAST()`) or minimum
    (`FIRST()`) dense rank with respect to a given sorting), respectively suffixed
    by `ORDER BY()` and, optionally, by `OVER(PARTITION BY())`. Both `LAST()` and
    `FIRST()` can be treated as aggregates (if you omit the `OVER()` clause) or as
    analytic functions.
  id: totrans-738
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你做到了，那么你知道你所看到的是 Oracle 的 `KEEP()` 子句在起作用，或者换句话说，是 SQL 的 `FIRST()` 和 `LAST()`
    函数，由 `KEEP()` 子句前缀以增加语义清晰度，以及 `DENSE_RANK()` 以指示 Oracle 应该仅对奥运排名（那些具有最大（`LAST()`）或最小（`FIRST()`）密集排名的行）进行聚合，分别后缀
    `ORDER BY()` 和可选的 `OVER(PARTITION BY())`。`LAST()` 和 `FIRST()` 都可以被视为聚合函数（如果你省略了
    `OVER()` 子句）或作为分析函数。
- en: 'But let''s have a scenario based on `CUSTOMER` and `ORDER` tables. Each customer
    (`CUSTOMER.CUSTOMER_NUMBER`) has one or more order, and let''s assume that we
    want to fetch the `ORDER.ORDER_DATE` value closest to 2004-June-06 (or any other
    date, including the current date) for each `CUSTOMER` type. This can be easily
    accomplished in a query, as here:'
  id: totrans-739
  prefs: []
  type: TYPE_NORMAL
  zh: 但让我们基于 `CUSTOMER` 和 `ORDER` 表来设定一个场景。每个客户 (`CUSTOMER.CUSTOMER_NUMBER`) 都有一个或多个订单，假设我们想要为每个
    `CUSTOMER` 类型获取最接近 2004 年 6 月 6 日（或任何其他日期，包括当前日期）的 `ORDER.ORDER_DATE` 值。这可以通过查询轻松实现，如下所示：
- en: '[PRE431]'
  id: totrans-740
  prefs: []
  type: TYPE_PRE
  zh: '[PRE431]'
- en: '[PRE432]'
  id: totrans-741
  prefs: []
  type: TYPE_PRE
  zh: '[PRE432]'
- en: '[PRE433]'
  id: totrans-742
  prefs: []
  type: TYPE_PRE
  zh: '[PRE433]'
- en: '[PRE434]'
  id: totrans-743
  prefs: []
  type: TYPE_PRE
  zh: '[PRE434]'
- en: '[PRE435]'
  id: totrans-744
  prefs: []
  type: TYPE_PRE
  zh: '[PRE435]'
- en: 'How about selecting `ORDER.SHIPPED_DATE` and `ORDER.STATUS` as well? One approach
    could be to rely on the `ROW_NUMBER()` window function and the `QUALIFY()` clause,
    as shown here:'
  id: totrans-745
  prefs: []
  type: TYPE_NORMAL
  zh: 顺便选择 `ORDER.SHIPPED_DATE` 和 `ORDER.STATUS` 好吗？一种方法可能是依赖 `ROW_NUMBER()` 窗口函数和
    `QUALIFY()` 子句，如下所示：
- en: '[PRE436]'
  id: totrans-746
  prefs: []
  type: TYPE_PRE
  zh: '[PRE436]'
- en: '[PRE437]'
  id: totrans-747
  prefs: []
  type: TYPE_PRE
  zh: '[PRE437]'
- en: '[PRE438]'
  id: totrans-748
  prefs: []
  type: TYPE_PRE
  zh: '[PRE438]'
- en: '[PRE439]'
  id: totrans-749
  prefs: []
  type: TYPE_PRE
  zh: '[PRE439]'
- en: '[PRE440]'
  id: totrans-750
  prefs: []
  type: TYPE_PRE
  zh: '[PRE440]'
- en: '[PRE441]'
  id: totrans-751
  prefs: []
  type: TYPE_PRE
  zh: '[PRE441]'
- en: '[PRE442]'
  id: totrans-752
  prefs: []
  type: TYPE_PRE
  zh: '[PRE442]'
- en: '[PRE443]'
  id: totrans-753
  prefs: []
  type: TYPE_PRE
  zh: '[PRE443]'
- en: 'As you can see in the bundled code, another approach could be to rely on `SELECT
    DISTINCT ON` (as *@dmitrygusev* suggested on Twitter) or on an anti-join, but
    if we write our query for Oracle, then most probably you''ll go for the `KEEP()`
    clause, as follows:'
  id: totrans-754
  prefs: []
  type: TYPE_NORMAL
  zh: 如你在捆绑的代码中所见，另一种方法可能是依赖 `SELECT DISTINCT ON`（如 Twitter 上的 *@dmitrygusev* 建议的）或反连接，但如果我们为
    Oracle 编写查询，那么你很可能会选择 `KEEP()` 子句，如下所示：
- en: '[PRE444]'
  id: totrans-755
  prefs: []
  type: TYPE_PRE
  zh: '[PRE444]'
- en: '[PRE445]'
  id: totrans-756
  prefs: []
  type: TYPE_PRE
  zh: '[PRE445]'
- en: '[PRE446]'
  id: totrans-757
  prefs: []
  type: TYPE_PRE
  zh: '[PRE446]'
- en: '[PRE447]'
  id: totrans-758
  prefs: []
  type: TYPE_PRE
  zh: '[PRE447]'
- en: '[PRE448]'
  id: totrans-759
  prefs: []
  type: TYPE_PRE
  zh: '[PRE448]'
- en: '[PRE449]'
  id: totrans-760
  prefs: []
  type: TYPE_PRE
  zh: '[PRE449]'
- en: '[PRE450]'
  id: totrans-761
  prefs: []
  type: TYPE_PRE
  zh: '[PRE450]'
- en: '[PRE451]'
  id: totrans-762
  prefs: []
  type: TYPE_PRE
  zh: '[PRE451]'
- en: '[PRE452]'
  id: totrans-763
  prefs: []
  type: TYPE_PRE
  zh: '[PRE452]'
- en: 'Or, you could do this by exploiting the Oracle''s `ROWID` pseudo-column, as
    follows:'
  id: totrans-764
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，你也可以通过利用 Oracle 的 `ROWID` 伪列来实现，如下所示：
- en: '[PRE453]'
  id: totrans-765
  prefs: []
  type: TYPE_PRE
  zh: '[PRE453]'
- en: '[PRE454]'
  id: totrans-766
  prefs: []
  type: TYPE_PRE
  zh: '[PRE454]'
- en: '[PRE455]'
  id: totrans-767
  prefs: []
  type: TYPE_PRE
  zh: '[PRE455]'
- en: '[PRE456]'
  id: totrans-768
  prefs: []
  type: TYPE_PRE
  zh: '[PRE456]'
- en: '[PRE457]'
  id: totrans-769
  prefs: []
  type: TYPE_PRE
  zh: '[PRE457]'
- en: '[PRE458]'
  id: totrans-770
  prefs: []
  type: TYPE_PRE
  zh: '[PRE458]'
- en: '[PRE459]'
  id: totrans-771
  prefs: []
  type: TYPE_PRE
  zh: '[PRE459]'
- en: '[PRE460]'
  id: totrans-772
  prefs: []
  type: TYPE_PRE
  zh: '[PRE460]'
- en: You can practice these examples in the *AggregateFunctionsOrderBy* bundled code.
  id: totrans-773
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在捆绑的代码 *AggregateFunctionsOrderBy* 中练习这些示例。
- en: Ordered set aggregate functions (WITHIN GROUP)
  id: totrans-774
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 有序集聚合函数（WITHIN GROUP）
- en: '*Ordered set aggregate functions* allow operations on a set of rows sorted
    with `ORDER BY` via the `WITHIN GROUP` clause. Commonly, such functions are used
    for performing computations that depend on a certain row ordering. Here, we can
    quickly mention *hypothetical set* functions such as `RANK()`, `DENSE_RANK()`,
    `PERCENT_RANK()`, or `CUME_DIST()`, and *inverse distribution functions* such
    as `PERCENTILE_CONT()`, `PERCENTILE_DISC()`, or `MODE()`. A particular case is
    represented by `LISTAGG()`, which is covered at the end of this section.'
  id: totrans-775
  prefs: []
  type: TYPE_NORMAL
  zh: '*有序集聚合函数* 允许通过 `WITHIN GROUP` 子句对排序后的行集进行操作。通常，这些函数用于执行依赖于特定行排序的计算。在这里，我们可以快速提及
    *假设集* 函数，如 `RANK()`、`DENSE_RANK()`、`PERCENT_RANK()` 或 `CUME_DIST()`，以及 *逆分布函数*，如
    `PERCENTILE_CONT()`、`PERCENTILE_DISC()` 或 `MODE()`。一个特殊情况由 `LISTAGG()` 表示，它在本节的末尾进行介绍。'
- en: Hypothetical set functions
  id: totrans-776
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 假设集函数
- en: A hypothetical set function calculates something for a hypothetical value (let's
    denote it as `hv`). In this context, `DENSE_RANK()` computes the rank of `hv`
    without gaps, while `RANK()` does the same thing but with gaps. `CUME_DIST()`
    computes the cumulative distribution of `hv` (the relative rank of a row from
    1/n to 1), while `PERCENT_RANK()` computes the percent rank of `hv` (the relative
    rank of a row from 0 to 1).
  id: totrans-777
  prefs: []
  type: TYPE_NORMAL
  zh: 假设集函数为假设值（让我们用 `hv` 表示）计算某些内容。在这个上下文中，`DENSE_RANK()` 计算没有间隔的 `hv` 排名，而 `RANK()`
    做同样的事情但带有间隔。`CUME_DIST()` 计算累积分布（`hv` 的相对排名从 1/n 到 1），而 `PERCENT_RANK()` 计算百分比排名（`hv`
    的相对排名从 0 到 1）。
- en: 'For instance, let''s assume that we want to compute the rank without gaps for
    the hypothetical value (*2004*, *10000*), where *2004* is `SALE.FISCAL_YEAR` and
    *10000* is `SALE.SALE_`. Next, for the existing data, we want to obtain all ranks
    without gaps less than the rank of this hypothetical value. For the first part
    of the problem, we rely on the `DENSE_RANK()` hypothetical set function, while
    for the second part, on the `DENSE_RANK()` window function, as follows:'
  id: totrans-778
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设我们想要计算假设值（*2004*，*10000*）的排名，其中*2004*是`SALE.FISCAL_YEAR`，*10000*是`SALE.SALE_`。接下来，对于现有数据，我们想要获得所有小于这个假设值排名的无间隙排名。对于问题的第一部分，我们依赖于`DENSE_RANK()`假设集函数，而对于第二部分，依赖于`DENSE_RANK()`窗口函数，如下所示：
- en: '[PRE461]'
  id: totrans-779
  prefs: []
  type: TYPE_PRE
  zh: '[PRE461]'
- en: '[PRE462]'
  id: totrans-780
  prefs: []
  type: TYPE_PRE
  zh: '[PRE462]'
- en: '[PRE463]'
  id: totrans-781
  prefs: []
  type: TYPE_PRE
  zh: '[PRE463]'
- en: '[PRE464]'
  id: totrans-782
  prefs: []
  type: TYPE_PRE
  zh: '[PRE464]'
- en: '[PRE465]'
  id: totrans-783
  prefs: []
  type: TYPE_PRE
  zh: '[PRE465]'
- en: '[PRE466]'
  id: totrans-784
  prefs: []
  type: TYPE_PRE
  zh: '[PRE466]'
- en: '[PRE467]'
  id: totrans-785
  prefs: []
  type: TYPE_PRE
  zh: '[PRE467]'
- en: 'Now, let''s consider another example that uses the `PERCENT_RANK()` hypothetical
    set function. This time, let''s assume that we plan to have a salary of *$61,000*
    for new sales reps, but before doing that, we want to know the percentage of current
    sales reps having salaries higher than *$61,000*. This can be done like so:'
  id: totrans-786
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们考虑另一个使用`PERCENT_RANK()`假设集函数的例子。这次，假设我们计划为新销售代表提供*$61,000*的薪水，但在做这件事之前，我们想知道有多少比例的当前销售代表的薪水高于*$61,000*。这可以这样完成：
- en: '[PRE468]'
  id: totrans-787
  prefs: []
  type: TYPE_PRE
  zh: '[PRE468]'
- en: '[PRE469]'
  id: totrans-788
  prefs: []
  type: TYPE_PRE
  zh: '[PRE469]'
- en: '[PRE470]'
  id: totrans-789
  prefs: []
  type: TYPE_PRE
  zh: '[PRE470]'
- en: '[PRE471]'
  id: totrans-790
  prefs: []
  type: TYPE_PRE
  zh: '[PRE471]'
- en: '[PRE472]'
  id: totrans-791
  prefs: []
  type: TYPE_PRE
  zh: '[PRE472]'
- en: '[PRE473]'
  id: totrans-792
  prefs: []
  type: TYPE_PRE
  zh: '[PRE473]'
- en: 'Moreover, we want to know the percentage of sales reps'' salaries that are
    higher than *$61,000*. For this, we need the distinct salaries, as shown here:'
  id: totrans-793
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们还想了解薪水高于*$61,000*的销售代表的百分比。为此，我们需要不同的薪水，如下所示：
- en: '[PRE474]'
  id: totrans-794
  prefs: []
  type: TYPE_PRE
  zh: '[PRE474]'
- en: '[PRE475]'
  id: totrans-795
  prefs: []
  type: TYPE_PRE
  zh: '[PRE475]'
- en: '[PRE476]'
  id: totrans-796
  prefs: []
  type: TYPE_PRE
  zh: '[PRE476]'
- en: '[PRE477]'
  id: totrans-797
  prefs: []
  type: TYPE_PRE
  zh: '[PRE477]'
- en: '[PRE478]'
  id: totrans-798
  prefs: []
  type: TYPE_PRE
  zh: '[PRE478]'
- en: '[PRE479]'
  id: totrans-799
  prefs: []
  type: TYPE_PRE
  zh: '[PRE479]'
- en: '[PRE480]'
  id: totrans-800
  prefs: []
  type: TYPE_PRE
  zh: '[PRE480]'
- en: '[PRE481]'
  id: totrans-801
  prefs: []
  type: TYPE_PRE
  zh: '[PRE481]'
- en: '[PRE482]'
  id: totrans-802
  prefs: []
  type: TYPE_PRE
  zh: '[PRE482]'
- en: You can practice these examples next to other `RANK()` and `CUME_DIST()` hypothetical
    set functions in the *OrderedSetAggregateFunctions* bundled code.
  id: totrans-803
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在`OrderedSetAggregateFunctions`捆绑代码旁边练习这些例子，以及其他`RANK()`和`CUME_DIST()`假设集函数。
- en: Inverse distribution functions
  id: totrans-804
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 逆分布函数
- en: 'Briefly, the inverse distribution functions compute *percentiles*. There are
    two distribution models: a discrete model (computed via `PERCENTILE_DISC()`) and
    a continuous model (computed via `PERCENTILE_CONT()`).'
  id: totrans-805
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，逆分布函数计算*百分位数*。有两种分布模型：一种离散模型（通过`PERCENTILE_DISC()`计算）和一种连续模型（通过`PERCENTILE_CONT()`计算）。
- en: PERCENTILE_DISC() and PERCENTILE_CONT()
  id: totrans-806
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`PERCENTILE_DISC()`和`PERCENTILE_CONT()`'
- en: But what does it actually mean to compute *percentiles*? Loosely speaking, consider
    a certain percent, `P` (this percent is a float value between 0 inclusive and
    1 inclusive), and an ordering field, `F`. In this context, the percentile computation
    represents the value below which `P` percent of the `F` values fall.
  id: totrans-807
  prefs: []
  type: TYPE_NORMAL
  zh: 但计算*百分位数*实际上意味着什么呢？粗略地说，考虑一个特定的百分比，`P`（这个百分比是一个介于0（包含）和1（包含）之间的浮点值），以及一个排序字段，`F`。在这种情况下，百分位数的计算表示低于`F`值百分比的值。
- en: 'For instance, let''s consider the `SALES` table, and we want to find the 25th
    percentile sale. In this case, `P` = 0.25, and the ordering field is `SALE.SALE_`.
    Applying `PERCENTILE_DISC()` and `PERCENTILE_CONT()` results in this query:'
  id: totrans-808
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，让我们考虑`SALES`表，并希望找到第25百分位的销售额。在这种情况下，`P` = 0.25，排序字段是`SALE.SALE_`。应用`PERCENTILE_DISC()`和`PERCENTILE_CONT()`函数的结果如下：
- en: '[PRE483]'
  id: totrans-809
  prefs: []
  type: TYPE_PRE
  zh: '[PRE483]'
- en: '[PRE484]'
  id: totrans-810
  prefs: []
  type: TYPE_PRE
  zh: '[PRE484]'
- en: '[PRE485]'
  id: totrans-811
  prefs: []
  type: TYPE_PRE
  zh: '[PRE485]'
- en: '[PRE486]'
  id: totrans-812
  prefs: []
  type: TYPE_PRE
  zh: '[PRE486]'
- en: '[PRE487]'
  id: totrans-813
  prefs: []
  type: TYPE_PRE
  zh: '[PRE487]'
- en: '[PRE488]'
  id: totrans-814
  prefs: []
  type: TYPE_PRE
  zh: '[PRE488]'
- en: '[PRE489]'
  id: totrans-815
  prefs: []
  type: TYPE_PRE
  zh: '[PRE489]'
- en: In the bundled code, you can see this query extended for the 50th, 75th, and
    100th percentile. The resulting value (for instance, 2974.43) represents the sale
    below which 25% of the sales fall. In this case, `PERCENTILE_DISC()` and `PERCENTILE_CONT()`
    return the same value (2974.43), but this is not always the case. Remember that
    `PERCENTILE_DISC()` works on a discrete model, while `PERCENTILE_CONT()` works
    on a continuous model. In other words, if there is no value (sale) in the sales
    (also referred to as population) that fall exactly in the specified percentile,
    `PERCENTILE_CONT()` must interpolate it assuming continuous distribution. Basically,
    `PERCENTILE_CONT()` interpolates the value (sale) from the two values (sales)
    that are immediately after and before the needed one. For instance, if we repeat
    the previous example for the 11th percentile, then `PERCENTILE_DISC()` returns
    1676.14, which is an existent sale, while `PERCENTILE_CONT()` returns 1843.88,
    which is an interpolated value that doesn't exist in the database.
  id: totrans-816
  prefs: []
  type: TYPE_NORMAL
  zh: 在捆绑的代码中，你可以看到这个查询扩展到了50th、75th和100th百分位数。得到的值（例如，2974.43）表示低于该值的销售额占销售额的25%。在这种情况下，`PERCENTILE_DISC()`和`PERCENTILE_CONT()`返回相同的值（2974.43），但这并不总是如此。记住，`PERCENTILE_DISC()`在离散模型上工作，而`PERCENTILE_CONT()`在连续模型上工作。换句话说，如果销售（也称为总体）中没有值（销售额）正好落在指定的百分位数，`PERCENTILE_CONT()`必须假设连续分布进行插值。基本上，`PERCENTILE_CONT()`从两个紧接在所需值之后和之前的值（销售额）中插值所需的值（销售额）。例如，如果我们重复之前的例子来计算11th百分位数，那么`PERCENTILE_DISC()`返回1676.14，这是一个存在的销售额，而`PERCENTILE_CONT()`返回1843.88，这是一个插值值，该值在数据库中不存在。
- en: 'While Oracle supports `PERCENTILE_DISC()` and `PERCENTILE_CONT()` as ordered
    set aggregate functions and window function variants, PostgreSQL supports them
    only as ordered set aggregate functions, SQL Server supports only the window function
    variants, and MySQL doesn''t support them at all. Emulating them is not quite
    simple, but this great article by Lukas Eder is a must-read in this direction:
    [https://blog.jooq.org/2019/01/28/how-to-emulate-percentile_disc-in-mysql-and-other-rdbms/](https://blog.jooq.org/2019/01/28/how-to-emulate-percentile_disc-in-mysql-and-other-rdbms/).'
  id: totrans-817
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 Oracle 支持 `PERCENTILE_DISC()` 和 `PERCENTILE_CONT()` 作为排序集聚合函数和窗口函数变体，但 PostgreSQL
    只支持它们作为排序集聚合函数，SQL Server 只支持窗口函数变体，MySQL 完全不支持它们。模拟它们并不简单，但 Lukas Eder 的这篇优秀文章是这方面的必读之作：[https://blog.jooq.org/2019/01/28/how-to-emulate-percentile_disc-in-mysql-and-other-rdbms/](https://blog.jooq.org/2019/01/28/how-to-emulate-percentile_disc-in-mysql-and-other-rdbms/)。
- en: 'Now, let''s see an example of using `PERCENTILE_DISC()` as the window function
    variant and `PERCENTILE_CONT()` as the ordered set aggregate function. This time,
    the focus is on `EMPLOYEE.SALARY`. First, we want to compute the 50th percentile
    of salaries per office via `PERCENTILE_DISC()`. Second, we want to keep only those
    50th percentiles less than the general 50th percentile calculated via `PERCENTILE_CONT()`.
    The code is illustrated in the following snippet:'
  id: totrans-818
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看使用 `PERCENTILE_DISC()` 作为窗口函数变体和 `PERCENTILE_CONT()` 作为排序集聚合函数的示例。这次，重点是
    `EMPLOYEE.SALARY`。首先，我们想通过 `PERCENTILE_DISC()` 计算每个办公室的薪资的 50 分位数。其次，我们只想保留那些小于通过
    `PERCENTILE_CONT()` 计算的总体 50 分位数的 50 分位数。代码如下所示：
- en: '[PRE490]'
  id: totrans-819
  prefs: []
  type: TYPE_PRE
  zh: '[PRE490]'
- en: '[PRE491]'
  id: totrans-820
  prefs: []
  type: TYPE_PRE
  zh: '[PRE491]'
- en: '[PRE492]'
  id: totrans-821
  prefs: []
  type: TYPE_PRE
  zh: '[PRE492]'
- en: '[PRE493]'
  id: totrans-822
  prefs: []
  type: TYPE_PRE
  zh: '[PRE493]'
- en: '[PRE494]'
  id: totrans-823
  prefs: []
  type: TYPE_PRE
  zh: '[PRE494]'
- en: '[PRE495]'
  id: totrans-824
  prefs: []
  type: TYPE_PRE
  zh: '[PRE495]'
- en: '[PRE496]'
  id: totrans-825
  prefs: []
  type: TYPE_PRE
  zh: '[PRE496]'
- en: '[PRE497]'
  id: totrans-826
  prefs: []
  type: TYPE_PRE
  zh: '[PRE497]'
- en: '[PRE498]'
  id: totrans-827
  prefs: []
  type: TYPE_PRE
  zh: '[PRE498]'
- en: '[PRE499]'
  id: totrans-828
  prefs: []
  type: TYPE_PRE
  zh: '[PRE499]'
- en: '[PRE500]'
  id: totrans-829
  prefs: []
  type: TYPE_PRE
  zh: '[PRE500]'
- en: '[PRE501]'
  id: totrans-830
  prefs: []
  type: TYPE_PRE
  zh: '[PRE501]'
- en: '[PRE502]'
  id: totrans-831
  prefs: []
  type: TYPE_PRE
  zh: '[PRE502]'
- en: You can practice these examples in the *OrderedSetAggregateFunctions* bundled
    code.
  id: totrans-832
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在捆绑的 *OrderedSetAggregateFunctions* 代码中练习这些示例。
- en: The MODE() function
  id: totrans-833
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`MODE()` 函数'
- en: 'Mainly, the `MODE()` function works on a set of values to produce a result
    (referred to as the *mode*) representing the value that appears with the greatest
    frequency. The `MODE()` function comes in two flavors, as outlined here:'
  id: totrans-834
  prefs: []
  type: TYPE_NORMAL
  zh: 主要来说，`MODE()` 函数作用于一系列值以产生一个结果（称为 *众数*），表示出现频率最高的值。`MODE()` 函数有两种形式，如下所述：
- en: '`MODE(field)` aggregate function'
  id: totrans-835
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MODE(field)` 聚合函数'
- en: '`MODE WITHIN GROUP (ORDER BY [order clause])` ordered set aggregate function'
  id: totrans-836
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MODE WITHIN GROUP (ORDER BY [order clause])` 排序集聚合函数'
- en: If multiple results (modes) are available, then `MODE()` returns only one value.
    If there is a given ordering, then the first value will be chosen.
  id: totrans-837
  prefs: []
  type: TYPE_NORMAL
  zh: 如果有多个结果（众数）可用，那么 `MODE()` 只返回一个值。如果有给定的排序，那么将选择第一个值。
- en: 'The `MODE()` aggregate function is emulated by jOOQ in PostgreSQL and Oracle
    and is not supported in MySQL and SQL Server. For instance, let''s assume that
    we want to find out in which month of the year we have the most sales, and for
    this, we may come up with the following query (notice that an explicit `ORDER
    BY` clause for `MODE()` is not allowed):'
  id: totrans-838
  prefs: []
  type: TYPE_NORMAL
  zh: '`MODE()` 聚合函数在 PostgreSQL 和 Oracle 中由 jOOQ 模拟，但在 MySQL 和 SQL Server 中不支持。例如，假设我们想找出一年中销售量最多的月份，为此，我们可能会提出以下查询（注意，不允许为
    `MODE()` 明确使用 `ORDER BY` 子句）：'
- en: '[PRE503]'
  id: totrans-839
  prefs: []
  type: TYPE_PRE
  zh: '[PRE503]'
- en: '[PRE504]'
  id: totrans-840
  prefs: []
  type: TYPE_PRE
  zh: '[PRE504]'
- en: 'Running this query in PostgreSQL reveals that jOOQ emulates the `MODE()` aggregate
    function via the ordered set aggregate function, which is supported by PostgreSQL:'
  id: totrans-841
  prefs: []
  type: TYPE_NORMAL
  zh: 在 PostgreSQL 中运行此查询会显示 jOOQ 通过排序集聚合函数模拟了 `MODE()` 聚合函数，该函数由 PostgreSQL 支持：
- en: '[PRE505]'
  id: totrans-842
  prefs: []
  type: TYPE_PRE
  zh: '[PRE505]'
- en: '[PRE506]'
  id: totrans-843
  prefs: []
  type: TYPE_PRE
  zh: '[PRE506]'
- en: '[PRE507]'
  id: totrans-844
  prefs: []
  type: TYPE_PRE
  zh: '[PRE507]'
- en: 'In this case, if multiple modes are available, then the first one is returned
    with respect to the ascending ordering. On the other hand, for the Oracle case,
    jOOQ uses the `STATS_MODE()` function, as follows:'
  id: totrans-845
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，如果有多个众数可用，那么将返回第一个，按照升序排列。另一方面，对于 Oracle 的情况，jOOQ 使用 `STATS_MODE()` 函数，如下所示：
- en: '[PRE508]'
  id: totrans-846
  prefs: []
  type: TYPE_PRE
  zh: '[PRE508]'
- en: '[PRE509]'
  id: totrans-847
  prefs: []
  type: TYPE_PRE
  zh: '[PRE509]'
- en: '[PRE510]'
  id: totrans-848
  prefs: []
  type: TYPE_PRE
  zh: '[PRE510]'
- en: 'In the following case, there is no ordering in the generated SQL, and if multiple
    modes are available, then only one is returned. On the other hand, the `MODE()`
    ordered set aggregate function is supported only by PostgreSQL:'
  id: totrans-849
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下情况下，生成的 SQL 中没有排序，如果有多个众数可用，那么只返回一个。另一方面，`MODE()` 排序集聚合函数只由 PostgreSQL 支持：
- en: '[PRE511]'
  id: totrans-850
  prefs: []
  type: TYPE_PRE
  zh: '[PRE511]'
- en: '[PRE512]'
  id: totrans-851
  prefs: []
  type: TYPE_PRE
  zh: '[PRE512]'
- en: '[PRE513]'
  id: totrans-852
  prefs: []
  type: TYPE_PRE
  zh: '[PRE513]'
- en: If multiple results (modes) are available, then `MODE()` returns only one value
    representing the highest value (in this particular case, the month closest to
    December inclusive) since we have used a descending order.
  id: totrans-853
  prefs: []
  type: TYPE_NORMAL
  zh: 如果有多个结果（众数）可用，那么 `MODE()` 只返回一个值，表示最高值（在这个特定情况下，最接近十二月（包括十二月）的月份）因为我们使用了降序排列。
- en: 'Nevertheless, how to return all modes (if more are available)? Commonly, statisticians
    refer to a bimodal distribution if two modes are available, to a trimodal distribution
    if three modes are available, and so on. Emulating `MODE()` to return all modes
    can be done in several ways. Here is one way (in the bundled code, you can see
    one more):'
  id: totrans-854
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管如此，如果存在多个模式（如果有更多的话），如何返回所有模式？通常，统计学家在存在两个模式时称之为双峰分布，存在三个模式时称之为三峰分布，依此类推。模拟`MODE()`以返回所有模式可以通过几种方式实现。这里有一种方式（在捆绑的代码中，你可以看到另一种）：
- en: '[PRE514]'
  id: totrans-855
  prefs: []
  type: TYPE_PRE
  zh: '[PRE514]'
- en: '[PRE515]'
  id: totrans-856
  prefs: []
  type: TYPE_PRE
  zh: '[PRE515]'
- en: '[PRE516]'
  id: totrans-857
  prefs: []
  type: TYPE_PRE
  zh: '[PRE516]'
- en: '[PRE517]'
  id: totrans-858
  prefs: []
  type: TYPE_PRE
  zh: '[PRE517]'
- en: '[PRE518]'
  id: totrans-859
  prefs: []
  type: TYPE_PRE
  zh: '[PRE518]'
- en: '[PRE519]'
  id: totrans-860
  prefs: []
  type: TYPE_PRE
  zh: '[PRE519]'
- en: '[PRE520]'
  id: totrans-861
  prefs: []
  type: TYPE_PRE
  zh: '[PRE520]'
- en: 'But having 1,000 cases where the value of `X` is `''foo''` and 999 cases where
    the value is `''buzz''`, `MODE()` is `''foo''`. By adding two more instances of
    `''buzz''`, `MODE()` switches to `''buzz''`. Maybe a good idea would be to allow
    for some variation in the values via a percent. In other words, the emulation
    of `MODE()` using a percentage of the total number of occurrences can be done
    like so (here, 75%):'
  id: totrans-862
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，当`X`的值为`'foo'`时有1,000个案例，而当值为`'buzz'`时有999个案例时，`MODE()`是`'foo'`。通过添加两个`'buzz'`的实例，`MODE()`切换到`'buzz'`。也许允许值有一些百分比的变化是个好主意。换句话说，使用总出现次数的百分比来模拟`MODE()`可以这样进行（这里为75%）：
- en: '[PRE521]'
  id: totrans-863
  prefs: []
  type: TYPE_PRE
  zh: '[PRE521]'
- en: '[PRE522]'
  id: totrans-864
  prefs: []
  type: TYPE_PRE
  zh: '[PRE522]'
- en: '[PRE523]'
  id: totrans-865
  prefs: []
  type: TYPE_PRE
  zh: '[PRE523]'
- en: '[PRE524]'
  id: totrans-866
  prefs: []
  type: TYPE_PRE
  zh: '[PRE524]'
- en: '[PRE525]'
  id: totrans-867
  prefs: []
  type: TYPE_PRE
  zh: '[PRE525]'
- en: '[PRE526]'
  id: totrans-868
  prefs: []
  type: TYPE_PRE
  zh: '[PRE526]'
- en: '[PRE527]'
  id: totrans-869
  prefs: []
  type: TYPE_PRE
  zh: '[PRE527]'
- en: You can practice these examples in the *OrderedSetAggregateFunctions* bundled
    code.
  id: totrans-870
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在*OrderedSetAggregateFunctions*捆绑代码中练习这些示例。
- en: LISTAGG()
  id: totrans-871
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`LISTAGG()`'
- en: The last ordered set aggregate function discussed in this section is `LISTAGG()`.
    This function is used for aggregating a given list of values into a string delimited
    via a separator (for instance, it is useful for producing CSV files). The SQL
    standard imposes the presence of the separator and `WITHIN GROUP` clause. Nevertheless,
    some databases treat these standards as being optional and apply certain defaults
    or expose an undefined behavior if the `WITHIN GROUP` clause is omitted. jOOQ
    provides `listAgg(Field<?> field)` having no explicit separator, and `listAgg(Field<?>
    field, String separator)`. The `WITHIN GROUP` clause cannot be omitted. jOOQ emulates
    this function for dialects that don't support it, such as MySQL (emulates it via
    `GROUP_CONCAT()`, so a comma is a default separator), PostgreSQL (emulates it
    via `STRING_AGG()`, so no default separator), and SQL Server (same as in PostgreSQL)
    via proprietary syntax that offers similar functionality. Oracle supports `LISTAGG()`
    and there is no default separator.
  id: totrans-872
  prefs: []
  type: TYPE_NORMAL
  zh: 本节最后讨论的有序集聚合函数是`LISTAGG()`。此函数用于将给定值列表聚合为一个通过分隔符分隔的字符串（例如，对于生成CSV文件很有用）。SQL标准要求存在分隔符和`WITHIN
    GROUP`子句。尽管如此，一些数据库将这些标准视为可选的，并应用某些默认值或在省略`WITHIN GROUP`子句时表现出未定义的行为。jOOQ提供了`listAgg(Field<?>
    field)`，它没有显式分隔符，以及`listAgg(Field<?> field, String separator)`。`WITHIN GROUP`子句不能省略。jOOQ为不支持此功能的方言（如MySQL（通过`GROUP_CONCAT()`模拟，因此逗号是默认分隔符）、PostgreSQL（通过`STRING_AGG()`模拟，因此没有默认分隔符）和SQL
    Server（与PostgreSQL相同））提供了此函数，通过专有语法提供类似的功能。Oracle支持`LISTAGG()`，没有默认分隔符。
- en: 'Here are two simple examples with and without an explicit separator that produces
    a list of employees names'' in ascending order by salary as `Result<Record1<String>>`:'
  id: totrans-873
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有两个简单的示例，一个带有显式分隔符，一个没有，它们按薪资升序生成员工姓名列表作为`Result<Record1<String>>`：
- en: '[PRE528]'
  id: totrans-874
  prefs: []
  type: TYPE_PRE
  zh: '[PRE528]'
- en: '[PRE529]'
  id: totrans-875
  prefs: []
  type: TYPE_PRE
  zh: '[PRE529]'
- en: '[PRE530]'
  id: totrans-876
  prefs: []
  type: TYPE_PRE
  zh: '[PRE530]'
- en: '[PRE531]'
  id: totrans-877
  prefs: []
  type: TYPE_PRE
  zh: '[PRE531]'
- en: '[PRE532]'
  id: totrans-878
  prefs: []
  type: TYPE_PRE
  zh: '[PRE532]'
- en: '[PRE533]'
  id: totrans-879
  prefs: []
  type: TYPE_PRE
  zh: '[PRE533]'
- en: Fetching directly, the `String` can be achieved via `fetchOneInto(String.class)`.
  id: totrans-880
  prefs: []
  type: TYPE_NORMAL
  zh: 直接获取，可以通过`fetchOneInto(String.class)`获取`String`。
- en: '`LISTAGG()` can be used in combination with `GROUP BY` and `ORDER BY`, as in
    the following example that fetches a list of employees per job title:'
  id: totrans-881
  prefs: []
  type: TYPE_NORMAL
  zh: '`LISTAGG()`可以与`GROUP BY`和`ORDER BY`结合使用，如下面的示例所示，它获取按职位标题的员工列表：'
- en: '[PRE534]'
  id: totrans-882
  prefs: []
  type: TYPE_PRE
  zh: '[PRE534]'
- en: '[PRE535]'
  id: totrans-883
  prefs: []
  type: TYPE_PRE
  zh: '[PRE535]'
- en: '[PRE536]'
  id: totrans-884
  prefs: []
  type: TYPE_PRE
  zh: '[PRE536]'
- en: '[PRE537]'
  id: totrans-885
  prefs: []
  type: TYPE_PRE
  zh: '[PRE537]'
- en: '[PRE538]'
  id: totrans-886
  prefs: []
  type: TYPE_PRE
  zh: '[PRE538]'
- en: '[PRE539]'
  id: totrans-887
  prefs: []
  type: TYPE_PRE
  zh: '[PRE539]'
- en: 'Moreover, `LISTAGG()` supports a window function variant as well, as shown
    here:'
  id: totrans-888
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，`LISTAGG()`还支持一个窗口函数变体，如下所示：
- en: '[PRE540]'
  id: totrans-889
  prefs: []
  type: TYPE_PRE
  zh: '[PRE540]'
- en: '[PRE541]'
  id: totrans-890
  prefs: []
  type: TYPE_PRE
  zh: '[PRE541]'
- en: '[PRE542]'
  id: totrans-891
  prefs: []
  type: TYPE_PRE
  zh: '[PRE542]'
- en: '[PRE543]'
  id: totrans-892
  prefs: []
  type: TYPE_PRE
  zh: '[PRE543]'
- en: 'And here is a fun fact from Lukas Eder: "`LISTAGG()` *is not a true ordered
    set aggregate function. It should use the same* `ORDER BY` *syntax as* `ARRAY_AGG`."
    See the discussion here: [https://twitter.com/lukaseder/status/1237662156553883648](https://twitter.com/lukaseder/status/1237662156553883648).'
  id: totrans-893
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个来自卢卡斯·埃德（Lukas Eder）的有趣事实：“`LISTAGG()`不是一个真正的有序集聚合函数。它应该使用与`ARRAY_AGG`相同的*`ORDER
    BY`*语法。”参见这里的讨论：[https://twitter.com/lukaseder/status/1237662156553883648](https://twitter.com/lukaseder/status/1237662156553883648)。
- en: You can practice these examples and more in *OrderedSetAggregateFunctions*.
  id: totrans-894
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在*OrderedSetAggregateFunctions*中练习这些示例和其他示例。
- en: Grouping, filtering, distinctness, and functions
  id: totrans-895
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分组、过滤、唯一性和函数
- en: In this section, *grouping* refers to the usage of `GROUP BY` with functions,
    *filtering* refers to the usage of the `FILTER` clause with functions, and *distinctness*
    refers to aggregate functions on distinct values.
  id: totrans-896
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，*分组*指的是使用带有函数的`GROUP BY`，*过滤*指的是使用带有函数的`FILTER`子句，而*唯一性*指的是对唯一值上的聚合函数。
- en: Grouping
  id: totrans-897
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 分组
- en: As you already know, `GROUP BY` is a SQL clause useful for arranging rows in
    groups via one (or more) column given as an argument. Rows that land in a group
    have matching values in the given columns/expressions. Typical use cases apply
    aggregate functions on groups of data produced by `GROUP BY`.
  id: totrans-898
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所知，`GROUP BY` 是一个SQL子句，用于通过一个（或多个）作为参数给出的列对行进行分组。落在组中的行在给定列/表达式中具有匹配的值。典型的用例是在
    `GROUP BY` 产生的数据组上应用聚合函数。
- en: Important Note
  id: totrans-899
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Especially when dealing with multiple dialects, it is correct to list all non-aggregated
    columns from the `SELECT` clause in the `GROUP BY` clause. This way, you avoid
    potentially indeterminate/random behavior and errors across dialects (some of
    them will not ask you to do this (for example, MySQL), while others will (for
    example, Oracle)).
  id: totrans-900
  prefs: []
  type: TYPE_NORMAL
  zh: 尤其是在处理多个方言时，正确做法是在 `GROUP BY` 子句中列出 `SELECT` 子句中的所有非聚合列。这样，您可以避免在不同方言中可能的不确定/随机行为和错误（其中一些不会要求您这样做，例如
    MySQL），而另一些则会（例如 Oracle）。
- en: 'jOOQ supports `GROUP BY` in all dialects, therefore here is an example of fetching
    offices (`OFFICE`) having fewer than three employees:'
  id: totrans-901
  prefs: []
  type: TYPE_NORMAL
  zh: jOOQ 在所有方言中都支持 `GROUP BY`，因此以下是一个获取员工少于三个的办公室（`OFFICE`）的例子：
- en: '[PRE544]'
  id: totrans-902
  prefs: []
  type: TYPE_PRE
  zh: '[PRE544]'
- en: '[PRE545]'
  id: totrans-903
  prefs: []
  type: TYPE_PRE
  zh: '[PRE545]'
- en: '[PRE546]'
  id: totrans-904
  prefs: []
  type: TYPE_PRE
  zh: '[PRE546]'
- en: '[PRE547]'
  id: totrans-905
  prefs: []
  type: TYPE_PRE
  zh: '[PRE547]'
- en: '[PRE548]'
  id: totrans-906
  prefs: []
  type: TYPE_PRE
  zh: '[PRE548]'
- en: '[PRE549]'
  id: totrans-907
  prefs: []
  type: TYPE_PRE
  zh: '[PRE549]'
- en: '[PRE550]'
  id: totrans-908
  prefs: []
  type: TYPE_PRE
  zh: '[PRE550]'
- en: 'Here is another example that computes the sum of sales per employee per year,
    and after that, it computes the average of these sums per employee:'
  id: totrans-909
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是另一个例子，它计算每位员工每年的销售额总和，然后计算这些总和的平均值：
- en: '[PRE551]'
  id: totrans-910
  prefs: []
  type: TYPE_PRE
  zh: '[PRE551]'
- en: '[PRE552]'
  id: totrans-911
  prefs: []
  type: TYPE_PRE
  zh: '[PRE552]'
- en: '[PRE553]'
  id: totrans-912
  prefs: []
  type: TYPE_PRE
  zh: '[PRE553]'
- en: '[PRE554]'
  id: totrans-913
  prefs: []
  type: TYPE_PRE
  zh: '[PRE554]'
- en: '[PRE555]'
  id: totrans-914
  prefs: []
  type: TYPE_PRE
  zh: '[PRE555]'
- en: '[PRE556]'
  id: totrans-915
  prefs: []
  type: TYPE_PRE
  zh: '[PRE556]'
- en: '[PRE557]'
  id: totrans-916
  prefs: []
  type: TYPE_PRE
  zh: '[PRE557]'
- en: '[PRE558]'
  id: totrans-917
  prefs: []
  type: TYPE_PRE
  zh: '[PRE558]'
- en: '[PRE559]'
  id: totrans-918
  prefs: []
  type: TYPE_PRE
  zh: '[PRE559]'
- en: You can find more examples of using `GROUP BY` in *GroupByDistinctFilter*.
  id: totrans-919
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在 *GroupByDistinctFilter* 中找到更多使用 `GROUP BY` 的例子。
- en: Filtering
  id: totrans-920
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 过滤
- en: 'If we want to refine a query by applying aggregations against a limited set
    of the values in a column, then we can use `CASE` expressions, as in this example,
    which sum the salaries of sales reps and the rest of the employees:'
  id: totrans-921
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要通过针对列中有限值的集合应用聚合来细化查询，那么我们可以使用 `CASE` 表达式，如下例所示，它计算销售代表和其他员工的工资总和：
- en: '[PRE560]'
  id: totrans-922
  prefs: []
  type: TYPE_PRE
  zh: '[PRE560]'
- en: '[PRE561]'
  id: totrans-923
  prefs: []
  type: TYPE_PRE
  zh: '[PRE561]'
- en: '[PRE562]'
  id: totrans-924
  prefs: []
  type: TYPE_PRE
  zh: '[PRE562]'
- en: '[PRE563]'
  id: totrans-925
  prefs: []
  type: TYPE_PRE
  zh: '[PRE563]'
- en: '[PRE564]'
  id: totrans-926
  prefs: []
  type: TYPE_PRE
  zh: '[PRE564]'
- en: '[PRE565]'
  id: totrans-927
  prefs: []
  type: TYPE_PRE
  zh: '[PRE565]'
- en: 'As you can see, `CASE` is flexible but it''s a bit tedious. A more straightforward
    solution is represented by the `FILTER` clause, exposed by jOOQ via the `filterWhere()`
    method, and emulated for every dialect that doesn''t support it (usually via `CASE`
    expressions). The previous query can be expressed via `FILTER`, as follows:'
  id: totrans-928
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，`CASE` 很灵活，但有点繁琐。一个更直接的方法是通过 `FILTER` 子句，这是 jOOQ 通过 `filterWhere()` 方法公开的，并且为不支持它的每个方言模拟（通常通过
    `CASE` 表达式）。之前的查询可以通过 `FILTER` 表达如下：
- en: '[PRE566]'
  id: totrans-929
  prefs: []
  type: TYPE_PRE
  zh: '[PRE566]'
- en: '[PRE567]'
  id: totrans-930
  prefs: []
  type: TYPE_PRE
  zh: '[PRE567]'
- en: '[PRE568]'
  id: totrans-931
  prefs: []
  type: TYPE_PRE
  zh: '[PRE568]'
- en: '[PRE569]'
  id: totrans-932
  prefs: []
  type: TYPE_PRE
  zh: '[PRE569]'
- en: '[PRE570]'
  id: totrans-933
  prefs: []
  type: TYPE_PRE
  zh: '[PRE570]'
- en: '[PRE571]'
  id: totrans-934
  prefs: []
  type: TYPE_PRE
  zh: '[PRE571]'
- en: '[PRE572]'
  id: totrans-935
  prefs: []
  type: TYPE_PRE
  zh: '[PRE572]'
- en: 'Or, here is an example of removing `NULL` values for `ARRAY_AGG()`:'
  id: totrans-936
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，以下是一个移除 `ARRAY_AGG()` 中的 `NULL` 值的例子：
- en: '[PRE573]'
  id: totrans-937
  prefs: []
  type: TYPE_PRE
  zh: '[PRE573]'
- en: '[PRE574]'
  id: totrans-938
  prefs: []
  type: TYPE_PRE
  zh: '[PRE574]'
- en: '[PRE575]'
  id: totrans-939
  prefs: []
  type: TYPE_PRE
  zh: '[PRE575]'
- en: 'Another use case for `FILTER` is related to pivoting rows to columns. For instance,
    check out this query, which produces the sales per month and per year:'
  id: totrans-940
  prefs: []
  type: TYPE_NORMAL
  zh: '`FILTER` 的另一个用途与将行转换为列的转置相关。例如，查看以下查询，它生成了每月和每年的销售额：'
- en: '[PRE576]'
  id: totrans-941
  prefs: []
  type: TYPE_PRE
  zh: '[PRE576]'
- en: '[PRE577]'
  id: totrans-942
  prefs: []
  type: TYPE_PRE
  zh: '[PRE577]'
- en: '[PRE578]'
  id: totrans-943
  prefs: []
  type: TYPE_PRE
  zh: '[PRE578]'
- en: '[PRE579]'
  id: totrans-944
  prefs: []
  type: TYPE_PRE
  zh: '[PRE579]'
- en: 'The query returns the correct result but in an unexpected form. Its vertical
    form having one value per row is not quite readable for users. Most probably,
    a user will be more familiar with a form having one row per year and a dedicated
    column per month. So, turning the rows of a year into columns should solve the
    problem, and this can be accomplished in several ways, including the `FILTER`
    clause, as shown here:'
  id: totrans-945
  prefs: []
  type: TYPE_NORMAL
  zh: 查询返回了正确的结果，但形式出人意料。其垂直形式每行一个值，对于用户来说不太易读。很可能是用户更熟悉每年一行且每月有专用列的形式。因此，将一年的行转换为列应该能解决问题，这可以通过多种方式实现，包括
    `FILTER` 子句，如下所示：
- en: '[PRE580]'
  id: totrans-946
  prefs: []
  type: TYPE_PRE
  zh: '[PRE580]'
- en: '[PRE581]'
  id: totrans-947
  prefs: []
  type: TYPE_PRE
  zh: '[PRE581]'
- en: '[PRE582]'
  id: totrans-948
  prefs: []
  type: TYPE_PRE
  zh: '[PRE582]'
- en: '[PRE583]'
  id: totrans-949
  prefs: []
  type: TYPE_PRE
  zh: '[PRE583]'
- en: '[PRE584]'
  id: totrans-950
  prefs: []
  type: TYPE_PRE
  zh: '[PRE584]'
- en: '[PRE585]'
  id: totrans-951
  prefs: []
  type: TYPE_PRE
  zh: '[PRE585]'
- en: '[PRE586]'
  id: totrans-952
  prefs: []
  type: TYPE_PRE
  zh: '[PRE586]'
- en: '[PRE587]'
  id: totrans-953
  prefs: []
  type: TYPE_PRE
  zh: '[PRE587]'
- en: '[PRE588]'
  id: totrans-954
  prefs: []
  type: TYPE_PRE
  zh: '[PRE588]'
- en: 'The `FILTER` clause can be considered with aggregate functions used as window
    functions as well. In such cases, `filterWhere()` comes between the aggregate
    function and the `OVER()` clause. For instance, the following query sums the salaries
    of employees per office only for employees that don''t get a commission:'
  id: totrans-955
  prefs: []
  type: TYPE_NORMAL
  zh: '`FILTER` 子句也可以与用作窗口函数的聚合函数一起考虑。在这种情况下，`filterWhere()` 位于聚合函数和 `OVER()` 子句之间。例如，以下查询仅对没有获得佣金员工的工资进行求和：'
- en: '[PRE589]'
  id: totrans-956
  prefs: []
  type: TYPE_PRE
  zh: '[PRE589]'
- en: '[PRE590]'
  id: totrans-957
  prefs: []
  type: TYPE_PRE
  zh: '[PRE590]'
- en: '[PRE591]'
  id: totrans-958
  prefs: []
  type: TYPE_PRE
  zh: '[PRE591]'
- en: '[PRE592]'
  id: totrans-959
  prefs: []
  type: TYPE_PRE
  zh: '[PRE592]'
- en: '[PRE593]'
  id: totrans-960
  prefs: []
  type: TYPE_PRE
  zh: '[PRE593]'
- en: '[PRE594]'
  id: totrans-961
  prefs: []
  type: TYPE_PRE
  zh: '[PRE594]'
- en: '[PRE595]'
  id: totrans-962
  prefs: []
  type: TYPE_PRE
  zh: '[PRE595]'
- en: '[PRE596]'
  id: totrans-963
  prefs: []
  type: TYPE_PRE
  zh: '[PRE596]'
- en: 'Moreover, the `FILTER` clause can be used with ordered set aggregate functions.
    This way, we can remove rows that don''t pass the filter before the aggregation
    takes place. Here is an example of filtering employees having salaries higher
    than *$80,000* and collecting the result via `LISTAGG()`:'
  id: totrans-964
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，`FILTER` 子句还可以与有序集聚合函数一起使用。这样，我们可以在聚合之前移除未通过过滤器的行。以下是一个过滤工资高于 *$80,000* 的员工的例子，并通过
    `LISTAGG()` 收集结果：
- en: '[PRE597]'
  id: totrans-965
  prefs: []
  type: TYPE_PRE
  zh: '[PRE597]'
- en: '[PRE598]'
  id: totrans-966
  prefs: []
  type: TYPE_PRE
  zh: '[PRE598]'
- en: '[PRE599]'
  id: totrans-967
  prefs: []
  type: TYPE_PRE
  zh: '[PRE599]'
- en: '[PRE600]'
  id: totrans-968
  prefs: []
  type: TYPE_PRE
  zh: '[PRE600]'
- en: 'Since you are here, I am sure that you''ll love this article by Lukas Eder
    about calculating multiple aggregate functions in a single query: [https://blog.jooq.org/2017/04/20/how-to-calculate-multiple-aggregate-functions-in-a-single-query/](https://blog.jooq.org/2017/04/20/how-to-calculate-multiple-aggregate-functions-in-a-single-query/).'
  id: totrans-969
  prefs: []
  type: TYPE_NORMAL
- en: You can practice the examples and more in the *GroupByDistinctFilter* bundled
    code.
  id: totrans-970
  prefs: []
  type: TYPE_NORMAL
- en: Distinctness
  id: totrans-971
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Most aggregate functions come with a variant for applying them to a distinct
    set of values. While you can find all of them in the jOOQ documentation, let's
    quickly list here `countDistinct()`, `sumDistinct()`, `avgDistinct()`, `productDistinct()`,
    `groupConcatDistinct``()`, `arrayAggDistinct()`, and `collectDistinct()`. For
    completeness' sake, we also have `minDistinct()` and `maxDistinct()`. When a function
    is not supported by jOOQ, we can still call it via the general `aggregateDistinct()`
    function.
  id: totrans-972
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example of using `countDistinct()` for fetching employees having
    sales in at least 3 distinct years:'
  id: totrans-973
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE601]'
  id: totrans-974
  prefs: []
  type: TYPE_PRE
  zh: '[PRE601]'
- en: '[PRE602]'
  id: totrans-975
  prefs: []
  type: TYPE_PRE
  zh: '[PRE602]'
- en: '[PRE603]'
  id: totrans-976
  prefs: []
  type: TYPE_PRE
  zh: '[PRE603]'
- en: '[PRE604]'
  id: totrans-977
  prefs: []
  type: TYPE_PRE
  zh: '[PRE604]'
- en: More examples are available in the *GroupByDistinctFilter* bundled code.
  id: totrans-978
  prefs: []
  type: TYPE_NORMAL
- en: Grouping sets
  id: totrans-979
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For those not familiar with *grouping sets*, let''s briefly follow a scenario
    meant to quickly introduce and cover this notion. Consider the following screenshot:'
  id: totrans-980
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.24 – Two queries using a grouping set each'
  id: totrans-981
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16833_Figure_13.24.jpg)'
  id: totrans-982
  prefs: []
  type: TYPE_NORMAL
- en: Figure 13.24 – Two queries using a grouping set each
  id: totrans-983
  prefs: []
  type: TYPE_NORMAL
- en: The `groupBy(SALE.EMPLOYEE_NUMBER)` construction from the left-hand side (respectively,
    `groupBy(SALE.FISCAL_YEAR)` from the right-hand side) is referred to as a *grouping
    set*. A grouping set can contain none (empty grouping set), one, or more columns.
    In our case, both grouping sets contain one column.
  id: totrans-984
  prefs: []
  type: TYPE_NORMAL
- en: 'Getting a unified result set of these two result sets containing the aggregated
    data of both grouping sets can be done via the `UNION ALL` operator, as illustrated
    here:'
  id: totrans-985
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.25 – Union grouping sets'
  id: totrans-986
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16833_Figure_13.25.jpg)'
  id: totrans-987
  prefs: []
  type: TYPE_NORMAL
- en: Figure 13.25 – Union grouping sets
  id: totrans-988
  prefs: []
  type: TYPE_NORMAL
- en: 'But, as you can see, even for only two grouping sets, this query is quite lengthy.
    Moreover, it needs to resolve two `SELECT` statements before combining their results
    into a single result set. Here is where the `GROUPING SETS(column_list)` clause
    of `GROUP BY` enters the scene. This clause represents a handy shorthand for a
    series of `UNION`-ed queries, and it can be used in the following example of rewriting
    the previous query:'
  id: totrans-989
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE605]'
  id: totrans-990
  prefs: []
  type: TYPE_PRE
  zh: '[PRE605]'
- en: '[PRE606]'
  id: totrans-991
  prefs: []
  type: TYPE_PRE
  zh: '[PRE606]'
- en: '[PRE607]'
  id: totrans-992
  prefs: []
  type: TYPE_PRE
  zh: '[PRE607]'
- en: '[PRE608]'
  id: totrans-993
  prefs: []
  type: TYPE_PRE
  zh: '[PRE608]'
- en: '[PRE609]'
  id: totrans-994
  prefs: []
  type: TYPE_PRE
  zh: '[PRE609]'
- en: '[PRE610]'
  id: totrans-995
  prefs: []
  type: TYPE_PRE
  zh: '[PRE610]'
- en: Cool, right?! Nevertheless, there is an issue that should be considered. `GROUPING
    SETS()` will generate `NULL` values for each dimension at the subtotal levels.
    In other words, it is quite hard to distinguish between a real `NULL` value (present
    in the original data) and a generated `NULL` value. But this job is the responsibility
    of the `GROUPING()` function, which returns 0 for `NULL` values in the original
    data and, respectively, 1 for generated `NULL` values that indicate a subtotal.
  id: totrans-996
  prefs: []
  type: TYPE_NORMAL
- en: 'For instance, if we write a query in the `groupBy(groupingSets(OFFICE.CITY,
    OFFICE.COUNTRY))` clause, then we will need to distinguish between generated `NULL`
    values and `NULL` values of `OFFICE.CITY` and, respectively, `OFFICE.COUNTRY`.
    By using `GROUPING()` to form a condition of a `CASE` expression, we can achieve
    this, like so:'
  id: totrans-997
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果我们在一个`groupBy(groupingSets(OFFICE.CITY, OFFICE.COUNTRY))`子句中编写查询，那么我们需要区分生成的`NULL`值和`OFFICE.CITY`以及`OFFICE.COUNTRY`的`NULL`值。通过使用`GROUPING()`来形成`CASE`表达式的条件，我们可以实现这一点，如下所示：
- en: '[PRE611]'
  id: totrans-998
  prefs: []
  type: TYPE_PRE
  zh: '[PRE611]'
- en: '[PRE612]'
  id: totrans-999
  prefs: []
  type: TYPE_PRE
  zh: '[PRE612]'
- en: '[PRE613]'
  id: totrans-1000
  prefs: []
  type: TYPE_PRE
  zh: '[PRE613]'
- en: '[PRE614]'
  id: totrans-1001
  prefs: []
  type: TYPE_PRE
  zh: '[PRE614]'
- en: '[PRE615]'
  id: totrans-1002
  prefs: []
  type: TYPE_PRE
  zh: '[PRE615]'
- en: '[PRE616]'
  id: totrans-1003
  prefs: []
  type: TYPE_PRE
  zh: '[PRE616]'
- en: '[PRE617]'
  id: totrans-1004
  prefs: []
  type: TYPE_PRE
  zh: '[PRE617]'
- en: '[PRE618]'
  id: totrans-1005
  prefs: []
  type: TYPE_PRE
  zh: '[PRE618]'
- en: '[PRE619]'
  id: totrans-1006
  prefs: []
  type: TYPE_PRE
  zh: '[PRE619]'
- en: 'In this query, we replaced every generated `NULL` value with the text `{generated}`,
    while the `NULL` values on the original data will be fetched as `NULL` values.
    So, we now have a clear picture of `NULL` values'' provenience, as illustrated
    here:'
  id: totrans-1007
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个查询中，我们将每个生成的`NULL`值替换为文本`{generated}`，而原始数据上的`NULL`值将被检索为`NULL`值。因此，我们现在对`NULL`值的来源有了清晰的了解，如图所示：
- en: '![Figure 13.26 – No grouping (left-hand side) versus grouping (right-hand side)'
  id: totrans-1008
  prefs: []
  type: TYPE_NORMAL
  zh: '![图13.26 – 无分组（左侧）与分组（右侧）'
- en: '](img/B16833_Figure_13.26.jpg)'
  id: totrans-1009
  prefs: []
  type: TYPE_NORMAL
  zh: '![图13.26](img/B16833_Figure_13.26.jpg)'
- en: Figure 13.26 – No grouping (left-hand side) versus grouping (right-hand side)
  id: totrans-1010
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.26 – 无分组（左侧）与分组（右侧）
- en: 'Most probably, `{null}` and `{generated}` will not be very attractive for our
    clients, so we can tune this query a little bit to be more friendly by replacing
    `{null}` with `"Unspecified"` and `{generated}` with `"-"`, like so:'
  id: totrans-1011
  prefs: []
  type: TYPE_NORMAL
  zh: 很可能，`{null}`和`{generated}`对我们的客户来说不会很有吸引力，因此我们可以稍微调整这个查询，使其更加友好，将`{null}`替换为`"未指定"`，将`{generated}`替换为`"-"`，如下所示：
- en: '[PRE620]'
  id: totrans-1012
  prefs: []
  type: TYPE_PRE
  zh: '[PRE620]'
- en: '[PRE621]'
  id: totrans-1013
  prefs: []
  type: TYPE_PRE
  zh: '[PRE621]'
- en: '[PRE622]'
  id: totrans-1014
  prefs: []
  type: TYPE_PRE
  zh: '[PRE622]'
- en: '[PRE623]'
  id: totrans-1015
  prefs: []
  type: TYPE_PRE
  zh: '[PRE623]'
- en: '[PRE624]'
  id: totrans-1016
  prefs: []
  type: TYPE_PRE
  zh: '[PRE624]'
- en: '[PRE625]'
  id: totrans-1017
  prefs: []
  type: TYPE_PRE
  zh: '[PRE625]'
- en: '[PRE626]'
  id: totrans-1018
  prefs: []
  type: TYPE_PRE
  zh: '[PRE626]'
- en: '[PRE627]'
  id: totrans-1019
  prefs: []
  type: TYPE_PRE
  zh: '[PRE627]'
- en: Next to `GROUPING SETS()`, we have `ROLLUP` and `CUBE`. These two extensions
    of the `GROUP BY` clause are syntactic sugar of `GROUPING SETS()`.
  id: totrans-1020
  prefs: []
  type: TYPE_NORMAL
  zh: 在`GROUPING SETS()`旁边，我们有`ROLLUP`和`CUBE`。这两个`GROUP BY`子句的扩展是`GROUPING SETS()`的语法糖。
- en: 'The `ROLLUP` group is a series of grouping sets. For instance, `GROUP BY ROLLUP
    (x, y, z)` is equivalent to `GROUP BY GROUPING SETS ((x, y, z), (x, y), (x), ())`.
    `ROLLUP` is typically applied for aggregates of hierarchical data such as sales
    by year > quarter > month > week, or offices internal budget per territory > state
    > country > city, as shown here:'
  id: totrans-1021
  prefs: []
  type: TYPE_NORMAL
  zh: '`ROLLUP`分组是一系列分组集。例如，`GROUP BY ROLLUP (x, y, z)`等价于`GROUP BY GROUPING SETS
    ((x, y, z), (x, y), (x), ())`。`ROLLUP`通常用于层次数据的聚合，例如按年份 > 季度 > 月份 > 周的销售，或按地区
    > 州 > 国家 > 城市的内部预算，如下所示：'
- en: '[PRE628]'
  id: totrans-1022
  prefs: []
  type: TYPE_PRE
  zh: '[PRE628]'
- en: '[PRE629]'
  id: totrans-1023
  prefs: []
  type: TYPE_PRE
  zh: '[PRE629]'
- en: '[PRE630]'
  id: totrans-1024
  prefs: []
  type: TYPE_PRE
  zh: '[PRE630]'
- en: '[PRE631]'
  id: totrans-1025
  prefs: []
  type: TYPE_PRE
  zh: '[PRE631]'
- en: '[PRE632]'
  id: totrans-1026
  prefs: []
  type: TYPE_PRE
  zh: '[PRE632]'
- en: '[PRE633]'
  id: totrans-1027
  prefs: []
  type: TYPE_PRE
  zh: '[PRE633]'
- en: '[PRE634]'
  id: totrans-1028
  prefs: []
  type: TYPE_PRE
  zh: '[PRE634]'
- en: '[PRE635]'
  id: totrans-1029
  prefs: []
  type: TYPE_PRE
  zh: '[PRE635]'
- en: '[PRE636]'
  id: totrans-1030
  prefs: []
  type: TYPE_PRE
  zh: '[PRE636]'
- en: '[PRE637]'
  id: totrans-1031
  prefs: []
  type: TYPE_PRE
  zh: '[PRE637]'
- en: '[PRE638]'
  id: totrans-1032
  prefs: []
  type: TYPE_PRE
  zh: '[PRE638]'
- en: '[PRE639]'
  id: totrans-1033
  prefs: []
  type: TYPE_PRE
  zh: '[PRE639]'
- en: '[PRE640]'
  id: totrans-1034
  prefs: []
  type: TYPE_PRE
  zh: '[PRE640]'
- en: '[PRE641]'
  id: totrans-1035
  prefs: []
  type: TYPE_PRE
  zh: '[PRE641]'
- en: 'And the output is shown here:'
  id: totrans-1036
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下所示：
- en: '![Figure 13.27 – ROLLUP output'
  id: totrans-1037
  prefs: []
  type: TYPE_NORMAL
  zh: '![图13.27 – ROLLUP输出'
- en: '](img/B16833_Figure_13.27.jpg)'
  id: totrans-1038
  prefs: []
  type: TYPE_NORMAL
  zh: '![图13.27](img/B16833_Figure_13.27.jpg)'
- en: Figure 13.27 – ROLLUP output
  id: totrans-1039
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.27 – ROLLUP输出
- en: As with `ROLLUP`, a `CUBE` group can also be perceived as a series of grouping
    sets. However, `CUBE` calculates all permutations of the cubed grouping expression
    along with the grand total. So, for *n* elements, `CUBE` produces 2n grouping
    sets. For instance `GROUP BY CUBE (x, y, x)` is equivalent to `GROUP BY GROUPING
    SETS ((x, y, z), (x, y), (x, z), (y, z), (x), (y), (z), ())`.
  id: totrans-1040
  prefs: []
  type: TYPE_NORMAL
  zh: 与`ROLLUP`类似，`CUBE`分组也可以被视为一系列分组集。然而，`CUBE`计算立方分组表达式的所有排列以及总和。因此，对于*n*个元素，`CUBE`产生2^n个分组集。例如，`GROUP
    BY CUBE (x, y, x)`等价于`GROUP BY GROUPING SETS ((x, y, z), (x, y), (x, z), (y, z),
    (x), (y), (z), ())`。
- en: 'Let''s apply `CUBE` for computing the sum of the internal budget for offices
    by state, country, and city. The query is shown here:'
  id: totrans-1041
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们应用`CUBE`来计算按州、国家和城市计算办公室内部预算的总和。查询如下所示：
- en: '[PRE642]'
  id: totrans-1042
  prefs: []
  type: TYPE_PRE
  zh: '[PRE642]'
- en: '[PRE643]'
  id: totrans-1043
  prefs: []
  type: TYPE_PRE
  zh: '[PRE643]'
- en: '[PRE644]'
  id: totrans-1044
  prefs: []
  type: TYPE_PRE
  zh: '[PRE644]'
- en: '[PRE645]'
  id: totrans-1045
  prefs: []
  type: TYPE_PRE
  zh: '[PRE645]'
- en: '[PRE646]'
  id: totrans-1046
  prefs: []
  type: TYPE_PRE
  zh: '[PRE646]'
- en: '[PRE647]'
  id: totrans-1047
  prefs: []
  type: TYPE_PRE
  zh: '[PRE647]'
- en: '[PRE648]'
  id: totrans-1048
  prefs: []
  type: TYPE_PRE
  zh: '[PRE648]'
- en: '[PRE649]'
  id: totrans-1049
  prefs: []
  type: TYPE_PRE
  zh: '[PRE649]'
- en: '[PRE650]'
  id: totrans-1050
  prefs: []
  type: TYPE_PRE
  zh: '[PRE650]'
- en: '[PRE651]'
  id: totrans-1051
  prefs: []
  type: TYPE_PRE
  zh: '[PRE651]'
- en: '[PRE652]'
  id: totrans-1052
  prefs: []
  type: TYPE_PRE
  zh: '[PRE652]'
- en: '[PRE653]'
  id: totrans-1053
  prefs: []
  type: TYPE_PRE
  zh: '[PRE653]'
- en: 'Finally, let''s talk about the `GROUPING_ID()` function. This function computes
    the decimal equivalent of the binary value obtained by concatenating the values
    returned by the `GROUPING()` functions applied to all the columns of the `GROUP
    BY` clause. Here is an example of using `GROUPING_ID()` via jOOQ `groupingId()`:'
  id: totrans-1054
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们来谈谈`GROUPING_ID()`函数。这个函数计算通过连接应用于`GROUP BY`子句中所有列的`GROUPING()`函数返回的值的二进制值的十进制等价物。以下是通过jOOQ的`groupingId()`使用`GROUPING_ID()`的示例：
- en: '[PRE654]'
  id: totrans-1055
  prefs: []
  type: TYPE_PRE
  zh: '[PRE654]'
- en: '[PRE655]'
  id: totrans-1056
  prefs: []
  type: TYPE_PRE
  zh: '[PRE655]'
- en: '[PRE656]'
  id: totrans-1057
  prefs: []
  type: TYPE_PRE
  zh: '[PRE656]'
- en: '[PRE657]'
  id: totrans-1058
  prefs: []
  type: TYPE_PRE
  zh: '[PRE657]'
- en: '[PRE658]'
  id: totrans-1059
  prefs: []
  type: TYPE_PRE
  zh: '[PRE658]'
- en: '[PRE659]'
  id: totrans-1060
  prefs: []
  type: TYPE_PRE
  zh: '[PRE659]'
- en: '[PRE660]'
  id: totrans-1061
  prefs: []
  type: TYPE_PRE
  zh: '[PRE660]'
- en: '[PRE661]'
  id: totrans-1062
  prefs: []
  type: TYPE_PRE
  zh: '[PRE661]'
- en: '[PRE662]'
  id: totrans-1063
  prefs: []
  type: TYPE_PRE
  zh: '[PRE662]'
- en: '[PRE663]'
  id: totrans-1064
  prefs: []
  type: TYPE_PRE
  zh: '[PRE663]'
- en: '[PRE664]'
  id: totrans-1065
  prefs: []
  type: TYPE_PRE
  zh: '[PRE664]'
- en: '[PRE665]'
  id: totrans-1066
  prefs: []
  type: TYPE_PRE
  zh: '[PRE665]'
- en: '[PRE666]'
  id: totrans-1067
  prefs: []
  type: TYPE_PRE
  zh: '[PRE666]'
- en: '[PRE667]'
  id: totrans-1068
  prefs: []
  type: TYPE_PRE
  zh: '[PRE667]'
- en: 'The following screenshot shows a sample output:'
  id: totrans-1069
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的屏幕截图显示了示例输出：
- en: '![Figure 13.28 – GROUPING_ID() output'
  id: totrans-1070
  prefs: []
  type: TYPE_NORMAL
  zh: '![图13.28 – GROUPING_ID()输出'
- en: '](img/B16833_Figure_13.28.jpg)'
  id: totrans-1071
  prefs: []
  type: TYPE_NORMAL
  zh: '![图13.28](img/B16833_Figure_13.28.jpg)'
- en: Figure 13.28 – GROUPING_ID() output
  id: totrans-1072
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.28 – GROUPING_ID()输出
- en: '`GROUPING_ID()` can also be used in `HAVING` for creating conditions, as follows:'
  id: totrans-1073
  prefs: []
  type: TYPE_NORMAL
  zh: '`GROUPING_ID()`也可以用于`HAVING`来创建条件，如下所示：'
- en: '[PRE668]'
  id: totrans-1074
  prefs: []
  type: TYPE_PRE
  zh: '[PRE668]'
- en: '[PRE669]'
  id: totrans-1075
  prefs: []
  type: TYPE_PRE
  zh: '[PRE669]'
- en: The complete query is available in the *GroupingRollupCube* bundled code.
  id: totrans-1076
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的查询可以在`GroupingRollupCube`捆绑代码中找到。
- en: Summary
  id: totrans-1077
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: 'Working with SQL functions is such fun! They truly boost the SQL world and
    allow us to solve so many problems during data manipulation. As you saw in this
    chapter, jOOQ provides comprehensive support to SQL functions, covering regular
    and aggregate functions to the mighty window functions, ordered set aggregate
    functions (`WITHIN GROUP`), and so on. While we''re on this topic, allow me to
    recommend the following article as a great read: [https://blog.jooq.org/how-to-find-the-closest-subset-sum-with-sql/](https://blog.jooq.org/how-to-find-the-closest-subset-sum-with-sql/).
    In the next chapter, we tackle virtual tables (vtables).'
  id: totrans-1078
  prefs: []
  type: TYPE_NORMAL
  zh: 与 SQL 函数一起工作真是太有趣了！它们真正提升了 SQL 世界，并允许我们在数据处理过程中解决许多问题。正如你在本章中看到的，jOOQ 提供了对 SQL
    函数的全面支持，涵盖了常规函数和聚合函数，到强大的窗口函数，有序集聚合函数（`WITHIN GROUP`）等等。当我们谈论这个话题时，请允许我推荐以下文章作为一篇极佳的阅读材料：[https://blog.jooq.org/how-to-find-the-closest-subset-sum-with-sql/](https://blog.jooq.org/how-to-find-the-closest-subset-sum-with-sql/).
    在下一章中，我们将探讨虚拟表（vtables）。
