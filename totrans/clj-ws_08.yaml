- en: 8\. Namespaces, Libraries and Leiningen
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Overview
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we learn how to organize Clojure code. We start by looking
    at namespacesâ€”a way to group Clojure functions together. We will see how to create
    our own namespaces and how to import namespaces written by others. Namespaces
    are building blocks of Clojure libraries. We will learn how to import and use
    Clojure libraries. After learning about namespaces and libraries, we investigate
    how to structure a Clojure project. We then look at Leiningen project template
    and how it helps developers to create applications.
  prefs: []
  type: TYPE_NORMAL
- en: By the end of this chapter, you will be able to use Leiningen to organize and
    run your projects.
  prefs: []
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we learned about sequences in Clojure and how working
    with them helps us to build Clojure programs. Now that you're familiar with using
    Clojure to implement various pieces of functionality, it's time to become more
    comfortable with accomplishing the basic tasks of creating, building, testing,
    deploying, and running projects in Clojure and ClojureScript.
  prefs: []
  type: TYPE_NORMAL
- en: Clojure was designed to be a very practical language from the beginning. Getting
    things done means interacting with the outside world, building projects, using
    libraries, and deploying your work. As a developer, you will need to organize
    written code in a structure. In this chapter, you will see how namespaces can
    help you structure code and how build tools such as Leiningen help you put together
    a whole application.
  prefs: []
  type: TYPE_NORMAL
- en: In a real-world project, you won't write all the code. External dependencies
    are a crucial part of any project, and we'll learn here how to bring them into
    your project and your code.
  prefs: []
  type: TYPE_NORMAL
- en: The first step is to understand how Clojure namespaces work in general. Then
    we'll look at the project level and using Leiningen and your `project.clj` file
    to pull everything together into a Java executable. Finally, we'll take a look
    at some of the conveniences that Leiningen provides throughout the life cycle
    of a project.
  prefs: []
  type: TYPE_NORMAL
- en: Namespaces
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Namespaces are a way to organize Clojure functions; you can think of a namespace
    as being a directory (or file) that stores a particular group of functions. Each
    directory is independent of other directories; this helps to keep different groups
    of functions separate and gives a clear structure to your code. It also helps
    to avoid the confusion that can come with naming clashes.
  prefs: []
  type: TYPE_NORMAL
- en: Consider a situation where you have written a function called `calculate-total`,
    and as part of your project, you're using a library *(more on libraries later
    in this chapter)* that also contains a function called `calculate-total`. Although
    these functions have the same name, they work differently, produce slightly different
    outputs, and are intended to be used in different situations. When you come to
    use `calculate-total` in your code, how does the system know which `calculate-function`
    you actually want? That's where namespaces come in. The two functions will exist
    in different namespaces, so you can state the appropriate namespace when calling
    the function in order to specify which one you want to use.
  prefs: []
  type: TYPE_NORMAL
- en: In more technical terms, namespaces provide a mapping between a symbol (which
    makes sense to a human reader) and a var or class. Namespaces can be compared
    to packages in Java or modules in Ruby and Python. We will first explore the concept
    of namespaces in Clojure using REPL.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 8.01: Investigating Namespaces Started by Default in REPL'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this exercise, we will investigate how namespaces are handled in REPL:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open Terminal or Command Prompt and add the following command to start REPL
    using Leiningen:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This will start REPL using Leiningen. It might take several seconds to start
    REPL. Once REPL is started, you should see something similar to the following:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 8.1: Starting REPL'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/B14502_08_01.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 8.1: Starting REPL'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The last line, `user=>`, tells us that we are in the default `user` namespace.
    In this namespace, functions from the `clojure.core` namespace are available to
    us. Let's explore a few functions.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'In REPL, type the following code to calculate the sum of two numbers:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This simple code should return:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Let''s try Clojure''s `filter odd` function to return the odd numbers:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This will return the following:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We see that in the default user namespace, we have access to core Clojure functions.
    But what if we want to access functions that are defined in some other namespaces?
    Clojure provides us with the `in-ns` function, which switches to the requested
    namespace. This function will also create a new namespace if the requested namespace
    does not exist. In the next exercise, we will use the `in-ns` function to access
    data from a different namespace than the one currently being used.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 8.02: Navigating Namespaces'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the previous exercise, we used functions in the default user namespace.
    In this exercise, we will have a look at accessing data from other namespaces:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In Terminal, call the `in-ns` function to create a new namespace:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In REPL, we will see that a new namespace has been created:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 8.2: New namespace created'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/B14502_08_02.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 8.2: New namespace created'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: You should notice that the REPL prompt has changed to `new-namespace=>`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: This visual cue tells us that we have successfully switched to a new namespace.
    Anything you declare inside this namespace will be available in it.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'We will declare a variable in our new namespace. Type the following declaration:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'REPL lets us know that a new variable has been created:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To check its content, we will access it from REPL as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'As expected, REPL gives us back the vector:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We will switch the namespace now using the `in-ns` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'REPL lets us know that the change has happened:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'REPL''s prompt has also changed:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now access the `fruits` vector as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We will see an unpleasant surprise:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We have declared the `fruits` vector in `new-namespace` but we tried to access
    it from another namespace. To access vars from one namespace in another namespace,
    we need to explicitly state which namespace the var comes from.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Type the fully qualified name in REPL to access the data as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This time, we get our `fruits` vector:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Using fully qualified names can become tedious. In the next exercise, we will
    see how Clojure helps us with managing multiple namespaces.
  prefs: []
  type: TYPE_NORMAL
- en: Importing Clojure Namespaces Using the refer Function
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Clojure provides the `refer` function, which aims to help developers write compact
    code. This is achieved by importing the contents of a specific namespace into
    the current namespace, thereby allowing those contents to be accessed easily.
    In the previous example, we used `new-namespace/fruits` to access the `fruits`
    vector from a different namespace outside `new-namespace`. What `refer` allows
    us to do is reference `new-namespace` once and then use `fruits` as many times
    as we need, without having to state the full namespace every time.
  prefs: []
  type: TYPE_NORMAL
- en: In the previous section, we used the `in-ns` function. In this section, we will
    use `refer` function. Although both functions help us to work with namespaces,
    we use them for different purposes. The `in-ns` function creates a scope for our
    code. We place data and functions inside a namespace. When we want to create a
    new namespace and thus a new scope for code, we use `in-ns`. Now, `refer`, on
    the other hand, will allow us to work within the scope of the current namespace
    and import data from a different namespace. We can import one or more namespaces
    and still work in one namespace scope.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 8.03: Using the refer Function to Import a Namespace'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this exercise, we will use the `refer` function to import Clojure namespaces.
    This will help us understand how the `refer` function is used.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using `refer` allows us to reference functions or objects from other namespaces:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In REPL, type the following command to import a new namespace using the `refer`Â function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We used `refer` here to import data from `new-namespace`. If we'd used the `in-ns`
    function, we would have changed the scope of the code. We would be able to access
    data from `new-namespace` but because the scope changed, we would lose access
    to `other-namespace` that we worked at before switching to `new-namespace`. Our
    aim is to write code within the scope of `other-namespace` and only access functions
    from `new-namespace`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'After this, we can use the `fruits` vector directly by calling it in REPL:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Using `refer` allowed us to include all objects from the specified namespace
    in the current one. The `refer` function allows us to use optional keywords to
    control importing namespaces. We will see them in action now.
  prefs: []
  type: TYPE_NORMAL
- en: Advanced Use of the refer Function
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In *Chapter 2*, *Data Types and Immutability*, we learned about keywords in
    Clojure. The basic usage of the `refer` function that we learned in the previous
    section can be altered or expanded using keywords. They are optional as we can
    use them but do not have to.
  prefs: []
  type: TYPE_NORMAL
- en: 'The keywords that we can use with `refer` are:'
  prefs: []
  type: TYPE_NORMAL
- en: '`:only`: The `:only` keyword allows us to import only the functions that we
    specify. This means that any functions not specified are not imported.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`:exclude`: The `:exclude` keyword allows us to exclude certain functions from
    being imported. We would import all but the ones that we want to exclude.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`:rename`: The `:rename` keyword allows us to rename functions that we import.
    This sets an aliasâ€”a new name for a functionâ€”and we would refer to the function
    using that new name.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We now know three keywords that can modify the importing of namespaces using
    the `refer` function. In the next three exercises, we will use each keyword to
    import namespaces and use data from them.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 8.04: Using the :only Keyword'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The aim of this exercise is to show how we can extend the basic use of the
    `refer` function by using the `:only` keyword. We will import namespaces using
    the `refer` function with the `:only` keyword. Then, we will access data from
    the imported namespace:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In REPL, type the following command to use the `in-ns` function to create the
    `garden`Â namespace:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'REPL creates a new namespace for us:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We can define two variables in this namespace:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'REPL informs us that vars have been created:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'After that, we switch to a new namespace using the `in-ns` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: With the `:only` keyword, we can refer to another namespace but import only
    selected parts.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Import the `garden` namespace using the `refer` function together with the
    `:only`Â keyword:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This will return the following:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We can access the `vegetables` var directly in the new `shop` namespace.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Call the `vegetables` var to access its content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'REPL returns the expected vector as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If, however, we want to access another var, `fruits`, call the `fruits` vector
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We get an exception in REPL:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Because when we imported the namespace, we used the `:only` keyword to import
    the `vegetables` var. The other var needs to be fully qualified with a namespace
    if we want to use it.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Call the `fruits` vector using the fully qualified name:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This time, we get the expected vector as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In this exercise, we created vars in one namespace and then we imported this
    namespace using the `refer` function. During the import, we used the `:only` keyword,
    which allowed us to import only the selected data.
  prefs: []
  type: TYPE_NORMAL
- en: In the next exercise, we will import a namespace using the `refer` function
    and the `:exclude` keyword.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 8.05: Using the :exclude Keyword'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the previous exercise, we imported content from one namespace to another
    using the `refer` function. We restricted importing using the `:only` keyword
    to import only selected data. Now we will use a second keyword that allows us
    to control the importing of namespaces with the `refer` function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using the `:exclude` keyword allows us to import some parts from a namespace
    but exclude parts that we do not need:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we will switch to a new namespace using the `in-ns` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'REPL tells us that we successfully switched to a new namespace:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The next step is to import the `garden` namespace but exclude the `vegetables`
    var. We use the `refer` function with the `:exclude` keyword:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This will return the following:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We test the import by trying to access the `fruits` var:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'So far, so good, as REPL returns us the vector:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We will try accessing the excluded var, `vegetables`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We immediately see an exception message in REPL:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We need to use the fully qualified name to access the `vegetables` var:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This time, REPL shows us the expected vector:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In this exercise, we imported a namespace using the `refer` function. During
    the import, we used the `:exclude` keyword, which allowed us to restrict the data
    to be imported.
  prefs: []
  type: TYPE_NORMAL
- en: In the next exercise, we will import a namespace using the `refer` function
    and the `:rename` keyword.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 8.06: Using the :rename Keyword'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the previous exercise, we imported content from one namespace to another
    using the `refer` function. We restricted importing using the `:exclude` keyword
    to import only data that we wanted. Now we will use a third keyword that allows
    us to control the importing of namespaces with the `refer` function.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will see the `:rename` keyword in use. It allows us to import from one namespace
    and rename certain symbols:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We will switch to a new namespace using the `in-ns` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'While we import the `garden` namespace, we want to rename the `fruits` var
    to `owoce` (Polish for fruits). We will use the `refer` function with the `:rename`
    keyword:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We access the `vegetables` var in the REPL:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This returns the vector in the REPL:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Trying to access the `fruits` var:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'It tells us that it is not accessible:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Because we renamed the `fruits` var, we need to access `fruits` with a new name,
    which we defined when we used the `refer` function.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now type `owoce` in the REPL:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This time, we get the expected vector:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In this exercise, we imported a namespace using the `refer` function. During
    the import, we used the `:rename` keyword, which allowed us to restrict what data
    should be imported.
  prefs: []
  type: TYPE_NORMAL
- en: 'We now know how to use `refer`. First, we imported a namespace using the `refer`
    function. Then we saw how we can modify importing with the `refer` function when
    we use three keywords: `:only`, `:exclude`, and `:rename`.'
  prefs: []
  type: TYPE_NORMAL
- en: We use the `:only` keyword when we want to import from one namespace to certain
    other functions. The `:only` keyword allows us to limit the functions that we
    import.
  prefs: []
  type: TYPE_NORMAL
- en: We use the `:exclude` keyword when we want to import from one namespace to another
    but without certain functions. The `:only` keyword allows us to exclude functions
    that we do not want to import.
  prefs: []
  type: TYPE_NORMAL
- en: We use the `:rename` keyword when we want to import from one namespace to another
    and change the names of some functions during the import.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will learn how `require` and `use` help us with managing
    namespaces.
  prefs: []
  type: TYPE_NORMAL
- en: Importing Clojure Functions with require and use
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous section, we learned how to import Clojure functions using `refer`.
    In this section, we will learn how we can import Clojure functions with `require`
    and `use`.
  prefs: []
  type: TYPE_NORMAL
- en: While `refer` allows us to literally refer to other namespaces' vars without
    fully qualifying them, often we need more than that. In the previous exercise,
    we imported a namespace and accessed vars such as `fruits` from it without using
    the namespace name as a prefix to the `garden`/`fruits` var. Often, we want to
    load functions from a namespace and use those functions. If we want to read the
    file, we need to import code from the Clojure I/O library (the library for input-output
    operations such as reading and writing files).
  prefs: []
  type: TYPE_NORMAL
- en: With the `require` function, we will load a namespace that we'll specify. This
    way, functions from the loaded namespace are available in our namespace for use.
    This is a great way to write Clojure code, reuse existing functions, and make
    them available in our code. Although we loaded new functions with `require`, we
    still need to fully qualify them.
  prefs: []
  type: TYPE_NORMAL
- en: While the `require` function allows us to load a designated namespace, the `use`
    function goes a little bit further and implicitly uses `refer` to allow code to
    refer to other namespaces' vars without fully qualifying them.
  prefs: []
  type: TYPE_NORMAL
- en: '`refer`, `require`, and `use` all serve different purposes:'
  prefs: []
  type: TYPE_NORMAL
- en: '`refer` allows us to call functions from a different namespace (functions are
    notÂ imported).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`require` imports functions from a different namespace but we have to qualify
    them when using them.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`use` loads functions from a different namespace and we do not have to qualify
    them.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Exercise 8.07: Importing Clojure Functions with require and use'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this exercise, we will learn how the `require` and `use` functions can help
    us to import Clojure namespaces. We will import Clojure namespaces using both
    methods. This will help us understand the difference between both methods.
  prefs: []
  type: TYPE_NORMAL
- en: By using `require`, we ensure that the namespaces provided are fully loaded
    whenever we need to use them.
  prefs: []
  type: TYPE_NORMAL
- en: Clojure provides a number of namespaces, such as `clojure.edn` or `clojure.pprint`,
    that help developers to create programs. EDN stands for extensible data notation.
    It is a system for representing objects. It provides a rich set of features such
    as functionality for specifying the date and time. The `clojure.edn` namespace
    allows us to use the `edn` format. Imagine that you want to send a date from one
    program to another. If you send the date as a string, "Monday 7.10.2019," there
    is no information about time zone. The program receiving this date string does
    not know whether this time is in London or New York. With `edn`, we can send a
    date object that contains information about the time zone.
  prefs: []
  type: TYPE_NORMAL
- en: The `clojure.print` namespace contains utility functions that help to print
    data from programs in an easy-to-understand and easy-to-read format.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider printing a hash as shown in the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.3: Printing a hash'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B14502_08_03.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 8.3: Printing a hash'
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead of printing a hash as shown in *Figure 8.3*, functions from the `clojure.pprint`
    namespace allow us to print a hash like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.4: Printing a hash using the functions from the namespace'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B14502_08_04.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 8.4: Printing a hash using the functions from the namespace'
  prefs: []
  type: TYPE_NORMAL
- en: 'By default, when we start a new session, only `clojure.core` is available.
    The `clojure.core` namespace contains the main Clojure functions, such as `filter`,
    `map`, `reduce`, and `count`. These are core functions that are used very often
    when working in Clojure. That is why they are available by default when working
    in Clojure. The other namespaces need to be added by us:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We will require a new namespace in our REPL session that will help us pretty
    print some content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We can use functions from this namespace now. We call the `print-table` function
    to print a table in REPL:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This prints a table in REPL:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 8.5: Printing a table in REPL'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/B14502_08_05.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 8.5: Printing a table in REPL'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Using fully qualified names can become tedious because every time we want to
    call any function, we have to provide its full name, including the namespace.
    This results in verbose code and a lot of repetition of namespace names. Fortunately,
    Clojure allows us to set an alias for a namespace. In order to set an alias, we
    use the `:as` keyword. With the `:as` keyword, we shorten how we call functions.
    We do not need to write the full namespace but simply an alias that we choose.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Call the `require` function with the `:as` keyword to simplify importing the
    function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now we can use the alias to call the `print-table` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We have just seen how the `require` function is used. Next, we will see how
    the `use` function helps us to import namespaces.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'We call the `use` function to import namespaces in REPL:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The preceding statement will load the `clojure.pprint` namespace and refer to
    theÂ namespace.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: We can use functions from this namespace without fully qualifying them.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Call the `print-table` function without the namespace name to print a table:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This will print a table for us:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 8.6: Calling the print-table function'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/B14502_08_06.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 8.6: Calling the print-table function'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: We have just seen how `use` works. Next, we will look into using keywords such
    as `:only` and `:rename` with `use`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Import a function from the `clojure.string` namespace:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This will import the `split` function from the `string` namespace and return
    theÂ following:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We can use the `split` function without a namespace name:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 8.7: Using the split function'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/B14502_08_07.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 8.7: Using the split function'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Rename the function from the `clojure.edn` namespace when importing with `use`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This will return the following:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We renamed the `read-string` function from the `clojure.end` namespace to `string-read`.
    We can call the `string-read` function without a namespace name now:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We have a string that represents a date from 1989\. We pass this string to the
    `edn` function, which converts a string to a `Date` object. When we call the `class`
    function, it tells us that we have a `Date` object.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: We have seen how to import namespaces with `refer` and `use`. In the following
    activity, we will put this knowledge into practice.
  prefs: []
  type: TYPE_NORMAL
- en: 'Activity 8.01: Altering the Users List in an Application'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this activity, we will apply our knowledge about importing namespaces to
    solve a real-world problem. Imagine that we work in an IT company and we are responsible
    for designing a backend application. One of the functions in our backend returns
    a list of users. A new frontend feature needs this list in a different format.
    The aim of this activity is to alter the list of users.
  prefs: []
  type: TYPE_NORMAL
- en: 'The two alterations required are:'
  prefs: []
  type: TYPE_NORMAL
- en: Capitalizing usernames
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Checking whether the users John, Paul, and Katie belong to an admin group
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The application currently displays a list of users, their honorifics, their
    first names, and their last names. The honorifics and first names are separated
    by `_` (an underscore). In this activity, we will add a space between the honorifics
    and the first names. Then, we will take the first and last names and capitalize
    the first letter of the honorifics, first names, and last names. Finally, we will
    check whether our users belong to the admin group.
  prefs: []
  type: TYPE_NORMAL
- en: 'These steps will help you complete the activity:'
  prefs: []
  type: TYPE_NORMAL
- en: Import the `clojure.string` namespace with `use` and the `:rename` keyword for
    the `replace` and `reverse` functions.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a set of users.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Replace the underscore between the honorifics and the first names.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use the `capitalize` function to capitalize each person's initials in the user
    group.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Update the user list by using the string `replace` and `capitalize` functions.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Import only the `print-table` function from the `clojure.pprint` namespace.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Print a table with users.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Import the `clojure.set` namespace, excluding the `join` function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a set of admins.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Call the `subset?` function on two sets of users and admins.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The initial list of users and admins will look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'The admin list will look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'The final list of users will look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.8: Expected outcome'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B14502_08_08.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 8.8: Expected outcome'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The solution for this activity can be found on page 706.
  prefs: []
  type: TYPE_NORMAL
- en: When You Want use versus When You Want require
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Although `use` and `require` may seem very similar at first glance, with some
    practice you will understand when to use each one.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we want to import a namespace using `require`, we will call it as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'Importing a namespace with `use` is done as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: If we compare both statements, we see that the only difference is the importing
    function, either `require` or `use`. The syntax of using them is the same. We
    call a function and then the namespace that we want to import. The reason to use
    both importing functions is different, though, as we will see in this topic.
  prefs: []
  type: TYPE_NORMAL
- en: 'When in doubt, choose `require`. It allows you to add an alias for the namespace
    and makes the code more readable than having to use fully qualified names:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'This way, we can call functions very easily. Consider the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'When choosing `use`, advised to add an alias and import only required functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: When you import only required functions, you can easily add more later on. Importing
    only the functions that we require at the moment helps us to maintain the code.
    The developers dealing with the code will not spend time searching for the usage
    of functions that we imported.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two potential problems with using `use` without the `:only` keyword:'
  prefs: []
  type: TYPE_NORMAL
- en: Inspecting the code does not tell us quickly from which namespace a certain
    function comes. With aliased namespaces, we can establish this more easily.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We avoid any name collisions in the future if we add a new library or if an
    existing library introduces a new function with a name that we are already using.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now that we've looked at namespaces, we will go a level higher and investigate
    how to structure projects using Leiningen.
  prefs: []
  type: TYPE_NORMAL
- en: Leiningenâ€”A Build Tool in Clojure
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With namespaces, we put our functions into files and group related functions
    together. This helps to keep code separated into units. Consider a situation where
    utility functions are separated from frontend functions. This helps us navigate
    code and find functions. We know that frontend functions responsible for creating
    HTML will not be in a backend namespace responsible for connecting to the database.
    Build tools serve a different purpose. As the name suggests, these are tools that
    help us build. With them, we automate the creation of an executable application.
    An alternative would be to compile all the code ourselves and put it on a server.
    Even in applications with only a few features, we run the risk of forgetting to
    compile a namespace. The more namespaces there are and the more complicated an
    application is, the bigger the risk of making a mistake in manual code compilation.
    Build tools compile our code and package it into a usable form. Developers specify
    parts of the application that need to be compiled and the build tool automatically
    compiles the parts for them. This helps to minimize compilation mistakes. Some
    build tools are Maven, Gradle, Webpack, and Grunt.
  prefs: []
  type: TYPE_NORMAL
- en: Leiningen is a very popular build tool in the Clojure community. Its popularity
    comes from the rich set of features it has. It provides a lot of templates that
    allow developers to start writing code without much of a project setup. Often,
    the type of application that a developer wants to create has already been created
    by someone else. This way, we can reuse what developers before us created instead
    of writing so much code ourselves. We have a web application template that provides
    us with a common structure for a web page. There is a template for a backend server
    with a file structure and configuration that is common in backend servers. In
    the next exercise, we will create a new project.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 8.08: Creating a Leiningen Project'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The aim of this exercise is to learn about the standard structure in Leiningen
    projects. We will create a sample project based on a template from Leiningen.
    This will allow us to explore the files that Leiningen creates and the purpose
    of each file.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to create a new Leiningen project, we will use the command line:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Call a new `lein` task with the `app` template. To create a new project, execute
    theÂ following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the preceding command, the `lein` command takes three parameters:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`new`: A `lein` task telling Leiningen what type of task to execute. Task `new`
    will create a project based on a template.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`app`: The name of the template to use when creating a project. Leiningen will
    create a project using a specified template.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`hello-leiningen`: The name of the project.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'We should see that our new project has been created:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'After creating a project, we will navigate to the project''s directory:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, inspect the project as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We will see that Leiningen has created a number of files for us already:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 8.9: Inspecting the project'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/B14502_08_09.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 8.9: Inspecting the project'
  prefs: []
  type: TYPE_NORMAL
- en: 'There are a few important things to notice here:'
  prefs: []
  type: TYPE_NORMAL
- en: We have a source directory, `src`, where we will put our code.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `project.clj` file contains a description of our project.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`README.md` is an entry point with information about our application.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We have a `test` directory for our tests.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will have a closer look at these points in the following sections. Testing
    will be covered in *Chapter 10*, *Testing*. In the next section, we will look
    at the `project.clj` file.
  prefs: []
  type: TYPE_NORMAL
- en: Investigating project.clj
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `project.clj` file that you have created will look similar to this one:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.10: The project.clj file'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B14502_08_10.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 8.10: The project.clj file'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at each parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '`hello-leiningen` project has got a SNAPSHOT version. This means that it is
    not yet a stable production-tested version but rather a development version. When
    you are ready to publish your project, be sure to add a proper version. A good
    guide is to use semantic versioning. There are times when using a snapshot version
    is necessary, such as with a bug fix before the fix gets included in the next
    release. The rule of thumb is to use stable versions unless a bug fix is needed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Description**: Adding a description is a good starting point for people looking
    at understanding the purpose of a project. Also, when the project is published
    in project repositories such as Maven or Clojars, it is easier to search for the
    project.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`url` parameter allows us to place a web URL for our project. On our web page,
    we can add much more information about our project. Most project websites would
    have:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A rationale: Why the project was created'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Documentation: A description of its usage'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Tutorials: Examples of using the project'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**License**: The license is used as you might expect. It is a legal instrument
    governing the use of software. Essentially, it is an agreement between the owner
    of software and its user, allowing the user to use software under certain conditions.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'There are many types of software licenses. Examples of licenses include:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'MIT license: This allows the distribution and modification of source code.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Apache License 2.0: Like the MIT license, this allows the distribution and
    modification of code but requires the preservation of copyright notices.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'GNU AGPLv3: Like the MIT license, this allows the distribution and modification
    of code but requires the stating of changes compared to the original version of
    the software.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`jar` files. They are basically `zip` files (compressed files) with some metadata
    about the project. When we specify dependencies in our `project.clj`, Leiningen
    will search the local repository. If dependencies are not already stored locally,
    then it will search the Maven and Clojars websites and download the dependencies.
    Such dependencies are then available for our project.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`:main` keyword, we specify the namespace that is the entry point for our project
    and application. It gets called when we run our project.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`:profiles` keyword, we have an `uberjar` profile where we want AOT compilation.
    On the other hand, we would like our `:main` namespace to be without AOT. We create
    an uberjar with AOT because we want to compile the code before we run it. We do
    not want AOT for `:main` as we want to defer compilation until we start an application.
    For example, `:main` can use symbols such as environment settings, parameters
    that are not available at AOT compilation. They are only available when we start
    an application. If we compile too fast, the application will not have access to
    parameters that we passed when we start an application.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Profiles**: Leiningen allows us to set up various profiles in our projects.
    Thanks to profiles, we can customize projects depending on our needs.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For example, a development version could require a testing suite and we might
    want testing dependencies. On the other hand, when creating a production jar,
    we do not need testing dependencies.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: We will look at Leiningen's profiles at the end of this chapter.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Now that we have looked at `project.clj`, we will see what the `README.md` file
    has to offer for us.
  prefs: []
  type: TYPE_NORMAL
- en: A README file is a Markdown file that provides information about our project
    that we consider important for users to know. Markdown is a markup language that
    allows us to style documents.
  prefs: []
  type: TYPE_NORMAL
- en: 'Typically, a README file will have the following sections:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Project name**: Where we put a short description of what the project does'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Installation**: Where we inform users of the steps necessary to install ourÂ application'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Usage**: Where we let users know how to use our project'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Examples**: A section with code samples showing how to use our project'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Bugs**: Any known bugs'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Changelog**: Where we document any changes between versions'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**License**: Where we inform users of our project''s license type'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here''s a sample README file:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.11: Sample README file'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B14502_08_11.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 8.11: Sample README file'
  prefs: []
  type: TYPE_NORMAL
- en: You can add more sections. It all depends on what you think is important for
    users ofÂ your project to know. In the next topic, we will modify source files
    and run our application.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 8.09: Executing the Application on the Command Line'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The aim of this exercise is to create a Leiningen application and explore how
    applications are run.
  prefs: []
  type: TYPE_NORMAL
- en: This will help us understand the different options that Leiningen provides in
    the `project.clj` file.
  prefs: []
  type: TYPE_NORMAL
- en: As we will see at the end of this exercise, in order to run our application
    from the command line, we need to call Leiningen's `run` task. Leiningen's `run`
    task will search the `project.clj` file for the `:main` keyword and corresponding
    namespace.
  prefs: []
  type: TYPE_NORMAL
- en: 'In our case, the `:main` keyword in `project.clj` will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: '`^:skip-aot` instructs Leiningen to skip AOT for the namespace that we specify.
    Here, the namespace is `hello-leiningen.core`. When we explored the `project.clj`
    file, we talked about why we want to skip AOT for the `:main` namespace.'
  prefs: []
  type: TYPE_NORMAL
- en: 'By default, Leiningen will search for the namespace that we specified in the
    `:main` keyword. In our case, it will search for the `hello-leiningen.core` namespace.
    In this namespace, if we have the `-main` function, it will be called:'
  prefs: []
  type: TYPE_NORMAL
- en: 'After creating a new project, the content of the `hello-leiningen.core` namespace
    is the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: When we create an application using Leiningen, it will autogenerate code in
    the `core` namespace. `(:gen-class)` instructs Leiningen to generate a Java class
    from the namespace. Build tools such as Leiningen execute Java bytecode so we
    need to compile Clojure to bytecode in order to run the `core` namespace.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Next, we have the `-main` function. By default, when an application is started,
    Leiningen will search for a method with that name and execute it. As such, `-main`
    is an entry point to our application.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Like all functions in Clojure, `-main` can be supplied with an optional documentation
    string. Here, it tells us that the function does not do a whole lot... yet. This
    function takes optional arguments. We can pass arguments when we start an application.
    Often, applications are started for various environments by passing an environment
    type, such as test or production, as a command-line argument.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: When Leiningen calls the `-main` function, it will execute the body of this
    function. In this case, the function will print the string `Hello World!` to the
    console.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'To run the application from the command line, we use Leiningen''s `run` task:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This will print the following to the console:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This exercise showed us how to run a Leiningen application as defined in `project.clj`
    file.
  prefs: []
  type: TYPE_NORMAL
- en: In the next exercise we will extend the application to take arguments from the
    command line.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 8.10: Executing Application on the Command Line with arguments'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this exercise we will write a small command line application that takes a
    string as input, parses that input and replaces the contents of that string.
  prefs: []
  type: TYPE_NORMAL
- en: 'After creating a new project, the content of the `hello-leiningen.core` namespace
    is the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: When we create an application using Leiningen, it will autogenerate code in
    the core namespace. (`:gen-class`) instructs Leiningen to generate a Java class
    from the namespace. Build tools such as Leiningen execute Java bytecode so we
    need to compile Clojure to bytecode in order to run the core namespace.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, we have the `-main` function. By default, when an application is started,
    Leiningen will search for a method with that name and execute it. As such, -main
    is an entry point to our application.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Like all functions in Clojure, `-main` can be supplied with an optional documentation
    string. Here, it tells us that the function does not do a whole lot... yet. This
    function takes optional arguments. We can pass arguments when we start an application.
    Often, applications are started for various environments by passing an environment
    type, such as test or production, as a command-line argument.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When Leiningen calls the -main function, it will execute the body of this function.
    In this case, the function will print the string Hello World! to the console.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'To run the application from the command line, we use Leiningen''s run task:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This will print the following to the console:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Import the `clojure.string`. We want to manipulate strings in our `-main` function.
    In order to do that we need to import string namespace.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: After importing `clojure.string` namespace we can use functions from this namespace.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Updating `-main` function to replace certain words when the `-main` function
    is run:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This code will replace words "`melon`" and "`apple`" with other fruits.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'We run the application as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This will print the following in the REPL:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We know now how to run an application from the command line and pass arguments.
    InÂ the following activity, you will use this knowledge to create a new application.
  prefs: []
  type: TYPE_NORMAL
- en: 'Activity 8.02: Summing Up Numbers'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Often, applications that are created by developers need to run in different
    environments and business contexts. This requires the applications to be flexible.
    OneÂ way to achieve this is by using command-line parameters that change how applications
    behave.
  prefs: []
  type: TYPE_NORMAL
- en: In this activity, you will create an application that takes integers as input
    parameters from the command line and sums them up to print the result to the console.
    Depending on the integers passed, the results will differ. This shows the flexibility
    of the application.
  prefs: []
  type: TYPE_NORMAL
- en: 'These steps will help you complete the activity:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a Leiningen application.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Alter the `-main` function to convert string arguments to integers, add integers,
    and print the result.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The output will look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.12: Expected output'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B14502_08_12.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 8.12: Expected output'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The solution for this activity can be found on page 708.
  prefs: []
  type: TYPE_NORMAL
- en: Working with External Libraries
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Libraries are packaged programs that are ready to be used in other projects.
    External libraries are libraries that come from other developers. In Clojure,
    examples of such libraries include Ring, an HTTP library; `clojure.java-time`,
    a library for time and date manipulation; and `hiccup`, a library for writing
    HTML code using Clojure-style syntax.
  prefs: []
  type: TYPE_NORMAL
- en: Most projects will require developers to use existing code packaged as libraries.
    This is a good thing. We do not want to write code over and over again if the
    problem at hand has been already solved and someone has created a library for
    it that we can use.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we will use the `clojure.Java-time` library to display the
    current time.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 8.11: Using an External Library in a Leiningen Project'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The aim of this exercise is to show you how to add a library to a Leiningen
    project and demonstrate how this library is used in code:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The first thing to do is add a dependency to the `time` library in the `project.clj`
    file. The `dependencies` section should look like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The next step is to import the library to our `core` namespace. Alter `hello-leiningen.core`
    to look like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, we will change the `-main` function to print the local time using
    a function from the `clojure.java-time` library:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We run the application from the command line using the `run` task:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This will show us output similar to the following:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We now know how to add and use external libraries. We are ready to package our
    application to a jar and run it.
  prefs: []
  type: TYPE_NORMAL
- en: Creating and Executing a jar with Leiningen
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When we discussed project structure in Clojure, we mentioned that projects are
    packaged as jar files. To remind you, a jar file is a zipped (packed) file that
    is an executable application. Leiningen has tasks for creating jars.
  prefs: []
  type: TYPE_NORMAL
- en: 'Leiningen provides two tasks that can create a jar:'
  prefs: []
  type: TYPE_NORMAL
- en: jar
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: uberjar
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Both will create a zipped file with our code. The difference is that a jar task
    will package only our code while an uberjar task will also package dependencies.
    If you run one application on your server and want one standalone file, then an
    uberjar is your go-to option. If you have a number of applications on your server
    and they share libraries, then packaging each application as a jar will take less
    space overall than packaging them as uberjars. This is because libraries are shared
    on servers between your applications.
  prefs: []
  type: TYPE_NORMAL
- en: If we want to run a jar, we need to generate a named class from our core namespace.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 8.12: Creating a Jar File'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this exercise, we will show how to create a jar file using Leiningen tasks:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Alter the `hello-leiningen.core` namespace declaration to include a `(:gen-class)`
    function call:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `:gen-class` directive is an important concept in Clojure. This directive
    will generate a Java class corresponding to the target namespace. The result of
    generating a Java class is a `.class` file. A Java `.class` file contains Java
    bytecode that can be executed on the JVM. Such a file can be executed by build
    tools such as Leiningen.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Running Leiningen tasks for both a jar and uberjar is the same. In our case,
    we will create an uberjar.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Call Leiningen''s `uberjar` task in the command line:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This task will create `hello-leiningen-0.1.0-SNAPSHOT.jar` and `hello-leiningen-0.1.0-SNAPSHOT-standalone.jar`
    jar files inside the target directory.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'When we compare the files, we will see that their sizes differ greatly:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 8.13: Comparing the files'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/B14502_08_13.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Running this command will give us the output similar to the following:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 8.14: Inspecting the standalone version of the file'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/B14502_08_14.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 8.14: Inspecting the standalone version of the file'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'We would notice a `clojure` directory. When inspecting the first file, however,
    there would be no Clojure directory:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 8.15: Checking for the Clojure directory'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/B14502_08_15.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 8.15: Checking for the Clojure directory'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The first jar (`hello-leiningen-0.1.0-SNAPSHOT.jar`) contains only application
    code, while the second file (`hello-leiningen-0.1.0-SNAPSHOT-standalone.jar`)
    also contains core Clojure code. The standalone file is intended to be used when
    we have one Clojure application. In such cases, we want to have all the dependencies
    in one place. When we run more than one Clojure application on a server, having
    each application containing core Clojure functions takes more space than needed.
    In such cases, having core Clojure code once and allowing all applications to
    access it saves disk space.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'In order to run a jar, we will call the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This will display the current local time for us, as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 8.16: Print the local time'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/B14502_08_16.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 8.16: Print the local time'
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will look at Leiningen profilesâ€”a powerful feature that
    allows us to customize our projects.
  prefs: []
  type: TYPE_NORMAL
- en: Leiningen Profiles
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Profiles are a Leiningen tool that allows us to change the configuration of
    our projects. A profile is a specification that influences how a project behaves.
    For example, during development or testing, say that we would like to include
    testing frameworks in our builds but the production build does not need testing
    dependencies. Using profiles is a great way to separate different development
    setups that should be run against one code base.
  prefs: []
  type: TYPE_NORMAL
- en: 'Leiningen allows us to define profiles in a few places depending on our needs:'
  prefs: []
  type: TYPE_NORMAL
- en: In the `project.clj` file
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the `profiles.clj` file
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the `~/.lein/profiles.clj` file
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Leiningen profiles defined in `project.clj` are specific to that particular
    project. Such profiles will not affect other projects. This allows separation
    between projects and the ability to customize them independently. We could have
    one application that uses the newest version of Clojure and requires different
    libraries to another application relying on an older Clojure version.
  prefs: []
  type: TYPE_NORMAL
- en: Leiningen profiles defined in `profiles.clj` are also specific to a project.
    Such profiles will not affect other projects. The difference between putting a
    profile in `project.clj` and `profiles.clj` is that profiles in `project.clj`
    will be committed in version control. Profiles defined in `profiles.clj` are independent
    of the project configuration in `project.clj` and do not need to be committed
    to version control. Profiles from both files are merged together by Leiningen.
    Profiles with the same name in `profiles.clj` take precedence over profiles in
    `project.clj`.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we know what Leiningen profiles are and the places that they can be
    defined, we will look at the syntax of creating profiles. First, we will define
    a profile in a `project.clj` file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 8.13: Adding Leiningen Profiles to a Project'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The aim of this exercise is to add a new development profile inside a `project.clj`
    file. This will allow us to customize a project for the development phase of the
    software development life cycle.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we wanted to add a dependency on a testing framework, such as `expectations`,
    we would alter the `project.clj` file to look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: 'Inside the `:profiles` hash, we have a `:dev` hash with a dependency on the
    `expectations` framework. With this change, the `dev` profile is available for
    us. We can check this by listing available profiles:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Calling Leiningen''s `show-profiles` task will display the available profiles:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 8.17: Printing the available profiles'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/B14502_08_17.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 8.17: Printing the available profiles'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The profiles available in this example are:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`base`: A profile that provides basic REPL functionality.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`debug`: When Leiningen tasks are run with this profile, they print more information
    to the console, such as the names of the dependencies used.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`default`: The default profile run when no profiles are selected. Unless overridden,
    the profile defaults to the `leiningen/default` profile.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`dev`: The development profile as set up in the `project.clj` file by a developer.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`leiningen/default`: The default profile that runs when no profile is selected.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`leiningen/test`: A test profile that runs test files.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`offline`: Profiles where stored dependencies are used offline without downloading
    new ones.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`uberjar`: Profiles that create uberjar files.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`update`: Profiles that update dependencies.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`user`: A profile defined for a Linux user.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`whidbey/repl`: A profile where results in the REPL are printed in a formatted
    way.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: As you can see, the `dev` profile is listed among other profiles.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'If we wanted to run this profile, we would call the `with-profiles` task:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Calling this task would run the tests with the `dev` profile. In *Chapter 10*,
    *Testing*, we will explore testing in Clojure and this task will be used often.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: In this exercise, we have added a new Leiningen profile to the `project.clj`
    file. This allows us to have a configuration for a particular project. This configuration
    is independent of configurations in other projects.
  prefs: []
  type: TYPE_NORMAL
- en: In the next exercise, we will add user-wide profile configuration.
  prefs: []
  type: TYPE_NORMAL
- en: User-Wide Profiles
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Leiningen allows us to define user-wide profiles that will affect all Leiningen
    projects. This is a great place to put common code that we want for all our projects.
    The most common examples would be including libraries for testing or pretty printing
    output. Once we include a testing library in a user-wide profile, that library
    can be used to write tests for all our projects. This also benefits us when it
    comes to upgrading the library. We only need to upgrade its version in one place.
  prefs: []
  type: TYPE_NORMAL
- en: User-wide profiles allow us to add dependencies that we would like to be included
    in all our projects. One such dependency would be Ultra, which gives developers
    working in REPL features such as colorization and pretty printing.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 8.14: Using User-Wide Profiles'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The aim of this exercise is to add a new library to the `profiles.clj` file.
    This will allow us to access the added library on all Leiningen projects, reducing
    the need to manually add a dependency every time we create a new project. Additionally,
    if a new version of the library is available, we need to update only one `profiles.clj`
    file and the update will be available in all our Leiningen projects.
  prefs: []
  type: TYPE_NORMAL
- en: If we often work with input that we need to display in a way that's accessible
    to users, we can use the `humanize` library. This library pluralizes nouns, shows
    dates in a friendly manner, and converts numbers to strings.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to use the humanize library for all of our projects, we add it to
    the `:user` keyword in `~/.lein/profiles.clj`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: 'Quite often, you will have more libraries and plugins defined in `profiles.clj`.
    It could look like this with the `humanize` library and two plugins, `ultra` and
    `localrepo`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: 'Start the REPL using Leiningen:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Import the humanize library:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Although we did not have the `humanize` library in the `project.clj` file,
    we could import this library:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 8.18: Importing the humanize library'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/B14502_08_18.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 8.18: Importing the humanize library'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Convert numbers to strings as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'humanize will convert passed numbers to strings as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Convert the number of milliseconds to time values:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '500 milliseconds is not even a second and hence the output will be as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This concludes our tour of namespaces in Clojure and Leiningen project structure.
    In the following activity, we will use our new knowledge of libraries and profiles
    inÂ Leiningen.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Useful Clojure Libraries
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Clojure ecosystem has a number of great libraries. As we have learned in
    this chapter, using libraries helps us to create Clojure applications. Libraries
    provide features that we can use in our code. We do not need to write code ourselves
    as we can instead reuse code written by others. This saves us time and means we
    can focus on developing features specific to our application. There are a number
    of Clojure libraries. Clojure provides a central place to search for available
    libraries on [https://clojars.org](https://clojars.org). We will learn about two
    useful Clojure libraries, `cheshire` and `lein-ancient`. The `cheshire` library
    allows us to work with the JSON format. `cheshire` library, we can change Clojure
    data to JSON format and back. This is a very powerful feature. Imagine that we
    have a holiday-booking application. In the application, we want to display current
    weather information. There are national services providing such information. The
    weather services allow the downloading of data in a common JSON format. When we
    download weather data, we need to turn JSON into Clojure data. The `cheshire`
    library helps us with data conversion. `lein-ancient` is a useful Leiningen plugin.
    This plugin allows us to check our Leiningen projects for outdated dependencies.
    Often, a new version of a library that we use is released. New releases introduce
    errors or security fixes. Using updated libraries helps our applications to stay
    secure. In the following activity, we will create a Leiningen project using useful
    Clojure libraries.
  prefs: []
  type: TYPE_NORMAL
- en: 'Activity 8.03: Building a Format-Converting Application'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The aim of this activity is to create a Leiningen project that will convert
    between JSON format and Clojure data. JSON is a popular transfer format often
    used to send data between various backend applications. Using a common format
    increases the operability between different applications and reduces the development
    cost of building and maintaining applications.
  prefs: []
  type: TYPE_NORMAL
- en: Like most applications used in production, our application will have development
    and default production profiles. Leiningen profiles will be used to create a testing
    profile that will use testing libraries to make sure our application is running
    correctly.
  prefs: []
  type: TYPE_NORMAL
- en: As our application matures, newer versions of the libraries used will be released.
    We will use a plugin that will let us know whether any libraries that we use are
    outdated.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you complete this activity, the application will have the following features:'
  prefs: []
  type: TYPE_NORMAL
- en: Converting between JSON and Clojure data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A testing profile for checking code before releasing to production
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Checking for outdated libraries
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'These steps will help you complete the activity:'
  prefs: []
  type: TYPE_NORMAL
- en: Include the `cheshire` "3.0.0" library as a dependency.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a function to convert from hash to JSON.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a function to convert from JSON to hash.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add the `expectations` library to the testing profile defined for the project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add the `lein-expectations` plugin to the project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Write a test for the JSON functions.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add `lein-ancient` to the user-wide profiles.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The latest versions of libraries can be found on the [https://clojars.org](https://clojars.org)
    website.
  prefs: []
  type: TYPE_NORMAL
- en: After creating the application and running it, you should have output similar
    to the following.
  prefs: []
  type: TYPE_NORMAL
- en: 'Converting from hash to JSON format should return the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.19: Converting from hash to JSON'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B14502_08_19.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 8.19: Converting from hash to JSON'
  prefs: []
  type: TYPE_NORMAL
- en: 'Generating JSON from hash should return the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.20: Generating JSON from hash'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B14502_08_20.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 8.20: Generating JSON from hash'
  prefs: []
  type: TYPE_NORMAL
- en: 'Running the testing profile should return the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.21: Executing the test profile'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B14502_08_21.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 8.21: Executing the test profile'
  prefs: []
  type: TYPE_NORMAL
- en: 'Checking for outdated dependencies should return the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.22: Checking for outdated dependencies'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B14502_08_22.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 8.22: Checking for outdated dependencies'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The solution for this activity can be found on page 709.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned about namespaces in Clojure. Namespaces are key
    Clojure concepts. We organize code into namespaces. We investigated various ways
    in which we can import namespaces in Clojure by using `refer`, `require`, and
    `use`. With each option to import, we learned the syntax of importing functions
    and when to use each type of function. We went into depth and investigated the
    `:only`, `:exlude`, and `:rename` keywords, which help us to fine-tune importing.
  prefs: []
  type: TYPE_NORMAL
- en: Then, we learned about Leiningenâ€”a popular Clojure build tool. We created a
    Leiningen application and explored how Clojure projects are structured. We added
    dependencies on libraries. Finally, we saw how we can customize Leiningen projects
    using profiles. We created an application that accepted command-line arguments
    that were used by the application to customize the output.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will investigate host platform interopâ€”accessing Java
    and JavaScript from Clojure.
  prefs: []
  type: TYPE_NORMAL
