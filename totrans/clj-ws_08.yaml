- en: 8\. Namespaces, Libraries and Leiningen
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 8. 命名空间、库和 Leiningen
- en: Overview
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 概述
- en: In this chapter, we learn how to organize Clojure code. We start by looking
    at namespaces—a way to group Clojure functions together. We will see how to create
    our own namespaces and how to import namespaces written by others. Namespaces
    are building blocks of Clojure libraries. We will learn how to import and use
    Clojure libraries. After learning about namespaces and libraries, we investigate
    how to structure a Clojure project. We then look at Leiningen project template
    and how it helps developers to create applications.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习如何组织 Clojure 代码。我们首先来看命名空间——一种将 Clojure 函数分组的方法。我们将了解如何创建自己的命名空间以及如何导入他人编写的命名空间。命名空间是
    Clojure 库的构建块。我们将学习如何导入和使用 Clojure 库。在了解命名空间和库之后，我们将研究如何构建 Clojure 项目。然后，我们将查看
    Leiningen 项目模板以及它是如何帮助开发者创建应用程序的。
- en: By the end of this chapter, you will be able to use Leiningen to organize and
    run your projects.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将能够使用 Leiningen 组织和运行你的项目。
- en: Introduction
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: In the previous chapter, we learned about sequences in Clojure and how working
    with them helps us to build Clojure programs. Now that you're familiar with using
    Clojure to implement various pieces of functionality, it's time to become more
    comfortable with accomplishing the basic tasks of creating, building, testing,
    deploying, and running projects in Clojure and ClojureScript.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们学习了 Clojure 中的序列以及如何使用它们来构建 Clojure 程序。现在你已经熟悉了如何使用 Clojure 实现各种功能，是时候更熟悉在
    Clojure 和 ClojureScript 中创建、构建、测试、部署和运行项目的基本任务了。
- en: Clojure was designed to be a very practical language from the beginning. Getting
    things done means interacting with the outside world, building projects, using
    libraries, and deploying your work. As a developer, you will need to organize
    written code in a structure. In this chapter, you will see how namespaces can
    help you structure code and how build tools such as Leiningen help you put together
    a whole application.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: Clojure 从一开始就被设计成一种非常实用的语言。完成任务意味着与外部世界互动、构建项目、使用库以及部署你的工作。作为一名开发者，你需要以结构化的方式组织编写的代码。在本章中，你将看到命名空间如何帮助你组织代码，以及构建工具如
    Leiningen 如何帮助你构建整个应用程序。
- en: In a real-world project, you won't write all the code. External dependencies
    are a crucial part of any project, and we'll learn here how to bring them into
    your project and your code.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在现实世界的项目中，你不会编写所有的代码。外部依赖是任何项目的关键部分，我们将在这里学习如何将它们引入你的项目和代码中。
- en: The first step is to understand how Clojure namespaces work in general. Then
    we'll look at the project level and using Leiningen and your `project.clj` file
    to pull everything together into a Java executable. Finally, we'll take a look
    at some of the conveniences that Leiningen provides throughout the life cycle
    of a project.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步是了解 Clojure 命名空间的一般工作原理。然后，我们将查看项目级别，使用 Leiningen 和你的 `project.clj` 文件将所有内容整合成一个
    Java 可执行文件。最后，我们将看看 Leiningen 在项目生命周期中提供的便利之处。
- en: Namespaces
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 命名空间
- en: Namespaces are a way to organize Clojure functions; you can think of a namespace
    as being a directory (or file) that stores a particular group of functions. Each
    directory is independent of other directories; this helps to keep different groups
    of functions separate and gives a clear structure to your code. It also helps
    to avoid the confusion that can come with naming clashes.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 命名空间是一种组织 Clojure 函数的方式；你可以将命名空间想象成一个目录（或文件），它存储了一组特定的函数。每个目录都是独立的，这有助于保持不同组函数的分离，并为你的代码提供清晰的架构。它还有助于避免命名冲突可能带来的混淆。
- en: Consider a situation where you have written a function called `calculate-total`,
    and as part of your project, you're using a library *(more on libraries later
    in this chapter)* that also contains a function called `calculate-total`. Although
    these functions have the same name, they work differently, produce slightly different
    outputs, and are intended to be used in different situations. When you come to
    use `calculate-total` in your code, how does the system know which `calculate-function`
    you actually want? That's where namespaces come in. The two functions will exist
    in different namespaces, so you can state the appropriate namespace when calling
    the function in order to specify which one you want to use.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑这样一个情况，你已经编写了一个名为`calculate-total`的函数，作为你的项目的一部分，你正在使用一个库（关于库的更多内容将在本章后面介绍），该库也包含一个名为`calculate-total`的函数。尽管这两个函数具有相同的名称，但它们的工作方式不同，输出略有不同，并且旨在不同的场景中使用。当你开始在代码中使用`calculate-total`时，系统如何知道你实际上想要哪个`calculate-function`？这就是命名空间发挥作用的地方。这两个函数将存在于不同的命名空间中，因此当你调用函数时，你可以声明适当的命名空间来指定你想要使用的是哪一个。
- en: In more technical terms, namespaces provide a mapping between a symbol (which
    makes sense to a human reader) and a var or class. Namespaces can be compared
    to packages in Java or modules in Ruby and Python. We will first explore the concept
    of namespaces in Clojure using REPL.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 从更技术性的角度来说，命名空间在符号（对人类读者有意义）和var或类之间提供了一个映射。命名空间可以与Java中的包或Ruby和Python中的模块相比较。我们将首先使用REPL来探索Clojure中命名空间的概念。
- en: 'Exercise 8.01: Investigating Namespaces Started by Default in REPL'
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 8.01：调查REPL中默认启动的命名空间
- en: 'In this exercise, we will investigate how namespaces are handled in REPL:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将研究REPL中命名空间是如何处理的：
- en: 'Open Terminal or Command Prompt and add the following command to start REPL
    using Leiningen:'
  id: totrans-15
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开终端或命令提示符，并添加以下命令以使用Leiningen启动REPL：
- en: '[PRE0]'
  id: totrans-16
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'This will start REPL using Leiningen. It might take several seconds to start
    REPL. Once REPL is started, you should see something similar to the following:'
  id: totrans-17
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这将使用Leiningen启动REPL。启动REPL可能需要几秒钟。一旦REPL启动，你应该看到以下类似的内容：
- en: '![Figure 8.1: Starting REPL'
  id: totrans-18
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图 8.1：启动REPL'
- en: '](img/B14502_08_01.jpg)'
  id: totrans-19
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B14502_08_01.jpg)'
- en: 'Figure 8.1: Starting REPL'
  id: totrans-20
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 8.1：启动REPL
- en: The last line, `user=>`, tells us that we are in the default `user` namespace.
    In this namespace, functions from the `clojure.core` namespace are available to
    us. Let's explore a few functions.
  id: totrans-21
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 最后的行，`user=>`，告诉我们我们处于默认的`user`命名空间。在这个命名空间中，`clojure.core`命名空间中的函数对我们可用。让我们探索几个函数。
- en: 'In REPL, type the following code to calculate the sum of two numbers:'
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在REPL中，输入以下代码来计算两个数字的和：
- en: '[PRE1]'
  id: totrans-23
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'This simple code should return:'
  id: totrans-24
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这段简单的代码应该返回：
- en: '[PRE2]'
  id: totrans-25
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Let''s try Clojure''s `filter odd` function to return the odd numbers:'
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们尝试使用Clojure的`filter odd`函数来返回奇数：
- en: '[PRE3]'
  id: totrans-27
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'This will return the following:'
  id: totrans-28
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这将返回以下内容：
- en: '[PRE4]'
  id: totrans-29
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: We see that in the default user namespace, we have access to core Clojure functions.
    But what if we want to access functions that are defined in some other namespaces?
    Clojure provides us with the `in-ns` function, which switches to the requested
    namespace. This function will also create a new namespace if the requested namespace
    does not exist. In the next exercise, we will use the `in-ns` function to access
    data from a different namespace than the one currently being used.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到在默认用户命名空间中，我们可以访问核心Clojure函数。但如果我们想访问定义在其他命名空间中的函数怎么办？Clojure为我们提供了`in-ns`函数，该函数切换到请求的命名空间。如果请求的命名空间不存在，此函数还会创建一个新的命名空间。在下一个练习中，我们将使用`in-ns`函数来访问当前正在使用的不同命名空间中的数据。
- en: 'Exercise 8.02: Navigating Namespaces'
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 8.02：在命名空间中导航
- en: 'In the previous exercise, we used functions in the default user namespace.
    In this exercise, we will have a look at accessing data from other namespaces:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个练习中，我们使用了默认用户命名空间中的函数。在这个练习中，我们将查看如何访问其他命名空间中的数据：
- en: 'In Terminal, call the `in-ns` function to create a new namespace:'
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在终端中，调用`in-ns`函数来创建一个新的命名空间：
- en: '[PRE5]'
  id: totrans-34
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'In REPL, we will see that a new namespace has been created:'
  id: totrans-35
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在REPL中，我们将看到已经创建了一个新的命名空间：
- en: '![Figure 8.2: New namespace created'
  id: totrans-36
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图 8.2：创建的新命名空间'
- en: '](img/B14502_08_02.jpg)'
  id: totrans-37
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B14502_08_02.jpg)'
- en: 'Figure 8.2: New namespace created'
  id: totrans-38
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 8.2：创建的新命名空间
- en: You should notice that the REPL prompt has changed to `new-namespace=>`.
  id: totrans-39
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你应该注意到REPL提示已经更改为`new-namespace=>`。
- en: This visual cue tells us that we have successfully switched to a new namespace.
    Anything you declare inside this namespace will be available in it.
  id: totrans-40
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这个视觉提示告诉我们我们已经成功切换到了一个新的命名空间。在这个命名空间内部声明的任何内容都将在此可用。
- en: 'We will declare a variable in our new namespace. Type the following declaration:'
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将在新的命名空间中声明一个变量。输入以下声明：
- en: '[PRE6]'
  id: totrans-42
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'REPL lets us know that a new variable has been created:'
  id: totrans-43
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: REPL 告诉我们已创建了一个新变量：
- en: '[PRE7]'
  id: totrans-44
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'To check its content, we will access it from REPL as follows:'
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了检查其内容，我们将从 REPL 按如下方式访问它：
- en: '[PRE8]'
  id: totrans-46
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'As expected, REPL gives us back the vector:'
  id: totrans-47
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如预期，REPL 返回给我们向量：
- en: '[PRE9]'
  id: totrans-48
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'We will switch the namespace now using the `in-ns` function:'
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们将使用 `in-ns` 函数切换命名空间：
- en: '[PRE10]'
  id: totrans-50
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'REPL lets us know that the change has happened:'
  id: totrans-51
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: REPL 告诉我们知道发生了变化：
- en: '[PRE11]'
  id: totrans-52
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'REPL''s prompt has also changed:'
  id: totrans-53
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: REPL 的提示符也发生了变化：
- en: '[PRE12]'
  id: totrans-54
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Now access the `fruits` vector as follows:'
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在按如下方式访问 `fruits` 向量：
- en: '[PRE13]'
  id: totrans-56
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'We will see an unpleasant surprise:'
  id: totrans-57
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们将看到不愉快的结果：
- en: '[PRE14]'
  id: totrans-58
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: We have declared the `fruits` vector in `new-namespace` but we tried to access
    it from another namespace. To access vars from one namespace in another namespace,
    we need to explicitly state which namespace the var comes from.
  id: totrans-59
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们在 `new-namespace` 中声明了 `fruits` 向量，但我们尝试从另一个命名空间访问它。要从另一个命名空间访问变量，我们需要明确指出变量来自哪个命名空间。
- en: 'Type the fully qualified name in REPL to access the data as follows:'
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 REPL 中输入完全限定名称以按如下方式访问数据：
- en: '[PRE15]'
  id: totrans-61
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'This time, we get our `fruits` vector:'
  id: totrans-62
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这次，我们得到了 `fruits` 向量：
- en: '[PRE16]'
  id: totrans-63
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Using fully qualified names can become tedious. In the next exercise, we will
    see how Clojure helps us with managing multiple namespaces.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 使用完全限定名称可能会变得繁琐。在下一个练习中，我们将看到 Clojure 如何帮助我们管理多个命名空间。
- en: Importing Clojure Namespaces Using the refer Function
  id: totrans-65
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 `refer` 函数导入 Clojure 命名空间
- en: Clojure provides the `refer` function, which aims to help developers write compact
    code. This is achieved by importing the contents of a specific namespace into
    the current namespace, thereby allowing those contents to be accessed easily.
    In the previous example, we used `new-namespace/fruits` to access the `fruits`
    vector from a different namespace outside `new-namespace`. What `refer` allows
    us to do is reference `new-namespace` once and then use `fruits` as many times
    as we need, without having to state the full namespace every time.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: Clojure 提供了 `refer` 函数，旨在帮助开发者编写紧凑的代码。这是通过将特定命名空间的内容导入当前命名空间来实现的，从而使得这些内容可以轻松访问。在之前的例子中，我们使用了
    `new-namespace/fruits` 从 `new-namespace` 外部的不同命名空间访问 `fruits` 向量。`refer` 允许我们一次性引用
    `new-namespace`，然后根据需要多次使用 `fruits`，而不必每次都指定完整的命名空间。
- en: In the previous section, we used the `in-ns` function. In this section, we will
    use `refer` function. Although both functions help us to work with namespaces,
    we use them for different purposes. The `in-ns` function creates a scope for our
    code. We place data and functions inside a namespace. When we want to create a
    new namespace and thus a new scope for code, we use `in-ns`. Now, `refer`, on
    the other hand, will allow us to work within the scope of the current namespace
    and import data from a different namespace. We can import one or more namespaces
    and still work in one namespace scope.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们使用了 `in-ns` 函数。在本节中，我们将使用 `refer` 函数。虽然这两个函数都帮助我们处理命名空间，但我们使用它们的目的不同。`in-ns`
    函数为我们的代码创建一个作用域。我们在命名空间内放置数据和函数。当我们想要创建一个新的命名空间以及相应的代码作用域时，我们使用 `in-ns`。现在，另一方面，`refer`
    将允许我们在当前命名空间的作用域内工作，并从不同的命名空间导入数据。我们可以导入一个或多个命名空间，同时仍然在一个命名空间的作用域内工作。
- en: 'Exercise 8.03: Using the refer Function to Import a Namespace'
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 8.03：使用 `refer` 函数导入命名空间
- en: In this exercise, we will use the `refer` function to import Clojure namespaces.
    This will help us understand how the `refer` function is used.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将使用 `refer` 函数导入 Clojure 命名空间。这将帮助我们理解 `refer` 函数的使用方法。
- en: 'Using `refer` allows us to reference functions or objects from other namespaces:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `refer` 允许我们引用来自其他命名空间的功能或对象：
- en: 'In REPL, type the following command to import a new namespace using the `refer` function:'
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 REPL 中，输入以下命令以使用 `refer` 函数导入新的命名空间：
- en: '[PRE17]'
  id: totrans-72
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: We used `refer` here to import data from `new-namespace`. If we'd used the `in-ns`
    function, we would have changed the scope of the code. We would be able to access
    data from `new-namespace` but because the scope changed, we would lose access
    to `other-namespace` that we worked at before switching to `new-namespace`. Our
    aim is to write code within the scope of `other-namespace` and only access functions
    from `new-namespace`.
  id: totrans-73
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们在这里使用 `refer` 导入 `new-namespace` 的数据。如果我们使用了 `in-ns` 函数，我们就会改变代码的作用域。我们将能够访问
    `new-namespace` 的数据，但由于作用域发生了变化，我们将失去对之前切换到 `new-namespace` 之前工作的 `other-namespace`
    的访问权限。我们的目标是编写在 `other-namespace` 作用域内的代码，并且只访问 `new-namespace` 的功能。
- en: 'After this, we can use the `fruits` vector directly by calling it in REPL:'
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 之后，我们可以直接在 REPL 中调用 `fruits` 向量来使用它：
- en: '[PRE18]'
  id: totrans-75
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The output is as follows:'
  id: totrans-76
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE19]'
  id: totrans-77
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Using `refer` allowed us to include all objects from the specified namespace
    in the current one. The `refer` function allows us to use optional keywords to
    control importing namespaces. We will see them in action now.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `refer` 允许我们将指定命名空间中的所有对象包含到当前命名空间中。`refer` 函数允许我们使用可选关键字来控制导入命名空间。我们现在将看到它们的作用。
- en: Advanced Use of the refer Function
  id: totrans-79
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`refer` 函数的高级使用'
- en: In *Chapter 2*, *Data Types and Immutability*, we learned about keywords in
    Clojure. The basic usage of the `refer` function that we learned in the previous
    section can be altered or expanded using keywords. They are optional as we can
    use them but do not have to.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *第二章*，*数据类型和不可变性* 中，我们学习了 Clojure 中的关键字。我们之前章节中学到的 `refer` 函数的基本用法可以通过关键字进行修改或扩展。它们是可选的，因为我们可以使用它们，但不必使用。
- en: 'The keywords that we can use with `refer` are:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以与 `refer` 一起使用的关键字是：
- en: '`:only`: The `:only` keyword allows us to import only the functions that we
    specify. This means that any functions not specified are not imported.'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`:only`：`:only` 关键字允许我们只导入我们指定的函数。这意味着任何未指定的函数都不会被导入。'
- en: '`:exclude`: The `:exclude` keyword allows us to exclude certain functions from
    being imported. We would import all but the ones that we want to exclude.'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`:exclude`：`:exclude` 关键字允许我们排除某些函数的导入。我们将导入除了我们想要排除的函数之外的所有函数。'
- en: '`:rename`: The `:rename` keyword allows us to rename functions that we import.
    This sets an alias—a new name for a function—and we would refer to the function
    using that new name.'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`:rename`：`:rename` 关键字允许我们重命名导入的函数。这设置了一个别名——一个函数的新名称——我们将使用这个新名称来引用该函数。'
- en: We now know three keywords that can modify the importing of namespaces using
    the `refer` function. In the next three exercises, we will use each keyword to
    import namespaces and use data from them.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在知道了三个可以修改使用 `refer` 函数导入命名空间的 `refer` 关键字。在接下来的三个练习中，我们将使用每个关键字导入命名空间并使用它们的数据。
- en: 'Exercise 8.04: Using the :only Keyword'
  id: totrans-86
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 8.04：使用 :only 关键字
- en: 'The aim of this exercise is to show how we can extend the basic use of the
    `refer` function by using the `:only` keyword. We will import namespaces using
    the `refer` function with the `:only` keyword. Then, we will access data from
    the imported namespace:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 本练习的目的是展示我们如何通过使用 `:only` 关键字来扩展 `refer` 函数的基本用法。我们将使用带有 `:only` 关键字的 `refer`
    函数导入命名空间。然后，我们将从导入的命名空间中访问数据：
- en: 'In REPL, type the following command to use the `in-ns` function to create the
    `garden` namespace:'
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 REPL 中，输入以下命令以使用 `in-ns` 函数创建 `garden` 命名空间：
- en: '[PRE20]'
  id: totrans-89
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'REPL creates a new namespace for us:'
  id: totrans-90
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: REPL为我们创建了一个新的命名空间：
- en: '[PRE21]'
  id: totrans-91
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'We can define two variables in this namespace:'
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以在该命名空间中定义两个变量：
- en: '[PRE22]'
  id: totrans-93
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'REPL informs us that vars have been created:'
  id: totrans-94
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: REPL 通知我们已创建变量：
- en: '[PRE23]'
  id: totrans-95
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'After that, we switch to a new namespace using the `in-ns` function:'
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们使用 `in-ns` 函数切换到新的命名空间：
- en: '[PRE24]'
  id: totrans-97
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Note
  id: totrans-98
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意
- en: With the `:only` keyword, we can refer to another namespace but import only
    selected parts.
  id: totrans-99
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 使用 `:only` 关键字，我们可以引用另一个命名空间，但只导入选定的部分。
- en: 'Import the `garden` namespace using the `refer` function together with the
    `:only` keyword:'
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `refer` 函数和 `:only` 关键字导入 `garden` 命名空间：
- en: '[PRE25]'
  id: totrans-101
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'This will return the following:'
  id: totrans-102
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这将返回以下内容：
- en: '[PRE26]'
  id: totrans-103
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: We can access the `vegetables` var directly in the new `shop` namespace.
  id: totrans-104
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们可以直接在新 `shop` 命名空间中访问 `vegetables` 变量。
- en: 'Call the `vegetables` var to access its content:'
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用 `vegetables` 变量以访问其内容：
- en: '[PRE27]'
  id: totrans-106
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'REPL returns the expected vector as follows:'
  id: totrans-107
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: REPL 返回预期的向量如下：
- en: '[PRE28]'
  id: totrans-108
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'If, however, we want to access another var, `fruits`, call the `fruits` vector
    as follows:'
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然而，如果我们想访问另一个变量 `fruits`，可以这样调用 `fruits` 向量：
- en: '[PRE29]'
  id: totrans-110
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'We get an exception in REPL:'
  id: totrans-111
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在 REPL 中，我们遇到了异常：
- en: '[PRE30]'
  id: totrans-112
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Because when we imported the namespace, we used the `:only` keyword to import
    the `vegetables` var. The other var needs to be fully qualified with a namespace
    if we want to use it.
  id: totrans-113
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 因为当我们导入命名空间时，我们使用了 `:only` 关键字来导入 `vegetables` 变量。如果我们想使用其他变量，则需要使用完整的命名空间名称。
- en: 'Call the `fruits` vector using the fully qualified name:'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用完全限定名称调用 `fruits` 向量：
- en: '[PRE31]'
  id: totrans-115
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'This time, we get the expected vector as follows:'
  id: totrans-116
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这次，我们得到了预期的向量如下：
- en: '[PRE32]'
  id: totrans-117
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: In this exercise, we created vars in one namespace and then we imported this
    namespace using the `refer` function. During the import, we used the `:only` keyword,
    which allowed us to import only the selected data.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们在一个命名空间中创建了变量，然后使用 `refer` 函数导入这个命名空间。在导入过程中，我们使用了 `:only` 关键字，这允许我们只导入选定的数据。
- en: In the next exercise, we will import a namespace using the `refer` function
    and the `:exclude` keyword.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个练习中，我们将使用`refer`函数和`:exclude`关键字导入一个命名空间。
- en: 'Exercise 8.05: Using the :exclude Keyword'
  id: totrans-120
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 8.05：使用`:exclude`关键字
- en: In the previous exercise, we imported content from one namespace to another
    using the `refer` function. We restricted importing using the `:only` keyword
    to import only selected data. Now we will use a second keyword that allows us
    to control the importing of namespaces with the `refer` function.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个练习中，我们使用`refer`函数从一个命名空间导入到另一个命名空间的内容。我们使用`:only`关键字限制了导入，只导入所需的数据。现在我们将使用第二个关键字，它允许我们使用`refer`函数控制命名空间的导入。
- en: 'Using the `:exclude` keyword allows us to import some parts from a namespace
    but exclude parts that we do not need:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`:exclude`关键字允许我们从命名空间中导入部分内容，但排除我们不需要的部分：
- en: 'First, we will switch to a new namespace using the `in-ns` function:'
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们将使用`in-ns`函数切换到新的命名空间：
- en: '[PRE33]'
  id: totrans-124
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'REPL tells us that we successfully switched to a new namespace:'
  id: totrans-125
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: REPL告诉我们我们成功切换到了新的命名空间：
- en: '[PRE34]'
  id: totrans-126
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The next step is to import the `garden` namespace but exclude the `vegetables`
    var. We use the `refer` function with the `:exclude` keyword:'
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一步是导入`garden`命名空间，但排除`vegetables`变量。我们使用带有`:exclude`关键字的`refer`函数：
- en: '[PRE35]'
  id: totrans-128
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'This will return the following:'
  id: totrans-129
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这将返回以下内容：
- en: '[PRE36]'
  id: totrans-130
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'We test the import by trying to access the `fruits` var:'
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们通过尝试访问`fruits`变量来测试导入：
- en: '[PRE37]'
  id: totrans-132
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'So far, so good, as REPL returns us the vector:'
  id: totrans-133
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 到目前为止，一切顺利，因为REPL返回了向量：
- en: '[PRE38]'
  id: totrans-134
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'We will try accessing the excluded var, `vegetables`:'
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将尝试访问被排除的变量`vegetables`：
- en: '[PRE39]'
  id: totrans-136
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'We immediately see an exception message in REPL:'
  id: totrans-137
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们立即在REPL中看到了一个异常消息：
- en: '[PRE40]'
  id: totrans-138
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'We need to use the fully qualified name to access the `vegetables` var:'
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要使用完全限定名来访问`vegetables`变量：
- en: '[PRE41]'
  id: totrans-140
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'This time, REPL shows us the expected vector:'
  id: totrans-141
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这次，REPL显示了预期的向量：
- en: '[PRE42]'
  id: totrans-142
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: In this exercise, we imported a namespace using the `refer` function. During
    the import, we used the `:exclude` keyword, which allowed us to restrict the data
    to be imported.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们使用`refer`函数导入了一个命名空间。在导入过程中，我们使用了`:exclude`关键字，这允许我们限制要导入的数据。
- en: In the next exercise, we will import a namespace using the `refer` function
    and the `:rename` keyword.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个练习中，我们将使用`refer`函数和`:rename`关键字导入一个命名空间。
- en: 'Exercise 8.06: Using the :rename Keyword'
  id: totrans-145
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 8.06：使用`:rename`关键字
- en: In the previous exercise, we imported content from one namespace to another
    using the `refer` function. We restricted importing using the `:exclude` keyword
    to import only data that we wanted. Now we will use a third keyword that allows
    us to control the importing of namespaces with the `refer` function.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个练习中，我们使用`refer`函数从一个命名空间导入到另一个命名空间的内容。我们使用`:exclude`关键字限制了导入，只导入我们想要的数据。现在我们将使用第三个关键字，它允许我们使用`refer`函数控制命名空间的导入。
- en: 'We will see the `:rename` keyword in use. It allows us to import from one namespace
    and rename certain symbols:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将看到`:rename`关键字的用法。它允许我们从另一个命名空间导入并重命名某些符号：
- en: 'We will switch to a new namespace using the `in-ns` function:'
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将使用`in-ns`函数切换到新的命名空间：
- en: '[PRE43]'
  id: totrans-149
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'While we import the `garden` namespace, we want to rename the `fruits` var
    to `owoce` (Polish for fruits). We will use the `refer` function with the `:rename`
    keyword:'
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当我们导入`garden`命名空间时，我们希望将`fruits`变量重命名为`owoce`（波兰语中的水果）。我们将使用带有`:rename`关键字的`refer`函数：
- en: '[PRE44]'
  id: totrans-151
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'We access the `vegetables` var in the REPL:'
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们在REPL中访问`vegetables`变量：
- en: '[PRE45]'
  id: totrans-153
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'This returns the vector in the REPL:'
  id: totrans-154
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这在REPL中返回了向量：
- en: '[PRE46]'
  id: totrans-155
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Trying to access the `fruits` var:'
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 尝试访问`fruits`变量：
- en: '[PRE47]'
  id: totrans-157
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'It tells us that it is not accessible:'
  id: totrans-158
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 它告诉我们它不可访问：
- en: '[PRE48]'
  id: totrans-159
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Because we renamed the `fruits` var, we need to access `fruits` with a new name,
    which we defined when we used the `refer` function.
  id: totrans-160
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 因为我们将`fruits`变量重命名了，所以我们需要使用我们使用`refer`函数时定义的新名称来访问`fruits`。
- en: 'Now type `owoce` in the REPL:'
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在在REPL中输入`owoce`：
- en: '[PRE49]'
  id: totrans-162
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'This time, we get the expected vector:'
  id: totrans-163
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这次，我们得到了预期的向量：
- en: '[PRE50]'
  id: totrans-164
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: In this exercise, we imported a namespace using the `refer` function. During
    the import, we used the `:rename` keyword, which allowed us to restrict what data
    should be imported.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们使用`refer`函数导入了一个命名空间。在导入过程中，我们使用了`:rename`关键字，这允许我们限制应该导入的数据。
- en: 'We now know how to use `refer`. First, we imported a namespace using the `refer`
    function. Then we saw how we can modify importing with the `refer` function when
    we use three keywords: `:only`, `:exclude`, and `:rename`.'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道如何使用`refer`。首先，我们使用`refer`函数导入了一个命名空间。然后我们看到了如何使用三个关键字（`:only`、`:exclude`和`:rename`）来修改使用`refer`函数时的导入。
- en: We use the `:only` keyword when we want to import from one namespace to certain
    other functions. The `:only` keyword allows us to limit the functions that we
    import.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们想要从一个命名空间导入到另一个命名空间的某些函数时，我们使用 `:only` 关键字。`:only` 关键字允许我们限制导入的函数。
- en: We use the `:exclude` keyword when we want to import from one namespace to another
    but without certain functions. The `:only` keyword allows us to exclude functions
    that we do not want to import.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们想要从一个命名空间导入到另一个命名空间，但不导入某些函数时，我们使用 `:exclude` 关键字。`:only` 关键字允许我们排除我们不想导入的函数。
- en: We use the `:rename` keyword when we want to import from one namespace to another
    and change the names of some functions during the import.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们想要从一个命名空间导入到另一个命名空间并更改导入过程中某些函数的名称时，我们使用 `:rename` 关键字。
- en: In the next section, we will learn how `require` and `use` help us with managing
    namespaces.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将学习 `require` 和 `use` 如何帮助我们管理命名空间。
- en: Importing Clojure Functions with require and use
  id: totrans-171
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 `require` 和 `use` 导入 Clojure 函数
- en: In the previous section, we learned how to import Clojure functions using `refer`.
    In this section, we will learn how we can import Clojure functions with `require`
    and `use`.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们学习了如何使用 `refer` 导入 Clojure 函数。在本节中，我们将学习如何使用 `require` 和 `use` 导入 Clojure
    函数。
- en: While `refer` allows us to literally refer to other namespaces' vars without
    fully qualifying them, often we need more than that. In the previous exercise,
    we imported a namespace and accessed vars such as `fruits` from it without using
    the namespace name as a prefix to the `garden`/`fruits` var. Often, we want to
    load functions from a namespace and use those functions. If we want to read the
    file, we need to import code from the Clojure I/O library (the library for input-output
    operations such as reading and writing files).
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 `refer` 允许我们直接引用其他命名空间的变量而不需要完全限定它们，但通常我们需要的不仅仅是这样。在之前的练习中，我们导入了一个命名空间，并从中访问了如
    `fruits` 这样的变量，而没有使用命名空间名称作为 `garden`/`fruits` 变量的前缀。通常，我们想要从一个命名空间加载函数并使用这些函数。如果我们想读取文件，我们需要从
    Clojure I/O 库（用于输入输出操作，如读取和写入文件的库）导入代码。
- en: With the `require` function, we will load a namespace that we'll specify. This
    way, functions from the loaded namespace are available in our namespace for use.
    This is a great way to write Clojure code, reuse existing functions, and make
    them available in our code. Although we loaded new functions with `require`, we
    still need to fully qualify them.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `require` 函数，我们将加载一个我们将指定的命名空间。这样，加载命名空间中的函数就可用在我们的命名空间中使用了。这是一种编写 Clojure
    代码、重用现有函数并在我们的代码中使它们可用的好方法。尽管我们使用 `require` 加载了新函数，但我们仍然需要在使用时完全限定它们。
- en: While the `require` function allows us to load a designated namespace, the `use`
    function goes a little bit further and implicitly uses `refer` to allow code to
    refer to other namespaces' vars without fully qualifying them.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 `require` 函数允许我们加载指定的命名空间，但 `use` 函数更进一步，隐式地使用 `refer` 允许代码引用其他命名空间的变量，而无需完全限定它们。
- en: '`refer`, `require`, and `use` all serve different purposes:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '`refer`、`require` 和 `use` 都有不同的用途：'
- en: '`refer` allows us to call functions from a different namespace (functions are
    not imported).'
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`refer` 允许我们从不同的命名空间调用函数（函数不是导入的）。'
- en: '`require` imports functions from a different namespace but we have to qualify
    them when using them.'
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`require` 从不同的命名空间导入函数，但在使用时我们必须对它们进行限定。'
- en: '`use` loads functions from a different namespace and we do not have to qualify
    them.'
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`use` 加载来自不同命名空间的函数，我们不需要对它们进行限定。'
- en: 'Exercise 8.07: Importing Clojure Functions with require and use'
  id: totrans-180
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 8.07：使用 `require` 和 `use` 导入 Clojure 函数
- en: In this exercise, we will learn how the `require` and `use` functions can help
    us to import Clojure namespaces. We will import Clojure namespaces using both
    methods. This will help us understand the difference between both methods.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将学习 `require` 和 `use` 函数如何帮助我们导入 Clojure 命名空间。我们将使用这两种方法导入 Clojure
    命名空间。这将帮助我们理解两种方法之间的区别。
- en: By using `require`, we ensure that the namespaces provided are fully loaded
    whenever we need to use them.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用 `require`，我们确保在需要使用时，提供的命名空间总是完全加载的。
- en: Clojure provides a number of namespaces, such as `clojure.edn` or `clojure.pprint`,
    that help developers to create programs. EDN stands for extensible data notation.
    It is a system for representing objects. It provides a rich set of features such
    as functionality for specifying the date and time. The `clojure.edn` namespace
    allows us to use the `edn` format. Imagine that you want to send a date from one
    program to another. If you send the date as a string, "Monday 7.10.2019," there
    is no information about time zone. The program receiving this date string does
    not know whether this time is in London or New York. With `edn`, we can send a
    date object that contains information about the time zone.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: Clojure提供了一系列命名空间，例如`clojure.edn`或`clojure.pprint`，这些命名空间帮助开发者创建程序。EDN代表可扩展数据表示法。它是一个表示对象的系统。它提供了一系列丰富的功能，例如指定日期和时间的功能。`clojure.edn`命名空间允许我们使用`edn`格式。想象一下，你想要将一个日期从一个程序发送到另一个程序。如果你将日期作为字符串发送，例如“Monday
    7.10.2019”，那么没有关于时区的信息。接收这个日期字符串的程序不知道这个时间是在伦敦还是纽约。使用`edn`，我们可以发送包含时区信息的日期对象。
- en: The `clojure.print` namespace contains utility functions that help to print
    data from programs in an easy-to-understand and easy-to-read format.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '`clojure.print`命名空间包含一些实用函数，这些函数有助于以易于理解和阅读的格式从程序中打印数据。'
- en: 'Consider printing a hash as shown in the following figure:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑打印如图所示的哈希：
- en: '![Figure 8.3: Printing a hash'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.3：打印哈希'
- en: '](img/B14502_08_03.jpg)'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B14502_08_03.jpg)'
- en: 'Figure 8.3: Printing a hash'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.3：打印哈希
- en: 'Instead of printing a hash as shown in *Figure 8.3*, functions from the `clojure.pprint`
    namespace allow us to print a hash like this:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 与*图8.3*中显示的打印哈希不同，`clojure.pprint`命名空间中的函数允许我们以这种方式打印哈希：
- en: '![Figure 8.4: Printing a hash using the functions from the namespace'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.4：使用命名空间中的函数打印哈希'
- en: '](img/B14502_08_04.jpg)'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B14502_08_04.jpg)'
- en: 'Figure 8.4: Printing a hash using the functions from the namespace'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.4：使用命名空间中的函数打印哈希
- en: 'By default, when we start a new session, only `clojure.core` is available.
    The `clojure.core` namespace contains the main Clojure functions, such as `filter`,
    `map`, `reduce`, and `count`. These are core functions that are used very often
    when working in Clojure. That is why they are available by default when working
    in Clojure. The other namespaces need to be added by us:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，当我们启动一个新的会话时，只有`clojure.core`可用。`clojure.core`命名空间包含主要的Clojure函数，如`filter`、`map`、`reduce`和`count`。这些是在Clojure中工作时经常使用的核心函数。这就是为什么它们在Clojure中默认可用。其他命名空间需要我们添加：
- en: 'We will require a new namespace in our REPL session that will help us pretty
    print some content:'
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将在REPL会话中导入一个新的命名空间，这将帮助我们美化打印一些内容：
- en: '[PRE51]'
  id: totrans-195
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'We can use functions from this namespace now. We call the `print-table` function
    to print a table in REPL:'
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在可以使用这个命名空间中的函数。我们调用`print-table`函数在REPL中打印表格：
- en: '[PRE52]'
  id: totrans-197
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'This prints a table in REPL:'
  id: totrans-198
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这将在REPL中打印一个表格：
- en: '![Figure 8.5: Printing a table in REPL'
  id: totrans-199
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图8.5：在REPL中打印表格'
- en: '](img/B14502_08_05.jpg)'
  id: totrans-200
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B14502_08_05.jpg)'
- en: 'Figure 8.5: Printing a table in REPL'
  id: totrans-201
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图8.5：在REPL中打印表格
- en: Using fully qualified names can become tedious because every time we want to
    call any function, we have to provide its full name, including the namespace.
    This results in verbose code and a lot of repetition of namespace names. Fortunately,
    Clojure allows us to set an alias for a namespace. In order to set an alias, we
    use the `:as` keyword. With the `:as` keyword, we shorten how we call functions.
    We do not need to write the full namespace but simply an alias that we choose.
  id: totrans-202
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 使用完全限定名称可能会变得繁琐，因为每次我们想要调用任何函数时，我们都必须提供其完整名称，包括命名空间。这导致代码冗长，并且命名空间名称重复很多。幸运的是，Clojure允许我们为命名空间设置别名。为了设置别名，我们使用`:as`关键字。使用`:as`关键字，我们可以缩短调用函数的方式。我们不需要写出完整的命名空间，只需简单地使用我们选择的别名。
- en: 'Call the `require` function with the `:as` keyword to simplify importing the
    function:'
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`:as`关键字调用`require`函数以简化导入函数：
- en: '[PRE53]'
  id: totrans-204
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Now we can use the alias to call the `print-table` function:'
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们可以使用别名来调用`print-table`函数：
- en: '[PRE54]'
  id: totrans-206
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: We have just seen how the `require` function is used. Next, we will see how
    the `use` function helps us to import namespaces.
  id: totrans-207
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们刚刚看到了`require`函数的使用方法。接下来，我们将看到`use`函数如何帮助我们导入命名空间。
- en: 'We call the `use` function to import namespaces in REPL:'
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们调用`use`函数在REPL中导入命名空间：
- en: '[PRE55]'
  id: totrans-209
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: The preceding statement will load the `clojure.pprint` namespace and refer to
    the namespace.
  id: totrans-210
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 前面的语句将加载`clojure.pprint`命名空间并引用该命名空间。
- en: We can use functions from this namespace without fully qualifying them.
  id: totrans-211
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们可以不使用完全限定名称来使用这个命名空间中的函数。
- en: 'Call the `print-table` function without the namespace name to print a table:'
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在没有命名空间名称的情况下调用 `print-table` 函数以打印表格：
- en: '[PRE56]'
  id: totrans-213
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'This will print a table for us:'
  id: totrans-214
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这将为我们打印一个表格：
- en: '![Figure 8.6: Calling the print-table function'
  id: totrans-215
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图 8.6：调用 print-table 函数](img/B14502_08_06.jpg)'
- en: '](img/B14502_08_06.jpg)'
  id: totrans-216
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B14502_08_07.jpg)'
- en: 'Figure 8.6: Calling the print-table function'
  id: totrans-217
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 8.6：调用 print-table 函数
- en: We have just seen how `use` works. Next, we will look into using keywords such
    as `:only` and `:rename` with `use`.
  id: totrans-218
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们刚刚看到了 `use` 的工作方式。接下来，我们将探讨使用 `use` 中的关键字，如 `:only` 和 `:rename`。
- en: 'Import a function from the `clojure.string` namespace:'
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 `clojure.string` 命名空间导入一个函数：
- en: '[PRE57]'
  id: totrans-220
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'This will import the `split` function from the `string` namespace and return
    the following:'
  id: totrans-221
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这将导入 `string` 命名空间中的 `split` 函数并返回以下内容：
- en: '[PRE58]'
  id: totrans-222
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'We can use the `split` function without a namespace name:'
  id: totrans-223
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们可以在没有命名空间名称的情况下使用 `split` 函数：
- en: '![Figure 8.7: Using the split function'
  id: totrans-224
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图 8.7：使用 split 函数](img/B14502_08_06.jpg)'
- en: '](img/B14502_08_07.jpg)'
  id: totrans-225
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B14502_08_07.jpg)'
- en: 'Figure 8.7: Using the split function'
  id: totrans-226
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 8.7：使用 split 函数
- en: 'Rename the function from the `clojure.edn` namespace when importing with `use`:'
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当使用 `use` 导入时，重命名 `clojure.edn` 命名空间中的函数：
- en: '[PRE59]'
  id: totrans-228
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'This will return the following:'
  id: totrans-229
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这将返回以下内容：
- en: '[PRE60]'
  id: totrans-230
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'We renamed the `read-string` function from the `clojure.end` namespace to `string-read`.
    We can call the `string-read` function without a namespace name now:'
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们已将 `clojure.end` 命名空间中的 `read-string` 函数重命名为 `string-read`。现在我们可以没有命名空间名称地调用
    `string-read` 函数：
- en: '[PRE61]'
  id: totrans-232
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'The output is as follows:'
  id: totrans-233
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE62]'
  id: totrans-234
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE62]'
- en: We have a string that represents a date from 1989\. We pass this string to the
    `edn` function, which converts a string to a `Date` object. When we call the `class`
    function, it tells us that we have a `Date` object.
  id: totrans-235
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们有一个表示 1989 年的日期的字符串。我们将这个字符串传递给 `edn` 函数，该函数将字符串转换为 `Date` 对象。当我们调用 `class`
    函数时，它告诉我们我们有一个 `Date` 对象。
- en: We have seen how to import namespaces with `refer` and `use`. In the following
    activity, we will put this knowledge into practice.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了如何使用 `refer` 和 `use` 导入命名空间。在接下来的活动中，我们将将这些知识付诸实践。
- en: 'Activity 8.01: Altering the Users List in an Application'
  id: totrans-237
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 活动 8.01：在应用程序中更改用户列表
- en: In this activity, we will apply our knowledge about importing namespaces to
    solve a real-world problem. Imagine that we work in an IT company and we are responsible
    for designing a backend application. One of the functions in our backend returns
    a list of users. A new frontend feature needs this list in a different format.
    The aim of this activity is to alter the list of users.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个活动中，我们将应用关于导入命名空间的知识来解决一个实际问题。想象一下，我们在一家 IT 公司工作，我们负责设计后端应用程序。我们后端中的一个函数返回一个用户列表。新的前端功能需要以不同的格式获取这个列表。这个活动的目的是更改用户列表。
- en: 'The two alterations required are:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 需要进行的两个更改是：
- en: Capitalizing usernames
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 大写用户名
- en: Checking whether the users John, Paul, and Katie belong to an admin group
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查 John、Paul 和 Katie 是否属于管理员组
- en: The application currently displays a list of users, their honorifics, their
    first names, and their last names. The honorifics and first names are separated
    by `_` (an underscore). In this activity, we will add a space between the honorifics
    and the first names. Then, we will take the first and last names and capitalize
    the first letter of the honorifics, first names, and last names. Finally, we will
    check whether our users belong to the admin group.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序当前显示用户列表、他们的头衔、他们的名字和姓氏。头衔和名字之间用下划线（_）分隔。在这个活动中，我们将在头衔和名字之间添加一个空格。然后，我们将名字和姓氏的首字母大写。最后，我们将检查我们的用户是否属于管理员组。
- en: 'These steps will help you complete the activity:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 这些步骤将帮助您完成活动：
- en: Import the `clojure.string` namespace with `use` and the `:rename` keyword for
    the `replace` and `reverse` functions.
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `use` 和 `:rename` 关键字导入 `clojure.string` 命名空间，并为 `replace` 和 `reverse` 函数指定。
- en: Create a set of users.
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一组用户。
- en: Replace the underscore between the honorifics and the first names.
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 替换头衔和名字之间的下划线。
- en: Use the `capitalize` function to capitalize each person's initials in the user
    group.
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `capitalize` 函数将用户组中每个人的首字母大写。
- en: Update the user list by using the string `replace` and `capitalize` functions.
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用字符串的 `replace` 和 `capitalize` 函数更新用户列表。
- en: Import only the `print-table` function from the `clojure.pprint` namespace.
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 仅从 `clojure.pprint` 命名空间导入 `print-table` 函数。
- en: Print a table with users.
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打印包含用户的表格。
- en: Import the `clojure.set` namespace, excluding the `join` function.
  id: totrans-251
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入 `clojure.set` 命名空间，但不包括 `join` 函数。
- en: Create a set of admins.
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一组管理员。
- en: Call the `subset?` function on two sets of users and admins.
  id: totrans-253
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在两个用户和管理员集合上调用 `subset?` 函数。
- en: 'The initial list of users and admins will look as follows:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 初始的用户和管理员列表将如下所示：
- en: '[PRE63]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'The admin list will look as follows:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 管理员列表将如下所示：
- en: '[PRE64]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'The final list of users will look as follows:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 最终的用户列表将如下所示：
- en: '![Figure 8.8: Expected outcome'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.8：预期结果'
- en: '](img/B14502_08_08.jpg)'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B14502_08_08.jpg)'
- en: 'Figure 8.8: Expected outcome'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.8：预期结果
- en: Note
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The solution for this activity can be found on page 706.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 此活动的解决方案可以在第706页找到。
- en: When You Want use versus When You Want require
  id: totrans-264
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 当你想使用（use）时与当你需要（require）时
- en: Although `use` and `require` may seem very similar at first glance, with some
    practice you will understand when to use each one.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然乍一看`use`和`require`可能非常相似，但通过一些实践，你将理解何时使用哪一个。
- en: 'If we want to import a namespace using `require`, we will call it as follows:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想使用`require`导入命名空间，我们将如下调用：
- en: '[PRE65]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Importing a namespace with `use` is done as follows:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`use`导入命名空间的方式如下：
- en: '[PRE66]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: If we compare both statements, we see that the only difference is the importing
    function, either `require` or `use`. The syntax of using them is the same. We
    call a function and then the namespace that we want to import. The reason to use
    both importing functions is different, though, as we will see in this topic.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们比较这两个语句，我们会看到唯一的区别是导入函数，要么是`require`要么是`use`。它们的语法是相同的。我们调用一个函数然后是我们要导入的命名空间。尽管如此，使用这两个导入函数的原因是不同的，正如我们将在本主题中看到的那样。
- en: 'When in doubt, choose `require`. It allows you to add an alias for the namespace
    and makes the code more readable than having to use fully qualified names:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 当有疑问时，选择`require`。它允许你为命名空间添加别名，使代码比使用完全限定名称更易于阅读：
- en: '[PRE67]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'This way, we can call functions very easily. Consider the following example:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，我们可以非常容易地调用函数。考虑以下示例：
- en: '[PRE68]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'When choosing `use`, advised to add an alias and import only required functions:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 当选择`use`时，建议添加别名并只导入所需的函数：
- en: '[PRE69]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: When you import only required functions, you can easily add more later on. Importing
    only the functions that we require at the moment helps us to maintain the code.
    The developers dealing with the code will not spend time searching for the usage
    of functions that we imported.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 当你只导入所需的函数时，你可以很容易地稍后添加更多。只导入我们目前所需的函数有助于我们维护代码。处理代码的开发者不会花费时间搜索我们导入的函数的使用情况。
- en: 'There are two potential problems with using `use` without the `:only` keyword:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 在不使用`:only`关键字的情况下使用`use`可能存在两个潜在问题：
- en: Inspecting the code does not tell us quickly from which namespace a certain
    function comes. With aliased namespaces, we can establish this more easily.
  id: totrans-279
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查代码并不能快速告诉我们某个函数来自哪个命名空间。通过使用别名的命名空间，我们可以更容易地建立这一点。
- en: We avoid any name collisions in the future if we add a new library or if an
    existing library introduces a new function with a name that we are already using.
  id: totrans-280
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果我们添加一个新的库或者现有的库引入了一个我们已经在使用的同名新函数，我们避免未来出现任何名称冲突。
- en: Now that we've looked at namespaces, we will go a level higher and investigate
    how to structure projects using Leiningen.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了命名空间，我们将提升一个层次，研究如何使用Leiningen来构建项目。
- en: Leiningen—A Build Tool in Clojure
  id: totrans-282
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Leiningen——Clojure中的构建工具
- en: With namespaces, we put our functions into files and group related functions
    together. This helps to keep code separated into units. Consider a situation where
    utility functions are separated from frontend functions. This helps us navigate
    code and find functions. We know that frontend functions responsible for creating
    HTML will not be in a backend namespace responsible for connecting to the database.
    Build tools serve a different purpose. As the name suggests, these are tools that
    help us build. With them, we automate the creation of an executable application.
    An alternative would be to compile all the code ourselves and put it on a server.
    Even in applications with only a few features, we run the risk of forgetting to
    compile a namespace. The more namespaces there are and the more complicated an
    application is, the bigger the risk of making a mistake in manual code compilation.
    Build tools compile our code and package it into a usable form. Developers specify
    parts of the application that need to be compiled and the build tool automatically
    compiles the parts for them. This helps to minimize compilation mistakes. Some
    build tools are Maven, Gradle, Webpack, and Grunt.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 使用命名空间，我们将函数放入文件并将相关函数分组在一起。这有助于将代码分离成单元。考虑一种情况，其中实用函数与前端函数分离。这有助于我们导航代码并找到函数。我们知道负责创建HTML的前端函数不会在负责连接数据库的后端命名空间中。构建工具服务于不同的目的。正如其名所示，这些是帮助我们构建的工具。使用它们，我们可以自动化可执行应用程序的创建。另一种选择是自行编译所有代码并将其放在服务器上。即使在只有少量功能的程序中，我们也存在忘记编译命名空间的风险。命名空间越多，应用程序越复杂，手动代码编译出错的风险就越大。构建工具编译我们的代码并将其打包成可用的形式。开发者指定需要编译的应用程序部分，构建工具会自动为他们编译这些部分。这有助于最小化编译错误。一些构建工具有Maven、Gradle、Webpack和Grunt。
- en: Leiningen is a very popular build tool in the Clojure community. Its popularity
    comes from the rich set of features it has. It provides a lot of templates that
    allow developers to start writing code without much of a project setup. Often,
    the type of application that a developer wants to create has already been created
    by someone else. This way, we can reuse what developers before us created instead
    of writing so much code ourselves. We have a web application template that provides
    us with a common structure for a web page. There is a template for a backend server
    with a file structure and configuration that is common in backend servers. In
    the next exercise, we will create a new project.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: Leiningen是Clojure社区中非常流行的构建工具。其流行度来自于它丰富的功能集。它提供了许多模板，允许开发者在不进行太多项目设置的情况下开始编写代码。通常，开发者想要创建的应用程序类型可能已经被其他人创建。这样，我们可以重用我们之前开发者的成果，而不是自己编写大量代码。我们有一个提供网页常见结构的Web应用程序模板。有一个为后端服务器提供的模板，其文件结构和配置在后端服务器中很常见。在下一个练习中，我们将创建一个新的项目。
- en: 'Exercise 8.08: Creating a Leiningen Project'
  id: totrans-285
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习8.08：创建Leiningen项目
- en: The aim of this exercise is to learn about the standard structure in Leiningen
    projects. We will create a sample project based on a template from Leiningen.
    This will allow us to explore the files that Leiningen creates and the purpose
    of each file.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 本练习的目的是了解Leiningen项目的标准结构。我们将基于Leiningen的模板创建一个示例项目。这将使我们能够探索Leiningen创建的文件以及每个文件的目的。
- en: 'In order to create a new Leiningen project, we will use the command line:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 为了创建一个新的Leiningen项目，我们将使用命令行：
- en: 'Call a new `lein` task with the `app` template. To create a new project, execute
    the following:'
  id: totrans-288
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`app`模板调用一个新的`lein`任务。要创建一个新项目，执行以下命令：
- en: '[PRE70]'
  id: totrans-289
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'In the preceding command, the `lein` command takes three parameters:'
  id: totrans-290
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在上述命令中，`lein`命令接受三个参数：
- en: '`new`: A `lein` task telling Leiningen what type of task to execute. Task `new`
    will create a project based on a template.'
  id: totrans-291
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`new`：一个`lein`任务，告诉Leiningen要执行哪种类型的任务。任务`new`将基于模板创建项目。'
- en: '`app`: The name of the template to use when creating a project. Leiningen will
    create a project using a specified template.'
  id: totrans-292
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`app`：创建项目时使用的模板名称。Leiningen将使用指定的模板创建项目。'
- en: '`hello-leiningen`: The name of the project.'
  id: totrans-293
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`hello-leiningen`：项目的名称。'
- en: 'We should see that our new project has been created:'
  id: totrans-294
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们应该看到我们的新项目已经创建：
- en: '[PRE71]'
  id: totrans-295
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'After creating a project, we will navigate to the project''s directory:'
  id: totrans-296
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建项目后，我们将导航到项目的目录：
- en: '[PRE72]'
  id: totrans-297
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'Now, inspect the project as follows:'
  id: totrans-298
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，按照以下方式检查项目：
- en: '[PRE73]'
  id: totrans-299
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'We will see that Leiningen has created a number of files for us already:'
  id: totrans-300
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们将看到Leiningen已经为我们创建了一些文件：
- en: '![Figure 8.9: Inspecting the project'
  id: totrans-301
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图8.9：检查项目'
- en: '](img/B14502_08_09.jpg)'
  id: totrans-302
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B14502_08_09.jpg)'
- en: 'Figure 8.9: Inspecting the project'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.9：检查项目
- en: 'There are a few important things to notice here:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些需要注意的重要事项：
- en: We have a source directory, `src`, where we will put our code.
  id: totrans-305
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们有一个源目录，`src`，我们将在这里放置我们的代码。
- en: The `project.clj` file contains a description of our project.
  id: totrans-306
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`project.clj`文件包含我们项目的描述。'
- en: '`README.md` is an entry point with information about our application.'
  id: totrans-307
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`README.md`是一个入口点，其中包含有关我们应用程序的信息。'
- en: We have a `test` directory for our tests.
  id: totrans-308
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们有一个用于测试的`test`目录。
- en: We will have a closer look at these points in the following sections. Testing
    will be covered in *Chapter 10*, *Testing*. In the next section, we will look
    at the `project.clj` file.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在以下章节中更详细地探讨这些点。测试将在*第10章*，*测试*中介绍。在下一节中，我们将查看`project.clj`文件。
- en: Investigating project.clj
  id: totrans-310
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 调查`project.clj`
- en: 'The `project.clj` file that you have created will look similar to this one:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 你创建的`project.clj`文件将看起来类似于这个：
- en: '![Figure 8.10: The project.clj file'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.10：`project.clj`文件'
- en: '](img/B14502_08_10.jpg)'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B14502_08_10.jpg)'
- en: 'Figure 8.10: The project.clj file'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.10：`project.clj`文件
- en: 'Let''s take a look at each parameter:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看每个参数：
- en: '`hello-leiningen` project has got a SNAPSHOT version. This means that it is
    not yet a stable production-tested version but rather a development version. When
    you are ready to publish your project, be sure to add a proper version. A good
    guide is to use semantic versioning. There are times when using a snapshot version
    is necessary, such as with a bug fix before the fix gets included in the next
    release. The rule of thumb is to use stable versions unless a bug fix is needed.'
  id: totrans-316
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`hello-leiningen`项目有一个快照版本。这意味着它还不是经过稳定生产测试的版本，而是一个开发版本。当你准备好发布你的项目时，请确保添加一个适当的版本。一个好的指南是使用语义版本控制。有时使用快照版本是必要的，比如在修复被包含在下一个版本之前进行错误修复。一般规则是除非需要错误修复，否则使用稳定版本。'
- en: '**Description**: Adding a description is a good starting point for people looking
    at understanding the purpose of a project. Also, when the project is published
    in project repositories such as Maven or Clojars, it is easier to search for the
    project.'
  id: totrans-317
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**描述**：添加描述是让想要了解项目目的的人的好起点。此外，当项目在Maven或Clojars等项目仓库中发布时，更容易搜索到项目。'
- en: '`url` parameter allows us to place a web URL for our project. On our web page,
    we can add much more information about our project. Most project websites would
    have:'
  id: totrans-318
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`url`参数允许我们为项目放置一个网页URL。在我们的网页上，我们可以添加更多关于我们项目的信息。大多数项目网站都会有：'
- en: 'A rationale: Why the project was created'
  id: totrans-319
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 理由：为什么创建项目
- en: 'Documentation: A description of its usage'
  id: totrans-320
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 文档：对其用法的描述
- en: 'Tutorials: Examples of using the project'
  id: totrans-321
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 指南：使用项目的示例
- en: '**License**: The license is used as you might expect. It is a legal instrument
    governing the use of software. Essentially, it is an agreement between the owner
    of software and its user, allowing the user to use software under certain conditions.'
  id: totrans-322
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**许可证**：许可证的使用方式可能正如你所预期的那样。它是一种规范软件使用的法律工具。本质上，它是在软件所有者和用户之间的一项协议，允许用户在特定条件下使用软件。'
- en: 'There are many types of software licenses. Examples of licenses include:'
  id: totrans-323
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 软件许可证有很多种类型。许可证的例子包括：
- en: 'MIT license: This allows the distribution and modification of source code.'
  id: totrans-324
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: MIT许可证：这允许分发和修改源代码。
- en: 'Apache License 2.0: Like the MIT license, this allows the distribution and
    modification of code but requires the preservation of copyright notices.'
  id: totrans-325
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Apache许可证2.0：与MIT许可证类似，这允许分发和修改代码，但要求保留版权声明。
- en: 'GNU AGPLv3: Like the MIT license, this allows the distribution and modification
    of code but requires the stating of changes compared to the original version of
    the software.'
  id: totrans-326
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: GNU AGPLv3：与MIT许可证类似，这允许分发和修改代码，但要求说明与软件原始版本相比的更改。
- en: '`jar` files. They are basically `zip` files (compressed files) with some metadata
    about the project. When we specify dependencies in our `project.clj`, Leiningen
    will search the local repository. If dependencies are not already stored locally,
    then it will search the Maven and Clojars websites and download the dependencies.
    Such dependencies are then available for our project.'
  id: totrans-327
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`jar`文件。它们基本上是带有一些项目元数据的`zip`文件（压缩文件）。当我们指定`project.clj`中的依赖项时，Leiningen将在本地仓库中搜索。如果依赖项尚未存储在本地，那么它将在Maven和Clojars网站上搜索并下载依赖项。这些依赖项随后将可用于我们的项目。'
- en: '`:main` keyword, we specify the namespace that is the entry point for our project
    and application. It gets called when we run our project.'
  id: totrans-328
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `:main` 关键字，我们指定了项目和应用入口点的命名空间。当我们运行项目时，它会被调用。
- en: '`:profiles` keyword, we have an `uberjar` profile where we want AOT compilation.
    On the other hand, we would like our `:main` namespace to be without AOT. We create
    an uberjar with AOT because we want to compile the code before we run it. We do
    not want AOT for `:main` as we want to defer compilation until we start an application.
    For example, `:main` can use symbols such as environment settings, parameters
    that are not available at AOT compilation. They are only available when we start
    an application. If we compile too fast, the application will not have access to
    parameters that we passed when we start an application.'
  id: totrans-329
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `:profiles` 关键字，我们有一个 `uberjar` 配置文件，我们希望在 AOT 编译。另一方面，我们希望 `:main` 命名空间不进行
    AOT 编译。我们创建一个带有 AOT 的 uberjar，因为我们希望在运行之前编译代码。我们不希望 `:main` 进行 AOT 编译，因为我们希望在启动应用程序时再进行编译。例如，`:main`
    可以使用环境设置、在 AOT 编译时不可用的参数等符号。它们只有在启动应用程序时才可用。如果我们编译得太快，应用程序将无法访问我们在启动应用程序时传递的参数。
- en: '**Profiles**: Leiningen allows us to set up various profiles in our projects.
    Thanks to profiles, we can customize projects depending on our needs.'
  id: totrans-330
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**配置文件**：Leiningen 允许我们在项目中设置各种配置文件。多亏了配置文件，我们可以根据我们的需求定制项目。'
- en: For example, a development version could require a testing suite and we might
    want testing dependencies. On the other hand, when creating a production jar,
    we do not need testing dependencies.
  id: totrans-331
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 例如，开发版本可能需要测试套件，我们可能需要测试依赖项。另一方面，在创建生产 jar 时，我们不需要测试依赖项。
- en: We will look at Leiningen's profiles at the end of this chapter.
  id: totrans-332
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们将在本章的结尾查看 Leiningen 的配置文件。
- en: Now that we have looked at `project.clj`, we will see what the `README.md` file
    has to offer for us.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经查看了 `project.clj`，我们将看看 `README.md` 文件能为我们提供什么。
- en: A README file is a Markdown file that provides information about our project
    that we consider important for users to know. Markdown is a markup language that
    allows us to style documents.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: README 文件是一个 Markdown 文件，它提供了我们认为用户需要了解的关于我们项目的相关信息。Markdown 是一种标记语言，允许我们格式化文档。
- en: 'Typically, a README file will have the following sections:'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，README 文件将包含以下部分：
- en: '**Project name**: Where we put a short description of what the project does'
  id: totrans-336
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**项目名称**：在这里我们放置一个关于项目做什么的简短描述'
- en: '**Installation**: Where we inform users of the steps necessary to install our application'
  id: totrans-337
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**安装**：在这里我们告知用户安装应用程序所需的步骤'
- en: '**Usage**: Where we let users know how to use our project'
  id: totrans-338
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**用法**：在这里我们告知用户如何使用我们的项目'
- en: '**Examples**: A section with code samples showing how to use our project'
  id: totrans-339
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**示例**：一个包含代码示例的部分，展示如何使用我们的项目'
- en: '**Bugs**: Any known bugs'
  id: totrans-340
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**错误**：任何已知的错误'
- en: '**Changelog**: Where we document any changes between versions'
  id: totrans-341
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**变更日志**：在这里我们记录版本之间的任何更改'
- en: '**License**: Where we inform users of our project''s license type'
  id: totrans-342
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**许可证**：在这里我们告知用户我们项目的许可证类型'
- en: 'Here''s a sample README file:'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个示例 README 文件：
- en: '![Figure 8.11: Sample README file'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 8.11：示例 README 文件'
- en: '](img/B14502_08_11.jpg)'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B14502_08_11.jpg)'
- en: 'Figure 8.11: Sample README file'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.11：示例 README 文件
- en: You can add more sections. It all depends on what you think is important for
    users of your project to know. In the next topic, we will modify source files
    and run our application.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以添加更多部分。这完全取决于您认为用户需要了解哪些重要信息。在下一个主题中，我们将修改源文件并运行我们的应用程序。
- en: 'Exercise 8.09: Executing the Application on the Command Line'
  id: totrans-348
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 8.09：在命令行上执行应用程序
- en: The aim of this exercise is to create a Leiningen application and explore how
    applications are run.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 本练习的目的是创建一个 Leiningen 应用程序并探索应用程序的运行方式。
- en: This will help us understand the different options that Leiningen provides in
    the `project.clj` file.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 这将帮助我们理解 Leiningen 在 `project.clj` 文件中提供的不同选项。
- en: As we will see at the end of this exercise, in order to run our application
    from the command line, we need to call Leiningen's `run` task. Leiningen's `run`
    task will search the `project.clj` file for the `:main` keyword and corresponding
    namespace.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在本练习的结尾将要看到的，为了从命令行运行我们的应用程序，我们需要调用 Leiningen 的 `run` 任务。Leiningen 的 `run`
    任务将会在 `project.clj` 文件中搜索 `:main` 关键字及其对应的命名空间。
- en: 'In our case, the `:main` keyword in `project.clj` will look like this:'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的例子中，`project.clj` 中的 `:main` 关键字将看起来像这样：
- en: '[PRE74]'
  id: totrans-353
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: '`^:skip-aot` instructs Leiningen to skip AOT for the namespace that we specify.
    Here, the namespace is `hello-leiningen.core`. When we explored the `project.clj`
    file, we talked about why we want to skip AOT for the `:main` namespace.'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: '`^:skip-aot` 指示 Leiningen 跳过我们指定的命名空间的 AOT。在这里，命名空间是 `hello-leiningen.core`。当我们探索
    `project.clj` 文件时，我们讨论了为什么我们想要跳过 `:main` 命名空间的 AOT。'
- en: 'By default, Leiningen will search for the namespace that we specified in the
    `:main` keyword. In our case, it will search for the `hello-leiningen.core` namespace.
    In this namespace, if we have the `-main` function, it will be called:'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，Leiningen 将搜索我们在 `:main` 关键字中指定的命名空间。在我们的例子中，它将搜索 `hello-leiningen.core`
    命名空间。在这个命名空间中，如果我们有 `-main` 函数，它将被调用：
- en: 'After creating a new project, the content of the `hello-leiningen.core` namespace
    is the following:'
  id: totrans-356
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建新项目后，`hello-leiningen.core` 命名空间的内容如下：
- en: '[PRE75]'
  id: totrans-357
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE75]'
- en: When we create an application using Leiningen, it will autogenerate code in
    the `core` namespace. `(:gen-class)` instructs Leiningen to generate a Java class
    from the namespace. Build tools such as Leiningen execute Java bytecode so we
    need to compile Clojure to bytecode in order to run the `core` namespace.
  id: totrans-358
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当我们使用 Leiningen 创建应用程序时，它将在 `core` 命名空间中自动生成代码。`(:gen-class)` 指示 Leiningen 从命名空间生成一个
    Java 类。构建工具（如 Leiningen）执行 Java 字节码，因此我们需要将 Clojure 编译成字节码才能运行 `core` 命名空间。
- en: Next, we have the `-main` function. By default, when an application is started,
    Leiningen will search for a method with that name and execute it. As such, `-main`
    is an entry point to our application.
  id: totrans-359
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 接下来，我们有 `-main` 函数。默认情况下，当应用程序启动时，Leiningen 将搜索具有该名称的方法并执行它。因此，`-main` 是我们应用程序的入口点。
- en: Like all functions in Clojure, `-main` can be supplied with an optional documentation
    string. Here, it tells us that the function does not do a whole lot... yet. This
    function takes optional arguments. We can pass arguments when we start an application.
    Often, applications are started for various environments by passing an environment
    type, such as test or production, as a command-line argument.
  id: totrans-360
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 与 Clojure 中的所有函数一样，`-main` 可以提供一个可选的文档字符串。在这里，它告诉我们该函数目前还没有做很多事情。此函数接受可选参数。我们可以在启动应用程序时传递参数。通常，通过传递环境类型（如测试或生产）作为命令行参数来启动各种环境的应用程序。
- en: When Leiningen calls the `-main` function, it will execute the body of this
    function. In this case, the function will print the string `Hello World!` to the
    console.
  id: totrans-361
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当 Leiningen 调用 `-main` 函数时，它将执行该函数的主体。在这种情况下，该函数将字符串 `Hello World!` 打印到控制台。
- en: 'To run the application from the command line, we use Leiningen''s `run` task:'
  id: totrans-362
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要从命令行运行应用程序，我们使用 Leiningen 的 `run` 任务：
- en: '[PRE76]'
  id: totrans-363
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'This will print the following to the console:'
  id: totrans-364
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这将在控制台打印以下内容：
- en: '[PRE77]'
  id: totrans-365
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE77]'
- en: This exercise showed us how to run a Leiningen application as defined in `project.clj`
    file.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 这个练习展示了如何运行在 `project.clj` 文件中定义的 Leiningen 应用程序。
- en: In the next exercise we will extend the application to take arguments from the
    command line.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个练习中，我们将扩展应用程序以从命令行获取参数。
- en: 'Exercise 8.10: Executing Application on the Command Line with arguments'
  id: totrans-368
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 8.10：使用参数在命令行上执行应用程序
- en: In this exercise we will write a small command line application that takes a
    string as input, parses that input and replaces the contents of that string.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将编写一个小型的命令行应用程序，该程序接受一个字符串作为输入，解析该输入并替换该字符串的内容。
- en: 'After creating a new project, the content of the `hello-leiningen.core` namespace
    is the following:'
  id: totrans-370
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建新项目后，`hello-leiningen.core` 命名空间的内容如下：
- en: '[PRE78]'
  id: totrans-371
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE78]'
- en: When we create an application using Leiningen, it will autogenerate code in
    the core namespace. (`:gen-class`) instructs Leiningen to generate a Java class
    from the namespace. Build tools such as Leiningen execute Java bytecode so we
    need to compile Clojure to bytecode in order to run the core namespace.
  id: totrans-372
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当我们使用 Leiningen 创建应用程序时，它将在 `core` 命名空间中自动生成代码。（`:gen-class`）指示 Leiningen 从命名空间生成一个
    Java 类。构建工具（如 Leiningen）执行 Java 字节码，因此我们需要将 Clojure 编译成字节码才能运行 `core` 命名空间。
- en: Next, we have the `-main` function. By default, when an application is started,
    Leiningen will search for a method with that name and execute it. As such, -main
    is an entry point to our application.
  id: totrans-373
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们有 `-main` 函数。默认情况下，当应用程序启动时，Leiningen 将搜索具有该名称的方法并执行它。因此，`-main` 是我们应用程序的入口点。
- en: Like all functions in Clojure, `-main` can be supplied with an optional documentation
    string. Here, it tells us that the function does not do a whole lot... yet. This
    function takes optional arguments. We can pass arguments when we start an application.
    Often, applications are started for various environments by passing an environment
    type, such as test or production, as a command-line argument.
  id: totrans-374
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 与 Clojure 中的所有函数一样，`-main` 可以提供一个可选的文档字符串。在这里，它告诉我们该函数目前还没有做很多……。此函数接受可选参数。我们可以在启动应用程序时传递参数。通常，应用程序通过传递环境类型（如测试或生产）作为命令行参数来为各种环境启动。
- en: When Leiningen calls the -main function, it will execute the body of this function.
    In this case, the function will print the string Hello World! to the console.
  id: totrans-375
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当 Leiningen 调用 `-main` 函数时，它将执行此函数的主体。在这种情况下，该函数将打印字符串 "Hello World!" 到控制台。
- en: 'To run the application from the command line, we use Leiningen''s run task:'
  id: totrans-376
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要从命令行运行应用程序，我们使用 Leiningen 的运行任务：
- en: '[PRE79]'
  id: totrans-377
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'This will print the following to the console:'
  id: totrans-378
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这将在控制台打印以下内容：
- en: '[PRE80]'
  id: totrans-379
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE80]'
- en: Import the `clojure.string`. We want to manipulate strings in our `-main` function.
    In order to do that we need to import string namespace.
  id: totrans-380
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入 `clojure.string`。我们想在 `-main` 函数中操作字符串。为了做到这一点，我们需要导入字符串命名空间。
- en: '[PRE81]'
  id: totrans-381
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE81]'
- en: After importing `clojure.string` namespace we can use functions from this namespace.
  id: totrans-382
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在导入 `clojure.string` 命名空间后，我们可以使用该命名空间中的函数。
- en: 'Updating `-main` function to replace certain words when the `-main` function
    is run:'
  id: totrans-383
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新 `-main` 函数以在运行 `-main` 函数时替换某些单词：
- en: '[PRE82]'
  id: totrans-384
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE82]'
- en: This code will replace words "`melon`" and "`apple`" with other fruits.
  id: totrans-385
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此代码将用其他水果替换单词 "melon" 和 "apple"。
- en: 'We run the application as follows:'
  id: totrans-386
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们按照以下方式运行应用程序：
- en: '[PRE83]'
  id: totrans-387
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'This will print the following in the REPL:'
  id: totrans-388
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这将在 REPL 中打印以下内容：
- en: '[PRE84]'
  id: totrans-389
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE84]'
- en: We know now how to run an application from the command line and pass arguments.
    In the following activity, you will use this knowledge to create a new application.
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在知道如何从命令行运行应用程序并传递参数。在以下活动中，你将使用这些知识来创建一个新的应用程序。
- en: 'Activity 8.02: Summing Up Numbers'
  id: totrans-391
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 活动 8.02：求和数字
- en: Often, applications that are created by developers need to run in different
    environments and business contexts. This requires the applications to be flexible.
    One way to achieve this is by using command-line parameters that change how applications
    behave.
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，开发者创建的应用程序需要在不同的环境和业务场景中运行。这要求应用程序具有灵活性。实现这一目标的一种方法是通过使用命令行参数来改变应用程序的行为。
- en: In this activity, you will create an application that takes integers as input
    parameters from the command line and sums them up to print the result to the console.
    Depending on the integers passed, the results will differ. This shows the flexibility
    of the application.
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个活动中，你将创建一个应用程序，该应用程序从命令行接收整数作为输入参数，并将它们相加以将结果打印到控制台。根据传递的整数，结果将不同。这显示了应用程序的灵活性。
- en: 'These steps will help you complete the activity:'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 这些步骤将帮助你完成活动：
- en: Create a Leiningen application.
  id: totrans-395
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个 Leiningen 应用程序。
- en: Alter the `-main` function to convert string arguments to integers, add integers,
    and print the result.
  id: totrans-396
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改 `-main` 函数以将字符串参数转换为整数，相加并打印结果。
- en: 'The output will look like the following:'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 输出将如下所示：
- en: '![Figure 8.12: Expected output'
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 8.12：预期输出'
- en: '](img/B14502_08_12.jpg)'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B14502_08_12.jpg)'
- en: 'Figure 8.12: Expected output'
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.12：预期输出
- en: Note
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The solution for this activity can be found on page 708.
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 本活动的解决方案可以在第 708 页找到。
- en: Working with External Libraries
  id: totrans-403
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与外部库一起工作
- en: Libraries are packaged programs that are ready to be used in other projects.
    External libraries are libraries that come from other developers. In Clojure,
    examples of such libraries include Ring, an HTTP library; `clojure.java-time`,
    a library for time and date manipulation; and `hiccup`, a library for writing
    HTML code using Clojure-style syntax.
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 库是打包好的程序，可以用于其他项目。外部库是从其他开发者那里来的库。在 Clojure 中，此类库的例子包括 Ring，一个 HTTP 库；`clojure.java-time`，一个用于时间和日期操作的库；以及
    `hiccup`，一个用于使用 Clojure 风格语法编写 HTML 代码的库。
- en: Most projects will require developers to use existing code packaged as libraries.
    This is a good thing. We do not want to write code over and over again if the
    problem at hand has been already solved and someone has created a library for
    it that we can use.
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数项目都需要开发者使用现有代码打包成的库。这是好事。我们不希望重复编写代码，如果问题已经解决，并且有人为它创建了一个我们可以使用的库。
- en: In this section, we will use the `clojure.Java-time` library to display the
    current time.
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将使用 `clojure.java-time` 库来显示当前时间。
- en: 'Exercise 8.11: Using an External Library in a Leiningen Project'
  id: totrans-407
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 8.11：在 Leiningen 项目中使用外部库
- en: 'The aim of this exercise is to show you how to add a library to a Leiningen
    project and demonstrate how this library is used in code:'
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 本练习的目的是向你展示如何向 Leiningen 项目添加库，并演示如何在代码中使用这个库：
- en: 'The first thing to do is add a dependency to the `time` library in the `project.clj`
    file. The `dependencies` section should look like this:'
  id: totrans-409
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先要做的事情是在 `project.clj` 文件中添加对 `time` 库的依赖。`dependencies` 部分应该看起来像这样：
- en: '[PRE85]'
  id: totrans-410
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'The next step is to import the library to our `core` namespace. Alter `hello-leiningen.core`
    to look like this:'
  id: totrans-411
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一步是将库导入到我们的 `core` 命名空间。将 `hello-leiningen.core` 修改如下：
- en: '[PRE86]'
  id: totrans-412
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'Finally, we will change the `-main` function to print the local time using
    a function from the `clojure.java-time` library:'
  id: totrans-413
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们将把 `-main` 函数改为使用 `clojure.java-time` 库中的函数来打印本地时间：
- en: '[PRE87]'
  id: totrans-414
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'We run the application from the command line using the `run` task:'
  id: totrans-415
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们使用 `run` 任务从命令行运行应用程序：
- en: '[PRE88]'
  id: totrans-416
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'This will show us output similar to the following:'
  id: totrans-417
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这将给出类似于以下输出的结果：
- en: '[PRE89]'
  id: totrans-418
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE89]'
- en: We now know how to add and use external libraries. We are ready to package our
    application to a jar and run it.
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经知道如何添加和使用外部库。我们现在可以打包我们的应用程序到一个 jar 文件中并运行它。
- en: Creating and Executing a jar with Leiningen
  id: totrans-420
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 Leiningen 创建和执行 jar 文件
- en: When we discussed project structure in Clojure, we mentioned that projects are
    packaged as jar files. To remind you, a jar file is a zipped (packed) file that
    is an executable application. Leiningen has tasks for creating jars.
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们讨论 Clojure 的项目结构时，我们提到项目被打包成 jar 文件。为了提醒你，jar 文件是一个压缩（打包）的文件，是一个可执行的应用程序。Leiningen
    有创建 jar 文件的任务。
- en: 'Leiningen provides two tasks that can create a jar:'
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: Leiningen 提供了两个可以创建 jar 文件的任务：
- en: jar
  id: totrans-423
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: jar
- en: uberjar
  id: totrans-424
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: uberjar
- en: Both will create a zipped file with our code. The difference is that a jar task
    will package only our code while an uberjar task will also package dependencies.
    If you run one application on your server and want one standalone file, then an
    uberjar is your go-to option. If you have a number of applications on your server
    and they share libraries, then packaging each application as a jar will take less
    space overall than packaging them as uberjars. This is because libraries are shared
    on servers between your applications.
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个都会创建一个包含我们代码的压缩文件。区别在于，jar 任务只会打包我们的代码，而 uberjar 任务还会打包依赖项。如果你想在服务器上运行一个应用程序并且想要一个独立的文件，那么
    uberjar 是你的首选选项。如果你在服务器上有多个应用程序并且它们共享库，那么将每个应用程序打包成 jar 文件在总体上比打包成 uberjars 占用更少的空间。这是因为库在服务器上被你的应用程序共享。
- en: If we want to run a jar, we need to generate a named class from our core namespace.
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想运行一个 jar，我们需要从我们的核心命名空间生成一个命名的类。
- en: 'Exercise 8.12: Creating a Jar File'
  id: totrans-427
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 8.12：创建 Jar 文件
- en: 'In this exercise, we will show how to create a jar file using Leiningen tasks:'
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将展示如何使用 Leiningen 任务创建 jar 文件：
- en: 'Alter the `hello-leiningen.core` namespace declaration to include a `(:gen-class)`
    function call:'
  id: totrans-429
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `hello-leiningen.core` 命名空间声明修改为包含一个 `(:gen-class)` 函数调用：
- en: '[PRE90]'
  id: totrans-430
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE90]'
- en: The `:gen-class` directive is an important concept in Clojure. This directive
    will generate a Java class corresponding to the target namespace. The result of
    generating a Java class is a `.class` file. A Java `.class` file contains Java
    bytecode that can be executed on the JVM. Such a file can be executed by build
    tools such as Leiningen.
  id: totrans-431
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`:gen-class` 指令是 Clojure 中的一个重要概念。这个指令将生成一个与目标命名空间对应的 Java 类。生成 Java 类的结果是一个
    `.class` 文件。Java `.class` 文件包含可以在 JVM 上执行的 Java 字节码。这样的文件可以通过 Leiningen 等构建工具执行。'
- en: Running Leiningen tasks for both a jar and uberjar is the same. In our case,
    we will create an uberjar.
  id: totrans-432
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 运行 jar 和 uberjar 的 Leiningen 任务是相同的。在我们的情况下，我们将创建一个 uberjar。
- en: 'Call Leiningen''s `uberjar` task in the command line:'
  id: totrans-433
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在命令行中调用 Leiningen 的 `uberjar` 任务：
- en: '[PRE91]'
  id: totrans-434
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE91]'
- en: This task will create `hello-leiningen-0.1.0-SNAPSHOT.jar` and `hello-leiningen-0.1.0-SNAPSHOT-standalone.jar`
    jar files inside the target directory.
  id: totrans-435
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这个任务将在目标目录内创建 `hello-leiningen-0.1.0-SNAPSHOT.jar` 和 `hello-leiningen-0.1.0-SNAPSHOT-standalone.jar`
    jar 文件。
- en: 'When we compare the files, we will see that their sizes differ greatly:'
  id: totrans-436
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当我们比较文件时，我们会看到它们的尺寸差异很大：
- en: '![Figure 8.13: Comparing the files'
  id: totrans-437
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图 8.13：比较文件](img/B14502_08_14.jpg)'
- en: '](img/B14502_08_13.jpg)'
  id: totrans-438
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B14502_08_13.jpg)'
- en: '[PRE92]'
  id: totrans-439
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'Running this command will give us the output similar to the following:'
  id: totrans-440
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 运行这个命令将给出类似于以下输出的结果：
- en: '![Figure 8.14: Inspecting the standalone version of the file'
  id: totrans-441
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图 8.14：检查文件的独立版本](img/B14502_08_13.jpg)'
- en: '](img/B14502_08_14.jpg)'
  id: totrans-442
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B14502_08_14.jpg)'
- en: 'Figure 8.14: Inspecting the standalone version of the file'
  id: totrans-443
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 8.14：检查文件的独立版本
- en: 'We would notice a `clojure` directory. When inspecting the first file, however,
    there would be no Clojure directory:'
  id: totrans-444
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们会注意到一个`clojure`目录。然而，当我们检查第一个文件时，却找不到Clojure目录：
- en: '![Figure 8.15: Checking for the Clojure directory'
  id: totrans-445
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图 8.15：检查Clojure目录]'
- en: '](img/B14502_08_15.jpg)'
  id: totrans-446
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图片 B14502_08_15.jpg]'
- en: 'Figure 8.15: Checking for the Clojure directory'
  id: totrans-447
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 8.15：检查Clojure目录
- en: The first jar (`hello-leiningen-0.1.0-SNAPSHOT.jar`) contains only application
    code, while the second file (`hello-leiningen-0.1.0-SNAPSHOT-standalone.jar`)
    also contains core Clojure code. The standalone file is intended to be used when
    we have one Clojure application. In such cases, we want to have all the dependencies
    in one place. When we run more than one Clojure application on a server, having
    each application containing core Clojure functions takes more space than needed.
    In such cases, having core Clojure code once and allowing all applications to
    access it saves disk space.
  id: totrans-448
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 第一个jar文件（`hello-leiningen-0.1.0-SNAPSHOT.jar`）仅包含应用程序代码，而第二个文件（`hello-leiningen-0.1.0-SNAPSHOT-standalone.jar`）还包含核心Clojure代码。独立文件旨在在我们只有一个Clojure应用程序时使用。在这种情况下，我们希望所有依赖项都在一个地方。当我们在一个服务器上运行多个Clojure应用程序时，每个应用程序都包含核心Clojure函数会占用比所需更多的空间。在这种情况下，将核心Clojure代码只保留一次，并允许所有应用程序访问它，可以节省磁盘空间。
- en: 'In order to run a jar, we will call the following:'
  id: totrans-449
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了运行一个jar文件，我们将调用以下命令：
- en: '[PRE93]'
  id: totrans-450
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE93]'
- en: 'This will display the current local time for us, as follows:'
  id: totrans-451
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这将显示当前的本地时间，如下所示：
- en: '![Figure 8.16: Print the local time'
  id: totrans-452
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图 8.16：打印本地时间]'
- en: '](img/B14502_08_16.jpg)'
  id: totrans-453
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图片 B14502_08_16.jpg]'
- en: 'Figure 8.16: Print the local time'
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.16：打印本地时间
- en: In the next section, we will look at Leiningen profiles—a powerful feature that
    allows us to customize our projects.
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将探讨Leiningen配置文件——这是一个强大的功能，允许我们自定义我们的项目。
- en: Leiningen Profiles
  id: totrans-456
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Leiningen配置文件
- en: Profiles are a Leiningen tool that allows us to change the configuration of
    our projects. A profile is a specification that influences how a project behaves.
    For example, during development or testing, say that we would like to include
    testing frameworks in our builds but the production build does not need testing
    dependencies. Using profiles is a great way to separate different development
    setups that should be run against one code base.
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: 配置文件是Leiningen的一个工具，允许我们更改项目的配置。配置文件是一个影响项目行为的规范。例如，在开发或测试期间，如果我们希望在构建中包含测试框架，但生产构建不需要测试依赖项，使用配置文件是分离不同开发设置并针对同一代码库运行的一个很好的方法。
- en: 'Leiningen allows us to define profiles in a few places depending on our needs:'
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: Leiningen允许我们在需要的地方定义配置文件：
- en: In the `project.clj` file
  id: totrans-459
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`project.clj`文件中
- en: In the `profiles.clj` file
  id: totrans-460
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`profiles.clj`文件中
- en: In the `~/.lein/profiles.clj` file
  id: totrans-461
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`~/.lein/profiles.clj`文件中
- en: Leiningen profiles defined in `project.clj` are specific to that particular
    project. Such profiles will not affect other projects. This allows separation
    between projects and the ability to customize them independently. We could have
    one application that uses the newest version of Clojure and requires different
    libraries to another application relying on an older Clojure version.
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: 在`project.clj`中定义的Leiningen配置文件仅针对该特定项目。这些配置文件不会影响其他项目。这允许项目之间分离，并能够独立地自定义它们。我们可能有一个使用Clojure最新版本并需要不同库的应用程序，而另一个应用程序则依赖于较旧的Clojure版本。
- en: Leiningen profiles defined in `profiles.clj` are also specific to a project.
    Such profiles will not affect other projects. The difference between putting a
    profile in `project.clj` and `profiles.clj` is that profiles in `project.clj`
    will be committed in version control. Profiles defined in `profiles.clj` are independent
    of the project configuration in `project.clj` and do not need to be committed
    to version control. Profiles from both files are merged together by Leiningen.
    Profiles with the same name in `profiles.clj` take precedence over profiles in
    `project.clj`.
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: 在`profiles.clj`中定义的Leiningen配置文件也仅针对特定项目。这些配置文件不会影响其他项目。将配置文件放在`project.clj`和`profiles.clj`中的区别在于，`project.clj`中的配置文件会被提交到版本控制中。在`profiles.clj`中定义的配置文件独立于`project.clj`中的项目配置，并且不需要提交到版本控制。来自两个文件的相同名称的配置文件，`profiles.clj`中的配置文件将优先于`project.clj`中的配置文件。
- en: Now that we know what Leiningen profiles are and the places that they can be
    defined, we will look at the syntax of creating profiles. First, we will define
    a profile in a `project.clj` file.
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了Leiningen配置文件是什么以及它们可以定义的位置，我们将探讨创建配置文件的语法。首先，我们将在`project.clj`文件中定义一个配置文件。
- en: 'Exercise 8.13: Adding Leiningen Profiles to a Project'
  id: totrans-465
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 8.13：将Leiningen配置文件添加到项目中
- en: The aim of this exercise is to add a new development profile inside a `project.clj`
    file. This will allow us to customize a project for the development phase of the
    software development life cycle.
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: 本练习的目的是在 `project.clj` 文件中添加一个新的开发配置文件。这将允许我们为软件开发生命周期的开发阶段定制项目。
- en: 'If we wanted to add a dependency on a testing framework, such as `expectations`,
    we would alter the `project.clj` file to look like this:'
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要添加对测试框架（如 `expectations`）的依赖项，我们将修改 `project.clj` 文件，使其看起来像这样：
- en: '[PRE94]'
  id: totrans-468
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: 'Inside the `:profiles` hash, we have a `:dev` hash with a dependency on the
    `expectations` framework. With this change, the `dev` profile is available for
    us. We can check this by listing available profiles:'
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `:profiles` 哈希中，我们有一个 `:dev` 哈希，它依赖于 `expectations` 框架。通过此更改，`dev` 配置文件对我们可用。我们可以通过列出可用的配置文件来检查这一点：
- en: 'Calling Leiningen''s `show-profiles` task will display the available profiles:'
  id: totrans-470
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用 Leiningen 的 `show-profiles` 任务将显示可用的配置文件：
- en: '[PRE95]'
  id: totrans-471
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 'The output is as follows:'
  id: totrans-472
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '![Figure 8.17: Printing the available profiles'
  id: totrans-473
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图 8.17：打印可用的配置文件'
- en: '](img/B14502_08_17.jpg)'
  id: totrans-474
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B14502_08_17.jpg)'
- en: 'Figure 8.17: Printing the available profiles'
  id: totrans-475
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 8.17：打印可用的配置文件
- en: 'The profiles available in this example are:'
  id: totrans-476
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 本例中可用的配置文件有：
- en: '`base`: A profile that provides basic REPL functionality.'
  id: totrans-477
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`base`: 提供基本 REPL 功能的配置文件。'
- en: '`debug`: When Leiningen tasks are run with this profile, they print more information
    to the console, such as the names of the dependencies used.'
  id: totrans-478
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`debug`: 当使用此配置文件运行 Leiningen 任务时，它们会在控制台打印更多信息，例如使用的依赖项名称。'
- en: '`default`: The default profile run when no profiles are selected. Unless overridden,
    the profile defaults to the `leiningen/default` profile.'
  id: totrans-479
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`default`: 当未选择任何配置文件时运行的默认配置文件。除非被覆盖，否则配置文件默认为 `leiningen/default` 配置文件。'
- en: '`dev`: The development profile as set up in the `project.clj` file by a developer.'
  id: totrans-480
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`dev`: 在 `project.clj` 文件中由开发者设置的开发配置文件。'
- en: '`leiningen/default`: The default profile that runs when no profile is selected.'
  id: totrans-481
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`leiningen/default`: 当未选择任何配置文件时运行的默认配置文件。'
- en: '`leiningen/test`: A test profile that runs test files.'
  id: totrans-482
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`leiningen/test`: 运行测试文件的测试配置文件。'
- en: '`offline`: Profiles where stored dependencies are used offline without downloading
    new ones.'
  id: totrans-483
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`offline`: 使用离线存储的依赖项，而不下载新的依赖项的配置文件。'
- en: '`uberjar`: Profiles that create uberjar files.'
  id: totrans-484
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`uberjar`: 创建 uberjar 文件的配置文件。'
- en: '`update`: Profiles that update dependencies.'
  id: totrans-485
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`update`: 更新依赖项的配置文件。'
- en: '`user`: A profile defined for a Linux user.'
  id: totrans-486
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`user`: 为 Linux 用户定义的配置文件。'
- en: '`whidbey/repl`: A profile where results in the REPL are printed in a formatted
    way.'
  id: totrans-487
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`whidbey/repl`: 一个配置文件，其中在 REPL 中的结果以格式化的方式打印。'
- en: As you can see, the `dev` profile is listed among other profiles.
  id: totrans-488
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如您所见，`dev` 配置文件列在其他配置文件中。
- en: 'If we wanted to run this profile, we would call the `with-profiles` task:'
  id: totrans-489
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们想要运行此配置文件，我们将调用 `with-profiles` 任务：
- en: '[PRE96]'
  id: totrans-490
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE96]'
- en: Calling this task would run the tests with the `dev` profile. In *Chapter 10*,
    *Testing*, we will explore testing in Clojure and this task will be used often.
  id: totrans-491
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 调用此任务将使用 `dev` 配置文件运行测试。在 *第 10 章*，*测试* 中，我们将探讨 Clojure 的测试，此任务将被经常使用。
- en: In this exercise, we have added a new Leiningen profile to the `project.clj`
    file. This allows us to have a configuration for a particular project. This configuration
    is independent of configurations in other projects.
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们在 `project.clj` 文件中添加了一个新的 Leiningen 配置文件。这允许我们为特定项目设置配置。此配置独立于其他项目的配置。
- en: In the next exercise, we will add user-wide profile configuration.
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个练习中，我们将添加用户范围的配置文件。
- en: User-Wide Profiles
  id: totrans-494
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 用户范围配置文件
- en: Leiningen allows us to define user-wide profiles that will affect all Leiningen
    projects. This is a great place to put common code that we want for all our projects.
    The most common examples would be including libraries for testing or pretty printing
    output. Once we include a testing library in a user-wide profile, that library
    can be used to write tests for all our projects. This also benefits us when it
    comes to upgrading the library. We only need to upgrade its version in one place.
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
  zh: Leiningen 允许我们定义影响所有 Leiningen 项目的用户范围配置文件。这是一个放置我们希望所有项目都有的通用代码的好地方。最常见的情况包括包含用于测试或美化打印输出的库。一旦我们在用户范围配置文件中包含了一个测试库，该库就可以用于为所有项目编写测试。这也使我们升级库时受益。我们只需要在一个地方升级其版本。
- en: User-wide profiles allow us to add dependencies that we would like to be included
    in all our projects. One such dependency would be Ultra, which gives developers
    working in REPL features such as colorization and pretty printing.
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
  zh: 用户级别的配置文件允许我们添加希望在所有项目中包含的依赖项。其中一个这样的依赖项是 Ultra，它为在 REPL 中工作的开发者提供了诸如着色和格式化打印等功能。
- en: 'Exercise 8.14: Using User-Wide Profiles'
  id: totrans-497
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 8.14：使用用户级配置文件
- en: The aim of this exercise is to add a new library to the `profiles.clj` file.
    This will allow us to access the added library on all Leiningen projects, reducing
    the need to manually add a dependency every time we create a new project. Additionally,
    if a new version of the library is available, we need to update only one `profiles.clj`
    file and the update will be available in all our Leiningen projects.
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
  zh: 本练习的目的是向 `profiles.clj` 文件中添加一个新的库。这将使我们能够在所有 Leiningen 项目中访问添加的库，减少每次创建新项目时手动添加依赖项的需求。此外，如果库的新版本可用，我们只需要更新一个
    `profiles.clj` 文件，更新将在所有我们的 Leiningen 项目中可用。
- en: If we often work with input that we need to display in a way that's accessible
    to users, we can use the `humanize` library. This library pluralizes nouns, shows
    dates in a friendly manner, and converts numbers to strings.
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们经常需要以用户可访问的方式显示输入，我们可以使用 `humanize` 库。这个库可以将名词复数化，以友好的方式显示日期，并将数字转换为字符串。
- en: 'In order to use the humanize library for all of our projects, we add it to
    the `:user` keyword in `~/.lein/profiles.clj`:'
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在所有项目中使用 humanize 库，我们在 `~/.lein/profiles.clj` 文件中将它添加到 `:user` 关键字中：
- en: '[PRE97]'
  id: totrans-501
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: 'Quite often, you will have more libraries and plugins defined in `profiles.clj`.
    It could look like this with the `humanize` library and two plugins, `ultra` and
    `localrepo`:'
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
  zh: 很常见，你会在 `profiles.clj` 文件中定义更多的库和插件。它可能看起来像这样，包括 humanize 库和两个插件 `ultra` 和 `localrepo`：
- en: '[PRE98]'
  id: totrans-503
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: 'Start the REPL using Leiningen:'
  id: totrans-504
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 Leiningen 启动 REPL：
- en: '[PRE99]'
  id: totrans-505
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE99]'
- en: 'Import the humanize library:'
  id: totrans-506
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入 humanize 库：
- en: '[PRE100]'
  id: totrans-507
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE100]'
- en: 'Although we did not have the `humanize` library in the `project.clj` file,
    we could import this library:'
  id: totrans-508
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 虽然我们在 `project.clj` 文件中没有 humanize 库，但我们仍然可以导入这个库：
- en: '![Figure 8.18: Importing the humanize library'
  id: totrans-509
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图 8.18：导入 humanize 库'
- en: '](img/B14502_08_18.jpg)'
  id: totrans-510
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B14502_08_18.jpg)'
- en: 'Figure 8.18: Importing the humanize library'
  id: totrans-511
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 8.18：导入 humanize 库
- en: 'Convert numbers to strings as follows:'
  id: totrans-512
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将数字转换为字符串的方法如下：
- en: '[PRE101]'
  id: totrans-513
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE101]'
- en: 'humanize will convert passed numbers to strings as follows:'
  id: totrans-514
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: humanize 将传入的数字转换为字符串，如下所示：
- en: '[PRE102]'
  id: totrans-515
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE102]'
- en: 'Convert the number of milliseconds to time values:'
  id: totrans-516
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将毫秒数转换为时间值：
- en: '[PRE103]'
  id: totrans-517
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE103]'
- en: '500 milliseconds is not even a second and hence the output will be as follows:'
  id: totrans-518
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 500 毫秒甚至不是一秒，因此输出将如下所示：
- en: '[PRE104]'
  id: totrans-519
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE104]'
- en: This concludes our tour of namespaces in Clojure and Leiningen project structure.
    In the following activity, we will use our new knowledge of libraries and profiles
    in Leiningen.
  id: totrans-520
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这就结束了我们对 Clojure 和 Leiningen 项目结构中命名空间的探索。在接下来的活动中，我们将使用我们在 Leiningen 中关于库和配置文件的新知识。
- en: Useful Clojure Libraries
  id: totrans-521
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 有用的 Clojure 库
- en: The Clojure ecosystem has a number of great libraries. As we have learned in
    this chapter, using libraries helps us to create Clojure applications. Libraries
    provide features that we can use in our code. We do not need to write code ourselves
    as we can instead reuse code written by others. This saves us time and means we
    can focus on developing features specific to our application. There are a number
    of Clojure libraries. Clojure provides a central place to search for available
    libraries on [https://clojars.org](https://clojars.org). We will learn about two
    useful Clojure libraries, `cheshire` and `lein-ancient`. The `cheshire` library
    allows us to work with the JSON format. `cheshire` library, we can change Clojure
    data to JSON format and back. This is a very powerful feature. Imagine that we
    have a holiday-booking application. In the application, we want to display current
    weather information. There are national services providing such information. The
    weather services allow the downloading of data in a common JSON format. When we
    download weather data, we need to turn JSON into Clojure data. The `cheshire`
    library helps us with data conversion. `lein-ancient` is a useful Leiningen plugin.
    This plugin allows us to check our Leiningen projects for outdated dependencies.
    Often, a new version of a library that we use is released. New releases introduce
    errors or security fixes. Using updated libraries helps our applications to stay
    secure. In the following activity, we will create a Leiningen project using useful
    Clojure libraries.
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
- en: 'Activity 8.03: Building a Format-Converting Application'
  id: totrans-523
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The aim of this activity is to create a Leiningen project that will convert
    between JSON format and Clojure data. JSON is a popular transfer format often
    used to send data between various backend applications. Using a common format
    increases the operability between different applications and reduces the development
    cost of building and maintaining applications.
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
- en: Like most applications used in production, our application will have development
    and default production profiles. Leiningen profiles will be used to create a testing
    profile that will use testing libraries to make sure our application is running
    correctly.
  id: totrans-525
  prefs: []
  type: TYPE_NORMAL
- en: As our application matures, newer versions of the libraries used will be released.
    We will use a plugin that will let us know whether any libraries that we use are
    outdated.
  id: totrans-526
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you complete this activity, the application will have the following features:'
  id: totrans-527
  prefs: []
  type: TYPE_NORMAL
- en: Converting between JSON and Clojure data
  id: totrans-528
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A testing profile for checking code before releasing to production
  id: totrans-529
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Checking for outdated libraries
  id: totrans-530
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'These steps will help you complete the activity:'
  id: totrans-531
  prefs: []
  type: TYPE_NORMAL
- en: Include the `cheshire` "3.0.0" library as a dependency.
  id: totrans-532
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a function to convert from hash to JSON.
  id: totrans-533
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a function to convert from JSON to hash.
  id: totrans-534
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add the `expectations` library to the testing profile defined for the project.
  id: totrans-535
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add the `lein-expectations` plugin to the project.
  id: totrans-536
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Write a test for the JSON functions.
  id: totrans-537
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add `lein-ancient` to the user-wide profiles.
  id: totrans-538
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`lein-ancient`添加到用户全局配置文件中。
- en: The latest versions of libraries can be found on the [https://clojars.org](https://clojars.org)
    website.
  id: totrans-539
  prefs: []
  type: TYPE_NORMAL
  zh: 库的最新版本可以在[https://clojars.org](https://clojars.org)网站上找到。
- en: After creating the application and running it, you should have output similar
    to the following.
  id: totrans-540
  prefs: []
  type: TYPE_NORMAL
  zh: 创建应用程序并运行后，你应该会有以下类似的输出。
- en: 'Converting from hash to JSON format should return the following:'
  id: totrans-541
  prefs: []
  type: TYPE_NORMAL
  zh: 从哈希转换为JSON格式应返回以下内容：
- en: '![Figure 8.19: Converting from hash to JSON'
  id: totrans-542
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.19：从哈希转换为JSON'
- en: '](img/B14502_08_19.jpg)'
  id: totrans-543
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/B14502_08_19.jpg](img/B14502_08_19.jpg)'
- en: 'Figure 8.19: Converting from hash to JSON'
  id: totrans-544
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.19：从哈希转换为JSON
- en: 'Generating JSON from hash should return the following:'
  id: totrans-545
  prefs: []
  type: TYPE_NORMAL
  zh: 从哈希生成JSON应返回以下内容：
- en: '![Figure 8.20: Generating JSON from hash'
  id: totrans-546
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.20：从哈希生成JSON'
- en: '](img/B14502_08_20.jpg)'
  id: totrans-547
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/B14502_08_20.jpg](img/B14502_08_20.jpg)'
- en: 'Figure 8.20: Generating JSON from hash'
  id: totrans-548
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.20：从哈希生成JSON
- en: 'Running the testing profile should return the following:'
  id: totrans-549
  prefs: []
  type: TYPE_NORMAL
  zh: 运行测试配置文件应返回以下内容：
- en: '![Figure 8.21: Executing the test profile'
  id: totrans-550
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.21：执行测试配置文件'
- en: '](img/B14502_08_21.jpg)'
  id: totrans-551
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/B14502_08_21.jpg](img/B14502_08_21.jpg)'
- en: 'Figure 8.21: Executing the test profile'
  id: totrans-552
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.21：执行测试配置文件
- en: 'Checking for outdated dependencies should return the following:'
  id: totrans-553
  prefs: []
  type: TYPE_NORMAL
  zh: 检查过时依赖项应返回以下内容：
- en: '![Figure 8.22: Checking for outdated dependencies'
  id: totrans-554
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.22：检查过时的依赖项'
- en: '](img/B14502_08_22.jpg)'
  id: totrans-555
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/B14502_08_22.jpg](img/B14502_08_22.jpg)'
- en: 'Figure 8.22: Checking for outdated dependencies'
  id: totrans-556
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.22：检查过时的依赖项
- en: Note
  id: totrans-557
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The solution for this activity can be found on page 709.
  id: totrans-558
  prefs: []
  type: TYPE_NORMAL
  zh: 本活动的解决方案可以在第709页找到。
- en: Summary
  id: totrans-559
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we learned about namespaces in Clojure. Namespaces are key
    Clojure concepts. We organize code into namespaces. We investigated various ways
    in which we can import namespaces in Clojure by using `refer`, `require`, and
    `use`. With each option to import, we learned the syntax of importing functions
    and when to use each type of function. We went into depth and investigated the
    `:only`, `:exlude`, and `:rename` keywords, which help us to fine-tune importing.
  id: totrans-560
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了Clojure中的命名空间。命名空间是Clojure的关键概念。我们将代码组织到命名空间中。我们研究了使用`refer`、`require`和`use`导入命名空间的多种方法。对于每种导入选项，我们学习了导入函数的语法以及何时使用每种类型的函数。我们深入研究了`:only`、`:exclude`和`:rename`关键字，这些关键字帮助我们精细调整导入。
- en: Then, we learned about Leiningen—a popular Clojure build tool. We created a
    Leiningen application and explored how Clojure projects are structured. We added
    dependencies on libraries. Finally, we saw how we can customize Leiningen projects
    using profiles. We created an application that accepted command-line arguments
    that were used by the application to customize the output.
  id: totrans-561
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们学习了Leiningen——一个流行的Clojure构建工具。我们创建了一个Leiningen应用程序，并探讨了Clojure项目的结构。我们添加了库依赖项。最后，我们看到了如何使用配置文件来自定义Leiningen项目。我们创建了一个应用程序，该应用程序接受命令行参数，这些参数被应用程序用来自定义输出。
- en: In the next chapter, we will investigate host platform interop—accessing Java
    and JavaScript from Clojure.
  id: totrans-562
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将研究主机平台互操作性——从Clojure访问Java和JavaScript。
