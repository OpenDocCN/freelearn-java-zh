["```java\nmodifiers... \ndef function_name(arg1: arg1_type, arg2: arg2_type,...): return_type = ???\n```", "```java\ndef compareIntegers(value1: Int, value2: Int): Int = if (value1 == value2) 0 else if (value1 > value2) 1 else -1\n```", "```java\ndef compareIntegersV1(value1: Int, value2: Int): Int = \n  if (value1 == value2) 0 else if (value1 > value2) 1 else -1 \n```", "```java\ndef compareIntegersV2(value1: Int, value2: Int): Int = { \n  println(s\" Executing V2\") \n  if (value1 == value2) 0 else if (value1 > value2) 1 else -1 \n} \n```", "```java\nobject FunctionSyntax extends App{ \n /* \n  * Function compare two Integer numbers \n  * @param value1 Int \n  * @param value2 Int \n  * return Int \n  * 1  if value1 > value2 \n  * 0  if value1 = value2 \n  * -1 if value1 < value2 \n  */ \n  def compareIntegers(value1: Int, value2: Int): Int = if (value1 == value2) 0 else if (value1 > value2) 1 else -1 \n\n  def compareIntegersV1(value1: Int, value2: Int): Int = {\n    if (value1 == value2) 0 else if (value1 > value2) 1 else -1 \n   }\n\n  def compareIntegersV2(value1: Int, value2: Int): Int =\n    if (value1 == value2) 0 else if (value1 > value2) 1 else -1 \n\n  println(compareIntegers(1, 2)) \n  println(compareIntegersV1(2, 1)) \n  println(compareIntegersV2(2, 2)) \n\n} \n```", "```java\n-1\n1 \n0 \n```", "```java\nobject FunctionSyntaxOne extends App { \n\n  def compareIntegersV4(value1: Int, value2: Int): String = { \n println(\"Executing V4\") \n    val result = if (value1 == value2) 0 else if (value1 > value2) 1 else -1 \n    giveAMeaningFullResult(result, value1, value2) \n  } \n\n  private def giveAMeaningFullResult(result: Int, value1: Int, value2: Int) = result match { \n    case 0 => \"Values are equal\" \n    case -1 => s\"$value1 is smaller than $value2\" \n    case 1 => s\"$value1 is greater than $value2\" \n    case _ => \"Could not perform the operation\" \n  } \n\n  println(compareIntegersV4(2,1)) \n} \n```", "```java\nExecuting V4 \n2 is greater than 1 \n```", "```java\nobject FunctionSyntaxTwo extends App { \n\n  def compareIntegersV5(value1: Int, value2: Int): String = { \n println(\"Executing V5\") \n\n    def giveAMeaningFullResult(result: Int) = result match { \n      case 0 => \"Values are equal\" \n      case -1 => s\"$value1 is smaller than $value2\" \n      case 1 => s\"$value1 is greater than $value2\" \n      case _ => \"Could not perform the operation\" \n    } \n\n    val result = if (value1 == value2) 0 else if (value1 > value2) 1 else -1 \n    giveAMeaningFullResult(result) \n  } \n\n  println(compareIntegersV5(2,1)) \n} \n```", "```java\nExecuting V5 \n2 is greater than 1 \n```", "```java\n /* \n  * Prints pages with given Indexes for doc \n  */ \n  def printPages(doc: Document, indexes: Int*) = for(index <- indexes if index <= doc.numOfPages) print(index) \n```", "```java\ndef average(numbers: Int*): Double = ??? \n```", "```java\nobject FunctionCalls extends App { \n\n  def average(numbers: Int*) : Double = numbers.foldLeft(0)((a, c) => a + c) / numbers.length \n\n  def averageV1(numbers: Int*) : Double = numbers.sum / numbers.length \n\n  println(average(2,2)) \n  println(average(1,2,3)) \n  println(averageV1(1,2,3)) \n\n} \n```", "```java\n2.0 \n2.0 \n2.0 \n```", "```java\ndef averageV1(numbers: Int*, wrongArgument: Int): Double = numbers.sum / numbers.length \n```", "```java\ndef compareIntegersV6(value1: Int, value2: Int = 10): String = { \n println(\"Executing V6\") \n\n  def giveAMeaningFullResult(result: Int) = result match { \n    case 0 => \"Values are equal\" \n    case -1 => s\"$value1 is smaller than $value2\" \n    case 1 => s\"$value1 is greater than $value2\" \n    case _ => \"Could not perform the operation\" \n  } \n\n  val result = if (value1 == value2) 0 else if (value1 > value2) 1 else -1 \n  giveAMeaningFullResult(result) \n} \n\nprintln(compareIntegersV6(12)) \n```", "```java\nExecuting V6 \n12 is greater than 10 \n```", "```java\ncompareIntegersV6(12) \n```", "```java\ndef compareIntegersV6(value1: Int = 10, value2: Int) = ??? \n```", "```java\nprintln(compareIntegersV6(12)) // Compiler won't allow \n```", "```java\ndef compareIntegersV6(value1: Int = 10, value2: Int): String = { \n println(\"Executing V6\") \n\n  def giveAMeaningFullResult(result: Int) = result match { \n    case 0 => \"Values are equal\" \n    case -1 => s\"$value1 is smaller than $value2\" \n    case 1 => s\"$value1 is greater than $value2\" \n    case _ => \"Could not perform the operation\" \n  } \n\n  val result = if (value1 == value2) 0 else if (value1 > value2) 1 else -1 \n  giveAMeaningFullResult(result) \n} \n\nprintln(compareIntegersV6(value2 = 12)) \n```", "```java\nExecuting V6 \n10 is smaller than 12 \n```", "```java\nprintln(compareIntegersV6(value2 = 12, value1 = 10)) \n```", "```java\nExecuting V6 \n10 is smaller than 12 \n```", "```java\ndef compareIntegersV6(value1: Int = 10, value2: Int): Int = ??? \n```", "```java\n(value1: Int, value2: Int) => Int     \n```", "```java\nval compareFuncLiteral = (value1: Int, value2: Int) => if (value1 == value2) 0 else if (value1 > value2) 1 else -1 \n```", "```java\nprivate def print(index: Int) = println(s\"Printing Page $index.\") \n```", "```java\n(index: Int) => Unit \n```", "```java\nobject ColorPrinter extends App { \n\n  def printPages(doc: Document, lastIndex: Int, print: (Int) => Unit) = if(lastIndex <= doc.numOfPages) for(i <- 1 to lastIndex) print(i) \n\n  val colorPrint = (index: Int) => println(s\"Printing Color Page $index.\") \n\n  val simplePrint = (index: Int) => println(s\"Printing Simple Page $index.\") \n\n  println(\"---------Method V1-----------\") \n  printPages(Document(15, \"DOCX\"), 5, colorPrint) \n\n   println(\"---------Method V2-----------\") \n   printPages(Document(15, \"DOCX\"), 2, simplePrint) \n} \n\ncase class Document(numOfPages: Int, typeOfDoc: String) \n```", "```java\n---------Method V1----------- \nPrinting Color Page 1\\. \nPrinting Color Page 2\\. \nPrinting Color Page 3\\. \nPrinting Color Page 4\\. \nPrinting Color Page 5\\. \n---------Method V2----------- \nPrinting Simple Page 1\\. \nPrinting Simple Page 2\\. \n```", "```java\nscala> val names = List(\"Alice\",\"Allen\",\"Bob\",\"Catherine\",\"Alex\") \nnames: List[String] = List(Alice, Allen, Bob, Catherine, Alex) \n\nscala> val nameStartsWithA = names.filter((name) => name.startsWith(\"A\")) \nnameStartsWithA: List[String] = List(Alice, Allen, Alex) \n```", "```java\n (name) => name.startsWith(\"A\") \n```", "```java\nscala> val nameStartsWithA = names.filter(_.startsWith(\"A\")) \nnameStartsWithA: List[String] = List(Alice, Allen, Alex) \nplaceholder syntax instead. What if we pass a function literal as an argument and want it to be evaluated only when it's needed, for example, a predicate that gets evaluated only if a certain functionality is active? In that case, we can pass the parameter as a named parameter. Scala does provide this functionality in the form of *call by name* parameters. These parameters get evaluated lazily whenever needed or first called. Let's take a look at some evaluation strategies provided by Scala.\n```", "```java\ndef printPages(doc: Document, lastIndex: Int, print: (Int) => Unit, isPrinterOn: () => Boolean) = { \n\n  if(lastIndex <= doc.numOfPages && isPrinterOn()) for(i <- 1 to lastIndex) print(i) \n\n} \n```", "```java\nprintPages(Document(15, \"DOCX\"), 16, colorPrint, () => !printerSwitch) \n```", "```java\nobject ColorPrinter extends App { \n\n  val printerSwitch = false \n\n  def printPages(doc: Document, lastIndex: Int, print: (Int) => Unit, isPrinterOn: => Boolean) = { \n\n    if(lastIndex <= doc.numOfPages && isPrinterOn) for(i <- 1 to lastIndex) print(i) \n\n  } \n\n  val colorPrint = (index: Int) => { \n    println(s\"Printing Color Page $index.\") \n  } \n\n  println(\"---------Method V1-----------\") \n  printPages(Document(15, \"DOCX\"), 2, colorPrint, !printerSwitch) \n\n} \n\ncase class Document(numOfPages: Int, typeOfDoc: String) \n```", "```java\n---------Method V1----------- \nPrinting Color Page 1\\. \nPrinting Color Page 2\\. \n```", "```java\nprintPages(Document(15, \"DOCX\"), 2, colorPrint, !printerSwitch) \n```", "```java\ndef compareIntegers(value1: Int, value2: Int): Int = \n       if (value1 == value2) 0 else if (value1 > value2) 1 else -1 \n\ncompareIntegers(10, 8) \n```", "```java\nscala> val oneToFirst: PartialFunction[Int, String] = { \n     | case 1 => \"First\" \n     | } \noneToFirst: PartialFunction[Int, String] = <function1> \n\nscala> println(oneToFirst(1)) \nFirst \n```", "```java\ntrait PartialFunction[-A, +B] extends (A) => B \n```", "```java\nscala> println(oneToFirst(2)) \nscala.MatchError: 2 (of class java.lang.Integer) \n  at scala.PartialFunction$$anon$1.apply(PartialFunction.scala:254) \n  at scala.PartialFunction$$anon$1.apply(PartialFunction.scala:252) \n  at $anonfun$1.applyOrElse(<console>:12) \n  at $anonfun$1.applyOrElse(<console>:11) \n  at scala.runtime.AbstractPartialFunction.apply(AbstractPartialFunction.scala:34) \n```", "```java\nscala> oneToFirst.isDefinedAt(1) \nres3: Boolean = true \n\nscala> oneToFirst.isDefinedAt(2) \nres4: Boolean = false \n```", "```java\nobject PartialFunctions extends App { \n\n  val isPrimeEligible: PartialFunction[Item, Boolean] = { \n    case item => item.isPrimeEligible \n  } \n\n  val amountMoreThan500: PartialFunction[Item, Boolean] = { \n    case item => item.price > 500.0 \n  } \n\n  val freeDeliverable = isPrimeEligible orElse amountMoreThan500 \n\n  def deliveryCharge(item: Item): Double = if(freeDeliverable(item)) 0 else 50 \n\n  println(deliveryCharge(Item(\"1\", \"ABC Keyboard\", 490.0, false))) \n\n} \n\ncase class Item(id: String, name: String, price: Double, isPrimeEligible: Boolean)\n```", "```java\n50.0 \n```"]