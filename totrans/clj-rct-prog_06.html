<html><head></head><body>
<div id="page" style="height:0pt"/><div class="book" title="Chapter&#xA0;6.&#xA0;Building a Simple ClojureScript Game with Reagi"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch06" class="calibre1"/>Chapter 6. Building a Simple ClojureScript Game with Reagi</h1></div></div></div><p class="calibre7">In the previous chapter, we learned how a framework for <span class="strong"><strong class="calibre2">Compositional Event Systems</strong></span> (<span class="strong"><strong class="calibre2">CES</strong></span>) works by building our own framework, which we called <span class="strong"><em class="calibre8">respondent</em></span>. It gave us a great insight into the main abstractions involved in such a piece of software as well as a good overview of <code class="email">core.async</code>, Clojure's library for asynchronous programming and the foundation of our framework.</p><p class="calibre7">Respondent is but a toy framework, however. We paid little attention to cross-cutting concerns such as memory efficiency and exception handling. That is okay as we used it as a vehicle for learning more about handling and composing event systems with <code class="email">core.async</code>. Additionally, its design is intentionally similar to Reagi's design.</p><p class="calibre7">In this chapter, we will:</p><div class="book"><ul class="itemizedlist"><li class="listitem">Learn about Reagi, a CES framework built on top of <code class="email">core.async</code></li><li class="listitem">Use Reagi to build the rudiments of a ClojureScript game that will teach us how to handle user input in a clean and maintainable way</li><li class="listitem">Briefly compare Reagi to other CES frameworks and get a feel for when to use each one</li></ul></div></div>

<div class="book" title="Chapter&#xA0;6.&#xA0;Building a Simple ClojureScript Game with Reagi">
<div class="book" title="Setting up the project"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_1"><a id="ch06lvl1sec38" class="calibre1"/>Setting up the project</h1></div></div></div><p class="calibre7">Have you ever played Asteroids? If you haven't, Asteroids is an arcade space shooter first <a id="id257" class="calibre1"/>released by Atari in 1979. In Asteroids, you are the pilot of a<a id="id258" class="calibre1"/> ship flying through space. As you do so, you get surrounded by asteroids and flying saucers you have to shoot and destroy.</p><p class="calibre7">Developing the whole game in one chapter is too ambitious and would distract us from the subject of this book. We will limit ourselves to making sure we have a ship on the screen we can fly around as well as shoot space bullets into the void. By the end of this chapter, we will have something that looks like what is shown in the following screenshot:</p><div class="mediaobject"><img src="../images/00017.jpeg" alt="Setting up the project" class="calibre10"/></div><p class="calibre11"> </p><p class="calibre7">To get started, we will create a <code class="email">newClojureScript</code> project using the same leiningen template <a id="id259" class="calibre1"/>we used in the previous chapter, <code class="email">cljs-start</code> (see <a class="calibre1" href="https://github.com/magomimmo/cljs-start">https://github.com/magomimmo/cljs-start</a>):</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre2">lein new cljs-start reagi-game</strong></span>
</pre></div><p class="calibre7">Next, add<a id="id260" class="calibre1"/> the following dependencies to your project file:</p><div class="informalexample"><pre class="programlisting">   [org.clojure/clojurescript "0.0-2138"]
   [reagi "0.10.0"]
   [rm-hull/monet "0.1.12"]</pre></div><p class="calibre7">The last <a id="id261" class="calibre1"/>dependency, monet (see <a class="calibre1" href="https://github.com/rm-hull/monet">https://github.com/rm-hull/monet</a>), is a ClojureScript library you can use to work with HTML 5 Canvas. It is a high-level wrapper on top of the Canvas API and makes interacting with it a lot simpler.</p><p class="calibre7">Before we continue, it's probably a good idea to make sure our setup is working properly. Change into the project directory, start a Clojure REPL, and then start the embedded web server:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre2">cd reagi-game/</strong></span>
<span class="strong"><strong class="calibre2">lein repl</strong></span>
<span class="strong"><strong class="calibre2">Compiling ClojureScript.</strong></span>
<span class="strong"><strong class="calibre2">Compiling "dev-resources/public/js/reagi_game.js" from ("src/cljs" "test/cljs" "dev-resources/tools/repl")...</strong></span>
<span class="strong"><strong class="calibre2">user=&gt; (run)</strong></span>
<span class="strong"><strong class="calibre2">2014-06-14 19:21:40.381:INFO:oejs.Server:jetty-7.6.8.v20121106</strong></span>
<span class="strong"><strong class="calibre2">2014-06-14 19:21:40.403:INFO:oejs.AbstractConnector:Started SelectChannelConnector@0.0.0.0:3000</strong></span>
<span class="strong"><strong class="calibre2">#&lt;Server org.eclipse.jetty.server.Server@51f6292b&gt;</strong></span>
</pre></div><p class="calibre7">This will <a id="id262" class="calibre1"/>compile the ClojureScript source files to JavaScript and start the sample web server. In your browser, navigate to <code class="email">http://localhost:3000/</code>. If you see something like the following, we are good to go:</p><div class="mediaobject"><img src="../images/00018.jpeg" alt="Setting up the project" class="calibre10"/></div><p class="calibre11"> </p><p class="calibre7">As we will be working with HTML 5 Canvas, we need an actual canvas to render to. Let's update our HTML document to include that. It's located under <code class="email">dev-resources/public/index.html</code>:</p><div class="informalexample"><pre class="programlisting">&lt;!doctype html&gt;
&lt;html lang="en"&gt;
  &lt;head&gt;
    &lt;meta charset="utf-8"&gt;
    &lt;title&gt;bREPL Connection&lt;/title&gt;
    &lt;!--[if lt IE 9]&gt;
        &lt;script src="http://html5shiv.googlecode.com/svn/trunk/html5.js"&gt;&lt;/script&gt;
        &lt;![endif]--&gt;
  &lt;/head&gt;

  &lt;body&gt;
<span class="strong"><strong class="calibre2">    &lt;canvas id="canvas" width="800" height="600"&gt;&lt;/canvas&gt;</strong></span>
    &lt;script src="js/reagi_game.js"&gt;&lt;/script&gt;
  &lt;/body&gt;
&lt;/html&gt;</pre></div><p class="calibre7">We have <a id="id263" class="calibre1"/>added a <code class="email">canvas</code> DOM element to our document. All rendering will happen in this context.</p></div></div>

<div class="book" title="Chapter&#xA0;6.&#xA0;Building a Simple ClojureScript Game with Reagi">
<div class="book" title="Setting up the project">
<div class="book" title="Game entities"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_2"><a id="ch06lvl2sec44" class="calibre1"/>Game entities</h2></div></div></div><p class="calibre7">Our game <a id="id264" class="calibre1"/>will have only two entities: one representing the spaceship and the other  representing bullets. To better organize the code, we will put all entity-related code in its own file, <code class="email">src/cljs/reagi_game/entities.cljs</code>. This file will also contain some of the rendering logic, so we'll need to require <code class="email">monet</code>:</p><div class="informalexample"><pre class="programlisting">(ns reagi-game.entities
  (:require [monet.canvas :as canvas]
            [monet.geometry :as geom]))</pre></div><p class="calibre7">Next, we'll add a few helper functions to avoid repeating ourselves too much:</p><div class="informalexample"><pre class="programlisting">(defn shape-x [shape]
  (-&gt; shape :pos deref :x))

(defn shape-y [shape]
  (-&gt; shape :pos deref :y))

(defn shape-angle [shape]
  @(:angle shape))


(defn shape-data [x y angle]
  {:pos   (atom {:x x :y y})
   :angle (atom angle)})</pre></div><p class="calibre7">The first three functions are simply a shorter way of getting data out of our shape data structure. The <code class="email">shape-data</code> function creates a structure. Note that we are using <code class="email">atoms</code>, one of Clojure's reference types, to represent a shape's position and angle.</p><p class="calibre7">This way, we can safely pass our shape data into monet's rendering functions and still be able to update it in a consistent way.</p><p class="calibre7">Next up is our ship constructor function. This is where the bulk of the interaction with monet happens:</p><div class="informalexample"><pre class="programlisting">(defn ship-entity [ship]
  (canvas/entity {:x (shape-x ship) 
                  :y (shape-y ship) 
                  :angle (shape-angle ship)}
                 (fn [value]
                   (-&gt; value
                       (assoc :x     (shape-x ship))
                       (assoc :y     (shape-y ship))
                       (assoc :angle (shape-angle ship))))
                 (fn [ctx val]
                   (-&gt; ctx
                       canvas/save
                       (canvas/translate (:x val) (:y val))
                       (canvas/rotate (:angle val))
                       (canvas/begin-path)
                       (canvas/move-to 50 0)
                       (canvas/line-to 0 -15)
                       (canvas/line-to 0 15)
                       (canvas/fill)
                       canvas/restore))))</pre></div><p class="calibre7">There is <a id="id265" class="calibre1"/>quite a bit going on, so let's break it down.</p><p class="calibre7">
<code class="email">canvas/entity</code> is a monet constructor and expects you to provide three arguments that describe our ship: its initial x, y coordinates and angle, an update function that gets called in the draw loop, and a draw function that is responsible for actually drawing the shape onto the screen after each update.</p><p class="calibre7">The update function is fairly straightforward:</p><div class="informalexample"><pre class="programlisting">(fn [value]
  (-&gt; value
      (assoc :x     (shape-x ship))
      (assoc :y     (shape-y ship))
      (assoc :angle (shape-angle ship))))</pre></div><p class="calibre7">We simply update its attributes to the current values from the ship's atoms.</p><p class="calibre7">The next function, responsible for drawing, interacts with monet's API more heavily:</p><div class="informalexample"><pre class="programlisting">(fn [ctx val]
   (-&gt; ctx
       canvas/save
       (canvas/translate (:x val) (:y val))
       (canvas/rotate (:angle val))
       (canvas/begin-path)
       (canvas/move-to 50 0)
       (canvas/line-to 0 -15)
       (canvas/line-to 0 15)
       (canvas/fill)
       canvas/restore))</pre></div><p class="calibre7">We start by saving the current context so that we can restore things such as drawing style and canvas positioning later. Next, we translate the canvas to the ship's x,y coordinates and rotate it according to its angle. We then start drawing our shape, a triangle, and finish by restoring<a id="id266" class="calibre1"/> our saved context.</p><p class="calibre7">The next function also creates an entity, our bullet:</p><div class="informalexample"><pre class="programlisting">(declare move-forward!)

(defn make-bullet-entity [monet-canvas key shape]
  (canvas/entity {:x (shape-x shape) 
                  :y (shape-y shape) 
                  :angle (shape-angle shape)}
                 (fn [value]
                   (when (not 
                           (geom/contained? 
                             {:x 0 :y 0
                              :w (.-width (:canvas monet-canvas))
                              :h (.-height (:canvas monet-canvas))}
                             {:x (shape-x shape) 
                              :y (shape-y shape) 
                              :r 5}))
                     (canvas/remove-entity monet-canvas key))
                   (move-forward! shape)
                   (-&gt; value
                       (assoc :x     (shape-x shape))
                       (assoc :y     (shape-y shape))
                       (assoc :angle (shape-angle shape))))
                 (fn [ctx val]
                   (-&gt; ctx
                       canvas/save
                       (canvas/translate (:x val) (:y val))
                       (canvas/rotate (:angle val))
                       (canvas/fill-style "red")
                       (canvas/circle {:x 10 :y 0 :r 5})
                       canvas/restore))))</pre></div><p class="calibre7">As before, let's inspect the <code class="email">update</code> and <code class="email">drawing</code> functions. We'll start with <code class="email">update</code>:</p><div class="informalexample"><pre class="programlisting">(fn [value]
  (when (not 
         (geom/contained? 
          {:x 0 :y 0
           :w (.-width (:canvas monet-canvas))
           :h (.-height (:canvas monet-canvas))}
          {:x (shape-x shape) 
           :y (shape-y shape) 
           :r 5}))
    (canvas/remove-entity monet-canvas key))
  (move-forward! shape)
  (-&gt; value
      (assoc :x     (shape-x shape))
      (assoc :y     (shape-y shape))
      (assoc :angle (shape-angle shape))))</pre></div><p class="calibre7">Bullets have a little more logic in their update function. As you fire them from the ship, we<a id="id267" class="calibre1"/> might create hundreds of these entities, so it's a good practice to get rid of them as soon as they go off the visible canvas area. That's the first thing the function does: it uses <code class="email">geom/contained?</code> to check whether the entity is within the dimensions of the canvas, removing it when it isn't.</p><p class="calibre7">Different from the ship, however, bullets don't need user input in order to move. Once fired, they move on their own. That's why the next thing we do is call <code class="email">move-forward!</code> We haven't implemented this function yet, so we had to declare it beforehand. We'll get to it.</p><p class="calibre7">Once the bullet's coordinates and angle have been updated, we simply return the new entity.</p><p class="calibre7">The draw function is a bit simpler than the ship's version mostly due to its shape being simpler; it's just a red circle:</p><div class="informalexample"><pre class="programlisting">(fn [ctx val]
                   (-&gt; ctx
                       canvas/save
                       (canvas/translate (:x val) (:y val))
                       (canvas/rotate (:angle val))
                       (canvas/fill-style "red")
                       (canvas/circle {:x 10 :y 0 :r 5})
                       canvas/restore))</pre></div><p class="calibre7">Now, we'll move on to the functions responsible for updating our shape's coordinates and angle, starting with <code class="email">move!</code>:</p><div class="informalexample"><pre class="programlisting">(def speed 200)

(defn calculate-x [angle]
  (* speed (/ (* (Math/cos angle)
                 Math/PI)
              180)))

(defn calculate-y [angle]
  (* speed (/ (* (Math/sin angle)
                 Math/PI)
              180)))

(defn move! [shape f]
  (let [pos (:pos shape)]
    (swap! pos (fn [xy]
                 (-&gt; xy
                     (update-in [:x]
                                #(f % (calculate-x
                                       (shape-angle shape))))
                     (update-in [:y]
                                #(f % (calculate-y
                                       (shape-angle shape)))))))))</pre></div><p class="calibre7">To <a id="id268" class="calibre1"/>keep things simple, both the ship and bullets use the same speed value to calculate their positioning, here defined as <code class="email">200</code>.</p><p class="calibre7">
<code class="email">move!</code> takes two arguments: the shape map and a function <code class="email">f</code>. This function will either be the <code class="email">+</code> (plus) or the <code class="email">-</code> (minus) function, depending on whether we're moving forward or backward, respectively. Next, it updates the shape's x,y coordinates using some basic trigonometry.</p><p class="calibre7">If you're wondering why we are passing the plus and minus functions as arguments, it's all about not repeating ourselves, as the next two functions show:</p><div class="informalexample"><pre class="programlisting">(defn move-forward! [shape]
  (move! shape +))

(defn move-backward! [shape]
  (move! shape -))</pre></div><p class="calibre7">With movement taken care of, the next step is to write the rotation functions:</p><div class="informalexample"><pre class="programlisting">(defn rotate! [shape f]
  (swap! (:angle shape) #(f % (/ (/ Math/PI 3) 20))))

(defn rotate-right! [shape]
  (rotate! shape +))

(defn rotate-left! [shape]
  (rotate! shape -))</pre></div><p class="calibre7">So far, we've got ship movement covered! But what good is our ship if we can't fire bullets? Let's make sure we have that covered as well:</p><div class="informalexample"><pre class="programlisting">(defn fire! [monet-canvas ship]
  (let [entity-key (keyword (gensym "bullet"))
        data (shape-data (shape-x ship)
                         (shape-y ship)
                         (shape-angle ship))
        bullet (make-bullet-entity monet-canvas
                                   entity-key
                                   data)]
    (canvas/add-entity monet-canvas entity-key bullet)))</pre></div><p class="calibre7">The <code class="email">fire!</code> function takes two arguments: a reference to the game canvas and the ship. It then <a id="id269" class="calibre1"/>creates a new bullet by calling <code class="email">make-bullet-entity</code> and adds it to the canvas.</p><p class="calibre7">Note how we use Clojure's <code class="email">gensym</code> function to create a unique key for the new entity. We use this key to remove an entity from the game.</p><p class="calibre7">This concludes the code for the <code class="email">entities</code> namespace.</p><div class="informalexample" title="Note"><h3 class="title2"><a id="tip23" class="calibre1"/>Tip</h3><p class="calibre7">
<code class="email">gensym</code> is quite heavily used in writing hygienic macros as you can be sure that the generated symbols will not clash with any local bindings belonging to the code using the macro. Macros are beyond the scope of this book, but you <a id="id270" class="calibre1"/>might find this series of macro exercises useful in the learning process, at <a class="calibre1" href="https://github.com/leonardoborges/clojure-macros-workshop">https://github.com/leonardoborges/clojure-macros-workshop</a>.</p></div></div></div></div>

<div class="book" title="Chapter&#xA0;6.&#xA0;Building a Simple ClojureScript Game with Reagi">
<div class="book" title="Setting up the project">
<div class="book" title="Putting it all together"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_3"><a id="ch06lvl2sec45" class="calibre1"/>Putting it all together</h2></div></div></div><p class="calibre7">We're <a id="id271" class="calibre1"/>now ready to assemble our game. Go ahead and open the core namespace file, <code class="email">src/cljs/reagi_game/core.cljs</code>, and add the following:</p><div class="informalexample"><pre class="programlisting">(ns reagi-game.core
  (:require [monet.canvas :as canvas]
            [reagi.core :as r]
            [clojure.set :as set]
            [reagi-game.entities :as entities
             :refer [move-forward! move-backward! rotate-left! rotate-right! fire!]]))</pre></div><p class="calibre7">The following snippet sets up various data structures and references we'll need in order to develop the game:</p><div class="informalexample"><pre class="programlisting">(def canvas-dom (.getElementById js/document "canvas"))

(def monet-canvas (canvas/init canvas-dom "2d"))

(def ship 
       (entities/shape-data (/ (.-width (:canvas monet-canvas)) 2)
                            (/ (.-height (:canvas monet-canvas)) 2)
                            0))

(def ship-entity (entities/ship-entity ship))

(canvas/add-entity monet-canvas :ship-entity ship-entity)
(canvas/draw-loop monet-canvas)</pre></div><p class="calibre7">We<a id="id272" class="calibre1"/> start by creating <code class="email">monet-canvas</code> from a reference to our <code class="email">canvas</code> DOM element. We then create our ship data, placing it at the center of the canvas, and add the entity to <code class="email">monet-canvas</code>. Finally, we start a draw-loop, which will handle our animations using the browser's native capabilities—internally it calls <code class="email">window.requestAnimationFrame()</code>, if available, but it falls back to <code class="email">window.setTimemout()</code> otherwise.</p><p class="calibre7">If you were to try the application now, this would be enough to draw the ship on the middle of the screen, but nothing else would happen as we haven't started handling user input yet.</p><p class="calibre7">As far as user input goes, we're concerned with a few actions:</p><div class="book"><ul class="itemizedlist"><li class="listitem">Ship movement: rotation, forward, and backward</li><li class="listitem">Firing the ship's gun</li><li class="listitem">Pausing the game</li></ul></div><p class="calibre7">To account for these actions, we'll define some constants that represent the ASCII codes of the keys involved:</p><div class="informalexample"><pre class="programlisting">(def UP    38)
(def RIGHT 39)
(def DOWN  40)
(def LEFT  37)
(def FIRE  32) ;; space
(def PAUSE 80) ;; lower-case P</pre></div><p class="calibre7">This should look sensible as we are using the keys traditionally used for these types of actions.</p></div></div></div>

<div class="book" title="Chapter&#xA0;6.&#xA0;Building a Simple ClojureScript Game with Reagi">
<div class="book" title="Setting up the project">
<div class="book" title="Modeling user input as event streams"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_4"><a id="ch06lvl2sec46" class="calibre1"/>Modeling user input as event streams</h2></div></div></div><p class="calibre7">One of the things discussed in the earlier chapters is that if you can think of events as a list of <a id="id273" class="calibre1"/>things that haven't happened yet; you can probably model it as an event stream. In our case, this list is composed by the keys the player presses during the game and can be visualized like so:</p><div class="mediaobject"><img src="../images/00019.jpeg" alt="Modeling user input as event streams" class="calibre10"/></div><p class="calibre11"> </p><p class="calibre7">There is a catch though. Most games need to handle simultaneously pressed keys.</p><p class="calibre7">Say you're flying the spaceship forwards. You don't want to have to stop it in order to rotate it to the left and then continue moving forwards. What you want is to press left at the same time you're pressing up and have the ship respond accordingly.</p><p class="calibre7">This hints at the fact that we need to be able to tell whether the player is currently pressing multiple keys. Traditionally this is done in JavaScript by keeping track of which keys are being held down in a map-like object, using flags. Something similar to the following snippet:</p><div class="informalexample"><pre class="programlisting">var keysPressed = {};

document.addEventListener('keydown', function(e) {
   keysPressed[e.keyCode] = true;
}, false);
document.addEventListener('keyup', function(e) {
   keysPressed[e.keyCode] = false;
}, false);</pre></div><p class="calibre7">Then, later in the game loop, you would check whether there are multiple keys being pressed:</p><div class="informalexample"><pre class="programlisting">function gameLoop() {
   if (keyPressed[UP] &amp;&amp; keyPressed[LEFT]) {
      // update ship position
   }
   // ...
}</pre></div><p class="calibre7">While this code works, it relies on mutating the <code class="email">keysPressed</code> object which isn't ideal.</p><p class="calibre7">Additionally, with a setup similar to the preceding one, the <code class="email">keysPressed</code> object is global to the application as it is needed both in the <code class="email">keyup</code>/<code class="email">keydown</code> event handlers as well as in the game loop itself.</p><p class="calibre7">In<a id="id274" class="calibre1"/> functional programming, we strive to eliminate or reduce the amount of global mutable state in order to write readable, maintainable code that is less error-prone. We will apply these principles here.</p><p class="calibre7">As seen in the preceding JavaScript example, we can register callbacks to be notified whenever a <code class="email">keyup</code> or <code class="email">keydown</code> event happens. This is useful as we can easily turn them into event streams:</p><div class="informalexample"><pre class="programlisting">(defn keydown-stream []
  (let [out (r/events)]
    (set! (.-onkeydown js/document) 
          #(r/deliver out [::down (.-keyCode %)]))
    out))

(defn keyup-stream []
  (let [out (r/events)]
    (set! (.-onkeyup   js/document) 
          #(r/deliver out [::up (.-keyCode %)]))
    out))</pre></div><p class="calibre7">Both <code class="email">keydown-stream</code> and <code class="email">keyup-stream</code> return a new stream to which they deliver events whenever they happen. Each event is tagged with a keyword, so we can easily identify its type.</p><p class="calibre7">We would like to handle both types of events simultaneously and as such we need a way to combine these two streams into a single one.</p><p class="calibre7">There are many ways in which we can combine streams, for example, using operators such as <code class="email">zip</code> and <code class="email">flatmap</code>. For this instance, however, we are interested in the <code class="email">merge</code> operator. <code class="email">merge</code> creates a new stream that emits values from both streams as they arrive:</p><div class="mediaobject"><img src="../images/00020.jpeg" alt="Modeling user input as event streams" class="calibre10"/></div><p class="calibre11"> </p><p class="calibre7">This<a id="id275" class="calibre1"/> gives us enough to start creating our stream of active keys. Based on what we have discussed so far, our stream looks something like the following at the moment:</p><div class="informalexample"><pre class="programlisting">(def active-keys-stream
  (-&gt;&gt; (r/merge (keydown-stream) (keyup-stream))
       ...
       ))</pre></div><p class="calibre7">To keep track of which keys are currently pressed, we will use a ClojureScript set. This way we don't have to worry about setting flags to true or false—we can simply perform standard set operations and add/remove keys from the data structure.</p><p class="calibre7">The next thing we need is a way to accumulate the pressed keys into this set as new events are emitted from the merged stream.</p><p class="calibre7">In functional programming, whenever we wish to accumulate or aggregate some type of data over a sequence of values, we use <code class="email">reduce</code>.</p><p class="calibre7">Most—if not all—CES frameworks have this function built-in. RxJava calls it <code class="email">scan</code>. Reagi, on the other hand, calls it <code class="email">reduce</code>, making it intuitive to functional programmers in general.</p><p class="calibre7">That is the function we will use to finish the implementation of <code class="email">active-keys-stream</code>:</p><div class="informalexample"><pre class="programlisting">(def active-keys-stream
  (-&gt;&gt; (r/merge (keydown-stream) (keyup-stream))
      (r/reduce (fn [acc [event-type key-code]]
          (condp = event-type
              ::down (conj acc key-code)
              ::up (disj acc key-code)
              acc))
          #{})
      (r/sample 25)))</pre></div><p class="calibre7">
<code class="email">r/reduce</code> takes three arguments: a reducing function, an optional initial/seed value, and the stream to reduce over.</p><p class="calibre7">Our <a id="id276" class="calibre1"/>seed value is an empty set as initially the user hasn't yet pressed any keys. Then, our reducing function checks the event type, removing or adding the key from/to the set as appropriate.</p><p class="calibre7">As a result, what we have is a stream like the one represented as follows:</p><div class="mediaobject"><img src="../images/00021.jpeg" alt="Modeling user input as event streams" class="calibre10"/></div><p class="calibre11"> </p></div></div></div>

<div class="book" title="Chapter&#xA0;6.&#xA0;Building a Simple ClojureScript Game with Reagi">
<div class="book" title="Setting up the project">
<div class="book" title="Working with the active keys stream"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_5"><a id="ch06lvl2sec47" class="calibre1"/>Working with the active keys stream</h2></div></div></div><p class="calibre7">The <a id="id277" class="calibre1"/>ground work we've done so far will make sure we can easily handle game events in a clean and maintainable way. The main idea behind having a stream representing the game keys is that now we can partition it much like we would a normal list.</p><p class="calibre7">For instance, if we're interested in all events where the key pressed is <code class="email">UP</code>, we would run the <a id="id278" class="calibre1"/>following code:</p><div class="informalexample"><pre class="programlisting">(-&gt;&gt; active-keys-stream
     (r/filter (partial some #{UP}))
     (r/map (fn [_] (.log js/console "Pressed up..."))))</pre></div><p class="calibre7">Similarly, for events involving the <code class="email">FIRE</code> key, we could do the following:</p><div class="informalexample"><pre class="programlisting">(-&gt;&gt; active-keys-stream
     (r/filter (partial some #{FIRE}))
     (r/map (fn [_] (.log js/console "Pressed fire..."))))</pre></div><p class="calibre7">This works because in Clojure, sets can be used as predicates. We can quickly verify this at the REPL:</p><div class="informalexample"><pre class="programlisting">user&gt; (def numbers #{12 13 14})
#'user/numbers
user&gt; (some #{12} numbers)
12
user&gt; (some #{15} numbers)
nil</pre></div><p class="calibre7">By representing the events as a stream, we can easily operate on them using familiar sequence functions such as <code class="email">map</code> and <code class="email">filter</code>.</p><p class="calibre7">Writing code like this, however, is a little repetitive. The two previous examples are pretty much saying something along these lines: filter all events matching a given predicate <code class="email">pred</code> and then map the <code class="email">f</code> function over them. We can abstract this pattern in a function we'll call <code class="email">filter-map</code>:</p><div class="informalexample"><pre class="programlisting">(defn filter-map [pred f &amp; args]
  (-&gt;&gt; active-keys-stream
       (r/filter (partial some pred))
       (r/map (fn [_] (apply f args)))))</pre></div><p class="calibre7">With this helper function in place, it becomes easy to handle our game actions:</p><div class="informalexample"><pre class="programlisting">(filter-map #{FIRE}  fire! monet-canvas ship)
(filter-map #{UP}    move-forward!  ship)
(filter-map #{DOWN}  move-backward! ship)
(filter-map #{RIGHT} rotate-right!  ship)
(filter-map #{LEFT}  rotate-left!   ship)</pre></div><p class="calibre7">The only thing missing now is taking care of pausing the animations when the player presses the <code class="email">PAUSE</code> key. We follow the same logic as above, but with a slight change:</p><div class="informalexample"><pre class="programlisting">(defn pause! [_]
  (if @(:updating? monet-canvas)
    (canvas/stop-updating monet-canvas)
    (canvas/start-updating monet-canvas)))

(-&gt;&gt; active-keys-stream
     (r/filter (partial some #{PAUSE}))
<span class="strong"><strong class="calibre2">     (r/throttle 100)</strong></span>
     (r/map pause!))</pre></div><p class="calibre7">Monet <a id="id279" class="calibre1"/>makes a flag available that tells us whether it is currently updating the animation state. We use that as a cheap mechanism to "pause" the game.</p><p class="calibre7">Note that <code class="email">active-keys-stream</code> pushes events as they happen so, if a user is holding a button down for any amount of time, we will get multiple events for that key. As such, we would probably get multiple occurrences of the <code class="email">PAUSE</code> key in a very short amount of time. This would cause the game to frantically stop/start. In order to prevent this from happening, we throttle the filtered stream and ignore all <code class="email">PAUSE</code> events that happen in a window shorter than 100 milliseconds.</p><p class="calibre7">To make sure we didn't miss anything, this is what our <code class="email">src/cljs/reagi_game/core.cljs</code> file should look like, in full:</p><div class="informalexample"><pre class="programlisting">(ns reagi-game.core
  (:require [monet.canvas :as canvas]
            [reagi.core :as r]
            [clojure.set :as set]
            [reagi-game.entities :as entities
             :refer [move-forward! move-backward! rotate-left! rotate-right! fire!]]))

(def canvas-dom (.getElementById js/document "canvas"))

(def monet-canvas (canvas/init canvas-dom "2d"))

(def ship (entities/shape-data (/ (.-width (:canvas monet-canvas)) 2)
                               (/ (.-height (:canvas monet-canvas)) 2)
                               0))

(def ship-entity (entities/ship-entity ship))

(canvas/add-entity monet-canvas :ship-entity ship-entity)
(canvas/draw-loop monet-canvas)

(def UP    38)
(def RIGHT 39)
(def DOWN  40)
(def LEFT  37)
(def FIRE  32) ;; space
(def PAUSE 80) ;; lower-case P

(defn keydown-stream []
  (let [out (r/events)]
    (set! (.-onkeydown js/document) #(r/deliver out [::down (.-keyCode %)]))
    out))

(defn keyup-stream []
  (let [out (r/events)]
    (set! (.-onkeyup   js/document) #(r/deliver out [::up (.-keyCode %)]))
    out))

(def active-keys-stream
  (-&gt;&gt; (r/merge (keydown-stream) (keyup-stream))
      (r/reduce (fn [acc [event-type key-code]]
          (condp = event-type
              ::down (conj acc key-code)
              ::up (disj acc key-code)
              acc))
          #{})
      (r/sample 25)))

(defn filter-map [pred f &amp; args]
  (-&gt;&gt; active-keys-stream
       (r/filter (partial some pred))
       (r/map (fn [_] (apply f args)))))

(filter-map #{FIRE}  fire! monet-canvas ship)
(filter-map #{UP}    move-forward!  ship)
(filter-map #{DOWN}  move-backward! ship)
(filter-map #{RIGHT} rotate-right!  ship)
(filter-map #{LEFT}  rotate-left!   ship)

(defn pause! [_]
  (if @(:updating? monet-canvas)
    (canvas/stop-updating monet-canvas)
    (canvas/start-updating monet-canvas)))

(-&gt;&gt; active-keys-stream
     (r/filter (partial some #{PAUSE}))
     (r/throttle 100)
     (r/map pause!))</pre></div><p class="calibre7">This<a id="id280" class="calibre1"/> completes the code and we're now ready to have a look at the results.</p><p class="calibre7">If you still have the server running from earlier in this chapter, simply exit the REPL, start it again, and start the embedded web server:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre2">lein repl</strong></span>
<span class="strong"><strong class="calibre2">Compiling ClojureScript.</strong></span>
<span class="strong"><strong class="calibre2">Compiling "dev-resources/public/js/reagi_game.js" from ("src/cljs" "test/cljs" "dev-resources/tools/repl")...</strong></span>
<span class="strong"><strong class="calibre2">user=&gt; (run)</strong></span>
<span class="strong"><strong class="calibre2">2014-06-14 19:21:40.381:INFO:oejs.Server:jetty-7.6.8.v20121106</strong></span>
<span class="strong"><strong class="calibre2">2014-06-14 19:21:40.403:INFO:oejs.AbstractConnector:Started SelectChannelConnector@0.0.0.0:3000</strong></span>
<span class="strong"><strong class="calibre2">#&lt;Server org.eclipse.jetty.server.Server@51f6292b&gt;</strong></span>
</pre></div><p class="calibre7">This will compile the latest version of our ClojureScript source to JavaScript.</p><p class="calibre7">Alternatively, you can leave the REPL running and simply ask <code class="email">cljsbuild</code> to auto-compile the source code from another terminal window:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre2">lein cljsbuild auto</strong></span>
<span class="strong"><strong class="calibre2">Compiling "dev-resources/public/js/reagi_game.js" from ("src/cljs" "test/cljs" "dev-resources/tools/repl")...</strong></span>
<span class="strong"><strong class="calibre2">Successfully compiled "dev-resources/public/js/reagi_game.js" in 13.23869 seconds.</strong></span>
</pre></div><p class="calibre7">Now you can point your browser to <code class="email">http://localhost:3000/</code> and fly around your spaceship! Don't forget to shoot some bullets as well!</p></div></div></div>
<div class="book" title="Reagi and other CES frameworks"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch06lvl1sec39" class="calibre1"/>Reagi and other CES frameworks</h1></div></div></div><p class="calibre7">Back in <a class="calibre1" title="Chapter 4. Introduction to core.async" href="part0033_split_000.html#page">Chapter 4</a>, <span class="strong"><em class="calibre8">Introduction to core.async</em></span>, we had an overview of the main differences between <code class="email">core.async</code> and CES. Another question that might have arisen in this chapter is this: how do we decide which CES framework to use?</p><p class="calibre7">The <a id="id281" class="calibre1"/>answer is less clear than before and often depends on the specifics of the tool being looked at. We have learned about two such tools so far: Reactive Extensions (encompassing RxJS, RxJava, and RxClojure) and Reagi.</p><p class="calibre7">
<span class="strong"><strong class="calibre2">Reactive Extensions</strong></span> (<span class="strong"><strong class="calibre2">Rx</strong></span>) is<a id="id282" class="calibre1"/> a much more mature framework. Its first version for the .NET platform was released in 2011 and the ideas in it have since evolved substantially.</p><p class="calibre7">Additionally, ports for other platforms such as RxJava are being heavily used in production by big names such as Netflix.</p><p class="calibre7">A drawback<a id="id283" class="calibre1"/> of Rx is that if you would like to use it both in the browser and on the server, you have to use two separate frameworks, RxJS and RxJava, respectively. While they do share the same API, they are different codebases, which can incur bugs that might have been solved in one port but not yet in another.</p><p class="calibre7">For <a id="id284" class="calibre1"/>Clojure developers, it also means relying more on interoperability to interact with the full API of Rx.</p><p class="calibre7">Reagi, on the <a id="id285" class="calibre1"/>other hand, is a new player in this space but builds on the solid foundation laid out by <code class="email">core.async</code>. It is fully developed in Clojure and solves the in-browser/on-server issue by compiling to both Clojure and ClojureScript.</p><p class="calibre7">Reagi also allows seamless integration with <code class="email">core.async</code> via functions such as <code class="email">port</code> and <code class="email">subscribe</code>, which allow channels to be created from event streams.</p><p class="calibre7">Moreover, the use of <code class="email">core.async</code> in ClojureScript applications is becoming ubiquitous, so chances are you already have it as a dependency. This makes Reagi an attractive option for the times when we need a higher level of abstraction than the one provided by <code class="email">core.async</code>.</p></div>
<div class="book" title="Summary"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch06lvl1sec40" class="calibre1"/>Summary</h1></div></div></div><p class="calibre7">In this chapter, we learned how we can use the techniques from reactive programming we have learned so far in order to write code that is cleaner and easier to maintain. To do so, we insisted on thinking about asynchronous events simply as lists and saw how that way of thinking lends itself quite easily to being modeled as an event stream. All our game has to do, then, is operate on these streams using familiar sequence processing functions.</p><p class="calibre7">We also learned the basics of Reagi, a framework for CES similar to the one we created in <a class="calibre1" title="Chapter 4. Introduction to core.async" href="part0033_split_000.html#page">Chapter 4</a>, <span class="strong"><em class="calibre8">Introduction to core.async</em></span>, but that is more feature rich and robust.</p><p class="calibre7">In the next chapter, we will take a break from CES and see how a more traditional reactive approach based on data flows can be useful.</p></div></body></html>