["```java\npublic interface HashTable<K,V> {\n  void put(K key,V value);\n  Optional<V> get(K key);\n  void remove(K key);\n}  \n```", "```java\npublic void put(K key, V value) {\n  int hashValue = hashProvider.hashKey(key, array.length);\n  array[hashValue].addFirst(new Pair<>(key, value));\n}\npublic Optional<V> get(K key) {\n  int hashValue = hashProvider.hashKey(key, array.length);\n  return array[hashValue].stream()\n    .filter(keyValue -> keyValue.getKey().equals(key))\n    .findFirst()\n    .map(Pair::getValue);\n}  \n```", "```java\ninsert(key, value, array)\n  s = length(array)\n  hashValue = hash(key, s)\n  i = 0\n  while (i < s and array[(hashValue + i) mod s] != null)\n    i = i + 1\n  if (i < s) array[(hashValue + i) mod s] = (key, value)  \n```", "```java\n array[(hashValue + a*i + b*i^2) mod s] \n```", "```java\n search(key, array)  \n```", "```java\nsearch(key, array)\ns = length(array)\nhashValue = hash(key, s)\ni = 0\nwhile (i < s and array[(hashValue + i) mod s] != null\n  and array[(hashValue + i) mod s].key != key)\n  i = i + 1\nkeyValue = array[(hashValue + i) mod s]\nif (keyValue != null && keyValue.key == key) \n\n```", "```java\n  return keyValue.value\nelse return null \n\n```", "```java\npublic int hashKey(Integer key, int tableSize) {\n  return key % tableSize;\n}  \n```", "```java\n int hashKey(int key, int tableSize) \n```", "```java\nprivate double k;\npublic MultiplicationHashing(double k) {\n  this.k = k;\n}\npublic int hashKey(Integer key, int tableSize) {\n  return (int) (tableSize * (k * key % 1));\n}  \n```", "```java\nBigInteger class to work out the hash key. This is needed because multiplying a long Java numeric type with a large integer might result in a big enough value that exceeds the maximum capacity of a Java long. The choice of p in this method is such that any integer key input will always have a smaller value, since in Java an integer only has a maximum value of *2**31*:\n```", "```java\npublic UniversalHashing() {\n  j = BigInteger.valueOf((long) (Math.random() * p));\n  i = BigInteger.valueOf(1 + (long) (Math.random() * (p -  1L))); \n}\npublic int hashKey(Integer key, int tableSize) {\n  return i.multiply(BigInteger.valueOf(key)).add(j)\n    .mod(BigInteger.valueOf(p))\n\n```", "```java\n    .mod(BigInteger.valueOf(tableSize))\n    .intValue();\n}  \n```", "```java\npublic class BinaryTreeNode<K,V> {\n  private BinaryTreeNode<K,V> left;\n  private BinaryTreeNode<K,V> right;\n  private K key;\n  private V value;\n  public BinaryTreeNode(K key, V value) {\n    this.key = key;\n    this.value = value;\n  } \n```", "```java\npublic interface BinaryTree<K,V> {\n  void put(K key,V value);\n  Optional<V> get(K key);\n} \n```", "```java\npublic Optional<V> get(K key) {\n  return Optional.ofNullable(root).flatMap(n -> get(key, n));\n}\nprivate Optional<V> get(K key, BinaryTreeNode<K, V> node) {\n  if (((Comparable) key).compareTo(node.getKey()) == 0)\n    return Optional.of(node.getValue());\n  else if (((Comparable) key).compareTo(node.getKey()) < 0)\n    return node.getLeft().flatMap(n -> get(key, n));\n  else\n    return node.getRight().flatMap(n -> get(key, n));\n} \n```", "```java\n((Comparable) key).compareTo(node.getKey()) < 0 \n```", "```java\nkey < node.getKey()\n```", "```java\nif (((Comparable) key).compareTo(node.getKey()) == 0) {\n  node.setKey(key);\n  node.setValue(value);\n} else if (((Comparable) key).compareTo(node.getKey()) <0) {\n  if (node.getLeft().isPresent())\n    put(key, value, node.getLeft().get());\n  else\n    node.setLeft(new BinaryTreeNode<>(key, value));\n} else {\n  if (node.getRight().isPresent())\n    put(key, value, node.getRight().get());\n  else\n    node.setRight(new BinaryTreeNode<>(key, value));\n}\n```", "```java\n public Optional<K> minKey()  \n```", "```java\npublic Optional<K> minKey() {\n  return Optional.ofNullable(root).map(this::minKey);\n}\nprivate K minKey(BinaryTreeNode<K, V> node) {\n  return node.getLeft().map(this::minKey).orElse(node.getKey());\n}  \n```", "```java\npublic void printDfs() {\n  Optional.ofNullable(root).ifPresent(this::printDfs);\n}\nprivate void printDfs(BinaryTreeNode<K, V> node) {\n  //System.out.println(\"PREORDER \" + node.getKey());\n  node.getLeft().ifPresent(this::printDfs);\n  System.out.println(\"INORDER \" + node.getKey());\n  node.getRight().ifPresent(this::printDfs);\n  //System.out.println(\"POSTORDER \" + node.getKey());\n}  \n```", "```java\nbreadthFirstSearch(root)\n  if (root != null)\n    queue = createQueue()\n    enqueue(queue, root)\n    while (not isEmpty(queue))\n      node = dequeue(queue)\n      process(node)\n      if (node.left != null) enqueue(queue, node.left)\n      if (node.right != null) enqueue(queue, node.right)  \n```", "```java\n public void printBfs() \n```", "```java\npublic void leftRotate(BinaryTreeNode<K, V> nodeX,\n BinaryTreeNode<K, V> parent) {\n  BinaryTreeNode<K, V> nodeY = nodeX.getRight().get();\n  nodeX.setRight(nodeY.getLeft().orElse(null));\n  if (parent == null)\n    this.root = nodeY;\n  else if (parent.getLeft().filter(n -> n == nodeX).isPresent())\n    parent.setLeft(nodeY);\n  else\n    parent.setRight(nodeY);\n    nodeY.setLeft(nodeX);\n} \n```", "```java\npublic void rightRotate(BinaryTreeNode<K, V> nodeX,\n BinaryTreeNode<K, V> parent) {\n  BinaryTreeNode<K, V> nodeY = nodeX.getLeft().get();\n  nodeX.setLeft(nodeY.getRight().orElse(null));\n  if (parent == null)\n    this.root = nodeY;\n  else if (parent.getRight().filter(n -> n == nodeX).isPresent())\n    parent.setRight(nodeY);\n  else\n    parent.setLeft(nodeY);\n    nodeY.setRight(nodeX);\n} \n```", "```java\n public Optional<K> inOrderSuccessorKey(K key) \n```"]