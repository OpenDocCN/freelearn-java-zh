<html><head></head><body>
		<div id="_idContainer182">
			<h1 id="_idParaDest-316"><em class="italic"><a id="_idTextAnchor315"/>Chapter 15</em>: Reactive Programming</h1>
			<p>In this chapter, you will be introduced to the <strong class="bold">Reactive Manifesto</strong> and the world of reactive programming. We start with defining and discussing the main concepts of reactive programming – asynchronous, non-blocking, and responsive. Using them, we then define and discuss reactive programming, the main reactive frameworks, and talk about <strong class="bold">RxJava</strong> in more detail.</p>
			<p>In this chapter, we will cover the following topics:</p>
			<ul>
				<li>Asynchronous processing</li>
				<li>Non-blocking APIs</li>
				<li>Reactive – responsive, resilient, elastic, and message-driven systems</li>
				<li>Reactive streams</li>
				<li>RxJava</li>
			</ul>
			<p>By the end of the chapter, you will be able to write code for asynchronous processing using reactive programming.</p>
			<h1 id="_idParaDest-317"><a id="_idTextAnchor316"/>Technical requirements</h1>
			<p>To be able to execute the code examples that are provided in this chapter, you will need the following:</p>
			<ul>
				<li>A computer with an operating system: Microsoft Windows, Apple macOS, or Linux </li>
				<li>Java SE version 17 or later</li>
				<li>Any IDE or code editor you prefer</li>
			</ul>
			<p>The instructions for how to set up a Java SE and IntelliJ IDEA editor were provided in <a href="B18388_01_ePub.xhtml#_idTextAnchor015"><em class="italic">Chapter 1</em></a>, <em class="italic">Getting Started with Java 17</em>, of this book. The files and the code examples for this chapter are available from the GitHub repository at <a href="https://github.com/PacktPublishing/Learn-Java-17-Programming.git">https://github.com/PacktPublishing/Learn-Java-17-Programming.git</a>. You can locate them in the <a href="https://examples/src/main/java/com/packt/learnjava/ch15_reactive">examples/src/main/java/com/packt/learnjava/ch15_reactive</a> folder.</p>
			<h1 id="_idParaDest-318"><a id="_idTextAnchor317"/>Asynchronous processing</h1>
			<p><strong class="bold">Asynchronous</strong> means<a id="_idIndexMarker1749"/> that the requestor gets the response immediately, but the result is not there. Instead, the requestor waits until the result is sent to them, saved in the database, or, for example, presented as an object that allows you to check whether the result is ready. If the latter is the case, the requestor calls a certain method to this object periodically and, when the result is ready, retrieves it using another method on the same object. The<a id="_idIndexMarker1750"/> advantage of asynchronous processing is that the requestor can do other things while waiting.</p>
			<p>In <a href="B18388_08_ePub.xhtml#_idTextAnchor187"><em class="italic">Chapter 8</em></a>, <em class="italic">Multithreading and Concurrent Processing</em>, we demonstrated how a child thread can be created. Such a child thread then sends a non-asynchronous (blocking) request and waits for its return doing nothing. Meanwhile, the main thread continues executing and periodically calls the child thread object to see whether the result is ready. That is the most basic of asynchronous processing implementations. In fact, we already used it when we used parallel streams.</p>
			<p>The parallel stream operations that work behind the scenes to create the child threads break the stream into segments, assign each segment to a dedicated thread for processing, and then aggregate the partial results from all the segments into the final result. In the previous chapter, we even wrote functions that did the aggregating job. As a reminder, the function was<a id="_idIndexMarker1751"/> called <strong class="bold">combiner</strong>.</p>
			<p>Let’s compare the performance of sequential and parallel streams using an example.</p>
			<h2 id="_idParaDest-319"><a id="_idTextAnchor318"/>Sequential and parallel streams</h2>
			<p>To demonstrate<a id="_idIndexMarker1752"/> the difference between sequential and parallel processing, let’s imagine a system that collects <a id="_idIndexMarker1753"/>data from 10 physical devices (such as sensors) and<a id="_idIndexMarker1754"/> calculates an average. The following is the <strong class="source-inline">get()</strong> method, which collects a measurement from a sensor identified by its ID:</p>
			<pre class="source-code">double get(String id){</pre>
			<pre class="source-code">    try{</pre>
			<pre class="source-code">        TimeUnit.MILLISECONDS.sleep(100);</pre>
			<pre class="source-code">    } catch(InterruptedException ex){</pre>
			<pre class="source-code">        ex.printStackTrace();</pre>
			<pre class="source-code">    }</pre>
			<pre class="source-code">    return id * Math.random();</pre>
			<pre class="source-code">}</pre>
			<p>We <a id="_idIndexMarker1755"/>have included a delay of 100 ms to imitate the time it takes to collect the measurement from the sensor. As for the resulting measurement value, we use the <strong class="source-inline">Math.random()</strong> method. We are going to call this <strong class="source-inline">get()</strong> method using an object of the <strong class="source-inline">MeasuringSystem</strong> class, which is where the method belongs. </p>
			<p>Then, we <a id="_idIndexMarker1756"/>are going to calculate an average to <a id="_idIndexMarker1757"/>offset the errors and other idiosyncrasies of individual devices:</p>
			<pre class="source-code">void getAverage(Stream&lt;Integer&gt; ids) {</pre>
			<pre class="source-code">    LocalTime start = LocalTime.now();</pre>
			<pre class="source-code">    double a = ids.mapToDouble(id -&gt; new MeasuringSystem()</pre>
			<pre class="source-code">                  .get(id))</pre>
			<pre class="source-code">                  .average()</pre>
			<pre class="source-code">                  .orElse(0);</pre>
			<pre class="source-code">    System.out.println((Math.round(a * 100.) / 100.) + " in " +</pre>
			<pre class="source-code">       Duration.between(start, LocalTime.now()).toMillis() +  </pre>
			<pre class="source-code">                                                         "ms");</pre>
			<pre class="source-code">}</pre>
			<p>Notice how we convert the stream of IDs into <strong class="source-inline">DoubleStream</strong> using the <strong class="source-inline">mapToDouble()</strong> operation so that we can apply the <strong class="source-inline">average()</strong> operation. The <strong class="source-inline">average()</strong> operation returns an <strong class="source-inline">Optional&lt;Double&gt;</strong> object, and we call its <strong class="source-inline">orElse(0)</strong> method, which returns either the calculated value or zero (for example, if the measuring system could not connect to any of its sensors and returned an empty stream). </p>
			<p>The last line of the <strong class="source-inline">getAverage()</strong> method prints the result and the time it took to calculate it. In real code, we would return the result and use it for other calculations. However, for demonstration purposes, we will just print it.</p>
			<p>Now we can<a id="_idIndexMarker1758"/> compare the <a id="_idIndexMarker1759"/>performance of sequential stream <a id="_idIndexMarker1760"/>processing with the performance of parallel processing (see the <strong class="source-inline">MeasuringSystem</strong> class and the <strong class="source-inline">compareSequentialAndParallelProcessing()</strong> method):</p>
			<pre class="source-code">List&lt;Integer&gt; ids = IntStream.range(1, 11)</pre>
			<pre class="source-code">                             .mapToObj(i -&gt; i)</pre>
			<pre class="source-code">                             .collect(Collectors.toList());</pre>
			<pre class="source-code">getAverage(ids.stream());          //prints: 2.99 in 1030 ms</pre>
			<pre class="source-code">getAverage(ids.parallelStream());  //prints: 2.34 in  214 ms</pre>
			<p>The results might be different if you run this example because, as you might recall, we simulate the collected measurements as random values.</p>
			<p>As you can see, the processing of a parallel stream is five times faster than the processing of a sequential stream. The results are different because the measurement produces a slightly different result each time. </p>
			<p>Although the parallel stream uses asynchronous processing behind the scenes, this is not what programmers have in mind when talking about the asynchronous processing of requests. From the application’s perspective, it is just parallel (also called concurrent) processing. It is faster than sequential processing, but the main thread has to wait until all the calls are made and the data has been retrieved. If each call takes at least 100 ms (as it is in our case), then the processing of all the calls cannot be completed in less time, even when each call is made by a dedicated thread.</p>
			<p>Of course, we can create a service that uses a child thread to make all the calls, while the main thread does something else. Later, the main thread can call the service again and get the result or pick it up from a previously agreed location. That truly would be the asynchronous processing programmers are talking about. </p>
			<p>But before writing such code, let’s look at the <strong class="source-inline">CompletableFuture</strong> class located in the <strong class="source-inline">java.util.concurrent</strong> package. It does everything described and more.</p>
			<h2 id="_idParaDest-320"><a id="_idTextAnchor319"/>Using the CompletableFuture object</h2>
			<p>Using the <strong class="source-inline">CompletableFuture</strong> object, we can separate sending the request to the measuring system from getting the result from the <strong class="source-inline">CompletableFuture</strong> object. That is <a id="_idIndexMarker1761"/>exactly the scenario we <a id="_idIndexMarker1762"/>described while explaining what asynchronous processing was. Let’s demonstrate it in the code (see the <strong class="source-inline">MeasuringSystem</strong> class and the <strong class="source-inline">completableFuture()</strong> method):</p>
			<pre class="source-code">List&lt;CompletableFuture&lt;Double&gt;&gt; list = ids.stream()</pre>
			<pre class="source-code">     .map(id -&gt; CompletableFuture.supplyAsync(() -&gt;</pre>
			<pre class="source-code">  new MeasuringSystem().get(id))).collect(Collectors.toList());</pre>
			<p>The <strong class="source-inline">supplyAsync()</strong> method does not wait for the call to the measuring system to return. Instead, it immediately creates a <strong class="source-inline">CompletableFuture</strong> object and returns it. This is so that a client can use this object any time later on to retrieve the result returned by the measuring system. The following code takes the list of <strong class="source-inline">CompletableFuture</strong> objects and iterates over it, retrieving the result from each object and calculating the average value:</p>
			<pre class="source-code">LocalTime start = LocalTime.now();</pre>
			<pre class="source-code">double a = list.stream()</pre>
			<pre class="source-code">               .mapToDouble(cf -&gt; cf.join().doubleValue())</pre>
			<pre class="source-code">               .average()</pre>
			<pre class="source-code">               .orElse(0);</pre>
			<pre class="source-code">System.out.println((Math.round(a * 100.) / 100.) + " in " +</pre>
			<pre class="source-code">  Duration.between(start, LocalTime.now()).toMillis() + " ms"); </pre>
			<pre class="source-code">                                         //prints: 2.92 in 6 ms</pre>
			<p>Additionally, some methods allow you to check whether the value was returned at all, but that is not the point of this demonstration, which is to show how the <strong class="source-inline">CompletableFuture</strong> class can be used to organize asynchronous processing.</p>
			<p>The <a id="_idIndexMarker1763"/>created list of <strong class="source-inline">CompletableFuture</strong> objects can be stored anywhere and processed very quickly (in our case, in 6 ms), provided that the measurements have been received already (all the <strong class="source-inline">get()</strong> methods were invoked and returned values). After creating the list of <strong class="source-inline">CompletableFuture</strong> objects and before processing it, the system is not<a id="_idIndexMarker1764"/> blocked and can do something else. That is the advantage of asynchronous processing.</p>
			<p>The <strong class="source-inline">CompletableFuture</strong> class has many methods and is supported by several other classes and interfaces. For example, a fixed-size thread pool can be added to limit the number of threads (see the <strong class="source-inline">MeasuringSystem</strong> class and the <strong class="source-inline">threadPool()</strong> method):</p>
			<pre class="source-code">ExecutorService <strong class="bold">pool</strong> = Executors.newFixedThreadPool(3);</pre>
			<pre class="source-code">List&lt;CompletableFuture&lt;Double&gt;&gt; list = ids.stream()</pre>
			<pre class="source-code">        .map(id -&gt; CompletableFuture.supplyAsync(() -&gt; </pre>
			<pre class="source-code">                         new MeasuringSystem().get(id), <strong class="bold">pool</strong>))</pre>
			<pre class="source-code">        .collect(Collectors.toList());</pre>
			<p>There is a variety of such pools for different purposes and different performances. But using a pool does not change the overall system design, so we omit such a detail.</p>
			<p>As you can see, the power of asynchronous processing is great. There is also a variation of the asynchronous API called a <strong class="bold">non-blocking API</strong>. We are going to discuss this in the next section.</p>
			<h1 id="_idParaDest-321"><a id="_idTextAnchor320"/>Non-blocking APIs</h1>
			<p>The client <a id="_idIndexMarker1765"/>of a non-blocking API gets the results without being blocked for a significant amount of time, thus allowing the client to do something else during the period when the results are being prepared. So, the notion of a non-blocking API implies a highly responsive application. The processing of the request (that is, getting the results) can be done synchronously or asynchronously – it does not matter to the client. In practice, though, typically, the application uses asynchronous processing to facilitate an increased throughput and improved performance of the API.</p>
			<p>The term <strong class="bold">non-blocking</strong> came <a id="_idIndexMarker1766"/>into use with the <strong class="source-inline">java.nio</strong> package. The <strong class="bold">non-blocking input/output</strong> (<strong class="bold">NIO</strong>) provides support for intensive <strong class="bold">input/output</strong> (<strong class="bold">I/O</strong>) operations. It <a id="_idIndexMarker1767"/>describes how the application is implemented: it does not dedicate an execution thread to each of the requests but provides several lightweight worker threads that do the processing asynchronously and concurrently. </p>
			<h2 id="_idParaDest-322"><a id="_idTextAnchor321"/>The java.io package versus the java.nio package</h2>
			<p>Writing and<a id="_idIndexMarker1768"/> reading data to and from external memory (for example, a hard drive) is a much slower operation than processing in memory only. Initially, the already-existing classes and interfaces of the <strong class="source-inline">java.io</strong> package worked well, but once in a while, they would create a performance bottleneck. The new <strong class="source-inline">java.nio</strong> package was created to provide more effective I/O support.</p>
			<p>The <strong class="source-inline">java.io</strong> implementation<a id="_idIndexMarker1769"/> is based on I/O stream processing. As we saw in the previous section, essentially, this is a blocking operation even if some kind of concurrency is happening behind the scenes. To increase speeds, the <strong class="source-inline">java.nio</strong> implementation was introduced based on the reading/writing to/from a buffer in the memory. Such a design allowed it to separate the slow process of filling/emptying the buffer and quickly reading/writing from/to it.</p>
			<p>In a way, it is similar to what we have done in our example of <strong class="source-inline">CompletableFuture</strong> usage. The additional advantage of having data in a buffer is that it is possible to inspect the data, going there and back along with the buffer, which is impossible while reading sequentially from the stream. It has provided more flexibility during data processing. In addition, the <strong class="source-inline">java.nio</strong> implementation introduced another middleman process called <a id="_idIndexMarker1770"/>a <strong class="bold">channel</strong> for bulk data transfers to and from a buffer.</p>
			<p>The reading thread is getting data from a channel and only receives what is currently available or nothing at all (if no data is in the channel). If data is not available, the thread, instead of remaining blocked, can do something else–for example, reading/writing to/from other channels in the same way the main thread in our <strong class="source-inline">CompletableFuture</strong> example was free to do whatever had to be done while the measuring system was getting data from its sensors.</p>
			<p>This way, instead<a id="_idIndexMarker1771"/> of dedicating a<a id="_idIndexMarker1772"/> thread to one I/O process, a few worker threads can serve many I/O processes. Such a solution was eventually called NIO and<a id="_idIndexMarker1773"/> was later applied to other processes, the most prominent being the <em class="italic">event processing in an event loop</em>, which is also<a id="_idIndexMarker1774"/> called a <strong class="bold">run loop</strong>.</p>
			<h2 id="_idParaDest-323"><a id="_idTextAnchor322"/>The event/run loop</h2>
			<p>Many<a id="_idIndexMarker1775"/> non-blocking systems are based on the <strong class="bold">event</strong> (or <strong class="bold">run</strong>) loop – a thread<a id="_idIndexMarker1776"/> that is continually executed. It receives events (requests and messages) and then dispatches them to the corresponding event handlers (workers). There is nothing special about event handlers. They are just methods (functions) dedicated by the programmer for the processing of the particular event type.</p>
			<p>Such a design is <a id="_idIndexMarker1777"/>called a <strong class="bold">reactor design pattern</strong>. It is constructed around processing events and service requests concurrently. Also, it gives the name to<a id="_idIndexMarker1778"/> the <strong class="bold">reactive programming</strong> and <strong class="bold">reactive systems</strong> that <em class="italic">react</em> to events and <a id="_idIndexMarker1779"/>process them concurrently.</p>
			<p>Event loop-based design is widely used in operating systems and graphical user interfaces. It has been available in Spring WebFlux since Spring 5 and can be implemented in JavaScript and the popular executing environment, Node.js. The latter uses an event loop as its processing backbone. The toolkit, Vert.x, is built around the event loop, too.</p>
			<p>Before the adoption of an event loop, a dedicated thread was assigned to each incoming request – much like in our demonstration of stream processing. Each of the threads required the allocation of a certain amount of resources that were not request-specific, so some of the resources – mostly memory allocation – were wasted. Then, as the number of requests grew, the CPU needed to switch its context from one thread to another more frequently to allow more or less concurrent processing of all the requests. Under the load, the overhead of switching the context is substantial enough to affect the performance of an application.</p>
			<p>Implementing an <a id="_idIndexMarker1780"/>event loop has addressed these two issues. It has eliminated the waste of resources by avoiding the creation of a thread for each request and removed the overhead of switching the context. With an event loop in place, a much smaller memory allocation is needed for each request to capture its specifics, which makes<a id="_idIndexMarker1781"/> it possible to keep many more requests in memory so that they can be processed concurrently. The overhead of the CPU context-switching has become far smaller too because of the diminishing context size.</p>
			<p>The non-blocking API is a way of processing requests so that systems are able to handle a much bigger load while remaining highly responsive and resilient.</p>
			<h1 id="_idParaDest-324"><a id="_idTextAnchor323"/>Reactive</h1>
			<p>Usually, the term <strong class="bold">reactive</strong> is <a id="_idIndexMarker1782"/>used in the context of reactive programming and<a id="_idIndexMarker1783"/> reactive systems. Reactive programming (which is also called Rx programming) is based on asynchronous data streams (which is also called <strong class="bold">reactive streams</strong>). It was introduced as a <strong class="bold">Reactive Extension</strong> (<strong class="bold">RX</strong>) of <a id="_idIndexMarker1784"/>Java, which is also <a id="_idIndexMarker1785"/>called <strong class="bold">RxJava</strong> (<a href="http://reactivex.io">http://reactivex.io</a>). Later, RX support was added to Java 9 in the <strong class="source-inline">java.util.concurrent</strong> package. It allows a <strong class="source-inline">Publisher</strong> to generate a stream of data to which a <strong class="source-inline">Subscriber</strong> can asynchronously subscribe.</p>
			<p>One principal difference between reactive streams and standard streams (which are also called <strong class="bold">Java 8 streams</strong> and<a id="_idIndexMarker1786"/> are located in the <strong class="source-inline">java.util.stream</strong> package) is that a source (publisher) of the reactive stream pushes elements to subscribers at its own rate, while in standard streams, a new element is pulled and emitted only after the previous one has been processed (in fact, it acts like a <strong class="source-inline">for</strong> loop). </p>
			<p>As you have seen, we were able to process data asynchronously even without this new API by using <strong class="source-inline">CompletableFuture</strong>. But after writing such code a few times, you might notice that most of the code is just plumbing, so you get the feeling that there has to be an even simpler and more convenient solution. That’s how the reactive streams initiative (<a href="http://www.reactive-streams.org">http://www.reactive-streams.org</a>) was<a id="_idIndexMarker1787"/> born. The scope of the effort was defined as follows: </p>
			<p><em class="italic">The scope of Reactive Streams is to find a minimal set of interfaces, methods, and protocols that will describe the necessary operations and entities to achieve the goal – asynchronous streams of data with non-blocking back pressure.</em></p>
			<p>The term <strong class="bold">non-blocking backpressure</strong> refers <a id="_idIndexMarker1788"/>to one of the problems of asynchronous processing: coordinating the speed rate of the incoming data with the ability of the system to process them without the need for stopping (blocking) the data input. The solution is to inform the source that the consumer has difficulty keeping up with the input. Also, processing should react to the change in the rate of the incoming data in a more flexible manner than just blocking the flow, hence the name <em class="italic">reactive</em>.</p>
			<p>Several libraries already implement the reactive <a id="_idIndexMarker1789"/>streams API: RxJava (<a href="http://reactivex.io">http://reactivex.io</a>), Reactor (<a href="https://projectreactor.io">https://projectreactor.io</a>), Akka Streams (<a href="https://akka.io/docs">https://akka.io/docs</a>), and Vert.x (<a href="https://vertx.io/">https://vertx.io/</a>) are among the most well known. Writing code<a id="_idIndexMarker1790"/> using<a id="_idIndexMarker1791"/> RxJava or another library of asynchronous<a id="_idIndexMarker1792"/> streams constitutes <em class="italic">reactive programming</em>. It realizes the goal declared in the<a id="_idIndexMarker1793"/> Reactive Manifesto (<a href="https://www.reactivemanifesto.org">https://www.reactivemanifesto.org</a>) by building reactive systems that are <em class="italic">responsive</em>, <em class="italic">resilient</em>, <em class="italic">elastic</em>, and <em class="italic">message-driven</em>.</p>
			<h2 id="_idParaDest-325"><a id="_idTextAnchor324"/>Responsive</h2>
			<p>This term is <a id="_idIndexMarker1794"/>relatively self-explanatory. The ability to respond in a timely manner is one of the primary qualities of any system. There are many ways to achieve it. Even a traditional blocking API supported by enough servers and other infrastructure can achieve decent responsiveness under a growing load.</p>
			<p>Reactive programming helps to do this using less hardware. It comes at a price, as reactive code requires changing the way we think about control flow. But after some time, this new way of thinking becomes as natural as any other familiar skill.</p>
			<p>In the following sections, we will see quite a few examples of reactive programming.</p>
			<h2 id="_idParaDest-326"><a id="_idTextAnchor325"/>Resilient</h2>
			<p>Failures <a id="_idIndexMarker1795"/>are inevitable. The hardware crashes, the software has defects, unexpected data is received, or an untested execution path has been taken – any of these events, or a combination of them, can happen at any time. <em class="italic">Resilience</em> is the ability of a system to continue delivering the expected results under unexpected circumstances.</p>
			<p>For example, it can be achieved using redundancy of the deployable components and hardware, using isolation of parts of the system so the domino effect becomes less probable, by designing the system with automatically replaceable parts, or by raising an alarm so that qualified personnel can interfere. Additionally, we have talked about distributed systems as a good example of resilient systems by design.</p>
			<p>A distributed architecture eliminates a single point of failure. Also, breaking the system into many specialized components that talk to one another using messages allows better tuning for the duplication of the most critical parts and creates more opportunities for their isolation and potential failure containment.</p>
			<h2 id="_idParaDest-327"><a id="_idTextAnchor326"/>Elastic</h2>
			<p>Usually, the<a id="_idIndexMarker1796"/> ability to sustain the biggest possible load is associated <a id="_idIndexMarker1797"/>with <strong class="bold">scalability</strong>. But the ability to preserve the same performance characteristics under a varying load, not just under the growing one, is<a id="_idIndexMarker1798"/> called <strong class="bold">elasticity</strong>.</p>
			<p>The client of an elastic system should not notice any difference between the idle periods and the periods of peak load. A non-blocking reactive style of implementation facilitates this quality. Also, breaking the program into smaller parts and converting them into services that can be deployed and managed independently allows for the fine-tuning of resource allocation.</p>
			<p>Such small services are called microservices, and many of them together can comprise a reactive system that can be both scalable and elastic. We will talk about such architecture, in more detail, in the following sections and the next chapter.</p>
			<h2 id="_idParaDest-328"><a id="_idTextAnchor327"/>Message-driven</h2>
			<p>We have<a id="_idIndexMarker1799"/> already established that component isolation and system distribution are two aspects that help to keep the system responsive, resilient, and elastic. Loose and flexible connections are important conditions that support these qualities, too. And the asynchronous nature of the reactive system simply does not leave the designer any other choice but to build communication between the components and the messages.</p>
			<p>It creates breathing space around each component without which the system would become a tightly coupled monolith that was susceptible to all kinds of problems, not to mention a maintenance nightmare.</p>
			<p>In the next chapter, we are going to look at an architectural style that can be used to build an application as a collection of loosely coupled microservices that communicate using messages.</p>
			<h1 id="_idParaDest-329"><a id="_idTextAnchor328"/>Reactive streams</h1>
			<p>The reactive streams API, which <a id="_idIndexMarker1800"/>was introduced in Java 9, consists of the following four interfaces:</p>
			<pre class="source-code">@FunctionalInterface</pre>
			<pre class="source-code">public static interface Flow.Publisher&lt;T&gt; {</pre>
			<pre class="source-code">    public void subscribe(Flow.Subscriber&lt;T&gt; subscriber);</pre>
			<pre class="source-code">}</pre>
			<pre class="source-code">public static interface Flow.Subscriber&lt;T&gt; {</pre>
			<pre class="source-code">    public void onSubscribe(Flow.Subscription subscription);</pre>
			<pre class="source-code">    public void onNext(T item);</pre>
			<pre class="source-code">    public void onError(Throwable throwable);</pre>
			<pre class="source-code">    public void onComplete();</pre>
			<pre class="source-code">}</pre>
			<pre class="source-code">public static interface Flow.Subscription {</pre>
			<pre class="source-code">    public void request(long numberOfItems);</pre>
			<pre class="source-code">    public void cancel();</pre>
			<pre class="source-code">}</pre>
			<pre class="source-code">public static interface Flow.Processor&lt;T,R&gt;</pre>
			<pre class="source-code">               extends Flow.Subscriber&lt;T&gt;, Flow.Publisher&lt;R&gt; {</pre>
			<pre class="source-code">}</pre>
			<p>A <strong class="source-inline">Flow.Subscriber</strong> object <a id="_idIndexMarker1801"/>can be passed, as a parameter, into the <strong class="source-inline">subscribe()</strong> method of <strong class="source-inline">Flow.Publisher&lt;T&gt;</strong>. Then, the publisher calls the subscriber’s <strong class="source-inline">onSubscribe()</strong> method and passes to it a <strong class="source-inline">Flow.Subscription</strong> object as a parameter. Now, the subscriber can call <strong class="source-inline">request(long numberOfItems)</strong> on the subscription object to request data from the publisher. That is <a id="_idIndexMarker1802"/>the way the <strong class="bold">pull model</strong> can be implemented, which leaves it up to a subscriber to decide when to request another item for processing. The subscriber can unsubscribe from the publisher services by calling the <strong class="source-inline">cancel()</strong> method on the subscription.</p>
			<p>In return, the publisher can pass a new item to the subscriber by calling the subscriber’s <strong class="source-inline">onNext()</strong> method. When no more data will be coming (that is, all the data from the source was emitted) the publisher calls the subscriber’s <strong class="source-inline">onComplete()</strong> method. Also, by calling the subscriber’s <strong class="source-inline">onError()</strong> method, the publisher can tell the subscriber that it has encountered a problem. </p>
			<p>The <strong class="source-inline">Flow.Processor</strong> interface describes an entity that can act as both a subscriber and a publisher. It allows you to create chains (or pipelines) of such processors, so a subscriber can receive an item from a publisher, transform it, and then pass the result to the next subscriber or processor.</p>
			<p>In a push model, the publisher can call <strong class="source-inline">onNext()</strong> without any request from the subscriber. If the rate of processing is lower than the rate of the item being published, the subscriber can use various strategies to relieve the pressure. For example, it can skip the items or create a buffer for temporary storage with the hope that the item production will slow down and the subscriber will be able to catch up. </p>
			<p>This is the minimal set of interfaces that the reactive streams initiative has defined in support of the asynchronous data streams with non-blocking backpressure. As you can see, it allows the <a id="_idIndexMarker1803"/>subscriber and publisher to talk to each other and coordinate the rate of incoming data; therefore, it makes possible a variety of solutions for the backpressure problem that we discussed in the <em class="italic">Reactive</em> section.</p>
			<p>There are many ways to implement these interfaces. Currently, in JDK 9, there is only one implementation of one of the interfaces: the <strong class="source-inline">SubmissionPublisher</strong> class implements <strong class="source-inline">Flow.Publisher</strong>. The reason for this is that these interfaces are not supposed to be used by an application <a id="_idIndexMarker1804"/>developer. It is a <strong class="bold">Service Provider Interface</strong> (<strong class="bold">SPI</strong>) that is used by the developers of the reactive streams libraries. If needed, use one of the already-existing toolkits to implement the reactive streams API that we mentioned earlier: RxJava, Reactor, Akka Streams, Vert.x, or any other library of your preference.</p>
			<h1 id="_idParaDest-330"><a id="_idTextAnchor329"/>RxJava</h1>
			<p>In our examples, we will<a id="_idIndexMarker1805"/> use <strong class="bold">RxJava 2.2.21</strong> (<a href="http://reactivex.io">http://reactivex.io</a>) . It can be added to the <a id="_idIndexMarker1806"/>project using the following dependency:</p>
			<pre class="source-code">&lt;dependency&gt;</pre>
			<pre class="source-code">    &lt;groupId&gt;io.reactivex.rxjava2&lt;/groupId&gt;</pre>
			<pre class="source-code">    &lt;artifactId&gt;rxjava&lt;/artifactId&gt;</pre>
			<pre class="source-code">    &lt;version&gt;2.2.21&lt;/version&gt;</pre>
			<pre class="source-code">&lt;/dependency&gt;</pre>
			<p>First, let’s compare two implementations of the same functionality using the <strong class="source-inline">java.util.stream</strong> package and the <strong class="source-inline">io.reactivex</strong> package. The sample program is going to be very simple:</p>
			<ul>
				<li>Create a stream of integers: <strong class="source-inline">1</strong>, <strong class="source-inline">2</strong>, <strong class="source-inline">3</strong>, <strong class="source-inline">4</strong>, and <strong class="source-inline">5</strong>.</li>
				<li>Only filter the even numbers (that is, <strong class="source-inline">2</strong> and <strong class="source-inline">4</strong>).</li>
				<li>Calculate the square root of each of the filtered numbers.</li>
				<li>Calculate the sum of all the square roots.</li>
			</ul>
			<p>Here is how it can be<a id="_idIndexMarker1807"/> implemented using the <strong class="source-inline">java.util.stream</strong> package (see the <strong class="source-inline">ObservableIntro</strong> class and the <strong class="source-inline">squareRootSum()</strong> method):</p>
			<pre class="source-code">double a = IntStream.rangeClosed(1, 5)</pre>
			<pre class="source-code">                    .filter(i -&gt; i % 2 == 0)</pre>
			<pre class="source-code">                    .mapToDouble(Double::valueOf)</pre>
			<pre class="source-code">                    .map(Math::sqrt)</pre>
			<pre class="source-code">                    .sum();</pre>
			<pre class="source-code">System.out.println(a);          //prints: 3.414213562373095</pre>
			<p>Additionally, the same functionality implemented with RxJava looks like this:</p>
			<pre class="source-code">Observable.range(1, 5)</pre>
			<pre class="source-code">      .filter(i -&gt; i % 2 == 0)</pre>
			<pre class="source-code">      .map(Math::sqrt)</pre>
			<pre class="source-code">      .reduce((r, d) -&gt; r + d)</pre>
			<pre class="source-code">      .subscribe(System.out::println); </pre>
			<pre class="source-code">                                    //prints: 3.414213562373095</pre>
			<p>RxJava is based on the <strong class="source-inline">Observable</strong> object (which plays the role of <strong class="source-inline">Publisher</strong>) and <strong class="source-inline">Observer</strong> that subscribes to the <strong class="source-inline">Observable</strong> object and waits for the data to be emitted.</p>
			<p>In contrast to the <strong class="source-inline">Stream</strong> functionality, <strong class="source-inline">Observable</strong> has significantly different capabilities. For example, a stream, once closed, cannot be reopened, while an <strong class="source-inline">Observable</strong> object can be used again. Here is an example (see the <strong class="source-inline">ObservableIntro</strong> class and the <strong class="source-inline">reuseObservable()</strong> method):</p>
			<pre class="source-code">Observable&lt;Double&gt; observable = Observable.range(1, 5)</pre>
			<pre class="source-code">     .filter(i -&gt; i % 2 == 0)</pre>
			<pre class="source-code">     .doOnNext(System.out::println)    //prints 2 and 4 twice</pre>
			<pre class="source-code">     .map(Math::sqrt);</pre>
			<pre class="source-code">observable</pre>
			<pre class="source-code">     .reduce((r, d) -&gt; r + d)</pre>
			<pre class="source-code">     .subscribe(System.out::println);  </pre>
			<pre class="source-code">                                    //prints: 3.414213562373095</pre>
			<pre class="source-code">observable</pre>
			<pre class="source-code">     .reduce((r, d) -&gt; r + d)</pre>
			<pre class="source-code">     .map(r -&gt; r / 2)</pre>
			<pre class="source-code">     .subscribe(System.out::println);  </pre>
			<pre class="source-code">                                   //prints: 1.7071067811865475</pre>
			<p>In the preceding example, as you can see from the comments, the <strong class="source-inline">doOnNext()</strong> operation was called twice, which means the observable object also emitted values twice, once<a id="_idIndexMarker1808"/> for each processing pipeline:</p>
			<div>
				<div id="_idContainer166" class="IMG---Figure">
					<img src="image/B18388_Figure_15.1.jpg" alt=""/>
				</div>
			</div>
			<p>If we do not want <strong class="source-inline">Observable</strong> to run twice, we can cache its data, by adding the <strong class="source-inline">cache()</strong> operation (see the <strong class="source-inline">ObservableIntro</strong> class and the <strong class="source-inline">cacheObservableData()</strong> method):</p>
			<pre class="source-code">Observable&lt;Double&gt; observable = Observable.range(1,5)</pre>
			<pre class="source-code">     .filter(i -&gt; i % 2 == 0)</pre>
			<pre class="source-code">     .doOnNext(System.out::println)  //prints 2 and 4 only once</pre>
			<pre class="source-code">     .map(Math::sqrt)</pre>
			<pre class="source-code">     .<strong class="bold">cache()</strong>;</pre>
			<pre class="source-code">observable</pre>
			<pre class="source-code">     .reduce((r, d) -&gt; r + d)</pre>
			<pre class="source-code">     .subscribe(System.out::println); </pre>
			<pre class="source-code">                                    //prints: 3.414213562373095</pre>
			<pre class="source-code">observable</pre>
			<pre class="source-code">     .reduce((r, d) -&gt; r + d)</pre>
			<pre class="source-code">     .map(r -&gt; r / 2)</pre>
			<pre class="source-code">     .subscribe(System.out::println);  </pre>
			<pre class="source-code">                                   //prints: 1.7071067811865475</pre>
			<p>As you can<a id="_idIndexMarker1809"/> see, the second usage of the same <strong class="source-inline">Observable</strong> object took advantage of the cached data, thus allowing for better performance:</p>
			<div>
				<div id="_idContainer167" class="IMG---Figure">
					<img src="image/B18388_Figure_15.2.jpg" alt=""/>
				</div>
			</div>
			<p>RxJava provides such a rich functionality that there is no way we can review it all in this book. Instead, we will try to cover the most popular functionality. The API describes the methods available for <a id="_idIndexMarker1810"/>invocation using an <strong class="source-inline">Observable</strong> object. Such methods are also called <strong class="bold">operations</strong> (as in the case with the standard Java 8 streams) or <strong class="bold">operators</strong> (this term is mostly used in connection to reactive streams). We will use <a id="_idIndexMarker1811"/>these three terms – methods, operations, and operators – interchangeably as synonyms. </p>
			<h2 id="_idParaDest-331"><a id="_idTextAnchor330"/>Observable types</h2>
			<p>Talking<a id="_idIndexMarker1812"/> about the RxJava 2 API (notice that is it quite different from RxJava 1), we will use<a id="_idIndexMarker1813"/> the online documentation, which can be found at <a href="http://reactivex.io/RxJava/2.x/javadoc/index.html">http://reactivex.io/RxJava/2.x/javadoc/index.html</a>.</p>
			<p>An observer subscribes to receive values from an observable object, which can behave as one of the following types: </p>
			<ul>
				<li><strong class="bold">Blocking</strong>: This <a id="_idIndexMarker1814"/>waits until the result is returned.</li>
				<li><strong class="bold">Non-blocking</strong>: This<a id="_idIndexMarker1815"/> processes the emitted elements asynchronously.</li>
				<li><strong class="bold">Cold</strong>: This<a id="_idIndexMarker1816"/> emits an element at the observer’s request.</li>
				<li><strong class="bold">Hot</strong>: This <a id="_idIndexMarker1817"/>emits elements whether an observer has subscribed or not.</li>
			</ul>
			<p>An observable object <a id="_idIndexMarker1818"/>can be an object of one of the following classes of the <strong class="source-inline">io.reactivex</strong> package:</p>
			<ul>
				<li><strong class="source-inline">Observable&lt;T&gt;</strong>: This <a id="_idIndexMarker1819"/>can emit none, one, or many elements; it does not support backpressure.</li>
				<li><strong class="source-inline">Flowable&lt;T&gt;</strong>: This<a id="_idIndexMarker1820"/> can emit none, one, or many elements; it supports backpressure.</li>
				<li><strong class="source-inline">Single&lt;T&gt;</strong>: This<a id="_idIndexMarker1821"/> can emit either one element or an error; the notion of backpressure does not apply.</li>
				<li><strong class="source-inline">Maybe&lt;T&gt;</strong>: This<a id="_idIndexMarker1822"/> represents a deferred computation. It can emit either no value, one value, or an error; the notion of backpressure does not apply.</li>
				<li><strong class="source-inline">Completable</strong>: This<a id="_idIndexMarker1823"/> represents a deferred computation without any value. This indicates the completion of a task or an error; the notion of backpressure does not apply.</li>
			</ul>
			<p>An object of each of these classes can behave as a blocking, non-blocking, cold, or hot observable. They differ from each other by the number of values that can be emitted, their ability to defer the returning of the result or returning the flag of the task completion only, and their ability to handle backpressure.</p>
			<h3>Blocking versus non-blocking</h3>
			<p>To<a id="_idIndexMarker1824"/> demonstrate this behavior, we create an observable that emits five sequential integers, starting with <strong class="source-inline">1</strong> (see the <strong class="source-inline">BlockingOperators</strong> class and the <strong class="source-inline">observableBlocking1()</strong> method):</p>
			<pre class="source-code">Observable&lt;Integer&gt; obs = Observable.range(1,5);</pre>
			<p>All the blocking methods (operators) of <strong class="source-inline">Observable</strong> start with the “blocking.” For example, the <strong class="source-inline">blockingLast()</strong> operator blocks the pipeline until the last elements are emitted:</p>
			<pre class="source-code">Double d2 = obs.filter(i -&gt; i % 2 == 0)</pre>
			<pre class="source-code">               .doOnNext(System.out::println)  //prints 2 and 4</pre>
			<pre class="source-code">               .map(Math::sqrt)</pre>
			<pre class="source-code">               .delay(100, TimeUnit.MILLISECONDS)</pre>
			<pre class="source-code">               .blockingLast();</pre>
			<pre class="source-code">System.out.println(d2);                        //prints: 2.0</pre>
			<p>In this example, we only select even numbers, print the selected element, and then calculate the square root and wait for 100 ms (imitating a long-running calculation). The result of this example is as follows:</p>
			<div>
				<div id="_idContainer168" class="IMG---Figure">
					<img src="image/B18388_Figure_15.3.jpg" alt=""/>
				</div>
			</div>
			<p>The non-blocking version of the same functionality is as follows (see the <strong class="source-inline">BlockingOperators</strong> class and the second half of the <strong class="source-inline">observableBlocking1()</strong> method):</p>
			<pre class="source-code">List&lt;Double&gt; list = new ArrayList&lt;&gt;();</pre>
			<pre class="source-code">obs.filter(i -&gt; i % 2 == 0)</pre>
			<pre class="source-code">   .doOnNext(System.out::println)  //prints 2 and 4</pre>
			<pre class="source-code">   .map(Math::sqrt)</pre>
			<pre class="source-code">   .delay(100, TimeUnit.MILLISECONDS)</pre>
			<pre class="source-code">   .subscribe(d -&gt; {</pre>
			<pre class="source-code">        if(list.size() == 1){</pre>
			<pre class="source-code">            list.remove(0);</pre>
			<pre class="source-code">        }</pre>
			<pre class="source-code">        list.add(d);</pre>
			<pre class="source-code">   });</pre>
			<pre class="source-code">System.out.println(list);          //prints: []</pre>
			<p>We use the <strong class="source-inline">List</strong> object to capture the result because, as you might remember, the lambda expression does not allow us to use the non-final variables.</p>
			<p>As you <a id="_idIndexMarker1825"/>can see, the resulting list is empty. That is because the pipeline calculations are performed without blocking (asynchronously). We set a delay of 100 ms (to simulate processing, which takes a long time), but there is no blocking operation, so the control goes down to the next line that prints the list content, which is still empty. </p>
			<p>To prevent the control from going to this line too early, we can set a delay in front of it (see the <strong class="source-inline">BlockingOperators</strong> class and the <strong class="source-inline">observableBlocking2()</strong> method):</p>
			<pre class="source-code">try {</pre>
			<pre class="source-code">    TimeUnit.MILLISECONDS.sleep(250);</pre>
			<pre class="source-code">} catch (InterruptedException e) {</pre>
			<pre class="source-code">    e.printStackTrace();</pre>
			<pre class="source-code">}</pre>
			<pre class="source-code">System.out.println(list);   //prints: [2.0]</pre>
			<p>Note that the delay has to be 200 ms at least because the pipeline processes two elements, each with a delay of 100 ms. Now you can see the list contains an expected value of <strong class="source-inline">2.0</strong>. </p>
			<p>Esentially, that is the difference between blocking and non-blocking operators. Other classes that represent an <strong class="source-inline">observable</strong> have similar blocking operators. Here are some examples of<a id="_idIndexMarker1826"/> blocking <strong class="source-inline">Flowable</strong>, <strong class="source-inline">Single</strong>, and <strong class="source-inline">Maybe</strong> (see the <strong class="source-inline">BlockingOperators</strong> class and the <strong class="source-inline">flowableBlocking()</strong>, <strong class="source-inline">singleBlocking()</strong>, and <strong class="source-inline">maybeBlocking()</strong> methods):</p>
			<pre class="source-code">Flowable&lt;Integer&gt; obs = Flowable.range(1,5);</pre>
			<pre class="source-code">Double d2 = obs.filter(i -&gt; i % 2 == 0)</pre>
			<pre class="source-code">        .doOnNext(System.out::println)  //prints 2 and 4</pre>
			<pre class="source-code">        .map(Math::sqrt)</pre>
			<pre class="source-code">        .delay(100, TimeUnit.MILLISECONDS)</pre>
			<pre class="source-code">        .blockingLast();</pre>
			<pre class="source-code">System.out.println(d2);                 //prints: 2.0</pre>
			<pre class="source-code">Single&lt;Integer&gt; obs2 = Single.just(42);</pre>
			<pre class="source-code">int i2 = obs2.delay(100, TimeUnit.MILLISECONDS).blockingGet();</pre>
			<pre class="source-code">System.out.println(i2);                 //prints: 42</pre>
			<pre class="source-code">Maybe&lt;Integer&gt; obs3 = Maybe.just(42); </pre>
			<pre class="source-code">int i3 = obs3.delay(100, TimeUnit.MILLISECONDS).blockingGet(); </pre>
			<pre class="source-code">System.out.println(i3);                 //prints: 42 </pre>
			<p>The <strong class="source-inline">Completable</strong> class has blocking operators that allow us to set a timeout (see the <strong class="source-inline">BlockingOperators</strong> class and the second half of the <strong class="source-inline">completableBlocking()</strong> method):</p>
			<pre class="source-code">(1) Completable obs = Completable.fromRunnable(() -&gt; {</pre>
			<pre class="source-code">         System.out.println("Run");           //prints: Run</pre>
			<pre class="source-code">         try {</pre>
			<pre class="source-code">              TimeUnit.MILLISECONDS.sleep(200);</pre>
			<pre class="source-code">         } catch (InterruptedException e) {</pre>
			<pre class="source-code">              e.printStackTrace();</pre>
			<pre class="source-code">         }</pre>
			<pre class="source-code">    });                                           </pre>
			<pre class="source-code">(2) Throwable ex = obs.blockingGet();</pre>
			<pre class="source-code">(3) System.out.println(ex);                   //prints: null</pre>
			<pre class="source-code">//(4) ex = obs.blockingGet(15, TimeUnit.MILLISECONDS);</pre>
			<pre class="source-code">// java.util.concurrent.TimeoutException: </pre>
			<pre class="source-code">//      The source did not signal an event for 15 milliseconds.</pre>
			<pre class="source-code">(5) ex = obs.blockingGet(150, TimeUnit.MILLISECONDS);</pre>
			<pre class="source-code">(6) System.out.println(ex);                   //prints: null</pre>
			<pre class="source-code">(7) obs.blockingAwait();</pre>
			<pre class="source-code">(8) obs.blockingAwait(15, TimeUnit.MILLISECONDS);</pre>
			<p>The result<a id="_idIndexMarker1827"/> of the preceding code is presented in the following screenshot:</p>
			<div>
				<div id="_idContainer169" class="IMG---Figure">
					<img src="image/B18388_Figure_15.4.jpg" alt=""/>
				</div>
			</div>
			<p class="figure-caption"> </p>
			<p>The first <strong class="source-inline">Run</strong> message comes from line 2 in response to the call of the blocking <strong class="source-inline">blockingGet()</strong> method. The first <strong class="source-inline">null</strong> message comes from line 3. Line 4 throws an exception because the timeout was set to 15 ms, while the actual processing was set to a delay of 100 ms. The second <strong class="source-inline">Run</strong> message comes from line 5 in response to the <strong class="source-inline">blockingGet()</strong> method call. This time, the timeout is set to 150 ms, which is more than 100 ms, so the method is able to return before the timeout was up.</p>
			<p>The last<a id="_idIndexMarker1828"/> two lines, 7 and 8, demonstrate the usage of the <strong class="source-inline">blockingAwait()</strong> method with and without a timeout. This method does not return a value but allows the observable pipeline to run its course. Interestingly, it does not break with an exception even when the timeout is set to a smaller value than the time the pipeline takes to finish. Apparently, it starts waiting after the pipeline has finished processing unless it is a defect that will be fixed later (the documentation is not clear regarding this point).</p>
			<p>Although blocking operations do exist (and we will review more of them while talking about each observable type in the following sections), they are and should only be used in cases when it is not possible to implement the required functionality of using non-blocking operations only. The main thrust of reactive programming is to strive to process all requests asynchronously in a non-blocking style. </p>
			<h3>Cold versus hot</h3>
			<p>So far, all the<a id="_idIndexMarker1829"/> examples we have seen have only demonstrated a cold observable, which only provides the next value at the request of the processing pipeline after the previous value has been processed. Here is another example (see the <strong class="source-inline">ColdObservable</strong> class and the <strong class="source-inline">main()</strong> method):</p>
			<pre class="source-code">Observable&lt;Long&gt; cold = </pre>
			<pre class="source-code">        Observable.interval(10, TimeUnit.MILLISECONDS);</pre>
			<pre class="source-code">cold.subscribe(i -&gt; System.out.println("First: " + i));</pre>
			<pre class="source-code">pauseMs(25);</pre>
			<pre class="source-code">cold.subscribe(i -&gt; System.out.println("Second: " + i));</pre>
			<pre class="source-code">pauseMs(55);</pre>
			<p>We have used the <strong class="source-inline">interval()</strong> method to create an <strong class="source-inline">Observable</strong> object that represents a stream of sequential numbers emitted at every specified interval (in our case, every 10 ms). Then, we subscribe to the created object, wait 25 ms, subscribe again, and <a id="_idIndexMarker1830"/>wait another 55 ms. The <strong class="source-inline">pauseMs()</strong> method is as follows:</p>
			<pre class="source-code">void pauseMs(long ms){</pre>
			<pre class="source-code">    try {</pre>
			<pre class="source-code">        TimeUnit.MILLISECONDS.sleep(ms);</pre>
			<pre class="source-code">    } catch (InterruptedException e) {</pre>
			<pre class="source-code">        e.printStackTrace();</pre>
			<pre class="source-code">    }</pre>
			<pre class="source-code">}</pre>
			<p>If we run the preceding example, the output will look similar to the following:</p>
			<div>
				<div id="_idContainer170" class="IMG---Figure">
					<img src="image/B18388_Figure_15.5.jpg" alt=""/>
				</div>
			</div>
			<p>As you can see, each of the pipelines processed every value emitted by the cold observable.</p>
			<p>To convert the <em class="italic">cold</em> observable into a <em class="italic">hot</em> one, we use the <strong class="source-inline">publish()</strong> method, which converts the observable into a <strong class="source-inline">ConnectableObservable</strong> object that extends the <strong class="source-inline">Observable</strong> object (see the <strong class="source-inline">HotObservable</strong> class and the <strong class="source-inline">hot1()</strong> method):</p>
			<pre class="source-code">ConnectableObservable&lt;Long&gt; hot = </pre>
			<pre class="source-code">      Observable.interval(10, TimeUnit.MILLISECONDS).publish();</pre>
			<pre class="source-code">hot.connect();</pre>
			<pre class="source-code">hot.subscribe(i -&gt; System.out.println("First: " + i));</pre>
			<pre class="source-code">pauseMs(25);</pre>
			<pre class="source-code">hot.subscribe(i -&gt; System.out.println("Second: " + i));</pre>
			<pre class="source-code">pauseMs(55);</pre>
			<p>As you can <a id="_idIndexMarker1831"/>see, we have to call the <strong class="source-inline">connect()</strong> method so that the <strong class="source-inline">ConnectableObservable</strong> object starts emitting values. The output looks similar to the following:</p>
			<div>
				<div id="_idContainer171" class="IMG---Figure">
					<img src="image/B18388_Figure_15.6.jpg" alt=""/>
				</div>
			</div>
			<p>The preceding output shows that the second pipeline did not receive the first three values because it was subscribed to the observable later on. So, the observable emits values independent of the ability of the observers to process them. If the processing falls behind, and new values keep coming while the previous ones are not fully processed yet, the <strong class="source-inline">Observable</strong> class puts them into a buffer. If this buffer grows large enough, the JVM can run out of memory because, as we mentioned earlier, the <strong class="source-inline">Observable</strong> class is not capable of backpressure management.</p>
			<p>For such cases, the <strong class="source-inline">Flowable</strong> class is a better candidate for the observable because it does have the ability to handle backpressure. Here is an example (see the <strong class="source-inline">HotObservable</strong> class and the <strong class="source-inline">hot2()</strong> method): </p>
			<pre class="source-code">PublishProcessor&lt;Integer&gt; hot = PublishProcessor.create();</pre>
			<pre class="source-code">hot.observeOn(Schedulers.io(), true)</pre>
			<pre class="source-code">   .subscribe(System.out::println, Throwable::printStackTrace);</pre>
			<pre class="source-code">for (int i = 0; i &lt; 1_000_000; i++) {</pre>
			<pre class="source-code">    hot.onNext(i);</pre>
			<pre class="source-code">}</pre>
			<p>The <strong class="source-inline">PublishProcessor</strong> class extends <strong class="source-inline">Flowable</strong> and has an <strong class="source-inline">onNext(Object o)</strong> method <a id="_idIndexMarker1832"/>that forces it to emit the passed-in object. Before calling it, we have subscribed to the observable using the <strong class="source-inline">Schedulers.io()</strong> thread. We will talk about schedulers in the <em class="italic">Multithreading (scheduler)</em> section.</p>
			<p>The <strong class="source-inline">subscribe()</strong> method has several overloaded versions. We decided to use the one that accepts two <strong class="source-inline">Consumer</strong> functions: the first one processes the passed-in value, and the second one processes an exception if it was thrown by any of the pipeline operations (it works similar to a <strong class="source-inline">Catch</strong> block).</p>
			<p>If we run the preceding example, it will successfully print the first 127 values and then throw <strong class="source-inline">MissingBackpressureException</strong>, as shown in the following screenshot:</p>
			<div>
				<div id="_idContainer172" class="IMG---Figure">
					<img src="image/B18388_Figure_15.7.jpg" alt=""/>
				</div>
			</div>
			<p>The message in the exception provides a clue: <strong class="source-inline">Could not emit value due to lack of requests</strong>. Apparently, the rate of emitting values is higher than the rate of consuming them, while an internal buffer can only keep 128 elements. If we add a delay (to simulate a longer processing time), the result will be even worse (see the <strong class="source-inline">HotObservable</strong> class and the <strong class="source-inline">hot3()</strong> method):</p>
			<pre class="source-code">PublishProcessor&lt;Integer&gt; hot = PublishProcessor.create();</pre>
			<pre class="source-code">hot.observeOn(Schedulers.io(), true)</pre>
			<pre class="source-code">   .delay(10, TimeUnit.MILLISECONDS)</pre>
			<pre class="source-code">   .subscribe(System.out::println, Throwable::printStackTrace);</pre>
			<pre class="source-code">for (int i = 0; i &lt; 1_000_000; i++) {</pre>
			<pre class="source-code">    hot.onNext(i);</pre>
			<pre class="source-code">}</pre>
			<p>Even the first 128 elements will not get through and the output will only have <strong class="source-inline">MissingBackpressureException</strong>. </p>
			<p>To address<a id="_idIndexMarker1833"/> this issue, a backpressure strategy has to be set. For example, let’s drop every value that the pipeline did not manage to process (see the <strong class="source-inline">HotObservable</strong> class and the <strong class="source-inline">hot4()</strong> method):</p>
			<pre class="source-code">PublishProcessor&lt;Integer&gt; hot = PublishProcessor.create();</pre>
			<pre class="source-code">hot.onBackpressureDrop(v -&gt; System.out.println("Dropped: "+ v))</pre>
			<pre class="source-code">   .observeOn(Schedulers.io(), true)</pre>
			<pre class="source-code">   .subscribe(System.out::println, Throwable::printStackTrace);</pre>
			<pre class="source-code">for (int i = 0; i &lt; 1_000_000; i++) {</pre>
			<pre class="source-code">    hot.onNext(i);</pre>
			<pre class="source-code">}</pre>
			<p>Notice that the strategy has to be set before the <strong class="source-inline">observeOn()</strong> operation, so it will be picked up by the created <strong class="source-inline">Schedulers.io()</strong> thread.</p>
			<p>The output shows that many of the emitted values were dropped. Here is an output fragment:</p>
			<div>
				<div id="_idContainer173" class="IMG---Figure">
					<img src="image/B18388_Figure_15.8.jpg" alt=""/>
				</div>
			</div>
			<p>We will talk about other backpressure strategies in the <em class="italic">Operators</em> section when we overview the corresponding operators.</p>
			<h2 id="_idParaDest-332"><a id="_idTextAnchor331"/>Disposable</h2>
			<p>Notice <a id="_idIndexMarker1834"/>that a <strong class="source-inline">subscribe()</strong> method actually returns a <strong class="source-inline">Disposable</strong> object<a id="_idIndexMarker1835"/> that can be queried to check whether the pipeline processing has been completed and disposed of (see the <strong class="source-inline">DisposableUsage</strong> class and the <strong class="source-inline">disposable1()</strong> method):</p>
			<pre class="source-code">Observable&lt;Integer&gt; obs = Observable.range(1,5);</pre>
			<pre class="source-code">List&lt;Double&gt; list = new ArrayList&lt;&gt;();</pre>
			<pre class="source-code">Disposable disposable =</pre>
			<pre class="source-code">     obs.filter(i -&gt; i % 2 == 0)</pre>
			<pre class="source-code">        .doOnNext(System.out::println)     //prints 2 and 4</pre>
			<pre class="source-code">        .map(Math::sqrt)</pre>
			<pre class="source-code">        .delay(100, TimeUnit.MILLISECONDS)</pre>
			<pre class="source-code">        .subscribe(d -&gt; {</pre>
			<pre class="source-code">            if(list.size() == 1){</pre>
			<pre class="source-code">                list.remove(0);</pre>
			<pre class="source-code">            }</pre>
			<pre class="source-code">            list.add(d);</pre>
			<pre class="source-code">        });</pre>
			<pre class="source-code">System.out.println(disposable.isDisposed()); //prints: false</pre>
			<pre class="source-code">System.out.println(list);                    //prints: []</pre>
			<pre class="source-code">try {</pre>
			<pre class="source-code">    TimeUnit.MILLISECONDS.sleep(200);</pre>
			<pre class="source-code">} catch (InterruptedException e) {</pre>
			<pre class="source-code">    e.printStackTrace();</pre>
			<pre class="source-code">}</pre>
			<pre class="source-code">System.out.println(disposable.isDisposed());  //prints: true</pre>
			<pre class="source-code">System.out.println(list);                     //prints: [2.0]</pre>
			<p>Also, it is possible to enforce the disposing of a pipeline, thus effectively canceling the processing (see the <strong class="source-inline">DisposableUsage</strong> class and the <strong class="source-inline">disposable2()</strong> method):</p>
			<pre class="source-code">Observable&lt;Integer&gt; obs = Observable.range(1,5);</pre>
			<pre class="source-code">List&lt;Double&gt; list = new ArrayList&lt;&gt;();</pre>
			<pre class="source-code">Disposable disposable =</pre>
			<pre class="source-code">     obs.filter(i -&gt; i % 2 == 0)</pre>
			<pre class="source-code">        .doOnNext(System.out::println)       //prints 2 and 4</pre>
			<pre class="source-code">        .map(Math::sqrt)</pre>
			<pre class="source-code">        .delay(100, TimeUnit.MILLISECONDS)</pre>
			<pre class="source-code">        .subscribe(d -&gt; {</pre>
			<pre class="source-code">            if(list.size() == 1){</pre>
			<pre class="source-code">                list.remove(0);</pre>
			<pre class="source-code">            }</pre>
			<pre class="source-code">            list.add(d);</pre>
			<pre class="source-code">        });</pre>
			<pre class="source-code">System.out.println(disposable.isDisposed()); //prints: false</pre>
			<pre class="source-code">System.out.println(list);                    //prints: []</pre>
			<pre class="source-code"><strong class="bold">disposable.dispose();</strong></pre>
			<pre class="source-code">try {</pre>
			<pre class="source-code">    TimeUnit.MILLISECONDS.sleep(200);</pre>
			<pre class="source-code">} catch (InterruptedException e) {</pre>
			<pre class="source-code">    e.printStackTrace();</pre>
			<pre class="source-code">}</pre>
			<pre class="source-code">System.out.println(disposable.isDisposed()); //prints: true</pre>
			<pre class="source-code">System.out.println(list);                    //prints: <strong class="bold">[]</strong></pre>
			<p>As you can see, by adding the call to <strong class="source-inline">disposable.dispose()</strong>, we have stopped processing, so even after a delay of 200 ms, the list remains empty (see the last line of the preceding example).</p>
			<p>This <a id="_idIndexMarker1836"/>method <a id="_idIndexMarker1837"/>of forced disposal can be used to make sure that there are no runaway threads. Each created <strong class="source-inline">Disposable</strong> object can be disposed of in the same way that resources are released in a <strong class="source-inline">finally</strong> block. The <strong class="source-inline">CompositeDisposable</strong> class helps us to handle multiple <strong class="source-inline">Disposable</strong> objects in a coordinated manner.</p>
			<p>When an <strong class="source-inline">onComplete</strong> or <strong class="source-inline">onError</strong> event happens, the pipeline is disposed of automatically.</p>
			<p>For example, you can use the <strong class="source-inline">add()</strong> method and add a newly created <strong class="source-inline">Disposable</strong> object to the <strong class="source-inline">CompositeDisposable</strong> object. Then, when necessary, the <strong class="source-inline">clear()</strong> method can be invoked on the <strong class="source-inline">CompositeDisposable</strong> object. It will remove the collected <strong class="source-inline">Disposable</strong> objects and call the <strong class="source-inline">dispose()</strong> method on each of them.</p>
			<h2 id="_idParaDest-333"><a id="_idTextAnchor332"/>Creating an observable</h2>
			<p>You <a id="_idIndexMarker1838"/>have already seen a few methods of how to create an observable in our examples. There are many other factory methods, including <strong class="source-inline">Observable</strong>, <strong class="source-inline">Flowable</strong>, <strong class="source-inline">Single</strong>, <strong class="source-inline">Maybe</strong>, and <strong class="source-inline">Completable</strong>. However, not all of the following methods are available in each of these interfaces (see the comments; <em class="italic">all</em> means <a id="_idIndexMarker1839"/>that all of the listed interfaces have it):</p>
			<ul>
				<li><strong class="source-inline">create()</strong>: This creates an <strong class="source-inline">Observable</strong> object by providing the full implementation (all).</li>
				<li><strong class="source-inline">defer()</strong>: This creates a new <strong class="source-inline">Observable</strong> object every time a new <strong class="source-inline">Observer</strong> subscribes (all).</li>
				<li><strong class="source-inline">empty()</strong>: This creates an empty <strong class="source-inline">Observable</strong> object that completes immediately upon subscription (all, except for <strong class="source-inline">Single</strong>).</li>
				<li><strong class="source-inline">never()</strong>: This creates an <strong class="source-inline">Observable</strong> object that does not emit anything and does nothing at all; it does not even complete (all).</li>
				<li><strong class="source-inline">error()</strong>: This creates an <strong class="source-inline">Observable</strong> object that emits an exception immediately upon subscription (all).</li>
				<li><strong class="source-inline">fromXXX()</strong>: This creates an <strong class="source-inline">Observable</strong> object, where XXX can be <em class="italic">Callable</em>, <em class="italic">Future</em> (all), <em class="italic">Iterable</em>, <em class="italic">Array</em>, <em class="italic">Publisher</em> (<strong class="source-inline">Observable</strong> and <strong class="source-inline">Flowable</strong>), <em class="italic">Action</em>, or <em class="italic">Runnable</em> (<strong class="source-inline">Maybe</strong> and <strong class="source-inline">Completable</strong>); this means it creates an <strong class="source-inline">Observable</strong> object based on the provided function or object.</li>
				<li><strong class="source-inline">generate()</strong>: This <a id="_idIndexMarker1840"/>creates a cold <strong class="source-inline">Observable</strong> object that generates values based on the provided function or object (<strong class="source-inline">Observable</strong> and <strong class="source-inline">Flowable</strong> only).</li>
				<li><strong class="source-inline">range(), rangeLong(), interval(), intervalRange()</strong>: This creates an <strong class="source-inline">Observable</strong> object that emits sequential <strong class="source-inline">int</strong> or <strong class="source-inline">long</strong> values, which may or may not be limited by the specified range and spaced by the specified time interval (<strong class="source-inline">Observable</strong> and <strong class="source-inline">Flowable</strong> only).</li>
				<li><strong class="source-inline">just()</strong>: This creates an <strong class="source-inline">Observable</strong> object based on the provided object or a set of objects (all, except for <strong class="source-inline">Completable</strong>).</li>
				<li><strong class="source-inline">timer()</strong>: This creates an <strong class="source-inline">Observable</strong> object that, after the specified time, emits an <strong class="source-inline">0L</strong> signal (all) and then completes for <strong class="source-inline">Observable</strong> and <strong class="source-inline">Flowable</strong>.</li>
			</ul>
			<p>There <a id="_idIndexMarker1841"/>are also many other helpful methods, such as <strong class="source-inline">repeat()</strong>, <strong class="source-inline">startWith()</strong>, and more. We just do not have enough space to list all of them. Refer to the online documentation (<a href="http://reactivex.io/RxJava/2.x/javadoc/index.html">http://reactivex.io/RxJava/2.x/javadoc/index.html</a>).</p>
			<p>Let’s look at an example of the <strong class="source-inline">create()</strong> method usage. The <strong class="source-inline">create()</strong> method of <strong class="source-inline">Observable</strong> is as follows:</p>
			<pre class="source-code">public static Observable&lt;T&gt; create(ObservableOnSubscribe&lt;T&gt; source)</pre>
			<p>The passed-in object has to be an implementation of the <strong class="source-inline">ObservableOnSubscribe&lt;T&gt;</strong> functional interface, which only has one abstract method, <strong class="source-inline">subscribe()</strong>:</p>
			<pre class="source-code">void subscribe(ObservableEmitter&lt;T&gt; emitter)</pre>
			<p>The <strong class="source-inline">ObservableEmitter&lt;T&gt;</strong> interface <a id="_idIndexMarker1842"/>contains the following methods:</p>
			<ul>
				<li><strong class="source-inline">boolean isDisposed()</strong>: This returns <strong class="source-inline">true</strong> if the processing pipeline was disposed of or the emitter was terminated.</li>
				<li><strong class="source-inline">ObservableEmitter&lt;T&gt; serialize()</strong>: This provides the serialization algorithm used by the calls to <strong class="source-inline">onNext()</strong>, <strong class="source-inline">onError()</strong>, and <strong class="source-inline">onComplete()</strong>, located in the <strong class="source-inline">Emitter</strong> base class.</li>
				<li><strong class="source-inline">void setCancellable(Cancellable c)</strong>: This sets, on this emitter, a <strong class="source-inline">Cancellable</strong> implementation (that is, a functional interface that has only one method, <strong class="source-inline">cancel()</strong>).</li>
				<li><strong class="source-inline">void setDisposable(Disposable d)</strong>: This sets, on this emitter, a <strong class="source-inline">Disposable</strong> implementation (which is an interface that has two methods: <strong class="source-inline">isDispose()</strong> and <strong class="source-inline">dispose()</strong>).</li>
				<li><strong class="source-inline">boolean tryOnError(Throwable t)</strong>: This handles the error condition, attempts to emit the provided exception, and returns <strong class="source-inline">false</strong> if the emission is not allowed.</li>
			</ul>
			<p>To<a id="_idIndexMarker1843"/> create an observable, all the preceding interfaces can be implemented as follows (see the <strong class="source-inline">CreateObservable</strong> class and the <strong class="source-inline">main()</strong> method):</p>
			<pre class="source-code">ObservableOnSubscribe&lt;String&gt; source = emitter -&gt; {</pre>
			<pre class="source-code">    emitter.onNext("One");</pre>
			<pre class="source-code">    emitter.onNext("Two");</pre>
			<pre class="source-code">    emitter.onComplete();</pre>
			<pre class="source-code">};</pre>
			<pre class="source-code">Observable.create(source)</pre>
			<pre class="source-code">          .filter(s -&gt; s.contains("w"))</pre>
			<pre class="source-code">          .subscribe(v -&gt; System.out.println(v),</pre>
			<pre class="source-code">                     e -&gt; e.printStackTrace(),</pre>
			<pre class="source-code">                    () -&gt; System.out.println("Completed"));</pre>
			<pre class="source-code">pauseMs(100); </pre>
			<p>Let’s take a closer look at the preceding example. We created an <strong class="source-inline">ObservableOnSubscribe</strong> function as <strong class="source-inline">source</strong> and implemented the emitter: we told the emitter to emit <strong class="source-inline">One</strong> at the first call to <strong class="source-inline">onNext()</strong>, to emit <strong class="source-inline">Two</strong> at the second call to <strong class="source-inline">onNext()</strong>, and then to call <strong class="source-inline">onComplete()</strong>. We passed the <strong class="source-inline">source</strong> function to the <strong class="source-inline">create()</strong> method and built the pipeline to process all of the emitted values.</p>
			<p>To make it more interesting, we added the <strong class="source-inline">filter()</strong> operator, which only allows you to further propagate the values with the <em class="italic">w</em> character. Additionally, we chose the <strong class="source-inline">subscribe()</strong> method version with three parameters: the <strong class="source-inline">Consumer onNext</strong>, <strong class="source-inline">Consumer onError</strong>, and <strong class="source-inline">Action onComplete</strong> functions. The first is called every time a next value reached the method, the second is called when an exception was emitted, and the third is called when the source emits an <strong class="source-inline">onComplete()</strong> signal. After creating the pipeline, we paused for 100 ms to give the asynchronous process a chance to finish. The result is as follows:</p>
			<div>
				<div id="_idContainer174" class="IMG---Figure">
					<img src="image/B18388_Figure_15.9.jpg" alt=""/>
				</div>
			</div>
			<p>If we remove the <strong class="source-inline">emitter.onComplete()</strong> line from the emitter implementation, only the message <strong class="source-inline">Two</strong> will be displayed.</p>
			<p>So, those <a id="_idIndexMarker1844"/>are the basics of how the <strong class="source-inline">create()</strong> method can be used. As you can see, it allows for full customization. In practice, it is rarely used because there are far simpler ways to create an observable. We will review them in the following sections.</p>
			<p>Additionally, you will see examples of other factory methods that are used in our examples throughout other sections of this chapter.</p>
			<h2 id="_idParaDest-334"><a id="_idTextAnchor333"/>Operators</h2>
			<p>There <a id="_idIndexMarker1845"/>are<a id="_idIndexMarker1846"/> literally hundreds (if we count all of the overloaded versions) of operators available in each of the observable interfaces, <strong class="source-inline">Observable</strong>, <strong class="source-inline">Flowable</strong>, <strong class="source-inline">Single</strong>, <strong class="source-inline">Maybe</strong>, and <strong class="source-inline">Completable</strong>. </p>
			<p>In the <strong class="source-inline">Observable</strong> and <strong class="source-inline">Flowable</strong> interfaces, the number of methods goes beyond 500. That is why, in this section, we are going to provide just an overview and a few examples that will help you to navigate the maze of possible options.</p>
			<p>We have grouped all the operators into 10 categories: transforming, filtering, combining, converting from XXX, exceptions handling, life cycle events handling, utilities, conditionals and Booleans, backpressure, and connectable.</p>
			<p>Please note that these are not all of the operators that are available. You can see more in the online documentation (<a href="http://reactivex.io/RxJava/2.x/javadoc/index.html">http://reactivex.io/RxJava/2.x/javadoc/index.html</a>).</p>
			<h3>Transforming</h3>
			<p>The<a id="_idIndexMarker1847"/> following operators transform the values emitted by an observable:</p>
			<ul>
				<li><strong class="source-inline">buffer()</strong>: This collects the emitted values into bundles according to the provided parameters or by using the provided functions. It periodically emits these bundles one at a time.</li>
				<li><strong class="source-inline">flatMap()</strong>: This produces observables based on the current observable and inserts them into the current flow; it is one of the most popular operators.</li>
				<li><strong class="source-inline">groupBy()</strong>: This divides the current <strong class="source-inline">Observable</strong> object into groups of observables (<strong class="source-inline">GroupedObservables</strong> objects).</li>
				<li><strong class="source-inline">map()</strong>: This transforms the emitted value using the provided function.</li>
				<li><strong class="source-inline">scan()</strong>: This applies the provided function to each value in combination with the value produced as the result of the previous application of the same function to the previous value.</li>
				<li><strong class="source-inline">window()</strong>: This emits groups of values similar to <strong class="source-inline">buffer()</strong> but as observables, each of which emits a subset of values from the original observable and then terminates with <strong class="source-inline">onCompleted()</strong>.</li>
			</ul>
			<p>The following code <a id="_idIndexMarker1848"/>demonstrates the use of <strong class="source-inline">map()</strong>, <strong class="source-inline">flatMap()</strong>, and <strong class="source-inline">groupBy()</strong> (see the <strong class="source-inline">NonBlockingOperators</strong> class and the <strong class="source-inline">transforming()</strong> method):</p>
			<pre class="source-code">Observable&lt;String&gt; obs = Observable.fromArray("one", "two");</pre>
			<pre class="source-code">obs.map(s -&gt; s.contains("w") ? 1 : 0)</pre>
			<pre class="source-code">   .forEach(System.out::print);              //prints: 01</pre>
			<pre class="source-code">System.out.println();</pre>
			<pre class="source-code">List&lt;String&gt; os = new ArrayList&lt;&gt;();</pre>
			<pre class="source-code">List&lt;String&gt; noto = new ArrayList&lt;&gt;();</pre>
			<pre class="source-code">obs.flatMap(s -&gt; Observable.fromArray(s.split("")))</pre>
			<pre class="source-code">        .groupBy(s -&gt; "o".equals(s) ? "o" : "noto")</pre>
			<pre class="source-code">        .subscribe(g -&gt; g.subscribe(s -&gt; {</pre>
			<pre class="source-code">            if (g.getKey().equals("o")) {</pre>
			<pre class="source-code">                os.add(s);</pre>
			<pre class="source-code">            } else {</pre>
			<pre class="source-code">                noto.add(s);</pre>
			<pre class="source-code">            }</pre>
			<pre class="source-code">        }));</pre>
			<pre class="source-code">System.out.println(os);                  //prints: [o, o]</pre>
			<pre class="source-code">System.out.println(noto);                //prints: [n, e, t, w]</pre>
			<h3>Filtering </h3>
			<p>The <a id="_idIndexMarker1849"/>following operators (and their multiple overloaded versions) select which of the values will continue to flow through the pipeline:</p>
			<ul>
				<li><strong class="source-inline">debounce()</strong>: This emits a value only when a specified span of time has passed without the observable emitting another value.</li>
				<li><strong class="source-inline">distinct()</strong>: This selects unique values only.</li>
				<li><strong class="source-inline">elementAt(long n)</strong>: This emits only one value with the specified <strong class="source-inline">n</strong> position in the stream.</li>
				<li><strong class="source-inline">filter()</strong>: This emits only the values that match the specified criteria.</li>
				<li><strong class="source-inline">firstElement()</strong>: This emits the first value only.</li>
				<li><strong class="source-inline">ignoreElements()</strong>: This does not emit values; only the <strong class="source-inline">onComplete()</strong> signal goes through.</li>
				<li><strong class="source-inline">lastElement()</strong>: This emits the last value only.</li>
				<li><strong class="source-inline">sample()</strong>: This emits the most recent value emitted within the specified time interval.</li>
				<li><strong class="source-inline">skip(long n)</strong>: This skips the first <strong class="source-inline">n</strong> values.</li>
				<li><strong class="source-inline">take(long n)</strong>: This only emits the first <strong class="source-inline">n</strong> values.</li>
			</ul>
			<p>The following code showcases examples of some of the uses of the preceding operators (see the <strong class="source-inline">NonBlockingOperators</strong> class and the <strong class="source-inline">filtering()</strong> method):</p>
			<pre class="source-code">Observable&lt;String&gt; obs = Observable.just("onetwo")</pre>
			<pre class="source-code">        .flatMap(s -&gt; Observable.fromArray(s.split("")));</pre>
			<pre class="source-code">// obs emits "onetwo" as characters           </pre>
			<pre class="source-code">obs.map(s -&gt; {</pre>
			<pre class="source-code">            if("t".equals(s)){</pre>
			<pre class="source-code">               NonBlockingOperators.pauseMs(15);</pre>
			<pre class="source-code">            }</pre>
			<pre class="source-code">            return s;</pre>
			<pre class="source-code">        })</pre>
			<pre class="source-code">        .debounce(10, TimeUnit.MILLISECONDS)</pre>
			<pre class="source-code">        .forEach(System.out::print);               //prints: eo</pre>
			<pre class="source-code">obs.distinct().forEach(System.out::print);      //prints: onetw</pre>
			<pre class="source-code">obs.elementAt(3).subscribe(System.out::println);   //prints: t</pre>
			<pre class="source-code">obs.filter(s -&gt; s.equals("o"))</pre>
			<pre class="source-code">   .forEach(System.out::print);                    //prints: oo</pre>
			<pre class="source-code">obs.firstElement().subscribe(System.out::println); //prints: o</pre>
			<pre class="source-code">obs.ignoreElements().subscribe(() -&gt; </pre>
			<pre class="source-code">       System.out.println("Completed!"));  //prints: Completed!</pre>
			<pre class="source-code">Observable.interval(5, TimeUnit.MILLISECONDS)</pre>
			<pre class="source-code">   .sample(10, TimeUnit.MILLISECONDS)</pre>
			<pre class="source-code">   .subscribe(v -&gt; System.out.print(v + " ")); </pre>
			<pre class="source-code">                                            //prints: 1 3 4 6 8 </pre>
			<pre class="source-code">pauseMs(50);</pre>
			<h3>Combining</h3>
			<p>The <a id="_idIndexMarker1850"/>following operators (and their multiple overloaded versions) create a new observable using multiple source observables:</p>
			<ul>
				<li><strong class="source-inline">concat(src1, src2)</strong>: This creates an <strong class="source-inline">Observable</strong> object that emits all values of <strong class="source-inline">src1</strong> and then all values of <strong class="source-inline">src2</strong>.</li>
				<li><strong class="source-inline">combineLatest(src1, src2, combiner)</strong>: This creates an <strong class="source-inline">Observable</strong> object that emits a value emitted by either of the two sources combined with the latest value emitted by each source using the provided <strong class="source-inline">combiner</strong> function.</li>
				<li><strong class="source-inline">join(src2, leftWin, rightWin, combiner)</strong>: This combines the values emitted by two observables during the <strong class="source-inline">leftWin</strong> and <strong class="source-inline">rightWin</strong> time windows according to the <strong class="source-inline">combiner</strong> function.</li>
				<li><strong class="source-inline">merge()</strong>: This <a id="_idIndexMarker1851"/>combines multiple observables into one; in contrast to <strong class="source-inline">concat()</strong>, it might interleave them, whereas <strong class="source-inline">concat()</strong> never interleaves the emitted values from different observables.</li>
				<li><strong class="source-inline">startWith(T item)</strong>: This adds the specified value before emitting values from the source observable.</li>
				<li><strong class="source-inline">startWith(Observable&lt;T&gt; other)</strong>: This adds the values from the specified observable before emitting values from the source observable.</li>
				<li><strong class="source-inline">switchOnNext(Observable&lt;Observable&gt; observables)</strong>: This creates a new <strong class="source-inline">Observable</strong> object that emits the most-recently emitted values of the specified observables.</li>
				<li><strong class="source-inline">zip()</strong>: This combines the values of the specified observables using the provided function.</li>
			</ul>
			<p>The following code demonstrates the use of some of these operators (see the <strong class="source-inline">NonBlockingOperators</strong> class and the <strong class="source-inline">combined()</strong> method):</p>
			<pre class="source-code">Observable&lt;String&gt; obs1 = Observable.just("one")</pre>
			<pre class="source-code">             .flatMap(s -&gt; Observable.fromArray(s.split("")));</pre>
			<pre class="source-code">Observable&lt;String&gt; obs2 = Observable.just("two")</pre>
			<pre class="source-code">             .flatMap(s -&gt; Observable.fromArray(s.split("")));</pre>
			<pre class="source-code">Observable.concat(obs2, obs1, obs2)</pre>
			<pre class="source-code">          .subscribe(System.out::print);    //prints: twoonetwo</pre>
			<pre class="source-code">Observable.combineLatest(obs2, obs1, (x,y) -&gt; "("+x+y+")")</pre>
			<pre class="source-code">          .subscribe(System.out::print); //prints: (oo)(on)(oe)</pre>
			<pre class="source-code">System.out.println();</pre>
			<pre class="source-code">obs1.join(obs2, i -&gt; Observable.timer(5, </pre>
			<pre class="source-code">                TimeUnit.MILLISECONDS),i -&gt; Observable.timer(5, </pre>
			<pre class="source-code">                TimeUnit.MILLISECONDS),(x,y) -&gt; "("+x+y+")")</pre>
			<pre class="source-code">                                 .subscribe(System.out::print); </pre>
			<pre class="source-code">                 //prints: (ot)(nt)(et)(ow)(nw)(ew)(oo)(no)(eo)</pre>
			<pre class="source-code">Observable.merge(obs2, obs1, obs2)</pre>
			<pre class="source-code">          .subscribe(System.out::print);  </pre>
			<pre class="source-code">                       //prints: twoonetwo obs1.startWith("42")</pre>
			<pre class="source-code">    .subscribe(System.out::print);         //prints: 42one</pre>
			<pre class="source-code">Observable.zip(obs1, obs2, obs1,  (x,y,z) -&gt; "("+x+y+z+")")</pre>
			<pre class="source-code">          .subscribe(System.out::print); </pre>
			<pre class="source-code">                                      //prints: (oto)(nwn)(eoe) </pre>
			<h3>Converting from XXX</h3>
			<p>These operators are<a id="_idIndexMarker1852"/> pretty straightforward. Here is a list of from-XXX operators of the <strong class="source-inline">Observable</strong> class:</p>
			<ul>
				<li><strong class="source-inline">fromArray(T... items)</strong>: This creates an <strong class="source-inline">Observable</strong> object from a varargs.</li>
				<li><strong class="source-inline">fromCallable(Callable&lt;T&gt; supplier)</strong>: This creates an <strong class="source-inline">Observable</strong> object from a <strong class="source-inline">Callable</strong> function.</li>
				<li><strong class="source-inline">fromFuture(Future&lt;T&gt; future)</strong>: This creates an <strong class="source-inline">Observable</strong> object from a <strong class="source-inline">Future</strong> object.</li>
				<li><strong class="source-inline">fromFuture(Future&lt;T&gt; future, long timeout, TimeUnit unit)</strong>: This creates an <strong class="source-inline">Observable</strong> object from a <strong class="source-inline">Future</strong> object with the timeout parameters applied to the <strong class="source-inline">future</strong>.</li>
				<li><strong class="source-inline">fromFuture(Future&lt;T&gt; future, long timeout, TimeUnit unit, Scheduler scheduler)</strong>: This creates an <strong class="source-inline">Observable</strong> object from a <strong class="source-inline">Future</strong> object with the timeout parameters applied to the <strong class="source-inline">future</strong> and the<a id="_idIndexMarker1853"/> scheduler (note that <strong class="source-inline">Schedulers.io()</strong> is recommended; please see the <em class="italic">Multithreading (scheduler)</em> section).</li>
				<li><strong class="source-inline">fromFuture(Future&lt;T&gt; future, Scheduler scheduler)</strong>: This creates an <strong class="source-inline">Observable</strong> object from a <strong class="source-inline">Future</strong> object on the specified scheduler (note that <strong class="source-inline">Schedulers.io()</strong> is recommended; please see the <em class="italic">Multithreading (scheduler)</em> section).</li>
				<li><strong class="source-inline">fromIterable(Iterable&lt;T&gt; source)</strong>: This creates an <strong class="source-inline">Observable</strong> object from an iterable object (for example, <strong class="source-inline">List</strong>).</li>
				<li><strong class="source-inline">fromPublisher(Publisher&lt;T&gt; publisher)</strong>: This creates an <strong class="source-inline">Observable</strong> object, for example from a <strong class="source-inline">Publisher</strong> object.</li>
			</ul>
			<h3>Exceptions handling</h3>
			<p>The <strong class="source-inline">subscribe()</strong> operator <a id="_idIndexMarker1854"/>has an overloaded version that accepts the <strong class="source-inline">Consumer&lt;Throwable&gt;</strong> function, which handles exceptions raised anywhere in the pipeline. It works in a similar way to the all-embracing <strong class="source-inline">try-catch</strong> block. If you have this function passed into the <strong class="source-inline">subscribe()</strong> operator, you can be sure that is the only place where all exceptions will end up.</p>
			<p>However, if you need to handle the exceptions in the middle of the pipeline, the values flow can be<a id="_idIndexMarker1855"/> recovered and processed by the rest of the operators, that is, after the operator has thrown the exception. The following operators (and their multiple overloaded versions) can help with that:</p>
			<ul>
				<li><strong class="source-inline">onErrorXXX()</strong>: This resumes the provided sequence when an exception was caught; XXX indicates what the operator does: <strong class="source-inline">onErrorResumeNext()</strong>, <strong class="source-inline">onErrorReturn()</strong>, or <strong class="source-inline">onErrorReturnItem()</strong>.</li>
				<li><strong class="source-inline">retry()</strong>: This creates an <strong class="source-inline">Observable</strong> object that repeats the emissions emitted from the source; it resubscribes to the source <strong class="source-inline">Observable</strong> if it calls <strong class="source-inline">onError()</strong>.</li>
			</ul>
			<p>The demo code appears as follows (see the <strong class="source-inline">NonBlockingOperators</strong> class and the <strong class="source-inline">exceptions()</strong> method):</p>
			<pre class="source-code">Observable&lt;String&gt; obs = Observable.just("one")</pre>
			<pre class="source-code">              .flatMap(s -&gt; Observable.fromArray(s.split("")));</pre>
			<pre class="source-code">Observable.error(new RuntimeException("MyException"))</pre>
			<pre class="source-code">  .flatMap(x -&gt; Observable.fromArray("two".split("")))</pre>
			<pre class="source-code">  .subscribe(System.out::print,</pre>
			<pre class="source-code">      e -&gt; System.out.println(e.getMessage()) </pre>
			<pre class="source-code">                                          //prints: MyException</pre>
			<pre class="source-code">  );</pre>
			<pre class="source-code">Observable.error(new RuntimeException("MyException"))</pre>
			<pre class="source-code">          .flatMap(y -&gt; Observable.fromArray("two".split("")))</pre>
			<pre class="source-code">          .onErrorResumeNext(obs)</pre>
			<pre class="source-code">          .subscribe(System.out::print);          //prints: one</pre>
			<pre class="source-code">Observable.error(new RuntimeException("MyException"))</pre>
			<pre class="source-code">          .flatMap(z -&gt; Observable.fromArray("two".split("")))</pre>
			<pre class="source-code">          .onErrorReturnItem("42")</pre>
			<pre class="source-code">          .subscribe(System.out::print);          //prints: 42</pre>
			<h3>Life cycle events handling</h3>
			<p>These operators are<a id="_idIndexMarker1856"/> each invoked on a certain event that happened anywhere in the pipeline. They work similarly to the operators described in the <em class="italic">Exceptions handling</em> section.</p>
			<p>The format of these operators is <strong class="source-inline">doXXX()</strong>, where XXX is the name of the event: <strong class="source-inline">onComplete</strong>, <strong class="source-inline">onNext</strong>, <strong class="source-inline">onError</strong>, and similar. Not all of them are available in all the classes, and some of them are slightly different in <strong class="source-inline">Observable</strong>, <strong class="source-inline">Flowable</strong>, <strong class="source-inline">Single</strong>, <strong class="source-inline">Maybe</strong>, or <strong class="source-inline">Completable</strong>. However, we do not have space to list all the variations of all these classes and will limit our overview to a few examples of the life cycle events-handling operators of the <strong class="source-inline">Observable</strong> class:</p>
			<ul>
				<li><strong class="source-inline">doOnSubscribe(Consumer&lt;Disposable&gt; onSubscribe)</strong>: This executes when an observer subscribes.</li>
				<li><strong class="source-inline">doOnNext(Consumer&lt;T&gt; onNext)</strong>: This applies the provided <strong class="source-inline">Consumer</strong> function when the source observable calls <strong class="source-inline">onNext</strong>.</li>
				<li><strong class="source-inline">doAfterNext(Consumer&lt;T&gt; onAfterNext)</strong>: This applies the provided <strong class="source-inline">Consumer</strong> function to the current value after it is pushed downstream.</li>
				<li><strong class="source-inline">doOnEach(Consumer&lt;Notification&lt;T&gt;&gt; onNotification)</strong>: This executes the <strong class="source-inline">Consumer</strong> function for each emitted value.</li>
				<li><strong class="source-inline">doOnEach(Observer&lt;T&gt; observer)</strong>: This notifies an <strong class="source-inline">Observer</strong> object for each emitted value and the terminal event it emits.</li>
				<li><strong class="source-inline">doOnComplete(Action onComplete)</strong>: This executes the provided <strong class="source-inline">Action</strong> function after the source observable generates the <strong class="source-inline">onComplete</strong> event.</li>
				<li><strong class="source-inline">doOnDispose(Action onDispose)</strong>: This executes the provided <strong class="source-inline">Action</strong> function after the pipeline was disposed of downstream.</li>
				<li><strong class="source-inline">doOnError(Consumer&lt;Throwable&gt; onError)</strong>: This executes when the <strong class="source-inline">onError</strong> event is sent.</li>
				<li><strong class="source-inline">doOnLifecycle(Consumer&lt;Disposable&gt; onSubscribe, Action onDispose)</strong>: This calls the corresponding <strong class="source-inline">onSubscribe</strong> or <strong class="source-inline">onDispose</strong> function for the corresponding event.</li>
				<li><strong class="source-inline">doOnTerminate(Action onTerminate)</strong>: This executes the provided <strong class="source-inline">Action</strong> function <a id="_idIndexMarker1857"/>when the source observable generates the <strong class="source-inline">onComplete</strong> event or an exception (the <strong class="source-inline">onError</strong> event) is raised.</li>
				<li><strong class="source-inline">doAfterTerminate(Action onFinally)</strong>: This executes the provided <strong class="source-inline">Action</strong> function after the source observable generates the <strong class="source-inline">onComplete</strong> event or an exception (the <strong class="source-inline">onError</strong> event) is raised.</li>
				<li><strong class="source-inline">doFinally(Action onFinally)</strong>: This executes the provided <strong class="source-inline">Action</strong> function after the source observable generates the <strong class="source-inline">onComplete</strong> event or an exception (the <strong class="source-inline">onError</strong> event) is raised, or the pipeline was disposed of downstream.</li>
			</ul>
			<p>Here is demo code (see the <strong class="source-inline">NonBlockingOperators</strong> class and the <strong class="source-inline">events()</strong> method):</p>
			<pre class="source-code">Observable&lt;String&gt; obs = Observable.just("one")</pre>
			<pre class="source-code">            .flatMap(s -&gt; Observable.fromArray(s.split("")));</pre>
			<pre class="source-code">obs.doOnComplete(() -&gt; System.out.println("Completed!")) </pre>
			<pre class="source-code">        .subscribe(v -&gt; {</pre>
			<pre class="source-code">            System.out.println("Subscribe onComplete: " + v);</pre>
			<pre class="source-code">        });        </pre>
			<pre class="source-code">pauseMs(25);</pre>
			<p>If we run<a id="_idIndexMarker1858"/> this code, the output will be as follows:</p>
			<div>
				<div id="_idContainer175" class="IMG---Figure">
					<img src="image/B18388_Figure_15.10.jpg" alt=""/>
				</div>
			</div>
			<p>You will also see other examples of these operators’ usage in the <em class="italic">Multithreading (scheduler)</em> section.</p>
			<h3>Utilities</h3>
			<p>Various<a id="_idIndexMarker1859"/> useful operators (and their multiple overloaded versions) can be used for controlling the pipeline behavior:</p>
			<ul>
				<li><strong class="source-inline">delay()</strong>: This delays the emission for a specified period.</li>
				<li><strong class="source-inline">materialize()</strong>: This creates an <strong class="source-inline">Observable</strong> object that represents both the emitted values and the notifications sent.</li>
				<li><strong class="source-inline">dematerialize()</strong>: This reverses the result of the <strong class="source-inline">materialize()</strong> operator.</li>
				<li><strong class="source-inline">observeOn()</strong>: This specifies the <strong class="source-inline">Scheduler</strong> (thread) on which the <strong class="source-inline">Observer</strong> should observe the <strong class="source-inline">Observable</strong> object (see the <em class="italic">Multithreading (scheduler)</em> section).</li>
				<li><strong class="source-inline">serialize()</strong>: This forces the serialization of the emitted values and notifications.</li>
				<li><strong class="source-inline">subscribe()</strong>: This subscribes to the emissions and notifications from an observable; various overloaded versions accept callbacks used for a variety of events, including <strong class="source-inline">onComplete</strong> and <strong class="source-inline">onError</strong>; only after <strong class="source-inline">subscribe()</strong> is invoked do the the <a id="_idIndexMarker1860"/>values start flowing through the pipeline.</li>
				<li><strong class="source-inline">subscribeOn()</strong>: This subscribes the <strong class="source-inline">Observer</strong> to the <strong class="source-inline">Observable</strong> object asynchronously using the specified <strong class="source-inline">Scheduler</strong> (see the <em class="italic">Multithreading (scheduler)</em> section).</li>
				<li><strong class="source-inline">timeInterval(), timestamp()</strong>: This converts an <strong class="source-inline">Observable&lt;T&gt;</strong> class that emits values into <strong class="source-inline">Observable&lt;Timed&lt;T&gt;&gt;</strong>, which, in turn, emits the amount of time elapsed between the emissions or the timestamp correspondingly.</li>
				<li><strong class="source-inline">timeout()</strong>: This repeats the emissions of the source <strong class="source-inline">Observable</strong>; it generates an error if no emissions happen after the specified period of time.</li>
				<li><strong class="source-inline">using()</strong>: This creates a resource that is disposed of automatically along with the <strong class="source-inline">Observable</strong> object; it works similarly to the try-with-resources construct.</li>
			</ul>
			<p>The following code contains examples of some of these operators being used in a pipeline (see the <strong class="source-inline">NonBlockingOperators</strong> class and the <strong class="source-inline">utilities()</strong> method):</p>
			<pre class="source-code">Observable&lt;String&gt; obs = Observable.just("one")</pre>
			<pre class="source-code">          .flatMap(s -&gt; Observable.fromArray(s.split("")));</pre>
			<pre class="source-code">obs.delay(5, TimeUnit.MILLISECONDS)</pre>
			<pre class="source-code">   .subscribe(System.out::print);           //prints: one</pre>
			<pre class="source-code">pauseMs(10);</pre>
			<pre class="source-code">System.out.println(); //used here just to break the line</pre>
			<pre class="source-code">Observable source = Observable.range(1,5);</pre>
			<pre class="source-code">Disposable disposable = source.subscribe();</pre>
			<pre class="source-code">Observable.using(</pre>
			<pre class="source-code">  () -&gt; disposable,</pre>
			<pre class="source-code">  x -&gt; source,</pre>
			<pre class="source-code">  y -&gt; System.out.println("Disposed: " + y) </pre>
			<pre class="source-code">                               //prints: Disposed: DISPOSED</pre>
			<pre class="source-code">)</pre>
			<pre class="source-code">.delay(10, TimeUnit.MILLISECONDS)</pre>
			<pre class="source-code">.subscribe(System.out::print);              //prints: 12345</pre>
			<pre class="source-code">pauseMs(25);</pre>
			<p>If we run all<a id="_idIndexMarker1861"/> these examples, the output will appear as follows:</p>
			<div>
				<div id="_idContainer176" class="IMG---Figure">
					<img src="image/B18388_Figure_15.11.jpg" alt=""/>
				</div>
			</div>
			<p>As you can see, when completed, the pipeline sends the <strong class="source-inline">DISPOSED</strong> signal to the <strong class="source-inline">using</strong> operator (the third parameter), so the <strong class="source-inline">Consumer</strong> function we pass as the third parameter can dispose of the resources used by the pipeline. </p>
			<h3>Conditional and Boolean</h3>
			<p>The<a id="_idIndexMarker1862"/> following operators (and their multiple overloaded versions) allow you to<a id="_idIndexMarker1863"/> the evaluate one or more observables or emitted values and change the logic of the processing accordingly:</p>
			<ul>
				<li><strong class="source-inline">all(Predicate criteria)</strong>: This returns <strong class="source-inline">Single&lt;Boolean&gt;</strong> with a <strong class="source-inline">true</strong> value, that is, if all the emitted values match the provided criteria.</li>
				<li><strong class="source-inline">amb()</strong>: This accepts two or more source observables and emits values from only the first of them that starts emitting.</li>
				<li><strong class="source-inline">contains(Object value)</strong>: This returns <strong class="source-inline">Single&lt;Boolean&gt;</strong> with <strong class="source-inline">true</strong>, that is, if the observable emits the provided value.</li>
				<li><strong class="source-inline">defaultIfEmpty(T value)</strong>: This emits the provided value if the source <strong class="source-inline">Observable</strong> does not emit anything.</li>
				<li><strong class="source-inline">sequenceEqual()</strong>: This returns <strong class="source-inline">Single&lt;Boolean&gt;</strong> with <strong class="source-inline">true</strong>, that is, if the provided sources emit the same sequence; an overloaded version allows us to provide the equality function used for comparison.</li>
				<li><strong class="source-inline">skipUntil(Observable other)</strong>: This discards emitted values until the provided <strong class="source-inline">Observable other</strong> emits a value.</li>
				<li><strong class="source-inline">skipWhile(Predicate condition)</strong>: This discards emitted values as long as the provided condition remains <strong class="source-inline">true</strong>.</li>
				<li><strong class="source-inline">takeUntil(Observable other)</strong>: This discards emitted values after the provided <strong class="source-inline">Observable other</strong> emits a value.</li>
				<li><strong class="source-inline">takeWhile(Predicate condition)</strong>: This discards emitted values after the provided condition becomes <strong class="source-inline">false</strong>.</li>
			</ul>
			<p>The<a id="_idIndexMarker1864"/> following <a id="_idIndexMarker1865"/>code contains a few demo examples (see the <strong class="source-inline">NonBlockingOperators</strong> class and the <strong class="source-inline">conditional()</strong> method):</p>
			<pre class="source-code">Observable&lt;String&gt; obs = Observable.just("one")</pre>
			<pre class="source-code">              .flatMap(s -&gt; Observable.fromArray(s.split("")));</pre>
			<pre class="source-code">Single&lt;Boolean&gt; cont = obs.contains("n");</pre>
			<pre class="source-code">System.out.println(cont.blockingGet());          //prints: true</pre>
			<pre class="source-code">obs.defaultIfEmpty("two")</pre>
			<pre class="source-code">   .subscribe(System.out::print);                 //prints: one</pre>
			<pre class="source-code">Observable.empty().defaultIfEmpty("two")</pre>
			<pre class="source-code">          .subscribe(System.out::print);          //prints: two</pre>
			<pre class="source-code">Single&lt;Boolean&gt; equal = Observable.sequenceEqual(obs, </pre>
			<pre class="source-code">                                 Observable.just("one"));</pre>
			<pre class="source-code">System.out.println(equal.blockingGet());        //prints: false</pre>
			<pre class="source-code">equal = Observable.sequenceEqual(Observable.just("one"), </pre>
			<pre class="source-code">                                 Observable.just("one"));</pre>
			<pre class="source-code">System.out.println(equal.blockingGet());         //prints: true</pre>
			<pre class="source-code">equal = Observable.sequenceEqual(Observable.just("one"), </pre>
			<pre class="source-code">                                 Observable.just("two"));</pre>
			<pre class="source-code">System.out.println(equal.blockingGet());        //prints: false</pre>
			<h3>Backpressure</h3>
			<p>So, we discussed <a id="_idIndexMarker1866"/>and demonstrated the <strong class="bold">backpressure</strong> effect and the possible drop strategy in the <em class="italic">Cold versus hot</em> section. The other strategy might be as follows:</p>
			<pre class="source-code">Flowable&lt;Double&gt; obs = Flowable.fromArray(1.,2.,3.);</pre>
			<pre class="source-code">obs.onBackpressureBuffer().subscribe();</pre>
			<pre class="source-code">//or</pre>
			<pre class="source-code">obs.onBackpressureLatest().subscribe();</pre>
			<p>The buffering strategy allows you to define the buffer size and provide a function that can be executed if the buffer overflows. The latest strategy tells the values producer to pause (when the consumer cannot process the emitted values on time) and emit the next value on request.</p>
			<p>Note that the backpressure operators are available only in the <strong class="source-inline">Flowable</strong> class.</p>
			<h3>Connectable </h3>
			<p>The operators <a id="_idIndexMarker1867"/>of this category allow us to connect observables and, thus, achieve more precisely controlled subscription dynamics:</p>
			<ul>
				<li><strong class="source-inline">publish()</strong>: This converts an <strong class="source-inline">Observable</strong> object into a <strong class="source-inline">ConnectableObservable</strong> object.</li>
				<li><strong class="source-inline">replay()</strong>: This returns a <strong class="source-inline">ConnectableObservable</strong> object that repeats all the emitted values and notifications every time a new <strong class="source-inline">Observer</strong> subscribes.</li>
				<li><strong class="source-inline">connect()</strong>: This instructs a <strong class="source-inline">ConnectableObservable</strong> object to begin emitting values to the subscribers.</li>
				<li><strong class="source-inline">refCount()</strong>: This converts a <strong class="source-inline">ConnectableObservable</strong> object into an <strong class="source-inline">Observable</strong> object.</li>
			</ul>
			<p>We have <a id="_idIndexMarker1868"/>demonstrated how <strong class="source-inline">ConnectableObservable</strong> works in the <em class="italic">Cold versus hot</em> section. One principal difference between <strong class="source-inline">ConnectableObservable</strong> and <strong class="source-inline">Observable</strong> is that <strong class="source-inline">ConnectableObservable</strong> does not start emitting values until its <strong class="source-inline">connect</strong> operator has been called.</p>
			<h2 id="_idParaDest-335"><a id="_idTextAnchor334"/>Multithreading (scheduler)</h2>
			<p>By <a id="_idIndexMarker1869"/>default, RxJava <a id="_idIndexMarker1870"/>is single-threaded. This means that the source observable and all its operators notify the observers on the same thread that <a id="_idIndexMarker1871"/>the <strong class="source-inline">subscribe()</strong> operator is called.</p>
			<p>Тhere are two operators, <strong class="source-inline">observeOn()</strong> and <strong class="source-inline">subscribeOn()</strong>, that allow you to move the execution of individual actions to a different thread. These methods take a <strong class="source-inline">Scheduler</strong> object as an argument that, well, schedules the individual actions to be executed on a different thread.</p>
			<p>The <strong class="source-inline">subscribeOn()</strong> operator<a id="_idIndexMarker1872"/> declares which scheduler should emit the values.</p>
			<p>The <strong class="source-inline">observeOn()</strong> operator <a id="_idIndexMarker1873"/>declares which scheduler should observe and process values.</p>
			<p>The <strong class="source-inline">Schedulers</strong> class contains factory methods that create <strong class="source-inline">Scheduler</strong> objects with different life cycles and performance configurations:</p>
			<ul>
				<li><strong class="source-inline">computation()</strong>: This creates a scheduler based on a bounded thread pool with a size up to the number of available processors; it should be used for CPU-intensive computations. Use <strong class="source-inline">Runtime.getRuntime().availableProcessors()</strong> to avoid using more of these types of schedulers than available processors; otherwise, the performance might become degraded because of the overhead of the thread-context switching.</li>
				<li><strong class="source-inline">io()</strong>: This <a id="_idIndexMarker1874"/>creates a scheduler based on an unbounded <a id="_idIndexMarker1875"/>thread pool used for I/O-related work, such as working with files and databases in general when the interaction with the source is blocking by nature; avoid using it otherwise because it might spin too many threads and negatively affect performance and memory usage.</li>
				<li><strong class="source-inline">newThread()</strong>: This creates a new thread every time and does not use any pool; it is an expensive way to create a thread, so you are expected to know exactly what the reason is for using it.</li>
				<li><strong class="source-inline">single()</strong>: This creates a scheduler based on a single thread that executes all the tasks sequentially; this is useful when the sequence of the execution matters.</li>
				<li><strong class="source-inline">trampoline()</strong>: This creates a scheduler that executes tasks in a first-in-first-out manner; this is useful for executing recursive algorithms.</li>
				<li><strong class="source-inline">from(Executor executor)</strong>: This creates a scheduler based on the provided executor (thread pool), which allows for better control over the max number of threads and their life cycles. </li>
			</ul>
			<p>In <a href="B18388_08_ePub.xhtml#_idTextAnchor187"><em class="italic">Chapter 8</em></a>, <em class="italic">Multithreading and Concurrent Processing</em>, we talked about thread pools. To remind you, here are the pools we discussed:</p>
			<pre class="source-code">          Executors.newCachedThreadPool();</pre>
			<pre class="source-code">          Executors.newSingleThreadExecutor();</pre>
			<pre class="source-code">          Executors.newFixedThreadPool(int nThreads);</pre>
			<pre class="source-code">          Executors.newScheduledThreadPool(int poolSize);</pre>
			<pre class="source-code">          Executors.newWorkStealingPool(int parallelism);</pre>
			<p>As you can see, some of the other factory methods of the <strong class="source-inline">Schedulers</strong> class are backed by one of these thread pools, and they serve as just a simpler and shorter expression of a thread pool declaration. To make the examples simpler and more comparable, we are only going to use a <strong class="source-inline">computation()</strong> scheduler. Let’s look at the basics of parallel/concurrent processing in RxJava.</p>
			<p>The following code<a id="_idIndexMarker1876"/> is an example of <a id="_idIndexMarker1877"/>delegating CPU-intensive calculations to dedicated threads (see the <strong class="source-inline">Scheduler</strong> class and the <strong class="source-inline">parallel1()</strong> method):</p>
			<pre class="source-code">Observable.fromArray("one","two","three")</pre>
			<pre class="source-code">          .doAfterNext(s -&gt; System.out.println("1: " + </pre>
			<pre class="source-code">                Thread.currentThread().getName() + " =&gt; " + s))</pre>
			<pre class="source-code">          .flatMap(w -&gt; Observable.fromArray(w.split(""))</pre>
			<pre class="source-code">                           .observeOn(Schedulers.computation())</pre>
			<pre class="source-code">              //.flatMap(s -&gt; {             </pre>
			<pre class="source-code">              //      CPU-intensive calculations go here</pre>
			<pre class="source-code">              // }  </pre>
			<pre class="source-code">                .doAfterNext(s -&gt; System.out.println("2: " + </pre>
			<pre class="source-code">                Thread.currentThread().getName() + " =&gt; " + s))</pre>
			<pre class="source-code">          )</pre>
			<pre class="source-code">          .subscribe(s -&gt; System.out.println("3: " + s));</pre>
			<pre class="source-code">pauseMs(100);</pre>
			<p>In this example, we decided to create a sub-flow of characters from each emitted word and let a dedicated thread process the characters of each word. The output of this example appears as follows:</p>
			<div>
				<div id="_idContainer177" class="IMG---Figure">
					<img src="image/B18388_Figure_15.12.jpg" alt=""/>
				</div>
			</div>
			<p>As you can see, the<a id="_idIndexMarker1878"/> main thread was used to emit the words, and the characters of each word<a id="_idIndexMarker1879"/> were processed by a dedicated thread. Please note that although in this example the sequence of the results coming to the <strong class="source-inline">subscribe()</strong> operation corresponds to the sequence the words and characters were emitted, in real-life cases, the calculation time of each value will not be the same. So, there is no guarantee that the results will come in the same sequence.</p>
			<p>If needed, we can put each word emission on a dedicated non-main thread too, so the main thread can be free to do anything else. For example, note the following (see the <strong class="source-inline">Scheduler</strong> class and the <strong class="source-inline">parallel2()</strong> method):</p>
			<pre class="source-code">Observable.fromArray("one","two","three")</pre>
			<pre class="source-code">        .observeOn(Schedulers.computation())</pre>
			<pre class="source-code">        .doAfterNext(s -&gt; System.out.println("1: " + </pre>
			<pre class="source-code">                Thread.currentThread().getName() + " =&gt; " + s))</pre>
			<pre class="source-code">        .flatMap(w -&gt; Observable.fromArray(w.split(""))</pre>
			<pre class="source-code">                .observeOn(Schedulers.computation())</pre>
			<pre class="source-code">                .doAfterNext(s -&gt; System.out.println("2: " + </pre>
			<pre class="source-code">                Thread.currentThread().getName() + " =&gt; " + s))</pre>
			<pre class="source-code">        )</pre>
			<pre class="source-code">        .subscribe(s -&gt; System.out.println("3: " + s));</pre>
			<pre class="source-code">pauseMs(100);</pre>
			<p>The output<a id="_idIndexMarker1880"/> of this example is as follows:</p>
			<div>
				<div id="_idContainer178" class="IMG---Figure">
					<img src="image/B18388_Figure_15.13.jpg" alt=""/>
				</div>
			</div>
			<p>As you<a id="_idIndexMarker1881"/> can see, the main thread no longer emits the words.</p>
			<p>In RxJava 2.0.5, a new, simpler way of parallel processing was introduced, similar to parallel processing in the standard Java 8 streams. Using <strong class="source-inline">ParallelFlowable</strong>, the same functionality can be achieved as follows (see the <strong class="source-inline">Scheduler</strong> class and the <strong class="source-inline">parallel3()</strong> method):</p>
			<pre class="source-code">ParallelFlowable src = </pre>
			<pre class="source-code">            Flowable.fromArray("one","two","three").parallel();</pre>
			<pre class="source-code">src.runOn(Schedulers.computation())</pre>
			<pre class="source-code">   .doAfterNext(s -&gt; System.out.println("1: " + </pre>
			<pre class="source-code">                Thread.currentThread().getName() + " =&gt; " + s))</pre>
			<pre class="source-code">   .flatMap(w -&gt; Flowable.fromArray(((String)w).split("")))</pre>
			<pre class="source-code">   .runOn(Schedulers.computation())</pre>
			<pre class="source-code">   .doAfterNext(s -&gt; System.out.println("2: " + </pre>
			<pre class="source-code">                Thread.currentThread().getName() + " =&gt; " + s))</pre>
			<pre class="source-code">   .sequential()</pre>
			<pre class="source-code">   .subscribe(s -&gt; System.out.println("3: " + s));</pre>
			<pre class="source-code">pauseMs(100);</pre>
			<p>As <a id="_idIndexMarker1882"/>you can see, the <strong class="source-inline">ParallelFlowable</strong> object is created by applying the <strong class="source-inline">parallel()</strong> operator to the regular <strong class="source-inline">Flowable</strong> operator. Then, the <strong class="source-inline">runOn()</strong> operator <a id="_idIndexMarker1883"/>tells the created observable to use the <strong class="source-inline">computation()</strong> scheduler to emit the values. Please note that there is no need to set another scheduler (for processing the characters) inside the <strong class="source-inline">flatMap()</strong> operator. It can be set outside it – just in the main pipeline, which makes the code simpler. The result looks like this:</p>
			<p class="figure-caption"><img src="image/B18388_Figure_15.14.png" alt="Text&#10;&#10;Description automatically generated"/></p>
			<p>As for the <strong class="source-inline">subscribeOn()</strong> operator, its location in the pipeline does not play any role. Wherever<a id="_idIndexMarker1884"/> it is <a id="_idIndexMarker1885"/>placed, it still tells the observable which scheduler should emit the values. Here is an example (see the <strong class="source-inline">Scheduler</strong> class and the <strong class="source-inline">subscribeOn1()</strong> method):</p>
			<pre class="source-code">Observable.just("a", "b", "c")</pre>
			<pre class="source-code">          .doAfterNext(s -&gt; System.out.println("1: " + </pre>
			<pre class="source-code">                Thread.currentThread().getName() + " =&gt; " + s))</pre>
			<pre class="source-code">          .subscribeOn(Schedulers.computation())</pre>
			<pre class="source-code">          .subscribe(s -&gt; System.out.println("2: " + </pre>
			<pre class="source-code">               Thread.currentThread().getName() + " =&gt; " + s));</pre>
			<pre class="source-code">pauseMs(100);</pre>
			<p>The result looks like this:</p>
			<div>
				<div id="_idContainer180" class="IMG---Figure">
					<img src="image/B18388_Figure_15.15.jpg" alt=""/>
				</div>
			</div>
			<p>Even if we <a id="_idIndexMarker1886"/>change the location of the <strong class="source-inline">subscribeOn()</strong> operator, as shown in the following example, the result does not change (see the <strong class="source-inline">Scheduler</strong> class and the <strong class="source-inline">subscribeOn2()</strong> method):</p>
			<pre class="source-code">Observable.just("a", "b", "c")</pre>
			<pre class="source-code">          .subscribeOn(Schedulers.computation())</pre>
			<pre class="source-code">          .doAfterNext(s -&gt; System.out.println("1: " + </pre>
			<pre class="source-code">                Thread.currentThread().getName() + " =&gt; " + s))</pre>
			<pre class="source-code">          .subscribe(s -&gt; System.out.println("2: " + </pre>
			<pre class="source-code">               Thread.currentThread().getName() + " =&gt; " + s));</pre>
			<pre class="source-code">pauseMs(100);</pre>
			<p>Finally, here <a id="_idIndexMarker1887"/>is the example with both operators (see the <strong class="source-inline">Scheduler</strong> class and the <strong class="source-inline">subscribeOnAndObserveOn()</strong> method):</p>
			<pre class="source-code">Observable.just("a", "b", "c")</pre>
			<pre class="source-code">          .subscribeOn(Schedulers.computation())</pre>
			<pre class="source-code">          .doAfterNext(s -&gt; System.out.println("1: " + </pre>
			<pre class="source-code">                Thread.currentThread().getName() + " =&gt; " + s))</pre>
			<pre class="source-code">          .observeOn(Schedulers.computation())</pre>
			<pre class="source-code">          .subscribe(s -&gt; System.out.println("2: " + </pre>
			<pre class="source-code">               Thread.currentThread().getName() + " =&gt; " + s));</pre>
			<pre class="source-code">pauseMs(100);</pre>
			<p>Now the result shows that two threads are used: one for subscribing and another for observing:</p>
			<div>
				<div id="_idContainer181" class="IMG---Figure">
					<img src="image/B18388_Figure_15.16.jpg" alt=""/>
				</div>
			</div>
			<p>This <a id="_idIndexMarker1888"/>concludes<a id="_idIndexMarker1889"/> our short overview of RxJava, which is a big and still-growing library with a lot of possibilities, many of which we just did not have space in this book to review. We encourage you to try and learn it because it seems that reactive programming is the way modern data processing is heading.</p>
			<p>In the following chapters, we will demonstrate how to build reactive applications (microservices) using Spring Boot and Vert.x.</p>
			<h1 id="_idParaDest-336"><a id="_idTextAnchor335"/>Summary</h1>
			<p>In this chapter, you learned what reactive programming is and what its main concepts are: asynchronous, non-blocking, responsive, and more. Reactive streams were introduced and explained in simple terms, along with the RxJava library, which is the first solid implementation that supports reactive programming principles.</p>
			<p>Now you can write code for asynchronous processing using reactive programming.</p>
			<p>In the next chapter, we will talk about microservices as the foundation for creating reactive systems, and we will review another library that successfully supports reactive programming: <strong class="bold">Vert.x</strong>. We will use it to demonstrate how various microservices can be built.</p>
			<h1 id="_idParaDest-337"><a id="_idTextAnchor336"/>Quiz</h1>
			<ol>
				<li>Select all the correct statements:<ol><li>Asynchronous processing always provides results later.</li><li>Asynchronous processing always provides responses quickly.</li><li>Asynchronous processing can use parallel processing.</li><li>Asynchronous processing always provides results faster than a blocking call.</li></ol></li>
				<li>Can <strong class="source-inline">CompletableFuture</strong> be used without using a thread pool?</li>
				<li>What does the <em class="italic">nio</em> in <strong class="source-inline">java.nio</strong> stand for?</li>
				<li>Is an <strong class="source-inline">event</strong> loop the only design that supports a non-blocking API?</li>
				<li>What does the <em class="italic">Rx</em> in RxJava stand for?</li>
				<li>Which Java package of the <strong class="bold">Java Class Library</strong> (<strong class="bold">JCL</strong>) supports reactive streams?</li>
				<li>Select all classes from the following list that can represent an observable in a reactive stream:<ol><li><strong class="source-inline">Flowable</strong></li><li><strong class="source-inline">Probably</strong></li><li><strong class="source-inline">CompletableFuture</strong></li><li><strong class="source-inline">Single</strong></li></ol></li>
				<li>How do you know that a particular method (operator) of the <strong class="source-inline">Observable</strong> class is blocking?</li>
				<li>What is the difference between a cold and a hot observable?</li>
				<li>The <strong class="source-inline">subscribe()</strong> method of <strong class="source-inline">Observable</strong> returns a <strong class="source-inline">Disposable</strong> object. What happens when the <strong class="source-inline">dispose()</strong> method is called on this object?</li>
				<li>Select all the names of the methods that create an <strong class="source-inline">Observable</strong> object:<ol><li><strong class="source-inline">interval()</strong></li><li><strong class="source-inline">new()</strong></li><li><strong class="source-inline">generate()</strong></li><li><strong class="source-inline">defer()</strong></li></ol></li>
				<li>Name two transforming <strong class="source-inline">Observable</strong> operators.</li>
				<li>Name two filtering <strong class="source-inline">Observable</strong> operators.</li>
				<li>Name two backpressure-processing strategies.</li>
				<li>Name two <strong class="source-inline">Observable</strong> operators that allow you to add threads to the pipeline processing.</li>
			</ol>
		</div>
	</body></html>