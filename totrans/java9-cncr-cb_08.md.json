["```java\n        public class MyExecutor extends ThreadPoolExecutor {\n\n```", "```java\n        private final ConcurrentHashMap<Runnable, Date> startTimes;\n\n```", "```java\n        public MyExecutor(int corePoolSize, int maximumPoolSize,\n                          long keepAliveTime, TimeUnit unit,\n                          BlockingQueue<Runnable> workQueue) {\n          super(corePoolSize, maximumPoolSize, keepAliveTime, unit,\n                workQueue);\n          startTimes=new ConcurrentHashMap<>();\n        }\n\n```", "```java\n        @Override \n        public void shutdown() { \n          System.out.printf(\"MyExecutor: Going to shutdown.\\n\"); \n          System.out.printf(\"MyExecutor: Executed tasks: %d\\n\",\n                            getCompletedTaskCount());\n\n```", "```java\n          System.out.printf(\"MyExecutor: Running tasks: %d\\n\",\n                            getActiveCount());                                      System.out.printf(\"MyExecutor: Pending tasks: %d\\n\",\n                            getQueue().size()); \n          super.shutdown(); \n        }\n\n```", "```java\n        @Override \n        public List<Runnable> shutdownNow() { \n          System.out.printf(\"MyExecutor: Going to immediately\n                            shutdown.\\n\"); \n          System.out.printf(\"MyExecutor: Executed tasks: %d\\n\",\n                            getCompletedTaskCount()); \n          System.out.printf(\"MyExecutor: Running tasks: %d\\n\",\n                            getActiveCount()); \n          System.out.printf(\"MyExecutor: Pending tasks: %d\\n\",\n                            getQueue().size()); \n          return super.shutdownNow(); \n        }\n\n```", "```java\n        @Override \n        protected void beforeExecute(Thread t, Runnable r) { \n          System.out.printf(\"MyExecutor: A task is beginning: %s : %s\\n\",\n                                t.getName(),r.hashCode()); \n          startTimes.put(r, new Date()); \n        }\n\n```", "```java\n          @Override \n          protected void afterExecute(Runnable r, Throwable t) { \n            Future<?> result=(Future<?>)r; \n            try { \n              System.out.printf(\"*********************************\\n\"); \n              System.out.printf(\"MyExecutor: A task is finishing.\\n\"); \n\n```", "```java\n              System.out.printf(\"MyExecutor: Result: %s\\n\",\n                                result.get()); \n              Date startDate=startTimes.remove(r); \n              Date finishDate=new Date(); \n              long diff=finishDate.getTime()-startDate.getTime(); \n              System.out.printf(\"MyExecutor: Duration: %d\\n\",diff); \n              System.out.printf(\"*********************************\\n\"); \n            } catch (InterruptedException | ExecutionException e) { \n              e.printStackTrace(); \n            } \n          } \n        }\n\n```", "```java\n        public class SleepTwoSecondsTask implements Callable<String> { \n\n          public String call() throws Exception { \n            TimeUnit.SECONDS.sleep(2); \n            return new Date().toString(); \n          } \n\n        }\n\n```", "```java\n        public class Main { \n          public static void main(String[] args) {\n\n```", "```java\n        MyExecutor myExecutor=new MyExecutor(4, 8, 1000,\n                                  TimeUnit.MILLISECONDS,\n                                  new LinkedBlockingDeque<Runnable>());\n\n```", "```java\n        List<Future<String>> results=new ArrayList<>();\n\n```", "```java\n        for (int i=0; i<10; i++) { \n          SleepTwoSecondsTask task=new SleepTwoSecondsTask(); \n          Future<String> result=myExecutor.submit(task); \n          results.add(result); \n        }\n\n```", "```java\n        for (int i=0; i<5; i++){ \n          try { \n            String result=results.get(i).get(); \n            System.out.printf(\"Main: Result for Task %d : %s\\n\",\n                              i,result); \n          } catch (InterruptedException | ExecutionException e) { \n            e.printStackTrace(); \n          } \n        }\n\n```", "```java\n        myExecutor.shutdown();\n\n```", "```java\n        for (int i=5; i<10; i++){ \n          try { \n            String result=results.get(i).get(); \n            System.out.printf(\"Main: Result for Task %d : %s\\n\",\n                              i,result); \n          } catch (InterruptedException | ExecutionException e) { \n            e.printStackTrace(); \n          } \n        }\n\n```", "```java\n        try { \n          myExecutor.awaitTermination(1, TimeUnit.DAYS); \n        } catch (InterruptedException e) { \n          e.printStackTrace(); \n        }\n\n```", "```java\n        System.out.printf(\"Main: End of the program.\\n\");\n\n```", "```java\n        public class MyPriorityTask implements Runnable,\n                              Comparable<MyPriorityTask> {\n\n```", "```java\n        private int priority;\n\n```", "```java\n        private String name;\n\n```", "```java\n        public MyPriorityTask(String name, int priority) { \n          this.name=name; \n          this.priority=priority; \n        }\n\n```", "```java\n        public int getPriority(){ \n          return priority; \n        }\n\n```", "```java\n        @Override \n        public int compareTo(MyPriorityTask o) { \n          return Integer.compare(o.getPriority(), this.getPriority()); \n        }\n\n```", "```java\n        @Override \n        public void run() { \n          System.out.printf(\"MyPriorityTask: %s Priority : %d\\n\",\n                            name,priority); \n          try { \n            TimeUnit.SECONDS.sleep(2); \n          } catch (InterruptedException e) { \n            e.printStackTrace(); \n            Thread.currentThread().interrupt(); \n          } \n        }\n\n```", "```java\n        public class Main { \n          public static void main(String[] args) {\n\n```", "```java\n        ThreadPoolExecutor executor=new ThreadPoolExecutor(4,4,1,\n                                    TimeUnit.SECONDS,\n                                    new PriorityBlockingQueue<Runnable>());\n\n```", "```java\n        for (int i=0; i<10; i++){ \n          MyPriorityTask task=new MyPriorityTask (\"Task \"+i,i); \n          executor.execute(task); \n        }\n\n```", "```java\n        try { \n          TimeUnit.SECONDS.sleep(1); \n        } catch (InterruptedException e) { \n          e.printStackTrace(); \n        }\n\n```", "```java\n        for (int i=10; i<20; i++) { \n          MyPriorityTask task=new MyPriorityTask (\"Task \"+i,i); \n          executor.execute(task);       \n        }\n\n```", "```java\n        executor.shutdown();\n\n```", "```java\n        try { \n          executor.awaitTermination(1, TimeUnit.DAYS); \n        } catch (InterruptedException e) { \n          e.printStackTrace(); \n        }\n\n```", "```java\n        System.out.printf(\"Main: End of the program.\\n\");\n\n```", "```java\n        public class MyThread extends Thread {\n\n```", "```java\n        private final Date creationDate; \n        private Date startDate; \n        private Date finishDate;\n\n```", "```java\n        public MyThread(Runnable target, String name ){ \n          super(target,name); \n          creationDate = new Date(); \n        }\n\n```", "```java\n        @Override \n        public void run() { \n          setStartDate(); \n          super.run(); \n          setFinishDate(); \n        }\n\n```", "```java\n        public synchronized void setStartDate() { \n          startDate=new Date(); \n        }\n\n```", "```java\n        public synchronized void setFinishDate() { \n          finishDate=new Date(); \n        }\n\n```", "```java\n        public synchronized long getExecutionTime() { \n          return finishDate.getTime()-startDate.getTime(); \n        }\n\n```", "```java\n        @Override \n        public synchronized String toString(){ \n          StringBuilder buffer=new StringBuilder(); \n          buffer.append(getName()); \n          buffer.append(\": \"); \n          buffer.append(\" Creation Date: \"); \n          buffer.append(creationDate); \n          buffer.append(\" : Running time: \"); \n          buffer.append(getExecutionTime()); \n          buffer.append(\" Milliseconds.\"); \n          return buffer.toString(); \n        }\n\n```", "```java\n        public class MyThreadFactory implements ThreadFactory {\n\n```", "```java\n        private AtomicInteger counter;\n\n```", "```java\n        private String prefix;\n\n```", "```java\n        public MyThreadFactory (String prefix) { \n          this.prefix=prefix; \n          counter=new AtomicInteger(1); \n        }\n\n```", "```java\n        @Override \n        public Thread newThread(Runnable r) { \n          MyThread myThread=new MyThread(r,prefix+\"-\"+counter\n                                                  .getAndIncrement()); \n          return myThread; \n        }\n\n```", "```java\n        public class MyTask implements Runnable { \n          @Override \n          public void run() { \n            try { \n              TimeUnit.SECONDS.sleep(2); \n            } catch (InterruptedException e) { \n              e.printStackTrace(); \n            } \n          } \n        }\n\n```", "```java\n        public class Main { \n          public static void main(String[] args) throws Exception {\n\n```", "```java\n        MyThreadFactory myFactory=new MyThreadFactory\n                                               (\"MyThreadFactory\");\n\n```", "```java\n        MyTask task=new MyTask();\n\n```", "```java\n        Thread thread=myFactory.newThread(task);\n\n```", "```java\n        thread.start(); \n        thread.join();\n\n```", "```java\n        System.out.printf(\"Main: Thread information.\\n\"); \n        System.out.printf(\"%s\\n\",thread); \n        System.out.printf(\"Main: End of the example.\\n\");\n\n```", "```java\n        public class Main { \n          public static void main(String[] args) throws Exception {\n\n```", "```java\n        MyThreadFactory threadFactory=new MyThreadFactory\n                                                  (\"MyThreadFactory\");\n\n```", "```java\n        ExecutorService executor=Executors.newCachedThreadPool\n                                                     (threadFactory);\n\n```", "```java\n        MyTask task=new MyTask(); \n        executor.submit(task);\n\n```", "```java\n        executor.shutdown();\n\n```", "```java\n        executor.awaitTermination(1, TimeUnit.DAYS);\n\n```", "```java\n        System.out.printf(\"Main: End of the program.\\n\");\n\n```", "```java\n        public class MyScheduledTask<V> extends FutureTask<V>\n                                implements RunnableScheduledFuture<V> {\n\n```", "```java\n        private RunnableScheduledFuture<V> task;\n\n```", "```java\n        private ScheduledThreadPoolExecutor executor;\n\n```", "```java\n        private long period;\n\n```", "```java\n        private long startDate;\n\n```", "```java\n        public MyScheduledTask(Runnable runnable, V result,\n                               RunnableScheduledFuture<V> task,\n                               ScheduledThreadPoolExecutor executor) { \n          super(runnable, result); \n          this.task=task; \n          this.executor=executor; \n        }\n\n```", "```java\n        @Override \n        public long getDelay(TimeUnit unit) { \n          if (!isPeriodic()) { \n            return task.getDelay(unit); \n          } else { \n            if (startDate==0){ \n              return task.getDelay(unit); \n            } else { \n              Date now=new Date(); \n              long delay=startDate-now.getTime(); \n              return unit.convert(delay, TimeUnit.MILLISECONDS); \n            } \n          } \n        }\n\n```", "```java\n        @Override \n        public int compareTo(Delayed o) { \n          return task.compareTo(o); \n        }\n\n```", "```java\n        @Override \n        public boolean isPeriodic() { \n          return task.isPeriodic(); \n        }\n\n```", "```java\n        @Override \n        public void run() { \n          if (isPeriodic() && (!executor.isShutdown())) { \n            Date now=new Date(); \n            startDate=now.getTime()+period; \n            executor.getQueue().add(this); \n          }\n\n```", "```java\n          System.out.printf(\"Pre-MyScheduledTask: %s\\n\",new Date()); \n          System.out.printf(\"MyScheduledTask: Is Periodic: %s\\n\",\n                            isPeriodic()); \n          super.runAndReset(); \n          System.out.printf(\"Post-MyScheduledTask: %s\\n\",new Date()); \n        }\n\n```", "```java\n        public void setPeriod(long period) { \n          this.period=period; \n        }\n\n```", "```java\n        public class MyScheduledThreadPoolExecutor extends\n                                          ScheduledThreadPoolExecutor {\n\n```", "```java\n        public MyScheduledThreadPoolExecutor(int corePoolSize) { \n          super(corePoolSize); \n        }\n\n```", "```java\n\n        @Override \n        protected <V> RunnableScheduledFuture<V> decorateTask(\n                                   Runnable runnable,\n                                   RunnableScheduledFuture<V> task) { \n          MyScheduledTask<V> myTask=new MyScheduledTask<V>(runnable,\n                                                    null, task,this);   \n          return myTask; \n        }\n\n```", "```java\n        @Override \n        public ScheduledFuture<?> scheduleAtFixedRate(Runnable command,\n                       long initialDelay, long period, TimeUnit unit) { \n          ScheduledFuture<?> task= super.scheduleAtFixedRate(command,\n                                        initialDelay, period, unit); \n          MyScheduledTask<?> myTask=(MyScheduledTask<?>)task; \n          myTask.setPeriod(TimeUnit.MILLISECONDS.convert(period,unit)); \n          return task; \n        }\n\n```", "```java\n        public class Task implements Runnable {\n\n```", "```java\n        @Override \n        public void run() { \n          System.out.printf(\"Task: Begin.\\n\"); \n          try { \n            TimeUnit.SECONDS.sleep(2); \n          } catch (InterruptedException e) { \n            e.printStackTrace(); \n          } \n          System.out.printf(\"Task: End.\\n\"); \n        }\n\n```", "```java\n        public class Main { \n\n          public static void main(String[] args) throws Exception{\n\n```", "```java\n        MyScheduledThreadPoolExecutor executor=new\n                                 MyScheduledThreadPoolExecutor(4);\n\n```", "```java\n        Task task=new Task(); \n        System.out.printf(\"Main: %s\\n\",new Date());\n\n```", "```java\n        executor.schedule(task, 1, TimeUnit.SECONDS);\n\n```", "```java\n        TimeUnit.SECONDS.sleep(3);\n\n```", "```java\n        task=new Task(); \n        System.out.printf(\"Main: %s\\n\",new Date());\n\n```", "```java\n        executor.scheduleAtFixedRate(task, 1, 3, TimeUnit.SECONDS);\n\n```", "```java\n        TimeUnit.SECONDS.sleep(10);\n\n```", "```java\n        executor.shutdown(); \n        executor.awaitTermination(1, TimeUnit.DAYS);\n\n```", "```java\n        System.out.printf(\"Main: End of the program.\\n\");\n\n```", "```java\n        public class MyWorkerThread extends ForkJoinWorkerThread {\n\n```", "```java\n        private final static ThreadLocal<Integer> taskCounter=\n                                         new ThreadLocal<Integer>();\n\n```", "```java\n        protected MyWorkerThread(ForkJoinPool pool) { \n          super(pool); \n        }\n\n```", "```java\n        @Override \n        protected void onStart() { \n          super.onStart(); \n          System.out.printf(\"MyWorkerThread %d: Initializing task\n                             counter.\\n\", getId()); \n          taskCounter.set(0); \n        }\n\n```", "```java\n        @Override \n        protected void onTermination(Throwable exception) { \n          System.out.printf(\"MyWorkerThread %d: %d\\n\",\n                            getId(),taskCounter.get()); \n          super.onTermination(exception); \n        }\n\n```", "```java\n        public void addTask(){ \n          taskCounter.set(taskCounter.get() + 1);; \n        }\n\n```", "```java\n        public class MyWorkerThreadFactory implements\n                       ForkJoinWorkerThreadFactory { \n          @Override \n          public ForkJoinWorkerThread newThread(ForkJoinPool pool) { \n            return new MyWorkerThread(pool); \n          } \n\n        }\n\n```", "```java\n        public class MyRecursiveTask extends RecursiveTask<Integer> {\n\n```", "```java\n        private int array[];\n\n```", "```java\n        private int start, end;\n\n```", "```java\n        public Task(int array[],int start, int end) { \n          this.array=array; \n          this.start=start; \n          this.end=end; \n        }\n\n```", "```java\n        @Override \n        protected Integer compute() { \n          Integer ret; \n          MyWorkerThread thread=(MyWorkerThread)Thread.currentThread(); \n          thread.addTask();\n\n```", "```java\n        if (end-start>100) { \n          int mid=(start+end)/2; \n          MyRecursiveTask task1=new MyRecursiveTask(array,start,mid); \n          MyRecursiveTask task2=new MyRecursiveTask(array,mid,end); \n          invokeAll(task1,task2); \n          ret=addResults(task1,task2); \n        } else { \n          int add=0; \n          for (int i=start; i<end; i++) { \n            add+=array[i]; \n          } \n          ret=add; \n        }\n\n```", "```java\n          try { \n            TimeUnit.MILLISECONDS.sleep(10); \n          } catch (InterruptedException e) { \n            e.printStackTrace(); \n          } \n          return ret; \n        }\n\n```", "```java\n        private Integer addResults(Task task1, Task task2) { \n          int value; \n          try { \n            value = task1.get().intValue()+task2.get().intValue(); \n          } catch (InterruptedException e) { \n            e.printStackTrace(); \n            value=0; \n          } catch (ExecutionException e) { \n            e.printStackTrace(); \n            value=0; \n          }\n\n```", "```java\n        public class Main { \n\n          public static void main(String[] args) throws Exception {\n\n```", "```java\n        MyWorkerThreadFactory factory=new MyWorkerThreadFactory();\n\n```", "```java\n        ForkJoinPool pool=new ForkJoinPool(4, factory, null, false);\n\n```", "```java\n        int array[]=new int[100000]; \n        for (int i=0; i<array.length; i++){ \n          array[i]=1; \n        }\n\n```", "```java\n        MyRecursiveTask task=new MyRecursiveTask(array,0,array.length);\n\n```", "```java\n        pool.execute(task);\n\n```", "```java\n        task.join();\n\n```", "```java\n        pool.shutdown();\n\n```", "```java\n        pool.awaitTermination(1, TimeUnit.DAYS);\n\n```", "```java\n        System.out.printf(\"Main: Result: %d\\n\",task.get());\n\n```", "```java\n        System.out.printf(\"Main: End of the program\\n\");\n\n```", "```java\n        public abstract class MyWorkerTask extends ForkJoinTask<Void> {\n\n```", "```java\n        private String name;\n\n```", "```java\n        public MyWorkerTask(String name) { \n          this.name=name; \n        }\n\n```", "```java\n        @Override \n        public Void getRawResult() { \n          return null; \n        }\n\n```", "```java\n        @Override \n        protected void setRawResult(Void value) { \n\n        }\n\n```", "```java\n        @Override \n        protected boolean exec() { \n          Date startDate=new Date(); \n          compute(); \n          Date finishDate=new Date(); \n          long diff=finishDate.getTime()-startDate.getTime(); \n          System.out.printf(\"MyWorkerTask: %s : %d Milliseconds to\n                             complete.\\n\",name,diff); \n          return true; \n        }\n\n```", "```java\n        public String getName(){ \n          return name; \n        }\n\n```", "```java\n        protected abstract void compute();\n\n```", "```java\n        public class Task extends MyWorkerTask {\n\n```", "```java\n        private int array[];\n\n```", "```java\n        public Task(String name, int array[], int start, int end){ \n          super(name); \n          this.array=array; \n          this.start=start; \n          this.end=end; \n        }\n\n```", "```java\n        protected void compute() { \n          if (end-start>100){ \n            int mid=(end+start)/2; \n            Task task1=new Task(this.getName()+\"1\",array,start,mid); \n            Task task2=new Task(this.getName()+\"2\",array,mid,end); \n            invokeAll(task1,task2);\n\n```", "```java\n        } else { \n        for (int i=start; i<end; i++) { \n          array[i]++; \n        }\n\n```", "```java\n            try { \n              Thread.sleep(50); \n            } catch (InterruptedException e) { \n              e.printStackTrace(); \n            } \n          } \n        }\n\n```", "```java\n        public class Main { \n          public static void main(String[] args) throws Exception {\n\n```", "```java\n        int array[]=new int[10000];\n\n```", "```java\n        ForkJoinPool pool=new ForkJoinPool();\n\n```", "```java\n        Task task=new Task(\"Task\",array,0,array.length);\n\n```", "```java\n        pool.invoke(task);\n\n```", "```java\n        pool.shutdown();\n\n```", "```java\n        System.out.printf(\"Main: End of the program.\\n\");\n\n```", "```java\n        public class MyAbstractQueuedSynchronizer extends\n                                        AbstractQueuedSynchronizer {\n\n```", "```java\n        private final AtomicInteger state;\n\n```", "```java\n        public MyAbstractQueuedSynchronizer() { \n          state=new AtomicInteger(0); \n        }\n\n```", "```java\n        @Override \n        protected boolean tryAcquire(int arg) { \n          return state.compareAndSet(0, 1); \n        }\n\n```", "```java\n        @Override \n        protected boolean tryRelease(int arg) { \n          return state.compareAndSet(1, 0); \n        }\n\n```", "```java\n        public class MyLock implements Lock{\n\n```", "```java\n        private final AbstractQueuedSynchronizer sync;\n\n```", "```java\n        public MyLock() { \n          sync=new MyAbstractQueuedSynchronizer(); \n        }\n\n```", "```java\n        @Override \n        public void lock() { \n          sync.acquire(1); \n        }\n\n```", "```java\n        @Override \n        public void lockInterruptibly() throws InterruptedException { \n          sync.acquireInterruptibly(1); \n        }\n\n```", "```java\n        @Override \n        public boolean tryLock() { \n          try { \n            return sync.tryAcquireNanos(1, 1000); \n          } catch (InterruptedException e) { \n            e.printStackTrace(); \n            Thread.currentThread().interrupt(); \n            return false; \n          } \n        }\n\n```", "```java\n        @Override \n        public boolean tryLock(long time, TimeUnit unit) throws\n                                         InterruptedException { \n          return sync.tryAcquireNanos(1, TimeUnit.NANOSECONDS\n                                             .convert(time, unit)); \n        }\n\n```", "```java\n        @Override \n        public void unlock() { \n          sync.release(1); \n        }\n\n```", "```java\n        @Override \n        public Condition newCondition() { \n          return sync.new ConditionObject(); \n        }\n\n```", "```java\n        public class Task implements Runnable {\n\n```", "```java\n        private final MyLock lock;\n\n```", "```java\n        private final String name;\n\n```", "```java\n        public Task(String name, MyLock lock){ \n          this.lock=lock; \n          this.name=name; \n        }\n\n```", "```java\n        @Override \n        public void run() { \n          lock.lock(); \n          System.out.printf(\"Task: %s: Take the lock\\n\",name); \n          try { \n            TimeUnit.SECONDS.sleep(2); \n            System.out.printf(\"Task: %s: Free the lock\\n\",name); \n          } catch (InterruptedException e) { \n            e.printStackTrace(); \n          } finally { \n            lock.unlock(); \n          } \n        }\n\n```", "```java\n        public class Main { \n          public static void main(String[] args) {\n\n```", "```java\n        MyLock lock=new MyLock();\n\n```", "```java\n        for (int i=0; i<10; i++){ \n          Task task=new Task(\"Task-\"+i,lock); \n          Thread thread=new Thread(task); \n          thread.start(); \n        }\n\n```", "```java\n        boolean value; \n        do { \n          try { \n            value=lock.tryLock(1,TimeUnit.SECONDS); \n            if (!value) { \n              System.out.printf(\"Main: Trying to get the Lock\\n\"); \n            } \n          } catch (InterruptedException e) { \n            e.printStackTrace(); \n            value=false; \n          } \n        } while (!value);\n\n```", "```java\n        System.out.printf(\"Main: Got the lock\\n\"); \n        lock.unlock();\n\n```", "```java\n        System.out.printf(\"Main: End of the program\\n\");\n\n```", "```java\n        public class MyPriorityTransferQueue<E> extends\n                 PriorityBlockingQueue<E> implements TransferQueue<E> {\n\n```", "```java\n        private final AtomicInteger counter;\n\n```", "```java\n        private final LinkedBlockingQueue<E> transfered;\n\n```", "```java\n        private final ReentrantLock lock;\n\n```", "```java\n        public MyPriorityTransferQueue() { \n          counter=new AtomicInteger(0); \n          lock=new ReentrantLock(); \n          transfered=new LinkedBlockingQueue<E>(); \n        }\n\n```", "```java\n        @Override \n        public boolean tryTransfer(E e) { \n          boolean value=false; \n          try { \n            lock.lock(); \n            if (counter.get() == 0) { \n              value = false; \n            } else { \n              put(e); \n              value = true; \n            } \n          } finally { \n            lock.unlock(); \n          } \n          return value;    \n        }\n\n```", "```java\n          @Override \n          public void transfer(E e) throws InterruptedException { \n            lock.lock(); \n            if (counter.get()!=0) { \n              try { \n                put(e); \n              } finally { \n                lock.unlock(); \n              } \n            } else { \n              try { \n                transfered.add(e); \n              } finally { \n                lock.unlock(); \n              } \n              synchronized (e) { \n              e.wait(); \n            } \n          } \n        }\n\n```", "```java\n        @Override \n        public boolean tryTransfer(E e, long timeout, TimeUnit unit)\n                                       throws InterruptedException { \n          lock.lock(); \n          if (counter.get() != 0) { \n            try { \n              put(e); \n            } finally { \n              lock.unlock(); \n            } \n            return true; \n          } else { \n            long newTimeout=0; \n            try { \n              transfered.add(e); \n              newTimeout = TimeUnit.MILLISECONDS.convert(timeout, unit); \n            } finally { \n              lock.unlock(); \n            } \n            e.wait(newTimeout); \n            lock.lock(); \n            boolean value; \n            try { \n              if (transfered.contains(e)) { \n                transfered.remove(e); \n                value = false; \n              } else { \n                value = true; \n              } \n            } finally { \n              lock.unlock(); \n            } \n            return value; \n          } \n        }\n\n```", "```java\n        @Override \n        public boolean hasWaitingConsumer() { \n          return (counter.get()!=0); \n        }\n\n```", "```java\n        @Override \n        public int getWaitingConsumerCount() { \n          return counter.get(); \n        }\n\n```", "```java\n        @Override \n        public E take() throws InterruptedException { \n          lock.lock(); \n          try { \n            counter.incrementAndGet();\n\n```", "```java\n        E value=transfered.poll(); \n        if (value==null) { \n          lock.unlock(); \n          value=super.take(); \n          lock.lock();\n\n```", "```java\n        } else { \n          synchronized (value) { \n            value.notify(); \n          } \n        }\n\n```", "```java\n            counter.decrementAndGet(); \n          } finally { \n            lock.unlock(); \n          } \n          return value; \n        }\n\n```", "```java\n        public class Event implements Comparable<Event> {\n\n```", "```java\n        private final String thread;\n\n```", "```java\n        private final int priority;\n\n```", "```java\n        public Event(String thread, int priority){ \n          this.thread=thread; \n          this.priority=priority; \n        }\n\n```", "```java\n        public String getThread() { \n          return thread; \n        }\n\n```", "```java\n        public int getPriority() { \n          return priority; \n        }\n\n```", "```java\n        public int compareTo(Event e) { \n          return Integer.compare(e.priority, this.getPriority()); \n        }\n\n```", "```java\n        public class Producer implements Runnable {\n\n```", "```java\n        private final MyPriorityTransferQueue<Event> buffer;\n\n```", "```java\n        public Producer(MyPriorityTransferQueue<Event> buffer) { \n          this.buffer=buffer; \n        }\n\n```", "```java\n        @Override \n        public void run() { \n          for (int i=0; i<100; i++) { \n            Event event=new Event(Thread.currentThread().getName(),i); \n            buffer.put(event); \n          } \n        }\n\n```", "```java\n        public class Consumer implements Runnable {\n\n```", "```java\n        private final MyPriorityTransferQueue<Event> buffer;\n\n```", "```java\n        public Consumer(MyPriorityTransferQueue<Event> buffer) { \n          this.buffer=buffer; \n        }\n\n```", "```java\n        @Override \n        public void run() { \n          for (int i=0; i<1002; i++) { \n            try { \n              Event value=buffer.take(); \n              System.out.printf(\"Consumer: %s: %d\\n\",value.getThread(),\n                                value.getPriority()); \n            } catch (InterruptedException e) { \n              e.printStackTrace(); \n            } \n          } \n        }\n\n```", "```java\n        public class Main { \n\n          public static void main(String[] args) throws Exception {\n\n```", "```java\n        MyPriorityTransferQueue<Event> buffer=new\n                                MyPriorityTransferQueue<Event>();\n\n```", "```java\n        Producer producer=new Producer(buffer); \n        Thread producerThreads[]=new Thread[10]; \n        for (int i=0; i<producerThreads.length; i++) { \n          producerThreads[i]=new Thread(producer); \n          producerThreads[i].start(); \n        }\n\n```", "```java\n        Consumer consumer=new Consumer(buffer); \n        Thread consumerThread=new Thread(consumer); \n        consumerThread.start();\n\n```", "```java\n        System.out.printf(\"Main: Buffer: Consumer count: %d\\n\",\n                          buffer.getWaitingConsumerCount());\n\n```", "```java\n        Event myEvent=new Event(\"Core Event\",0); \n        buffer.transfer(myEvent); \n        System.out.printf(\"Main: My Event has ben transfered.\\n\");\n\n```", "```java\n        for (int i=0; i<producerThreads.length; i++) { \n          try { \n            producerThreads[i].join(); \n          } catch (InterruptedException e) { \n            e.printStackTrace(); \n          } \n        }\n\n```", "```java\n        TimeUnit.SECONDS.sleep(1);\n\n```", "```java\n        System.out.printf(\"Main: Buffer: Consumer count: %d\\n\",\n                          buffer.getWaitingConsumerCount());\n\n```", "```java\n        myEvent=new Event(\"Core Event 2\",0); \n        buffer.transfer(myEvent);\n\n```", "```java\n        consumerThread.join();\n\n```", "```java\n        System.out.printf(\"Main: End of the program\\n\");\n\n```", "```java\n        public class ParkingCounter extends AtomicInteger {\n\n```", "```java\n        private final int maxNumber;\n\n```", "```java\n        public ParkingCounter(int maxNumber){ \n          set(0); \n          this.maxNumber=maxNumber; \n        }\n\n```", "```java\n        public boolean carIn() { \n          for (;;) { \n            int value=get();\n\n```", "```java\n        if (value==maxNumber) { \n          System.out.printf(\"ParkingCounter: The parking lot is full.\\n\"); \n          return false;\n\n```", "```java\n            } else { \n              int newValue=value+1; \n              boolean changed=compareAndSet(value,newValue); \n              if (changed) { \n                System.out.printf(\"ParkingCounter: A car has entered.\\n\"); \n                return true; \n              } \n            } \n          } \n        }\n\n```", "```java\n        public boolean carOut() { \n          for (;;) { \n            int value=get(); \n            if (value==0) { \n              System.out.printf(\"ParkingCounter: The parking lot is\n                                 empty.\\n\"); \n              return false; \n            } else { \n              int newValue=value-1; \n              boolean changed=compareAndSet(value,newValue); \n              if (changed) { \n                System.out.printf(\"ParkingCounter: A car has gone out.\\n\"); \n                return true; \n              } \n            } \n          } \n        }\n\n```", "```java\n        public class Sensor1 implements Runnable {\n\n```", "```java\n        private final ParkingCounter counter;\n\n```", "```java\n        public Sensor1(ParkingCounter counter) { \n          this.counter=counter; \n        }\n\n```", "```java\n        @Override \n        public void run() { \n          counter.carIn(); \n          counter.carIn(); \n          counter.carIn(); \n          counter.carIn(); \n          counter.carOut(); \n          counter.carOut(); \n          counter.carOut(); \n          counter.carIn(); \n          counter.carIn(); \n          counter.carIn(); \n        }\n\n```", "```java\n        public class Sensor2 implements Runnable {\n\n```", "```java\n        private ParkingCounter counter;\n\n```", "```java\n        public Sensor2(ParkingCounter counter) { \n          this.counter=counter; \n        }\n\n```", "```java\n        @Override \n        public void run() { \n          counter.carIn(); \n          counter.carOut(); \n          counter.carOut(); \n          counter.carIn(); \n          counter.carIn(); \n          counter.carIn(); \n          counter.carIn(); \n          counter.carIn(); \n          counter.carIn(); \n        }\n\n```", "```java\n        public class Main { \n\n          public static void main(String[] args) throws Exception {\n\n```", "```java\n        ParkingCounter counter=new ParkingCounter(5);\n\n```", "```java\n        Sensor1 sensor1=new Sensor1(counter); \n        Sensor2 sensor2=new Sensor2(counter); \n\n        Thread thread1=new Thread(sensor1); \n        Thread thread2=new Thread(sensor2); \n\n        thread1.start(); \n        thread2.start();\n\n```", "```java\n        thread1.join(); \n        thread2.join();\n\n```", "```java\n        System.out.printf(\"Main: Number of cars: %d\\n\",counter.get());\n\n```", "```java\n        System.out.printf(\"Main: End of the program.\\n\");\n\n```", "```java\n        public class MySpliterator implements Spliterator<Item> { \n\n          private Item[][] items; \n          private int start, end, current; \n\n          public MySpliterator(Item[][] items, int start, int end) { \n            this.items=items; \n            this.start=start; \n            this.end=end; \n            this.current=start; \n          }\n\n```", "```java\n        @Override \n        public int characteristics() { \n          return ORDERED | SIZED | SUBSIZED; \n        }\n\n```", "```java\n        @Override \n        public long estimateSize() { \n          return end - current; \n        }\n\n```", "```java\n        @Override \n        public boolean tryAdvance(Consumer<? super Item> consumer) { \n          System.out.printf(\"MySpliterator.tryAdvance.start: %d, %d, %d\\n\",\n                            start,end,current); \n            if (current < end) { \n              for (int i=0; i<items[current].length; i++) { \n                consumer.accept(items[current][i]); \n              } \n              current++; \n              System.out.printf(\"MySpliterator.tryAdvance.end:true\\n\"); \n              return true; \n            } \n            System.out.printf(\"MySpliterator.tryAdvance.end:false\\n\"); \n            return false; \n          }\n\n```", "```java\n        @Override \n        public void forEachRemaining(Consumer<? super Item> consumer) { \n          System.out.printf(\"MySpliterator.forEachRemaining.start\\n\"); \n          boolean ret; \n          do { \n            ret=tryAdvance(consumer); \n          } while (ret); \n          System.out.printf(\"MySpliterator.forEachRemaining.end\\n\"); \n        }\n\n```", "```java\n        @Override \n        public Spliterator<Item> trySplit() { \n          System.out.printf(\"MySpliterator.trySplit.start\\n\"); \n\n          if (end-start<=2) { \n            System.out.printf(\"MySpliterator.trySplit.end\\n\"); \n            return null; \n          } \n          int mid=start+((end-start)/2); \n          int newStart=mid; \n          int newEnd=end; \n          end=mid; \n          System.out.printf(\"MySpliterator.trySplit.end: %d, %d, %d,\n                            %d, %d, %d\\n\",start, mid, end, newStart,\n                            newEnd, current); \n\n          return new MySpliterator(items, newStart, newEnd); \n        }\n\n```", "```java\n        public class Main { \n\n          public static void main(String[] args) { \n            Item[][] items; \n            items= new Item[10][10]; \n\n            for (int i=0; i<10; i++) { \n              for (int j=0; j<10; j++) { \n                items[i][j]=new Item(); \n                items[i][j].setRow(i); \n                items[i][j].setColumn(j); \n                items[i][j].setName(\"Item \"+i+\" \"+j); \n              } \n            }\n\n```", "```java\n        MySpliterator mySpliterator=new MySpliterator(items, 0,\n                                                      items.length);\n\n```", "```java\n          StreamSupport.stream(mySpliterator, true).forEach( item -> { \n            System.out.printf(\"%s: %s\\n\",Thread.currentThread()\n                              .getName(),item.getName()); \n          }); \n        }\n\n```", "```java\n        public class Consumer implements Subscriber<News> { \n\n          private Subscription subscription; \n          private String name; \n\n          public Consumer(String name) { \n            this.name=name; \n          }\n\n```", "```java\n        @Override \n        public void onComplete() { \n          System.out.printf(\"%s - %s: Consumer - Completed\\n\", name,\n                            Thread.currentThread().getName()); \n        }\n\n```", "```java\n        @Override \n        public void onError(Throwable exception) { \n          System.out.printf(\"%s - %s: Consumer - Error: %s\\n\", name,\n                            Thread.currentThread().getName(),\n                            exception.getMessage()); \n        }\n\n```", "```java\n        @Override \n        public void onNext(News item) { \n          System.out.printf(\"%s - %s: Consumer - News\\n\", name,\n                            Thread.currentThread().getName()); \n          System.out.printf(\"%s - %s: Title: %s\\n\", name,\n                            Thread.currentThread().getName(),\n                            item.getTitle()); \n          System.out.printf(\"%s - %s: Content: %s\\n\", name,\n                            Thread.currentThread().getName(),\n                            item.getContent()); \n          System.out.printf(\"%s - %s: Date: %s\\n\", name,\n                            Thread.currentThread().getName(),\n                            item.getDate()); \n          subscription.request(1); \n        }\n\n```", "```java\n        @Override \n        public void onSubscribe(Subscription subscription) { \n          this.subscription = subscription; \n          subscription.request(1); \n          System.out.printf(\"%s: Consumer - Subscription\\n\",\n                            Thread.currentThread().getName()); \n        }\n\n```", "```java\n        public class MySubscription implements Subscription { \n\n          private boolean canceled=false; \n          private long requested=0;\n\n```", "```java\n        @Override \n        public void cancel() { \n          canceled=true; \n        }\n\n```", "```java\n        @Override \n        public void request(long value) { \n          requested+=value; \n        }\n\n```", "```java\n        public boolean isCanceled() { \n          return canceled; \n        } \n\n        public long getRequested() { \n          return requested; \n        } \n\n        public void decreaseRequested() { \n          requested--;      \n        }\n\n```", "```java\n        public class PublisherTask implements Runnable { \n\n        private ConsumerData consumerData; \n        private News news; \n\n        public PublisherTask(ConsumerData consumerData, News news) { \n          this.consumerData = consumerData; \n          this.news = news; \n        }\n\n```", "```java\n          @Override \n          public void run() { \n            MySubscription subscription = consumerData.getSubscription(); \n            if (!(subscription.isCanceled() && (subscription.getRequested()\n                                                               > 0))) { \n              consumerData.getConsumer().onNext(news); \n              subscription.decreaseRequested(); \n            } \n          } \n        }\n\n```", "```java\n        public class MyPublisher implements Publisher<News> { \n\n          private ConcurrentLinkedDeque<ConsumerData> consumers; \n          private ThreadPoolExecutor executor; \n\n          public MyPublisher() { \n            consumers=new ConcurrentLinkedDeque<>(); \n            executor = (ThreadPoolExecutor)Executors.newFixedThreadPool\n                          (Runtime.getRuntime().availableProcessors()); \n          }\n\n```", "```java\n        @Override \n        public void subscribe(Subscriber<? super News> subscriber) { \n\n          ConsumerData consumerData=new ConsumerData(); \n          consumerData.setConsumer((Consumer)subscriber); \n\n          MySubscription subscription=new MySubscription(); \n          consumerData.setSubscription(subscription); \n\n          subscriber.onSubscribe(subscription); \n\n          consumers.add(consumerData); \n        }\n\n```", "```java\n        public void publish(News news) { \n          consumers.forEach( consumerData -> { \n            try { \n              executor.execute(new PublisherTask(consumerData, news)); \n            } catch (Exception e) { \n              consumerData.getConsumer().onError(e); \n            } \n          }); \n        }\n\n```", "```java\n        public class Main { \n\n          public static void main(String[] args) { \n\n            MyPublisher publisher=new MyPublisher(); \n\n            Subscriber<News> consumer1, consumer2; \n            consumer1=new Consumer(\"Consumer 1\"); \n            consumer2=new Consumer(\"Consumer 2\"); \n\n            publisher.subscribe(consumer1); \n            publisher.subscribe(consumer2);\n\n```", "```java\n        System.out.printf(\"Main: Start\\n\"); \n\n          News news=new News(); \n          news.setTitle(\"My first news\"); \n          news.setContent(\"This is the content\"); \n          news.setDate(new Date()); \n\n          publisher.publish(news); \n\n          try { \n            TimeUnit.SECONDS.sleep(1); \n          } catch (InterruptedException e) { \n            e.printStackTrace(); \n          } \n\n          news=new News(); \n          news.setTitle(\"My second news\"); \n          news.setContent(\"This is the content of the second news\"); \n          news.setDate(new Date()); \n          publisher.publish(news); \n\n          System.out.printf(\"Main: End\\n\"); \n\n        }\n\n```"]