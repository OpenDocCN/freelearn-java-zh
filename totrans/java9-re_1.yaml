- en: from the specified string, ignoring delimiters.
  prefs: []
  type: TYPE_NORMAL
- en: Scanner skip(Pattern
  prefs: []
  type: TYPE_NORMAL
- en: This method is almost the same as the previous one
  prefs: []
  type: TYPE_NORMAL
- en: pattern)
  prefs: []
  type: TYPE_NORMAL
- en: but gets Pattern as an argument instead of String.
  prefs: []
  type: TYPE_NORMAL
- en: String
  prefs: []
  type: TYPE_NORMAL
- en: Attempts to find the next occurrence of a pattern
  prefs: []
  type: TYPE_NORMAL
- en: findWithinHorizon(String
  prefs: []
  type: TYPE_NORMAL
- en: constructed from the specified string, ignoring
  prefs: []
  type: TYPE_NORMAL
- en: pattern, int horizon)
  prefs: []
  type: TYPE_NORMAL
- en: delimiters.
  prefs: []
  type: TYPE_NORMAL
- en: String
  prefs: []
  type: TYPE_NORMAL
- en: This method is almost the same as the previous one
  prefs: []
  type: TYPE_NORMAL
- en: findWithinHorizon(Pattern
  prefs: []
  type: TYPE_NORMAL
- en: but gets Pattern as an argument instead of String.
  prefs: []
  type: TYPE_NORMAL
- en: pattern, int horizon)
  prefs: []
  type: TYPE_NORMAL
- en: In addition to the two hasNext() methods mentioned in the preceding table using
    regular expression, the Scanner class also provides several overloaded hasNext
    methods that return true if the next available token in the input can be retrieved
    for that
  prefs: []
  type: TYPE_NORMAL
- en: 'particular type. For example: hasNextInt(), hasNextDouble(), hasNextBoolean(),
    hasNextByte(), hasNextFloat(), hasNextLong(), hasNextShort(), hasNextBigInteger(),
    hasNextBigDecimal(), hasNext().'
  prefs: []
  type: TYPE_NORMAL
- en: 'Similarly, there are several overloaded next methods that scan the input to
    return the next token for that particular type. For example: nextextInt(), nextextDouble(),
    nextextBoolean(), nextextByte(), nextextFloat(), nextextLong(), nextextShort(),
    nextextBigInteger(), nextextBigDecimal(), nextext().'
  prefs: []
  type: TYPE_NORMAL
- en: For the complete reference of the Scanner class refer to
  prefs: []
  type: TYPE_NORMAL
- en: https://docs.oracle.com/javase/8/docs/api/java/util/Scanner.html.
  prefs: []
  type: TYPE_NORMAL
- en: 'Suppose there is an input text delimited by two exclamation marks. The data
    is structured in the following sequence:'
  prefs: []
  type: TYPE_NORMAL
- en: animal!!id!!weight
  prefs: []
  type: TYPE_NORMAL
- en: The animal name is a string, id is an integer number, and weight is a double
    number.
  prefs: []
  type: TYPE_NORMAL
- en: 'With this structure, here is an example input:'
  prefs: []
  type: TYPE_NORMAL
- en: Tiger!!123!!221.2!!Fox!!581!!52.50
  prefs: []
  type: TYPE_NORMAL
- en: 'Given that there are two animals, here is how we can use the Scanner class
    to parse this input data in Java:'
  prefs: []
  type: TYPE_NORMAL
- en: final String input = "Tiger!!123!!221.2!!Fox!!581!!52.50"; final int MAX_COUNT
    = 2;
  prefs: []
  type: TYPE_NORMAL
- en: String animal;
  prefs: []
  type: TYPE_NORMAL
- en: int id;
  prefs: []
  type: TYPE_NORMAL
- en: double weight;
  prefs: []
  type: TYPE_NORMAL
- en: Scanner scanner = new Scanner(input).useDelimiter("!!"); for (int i=0; i<MAX_COUNT;
    i++)
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: animal = scanner.next();
  prefs: []
  type: TYPE_NORMAL
- en: id = scanner.nextInt();
  prefs: []
  type: TYPE_NORMAL
- en: weight = scanner.nextDouble();
  prefs: []
  type: TYPE_NORMAL
- en: System.out.printf("animal=[%s], id=[%d], weight=[%.2f]%n", animal, id, weight);
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: scanner.close();
  prefs: []
  type: TYPE_NORMAL
- en: 'This is what is happening in this code:'
  prefs: []
  type: TYPE_NORMAL
- en: new Scanner(input) is the code to construct a scanner using the input string
    scanner.useDelimiter("!!") sets the delimiter regular expression as "!!"
  prefs: []
  type: TYPE_NORMAL
- en: scanner.next() gets the next string token from the constructed scanner scanner.nextInt()
    gets the next int token from the scanner scanner.nextDouble() gets the next double
    token from the scanner scanner.close() closes the scanner object; we cannot generate
    further tokens from the scanner after this method call
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can guess, we will get the following output from the preceding code:
    animal=[Tiger], id=[123], weight=[221.20]'
  prefs: []
  type: TYPE_NORMAL
- en: animal=[Fox], id=[581], weight=[52.50]
  prefs: []
  type: TYPE_NORMAL
- en: Let's parse a more complex input data to understand the use of the Scanner class
    better.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the complete code listing:'
  prefs: []
  type: TYPE_NORMAL
- en: package example.regex;
  prefs: []
  type: TYPE_NORMAL
- en: import java.util.*;
  prefs: []
  type: TYPE_NORMAL
- en: public class ScannerApi
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: public static void main (String[] args)
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: final String str = "London:Rome#Paris:1234:Munich///Moscow"; Scanner scanner
    = new Scanner(str);
  prefs: []
  type: TYPE_NORMAL
- en: scanner.useDelimiter("\\p{Punct}+");
  prefs: []
  type: TYPE_NORMAL
- en: final String cityPattern = "\\p{L}+";
  prefs: []
  type: TYPE_NORMAL
- en: while(scanner.hasNext()) {
  prefs: []
  type: TYPE_NORMAL
- en: if(scanner.hasNext(cityPattern)) {
  prefs: []
  type: TYPE_NORMAL
- en: System.out.println(scanner.next());
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: else {
  prefs: []
  type: TYPE_NORMAL
- en: scanner.next();
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: scanner.close();
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: 'This is what is happening in this code:'
  prefs: []
  type: TYPE_NORMAL
- en: new Scanner(str) is the code to construct a scanner using the input string
  prefs: []
  type: TYPE_NORMAL
- en: '* scanner.useDelimiter("\\p{Punct}+") sets the delimiter regular expression
    as one or more punctuation characters'
  prefs: []
  type: TYPE_NORMAL
- en: We are using "\\p{L}+" as the acceptable city name pattern, which means one
    or more Unicode letters
  prefs: []
  type: TYPE_NORMAL
- en: scanner.hasNext(cityPattern) returns true if the next token from the scanner
    matches cityPattern
  prefs: []
  type: TYPE_NORMAL
- en: scanner.next() retrieves the next string token from the scanner scanner.close()
    closes the scanner object; we cannot generate further tokens from the scanner
    after this method call
  prefs: []
  type: TYPE_NORMAL
- en: 'Upon compiling and running the preceding code, it will produce the following
    output: London'
  prefs: []
  type: TYPE_NORMAL
- en: Rome
  prefs: []
  type: TYPE_NORMAL
- en: Paris
  prefs: []
  type: TYPE_NORMAL
- en: Munich
  prefs: []
  type: TYPE_NORMAL
- en: Moscow
  prefs: []
  type: TYPE_NORMAL
- en: '**Summary**'
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, you were introduced to Java programs using regular expressions
    using the String and Scanner classes. We discussed the methods available in these
    two APIs that are related to regular expression handling and how we can make use
    of those methods in our code.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will cover the Pattern and Matcher classes, which are
    the most important classes for programs using regular expressions.
  prefs: []
  type: TYPE_NORMAL
- en: '**Introduction to Java Regular**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Expression APIs - Pattern**'
  prefs: []
  type: TYPE_NORMAL
- en: '**and Matcher Classes**'
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will introduce you to dedicated Java APIs for writing programs
    using regular expressions. Java provides a package, java.util.regex, which contains
    all the classes and interfaces for handling regular expressions. This package
    is in the java.base module, so we do not explicitly declare its use in the module-info.java
    source file. The java.base module is automatically required by all modules, and
    it contains the most important and basic JDK packages and classes. Regular expressions
    is such an important topic and tool that Java 9 experts decided to keep it inside
    the java.base module.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will cover the following classes and interfaces from this package: The MatchResult
    interface'
  prefs: []
  type: TYPE_NORMAL
- en: Using Pattern class
  prefs: []
  type: TYPE_NORMAL
- en: Using Matcher class
  prefs: []
  type: TYPE_NORMAL
- en: Various methods of Pattern and Matcher classes and how to use them for solving
    problems involving regular expressions
  prefs: []
  type: TYPE_NORMAL
- en: '**The MatchResult interface**'
  prefs: []
  type: TYPE_NORMAL
- en: 'MatchResult is an interface for representing the result of a match operation.
    This interface is implemented by the Matcher class. This interface contains query
    methods used to determine the results of a match against a regular expression.
    The match boundaries, groups, and group boundaries can only be retrieved but not
    modified through this interface. Here is a list of important methods provided
    in this interface: Method'
  prefs: []
  type: TYPE_NORMAL
- en: Description
  prefs: []
  type: TYPE_NORMAL
- en: Name
  prefs: []
  type: TYPE_NORMAL
- en: int start()
  prefs: []
  type: TYPE_NORMAL
- en: Returns the start index of the match in the input
  prefs: []
  type: TYPE_NORMAL
- en: int start(int
  prefs: []
  type: TYPE_NORMAL
- en: Returns the start index of the specified capturing group
  prefs: []
  type: TYPE_NORMAL
- en: group)
  prefs: []
  type: TYPE_NORMAL
- en: int end()
  prefs: []
  type: TYPE_NORMAL
- en: Returns the offset after the last character matched
  prefs: []
  type: TYPE_NORMAL
- en: int end(int
  prefs: []
  type: TYPE_NORMAL
- en: Returns the offset after the last character of the subsequence group)
  prefs: []
  type: TYPE_NORMAL
- en: captured by the given group during this match
  prefs: []
  type: TYPE_NORMAL
- en: String
  prefs: []
  type: TYPE_NORMAL
- en: Returns the input substring matched by the previous match group()
  prefs: []
  type: TYPE_NORMAL
- en: String
  prefs: []
  type: TYPE_NORMAL
- en: Returns the input subsequence captured by the given group during group(int
  prefs: []
  type: TYPE_NORMAL
- en: the previous match operation
  prefs: []
  type: TYPE_NORMAL
- en: group)
  prefs: []
  type: TYPE_NORMAL
- en: int
  prefs: []
  type: TYPE_NORMAL
- en: Returns the number of capturing groups in this match result's groupCount()
  prefs: []
  type: TYPE_NORMAL
- en: pattern
  prefs: []
  type: TYPE_NORMAL
- en: Let's take an example to understand this interface better.
  prefs: []
  type: TYPE_NORMAL
- en: 'Suppose, the input string is a web server response line from HTTP response
    headers: HTTP/1.1 302 Found'
  prefs: []
  type: TYPE_NORMAL
- en: 'Our regex pattern to parse this line is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: HTTP/1\.[01] (\d+) [a-zA-Z]+
  prefs: []
  type: TYPE_NORMAL
- en: Note that there is only one captured group that captures integer status code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at this code listing to understand the various methods of the MatchResult
    interface better:'
  prefs: []
  type: TYPE_NORMAL
- en: package example.regex;
  prefs: []
  type: TYPE_NORMAL
- en: import java.util.regex.*;
  prefs: []
  type: TYPE_NORMAL
- en: public class MatchResultExample
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: public static void main(String[] args)
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: final String re = "HTTP/1\\.[01] (\\d+) [a-zA-Z]+"; final String str = "HTTP/1.1
    302 Found";
  prefs: []
  type: TYPE_NORMAL
- en: final Pattern p = Pattern.compile(re);
  prefs: []
  type: TYPE_NORMAL
- en: Matcher m = p.matcher(str);
  prefs: []
  type: TYPE_NORMAL
- en: if (m.matches())
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: MatchResult mr = m.toMatchResult();
  prefs: []
  type: TYPE_NORMAL
- en: // print count of capturing groups
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println("groupCount(): " + mr.groupCount());'
  prefs: []
  type: TYPE_NORMAL
- en: // print complete matched text
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println("group(): " + mr.group());'
  prefs: []
  type: TYPE_NORMAL
- en: // print start position of matched text
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println("start(): " + mr.start());'
  prefs: []
  type: TYPE_NORMAL
- en: // print end position of matched text
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println("end(): " + mr.end());'
  prefs: []
  type: TYPE_NORMAL
- en: // print 1st captured group
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println("group(1): " + mr.group(1));'
  prefs: []
  type: TYPE_NORMAL
- en: // print 1st captured group's start position
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println("start(1): " + mr.start(1));'
  prefs: []
  type: TYPE_NORMAL
- en: // print 1st captured group's end position
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println("end(1): " + mr.end(1));'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: 'We retrieve a MatchResult instance after calling the required Pattern and Matcher
    methods (discussed in the next section). After compiling and running the preceding
    code, we will get the following output, which shows the use of the various methods
    of this interface:'
  prefs: []
  type: TYPE_NORMAL
- en: 'groupCount(): 1'
  prefs: []
  type: TYPE_NORMAL
- en: 'group(): HTTP/1.1 302 Found'
  prefs: []
  type: TYPE_NORMAL
- en: 'start(): 0'
  prefs: []
  type: TYPE_NORMAL
- en: 'end(): 18'
  prefs: []
  type: TYPE_NORMAL
- en: 'group(1): 302'
  prefs: []
  type: TYPE_NORMAL
- en: 'start(1): 9'
  prefs: []
  type: TYPE_NORMAL
- en: 'end(1): 12'
  prefs: []
  type: TYPE_NORMAL
- en: '**The Pattern class**'
  prefs: []
  type: TYPE_NORMAL
- en: The Pattern class represents the compiled form of a string regular expression.
    So far, we have provided all the regular expressions as strings. Each String regular
    expression must be compiled into an instance of the Pattern class before the Java
    regex engine can execute it. An instance of the Pattern class is used to create
    a Matcher object to match input text against the regular expression.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s list down the important and useful methods from the Pattern class first:
    Method Signature'
  prefs: []
  type: TYPE_NORMAL
- en: Description
  prefs: []
  type: TYPE_NORMAL
- en: Static Pattern compile(String
  prefs: []
  type: TYPE_NORMAL
- en: Compiles the given String regular expression into a
  prefs: []
  type: TYPE_NORMAL
- en: regex)
  prefs: []
  type: TYPE_NORMAL
- en: Compiles the given String regular expression into a Pattern instance with the
    given flags. Flags can be one or more of
  prefs: []
  type: TYPE_NORMAL
- en: Static Pattern compile(String
  prefs: []
  type: TYPE_NORMAL
- en: CASE_SENSITIVE, UNICODE_CHARACTER_CLASS and a few others. Check the regex, int
    flags)
  prefs: []
  type: TYPE_NORMAL
- en: Java Pattern API at
  prefs: []
  type: TYPE_NORMAL
- en: http://download.java.net/java/jdk9/docs/api/java/util/regex/Pattern.html for
    all flags and their descriptions.
  prefs: []
  type: TYPE_NORMAL
- en: Matcher matcher(CharSequence
  prefs: []
  type: TYPE_NORMAL
- en: Creates a matcher instance to match the given input against this input)
  prefs: []
  type: TYPE_NORMAL
- en: compiled pattern.
  prefs: []
  type: TYPE_NORMAL
- en: Returns a literal pattern string for the specified string. After quoting the
    String, regex meta characters or escape sequences in the input string will just
    be literals without any special meaning.
  prefs: []
  type: TYPE_NORMAL
- en: String quote(String str)
  prefs: []
  type: TYPE_NORMAL
- en: the given string in \\Q and \\E escape constructs. These special escape constructs
    are used to make a wrapped string as a literal string, thus removing all the special
    meanings of regex meta and special characters.
  prefs: []
  type: TYPE_NORMAL
- en: asPredicate
  prefs: []
  type: TYPE_NORMAL
- en: Predicate<String>
  prefs: []
  type: TYPE_NORMAL
- en: ()
  prefs: []
  type: TYPE_NORMAL
- en: Creates a Predicate of a string to match the input string.
  prefs: []
  type: TYPE_NORMAL
- en: Predicate<String> asPredicate ()
  prefs: []
  type: TYPE_NORMAL
- en: Stream<String>
  prefs: []
  type: TYPE_NORMAL
- en: Splits the given input string using this pattern and creates a stream splitAsStream(CharSequence
  prefs: []
  type: TYPE_NORMAL
- en: from the given input sequence around the matches of this pattern
  prefs: []
  type: TYPE_NORMAL
- en: input)
  prefs: []
  type: TYPE_NORMAL
- en: (added in Java 8).
  prefs: []
  type: TYPE_NORMAL
- en: Splits the given input sequence around the matches of this pattern. It is String[]
    split(CharSequence input)
  prefs: []
  type: TYPE_NORMAL
- en: the same as String.split(String regex).
  prefs: []
  type: TYPE_NORMAL
- en: Splits the given input sequence around the matches of this pattern. The String[]
    split(CharSequence input,
  prefs: []
  type: TYPE_NORMAL
- en: limit parameter controls the number of times the pattern is applied and, int
    limit)
  prefs: []
  type: TYPE_NORMAL
- en: therefore, affects the length of the resulting array. It is the same as String.split(String
    regex, int limit).
  prefs: []
  type: TYPE_NORMAL
- en: 'The Pattern class has a static method that can be called to match a string
    against a regular expression. This is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: boolean matches(String regex, CharSequence input)
  prefs: []
  type: TYPE_NORMAL
- en: 'It can be used instead of the following:'
  prefs: []
  type: TYPE_NORMAL
- en: final Pattern p = Pattern.compile(regex);
  prefs: []
  type: TYPE_NORMAL
- en: Matcher m = p.matcher(input);
  prefs: []
  type: TYPE_NORMAL
- en: m.matches();
  prefs: []
  type: TYPE_NORMAL
- en: This is actually the JDK9 implementation of this method. Although it is simpler
    and shorter to call this method instead of three lines, it is recommended to use
    the methods compile(), matcher(), and matches() separately if we perform matching
    against the same regular expression many times. In such a case, we can invoke
    compile() only the first time and keep the compiled pattern and avoid recompilation
    each time the matching is performed.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image 16](img/index-116_1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**Examples using the Pattern**'
  prefs: []
  type: TYPE_NORMAL
- en: '**class**'
  prefs: []
  type: TYPE_NORMAL
- en: Let's look at a few examples to understand some of these methods.
  prefs: []
  type: TYPE_NORMAL
- en: 'To compile a regular expression for decimal numbers, we can use the following
    code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: final String decimalPattern = "^[+-]?\\d*\\.?\\d+$"; Final Pattern pattern =
    Pattern.compile(decimalPattern);
  prefs: []
  type: TYPE_NORMAL
- en: The static method, Pattern.compile, compiles a string regex and returns a Pattern
    instance.
  prefs: []
  type: TYPE_NORMAL
- en: 'To match text between ## and ## that may include newlines as well, we can use
    the following compiled pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: final String re = "##.*?##";
  prefs: []
  type: TYPE_NORMAL
- en: 'Final Pattern pattern = Pattern.compile(re, Pattern.DOTALL); Here, we are using
    two parameters: the Pattern.compile method and passing DOTALL as a flag in the
    second parameter, since we want to match the newline as well as using our lazy
    pattern .*?.'
  prefs: []
  type: TYPE_NORMAL
- en: '*Note the use of lazy pattern .*? instead of greedy .* so that we match* *the
    shortest match between ## and ##.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also write the preceding code snippet using the inline mode modifier,
    (?s): final String re = "(?s)##.*?##";'
  prefs: []
  type: TYPE_NORMAL
- en: Final Pattern pattern = Pattern.compile(re);
  prefs: []
  type: TYPE_NORMAL
- en: 'If we want to match a string that contains a subsequence, +-*/., surrounded
    by one or more white spaces on both the sides, then we can use the following code:
    package example.regex;'
  prefs: []
  type: TYPE_NORMAL
- en: import java.util.*;
  prefs: []
  type: TYPE_NORMAL
- en: import java.util.regex.*;
  prefs: []
  type: TYPE_NORMAL
- en: class PatternQuoteExample
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: public static void main (String[] args)
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: 'String input = "Math operators: +-*/. ";'
  prefs: []
  type: TYPE_NORMAL
- en: boolean result;
  prefs: []
  type: TYPE_NORMAL
- en: String quoted = Pattern.quote("+-*/.");
  prefs: []
  type: TYPE_NORMAL
- en: System.out.println(quoted);
  prefs: []
  type: TYPE_NORMAL
- en: // regex using standard escaping
  prefs: []
  type: TYPE_NORMAL
- en: result = input.matches(".*\\s+\\+-\\*/\\.\\s+.*"); System.out.println(result);
  prefs: []
  type: TYPE_NORMAL
- en: // regex Using Pattern.quote around our search string
  prefs: []
  type: TYPE_NORMAL
- en: result = input.matches(".*\\s+" + quoted + "\\s+.*");
  prefs: []
  type: TYPE_NORMAL
- en: System.out.println(result);
  prefs: []
  type: TYPE_NORMAL
- en: // regex Using \Q and \E around our search string
  prefs: []
  type: TYPE_NORMAL
- en: result = input.matches(".*\\s+\\Q+-*/.\\E\\s+.*"); System.out.println(result);
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: 'After compiling and running this code, will quoted string as: "\Q+-*/.\E" and
    then print true for all the three cases as the call to matches succeeds all the
    times. However, an important difference is the use of Pattern.quote in the second
    case, which handles the quoting of special regex characters in the search string,
    such as +, *, .'
  prefs: []
  type: TYPE_NORMAL
- en: Then, in the third case, we just wrap our search string using \\Q and \\E, which
    is the same as calling Pattern.quote with our search string.
  prefs: []
  type: TYPE_NORMAL
- en: 'To split an input text on two pipes or ||, we can use following code: package
    example.regex;'
  prefs: []
  type: TYPE_NORMAL
- en: import java.util.*;
  prefs: []
  type: TYPE_NORMAL
- en: import java.util.regex.*;
  prefs: []
  type: TYPE_NORMAL
- en: class PatternSplitExample
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: public static void main (String[] args)
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: final String input = "value1||value2||value3";
  prefs: []
  type: TYPE_NORMAL
- en: final Pattern p = Pattern.compile(Pattern.quote("||"));
  prefs: []
  type: TYPE_NORMAL
- en: // call split and print each element from generated array
  prefs: []
  type: TYPE_NORMAL
- en: // using stream API
  prefs: []
  type: TYPE_NORMAL
- en: Arrays.stream(p.split(input))
  prefs: []
  type: TYPE_NORMAL
- en: .forEach(System.out::println);
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following few points about this code:'
  prefs: []
  type: TYPE_NORMAL
- en: We call Pattern.quote to avoid escaping double pipe string We call Pattern.compile
    to compile our string regex and get back a compiled Pattern object
  prefs: []
  type: TYPE_NORMAL
- en: We use a generated pattern instance to call the split method by supplying an
    input string that we want to operate on
  prefs: []
  type: TYPE_NORMAL
- en: 'Java 8 added a new method, splitAsStream, which returns a stream containing
    the substring from the given input sequence around the matches of this pattern.
    Using splitAsStream, we can simplify the preceding class as follows: package example.regex;'
  prefs: []
  type: TYPE_NORMAL
- en: import java.util.*;
  prefs: []
  type: TYPE_NORMAL
- en: import java.util.regex.*;
  prefs: []
  type: TYPE_NORMAL
- en: class PatternSplitStreamExample
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: public static void main (String[] args) throws java.lang.Exception
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: final String input = "value1||value2||value3";
  prefs: []
  type: TYPE_NORMAL
- en: final Pattern p = Pattern.compile(Pattern.quote("||"));
  prefs: []
  type: TYPE_NORMAL
- en: // call splitAsStream and print each element from generated stream p.splitAsStream(input)
  prefs: []
  type: TYPE_NORMAL
- en: .forEach(System.out::println);
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: Note the use of the splitAsStream method instead of the Arrays.stream() static
    method
  prefs: []
  type: TYPE_NORMAL
- en: in this class. Creating an array performs the whole split. When Pattern returns
    a stream, it can do the splitting only when it is needed. If we, for example,
    limit the stream to work up only the first 10 elements, then the splitting does
    not need to do the splitting for further elements.
  prefs: []
  type: TYPE_NORMAL
- en: It is true even if some of the implementations just do the splitting and return
    an array based stream from splitAsStream(). A different implementation of the
    JDK is free to use a better solution only if we use splitAsStream() but has no
    choice if we use split() and convert to stream afterward.
  prefs: []
  type: TYPE_NORMAL
- en: '**Filtering a list of tokens**'
  prefs: []
  type: TYPE_NORMAL
- en: '**using the asPredicate()**'
  prefs: []
  type: TYPE_NORMAL
- en: '**method**'
  prefs: []
  type: TYPE_NORMAL
- en: 'As noted in the preceding table, the asPredicate() method creates a predicate
    that can be used to match an input string. Let''s look at an example code listing
    to understand this method better:'
  prefs: []
  type: TYPE_NORMAL
- en: package example.regex;
  prefs: []
  type: TYPE_NORMAL
- en: import java.util.List;
  prefs: []
  type: TYPE_NORMAL
- en: import java.util.stream.*;
  prefs: []
  type: TYPE_NORMAL
- en: import java.util.regex.*;
  prefs: []
  type: TYPE_NORMAL
- en: public class AsPredicateExample
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: public static void main(String[] args)
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: final String[] monthsArr =
  prefs: []
  type: TYPE_NORMAL
- en: '{"10", "0", "05", "09", "12", "15", "00", "-1", "100"}; final Pattern validMonthPattern
    ='
  prefs: []
  type: TYPE_NORMAL
- en: Pattern.compile("^(?:0?[1-9]|1[00-2])$");
  prefs: []
  type: TYPE_NORMAL
- en: List<String> filteredMonths = Stream.of(monthsArr)
  prefs: []
  type: TYPE_NORMAL
- en: .filter(validMonthPattern.asPredicate())
  prefs: []
  type: TYPE_NORMAL
- en: .collect(Collectors.toList());
  prefs: []
  type: TYPE_NORMAL
- en: System.out.println(filteredMonths);
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: This code has a list of month numbers as an array of String. The valid months
    are between 1 and 12 with an optional 0 before the single-digit months.
  prefs: []
  type: TYPE_NORMAL
- en: 'We use the following regex pattern for a valid month number:'
  prefs: []
  type: TYPE_NORMAL
- en: ^(?:0?[1-9]|1[00-2])$
  prefs: []
  type: TYPE_NORMAL
- en: We use the return value of the asPredicate() method to filter the stream of
    string array containing all the input month values.
  prefs: []
  type: TYPE_NORMAL
- en: 'After compiling and running, the preceding code will print the following output,
    which is a filtered list from the original list containing all the valid month
    numbers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[10, 05, 09, 12]'
  prefs: []
  type: TYPE_NORMAL
- en: '**The Matcher class**'
  prefs: []
  type: TYPE_NORMAL
- en: 'An instance of the Matcher class performs various match operations on a character
    sequence by interpreting a compiled regular expression represented by an instance
    of Pattern. This is how we use this class to match a regex:'
  prefs: []
  type: TYPE_NORMAL
- en: We create a matcher instance from a pattern by invoking the pattern's matcher
    method that requires the input sequence as argument
  prefs: []
  type: TYPE_NORMAL
- en: 'The instance of matcher is used to perform three types of match operations
    using these three methods, each returning a Boolean value (true indicates success):
    matches'
  prefs: []
  type: TYPE_NORMAL
- en: find
  prefs: []
  type: TYPE_NORMAL
- en: lookingAt
  prefs: []
  type: TYPE_NORMAL
- en: 'These methods perform the matching in the following manner: The matches method
    attempts to match the *complete input sequence* using the matcher''s pattern'
  prefs: []
  type: TYPE_NORMAL
- en: The find method *searches* the input sequence for the next substring that matches
    the pattern
  prefs: []
  type: TYPE_NORMAL
- en: The lookingAt method attempts to match the input sequence using the matcher's
    pattern *at the start position*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s list down all the important methods from the Matcher class here: Method
    Signature'
  prefs: []
  type: TYPE_NORMAL
- en: Description
  prefs: []
  type: TYPE_NORMAL
- en: Using the matcher's pattern attempts to find
  prefs: []
  type: TYPE_NORMAL
- en: boolean find()
  prefs: []
  type: TYPE_NORMAL
- en: the next matching substring of the input text.
  prefs: []
  type: TYPE_NORMAL
- en: This is the same as the previous, except that
  prefs: []
  type: TYPE_NORMAL
- en: boolean find(int start)
  prefs: []
  type: TYPE_NORMAL
- en: the search starts at the start position.
  prefs: []
  type: TYPE_NORMAL
- en: boolean matches()
  prefs: []
  type: TYPE_NORMAL
- en: Attempts to match the complete input text..
  prefs: []
  type: TYPE_NORMAL
- en: Attempts to match the input text, starting at
  prefs: []
  type: TYPE_NORMAL
- en: boolean lookingAt()
  prefs: []
  type: TYPE_NORMAL
- en: the beginning of the region. It does not need to
  prefs: []
  type: TYPE_NORMAL
- en: match the complete input text.
  prefs: []
  type: TYPE_NORMAL
- en: Returns the complete input text matched by
  prefs: []
  type: TYPE_NORMAL
- en: String group()
  prefs: []
  type: TYPE_NORMAL
- en: the previous match.
  prefs: []
  type: TYPE_NORMAL
- en: String group(int group)
  prefs: []
  type: TYPE_NORMAL
- en: Returns the input text captured by the
  prefs: []
  type: TYPE_NORMAL
- en: specified group number during the previous
  prefs: []
  type: TYPE_NORMAL
- en: match operation.
  prefs: []
  type: TYPE_NORMAL
- en: Returns the input text captured by the given
  prefs: []
  type: TYPE_NORMAL
- en: String group(String groupName)
  prefs: []
  type: TYPE_NORMAL
- en: named group during the previous match
  prefs: []
  type: TYPE_NORMAL
- en: operation.
  prefs: []
  type: TYPE_NORMAL
- en: Returns the number of capturing groups in this
  prefs: []
  type: TYPE_NORMAL
- en: int groupCount()
  prefs: []
  type: TYPE_NORMAL
- en: matcher's pattern.
  prefs: []
  type: TYPE_NORMAL
- en: Returns the start index of the previous match
  prefs: []
  type: TYPE_NORMAL
- en: int start()
  prefs: []
  type: TYPE_NORMAL
- en: operation.
  prefs: []
  type: TYPE_NORMAL
- en: Returns the start position of the text captured
  prefs: []
  type: TYPE_NORMAL
- en: int start(int group)
  prefs: []
  type: TYPE_NORMAL
- en: by the given group number during the
  prefs: []
  type: TYPE_NORMAL
- en: previous match operation.
  prefs: []
  type: TYPE_NORMAL
- en: Returns the start position of the text captured
  prefs: []
  type: TYPE_NORMAL
- en: int start(int groupName)
  prefs: []
  type: TYPE_NORMAL
- en: by the given named group during the previous
  prefs: []
  type: TYPE_NORMAL
- en: match operation.
  prefs: []
  type: TYPE_NORMAL
- en: Returns the end position of the previous match
  prefs: []
  type: TYPE_NORMAL
- en: int end()
  prefs: []
  type: TYPE_NORMAL
- en: operation.
  prefs: []
  type: TYPE_NORMAL
- en: Returns the end position of the text captured
  prefs: []
  type: TYPE_NORMAL
- en: int end(int group)
  prefs: []
  type: TYPE_NORMAL
- en: by the given group number during the
  prefs: []
  type: TYPE_NORMAL
- en: previous match operation.
  prefs: []
  type: TYPE_NORMAL
- en: Returns the end position of the text captured
  prefs: []
  type: TYPE_NORMAL
- en: int end(int groupName)
  prefs: []
  type: TYPE_NORMAL
- en: by the given named group during the previous
  prefs: []
  type: TYPE_NORMAL
- en: match operation.
  prefs: []
  type: TYPE_NORMAL
- en: Matcher
  prefs: []
  type: TYPE_NORMAL
- en: Appends the given replacement text to the
  prefs: []
  type: TYPE_NORMAL
- en: appendReplacement(StringBuffer
  prefs: []
  type: TYPE_NORMAL
- en: string buffer after the last character of the
  prefs: []
  type: TYPE_NORMAL
- en: buffer, String replacement)
  prefs: []
  type: TYPE_NORMAL
- en: previous match in the string buffer.
  prefs: []
  type: TYPE_NORMAL
- en: This method reads characters from the input
  prefs: []
  type: TYPE_NORMAL
- en: text, starting at the append position, and
  prefs: []
  type: TYPE_NORMAL
- en: appends them to the given string buffer. It is
  prefs: []
  type: TYPE_NORMAL
- en: StringBuffer
  prefs: []
  type: TYPE_NORMAL
- en: intended to be invoked after one or more
  prefs: []
  type: TYPE_NORMAL
- en: appendTail(StringBuffer buffer)
  prefs: []
  type: TYPE_NORMAL
- en: invocations of the appendReplacement method in
  prefs: []
  type: TYPE_NORMAL
- en: order to copy the remainder of the input text to the buffer.
  prefs: []
  type: TYPE_NORMAL
- en: Returns a literal replacement String for the
  prefs: []
  type: TYPE_NORMAL
- en: Static String
  prefs: []
  type: TYPE_NORMAL
- en: specified String. It makes backslashes and
  prefs: []
  type: TYPE_NORMAL
- en: quoteReplacement(String s)
  prefs: []
  type: TYPE_NORMAL
- en: dollar signs to be treated literally.
  prefs: []
  type: TYPE_NORMAL
- en: Using the current matcher's pattern, it replaces
  prefs: []
  type: TYPE_NORMAL
- en: String replaceAll(String
  prefs: []
  type: TYPE_NORMAL
- en: all the matched substrings of the input text
  prefs: []
  type: TYPE_NORMAL
- en: replacement)
  prefs: []
  type: TYPE_NORMAL
- en: with the given replacement string.
  prefs: []
  type: TYPE_NORMAL
- en: Using the current matcher's pattern, it replaces
  prefs: []
  type: TYPE_NORMAL
- en: String replaceFirst(String
  prefs: []
  type: TYPE_NORMAL
- en: the first matched substring of the input text
  prefs: []
  type: TYPE_NORMAL
- en: replacement)
  prefs: []
  type: TYPE_NORMAL
- en: with the given replacement string.
  prefs: []
  type: TYPE_NORMAL
- en: Resets this matcher object and initializes all
  prefs: []
  type: TYPE_NORMAL
- en: Matcher reset()
  prefs: []
  type: TYPE_NORMAL
- en: the internal states.
  prefs: []
  type: TYPE_NORMAL
- en: Matcher reset(CharSequence
  prefs: []
  type: TYPE_NORMAL
- en: Resets this matcher object with a new input
  prefs: []
  type: TYPE_NORMAL
- en: input)
  prefs: []
  type: TYPE_NORMAL
- en: text and initializes all the internal states.
  prefs: []
  type: TYPE_NORMAL
- en: Returns the match result of the matcher that
  prefs: []
  type: TYPE_NORMAL
- en: represents state of the match. This method is
  prefs: []
  type: TYPE_NORMAL
- en: MatchResult toMatchResult()
  prefs: []
  type: TYPE_NORMAL
- en: usually called after one of the
  prefs: []
  type: TYPE_NORMAL
- en: find/matches/lookingAt method calls.
  prefs: []
  type: TYPE_NORMAL
- en: Matcher usePattern(Pattern
  prefs: []
  type: TYPE_NORMAL
- en: Updates the pattern used by this matcher to
  prefs: []
  type: TYPE_NORMAL
- en: newPattern)
  prefs: []
  type: TYPE_NORMAL
- en: find new matches.
  prefs: []
  type: TYPE_NORMAL
- en: '**Examples using the Matcher**'
  prefs: []
  type: TYPE_NORMAL
- en: '**class**'
  prefs: []
  type: TYPE_NORMAL
- en: The Matcher class represents the main regular expression engine in Java that
    provides all the functionality and features required to match regular expressions
    against input.
  prefs: []
  type: TYPE_NORMAL
- en: Let's look at some important methods of this class with practical examples to
    understand their use.
  prefs: []
  type: TYPE_NORMAL
- en: '**Method Boolean lookingAt()**'
  prefs: []
  type: TYPE_NORMAL
- en: 'The lookingAt()method attempts to match the input against the pattern, starting
    from the *beginning* of the input but without requiring that the entire region
    be matched against the pattern. The following code demonstrates it:'
  prefs: []
  type: TYPE_NORMAL
- en: package example.regex;
  prefs: []
  type: TYPE_NORMAL
- en: import java.util.regex.*;
  prefs: []
  type: TYPE_NORMAL
- en: class MatcherLookingatExample
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: public static void main (String[] args)
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: final Pattern pattern1 = Pattern.compile("master[a-z]*"); final Pattern pattern2
    = Pattern.compile("master"); final Pattern pattern3 = Pattern.compile("regular");
    String input = "mastering regular expressions"; Matcher matcher = pattern1.matcher(input);
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.printf("[%s] => [%s]: %s%n", input, matcher.pattern(), matcher.lookingAt());'
  prefs: []
  type: TYPE_NORMAL
- en: // update the matcher's pattern with a new pattern
  prefs: []
  type: TYPE_NORMAL
- en: matcher.usePattern(pattern2);
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.printf("[%s] => [%s]: %s%n", input, matcher.pattern(), matcher.lookingAt());'
  prefs: []
  type: TYPE_NORMAL
- en: // update the matcher's pattern with a new pattern
  prefs: []
  type: TYPE_NORMAL
- en: matcher.usePattern(pattern3);
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.printf("[%s] => [%s]: %s%n", input, matcher.pattern(), matcher.lookingAt());'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: 'Upon compiling and running, the preceding code produces following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[mastering regular expressions] => [master[a-z]*]: true'
  prefs: []
  type: TYPE_NORMAL
- en: '[mastering regular expressions] => [master]: true'
  prefs: []
  type: TYPE_NORMAL
- en: '[mastering regular expressions] => [regular]: false'
  prefs: []
  type: TYPE_NORMAL
- en: You can see that the lookingAt()method returns true only when we supply patterns
    that are at the starting of the input, such as master[a-z]* and master, but returns
    false when we supply a pattern that is in the middle, such as regular.
  prefs: []
  type: TYPE_NORMAL
- en: '**The matches() method**'
  prefs: []
  type: TYPE_NORMAL
- en: The matches() method attempts to match the entire region against the pattern
    and returns true only if the entire region matches against the pattern.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at the following code to understand the use of this method better:
    package example.regex;'
  prefs: []
  type: TYPE_NORMAL
- en: import java.util.regex.*;
  prefs: []
  type: TYPE_NORMAL
- en: class MatcherMatchesExample
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: public static void main (String[] args)
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: final Pattern pattern1 = Pattern.compile("mastering"); final Pattern pattern2
    = Pattern.compile("mastering.*"); final Pattern pattern3 = Pattern.compile("regular.*");
    String input = "mastering regular expressions"; Matcher matcher = pattern1.matcher(input);
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.printf("[%s] => [%s]: %s%n", input, matcher.pattern(), matcher.matches());'
  prefs: []
  type: TYPE_NORMAL
- en: // update the matcher ppattern with a new pattern
  prefs: []
  type: TYPE_NORMAL
- en: matcher.usePattern(pattern2);
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.printf("[%s] => [%s]: %s%n", input, matcher.pattern(), matcher.matches());'
  prefs: []
  type: TYPE_NORMAL
- en: // update the matcher ppattern with a new pattern
  prefs: []
  type: TYPE_NORMAL
- en: matcher.usePattern(pattern3);
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.printf("[%s] => [%s]: %s%n", input, matcher.pattern(), matcher.matches());'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: 'This will give following output after running:'
  prefs: []
  type: TYPE_NORMAL
- en: '[mastering regula expressions] => [mastering]: false'
  prefs: []
  type: TYPE_NORMAL
- en: '[mastering regula expressions] => [mastering.*]: true'
  prefs: []
  type: TYPE_NORMAL
- en: '[mastering regula expressions] => [regular.*]: false'
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see, we get true only when our pattern matches the entire region
    from the start to end, which is using this regex: mastering.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**The find() and find(int start)**'
  prefs: []
  type: TYPE_NORMAL
- en: '**methods**'
  prefs: []
  type: TYPE_NORMAL
- en: These find methods attempt to find the next subsequence of the input sequence
    that matches the pattern. These methods return true only if a subsequence of the
    input matches this matcher's pattern. If multiple matches can be found in the
    text, then the find() method will find the first, and then for each subsequent
    call to find(), it will move to the next match.
  prefs: []
  type: TYPE_NORMAL
- en: 'An example code will make it clearer:'
  prefs: []
  type: TYPE_NORMAL
- en: package example.regex;
  prefs: []
  type: TYPE_NORMAL
- en: import java.util.regex.*;
  prefs: []
  type: TYPE_NORMAL
- en: class MatcherFindExample
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: public static void main (String[] args)
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: final String input = "some text <value1> anything <value2><value3> here";
  prefs: []
  type: TYPE_NORMAL
- en: /* Part 1 */
  prefs: []
  type: TYPE_NORMAL
- en: final Pattern pattern = Pattern.compile("<([^<>]*)>"); Matcher matcher = pattern.matcher(input);
  prefs: []
  type: TYPE_NORMAL
- en: while (matcher.find()) {
  prefs: []
  type: TYPE_NORMAL
- en: System.out.printf("[%d] => [%s]%n",
  prefs: []
  type: TYPE_NORMAL
- en: matcher.groupCount(), matcher.group(1));
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: /* Part 2 */
  prefs: []
  type: TYPE_NORMAL
- en: // now use similar pattern but use a named group and reset the
  prefs: []
  type: TYPE_NORMAL
- en: // matcher
  prefs: []
  type: TYPE_NORMAL
- en: matcher.usePattern(Pattern.compile("<(?<name>[^<>]*)>")); matcher.reset();
  prefs: []
  type: TYPE_NORMAL
- en: while (matcher.find()) {
  prefs: []
  type: TYPE_NORMAL
- en: System.out.printf("[%d] => [%s]%n",
  prefs: []
  type: TYPE_NORMAL
- en: matcher.groupCount(), matcher.group("name"));
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: 'This will output the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[1] => [value1]'
  prefs: []
  type: TYPE_NORMAL
- en: '[1] => [value2]'
  prefs: []
  type: TYPE_NORMAL
- en: '[1] => [value3]'
  prefs: []
  type: TYPE_NORMAL
- en: '[1] => [value1]'
  prefs: []
  type: TYPE_NORMAL
- en: '[1] => [value2]'
  prefs: []
  type: TYPE_NORMAL
- en: '[1] => [value3]'
  prefs: []
  type: TYPE_NORMAL
- en: As you can see in the preceding code, we are extracting all the text that is
    inside the angular brackets using a negated character class, [^<>]*, inside a
    capturing group.
  prefs: []
  type: TYPE_NORMAL
- en: In Part 1 of the code, we use regular captured group and matcher.group(1) to
    extract and print the subsequence captured in group number 1\. The numbering of
    the groups starts each time we execute find() and the previous captures are wiped
    off. Even though it is in a loop, it is always group(1) in the example because
    for each iteration, there can be more than one group.
  prefs: []
  type: TYPE_NORMAL
- en: In Part 2, we use a named capturing group and an overloaded method call to matcher.group("name")
    to extract the subsequence captured by the given group name.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image 17](img/index-128_1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**The**'
  prefs: []
  type: TYPE_NORMAL
- en: '**appendReplacement(StringBuffer**'
  prefs: []
  type: TYPE_NORMAL
- en: '**sb, String replacement)**'
  prefs: []
  type: TYPE_NORMAL
- en: '**method**'
  prefs: []
  type: TYPE_NORMAL
- en: This method is intended to be used in a loop together with the appendTail and
    find methods. Once we get a match using the find() method, we can call the appendReplacement()
    method to operate on each match and replace the matched text.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, it appends the replaced text to StringBuffer. It reads characters from
    the input sequence, starting at the append position, and appends them to the given
    string buffer.
  prefs: []
  type: TYPE_NORMAL
- en: It stops after reading the last character preceding the previous match, that
    is, the character at index start() - 1\.
  prefs: []
  type: TYPE_NORMAL
- en: The replacement string may contain references to subsequences captured during
    the previous match. All the rules of replacement reference we String.replaceAll
    apply to this method also.
  prefs: []
  type: TYPE_NORMAL
- en: The appendReplacement() method keeps track of what has been copied into StringBuffer,
    so we can keep searching for matches using find() in a loop, until no more matches
    are found in the input text. There will be an example following the next section.
  prefs: []
  type: TYPE_NORMAL
- en: '*Java 9 has another overloaded signature of this method to start* *accepting
    StringBuilder instead of StringBuffer as the first parameter.*'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image 18](img/index-129_1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**The**'
  prefs: []
  type: TYPE_NORMAL
- en: '**appendTail(StringBuffer sb)**'
  prefs: []
  type: TYPE_NORMAL
- en: '**method**'
  prefs: []
  type: TYPE_NORMAL
- en: This method reads characters from the input sequence, starting at the append
    position, and appends them to the given string buffer. It is intended to be invoked
    after one or more invocations of the appendReplacement method in order to copy
    the remainder of the input sequence.
  prefs: []
  type: TYPE_NORMAL
- en: '*Just like in the case of the appendReplacement() method, there is also an*
    *overloaded version of the appendTail() method that accepts* *StringBuilder, which
    is not synchronized, instead of StringBuffer, which* *is synchronized.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Example of the**'
  prefs: []
  type: TYPE_NORMAL
- en: '**appendReplacement and**'
  prefs: []
  type: TYPE_NORMAL
- en: '**appendTail methods**'
  prefs: []
  type: TYPE_NORMAL
- en: Let's look at a complete program to the understand use of these methods.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following input:'
  prefs: []
  type: TYPE_NORMAL
- en: <n1=v1 n2=v2 n3=v3> n1=v1 n2=v2 abc=123 <v=pq id=abc> v=pq We need to write
    code to swap each name-value pair enclosed in angular brackets, < and >, while
    leaving the name-value pairs outside the angular brackets unchanged.
  prefs: []
  type: TYPE_NORMAL
- en: 'After running our code, it should produce the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: <v1=n1 v2=n2 v3=n3> n1=v1 n2=v2 abc=123 <pq=v abc=id> v=pq To solve this problem,
    we have to first find each match enclosed in angular brackets using the find method
    in a loop. Inside the loop, we will have to replace each name-value pair using
    the appendReplacement method. Finally, outside the loop, we will use the appendTail
    method to append the remaining characters after our last match.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the full code:'
  prefs: []
  type: TYPE_NORMAL
- en: package example.regex;
  prefs: []
  type: TYPE_NORMAL
- en: import java.util.regex.*;
  prefs: []
  type: TYPE_NORMAL
- en: class MatcherAppendExample
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: public static void main (String[] args)
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: final String input = "<n1=v1 n2=v2 n3=v3> n1=v1 n2=v2 abc=
  prefs: []
  type: TYPE_NORMAL
- en: 123 <v=pq id=abc> v=pq";
  prefs: []
  type: TYPE_NORMAL
- en: // pattern1 to find all matches between < and >
  prefs: []
  type: TYPE_NORMAL
- en: final Pattern pattern = Pattern.compile("<[^>]+>");
  prefs: []
  type: TYPE_NORMAL
- en: // pattern1 to find each name=value pair
  prefs: []
  type: TYPE_NORMAL
- en: final Pattern pairPattern = Pattern.compile("(\\w+)=(\\w+)"); Matcher enclosedPairs
    = pattern.matcher(input);
  prefs: []
  type: TYPE_NORMAL
- en: StringBuilder sbuf = new StringBuilder();
  prefs: []
  type: TYPE_NORMAL
- en: // call find in a loop and call appendReplacement for each match while (enclosedPairs.find())
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: Matcher pairMatcher = pairPattern.matcher(enclosedPairs.group());
  prefs: []
  type: TYPE_NORMAL
- en: // replace name=value with value=name in each match
  prefs: []
  type: TYPE_NORMAL
- en: enclosedPairs.appendReplacement(sbuf,
  prefs: []
  type: TYPE_NORMAL
- en: pairMatcher.replaceAll("$2=$1"));
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: // appendTail to append remaining character to buffer
  prefs: []
  type: TYPE_NORMAL
- en: enclosedPairs.appendTail(sbuf);
  prefs: []
  type: TYPE_NORMAL
- en: System.out.println(sbuf);
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: 'Upon compiling and running, the preceding code will produce the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: <v1=n1 v2=n2 v3=n3> n1=v1 n2=v2 abc=123 <pq=v abc=id> v=pq As you can see, the
    final output has all the name=value pairs swapped inside the angular brackets.
  prefs: []
  type: TYPE_NORMAL
- en: '**Summary**'
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, you learned about the most important regular expression handling
    Java classes. The Matcher and Pattern classes are heavy and complex tools that
    can be used to get really far when it comes to string manipulation. We have seen
    an example of a compound task, transforming name-value pairs inside a string,
    enclosed between angular brackets. If you imagine how hard it would have been
    without regular expressions and these classes, then you realize the power you
    now have in your hand after this chapter; it is almost wizard-level.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will move on to advanced topics of regular expressions,
    such as zero-width assertions, using the lookahead and lookbehind assertions,
    atomic groups, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: '**Exploring Zero-Width**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Assertions, Lookarounds,**'
  prefs: []
  type: TYPE_NORMAL
- en: '**and Atomic Groups**'
  prefs: []
  type: TYPE_NORMAL
- en: You will learn about zero-width assertions in Java regular expressions. We will
    cover various zero-width assertions and their usage patterns. We will then move
    on to learn the important topic of lookahead and lookbehind assertions in Java
    regular expressions and how to use them to solve some important problems. We will
    also discuss the use of atomic groups in Java regular expressions.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will cover the following topics in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Zero-width assertions
  prefs: []
  type: TYPE_NORMAL
- en: Previous match boundary
  prefs: []
  type: TYPE_NORMAL
- en: Atomic groups
  prefs: []
  type: TYPE_NORMAL
- en: 'Lookahead assertions: positive and negative'
  prefs: []
  type: TYPE_NORMAL
- en: 'Lookbehind assertions: positive and negative'
  prefs: []
  type: TYPE_NORMAL
- en: Capturing text from overlapping matches
  prefs: []
  type: TYPE_NORMAL
- en: Capturing groups inside lookahead and lookbehind groups
  prefs: []
  type: TYPE_NORMAL
- en: Lookbehind limitations in Java regular expressions
  prefs: []
  type: TYPE_NORMAL
- en: '![Image 19](img/index-134_1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**Zero-width assertions**'
  prefs: []
  type: TYPE_NORMAL
- en: Zero-width or zero-length assertion in regular expressions means that there
    is a zero-length match that does not change the current position of the pointer
    in the input string. These assertions do not consume characters in the string
    but only assert whether a match is possible or not, giving us a binary true or
    false match result.
  prefs: []
  type: TYPE_NORMAL
- en: Although many zero-width assertions are denoted inside parentheses, like groups,
    we will soon see that they do not capture any text. Zero-width assertions have
    no real meaning in back-references or in replacements.
  prefs: []
  type: TYPE_NORMAL
- en: '*We have already discussed a few zero-width assertions in the previous* *chapters,
    such as anchors and boundary assertions.*'
  prefs: []
  type: TYPE_NORMAL
- en: The Java regular expression engine allows many predefined zero-width assertions,
    including the ones we have discussed already, such as start, end anchors, and
    word boundaries.
  prefs: []
  type: TYPE_NORMAL
- en: '**Predefined zero-width**'
  prefs: []
  type: TYPE_NORMAL
- en: '**assertions**'
  prefs: []
  type: TYPE_NORMAL
- en: Zero-width
  prefs: []
  type: TYPE_NORMAL
- en: Description
  prefs: []
  type: TYPE_NORMAL
- en: Assertion
  prefs: []
  type: TYPE_NORMAL
- en: \b
  prefs: []
  type: TYPE_NORMAL
- en: Asserts a word boundary
  prefs: []
  type: TYPE_NORMAL
- en: \B
  prefs: []
  type: TYPE_NORMAL
- en: Asserts anywhere except at a word boundary
  prefs: []
  type: TYPE_NORMAL
- en: ^
  prefs: []
  type: TYPE_NORMAL
- en: Asserts position only at the beginning of a line
  prefs: []
  type: TYPE_NORMAL
- en: $
  prefs: []
  type: TYPE_NORMAL
- en: Asserts position only at the end of a line
  prefs: []
  type: TYPE_NORMAL
- en: \A
  prefs: []
  type: TYPE_NORMAL
- en: Asserts position only at the beginning of a string
  prefs: []
  type: TYPE_NORMAL
- en: \z
  prefs: []
  type: TYPE_NORMAL
- en: Asserts position only at the end of a string
  prefs: []
  type: TYPE_NORMAL
- en: Asserts position only at the end of a string or before the line break
  prefs: []
  type: TYPE_NORMAL
- en: \Z
  prefs: []
  type: TYPE_NORMAL
- en: at the end of a string (if present)
  prefs: []
  type: TYPE_NORMAL
- en: Asserts position at the end of the previous match or at the start of
  prefs: []
  type: TYPE_NORMAL
- en: \G
  prefs: []
  type: TYPE_NORMAL
- en: the string for the very first match
  prefs: []
  type: TYPE_NORMAL
- en: '**Regex defined zero-width**'
  prefs: []
  type: TYPE_NORMAL
- en: '**assertions**'
  prefs: []
  type: TYPE_NORMAL
- en: Regex defined zero-width assertions use ( and ) and there is a ? after the opening
    (.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two assertions: positive, denoted by the = character, and negative,
    denoted by the ! character. If the assertion is backward-looking then the ? character
    is followed by a < character. Thus, (?=...) is a positive lookahead assertion
    and (?<!...) is a negative lookbehind assertion.'
  prefs: []
  type: TYPE_NORMAL
- en: The positive lookahead assertion ensures that the string matches the pattern
    after the current position. For example, abc(?=K) ensures that (?=pattern)
  prefs: []
  type: TYPE_NORMAL
- en: the characters "abc" in the checked strings are followed by the letter
  prefs: []
  type: TYPE_NORMAL
- en: '"K", but this check does not consume the character "K".'
  prefs: []
  type: TYPE_NORMAL
- en: The negative lookahead assertion ensures that the string does not match the
    pattern after the current position. For example, abc(?!Z) (?!pattern)
  prefs: []
  type: TYPE_NORMAL
- en: ensures that the characters "abc" in the checked string are not followed by
    the letter "Z", but this check does not consume the character "Z".
  prefs: []
  type: TYPE_NORMAL
- en: The positive lookbehind assertion ensures that the string matches the (?
  prefs: []
  type: TYPE_NORMAL
- en: pattern before the current position. For example, (?<=P)abc ensures
  prefs: []
  type: TYPE_NORMAL
- en: <=pattern)
  prefs: []
  type: TYPE_NORMAL
- en: that the characters "abc" in the checked string are preceded by the letter "P",
    but this check does not consume the character "P".
  prefs: []
  type: TYPE_NORMAL
- en: The negative lookbehind assertion ensures that the string does not match the
    pattern before the current position. For example, (?<!Q)abc (?
  prefs: []
  type: TYPE_NORMAL
- en: ensures that the characters "
  prefs: []
  type: TYPE_NORMAL
- en: <!pattern)
  prefs: []
  type: TYPE_NORMAL
- en: abc" in the checked string are not
  prefs: []
  type: TYPE_NORMAL
- en: preceded by the letter "Q", but this check does not consume the character "Q".
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will look into more details of the \G boundary assertions,
    and then, you will learn about the lookahead and lookbehind assertions. However,
    before the lookarounds, we will discuss atomic groups, which are an important
    construct and topic to ease the understanding of the behavior of the lookahead
    and lookbehind assertions.
  prefs: []
  type: TYPE_NORMAL
- en: '**\G boundary assertion**'
  prefs: []
  type: TYPE_NORMAL
- en: \G is a zero-width assertion. It is also a boundary matcher that asserts positions
    at the end of the previous match or at the start of the string, such as the \A
    assertion for the very first match. The Java regex engine remembers the position
    of \G within the context of a Matcher instance. If Matcher is instantiated again
    or is reset, then the position of \G is also initialized to the start of the string.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, consider the following input:'
  prefs: []
  type: TYPE_NORMAL
- en: ',,,,,123,45,67'
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider that we need to replace every comma that occurs only at the start
    of the input with a hyphen so that we have the same number of hyphens as the number
    of commas at the start. Our final output should be the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '-----123,45,67'
  prefs: []
  type: TYPE_NORMAL
- en: We cannot just do replaceAll by matching each comma, since that will also replace
    the comma after 123 and 45, and moreover, we want the same number of hyphens as
    the number of commas in the input string.
  prefs: []
  type: TYPE_NORMAL
- en: 'For cases like this, we can use the \G assertion and use this Java code snippet:
    input = input.replaceAll("\\G,", "-"); Since \G matches the start of the line
    the first time, it will assert the position just before the first comma. Subsequently,
    it matches the positions after each comma, since \G matches the positions at the
    end of the previous match. It will stop matching when the control reaches the
    digit 1\. Each of these matches is replaced by a single hyphen, thus giving us
    the same number of hyphens in the replaced string as the number of leading commas
    in the original input.'
  prefs: []
  type: TYPE_NORMAL
- en: Let's look at another full example to understand the use of \G better.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a sample input:'
  prefs: []
  type: TYPE_NORMAL
- en: '{%var1%, %var2%, %var3%} {%var4%, %var5%, %var6%}'
  prefs: []
  type: TYPE_NORMAL
- en: 'Our task is to replace the % characters with the # (hash) characters in the
    first {...}'
  prefs: []
  type: TYPE_NORMAL
- en: 'section only. We can assume that { and } are perfectly balanced. The expected
    output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '{#var1#, #var2#, #var3#} {%var4%, %var5%, %var6%}'
  prefs: []
  type: TYPE_NORMAL
- en: 'Note how the output has % replaced with # in only the first pair of {...}.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a code listing to solve this problem:'
  prefs: []
  type: TYPE_NORMAL
- en: package example.regex;
  prefs: []
  type: TYPE_NORMAL
- en: class GBoundaryMatcher
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: public static void main (String[] args)
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: String input = "{%var1%, %var2%, %var3%} " +
  prefs: []
  type: TYPE_NORMAL
- en: '"{%var4%, %var5%, %var6%}";'
  prefs: []
  type: TYPE_NORMAL
- en: final String re = "(^[^{]*\\{|\\G(?!^),\\h*)%([^%]+)%";
  prefs: []
  type: TYPE_NORMAL
- en: // now use above regex in replaceAll method String repl = input.replaceAll(re,
    "$1#$2#");
  prefs: []
  type: TYPE_NORMAL
- en: System.out.println(repl);
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: Here is how this regex is doing the job in this code.
  prefs: []
  type: TYPE_NORMAL
- en: 'We use this regex to match our pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: '"(^[^{]*\\{|\\G(?!^),\\h*)%([^%]+)%"'
  prefs: []
  type: TYPE_NORMAL
- en: 'The preceding regex has two groups, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: (^[^{]*\\{|\\G(?!^),\\h*)
  prefs: []
  type: TYPE_NORMAL
- en: 'This is the captured group number one. We are using alternation to select two
    possible patterns here:'
  prefs: []
  type: TYPE_NORMAL
- en: '^[^{]*\\{: This matches all text up to the first { from the start.'
  prefs: []
  type: TYPE_NORMAL
- en: '\\G(?!^),\\h*: This matches text from the end of the previous match followed
    by a comma and zero or more horizontal whitespaces. (?!^) is a negative lookahead
    to avoid matching \G at the start position. This is needed because \G also successfully
    asserts the start of the input string in the first use.'
  prefs: []
  type: TYPE_NORMAL
- en: The %([^%]+)% pattern is our captured group number two. It is the substring
    surrounded by the % characters.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the replacement, we use the following:'
  prefs: []
  type: TYPE_NORMAL
- en: $1#$2#
  prefs: []
  type: TYPE_NORMAL
- en: 'This basically puts back the first group''s captured text and wraps the second
    captured group in # instead of % to get the required output.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Once we compile and run the preceding code, it shows the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '{#var1#, #var2#, #var3#} {%var4%, %var5%, %var6%}'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image 20](img/index-139_1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**Atomic groups**'
  prefs: []
  type: TYPE_NORMAL
- en: An atomic group is a non-capturing group that throws away all the alternative
    positions remembered by any token inside the group when the matching process exits
    the group after the first match of the pattern inside the group. Thus, it avoids
    backtracking to attempt all the alternatives present in the group.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: (?>regex)
  prefs: []
  type: TYPE_NORMAL
- en: Here, the regex may contain alternative patterns. On the other hand, a non-atomic
    group will allow backtracking; it will try to find the first match and then if
    the matching ahead fails, it will backtrack and try to find the next match in
    alternation, until a match for the entire expression is found or all the possibilities
    are exhausted.
  prefs: []
  type: TYPE_NORMAL
- en: 'To understand it better, let''s take an example of a regular expression using
    a non-atomic group:'
  prefs: []
  type: TYPE_NORMAL
- en: ^foo(d|die|lish)$
  prefs: []
  type: TYPE_NORMAL
- en: The input string here is foodie.
  prefs: []
  type: TYPE_NORMAL
- en: It will match the starting pattern foo and then the first alternative d. It
    fails at this time because the end anchor, $, requires that we must be at the
    end of the input string, but we still have two characters, i and e, to be matched.
    Then, the engine attempts to match the second alternative die. This match operation
    succeeds, as the $ anchor asserts true since the input ends there and stops matching
    further with a successful match returned.
  prefs: []
  type: TYPE_NORMAL
- en: '*Even if we use a non-capturing group instead of a capturing group* *here to
    make it ^foo(?:d|die|lish)$, it will have the same effect while* *matching.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, take an example of the same regular expression using an **atomic group**:'
  prefs: []
  type: TYPE_NORMAL
- en: ^foo(?>d|die|lish)$
  prefs: []
  type: TYPE_NORMAL
- en: Note the use of ?> after ( to make it an atomic non-capturing group.
  prefs: []
  type: TYPE_NORMAL
- en: Let's see what happens when we apply the preceding regex against the same input
    string, that is, foodie.
  prefs: []
  type: TYPE_NORMAL
- en: It will match the starting pattern, foo, and then its first alternative, d.
    It fails because the $ anchor asserts false since the input does not end at food.
    However, because of the use of the atomic group, the regex engine gives up immediately
    and doesn't backtrack.
  prefs: []
  type: TYPE_NORMAL
- en: Since the regex engine throws away all the alternative positions remembered
    inside the atomic group, it does not attempt to match the second alternative die,
    which would have been a successful match for a non-atomic group. Finally, this
    match operation fails with no match.
  prefs: []
  type: TYPE_NORMAL
- en: You need to remember a simple but important fact that the alternation tries
    its alternatives from left to right and always attempts to complete the match
    using the
  prefs: []
  type: TYPE_NORMAL
- en: '![Image 21](img/index-140_1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: leftmost alternative. Therefore, whenever listing all the options in an alternation,
    it is good practice to place the longest matches first and then use the other
    alternatives to place shorter matches.
  prefs: []
  type: TYPE_NORMAL
- en: Using this principle, we can make some small changes to our atomic group to
    make it work.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the working regex:'
  prefs: []
  type: TYPE_NORMAL
- en: ^foo(?>lish|die|d)$
  prefs: []
  type: TYPE_NORMAL
- en: We have the same input string, foodie.
  prefs: []
  type: TYPE_NORMAL
- en: Note that we have the same alternatives in this atomic group but with a different
    order. Since d is a prefix of die, we are placing the die alternative on the left-hand
    side of d so that the regex engine can first attempt to match foodie before attempting
    food.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the full code listing running these examples:'
  prefs: []
  type: TYPE_NORMAL
- en: package example.regex;
  prefs: []
  type: TYPE_NORMAL
- en: class AtomicGroupExample
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: public static void main (String[] args)
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: final String input = "foodie";
  prefs: []
  type: TYPE_NORMAL
- en: // regex with non-atomic group
  prefs: []
  type: TYPE_NORMAL
- en: final String nonAtomicRegex = "foo(d|die|lish)";
  prefs: []
  type: TYPE_NORMAL
- en: // regex with an atomic group
  prefs: []
  type: TYPE_NORMAL
- en: final String atomicRegex = "foo(?>d|die|lish)";
  prefs: []
  type: TYPE_NORMAL
- en: // regex with an alternate atomic group with correct order final String atomicRegexImproved
    = "foo(?>lish|die|d)";
  prefs: []
  type: TYPE_NORMAL
- en: // now execute all 3 regex against same input
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.printf("%s: %s%n",'
  prefs: []
  type: TYPE_NORMAL
- en: nonAtomicRegex, input.matches(nonAtomicRegex));
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.printf("%s: %s%n",'
  prefs: []
  type: TYPE_NORMAL
- en: atomicRegex, input.matches(atomicRegex));
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.printf("%s: %s%n",'
  prefs: []
  type: TYPE_NORMAL
- en: atomicRegexImproved , input.matches(atomicRegexImproved));
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: 'After compiling and running the code, it will generate the following output:
    foo(?:d|die|lish): true'
  prefs: []
  type: TYPE_NORMAL
- en: 'foo(?>d|die|lish): false'
  prefs: []
  type: TYPE_NORMAL
- en: 'foo(?>lish|die|d): true'
  prefs: []
  type: TYPE_NORMAL
- en: '*Since the atomic group prevents the regex engine from backtracking by* *exiting
    from the evaluation of all the alternatives inside the group, the* *atomic group
    usually provides a significant gain in performance while* *evaluating a largely
    sized text with multiple options in alternation.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Lookahead assertions**'
  prefs: []
  type: TYPE_NORMAL
- en: Positive and negative lookahead assertions are zero-width assertions that allow
    for certain regular expression-based checks to be performed on the text that is
    ahead (or on the right-hand side) of the current position. The regex engine holds
    on to the current position after evaluating the lookahead pattern. We can chain
    multiple lookahead expressions one after another, but the regex engine does not
    move the control after checking all the lookaheads. Lookahead assertions can help
    solve some complex regex problems, which are not possible or are very difficult
    to solve without lookahead support. The Java regular expression engine, like many
    other regular expression flavors, allows the use of variable-length quantifiers
    such as * and + in lookahead patterns.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two types of lookahead assertions: positive lookahead and negative
    lookahead.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Positive lookahead**'
  prefs: []
  type: TYPE_NORMAL
- en: A positive lookahead assertion asserts true if the pattern inside the lookahead
    is matched.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is its syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: (?=...)
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, \d+(?=##) asserts that there must be a string, ##, immediately
    after matching one or more digits.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Negative lookahead**'
  prefs: []
  type: TYPE_NORMAL
- en: A negative lookahead assertion asserts true if the pattern inside the lookahead
    is not matched.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is its syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: (?!...)
  prefs: []
  type: TYPE_NORMAL
- en: For example, abc(?!xyz) asserts that there cannot be a string, xyz, immediately
    after matching the string abc.
  prefs: []
  type: TYPE_NORMAL
- en: '**Lookbehind assertions**'
  prefs: []
  type: TYPE_NORMAL
- en: Positive and negative lookbehind assertions are zero-width assertions that allow
    for certain regex-based checks to be performed on the text that precedes (or is
    on the left-hand side) of the current position. The regex engine holds on to the
    current position after evaluating the lookbehind pattern. We can chain multiple
    lookbehind expressions one after another, but the regex engine does not move the
    control after checking all the lookbehind assertions. Lookbehind assertions can
    also help solve some complex problems that are not possible or are very difficult
    to solve without lookbehind support. Up to Java version 8, the Java regular expression
    engine didn't allow the use of variable-length quantifiers such as * and + in
    lookbehind patterns.
  prefs: []
  type: TYPE_NORMAL
- en: With Java 9, the Java regex engine now allows the use of these quantifiers in
    lookbehind assertions.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two types of lookbehind assertions: positive lookbehind and negative
    lookbehind.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Positive lookbehind**'
  prefs: []
  type: TYPE_NORMAL
- en: A positive lookbehind assertion asserts true if the pattern inside the lookbehind
    is matched.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is its syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: (?<=...)
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, (?<=##)\d+ asserts that there must be a ## string just before
    matching one or more digits.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Negative lookbehind**'
  prefs: []
  type: TYPE_NORMAL
- en: A negative lookbehind assertion asserts true if the pattern inside the lookbehind
    is not matched.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is its syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: (?<!...)
  prefs: []
  type: TYPE_NORMAL
- en: For example, (?<!xyz)abc asserts that there cannot be the string, xyz, just
    before matching the string, abc.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are a few important points about lookaround regex patterns: Lookaround
    patterns are atomic. Like atomic groups, once a lookaround pattern is matched,
    the regex engine exits immediately from that lookaround, returning just a true
    or false assertion.'
  prefs: []
  type: TYPE_NORMAL
- en: Lookaround patterns don't move from the current position. All patterns are evaluated
    from the current position. The position remains the same after the lookaround
    assertions are completed.
  prefs: []
  type: TYPE_NORMAL
- en: If a regular expression uses multiple lookaround assertions next to each other,
    then the order of those expressions is not important.
  prefs: []
  type: TYPE_NORMAL
- en: Lookaround patterns are usually used in complex input validations, for splitting
    the input before or after the specified patterns, and for finding overlapping
    matches.
  prefs: []
  type: TYPE_NORMAL
- en: Let's look at some examples to understand the use of lookahead and lookbehind
    expressions.
  prefs: []
  type: TYPE_NORMAL
- en: 'To match an integer number with one or more digits that doesn''t allow all
    zeroes, we can use the following:'
  prefs: []
  type: TYPE_NORMAL
- en: ^(?!0+$)\d+$
  prefs: []
  type: TYPE_NORMAL
- en: (?!0+$) is a negative lookahead expression that will assert failure if we have
    one or more zeroes till the end, ahead of the current position, which is the start
    of the input string in our example.
  prefs: []
  type: TYPE_NORMAL
- en: 'Given an input text with @ characters, we need to match @ only if there is
    a word character at the next position. We can use a positive lookahead regex here,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '@(?=\w)'
  prefs: []
  type: TYPE_NORMAL
- en: Here, (?=\w) means a positive lookahead that asserts true when there is a word
    character next to @.
  prefs: []
  type: TYPE_NORMAL
- en: 'To match an input string that doesn''t allow the string zzz anywhere, we can
    use a negative lookahead such as this:'
  prefs: []
  type: TYPE_NORMAL
- en: ^(?!.*zzz)
  prefs: []
  type: TYPE_NORMAL
- en: 'To match a dot that is not followed or preceded by a digit, we can use negative
    lookahead and negative lookbehind conditions, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: (?<!\d)\.(?!\d)
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, we are using two assertions:'
  prefs: []
  type: TYPE_NORMAL
- en: (?<!\d) is a negative lookbehind condition that asserts that there is no digit
    preceding a dot
  prefs: []
  type: TYPE_NORMAL
- en: (?!\d) is a negative lookahead condition that asserts that there is no digit
    following a dot
  prefs: []
  type: TYPE_NORMAL
- en: This will match the dot in ip.address, .net, and abc. but won't match the dot
    in 25.78, 12., and .987\.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we need to match an input that must not contain the repetition of the
    @, #, or %'
  prefs: []
  type: TYPE_NORMAL
- en: characters.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will need to use a negative lookahead pattern that contains a capturing
    group and a back-reference to check repetition:'
  prefs: []
  type: TYPE_NORMAL
- en: ^(?!.*([@#%])\1)
  prefs: []
  type: TYPE_NORMAL
- en: (?!.*([@#%])\1) is a negative lookahead assertion that matches and captures
    the given special characters in the first capturing group. Using back-reference
    \1, we check duplication of the captured character. The pattern inside the negative
    lookahead .*
  prefs: []
  type: TYPE_NORMAL
- en: '([@#%])\1 makes sure that we don''t have a duplicated @, #, or % character
    at any position ahead of the current position.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, suppose that we need to find a search term in a long text with the following
    conditions:'
  prefs: []
  type: TYPE_NORMAL
- en: 1\. The search term is at the start or preceded by a whitespace.
  prefs: []
  type: TYPE_NORMAL
- en: 2\. The search term is at the end or followed by a whitespace.
  prefs: []
  type: TYPE_NORMAL
- en: 3\. The search term may contain non-word characters as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'To solve this, we can use a regular expression with a positive lookahead and
    a positive lookbehind like this:'
  prefs: []
  type: TYPE_NORMAL
- en: (?<=^|\h)searchTerm(?=\h|$)
  prefs: []
  type: TYPE_NORMAL
- en: Here, (?<=^|\h) is a positive lookbehind that asserts that the search term is
    at the start position or is preceded by a horizontal whitespace.
  prefs: []
  type: TYPE_NORMAL
- en: (?=\h|$) is a positive lookahead that asserts that the search term is at the
    end position or is followed by a horizontal whitespace.
  prefs: []
  type: TYPE_NORMAL
- en: Match a string containing one or more word characters but doesn't allow any
    of the characters to repeat.
  prefs: []
  type: TYPE_NORMAL
- en: 'To solve this problem, we need to use a capturing group, back-reference, and
    a negative lookahead like this:'
  prefs: []
  type: TYPE_NORMAL
- en: ^(?:(\w)(?!.*\1))+$
  prefs: []
  type: TYPE_NORMAL
- en: Here, we are matching and capturing each character in the first captured group.
    Each word character is asserted by a negative lookahead (?!.*\1), where \1 is
    the backreference of the first captured group. The negative lookahead (?!.*\1)
    asserts that we don't have another occurrence of the captured character in the
    string ahead. Finally, we wrap the whole expression in a non-capturing group to
    be able to use the quantifier
  prefs: []
  type: TYPE_NORMAL
- en: + to match one or more word non-repeating characters.
  prefs: []
  type: TYPE_NORMAL
- en: Suppose we need to scan a line of text and place a colon in every third position
    from right to left. However, we should not place a colon at the start position.
  prefs: []
  type: TYPE_NORMAL
- en: This should convert abcd into a:bcd and 123456 will be converted to 123:456,
    but abc must not become :abc.
  prefs: []
  type: TYPE_NORMAL
- en: 'To solve this, we can use a lookahead regex, as in this code listing: package
    example.regex;'
  prefs: []
  type: TYPE_NORMAL
- en: import java.util.regex.*;
  prefs: []
  type: TYPE_NORMAL
- en: class LookAroundExample1
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: public static void main (String[] args)
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: final String[] inputs =
  prefs: []
  type: TYPE_NORMAL
- en: '{"abcd98732", "pqrn", "qwerty12345678xyz", "123"}; final Pattern p = Pattern.compile("(?!^)(?=(.{3})+$)");
    for (String s: inputs)'
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: Matcher m = p.matcher(s);
  prefs: []
  type: TYPE_NORMAL
- en: System.out.printf("%s => %s%n", s, m.replaceAll(":"));
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: 'After running this code, we''ll get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: abcd98732 => abc:d98:732
  prefs: []
  type: TYPE_NORMAL
- en: pqrn => p:qrn
  prefs: []
  type: TYPE_NORMAL
- en: qwerty12345678xyz => qw:ert:y12:345:678:xyz
  prefs: []
  type: TYPE_NORMAL
- en: 123 => 123
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see, this code places a colon in every third position, going from
    right to left. Let''s see what happens during the matching of the regular expression:
    (?!^) is a negative lookahead to avoid matching at the position.'
  prefs: []
  type: TYPE_NORMAL
- en: '(?=(.{3})+$) is a positive lookahead that finds all the positions that have
    one or more three-character sets, ahead of the current position. This will first
    match the position where the first : has to be inserted, then the second, and
    so on. This may at first seem like something contradicting with atomic groups
    and the non-backtracking behaviour of a lookahead group. But it essentially is
    not. It is not contradicting because the lookahead itself is not backtracking.
    The regular expression matching is backtracking and evaluates the lookahead assertion
    again and again for each and every character position.'
  prefs: []
  type: TYPE_NORMAL
- en: Now, suppose that we have to replace all the commas that are outside the innermost
    parentheses with a semi-colon, assuming all the parentheses are balanced, not
    nested, and unescaped in the input text.
  prefs: []
  type: TYPE_NORMAL
- en: 'To solve this problem, we can use a negative lookahead expression, such as
    this one:'
  prefs: []
  type: TYPE_NORMAL
- en: ',(?![^()]*\))'
  prefs: []
  type: TYPE_NORMAL
- en: This one matches a comma followed by a negative lookahead assertion that asserts
    false when we have a right ) following zero or more characters and not containing
    (
  prefs: []
  type: TYPE_NORMAL
- en: and ). Since we know that ( and ) are balanced, this check ensures that we match
    a comma that is outside ( and ).
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the full code listing to see this regex in action: package example.regex;'
  prefs: []
  type: TYPE_NORMAL
- en: import java.util.regex.*;
  prefs: []
  type: TYPE_NORMAL
- en: class LookAroundExample2
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: public static void main (String[] args)
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: String input = "var1,var2,var3 (var1,var2,var3) var4,var5,var6 (var4,var5,var6)";
    final Pattern p = Pattern.compile(",(?![^()]*\\))"); Matcher m = p.matcher(input);
  prefs: []
  type: TYPE_NORMAL
- en: System.out.printf("%s%n", m.replaceAll(";"));
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: 'When we run the preceding code, it gives the following output, replacing all
    the commas outside the parentheses:'
  prefs: []
  type: TYPE_NORMAL
- en: 'var1;var2;var3 (var1,var2,var3) var4;var5;var6 (var4,var5,var6) Next, suppose
    that we need to validate a password string with the following constraints:'
  prefs: []
  type: TYPE_NORMAL
- en: At least one uppercase English letter
  prefs: []
  type: TYPE_NORMAL
- en: At least one lowercase English letter
  prefs: []
  type: TYPE_NORMAL
- en: At least one digit
  prefs: []
  type: TYPE_NORMAL
- en: At least one special character (non-word character)
  prefs: []
  type: TYPE_NORMAL
- en: Minimum six and maximum twelve in length
  prefs: []
  type: TYPE_NORMAL
- en: No whitespace allowed anywhere
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the solution:'
  prefs: []
  type: TYPE_NORMAL
- en: 'To check for six to twelve non-whitespace characters, we can use the following:'
  prefs: []
  type: TYPE_NORMAL
- en: ^\S{6,12}$
  prefs: []
  type: TYPE_NORMAL
- en: For the remaining conditions, we need to use multiple lookahead expressions,
    one for each condition. Let's build the lookahead patterns one by one.
  prefs: []
  type: TYPE_NORMAL
- en: 'To ensure that there is at least one uppercase letter in the input, we can
    use this lookahead assertion:'
  prefs: []
  type: TYPE_NORMAL
- en: (?=.*[A-Z])
  prefs: []
  type: TYPE_NORMAL
- en: This means that we have to check for the presence of an uppercase letter after
    zero or more characters.
  prefs: []
  type: TYPE_NORMAL
- en: 'Similarly, to ensure that there is at least one lowercase letter in the input,
    we can use this lookahead assertion:'
  prefs: []
  type: TYPE_NORMAL
- en: (?=.*[a-z])
  prefs: []
  type: TYPE_NORMAL
- en: 'Similarly, to ensure there is at least one digit in the input, we can use the
    following: (?=.*\d)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Similarly, to ensure there is at least one non-word character in the input,
    we can use the following:'
  prefs: []
  type: TYPE_NORMAL
- en: (?=.*\W)
  prefs: []
  type: TYPE_NORMAL
- en: 'As mentioned earlier, the order of these lookahead patterns does not matter,
    so we keep them in any order in our regular expression. Putting it all together,
    our final regular expression will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: ^(?=.*[A-Z])(?=.*[a-z])(?=.*\d)(?=.*\W)\S{6,12}$
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the full Java code to make this regex work: package example.regex;'
  prefs: []
  type: TYPE_NORMAL
- en: import java.util.regex.*;
  prefs: []
  type: TYPE_NORMAL
- en: class LookAroundPasswordValidation
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: public static void main (String[] args)
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: // build a Pattern using our regex
  prefs: []
  type: TYPE_NORMAL
- en: final Pattern p = Pattern.compile(
  prefs: []
  type: TYPE_NORMAL
- en: '"^(?=.*[A-Z])(?=.*[a-z])(?=.*\\d)(?=.*\\W)\\S{6,12}$" );'
  prefs: []
  type: TYPE_NORMAL
- en: // input strings to be tested against our regex
  prefs: []
  type: TYPE_NORMAL
- en: String[] inputs = { "abZ#45", "$$$f5P###", "abc123", "xyz-7612",
  prefs: []
  type: TYPE_NORMAL
- en: '"AbC@#$qwer", "xYz@#$ 1278" };'
  prefs: []
  type: TYPE_NORMAL
- en: 'for (String s: inputs)'
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: Matcher m = p.matcher( s );
  prefs: []
  type: TYPE_NORMAL
- en: System.out.printf( "%s => %s%n", s, m.matches() );
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: 'After compiling and running this code, we will get the following output: abZ#45
    => true'
  prefs: []
  type: TYPE_NORMAL
- en: $$$f5P### => true
  prefs: []
  type: TYPE_NORMAL
- en: abc123 => false
  prefs: []
  type: TYPE_NORMAL
- en: xyz-7612 => false
  prefs: []
  type: TYPE_NORMAL
- en: AbC@#$qwer => false
  prefs: []
  type: TYPE_NORMAL
- en: xYz@#$1278 => false
  prefs: []
  type: TYPE_NORMAL
- en: This output basically shows a true value for all the strings that pass all our
    password rules and false, otherwise.
  prefs: []
  type: TYPE_NORMAL
- en: '**Capturing text from**'
  prefs: []
  type: TYPE_NORMAL
- en: '**overlapping matches**'
  prefs: []
  type: TYPE_NORMAL
- en: Lookahead patterns are also very useful for situations where we want to match
    and capture text from overlapping matches.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s consider the following input string as an example:'
  prefs: []
  type: TYPE_NORMAL
- en: thathathisthathathatis
  prefs: []
  type: TYPE_NORMAL
- en: Suppose that we need to count the occurrence of the string, that, in this input,
    including all overlapping occurrences.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that there are three independent that substrings in the input string,
    but there are two additional overlapping matches that we need to match and count.
    Here are the start-end positions of overlapping the substring that:'
  prefs: []
  type: TYPE_NORMAL
- en: Positions 0-3 3-6 10-13 13-16 16-19
  prefs: []
  type: TYPE_NORMAL
- en: A simple search using the regex that will give us a match count of three because
    we miss out all the overlapping matches. To be able to match the overlapping matches,
    we need to use the lookahead pattern because lookahead patterns are zero-length.
  prefs: []
  type: TYPE_NORMAL
- en: 'These patterns don''t consume any characters; they just assert the presence
    of the required text ahead, based on the patterns used inside the lookahead, and
    the current position doesn''t change. So, the solution is to use a lookahead regex
    as follows: (?=that)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the full code to see this regex working in action: package example.regex;'
  prefs: []
  type: TYPE_NORMAL
- en: import java.util.regex.Matcher;
  prefs: []
  type: TYPE_NORMAL
- en: import java.util.regex.Pattern;
  prefs: []
  type: TYPE_NORMAL
- en: class LookaheadOverlapping
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: public static void main (String[] args)
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: final String kw = "that";
  prefs: []
  type: TYPE_NORMAL
- en: final String regex = "(?=" + kw+ ")"; final String string = "thathathisthathathatis";
    final Pattern pattern = Pattern.compile(regex);
  prefs: []
  type: TYPE_NORMAL
- en: final Matcher matcher = pattern.matcher(string);
  prefs: []
  type: TYPE_NORMAL
- en: int count = 0; while (matcher.find())
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.printf("Start: %d\tEnd:%d%n",'
  prefs: []
  type: TYPE_NORMAL
- en: matcher.start(), matcher.start() + kw.length() -1);
  prefs: []
  type: TYPE_NORMAL
- en: count++;
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.printf("Match count: %d%n", count);'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: 'Once we run and compile the preceding class, we will get the following output:
    Start: 0 End:3'
  prefs: []
  type: TYPE_NORMAL
- en: 'Start: 3 End:6'
  prefs: []
  type: TYPE_NORMAL
- en: 'Start: 10 End:13'
  prefs: []
  type: TYPE_NORMAL
- en: 'Start: 13 End:16'
  prefs: []
  type: TYPE_NORMAL
- en: 'Start: 16 End:19'
  prefs: []
  type: TYPE_NORMAL
- en: 'Match count: 5'
  prefs: []
  type: TYPE_NORMAL
- en: You can see from this output that all the Start, End positions of the overlapping
    matches and, more importantly, the count of the overlapping matches, which is
    5\.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is another code listing that finds all the three character strings that
    have ''a'' as the middle letter and the same word character before and after the
    letter ''a''. For example, bab, zaz, kak, dad, 5a5, and _a_ should be matched:'
  prefs: []
  type: TYPE_NORMAL
- en: package example.regex;
  prefs: []
  type: TYPE_NORMAL
- en: import java.util.regex.Matcher;
  prefs: []
  type: TYPE_NORMAL
- en: import java.util.regex.Pattern;
  prefs: []
  type: TYPE_NORMAL
- en: class LookaheadOverlappingMatches
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: public static void main(String[] args)
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: final String regex = "(?=(\\w)a\\1)";
  prefs: []
  type: TYPE_NORMAL
- en: final String string = "5a5akaktjzazbebbobabababsab"; final Matcher matcher =
    Pattern.compile(regex)
  prefs: []
  type: TYPE_NORMAL
- en: .matcher(string);
  prefs: []
  type: TYPE_NORMAL
- en: int count = 0; while (matcher.find())
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: final int start = matcher.start();
  prefs: []
  type: TYPE_NORMAL
- en: final int end = start + 2;
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.printf("Start: %2d\tEnd:%2d %s%n",'
  prefs: []
  type: TYPE_NORMAL
- en: start, end, string.substring(start,end+1));
  prefs: []
  type: TYPE_NORMAL
- en: count++;
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.printf("Match count: %d%n", count);'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: 'This code generates the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Start: 0 End: 2 5a5'
  prefs: []
  type: TYPE_NORMAL
- en: 'Start: 4 End: 6 kak'
  prefs: []
  type: TYPE_NORMAL
- en: 'Start: 9 End:11 zaz'
  prefs: []
  type: TYPE_NORMAL
- en: 'Start: 17 End:19 bab'
  prefs: []
  type: TYPE_NORMAL
- en: 'Start: 19 End:21 bab'
  prefs: []
  type: TYPE_NORMAL
- en: 'Start: 21 End:23 bab'
  prefs: []
  type: TYPE_NORMAL
- en: 'Match count: 6'
  prefs: []
  type: TYPE_NORMAL
- en: '**Be careful with capturing**'
  prefs: []
  type: TYPE_NORMAL
- en: '**groups inside a lookahead or**'
  prefs: []
  type: TYPE_NORMAL
- en: '**lookbehind atomic group**'
  prefs: []
  type: TYPE_NORMAL
- en: You learned to use capturing groups inside lookahead or lookbehind patterns
    in the preceding examples. However, you must remember that lookaround expressions
    are zero-width atomic groups. The regex engine exits from these groups as soon
    as an assertion is evaluated to true or false. Due to this fact, there is no backtracking
    inside these groups.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following three regular expressions. The first one is without
    any lookahead or atomic group, the second regex uses a lookahead expression, and
    the third regex uses an atomic group. Note that in each of the regex patterns,
    we use a capturing group to match and capture zero or more word characters inside
    the outer group:'
  prefs: []
  type: TYPE_NORMAL
- en: '#(?:(\w*))\w*_\1'
  prefs: []
  type: TYPE_NORMAL
- en: '#(?=(\w*))\w*_\1'
  prefs: []
  type: TYPE_NORMAL
- en: '#(?>(\w*))\w*_\1'
  prefs: []
  type: TYPE_NORMAL
- en: 'Suppose that we apply the preceding three regex patterns against the following
    input:'
  prefs: []
  type: TYPE_NORMAL
- en: '#abc_abc'
  prefs: []
  type: TYPE_NORMAL
- en: 'The first regex, #(?:(\w+)).*_\1, will find a successful match with group 1
    as "abc".'
  prefs: []
  type: TYPE_NORMAL
- en: Next, it matches _ and back-references \1 to complete the match. Since the capturing
    group (\w*) initially matches the complete input, "abc_abc", the regex engine
    backtracks multiple times to make this a successful match.
  prefs: []
  type: TYPE_NORMAL
- en: The second regex will fail to match because (\w+) inside the lookahead will
    match and capture "abc_abc", and when the regex engine exits the lookahead group,
    it is not able to find a match with .*_\1, as there is no further input and the
    engine won't backtrack to complete the match like it does in the first regex.
  prefs: []
  type: TYPE_NORMAL
- en: The third regex with an atomic group will also fail to match due to the same
    reason; the regex engine won't backtrack after matching the string inside an atomic
    group.
  prefs: []
  type: TYPE_NORMAL
- en: '**Lookbehind limitations in**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Java regular expressions**'
  prefs: []
  type: TYPE_NORMAL
- en: Like many other regular expression engines, the Java regex engine does not allow
    a variable-length text without an obvious maximum length match in the lookbehind
    regex pattern. This means that we cannot use the * or + quantifiers in a lookbehind
    pattern. However, the Java regex engine allows for limited or finite repetition
    in a lookbehind regex. This gives us a workaround for doing so in Java regular
    expressions by using limiting quantifiers in lookbehind expressions.
  prefs: []
  type: TYPE_NORMAL
- en: 'This means that we cannot use the following lookbehind regex to check filenames
    ending with extensions:'
  prefs: []
  type: TYPE_NORMAL
- en: (?<=\w\.\w+)$
  prefs: []
  type: TYPE_NORMAL
- en: 'However, we could change the preceding pattern to the following with a finite
    repetition, and now this pattern will be allowed by the Java regex engine: (?<=\w\.\w{1,99})$'
  prefs: []
  type: TYPE_NORMAL
- en: However, it limits the number of word characters in the lookbehind after the
    dot to be from 1 to 99 instead of open-ended one or more word characters, as is
    the case with the
  prefs: []
  type: TYPE_NORMAL
- en: + quantifier. However, you should use such a feature with caution and check
    the performance of the resulting regular expression. The Java lookbehind implementation
    also had quite a few bugs in the earlier versions. Some of these bugs have been
    resolved but one can still get unexpected results while using complex lookbehind
    regular expressions in Java.
  prefs: []
  type: TYPE_NORMAL
- en: 'Java 9, however, allows regex patterns without an obvious maximum-length restriction
    in lookbehind assertions. This will allow programmers to use the lookbehind regex
    patterns without any maximum length match, such as the following regex in the
    previous example:'
  prefs: []
  type: TYPE_NORMAL
- en: (?<=\w\.\w+)$
  prefs: []
  type: TYPE_NORMAL
- en: '**Summary**'
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we learned zero-width assertions and how they are crucial for
    solving some important matching problems. We discussed the boundary matcher, \G,
    and its usefulness in solving some problems. We discovered the idea behind atomic
    groups and understood how they can improve the overall regex performance. Then,
    we covered all the important lookahead and lookbehind patterns. We covered some
    interesting matching, validation, and splitting problems that are solved using
    lookarounds.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will continue to learn advanced concepts of Java regular
    expressions, such as union and intersection within character classes, and negated
    character classes.
  prefs: []
  type: TYPE_NORMAL
- en: '**Understanding the Union,**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Intersection, and**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Subtraction of Character**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Classes**'
  prefs: []
  type: TYPE_NORMAL
- en: Some regular expression engines allow composite character classes, or character
    classes inside other character classes. The Java regular expression engine also
    supports many of these features, and we will discuss these features in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will cover the following topics in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: The union of character classes
  prefs: []
  type: TYPE_NORMAL
- en: The intersection of character classes
  prefs: []
  type: TYPE_NORMAL
- en: The subtraction of character classes
  prefs: []
  type: TYPE_NORMAL
- en: The advantages of using composite character classes
  prefs: []
  type: TYPE_NORMAL
- en: '**The union of character**'
  prefs: []
  type: TYPE_NORMAL
- en: '**classes**'
  prefs: []
  type: TYPE_NORMAL
- en: The union of character classes will match a character that would be matched
    by any of the composing character classes. Essentially, this is the definition
    of the union operation in general. In regular expressions, it is possible to create
    unions of character classes by simply writing a character class inside another.
  prefs: []
  type: TYPE_NORMAL
- en: You may remember that character classes open with the [ character and close
    with the
  prefs: []
  type: TYPE_NORMAL
- en: '] character, and we can list characters and character ranges between the opening
    and closing brackets.'
  prefs: []
  type: TYPE_NORMAL
- en: In addition to those, we can use other character sets inside the brackets, and
    the resulting set will be the union of all these character classes. This way,
    there is no union operator to create the composition of these character classes;
    we just simply write them inside each other.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, consider the following composite character class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[A-D[PQR]]'
  prefs: []
  type: TYPE_NORMAL
- en: 'This matches any character in the range of A to D or any single character P,
    Q, or R. This regular expression can also be written as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[A-DPQR]'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also create a union of more than two character classes, such as as in
    the following regular expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '[A-D[P-S][X-Z]]'
  prefs: []
  type: TYPE_NORMAL
- en: 'This matches any character in the range of A to D, any character in the range
    of P to S, or any character in the range from X to Z. This regular expression
    can also be written as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[A-DP-SX-Z]'
  prefs: []
  type: TYPE_NORMAL
- en: The union of character classes can also be used with a negated inner character
    class, and this is where character class unions really start to shine and give
    us extra value.
  prefs: []
  type: TYPE_NORMAL
- en: We get to see a good use of the union operation only when we use the union of
    various character classes with a negated character class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s consider, for example, the following code listing on the union with
    a negated character class:'
  prefs: []
  type: TYPE_NORMAL
- en: package example.regex;
  prefs: []
  type: TYPE_NORMAL
- en: import java.util.regex.*;
  prefs: []
  type: TYPE_NORMAL
- en: public class UnionExample
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: public static void main(String[] args)
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: final String re = "[#@.[^\\p{Punct}\\s]]";
  prefs: []
  type: TYPE_NORMAL
- en: final String[] arr = new String[] {
  prefs: []
  type: TYPE_NORMAL
- en: '"A", "#", "@", "1", "5", " ", "\n", ":", ".", "a", "%", "-", "3"'
  prefs: []
  type: TYPE_NORMAL
- en: '};'
  prefs: []
  type: TYPE_NORMAL
- en: 'for (String s: arr)'
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: System.out.printf("[%s] %s%n", s,
  prefs: []
  type: TYPE_NORMAL
- en: '(s.matches(re) ? "matches" : "does not match"));'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: 'This regex has the following negated character class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[^\\p{Punct}\\s]'
  prefs: []
  type: TYPE_NORMAL
- en: 'The preceding negated character class allows any character that is not a punctuation
    and not a space character. Now, suppose that we want to allow a few selected punctuation
    characters, @, #, and ., or in other words, the [@#.] character class. In this
    scenario, the union comes handy. We make a composite character class that uses
    a union of both these cases, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[#@.[^\\p{Punct}\\s]]'
  prefs: []
  type: TYPE_NORMAL
- en: Now, this composite character class will allow the [@#.] characters, or any
    character that is not a punctuation and not a space character.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once we compile and run the preceding code, we''ll get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[A] matches'
  prefs: []
  type: TYPE_NORMAL
- en: '[#] matches'
  prefs: []
  type: TYPE_NORMAL
- en: '[@] matches'
  prefs: []
  type: TYPE_NORMAL
- en: '[1] matches'
  prefs: []
  type: TYPE_NORMAL
- en: '[5] matches'
  prefs: []
  type: TYPE_NORMAL
- en: '[ ] does not match'
  prefs: []
  type: TYPE_NORMAL
- en: '['
  prefs: []
  type: TYPE_NORMAL
- en: '] does not match'
  prefs: []
  type: TYPE_NORMAL
- en: '[:] does not match'
  prefs: []
  type: TYPE_NORMAL
- en: '[.] matches'
  prefs: []
  type: TYPE_NORMAL
- en: '[a] matches'
  prefs: []
  type: TYPE_NORMAL
- en: '[%] does not match'
  prefs: []
  type: TYPE_NORMAL
- en: '[-] does not match'
  prefs: []
  type: TYPE_NORMAL
- en: '[3] matches'
  prefs: []
  type: TYPE_NORMAL
- en: You can see the output of "matches" for all the character sets that are not
    included inside our negated character class or allowed by the [#@.] character
    class. It returns
  prefs: []
  type: TYPE_NORMAL
- en: '"does not match" for all other cases.'
  prefs: []
  type: TYPE_NORMAL
- en: '**The intersection of character**'
  prefs: []
  type: TYPE_NORMAL
- en: '**classes**'
  prefs: []
  type: TYPE_NORMAL
- en: 'The intersection operation on character classes results in a composite class
    that contains every character allowed by **all** of its operand (inner) classes
    or, in other words, matches characters that belong to all the character classes
    in the composite character class pattern. The intersection operator is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '&&'
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, consider the following composite character class using the &&
    operator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[A-Z&&[PQR]]'
  prefs: []
  type: TYPE_NORMAL
- en: 'This matches any character that is in the range of A to Z and is one of the
    single P, Q, or R characters. However, the preceding regular expression can also
    be simply written as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PQR]'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following composite character class using intersection matches the digits,
    5 and 6, since only these two digits belong to all the three character classes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[1-7&&[3-6]&&[5-8]]'
  prefs: []
  type: TYPE_NORMAL
- en: 'To see this regex in action, let''s use this complete code: package example.regex;'
  prefs: []
  type: TYPE_NORMAL
- en: import java.util.regex.*;
  prefs: []
  type: TYPE_NORMAL
- en: public class IntersectionExample
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: public static void main(String[] args)
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: final Pattern p = Pattern.compile("[1-7&&[3-6]&&[5-8]]"); for (int i=0; i<10;
    i++)
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: String s = String.valueOf(i);
  prefs: []
  type: TYPE_NORMAL
- en: Matcher m = p.matcher(s);
  prefs: []
  type: TYPE_NORMAL
- en: System.out.printf("[%s] %s%n", s,
  prefs: []
  type: TYPE_NORMAL
- en: '(m.matches() ? "matches" : "does not match"));'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: 'When we compile and run the preceding code, we will see the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[0] does not match'
  prefs: []
  type: TYPE_NORMAL
- en: '[1] does not match'
  prefs: []
  type: TYPE_NORMAL
- en: '[2] does not match'
  prefs: []
  type: TYPE_NORMAL
- en: '[3] does not match'
  prefs: []
  type: TYPE_NORMAL
- en: '[4] does not match'
  prefs: []
  type: TYPE_NORMAL
- en: '[5] matches'
  prefs: []
  type: TYPE_NORMAL
- en: '[6] matches'
  prefs: []
  type: TYPE_NORMAL
- en: '[7] does not match'
  prefs: []
  type: TYPE_NORMAL
- en: '[8] does not match'
  prefs: []
  type: TYPE_NORMAL
- en: '[9] does not match'
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, it shows "matches" only for the digits, 5 and 6\.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take another example, which involves matching a non-whitespace character
    that is not a Unicode letter. We know we can use the following regex using a positive
    lookahead:'
  prefs: []
  type: TYPE_NORMAL
- en: (?=\S)\P{L}
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also use an intersection operation to write this example, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[\\S&&[\\P{L}]]'
  prefs: []
  type: TYPE_NORMAL
- en: Due to the use of the && operator here, it matches a character that satisfies
    both the properties, \S (non-whitespace) and \P{L} (non-letters).
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that the inner square brackets are optional when not using a negated character
    class in an intersection operation. Hence, the preceding regex can also be written
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[\\S&&\\P{L}]'
  prefs: []
  type: TYPE_NORMAL
- en: 'Similarly, to match an uppercase Greek letter, we can use the intersection
    of the following two classes:'
  prefs: []
  type: TYPE_NORMAL
- en: '\p{InGreek}: This matches a character in the Greek block'
  prefs: []
  type: TYPE_NORMAL
- en: '\p{Lu}: This matches an uppercase Unicode letter'
  prefs: []
  type: TYPE_NORMAL
- en: 'By combining these two character classes with intersection, we can make a single
    composite character class, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[\p{InGreek}&&[\p{Lu}]]'
  prefs: []
  type: TYPE_NORMAL
- en: 'To test the preceding regex, let''s pick some Greek letters and write a simple
    Java code, such as the following, to test our regex against the selected Greek
    letters: package example.regex;'
  prefs: []
  type: TYPE_NORMAL
- en: import java.util.regex.*;
  prefs: []
  type: TYPE_NORMAL
- en: public class UppercaseGreekIntersectionExample
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: public static void main(String[] args)
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: final Pattern p = Pattern.compile("[\\p{InGreek}&&[\\p{Lu}]]"); final String[]
    arr = new String[] {
  prefs: []
  type: TYPE_NORMAL
- en: '"Γ", "Δ", "Θ", "Ξ", "Π", "Σ", "Φ", "α", "β", "γ", "δ", "ε", "A", "P", "e",
    "r"'
  prefs: []
  type: TYPE_NORMAL
- en: '};'
  prefs: []
  type: TYPE_NORMAL
- en: 'for (String s: arr)'
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: Matcher m = p.matcher(s);
  prefs: []
  type: TYPE_NORMAL
- en: System.out.printf("[%s] %s%n", s,
  prefs: []
  type: TYPE_NORMAL
- en: '(m.matches() ? "matches" : "does not match"));'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: 'When we run the preceding class, it prints the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[Γ] matches'
  prefs: []
  type: TYPE_NORMAL
- en: '[Δ] matches'
  prefs: []
  type: TYPE_NORMAL
- en: '[Θ] matches'
  prefs: []
  type: TYPE_NORMAL
- en: '[Ξ] matches'
  prefs: []
  type: TYPE_NORMAL
- en: '[Π] matches'
  prefs: []
  type: TYPE_NORMAL
- en: '[Σ] matches'
  prefs: []
  type: TYPE_NORMAL
- en: '[Φ] matches'
  prefs: []
  type: TYPE_NORMAL
- en: '[α] does not match'
  prefs: []
  type: TYPE_NORMAL
- en: '[β] does not match'
  prefs: []
  type: TYPE_NORMAL
- en: '[γ] does not match'
  prefs: []
  type: TYPE_NORMAL
- en: '[δ] does not match'
  prefs: []
  type: TYPE_NORMAL
- en: '[ε] does not match'
  prefs: []
  type: TYPE_NORMAL
- en: '[A] does not match'
  prefs: []
  type: TYPE_NORMAL
- en: '[P] does not match'
  prefs: []
  type: TYPE_NORMAL
- en: '[e] does not match'
  prefs: []
  type: TYPE_NORMAL
- en: '[r] does not match'
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, "matches" is only printed for the uppercase Greek letters. For
    all the other letters, it prints "does not match".
  prefs: []
  type: TYPE_NORMAL
- en: '![Image 22](img/index-162_1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**The subtraction of character**'
  prefs: []
  type: TYPE_NORMAL
- en: '**classes**'
  prefs: []
  type: TYPE_NORMAL
- en: Suppose we have to match characters that belong to one class but not to another
    in a composite character class pattern. There is no separate operator for the
    subtraction operation. Subtraction is performed by using the intersection operator,
    &&, and a negated inner character class.
  prefs: []
  type: TYPE_NORMAL
- en: '*A regular expression is usually more readable if we write the larger set*
    *in front and the one we want to subtract from it after the && operator.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, consider the following composite character class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[0-9&&[^3-6]]'
  prefs: []
  type: TYPE_NORMAL
- en: 'It will match the digits, 0 to 9, except the digits, 3 to 6\. This character
    class can also be written as a union of two character classes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[[0-2][7-9]]'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also just use a simple character class, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[0-27-9]'
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to match all the English consonant uppercase letters, we can subtract
    five vowels from uppercase letters, such as in the following regex:'
  prefs: []
  type: TYPE_NORMAL
- en: '[A-Z&&[^AEIOU]]'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also reverse the order of the two sets used in the preceding regex and
    use the following regex:'
  prefs: []
  type: TYPE_NORMAL
- en: '[[^AEIOU]&&A-Z]'
  prefs: []
  type: TYPE_NORMAL
- en: 'Suppose we want to match all punctuation characters except four basic math
    operators: +, -, *, and /. We can use the following composite character class
    using the subtraction operation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[\p{Punct}&&[^+*/-]]'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a test class that tests the preceding subtraction character class:
    package example.regex;'
  prefs: []
  type: TYPE_NORMAL
- en: import java.util.regex.*;
  prefs: []
  type: TYPE_NORMAL
- en: public class SubtractionExample
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: public static void main(String[] args)
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: final Pattern p = Pattern.compile("[\\p{Punct}&&[^+*/-]]"); final String[] arr
    = new String[] {
  prefs: []
  type: TYPE_NORMAL
- en: '"!", "@", "#", "$", "%", "+", "-", "*", "/", "1", "M", "d"'
  prefs: []
  type: TYPE_NORMAL
- en: '};'
  prefs: []
  type: TYPE_NORMAL
- en: 'for (String s: arr)'
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: Matcher m = p.matcher(s);
  prefs: []
  type: TYPE_NORMAL
- en: System.out.printf("[%s] %s%n", s,
  prefs: []
  type: TYPE_NORMAL
- en: '(m.matches() ? "matches" : "does not match"));'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: 'This program produces the following output when we run it after compilation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[!] matches'
  prefs: []
  type: TYPE_NORMAL
- en: '[@] matches'
  prefs: []
  type: TYPE_NORMAL
- en: '[#] matches'
  prefs: []
  type: TYPE_NORMAL
- en: '[$] matches'
  prefs: []
  type: TYPE_NORMAL
- en: '[%] matches'
  prefs: []
  type: TYPE_NORMAL
- en: '[+] does not match'
  prefs: []
  type: TYPE_NORMAL
- en: '[-] does not match'
  prefs: []
  type: TYPE_NORMAL
- en: '[*] does not match'
  prefs: []
  type: TYPE_NORMAL
- en: '[/] does not match'
  prefs: []
  type: TYPE_NORMAL
- en: '[1] does not match'
  prefs: []
  type: TYPE_NORMAL
- en: '[M] does not match'
  prefs: []
  type: TYPE_NORMAL
- en: '[d] does not match'
  prefs: []
  type: TYPE_NORMAL
- en: As is evident from this output, it allows all the punctuation characters except
    the four listed math operators.
  prefs: []
  type: TYPE_NORMAL
- en: '**Why should you use**'
  prefs: []
  type: TYPE_NORMAL
- en: '**composite character classes?**'
  prefs: []
  type: TYPE_NORMAL
- en: 'We should use composite character classes for the following reasons: To create
    new custom character classes from predefined Unicode blocks. For example, to match
    all the letters in an Arabic Unicode block, we can use the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[\p{InArabic}&&\p{L}]'
  prefs: []
  type: TYPE_NORMAL
- en: To avoid potentially slower lookahead or lookbehind patterns by using the intersection
    or subtraction operation on multiple character classes.
  prefs: []
  type: TYPE_NORMAL
- en: To enhance the readability of the regular expression.
  prefs: []
  type: TYPE_NORMAL
- en: '**Summary**'
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we discussed composite and inner character classes. We found
    out how we can use the union, intersection, and subtraction operations to combine
    simple character classes and make a completely different character class to suit
    our requirements. You learned some good usage patterns of composite character
    classes for solving tricky problems. Note how we could avoid more complex lookahead
    and lookbehind assertions by using the union and intersection of character classes.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will discuss the pitfalls of some poorly written regular
    expressions, and you will learn ways to avoid them. You will also learn some important
    optimizing tips and performance improvement methods for writing complex regular
    expressions.
  prefs: []
  type: TYPE_NORMAL
- en: '**Regular Expression Pitfalls,**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Optimization, and**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Performance Improvements**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Regular expressions, if not written well may perform poorly. They may run slowly,
    and when they are executed frequently in some code, they may be the source of
    high CPU utilization. To avoid these problems, regular expressions have to be
    crafted carefully, understanding the possible pitfalls, and they also have to
    be tested thoroughly. We will be covering the following topics in this chapter:
    Common pitfalls and ways to avoid them while writing regular expressions How to
    test your regex functionality and performance'
  prefs: []
  type: TYPE_NORMAL
- en: Optimization and performance enhancing tips
  prefs: []
  type: TYPE_NORMAL
- en: Catastrophic backtracking and how to avoid it
  prefs: []
  type: TYPE_NORMAL
- en: '**Common pitfalls and ways to**'
  prefs: []
  type: TYPE_NORMAL
- en: '**avoid them while writing**'
  prefs: []
  type: TYPE_NORMAL
- en: '**regular expressions**'
  prefs: []
  type: TYPE_NORMAL
- en: Let's discuss some common mistakes people make while building regular expressions
    to solve various problems.
  prefs: []
  type: TYPE_NORMAL
- en: '**Do not forget to escape regex**'
  prefs: []
  type: TYPE_NORMAL
- en: '**metacharacters outside a**'
  prefs: []
  type: TYPE_NORMAL
- en: '**character class**'
  prefs: []
  type: TYPE_NORMAL
- en: You learned that all the special metacharacters, such as *, +, ?, ., |, (, ),
    [, {, ^, $, and so on, need to be escaped if the intent is to match them literally.
    I often see cases where programmers leave them unescaped, thus giving a totally
    different meaning to the regular expression. The Java regex API that we discussed
    in [Chapter 5,](#p111) *Introduction* *to Java Regular Expressions APIs - Pattern
    and Matcher Classes*, throws a non-checked exception if a regex pattern is wrongly
    formatted and cannot be compiled.
  prefs: []
  type: TYPE_NORMAL
- en: '**Avoid escaping every non-**'
  prefs: []
  type: TYPE_NORMAL
- en: '**word character**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Some programmers overdo escaping, thinking that they need to escape every non-word
    character such as colon, hyphen, semicolon, forward slash, and whitespace, which
    is not correct. They end up writing a regular expression as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: ^https?\:\/\/(www\.)?example\.com$
  prefs: []
  type: TYPE_NORMAL
- en: 'The preceding regex pattern uses excessive escaping. This pattern still works,
    but it is not very readable. The colon and forward slash have no special meaning
    in regex; hence, it is better to write this regex in the following way:'
  prefs: []
  type: TYPE_NORMAL
- en: ^https?://(www\.)?example\.com$
  prefs: []
  type: TYPE_NORMAL
- en: '**Avoid unnecessary capturing**'
  prefs: []
  type: TYPE_NORMAL
- en: '**groups to reduce memory**'
  prefs: []
  type: TYPE_NORMAL
- en: '**consumption**'
  prefs: []
  type: TYPE_NORMAL
- en: 'We come across so many examples of regular expressions on the internet that
    promote unnecessary capturing groups. If we are not extracting any substring or
    not using a group in backreferences, then it is better to avoid capturing groups
    by using one or more of the following ways:'
  prefs: []
  type: TYPE_NORMAL
- en: '1\. We can use character classes in certain cases. Consider the following capturing
    group:'
  prefs: []
  type: TYPE_NORMAL
- en: (a|e|i|o|u)
  prefs: []
  type: TYPE_NORMAL
- en: 'So, instead of using the preceding regex, we can use the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[aeiou]'
  prefs: []
  type: TYPE_NORMAL
- en: '2\. We can use a non-capturing group by placing a ?: at the start of the group.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following regex:'
  prefs: []
  type: TYPE_NORMAL
- en: (red|blue|white)
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead of the previous regex, we can use the following:'
  prefs: []
  type: TYPE_NORMAL
- en: (?:red|blue|white)
  prefs: []
  type: TYPE_NORMAL
- en: '3\. To write a regex to match an integer or decimal number there is no need
    to use the following regex:'
  prefs: []
  type: TYPE_NORMAL
- en: ^(\d*)(\.?)(\d+)$
  prefs: []
  type: TYPE_NORMAL
- en: 'We can just rewrite it by removing unnecessary groups, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: ^\d*\.?d+$
  prefs: []
  type: TYPE_NORMAL
- en: '4\. Sometimes, a regex may contain multiple problems, such as the ones we discussed
    in the previous subsection:'
  prefs: []
  type: TYPE_NORMAL
- en: ^https?\:\/\/(www\.)?example\.com$
  prefs: []
  type: TYPE_NORMAL
- en: 'Not only does this regex use excessive escaping but there is also an unnecessary
    capturing group in this regex. Hence, by applying these fixes, the preceding regex
    can be better written as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: ^https?://(?:www\.)?example\.com$
  prefs: []
  type: TYPE_NORMAL
- en: '**However, don''t forget to use**'
  prefs: []
  type: TYPE_NORMAL
- en: '**the required group around**'
  prefs: []
  type: TYPE_NORMAL
- en: '**alternation**'
  prefs: []
  type: TYPE_NORMAL
- en: Often, we see regex patterns that use alternation, and around the alternation,
    we use anchors or boundary matchers without safeguarding the alternation expression
    in a group. Note that the ^, $, \A, \Z, \z anchors and the \b boundary matcher
    have a higher precedence than the alternation character, | (pipe)
  prefs: []
  type: TYPE_NORMAL
- en: 'So, consider a regular expression written as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: ^com|org|net$
  prefs: []
  type: TYPE_NORMAL
- en: It will also match computer, organization, and internet, though the intent probably
    was to match only com, net, and org. This is because the start anchor, ^, is being
    applied to com only and the end anchor, $, is being applied to net, whereas org
    is not anchored at all.
  prefs: []
  type: TYPE_NORMAL
- en: 'This regular expression should be written as follows to match only com, org,
    and net correctly:'
  prefs: []
  type: TYPE_NORMAL
- en: ^(?:com|org|net)$
  prefs: []
  type: TYPE_NORMAL
- en: '**Use predefined character**'
  prefs: []
  type: TYPE_NORMAL
- en: '**classes instead of longer**'
  prefs: []
  type: TYPE_NORMAL
- en: '**versions**'
  prefs: []
  type: TYPE_NORMAL
- en: We discussed predefined character classes and Unicode character classes in[ Chapter
    2](https://cdp.packtpub.com/java_9_regular_expressions/wp-admin/post.php?post=78&action=edit),
    *Understanding the Core Concepts of Java Regular Expressions*. We need to make
    good use of it. So use \d instead of [0-9] or \D instead of [^0-9], and use \w
    instead of
  prefs: []
  type: TYPE_NORMAL
- en: '[a-zA-Z_0-9] or \W instead of [^a-zA-Z_0-9].'
  prefs: []
  type: TYPE_NORMAL
- en: '**Use the limiting quantifier**'
  prefs: []
  type: TYPE_NORMAL
- en: '**instead of repeating a**'
  prefs: []
  type: TYPE_NORMAL
- en: '**character or pattern**'
  prefs: []
  type: TYPE_NORMAL
- en: '**multiple times**'
  prefs: []
  type: TYPE_NORMAL
- en: The MAC address of a computer is a unique identifier assigned to network interfaces
    at the time of manufacturing. MAC addresses are 6 bytes or 48 bits in length and
    are written in the nn:nn:nn:nn:nn:nn format, where each n represents a hexadecimal
    digit.
  prefs: []
  type: TYPE_NORMAL
- en: 'To match a MAC address, one can write the following regex:'
  prefs: []
  type: TYPE_NORMAL
- en: ^[A-F0-9]{2}:[A-F0-9]{2}:[A-F0-9]{2}:[A-F0-9]{2}:[A-F0-9]{2}:[A-F0-9]{2}$
  prefs: []
  type: TYPE_NORMAL
- en: 'However, it is much cleaner and more readable to write the regex as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: ^(?:[A-F\d]{2}:){5}[A-F\d]{2}$
  prefs: []
  type: TYPE_NORMAL
- en: Note how short and readable this regex pattern has become when compared to the
    previous regex.
  prefs: []
  type: TYPE_NORMAL
- en: '**Do not use an unescaped**'
  prefs: []
  type: TYPE_NORMAL
- en: '**hyphen in the middle of a**'
  prefs: []
  type: TYPE_NORMAL
- en: '**character class**'
  prefs: []
  type: TYPE_NORMAL
- en: We know that most of the special regex metacharacters are treated literally
    inside the character class and we do not need to escape them inside the character
    class.
  prefs: []
  type: TYPE_NORMAL
- en: However, if an unescaped hyphen is used between two characters, then it makes
    it a range between the previous and the next character of the hyphen.
  prefs: []
  type: TYPE_NORMAL
- en: 'As an illustrative example, let''s consider this character class expression
    to match the four basic math operators, +,-,*,/:'
  prefs: []
  type: TYPE_NORMAL
- en: '[*+-/]'
  prefs: []
  type: TYPE_NORMAL
- en: The way it is written, this character class has a hyphen between the + and /
    characters.
  prefs: []
  type: TYPE_NORMAL
- en: This makes the character class match all the characters that fall between +
    (0x2A) and /
  prefs: []
  type: TYPE_NORMAL
- en: (0x2F), as per the ASCII table. Due to this reason, the preceding pattern will
    also match the comma (,), that is, 0x2C, and DOT (.), that is, 0x2E, characters.
  prefs: []
  type: TYPE_NORMAL
- en: 'An unescaped hyphen can be safely used at the first or last positions in a
    character class to avoid making a range. With that in mind, we can correct this
    character class by using any of the following forms:'
  prefs: []
  type: TYPE_NORMAL
- en: '[-*+/]'
  prefs: []
  type: TYPE_NORMAL
- en: '[*+/-]'
  prefs: []
  type: TYPE_NORMAL
- en: '[*+\-/]'
  prefs: []
  type: TYPE_NORMAL
- en: '**The mistake of calling**'
  prefs: []
  type: TYPE_NORMAL
- en: '**matcher.goup() without a**'
  prefs: []
  type: TYPE_NORMAL
- en: '**prior call to matcher.find(),**'
  prefs: []
  type: TYPE_NORMAL
- en: '**matcher.matches(), or**'
  prefs: []
  type: TYPE_NORMAL
- en: '**matcher.lookingAt()**'
  prefs: []
  type: TYPE_NORMAL
- en: This annoying mistake is found in many programs. As the heading says, these
    are cases where programmers call any of the group() methods without a prior call
    to the find, matches, or lookingAt methods. A matcher is created using the pattern.matcher(String)
    method call, but we need to invoke one of these three methods to perform a match
    operation.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we call matcher.group() without calling one of these three methods, then
    the code will throw a java.lang.IllegalStateException exception, as the following
    code is doing: package example.regex;'
  prefs: []
  type: TYPE_NORMAL
- en: import java.util.regex.*;
  prefs: []
  type: TYPE_NORMAL
- en: public class MissingMethodCall
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: public static void main(String[] args)
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: final Pattern p = Pattern.compile("(\\d*)\\.?(\\d+)"); final String input =
    "123.75";
  prefs: []
  type: TYPE_NORMAL
- en: Matcher m = p.matcher(input);
  prefs: []
  type: TYPE_NORMAL
- en: System.out.printf("Number Value [%s], Decimal Value [%s]%n", m.group(1), m.group(2));
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: Note that the code calls m.group(1) and m.group(2) right after it instantiates
    the matcher object from a pattern instance. Once compiled and executed, this code
    will throw an unwanted java.lang.IllegalStateException exception, indicating that
    the matcher instance is not in the correct state to return group information.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to fix this code, insert a call to any one of the three methods (find,
    matches, or lookingAt) to perform a match operation, as shown in the following
    code: package example.regex;'
  prefs: []
  type: TYPE_NORMAL
- en: import java.util.regex.*;
  prefs: []
  type: TYPE_NORMAL
- en: public class RightMethodCall
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: public static void main(String[] args)
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: final Pattern p = Pattern.compile("(\\d*)\\.?(\\d+)"); final String input =
    "123.75";
  prefs: []
  type: TYPE_NORMAL
- en: Matcher m = p.matcher(input);
  prefs: []
  type: TYPE_NORMAL
- en: if (m.find()) // or m.lookingAt() or m.matches()
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: System.out.printf("Integer Part [%s], Fractional Part [%s]%n", m.group(1), m.group(2));
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, this code will produce the correct output, as follows: Integer Part [123],
    Fractional Part [75]'
  prefs: []
  type: TYPE_NORMAL
- en: '**Do not use regular**'
  prefs: []
  type: TYPE_NORMAL
- en: '**expressions to parse XML /**'
  prefs: []
  type: TYPE_NORMAL
- en: '**HTML data**'
  prefs: []
  type: TYPE_NORMAL
- en: Using regular expressions to parse XML or HTML text is probably the most frequently
    committed mistake. Although regular expressions are very useful, they have their
    limitations and these limits are usually met when trying to use them for XML or
    HTML parsing. HTML and XML are not regular languages by nature.
  prefs: []
  type: TYPE_NORMAL
- en: Luckily, there are other tools in Java for that purpose. The JDK contains readily
    available classes to parse these formats and convert them to **Document Object
    Model** (**DOM**), or to work with them on the fly using the SAX parsing model.
  prefs: []
  type: TYPE_NORMAL
- en: Do not use regular expressions for certain tasks when there are more specific
    parsers for the purpose. The fact that there are other readily available tools
    gives you a hint that probably regular expressions, in such a case, are not the
    best tools. After all, that is the reason why the programmers of the XML and HTML
    parsers started their work.
  prefs: []
  type: TYPE_NORMAL
- en: '**How to test and benchmark**'
  prefs: []
  type: TYPE_NORMAL
- en: '**your regular expression**'
  prefs: []
  type: TYPE_NORMAL
- en: '**performance**'
  prefs: []
  type: TYPE_NORMAL
- en: 'There are several free online regular expression tools available that tell
    you the number of steps to match a regex pattern against a given set of inputs
    and also provide you valuable debug info. You should also write your unit test
    cases. Here is a list of some online tools that can be used:'
  prefs: []
  type: TYPE_NORMAL
- en: Use jshell available with Java 9 to quickly test your regex Use RegexMatchers,
    a utility class with static methods, to test your regex in JUnit; check [http://matchers.jcabi.com/regex-matchers.html](http://matchers.jcabi.com/regex-matchers.html)
  prefs: []
  type: TYPE_NORMAL
- en: '[regex101.com](https://regex101.com/)'
  prefs: []
  type: TYPE_NORMAL
- en: '[www.regexplanet.com](http://www.regexplanet.com/)'
  prefs: []
  type: TYPE_NORMAL
- en: '[www.rexegg.com](http://www.rexegg.com/)'
  prefs: []
  type: TYPE_NORMAL
- en: '[www.debuggex.com](https://www.debuggex.com/)'
  prefs: []
  type: TYPE_NORMAL
- en: '[regexper.com](http://regexper.com)'
  prefs: []
  type: TYPE_NORMAL
- en: '[regexbuddy.com](https://www.regexbuddy.com/) (not free) Use the Java/JUnit
    regex-tester library from [https://github.com/nickawatts/regex-tester](https://github.com/nickawatts/regex-tester)'
  prefs: []
  type: TYPE_NORMAL
- en: In addition to these tools, you can yourself write your own comprehensive unit
    test cases using JUnit in your favorite Java IDE and check the timings and other
    matching information.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example of JUnit code using the RegExMatchers library: package example.regex;'
  prefs: []
  type: TYPE_NORMAL
- en: import com.jcabi.matchers.RegexMatchers;
  prefs: []
  type: TYPE_NORMAL
- en: import org.hamcrest.MatcherAssert;
  prefs: []
  type: TYPE_NORMAL
- en: import org.junit.Test;
  prefs: []
  type: TYPE_NORMAL
- en: public class RegexTest
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: '@Test'
  prefs: []
  type: TYPE_NORMAL
- en: public void matchesDecimalNumberPattern()
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: MatcherAssert.assertThat(
  prefs: []
  type: TYPE_NORMAL
- en: '"[+-]?\\d*\\.?\\d+",'
  prefs: []
  type: TYPE_NORMAL
- en: RegexMatchers.matchesPattern("-145.78")
  prefs: []
  type: TYPE_NORMAL
- en: );
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: You are encouraged to use this library to build your own test cases and ensure
    that your regex passes all the edge cases.
  prefs: []
  type: TYPE_NORMAL
- en: '**Catastrophic or exponential**'
  prefs: []
  type: TYPE_NORMAL
- en: '**backtracking**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Regular expression engines can be broadly categorized into two types: 1\. The
    **Non-deterministic Finite Automation** (**NFA**) engine 2\. The **Deterministic
    Finite Automation** (**DFA**) engine The DFA engines do not evaluate each character
    more than once to find a match. On the other hand, the NFA engines support backtracking,
    which means that each character in the input can be evaluated multiple times by
    the regex engine. The Java regular expression engine is an NFA engine.'
  prefs: []
  type: TYPE_NORMAL
- en: Regex engines backtrack or give back one position at a time to make various
    attempts to match a given pattern when using the greedy quantifier or trying alternations.
  prefs: []
  type: TYPE_NORMAL
- en: Similarly, when using lazy quantifiers, the regex engine moves forward one position
    at a time to attempt matching.
  prefs: []
  type: TYPE_NORMAL
- en: Regex engines usually take less time to find a positive match in the given input
    as compared to returning a failure for a non-match. The NFA regex engines need
    to evaluate all the possible permutations before returning a failure.
  prefs: []
  type: TYPE_NORMAL
- en: For example, in a regular expression that uses nested repetition quantifiers,
    the regex engine backtracks excessively while matching a long input text. A catastrophic
    backtracking problem usually occurs when the regex engine fails to make a negative
    match towards the end of the string and after attempting far too many permutations.
  prefs: []
  type: TYPE_NORMAL
- en: 'As an example, check the following regex with nested quantifiers:'
  prefs: []
  type: TYPE_NORMAL
- en: ^(\w+)*$
  prefs: []
  type: TYPE_NORMAL
- en: 'Suppose we test it against an input text that does not have a word character
    in the end, such as this input string:'
  prefs: []
  type: TYPE_NORMAL
- en: 'abcdefghijklmno:'
  prefs: []
  type: TYPE_NORMAL
- en: We know that due to the presence of a non-word character (colon) at the end
    of the input, the match will fail. However, due to the presence of nested compound
    quantifiers, (\w+)*, the regex engine backtracks excessively and makes a lot of
    attempts to match the input before giving up.
  prefs: []
  type: TYPE_NORMAL
- en: 'Excessive backtracking may also be caused by two or more alternatives that
    are mutually exclusive and can match the same string in the input. For example,
    having a regex pattern like this one to match the text between the %% tags:'
  prefs: []
  type: TYPE_NORMAL
- en: '%%(.|\s)+%%'
  prefs: []
  type: TYPE_NORMAL
- en: 'This regex may also cause catastrophic backtracking for failed cases, such
    as the following input string with a missing closing tag:'
  prefs: []
  type: TYPE_NORMAL
- en: '%% something here abcd 123'
  prefs: []
  type: TYPE_NORMAL
- en: The problem here is that the alternations in (.|\s) are not mutually exclusive,
    as dot can also match the same whitespace that is matched by \s, except the newline
    character.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a complete program listing that demonstrates a dynamically building
    regex getting slower with every iteration of the loop and eventually causing catastrophic
    backtracking:'
  prefs: []
  type: TYPE_NORMAL
- en: package example.regex;
  prefs: []
  type: TYPE_NORMAL
- en: import java.util.regex.Matcher;
  prefs: []
  type: TYPE_NORMAL
- en: import java.util.regex.Pattern;
  prefs: []
  type: TYPE_NORMAL
- en: public class CatastropicBacktracking
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: public static void main(String[] args)
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: final int MAX = 30;
  prefs: []
  type: TYPE_NORMAL
- en: for (int i = 1; i < MAX; i++)
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: StringBuilder sb1 = new StringBuilder(i);
  prefs: []
  type: TYPE_NORMAL
- en: StringBuilder sb2 = new StringBuilder(i);
  prefs: []
  type: TYPE_NORMAL
- en: for (int j = i; j > 0; j--)
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: sb1.append('a');
  prefs: []
  type: TYPE_NORMAL
- en: sb2.append("a?");
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: sb2.append(sb1);
  prefs: []
  type: TYPE_NORMAL
- en: final Pattern p = Pattern.compile("^" + sb2.toString() + "$"); Matcher m = p.matcher(sb1.toString());
  prefs: []
  type: TYPE_NORMAL
- en: long start = System.nanoTime();
  prefs: []
  type: TYPE_NORMAL
- en: m.matches();
  prefs: []
  type: TYPE_NORMAL
- en: long end = System.nanoTime();
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.printf("%s:: ( %sms ) :: Pattern <%s>, Input <%s>%n", i, (end -
    start)/1_000_000, sb2, sb1);'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: 'When you compile and run the preceding program and look at the generated output,
    you will note an output as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '1:: ( 0ms ) :: Pattern <a?a>, Input <a>'
  prefs: []
  type: TYPE_NORMAL
- en: '2:: ( 0ms ) :: Pattern <a?a?aa>, Input <aa>'
  prefs: []
  type: TYPE_NORMAL
- en: '3:: ( 0ms ) :: Pattern <a?a?a?aaa>, Input <aaa> 4:: ( 0ms ) :: Pattern <a?a?a?a?aaaa>,
    Input <aaaa> 5:: ( 0ms ) :: Pattern <a?a?a?a?a?aaaaa>, Input <aaaaa> 6:: ( 0ms
    ) :: Pattern <a?a?a?a?a?a?aaaaaa>, Input <aaaaaa> 7:: ( 0ms ) :: Pattern <a?a?a?a?a?a?a?aaaaaaa>,
    Input <aaaaaaa> 8:: ( 0ms ) :: Pattern <a?a?a?a?a?a?a?a?aaaaaaaa>, Input <aaaaaaaa>
    9:: ( 0ms ) :: Pattern <a?a?a?a?a?a?a?a?a?aaaaaaaaa>, Input <aaaaaaaaa> 10:: (
    0ms ) :: Pattern <a?a?a?a?a?a?a?a?a?a?aaaaaaaaaa>, Input <aaaaaaaaaa> 11:: ( 0ms
    ) :: Pattern <a?a?a?a?a?a?a?a?a?a?a?aaaaaaaaaaa>, Input <aaaaaaaaaaa> 12:: ( 0ms
    ) :: Pattern <a?a?a?a?a?a?a?a?a?a?a?a?aaaaaaaaaaaa>, Input <aaaaaaaaaaaa> 13::
    ( 10ms ) :: Pattern <a?a?a?a?a?a?a?a?a?a?a?a?a?aaaaaaaaaaaaa>, Input <aaaaaaaaaaaaa>
    14:: ( 1ms ) :: Pattern <a?a?a?a?a?a?a?a?a?a?a?a?a?a?aaaaaaaaaaaaaa>, Input <aaaaaaaaaaaaaa>
    15:: ( 15ms ) :: Pattern <a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?aaaaaaaaaaaaaaa>, Input
    <aaaaaaaaaaaaaaa> 16:: ( 18ms ) :: Pattern <a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?aaaaaaaaaaaaaaaa>,
    Input <aaaaaaaaaaaaaaaa> 17:: ( 29ms ) :: Pattern <a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?aaaaaaaaaaaaaaaaa>,
    Input <aaaaaaaaaaaaaaaaa> 18:: ( 22ms ) :: Pattern <a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?aaaaaaaaaaaaaaaaaa>,
    Input <aaaaaaaaaaaaaaaaaa> 19:: ( 51ms ) :: Pattern <a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?aaaaaaaaaaaaaaaaaaa>,
    Input <aaaaaaaaaaaaaaaaaaa> 20:: ( 97ms ) :: Pattern <a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?aaaaaaaaaaaaaaaaaaaa>,
    Input <aaaaaaaaaaaaaaaaaaaa> 21:: ( 188ms ) :: Pattern <a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?aaaaaaaaaaaaaaaaaaaaa>,
    Input <aaaaaaaaaaaaaaaaaaaaa> 22:: ( 441ms ) :: Pattern <a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?aaaaaaaaaaaaaaaaaaaaaa>,
    Input <aaaaaaaaaaaaaaaaaaaaaa> 23:: ( 1003ms ) :: Pattern <a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?aaaaaaaaaaaaaaaaaaaaaaa>,
    Input <aaaaaaaaaaaaaaaaaaaaaaa> 24:: ( 1549ms ) :: Pattern <a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?aaaaaaaaaaaaaaaaaaaaaaaa>,
    Input <aaaaaaaaaaaaaaaaaaaaaaaa> 25:: ( 3010ms ) :: Pattern <a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?aaaaaaaaaaaaaaaaaaaaaaaaa>,
    Input <aaaaaaaaaaaaaaaaaaaaaaaaa> 26:: ( 5884ms ) :: Pattern <a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?aaaaaaaaaaaaaaaaaaaaaaaaaa>,
    Input <aaaaaaaaaaaaaaaaaaaaaaaaaa>'
  prefs: []
  type: TYPE_NORMAL
- en: '27:: ( 12588ms ) :: Pattern <a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?aaaaaaaaaaaaaaaaaaaaaaaaaaa>,
    Input <aaaaaaaaaaaaaaaaaaaaaaaaaaa> 28:: ( 24765ms ) :: Pattern <a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?aaaaaaaaaaaaaaaaaaaaaaaaaaaa>,
    Input <aaaaaaaaaaaaaaaaaaaaaaaaaaaa> 29:: ( 51679ms ) :: Pattern <a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?aaaaaaaaaaaaaaaaaaaaaaaaaaaaa>,
    Input <aaaaaaaaaaaaaaaaaaaaaaaaaaaaa> Note how the execution time grows rapidly
    on higher values of the counter i, especially after 25\.'
  prefs: []
  type: TYPE_NORMAL
- en: '**How to avoid catastrophic**'
  prefs: []
  type: TYPE_NORMAL
- en: '**backtracking**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are some tips to keep in mind while handling situations with catastrophic
    or excessive backtracking in your regex:'
  prefs: []
  type: TYPE_NORMAL
- en: When you write regular expressions, make sure they fail fast without spending
    a lot of unnecessary steps in backtracking.
  prefs: []
  type: TYPE_NORMAL
- en: When using nested repetition operators or quantifiers, make sure that there
    is only one unique way to match the a string.
  prefs: []
  type: TYPE_NORMAL
- en: Make good judicious use of atomic groups and possessive quantifiers to avoid
    excessive backtracking.
  prefs: []
  type: TYPE_NORMAL
- en: You should avoid having too many optional matches that are not mutually exclusive
    in an alternation pattern.
  prefs: []
  type: TYPE_NORMAL
- en: Be very careful when using a free-flowing pattern such as .* or .+ in your regex.
  prefs: []
  type: TYPE_NORMAL
- en: Wherever possible, use negated character classes for cutting down the backtracking
    steps and for better performance.
  prefs: []
  type: TYPE_NORMAL
- en: Avoid matching hugely sized text using a single regex. It is better to match
    smaller strings using your regex and call matcher.find() in a loop to get multiple
    matches. If needed, use another inner pattern to match and examine the matches
    found by the main pattern.
  prefs: []
  type: TYPE_NORMAL
- en: 'The regex with the nested quantifier that caused catastrophic backtracking
    is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: ^(\w+)*$
  prefs: []
  type: TYPE_NORMAL
- en: 'We can make use of possessive quantifiers to disallow any backtracking, as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: ^(\w+)*+$
  prefs: []
  type: TYPE_NORMAL
- en: You will note a massive jump in this improved regex in any of the benchmarks
    or regex testing tools, as suggested earlier.
  prefs: []
  type: TYPE_NORMAL
- en: 'Also, in the alternation regex example, we found that this regex causes excessive
    backtracking for failed cases:'
  prefs: []
  type: TYPE_NORMAL
- en: '%%(.|\s)%%'
  prefs: []
  type: TYPE_NORMAL
- en: 'It can be converted to the following regex to avoid excessive backtracking:'
  prefs: []
  type: TYPE_NORMAL
- en: '%%(\S|\s)+%%'
  prefs: []
  type: TYPE_NORMAL
- en: 'It is even better to avoid the group and use a character class, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '%%[\S\s]+%%'
  prefs: []
  type: TYPE_NORMAL
- en: Note the use of \S instead of dot to make alternatives mutually exclusive.
  prefs: []
  type: TYPE_NORMAL
- en: 'A regex that can cause excessive backtracking is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: ^(?:.*:)+#$
  prefs: []
  type: TYPE_NORMAL
- en: 'In the preceding regex example, if we use a negated character class instead
    of .*, then we can avoid catastrophic backtracking:'
  prefs: []
  type: TYPE_NORMAL
- en: ^(?:[^:]+:)+#$
  prefs: []
  type: TYPE_NORMAL
- en: The regex engine doesn't backtrack excessively because the negated character
    class,
  prefs: []
  type: TYPE_NORMAL
- en: '[^:], matches any character except a colon instead of the dot that matches
    everything, including the colon.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider another example with this regex pattern that has the nested repetition
    operator, +:'
  prefs: []
  type: TYPE_NORMAL
- en: '%(?:[p-s]+|ye|wo)+%'
  prefs: []
  type: TYPE_NORMAL
- en: 'This regex pattern attempts to match a string that starts with the following
    conditions: Must start with %'
  prefs: []
  type: TYPE_NORMAL
- en: '% must be followed by one or more alternations: letters p,q,r,s or the string
    ye or wo'
  prefs: []
  type: TYPE_NORMAL
- en: Must end with another %
  prefs: []
  type: TYPE_NORMAL
- en: 'Now test this regex pattern against the input string, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '%yeqpsrwospqr'
  prefs: []
  type: TYPE_NORMAL
- en: Obviously, the regex pattern is not going to match because the last % is missing.
  prefs: []
  type: TYPE_NORMAL
- en: However, note that the starting % and all the following letters will match the
    regex pattern before the last %. Due to this, the regex engine will backtrack
    several times while making attempts to match the complete input before finally
    giving up.
  prefs: []
  type: TYPE_NORMAL
- en: 'When testing this regex on the *regex101* website''s debugger, it shows the
    following: match 1 failed in 748 steps'
  prefs: []
  type: TYPE_NORMAL
- en: 748 may be a quite a big number for the number of steps taken to fail the match
    for a small-sized input. Regex patterns such as this can slow down your application
    considerably. Some of them can even hang your code for many hours or days due
    to the catastrophic backtracking behavior.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, to prevent this catastrophic backtracking behavior, let''s consider the
    two options the we recommended earlier:'
  prefs: []
  type: TYPE_NORMAL
- en: '1\. Use a possessive quantifier, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '%(?:[p-s]+|ye|wo)++%'
  prefs: []
  type: TYPE_NORMAL
- en: 'On testing the preceding pattern on the same site, we get the following in
    the debugger:'
  prefs: []
  type: TYPE_NORMAL
- en: match 1 failed in 33 steps
  prefs: []
  type: TYPE_NORMAL
- en: '2\. Use an atomic group, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '%(?>[p-s]+|ye|wo)+%'
  prefs: []
  type: TYPE_NORMAL
- en: 'On testing the preceding pattern on the same site, we get the following in
    the debugger:'
  prefs: []
  type: TYPE_NORMAL
- en: match 1 failed in 36 steps
  prefs: []
  type: TYPE_NORMAL
- en: You can notice that by using any of the aforementioned techniques, we make the
    regex engine fail sooner and avoid the unnecessarily high number of backtracking
    steps.
  prefs: []
  type: TYPE_NORMAL
- en: '**Optimization and**'
  prefs: []
  type: TYPE_NORMAL
- en: '**performance enhancement**'
  prefs: []
  type: TYPE_NORMAL
- en: '**tips**'
  prefs: []
  type: TYPE_NORMAL
- en: Let's discuss some optimization techniques and performance enhancement guidelines.
  prefs: []
  type: TYPE_NORMAL
- en: '**Use a compiled form of**'
  prefs: []
  type: TYPE_NORMAL
- en: '**regular expressions**'
  prefs: []
  type: TYPE_NORMAL
- en: Compile your string regex pattern using the Pattern.compile(String) method call
    followed by calls to the Matcher APIs instead of calling shorthand methods in
    string, such as matches(), replaceAll, and replaceFirst, especially when these
    matching or replacement methods are invoked repeatedly inside a loop. Repeated
    calls to String.matches() or any other regex-based method defined in the String
    API will compile the String regex pattern every time; this can be very time-consuming
    for a complex regex pattern.
  prefs: []
  type: TYPE_NORMAL
- en: '**Use a negated character**'
  prefs: []
  type: TYPE_NORMAL
- en: '**class instead of the greedy**'
  prefs: []
  type: TYPE_NORMAL
- en: '**and slow .* or .+**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Wherever possible, use negated character classes instead of the potential performance
    draining patterns (.* or .+), as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: param1=[^&]+&param2=[^&]+&param3=[^&]+$
  prefs: []
  type: TYPE_NORMAL
- en: 'Avoid using slow-performing quantifiers, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: param1=.+&param2=.+param3=.+$
  prefs: []
  type: TYPE_NORMAL
- en: '**Avoid unnecessary grouping**'
  prefs: []
  type: TYPE_NORMAL
- en: Avoiding unnecessary captured groups in your regex. If grouping is required
    in your regex, then use non-capturing groups to save the overall memory footprint
    of the regex pattern while executing.
  prefs: []
  type: TYPE_NORMAL
- en: '**Use lazy quantifiers**'
  prefs: []
  type: TYPE_NORMAL
- en: '**strategically instead of**'
  prefs: []
  type: TYPE_NORMAL
- en: '**greedy quantifiers that cause**'
  prefs: []
  type: TYPE_NORMAL
- en: '**excessive backtracking**'
  prefs: []
  type: TYPE_NORMAL
- en: Suppose we need to match an input that contains three complete words, *start*,
    *middle*, and *end*, separated by non-whitespace characters.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider using the following pattern with a lazy quantifier:'
  prefs: []
  type: TYPE_NORMAL
- en: \bstart\b\S+?\bmiddle\b\S+?\bend\b
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead of using the following pattern, our match will be faster if we use
    the preceding pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: \bstart\b\S+\bmiddle\b\S+\bend\b
  prefs: []
  type: TYPE_NORMAL
- en: '**Make use of possessive**'
  prefs: []
  type: TYPE_NORMAL
- en: '**quantifiers to avoid**'
  prefs: []
  type: TYPE_NORMAL
- en: '**backtracking**'
  prefs: []
  type: TYPE_NORMAL
- en: Recall that we discussed in an earlier chapter how a possessive quantifier is
    used for fail-fast paradigm. Wherever possible, make good use of possessive quantifiers
    to tell the regex engine to avoid backtracking.
  prefs: []
  type: TYPE_NORMAL
- en: Suppose we need to write a regex to match the text between two markers, @START@
    and
  prefs: []
  type: TYPE_NORMAL
- en: '@END@. It is given that the semicolon is now allowed between two markers.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can write this regex with the + or greedy quantifier, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '@START@[^;]+@END@'
  prefs: []
  type: TYPE_NORMAL
- en: 'However, it is better to use the ++ or possessive quantifier in the regex,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '@START@[^;]++@END@'
  prefs: []
  type: TYPE_NORMAL
- en: 'This regex will be faster to execute for failed matches, such as the following
    string:'
  prefs: []
  type: TYPE_NORMAL
- en: '@START@ abc 123 foo @XYZ@'
  prefs: []
  type: TYPE_NORMAL
- en: '**Extract common repeating**'
  prefs: []
  type: TYPE_NORMAL
- en: '**substrings out of alternation**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: (playground|player|playing)
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead of using the preceding pattern, it is better to extract the common
    substring, play, and move it to the left of alternation, as follows: play(ground|er|ing)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Use atomic group to avoid**'
  prefs: []
  type: TYPE_NORMAL
- en: '**backtracking and fail fast**'
  prefs: []
  type: TYPE_NORMAL
- en: Recall from [Chapter 6](#p133), *Exploring Zero-Width Assertions, Lookarounds,
    and Atomic* *Groups,* that an atomic group is a non-capturing group that exits
    the group and throws away all the alternative positions remembered by any token
    inside the group, after the first match of the pattern inside the group. Thus,
    it avoids backtracking to attempt all the alternatives present in the group.
  prefs: []
  type: TYPE_NORMAL
- en: Due to this very characteristic of atomic groups, the use of atomic groups in
    certain scenarios saves many unnecessary backtracking steps and speeds up the
    overall regex execution.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, use this atomic group:'
  prefs: []
  type: TYPE_NORMAL
- en: \btra(?>ck|ce|ining|de|in|nsit|ns|uma)\b
  prefs: []
  type: TYPE_NORMAL
- en: 'It is better to use the preceding atomic group instead of the following non-capturing
    group:'
  prefs: []
  type: TYPE_NORMAL
- en: \btra(?:ck|ce|ining|de|in|nsit|ns|uma)\b
  prefs: []
  type: TYPE_NORMAL
- en: The difference in behavior will be evident when matching an input string, such
    as *tracker*, which fails to match.
  prefs: []
  type: TYPE_NORMAL
- en: '**Summary**'
  prefs: []
  type: TYPE_NORMAL
- en: In the final chapter of this book, we discussed some common mistakes people
    make while writing regular expressions. These mistakes often cause some exceptions
    to be thrown at runtime or cause the regular expressions to fail the match unexpectedly.
  prefs: []
  type: TYPE_NORMAL
- en: Then, you learned the various ways to avoid such mistakes.
  prefs: []
  type: TYPE_NORMAL
- en: We discussed catastrophic backtracking in regular expressions and the tricks
    to avoid excessive backtracking. By minimizing the backtracking steps, regular
    expressions can become really efficient.
  prefs: []
  type: TYPE_NORMAL
- en: You learned the testing and benchmarking techniques for regular expressions.
    Finally, we covered many regex optimization and performance enhancing tips in
    detail. We hope these tips help you understand the building blocks of regular
    expressions and write better-performing regular expressions to solve complex parsing
    and matching problems.
  prefs: []
  type: TYPE_NORMAL
- en: This book was downloaded from AvaxHome!
  prefs: []
  type: TYPE_NORMAL
- en: 'Visit my blog for more new books:'
  prefs: []
  type: TYPE_NORMAL
- en: '[www.avxhm.se/blogs/AlenMiler](https://tr.im/avaxhome)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Inhaltsverzeichnis**'
  prefs: []
  type: TYPE_NORMAL
- en: Preface
  prefs: []
  type: TYPE_NORMAL
- en: '16'
  prefs: []
  type: TYPE_NORMAL
- en: What this book covers
  prefs: []
  type: TYPE_NORMAL
- en: '17'
  prefs: []
  type: TYPE_NORMAL
- en: What you need for this book
  prefs: []
  type: TYPE_NORMAL
- en: '18'
  prefs: []
  type: TYPE_NORMAL
- en: Who this book is for
  prefs: []
  type: TYPE_NORMAL
- en: '19'
  prefs: []
  type: TYPE_NORMAL
- en: Conventions
  prefs: []
  type: TYPE_NORMAL
- en: '20'
  prefs: []
  type: TYPE_NORMAL
- en: Reader feedback
  prefs: []
  type: TYPE_NORMAL
- en: '21'
  prefs: []
  type: TYPE_NORMAL
- en: Customer support
  prefs: []
  type: TYPE_NORMAL
- en: '22'
  prefs: []
  type: TYPE_NORMAL
- en: Downloading the example code
  prefs: []
  type: TYPE_NORMAL
- en: '23'
  prefs: []
  type: TYPE_NORMAL
- en: Errata
  prefs: []
  type: TYPE_NORMAL
- en: '24'
  prefs: []
  type: TYPE_NORMAL
- en: Piracy
  prefs: []
  type: TYPE_NORMAL
- en: '25'
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs: []
  type: TYPE_NORMAL
- en: '26'
  prefs: []
  type: TYPE_NORMAL
- en: Getting Started with Regular Expressions
  prefs: []
  type: TYPE_NORMAL
- en: '27'
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to regular expressions
  prefs: []
  type: TYPE_NORMAL
- en: '28'
  prefs: []
  type: TYPE_NORMAL
- en: A bit of history of regular expressions
  prefs: []
  type: TYPE_NORMAL
- en: '29'
  prefs: []
  type: TYPE_NORMAL
- en: Various flavors of regular expressions
  prefs: []
  type: TYPE_NORMAL
- en: '30'
  prefs: []
  type: TYPE_NORMAL
- en: What type of problems need regular expressions to solve
  prefs: []
  type: TYPE_NORMAL
- en: '31'
  prefs: []
  type: TYPE_NORMAL
- en: The basic rules of regular expressions
  prefs: []
  type: TYPE_NORMAL
- en: '32'
  prefs: []
  type: TYPE_NORMAL
- en: Constructs of the standard regular expression and meta
  prefs: []
  type: TYPE_NORMAL
- en: '33'
  prefs: []
  type: TYPE_NORMAL
- en: characters
  prefs: []
  type: TYPE_NORMAL
- en: Some basic regular expression examples
  prefs: []
  type: TYPE_NORMAL
- en: '36'
  prefs: []
  type: TYPE_NORMAL
- en: Eager matching
  prefs: []
  type: TYPE_NORMAL
- en: '38'
  prefs: []
  type: TYPE_NORMAL
- en: The effect of eager matching on regular expression alternation 39
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs: []
  type: TYPE_NORMAL
- en: '41'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the Core Constructs of Java Regular
  prefs: []
  type: TYPE_NORMAL
- en: '42'
  prefs: []
  type: TYPE_NORMAL
- en: Expressions
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the core constructs of regular expressions
  prefs: []
  type: TYPE_NORMAL
- en: '43'
  prefs: []
  type: TYPE_NORMAL
- en: Quantifiers
  prefs: []
  type: TYPE_NORMAL
- en: '44'
  prefs: []
  type: TYPE_NORMAL
- en: Basic quantifiers
  prefs: []
  type: TYPE_NORMAL
- en: '45'
  prefs: []
  type: TYPE_NORMAL
- en: Examples using quantifiers
  prefs: []
  type: TYPE_NORMAL
- en: '46'
  prefs: []
  type: TYPE_NORMAL
- en: Greedy versus reluctant (lazy) matching using quantifiers 47
  prefs: []
  type: TYPE_NORMAL
- en: Possessive quantifiers
  prefs: []
  type: TYPE_NORMAL
- en: '48'
  prefs: []
  type: TYPE_NORMAL
- en: Boundary constructs
  prefs: []
  type: TYPE_NORMAL
- en: '50'
  prefs: []
  type: TYPE_NORMAL
- en: Examples using boundary constructs
  prefs: []
  type: TYPE_NORMAL
- en: '51'
  prefs: []
  type: TYPE_NORMAL
- en: Character classes
  prefs: []
  type: TYPE_NORMAL
- en: '52'
  prefs: []
  type: TYPE_NORMAL
- en: Examples of character classes
  prefs: []
  type: TYPE_NORMAL
- en: '53'
  prefs: []
  type: TYPE_NORMAL
- en: Range inside a character class
  prefs: []
  type: TYPE_NORMAL
- en: '54'
  prefs: []
  type: TYPE_NORMAL
- en: Examples of character range
  prefs: []
  type: TYPE_NORMAL
- en: '55'
  prefs: []
  type: TYPE_NORMAL
- en: Escaping special regex metacharacters and escaping rules inside 56
  prefs: []
  type: TYPE_NORMAL
- en: the character classes
  prefs: []
  type: TYPE_NORMAL
- en: Escaping inside a character class
  prefs: []
  type: TYPE_NORMAL
- en: '57'
  prefs: []
  type: TYPE_NORMAL
- en: Examples of escaping rules inside the character class 58
  prefs: []
  type: TYPE_NORMAL
- en: Literally matching a string that may contain special regex 59
  prefs: []
  type: TYPE_NORMAL
- en: metacharacters
  prefs: []
  type: TYPE_NORMAL
- en: Negated character classes
  prefs: []
  type: TYPE_NORMAL
- en: '60'
  prefs: []
  type: TYPE_NORMAL
- en: Examples of negated character classes
  prefs: []
  type: TYPE_NORMAL
- en: '61'
  prefs: []
  type: TYPE_NORMAL
- en: Predefined shorthand character classes
  prefs: []
  type: TYPE_NORMAL
- en: '62'
  prefs: []
  type: TYPE_NORMAL
- en: POSIX character classes
  prefs: []
  type: TYPE_NORMAL
- en: '63'
  prefs: []
  type: TYPE_NORMAL
- en: Unicode support in Java regular expressions
  prefs: []
  type: TYPE_NORMAL
- en: '64'
  prefs: []
  type: TYPE_NORMAL
- en: Commonly used Unicode character properties
  prefs: []
  type: TYPE_NORMAL
- en: '65'
  prefs: []
  type: TYPE_NORMAL
- en: Negation of the preceding regex directives
  prefs: []
  type: TYPE_NORMAL
- en: '66'
  prefs: []
  type: TYPE_NORMAL
- en: Unicode scripts support
  prefs: []
  type: TYPE_NORMAL
- en: '67'
  prefs: []
  type: TYPE_NORMAL
- en: Examples of matching Unicode text in regular
  prefs: []
  type: TYPE_NORMAL
- en: '69'
  prefs: []
  type: TYPE_NORMAL
- en: expressions
  prefs: []
  type: TYPE_NORMAL
- en: Double escaping in a Java String when defining regular
  prefs: []
  type: TYPE_NORMAL
- en: '70'
  prefs: []
  type: TYPE_NORMAL
- en: expressions
  prefs: []
  type: TYPE_NORMAL
- en: Embedded regular expression mode modifiers
  prefs: []
  type: TYPE_NORMAL
- en: '71'
  prefs: []
  type: TYPE_NORMAL
- en: The placement of embedded modes in a Java regular
  prefs: []
  type: TYPE_NORMAL
- en: '73'
  prefs: []
  type: TYPE_NORMAL
- en: expression
  prefs: []
  type: TYPE_NORMAL
- en: Disabling mode modifiers
  prefs: []
  type: TYPE_NORMAL
- en: '74'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs: []
  type: TYPE_NORMAL
- en: '75'
  prefs: []
  type: TYPE_NORMAL
- en: Working with Groups, Capturing, and References
  prefs: []
  type: TYPE_NORMAL
- en: '76'
  prefs: []
  type: TYPE_NORMAL
- en: Capturing groups
  prefs: []
  type: TYPE_NORMAL
- en: '77'
  prefs: []
  type: TYPE_NORMAL
- en: Group numbering
  prefs: []
  type: TYPE_NORMAL
- en: '78'
  prefs: []
  type: TYPE_NORMAL
- en: Named groups
  prefs: []
  type: TYPE_NORMAL
- en: '80'
  prefs: []
  type: TYPE_NORMAL
- en: Non-capturing groups
  prefs: []
  type: TYPE_NORMAL
- en: '81'
  prefs: []
  type: TYPE_NORMAL
- en: Advantages of non-capturing groups
  prefs: []
  type: TYPE_NORMAL
- en: '82'
  prefs: []
  type: TYPE_NORMAL
- en: Back references
  prefs: []
  type: TYPE_NORMAL
- en: '83'
  prefs: []
  type: TYPE_NORMAL
- en: Back reference of a named group
  prefs: []
  type: TYPE_NORMAL
- en: '85'
  prefs: []
  type: TYPE_NORMAL
- en: Replacement reference of a named group
  prefs: []
  type: TYPE_NORMAL
- en: '86'
  prefs: []
  type: TYPE_NORMAL
- en: Forward references
  prefs: []
  type: TYPE_NORMAL
- en: '87'
  prefs: []
  type: TYPE_NORMAL
- en: Invalid (non-existing) backward or forward references
  prefs: []
  type: TYPE_NORMAL
- en: '89'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs: []
  type: TYPE_NORMAL
- en: '90'
  prefs: []
  type: TYPE_NORMAL
- en: Regular Expression Programming Using Java String and
  prefs: []
  type: TYPE_NORMAL
- en: '91'
  prefs: []
  type: TYPE_NORMAL
- en: Scanner APIs
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to the Java String API for regular expressions'
  prefs: []
  type: TYPE_NORMAL
- en: '92'
  prefs: []
  type: TYPE_NORMAL
- en: evaluation
  prefs: []
  type: TYPE_NORMAL
- en: Method - boolean matches(String regex)
  prefs: []
  type: TYPE_NORMAL
- en: '93'
  prefs: []
  type: TYPE_NORMAL
- en: Example of the matches method
  prefs: []
  type: TYPE_NORMAL
- en: '94'
  prefs: []
  type: TYPE_NORMAL
- en: Method - String replaceAll(String regex, String replacement) 96
  prefs: []
  type: TYPE_NORMAL
- en: Examples of the replaceAll method
  prefs: []
  type: TYPE_NORMAL
- en: '97'
  prefs: []
  type: TYPE_NORMAL
- en: Method - String replaceFirst(String regex, String replacement) 99
  prefs: []
  type: TYPE_NORMAL
- en: Examples of the replaceFirst method
  prefs: []
  type: TYPE_NORMAL
- en: '100'
  prefs: []
  type: TYPE_NORMAL
- en: Methods - String split methods
  prefs: []
  type: TYPE_NORMAL
- en: '101'
  prefs: []
  type: TYPE_NORMAL
- en: The limit parameter rules
  prefs: []
  type: TYPE_NORMAL
- en: '102'
  prefs: []
  type: TYPE_NORMAL
- en: Examples of the split method
  prefs: []
  type: TYPE_NORMAL
- en: '103'
  prefs: []
  type: TYPE_NORMAL
- en: Example of the split method using the limit parameter
  prefs: []
  type: TYPE_NORMAL
- en: '104'
  prefs: []
  type: TYPE_NORMAL
- en: Using regular expressions in Java Scanner API
  prefs: []
  type: TYPE_NORMAL
- en: '106'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs: []
  type: TYPE_NORMAL
- en: '110'
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to Java Regular Expression APIs - Pattern and 111
  prefs: []
  type: TYPE_NORMAL
- en: Matcher Classes
  prefs: []
  type: TYPE_NORMAL
- en: The MatchResult interface
  prefs: []
  type: TYPE_NORMAL
- en: '112'
  prefs: []
  type: TYPE_NORMAL
- en: The Pattern class
  prefs: []
  type: TYPE_NORMAL
- en: '114'
  prefs: []
  type: TYPE_NORMAL
- en: Examples using the Pattern class
  prefs: []
  type: TYPE_NORMAL
- en: '116'
  prefs: []
  type: TYPE_NORMAL
- en: Filtering a list of tokens using the asPredicate() method 119
  prefs: []
  type: TYPE_NORMAL
- en: The Matcher class
  prefs: []
  type: TYPE_NORMAL
- en: '120'
  prefs: []
  type: TYPE_NORMAL
- en: Examples using the Matcher class
  prefs: []
  type: TYPE_NORMAL
- en: '123'
  prefs: []
  type: TYPE_NORMAL
- en: Method Boolean lookingAt()
  prefs: []
  type: TYPE_NORMAL
- en: '124'
  prefs: []
  type: TYPE_NORMAL
- en: The matches() method
  prefs: []
  type: TYPE_NORMAL
- en: '125'
  prefs: []
  type: TYPE_NORMAL
- en: The find() and find(int start) methods
  prefs: []
  type: TYPE_NORMAL
- en: '126'
  prefs: []
  type: TYPE_NORMAL
- en: The appendReplacement(StringBuffer sb, String replacement) 128
  prefs: []
  type: TYPE_NORMAL
- en: method
  prefs: []
  type: TYPE_NORMAL
- en: The appendTail(StringBuffer sb) method
  prefs: []
  type: TYPE_NORMAL
- en: '129'
  prefs: []
  type: TYPE_NORMAL
- en: Example of the appendReplacement and appendTail methods
  prefs: []
  type: TYPE_NORMAL
- en: '130'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs: []
  type: TYPE_NORMAL
- en: '132'
  prefs: []
  type: TYPE_NORMAL
- en: Exploring Zero-Width Assertions, Lookarounds, and
  prefs: []
  type: TYPE_NORMAL
- en: '133'
  prefs: []
  type: TYPE_NORMAL
- en: Atomic Groups
  prefs: []
  type: TYPE_NORMAL
- en: Zero-width assertions
  prefs: []
  type: TYPE_NORMAL
- en: '134'
  prefs: []
  type: TYPE_NORMAL
- en: Predefined zero-width assertions
  prefs: []
  type: TYPE_NORMAL
- en: '135'
  prefs: []
  type: TYPE_NORMAL
- en: Regex defined zero-width assertions
  prefs: []
  type: TYPE_NORMAL
- en: '136'
  prefs: []
  type: TYPE_NORMAL
- en: \G boundary assertion
  prefs: []
  type: TYPE_NORMAL
- en: '137'
  prefs: []
  type: TYPE_NORMAL
- en: Atomic groups
  prefs: []
  type: TYPE_NORMAL
- en: '139'
  prefs: []
  type: TYPE_NORMAL
- en: Lookahead assertions
  prefs: []
  type: TYPE_NORMAL
- en: '141'
  prefs: []
  type: TYPE_NORMAL
- en: Positive lookahead
  prefs: []
  type: TYPE_NORMAL
- en: '142'
  prefs: []
  type: TYPE_NORMAL
- en: Negative lookahead
  prefs: []
  type: TYPE_NORMAL
- en: '143'
  prefs: []
  type: TYPE_NORMAL
- en: Lookbehind assertions
  prefs: []
  type: TYPE_NORMAL
- en: '144'
  prefs: []
  type: TYPE_NORMAL
- en: Positive lookbehind
  prefs: []
  type: TYPE_NORMAL
- en: '145'
  prefs: []
  type: TYPE_NORMAL
- en: Negative lookbehind
  prefs: []
  type: TYPE_NORMAL
- en: '146'
  prefs: []
  type: TYPE_NORMAL
- en: Capturing text from overlapping matches
  prefs: []
  type: TYPE_NORMAL
- en: '151'
  prefs: []
  type: TYPE_NORMAL
- en: Be careful with capturing groups inside a lookahead or
  prefs: []
  type: TYPE_NORMAL
- en: '153'
  prefs: []
  type: TYPE_NORMAL
- en: lookbehind atomic group
  prefs: []
  type: TYPE_NORMAL
- en: Lookbehind limitations in Java regular expressions
  prefs: []
  type: TYPE_NORMAL
- en: '154'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs: []
  type: TYPE_NORMAL
- en: '155'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the Union, Intersection, and Subtraction of 156
  prefs: []
  type: TYPE_NORMAL
- en: Character Classes
  prefs: []
  type: TYPE_NORMAL
- en: The union of character classes
  prefs: []
  type: TYPE_NORMAL
- en: '157'
  prefs: []
  type: TYPE_NORMAL
- en: The intersection of character classes
  prefs: []
  type: TYPE_NORMAL
- en: '159'
  prefs: []
  type: TYPE_NORMAL
- en: The subtraction of character classes
  prefs: []
  type: TYPE_NORMAL
- en: '162'
  prefs: []
  type: TYPE_NORMAL
- en: Why should you use composite character classes?
  prefs: []
  type: TYPE_NORMAL
- en: '164'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs: []
  type: TYPE_NORMAL
- en: '165'
  prefs: []
  type: TYPE_NORMAL
- en: Regular Expression Pitfalls, Optimization, and Performance 166
  prefs: []
  type: TYPE_NORMAL
- en: Improvements
  prefs: []
  type: TYPE_NORMAL
- en: Common pitfalls and ways to avoid them while writing regular 167
  prefs: []
  type: TYPE_NORMAL
- en: expressions
  prefs: []
  type: TYPE_NORMAL
- en: Do not forget to escape regex metacharacters outside a character 168
  prefs: []
  type: TYPE_NORMAL
- en: class
  prefs: []
  type: TYPE_NORMAL
- en: Avoid escaping every non-word character
  prefs: []
  type: TYPE_NORMAL
- en: '169'
  prefs: []
  type: TYPE_NORMAL
- en: Avoid unnecessary capturing groups to reduce memory
  prefs: []
  type: TYPE_NORMAL
- en: '170'
  prefs: []
  type: TYPE_NORMAL
- en: consumption
  prefs: []
  type: TYPE_NORMAL
- en: However, don't forget to use the required group around
  prefs: []
  type: TYPE_NORMAL
- en: '171'
  prefs: []
  type: TYPE_NORMAL
- en: alternation
  prefs: []
  type: TYPE_NORMAL
- en: Use predefined character classes instead of longer versions 172
  prefs: []
  type: TYPE_NORMAL
- en: Use the limiting quantifier instead of repeating a character or 173
  prefs: []
  type: TYPE_NORMAL
- en: pattern multiple times
  prefs: []
  type: TYPE_NORMAL
- en: Do not use an unescaped hyphen in the middle of a character 174
  prefs: []
  type: TYPE_NORMAL
- en: class
  prefs: []
  type: TYPE_NORMAL
- en: The mistake of calling matcher.goup() without a prior call to 175
  prefs: []
  type: TYPE_NORMAL
- en: matcher.find(), matcher.matches(), or matcher.lookingAt() Do not use regular
    expressions to parse XML / HTML data
  prefs: []
  type: TYPE_NORMAL
- en: '177'
  prefs: []
  type: TYPE_NORMAL
- en: How to test and benchmark your regular expression performance 178
  prefs: []
  type: TYPE_NORMAL
- en: Catastrophic or exponential backtracking
  prefs: []
  type: TYPE_NORMAL
- en: '179'
  prefs: []
  type: TYPE_NORMAL
- en: How to avoid catastrophic backtracking
  prefs: []
  type: TYPE_NORMAL
- en: '182'
  prefs: []
  type: TYPE_NORMAL
- en: Optimization and performance enhancement tips
  prefs: []
  type: TYPE_NORMAL
- en: '185'
  prefs: []
  type: TYPE_NORMAL
- en: Use a compiled form of regular expressions
  prefs: []
  type: TYPE_NORMAL
- en: '186'
  prefs: []
  type: TYPE_NORMAL
- en: Use a negated character class instead of the greedy and slow .*
  prefs: []
  type: TYPE_NORMAL
- en: '187'
  prefs: []
  type: TYPE_NORMAL
- en: or .+
  prefs: []
  type: TYPE_NORMAL
- en: Avoid unnecessary grouping
  prefs: []
  type: TYPE_NORMAL
- en: '188'
  prefs: []
  type: TYPE_NORMAL
- en: Use lazy quantifiers strategically instead of greedy quantifiers 189
  prefs: []
  type: TYPE_NORMAL
- en: that cause excessive backtracking
  prefs: []
  type: TYPE_NORMAL
- en: Make use of possessive quantifiers to avoid backtracking
  prefs: []
  type: TYPE_NORMAL
- en: '190'
  prefs: []
  type: TYPE_NORMAL
- en: Extract common repeating substrings out of alternation
  prefs: []
  type: TYPE_NORMAL
- en: '191'
  prefs: []
  type: TYPE_NORMAL
- en: Use atomic group to avoid backtracking and fail fast
  prefs: []
  type: TYPE_NORMAL
- en: '192'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs: []
  type: TYPE_NORMAL
- en: '193'
  prefs: []
  type: TYPE_NORMAL
- en: Document Outline
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[Preface](index_split_000.html#p16)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[What this book covers](index_split_000.html#p17)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[What you need for this book](index_split_000.html#p18)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Who this book is for](index_split_000.html#p19)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Conventions](index_split_000.html#p20)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Reader feedback](index_split_000.html#p21)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Customer support](index_split_000.html#p22)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Downloading the example code](index_split_000.html#p23)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Errata](index_split_000.html#p24)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Piracy](index_split_000.html#p25)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Questions](index_split_000.html#p26)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Getting Started with Regular Expressions](index_split_000.html#p27)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Introduction to regular expressions](index_split_000.html#p28)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[A bit of history of regular expressions](index_split_000.html#p29)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Various flavors of regular expressions](index_split_000.html#p30)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[What type of problems need regular expressions to solve](index_split_000.html#p31)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[The basic rules of regular expressions](index_split_000.html#p32)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Constructs of the standard regular expression and meta characters](index_split_000.html#p33)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Some basic regular expression examples](index_split_000.html#p36)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Eager matching](index_split_000.html#p38)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[The effect of eager matching on regular expression alternation](index_split_000.html#p39)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Summary](index_split_000.html#p41)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Understanding the Core Constructs of Java Regular Expressions](index_split_000.html#p42)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Understanding the core constructs of regular expressions](index_split_000.html#p43)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Quantifiers](index_split_000.html#p44)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Basic quantifiers](index_split_000.html#p45)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Examples using quantifiers](index_split_000.html#p46)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Greedy versus reluctant (lazy) matching using quantifiers](index_split_000.html#p47)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Possessive quantifiers](index_split_000.html#p48)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Boundary constructs](index_split_000.html#p50)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Examples using boundary constructs](index_split_000.html#p51)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Character classes](index_split_000.html#p52)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Examples of character classes](index_split_000.html#p53)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Range inside a character class](index_split_000.html#p54)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Examples of character range](index_split_000.html#p55)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Escaping special regex metacharacters and escaping rules inside the character
    classes](index_split_000.html#p56)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Escaping inside a character class](index_split_000.html#p57)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Examples of escaping rules inside the character class](index_split_000.html#p58)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Literally matching a string that may contain special regex metacharacters](index_split_000.html#p59)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Negated character classes](index_split_000.html#p60)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Examples of negated character classes](index_split_000.html#p61)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Predefined shorthand character classes](index_split_000.html#p62)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[POSIX character classes](index_split_000.html#p63)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Unicode support in Java regular expressions](index_split_000.html#p64)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Commonly used Unicode character properties](index_split_000.html#p65)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Negation of the preceding regex directives](index_split_000.html#p66)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Unicode scripts support](index_split_000.html#p67)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Examples of matching Unicode text in regular expressions](index_split_000.html#p69)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Double escaping in a Java String when defining regular expressions](index_split_000.html#p70)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Embedded regular expression mode modifiers](index_split_000.html#p71)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[The placement of embedded modes in a Java regular expression](index_split_000.html#p73)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Disabling mode modifiers](index_split_000.html#p74)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Summary](index_split_000.html#p75)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Working with Groups, Capturing, and References](index_split_000.html#p76)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Capturing groups](index_split_000.html#p77)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Group numbering](index_split_000.html#p78)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Named groups](index_split_000.html#p80)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Non-capturing groups](index_split_000.html#p81)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Advantages of non-capturing groups](index_split_000.html#p82)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Back references](index_split_000.html#p83)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Back reference of a named group](index_split_000.html#p85)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Replacement reference of a named group](index_split_000.html#p86)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Forward references](index_split_000.html#p87)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Invalid (non-existing) backward or forward references](index_split_000.html#p89)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Summary](index_split_000.html#p90)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Regular Expression Programming Using Java String and Scanner APIs](index_split_000.html#p91)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Introduction to the Java String API for regular expressions'' evaluation](index_split_000.html#p92)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Method - boolean matches(String regex)](index_split_000.html#p93)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Example of the matches method](index_split_000.html#p94)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Method - String replaceAll(String regex, String replacement)](index_split_000.html#p96)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Examples of the replaceAll method](index_split_000.html#p97)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Method - String replaceFirst(String regex, String replacement)](index_split_000.html#p99)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Examples of the replaceFirst method](index_split_000.html#p100)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Methods - String split methods](index_split_000.html#p101)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[The limit parameter rules](index_split_000.html#p102)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Examples of the split method](index_split_000.html#p103)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Example of the split method using the limit parameter](index_split_000.html#p104)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Using regular expressions in Java Scanner API](index_split_000.html#p106)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Summary](index_split_001.html#p110)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Introduction to Java Regular Expression APIs - Pattern and Matcher Classes](index_split_001.html#p111)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[The MatchResult interface](index_split_001.html#p112)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[The Pattern class](index_split_001.html#p114)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Examples using the Pattern class](index_split_001.html#p116)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Filtering a list of tokens using the asPredicate() method](index_split_001.html#p119)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[The Matcher class](index_split_001.html#p120)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Examples using the Matcher class](index_split_001.html#p123)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Method Boolean lookingAt()](index_split_001.html#p124)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[The matches() method](index_split_001.html#p125)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[The find() and find(int start) methods](index_split_001.html#p126)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[The appendReplacement(StringBuffer sb, String replacement) method](index_split_001.html#p128)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[The appendTail(StringBuffer sb) method](index_split_001.html#p129)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Example of the appendReplacement and appendTail methods](index_split_001.html#p130)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Summary](index_split_001.html#p132)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Exploring Zero-Width Assertions, Lookarounds, and Atomic Groups](index_split_001.html#p133)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Zero-width assertions](index_split_001.html#p134)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Predefined zero-width assertions](index_split_001.html#p135)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Regex defined zero-width assertions](index_split_001.html#p136)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[\G boundary assertion](index_split_001.html#p137)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Atomic groups](index_split_001.html#p139)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Lookahead assertions](index_split_001.html#p141)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Positive lookahead](index_split_001.html#p142)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Negative lookahead](index_split_001.html#p143)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Lookbehind assertions](index_split_001.html#p144)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Positive lookbehind](index_split_001.html#p145)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Negative lookbehind](index_split_001.html#p146)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Capturing text from overlapping matches](index_split_001.html#p151)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Be careful with capturing groups inside a lookahead or lookbehind atomic group](index_split_001.html#p153)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Lookbehind limitations in Java regular expressions](index_split_001.html#p154)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Summary](index_split_001.html#p155)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Understanding the Union, Intersection, and Subtraction of Character Classes](index_split_001.html#p156)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[The union of character classes](index_split_001.html#p157)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[The intersection of character classes](index_split_001.html#p159)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[The subtraction of character classes](index_split_001.html#p162)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Why should you use composite character classes?](index_split_001.html#p164)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Summary](index_split_001.html#p165)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Regular Expression Pitfalls, Optimization, and Performance Improvements](index_split_001.html#p166)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Common pitfalls and ways to avoid them while writing regular expressions](index_split_001.html#p167)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Do not forget to escape regex metacharacters outside a character class](index_split_001.html#p168)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Avoid escaping every non-word character](index_split_001.html#p169)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Avoid unnecessary capturing groups to reduce memory consumption](index_split_001.html#p170)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[However, don''t forget to use the required group around alternation](index_split_001.html#p171)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Use predefined character classes instead of longer versions](index_split_001.html#p172)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Use the limiting quantifier instead of repeating a character or pattern multiple
    times](index_split_001.html#p173)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Do not use an unescaped hyphen in the middle of a character class](index_split_001.html#p174)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[The mistake of calling matcher.goup() without a prior call to matcher.find(),
    matcher.matches(), or matcher.lookingAt()](index_split_001.html#p175)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Do not use regular expressions to parse XML / HTML data](index_split_001.html#p177)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[How to test and benchmark your regular expression performance](index_split_001.html#p178)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Catastrophic or exponential backtracking](index_split_001.html#p179)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[How to avoid catastrophic backtracking](index_split_001.html#p182)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Optimization and performance enhancement tips](index_split_001.html#p185)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Use a compiled form of regular expressions](index_split_001.html#p186)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Use a negated character class instead of the greedy and slow .* or .+](index_split_001.html#p187)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Avoid unnecessary grouping](index_split_001.html#p188)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Use lazy quantifiers strategically instead of greedy quantifiers that cause
    excessive backtracking](index_split_001.html#p189)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Make use of possessive quantifiers to avoid backtracking](index_split_001.html#p190)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Extract common repeating substrings out of alternation](index_split_001.html#p191)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Use atomic group to avoid backtracking and fail fast](index_split_001.html#p192)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Summary](index_split_001.html#p193)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
