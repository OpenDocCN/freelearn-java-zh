- en: from the specified string, ignoring delimiters.
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: from the specified string, ignoring delimiters.
- en: Scanner skip(Pattern
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: Scanner skip(Pattern
- en: This method is almost the same as the previous one
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法几乎与上一个相同
- en: pattern)
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: pattern)
- en: but gets Pattern as an argument instead of String.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 但将Pattern作为参数而不是String。
- en: String
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: String
- en: Attempts to find the next occurrence of a pattern
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试在指定字符串中找到下一个模式
- en: findWithinHorizon(String
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: findWithinHorizon(String
- en: constructed from the specified string, ignoring
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: constructed from the specified string, ignoring
- en: pattern, int horizon)
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: pattern, int horizon)
- en: delimiters.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 分隔符。
- en: String
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: String
- en: This method is almost the same as the previous one
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法几乎与上一个相同
- en: findWithinHorizon(Pattern
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: findWithinHorizon(Pattern
- en: but gets Pattern as an argument instead of String.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 但将Pattern作为参数而不是String。
- en: pattern, int horizon)
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: pattern, int horizon)
- en: In addition to the two hasNext() methods mentioned in the preceding table using
    regular expression, the Scanner class also provides several overloaded hasNext
    methods that return true if the next available token in the input can be retrieved
    for that
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 除了前面表格中提到的使用正则表达式的两个hasNext()方法之外，Scanner类还提供了几个重载的hasNext方法，如果输入中下一个可用的令牌可以检索为该类型，则返回true。
- en: 'particular type. For example: hasNextInt(), hasNextDouble(), hasNextBoolean(),
    hasNextByte(), hasNextFloat(), hasNextLong(), hasNextShort(), hasNextBigInteger(),
    hasNextBigDecimal(), hasNext().'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 特定类型。例如：hasNextInt()，hasNextDouble()，hasNextBoolean()，hasNextByte()，hasNextFloat()，hasNextLong()，hasNextShort()，hasNextBigInteger()，hasNextBigDecimal()，hasNext()。
- en: 'Similarly, there are several overloaded next methods that scan the input to
    return the next token for that particular type. For example: nextextInt(), nextextDouble(),
    nextextBoolean(), nextextByte(), nextextFloat(), nextextLong(), nextextShort(),
    nextextBigInteger(), nextextBigDecimal(), nextext().'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，还有几个重载的next方法，用于扫描输入并返回特定类型的下一个令牌。例如：nextextInt()，nextextDouble()，nextextBoolean()，nextextByte()，nextextFloat()，nextextLong()，nextextShort()，nextextBigInteger()，nextextBigDecimal()，nextext()。
- en: For the complete reference of the Scanner class refer to
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 关于Scanner类的完整参考，请参阅
- en: https://docs.oracle.com/javase/8/docs/api/java/util/Scanner.html.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: https://docs.oracle.com/javase/8/docs/api/java/util/Scanner.html.
- en: 'Suppose there is an input text delimited by two exclamation marks. The data
    is structured in the following sequence:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 假设有一个由两个感叹号分隔的输入文本。数据按照以下顺序结构化：
- en: animal!!id!!weight
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: animal!!id!!weight
- en: The animal name is a string, id is an integer number, and weight is a double
    number.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 动物名称是一个字符串，id是一个整数，而重量是一个双精度浮点数。
- en: 'With this structure, here is an example input:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种结构，以下是一个示例输入：
- en: Tiger!!123!!221.2!!Fox!!581!!52.50
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: Tiger!!123!!221.2!!Fox!!581!!52.50
- en: 'Given that there are two animals, here is how we can use the Scanner class
    to parse this input data in Java:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 由于有两种动物，以下是如何在Java中使用Scanner类解析这些输入数据的示例：
- en: final String input = "Tiger!!123!!221.2!!Fox!!581!!52.50"; final int MAX_COUNT
    = 2;
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: final String input = "Tiger!!123!!221.2!!Fox!!581!!52.50"; final int MAX_COUNT
    = 2;
- en: String animal;
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: String animal;
- en: int id;
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: int id;
- en: double weight;
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: double weight;
- en: Scanner scanner = new Scanner(input).useDelimiter("!!"); for (int i=0; i<MAX_COUNT;
    i++)
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: Scanner scanner = new Scanner(input).useDelimiter("!!"); for (int i=0; i<MAX_COUNT;
    i++)
- en: '{'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: animal = scanner.next();
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: animal = scanner.next();
- en: id = scanner.nextInt();
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: id = scanner.nextInt();
- en: weight = scanner.nextDouble();
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: weight = scanner.nextDouble();
- en: System.out.printf("animal=[%s], id=[%d], weight=[%.2f]%n", animal, id, weight);
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.printf("animal=[%s], id=[%d], weight=[%.2f]%n", animal, id, weight);
- en: '}'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: scanner.close();
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: scanner.close();
- en: 'This is what is happening in this code:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是这段代码所发生的事情：
- en: new Scanner(input) is the code to construct a scanner using the input string
    scanner.useDelimiter("!!") sets the delimiter regular expression as "!!"
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: new Scanner(input) 是使用输入字符串构建scanner的代码 scanner.useDelimiter("!!") 将分隔符正则表达式设置为"!!"
- en: scanner.next() gets the next string token from the constructed scanner scanner.nextInt()
    gets the next int token from the scanner scanner.nextDouble() gets the next double
    token from the scanner scanner.close() closes the scanner object; we cannot generate
    further tokens from the scanner after this method call
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: scanner.next() 从构建的scanner中获取下一个字符串令牌 scanner.nextInt() 从scanner中获取下一个int令牌
    scanner.nextDouble() 从scanner中获取下一个double令牌 scanner.close() 关闭scanner对象；在调用此方法后，我们不能从scanner生成更多的令牌
- en: 'As you can guess, we will get the following output from the preceding code:
    animal=[Tiger], id=[123], weight=[221.20]'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所猜，我们将从前面的代码中得到以下输出：animal=[Tiger], id=[123], weight=[221.20]
- en: animal=[Fox], id=[581], weight=[52.50]
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: animal=[Fox], id=[581], weight=[52.50]
- en: Let's parse a more complex input data to understand the use of the Scanner class
    better.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们解析更复杂的输入数据，以更好地理解Scanner类的使用。
- en: 'Here is the complete code listing:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是完整的代码列表：
- en: package example.regex;
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: package example.regex;
- en: import java.util.*;
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: import java.util.*;
- en: public class ScannerApi
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: public class ScannerApi
- en: '{'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: public static void main (String[] args)
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: public static void main (String[] args)
- en: '{'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: final String str = "London:Rome#Paris:1234:Munich///Moscow"; Scanner scanner
    = new Scanner(str);
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: final String str = "London:Rome#Paris:1234:Munich///Moscow"; Scanner scanner
    = new Scanner(str);
- en: scanner.useDelimiter("\\p{Punct}+");
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: scanner.useDelimiter("\\p{Punct}+");
- en: final String cityPattern = "\\p{L}+";
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: final String cityPattern = "\\p{L}+";
- en: while(scanner.hasNext()) {
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: while(scanner.hasNext()) {
- en: if(scanner.hasNext(cityPattern)) {
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: if(scanner.hasNext(cityPattern)) {
- en: System.out.println(scanner.next());
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println(scanner.next());
- en: '}'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: else {
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: else {
- en: scanner.next();
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: scanner.next();
- en: '}'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: scanner.close();
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: scanner.close();
- en: '}'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: 'This is what is happening in this code:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码中正在发生的事情如下：
- en: new Scanner(str) is the code to construct a scanner using the input string
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: new Scanner(str)是使用输入字符串构建扫描器的代码
- en: '* scanner.useDelimiter("\\p{Punct}+") sets the delimiter regular expression
    as one or more punctuation characters'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '* scanner.useDelimiter("\\p{Punct}+")将分隔符正则表达式设置为一个或多个标点符号'
- en: We are using "\\p{L}+" as the acceptable city name pattern, which means one
    or more Unicode letters
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在使用"\\p{L}+"作为可接受的城市名称模式，这意味着一个或多个Unicode字母
- en: scanner.hasNext(cityPattern) returns true if the next token from the scanner
    matches cityPattern
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: scanner.hasNext(cityPattern)如果扫描器的下一个标记与cityPattern匹配，则返回true
- en: scanner.next() retrieves the next string token from the scanner scanner.close()
    closes the scanner object; we cannot generate further tokens from the scanner
    after this method call
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: scanner.next()从扫描器中检索下一个字符串标记 scanner.close()关闭扫描器对象；在调用此方法后，我们不能从扫描器生成更多标记
- en: 'Upon compiling and running the preceding code, it will produce the following
    output: London'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 编译并运行前面的代码后，将生成以下输出：London
- en: Rome
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: Rome
- en: Paris
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: Paris
- en: Munich
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: Munich
- en: Moscow
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: Moscow
- en: '**Summary**'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '**总结**'
- en: In this chapter, you were introduced to Java programs using regular expressions
    using the String and Scanner classes. We discussed the methods available in these
    two APIs that are related to regular expression handling and how we can make use
    of those methods in our code.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您已经通过String和Scanner类了解了使用正则表达式的Java程序。我们讨论了这两个API中与正则表达式处理相关的可用方法，以及我们如何在代码中利用这些方法。
- en: In the next chapter, we will cover the Pattern and Matcher classes, which are
    the most important classes for programs using regular expressions.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将介绍Pattern和Matcher类，它们是使用正则表达式的程序中最重要的类。
- en: '**Introduction to Java Regular**'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '**Java正则表达式简介**'
- en: '**Expression APIs - Pattern**'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '**表达式API - 模式**'
- en: '**and Matcher Classes**'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '**和Matcher类**'
- en: In this chapter, we will introduce you to dedicated Java APIs for writing programs
    using regular expressions. Java provides a package, java.util.regex, which contains
    all the classes and interfaces for handling regular expressions. This package
    is in the java.base module, so we do not explicitly declare its use in the module-info.java
    source file. The java.base module is automatically required by all modules, and
    it contains the most important and basic JDK packages and classes. Regular expressions
    is such an important topic and tool that Java 9 experts decided to keep it inside
    the java.base module.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将向您介绍用于使用正则表达式编写程序的专用Java API。Java提供了一个包，java.util.regex，其中包含处理正则表达式所需的所有类和接口。此包位于java.base模块中，因此我们不需要在module-info.java源文件中显式声明其使用。java.base模块由所有模块自动要求，它包含最重要的和基本的JDK包和类。正则表达式是一个如此重要的话题和工具，Java
    9专家决定将其保留在java.base模块中。
- en: 'We will cover the following classes and interfaces from this package: The MatchResult
    interface'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将介绍此包中的以下类和接口：MatchResult接口
- en: Using Pattern class
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Pattern类
- en: Using Matcher class
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Matcher类
- en: Various methods of Pattern and Matcher classes and how to use them for solving
    problems involving regular expressions
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: Pattern和Matcher类的各种方法以及如何使用它们解决涉及正则表达式的问题
- en: '**The MatchResult interface**'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '**MatchResult接口**'
- en: 'MatchResult is an interface for representing the result of a match operation.
    This interface is implemented by the Matcher class. This interface contains query
    methods used to determine the results of a match against a regular expression.
    The match boundaries, groups, and group boundaries can only be retrieved but not
    modified through this interface. Here is a list of important methods provided
    in this interface: Method'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: MatchResult是一个用于表示匹配操作结果的接口。此接口由Matcher类实现。此接口包含用于确定正则表达式匹配结果的查询方法。匹配边界、组和组边界只能通过此接口检索，但不能修改。以下是此接口中提供的重要方法的列表：方法
- en: Description
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 描述
- en: Name
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 名称
- en: int start()
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: int start()
- en: Returns the start index of the match in the input
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 返回输入中匹配的起始索引
- en: int start(int
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: int start(int
- en: Returns the start index of the specified capturing group
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 返回指定捕获组的起始索引
- en: group)
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: group)
- en: int end()
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: int end()
- en: Returns the offset after the last character matched
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 返回最后一个匹配字符之后的偏移量
- en: int end(int
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: int end(int
- en: Returns the offset after the last character of the subsequence group)
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 返回子序列组最后一个字符之后的偏移量
- en: captured by the given group during this match
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: captured by the given group during this match
- en: String
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: String
- en: Returns the input substring matched by the previous match group()
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 返回上一个匹配组匹配的输入子串
- en: String
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: String
- en: Returns the input subsequence captured by the given group during group(int
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 返回给定组在此次匹配中捕获的输入子序列
- en: the previous match operation
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 上一个匹配操作
- en: group)
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: group)
- en: int
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: int
- en: Returns the number of capturing groups in this match result's groupCount()
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 返回此匹配结果中捕获组的数量
- en: pattern
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: pattern
- en: Let's take an example to understand this interface better.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一个例子来更好地理解这个接口。
- en: 'Suppose, the input string is a web server response line from HTTP response
    headers: HTTP/1.1 302 Found'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 假设，输入字符串是来自HTTP响应头的Web服务器响应行：HTTP/1.1 302 Found
- en: 'Our regex pattern to parse this line is as follows:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 我们解析此行的正则表达式模式如下：
- en: HTTP/1\.[01] (\d+) [a-zA-Z]+
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP/1\.[01] (\d+) [a-zA-Z]+
- en: Note that there is only one captured group that captures integer status code.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: Note that there is only one captured group that captures integer status code.
- en: 'Let''s look at this code listing to understand the various methods of the MatchResult
    interface better:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看这段代码列表，以更好地理解MatchResult接口的各种方法：
- en: package example.regex;
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 包含example.regex.*
- en: import java.util.regex.*;
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 导入java.util.regex.*
- en: public class MatchResultExample
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: public class MatchResultExample
- en: '{'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: public static void main(String[] args)
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: public static void main(String[] args)
- en: '{'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: final String re = "HTTP/1\\.[01] (\\d+) [a-zA-Z]+"; final String str = "HTTP/1.1
    302 Found";
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: final String re = "HTTP/1\\.[01] (\\d+) [a-zA-Z]+"; final String str = "HTTP/1.1
    302 Found";
- en: final Pattern p = Pattern.compile(re);
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: final Pattern p = Pattern.compile(re);
- en: Matcher m = p.matcher(str);
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: Matcher m = p.matcher(str);
- en: if (m.matches())
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: if (m.matches())
- en: '{'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: MatchResult mr = m.toMatchResult();
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: MatchResult mr = m.toMatchResult();
- en: // print count of capturing groups
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: // 打印捕获组的数量
- en: 'System.out.println("groupCount(): " + mr.groupCount());'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 'System.out.println("groupCount(): " + mr.groupCount());'
- en: // print complete matched text
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: // 打印完整的匹配文本
- en: 'System.out.println("group(): " + mr.group());'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 'System.out.println("group(): " + mr.group());'
- en: // print start position of matched text
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: // 打印匹配文本的起始位置
- en: 'System.out.println("start(): " + mr.start());'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 'System.out.println("start(): " + mr.start());'
- en: // print end position of matched text
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: // 打印匹配文本的结束位置
- en: 'System.out.println("end(): " + mr.end());'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 'System.out.println("end(): " + mr.end());'
- en: // print 1st captured group
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: // 打印第一个捕获组
- en: 'System.out.println("group(1): " + mr.group(1));'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 'System.out.println("group(1): " + mr.group(1));'
- en: // print 1st captured group's start position
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: // 打印第一个捕获组的起始位置
- en: 'System.out.println("start(1): " + mr.start(1));'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 'System.out.println("start(1): " + mr.start(1));'
- en: // print 1st captured group's end position
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: // 打印第一个捕获组的结束位置
- en: 'System.out.println("end(1): " + mr.end(1));'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 'System.out.println("end(1): " + mr.end(1));'
- en: '}'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: 'We retrieve a MatchResult instance after calling the required Pattern and Matcher
    methods (discussed in the next section). After compiling and running the preceding
    code, we will get the following output, which shows the use of the various methods
    of this interface:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在调用所需的Pattern和Matcher方法（下一节讨论）之后，我们将检索一个MatchResult实例。编译并运行前面的代码后，我们将得到以下输出，它显示了该接口各种方法的使用：
- en: 'groupCount(): 1'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 'groupCount(): 1'
- en: 'group(): HTTP/1.1 302 Found'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 'group(): HTTP/1.1 302 Found'
- en: 'start(): 0'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 'start(): 0'
- en: 'end(): 18'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 'end(): 18'
- en: 'group(1): 302'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 'group(1): 302'
- en: 'start(1): 9'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 'start(1): 9'
- en: 'end(1): 12'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 'end(1): 12'
- en: '**The Pattern class**'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '**Pattern类**'
- en: The Pattern class represents the compiled form of a string regular expression.
    So far, we have provided all the regular expressions as strings. Each String regular
    expression must be compiled into an instance of the Pattern class before the Java
    regex engine can execute it. An instance of the Pattern class is used to create
    a Matcher object to match input text against the regular expression.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: Pattern类表示字符串正则表达式的编译形式。到目前为止，我们已将所有正则表达式作为字符串提供。每个字符串正则表达式都必须在Java正则表达式引擎执行之前编译成一个Pattern类的实例。Pattern类的实例用于创建一个Matcher对象，以匹配输入文本与正则表达式。
- en: 'Let''s list down the important and useful methods from the Pattern class first:
    Method Signature'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先列出Pattern类中重要且有用的方法：方法签名
- en: Description
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: Description
- en: Static Pattern compile(String
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: Static Pattern compile(String
- en: Compiles the given String regular expression into a
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 将给定的字符串正则表达式编译成一个
- en: regex)
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: regex)
- en: Compiles the given String regular expression into a Pattern instance with the
    given flags. Flags can be one or more of
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 将给定的 String 正则表达式编译成具有给定标志的 Pattern 实例。标志可以是其中一个或多个
- en: Static Pattern compile(String
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 静态 Pattern compile(String
- en: CASE_SENSITIVE, UNICODE_CHARACTER_CLASS and a few others. Check the regex, int
    flags)
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: CASE_SENSITIVE, UNICODE_CHARACTER_CLASS 和其他几个。检查正则表达式，int flags)
- en: Java Pattern API at
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: Java Pattern API 在
- en: http://download.java.net/java/jdk9/docs/api/java/util/regex/Pattern.html for
    all flags and their descriptions.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: http://download.java.net/java/jdk9/docs/api/java/util/regex/Pattern.html 查看所有标志及其描述。
- en: Matcher matcher(CharSequence
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: Matcher matcher(CharSequence
- en: Creates a matcher instance to match the given input against this input)
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个匹配器实例以匹配给定输入与此输入)
- en: compiled pattern.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 编译后的模式。
- en: Returns a literal pattern string for the specified string. After quoting the
    String, regex meta characters or escape sequences in the input string will just
    be literals without any special meaning.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 返回指定字符串的文本模式。在引用字符串后，输入字符串中的正则表达式元字符或转义序列将只是字面量，没有任何特殊含义。
- en: String quote(String str)
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: String quote(String str)
- en: the given string in \\Q and \\E escape constructs. These special escape constructs
    are used to make a wrapped string as a literal string, thus removing all the special
    meanings of regex meta and special characters.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 给定字符串在 \\Q 和 \\E 转义构造中。这些特殊的转义构造用于将包装的字符串作为字面字符串，从而移除所有正则表达式元字符和特殊字符的特殊含义。
- en: asPredicate
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: asPredicate
- en: Predicate<String>
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: Predicate<String>
- en: ()
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: ()
- en: Creates a Predicate of a string to match the input string.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个字符串的谓词以匹配输入字符串。
- en: Predicate<String> asPredicate ()
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: Predicate<String> asPredicate ()
- en: Stream<String>
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: Stream<String>
- en: Splits the given input string using this pattern and creates a stream splitAsStream(CharSequence
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 使用此模式分割给定输入字符串并创建一个流 splitAsStream(CharSequence
- en: from the given input sequence around the matches of this pattern
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 从给定输入序列中根据此模式的匹配项
- en: input)
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: input)
- en: (added in Java 8).
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: （添加于 Java 8）。
- en: Splits the given input sequence around the matches of this pattern. It is String[]
    split(CharSequence input)
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在给定输入序列中根据此模式的匹配项进行分割。它是 String[] split(CharSequence input)
- en: the same as String.split(String regex).
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 与 String.split(String regex) 相同。
- en: Splits the given input sequence around the matches of this pattern. The String[]
    split(CharSequence input,
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 在给定输入序列中根据此模式的匹配项进行分割。String[] split(CharSequence input,
- en: limit parameter controls the number of times the pattern is applied and, int
    limit)
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 限制参数控制模式应用的次数，以及 int limit)
- en: therefore, affects the length of the resulting array. It is the same as String.split(String
    regex, int limit).
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，它影响结果数组的长度。它与 String.split(String regex, int limit) 相同。
- en: 'The Pattern class has a static method that can be called to match a string
    against a regular expression. This is as follows:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: Pattern 类有一个静态方法，可以用来匹配字符串与正则表达式。如下所示：
- en: boolean matches(String regex, CharSequence input)
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: boolean matches(String regex, CharSequence input)
- en: 'It can be used instead of the following:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 它可以用作以下内容的替代：
- en: final Pattern p = Pattern.compile(regex);
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: final Pattern p = Pattern.compile(regex);
- en: Matcher m = p.matcher(input);
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: Matcher m = p.matcher(input);
- en: m.matches();
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: m.matches();
- en: This is actually the JDK9 implementation of this method. Although it is simpler
    and shorter to call this method instead of three lines, it is recommended to use
    the methods compile(), matcher(), and matches() separately if we perform matching
    against the same regular expression many times. In such a case, we can invoke
    compile() only the first time and keep the compiled pattern and avoid recompilation
    each time the matching is performed.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 这实际上是 JDK9 中此方法的实现。虽然调用此方法比三行代码更简单、更短，但如果多次执行相同的正则表达式匹配，建议单独使用 compile()、matcher()
    和 matches() 方法。在这种情况下，我们只需在第一次调用 compile() 时执行，并保留编译后的模式，以避免每次执行匹配时都重新编译。
- en: '![Image 16](img/index-116_1.jpg)'
  id: totrans-194
  prefs: []
  type: TYPE_IMG
  zh: '![Image 16](img/index-116_1.jpg)'
- en: '**Examples using the Pattern**'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '**使用 Pattern 的示例**'
- en: '**class**'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '**类**'
- en: Let's look at a few examples to understand some of these methods.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看几个示例，以了解这些方法的一些用法。
- en: 'To compile a regular expression for decimal numbers, we can use the following
    code snippet:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 要编译用于十进制数字的正则表达式，我们可以使用以下代码片段：
- en: final String decimalPattern = "^[+-]?\\d*\\.?\\d+$"; Final Pattern pattern =
    Pattern.compile(decimalPattern);
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: final String decimalPattern = "^[+-]?\\d*\\.?\\d+$"; Final Pattern pattern =
    Pattern.compile(decimalPattern);
- en: The static method, Pattern.compile, compiles a string regex and returns a Pattern
    instance.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 静态方法 Pattern.compile 编译一个字符串正则表达式并返回一个 Pattern 实例。
- en: 'To match text between ## and ## that may include newlines as well, we can use
    the following compiled pattern:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '要匹配可能包含换行符的文本之间的文本，例如在 ## 和 ## 之间，我们可以使用以下编译后的模式：'
- en: final String re = "##.*?##";
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: final String re = "##.*?##";
- en: 'Final Pattern pattern = Pattern.compile(re, Pattern.DOTALL); Here, we are using
    two parameters: the Pattern.compile method and passing DOTALL as a flag in the
    second parameter, since we want to match the newline as well as using our lazy
    pattern .*?.'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 最终Pattern pattern = Pattern.compile(re, Pattern.DOTALL); 这里，我们使用两个参数：Pattern.compile方法，并在第二个参数中传递DOTALL作为标志，因为我们想匹配换行符以及使用我们的懒惰模式
    .*?。
- en: '*Note the use of lazy pattern .*? instead of greedy .* so that we match* *the
    shortest match between ## and ##.*'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: '*注意使用懒惰模式 .*? 而不是贪婪模式 .*，这样我们就能匹配* *##和##之间的最短匹配。*'
- en: 'We can also write the preceding code snippet using the inline mode modifier,
    (?s): final String re = "(?s)##.*?##";'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以使用内联模式修饰符(?s)来编写前面的代码片段，final String re = "(?s)##.*?##";
- en: Final Pattern pattern = Pattern.compile(re);
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: Final Pattern pattern = Pattern.compile(re);
- en: 'If we want to match a string that contains a subsequence, +-*/., surrounded
    by one or more white spaces on both the sides, then we can use the following code:
    package example.regex;'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要匹配一个包含子序列的字符串，+-*/.，两边各有一个或多个空白字符，则可以使用以下代码：package example.regex;
- en: import java.util.*;
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: import java.util.*;
- en: import java.util.regex.*;
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: import java.util.regex.*;
- en: class PatternQuoteExample
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: class PatternQuoteExample
- en: '{'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: public static void main (String[] args)
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: public static void main (String[] args)
- en: '{'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: 'String input = "Math operators: +-*/. ";'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 'String input = "Math operators: +-*/. ";'
- en: boolean result;
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: boolean result;
- en: String quoted = Pattern.quote("+-*/.");
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: String quoted = Pattern.quote("+-*/.");
- en: System.out.println(quoted);
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println(quoted);
- en: // regex using standard escaping
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: // 使用标准转义的正则表达式
- en: result = input.matches(".*\\s+\\+-\\*/\\.\\s+.*"); System.out.println(result);
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: result = input.matches(".*\\s+\\+-\\*/\\.\\s+.*"); System.out.println(result);
- en: // regex Using Pattern.quote around our search string
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: // 使用Pattern.quote围绕我们的搜索字符串的正则表达式
- en: result = input.matches(".*\\s+" + quoted + "\\s+.*");
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: result = input.matches(".*\\s+" + quoted + "\\s+.*");
- en: System.out.println(result);
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println(result);
- en: // regex Using \Q and \E around our search string
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: // 使用\Q和\E围绕我们的搜索字符串的正则表达式
- en: result = input.matches(".*\\s+\\Q+-*/.\\E\\s+.*"); System.out.println(result);
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: result = input.matches(".*\\s+\\Q+-*/.\\E\\s+.*"); System.out.println(result);
- en: '}'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: 'After compiling and running this code, will quoted string as: "\Q+-*/.\E" and
    then print true for all the three cases as the call to matches succeeds all the
    times. However, an important difference is the use of Pattern.quote in the second
    case, which handles the quoting of special regex characters in the search string,
    such as +, *, .'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 在编译并运行此代码后，将引号字符串作为："\Q+-*/.\E"打印出来，并且对于所有三个情况都打印true，因为调用matches在所有时候都成功。然而，一个重要的区别是第二个情况中使用了Pattern.quote，它处理了搜索字符串中特殊正则表达式字符的引号，例如+，*，.
- en: Then, in the third case, we just wrap our search string using \\Q and \\E, which
    is the same as calling Pattern.quote with our search string.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在第三种情况下，我们只需使用\\Q和\\E来包装我们的搜索字符串，这与调用Pattern.quote并传递我们的搜索字符串相同。
- en: 'To split an input text on two pipes or ||, we can use following code: package
    example.regex;'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 要在两个管道符或||之间分割输入文本，我们可以使用以下代码：package example.regex;
- en: import java.util.*;
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: import java.util.*;
- en: import java.util.regex.*;
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: import java.util.regex.*;
- en: class PatternSplitExample
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: class PatternSplitExample
- en: '{'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: public static void main (String[] args)
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: public static void main (String[] args)
- en: '{'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: final String input = "value1||value2||value3";
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: final String input = "value1||value2||value3";
- en: final Pattern p = Pattern.compile(Pattern.quote("||"));
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: final Pattern p = Pattern.compile(Pattern.quote("||"));
- en: // call split and print each element from generated array
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: // 调用split并打印生成的数组中的每个元素
- en: // using stream API
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: // 使用流API
- en: Arrays.stream(p.split(input))
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: Arrays.stream(p.split(input))
- en: .forEach(System.out::println);
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: .forEach(System.out::println);
- en: '}'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: 'Consider the following few points about this code:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 关于此代码的以下几点需要注意：
- en: We call Pattern.quote to avoid escaping double pipe string We call Pattern.compile
    to compile our string regex and get back a compiled Pattern object
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 我们调用Pattern.quote来避免转义双管道字符串 我们调用Pattern.compile来编译我们的字符串正则表达式并返回一个编译后的Pattern对象
- en: We use a generated pattern instance to call the split method by supplying an
    input string that we want to operate on
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用生成的模式实例通过提供一个我们想要操作的输入字符串来调用split方法
- en: 'Java 8 added a new method, splitAsStream, which returns a stream containing
    the substring from the given input sequence around the matches of this pattern.
    Using splitAsStream, we can simplify the preceding class as follows: package example.regex;'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: Java 8 添加了一个新方法，splitAsStream，它返回一个包含给定输入序列中匹配此模式的子字符串的流。使用splitAsStream，我们可以将前面的类简化如下：package
    example.regex;
- en: import java.util.*;
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: import java.util.*;
- en: import java.util.regex.*;
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: import java.util.regex.*;
- en: class PatternSplitStreamExample
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: class PatternSplitStreamExample
- en: '{'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: public static void main (String[] args) throws java.lang.Exception
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: public static void main (String[] args) throws java.lang.Exception
- en: '{'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: final String input = "value1||value2||value3";
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: final String input = "value1||value2||value3";
- en: final Pattern p = Pattern.compile(Pattern.quote("||"));
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: final Pattern p = Pattern.compile(Pattern.quote("||"));
- en: // call splitAsStream and print each element from generated stream p.splitAsStream(input)
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: // 调用splitAsStream并从生成的流中打印每个元素 p.splitAsStream(input)
- en: .forEach(System.out::println);
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: .forEach(System.out::println);
- en: '}'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: Note the use of the splitAsStream method instead of the Arrays.stream() static
    method
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 注意使用splitAsStream方法而不是Arrays.stream()静态方法
- en: in this class. Creating an array performs the whole split. When Pattern returns
    a stream, it can do the splitting only when it is needed. If we, for example,
    limit the stream to work up only the first 10 elements, then the splitting does
    not need to do the splitting for further elements.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个类中。创建一个数组执行整个分割。当Pattern返回一个流时，它只有在需要时才会进行分割。如果我们，例如，限制流只处理前10个元素，那么就不需要对后续元素进行分割。
- en: It is true even if some of the implementations just do the splitting and return
    an array based stream from splitAsStream(). A different implementation of the
    JDK is free to use a better solution only if we use splitAsStream() but has no
    choice if we use split() and convert to stream afterward.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 即使某些实现只是进行分割并从splitAsStream()返回一个基于流的数组，这也是正确的。JDK的不同实现如果我们在使用splitAsStream()时使用更好的解决方案是自由的，但如果我们在使用split()之后将其转换为流，就没有选择。
- en: '**Filtering a list of tokens**'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: '**过滤令牌列表**'
- en: '**using the asPredicate()**'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: '**使用asPredicate()**'
- en: '**method**'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: '**方法**'
- en: 'As noted in the preceding table, the asPredicate() method creates a predicate
    that can be used to match an input string. Let''s look at an example code listing
    to understand this method better:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 如前表所示，asPredicate()方法创建了一个可以用于匹配输入字符串的谓词。让我们通过一个示例代码列表来更好地理解这个方法：
- en: package example.regex;
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: package example.regex;
- en: import java.util.List;
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: import java.util.List;
- en: import java.util.stream.*;
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: import java.util.stream.*;
- en: import java.util.regex.*;
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: import java.util.regex.*;
- en: public class AsPredicateExample
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: public class AsPredicateExample
- en: '{'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: public static void main(String[] args)
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: public static void main(String[] args)
- en: '{'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: final String[] monthsArr =
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: final String[] monthsArr =
- en: '{"10", "0", "05", "09", "12", "15", "00", "-1", "100"}; final Pattern validMonthPattern
    ='
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: '{"10", "0", "05", "09", "12", "15", "00", "-1", "100"}; final Pattern validMonthPattern
    ='
- en: Pattern.compile("^(?:0?[1-9]|1[00-2])$");
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: Pattern.compile("^(?:0?[1-9]|1[00-2])$");
- en: List<String> filteredMonths = Stream.of(monthsArr)
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: List<String> filteredMonths = Stream.of(monthsArr)
- en: .filter(validMonthPattern.asPredicate())
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: .filter(validMonthPattern.asPredicate())
- en: .collect(Collectors.toList());
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: .collect(Collectors.toList());
- en: System.out.println(filteredMonths);
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println(filteredMonths);
- en: '}'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: This code has a list of month numbers as an array of String. The valid months
    are between 1 and 12 with an optional 0 before the single-digit months.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码有一个月份数字列表，作为String数组。有效的月份在1到12之间，单位数月份前可以有可选的0。
- en: 'We use the following regex pattern for a valid month number:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用以下正则表达式模式来验证月份数字：
- en: ^(?:0?[1-9]|1[00-2])$
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: ^(?:0?[1-9]|1[00-2])$
- en: We use the return value of the asPredicate() method to filter the stream of
    string array containing all the input month values.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用asPredicate()方法的返回值来过滤包含所有输入月份值的字符串数组流。
- en: 'After compiling and running, the preceding code will print the following output,
    which is a filtered list from the original list containing all the valid month
    numbers:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 编译并运行后，前面的代码将打印以下输出，这是一个从原始列表中过滤出的包含所有有效月份数字的列表：
- en: '[10, 05, 09, 12]'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: '[10, 05, 09, 12]'
- en: '**The Matcher class**'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: '**Matcher类**'
- en: 'An instance of the Matcher class performs various match operations on a character
    sequence by interpreting a compiled regular expression represented by an instance
    of Pattern. This is how we use this class to match a regex:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: Matcher类的实例通过解释由Pattern实例表示的编译后的正则表达式，在字符序列上执行各种匹配操作。这就是我们如何使用这个类来匹配正则表达式的方式：
- en: We create a matcher instance from a pattern by invoking the pattern's matcher
    method that requires the input sequence as argument
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过调用需要输入序列作为参数的模式匹配器方法来从模式创建匹配器实例
- en: 'The instance of matcher is used to perform three types of match operations
    using these three methods, each returning a Boolean value (true indicates success):
    matches'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 匹配器实例用于使用这三种方法执行三种类型的匹配操作，每种方法都返回一个布尔值（true表示成功）：matches
- en: find
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: find
- en: lookingAt
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: lookingAt
- en: 'These methods perform the matching in the following manner: The matches method
    attempts to match the *complete input sequence* using the matcher''s pattern'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 这些方法以以下方式执行匹配：matches方法尝试使用匹配器的模式匹配整个输入序列
- en: The find method *searches* the input sequence for the next substring that matches
    the pattern
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
- en: The lookingAt method attempts to match the input sequence using the matcher's
    pattern *at the start position*.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s list down all the important methods from the Matcher class here: Method
    Signature'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
- en: Description
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
- en: Using the matcher's pattern attempts to find
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
- en: boolean find()
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
- en: the next matching substring of the input text.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
- en: This is the same as the previous, except that
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
- en: boolean find(int start)
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
- en: the search starts at the start position.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
- en: boolean matches()
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
- en: Attempts to match the complete input text..
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
- en: Attempts to match the input text, starting at
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
- en: boolean lookingAt()
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
- en: the beginning of the region. It does not need to
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
- en: match the complete input text.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
- en: Returns the complete input text matched by
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
- en: String group()
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
- en: the previous match.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
- en: String group(int group)
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
- en: Returns the input text captured by the
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
- en: specified group number during the previous
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
- en: match operation.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
- en: Returns the input text captured by the given
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
- en: String group(String groupName)
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
- en: named group during the previous match
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
- en: operation.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
- en: Returns the number of capturing groups in this
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
- en: int groupCount()
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
- en: matcher's pattern.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
- en: Returns the start index of the previous match
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
- en: int start()
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
- en: operation.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
- en: Returns the start position of the text captured
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
- en: int start(int group)
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
- en: by the given group number during the
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
- en: previous match operation.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
- en: Returns the start position of the text captured
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
- en: int start(int groupName)
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
- en: by the given named group during the previous
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
- en: match operation.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
- en: Returns the end position of the previous match
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
- en: int end()
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
- en: operation.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
- en: Returns the end position of the text captured
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
- en: int end(int group)
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
- en: by the given group number during the
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
- en: previous match operation.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
- en: Returns the end position of the text captured
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
- en: int end(int groupName)
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
- en: by the given named group during the previous
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
- en: match operation.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
- en: Matcher
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
- en: Appends the given replacement text to the
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
- en: appendReplacement(StringBuffer
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
- en: string buffer after the last character of the
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
- en: buffer, String replacement)
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
- en: previous match in the string buffer.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
- en: This method reads characters from the input
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
- en: text, starting at the append position, and
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
- en: appends them to the given string buffer. It is
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
- en: StringBuffer
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
- en: intended to be invoked after one or more
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
- en: appendTail(StringBuffer buffer)
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
- en: invocations of the appendReplacement method in
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
- en: order to copy the remainder of the input text to the buffer.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
- en: Returns a literal replacement String for the
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
- en: Static String
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
- en: specified String. It makes backslashes and
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
- en: quoteReplacement(String s)
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
- en: dollar signs to be treated literally.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
- en: Using the current matcher's pattern, it replaces
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
- en: String replaceAll(String
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
- en: all the matched substrings of the input text
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
- en: replacement)
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
- en: with the given replacement string.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
- en: Using the current matcher's pattern, it replaces
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
- en: String replaceFirst(String
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
- en: the first matched substring of the input text
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
- en: replacement)
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
- en: with the given replacement string.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
- en: Resets this matcher object and initializes all
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
- en: Matcher reset()
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
- en: the internal states.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
- en: Matcher reset(CharSequence
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
- en: Resets this matcher object with a new input
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
- en: input)
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
- en: text and initializes all the internal states.
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 文本并初始化所有内部状态。
- en: Returns the match result of the matcher that
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 返回匹配器的匹配结果
- en: represents state of the match. This method is
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 表示匹配的状态。此方法通常
- en: MatchResult toMatchResult()
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: MatchResult toMatchResult()
- en: usually called after one of the
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 通常在调用
- en: find/matches/lookingAt method calls.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: find/matches/lookingAt方法调用。
- en: Matcher usePattern(Pattern
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: Matcher usePattern(Pattern
- en: Updates the pattern used by this matcher to
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 更新此匹配器使用的模式
- en: newPattern)
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: newPattern)
- en: find new matches.
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 查找新的匹配项。
- en: '**Examples using the Matcher**'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: '**使用Matcher的示例**'
- en: '**class**'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: '**类**'
- en: The Matcher class represents the main regular expression engine in Java that
    provides all the functionality and features required to match regular expressions
    against input.
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: Matcher类代表Java中主要的正则表达式引擎，它提供了匹配正则表达式对输入所需的所有功能和特性。
- en: Let's look at some important methods of this class with practical examples to
    understand their use.
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过实际示例来查看这个类的一些重要方法，以了解它们的使用。
- en: '**Method Boolean lookingAt()**'
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: '**lookingAt()方法**'
- en: 'The lookingAt()method attempts to match the input against the pattern, starting
    from the *beginning* of the input but without requiring that the entire region
    be matched against the pattern. The following code demonstrates it:'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: lookingAt()方法尝试从输入的*开始*位置匹配输入，但不需要整个区域与模式匹配。以下代码演示了这一点：
- en: package example.regex;
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: package example.regex;
- en: import java.util.regex.*;
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: import java.util.regex.*;
- en: class MatcherLookingatExample
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: class MatcherLookingatExample
- en: '{'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: public static void main (String[] args)
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: public static void main (String[] args)
- en: '{'
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: final Pattern pattern1 = Pattern.compile("master[a-z]*"); final Pattern pattern2
    = Pattern.compile("master"); final Pattern pattern3 = Pattern.compile("regular");
    String input = "mastering regular expressions"; Matcher matcher = pattern1.matcher(input);
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: final Pattern pattern1 = Pattern.compile("master[a-z]*"); final Pattern pattern2
    = Pattern.compile("master"); final Pattern pattern3 = Pattern.compile("regular");
    String input = "mastering regular expressions"; Matcher matcher = pattern1.matcher(input);
- en: 'System.out.printf("[%s] => [%s]: %s%n", input, matcher.pattern(), matcher.lookingAt());'
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 'System.out.printf("[%s] => [%s]: %s%n", input, matcher.pattern(), matcher.lookingAt());'
- en: // update the matcher's pattern with a new pattern
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: // 更新匹配器的模式为新模式
- en: matcher.usePattern(pattern2);
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: matcher.usePattern(pattern2);
- en: 'System.out.printf("[%s] => [%s]: %s%n", input, matcher.pattern(), matcher.lookingAt());'
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 'System.out.printf("[%s] => [%s]: %s%n", input, matcher.pattern(), matcher.lookingAt());'
- en: // update the matcher's pattern with a new pattern
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: // 更新匹配器的模式为新模式
- en: matcher.usePattern(pattern3);
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: matcher.usePattern(pattern3);
- en: 'System.out.printf("[%s] => [%s]: %s%n", input, matcher.pattern(), matcher.lookingAt());'
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 'System.out.printf("[%s] => [%s]: %s%n", input, matcher.pattern(), matcher.lookingAt());'
- en: '}'
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: 'Upon compiling and running, the preceding code produces following output:'
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 编译并运行上述代码后，将产生以下输出：
- en: '[mastering regular expressions] => [master[a-z]*]: true'
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: '[掌握正则表达式] => [master[a-z]*]: true'
- en: '[mastering regular expressions] => [master]: true'
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: '[掌握正则表达式] => [master]: true'
- en: '[mastering regular expressions] => [regular]: false'
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: '[掌握正则表达式] => [regular]: false'
- en: You can see that the lookingAt()method returns true only when we supply patterns
    that are at the starting of the input, such as master[a-z]* and master, but returns
    false when we supply a pattern that is in the middle, such as regular.
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以看到，当我们提供位于输入开头的模式时，lookingAt()方法返回true，例如master[a-z]*和master，但当我们提供位于中间的模式时，例如regular，它返回false。
- en: '**The matches() method**'
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: '**matches()方法**'
- en: The matches() method attempts to match the entire region against the pattern
    and returns true only if the entire region matches against the pattern.
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: matches()方法尝试将整个区域与模式进行匹配，并且只有当整个区域与模式匹配时才返回true。
- en: 'Let''s look at the following code to understand the use of this method better:
    package example.regex;'
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看以下代码，以更好地理解这个方法的使用：package example.regex;
- en: import java.util.regex.*;
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 导入java.util.regex.*;
- en: class MatcherMatchesExample
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: class MatcherMatchesExample
- en: '{'
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: public static void main (String[] args)
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: public static void main (String[] args)
- en: '{'
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: final Pattern pattern1 = Pattern.compile("mastering"); final Pattern pattern2
    = Pattern.compile("mastering.*"); final Pattern pattern3 = Pattern.compile("regular.*");
    String input = "mastering regular expressions"; Matcher matcher = pattern1.matcher(input);
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: final Pattern pattern1 = Pattern.compile("mastering"); final Pattern pattern2
    = Pattern.compile("mastering.*"); final Pattern pattern3 = Pattern.compile("regular.*");
    String input = "mastering regular expressions"; Matcher matcher = pattern1.matcher(input);
- en: 'System.out.printf("[%s] => [%s]: %s%n", input, matcher.pattern(), matcher.matches());'
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 'System.out.printf("[%s] => [%s]: %s%n", input, matcher.pattern(), matcher.matches());'
- en: // update the matcher ppattern with a new pattern
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: // 更新匹配器的ppattern为新模式
- en: matcher.usePattern(pattern2);
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: matcher.usePattern(pattern2);
- en: 'System.out.printf("[%s] => [%s]: %s%n", input, matcher.pattern(), matcher.matches());'
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 'System.out.printf("[%s] => [%s]: %s%n", input, matcher.pattern(), matcher.matches());'
- en: // update the matcher ppattern with a new pattern
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: // 更新匹配器的模式为新模式
- en: matcher.usePattern(pattern3);
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: matcher.usePattern(pattern3);
- en: 'System.out.printf("[%s] => [%s]: %s%n", input, matcher.pattern(), matcher.matches());'
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 'System.out.printf("[%s] => [%s]: %s%n", input, matcher.pattern(), matcher.matches());'
- en: '}'
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: 'This will give following output after running:'
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: 运行后，这将给出以下输出：
- en: '[mastering regula expressions] => [mastering]: false'
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: '[掌握正则表达式] => [mastering]: false'
- en: '[mastering regula expressions] => [mastering.*]: true'
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: '[掌握正则表达式] => [mastering.*]: true'
- en: '[mastering regula expressions] => [regular.*]: false'
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: '[掌握正则表达式] => [regular.*]: false'
- en: 'As you can see, we get true only when our pattern matches the entire region
    from the start to end, which is using this regex: mastering.*'
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们只有在我们的模式与从开始到结束的整个区域匹配时才返回 true，这是使用此正则表达式：mastering.*
- en: '**The find() and find(int start)**'
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: '**find() 和 find(int start)** '
- en: '**methods**'
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: '**methods**'
- en: These find methods attempt to find the next subsequence of the input sequence
    that matches the pattern. These methods return true only if a subsequence of the
    input matches this matcher's pattern. If multiple matches can be found in the
    text, then the find() method will find the first, and then for each subsequent
    call to find(), it will move to the next match.
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: 这些查找方法试图找到输入序列中与模式匹配的下一个子序列。这些方法仅在输入序列的子序列与该匹配器的模式匹配时返回 true。如果文本中可以找到多个匹配项，则
    find() 方法将找到第一个，然后对于 find() 的每次后续调用，它将移动到下一个匹配项。
- en: 'An example code will make it clearer:'
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例代码将使其更清晰：
- en: package example.regex;
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: package example.regex;
- en: import java.util.regex.*;
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: import java.util.regex.*;
- en: class MatcherFindExample
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: class MatcherFindExample
- en: '{'
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: public static void main (String[] args)
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: public static void main (String[] args)
- en: '{'
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: final String input = "some text <value1> anything <value2><value3> here";
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: final String input = "some text <value1> anything <value2><value3> here";
- en: /* Part 1 */
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: /* 第 1 部分 */
- en: final Pattern pattern = Pattern.compile("<([^<>]*)>"); Matcher matcher = pattern.matcher(input);
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: final Pattern pattern = Pattern.compile("<([^<>]*)>"); Matcher matcher = pattern.matcher(input);
- en: while (matcher.find()) {
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: while (matcher.find()) {
- en: System.out.printf("[%d] => [%s]%n",
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.printf("[%d] => [%s]%n",
- en: matcher.groupCount(), matcher.group(1));
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: matcher.groupCount(), matcher.group(1));
- en: '}'
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: /* Part 2 */
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: /* 第 2 部分 */
- en: // now use similar pattern but use a named group and reset the
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: // 现在使用类似的模式，但使用命名组和重置
- en: // matcher
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: // 匹配器
- en: matcher.usePattern(Pattern.compile("<(?<name>[^<>]*)>")); matcher.reset();
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: matcher.usePattern(Pattern.compile("<(?<name>[^<>]*)>")); matcher.reset();
- en: while (matcher.find()) {
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: while (matcher.find()) {
- en: System.out.printf("[%d] => [%s]%n",
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.printf("[%d] => [%s]%n",
- en: matcher.groupCount(), matcher.group("name"));
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: matcher.groupCount(), matcher.group("name"));
- en: '}'
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: 'This will output the following:'
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: 这将输出以下内容：
- en: '[1] => [value1]'
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: '[1] => [value1]'
- en: '[1] => [value2]'
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: '[1] => [value2]'
- en: '[1] => [value3]'
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: '[1] => [value3]'
- en: '[1] => [value1]'
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: '[1] => [value1]'
- en: '[1] => [value2]'
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: '[1] => [value2]'
- en: '[1] => [value3]'
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
  zh: '[1] => [value3]'
- en: As you can see in the preceding code, we are extracting all the text that is
    inside the angular brackets using a negated character class, [^<>]*, inside a
    capturing group.
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: 如前述代码所示，我们使用否定字符类 [^<>]* 在捕获组内提取所有位于尖括号内的文本。
- en: In Part 1 of the code, we use regular captured group and matcher.group(1) to
    extract and print the subsequence captured in group number 1\. The numbering of
    the groups starts each time we execute find() and the previous captures are wiped
    off. Even though it is in a loop, it is always group(1) in the example because
    for each iteration, there can be more than one group.
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码的第 1 部分，我们使用正则捕获组和 matcher.group(1) 来提取并打印第 1 组捕获的子序列。组的编号每次执行 find() 时都会开始，之前的捕获将被清除。即使它在循环中，示例中始终是
    group(1)，因为在每次迭代中可能有多个组。
- en: In Part 2, we use a named capturing group and an overloaded method call to matcher.group("name")
    to extract the subsequence captured by the given group name.
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
  zh: 在第 2 部分，我们使用命名捕获组和重载的方法调用 matcher.group("name") 来提取给定组名捕获的子序列。
- en: '![Image 17](img/index-128_1.jpg)'
  id: totrans-481
  prefs: []
  type: TYPE_IMG
  zh: '![图像 17](img/index-128_1.jpg)'
- en: '**The**'
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: '**The**'
- en: '**appendReplacement(StringBuffer**'
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: '**appendReplacement(StringBuffer**'
- en: '**sb, String replacement)**'
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: '**sb, String replacement)**'
- en: '**method**'
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
  zh: '**method**'
- en: This method is intended to be used in a loop together with the appendTail and
    find methods. Once we get a match using the find() method, we can call the appendReplacement()
    method to operate on each match and replace the matched text.
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法旨在与 appendTail 和 find 方法一起在循环中使用。一旦我们使用 find() 方法找到一个匹配项，我们就可以调用 appendReplacement()
    方法来对每个匹配项进行操作并替换匹配的文本。
- en: Finally, it appends the replaced text to StringBuffer. It reads characters from
    the input sequence, starting at the append position, and appends them to the given
    string buffer.
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，它将替换后的文本追加到StringBuffer。它从输入序列的追加位置开始读取字符，并将它们追加到给定的字符串缓冲区。
- en: It stops after reading the last character preceding the previous match, that
    is, the character at index start() - 1\.
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: It stops after reading the last character preceding the previous match, that
    is, the character at index start() - 1\.
- en: The replacement string may contain references to subsequences captured during
    the previous match. All the rules of replacement reference we String.replaceAll
    apply to this method also.
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
  zh: The replacement string may contain references to subsequences captured during
    the previous match. All the rules of replacement reference we String.replaceAll
    apply to this method also.
- en: The appendReplacement() method keeps track of what has been copied into StringBuffer,
    so we can keep searching for matches using find() in a loop, until no more matches
    are found in the input text. There will be an example following the next section.
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: The appendReplacement() method keeps track of what has been copied into StringBuffer,
    so we can keep searching for matches using find() in a loop, until no more matches
    are found in the input text. There will be an example following the next section.
- en: '*Java 9 has another overloaded signature of this method to start* *accepting
    StringBuilder instead of StringBuffer as the first parameter.*'
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
  zh: '*Java 9为这个方法提供了一个重载签名，开始* *接受StringBuilder而不是StringBuffer作为第一个参数。*'
- en: '![Image 18](img/index-129_1.jpg)'
  id: totrans-492
  prefs: []
  type: TYPE_IMG
  zh: '![Image 18](img/index-129_1.jpg)'
- en: '**The**'
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
  zh: '**The**'
- en: '**appendTail(StringBuffer sb)**'
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
  zh: '**appendTail(StringBuffer sb)**'
- en: '**method**'
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
  zh: '**方法**'
- en: This method reads characters from the input sequence, starting at the append
    position, and appends them to the given string buffer. It is intended to be invoked
    after one or more invocations of the appendReplacement method in order to copy
    the remainder of the input sequence.
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法从输入序列中读取字符，从追加位置开始，并将它们追加到给定的字符串缓冲区。它旨在在调用appendReplacement方法一次或多次之后调用，以便复制输入序列的其余部分。
- en: '*Just like in the case of the appendReplacement() method, there is also an*
    *overloaded version of the appendTail() method that accepts* *StringBuilder, which
    is not synchronized, instead of StringBuffer, which* *is synchronized.*'
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
  zh: '*就像在appendReplacement()方法的情况下一样，appendTail()方法也有一个重载版本，它接受* *StringBuilder，它不是同步的，而不是StringBuffer，它是同步的。*'
- en: '**Example of the**'
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
  zh: '**示例**'
- en: '**appendReplacement and**'
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
  zh: '**appendReplacement和**'
- en: '**appendTail methods**'
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
  zh: '**appendTail方法**'
- en: Let's look at a complete program to the understand use of these methods.
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个完整的程序来理解这些方法的使用。
- en: 'Consider the following input:'
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下输入：
- en: <n1=v1 n2=v2 n3=v3> n1=v1 n2=v2 abc=123 <v=pq id=abc> v=pq We need to write
    code to swap each name-value pair enclosed in angular brackets, < and >, while
    leaving the name-value pairs outside the angular brackets unchanged.
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
  zh: <n1=v1 n2=v2 n3=v3> n1=v1 n2=v2 abc=123 <v=pq id=abc> v=pq 我们需要编写代码来交换所有在尖括号<和>内包含的名称-值对，同时保持尖括号外的名称-值对不变。
- en: 'After running our code, it should produce the following output:'
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
  zh: 运行我们的代码后，应该产生以下输出：
- en: <v1=n1 v2=n2 v3=n3> n1=v1 n2=v2 abc=123 <pq=v abc=id> v=pq To solve this problem,
    we have to first find each match enclosed in angular brackets using the find method
    in a loop. Inside the loop, we will have to replace each name-value pair using
    the appendReplacement method. Finally, outside the loop, we will use the appendTail
    method to append the remaining characters after our last match.
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
  zh: <v1=n1 v2=n2 v3=n3> n1=v1 n2=v2 abc=123 <pq=v abc=id> v=pq 要解决这个问题，我们首先必须使用find方法在循环中找到每个在尖括号内封闭的匹配项。在循环内部，我们将使用appendReplacement方法替换每个名称-值对。最后，在循环外部，我们将使用appendTail方法追加最后匹配后的剩余字符。
- en: 'Here is the full code:'
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是完整的代码：
- en: package example.regex;
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
  zh: package example.regex;
- en: import java.util.regex.*;
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
  zh: import java.util.regex.*;
- en: class MatcherAppendExample
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
  zh: class MatcherAppendExample
- en: '{'
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: public static void main (String[] args)
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
  zh: public static void main (String[] args)
- en: '{'
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: final String input = "<n1=v1 n2=v2 n3=v3> n1=v1 n2=v2 abc=
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
  zh: final String input = "<n1=v1 n2=v2 n3=v3> n1=v1 n2=v2 abc=
- en: 123 <v=pq id=abc> v=pq";
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
  zh: 123 <v=pq id=abc> v=pq";
- en: // pattern1 to find all matches between < and >
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
  zh: // 模式1用于查找所有在<和>之间的匹配项
- en: final Pattern pattern = Pattern.compile("<[^>]+>");
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
  zh: final Pattern pattern = Pattern.compile("<[^>]+>");
- en: // pattern1 to find each name=value pair
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
  zh: // 模式1用于查找每个name=value对
- en: final Pattern pairPattern = Pattern.compile("(\\w+)=(\\w+)"); Matcher enclosedPairs
    = pattern.matcher(input);
  id: totrans-518
  prefs: []
  type: TYPE_NORMAL
  zh: final Pattern pairPattern = Pattern.compile("(\\w+)=(\\w+)"); Matcher enclosedPairs
    = pattern.matcher(input);
- en: StringBuilder sbuf = new StringBuilder();
  id: totrans-519
  prefs: []
  type: TYPE_NORMAL
  zh: StringBuilder sbuf = new StringBuilder();
- en: // call find in a loop and call appendReplacement for each match while (enclosedPairs.find())
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
  zh: // 在循环中调用find并针对每个匹配项调用appendReplacement
- en: '{'
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: Matcher pairMatcher = pairPattern.matcher(enclosedPairs.group());
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
  zh: Matcher pairMatcher = pairPattern.matcher(enclosedPairs.group());
- en: // replace name=value with value=name in each match
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
  zh: // 在每个匹配中将name=value替换为value=name
- en: enclosedPairs.appendReplacement(sbuf,
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
  zh: enclosedPairs.appendReplacement(sbuf,
- en: pairMatcher.replaceAll("$2=$1"));
  id: totrans-525
  prefs: []
  type: TYPE_NORMAL
  zh: pairMatcher.replaceAll("$2=$1"));
- en: '}'
  id: totrans-526
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: // appendTail to append remaining character to buffer
  id: totrans-527
  prefs: []
  type: TYPE_NORMAL
  zh: // appendTail将剩余字符追加到缓冲区
- en: enclosedPairs.appendTail(sbuf);
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
  zh: enclosedPairs.appendTail(sbuf);
- en: System.out.println(sbuf);
  id: totrans-529
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println(sbuf);
- en: '}'
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-531
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: 'Upon compiling and running, the preceding code will produce the following output:'
  id: totrans-532
  prefs: []
  type: TYPE_NORMAL
  zh: 编译和运行前面的代码将产生以下输出：
- en: <v1=n1 v2=n2 v3=n3> n1=v1 n2=v2 abc=123 <pq=v abc=id> v=pq As you can see, the
    final output has all the name=value pairs swapped inside the angular brackets.
  id: totrans-533
  prefs: []
  type: TYPE_NORMAL
  zh: <v1=n1 v2=n2 v3=n3> n1=v1 n2=v2 abc=123 <pq=v abc=id> v=pq 如你所见，最终输出在尖括号内所有名称=值对都已交换。
- en: '**Summary**'
  id: totrans-534
  prefs: []
  type: TYPE_NORMAL
  zh: '**总结**'
- en: In this chapter, you learned about the most important regular expression handling
    Java classes. The Matcher and Pattern classes are heavy and complex tools that
    can be used to get really far when it comes to string manipulation. We have seen
    an example of a compound task, transforming name-value pairs inside a string,
    enclosed between angular brackets. If you imagine how hard it would have been
    without regular expressions and these classes, then you realize the power you
    now have in your hand after this chapter; it is almost wizard-level.
  id: totrans-535
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了最重要的正则表达式处理Java类。Matcher和Pattern类是重量级且复杂的工具，可以用于在字符串操作中达到非常高的水平。我们已经看到了一个复合任务的例子，即在字符串内部、由尖括号包围的名称-值对转换。如果你想象一下没有正则表达式和这些类会多么困难，那么你就会意识到在阅读本章后你手中的力量；这几乎是巫师级别的。
- en: In the next chapter, we will move on to advanced topics of regular expressions,
    such as zero-width assertions, using the lookahead and lookbehind assertions,
    atomic groups, and so on.
  id: totrans-536
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将继续学习正则表达式的进阶主题，例如零宽断言、使用前瞻和后顾断言、原子组等。
- en: '**Exploring Zero-Width**'
  id: totrans-537
  prefs: []
  type: TYPE_NORMAL
  zh: '**探索零宽**'
- en: '**Assertions, Lookarounds,**'
  id: totrans-538
  prefs: []
  type: TYPE_NORMAL
  zh: '**断言、环视**'
- en: '**and Atomic Groups**'
  id: totrans-539
  prefs: []
  type: TYPE_NORMAL
  zh: '**以及原子组**'
- en: You will learn about zero-width assertions in Java regular expressions. We will
    cover various zero-width assertions and their usage patterns. We will then move
    on to learn the important topic of lookahead and lookbehind assertions in Java
    regular expressions and how to use them to solve some important problems. We will
    also discuss the use of atomic groups in Java regular expressions.
  id: totrans-540
  prefs: []
  type: TYPE_NORMAL
  zh: 你将学习Java正则表达式中的零宽断言。我们将涵盖各种零宽断言及其使用模式。然后我们将继续学习Java正则表达式中的重要主题，如前瞻和后顾断言，以及如何使用它们来解决一些重要问题。我们还将讨论在Java正则表达式中使用原子组。
- en: 'We will cover the following topics in this chapter:'
  id: totrans-541
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们将涵盖以下主题：
- en: Zero-width assertions
  id: totrans-542
  prefs: []
  type: TYPE_NORMAL
  zh: 零宽断言
- en: Previous match boundary
  id: totrans-543
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的匹配边界
- en: Atomic groups
  id: totrans-544
  prefs: []
  type: TYPE_NORMAL
  zh: 原子组
- en: 'Lookahead assertions: positive and negative'
  id: totrans-545
  prefs: []
  type: TYPE_NORMAL
  zh: 前瞻断言：正断言和负断言
- en: 'Lookbehind assertions: positive and negative'
  id: totrans-546
  prefs: []
  type: TYPE_NORMAL
  zh: 后顾断言：正断言和负断言
- en: Capturing text from overlapping matches
  id: totrans-547
  prefs: []
  type: TYPE_NORMAL
  zh: 从重叠匹配中捕获文本
- en: Capturing groups inside lookahead and lookbehind groups
  id: totrans-548
  prefs: []
  type: TYPE_NORMAL
  zh: 在前瞻和后顾组内的捕获组
- en: Lookbehind limitations in Java regular expressions
  id: totrans-549
  prefs: []
  type: TYPE_NORMAL
  zh: Java正则表达式中后顾断言的限制
- en: '![Image 19](img/index-134_1.jpg)'
  id: totrans-550
  prefs: []
  type: TYPE_IMG
  zh: '![图像19](img/index-134_1.jpg)'
- en: '**Zero-width assertions**'
  id: totrans-551
  prefs: []
  type: TYPE_NORMAL
  zh: '**零宽断言**'
- en: Zero-width or zero-length assertion in regular expressions means that there
    is a zero-length match that does not change the current position of the pointer
    in the input string. These assertions do not consume characters in the string
    but only assert whether a match is possible or not, giving us a binary true or
    false match result.
  id: totrans-552
  prefs: []
  type: TYPE_NORMAL
  zh: 零宽或零长度断言在正则表达式中意味着存在一个零长度的匹配，它不会改变输入字符串中指针的当前位置。这些断言不会消耗字符串中的字符，但只会断言是否可能匹配，给出二进制的真或假匹配结果。
- en: Although many zero-width assertions are denoted inside parentheses, like groups,
    we will soon see that they do not capture any text. Zero-width assertions have
    no real meaning in back-references or in replacements.
  id: totrans-553
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然许多零宽断言像组一样用括号表示，但我们将很快看到它们不会捕获任何文本。零宽断言在回溯或替换中没有任何实际意义。
- en: '*We have already discussed a few zero-width assertions in the previous* *chapters,
    such as anchors and boundary assertions.*'
  id: totrans-554
  prefs: []
  type: TYPE_NORMAL
  zh: '*我们在前面的章节中已经讨论了一些零宽断言，例如锚点和边界断言。*'
- en: The Java regular expression engine allows many predefined zero-width assertions,
    including the ones we have discussed already, such as start, end anchors, and
    word boundaries.
  id: totrans-555
  prefs: []
  type: TYPE_NORMAL
  zh: Java正则表达式引擎允许许多预定义的零宽断言，包括我们之前讨论过的，如起始、结束锚点和单词边界。
- en: '**Predefined zero-width**'
  id: totrans-556
  prefs: []
  type: TYPE_NORMAL
  zh: '**预定义零宽**'
- en: '**assertions**'
  id: totrans-557
  prefs: []
  type: TYPE_NORMAL
  zh: '**断言**'
- en: Zero-width
  id: totrans-558
  prefs: []
  type: TYPE_NORMAL
  zh: 零宽
- en: Description
  id: totrans-559
  prefs: []
  type: TYPE_NORMAL
  zh: 描述
- en: Assertion
  id: totrans-560
  prefs: []
  type: TYPE_NORMAL
  zh: 断言
- en: \b
  id: totrans-561
  prefs: []
  type: TYPE_NORMAL
  zh: \b
- en: Asserts a word boundary
  id: totrans-562
  prefs: []
  type: TYPE_NORMAL
  zh: 断言单词边界
- en: \B
  id: totrans-563
  prefs: []
  type: TYPE_NORMAL
  zh: \B
- en: Asserts anywhere except at a word boundary
  id: totrans-564
  prefs: []
  type: TYPE_NORMAL
  zh: 除了在单词边界处之外任何地方都可以断言
- en: ^
  id: totrans-565
  prefs: []
  type: TYPE_NORMAL
  zh: ^
- en: Asserts position only at the beginning of a line
  id: totrans-566
  prefs: []
  type: TYPE_NORMAL
  zh: 仅在行的开始位置断言位置
- en: $
  id: totrans-567
  prefs: []
  type: TYPE_NORMAL
  zh: $
- en: Asserts position only at the end of a line
  id: totrans-568
  prefs: []
  type: TYPE_NORMAL
  zh: 仅在行的末尾断言位置
- en: \A
  id: totrans-569
  prefs: []
  type: TYPE_NORMAL
  zh: \A
- en: Asserts position only at the beginning of a string
  id: totrans-570
  prefs: []
  type: TYPE_NORMAL
  zh: 仅在字符串的开始位置断言位置
- en: \z
  id: totrans-571
  prefs: []
  type: TYPE_NORMAL
  zh: \z
- en: Asserts position only at the end of a string
  id: totrans-572
  prefs: []
  type: TYPE_NORMAL
  zh: 仅在字符串的末尾断言位置
- en: Asserts position only at the end of a string or before the line break
  id: totrans-573
  prefs: []
  type: TYPE_NORMAL
  zh: 仅在字符串的末尾或行中断言位置
- en: \Z
  id: totrans-574
  prefs: []
  type: TYPE_NORMAL
  zh: \Z
- en: at the end of a string (if present)
  id: totrans-575
  prefs: []
  type: TYPE_NORMAL
  zh: 在字符串的末尾（如果存在）
- en: Asserts position at the end of the previous match or at the start of
  id: totrans-576
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前匹配的末尾或开始位置断言位置
- en: \G
  id: totrans-577
  prefs: []
  type: TYPE_NORMAL
  zh: \G
- en: the string for the very first match
  id: totrans-578
  prefs: []
  type: TYPE_NORMAL
  zh: 用于第一个匹配的字符串
- en: '**Regex defined zero-width**'
  id: totrans-579
  prefs: []
  type: TYPE_NORMAL
  zh: '**正则表达式定义的零宽断言**'
- en: '**assertions**'
  id: totrans-580
  prefs: []
  type: TYPE_NORMAL
  zh: '**断言**'
- en: Regex defined zero-width assertions use ( and ) and there is a ? after the opening
    (.
  id: totrans-581
  prefs: []
  type: TYPE_NORMAL
  zh: 正则表达式定义的零宽断言使用 ( 和 )，并且在开括号后面有一个 ?。
- en: 'There are two assertions: positive, denoted by the = character, and negative,
    denoted by the ! character. If the assertion is backward-looking then the ? character
    is followed by a < character. Thus, (?=...) is a positive lookahead assertion
    and (?<!...) is a negative lookbehind assertion.'
  id: totrans-582
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种断言：正向，用等号 "=" 表示，和负向，用感叹号 "!" 表示。如果断言是向后看的，那么问号 "?" 后面跟着一个小于号 "<"。因此，(?=...)
    是正向前瞻断言，(?<!...) 是负向后顾断言。
- en: The positive lookahead assertion ensures that the string matches the pattern
    after the current position. For example, abc(?=K) ensures that (?=pattern)
  id: totrans-583
  prefs: []
  type: TYPE_NORMAL
  zh: 正向前瞻断言确保字符串与当前位置之后的模式匹配。例如，abc(?=K) 确保了 (?=模式)
- en: the characters "abc" in the checked strings are followed by the letter
  id: totrans-584
  prefs: []
  type: TYPE_NORMAL
  zh: 检查字符串中的字符 "abc" 后面是字母
- en: '"K", but this check does not consume the character "K".'
  id: totrans-585
  prefs: []
  type: TYPE_NORMAL
  zh: '"K"，但这个检查不会消耗字符 "K"。'
- en: The negative lookahead assertion ensures that the string does not match the
    pattern after the current position. For example, abc(?!Z) (?!pattern)
  id: totrans-586
  prefs: []
  type: TYPE_NORMAL
  zh: 负向前瞻断言确保字符串在当前位置之后不匹配模式。例如，abc(?!Z) (?!模式)
- en: ensures that the characters "abc" in the checked string are not followed by
    the letter "Z", but this check does not consume the character "Z".
  id: totrans-587
  prefs: []
  type: TYPE_NORMAL
  zh: 确保检查字符串中的字符 "abc" 后面不是字母 "Z"，但这种检查不会消耗字符 "Z"。
- en: The positive lookbehind assertion ensures that the string matches the (?
  id: totrans-588
  prefs: []
  type: TYPE_NORMAL
  zh: 正向后顾断言确保字符串与当前位置之前的模式匹配
- en: pattern before the current position. For example, (?<=P)abc ensures
  id: totrans-589
  prefs: []
  type: TYPE_NORMAL
  zh: 模式在当前位置之前。例如，(?<=P)abc 确保
- en: <=pattern)
  id: totrans-590
  prefs: []
  type: TYPE_NORMAL
  zh: <=模式)
- en: that the characters "abc" in the checked string are preceded by the letter "P",
    but this check does not consume the character "P".
  id: totrans-591
  prefs: []
  type: TYPE_NORMAL
  zh: 检查字符串中的 "abc" 前面是字母 "P"，但这个检查不会消耗字符 "P"。
- en: The negative lookbehind assertion ensures that the string does not match the
    pattern before the current position. For example, (?<!Q)abc (?
  id: totrans-592
  prefs: []
  type: TYPE_NORMAL
  zh: 负向后顾断言确保字符串在当前位置之前不匹配模式。例如，(?<!Q)abc (?
- en: ensures that the characters "
  id: totrans-593
  prefs: []
  type: TYPE_NORMAL
  zh: 确保字符 ""
- en: <!pattern)
  id: totrans-594
  prefs: []
  type: TYPE_NORMAL
  zh: <!模式)
- en: abc" in the checked string are not
  id: totrans-595
  prefs: []
  type: TYPE_NORMAL
  zh: 检查字符串中的 "abc" 不是
- en: preceded by the letter "Q", but this check does not consume the character "Q".
  id: totrans-596
  prefs: []
  type: TYPE_NORMAL
  zh: 在字母 "Q" 前面，但这个检查不会消耗字符 "Q"。
- en: In the next section, we will look into more details of the \G boundary assertions,
    and then, you will learn about the lookahead and lookbehind assertions. However,
    before the lookarounds, we will discuss atomic groups, which are an important
    construct and topic to ease the understanding of the behavior of the lookahead
    and lookbehind assertions.
  id: totrans-597
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将深入了解 \G 边界断言的更多细节，然后，你将了解前瞻和后顾断言。然而，在讨论前瞻和后顾断言之前，我们将讨论原子组，这是一个重要的结构和主题，有助于理解前瞻和后顾断言的行为。
- en: '**\G boundary assertion**'
  id: totrans-598
  prefs: []
  type: TYPE_NORMAL
  zh: '**\G 边界断言**'
- en: \G is a zero-width assertion. It is also a boundary matcher that asserts positions
    at the end of the previous match or at the start of the string, such as the \A
    assertion for the very first match. The Java regex engine remembers the position
    of \G within the context of a Matcher instance. If Matcher is instantiated again
    or is reset, then the position of \G is also initialized to the start of the string.
  id: totrans-599
  prefs: []
  type: TYPE_NORMAL
  zh: \G 是零宽断言。它也是一个边界匹配器，断言在之前匹配的末尾或字符串的开始位置，例如，对于第一个匹配的 \A 断言。Java 正则表达式引擎在 Matcher
    实例的上下文中记住 \G 的位置。如果 Matcher 再次实例化或重置，那么 \G 的位置也会初始化为字符串的开始。
- en: 'For example, consider the following input:'
  id: totrans-600
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，考虑以下输入：
- en: ',,,,,123,45,67'
  id: totrans-601
  prefs: []
  type: TYPE_NORMAL
  zh: ',,,,,123,45,67'
- en: 'Consider that we need to replace every comma that occurs only at the start
    of the input with a hyphen so that we have the same number of hyphens as the number
    of commas at the start. Our final output should be the following:'
  id: totrans-602
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到我们需要将仅在输入起始处出现的每个逗号替换为连字符，以便我们有与输入字符串中逗号数量相同的连字符数量。我们的最终输出应该是以下内容：
- en: '-----123,45,67'
  id: totrans-603
  prefs: []
  type: TYPE_NORMAL
  zh: '-----123,45,67'
- en: We cannot just do replaceAll by matching each comma, since that will also replace
    the comma after 123 and 45, and moreover, we want the same number of hyphens as
    the number of commas in the input string.
  id: totrans-604
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不能仅仅通过匹配每个逗号来进行replaceAll，因为这也会替换123和45之后的逗号，而且我们还想有与输入字符串中逗号数量相同的连字符数量。
- en: 'For cases like this, we can use the \G assertion and use this Java code snippet:
    input = input.replaceAll("\\G,", "-"); Since \G matches the start of the line
    the first time, it will assert the position just before the first comma. Subsequently,
    it matches the positions after each comma, since \G matches the positions at the
    end of the previous match. It will stop matching when the control reaches the
    digit 1\. Each of these matches is replaced by a single hyphen, thus giving us
    the same number of hyphens in the replaced string as the number of leading commas
    in the original input.'
  id: totrans-605
  prefs: []
  type: TYPE_NORMAL
  zh: 对于此类情况，我们可以使用\G断言并使用以下Java代码片段：input = input.replaceAll("\\G,", "-"); 由于\G第一次匹配行首，它将断言第一个逗号之前的位置。随后，它匹配每个逗号之后的位臵，因为\G匹配上一个匹配的末尾位置。它将在控制达到数字1时停止匹配。这些匹配中的每一个都替换为一个单个连字符，因此给我们的替换字符串中的连字符数量与原始输入中起始逗号的数量相同。
- en: Let's look at another full example to understand the use of \G better.
  id: totrans-606
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再看另一个完整示例，以更好地理解\G的使用。
- en: 'Here is a sample input:'
  id: totrans-607
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个示例输入：
- en: '{%var1%, %var2%, %var3%} {%var4%, %var5%, %var6%}'
  id: totrans-608
  prefs: []
  type: TYPE_NORMAL
  zh: '{%var1%, %var2%, %var3%} {%var4%, %var5%, %var6%}'
- en: 'Our task is to replace the % characters with the # (hash) characters in the
    first {...}'
  id: totrans-609
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的任务是将第一 {...} 中的%字符替换为#（井号）字符。
- en: 'section only. We can assume that { and } are perfectly balanced. The expected
    output is as follows:'
  id: totrans-610
  prefs: []
  type: TYPE_NORMAL
  zh: section only. 我们可以假设{和}是完美平衡的。预期的输出如下：
- en: '{#var1#, #var2#, #var3#} {%var4%, %var5%, %var6%}'
  id: totrans-611
  prefs: []
  type: TYPE_NORMAL
  zh: '{#var1#, #var2#, #var3#} {%var4%, %var5%, %var6%}'
- en: 'Note how the output has % replaced with # in only the first pair of {...}.'
  id: totrans-612
  prefs: []
  type: TYPE_NORMAL
  zh: 注意输出中只有第一对 {...} 中的%被替换为#。
- en: 'Here is a code listing to solve this problem:'
  id: totrans-613
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个代码列表，用于解决这个问题：
- en: package example.regex;
  id: totrans-614
  prefs: []
  type: TYPE_NORMAL
  zh: package example.regex;
- en: class GBoundaryMatcher
  id: totrans-615
  prefs: []
  type: TYPE_NORMAL
  zh: class GBoundaryMatcher
- en: '{'
  id: totrans-616
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: public static void main (String[] args)
  id: totrans-617
  prefs: []
  type: TYPE_NORMAL
  zh: public static void main (String[] args)
- en: '{'
  id: totrans-618
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: String input = "{%var1%, %var2%, %var3%} " +
  id: totrans-619
  prefs: []
  type: TYPE_NORMAL
  zh: String input = "{%var1%, %var2%, %var3%} " +
- en: '"{%var4%, %var5%, %var6%}";'
  id: totrans-620
  prefs: []
  type: TYPE_NORMAL
  zh: '"{%var4%, %var5%, %var6%}";'
- en: final String re = "(^[^{]*\\{|\\G(?!^),\\h*)%([^%]+)%";
  id: totrans-621
  prefs: []
  type: TYPE_NORMAL
  zh: final String re = "(^[^{]*\\{|\\G(?!^),\\h*)%([^%]+)%";
- en: // now use above regex in replaceAll method String repl = input.replaceAll(re,
    "$1#$2#");
  id: totrans-622
  prefs: []
  type: TYPE_NORMAL
  zh: //现在在replaceAll方法中使用上述正则表达式 String repl = input.replaceAll(re, "$1#$2#");
- en: System.out.println(repl);
  id: totrans-623
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println(repl);
- en: '}'
  id: totrans-624
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-625
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: Here is how this regex is doing the job in this code.
  id: totrans-626
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是如何在这个代码中执行这个正则表达式的。
- en: 'We use this regex to match our pattern:'
  id: totrans-627
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用此正则表达式来匹配我们的模式：
- en: '"(^[^{]*\\{|\\G(?!^),\\h*)%([^%]+)%"'
  id: totrans-628
  prefs: []
  type: TYPE_NORMAL
  zh: '"(^[^{]*\\{|\\G(?!^),\\h*)%([^%]+)%"'
- en: 'The preceding regex has two groups, as follows:'
  id: totrans-629
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的正则表达式有两个组，如下所示：
- en: (^[^{]*\\{|\\G(?!^),\\h*)
  id: totrans-630
  prefs: []
  type: TYPE_NORMAL
  zh: (^[^{]*\\{|\\G(?!^),\\h*)
- en: 'This is the captured group number one. We are using alternation to select two
    possible patterns here:'
  id: totrans-631
  prefs: []
  type: TYPE_NORMAL
  zh: 这是第一个捕获组。我们在这里使用交替来选择两种可能的模式：
- en: '^[^{]*\\{: This matches all text up to the first { from the start.'
  id: totrans-632
  prefs: []
  type: TYPE_NORMAL
  zh: '^[^{]*\\{: 这匹配从开始到第一个{的所有文本。'
- en: '\\G(?!^),\\h*: This matches text from the end of the previous match followed
    by a comma and zero or more horizontal whitespaces. (?!^) is a negative lookahead
    to avoid matching \G at the start position. This is needed because \G also successfully
    asserts the start of the input string in the first use.'
  id: totrans-633
  prefs: []
  type: TYPE_NORMAL
  zh: '\\G(?!^),\\h*: 这匹配从上一个匹配的末尾开始的文本，后跟一个逗号和零个或多个水平空白。(?!^)是一个负向前瞻，以避免在起始位置匹配\G。这是必需的，因为\G在第一次使用时也成功地断言了输入字符串的起始位置。'
- en: The %([^%]+)% pattern is our captured group number two. It is the substring
    surrounded by the % characters.
  id: totrans-634
  prefs: []
  type: TYPE_NORMAL
  zh: '%([^%]+)%模式是我们的第二个捕获组。它是被%字符包围的子字符串。'
- en: 'In the replacement, we use the following:'
  id: totrans-635
  prefs: []
  type: TYPE_NORMAL
  zh: 在替换中，我们使用以下内容：
- en: $1#$2#
  id: totrans-636
  prefs: []
  type: TYPE_NORMAL
  zh: $1#$2#
- en: 'This basically puts back the first group''s captured text and wraps the second
    captured group in # instead of % to get the required output.'
  id: totrans-637
  prefs: []
  type: TYPE_NORMAL
  zh: 这基本上是将第一组捕获的文本放回，并将第二捕获组用#而不是%包裹，以获得所需输出。
- en: 'Once we compile and run the preceding code, it shows the following output:'
  id: totrans-638
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们编译并运行前面的代码，它将显示以下输出：
- en: '{#var1#, #var2#, #var3#} {%var4%, %var5%, %var6%}'
  id: totrans-639
  prefs: []
  type: TYPE_NORMAL
  zh: '{#var1#, #var2#, #var3#} {%var4%, %var5%, %var6%}'
- en: '![Image 20](img/index-139_1.jpg)'
  id: totrans-640
  prefs: []
  type: TYPE_IMG
  zh: '![Image 20](img/index-139_1.jpg)'
- en: '**Atomic groups**'
  id: totrans-641
  prefs: []
  type: TYPE_NORMAL
  zh: '**原子组**'
- en: An atomic group is a non-capturing group that throws away all the alternative
    positions remembered by any token inside the group when the matching process exits
    the group after the first match of the pattern inside the group. Thus, it avoids
    backtracking to attempt all the alternatives present in the group.
  id: totrans-642
  prefs: []
  type: TYPE_NORMAL
  zh: 原子组是一个非捕获组，当匹配过程在组内第一个模式匹配后退出组时，它会丢弃组内任何标记记住的所有备选位置。因此，它避免了回溯以尝试组中存在的所有备选模式。
- en: 'Here is the syntax:'
  id: totrans-643
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是语法：
- en: (?>regex)
  id: totrans-644
  prefs: []
  type: TYPE_NORMAL
  zh: (?>regex)
- en: Here, the regex may contain alternative patterns. On the other hand, a non-atomic
    group will allow backtracking; it will try to find the first match and then if
    the matching ahead fails, it will backtrack and try to find the next match in
    alternation, until a match for the entire expression is found or all the possibilities
    are exhausted.
  id: totrans-645
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，正则表达式可能包含备选模式。另一方面，非原子组将允许回溯；它将尝试找到第一个匹配项，然后如果向前匹配失败，它将回溯并尝试在交替中找到下一个匹配项，直到找到整个表达式的匹配项或耗尽所有可能性。
- en: 'To understand it better, let''s take an example of a regular expression using
    a non-atomic group:'
  id: totrans-646
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地理解它，让我们用一个非原子组的正则表达式作为例子：
- en: ^foo(d|die|lish)$
  id: totrans-647
  prefs: []
  type: TYPE_NORMAL
  zh: ^foo(d|die|lish)$
- en: The input string here is foodie.
  id: totrans-648
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的输入字符串是foodie。
- en: It will match the starting pattern foo and then the first alternative d. It
    fails at this time because the end anchor, $, requires that we must be at the
    end of the input string, but we still have two characters, i and e, to be matched.
    Then, the engine attempts to match the second alternative die. This match operation
    succeeds, as the $ anchor asserts true since the input ends there and stops matching
    further with a successful match returned.
  id: totrans-649
  prefs: []
  type: TYPE_NORMAL
  zh: 它将匹配起始模式foo，然后是第一个备选模式d。它此时失败，因为结束锚点$要求我们必须在输入字符串的末尾，但我们还有两个字符i和e需要匹配。然后，引擎尝试匹配第二个备选模式die。这个匹配操作成功，因为$锚点断言为真，因为输入在这里结束，并且停止进一步匹配，返回一个成功的匹配。
- en: '*Even if we use a non-capturing group instead of a capturing group* *here to
    make it ^foo(?:d|die|lish)$, it will have the same effect while* *matching.*'
  id: totrans-650
  prefs: []
  type: TYPE_NORMAL
  zh: '*即使我们在这里使用非捕获组而不是捕获组* *来使其成为^foo(?:d|die|lish)$，它在匹配时也会产生相同的效果。*'
- en: 'Now, take an example of the same regular expression using an **atomic group**:'
  id: totrans-651
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们用一个**原子组**的相同正则表达式作为例子：
- en: ^foo(?>d|die|lish)$
  id: totrans-652
  prefs: []
  type: TYPE_NORMAL
  zh: ^foo(?>d|die|lish)$
- en: Note the use of ?> after ( to make it an atomic non-capturing group.
  id: totrans-653
  prefs: []
  type: TYPE_NORMAL
  zh: 注意在(之后使用?>使其成为一个原子非捕获组。
- en: Let's see what happens when we apply the preceding regex against the same input
    string, that is, foodie.
  id: totrans-654
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看当我们将前面的正则表达式应用于相同的输入字符串时会发生什么，即foodie。
- en: It will match the starting pattern, foo, and then its first alternative, d.
    It fails because the $ anchor asserts false since the input does not end at food.
    However, because of the use of the atomic group, the regex engine gives up immediately
    and doesn't backtrack.
  id: totrans-655
  prefs: []
  type: TYPE_NORMAL
  zh: 它将匹配起始模式foo，然后是其第一个备选模式d。它失败是因为锚点断言为假，因为输入没有在food结束。然而，由于使用了原子组，正则表达式引擎立即放弃并不会回溯。
- en: Since the regex engine throws away all the alternative positions remembered
    inside the atomic group, it does not attempt to match the second alternative die,
    which would have been a successful match for a non-atomic group. Finally, this
    match operation fails with no match.
  id: totrans-656
  prefs: []
  type: TYPE_NORMAL
  zh: 由于正则表达式引擎丢弃了原子组内记住的所有备选位置，它不会尝试匹配第二个备选模式die，这对于非原子组来说将是一个成功的匹配。最后，这个匹配操作失败，没有匹配。
- en: You need to remember a simple but important fact that the alternation tries
    its alternatives from left to right and always attempts to complete the match
    using the
  id: totrans-657
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要记住一个简单但重要的事实，交替从左到右尝试其备选模式，并且总是尝试使用
- en: '![Image 21](img/index-140_1.jpg)'
  id: totrans-658
  prefs: []
  type: TYPE_IMG
  zh: '![Image 21](img/index-140_1.jpg)'
- en: leftmost alternative. Therefore, whenever listing all the options in an alternation,
    it is good practice to place the longest matches first and then use the other
    alternatives to place shorter matches.
  id: totrans-659
  prefs: []
  type: TYPE_NORMAL
  zh: 最左侧的备选模式。因此，在列出交替中的所有选项时，将最长的匹配项首先列出，然后使用其他备选模式来放置较短的匹配项是良好的实践。
- en: Using this principle, we can make some small changes to our atomic group to
    make it work.
  id: totrans-660
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个原则，我们可以对我们的原子组做一些小的修改以使其工作。
- en: 'Here is the working regex:'
  id: totrans-661
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是工作的正则表达式：
- en: ^foo(?>lish|die|d)$
  id: totrans-662
  prefs: []
  type: TYPE_NORMAL
  zh: ^foo(?>lish|die|d)$
- en: We have the same input string, foodie.
  id: totrans-663
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有相同的输入字符串，foodie。
- en: Note that we have the same alternatives in this atomic group but with a different
    order. Since d is a prefix of die, we are placing the die alternative on the left-hand
    side of d so that the regex engine can first attempt to match foodie before attempting
    food.
  id: totrans-664
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在这个原子组中我们有相同的替代选项，但顺序不同。由于 d 是 die 的前缀，我们将 die 替代选项放在 d 的左侧，以便正则表达式引擎首先尝试匹配
    foodie，然后再尝试匹配 food。
- en: 'Here is the full code listing running these examples:'
  id: totrans-665
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是运行这些示例的完整代码列表：
- en: package example.regex;
  id: totrans-666
  prefs: []
  type: TYPE_NORMAL
  zh: package example.regex;
- en: class AtomicGroupExample
  id: totrans-667
  prefs: []
  type: TYPE_NORMAL
  zh: class AtomicGroupExample
- en: '{'
  id: totrans-668
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: public static void main (String[] args)
  id: totrans-669
  prefs: []
  type: TYPE_NORMAL
  zh: public static void main (String[] args)
- en: '{'
  id: totrans-670
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: final String input = "foodie";
  id: totrans-671
  prefs: []
  type: TYPE_NORMAL
  zh: final String input = "foodie";
- en: // regex with non-atomic group
  id: totrans-672
  prefs: []
  type: TYPE_NORMAL
  zh: // 使用非原子组的正则表达式
- en: final String nonAtomicRegex = "foo(d|die|lish)";
  id: totrans-673
  prefs: []
  type: TYPE_NORMAL
  zh: final String nonAtomicRegex = "foo(d|die|lish)";
- en: // regex with an atomic group
  id: totrans-674
  prefs: []
  type: TYPE_NORMAL
  zh: // 使用原子组的正则表达式
- en: final String atomicRegex = "foo(?>d|die|lish)";
  id: totrans-675
  prefs: []
  type: TYPE_NORMAL
  zh: final String atomicRegex = "foo(?>d|die|lish)";
- en: // regex with an alternate atomic group with correct order final String atomicRegexImproved
    = "foo(?>lish|die|d)";
  id: totrans-676
  prefs: []
  type: TYPE_NORMAL
  zh: // 使用正确顺序的替代原子组的正则表达式 final String atomicRegexImproved = "foo(?>lish|die|d)";
- en: // now execute all 3 regex against same input
  id: totrans-677
  prefs: []
  type: TYPE_NORMAL
  zh: // 现在将所有 3 个正则表达式对相同的输入进行执行
- en: 'System.out.printf("%s: %s%n",'
  id: totrans-678
  prefs: []
  type: TYPE_NORMAL
  zh: 'System.out.printf("%s: %s%n",'
- en: nonAtomicRegex, input.matches(nonAtomicRegex));
  id: totrans-679
  prefs: []
  type: TYPE_NORMAL
  zh: nonAtomicRegex, input.matches(nonAtomicRegex));
- en: 'System.out.printf("%s: %s%n",'
  id: totrans-680
  prefs: []
  type: TYPE_NORMAL
  zh: 'System.out.printf("%s: %s%n",'
- en: atomicRegex, input.matches(atomicRegex));
  id: totrans-681
  prefs: []
  type: TYPE_NORMAL
  zh: atomicRegex, input.matches(atomicRegex));
- en: 'System.out.printf("%s: %s%n",'
  id: totrans-682
  prefs: []
  type: TYPE_NORMAL
  zh: 'System.out.printf("%s: %s%n",'
- en: atomicRegexImproved , input.matches(atomicRegexImproved));
  id: totrans-683
  prefs: []
  type: TYPE_NORMAL
  zh: atomicRegexImproved , input.matches(atomicRegexImproved));
- en: '}'
  id: totrans-684
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-685
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: 'After compiling and running the code, it will generate the following output:
    foo(?:d|die|lish): true'
  id: totrans-686
  prefs: []
  type: TYPE_NORMAL
  zh: '编译并运行代码后，将生成以下输出：foo(?:d|die|lish): true'
- en: 'foo(?>d|die|lish): false'
  id: totrans-687
  prefs: []
  type: TYPE_NORMAL
  zh: 'foo(?>d|die|lish): false'
- en: 'foo(?>lish|die|d): true'
  id: totrans-688
  prefs: []
  type: TYPE_NORMAL
  zh: 'foo(?>lish|die|d): true'
- en: '*Since the atomic group prevents the regex engine from backtracking by* *exiting
    from the evaluation of all the alternatives inside the group, the* *atomic group
    usually provides a significant gain in performance while* *evaluating a largely
    sized text with multiple options in alternation.*'
  id: totrans-689
  prefs: []
  type: TYPE_NORMAL
  zh: '*由于原子组通过* *退出组内所有替代选项的评估，从而阻止正则表达式引擎回溯，因此* *原子组在评估具有多个交替选项的大规模文本时通常可以提供显著的性能提升*。'
- en: '**Lookahead assertions**'
  id: totrans-690
  prefs: []
  type: TYPE_NORMAL
  zh: '**后行断言**'
- en: Positive and negative lookahead assertions are zero-width assertions that allow
    for certain regular expression-based checks to be performed on the text that is
    ahead (or on the right-hand side) of the current position. The regex engine holds
    on to the current position after evaluating the lookahead pattern. We can chain
    multiple lookahead expressions one after another, but the regex engine does not
    move the control after checking all the lookaheads. Lookahead assertions can help
    solve some complex regex problems, which are not possible or are very difficult
    to solve without lookahead support. The Java regular expression engine, like many
    other regular expression flavors, allows the use of variable-length quantifiers
    such as * and + in lookahead patterns.
  id: totrans-691
  prefs: []
  type: TYPE_NORMAL
  zh: 正向和负向先行断言是零宽断言，允许在文本的当前位置之前（或右侧）执行某些基于正则表达式的检查。正则表达式引擎在评估先行断言模式后保持当前位置。我们可以将多个先行断言表达式一个接一个地链接起来，但正则表达式引擎在检查所有先行断言后不会移动控制。先行断言可以帮助解决一些复杂的正则表达式问题，这些问题在没有先行断言支持的情况下无法解决或非常难以解决。Java
    正则表达式引擎，像许多其他正则表达式变体一样，允许在先行断言模式中使用可变长度的量词，如 * 和 +。
- en: 'There are two types of lookahead assertions: positive lookahead and negative
    lookahead.'
  id: totrans-692
  prefs: []
  type: TYPE_NORMAL
  zh: 存在两种类型的先行断言：正向先行断言和负向先行断言。
- en: '**Positive lookahead**'
  id: totrans-693
  prefs: []
  type: TYPE_NORMAL
  zh: '**正向先行断言**'
- en: A positive lookahead assertion asserts true if the pattern inside the lookahead
    is matched.
  id: totrans-694
  prefs: []
  type: TYPE_NORMAL
  zh: 一个正向先行断言如果先行断言内的模式匹配，则断言为真。
- en: 'The following is its syntax:'
  id: totrans-695
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是其语法：
- en: (?=...)
  id: totrans-696
  prefs: []
  type: TYPE_NORMAL
  zh: (?=...)
- en: 'For example, \d+(?=##) asserts that there must be a string, ##, immediately
    after matching one or more digits.'
  id: totrans-697
  prefs: []
  type: TYPE_NORMAL
  zh: '例如，\d+(?=##) 断言在匹配一个或多个数字后必须立即跟有字符串 ##。'
- en: '**Negative lookahead**'
  id: totrans-698
  prefs: []
  type: TYPE_NORMAL
  zh: '**负向先行断言**'
- en: A negative lookahead assertion asserts true if the pattern inside the lookahead
    is not matched.
  id: totrans-699
  prefs: []
  type: TYPE_NORMAL
  zh: 一个负向先行断言如果先行断言内的模式不匹配，则断言为真。
- en: 'The following is its syntax:'
  id: totrans-700
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是其语法：
- en: (?!...)
  id: totrans-701
  prefs: []
  type: TYPE_NORMAL
  zh: (?!...)
- en: For example, abc(?!xyz) asserts that there cannot be a string, xyz, immediately
    after matching the string abc.
  id: totrans-702
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，abc(?!xyz) 断言在匹配字符串 abc 后不能立即跟有字符串 xyz。
- en: '**Lookbehind assertions**'
  id: totrans-703
  prefs: []
  type: TYPE_NORMAL
  zh: '**后行断言**'
- en: Positive and negative lookbehind assertions are zero-width assertions that allow
    for certain regex-based checks to be performed on the text that precedes (or is
    on the left-hand side) of the current position. The regex engine holds on to the
    current position after evaluating the lookbehind pattern. We can chain multiple
    lookbehind expressions one after another, but the regex engine does not move the
    control after checking all the lookbehind assertions. Lookbehind assertions can
    also help solve some complex problems that are not possible or are very difficult
    to solve without lookbehind support. Up to Java version 8, the Java regular expression
    engine didn't allow the use of variable-length quantifiers such as * and + in
    lookbehind patterns.
  id: totrans-704
  prefs: []
  type: TYPE_NORMAL
  zh: 正向和负向后行断言是零宽断言，允许在当前位置之前的文本上执行某些基于正则表达式的检查。正则表达式引擎在评估后行模式后保持当前位置。我们可以将多个后行表达式一个接一个地链接起来，但正则表达式引擎在检查所有后行断言后不会移动控制。后行断言还可以帮助解决一些没有后行支持或很难解决的问题。直到Java版本8，Java正则表达式引擎不允许在后行模式中使用诸如*和+这样的变长量词。
- en: With Java 9, the Java regex engine now allows the use of these quantifiers in
    lookbehind assertions.
  id: totrans-705
  prefs: []
  type: TYPE_NORMAL
  zh: 从Java 9开始，Java正则表达式引擎现在允许在先行断言中使用这些量词。
- en: 'There are two types of lookbehind assertions: positive lookbehind and negative
    lookbehind.'
  id: totrans-706
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种类型的后行断言：正向后行和负向后行。
- en: '**Positive lookbehind**'
  id: totrans-707
  prefs: []
  type: TYPE_NORMAL
  zh: '**正向后行**'
- en: A positive lookbehind assertion asserts true if the pattern inside the lookbehind
    is matched.
  id: totrans-708
  prefs: []
  type: TYPE_NORMAL
  zh: 正向后行断言如果后行模式匹配，则断言为真。
- en: 'Here is its syntax:'
  id: totrans-709
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是其语法：
- en: (?<=...)
  id: totrans-710
  prefs: []
  type: TYPE_NORMAL
  zh: (?<=...)
- en: 'For example, (?<=##)\d+ asserts that there must be a ## string just before
    matching one or more digits.'
  id: totrans-711
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，(?<=##)\d+断言在匹配一个或多个数字之前必须有一个##字符串。
- en: '**Negative lookbehind**'
  id: totrans-712
  prefs: []
  type: TYPE_NORMAL
  zh: '**负向后行**'
- en: A negative lookbehind assertion asserts true if the pattern inside the lookbehind
    is not matched.
  id: totrans-713
  prefs: []
  type: TYPE_NORMAL
  zh: 负向后行断言如果后行模式不匹配，则断言为真。
- en: 'Here is its syntax:'
  id: totrans-714
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是其语法：
- en: (?<!...)
  id: totrans-715
  prefs: []
  type: TYPE_NORMAL
  zh: (?<!...)
- en: For example, (?<!xyz)abc asserts that there cannot be the string, xyz, just
    before matching the string, abc.
  id: totrans-716
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，(?<!xyz)abc断言在匹配字符串abc之前不能有字符串xyz。
- en: 'Here are a few important points about lookaround regex patterns: Lookaround
    patterns are atomic. Like atomic groups, once a lookaround pattern is matched,
    the regex engine exits immediately from that lookaround, returning just a true
    or false assertion.'
  id: totrans-717
  prefs: []
  type: TYPE_NORMAL
  zh: 关于先行正则模式的一些重要点：先行模式是原子的。像原子组一样，一旦先行模式匹配，正则表达式引擎立即从该先行模式退出，只返回一个真或假的断言。
- en: Lookaround patterns don't move from the current position. All patterns are evaluated
    from the current position. The position remains the same after the lookaround
    assertions are completed.
  id: totrans-718
  prefs: []
  type: TYPE_NORMAL
  zh: 先行模式不会从当前位置移动。所有模式都是从当前位置评估的。在先行断言完成后，位置保持不变。
- en: If a regular expression uses multiple lookaround assertions next to each other,
    then the order of those expressions is not important.
  id: totrans-719
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个正则表达式在相邻位置使用多个先行断言，那么这些表达式的顺序并不重要。
- en: Lookaround patterns are usually used in complex input validations, for splitting
    the input before or after the specified patterns, and for finding overlapping
    matches.
  id: totrans-720
  prefs: []
  type: TYPE_NORMAL
  zh: 先行模式通常用于复杂的输入验证，在指定模式之前或之后分割输入，以及寻找重叠匹配。
- en: Let's look at some examples to understand the use of lookahead and lookbehind
    expressions.
  id: totrans-721
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一些示例来了解先行和后行表达式的用法。
- en: 'To match an integer number with one or more digits that doesn''t allow all
    zeroes, we can use the following:'
  id: totrans-722
  prefs: []
  type: TYPE_NORMAL
  zh: 要匹配一个整数，该整数有一个或多个数字且不允许所有为零，我们可以使用以下方法：
- en: ^(?!0+$)\d+$
  id: totrans-723
  prefs: []
  type: TYPE_NORMAL
  zh: ^(?!0+$)\d+$
- en: (?!0+$) is a negative lookahead expression that will assert failure if we have
    one or more zeroes till the end, ahead of the current position, which is the start
    of the input string in our example.
  id: totrans-724
  prefs: []
  type: TYPE_NORMAL
  zh: (?!0+$)是一个负先行表达式，如果在我们示例中的当前位置之前有一个或多个零，则断言失败，这是输入字符串的起始位置。
- en: 'Given an input text with @ characters, we need to match @ only if there is
    a word character at the next position. We can use a positive lookahead regex here,
    as follows:'
  id: totrans-725
  prefs: []
  type: TYPE_NORMAL
  zh: 给定一个包含@字符的输入文本，我们需要匹配@，前提是下一个位置是单词字符。我们可以在这里使用正向先行正则表达式，如下所示：
- en: '@(?=\w)'
  id: totrans-726
  prefs: []
  type: TYPE_NORMAL
  zh: '@(?=\w)'
- en: Here, (?=\w) means a positive lookahead that asserts true when there is a word
    character next to @.
  id: totrans-727
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，(?=\w)表示一个正向先行断言，当@旁边是单词字符时，断言为真。
- en: 'To match an input string that doesn''t allow the string zzz anywhere, we can
    use a negative lookahead such as this:'
  id: totrans-728
  prefs: []
  type: TYPE_NORMAL
  zh: 要匹配一个不允许字符串zzz出现在任何地方的输入字符串，我们可以使用如下负先行断言：
- en: ^(?!.*zzz)
  id: totrans-729
  prefs: []
  type: TYPE_NORMAL
  zh: ^(?!.*zzz)
- en: 'To match a dot that is not followed or preceded by a digit, we can use negative
    lookahead and negative lookbehind conditions, as follows:'
  id: totrans-730
  prefs: []
  type: TYPE_NORMAL
  zh: 为了匹配一个不跟随或不 precede 数字点的点，我们可以使用负向前瞻和负向后瞻条件，如下所示：
- en: (?<!\d)\.(?!\d)
  id: totrans-731
  prefs: []
  type: TYPE_NORMAL
  zh: (?<!\d)\.(?!\d)
- en: 'Here, we are using two assertions:'
  id: totrans-732
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我们使用了两个断言：
- en: (?<!\d) is a negative lookbehind condition that asserts that there is no digit
    preceding a dot
  id: totrans-733
  prefs: []
  type: TYPE_NORMAL
  zh: (?<!\d) 是一个负向后瞻条件，断言在点之前没有数字。
- en: (?!\d) is a negative lookahead condition that asserts that there is no digit
    following a dot
  id: totrans-734
  prefs: []
  type: TYPE_NORMAL
  zh: (?!\d) 是一个负向前瞻条件，断言在点之后没有数字。
- en: This will match the dot in ip.address, .net, and abc. but won't match the dot
    in 25.78, 12., and .987\.
  id: totrans-735
  prefs: []
  type: TYPE_NORMAL
  zh: 这将匹配 ip.address、.net 和 abc 中的点，但不会匹配 25.78、12. 和 .987\. 中的点。
- en: 'Next, we need to match an input that must not contain the repetition of the
    @, #, or %'
  id: totrans-736
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要匹配一个不包含 @、# 或 % 重复的输入。
- en: characters.
  id: totrans-737
  prefs: []
  type: TYPE_NORMAL
  zh: characters.
- en: 'We will need to use a negative lookahead pattern that contains a capturing
    group and a back-reference to check repetition:'
  id: totrans-738
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将需要使用一个包含捕获组和回溯引用的负向前瞻模式：
- en: ^(?!.*([@#%])\1)
  id: totrans-739
  prefs: []
  type: TYPE_NORMAL
  zh: ^(?!.*([@#%])\1)
- en: (?!.*([@#%])\1) is a negative lookahead assertion that matches and captures
    the given special characters in the first capturing group. Using back-reference
    \1, we check duplication of the captured character. The pattern inside the negative
    lookahead .*
  id: totrans-740
  prefs: []
  type: TYPE_NORMAL
  zh: '(?!.*([@#%])\1) 是一个负向前瞻断言，匹配并捕获第一个捕获组中的给定特殊字符。使用回溯引用 \1，我们检查捕获字符的重复。负向前瞻中的模式
    .* '
- en: '([@#%])\1 makes sure that we don''t have a duplicated @, #, or % character
    at any position ahead of the current position.'
  id: totrans-741
  prefs: []
  type: TYPE_NORMAL
  zh: ([@#%])\1 确保在当前位置之前没有重复的 @、# 或 % 字符。
- en: 'Now, suppose that we need to find a search term in a long text with the following
    conditions:'
  id: totrans-742
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，假设我们需要在满足以下条件的长文本中找到一个搜索词：
- en: 1\. The search term is at the start or preceded by a whitespace.
  id: totrans-743
  prefs: []
  type: TYPE_NORMAL
  zh: 1\. 搜索词位于起始位置或之前有一个空白。
- en: 2\. The search term is at the end or followed by a whitespace.
  id: totrans-744
  prefs: []
  type: TYPE_NORMAL
  zh: 2\. 搜索词位于末尾或之后有一个空白。
- en: 3\. The search term may contain non-word characters as well.
  id: totrans-745
  prefs: []
  type: TYPE_NORMAL
  zh: 3\. 搜索词可能包含非单词字符。
- en: 'To solve this, we can use a regular expression with a positive lookahead and
    a positive lookbehind like this:'
  id: totrans-746
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，我们可以使用一个带有正向前瞻和正向后瞻的正则表达式，如下所示：
- en: (?<=^|\h)searchTerm(?=\h|$)
  id: totrans-747
  prefs: []
  type: TYPE_NORMAL
  zh: (?<=^|\h)searchTerm(?=\h|$)
- en: Here, (?<=^|\h) is a positive lookbehind that asserts that the search term is
    at the start position or is preceded by a horizontal whitespace.
  id: totrans-748
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，(?<=^|\h) 是一个正向后瞻，断言搜索词位于起始位置或之前有一个水平空白。
- en: (?=\h|$) is a positive lookahead that asserts that the search term is at the
    end position or is followed by a horizontal whitespace.
  id: totrans-749
  prefs: []
  type: TYPE_NORMAL
  zh: (?=\h|$) 是一个正向前瞻，断言搜索词位于末尾位置或之后有一个水平空白。
- en: Match a string containing one or more word characters but doesn't allow any
    of the characters to repeat.
  id: totrans-750
  prefs: []
  type: TYPE_NORMAL
  zh: 匹配包含一个或多个单词字符的字符串，但不允许任何字符重复。
- en: 'To solve this problem, we need to use a capturing group, back-reference, and
    a negative lookahead like this:'
  id: totrans-751
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，我们需要使用一个捕获组、回溯引用和负向前瞻，如下所示：
- en: ^(?:(\w)(?!.*\1))+$
  id: totrans-752
  prefs: []
  type: TYPE_NORMAL
  zh: ^(?:(\w)(?!.*\1))+$
- en: Here, we are matching and capturing each character in the first captured group.
    Each word character is asserted by a negative lookahead (?!.*\1), where \1 is
    the backreference of the first captured group. The negative lookahead (?!.*\1)
    asserts that we don't have another occurrence of the captured character in the
    string ahead. Finally, we wrap the whole expression in a non-capturing group to
    be able to use the quantifier
  id: totrans-753
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们正在匹配并捕获第一个捕获组中的每个字符。每个单词字符通过一个负向前瞻（?!.*\1）来断言，其中\1是第一个捕获组的回溯引用。负向前瞻（?!.*\1）断言在字符串前方没有捕获字符的另一个出现。最后，我们将整个表达式包裹在一个非捕获组中，以便能够使用量词
- en: + to match one or more word non-repeating characters.
  id: totrans-754
  prefs: []
  type: TYPE_NORMAL
  zh: + 匹配一个或多个非重复单词字符。
- en: Suppose we need to scan a line of text and place a colon in every third position
    from right to left. However, we should not place a colon at the start position.
  id: totrans-755
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们需要扫描一行文本，并在从右到左的第三个位置放置一个冒号。然而，我们不应该在起始位置放置冒号。
- en: This should convert abcd into a:bcd and 123456 will be converted to 123:456,
    but abc must not become :abc.
  id: totrans-756
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该将 abcd 转换为 a:bcd，而 123456 将转换为 123:456，但 abc 必须不会变成 :abc。
- en: 'To solve this, we can use a lookahead regex, as in this code listing: package
    example.regex;'
  id: totrans-757
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，我们可以使用一个前瞻正则表达式，如下面的代码所示：package example.regex;
- en: import java.util.regex.*;
  id: totrans-758
  prefs: []
  type: TYPE_NORMAL
  zh: import java.util.regex.*;
- en: class LookAroundExample1
  id: totrans-759
  prefs: []
  type: TYPE_NORMAL
  zh: class LookAroundExample1
- en: '{'
  id: totrans-760
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: public static void main (String[] args)
  id: totrans-761
  prefs: []
  type: TYPE_NORMAL
  zh: public static void main (String[] args)
- en: '{'
  id: totrans-762
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: final String[] inputs =
  id: totrans-763
  prefs: []
  type: TYPE_NORMAL
  zh: final String[] inputs =
- en: '{"abcd98732", "pqrn", "qwerty12345678xyz", "123"}; final Pattern p = Pattern.compile("(?!^)(?=(.{3})+$)");
    for (String s: inputs)'
  id: totrans-764
  prefs: []
  type: TYPE_NORMAL
  zh: '{"abcd98732", "pqrn", "qwerty12345678xyz", "123"}; `final Pattern p = Pattern.compile("(?!^)(?=(.{3})+$)");`
    for (`String s: inputs`)'
- en: '{'
  id: totrans-765
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: Matcher m = p.matcher(s);
  id: totrans-766
  prefs: []
  type: TYPE_NORMAL
  zh: '`Matcher m = p.matcher(s);`'
- en: System.out.printf("%s => %s%n", s, m.replaceAll(":"));
  id: totrans-767
  prefs: []
  type: TYPE_NORMAL
  zh: '`System.out.printf("%s => %s%n", s, m.replaceAll(":"));`'
- en: '}'
  id: totrans-768
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-769
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-770
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: 'After running this code, we''ll get the following output:'
  id: totrans-771
  prefs: []
  type: TYPE_NORMAL
  zh: 运行此代码后，我们将得到以下输出：
- en: abcd98732 => abc:d98:732
  id: totrans-772
  prefs: []
  type: TYPE_NORMAL
  zh: '`abcd98732 => abc:d98:732`'
- en: pqrn => p:qrn
  id: totrans-773
  prefs: []
  type: TYPE_NORMAL
  zh: '`pqrn => p:qrn`'
- en: qwerty12345678xyz => qw:ert:y12:345:678:xyz
  id: totrans-774
  prefs: []
  type: TYPE_NORMAL
  zh: '`qwerty12345678xyz => qw:ert:y12:345:678:xyz`'
- en: 123 => 123
  id: totrans-775
  prefs: []
  type: TYPE_NORMAL
  zh: '`123 => 123`'
- en: 'As you can see, this code places a colon in every third position, going from
    right to left. Let''s see what happens during the matching of the regular expression:
    (?!^) is a negative lookahead to avoid matching at the position.'
  id: totrans-776
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，此代码在从右到左的每个第三个位置放置冒号。让我们看看正则表达式匹配过程中会发生什么：(?!^) 是一个负前瞻，用于避免在当前位置匹配。
- en: '(?=(.{3})+$) is a positive lookahead that finds all the positions that have
    one or more three-character sets, ahead of the current position. This will first
    match the position where the first : has to be inserted, then the second, and
    so on. This may at first seem like something contradicting with atomic groups
    and the non-backtracking behaviour of a lookahead group. But it essentially is
    not. It is not contradicting because the lookahead itself is not backtracking.
    The regular expression matching is backtracking and evaluates the lookahead assertion
    again and again for each and every character position.'
  id: totrans-777
  prefs: []
  type: TYPE_NORMAL
  zh: '`(?=(.{3})+$)` 是一个正前瞻，它找到所有当前位置之前有一个或多个三个字符集的位置。这将首先匹配第一个冒号必须插入的位置，然后是第二个，依此类推。这最初可能看起来与原子组和前瞻组的非回溯行为相矛盾。但实际上并非如此。它并不矛盾，因为前瞻本身并不回溯。正则表达式匹配是回溯的，并且会反复评估前瞻断言，针对每个和每个字符位置。'
- en: Now, suppose that we have to replace all the commas that are outside the innermost
    parentheses with a semi-colon, assuming all the parentheses are balanced, not
    nested, and unescaped in the input text.
  id: totrans-778
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，假设我们必须将最内层括号外的所有逗号替换为分号，假设所有括号都是平衡的、不嵌套且在输入文本中未转义。
- en: 'To solve this problem, we can use a negative lookahead expression, such as
    this one:'
  id: totrans-779
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，我们可以使用一个负前瞻表达式，如下所示：
- en: ',(?![^()]*\))'
  id: totrans-780
  prefs: []
  type: TYPE_NORMAL
  zh: '`,(?![^()]*\)`'
- en: This one matches a comma followed by a negative lookahead assertion that asserts
    false when we have a right ) following zero or more characters and not containing
    (
  id: totrans-781
  prefs: []
  type: TYPE_NORMAL
  zh: 这个模式匹配一个逗号后跟一个负前瞻断言，当我们在零个或多个字符后跟一个右括号()时，该断言为假，且不包含左括号(
- en: and ). Since we know that ( and ) are balanced, this check ensures that we match
    a comma that is outside ( and ).
  id: totrans-782
  prefs: []
  type: TYPE_NORMAL
  zh: '`and )`。由于我们知道括号()是平衡的，这个检查确保我们匹配一个位于括号外的逗号。'
- en: 'Here is the full code listing to see this regex in action: package example.regex;'
  id: totrans-783
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是查看此正则表达式如何工作的完整代码列表：`package example.regex;`
- en: import java.util.regex.*;
  id: totrans-784
  prefs: []
  type: TYPE_NORMAL
  zh: '`import java.util.regex.*;`'
- en: class LookAroundExample2
  id: totrans-785
  prefs: []
  type: TYPE_NORMAL
  zh: '`class LookAroundExample2`'
- en: '{'
  id: totrans-786
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: public static void main (String[] args)
  id: totrans-787
  prefs: []
  type: TYPE_NORMAL
  zh: '`public static void main (String[] args)`'
- en: '{'
  id: totrans-788
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: String input = "var1,var2,var3 (var1,var2,var3) var4,var5,var6 (var4,var5,var6)";
    final Pattern p = Pattern.compile(",(?![^()]*\\))"); Matcher m = p.matcher(input);
  id: totrans-789
  prefs: []
  type: TYPE_NORMAL
  zh: '`String input = "var1,var2,var3 (var1,var2,var3) var4,var5,var6 (var4,var5,var6)";
    `final Pattern p = Pattern.compile(",(?![^()]*\\))");` Matcher m = p.matcher(input);'
- en: System.out.printf("%s%n", m.replaceAll(";"));
  id: totrans-790
  prefs: []
  type: TYPE_NORMAL
  zh: '`System.out.printf("%s%n", m.replaceAll(";"));`'
- en: '}'
  id: totrans-791
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-792
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: 'When we run the preceding code, it gives the following output, replacing all
    the commas outside the parentheses:'
  id: totrans-793
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行前面的代码时，它给出以下输出，替换括号外的所有逗号：
- en: 'var1;var2;var3 (var1,var2,var3) var4;var5;var6 (var4,var5,var6) Next, suppose
    that we need to validate a password string with the following constraints:'
  id: totrans-794
  prefs: []
  type: TYPE_NORMAL
  zh: var1;var2;var3 (var1,var2,var3) var4;var5;var6 (var4,var5,var6) 接下来，假设我们需要验证一个密码字符串，并满足以下约束条件：
- en: At least one uppercase English letter
  id: totrans-795
  prefs: []
  type: TYPE_NORMAL
  zh: 至少一个英文大写字母
- en: At least one lowercase English letter
  id: totrans-796
  prefs: []
  type: TYPE_NORMAL
  zh: 至少一个英文小写字母
- en: At least one digit
  id: totrans-797
  prefs: []
  type: TYPE_NORMAL
  zh: 至少一个数字
- en: At least one special character (non-word character)
  id: totrans-798
  prefs: []
  type: TYPE_NORMAL
  zh: 至少一个特殊字符（非单词字符）
- en: Minimum six and maximum twelve in length
  id: totrans-799
  prefs: []
  type: TYPE_NORMAL
  zh: 长度至少为六，最大为十二
- en: No whitespace allowed anywhere
  id: totrans-800
  prefs: []
  type: TYPE_NORMAL
  zh: 任何地方都不允许有空格
- en: 'Here is the solution:'
  id: totrans-801
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是解决方案：
- en: 'To check for six to twelve non-whitespace characters, we can use the following:'
  id: totrans-802
  prefs: []
  type: TYPE_NORMAL
  zh: 要检查六到十二个非空白字符，我们可以使用以下表达式：
- en: ^\S{6,12}$
  id: totrans-803
  prefs: []
  type: TYPE_NORMAL
  zh: '`^\S{6,12}$`'
- en: For the remaining conditions, we need to use multiple lookahead expressions,
    one for each condition. Let's build the lookahead patterns one by one.
  id: totrans-804
  prefs: []
  type: TYPE_NORMAL
  zh: 对于剩余的条件，我们需要使用多个前瞻表达式，每个条件一个。让我们逐一构建前瞻模式。
- en: 'To ensure that there is at least one uppercase letter in the input, we can
    use this lookahead assertion:'
  id: totrans-805
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保输入中至少有一个大写字母，我们可以使用以下前瞻断言：
- en: (?=.*[A-Z])
  id: totrans-806
  prefs: []
  type: TYPE_NORMAL
  zh: (?=.*[A-Z])
- en: This means that we have to check for the presence of an uppercase letter after
    zero or more characters.
  id: totrans-807
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着我们必须检查在零个或多个字符之后是否存在大写字母。
- en: 'Similarly, to ensure that there is at least one lowercase letter in the input,
    we can use this lookahead assertion:'
  id: totrans-808
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，为了确保输入中至少有一个小写字母，我们可以使用以下前瞻断言：
- en: (?=.*[a-z])
  id: totrans-809
  prefs: []
  type: TYPE_NORMAL
  zh: (?=.*[a-z])
- en: 'Similarly, to ensure there is at least one digit in the input, we can use the
    following: (?=.*\d)'
  id: totrans-810
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，为了确保输入中至少有一个数字，我们可以使用以下：(?=.*\d)
- en: 'Similarly, to ensure there is at least one non-word character in the input,
    we can use the following:'
  id: totrans-811
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，为了确保输入中至少有一个非单词字符，我们可以使用以下：
- en: (?=.*\W)
  id: totrans-812
  prefs: []
  type: TYPE_NORMAL
  zh: (?=.*\W)
- en: 'As mentioned earlier, the order of these lookahead patterns does not matter,
    so we keep them in any order in our regular expression. Putting it all together,
    our final regular expression will be as follows:'
  id: totrans-813
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，这些前瞻模式的顺序并不重要，所以我们可以在正则表达式中以任何顺序保持它们。将所有这些放在一起，我们的最终正则表达式将如下所示：
- en: ^(?=.*[A-Z])(?=.*[a-z])(?=.*\d)(?=.*\W)\S{6,12}$
  id: totrans-814
  prefs: []
  type: TYPE_NORMAL
  zh: ^(?=.*[A-Z])(?=.*[a-z])(?=.*\d)(?=.*\W)\S{6,12}$
- en: 'Here is the full Java code to make this regex work: package example.regex;'
  id: totrans-815
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是使这个正则表达式工作的完整Java代码：package example.regex;
- en: import java.util.regex.*;
  id: totrans-816
  prefs: []
  type: TYPE_NORMAL
  zh: import java.util.regex.*;
- en: class LookAroundPasswordValidation
  id: totrans-817
  prefs: []
  type: TYPE_NORMAL
  zh: class LookAroundPasswordValidation
- en: '{'
  id: totrans-818
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: public static void main (String[] args)
  id: totrans-819
  prefs: []
  type: TYPE_NORMAL
  zh: public static void main (String[] args)
- en: '{'
  id: totrans-820
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: // build a Pattern using our regex
  id: totrans-821
  prefs: []
  type: TYPE_NORMAL
  zh: // 使用我们的正则表达式构建Pattern
- en: final Pattern p = Pattern.compile(
  id: totrans-822
  prefs: []
  type: TYPE_NORMAL
  zh: final Pattern p = Pattern.compile(
- en: '"^(?=.*[A-Z])(?=.*[a-z])(?=.*\\d)(?=.*\\W)\\S{6,12}$" );'
  id: totrans-823
  prefs: []
  type: TYPE_NORMAL
  zh: '"^(?=.*[A-Z])(?=.*[a-z])(?=.*\\d)(?=.*\\W)\\S{6,12}$" );'
- en: // input strings to be tested against our regex
  id: totrans-824
  prefs: []
  type: TYPE_NORMAL
  zh: // 要测试的输入字符串
- en: String[] inputs = { "abZ#45", "$$$f5P###", "abc123", "xyz-7612",
  id: totrans-825
  prefs: []
  type: TYPE_NORMAL
  zh: String[] inputs = { "abZ#45", "$$$f5P###", "abc123", "xyz-7612",
- en: '"AbC@#$qwer", "xYz@#$ 1278" };'
  id: totrans-826
  prefs: []
  type: TYPE_NORMAL
  zh: '"AbC@#$qwer", "xYz@#$ 1278" };'
- en: 'for (String s: inputs)'
  id: totrans-827
  prefs: []
  type: TYPE_NORMAL
  zh: 'for (String s: inputs)'
- en: '{'
  id: totrans-828
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: Matcher m = p.matcher( s );
  id: totrans-829
  prefs: []
  type: TYPE_NORMAL
  zh: Matcher m = p.matcher( s );
- en: System.out.printf( "%s => %s%n", s, m.matches() );
  id: totrans-830
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.printf( "%s => %s%n", s, m.matches() );
- en: '}'
  id: totrans-831
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-832
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-833
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: 'After compiling and running this code, we will get the following output: abZ#45
    => true'
  id: totrans-834
  prefs: []
  type: TYPE_NORMAL
  zh: 编译并运行此代码后，我们将得到以下输出：abZ#45 => true
- en: $$$f5P### => true
  id: totrans-835
  prefs: []
  type: TYPE_NORMAL
  zh: $$$f5P### => true
- en: abc123 => false
  id: totrans-836
  prefs: []
  type: TYPE_NORMAL
  zh: abc123 => false
- en: xyz-7612 => false
  id: totrans-837
  prefs: []
  type: TYPE_NORMAL
  zh: xyz-7612 => false
- en: AbC@#$qwer => false
  id: totrans-838
  prefs: []
  type: TYPE_NORMAL
  zh: AbC@#$qwer => false
- en: xYz@#$1278 => false
  id: totrans-839
  prefs: []
  type: TYPE_NORMAL
  zh: xYz@#$1278 => false
- en: This output basically shows a true value for all the strings that pass all our
    password rules and false, otherwise.
  id: totrans-840
  prefs: []
  type: TYPE_NORMAL
  zh: 这个输出基本上显示了所有通过我们密码规则的所有字符串的true值，否则为false。
- en: '**Capturing text from**'
  id: totrans-841
  prefs: []
  type: TYPE_NORMAL
  zh: '**捕获文本来源**'
- en: '**overlapping matches**'
  id: totrans-842
  prefs: []
  type: TYPE_NORMAL
  zh: '**重叠匹配**'
- en: Lookahead patterns are also very useful for situations where we want to match
    and capture text from overlapping matches.
  id: totrans-843
  prefs: []
  type: TYPE_NORMAL
  zh: 前瞻模式在需要匹配和捕获重叠匹配文本的情况下也非常有用。
- en: 'Let''s consider the following input string as an example:'
  id: totrans-844
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑以下输入字符串作为示例：
- en: thathathisthathathatis
  id: totrans-845
  prefs: []
  type: TYPE_NORMAL
  zh: thathathisthathatis
- en: Suppose that we need to count the occurrence of the string, that, in this input,
    including all overlapping occurrences.
  id: totrans-846
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们需要计算字符串"that"在这个输入中包括所有重叠出现的出现次数。
- en: 'Note that there are three independent that substrings in the input string,
    but there are two additional overlapping matches that we need to match and count.
    Here are the start-end positions of overlapping the substring that:'
  id: totrans-847
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，输入字符串中有三个独立的"that"子字符串，但还有两个额外的重叠匹配需要匹配和计数。以下是重叠子字符串"that"的起始-结束位置：
- en: Positions 0-3 3-6 10-13 13-16 16-19
  id: totrans-848
  prefs: []
  type: TYPE_NORMAL
  zh: 位置 0-3 3-6 10-13 13-16 16-19
- en: A simple search using the regex that will give us a match count of three because
    we miss out all the overlapping matches. To be able to match the overlapping matches,
    we need to use the lookahead pattern because lookahead patterns are zero-length.
  id: totrans-849
  prefs: []
  type: TYPE_NORMAL
  zh: 使用正则表达式进行简单搜索将给出三个匹配计数，因为我们遗漏了所有重叠的匹配。为了能够匹配重叠的匹配项，我们需要使用前瞻模式，因为前瞻模式是零长度的。
- en: 'These patterns don''t consume any characters; they just assert the presence
    of the required text ahead, based on the patterns used inside the lookahead, and
    the current position doesn''t change. So, the solution is to use a lookahead regex
    as follows: (?=that)'
  id: totrans-850
  prefs: []
  type: TYPE_NORMAL
  zh: 这些模式不会消耗任何字符；它们只是根据前瞻中使用的模式断言所需文本的存在，并且当前位置不会改变。因此，解决方案是使用以下前瞻正则表达式：(?=that)
- en: 'Here is the full code to see this regex working in action: package example.regex;'
  id: totrans-851
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是完整的代码，以查看这个正则表达式在实际操作中的效果：package example.regex;
- en: import java.util.regex.Matcher;
  id: totrans-852
  prefs: []
  type: TYPE_NORMAL
  zh: import java.util.regex.Matcher;
- en: import java.util.regex.Pattern;
  id: totrans-853
  prefs: []
  type: TYPE_NORMAL
  zh: import java.util.regex.Pattern;
- en: class LookaheadOverlapping
  id: totrans-854
  prefs: []
  type: TYPE_NORMAL
  zh: class LookaheadOverlapping
- en: '{'
  id: totrans-855
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: public static void main (String[] args)
  id: totrans-856
  prefs: []
  type: TYPE_NORMAL
  zh: public static void main (String[] args)
- en: '{'
  id: totrans-857
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: final String kw = "that";
  id: totrans-858
  prefs: []
  type: TYPE_NORMAL
  zh: final String kw = "that";
- en: final String regex = "(?=" + kw+ ")"; final String string = "thathathisthathathatis";
    final Pattern pattern = Pattern.compile(regex);
  id: totrans-859
  prefs: []
  type: TYPE_NORMAL
  zh: final String regex = "(?=" + kw+ ")"; final String string = "thathathisthathathatis";
    final Pattern pattern = Pattern.compile(regex);
- en: final Matcher matcher = pattern.matcher(string);
  id: totrans-860
  prefs: []
  type: TYPE_NORMAL
  zh: final Matcher matcher = pattern.matcher(string);
- en: int count = 0; while (matcher.find())
  id: totrans-861
  prefs: []
  type: TYPE_NORMAL
  zh: int count = 0; while (matcher.find())
- en: '{'
  id: totrans-862
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: 'System.out.printf("Start: %d\tEnd:%d%n",'
  id: totrans-863
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.printf("开始：%d\t结束：%d%n",
- en: matcher.start(), matcher.start() + kw.length() -1);
  id: totrans-864
  prefs: []
  type: TYPE_NORMAL
  zh: matcher.start(), matcher.start() + kw.length() -1);
- en: count++;
  id: totrans-865
  prefs: []
  type: TYPE_NORMAL
  zh: count++;
- en: '}'
  id: totrans-866
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: 'System.out.printf("Match count: %d%n", count);'
  id: totrans-867
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.printf("匹配计数：%d%n", count);
- en: '}'
  id: totrans-868
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-869
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: 'Once we run and compile the preceding class, we will get the following output:
    Start: 0 End:3'
  id: totrans-870
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们运行并编译前面的类，我们将得到以下输出：开始：0 结束：3
- en: 'Start: 3 End:6'
  id: totrans-871
  prefs: []
  type: TYPE_NORMAL
  zh: 开始：3 结束：6
- en: 'Start: 10 End:13'
  id: totrans-872
  prefs: []
  type: TYPE_NORMAL
  zh: 开始：10 结束：13
- en: 'Start: 13 End:16'
  id: totrans-873
  prefs: []
  type: TYPE_NORMAL
  zh: 开始：13 结束：16
- en: 'Start: 16 End:19'
  id: totrans-874
  prefs: []
  type: TYPE_NORMAL
  zh: 开始：16 结束：19
- en: 'Match count: 5'
  id: totrans-875
  prefs: []
  type: TYPE_NORMAL
  zh: 匹配计数：5
- en: You can see from this output that all the Start, End positions of the overlapping
    matches and, more importantly, the count of the overlapping matches, which is
    5\.
  id: totrans-876
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从这个输出中看到所有重叠匹配的 Start、End 位置，更重要的是，重叠匹配的计数，即 5。
- en: 'Here is another code listing that finds all the three character strings that
    have ''a'' as the middle letter and the same word character before and after the
    letter ''a''. For example, bab, zaz, kak, dad, 5a5, and _a_ should be matched:'
  id: totrans-877
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是另一个代码示例，它查找所有以 'a' 为中间字母，且在字母 'a' 前后都有相同单词字符的三个字符字符串。例如，bab、zaz、kak、dad、5a5
    和 _a_ 应该被匹配：
- en: package example.regex;
  id: totrans-878
  prefs: []
  type: TYPE_NORMAL
  zh: package example.regex;
- en: import java.util.regex.Matcher;
  id: totrans-879
  prefs: []
  type: TYPE_NORMAL
  zh: import java.util.regex.Matcher;
- en: import java.util.regex.Pattern;
  id: totrans-880
  prefs: []
  type: TYPE_NORMAL
  zh: import java.util.regex.Pattern;
- en: class LookaheadOverlappingMatches
  id: totrans-881
  prefs: []
  type: TYPE_NORMAL
  zh: class LookaheadOverlappingMatches
- en: '{'
  id: totrans-882
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: public static void main(String[] args)
  id: totrans-883
  prefs: []
  type: TYPE_NORMAL
  zh: public static void main(String[] args)
- en: '{'
  id: totrans-884
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: final String regex = "(?=(\\w)a\\1)";
  id: totrans-885
  prefs: []
  type: TYPE_NORMAL
  zh: final String regex = "(?=(\\w)a\\1)";
- en: final String string = "5a5akaktjzazbebbobabababsab"; final Matcher matcher =
    Pattern.compile(regex)
  id: totrans-886
  prefs: []
  type: TYPE_NORMAL
  zh: final String string = "5a5akaktjzazbebbobabababsab"; final Matcher matcher =
    Pattern.compile(regex)
- en: .matcher(string);
  id: totrans-887
  prefs: []
  type: TYPE_NORMAL
  zh: .matcher(string);
- en: int count = 0; while (matcher.find())
  id: totrans-888
  prefs: []
  type: TYPE_NORMAL
  zh: int count = 0; while (matcher.find())
- en: '{'
  id: totrans-889
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: final int start = matcher.start();
  id: totrans-890
  prefs: []
  type: TYPE_NORMAL
  zh: final int start = matcher.start();
- en: final int end = start + 2;
  id: totrans-891
  prefs: []
  type: TYPE_NORMAL
  zh: final int end = start + 2;
- en: 'System.out.printf("Start: %2d\tEnd:%2d %s%n",'
  id: totrans-892
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.printf("开始：%2d\t结束：%2d %s%n",
- en: start, end, string.substring(start,end+1));
  id: totrans-893
  prefs: []
  type: TYPE_NORMAL
  zh: start, end, string.substring(start,end+1));
- en: count++;
  id: totrans-894
  prefs: []
  type: TYPE_NORMAL
  zh: count++;
- en: '}'
  id: totrans-895
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: 'System.out.printf("Match count: %d%n", count);'
  id: totrans-896
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.printf("匹配计数：%d%n", count);
- en: '}'
  id: totrans-897
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-898
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: 'This code generates the following output:'
  id: totrans-899
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码生成以下输出：
- en: 'Start: 0 End: 2 5a5'
  id: totrans-900
  prefs: []
  type: TYPE_NORMAL
  zh: 开始：0 结束：2 5a5
- en: 'Start: 4 End: 6 kak'
  id: totrans-901
  prefs: []
  type: TYPE_NORMAL
  zh: 开始：4 结束：6 kak
- en: 'Start: 9 End:11 zaz'
  id: totrans-902
  prefs: []
  type: TYPE_NORMAL
  zh: 开始：9 结束：11 zaz
- en: 'Start: 17 End:19 bab'
  id: totrans-903
  prefs: []
  type: TYPE_NORMAL
  zh: 开始：17 结束：19 bab
- en: 'Start: 19 End:21 bab'
  id: totrans-904
  prefs: []
  type: TYPE_NORMAL
  zh: 开始：19 结束：21 bab
- en: 'Start: 21 End:23 bab'
  id: totrans-905
  prefs: []
  type: TYPE_NORMAL
  zh: 开始：21 结束：23 bab
- en: 'Match count: 6'
  id: totrans-906
  prefs: []
  type: TYPE_NORMAL
  zh: 匹配计数：6
- en: '**Be careful with capturing**'
  id: totrans-907
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意捕获**'
- en: '**groups inside a lookahead or**'
  id: totrans-908
  prefs: []
  type: TYPE_NORMAL
  zh: '**前瞻或原子组内的组**'
- en: '**lookbehind atomic group**'
  id: totrans-909
  prefs: []
  type: TYPE_NORMAL
  zh: '**向后原子组**'
- en: You learned to use capturing groups inside lookahead or lookbehind patterns
    in the preceding examples. However, you must remember that lookaround expressions
    are zero-width atomic groups. The regex engine exits from these groups as soon
    as an assertion is evaluated to true or false. Due to this fact, there is no backtracking
    inside these groups.
  id: totrans-910
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，您学习了如何在前瞻或向后查找模式中使用捕获组。然而，您必须记住，前瞻表达式是零宽度的原子组。正则表达式引擎在评估断言为真或假后立即退出这些组。由于这个原因，这些组内没有回溯。
- en: 'Consider the following three regular expressions. The first one is without
    any lookahead or atomic group, the second regex uses a lookahead expression, and
    the third regex uses an atomic group. Note that in each of the regex patterns,
    we use a capturing group to match and capture zero or more word characters inside
    the outer group:'
  id: totrans-911
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下三个正则表达式。第一个没有使用任何前瞻或原子组，第二个正则表达式使用前瞻表达式，第三个正则表达式使用原子组。请注意，在每个正则表达式模式中，我们使用捕获组来匹配和捕获外部组内的零个或多个单词字符：
- en: '#(?:(\w*))\w*_\1'
  id: totrans-912
  prefs: []
  type: TYPE_NORMAL
  zh: '#(?:(\w*))\w*_\1'
- en: '#(?=(\w*))\w*_\1'
  id: totrans-913
  prefs: []
  type: TYPE_NORMAL
  zh: '#(?=(\w*))\w*_\1'
- en: '#(?>(\w*))\w*_\1'
  id: totrans-914
  prefs: []
  type: TYPE_NORMAL
  zh: '#(?>(\w*))\w*_\1'
- en: 'Suppose that we apply the preceding three regex patterns against the following
    input:'
  id: totrans-915
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们将前面的三个正则表达式模式应用于以下输入：
- en: '#abc_abc'
  id: totrans-916
  prefs: []
  type: TYPE_NORMAL
  zh: '#abc_abc'
- en: 'The first regex, #(?:(\w+)).*_\1, will find a successful match with group 1
    as "abc".'
  id: totrans-917
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个正则表达式，#(?:(\w+)).*_\1，将找到以组 1 为 "abc" 的成功匹配。
- en: Next, it matches _ and back-references \1 to complete the match. Since the capturing
    group (\w*) initially matches the complete input, "abc_abc", the regex engine
    backtracks multiple times to make this a successful match.
  id: totrans-918
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，它匹配 _ 和反向引用 \1 以完成匹配。由于捕获组 (\w*) 最初匹配整个输入 "abc_abc"，正则表达式引擎多次回溯以使这次匹配成功。
- en: The second regex will fail to match because (\w+) inside the lookahead will
    match and capture "abc_abc", and when the regex engine exits the lookahead group,
    it is not able to find a match with .*_\1, as there is no further input and the
    engine won't backtrack to complete the match like it does in the first regex.
  id: totrans-919
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个正则表达式将无法匹配，因为 lookahead 中的 (\w+) 将匹配并捕获 "abc_abc"，当正则表达式引擎退出 lookahead 组时，它无法找到与
    .*_\1 匹配的匹配项，因为没有更多的输入，并且引擎不会像第一个正则表达式那样回溯以完成匹配。
- en: The third regex with an atomic group will also fail to match due to the same
    reason; the regex engine won't backtrack after matching the string inside an atomic
    group.
  id: totrans-920
  prefs: []
  type: TYPE_NORMAL
  zh: 由于相同的原因，带有原子组的第三个正则表达式也将失败匹配；正则表达式引擎在匹配原子组内的字符串后不会回溯。
- en: '**Lookbehind limitations in**'
  id: totrans-921
  prefs: []
  type: TYPE_NORMAL
  zh: '**查找限制在**'
- en: '**Java regular expressions**'
  id: totrans-922
  prefs: []
  type: TYPE_NORMAL
  zh: '**Java 正则表达式**'
- en: Like many other regular expression engines, the Java regex engine does not allow
    a variable-length text without an obvious maximum length match in the lookbehind
    regex pattern. This means that we cannot use the * or + quantifiers in a lookbehind
    pattern. However, the Java regex engine allows for limited or finite repetition
    in a lookbehind regex. This gives us a workaround for doing so in Java regular
    expressions by using limiting quantifiers in lookbehind expressions.
  id: totrans-923
  prefs: []
  type: TYPE_NORMAL
  zh: 与许多其他正则表达式引擎一样，Java 正则表达式引擎不允许在查找正则表达式模式中没有明显最大长度匹配的变长文本。这意味着我们无法在查找模式中使用 *
    或 + 量词。然而，Java 正则表达式引擎允许在查找正则表达式中进行有限的或有限的重复。这使我们能够在 Java 正则表达式中通过使用限制量词在查找表达式中解决这个问题。
- en: 'This means that we cannot use the following lookbehind regex to check filenames
    ending with extensions:'
  id: totrans-924
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着我们无法使用以下查找正则表达式来检查以扩展名结尾的文件名：
- en: (?<=\w\.\w+)$
  id: totrans-925
  prefs: []
  type: TYPE_NORMAL
  zh: (?<=\w\.\w+)$
- en: 'However, we could change the preceding pattern to the following with a finite
    repetition, and now this pattern will be allowed by the Java regex engine: (?<=\w\.\w{1,99})$'
  id: totrans-926
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们可以将前面的模式更改为以下有限重复的模式，现在这个模式将允许 Java 正则表达式引擎接受：(?<=\w\.\w{1,99})$
- en: However, it limits the number of word characters in the lookbehind after the
    dot to be from 1 to 99 instead of open-ended one or more word characters, as is
    the case with the
  id: totrans-927
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，它将点号之后查找中的单词字符数量限制在 1 到 99 之间，而不是像其他情况那样是开放式的零个或多个单词字符。
- en: + quantifier. However, you should use such a feature with caution and check
    the performance of the resulting regular expression. The Java lookbehind implementation
    also had quite a few bugs in the earlier versions. Some of these bugs have been
    resolved but one can still get unexpected results while using complex lookbehind
    regular expressions in Java.
  id: totrans-928
  prefs: []
  type: TYPE_NORMAL
  zh: + 量词。然而，你应该谨慎使用此类功能，并检查生成的正则表达式的性能。Java 的后视查找实现在前几个版本中也有不少错误。其中一些错误已经得到解决，但使用
    Java 中的复杂后视查找正则表达式时，仍然可能会得到意外结果。
- en: 'Java 9, however, allows regex patterns without an obvious maximum-length restriction
    in lookbehind assertions. This will allow programmers to use the lookbehind regex
    patterns without any maximum length match, such as the following regex in the
    previous example:'
  id: totrans-929
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，Java 9 允许在查找断言中没有明显的最大长度限制的正则表达式模式。这将允许程序员使用没有最大长度匹配的后视正则表达式模式，例如前一个示例中的以下正则表达式：
- en: (?<=\w\.\w+)$
  id: totrans-930
  prefs: []
  type: TYPE_NORMAL
  zh: (?<=\w\.\w+)$
- en: '**Summary**'
  id: totrans-931
  prefs: []
  type: TYPE_NORMAL
  zh: '**总结**'
- en: In this chapter, we learned zero-width assertions and how they are crucial for
    solving some important matching problems. We discussed the boundary matcher, \G,
    and its usefulness in solving some problems. We discovered the idea behind atomic
    groups and understood how they can improve the overall regex performance. Then,
    we covered all the important lookahead and lookbehind patterns. We covered some
    interesting matching, validation, and splitting problems that are solved using
    lookarounds.
  id: totrans-932
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了零宽断言及其在解决一些重要匹配问题中的关键作用。我们讨论了边界匹配器 \G 及其在解决一些问题中的有用性。我们发现了原子组的背后思想，并了解了它们如何提高整体正则表达式性能。然后，我们涵盖了所有重要的前瞻和后视模式。我们涵盖了使用查找的一些有趣的匹配、验证和分割问题。
- en: In the next chapter, we will continue to learn advanced concepts of Java regular
    expressions, such as union and intersection within character classes, and negated
    character classes.
  id: totrans-933
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将继续学习 Java 正则表达式的先进概念，例如字符类内的联合和交集，以及否定字符类。
- en: '**Understanding the Union,**'
  id: totrans-934
  prefs: []
  type: TYPE_NORMAL
  zh: '**理解联合，**'
- en: '**Intersection, and**'
  id: totrans-935
  prefs: []
  type: TYPE_NORMAL
  zh: '**交集，和**'
- en: '**Subtraction of Character**'
  id: totrans-936
  prefs: []
  type: TYPE_NORMAL
  zh: '**字符的减法**'
- en: '**Classes**'
  id: totrans-937
  prefs: []
  type: TYPE_NORMAL
  zh: '**类**'
- en: Some regular expression engines allow composite character classes, or character
    classes inside other character classes. The Java regular expression engine also
    supports many of these features, and we will discuss these features in this chapter.
  id: totrans-938
  prefs: []
  type: TYPE_NORMAL
  zh: 一些正则表达式引擎允许组合字符类，或者字符类内部包含其他字符类。Java正则表达式引擎也支持这些特性中的许多，我们将在本章中讨论这些特性。
- en: 'We will cover the following topics in this chapter:'
  id: totrans-939
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们将涵盖以下主题：
- en: The union of character classes
  id: totrans-940
  prefs: []
  type: TYPE_NORMAL
  zh: 字符类的并集
- en: The intersection of character classes
  id: totrans-941
  prefs: []
  type: TYPE_NORMAL
  zh: 字符类的交集
- en: The subtraction of character classes
  id: totrans-942
  prefs: []
  type: TYPE_NORMAL
  zh: 字符类的减法
- en: The advantages of using composite character classes
  id: totrans-943
  prefs: []
  type: TYPE_NORMAL
  zh: 使用组合字符类的优点
- en: '**The union of character**'
  id: totrans-944
  prefs: []
  type: TYPE_NORMAL
  zh: '**字符的并集**'
- en: '**classes**'
  id: totrans-945
  prefs: []
  type: TYPE_NORMAL
  zh: '**类**'
- en: The union of character classes will match a character that would be matched
    by any of the composing character classes. Essentially, this is the definition
    of the union operation in general. In regular expressions, it is possible to create
    unions of character classes by simply writing a character class inside another.
  id: totrans-946
  prefs: []
  type: TYPE_NORMAL
  zh: 字符类的并集将匹配由任何组成字符类匹配的字符。本质上，这是并集运算的一般定义。在正则表达式中，可以通过在另一个字符类内写入字符类来创建字符类的并集。
- en: You may remember that character classes open with the [ character and close
    with the
  id: totrans-947
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能还记得，字符类以[字符开始，以]字符结束
- en: '] character, and we can list characters and character ranges between the opening
    and closing brackets.'
  id: totrans-948
  prefs: []
  type: TYPE_NORMAL
  zh: ']字符，我们可以在开闭括号之间列出字符和字符范围。'
- en: In addition to those, we can use other character sets inside the brackets, and
    the resulting set will be the union of all these character classes. This way,
    there is no union operator to create the composition of these character classes;
    we just simply write them inside each other.
  id: totrans-949
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这些，我们还可以在括号内使用其他字符集，并且结果集将是所有这些字符类的并集。这样，就没有并集运算符来创建这些字符类的组合；我们只需简单地将它们相互写入即可。
- en: 'For example, consider the following composite character class:'
  id: totrans-950
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，考虑以下组合字符类：
- en: '[A-D[PQR]]'
  id: totrans-951
  prefs: []
  type: TYPE_NORMAL
  zh: '[A-D[PQR]]'
- en: 'This matches any character in the range of A to D or any single character P,
    Q, or R. This regular expression can also be written as follows:'
  id: totrans-952
  prefs: []
  type: TYPE_NORMAL
  zh: 这将匹配A到D范围内的任何字符或单个字符P、Q或R。这个正则表达式也可以写成以下形式：
- en: '[A-DPQR]'
  id: totrans-953
  prefs: []
  type: TYPE_NORMAL
  zh: '[A-DPQR]'
- en: 'We can also create a union of more than two character classes, such as as in
    the following regular expression:'
  id: totrans-954
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以创建超过两个字符类的并集，例如以下正则表达式：
- en: '[A-D[P-S][X-Z]]'
  id: totrans-955
  prefs: []
  type: TYPE_NORMAL
  zh: '[A-D[P-S][X-Z]]'
- en: 'This matches any character in the range of A to D, any character in the range
    of P to S, or any character in the range from X to Z. This regular expression
    can also be written as follows:'
  id: totrans-956
  prefs: []
  type: TYPE_NORMAL
  zh: 这将匹配A到D范围内的任何字符，P到S范围内的任何字符，或者X到Z范围内的任何字符。这个正则表达式也可以写成以下形式：
- en: '[A-DP-SX-Z]'
  id: totrans-957
  prefs: []
  type: TYPE_NORMAL
  zh: '[A-DP-SX-Z]'
- en: The union of character classes can also be used with a negated inner character
    class, and this is where character class unions really start to shine and give
    us extra value.
  id: totrans-958
  prefs: []
  type: TYPE_NORMAL
  zh: 字符类的并集也可以与取反内部字符类一起使用，这正是字符类并集真正发光并给我们带来额外价值的地方。
- en: We get to see a good use of the union operation only when we use the union of
    various character classes with a negated character class.
  id: totrans-959
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只有在使用取反字符类与各种字符类的并集时，才能看到并集运算的良好应用。
- en: 'Let''s consider, for example, the following code listing on the union with
    a negated character class:'
  id: totrans-960
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，让我们考虑以下关于取反字符类并集的代码示例：
- en: package example.regex;
  id: totrans-961
  prefs: []
  type: TYPE_NORMAL
  zh: package example.regex;
- en: import java.util.regex.*;
  id: totrans-962
  prefs: []
  type: TYPE_NORMAL
  zh: import java.util.regex.*;
- en: public class UnionExample
  id: totrans-963
  prefs: []
  type: TYPE_NORMAL
  zh: public class UnionExample
- en: '{'
  id: totrans-964
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: public static void main(String[] args)
  id: totrans-965
  prefs: []
  type: TYPE_NORMAL
  zh: public static void main(String[] args)
- en: '{'
  id: totrans-966
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: final String re = "[#@.[^\\p{Punct}\\s]]";
  id: totrans-967
  prefs: []
  type: TYPE_NORMAL
  zh: final String re = "[#@.[^\\p{Punct}\\s]]";
- en: final String[] arr = new String[] {
  id: totrans-968
  prefs: []
  type: TYPE_NORMAL
  zh: final String[] arr = new String[] {
- en: '"A", "#", "@", "1", "5", " ", "\n", ":", ".", "a", "%", "-", "3"'
  id: totrans-969
  prefs: []
  type: TYPE_NORMAL
  zh: '"A", "#", "@", "1", "5", " ", "\n", ":", ".", "a", "%", "-", "3"'
- en: '};'
  id: totrans-970
  prefs: []
  type: TYPE_NORMAL
  zh: '};'
- en: 'for (String s: arr)'
  id: totrans-971
  prefs: []
  type: TYPE_NORMAL
  zh: 'for (String s: arr)'
- en: '{'
  id: totrans-972
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: System.out.printf("[%s] %s%n", s,
  id: totrans-973
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.printf("[%s] %s%n", s,
- en: '(s.matches(re) ? "matches" : "does not match"));'
  id: totrans-974
  prefs: []
  type: TYPE_NORMAL
  zh: '(s.matches(re) ? "matches" : "does not match"));'
- en: '}'
  id: totrans-975
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-976
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-977
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: 'This regex has the following negated character class:'
  id: totrans-978
  prefs: []
  type: TYPE_NORMAL
  zh: 这个正则表达式有以下取反字符类：
- en: '[^\\p{Punct}\\s]'
  id: totrans-979
  prefs: []
  type: TYPE_NORMAL
  zh: '[^\\p{Punct}\\s]'
- en: 'The preceding negated character class allows any character that is not a punctuation
    and not a space character. Now, suppose that we want to allow a few selected punctuation
    characters, @, #, and ., or in other words, the [@#.] character class. In this
    scenario, the union comes handy. We make a composite character class that uses
    a union of both these cases, as follows:'
  id: totrans-980
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的否定字符类允许任何既不是标点符号也不是空格字符的字符。现在，假设我们想要允许一些选定的标点符号字符，@、#和.，或者换句话说，是[@#.]字符类。在这种情况下，并集很有用。我们创建一个复合字符类，它使用这两种情况的并集，如下所示：
- en: '[#@.[^\\p{Punct}\\s]]'
  id: totrans-981
  prefs: []
  type: TYPE_NORMAL
  zh: '[#@.[^\\p{Punct}\\s]]'
- en: Now, this composite character class will allow the [@#.] characters, or any
    character that is not a punctuation and not a space character.
  id: totrans-982
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，这个复合字符类将允许[@#.]字符，或者任何既不是标点符号也不是空格字符的字符。
- en: 'Once we compile and run the preceding code, we''ll get the following output:'
  id: totrans-983
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们编译并运行前面的代码，我们将得到以下输出：
- en: '[A] matches'
  id: totrans-984
  prefs: []
  type: TYPE_NORMAL
  zh: '[A] 匹配'
- en: '[#] matches'
  id: totrans-985
  prefs: []
  type: TYPE_NORMAL
  zh: '[#] 匹配'
- en: '[@] matches'
  id: totrans-986
  prefs: []
  type: TYPE_NORMAL
  zh: '[@] 匹配'
- en: '[1] matches'
  id: totrans-987
  prefs: []
  type: TYPE_NORMAL
  zh: '[1] 匹配'
- en: '[5] matches'
  id: totrans-988
  prefs: []
  type: TYPE_NORMAL
  zh: '[5] 匹配'
- en: '[ ] does not match'
  id: totrans-989
  prefs: []
  type: TYPE_NORMAL
  zh: '[ ] 不匹配'
- en: '['
  id: totrans-990
  prefs: []
  type: TYPE_NORMAL
  zh: '['
- en: '] does not match'
  id: totrans-991
  prefs: []
  type: TYPE_NORMAL
  zh: '] 不匹配'
- en: '[:] does not match'
  id: totrans-992
  prefs: []
  type: TYPE_NORMAL
  zh: '[:] 不匹配'
- en: '[.] matches'
  id: totrans-993
  prefs: []
  type: TYPE_NORMAL
  zh: '[.] 匹配'
- en: '[a] matches'
  id: totrans-994
  prefs: []
  type: TYPE_NORMAL
  zh: '[a] 匹配'
- en: '[%] does not match'
  id: totrans-995
  prefs: []
  type: TYPE_NORMAL
  zh: '[%] 不匹配'
- en: '[-] does not match'
  id: totrans-996
  prefs: []
  type: TYPE_NORMAL
  zh: '[-] 不匹配'
- en: '[3] matches'
  id: totrans-997
  prefs: []
  type: TYPE_NORMAL
  zh: '[3] 匹配'
- en: You can see the output of "matches" for all the character sets that are not
    included inside our negated character class or allowed by the [#@.] character
    class. It returns
  id: totrans-998
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到对于所有不在我们的否定字符类内部或由[@#.]字符类允许的字符集，输出都是"matches"。它返回
- en: '"does not match" for all other cases.'
  id: totrans-999
  prefs: []
  type: TYPE_NORMAL
  zh: 对于所有其他情况，都不匹配。
- en: '**The intersection of character**'
  id: totrans-1000
  prefs: []
  type: TYPE_NORMAL
  zh: '**字符的交集**'
- en: '**classes**'
  id: totrans-1001
  prefs: []
  type: TYPE_NORMAL
  zh: '**类**'
- en: 'The intersection operation on character classes results in a composite class
    that contains every character allowed by **all** of its operand (inner) classes
    or, in other words, matches characters that belong to all the character classes
    in the composite character class pattern. The intersection operator is as follows:'
  id: totrans-1002
  prefs: []
  type: TYPE_NORMAL
  zh: 字符类的交集操作产生一个复合类，它包含所有其操作数（内部）类允许的字符，换句话说，匹配属于复合字符类模式中所有字符类的字符。交集操作符如下：
- en: '&&'
  id: totrans-1003
  prefs: []
  type: TYPE_NORMAL
  zh: '&&'
- en: 'For example, consider the following composite character class using the &&
    operator:'
  id: totrans-1004
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，考虑以下使用&&操作符的复合字符类：
- en: '[A-Z&&[PQR]]'
  id: totrans-1005
  prefs: []
  type: TYPE_NORMAL
  zh: '[A-Z&&[PQR]]'
- en: 'This matches any character that is in the range of A to Z and is one of the
    single P, Q, or R characters. However, the preceding regular expression can also
    be simply written as follows:'
  id: totrans-1006
  prefs: []
  type: TYPE_NORMAL
  zh: 这匹配任何在A到Z范围内的字符，并且是单个P、Q或R字符之一。然而，前面的正则表达式也可以简单地写成以下形式：
- en: '[PQR]'
  id: totrans-1007
  prefs: []
  type: TYPE_NORMAL
  zh: '[PQR]'
- en: 'The following composite character class using intersection matches the digits,
    5 and 6, since only these two digits belong to all the three character classes:'
  id: totrans-1008
  prefs: []
  type: TYPE_NORMAL
  zh: 以下使用交集的复合字符类匹配数字5和6，因为只有这两个数字属于所有三个字符类：
- en: '[1-7&&[3-6]&&[5-8]]'
  id: totrans-1009
  prefs: []
  type: TYPE_NORMAL
  zh: '[1-7&&[3-6]&&[5-8]]'
- en: 'To see this regex in action, let''s use this complete code: package example.regex;'
  id: totrans-1010
  prefs: []
  type: TYPE_NORMAL
  zh: 为了看到这个正则表达式的作用，让我们使用以下完整的代码：package example.regex;
- en: import java.util.regex.*;
  id: totrans-1011
  prefs: []
  type: TYPE_NORMAL
  zh: import java.util.regex.*;
- en: public class IntersectionExample
  id: totrans-1012
  prefs: []
  type: TYPE_NORMAL
  zh: public class IntersectionExample
- en: '{'
  id: totrans-1013
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: public static void main(String[] args)
  id: totrans-1014
  prefs: []
  type: TYPE_NORMAL
  zh: public static void main(String[] args)
- en: '{'
  id: totrans-1015
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: final Pattern p = Pattern.compile("[1-7&&[3-6]&&[5-8]]"); for (int i=0; i<10;
    i++)
  id: totrans-1016
  prefs: []
  type: TYPE_NORMAL
  zh: final Pattern p = Pattern.compile("[1-7&&[3-6]&&[5-8]]"); for (int i=0; i<10;
    i++)
- en: '{'
  id: totrans-1017
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: String s = String.valueOf(i);
  id: totrans-1018
  prefs: []
  type: TYPE_NORMAL
  zh: String s = String.valueOf(i);
- en: Matcher m = p.matcher(s);
  id: totrans-1019
  prefs: []
  type: TYPE_NORMAL
  zh: Matcher m = p.matcher(s);
- en: System.out.printf("[%s] %s%n", s,
  id: totrans-1020
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.printf("[%s] %s%n", s,
- en: '(m.matches() ? "matches" : "does not match"));'
  id: totrans-1021
  prefs: []
  type: TYPE_NORMAL
  zh: '(m.matches() ? "matches" : "does not match"));'
- en: '}'
  id: totrans-1022
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-1023
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-1024
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: 'When we compile and run the preceding code, we will see the following output:'
  id: totrans-1025
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们编译并运行前面的代码时，我们将看到以下输出：
- en: '[0] does not match'
  id: totrans-1026
  prefs: []
  type: TYPE_NORMAL
  zh: '[0] 不匹配'
- en: '[1] does not match'
  id: totrans-1027
  prefs: []
  type: TYPE_NORMAL
  zh: '[1] 不匹配'
- en: '[2] does not match'
  id: totrans-1028
  prefs: []
  type: TYPE_NORMAL
  zh: '[2] 不匹配'
- en: '[3] does not match'
  id: totrans-1029
  prefs: []
  type: TYPE_NORMAL
  zh: '[3] 不匹配'
- en: '[4] does not match'
  id: totrans-1030
  prefs: []
  type: TYPE_NORMAL
  zh: '[4] 不匹配'
- en: '[5] matches'
  id: totrans-1031
  prefs: []
  type: TYPE_NORMAL
  zh: '[5] 匹配'
- en: '[6] matches'
  id: totrans-1032
  prefs: []
  type: TYPE_NORMAL
  zh: '[6] 匹配'
- en: '[7] does not match'
  id: totrans-1033
  prefs: []
  type: TYPE_NORMAL
  zh: '[7] 不匹配'
- en: '[8] does not match'
  id: totrans-1034
  prefs: []
  type: TYPE_NORMAL
  zh: '[8] 不匹配'
- en: '[9] does not match'
  id: totrans-1035
  prefs: []
  type: TYPE_NORMAL
  zh: '[9] 不匹配'
- en: As you can see, it shows "matches" only for the digits, 5 and 6\.
  id: totrans-1036
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，它只对数字5和6显示"匹配"。
- en: 'Let''s take another example, which involves matching a non-whitespace character
    that is not a Unicode letter. We know we can use the following regex using a positive
    lookahead:'
  id: totrans-1037
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再举一个例子，它涉及到匹配一个非空白字符，且不是Unicode字母。我们知道我们可以使用以下正则表达式，通过正向先行断言：
- en: (?=\S)\P{L}
  id: totrans-1038
  prefs: []
  type: TYPE_NORMAL
  zh: (?=\S)\P{L}
- en: 'We can also use an intersection operation to write this example, as follows:'
  id: totrans-1039
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以使用交集操作来编写此示例，如下所示：
- en: '[\\S&&[\\P{L}]]'
  id: totrans-1040
  prefs: []
  type: TYPE_NORMAL
  zh: '[\\S&&[\\P{L}]]'
- en: Due to the use of the && operator here, it matches a character that satisfies
    both the properties, \S (non-whitespace) and \P{L} (non-letters).
  id: totrans-1041
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这里使用了 && 操作符，它匹配同时满足以下两个属性的字符，\S（非空白字符）和 \P{L}（非字母字符）。
- en: 'Note that the inner square brackets are optional when not using a negated character
    class in an intersection operation. Hence, the preceding regex can also be written
    as follows:'
  id: totrans-1042
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，当在交集操作中不使用否定字符类时，内部方括号是可选的。因此，前面的正则表达式也可以写成以下形式：
- en: '[\\S&&\\P{L}]'
  id: totrans-1043
  prefs: []
  type: TYPE_NORMAL
  zh: '[\\S&&\\P{L}]'
- en: 'Similarly, to match an uppercase Greek letter, we can use the intersection
    of the following two classes:'
  id: totrans-1044
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，为了匹配大写希腊字母，我们可以使用以下两个类的交集：
- en: '\p{InGreek}: This matches a character in the Greek block'
  id: totrans-1045
  prefs: []
  type: TYPE_NORMAL
  zh: '\p{InGreek}: 这匹配希腊字符块中的字符'
- en: '\p{Lu}: This matches an uppercase Unicode letter'
  id: totrans-1046
  prefs: []
  type: TYPE_NORMAL
  zh: '\p{Lu}: 这匹配一个上标 Unicode 字母'
- en: 'By combining these two character classes with intersection, we can make a single
    composite character class, as follows:'
  id: totrans-1047
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将这两个字符类与交集结合，我们可以创建一个单一的复合字符类，如下所示：
- en: '[\p{InGreek}&&[\p{Lu}]]'
  id: totrans-1048
  prefs: []
  type: TYPE_NORMAL
  zh: '[\p{InGreek}&&[\p{Lu}]]'
- en: 'To test the preceding regex, let''s pick some Greek letters and write a simple
    Java code, such as the following, to test our regex against the selected Greek
    letters: package example.regex;'
  id: totrans-1049
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试前面的正则表达式，让我们选择一些希腊字母，并编写一个简单的 Java 代码，如下所示，以测试所选希腊字母与我们的正则表达式是否匹配：package
    example.regex;
- en: import java.util.regex.*;
  id: totrans-1050
  prefs: []
  type: TYPE_NORMAL
  zh: import java.util.regex.*;
- en: public class UppercaseGreekIntersectionExample
  id: totrans-1051
  prefs: []
  type: TYPE_NORMAL
  zh: public class UppercaseGreekIntersectionExample
- en: '{'
  id: totrans-1052
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: public static void main(String[] args)
  id: totrans-1053
  prefs: []
  type: TYPE_NORMAL
  zh: public static void main(String[] args)
- en: '{'
  id: totrans-1054
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: final Pattern p = Pattern.compile("[\\p{InGreek}&&[\\p{Lu}]]"); final String[]
    arr = new String[] {
  id: totrans-1055
  prefs: []
  type: TYPE_NORMAL
  zh: final Pattern p = Pattern.compile("[\\p{InGreek}&&[\\p{Lu}]]"); final String[]
    arr = new String[] {
- en: '"Γ", "Δ", "Θ", "Ξ", "Π", "Σ", "Φ", "α", "β", "γ", "δ", "ε", "A", "P", "e",
    "r"'
  id: totrans-1056
  prefs: []
  type: TYPE_NORMAL
  zh: '"Γ", "Δ", "Θ", "Ξ", "Π", "Σ", "Φ", "α", "β", "γ", "δ", "ε", "A", "P", "e",
    "r"'
- en: '};'
  id: totrans-1057
  prefs: []
  type: TYPE_NORMAL
  zh: '};'
- en: 'for (String s: arr)'
  id: totrans-1058
  prefs: []
  type: TYPE_NORMAL
  zh: 'for (String s: arr)'
- en: '{'
  id: totrans-1059
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: Matcher m = p.matcher(s);
  id: totrans-1060
  prefs: []
  type: TYPE_NORMAL
  zh: Matcher m = p.matcher(s);
- en: System.out.printf("[%s] %s%n", s,
  id: totrans-1061
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.printf("[%s] %s%n", s,
- en: '(m.matches() ? "matches" : "does not match"));'
  id: totrans-1062
  prefs: []
  type: TYPE_NORMAL
  zh: '(m.matches() ? "matches" : "does not match"));'
- en: '}'
  id: totrans-1063
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-1064
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-1065
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: 'When we run the preceding class, it prints the following output:'
  id: totrans-1066
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行前面的类时，它将打印以下输出：
- en: '[Γ] matches'
  id: totrans-1067
  prefs: []
  type: TYPE_NORMAL
  zh: '[Γ] 匹配'
- en: '[Δ] matches'
  id: totrans-1068
  prefs: []
  type: TYPE_NORMAL
  zh: '[Δ] 匹配'
- en: '[Θ] matches'
  id: totrans-1069
  prefs: []
  type: TYPE_NORMAL
  zh: '[Θ] 匹配'
- en: '[Ξ] matches'
  id: totrans-1070
  prefs: []
  type: TYPE_NORMAL
  zh: '[Ξ] 匹配'
- en: '[Π] matches'
  id: totrans-1071
  prefs: []
  type: TYPE_NORMAL
  zh: '[Π] 匹配'
- en: '[Σ] matches'
  id: totrans-1072
  prefs: []
  type: TYPE_NORMAL
  zh: '[Σ] 匹配'
- en: '[Φ] matches'
  id: totrans-1073
  prefs: []
  type: TYPE_NORMAL
  zh: '[Φ] 匹配'
- en: '[α] does not match'
  id: totrans-1074
  prefs: []
  type: TYPE_NORMAL
  zh: '[α] 不匹配'
- en: '[β] does not match'
  id: totrans-1075
  prefs: []
  type: TYPE_NORMAL
  zh: '[β] 不匹配'
- en: '[γ] does not match'
  id: totrans-1076
  prefs: []
  type: TYPE_NORMAL
  zh: '[γ] 不匹配'
- en: '[δ] does not match'
  id: totrans-1077
  prefs: []
  type: TYPE_NORMAL
  zh: '[δ] 不匹配'
- en: '[ε] does not match'
  id: totrans-1078
  prefs: []
  type: TYPE_NORMAL
  zh: '[ε] 不匹配'
- en: '[A] does not match'
  id: totrans-1079
  prefs: []
  type: TYPE_NORMAL
  zh: '[A] 不匹配'
- en: '[P] does not match'
  id: totrans-1080
  prefs: []
  type: TYPE_NORMAL
  zh: '[P] 不匹配'
- en: '[e] does not match'
  id: totrans-1081
  prefs: []
  type: TYPE_NORMAL
  zh: '[e] 不匹配'
- en: '[r] does not match'
  id: totrans-1082
  prefs: []
  type: TYPE_NORMAL
  zh: '[r] 不匹配'
- en: As you can see, "matches" is only printed for the uppercase Greek letters. For
    all the other letters, it prints "does not match".
  id: totrans-1083
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，"matches" 只在打印大写希腊字母时打印。对于所有其他字母，它打印 "does not match"。
- en: '![Image 22](img/index-162_1.jpg)'
  id: totrans-1084
  prefs: []
  type: TYPE_IMG
  zh: '![图像 22](img/index-162_1.jpg)'
- en: '**The subtraction of character**'
  id: totrans-1085
  prefs: []
  type: TYPE_NORMAL
  zh: '**字符的减法**'
- en: '**classes**'
  id: totrans-1086
  prefs: []
  type: TYPE_NORMAL
  zh: '**类**'
- en: Suppose we have to match characters that belong to one class but not to another
    in a composite character class pattern. There is no separate operator for the
    subtraction operation. Subtraction is performed by using the intersection operator,
    &&, and a negated inner character class.
  id: totrans-1087
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们必须在复合字符类模式中匹配属于一个类但不属于另一个类的字符。没有单独的运算符用于减法操作。减法操作是通过使用交集运算符 && 和否定内部字符类来执行的。
- en: '*A regular expression is usually more readable if we write the larger set*
    *in front and the one we want to subtract from it after the && operator.*'
  id: totrans-1088
  prefs: []
  type: TYPE_NORMAL
  zh: '*如果我们将较大的集合写在 && 操作符之后，正则表达式通常更容易阅读。*'
- en: 'For example, consider the following composite character class:'
  id: totrans-1089
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，考虑以下复合字符类：
- en: '[0-9&&[^3-6]]'
  id: totrans-1090
  prefs: []
  type: TYPE_NORMAL
  zh: '[0-9&&[^3-6]]'
- en: 'It will match the digits, 0 to 9, except the digits, 3 to 6\. This character
    class can also be written as a union of two character classes:'
  id: totrans-1091
  prefs: []
  type: TYPE_NORMAL
  zh: 它将匹配数字，0 到 9，除了数字，3 到 6。这个字符类也可以写成两个字符类的并集：
- en: '[[0-2][7-9]]'
  id: totrans-1092
  prefs: []
  type: TYPE_NORMAL
  zh: '[[0-2][7-9]]'
- en: 'We can also just use a simple character class, as follows:'
  id: totrans-1093
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以只使用一个简单的字符类，如下所示：
- en: '[0-27-9]'
  id: totrans-1094
  prefs: []
  type: TYPE_NORMAL
  zh: '[0-27-9]'
- en: 'In order to match all the English consonant uppercase letters, we can subtract
    five vowels from uppercase letters, such as in the following regex:'
  id: totrans-1095
  prefs: []
  type: TYPE_NORMAL
  zh: 为了匹配所有的大写英文字母，我们可以从大写字母中减去五个元音字母，如下面的正则表达式所示：
- en: '[A-Z&&[^AEIOU]]'
  id: totrans-1096
  prefs: []
  type: TYPE_NORMAL
  zh: '[A-Z&&[^AEIOU]]'
- en: 'We can also reverse the order of the two sets used in the preceding regex and
    use the following regex:'
  id: totrans-1097
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以颠倒前面正则表达式中使用的两个集合的顺序，并使用以下正则表达式：
- en: '[[^AEIOU]&&A-Z]'
  id: totrans-1098
  prefs: []
  type: TYPE_NORMAL
  zh: '[[^AEIOU]&&A-Z]'
- en: 'Suppose we want to match all punctuation characters except four basic math
    operators: +, -, *, and /. We can use the following composite character class
    using the subtraction operation:'
  id: totrans-1099
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想要匹配所有标点符号字符，除了四个基本数学运算符：+、-、*和/。我们可以使用以下复合字符类，通过减法操作：
- en: '[\p{Punct}&&[^+*/-]]'
  id: totrans-1100
  prefs: []
  type: TYPE_NORMAL
  zh: '[\p{Punct}&&[^+*/-]]'
- en: 'Here is a test class that tests the preceding subtraction character class:
    package example.regex;'
  id: totrans-1101
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个测试类，用于测试前面的减法字符类：package example.regex;
- en: import java.util.regex.*;
  id: totrans-1102
  prefs: []
  type: TYPE_NORMAL
  zh: import java.util.regex.*;
- en: public class SubtractionExample
  id: totrans-1103
  prefs: []
  type: TYPE_NORMAL
  zh: public class SubtractionExample
- en: '{'
  id: totrans-1104
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: public static void main(String[] args)
  id: totrans-1105
  prefs: []
  type: TYPE_NORMAL
  zh: public static void main(String[] args)
- en: '{'
  id: totrans-1106
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: final Pattern p = Pattern.compile("[\\p{Punct}&&[^+*/-]]"); final String[] arr
    = new String[] {
  id: totrans-1107
  prefs: []
  type: TYPE_NORMAL
  zh: final Pattern p = Pattern.compile("[\\p{Punct}&&[^+*/-]]"); final String[] arr
    = new String[] {
- en: '"!", "@", "#", "$", "%", "+", "-", "*", "/", "1", "M", "d"'
  id: totrans-1108
  prefs: []
  type: TYPE_NORMAL
  zh: '"!", "@", "#", "$", "%", "+", "-", "*", "/", "1", "M", "d"'
- en: '};'
  id: totrans-1109
  prefs: []
  type: TYPE_NORMAL
  zh: '};'
- en: 'for (String s: arr)'
  id: totrans-1110
  prefs: []
  type: TYPE_NORMAL
  zh: 'for (String s: arr)'
- en: '{'
  id: totrans-1111
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: Matcher m = p.matcher(s);
  id: totrans-1112
  prefs: []
  type: TYPE_NORMAL
  zh: Matcher m = p.matcher(s);
- en: System.out.printf("[%s] %s%n", s,
  id: totrans-1113
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.printf("[%s] %s%n", s,
- en: '(m.matches() ? "matches" : "does not match"));'
  id: totrans-1114
  prefs: []
  type: TYPE_NORMAL
  zh: '(m.matches() ? "matches" : "does not match"));'
- en: '}'
  id: totrans-1115
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-1116
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-1117
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: 'This program produces the following output when we run it after compilation:'
  id: totrans-1118
  prefs: []
  type: TYPE_NORMAL
  zh: 编译并运行此程序后，程序产生以下输出：
- en: '[!] matches'
  id: totrans-1119
  prefs: []
  type: TYPE_NORMAL
  zh: '[!] 匹配'
- en: '[@] matches'
  id: totrans-1120
  prefs: []
  type: TYPE_NORMAL
  zh: '[@] 匹配'
- en: '[#] matches'
  id: totrans-1121
  prefs: []
  type: TYPE_NORMAL
  zh: '[#] 匹配'
- en: '[$] matches'
  id: totrans-1122
  prefs: []
  type: TYPE_NORMAL
  zh: '[$] 匹配'
- en: '[%] matches'
  id: totrans-1123
  prefs: []
  type: TYPE_NORMAL
  zh: '[%] 匹配'
- en: '[+] does not match'
  id: totrans-1124
  prefs: []
  type: TYPE_NORMAL
  zh: '[+] 不匹配'
- en: '[-] does not match'
  id: totrans-1125
  prefs: []
  type: TYPE_NORMAL
  zh: '[-] 不匹配'
- en: '[*] does not match'
  id: totrans-1126
  prefs: []
  type: TYPE_NORMAL
  zh: '[*] 不匹配'
- en: '[/] does not match'
  id: totrans-1127
  prefs: []
  type: TYPE_NORMAL
  zh: '[/] 不匹配'
- en: '[1] does not match'
  id: totrans-1128
  prefs: []
  type: TYPE_NORMAL
  zh: '[1] 不匹配'
- en: '[M] does not match'
  id: totrans-1129
  prefs: []
  type: TYPE_NORMAL
  zh: '[M] 不匹配'
- en: '[d] does not match'
  id: totrans-1130
  prefs: []
  type: TYPE_NORMAL
  zh: '[d] 不匹配'
- en: As is evident from this output, it allows all the punctuation characters except
    the four listed math operators.
  id: totrans-1131
  prefs: []
  type: TYPE_NORMAL
  zh: 如此输出所示，它允许所有标点符号字符，除了列出的四个数学运算符。
- en: '**Why should you use**'
  id: totrans-1132
  prefs: []
  type: TYPE_NORMAL
  zh: '**为什么你应该使用**'
- en: '**composite character classes?**'
  id: totrans-1133
  prefs: []
  type: TYPE_NORMAL
  zh: '**复合字符类？**'
- en: 'We should use composite character classes for the following reasons: To create
    new custom character classes from predefined Unicode blocks. For example, to match
    all the letters in an Arabic Unicode block, we can use the following:'
  id: totrans-1134
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该使用复合字符类，以下是一些原因：从预定义的Unicode块中创建新的自定义字符类。例如，为了匹配阿拉伯Unicode块中的所有字母，我们可以使用以下：
- en: '[\p{InArabic}&&\p{L}]'
  id: totrans-1135
  prefs: []
  type: TYPE_NORMAL
  zh: '[\p{InArabic}&&\p{L}]'
- en: To avoid potentially slower lookahead or lookbehind patterns by using the intersection
    or subtraction operation on multiple character classes.
  id: totrans-1136
  prefs: []
  type: TYPE_NORMAL
  zh: 通过对多个字符类使用交集或减法操作来避免潜在的较慢的先行或后行模式。
- en: To enhance the readability of the regular expression.
  id: totrans-1137
  prefs: []
  type: TYPE_NORMAL
  zh: 为了提高正则表达式的可读性。
- en: '**Summary**'
  id: totrans-1138
  prefs: []
  type: TYPE_NORMAL
  zh: '**总结**'
- en: In this chapter, we discussed composite and inner character classes. We found
    out how we can use the union, intersection, and subtraction operations to combine
    simple character classes and make a completely different character class to suit
    our requirements. You learned some good usage patterns of composite character
    classes for solving tricky problems. Note how we could avoid more complex lookahead
    and lookbehind assertions by using the union and intersection of character classes.
  id: totrans-1139
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们讨论了复合和内部字符类。我们了解到如何使用并集、交集和减法操作来组合简单的字符类，从而创建一个完全不同的字符类以满足我们的需求。你学习了复合字符类的一些良好用法模式，用于解决棘手的问题。注意我们如何通过使用字符类的并集和交集来避免更复杂的先行和后行断言。
- en: In the next chapter, we will discuss the pitfalls of some poorly written regular
    expressions, and you will learn ways to avoid them. You will also learn some important
    optimizing tips and performance improvement methods for writing complex regular
    expressions.
  id: totrans-1140
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将讨论一些编写不良的正则表达式的陷阱，你将学习避免它们的方法。你还将学习编写复杂正则表达式的一些重要优化技巧和性能改进方法。
- en: '**Regular Expression Pitfalls,**'
  id: totrans-1141
  prefs: []
  type: TYPE_NORMAL
  zh: '**正则表达式陷阱，**'
- en: '**Optimization, and**'
  id: totrans-1142
  prefs: []
  type: TYPE_NORMAL
  zh: '**优化和**'
- en: '**Performance Improvements**'
  id: totrans-1143
  prefs: []
  type: TYPE_NORMAL
  zh: '**性能改进**'
- en: 'Regular expressions, if not written well may perform poorly. They may run slowly,
    and when they are executed frequently in some code, they may be the source of
    high CPU utilization. To avoid these problems, regular expressions have to be
    crafted carefully, understanding the possible pitfalls, and they also have to
    be tested thoroughly. We will be covering the following topics in this chapter:
    Common pitfalls and ways to avoid them while writing regular expressions How to
    test your regex functionality and performance'
  id: totrans-1144
  prefs: []
  type: TYPE_NORMAL
  zh: 正则表达式，如果编写不当，可能会表现不佳。它们可能运行缓慢，当它们在某些代码中频繁执行时，可能成为高CPU利用率的来源。为了避免这些问题，正则表达式必须精心制作，理解可能的陷阱，并且它们还必须彻底测试。在本章中，我们将涵盖以下主题：编写正则表达式时常见的陷阱和避免它们的方法
    如何测试你的正则表达式功能和性能
- en: Optimization and performance enhancing tips
  id: totrans-1145
  prefs: []
  type: TYPE_NORMAL
  zh: 优化和性能提升技巧
- en: Catastrophic backtracking and how to avoid it
  id: totrans-1146
  prefs: []
  type: TYPE_NORMAL
  zh: 意外回溯和如何避免它
- en: '**Common pitfalls and ways to**'
  id: totrans-1147
  prefs: []
  type: TYPE_NORMAL
  zh: '**常见的陷阱和解决方法**'
- en: '**avoid them while writing**'
  id: totrans-1148
  prefs: []
  type: TYPE_NORMAL
  zh: '**在编写时避免它们**'
- en: '**regular expressions**'
  id: totrans-1149
  prefs: []
  type: TYPE_NORMAL
  zh: '**正则表达式**'
- en: Let's discuss some common mistakes people make while building regular expressions
    to solve various problems.
  id: totrans-1150
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们讨论一下人们在构建正则表达式以解决各种问题时常见的错误。
- en: '**Do not forget to escape regex**'
  id: totrans-1151
  prefs: []
  type: TYPE_NORMAL
  zh: '**不要忘记转义正则表达式**'
- en: '**metacharacters outside a**'
  id: totrans-1152
  prefs: []
  type: TYPE_NORMAL
  zh: '**正则表达式外的元字符**'
- en: '**character class**'
  id: totrans-1153
  prefs: []
  type: TYPE_NORMAL
  zh: '**字符类**'
- en: You learned that all the special metacharacters, such as *, +, ?, ., |, (, ),
    [, {, ^, $, and so on, need to be escaped if the intent is to match them literally.
    I often see cases where programmers leave them unescaped, thus giving a totally
    different meaning to the regular expression. The Java regex API that we discussed
    in [Chapter 5,](#p111) *Introduction* *to Java Regular Expressions APIs - Pattern
    and Matcher Classes*, throws a non-checked exception if a regex pattern is wrongly
    formatted and cannot be compiled.
  id: totrans-1154
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经了解到，所有特殊元字符，如 *、+、?、.、|、(、)、[、{、^、$ 等，如果意图是匹配它们本身，则需要转义。我经常看到程序员没有转义这些元字符，从而给正则表达式带来了完全不同的含义。我们在第5章中讨论的Java正则表达式API，即
    *Java正则表达式API - Pattern和Matcher类*，如果正则表达式格式错误且无法编译，将抛出一个非受检异常。
- en: '**Avoid escaping every non-**'
  id: totrans-1155
  prefs: []
  type: TYPE_NORMAL
  zh: '**避免转义每个非**'
- en: '**word character**'
  id: totrans-1156
  prefs: []
  type: TYPE_NORMAL
  zh: '**单词字符**'
- en: 'Some programmers overdo escaping, thinking that they need to escape every non-word
    character such as colon, hyphen, semicolon, forward slash, and whitespace, which
    is not correct. They end up writing a regular expression as follows:'
  id: totrans-1157
  prefs: []
  type: TYPE_NORMAL
  zh: 一些程序员过度使用转义，认为他们需要转义每个非单词字符，如冒号、破折号、分号、正斜杠和空白字符，这是不正确的。他们最终编写了一个如下所示的正则表达式：
- en: ^https?\:\/\/(www\.)?example\.com$
  id: totrans-1158
  prefs: []
  type: TYPE_NORMAL
  zh: ^https?\:\/\/(www\.)?example\.com$
- en: 'The preceding regex pattern uses excessive escaping. This pattern still works,
    but it is not very readable. The colon and forward slash have no special meaning
    in regex; hence, it is better to write this regex in the following way:'
  id: totrans-1159
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的正则表达式模式使用了过多的转义。这个模式仍然有效，但它不是非常易读。冒号和正斜杠在正则表达式中没有特殊含义；因此，最好以以下方式编写这个正则表达式：
- en: ^https?://(www\.)?example\.com$
  id: totrans-1160
  prefs: []
  type: TYPE_NORMAL
  zh: ^https?://(www\.)?example\.com$
- en: '**Avoid unnecessary capturing**'
  id: totrans-1161
  prefs: []
  type: TYPE_NORMAL
  zh: '**避免不必要的捕获**'
- en: '**groups to reduce memory**'
  id: totrans-1162
  prefs: []
  type: TYPE_NORMAL
  zh: '**减少内存的分组**'
- en: '**consumption**'
  id: totrans-1163
  prefs: []
  type: TYPE_NORMAL
  zh: '**消耗**'
- en: 'We come across so many examples of regular expressions on the internet that
    promote unnecessary capturing groups. If we are not extracting any substring or
    not using a group in backreferences, then it is better to avoid capturing groups
    by using one or more of the following ways:'
  id: totrans-1164
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在网上遇到了许多推广不必要的捕获组的正则表达式示例。如果我们没有提取任何子串或没有在回溯中使用组，那么通过使用以下一种或多种方式来避免捕获组会更好：
- en: '1\. We can use character classes in certain cases. Consider the following capturing
    group:'
  id: totrans-1165
  prefs: []
  type: TYPE_NORMAL
  zh: 1. 在某些情况下，我们可以使用字符类。考虑以下捕获组：
- en: (a|e|i|o|u)
  id: totrans-1166
  prefs: []
  type: TYPE_NORMAL
  zh: (a|e|i|o|u)
- en: 'So, instead of using the preceding regex, we can use the following:'
  id: totrans-1167
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们不必使用前面的正则表达式，可以使用以下正则表达式：
- en: '[aeiou]'
  id: totrans-1168
  prefs: []
  type: TYPE_NORMAL
  zh: '[aeiou]'
- en: '2\. We can use a non-capturing group by placing a ?: at the start of the group.'
  id: totrans-1169
  prefs: []
  type: TYPE_NORMAL
  zh: '2. 我们可以在组的开始放置一个 ?: 来使用非捕获组。'
- en: 'Consider the following regex:'
  id: totrans-1170
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下正则表达式：
- en: (red|blue|white)
  id: totrans-1171
  prefs: []
  type: TYPE_NORMAL
  zh: (red|blue|white)
- en: 'Instead of the previous regex, we can use the following:'
  id: totrans-1172
  prefs: []
  type: TYPE_NORMAL
  zh: 与前面的正则表达式不同，我们可以使用以下正则表达式：
- en: (?:red|blue|white)
  id: totrans-1173
  prefs: []
  type: TYPE_NORMAL
  zh: (?:red|blue|white)
- en: '3\. To write a regex to match an integer or decimal number there is no need
    to use the following regex:'
  id: totrans-1174
  prefs: []
  type: TYPE_NORMAL
  zh: 3. 要编写一个匹配整数或十进制数的正则表达式，没有必要使用以下正则表达式：
- en: ^(\d*)(\.?)(\d+)$
  id: totrans-1175
  prefs: []
  type: TYPE_NORMAL
  zh: ^(\d*)(\.?)(\d+)$
- en: 'We can just rewrite it by removing unnecessary groups, as follows:'
  id: totrans-1176
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过删除不必要的分组来重写它，如下所示：
- en: ^\d*\.?d+$
  id: totrans-1177
  prefs: []
  type: TYPE_NORMAL
  zh: ^\d*\.?d+$
- en: '4\. Sometimes, a regex may contain multiple problems, such as the ones we discussed
    in the previous subsection:'
  id: totrans-1178
  prefs: []
  type: TYPE_NORMAL
  zh: 4. 有时，一个正则表达式可能包含多个问题，如我们在前一小节中讨论的：
- en: ^https?\:\/\/(www\.)?example\.com$
  id: totrans-1179
  prefs: []
  type: TYPE_NORMAL
  zh: ^https?\:\/\/(www\.)?example\.com$
- en: 'Not only does this regex use excessive escaping but there is also an unnecessary
    capturing group in this regex. Hence, by applying these fixes, the preceding regex
    can be better written as follows:'
  id: totrans-1180
  prefs: []
  type: TYPE_NORMAL
  zh: 不仅这个正则表达式使用了过多的转义，而且在这个正则表达式中还有一个不必要的捕获组。因此，通过应用这些修复，前面的正则表达式可以更好地写成以下形式：
- en: ^https?://(?:www\.)?example\.com$
  id: totrans-1181
  prefs: []
  type: TYPE_NORMAL
  zh: ^https?://(?:www\.)?example\.com$
- en: '**However, don''t forget to use**'
  id: totrans-1182
  prefs: []
  type: TYPE_NORMAL
  zh: '**然而，不要忘记使用**'
- en: '**the required group around**'
  id: totrans-1183
  prefs: []
  type: TYPE_NORMAL
  zh: '**所需的分组**'
- en: '**alternation**'
  id: totrans-1184
  prefs: []
  type: TYPE_NORMAL
  zh: '**交替**'
- en: Often, we see regex patterns that use alternation, and around the alternation,
    we use anchors or boundary matchers without safeguarding the alternation expression
    in a group. Note that the ^, $, \A, \Z, \z anchors and the \b boundary matcher
    have a higher precedence than the alternation character, | (pipe)
  id: totrans-1185
  prefs: []
  type: TYPE_NORMAL
  zh: 经常看到使用交替的正则表达式模式，在交替表达式中使用锚点或边界匹配器，但没有在组内保护交替表达式。请注意，^、$、\A、\Z、\z锚点和\b边界匹配器的优先级高于交替字符|（管道）
- en: 'So, consider a regular expression written as follows:'
  id: totrans-1186
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，考虑以下形式的正则表达式：
- en: ^com|org|net$
  id: totrans-1187
  prefs: []
  type: TYPE_NORMAL
  zh: ^com|org|net$
- en: It will also match computer, organization, and internet, though the intent probably
    was to match only com, net, and org. This is because the start anchor, ^, is being
    applied to com only and the end anchor, $, is being applied to net, whereas org
    is not anchored at all.
  id: totrans-1188
  prefs: []
  type: TYPE_NORMAL
  zh: 它也将匹配计算机、组织和互联网，尽管可能原本的意图是只匹配com、net和org。这是因为开始锚点^只应用于com，而结束锚点$应用于net，而org则完全没有锚定。
- en: 'This regular expression should be written as follows to match only com, org,
    and net correctly:'
  id: totrans-1189
  prefs: []
  type: TYPE_NORMAL
  zh: 为了正确匹配com、org和net，这个正则表达式应该写成以下形式：
- en: ^(?:com|org|net)$
  id: totrans-1190
  prefs: []
  type: TYPE_NORMAL
  zh: ^(?:com|org|net)$
- en: '**Use predefined character**'
  id: totrans-1191
  prefs: []
  type: TYPE_NORMAL
  zh: '**使用预定义字符**'
- en: '**classes instead of longer**'
  id: totrans-1192
  prefs: []
  type: TYPE_NORMAL
  zh: '**使用类而不是更长的**'
- en: '**versions**'
  id: totrans-1193
  prefs: []
  type: TYPE_NORMAL
  zh: '**版本**'
- en: We discussed predefined character classes and Unicode character classes in[ Chapter
    2](https://cdp.packtpub.com/java_9_regular_expressions/wp-admin/post.php?post=78&action=edit),
    *Understanding the Core Concepts of Java Regular Expressions*. We need to make
    good use of it. So use \d instead of [0-9] or \D instead of [^0-9], and use \w
    instead of
  id: totrans-1194
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在[第2章](https://cdp.packtpub.com/java_9_regular_expressions/wp-admin/post.php?post=78&action=edit)中讨论了预定义字符类和Unicode字符类，*理解Java正则表达式的核心概念*。我们需要充分利用它。因此，使用\d代替[0-9]或使用\D代替[^0-9]，并使用\w代替
- en: '[a-zA-Z_0-9] or \W instead of [^a-zA-Z_0-9].'
  id: totrans-1195
  prefs: []
  type: TYPE_NORMAL
  zh: '[a-zA-Z_0-9] 或 \W 而不是 [^a-zA-Z_0-9]。'
- en: '**Use the limiting quantifier**'
  id: totrans-1196
  prefs: []
  type: TYPE_NORMAL
  zh: '**使用限定符**'
- en: '**instead of repeating a**'
  id: totrans-1197
  prefs: []
  type: TYPE_NORMAL
  zh: '**而不是重复**'
- en: '**character or pattern**'
  id: totrans-1198
  prefs: []
  type: TYPE_NORMAL
  zh: '**字符或模式**'
- en: '**multiple times**'
  id: totrans-1199
  prefs: []
  type: TYPE_NORMAL
  zh: '**多次使用**'
- en: The MAC address of a computer is a unique identifier assigned to network interfaces
    at the time of manufacturing. MAC addresses are 6 bytes or 48 bits in length and
    are written in the nn:nn:nn:nn:nn:nn format, where each n represents a hexadecimal
    digit.
  id: totrans-1200
  prefs: []
  type: TYPE_NORMAL
  zh: 计算机的MAC地址是在制造时分配给网络接口的唯一标识符。MAC地址长度为6字节或48位，格式为nn:nn:nn:nn:nn:nn，其中每个n代表一个十六进制数字。
- en: 'To match a MAC address, one can write the following regex:'
  id: totrans-1201
  prefs: []
  type: TYPE_NORMAL
  zh: 要匹配MAC地址，可以编写以下正则表达式：
- en: ^[A-F0-9]{2}:[A-F0-9]{2}:[A-F0-9]{2}:[A-F0-9]{2}:[A-F0-9]{2}:[A-F0-9]{2}$
  id: totrans-1202
  prefs: []
  type: TYPE_NORMAL
  zh: ^[A-F0-9]{2}:[A-F0-9]{2}:[A-F0-9]{2}:[A-F0-9]{2}:[A-F0-9]{2}:[A-F0-9]{2}$
- en: 'However, it is much cleaner and more readable to write the regex as follows:'
  id: totrans-1203
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，将正则表达式写成以下形式会更简洁、更易于阅读：
- en: ^(?:[A-F\d]{2}:){5}[A-F\d]{2}$
  id: totrans-1204
  prefs: []
  type: TYPE_NORMAL
  zh: ^(?:[A-F\d]{2}:){5}[A-F\d]{2}$
- en: Note how short and readable this regex pattern has become when compared to the
    previous regex.
  id: totrans-1205
  prefs: []
  type: TYPE_NORMAL
  zh: 注意与之前的正则表达式相比，这个正则表达式模式变得多么简短且易于阅读。
- en: '**Do not use an unescaped**'
  id: totrans-1206
  prefs: []
  type: TYPE_NORMAL
  zh: '**不要使用未转义的**'
- en: '**hyphen in the middle of a**'
  id: totrans-1207
  prefs: []
  type: TYPE_NORMAL
  zh: '**中间的连字符**'
- en: '**character class**'
  id: totrans-1208
  prefs: []
  type: TYPE_NORMAL
  zh: '**字符类**'
- en: We know that most of the special regex metacharacters are treated literally
    inside the character class and we do not need to escape them inside the character
    class.
  id: totrans-1209
  prefs: []
  type: TYPE_NORMAL
  zh: 我们知道，大多数特殊正则表达式元字符在字符类内被当作普通字符处理，我们不需要在字符类内转义它们。
- en: However, if an unescaped hyphen is used between two characters, then it makes
    it a range between the previous and the next character of the hyphen.
  id: totrans-1210
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果两个字符之间使用未转义的连字符，那么它将使它成为连字符前后的字符之间的范围。
- en: 'As an illustrative example, let''s consider this character class expression
    to match the four basic math operators, +,-,*,/:'
  id: totrans-1211
  prefs: []
  type: TYPE_NORMAL
  zh: 作为说明性的例子，让我们考虑这个字符类表达式来匹配四个基本数学运算符，+、-、*、/：
- en: '[*+-/]'
  id: totrans-1212
  prefs: []
  type: TYPE_NORMAL
  zh: '[*+-/]'
- en: The way it is written, this character class has a hyphen between the + and /
    characters.
  id: totrans-1213
  prefs: []
  type: TYPE_NORMAL
  zh: 按照这种方式编写，这个字符类在加号（+）和斜杠（/）字符之间有一个连字符。
- en: This makes the character class match all the characters that fall between +
    (0x2A) and /
  id: totrans-1214
  prefs: []
  type: TYPE_NORMAL
  zh: 这使得字符类匹配所有介于+（0x2A）和/之间的字符
- en: (0x2F), as per the ASCII table. Due to this reason, the preceding pattern will
    also match the comma (,), that is, 0x2C, and DOT (.), that is, 0x2E, characters.
  id: totrans-1215
  prefs: []
  type: TYPE_NORMAL
  zh: (0x2F)，根据ASCII表。由于这个原因，前面的模式也将匹配逗号(,)，即0x2C，和点(.)，即0x2E，字符。
- en: 'An unescaped hyphen can be safely used at the first or last positions in a
    character class to avoid making a range. With that in mind, we can correct this
    character class by using any of the following forms:'
  id: totrans-1216
  prefs: []
  type: TYPE_NORMAL
  zh: 在字符类中，一个未转义的连字符可以安全地用于第一个或最后一个位置，以避免形成一个范围。考虑到这一点，我们可以通过以下任何一种形式来纠正这个字符类：
- en: '[-*+/]'
  id: totrans-1217
  prefs: []
  type: TYPE_NORMAL
  zh: '[-*+/]'
- en: '[*+/-]'
  id: totrans-1218
  prefs: []
  type: TYPE_NORMAL
  zh: '[*+/-]'
- en: '[*+\-/]'
  id: totrans-1219
  prefs: []
  type: TYPE_NORMAL
  zh: '[*+\-/]'
- en: '**The mistake of calling**'
  id: totrans-1220
  prefs: []
  type: TYPE_NORMAL
  zh: '**调用错误的**'
- en: '**matcher.goup() without a**'
  id: totrans-1221
  prefs: []
  type: TYPE_NORMAL
  zh: '**matcher.group()没有**'
- en: '**prior call to matcher.find(),**'
  id: totrans-1222
  prefs: []
  type: TYPE_NORMAL
  zh: '**之前的matcher.find()调用，**'
- en: '**matcher.matches(), or**'
  id: totrans-1223
  prefs: []
  type: TYPE_NORMAL
  zh: '**matcher.matches()，或**'
- en: '**matcher.lookingAt()**'
  id: totrans-1224
  prefs: []
  type: TYPE_NORMAL
  zh: '**matcher.lookingAt()**'
- en: This annoying mistake is found in many programs. As the heading says, these
    are cases where programmers call any of the group() methods without a prior call
    to the find, matches, or lookingAt methods. A matcher is created using the pattern.matcher(String)
    method call, but we need to invoke one of these three methods to perform a match
    operation.
  id: totrans-1225
  prefs: []
  type: TYPE_NORMAL
  zh: 这种令人烦恼的错误在许多程序中都会出现。正如标题所说，这些是在程序员在调用find、matches或lookingAt方法之前调用任何group方法的案例。使用pattern.matcher(String)方法调用创建了一个matcher，但我们需要调用这三个方法之一来执行匹配操作。
- en: 'If we call matcher.group() without calling one of these three methods, then
    the code will throw a java.lang.IllegalStateException exception, as the following
    code is doing: package example.regex;'
  id: totrans-1226
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们不调用这三个方法之一（find、matches或lookingAt）就调用matcher.group()，那么代码将抛出java.lang.IllegalStateException异常，如下所示：package
    example.regex;
- en: import java.util.regex.*;
  id: totrans-1227
  prefs: []
  type: TYPE_NORMAL
  zh: 导入java.util.regex.*;
- en: public class MissingMethodCall
  id: totrans-1228
  prefs: []
  type: TYPE_NORMAL
  zh: public class MissingMethodCall
- en: '{'
  id: totrans-1229
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: public static void main(String[] args)
  id: totrans-1230
  prefs: []
  type: TYPE_NORMAL
  zh: public static void main(String[] args)
- en: '{'
  id: totrans-1231
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: final Pattern p = Pattern.compile("(\\d*)\\.?(\\d+)"); final String input =
    "123.75";
  id: totrans-1232
  prefs: []
  type: TYPE_NORMAL
  zh: final Pattern p = Pattern.compile("(\\d*)\\.?(\\d+)"); final String input =
    "123.75";
- en: Matcher m = p.matcher(input);
  id: totrans-1233
  prefs: []
  type: TYPE_NORMAL
  zh: Matcher m = p.matcher(input);
- en: System.out.printf("Number Value [%s], Decimal Value [%s]%n", m.group(1), m.group(2));
  id: totrans-1234
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.printf("数值 [%s]，小数数值 [%s]%n", m.group(1), m.group(2));
- en: '}'
  id: totrans-1235
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-1236
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: Note that the code calls m.group(1) and m.group(2) right after it instantiates
    the matcher object from a pattern instance. Once compiled and executed, this code
    will throw an unwanted java.lang.IllegalStateException exception, indicating that
    the matcher instance is not in the correct state to return group information.
  id: totrans-1237
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，代码在从模式实例实例化matcher对象后立即调用m.group(1)和m.group(2)。一旦编译并执行，此代码将抛出一个不希望的java.lang.IllegalStateException异常，指示matcher实例不在正确的状态以返回分组信息。
- en: 'In order to fix this code, insert a call to any one of the three methods (find,
    matches, or lookingAt) to perform a match operation, as shown in the following
    code: package example.regex;'
  id: totrans-1238
  prefs: []
  type: TYPE_NORMAL
  zh: 为了修复此代码，插入对这三个方法之一（find、matches或lookingAt）的调用以执行匹配操作，如下所示：package example.regex;
- en: import java.util.regex.*;
  id: totrans-1239
  prefs: []
  type: TYPE_NORMAL
  zh: import java.util.regex.*;
- en: public class RightMethodCall
  id: totrans-1240
  prefs: []
  type: TYPE_NORMAL
  zh: public class RightMethodCall
- en: '{'
  id: totrans-1241
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: public static void main(String[] args)
  id: totrans-1242
  prefs: []
  type: TYPE_NORMAL
  zh: public static void main(String[] args)
- en: '{'
  id: totrans-1243
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: final Pattern p = Pattern.compile("(\\d*)\\.?(\\d+)"); final String input =
    "123.75";
  id: totrans-1244
  prefs: []
  type: TYPE_NORMAL
  zh: final Pattern p = Pattern.compile("(\\d*)\\.?(\\d+)"); final String input =
    "123.75";
- en: Matcher m = p.matcher(input);
  id: totrans-1245
  prefs: []
  type: TYPE_NORMAL
  zh: Matcher m = p.matcher(input);
- en: if (m.find()) // or m.lookingAt() or m.matches()
  id: totrans-1246
  prefs: []
  type: TYPE_NORMAL
  zh: if (m.find()) // 或 m.lookingAt() 或 m.matches()
- en: '{'
  id: totrans-1247
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: System.out.printf("Integer Part [%s], Fractional Part [%s]%n", m.group(1), m.group(2));
  id: totrans-1248
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.printf("整数部分 [%s]，小数部分 [%s]%n", m.group(1), m.group(2));
- en: '}'
  id: totrans-1249
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-1250
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-1251
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: 'Now, this code will produce the correct output, as follows: Integer Part [123],
    Fractional Part [75]'
  id: totrans-1252
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，此代码将产生正确的输出，如下所示：整数部分 [123]，小数部分 [75]
- en: '**Do not use regular**'
  id: totrans-1253
  prefs: []
  type: TYPE_NORMAL
  zh: '**不要使用正则**'
- en: '**expressions to parse XML /**'
  id: totrans-1254
  prefs: []
  type: TYPE_NORMAL
  zh: '**用于解析XML的正则表达式**'
- en: '**HTML data**'
  id: totrans-1255
  prefs: []
  type: TYPE_NORMAL
  zh: '**HTML数据**'
- en: Using regular expressions to parse XML or HTML text is probably the most frequently
    committed mistake. Although regular expressions are very useful, they have their
    limitations and these limits are usually met when trying to use them for XML or
    HTML parsing. HTML and XML are not regular languages by nature.
  id: totrans-1256
  prefs: []
  type: TYPE_NORMAL
  zh: 使用正则表达式解析XML或HTML文本可能是最常犯的错误。尽管正则表达式非常有用，但它们有其局限性，并且这些限制通常在尝试使用它们进行XML或HTML解析时遇到。HTML和XML本质上不是正则语言。
- en: Luckily, there are other tools in Java for that purpose. The JDK contains readily
    available classes to parse these formats and convert them to **Document Object
    Model** (**DOM**), or to work with them on the fly using the SAX parsing model.
  id: totrans-1257
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，Java中还有其他工具可以用于此目的。JDK包含现成的类来解析这些格式并将它们转换为**文档对象模型**（**DOM**），或者使用SAX解析模型即时处理它们。
- en: Do not use regular expressions for certain tasks when there are more specific
    parsers for the purpose. The fact that there are other readily available tools
    gives you a hint that probably regular expressions, in such a case, are not the
    best tools. After all, that is the reason why the programmers of the XML and HTML
    parsers started their work.
  id: totrans-1258
  prefs: []
  type: TYPE_NORMAL
  zh: 当有更具体的解析器用于特定任务时，不要使用正则表达式。存在其他现成工具的事实表明，在这种情况下，正则表达式可能不是最好的工具。毕竟，这就是XML和HTML解析器的程序员开始工作的原因。
- en: '**How to test and benchmark**'
  id: totrans-1259
  prefs: []
  type: TYPE_NORMAL
  zh: '**如何测试和基准测试**'
- en: '**your regular expression**'
  id: totrans-1260
  prefs: []
  type: TYPE_NORMAL
  zh: '**你的正则表达式**'
- en: '**performance**'
  id: totrans-1261
  prefs: []
  type: TYPE_NORMAL
  zh: '**性能**'
- en: 'There are several free online regular expression tools available that tell
    you the number of steps to match a regex pattern against a given set of inputs
    and also provide you valuable debug info. You should also write your unit test
    cases. Here is a list of some online tools that can be used:'
  id: totrans-1262
  prefs: []
  type: TYPE_NORMAL
  zh: 有几个免费的在线正则表达式工具可用，它们会告诉您匹配正则表达式模式所需步骤的数量，并提供有价值的调试信息。您还应该编写自己的单元测试用例。以下是一些可以使用的在线工具列表：
- en: Use jshell available with Java 9 to quickly test your regex Use RegexMatchers,
    a utility class with static methods, to test your regex in JUnit; check [http://matchers.jcabi.com/regex-matchers.html](http://matchers.jcabi.com/regex-matchers.html)
  id: totrans-1263
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Java 9中可用的jshell快速测试您的正则表达式 使用RegexMatchers，一个具有静态方法的实用工具类，在JUnit中测试您的正则表达式；查看[http://matchers.jcabi.com/regex-matchers.html](http://matchers.jcabi.com/regex-matchers.html)
- en: '[regex101.com](https://regex101.com/)'
  id: totrans-1264
  prefs: []
  type: TYPE_NORMAL
  zh: '[regex101.com](https://regex101.com/)'
- en: '[www.regexplanet.com](http://www.regexplanet.com/)'
  id: totrans-1265
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.regexplanet.com](http://www.regexplanet.com/)'
- en: '[www.rexegg.com](http://www.rexegg.com/)'
  id: totrans-1266
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.rexegg.com](http://www.rexegg.com/)'
- en: '[www.debuggex.com](https://www.debuggex.com/)'
  id: totrans-1267
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.debuggex.com](https://www.debuggex.com/)'
- en: '[regexper.com](http://regexper.com)'
  id: totrans-1268
  prefs: []
  type: TYPE_NORMAL
  zh: '[regexper.com](http://regexper.com)'
- en: '[regexbuddy.com](https://www.regexbuddy.com/) (not free) Use the Java/JUnit
    regex-tester library from [https://github.com/nickawatts/regex-tester](https://github.com/nickawatts/regex-tester)'
  id: totrans-1269
  prefs: []
  type: TYPE_NORMAL
  zh: '[regexbuddy.com](https://www.regexbuddy.com/) (not free) 使用Java/JUnit正则表达式测试库，来自[https://github.com/nickawatts/regex-tester](https://github.com/nickawatts/regex-tester)'
- en: In addition to these tools, you can yourself write your own comprehensive unit
    test cases using JUnit in your favorite Java IDE and check the timings and other
    matching information.
  id: totrans-1270
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这些工具之外，您还可以使用您最喜欢的Java IDE中的JUnit编写自己的综合单元测试用例，并检查计时和其他匹配信息。
- en: 'Here is an example of JUnit code using the RegExMatchers library: package example.regex;'
  id: totrans-1271
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是使用RegExMatchers库的JUnit代码示例：包example.regex;
- en: import com.jcabi.matchers.RegexMatchers;
  id: totrans-1272
  prefs: []
  type: TYPE_NORMAL
  zh: import com.jcabi.matchers.RegexMatchers;
- en: import org.hamcrest.MatcherAssert;
  id: totrans-1273
  prefs: []
  type: TYPE_NORMAL
  zh: import org.hamcrest.MatcherAssert;
- en: import org.junit.Test;
  id: totrans-1274
  prefs: []
  type: TYPE_NORMAL
  zh: import org.junit.Test;
- en: public class RegexTest
  id: totrans-1275
  prefs: []
  type: TYPE_NORMAL
  zh: public class RegexTest
- en: '{'
  id: totrans-1276
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: '@Test'
  id: totrans-1277
  prefs: []
  type: TYPE_NORMAL
  zh: '@Test'
- en: public void matchesDecimalNumberPattern()
  id: totrans-1278
  prefs: []
  type: TYPE_NORMAL
  zh: public void matchesDecimalNumberPattern()
- en: '{'
  id: totrans-1279
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: MatcherAssert.assertThat(
  id: totrans-1280
  prefs: []
  type: TYPE_NORMAL
  zh: MatcherAssert.assertThat(
- en: '"[+-]?\\d*\\.?\\d+",'
  id: totrans-1281
  prefs: []
  type: TYPE_NORMAL
  zh: '"[+-]?\\d*\\.?\\d+",'
- en: RegexMatchers.matchesPattern("-145.78")
  id: totrans-1282
  prefs: []
  type: TYPE_NORMAL
  zh: RegexMatchers.matchesPattern("-145.78")
- en: );
  id: totrans-1283
  prefs: []
  type: TYPE_NORMAL
  zh: );
- en: '}'
  id: totrans-1284
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-1285
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: You are encouraged to use this library to build your own test cases and ensure
    that your regex passes all the edge cases.
  id: totrans-1286
  prefs: []
  type: TYPE_NORMAL
  zh: 鼓励您使用此库来构建自己的测试用例，并确保您的正则表达式通过所有边缘情况。
- en: '**Catastrophic or exponential**'
  id: totrans-1287
  prefs: []
  type: TYPE_NORMAL
  zh: '**灾难性或指数级**'
- en: '**backtracking**'
  id: totrans-1288
  prefs: []
  type: TYPE_NORMAL
  zh: '**回溯**'
- en: 'Regular expression engines can be broadly categorized into two types: 1\. The
    **Non-deterministic Finite Automation** (**NFA**) engine 2\. The **Deterministic
    Finite Automation** (**DFA**) engine The DFA engines do not evaluate each character
    more than once to find a match. On the other hand, the NFA engines support backtracking,
    which means that each character in the input can be evaluated multiple times by
    the regex engine. The Java regular expression engine is an NFA engine.'
  id: totrans-1289
  prefs: []
  type: TYPE_NORMAL
  zh: 正则表达式引擎可以大致分为两种类型：1\. 非确定性有限自动机（**NFA**）引擎 2\. 确定性有限自动机（**DFA**）引擎。DFA引擎在查找匹配时不会对每个字符进行多次评估。另一方面，NFA引擎支持回溯，这意味着输入中的每个字符都可以被正则表达式引擎多次评估。Java正则表达式引擎是一个NFA引擎。
- en: Regex engines backtrack or give back one position at a time to make various
    attempts to match a given pattern when using the greedy quantifier or trying alternations.
  id: totrans-1290
  prefs: []
  type: TYPE_NORMAL
  zh: 正则表达式引擎在使用贪婪量词或尝试交替时，会一次回溯或退回一个位置，以尝试匹配给定的模式。
- en: Similarly, when using lazy quantifiers, the regex engine moves forward one position
    at a time to attempt matching.
  id: totrans-1291
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，当使用懒惰量词时，正则表达式引擎一次向前移动一个位置来尝试匹配。
- en: Regex engines usually take less time to find a positive match in the given input
    as compared to returning a failure for a non-match. The NFA regex engines need
    to evaluate all the possible permutations before returning a failure.
  id: totrans-1292
  prefs: []
  type: TYPE_NORMAL
  zh: 正则表达式引擎通常在给定输入中找到正匹配所需的时间比返回非匹配失败所需的时间少。NFA正则表达式引擎需要在返回失败之前评估所有可能的排列组合。
- en: For example, in a regular expression that uses nested repetition quantifiers,
    the regex engine backtracks excessively while matching a long input text. A catastrophic
    backtracking problem usually occurs when the regex engine fails to make a negative
    match towards the end of the string and after attempting far too many permutations.
  id: totrans-1293
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在使用嵌套重复量词的正则表达式中，正则表达式引擎在匹配长输入文本时会过度回溯。当正则表达式引擎在字符串末尾未能进行负匹配，并且尝试了过多的排列组合后，通常会发生灾难性回溯问题。
- en: 'As an example, check the following regex with nested quantifiers:'
  id: totrans-1294
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，检查以下具有嵌套量词的正则表达式：
- en: ^(\w+)*$
  id: totrans-1295
  prefs: []
  type: TYPE_NORMAL
  zh: ^(\w+)*$
- en: 'Suppose we test it against an input text that does not have a word character
    in the end, such as this input string:'
  id: totrans-1296
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们测试它对输入文本的测试，该输入文本末尾没有单词字符，例如以下输入字符串：
- en: 'abcdefghijklmno:'
  id: totrans-1297
  prefs: []
  type: TYPE_NORMAL
  zh: 'abcdefghijklmno:'
- en: We know that due to the presence of a non-word character (colon) at the end
    of the input, the match will fail. However, due to the presence of nested compound
    quantifiers, (\w+)*, the regex engine backtracks excessively and makes a lot of
    attempts to match the input before giving up.
  id: totrans-1298
  prefs: []
  type: TYPE_NORMAL
  zh: 我们知道，由于输入末尾存在一个非单词字符（冒号），匹配将失败。然而，由于存在嵌套复合量词 (\w+)*，正则表达式引擎会过度回溯，并在放弃之前尝试匹配输入多次。
- en: 'Excessive backtracking may also be caused by two or more alternatives that
    are mutually exclusive and can match the same string in the input. For example,
    having a regex pattern like this one to match the text between the %% tags:'
  id: totrans-1299
  prefs: []
  type: TYPE_NORMAL
  zh: 过度回溯也可能由两个或更多互斥的备选方案引起，这些方案可以匹配输入中的相同字符串。例如，有一个正则表达式模式如下，用于匹配 %% 标签之间的文本：
- en: '%%(.|\s)+%%'
  id: totrans-1300
  prefs: []
  type: TYPE_NORMAL
  zh: '%%(.|\s)+%%'
- en: 'This regex may also cause catastrophic backtracking for failed cases, such
    as the following input string with a missing closing tag:'
  id: totrans-1301
  prefs: []
  type: TYPE_NORMAL
  zh: 这个正则表达式也可能导致失败案例的灾难性回溯，例如以下缺少闭合标签的输入字符串：
- en: '%% something here abcd 123'
  id: totrans-1302
  prefs: []
  type: TYPE_NORMAL
  zh: '%% something here abcd 123'
- en: The problem here is that the alternations in (.|\s) are not mutually exclusive,
    as dot can also match the same whitespace that is matched by \s, except the newline
    character.
  id: totrans-1303
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的问题是，在 (.|\s) 中的交替不是互斥的，因为点号也可以匹配由 \s 匹配的相同空白字符，除了换行符。
- en: 'Here is a complete program listing that demonstrates a dynamically building
    regex getting slower with every iteration of the loop and eventually causing catastrophic
    backtracking:'
  id: totrans-1304
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个完整的程序列表，演示了正则表达式在每次循环迭代中都会变慢，并最终导致灾难性回溯：
- en: package example.regex;
  id: totrans-1305
  prefs: []
  type: TYPE_NORMAL
  zh: package example.regex;
- en: import java.util.regex.Matcher;
  id: totrans-1306
  prefs: []
  type: TYPE_NORMAL
  zh: import java.util.regex.Matcher;
- en: import java.util.regex.Pattern;
  id: totrans-1307
  prefs: []
  type: TYPE_NORMAL
  zh: import java.util.regex.Pattern;
- en: public class CatastropicBacktracking
  id: totrans-1308
  prefs: []
  type: TYPE_NORMAL
  zh: public class CatastropicBacktracking
- en: '{'
  id: totrans-1309
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: public static void main(String[] args)
  id: totrans-1310
  prefs: []
  type: TYPE_NORMAL
  zh: public static void main(String[] args)
- en: '{'
  id: totrans-1311
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: final int MAX = 30;
  id: totrans-1312
  prefs: []
  type: TYPE_NORMAL
  zh: final int MAX = 30;
- en: for (int i = 1; i < MAX; i++)
  id: totrans-1313
  prefs: []
  type: TYPE_NORMAL
  zh: for (int i = 1; i < MAX; i++)
- en: '{'
  id: totrans-1314
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: StringBuilder sb1 = new StringBuilder(i);
  id: totrans-1315
  prefs: []
  type: TYPE_NORMAL
  zh: StringBuilder sb1 = new StringBuilder(i);
- en: StringBuilder sb2 = new StringBuilder(i);
  id: totrans-1316
  prefs: []
  type: TYPE_NORMAL
  zh: StringBuilder sb2 = new StringBuilder(i);
- en: for (int j = i; j > 0; j--)
  id: totrans-1317
  prefs: []
  type: TYPE_NORMAL
  zh: for (int j = i; j > 0; j--)
- en: '{'
  id: totrans-1318
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: sb1.append('a');
  id: totrans-1319
  prefs: []
  type: TYPE_NORMAL
  zh: sb1.append('a');
- en: sb2.append("a?");
  id: totrans-1320
  prefs: []
  type: TYPE_NORMAL
  zh: sb2.append("a?");
- en: '}'
  id: totrans-1321
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: sb2.append(sb1);
  id: totrans-1322
  prefs: []
  type: TYPE_NORMAL
  zh: sb2.append(sb1);
- en: final Pattern p = Pattern.compile("^" + sb2.toString() + "$"); Matcher m = p.matcher(sb1.toString());
  id: totrans-1323
  prefs: []
  type: TYPE_NORMAL
  zh: final Pattern p = Pattern.compile("^" + sb2.toString() + "$"); Matcher m = p.matcher(sb1.toString());
- en: long start = System.nanoTime();
  id: totrans-1324
  prefs: []
  type: TYPE_NORMAL
  zh: long start = System.nanoTime();
- en: m.matches();
  id: totrans-1325
  prefs: []
  type: TYPE_NORMAL
  zh: m.matches();
- en: long end = System.nanoTime();
  id: totrans-1326
  prefs: []
  type: TYPE_NORMAL
  zh: long end = System.nanoTime();
- en: 'System.out.printf("%s:: ( %sms ) :: Pattern <%s>, Input <%s>%n", i, (end -
    start)/1_000_000, sb2, sb1);'
  id: totrans-1327
  prefs: []
  type: TYPE_NORMAL
  zh: 'System.out.printf("%s:: ( %sms ) :: Pattern <%s>, Input <%s>%n", i, (end -
    start)/1_000_000, sb2, sb1);'
- en: '}'
  id: totrans-1328
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-1329
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-1330
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: 'When you compile and run the preceding program and look at the generated output,
    you will note an output as follows:'
  id: totrans-1331
  prefs: []
  type: TYPE_NORMAL
  zh: 当你编译并运行前面的程序并查看生成的输出时，你会注意到如下输出：
- en: '1:: ( 0ms ) :: Pattern <a?a>, Input <a>'
  id: totrans-1332
  prefs: []
  type: TYPE_NORMAL
  zh: '1:: ( 0ms ) :: Pattern <a?a>, Input <a>'
- en: '2:: ( 0ms ) :: Pattern <a?a?aa>, Input <aa>'
  id: totrans-1333
  prefs: []
  type: TYPE_NORMAL
  zh: '2:: ( 0ms ) :: Pattern <a?a?aa>, Input <aa>'
- en: '3:: ( 0ms ) :: Pattern <a?a?a?aaa>, Input <aaa> 4:: ( 0ms ) :: Pattern <a?a?a?a?aaaa>,
    Input <aaaa> 5:: ( 0ms ) :: Pattern <a?a?a?a?a?aaaaa>, Input <aaaaa> 6:: ( 0ms
    ) :: Pattern <a?a?a?a?a?a?aaaaaa>, Input <aaaaaa> 7:: ( 0ms ) :: Pattern <a?a?a?a?a?a?a?aaaaaaa>,
    Input <aaaaaaa> 8:: ( 0ms ) :: Pattern <a?a?a?a?a?a?a?a?aaaaaaaa>, Input <aaaaaaaa>
    9:: ( 0ms ) :: Pattern <a?a?a?a?a?a?a?a?a?aaaaaaaaa>, Input <aaaaaaaaa> 10:: (
    0ms ) :: Pattern <a?a?a?a?a?a?a?a?a?a?aaaaaaaaaa>, Input <aaaaaaaaaa> 11:: ( 0ms
    ) :: Pattern <a?a?a?a?a?a?a?a?a?a?a?aaaaaaaaaaa>, Input <aaaaaaaaaaa> 12:: ( 0ms
    ) :: Pattern <a?a?a?a?a?a?a?a?a?a?a?a?aaaaaaaaaaaa>, Input <aaaaaaaaaaaa> 13::
    ( 10ms ) :: Pattern <a?a?a?a?a?a?a?a?a?a?a?a?a?aaaaaaaaaaaaa>, Input <aaaaaaaaaaaaa>
    14:: ( 1ms ) :: Pattern <a?a?a?a?a?a?a?a?a?a?a?a?a?a?aaaaaaaaaaaaaa>, Input <aaaaaaaaaaaaaa>
    15:: ( 15ms ) :: Pattern <a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?aaaaaaaaaaaaaaa>, Input
    <aaaaaaaaaaaaaaa> 16:: ( 18ms ) :: Pattern <a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?aaaaaaaaaaaaaaaa>,
    Input <aaaaaaaaaaaaaaaa> 17:: ( 29ms ) :: Pattern <a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?aaaaaaaaaaaaaaaaa>,
    Input <aaaaaaaaaaaaaaaaa> 18:: ( 22ms ) :: Pattern <a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?aaaaaaaaaaaaaaaaaa>,
    Input <aaaaaaaaaaaaaaaaaa> 19:: ( 51ms ) :: Pattern <a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?aaaaaaaaaaaaaaaaaaa>,
    Input <aaaaaaaaaaaaaaaaaaa> 20:: ( 97ms ) :: Pattern <a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?aaaaaaaaaaaaaaaaaaaa>,
    Input <aaaaaaaaaaaaaaaaaaaa> 21:: ( 188ms ) :: Pattern <a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?aaaaaaaaaaaaaaaaaaaaa>,
    Input <aaaaaaaaaaaaaaaaaaaaa> 22:: ( 441ms ) :: Pattern <a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?aaaaaaaaaaaaaaaaaaaaaa>,
    Input <aaaaaaaaaaaaaaaaaaaaaa> 23:: ( 1003ms ) :: Pattern <a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?aaaaaaaaaaaaaaaaaaaaaaa>,
    Input <aaaaaaaaaaaaaaaaaaaaaaa> 24:: ( 1549ms ) :: Pattern <a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?aaaaaaaaaaaaaaaaaaaaaaaa>,
    Input <aaaaaaaaaaaaaaaaaaaaaaaa> 25:: ( 3010ms ) :: Pattern <a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?aaaaaaaaaaaaaaaaaaaaaaaaa>,
    Input <aaaaaaaaaaaaaaaaaaaaaaaaa> 26:: ( 5884ms ) :: Pattern <a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?aaaaaaaaaaaaaaaaaaaaaaaaaa>,
    Input <aaaaaaaaaaaaaaaaaaaaaaaaaa>'
  id: totrans-1334
  prefs: []
  type: TYPE_NORMAL
  zh: '3:: ( 0ms ) :: 模式 <a?a?a?aaa>, 输入 <aaa> 4:: ( 0ms ) :: 模式 <a?a?a?a?aaaa>, 输入
    <aaaa> 5:: ( 0ms ) :: 模式 <a?a?a?a?a?aaaaa>, 输入 <aaaaa> 6:: ( 0ms ) :: 模式 <a?a?a?a?a?a?aaaaaa>,
    输入 <aaaaaa> 7:: ( 0ms ) :: 模式 <a?a?a?a?a?a?a?aaaaaaa>, 输入 <aaaaaaa> 8:: ( 0ms
    ) :: 模式 <a?a?a?a?a?a?a?a?aaaaaaaa>, 输入 <aaaaaaaa> 9:: ( 0ms ) :: 模式 <a?a?a?a?a?a?a?a?a?aaaaaaaaa>,
    输入 <aaaaaaaaa> 10:: ( 0ms ) :: 模式 <a?a?a?a?a?a?a?a?a?a?aaaaaaaaaa>, 输入 <aaaaaaaaaa>
    11:: ( 0ms ) :: 模式 <a?a?a?a?a?a?a?a?a?a?a?aaaaaaaaaaa>, 输入 <aaaaaaaaaaa> 12::
    ( 0ms ) :: 模式 <a?a?a?a?a?a?a?a?a?a?a?a?aaaaaaaaaaaa>, 输入 <aaaaaaaaaaaa> 13:: (
    10ms ) :: 模式 <a?a?a?a?a?a?a?a?a?a?a?a?a?aaaaaaaaaaaaa>, 输入 <aaaaaaaaaaaaa> 14::
    ( 1ms ) :: 模式 <a?a?a?a?a?a?a?a?a?a?a?a?a?a?aaaaaaaaaaaaaa>, 输入 <aaaaaaaaaaaaaa>
    15:: ( 15ms ) :: 模式 <a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?aaaaaaaaaaaaaaa>, 输入 <aaaaaaaaaaaaaaa>
    16:: ( 18ms ) :: 模式 <a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?aaaaaaaaaaaaaaaa>, 输入 <aaaaaaaaaaaaaaaa>
    17:: ( 29ms ) :: 模式 <a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?aaaaaaaaaaaaaaaaa>, 输入
    <aaaaaaaaaaaaaaaaa> 18:: ( 22ms ) :: 模式 <a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?aaaaaaaaaaaaaaaaaa>,
    输入 <aaaaaaaaaaaaaaaaaa> 19:: ( 51ms ) :: 模式 <a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?aaaaaaaaaaaaaaaaaaa>,
    输入 <aaaaaaaaaaaaaaaaaaa> 20:: ( 97ms ) :: 模式 <a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?aaaaaaaaaaaaaaaaaaaa>,
    输入 <aaaaaaaaaaaaaaaaaaaa> 21:: ( 188ms ) :: 模式 <a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?aaaaaaaaaaaaaaaaaaaaa>,
    输入 <aaaaaaaaaaaaaaaaaaaaa> 22:: ( 441ms ) :: 模式 <a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?aaaaaaaaaaaaaaaaaaaaaa>,
    输入 <aaaaaaaaaaaaaaaaaaaaaa> 23:: ( 1003ms ) :: 模式 <a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?aaaaaaaaaaaaaaaaaaaaaaa>,
    输入 <aaaaaaaaaaaaaaaaaaaaaaa> 24:: ( 1549ms ) :: 模式 <a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?aaaaaaaaaaaaaaaaaaaaaaaa>,
    输入 <aaaaaaaaaaaaaaaaaaaaaaaa> 25:: ( 3010ms ) :: 模式 <a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?aaaaaaaaaaaaaaaaaaaaaaaaa>,
    输入 <aaaaaaaaaaaaaaaaaaaaaaaaa> 26:: ( 5884ms ) :: 模式 <a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?aaaaaaaaaaaaaaaaaaaaaaaaaa>,
    输入 <aaaaaaaaaaaaaaaaaaaaaaaaaa>'
- en: '27:: ( 12588ms ) :: Pattern <a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?aaaaaaaaaaaaaaaaaaaaaaaaaaa>,
    Input <aaaaaaaaaaaaaaaaaaaaaaaaaaa> 28:: ( 24765ms ) :: Pattern <a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?aaaaaaaaaaaaaaaaaaaaaaaaaaaa>,
    Input <aaaaaaaaaaaaaaaaaaaaaaaaaaaa> 29:: ( 51679ms ) :: Pattern <a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?aaaaaaaaaaaaaaaaaaaaaaaaaaaaa>,
    Input <aaaaaaaaaaaaaaaaaaaaaaaaaaaaa> Note how the execution time grows rapidly
    on higher values of the counter i, especially after 25\.'
  id: totrans-1335
  prefs: []
  type: TYPE_NORMAL
  zh: '27:: ( 12588ms ) :: 模式 <a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?aaaaaaaaaaaaaaaaaaaaaaaaaaa>,
    输入 <aaaaaaaaaaaaaaaaaaaaaaaaaaa> 28:: ( 24765ms ) :: 模式 <a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?aaaaaaaaaaaaaaaaaaaaaaaaaaaa>,
    输入 <aaaaaaaaaaaaaaaaaaaaaaaaaaaa> 29:: ( 51679ms ) :: 模式 <a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?aaaaaaaaaaaaaaaaaaaaaaaaaaaaa>,
    输入 <aaaaaaaaaaaaaaaaaaaaaaaaaaaaa> 注意，当计数器i的值较高时，执行时间会迅速增长，尤其是在25之后。'
- en: '**How to avoid catastrophic**'
  id: totrans-1336
  prefs: []
  type: TYPE_NORMAL
  zh: '**如何避免灾难性的**'
- en: '**backtracking**'
  id: totrans-1337
  prefs: []
  type: TYPE_NORMAL
  zh: '**回溯**'
- en: 'Here are some tips to keep in mind while handling situations with catastrophic
    or excessive backtracking in your regex:'
  id: totrans-1338
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理正则表达式中的灾难性或过度回溯的情况时，以下是一些需要记住的提示：
- en: When you write regular expressions, make sure they fail fast without spending
    a lot of unnecessary steps in backtracking.
  id: totrans-1339
  prefs: []
  type: TYPE_NORMAL
  zh: 当你编写正则表达式时，确保它们快速失败，而不会在回溯中浪费很多不必要的步骤。
- en: When using nested repetition operators or quantifiers, make sure that there
    is only one unique way to match the a string.
  id: totrans-1340
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用嵌套重复操作符或量词时，确保只有一个唯一的方式来匹配字符串。
- en: Make good judicious use of atomic groups and possessive quantifiers to avoid
    excessive backtracking.
  id: totrans-1341
  prefs: []
  type: TYPE_NORMAL
  zh: 良好而谨慎地使用原子组和占有量词来避免过度回溯。
- en: You should avoid having too many optional matches that are not mutually exclusive
    in an alternation pattern.
  id: totrans-1342
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该避免在交替模式中拥有太多非互斥的可选匹配项。
- en: Be very careful when using a free-flowing pattern such as .* or .+ in your regex.
  id: totrans-1343
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用正则表达式中的自由流动模式如.*或.+时，要非常小心。
- en: Wherever possible, use negated character classes for cutting down the backtracking
    steps and for better performance.
  id: totrans-1344
  prefs: []
  type: TYPE_NORMAL
  zh: 在可能的情况下，使用否定字符类来减少回溯步骤并提高性能。
- en: Avoid matching hugely sized text using a single regex. It is better to match
    smaller strings using your regex and call matcher.find() in a loop to get multiple
    matches. If needed, use another inner pattern to match and examine the matches
    found by the main pattern.
  id: totrans-1345
  prefs: []
  type: TYPE_NORMAL
  zh: 避免使用单个正则表达式匹配大量文本。最好使用正则表达式匹配较小的字符串，并通过循环调用matcher.find()来获取多个匹配项。如果需要，可以使用另一个内部模式来匹配和检查主模式找到的匹配项。
- en: 'The regex with the nested quantifier that caused catastrophic backtracking
    is as follows:'
  id: totrans-1346
  prefs: []
  type: TYPE_NORMAL
  zh: 导致灾难性回溯的嵌套量词正则表达式如下：
- en: ^(\w+)*$
  id: totrans-1347
  prefs: []
  type: TYPE_NORMAL
  zh: ^(\w+)*$
- en: 'We can make use of possessive quantifiers to disallow any backtracking, as
    follows:'
  id: totrans-1348
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用占有量词来禁止任何回溯，如下所示：
- en: ^(\w+)*+$
  id: totrans-1349
  prefs: []
  type: TYPE_NORMAL
  zh: ^(\w+)*+$
- en: You will note a massive jump in this improved regex in any of the benchmarks
    or regex testing tools, as suggested earlier.
  id: totrans-1350
  prefs: []
  type: TYPE_NORMAL
  zh: 你会在任何基准测试或正则表达式测试工具中注意到这种改进的正则表达式有巨大的提升，如前所述。
- en: 'Also, in the alternation regex example, we found that this regex causes excessive
    backtracking for failed cases:'
  id: totrans-1351
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，在交替正则表达式示例中，我们发现此正则表达式在失败情况下导致过度回溯：
- en: '%%(.|\s)%%'
  id: totrans-1352
  prefs: []
  type: TYPE_NORMAL
  zh: '%%(.|\s)%%'
- en: 'It can be converted to the following regex to avoid excessive backtracking:'
  id: totrans-1353
  prefs: []
  type: TYPE_NORMAL
  zh: 可以转换为以下正则表达式以避免过度回溯：
- en: '%%(\S|\s)+%%'
  id: totrans-1354
  prefs: []
  type: TYPE_NORMAL
  zh: '%%(\S|\s)+%%'
- en: 'It is even better to avoid the group and use a character class, as follows:'
  id: totrans-1355
  prefs: []
  type: TYPE_NORMAL
  zh: 更好地避免使用分组并使用字符类，如下所示：
- en: '%%[\S\s]+%%'
  id: totrans-1356
  prefs: []
  type: TYPE_NORMAL
  zh: '%%[\S\s]+%%'
- en: Note the use of \S instead of dot to make alternatives mutually exclusive.
  id: totrans-1357
  prefs: []
  type: TYPE_NORMAL
  zh: 注意使用\S而不是点来使替代项相互排斥。
- en: 'A regex that can cause excessive backtracking is as follows:'
  id: totrans-1358
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个可能导致过度回溯的正则表达式：
- en: ^(?:.*:)+#$
  id: totrans-1359
  prefs: []
  type: TYPE_NORMAL
  zh: ^(?:.*:)+#$
- en: 'In the preceding regex example, if we use a negated character class instead
    of .*, then we can avoid catastrophic backtracking:'
  id: totrans-1360
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的正则表达式示例中，如果我们使用否定字符类代替.*，则可以避免灾难性回溯：
- en: ^(?:[^:]+:)+#$
  id: totrans-1361
  prefs: []
  type: TYPE_NORMAL
  zh: ^(?:[^:]+:)+#$
- en: The regex engine doesn't backtrack excessively because the negated character
    class,
  id: totrans-1362
  prefs: []
  type: TYPE_NORMAL
  zh: 正则表达式引擎不会过度回溯，因为否定字符类，
- en: '[^:], matches any character except a colon instead of the dot that matches
    everything, including the colon.'
  id: totrans-1363
  prefs: []
  type: TYPE_NORMAL
  zh: '[^:]匹配任何除冒号之外的字符，而不是匹配包括冒号在内的所有字符的点。'
- en: 'Consider another example with this regex pattern that has the nested repetition
    operator, +:'
  id: totrans-1364
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑另一个具有嵌套重复操作符+的正则表达式模式示例：
- en: '%(?:[p-s]+|ye|wo)+%'
  id: totrans-1365
  prefs: []
  type: TYPE_NORMAL
  zh: '%(?:[p-s]+|ye|wo)+%'
- en: 'This regex pattern attempts to match a string that starts with the following
    conditions: Must start with %'
  id: totrans-1366
  prefs: []
  type: TYPE_NORMAL
  zh: 此正则表达式模式尝试匹配满足以下条件的字符串：必须以%开头
- en: '% must be followed by one or more alternations: letters p,q,r,s or the string
    ye or wo'
  id: totrans-1367
  prefs: []
  type: TYPE_NORMAL
  zh: '%必须后跟一个或多个交替：字母p、q、r、s或字符串ye或wo'
- en: Must end with another %
  id: totrans-1368
  prefs: []
  type: TYPE_NORMAL
  zh: 必须以另一个%结束
- en: 'Now test this regex pattern against the input string, as follows:'
  id: totrans-1369
  prefs: []
  type: TYPE_NORMAL
  zh: 现在按照以下方式测试此正则表达式模式：
- en: '%yeqpsrwospqr'
  id: totrans-1370
  prefs: []
  type: TYPE_NORMAL
  zh: '%yeqpsrwospqr'
- en: Obviously, the regex pattern is not going to match because the last % is missing.
  id: totrans-1371
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，正则表达式模式不会匹配，因为最后一个%缺失。
- en: However, note that the starting % and all the following letters will match the
    regex pattern before the last %. Due to this, the regex engine will backtrack
    several times while making attempts to match the complete input before finally
    giving up.
  id: totrans-1372
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，请注意，起始的%和所有随后的字母将在最后一个%之前匹配正则表达式模式。因此，正则表达式引擎会在尝试匹配完整输入之前回溯多次，最终放弃。
- en: 'When testing this regex on the *regex101* website''s debugger, it shows the
    following: match 1 failed in 748 steps'
  id: totrans-1373
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在*regex101*网站的调试器上测试此正则表达式时，它显示以下内容：匹配1失败在748步
- en: 748 may be a quite a big number for the number of steps taken to fail the match
    for a small-sized input. Regex patterns such as this can slow down your application
    considerably. Some of them can even hang your code for many hours or days due
    to the catastrophic backtracking behavior.
  id: totrans-1374
  prefs: []
  type: TYPE_NORMAL
  zh: 748可能对于一个小型输入的匹配失败步骤数来说是一个相当大的数字。像这样的正则表达式可能会显著减慢你的应用程序。其中一些甚至可能因为灾难性的回溯行为而使你的代码挂起数小时或数天。
- en: 'Now, to prevent this catastrophic backtracking behavior, let''s consider the
    two options the we recommended earlier:'
  id: totrans-1375
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，为了防止这种灾难性的回溯行为，让我们考虑我们之前推荐的两个选项：
- en: '1\. Use a possessive quantifier, as follows:'
  id: totrans-1376
  prefs: []
  type: TYPE_NORMAL
  zh: 1. 使用占有量词，如下所示：
- en: '%(?:[p-s]+|ye|wo)++%'
  id: totrans-1377
  prefs: []
  type: TYPE_NORMAL
  zh: '%(?:[p-s]+|ye|wo)++%'
- en: 'On testing the preceding pattern on the same site, we get the following in
    the debugger:'
  id: totrans-1378
  prefs: []
  type: TYPE_NORMAL
  zh: 在对前面的模式进行相同站点的测试时，我们在调试器中得到了以下结果：
- en: match 1 failed in 33 steps
  id: totrans-1379
  prefs: []
  type: TYPE_NORMAL
  zh: 匹配1失败，在33步后
- en: '2\. Use an atomic group, as follows:'
  id: totrans-1380
  prefs: []
  type: TYPE_NORMAL
  zh: 2. 使用原子组，如下所示：
- en: '%(?>[p-s]+|ye|wo)+%'
  id: totrans-1381
  prefs: []
  type: TYPE_NORMAL
  zh: '%(?>[p-s]+|ye|wo)+%'
- en: 'On testing the preceding pattern on the same site, we get the following in
    the debugger:'
  id: totrans-1382
  prefs: []
  type: TYPE_NORMAL
  zh: 在对前面的模式进行相同站点的测试时，我们在调试器中得到了以下结果：
- en: match 1 failed in 36 steps
  id: totrans-1383
  prefs: []
  type: TYPE_NORMAL
  zh: 匹配1失败，在36步后
- en: You can notice that by using any of the aforementioned techniques, we make the
    regex engine fail sooner and avoid the unnecessarily high number of backtracking
    steps.
  id: totrans-1384
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以注意到，通过使用上述任何一种技术，我们使正则表达式引擎更快地失败，并避免不必要的回溯步骤数量。
- en: '**Optimization and**'
  id: totrans-1385
  prefs: []
  type: TYPE_NORMAL
  zh: '**优化和**'
- en: '**performance enhancement**'
  id: totrans-1386
  prefs: []
  type: TYPE_NORMAL
  zh: '**性能提升**'
- en: '**tips**'
  id: totrans-1387
  prefs: []
  type: TYPE_NORMAL
  zh: '**tips**'
- en: Let's discuss some optimization techniques and performance enhancement guidelines.
  id: totrans-1388
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们讨论一些优化技术和性能提升指南。
- en: '**Use a compiled form of**'
  id: totrans-1389
  prefs: []
  type: TYPE_NORMAL
  zh: '**使用编译形式**'
- en: '**regular expressions**'
  id: totrans-1390
  prefs: []
  type: TYPE_NORMAL
  zh: '**正则表达式**'
- en: Compile your string regex pattern using the Pattern.compile(String) method call
    followed by calls to the Matcher APIs instead of calling shorthand methods in
    string, such as matches(), replaceAll, and replaceFirst, especially when these
    matching or replacement methods are invoked repeatedly inside a loop. Repeated
    calls to String.matches() or any other regex-based method defined in the String
    API will compile the String regex pattern every time; this can be very time-consuming
    for a complex regex pattern.
  id: totrans-1391
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Pattern.compile(String) 方法调用编译你的字符串正则表达式模式，然后调用 Matcher API 的调用，而不是在字符串中调用简写方法，如
    matches()、replaceAll 和 replaceFirst，尤其是在这些匹配或替换方法在循环内部重复调用时。对 String.matches()
    或任何在 String API 中定义的基于正则表达式的其他方法的重复调用将每次编译字符串正则表达式模式；对于复杂的正则表达式模式，这可能会非常耗时。
- en: '**Use a negated character**'
  id: totrans-1392
  prefs: []
  type: TYPE_NORMAL
  zh: '**使用否定字符**'
- en: '**class instead of the greedy**'
  id: totrans-1393
  prefs: []
  type: TYPE_NORMAL
  zh: '**class代替贪婪**'
- en: '**and slow .* or .+**'
  id: totrans-1394
  prefs: []
  type: TYPE_NORMAL
  zh: '**和慢 .* 或 .+**'
- en: 'Wherever possible, use negated character classes instead of the potential performance
    draining patterns (.* or .+), as follows:'
  id: totrans-1395
  prefs: []
  type: TYPE_NORMAL
  zh: 在可能的情况下，使用否定字符类代替可能降低性能的模式（.* 或 .+），如下所示：
- en: param1=[^&]+&param2=[^&]+&param3=[^&]+$
  id: totrans-1396
  prefs: []
  type: TYPE_NORMAL
  zh: param1=[^&]+&param2=[^&]+&param3=[^&]+$
- en: 'Avoid using slow-performing quantifiers, as follows:'
  id: totrans-1397
  prefs: []
  type: TYPE_NORMAL
  zh: 避免使用性能较慢的量词，如下所示：
- en: param1=.+&param2=.+param3=.+$
  id: totrans-1398
  prefs: []
  type: TYPE_NORMAL
  zh: param1=.+&param2=.+param3=.+$
- en: '**Avoid unnecessary grouping**'
  id: totrans-1399
  prefs: []
  type: TYPE_NORMAL
  zh: '**避免不必要的分组**'
- en: Avoiding unnecessary captured groups in your regex. If grouping is required
    in your regex, then use non-capturing groups to save the overall memory footprint
    of the regex pattern while executing.
  id: totrans-1400
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的正则表达式中避免不必要的捕获组。如果正则表达式中的分组是必需的，那么使用非捕获组来节省正则表达式模式在执行时的整体内存占用。
- en: '**Use lazy quantifiers**'
  id: totrans-1401
  prefs: []
  type: TYPE_NORMAL
  zh: '**使用惰性量词**'
- en: '**strategically instead of**'
  id: totrans-1402
  prefs: []
  type: TYPE_NORMAL
  zh: '**strategically代替**'
- en: '**greedy quantifiers that cause**'
  id: totrans-1403
  prefs: []
  type: TYPE_NORMAL
  zh: '**贪婪量词导致**'
- en: '**excessive backtracking**'
  id: totrans-1404
  prefs: []
  type: TYPE_NORMAL
  zh: '**过多的回溯**'
- en: Suppose we need to match an input that contains three complete words, *start*,
    *middle*, and *end*, separated by non-whitespace characters.
  id: totrans-1405
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们需要匹配一个包含三个完整单词的输入，*start*、*middle* 和 *end*，它们之间由非空白字符分隔。
- en: 'Consider using the following pattern with a lazy quantifier:'
  id: totrans-1406
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑使用以下模式，并带有惰性量词：
- en: \bstart\b\S+?\bmiddle\b\S+?\bend\b
  id: totrans-1407
  prefs: []
  type: TYPE_NORMAL
  zh: \bstart\b\S+?\bmiddle\b\S+?\bend\b
- en: 'Instead of using the following pattern, our match will be faster if we use
    the preceding pattern:'
  id: totrans-1408
  prefs: []
  type: TYPE_NORMAL
  zh: 与使用以下模式相比，如果我们使用前面的模式，我们的匹配将会更快：
- en: \bstart\b\S+\bmiddle\b\S+\bend\b
  id: totrans-1409
  prefs: []
  type: TYPE_NORMAL
  zh: \bstart\b\S+\bmiddle\b\S+\bend\b
- en: '**Make use of possessive**'
  id: totrans-1410
  prefs: []
  type: TYPE_NORMAL
  zh: '**利用占有**'
- en: '**quantifiers to avoid**'
  id: totrans-1411
  prefs: []
  type: TYPE_NORMAL
  zh: '**quantifiers to avoid**'
- en: '**backtracking**'
  id: totrans-1412
  prefs: []
  type: TYPE_NORMAL
  zh: '**backtracking**'
- en: Recall that we discussed in an earlier chapter how a possessive quantifier is
    used for fail-fast paradigm. Wherever possible, make good use of possessive quantifiers
    to tell the regex engine to avoid backtracking.
  id: totrans-1413
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下，我们在前面的章节中讨论了如何使用占有量词来实现快速失败范式。在可能的情况下，充分利用占有量词来告诉正则表达式引擎避免回溯。
- en: Suppose we need to write a regex to match the text between two markers, @START@
    and
  id: totrans-1414
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们需要编写一个正则表达式来匹配两个标记@START@和@END@之间的文本
- en: '@END@. It is given that the semicolon is now allowed between two markers.'
  id: totrans-1415
  prefs: []
  type: TYPE_NORMAL
  zh: '@END@。假设分号现在允许在两个标记之间使用。'
- en: 'We can write this regex with the + or greedy quantifier, as follows:'
  id: totrans-1416
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以用+或贪婪量词编写此正则表达式，如下所示：
- en: '@START@[^;]+@END@'
  id: totrans-1417
  prefs: []
  type: TYPE_NORMAL
  zh: '@START@[^;]+@END@'
- en: 'However, it is better to use the ++ or possessive quantifier in the regex,
    as follows:'
  id: totrans-1418
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在正则表达式中使用++或占有性量词会更好，如下所示：
- en: '@START@[^;]++@END@'
  id: totrans-1419
  prefs: []
  type: TYPE_NORMAL
  zh: '@START@[^;]++@END@'
- en: 'This regex will be faster to execute for failed matches, such as the following
    string:'
  id: totrans-1420
  prefs: []
  type: TYPE_NORMAL
  zh: 对于以下字符串等失败匹配，此正则表达式将执行得更快：
- en: '@START@ abc 123 foo @XYZ@'
  id: totrans-1421
  prefs: []
  type: TYPE_NORMAL
  zh: '@START@ abc 123 foo @XYZ@'
- en: '**Extract common repeating**'
  id: totrans-1422
  prefs: []
  type: TYPE_NORMAL
  zh: '**提取重复的公共部分**'
- en: '**substrings out of alternation**'
  id: totrans-1423
  prefs: []
  type: TYPE_NORMAL
  zh: '**选择分支外的子串**'
- en: 'Consider the following pattern:'
  id: totrans-1424
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下模式：
- en: (playground|player|playing)
  id: totrans-1425
  prefs: []
  type: TYPE_NORMAL
  zh: (playground|player|playing)
- en: 'Instead of using the preceding pattern, it is better to extract the common
    substring, play, and move it to the left of alternation, as follows: play(ground|er|ing)'
  id: totrans-1426
  prefs: []
  type: TYPE_NORMAL
  zh: 不使用前面的模式，最好提取公共子串play，并将其移动到选择分支的左侧，如下所示：play(ground|er|ing)
- en: '**Use atomic group to avoid**'
  id: totrans-1427
  prefs: []
  type: TYPE_NORMAL
  zh: '**使用原子组避免**'
- en: '**backtracking and fail fast**'
  id: totrans-1428
  prefs: []
  type: TYPE_NORMAL
  zh: '**回溯和快速失败**'
- en: Recall from [Chapter 6](#p133), *Exploring Zero-Width Assertions, Lookarounds,
    and Atomic* *Groups,* that an atomic group is a non-capturing group that exits
    the group and throws away all the alternative positions remembered by any token
    inside the group, after the first match of the pattern inside the group. Thus,
    it avoids backtracking to attempt all the alternatives present in the group.
  id: totrans-1429
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下[第6章](#p133)，*探索零宽断言、前瞻和原子组*，原子组是一个非捕获组，在组内模式的第一次匹配后，它会退出组并丢弃组内任何标记记住的所有替代位置。因此，它避免了回溯以尝试组中存在的所有替代方案。
- en: Due to this very characteristic of atomic groups, the use of atomic groups in
    certain scenarios saves many unnecessary backtracking steps and speeds up the
    overall regex execution.
  id: totrans-1430
  prefs: []
  type: TYPE_NORMAL
  zh: 由于原子组的这一特性，在某些场景中使用原子组可以节省许多不必要的回溯步骤，并加快整体正则表达式的执行速度。
- en: 'So, use this atomic group:'
  id: totrans-1431
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，使用以下原子组：
- en: \btra(?>ck|ce|ining|de|in|nsit|ns|uma)\b
  id: totrans-1432
  prefs: []
  type: TYPE_NORMAL
  zh: \btra(?>ck|ce|ining|de|in|nsit|ns|uma)\b
- en: 'It is better to use the preceding atomic group instead of the following non-capturing
    group:'
  id: totrans-1433
  prefs: []
  type: TYPE_NORMAL
  zh: 使用前面的原子组而不是下面的非捕获组会更好：
- en: \btra(?:ck|ce|ining|de|in|nsit|ns|uma)\b
  id: totrans-1434
  prefs: []
  type: TYPE_NORMAL
  zh: \btra(?:ck|ce|ining|de|in|nsit|ns|uma)\b
- en: The difference in behavior will be evident when matching an input string, such
    as *tracker*, which fails to match.
  id: totrans-1435
  prefs: []
  type: TYPE_NORMAL
  zh: 当匹配输入字符串（如*tracker*，它无法匹配）时，行为差异将很明显。
- en: '**Summary**'
  id: totrans-1436
  prefs: []
  type: TYPE_NORMAL
  zh: '**总结**'
- en: In the final chapter of this book, we discussed some common mistakes people
    make while writing regular expressions. These mistakes often cause some exceptions
    to be thrown at runtime or cause the regular expressions to fail the match unexpectedly.
  id: totrans-1437
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的最后一章，我们讨论了人们在编写正则表达式时常见的错误。这些错误通常会在运行时抛出一些异常，或者导致正则表达式意外地失败匹配。
- en: Then, you learned the various ways to avoid such mistakes.
  id: totrans-1438
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你学会了避免此类错误的各种方法。
- en: We discussed catastrophic backtracking in regular expressions and the tricks
    to avoid excessive backtracking. By minimizing the backtracking steps, regular
    expressions can become really efficient.
  id: totrans-1439
  prefs: []
  type: TYPE_NORMAL
  zh: 我们讨论了正则表达式中的灾难性回溯以及避免过度回溯的技巧。通过最小化回溯步骤，正则表达式可以变得非常高效。
- en: You learned the testing and benchmarking techniques for regular expressions.
    Finally, we covered many regex optimization and performance enhancing tips in
    detail. We hope these tips help you understand the building blocks of regular
    expressions and write better-performing regular expressions to solve complex parsing
    and matching problems.
  id: totrans-1440
  prefs: []
  type: TYPE_NORMAL
  zh: 你学会了正则表达式的测试和基准测试技术。最后，我们详细介绍了许多正则表达式优化和性能提升技巧。我们希望这些技巧能帮助你理解正则表达式的构建块，并编写性能更好的正则表达式来解决复杂的解析和匹配问题。
- en: This book was downloaded from AvaxHome!
  id: totrans-1441
  prefs: []
  type: TYPE_NORMAL
  zh: 本书是从AvaxHome下载的！
- en: 'Visit my blog for more new books:'
  id: totrans-1442
  prefs: []
  type: TYPE_NORMAL
  zh: 访问我的博客获取更多新书：
- en: '[www.avxhm.se/blogs/AlenMiler](https://tr.im/avaxhome)'
  id: totrans-1443
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.avxhm.se/blogs/AlenMiler](https://tr.im/avaxhome)'
- en: '**Inhaltsverzeichnis**'
  id: totrans-1444
  prefs: []
  type: TYPE_NORMAL
  zh: '**目录**'
- en: Preface
  id: totrans-1445
  prefs: []
  type: TYPE_NORMAL
  zh: 前言
- en: '16'
  id: totrans-1446
  prefs: []
  type: TYPE_NORMAL
  zh: '16'
- en: What this book covers
  id: totrans-1447
  prefs: []
  type: TYPE_NORMAL
  zh: 本书涵盖的内容
- en: '17'
  id: totrans-1448
  prefs: []
  type: TYPE_NORMAL
  zh: '17'
- en: What you need for this book
  id: totrans-1449
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要为本书准备什么
- en: '18'
  id: totrans-1450
  prefs: []
  type: TYPE_NORMAL
  zh: '18'
- en: Who this book is for
  id: totrans-1451
  prefs: []
  type: TYPE_NORMAL
  zh: 适用于本书的读者
- en: '19'
  id: totrans-1452
  prefs: []
  type: TYPE_NORMAL
  zh: '19'
- en: Conventions
  id: totrans-1453
  prefs: []
  type: TYPE_NORMAL
  zh: 习惯用法
- en: '20'
  id: totrans-1454
  prefs: []
  type: TYPE_NORMAL
  zh: '20'
- en: Reader feedback
  id: totrans-1455
  prefs: []
  type: TYPE_NORMAL
  zh: 读者反馈
- en: '21'
  id: totrans-1456
  prefs: []
  type: TYPE_NORMAL
  zh: '21'
- en: Customer support
  id: totrans-1457
  prefs: []
  type: TYPE_NORMAL
  zh: 客户支持
- en: '22'
  id: totrans-1458
  prefs: []
  type: TYPE_NORMAL
  zh: '22'
- en: Downloading the example code
  id: totrans-1459
  prefs: []
  type: TYPE_NORMAL
  zh: 下载示例代码
- en: '23'
  id: totrans-1460
  prefs: []
  type: TYPE_NORMAL
  zh: '23'
- en: Errata
  id: totrans-1461
  prefs: []
  type: TYPE_NORMAL
  zh: 错误
- en: '24'
  id: totrans-1462
  prefs: []
  type: TYPE_NORMAL
  zh: '24'
- en: Piracy
  id: totrans-1463
  prefs: []
  type: TYPE_NORMAL
  zh: 盗版
- en: '25'
  id: totrans-1464
  prefs: []
  type: TYPE_NORMAL
  zh: '25'
- en: Questions
  id: totrans-1465
  prefs: []
  type: TYPE_NORMAL
  zh: 问题
- en: '26'
  id: totrans-1466
  prefs: []
  type: TYPE_NORMAL
  zh: '26'
- en: Getting Started with Regular Expressions
  id: totrans-1467
  prefs: []
  type: TYPE_NORMAL
  zh: 正则表达式入门
- en: '27'
  id: totrans-1468
  prefs: []
  type: TYPE_NORMAL
  zh: '27'
- en: Introduction to regular expressions
  id: totrans-1469
  prefs: []
  type: TYPE_NORMAL
- en: '28'
  id: totrans-1470
  prefs: []
  type: TYPE_NORMAL
- en: A bit of history of regular expressions
  id: totrans-1471
  prefs: []
  type: TYPE_NORMAL
- en: '29'
  id: totrans-1472
  prefs: []
  type: TYPE_NORMAL
- en: Various flavors of regular expressions
  id: totrans-1473
  prefs: []
  type: TYPE_NORMAL
- en: '30'
  id: totrans-1474
  prefs: []
  type: TYPE_NORMAL
- en: What type of problems need regular expressions to solve
  id: totrans-1475
  prefs: []
  type: TYPE_NORMAL
- en: '31'
  id: totrans-1476
  prefs: []
  type: TYPE_NORMAL
- en: The basic rules of regular expressions
  id: totrans-1477
  prefs: []
  type: TYPE_NORMAL
- en: '32'
  id: totrans-1478
  prefs: []
  type: TYPE_NORMAL
- en: Constructs of the standard regular expression and meta
  id: totrans-1479
  prefs: []
  type: TYPE_NORMAL
- en: '33'
  id: totrans-1480
  prefs: []
  type: TYPE_NORMAL
- en: characters
  id: totrans-1481
  prefs: []
  type: TYPE_NORMAL
- en: Some basic regular expression examples
  id: totrans-1482
  prefs: []
  type: TYPE_NORMAL
- en: '36'
  id: totrans-1483
  prefs: []
  type: TYPE_NORMAL
- en: Eager matching
  id: totrans-1484
  prefs: []
  type: TYPE_NORMAL
- en: '38'
  id: totrans-1485
  prefs: []
  type: TYPE_NORMAL
- en: The effect of eager matching on regular expression alternation 39
  id: totrans-1486
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-1487
  prefs: []
  type: TYPE_NORMAL
- en: '41'
  id: totrans-1488
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the Core Constructs of Java Regular
  id: totrans-1489
  prefs: []
  type: TYPE_NORMAL
- en: '42'
  id: totrans-1490
  prefs: []
  type: TYPE_NORMAL
- en: Expressions
  id: totrans-1491
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the core constructs of regular expressions
  id: totrans-1492
  prefs: []
  type: TYPE_NORMAL
- en: '43'
  id: totrans-1493
  prefs: []
  type: TYPE_NORMAL
- en: Quantifiers
  id: totrans-1494
  prefs: []
  type: TYPE_NORMAL
- en: '44'
  id: totrans-1495
  prefs: []
  type: TYPE_NORMAL
- en: Basic quantifiers
  id: totrans-1496
  prefs: []
  type: TYPE_NORMAL
- en: '45'
  id: totrans-1497
  prefs: []
  type: TYPE_NORMAL
- en: Examples using quantifiers
  id: totrans-1498
  prefs: []
  type: TYPE_NORMAL
- en: '46'
  id: totrans-1499
  prefs: []
  type: TYPE_NORMAL
- en: Greedy versus reluctant (lazy) matching using quantifiers 47
  id: totrans-1500
  prefs: []
  type: TYPE_NORMAL
- en: Possessive quantifiers
  id: totrans-1501
  prefs: []
  type: TYPE_NORMAL
- en: '48'
  id: totrans-1502
  prefs: []
  type: TYPE_NORMAL
- en: Boundary constructs
  id: totrans-1503
  prefs: []
  type: TYPE_NORMAL
- en: '50'
  id: totrans-1504
  prefs: []
  type: TYPE_NORMAL
- en: Examples using boundary constructs
  id: totrans-1505
  prefs: []
  type: TYPE_NORMAL
- en: '51'
  id: totrans-1506
  prefs: []
  type: TYPE_NORMAL
- en: Character classes
  id: totrans-1507
  prefs: []
  type: TYPE_NORMAL
- en: '52'
  id: totrans-1508
  prefs: []
  type: TYPE_NORMAL
- en: Examples of character classes
  id: totrans-1509
  prefs: []
  type: TYPE_NORMAL
- en: '53'
  id: totrans-1510
  prefs: []
  type: TYPE_NORMAL
- en: Range inside a character class
  id: totrans-1511
  prefs: []
  type: TYPE_NORMAL
- en: '54'
  id: totrans-1512
  prefs: []
  type: TYPE_NORMAL
- en: Examples of character range
  id: totrans-1513
  prefs: []
  type: TYPE_NORMAL
- en: '55'
  id: totrans-1514
  prefs: []
  type: TYPE_NORMAL
- en: Escaping special regex metacharacters and escaping rules inside 56
  id: totrans-1515
  prefs: []
  type: TYPE_NORMAL
- en: the character classes
  id: totrans-1516
  prefs: []
  type: TYPE_NORMAL
- en: Escaping inside a character class
  id: totrans-1517
  prefs: []
  type: TYPE_NORMAL
- en: '57'
  id: totrans-1518
  prefs: []
  type: TYPE_NORMAL
- en: Examples of escaping rules inside the character class 58
  id: totrans-1519
  prefs: []
  type: TYPE_NORMAL
- en: Literally matching a string that may contain special regex 59
  id: totrans-1520
  prefs: []
  type: TYPE_NORMAL
- en: metacharacters
  id: totrans-1521
  prefs: []
  type: TYPE_NORMAL
- en: Negated character classes
  id: totrans-1522
  prefs: []
  type: TYPE_NORMAL
- en: '60'
  id: totrans-1523
  prefs: []
  type: TYPE_NORMAL
- en: Examples of negated character classes
  id: totrans-1524
  prefs: []
  type: TYPE_NORMAL
- en: '61'
  id: totrans-1525
  prefs: []
  type: TYPE_NORMAL
- en: Predefined shorthand character classes
  id: totrans-1526
  prefs: []
  type: TYPE_NORMAL
- en: '62'
  id: totrans-1527
  prefs: []
  type: TYPE_NORMAL
- en: POSIX character classes
  id: totrans-1528
  prefs: []
  type: TYPE_NORMAL
- en: '63'
  id: totrans-1529
  prefs: []
  type: TYPE_NORMAL
- en: Unicode support in Java regular expressions
  id: totrans-1530
  prefs: []
  type: TYPE_NORMAL
- en: '64'
  id: totrans-1531
  prefs: []
  type: TYPE_NORMAL
- en: Commonly used Unicode character properties
  id: totrans-1532
  prefs: []
  type: TYPE_NORMAL
- en: '65'
  id: totrans-1533
  prefs: []
  type: TYPE_NORMAL
- en: Negation of the preceding regex directives
  id: totrans-1534
  prefs: []
  type: TYPE_NORMAL
- en: '66'
  id: totrans-1535
  prefs: []
  type: TYPE_NORMAL
- en: Unicode scripts support
  id: totrans-1536
  prefs: []
  type: TYPE_NORMAL
- en: '67'
  id: totrans-1537
  prefs: []
  type: TYPE_NORMAL
- en: Examples of matching Unicode text in regular
  id: totrans-1538
  prefs: []
  type: TYPE_NORMAL
- en: '69'
  id: totrans-1539
  prefs: []
  type: TYPE_NORMAL
- en: expressions
  id: totrans-1540
  prefs: []
  type: TYPE_NORMAL
- en: Double escaping in a Java String when defining regular
  id: totrans-1541
  prefs: []
  type: TYPE_NORMAL
- en: '70'
  id: totrans-1542
  prefs: []
  type: TYPE_NORMAL
- en: expressions
  id: totrans-1543
  prefs: []
  type: TYPE_NORMAL
- en: Embedded regular expression mode modifiers
  id: totrans-1544
  prefs: []
  type: TYPE_NORMAL
- en: '71'
  id: totrans-1545
  prefs: []
  type: TYPE_NORMAL
- en: The placement of embedded modes in a Java regular
  id: totrans-1546
  prefs: []
  type: TYPE_NORMAL
- en: '73'
  id: totrans-1547
  prefs: []
  type: TYPE_NORMAL
- en: expression
  id: totrans-1548
  prefs: []
  type: TYPE_NORMAL
- en: Disabling mode modifiers
  id: totrans-1549
  prefs: []
  type: TYPE_NORMAL
- en: '74'
  id: totrans-1550
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-1551
  prefs: []
  type: TYPE_NORMAL
- en: '75'
  id: totrans-1552
  prefs: []
  type: TYPE_NORMAL
- en: Working with Groups, Capturing, and References
  id: totrans-1553
  prefs: []
  type: TYPE_NORMAL
- en: '76'
  id: totrans-1554
  prefs: []
  type: TYPE_NORMAL
- en: Capturing groups
  id: totrans-1555
  prefs: []
  type: TYPE_NORMAL
- en: '77'
  id: totrans-1556
  prefs: []
  type: TYPE_NORMAL
- en: Group numbering
  id: totrans-1557
  prefs: []
  type: TYPE_NORMAL
- en: '78'
  id: totrans-1558
  prefs: []
  type: TYPE_NORMAL
- en: Named groups
  id: totrans-1559
  prefs: []
  type: TYPE_NORMAL
- en: '80'
  id: totrans-1560
  prefs: []
  type: TYPE_NORMAL
- en: Non-capturing groups
  id: totrans-1561
  prefs: []
  type: TYPE_NORMAL
- en: '81'
  id: totrans-1562
  prefs: []
  type: TYPE_NORMAL
- en: Advantages of non-capturing groups
  id: totrans-1563
  prefs: []
  type: TYPE_NORMAL
- en: '82'
  id: totrans-1564
  prefs: []
  type: TYPE_NORMAL
- en: Back references
  id: totrans-1565
  prefs: []
  type: TYPE_NORMAL
- en: '83'
  id: totrans-1566
  prefs: []
  type: TYPE_NORMAL
- en: Back reference of a named group
  id: totrans-1567
  prefs: []
  type: TYPE_NORMAL
- en: '85'
  id: totrans-1568
  prefs: []
  type: TYPE_NORMAL
- en: Replacement reference of a named group
  id: totrans-1569
  prefs: []
  type: TYPE_NORMAL
- en: '86'
  id: totrans-1570
  prefs: []
  type: TYPE_NORMAL
- en: Forward references
  id: totrans-1571
  prefs: []
  type: TYPE_NORMAL
- en: '87'
  id: totrans-1572
  prefs: []
  type: TYPE_NORMAL
- en: Invalid (non-existing) backward or forward references
  id: totrans-1573
  prefs: []
  type: TYPE_NORMAL
- en: '89'
  id: totrans-1574
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-1575
  prefs: []
  type: TYPE_NORMAL
- en: '90'
  id: totrans-1576
  prefs: []
  type: TYPE_NORMAL
- en: Regular Expression Programming Using Java String and
  id: totrans-1577
  prefs: []
  type: TYPE_NORMAL
- en: '91'
  id: totrans-1578
  prefs: []
  type: TYPE_NORMAL
- en: Scanner APIs
  id: totrans-1579
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to the Java String API for regular expressions'
  id: totrans-1580
  prefs: []
  type: TYPE_NORMAL
- en: '92'
  id: totrans-1581
  prefs: []
  type: TYPE_NORMAL
- en: evaluation
  id: totrans-1582
  prefs: []
  type: TYPE_NORMAL
- en: Method - boolean matches(String regex)
  id: totrans-1583
  prefs: []
  type: TYPE_NORMAL
- en: '93'
  id: totrans-1584
  prefs: []
  type: TYPE_NORMAL
- en: Example of the matches method
  id: totrans-1585
  prefs: []
  type: TYPE_NORMAL
- en: '94'
  id: totrans-1586
  prefs: []
  type: TYPE_NORMAL
- en: Method - String replaceAll(String regex, String replacement) 96
  id: totrans-1587
  prefs: []
  type: TYPE_NORMAL
- en: Examples of the replaceAll method
  id: totrans-1588
  prefs: []
  type: TYPE_NORMAL
- en: '97'
  id: totrans-1589
  prefs: []
  type: TYPE_NORMAL
- en: Method - String replaceFirst(String regex, String replacement) 99
  id: totrans-1590
  prefs: []
  type: TYPE_NORMAL
- en: Examples of the replaceFirst method
  id: totrans-1591
  prefs: []
  type: TYPE_NORMAL
- en: '100'
  id: totrans-1592
  prefs: []
  type: TYPE_NORMAL
- en: Methods - String split methods
  id: totrans-1593
  prefs: []
  type: TYPE_NORMAL
- en: '101'
  id: totrans-1594
  prefs: []
  type: TYPE_NORMAL
- en: The limit parameter rules
  id: totrans-1595
  prefs: []
  type: TYPE_NORMAL
- en: '102'
  id: totrans-1596
  prefs: []
  type: TYPE_NORMAL
- en: Examples of the split method
  id: totrans-1597
  prefs: []
  type: TYPE_NORMAL
- en: '103'
  id: totrans-1598
  prefs: []
  type: TYPE_NORMAL
- en: Example of the split method using the limit parameter
  id: totrans-1599
  prefs: []
  type: TYPE_NORMAL
- en: '104'
  id: totrans-1600
  prefs: []
  type: TYPE_NORMAL
- en: Using regular expressions in Java Scanner API
  id: totrans-1601
  prefs: []
  type: TYPE_NORMAL
- en: '106'
  id: totrans-1602
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-1603
  prefs: []
  type: TYPE_NORMAL
- en: '110'
  id: totrans-1604
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to Java Regular Expression APIs - Pattern and 111
  id: totrans-1605
  prefs: []
  type: TYPE_NORMAL
- en: Matcher Classes
  id: totrans-1606
  prefs: []
  type: TYPE_NORMAL
- en: The MatchResult interface
  id: totrans-1607
  prefs: []
  type: TYPE_NORMAL
- en: '112'
  id: totrans-1608
  prefs: []
  type: TYPE_NORMAL
- en: The Pattern class
  id: totrans-1609
  prefs: []
  type: TYPE_NORMAL
- en: '114'
  id: totrans-1610
  prefs: []
  type: TYPE_NORMAL
- en: Examples using the Pattern class
  id: totrans-1611
  prefs: []
  type: TYPE_NORMAL
- en: '116'
  id: totrans-1612
  prefs: []
  type: TYPE_NORMAL
- en: Filtering a list of tokens using the asPredicate() method 119
  id: totrans-1613
  prefs: []
  type: TYPE_NORMAL
- en: The Matcher class
  id: totrans-1614
  prefs: []
  type: TYPE_NORMAL
- en: '120'
  id: totrans-1615
  prefs: []
  type: TYPE_NORMAL
- en: Examples using the Matcher class
  id: totrans-1616
  prefs: []
  type: TYPE_NORMAL
- en: '123'
  id: totrans-1617
  prefs: []
  type: TYPE_NORMAL
- en: Method Boolean lookingAt()
  id: totrans-1618
  prefs: []
  type: TYPE_NORMAL
- en: '124'
  id: totrans-1619
  prefs: []
  type: TYPE_NORMAL
- en: The matches() method
  id: totrans-1620
  prefs: []
  type: TYPE_NORMAL
- en: '125'
  id: totrans-1621
  prefs: []
  type: TYPE_NORMAL
- en: The find() and find(int start) methods
  id: totrans-1622
  prefs: []
  type: TYPE_NORMAL
- en: '126'
  id: totrans-1623
  prefs: []
  type: TYPE_NORMAL
- en: The appendReplacement(StringBuffer sb, String replacement) 128
  id: totrans-1624
  prefs: []
  type: TYPE_NORMAL
- en: method
  id: totrans-1625
  prefs: []
  type: TYPE_NORMAL
- en: The appendTail(StringBuffer sb) method
  id: totrans-1626
  prefs: []
  type: TYPE_NORMAL
- en: '129'
  id: totrans-1627
  prefs: []
  type: TYPE_NORMAL
- en: Example of the appendReplacement and appendTail methods
  id: totrans-1628
  prefs: []
  type: TYPE_NORMAL
- en: '130'
  id: totrans-1629
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-1630
  prefs: []
  type: TYPE_NORMAL
- en: '132'
  id: totrans-1631
  prefs: []
  type: TYPE_NORMAL
- en: Exploring Zero-Width Assertions, Lookarounds, and
  id: totrans-1632
  prefs: []
  type: TYPE_NORMAL
- en: '133'
  id: totrans-1633
  prefs: []
  type: TYPE_NORMAL
- en: Atomic Groups
  id: totrans-1634
  prefs: []
  type: TYPE_NORMAL
- en: Zero-width assertions
  id: totrans-1635
  prefs: []
  type: TYPE_NORMAL
- en: '134'
  id: totrans-1636
  prefs: []
  type: TYPE_NORMAL
- en: Predefined zero-width assertions
  id: totrans-1637
  prefs: []
  type: TYPE_NORMAL
- en: '135'
  id: totrans-1638
  prefs: []
  type: TYPE_NORMAL
- en: Regex defined zero-width assertions
  id: totrans-1639
  prefs: []
  type: TYPE_NORMAL
- en: '136'
  id: totrans-1640
  prefs: []
  type: TYPE_NORMAL
- en: \G boundary assertion
  id: totrans-1641
  prefs: []
  type: TYPE_NORMAL
- en: '137'
  id: totrans-1642
  prefs: []
  type: TYPE_NORMAL
- en: Atomic groups
  id: totrans-1643
  prefs: []
  type: TYPE_NORMAL
- en: '139'
  id: totrans-1644
  prefs: []
  type: TYPE_NORMAL
- en: Lookahead assertions
  id: totrans-1645
  prefs: []
  type: TYPE_NORMAL
- en: '141'
  id: totrans-1646
  prefs: []
  type: TYPE_NORMAL
- en: Positive lookahead
  id: totrans-1647
  prefs: []
  type: TYPE_NORMAL
- en: '142'
  id: totrans-1648
  prefs: []
  type: TYPE_NORMAL
- en: Negative lookahead
  id: totrans-1649
  prefs: []
  type: TYPE_NORMAL
- en: '143'
  id: totrans-1650
  prefs: []
  type: TYPE_NORMAL
- en: Lookbehind assertions
  id: totrans-1651
  prefs: []
  type: TYPE_NORMAL
- en: '144'
  id: totrans-1652
  prefs: []
  type: TYPE_NORMAL
- en: Positive lookbehind
  id: totrans-1653
  prefs: []
  type: TYPE_NORMAL
- en: '145'
  id: totrans-1654
  prefs: []
  type: TYPE_NORMAL
- en: Negative lookbehind
  id: totrans-1655
  prefs: []
  type: TYPE_NORMAL
- en: '146'
  id: totrans-1656
  prefs: []
  type: TYPE_NORMAL
- en: Capturing text from overlapping matches
  id: totrans-1657
  prefs: []
  type: TYPE_NORMAL
- en: '151'
  id: totrans-1658
  prefs: []
  type: TYPE_NORMAL
- en: Be careful with capturing groups inside a lookahead or
  id: totrans-1659
  prefs: []
  type: TYPE_NORMAL
- en: '153'
  id: totrans-1660
  prefs: []
  type: TYPE_NORMAL
- en: lookbehind atomic group
  id: totrans-1661
  prefs: []
  type: TYPE_NORMAL
- en: Lookbehind limitations in Java regular expressions
  id: totrans-1662
  prefs: []
  type: TYPE_NORMAL
- en: '154'
  id: totrans-1663
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-1664
  prefs: []
  type: TYPE_NORMAL
- en: '155'
  id: totrans-1665
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the Union, Intersection, and Subtraction of 156
  id: totrans-1666
  prefs: []
  type: TYPE_NORMAL
- en: Character Classes
  id: totrans-1667
  prefs: []
  type: TYPE_NORMAL
- en: The union of character classes
  id: totrans-1668
  prefs: []
  type: TYPE_NORMAL
- en: '157'
  id: totrans-1669
  prefs: []
  type: TYPE_NORMAL
- en: The intersection of character classes
  id: totrans-1670
  prefs: []
  type: TYPE_NORMAL
- en: '159'
  id: totrans-1671
  prefs: []
  type: TYPE_NORMAL
- en: The subtraction of character classes
  id: totrans-1672
  prefs: []
  type: TYPE_NORMAL
- en: '162'
  id: totrans-1673
  prefs: []
  type: TYPE_NORMAL
- en: Why should you use composite character classes?
  id: totrans-1674
  prefs: []
  type: TYPE_NORMAL
- en: '164'
  id: totrans-1675
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-1676
  prefs: []
  type: TYPE_NORMAL
- en: '165'
  id: totrans-1677
  prefs: []
  type: TYPE_NORMAL
- en: Regular Expression Pitfalls, Optimization, and Performance 166
  id: totrans-1678
  prefs: []
  type: TYPE_NORMAL
- en: Improvements
  id: totrans-1679
  prefs: []
  type: TYPE_NORMAL
- en: Common pitfalls and ways to avoid them while writing regular 167
  id: totrans-1680
  prefs: []
  type: TYPE_NORMAL
- en: expressions
  id: totrans-1681
  prefs: []
  type: TYPE_NORMAL
- en: Do not forget to escape regex metacharacters outside a character 168
  id: totrans-1682
  prefs: []
  type: TYPE_NORMAL
- en: class
  id: totrans-1683
  prefs: []
  type: TYPE_NORMAL
- en: Avoid escaping every non-word character
  id: totrans-1684
  prefs: []
  type: TYPE_NORMAL
- en: '169'
  id: totrans-1685
  prefs: []
  type: TYPE_NORMAL
- en: Avoid unnecessary capturing groups to reduce memory
  id: totrans-1686
  prefs: []
  type: TYPE_NORMAL
- en: '170'
  id: totrans-1687
  prefs: []
  type: TYPE_NORMAL
- en: consumption
  id: totrans-1688
  prefs: []
  type: TYPE_NORMAL
- en: However, don't forget to use the required group around
  id: totrans-1689
  prefs: []
  type: TYPE_NORMAL
- en: '171'
  id: totrans-1690
  prefs: []
  type: TYPE_NORMAL
- en: alternation
  id: totrans-1691
  prefs: []
  type: TYPE_NORMAL
- en: Use predefined character classes instead of longer versions 172
  id: totrans-1692
  prefs: []
  type: TYPE_NORMAL
- en: Use the limiting quantifier instead of repeating a character or 173
  id: totrans-1693
  prefs: []
  type: TYPE_NORMAL
- en: pattern multiple times
  id: totrans-1694
  prefs: []
  type: TYPE_NORMAL
- en: Do not use an unescaped hyphen in the middle of a character 174
  id: totrans-1695
  prefs: []
  type: TYPE_NORMAL
- en: class
  id: totrans-1696
  prefs: []
  type: TYPE_NORMAL
- en: The mistake of calling matcher.goup() without a prior call to 175
  id: totrans-1697
  prefs: []
  type: TYPE_NORMAL
- en: matcher.find(), matcher.matches(), or matcher.lookingAt() Do not use regular
    expressions to parse XML / HTML data
  id: totrans-1698
  prefs: []
  type: TYPE_NORMAL
- en: '177'
  id: totrans-1699
  prefs: []
  type: TYPE_NORMAL
- en: How to test and benchmark your regular expression performance 178
  id: totrans-1700
  prefs: []
  type: TYPE_NORMAL
- en: Catastrophic or exponential backtracking
  id: totrans-1701
  prefs: []
  type: TYPE_NORMAL
- en: '179'
  id: totrans-1702
  prefs: []
  type: TYPE_NORMAL
- en: How to avoid catastrophic backtracking
  id: totrans-1703
  prefs: []
  type: TYPE_NORMAL
- en: '182'
  id: totrans-1704
  prefs: []
  type: TYPE_NORMAL
- en: Optimization and performance enhancement tips
  id: totrans-1705
  prefs: []
  type: TYPE_NORMAL
- en: '185'
  id: totrans-1706
  prefs: []
  type: TYPE_NORMAL
- en: Use a compiled form of regular expressions
  id: totrans-1707
  prefs: []
  type: TYPE_NORMAL
- en: '186'
  id: totrans-1708
  prefs: []
  type: TYPE_NORMAL
- en: Use a negated character class instead of the greedy and slow .*
  id: totrans-1709
  prefs: []
  type: TYPE_NORMAL
- en: '187'
  id: totrans-1710
  prefs: []
  type: TYPE_NORMAL
- en: or .+
  id: totrans-1711
  prefs: []
  type: TYPE_NORMAL
- en: Avoid unnecessary grouping
  id: totrans-1712
  prefs: []
  type: TYPE_NORMAL
- en: '188'
  id: totrans-1713
  prefs: []
  type: TYPE_NORMAL
- en: Use lazy quantifiers strategically instead of greedy quantifiers 189
  id: totrans-1714
  prefs: []
  type: TYPE_NORMAL
- en: that cause excessive backtracking
  id: totrans-1715
  prefs: []
  type: TYPE_NORMAL
- en: Make use of possessive quantifiers to avoid backtracking
  id: totrans-1716
  prefs: []
  type: TYPE_NORMAL
- en: '190'
  id: totrans-1717
  prefs: []
  type: TYPE_NORMAL
- en: Extract common repeating substrings out of alternation
  id: totrans-1718
  prefs: []
  type: TYPE_NORMAL
- en: '191'
  id: totrans-1719
  prefs: []
  type: TYPE_NORMAL
- en: Use atomic group to avoid backtracking and fail fast
  id: totrans-1720
  prefs: []
  type: TYPE_NORMAL
- en: '192'
  id: totrans-1721
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-1722
  prefs: []
  type: TYPE_NORMAL
- en: '193'
  id: totrans-1723
  prefs: []
  type: TYPE_NORMAL
- en: Document Outline
  id: totrans-1724
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[Preface](index_split_000.html#p16)'
  id: totrans-1725
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[What this book covers](index_split_000.html#p17)'
  id: totrans-1726
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[What you need for this book](index_split_000.html#p18)'
  id: totrans-1727
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Who this book is for](index_split_000.html#p19)'
  id: totrans-1728
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Conventions](index_split_000.html#p20)'
  id: totrans-1729
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Reader feedback](index_split_000.html#p21)'
  id: totrans-1730
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Customer support](index_split_000.html#p22)'
  id: totrans-1731
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Downloading the example code](index_split_000.html#p23)'
  id: totrans-1732
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Errata](index_split_000.html#p24)'
  id: totrans-1733
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[勘误表](index_split_000.html#p24)'
- en: '[Piracy](index_split_000.html#p25)'
  id: totrans-1734
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[盗版](index_split_000.html#p25)'
- en: '[Questions](index_split_000.html#p26)'
  id: totrans-1735
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[问题](index_split_000.html#p26)'
- en: '[Getting Started with Regular Expressions](index_split_000.html#p27)'
  id: totrans-1736
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[正则表达式入门](index_split_000.html#p27)'
- en: '[Introduction to regular expressions](index_split_000.html#p28)'
  id: totrans-1737
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[正则表达式简介](index_split_000.html#p28)'
- en: '[A bit of history of regular expressions](index_split_000.html#p29)'
  id: totrans-1738
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[正则表达式的一些历史](index_split_000.html#p29)'
- en: '[Various flavors of regular expressions](index_split_000.html#p30)'
  id: totrans-1739
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[正则表达式的各种风味](index_split_000.html#p30)'
- en: '[What type of problems need regular expressions to solve](index_split_000.html#p31)'
  id: totrans-1740
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[需要正则表达式解决的问题类型](index_split_000.html#p31)'
- en: '[The basic rules of regular expressions](index_split_000.html#p32)'
  id: totrans-1741
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[正则表达式的基本规则](index_split_000.html#p32)'
- en: '[Constructs of the standard regular expression and meta characters](index_split_000.html#p33)'
  id: totrans-1742
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[标准正则表达式和元字符的构造](index_split_000.html#p33)'
- en: '[Some basic regular expression examples](index_split_000.html#p36)'
  id: totrans-1743
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[一些基本的正则表达式示例](index_split_000.html#p36)'
- en: '[Eager matching](index_split_000.html#p38)'
  id: totrans-1744
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[贪婪匹配](index_split_000.html#p38)'
- en: '[The effect of eager matching on regular expression alternation](index_split_000.html#p39)'
  id: totrans-1745
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[贪婪匹配对正则表达式交替的影响](index_split_000.html#p39)'
- en: '[Summary](index_split_000.html#p41)'
  id: totrans-1746
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[摘要](index_split_000.html#p41)'
- en: '[Understanding the Core Constructs of Java Regular Expressions](index_split_000.html#p42)'
  id: totrans-1747
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[理解Java正则表达式的核心构造](index_split_000.html#p42)'
- en: '[Understanding the core constructs of regular expressions](index_split_000.html#p43)'
  id: totrans-1748
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[理解正则表达式的核心构造](index_split_000.html#p43)'
- en: '[Quantifiers](index_split_000.html#p44)'
  id: totrans-1749
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[量词](index_split_000.html#p44)'
- en: '[Basic quantifiers](index_split_000.html#p45)'
  id: totrans-1750
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[基本量词](index_split_000.html#p45)'
- en: '[Examples using quantifiers](index_split_000.html#p46)'
  id: totrans-1751
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[使用量词的示例](index_split_000.html#p46)'
- en: '[Greedy versus reluctant (lazy) matching using quantifiers](index_split_000.html#p47)'
  id: totrans-1752
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[使用量词的贪婪与懒惰（懒）匹配](index_split_000.html#p47)'
- en: '[Possessive quantifiers](index_split_000.html#p48)'
  id: totrans-1753
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[占有量词](index_split_000.html#p48)'
- en: '[Boundary constructs](index_split_000.html#p50)'
  id: totrans-1754
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[边界构造](index_split_000.html#p50)'
- en: '[Examples using boundary constructs](index_split_000.html#p51)'
  id: totrans-1755
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[使用边界构造的示例](index_split_000.html#p51)'
- en: '[Character classes](index_split_000.html#p52)'
  id: totrans-1756
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[字符类](index_split_000.html#p52)'
- en: '[Examples of character classes](index_split_000.html#p53)'
  id: totrans-1757
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[字符类示例](index_split_000.html#p53)'
- en: '[Range inside a character class](index_split_000.html#p54)'
  id: totrans-1758
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[字符类内部的范围](index_split_000.html#p54)'
- en: '[Examples of character range](index_split_000.html#p55)'
  id: totrans-1759
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[字符范围示例](index_split_000.html#p55)'
- en: '[Escaping special regex metacharacters and escaping rules inside the character
    classes](index_split_000.html#p56)'
  id: totrans-1760
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[转义特殊正则表达式元字符和字符类内部的转义规则](index_split_000.html#p56)'
- en: '[Escaping inside a character class](index_split_000.html#p57)'
  id: totrans-1761
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[字符类内部的转义](index_split_000.html#p57)'
- en: '[Examples of escaping rules inside the character class](index_split_000.html#p58)'
  id: totrans-1762
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[字符类内部转义规则示例](index_split_000.html#p58)'
- en: '[Literally matching a string that may contain special regex metacharacters](index_split_000.html#p59)'
  id: totrans-1763
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[字面匹配可能包含特殊正则表达式元字符的字符串](index_split_000.html#p59)'
- en: '[Negated character classes](index_split_000.html#p60)'
  id: totrans-1764
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[否定字符类](index_split_000.html#p60)'
- en: '[Examples of negated character classes](index_split_000.html#p61)'
  id: totrans-1765
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[否定字符类示例](index_split_000.html#p61)'
- en: '[Predefined shorthand character classes](index_split_000.html#p62)'
  id: totrans-1766
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[预定义的简写字符类](index_split_000.html#p62)'
- en: '[POSIX character classes](index_split_000.html#p63)'
  id: totrans-1767
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[POSIX字符类](index_split_000.html#p63)'
- en: '[Unicode support in Java regular expressions](index_split_000.html#p64)'
  id: totrans-1768
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Java正则表达式中的Unicode支持](index_split_000.html#p64)'
- en: '[Commonly used Unicode character properties](index_split_000.html#p65)'
  id: totrans-1769
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[常用Unicode字符属性](index_split_000.html#p65)'
- en: '[Negation of the preceding regex directives](index_split_000.html#p66)'
  id: totrans-1770
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[先前正则表达式指令的否定](index_split_000.html#p66)'
- en: '[Unicode scripts support](index_split_000.html#p67)'
  id: totrans-1771
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Unicode脚本支持](index_split_000.html#p67)'
- en: '[Examples of matching Unicode text in regular expressions](index_split_000.html#p69)'
  id: totrans-1772
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[正则表达式中匹配Unicode文本的示例](index_split_000.html#p69)'
- en: '[Double escaping in a Java String when defining regular expressions](index_split_000.html#p70)'
  id: totrans-1773
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[在定义正则表达式时Java字符串中的双重转义](index_split_000.html#p70)'
- en: '[Embedded regular expression mode modifiers](index_split_000.html#p71)'
  id: totrans-1774
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[内嵌正则表达式模式修饰符](index_split_000.html#p71)'
- en: '[The placement of embedded modes in a Java regular expression](index_split_000.html#p73)'
  id: totrans-1775
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Java正则表达式中内嵌模式的放置](index_split_000.html#p73)'
- en: '[Disabling mode modifiers](index_split_000.html#p74)'
  id: totrans-1776
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[禁用模式修饰符](index_split_000.html#p74)'
- en: '[Summary](index_split_000.html#p75)'
  id: totrans-1777
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[摘要](index_split_000.html#p75)'
- en: '[Working with Groups, Capturing, and References](index_split_000.html#p76)'
  id: totrans-1778
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Capturing groups](index_split_000.html#p77)'
  id: totrans-1779
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Group numbering](index_split_000.html#p78)'
  id: totrans-1780
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Named groups](index_split_000.html#p80)'
  id: totrans-1781
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Non-capturing groups](index_split_000.html#p81)'
  id: totrans-1782
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Advantages of non-capturing groups](index_split_000.html#p82)'
  id: totrans-1783
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Back references](index_split_000.html#p83)'
  id: totrans-1784
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Back reference of a named group](index_split_000.html#p85)'
  id: totrans-1785
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Replacement reference of a named group](index_split_000.html#p86)'
  id: totrans-1786
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Forward references](index_split_000.html#p87)'
  id: totrans-1787
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Invalid (non-existing) backward or forward references](index_split_000.html#p89)'
  id: totrans-1788
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Summary](index_split_000.html#p90)'
  id: totrans-1789
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Regular Expression Programming Using Java String and Scanner APIs](index_split_000.html#p91)'
  id: totrans-1790
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Introduction to the Java String API for regular expressions'' evaluation](index_split_000.html#p92)'
  id: totrans-1791
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Method - boolean matches(String regex)](index_split_000.html#p93)'
  id: totrans-1792
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Example of the matches method](index_split_000.html#p94)'
  id: totrans-1793
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Method - String replaceAll(String regex, String replacement)](index_split_000.html#p96)'
  id: totrans-1794
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Examples of the replaceAll method](index_split_000.html#p97)'
  id: totrans-1795
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Method - String replaceFirst(String regex, String replacement)](index_split_000.html#p99)'
  id: totrans-1796
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Examples of the replaceFirst method](index_split_000.html#p100)'
  id: totrans-1797
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Methods - String split methods](index_split_000.html#p101)'
  id: totrans-1798
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[The limit parameter rules](index_split_000.html#p102)'
  id: totrans-1799
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Examples of the split method](index_split_000.html#p103)'
  id: totrans-1800
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Example of the split method using the limit parameter](index_split_000.html#p104)'
  id: totrans-1801
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Using regular expressions in Java Scanner API](index_split_000.html#p106)'
  id: totrans-1802
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Summary](index_split_001.html#p110)'
  id: totrans-1803
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Introduction to Java Regular Expression APIs - Pattern and Matcher Classes](index_split_001.html#p111)'
  id: totrans-1804
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[The MatchResult interface](index_split_001.html#p112)'
  id: totrans-1805
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[The Pattern class](index_split_001.html#p114)'
  id: totrans-1806
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Examples using the Pattern class](index_split_001.html#p116)'
  id: totrans-1807
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Filtering a list of tokens using the asPredicate() method](index_split_001.html#p119)'
  id: totrans-1808
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[The Matcher class](index_split_001.html#p120)'
  id: totrans-1809
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Examples using the Matcher class](index_split_001.html#p123)'
  id: totrans-1810
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Method Boolean lookingAt()](index_split_001.html#p124)'
  id: totrans-1811
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[The matches() method](index_split_001.html#p125)'
  id: totrans-1812
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[The find() and find(int start) methods](index_split_001.html#p126)'
  id: totrans-1813
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[The appendReplacement(StringBuffer sb, String replacement) method](index_split_001.html#p128)'
  id: totrans-1814
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[The appendTail(StringBuffer sb) method](index_split_001.html#p129)'
  id: totrans-1815
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Example of the appendReplacement and appendTail methods](index_split_001.html#p130)'
  id: totrans-1816
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Summary](index_split_001.html#p132)'
  id: totrans-1817
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Exploring Zero-Width Assertions, Lookarounds, and Atomic Groups](index_split_001.html#p133)'
  id: totrans-1818
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Zero-width assertions](index_split_001.html#p134)'
  id: totrans-1819
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Predefined zero-width assertions](index_split_001.html#p135)'
  id: totrans-1820
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Regex defined zero-width assertions](index_split_001.html#p136)'
  id: totrans-1821
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[\G boundary assertion](index_split_001.html#p137)'
  id: totrans-1822
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Atomic groups](index_split_001.html#p139)'
  id: totrans-1823
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Lookahead assertions](index_split_001.html#p141)'
  id: totrans-1824
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Positive lookahead](index_split_001.html#p142)'
  id: totrans-1825
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Negative lookahead](index_split_001.html#p143)'
  id: totrans-1826
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Lookbehind assertions](index_split_001.html#p144)'
  id: totrans-1827
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Positive lookbehind](index_split_001.html#p145)'
  id: totrans-1828
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Negative lookbehind](index_split_001.html#p146)'
  id: totrans-1829
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Capturing text from overlapping matches](index_split_001.html#p151)'
  id: totrans-1830
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Be careful with capturing groups inside a lookahead or lookbehind atomic group](index_split_001.html#p153)'
  id: totrans-1831
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Lookbehind limitations in Java regular expressions](index_split_001.html#p154)'
  id: totrans-1832
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Summary](index_split_001.html#p155)'
  id: totrans-1833
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Understanding the Union, Intersection, and Subtraction of Character Classes](index_split_001.html#p156)'
  id: totrans-1834
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[The union of character classes](index_split_001.html#p157)'
  id: totrans-1835
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[The intersection of character classes](index_split_001.html#p159)'
  id: totrans-1836
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[The subtraction of character classes](index_split_001.html#p162)'
  id: totrans-1837
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Why should you use composite character classes?](index_split_001.html#p164)'
  id: totrans-1838
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Summary](index_split_001.html#p165)'
  id: totrans-1839
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Regular Expression Pitfalls, Optimization, and Performance Improvements](index_split_001.html#p166)'
  id: totrans-1840
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Common pitfalls and ways to avoid them while writing regular expressions](index_split_001.html#p167)'
  id: totrans-1841
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Do not forget to escape regex metacharacters outside a character class](index_split_001.html#p168)'
  id: totrans-1842
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Avoid escaping every non-word character](index_split_001.html#p169)'
  id: totrans-1843
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Avoid unnecessary capturing groups to reduce memory consumption](index_split_001.html#p170)'
  id: totrans-1844
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[However, don''t forget to use the required group around alternation](index_split_001.html#p171)'
  id: totrans-1845
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Use predefined character classes instead of longer versions](index_split_001.html#p172)'
  id: totrans-1846
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Use the limiting quantifier instead of repeating a character or pattern multiple
    times](index_split_001.html#p173)'
  id: totrans-1847
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Do not use an unescaped hyphen in the middle of a character class](index_split_001.html#p174)'
  id: totrans-1848
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[The mistake of calling matcher.goup() without a prior call to matcher.find(),
    matcher.matches(), or matcher.lookingAt()](index_split_001.html#p175)'
  id: totrans-1849
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Do not use regular expressions to parse XML / HTML data](index_split_001.html#p177)'
  id: totrans-1850
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[How to test and benchmark your regular expression performance](index_split_001.html#p178)'
  id: totrans-1851
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Catastrophic or exponential backtracking](index_split_001.html#p179)'
  id: totrans-1852
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[How to avoid catastrophic backtracking](index_split_001.html#p182)'
  id: totrans-1853
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Optimization and performance enhancement tips](index_split_001.html#p185)'
  id: totrans-1854
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Use a compiled form of regular expressions](index_split_001.html#p186)'
  id: totrans-1855
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Use a negated character class instead of the greedy and slow .* or .+](index_split_001.html#p187)'
  id: totrans-1856
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Avoid unnecessary grouping](index_split_001.html#p188)'
  id: totrans-1857
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Use lazy quantifiers strategically instead of greedy quantifiers that cause
    excessive backtracking](index_split_001.html#p189)'
  id: totrans-1858
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Make use of possessive quantifiers to avoid backtracking](index_split_001.html#p190)'
  id: totrans-1859
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Extract common repeating substrings out of alternation](index_split_001.html#p191)'
  id: totrans-1860
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Use atomic group to avoid backtracking and fail fast](index_split_001.html#p192)'
  id: totrans-1861
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Summary](index_split_001.html#p193)'
  id: totrans-1862
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
