<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">The Actor Model in Practice</h1>
                </header>
            
            <article>
                
<p>In the previous chapter, we started to look at the actors model as one of their concurrency models available in Scala. In <a href="6b6045c0-bf4d-4ae9-adc1-fdaf23985329.xhtml" target="_blank">Chapter 9</a>, <em>Libraries for Pure Functional Programming</em>, we saw how challenges of asynchronous and multithreaded programming can be solved using IO and the infrastructure it provides. However, this kind of technology is still not widely adopted. In practice, when working with multithreading, concurrency, and asynchrony in Scala, you will need to deal with more robust libraries in real-world situations.</p>
<p>In this chapter, we will look at the following topics:</p>
<ul>
<li>Akka overview</li>
<li>Defining, creating, and messaging actors</li>
<li>Working with actor systems</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Akka overview</h1>
                </header>
            
            <article>
                
<p>Akka is an implementation of the actor model, which we discussed in the previous chapter for its industrial purposes. If the Cats effect focuses on experimentation and trials with new technologies, then Akka focuses on providing the industry with the tools that can solve large-scale problems. Of course, we can expect cats to mature to that level as well, however, if you are going to work with concurrency and asynchrony in Scala in a real-world situation, it is likely you will encounter Akka.</p>
<p>The purpose of this book is to make you comfortable with modern technologies in functional programming that are in demand in real-world situations. Since concurrent and asynchronous programming is ubiquitous, we are going to discuss the tools that are most widely used to tackle its challenges. We will start by looking at the principles on which Akka is built.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Principles of Akka</h1>
                </header>
            
            <article>
                
<p>The central abstraction of Akka is an actor. An actor is an entity that can receive and send messages to other actors.</p>
<p>Actors are lightweight concurrency primitives. Similarly to how you can have millions of Fibres in cats, you can have millions of actors in Akka. This is because they utilize asynchrony and provide abstractions on top of standard Java virtual machine threads. By utilizing the resources of the JVM, you can have millions of actors in parallel on a single machine.</p>
<p>Akka is built with scaling in mind. The library does not stop at providing you with the abstractions for actors themselves. Similarly to how cats has an infrastructure of libraries for various specific cases of functional programming, Akka has a host of libraries for special cases of asynchronous programming. You will encounter an HTTP server as part of this library, which is an infrastructure to allow you to communicate between actors that reside on different machines.</p>
<p>The purpose of the actors model is to provide you with a concurrency framework that will reduce your mental overhead and allow for robust and scalable software.</p>
<p>To overcome the challenges that concurrent programming poses, Akka imposes a range of pretty harsh restrictions on a programmer. One can expect to benefit from the model only if they follow these restrictions. It is important to remember that the rules the actor model imposes are not encoded and enforced by the compiler. So it is up to you to follow them. Breaking them at will is easy. It is important to remember that if you do so, it is very likely that you are going to end up with even more of a headache than you had without the actor model.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Encapsulation</h1>
                </header>
            
            <article>
                
<p>One problem with concurrent programming is the shared mutable state. Akka eliminates this problem by providing a restriction that it is impossible to access your actors as ordinary objects. This means your business logic does not have a single variable that would store an actor. Hence, it is impossible to access the values defined on the actors by ordinary object-oriented means.</p>
<p>The actors are exposed to the outer world via proxy types—<kbd>ActorRef</kbd>s. The Akka library defines this type, and only safe operations are permitted on an actor.</p>
<p>If you want to do something with an actor, you should do so via this proxy. Also, you do not instantiate an actor as an ordinary Java or Scala object. You do not call a constructor on it. Instead, you will instruct <kbd>ActorSystem</kbd> to instantiate it. With these constraints, it becomes impossible to accept the data of an actor by any means other than messaging it.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Messaging</h1>
                </header>
            
            <article>
                
<p>Every actor has a mailbox, where any other messages can be sent. Akka guarantees that the messages are handled by the actor one at a time, and no concurrent handling happens. In fact, the actor model provides a guarantee that no more than one thread accesses the internal state of an actor at a time. However, keep in mind that it is up to the programmer to follow the actor model precisely. It is easy to break the model by spawning extra threads (e.g. with a <kbd>Future</kbd>) in an actor, thus breaking the single-threaded access guarantee.</p>
<p>This restriction is essential to enforce in the presence of other convenient concurrency libraries, such as Future. Akka works hand-in-hand with Scala Future. It is important to remember that futures start and work from other threads. So, the moment you start a Future in Akka, you lose the guarantee of single-threaded access to the state of an actor. If you follow this road, you will need to specify the synchronization and utilize the monitor mechanism provided to you by the JVM. This is an anti-pattern, it kills the very purpose of Akka, and is a big no-no in actor programming.</p>
<p>Remember that the model is going to help you only if you follow its rules, and there is nothing to enforce you to do so.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">No leaking of mutable state</h1>
                </header>
            
            <article>
                
<p>Another thing that you must look out for when programming with Akka is leaking mutable state of the actors. Remember the previous principle that no more than a single thread must access the inner state of an actor? Well, if you send a reference to a mutable object that is owned by one actor to another one, this object may be accessed from two threads at a time in parallel. If you leak mutable state to other actors, you may end up with a worse headache than when starting a Future from an actor. In the case of starting a Future, at least you have control over that Future and the thread it started from; you can define some monitors and  protocols to access the actor's state. Of course, you should not do it, but in theory, it is possible.</p>
<p>However, if you leak a reference to a mutable state from one actor to another, you will have no control whatsoever over how that actor will use it.</p>
<p>Again, this rule is not enforced by Akka. In Akka, you can pass any object as a message to another actor. This includes mutable references. So, you should be aware of the possibility and actively avoid it.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Fault-tolerance and supervision</h1>
                </header>
            
            <article>
                
<p>Akka is built with resilience and fault-tolerance in mind. This means that if an actor fails as a result of an exception, there is a well-defined way it will automatically restart and restore its state. Akka organizes actors in hierarchies, and parent actors are responsible for the performance of their children. So, if a child fails, its parent is supposed to be responsible for restarting it. The idea is that the external world should not be affected by the problems of an actor's subordinates. If the problem happens, it is the supervisor's responsibility to solve it rather than escalating it further. And when the child actor restarts, it should be able to restore itself to the state it was at when it failed.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Messaging guarantees</h1>
                </header>
            
            <article>
                
<p>Akka is built to be deployed in clusters, over the network. This means that you have fewer delivery guarantees about the messages than when you are working on a single JVM application. If you are sending a message from an actor that resides in one computer to an actor on another side of the world, you cannot guarantee that this message will get delivered.</p>
<p>So, the actor model as implemented by Akka requires you to build your applications with no guarantees whatsoever about delivering the messages. Your application must be robust to the situations of the impossibility of message-delivery.</p>
<p>However, Akka provides you with a guarantee about the order in which messages from one actor to another get delivered. This means that if from the same actor, you send a message before another, you can be sure that message also arrives before the second one.</p>
<p>The best thing to do after learning the preceding theory is to have a look at how it works in practice. Next, we will be discussing an example that relies on the numerous functionalities that Akka exposes. We will be learning these functionalities as we encounter them.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Asynchrony</h1>
                </header>
            
            <article>
                
<p>Remember when we discussed IO, we stressed the importance of asynchrony and non-blocking computations? Threads of the underlying operating system are scarce, and on a system with high load, you need to utilize them well. Blocking is not a wise utilization of the threads.</p>
<p>We have discussed that you should not invoke other threads from the current actor. The motivation for this is to prevent access to the mutable state of the current actor from more than one thread. We have discussed that whenever we need to process something, we schedule the processing as a message to the current actor.</p>
<p>Therefore, to enforce single-threaded processing, you might be tempted to block on a future from a message-handling logic, as follows:</p>
<pre>Await.ready(future, 3 seconds)</pre>
<p>However, this blocks the underlying thread. Blocking turns an actor that does so into a heavyweight concurrency primitive. If you use it in a setting of a high-load application, it will eat system-concurrency resources fast. The rationale here is the same as when we were discussing IO. Bottom line: do not block your concurrency primitives because the threads are scarce. If you need to wait for the result of some asynchronous computation to continue the current computation, make sure that that the computation will send this actor a message when it finishes, register a handler on the current actor saying what to do once the task finishes, and release the current thread.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Defining, creating, and messaging actors</h1>
                </header>
            
            <article>
                
<p>The actors are defined as classes that inherit from the <kbd>Actor</kbd> class from the Akka library:</p>
<pre>class HelloWorld extends Actor {</pre>
<p class="mce-root">Actor exposes the following abstract API:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/2ccebe72-90ba-46e7-a07d-2ff51a1a18a5.png" style="width:56.00em;height:13.75em;"/></p>
<p>The only method that is abstract in <kbd>Actor</kbd> is the <kbd>receive</kbd> method. Akka calls this method when an actor needs to handle an incoming message. It returns a partial function from <kbd>Any</kbd> to <kbd>Unit</kbd>. This means that it is capable of handling a message from a domain of all objects, and it is supposed to produce some side effects while handling this message, which is indicated by the <kbd>Unit</kbd> return type. That function is a partial function, which means that it can handle only a part of the input <kbd>Any</kbd> domain that your actor is interested in.</p>
<p>When your define an actor, you override this method to define what the actor must do:</p>
<pre>val log = Logging(context.system, this)<br/><br/>def receive = {<br/>  case Ping ⇒ log.info("Hello World")<br/>}</pre>
<p>The message is defined as follows:</p>
<pre>case object Ping</pre>
<p>So, when an actor receives the ping message, it will output the <kbd>hello world</kbd> string to the log. We can construct the log with the help of the following function:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/dc14022b-24bb-4ca5-aa76-8a5172aa424e.png" style="width:42.75em;height:17.08em;"/></p>
<p>This function is defined over the following object:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/d981b63f-57f1-4421-93f1-8bd8ea6c92e8.png" style="width:60.50em;height:18.83em;"/></p>
<p>One of the abstractions Akka relies upon is the event system. Events can be used to track the changes in the state of an actor and restore it to the previous state in case of failure. Since logging is also an event stream in a sense, Akka provides you with an elaborate logging infrastructure that also integrates with its general event system. When constructing a logger, you will need to provide the <kbd>ActorSystem</kbd> you are defining it for, as well as the reference to the current actor. You will then be able to display the log messages properly while specifying the current actor.</p>
<p>Notice that here, to construct the logger, we are accessing some other API defined on the actor. We are calling the context method and its member-system method. So, next, let's have a look at the API the actor exposes.</p>
<p>All of the concrete members of the <kbd>Actor</kbd> class can be divided into several groups.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Callbacks</h1>
                </header>
            
            <article>
                
<p>The following methods belong to the callbacks group:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/25f95e92-7c78-49ad-8573-5fcc394b2e4a.png" style="width:49.75em;height:16.33em;"/></p>
<p>The Akka framework in different situations calls these callbacks. For example, <kbd>postStop</kbd> is called after the actor stops. <kbd>preStart</kbd> is called before the actor starts. <kbd>preRestart</kbd> is called before, and <kbd>afterRestart</kbd> is called after, the actor has restarted. The restart callbacks take a <kbd>reason</kbd> as an argument. The <kbd>reason</kbd> is an exception due to which this actor had to restart itself. It is also part of Akka's fault-tolerance strategy. When building your actors, you should keep the possibility of such restarting in mind.</p>
<p><span>Finally, the </span><kbd>unhandled</kbd><span> method is called whenever a message arrives at an actor that it is not capable of handling it:</span></p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/2edac43e-39d2-4353-98d2-dcf08e60b1fb.png" style="width:50.67em;height:9.33em;"/></p>
<p>Remember that we have discussed that the <kbd>receive</kbd> method returns a partial function. This means it is defined only on a part of its domain type. So, whenever a message arrives at an actor that it is not able to handle, the unhandled callback is called instead.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Supervision</h1>
                </header>
            
            <article>
                
<p>Also, part of the fault-tolerance strategy that Actor provides is the <kbd>supervisorStrategy</kbd> method:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/959743bd-0a01-4bcd-80d4-22fdf7ac5aa6.png" style="width:34.08em;height:3.92em;"/></p>
<p>You can override this method to provide the actor with different ways to supervise its children. Supervision is the concept of watching the children's life cycle and taking actions on significant events, such as when an actor fails with an exception. In Akka, parent actors are supposed to supervise child actors. The supervision strategy is defined as follows:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/0a2d5019-f626-4dbb-b4d7-8e8452f3cde8.png" style="width:66.17em;height:32.67em;"/></p>
<p>As you can see, there are two subclasses defined for this class, and the documentation suggests you shouldn't implement additional subclasses because an incorrect implementation can lead to erroneous behavior:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/567857e7-750d-44b1-ae49-91a467650602.png" style="width:61.00em;height:15.92em;"/></p>
<p><kbd>AllForOneStrategy</kbd> will apply a given action to all of the children if one fails:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/fb9fa2ed-b0ab-4631-a5cb-91a3b60deb7a.png" style="width:47.00em;height:12.08em;"/></p>
<p><kbd>OneForOneStrategy</kbd> will apply an action only to the child that failed.</p>
<p>Notice also that both strategies are parameterized by various parameters that define how it should handle situations with failed children. One of these parameters is <kbd>Decider</kbd>:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/bffb40cc-0a99-4fb7-b544-e37b43f5b96b.png" style="width:27.08em;height:2.33em;"/></p>
<p>The <kbd>Decider</kbd> type is a partial function from a <kbd>Throwable</kbd> to a <kbd>Directive</kbd>. It takes a <kbd>Throwable</kbd> (which can be an <kbd>Exception</kbd> or an <kbd>Error</kbd>) that has occurred in the actor, and the job of <kbd>Decider</kbd> is to provide information to the actor system on how to handle this exception. </p>
<p><kbd>Directive</kbd><span> defines what to do on a </span>given<span> exception with an actor:</span></p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/1761d58a-5690-4282-a2b8-f97dc47c8726.png" style="width:17.25em;height:17.17em;"/></p>
<p>There are four subclasses to the <kbd>Directive</kbd> trait. <span>The </span><kbd>Escalate</kbd><span> directive escalates the exception to the parent of the supervising actor. So, when the child fails, the parent will also fail and will rely on its own parent to handle the exception.</span></p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/b6d3f406-a07e-49ab-bdf4-a663bde60bff.png" style="width:67.50em;height:13.08em;"/></p>
<p><span>The </span><kbd>Restart</kbd><span> directive will discard the actor that failed and will create a new actor in its place:</span></p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/699d3e4a-9b5c-4502-97b1-ca92edd3a756.png" style="width:38.33em;height:10.75em;"/></p>
<p><span>The </span><kbd>Resume</kbd><span> directive will instruct the </span>actor<span> that had an exception to continue processing the messages:</span></p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/dd04c5b5-d99c-4a2f-8d86-08b3f6510817.png" style="width:35.67em;height:10.17em;"/></p>
<p><span>The exception will be ignored, and no action will be taken to handle it. The child actor will continue as it did previously.</span></p>
<p><span>Finally, the </span><kbd>Stop</kbd><span> directive will stop the current actor without starting another one in its place.</span></p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/690b5fd8-cbdc-47b2-a035-cf5816285b79.png" style="width:35.83em;height:10.33em;"/></p>
<p>The preceding infrastructure provides you with the capability to construct hierarchies where parents are responsible for the sound operation of the children. This approach provides a separation of concerns and enables a degree of local reasoning. This means that actor systems handle the failures as early as possible instead of propagating them up the hierarchy.</p>
<p>Hierarchies also provide you with a measure of abstraction, because you no longer care about the children of a given actor, you can treat a given actor as a single point of responsibility for the task that it was asked to do. A single point of responsibility is similar to how, in organizations, you have a single person responsible for a department, and whenever you need the department to do something, you talk to the responsible person. You expect them to run the department properly. Akka is built the same way. Whenever you have a concern, you have an actor responsible for this concern. It may or may not have child actors that help them work on this concern, however, as an outside observer, you do not need to be aware of these factors. You do not need to care about the errors that happen to these subordinates. This is, of course, only if the errors in question can be localized to a given department. If the error is more significant than what the department can handle, it propagates up the chain.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Context and references</h1>
                </header>
            
            <article>
                
<p>Apart from the callbacks that give you control over how an actor reacts to various life cycle events, an actor has an API for managing the context of its execution:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/40ddd79e-c87b-4272-ba80-9259143b5b82.png" style="width:62.25em;height:18.33em;"/></p>
<p>Actors have references to the <kbd>ActorRef</kbd> of themselves and the sender actor. These references are supposed to be accessed from the <kbd>receive</kbd> method. Through them, you can interact with the sender actor, as well as with this actor as with <kbd>ActorRefs</kbd>. This means that you can send messages to these actors, and do other things you would usually do as an external observer.</p>
<p><span>Aside from references, an actor has a </span><kbd>context</kbd><span> reference that provides information and control over the context of the actor's execution:</span></p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/fc9246f3-5227-497f-93f9-fbc0d272072f.png" style="width:61.00em;height:11.67em;"/></p>
<p><kbd>ActorContext</kbd> provides various APIs that may be useful when handling messages.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Managing the actor hierarchy</h1>
                </header>
            
            <article>
                
<p class="mce-root">The central concept for managing actor hierarchies is the <kbd>ActorContext</kbd> type. It is defined as follows:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/fc5a0f1c-4894-4143-a1b2-11a3d1f58994.png" style="width:60.33em;height:12.08em;"/></p>
<p><kbd>ActorContext</kbd> allows you to perform various operations on the actor's hierarchy. For example, you can create new actors with the <kbd>actorOf</kbd> method which is defined as follows:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/163211b8-7a6f-4932-8721-1c7d1f255821.png" style="width:60.42em;height:9.92em;"/></p>
<p>So, with <kbd>ActorContext</kbd>, you can create child actors of this actor. We will cover the exact procedure of creating a new actor with the <kbd>Props</kbd> object a bit later when we will be discussing actor systems.</p>
<p><span>The current actor is </span>capable<span> of accessing the child actors it created with the </span><kbd>child</kbd><span> and </span><kbd>children</kbd><span> methods:</span></p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/53a40c8c-2f71-46df-b2c1-4465d9de6d87.png" style="width:58.92em;height:25.25em;"/></p>
<p><span>Similarly, you can access the parent actor of this actor:</span></p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/b641a011-3b0a-4f1f-8949-5480b56506b8.png" style="width:63.00em;height:8.42em;"/></p>
<p><kbd>ActorSystem</kbd><span> is a collection of actors:</span></p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/e60a61b8-c8a0-4ec9-bbb1-3c1c9917aafc.png" style="width:63.75em;height:7.83em;"/></p>
<p>We will cover actor systems later in the <em>Creating actors</em> section, but for now, you should understand that <kbd>ActorSystem</kbd> is accessible from <kbd>ActorContext</kbd>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Managing the life cycle</h1>
                </header>
            
            <article>
                
<p>Akka context provides you with various methods for the life cycle management of an actor:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/2c94e188-dc0e-4886-aa96-ec50765e342f.png" style="width:61.75em;height:12.25em;"/></p>
<p>You can stop this or another actor from using <kbd>ActorContext</kbd>. A widespread pattern with actor-based programming is the following:</p>
<pre class="mce-root">context stop self</pre>
<p class="mce-root">The preceding idiom is often used to terminate actors that have accomplished their job and have nothing more to do.</p>
<p><span>Actors can change their behavior. The behavior of an actor is defined by its </span><kbd>receive</kbd><span> method:</span></p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/4620ed59-abf7-46e8-a168-2b7283d58050.png" style="width:62.25em;height:19.33em;"/></p>
<p class="mce-root"/>
<p class="mce-root"/>
<p>However, as part of handling messages, you may want to change the way messages are handled by an actor. For this purpose, you can use the <kbd>become</kbd> method.</p>
<p>An actor remembers past behaviors you have overridden and keeps them in a stack. This means that you can call an <kbd>unbecome</kbd> method to pop the current behavior from the stack and use the previous behavior:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/4c290aa0-49c7-4c81-99fb-6c3ecc692fb0.png" style="width:66.50em;height:9.75em;"/></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Supervision</h1>
                </header>
            
            <article>
                
<p>An actor can watch another actor for its life cycle events:</p>
<p class="mce-root CDPAlignCenter CDPAlign"><img src="assets/79306989-d400-4770-86ff-ef281efec625.png" style="width:64.33em;height:20.00em;"/></p>
<p>Whenever you need this actor to be aware of when another actor terminates, you can instruct it to watch that other actor with actor context. When that actor terminates, the supervising actor will receive a <kbd>Terminated</kbd> message. You can register a handler of a <kbd>Terminated</kbd> message the same way you handle any other message from the received message.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Creating actors</h1>
                </header>
            
            <article>
                
<p>All of the actors belong to some <kbd>ActorSystem</kbd>, which is a hierarchy of actors:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/a72921b6-f7eb-47dc-a80e-516cbd03e19f.png" style="width:67.50em;height:13.33em;"/></p>
<p>The most important methods when creating new actors are as follows:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/d90a0218-399b-493a-8722-eae9736f6fbf.png" style="width:65.83em;height:10.75em;"/></p>
<p>Every actor is created using an <kbd>actorOf</kbd> method called over an actor system or an actor context. You can create the actor system itself using its companion-object API:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/a14197d5-79bb-4316-aad0-4da716b6a298.png" style="width:56.33em;height:8.50em;"/></p>
<p>When calling this method, you can specify the name of this system. You can also specify the configuration that defines certain aspects of the behavior of the actor system. The configuration is a file that is placed under the path specified under the <kbd>CLASSPATH</kbd> environmental variable. <kbd>CLASSPATH</kbd> is a standard way to let a JVM program know where to look for the classes it uses. For example, in an SBT project, you can place the configuration under the following path under the project root directory: <kbd>src/main/resources/application.conf</kbd>. In this configuration file, we can, for example, disable logging of so-called dead letters—messages intended for nonexistent actors:</p>
<pre>akka.log-dead-letters=0</pre>
<p class="mce-root">The configuration is quite flexible and grants you a degree of control of how your actor system is executed. For more information, please consult the Akka documentation on configuration.</p>
<p>You are also able to specify which execution context this <kbd>ActorSystem</kbd> is going to use to run its actors. Just as when we discussed IO, for a concurrency library, we need a way to specify what threading strategy the library should use. Finally, you can provide a class loader to <kbd>ActorSystem</kbd>, which will be used for things such as resolving configurations. All these parameters are optional. If you do not specify one of them, Akka will use reasonable defaults.</p>
<p>Now, let's have a look at how we run our Hello World example:</p>
<pre>val system = ActorSystem()<br/>val helloWorld = system.actorOf(Props[HelloWorld], "hello-world")<br/>helloWorld ! Ping</pre>
<p>First, we create <kbd>ActorSystem</kbd>. We create a <kbd>HelloWorld</kbd> actor. We do not call its constructor. We do so by using a <kbd>Props</kbd> object. We specify the class that we are going to create in the <kbd>Props</kbd> type parameters. We also specify the name of the actor to be created. <kbd>Props</kbd> is a case class defined as follows:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/31dba49b-53c3-4c23-ae9a-589db0a2530d.png" style="width:67.17em;height:13.25em;"/></p>
<p>Its companion also defines a bunch of convenience methods to create <kbd>Props</kbd>:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/70dfb8dc-8937-441f-be6e-87915eb3ae7a.png" style="width:53.17em;height:15.33em;"/></p>
<p class="mce-root"/>
<p class="mce-root"/>
<p>After we create an actor with the help of <kbd>Props</kbd>, we can send a message to this actor. We do so with the <kbd>!</kbd> operator that <kbd>ActorRef</kbd> defines.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Actor parameters</h1>
                </header>
            
            <article>
                
<p>Ordinary classes can have constructors that take arguments that can be used to parametrize the resulting instance. In the same way, an alternative version of the <kbd>Props</kbd> factory method can be used to create an actor with constructor parameters.</p>
<p>Imagine we have an actor whose constructor takes arguments:</p>
<pre>class HelloName(name: String) extends Actor {<br/>  val log = Logging(context.system, this)<br/><br/>  def receive = {<br/>    case "say-hello" ⇒ log.info(s"Hello, $name")<br/>  }<br/>}</pre>
<p>The preceding actor specifies the name of a person it is going to greet when it does its output. Also, notice how it accepts a string as a message. This is to show that you can send any object as a message to an actor.</p>
<p>When you have an actor that takes constructor parameters, a standard practice is to declare a <kbd>Props</kbd> factory method as a companion of an actor:</p>
<pre>object HelloName {<br/>  def props(name: String): Props =<br/>    Props(classOf[HelloName], name)<br/>}</pre>
<p>This method abstracts away the <kbd>Props</kbd> needed to create this actor. Now, you can construct this actor and use it as follows:</p>
<pre>val system = ActorSystem("hello-custom")<br/>val helloPerson = system.actorOf(HelloName.props("Awesome Person"), "hello-name")<br/>val helloAlien = system.actorOf(HelloName.props("Alien Invaders"), "hello-aliens")<br/>helloPerson ! "say-hello"<br/>helloAlien ! "say-hello"<br/>helloAlien ! "random-msg"</pre>
<p>The output is as follows:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/b071d3b3-0f7d-4e40-bc2c-208bf3d3a267.png" style="width:42.67em;height:22.33em;"/></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Working with actor systems</h1>
                </header>
            
            <article>
                
<p>The strength of the actor model is that actors are lightweight, which means you can use millions of them on a single JVM running on an ordinary computer. Most of the time, you are not going to use a single actor but many actors. This requires a model to handle multiple actors.</p>
<p>In Akka, actors are organized in hierarchical trees—meaning that every actor has a parent and can have multiple children. Next, we will have a look at a slightly more complicated example that will showcase how actors work in hierarchies.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Task specification</h1>
                </header>
            
            <article>
                
<p>Imagine we need to have multiple actors that all output a greeting to a given name to the log. Imagine also that we need to abstract away the fact that there are multiple actors in the system from the end user. We are going to do so by creating a single supervising actor that is going to be in charge of the execution of all its child actors. The child actors will be the actors that output the greeting message to the log, and the parent actor will be a manager that represents them.</p>
<p>The protocol is going to be as follows. First, create a <kbd>GreetingsManager</kbd> actor. Then, you are going to send a <kbd>SpawnGreeters</kbd> message to spawn a number of greeter actors parameterized by the number of greeters required. These spawned greeters must override the ones we already had. That overriding is done by stopping the previous actors and creating new ones.</p>
<p>Next, the user sends a <kbd>SayHello</kbd> message to the manager actor, which will instruct all of its children to perform output to the log. However, in a situation where the manager does not have any child actors spawned, we are going to output an error that asks the user to spawn the actors first.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Implementation</h1>
                </header>
            
            <article>
                
<p>Let's start by defining the <kbd>Greeter</kbd> actor, as it is the simpler one:</p>
<pre>class Greeter extends Actor {<br/>  val log = Logging(context.system, this)<br/><br/>  def receive = {<br/>    case SayHello(name) =&gt; log.info(s"Greetings to $name")<br/>    case Die =&gt;<br/>      context stop self<br/>      sender ! Dead<br/>  }<br/>}</pre>
<p>The actor is going to accept a say hello message that is parameterized by the name the actor is supposed to greet. On receiving this message, it is going to perform a log output.</p>
<p>The <kbd>Greeter</kbd> actor has the means for the other actors to stop it. We have already discussed that one of the requirements of the task is that the manager actor should be able to terminate its existing actress to spawn a new actor. This can be accomplished by sending a message to this <kbd>Greeter</kbd> actor.</p>
<p>That message will use the <kbd>context stop self</kbd> pattern and will report to the sender actor that it is dead with the <kbd>Dead</kbd> message. Note that <kbd>context stop self</kbd> terminates the <kbd>self</kbd> actor only once it is done processing its current message. So the <kbd>sender ! Dead</kbd> code will be executed once the actor is still alive. The actor will terminate after it finishes processing the <kbd>Die</kbd> message.</p>
<p class="mce-root"/>
<p>We are using case classes as messages to communicate between actors because they are convenient for pattern-matching. The entire protocol looks as follows:</p>
<pre>case class SpawnGreeters(n: Int)<br/>case class SayHello(name: String)<br/>case class Execute(f: () =&gt; Unit)<br/>case object JobDone<br/>case class GreetersResolution(result: Try[ActorRef])<br/>case class GreetersTerminated(result: List[Any])<br/>case object GreetersCreationAuthorised<br/>case object Die<br/>case object Dead</pre>
<p>We will introduce every message as we encounter it.</p>
<p>Also, notice that Akka has a built-in message that can be used to stop actors. <span>Whenever you send </span><kbd>PoisonPill</kbd><span> to an actor, its default behavior is to terminate itself:</span></p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/ed8d9a2a-d0e7-45a3-acd8-e5908b6203e1.png" style="width:43.08em;height:11.50em;"/></p>
<p> The reason we are not using <kbd>PoisonPill</kbd> here is that it does not play well with the pattern that we are going to use down the line.</p>
<p>Next, let's start working on the <kbd>GreetingsManager</kbd> actor:</p>
<pre>class GreetingsManager extends Actor {<br/>  val log = Logging(context.system, this)<br/><br/>  def baseReceive: Receive = {<br/>    case SpawnGreeters(n) =&gt;<br/>      log.info("Spawning {} greeters", n)<br/>      resolveGreeters()<br/>      context become spawningGreeters(sender, n)<br/>    <br/>    case msg@SayHello(_) =&gt;<br/>      resolveGreeters()<br/>      context become sayingHello(sender, msg)<br/>  }<br/><br/>  def receive = baseReceive<br/>/*To be continued...*/<br/>}</pre>
<p>The <kbd>receive</kbd> method is set to <kbd>baseReceive</kbd>. The reason we are not defining the API the actor exposes directly under <kbd>receive</kbd> is that we are going to leverage the <kbd>context become</kbd> functionality to change the behavior of the actor. <kbd>context become</kbd> can be used to override the functionality of the receive method. Every new behavior is going to be implemented as a separate method inside of this actor, for easy switching.</p>
<p>The <kbd>baseReceive</kbd> method enables the actor to handle two API messages: <kbd>SpawnGreeters</kbd> and <kbd>SayHello</kbd>. They will manage the underlying greeters and instruct them to perform output.</p>
<p>Notice that both of these methods follows a pattern. First, they optionally perform a log output, after that, they call the <kbd>resolveGreeters</kbd> method, and finally, they use the <kbd>context become</kbd> pattern to change the behavior of the current actor.</p>
<p>The reaction to both of these messages depends on whether or not the <kbd>Greeter</kbd> actors are spawned. If they are not, then in the case of the <kbd>SpawnGreeters</kbd> message, we are going to spawn them as usual. In the case of <kbd>SayHello</kbd>, we are going to output an error that we are not able to operate due to the absence of greeters.</p>
<p>If there are child actors, we are going to terminate them all in the case of <kbd>SpawnGreeter</kbd> to create new ones. In case of <kbd>SayHello</kbd>, we are going to instruct the child actors to output the greeting to the log.</p>
<p>In principle, you can track the state of all of your child actors from a mutable variable inside this actor. So, whenever you spawn a child actor, you save the references to it to a collection inside of this actor. This way, you will be able to quickly check for whether or not we have the child actors defined.</p>
<p>However, in this example, we are going to explore how to check for child actors using the built-in actor-hierarchy-management API.</p>
<p>The API is asynchronous and messaging-based. We have discussed already that it is crucial for the actors to be non-blocking. They are lightweight concurrency primitives, and threads are scarce, hence, to keep actors lightweight, we need to make sure that they utilize as little of their threading as necessary. Hence, we cannot afford to block on a children's query operation. The strategy is to request the children, register listeners to the responses as reactions to actor messages, and release the thread the actor is using to execute this strategy.</p>
<p>This strategy is what you see in the <kbd>baseReceive</kbd> example. The <kbd>resolveGreeters</kbd> method initiates the children resolution, and the results are going to arrive at the actor back as a message. We are going to change the <kbd>receive</kbd> implementation of this actor to handle this message.</p>
<p>Once the appropriate response arrives, these new behaviors will perform the requested functionality. We have separate behaviors for the <kbd>SpawnGreeters</kbd> and <kbd>SayHello</kbd> messages. Notice also that we parametrize these behaviors by the original sender of the current message and the data they provide. So, we will be able to execute the response request when we are ready, as well as notify the requester of the successful execution of this request.</p>
<p>Let's have a look at how the <kbd>resolveGreeters</kbd> function is implemented:</p>
<pre>def greeterFromId(id: Any) = s"greeter-$id"<br/><br/>def resolveGreeters() =<br/>  context.actorSelection(greeterFromId("*")).resolveOne(1 second)<br/>    .transformWith {<br/>      case s@Success(_) =&gt; Future.successful(s)<br/>      case f@Failure(_) =&gt; Future.successful(f)<br/>    }<br/>    .map(GreetersResolution) pipeTo self</pre>
<p>The <kbd>actorSelection</kbd> API is documented as follows:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/b8f4b986-83a2-40b3-b4b5-415ff57a0cd5.png" style="width:54.92em;height:11.67em;"/></p>
<p>In Akka, every actor has a name and a chain of parent actors it belongs to. Every actor also has a name. This allows you to identify actors by a path to them. For example, let's have a look again at the output of our hello world application:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/043dba65-e46f-47c1-b428-3b9701d07526.png" style="width:68.67em;height:31.75em;"/></p>
<p>The log provides a path to the current actor in square brackets:</p>
<pre>akka://default/user/hello-world</pre>
<p>In Akka, it is possible to query actors by their path. It is possible to query entire slices of actors and send messages to entire collections of actors.</p>
<p>So, the actor selection function is a function that accepts a path to the actor that can include wildcards to query lots of actors at the same time, and it will return an actor selection under a Future.</p>
<p>Actor-selection provides you with some of the capabilities you would have on an ordinary <kbd>ActorRef</kbd>. However, for the <kbd>resolveGreeters</kbd> function, our objective is to check whether the greeters exist at all. This can be done by calling a <kbd>resolveOne</kbd> function and observing whether it returns a successful Future or a failed Future.</p>
<p><kbd>resolveOne</kbd> takes the timeout as an argument and produces a Future that is going to result in a random actor from the collection of actors you are selecting. If the selection is empty, it is going to fail.</p>
<p>After that, we have an Akka pattern for Future interoperability. The pattern is called the pipe pattern, and in our example, it follows some transformations of the Future we are going to ignore for a moment:</p>
<pre>/*...*/<br/>  .map(GreetersResolution) pipeTo self</pre>
<p>The <kbd>pipeTo</kbd> method is available on actor references via a Rich Wrapper:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/2710b86f-8d7c-422a-8eea-e3535bb87bbf.png" style="width:24.58em;height:8.00em;"/></p>
<p>The API it injects is as follows:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/762c1a4d-e518-4794-9ca9-a0982c4fbfc6.png" style="width:66.42em;height:25.67em;"/></p>
<p>As we have discussed already, it is an anti-pattern to call a Future from an actor. Whenever you have an asynchronous computation that this actor depends upon, you need to make sure that this computation sends a message to this actor upon termination, and defines how to handle the message from the actor. Akka defines such a pattern for futures—the pipe pattern. The pattern makes sure that the message will be sent to a given actor upon future completion.</p>
<p>In our example, we request the <kbd>actorSelection</kbd> results and schedule a message with the results of this resolution to be sent to the current actor.</p>
<p>The transformations we are doing before the pattern are required to make sure that the failed future also sends a message to the current actor:</p>
<pre>.transformWith {<br/>  case s@Success(_) =&gt; Future.successful(s)<br/>  case f@Failure(_) =&gt; Future.successful(f)<br/>}<br/>.map(GreetersResolution)</pre>
<p>Finally, we use the map method to wrap the result of this future into a message that we want to send to the actor.</p>
<p>Let's have a look at how <kbd>actorSelection</kbd> works in practice with a small example. Consider the following case clause added to the base handler:</p>
<pre>case "resolve" =&gt;<br/>  val selection = context.actorSelection(greeterFromId("*"))<br/>  selection.resolveOne(1 second).onComplete { res =&gt;<br/>    log.info(s"Selection: $selection; Res: $res") }</pre>
<p>Our actor manager is now capable of receiving a <kbd>resolve</kbd> string as a message, upon which it will perform an actor-selection of all the current greeters and put the results into the log.</p>
<p>We can run the resolution as follows:</p>
<pre>implicit val timeout: Timeout = 3 seconds<br/>val system = ActorSystem("hierarchy-demo")<br/>val gm = system.actorOf(Props[this.GreetingsManager], "greetings-manager")<br/><br/>Await.ready(for {<br/>  _ &lt;- Future { gm ! "resolve" }<br/>  _ &lt;- gm ? SpawnGreeters(10)<br/>  _ &lt;- (1 to 10).toList.traverse(_ =&gt; Future { gm ! "resolve" })<br/>} yield (), 5 seconds)</pre>
<p>We are working under the Future Monadic flow here. This is because, on some occasions, we are going to wait on the response of an actor system before we proceed. Let's have a look at the example line by line.</p>
<p>First, we have a <kbd>resolve</kbd> message sent to the current actor:</p>
<pre>_ &lt;- Future { gm ! "resolve" }</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p><span>The </span><kbd>?</kbd><span> operator is injected by the following Rich Wrapper in Akka.</span></p>
<pre>_ &lt;- gm ? SpawnGreeters(10)</pre>
<p><span>Next, we have an ask pattern:</span></p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/c703fcdb-3913-4a96-8838-881beec0721f.png" style="width:21.25em;height:7.00em;"/></p>
<p>Here is the API it injects:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/34897b3c-0519-4d02-ab28-482b6f96c686.png" style="width:68.00em;height:23.33em;"/></p>
<p>The pattern sends a message to an actor reference, just like the ordinary <kbd>!</kbd> operator. However, it also expects the actor to respond to the current actor. The response message is returned under a Future. <span>Under the hood, this ask method creates a temporary child actor that actually sends the message to the original addressee. If the addressee responds to this temporary actor, the response will be available as the Future's result.</span></p>
<p>We are using the ask pattern because we want to suspend the execution of the example until the manager reports that the actors were successfully created. The first line of this example models a case where the greeting manager had no child actors. With the second line, we create the child actors and wait until they are created. The next line will test how actor-selection works against a non-empty selection:</p>
<pre>_ &lt;- (1 to 10).toList.traverse(_ =&gt; Future { gm ! "resolve" })</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p>With this line, we are sending 10 resolve messages to the greeting manager. The result of the execution of the program is as follows:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/c82a8925-cb91-4fea-9de4-86d3dfc010c5.png"/></p>
<p>The result is nondeterministic. This means that every time we send a message to the actor, we are not sure which actor will be returned. Notice how, at first, the greeter with ID <kbd>6</kbd> is returned, and on subsequent invocations, the greeter with ID <kbd>1</kbd> is returned.</p>
<p>Let's now have a look at how this pattern plays with the rest of the application. Let's explore the <kbd>SayHello</kbd> message-handling example first. After calling <kbd>resolveGreeters</kbd>, we use the <kbd>context become</kbd> pattern to change the way the actor handles messages and set a new <kbd>receive</kbd> function to <kbd>sayingHello</kbd>. Let's have a look at how <kbd>sayingHello</kbd> is defined:</p>
<pre class="mce-root">def sayingHello(requester: ActorRef, msg: Any): Receive = {<br/>  case GreetersResolution(Failure(_)) =&gt;<br/>    log.error("There are no greeters. Please create some first with SpawnGreeters message.")<br/>    context become baseReceive<br/>    requester ! JobDone<br/><br/>  case GreetersResolution(Success(_)) =&gt;<br/>    log.info(s"Dispatching message $msg to greeters")<br/>    context.actorSelection(greeterFromId("*")) ! msg<br/>    context become baseReceive<br/>    requester ! JobDone<br/>}</pre>
<p><kbd>sayingHello</kbd> is going to react on the <kbd>GreeterResolution</kbd> message. This is precisely the message we are sending from the result of the <kbd>Greeter</kbd> functions we just discussed. The message has the following definition:</p>
<pre>case class GreetersResolution(result: Try[ActorRef])</pre>
<p>So we have two cases of the payload of that message—the success and failure. We have a failure in which there are no greeters registered:</p>
<pre>case GreetersResolution(Failure(_)) =&gt;<br/>  log.error("There are no greeters. Please create some first with SpawnGreeters message.")<br/>  context become baseReceive<br/>  requester ! JobDone</pre>
<p>In this case, we log an error saying that there are no greeters. We then switch the actor's receive logic back to base and report to the original requester that the job is done, so that it is aware that the actor system has finished processing its request, in case the requester needs to wait upon such an event:</p>
<pre>case GreetersResolution(Success(_)) =&gt;<br/>  log.info(s"Dispatching message $msg to greeters")<br/>  context.actorSelection(greeterFromId("*")) ! msg<br/>  context become baseReceive<br/>  requester ! JobDone</pre>
<p>In the case of a successful resolution of greeters, we select the greeters using actor-selection logic and send the message to this selection. Finally, we switch back to base-handling logic and report to the requester that the job is done.</p>
<p>Now, let's have a look at how the spawning greeters logic works:</p>
<pre>def spawningGreeters(requester: ActorRef, numGreeters: Int): Receive = {<br/>  case GreetersResolution(Failure(_)) =&gt;<br/>    self ! GreetersCreationAuthorised<br/>  <br/>  case GreetersResolution(Success(_)) =&gt;<br/>    log.warning(s"Greeters already exist. Killing them and creating the new ones.")<br/>    context.children<br/>      .filter(c =&gt; raw"greeter-\d".r.unapplySeq(c.path.name).isDefined)<br/>      .toList.traverse(_ ? Die)<br/>      .map(GreetersTerminated) pipeTo self<br/><br/>  case GreetersTerminated(report) =&gt;<br/>    log.info(s"All greeters terminated, report: $report. Creating the new ones now.")<br/>    self ! GreetersCreationAuthorised<br/><br/>  case GreetersCreationAuthorised =&gt;<br/>    (1 to numGreeters).foreach { id =&gt;<br/>      context.actorOf(Props[Greeter], greeterFromId(id)) }<br/>    log.info(s"Created $numGreeters greeters")<br/>    requester ! JobDone<br/>    context become baseReceive<br/>}</pre>
<p>The method takes a requester actor and the number of greeters to create. Let's have a look at the message handlers:</p>
<pre>case GreetersResolution(Failure(_)) =&gt;<br/>  self ! GreetersCreationAuthorised</pre>
<p>If there are no children registered, we send a <kbd>GreetersCreationAuthorised</kbd> message to ourselves specifying that it is safe to create greeters. We need this authorization because sometimes it is not safe to create new greeters—namely when the current actor has old greeters still alive. In this case, we can have naming conflicts we want to avoid:</p>
<pre>case GreetersResolution(Success(_)) =&gt;<br/>  log.warning(s"Greeters already exist. Killing them and creating the new ones.")<br/>  context.children<br/>    .filter(c =&gt; raw"greeter-\d".r.unapplySeq(c.path.name).isDefined)<br/>    .toList.traverse(_ ? Die)<br/>    .map(GreetersTerminated) pipeTo self</pre>
<p>In case the resolution was successful, we must kill this actor's greeters first. We output a warning message to that log specifying that we are going to kill the existing greeters. After that, we obtain the children from the actor context. <kbd>children</kbd> provides us with an iterator of all the children of this actor. We are then going to filter the actors by name with a regular expression:</p>
<pre>c =&gt; raw"greeter-\d".r.unapplySeq(c.path.name).isDefined</pre>
<p>Above, <kbd>raw</kbd> is needed so that <kbd>\</kbd> is not treated as an escape character, but is interpreted literally. <kbd>r</kbd> turns the string it is called on into a regular expression object – this API is a part of Scala Core library. <kbd>unapplySeq</kbd> attempts to match the regex it is called on against the string passed to it as an argument. If the match succeeds, the method returns <kbd>Some</kbd>, otherwise –  <kbd>None</kbd>. See Scala Core API on <kbd>scala.util.matching.Regex</kbd> for more information.</p>
<p>In case we have any other children, only the greeters that follow a specific naming convention will get selected. We do not have any other children in this example. However, it is still a good idea to identify the target children.</p>
<p>After we have filtered the actors to kill, we send them a termination message:</p>
<pre>.toList.traverse(_ ? Die)</pre>
<p>We are using the ask pattern again in the body of the <kbd>traverse</kbd> method to produce a Future. The greeter actors will respond with a message reporting that they were terminated. This allows us to block the execution asynchronously and continue once all the greeters are dead. We can achieve this by using the ask pattern to track the termination of individual actors, then combine the returned Futures into one Future with the <kbd>traverse</kbd> method. This Future will succeed once all of the actors are terminated.</p>
<p>Finally, we wrap the Future's contents into the <kbd>GreetersTerminated</kbd> message. Next, let's look at the <kbd>GreetersTerminated</kbd> branch:</p>
<pre>case GreetersTerminated(report) =&gt;<br/>  log.info(s"All greeters terminated, report: $report. Creating the new ones now.")<br/>  self ! GreetersCreationAuthorised</pre>
<p>We output the report of the termination to the log and send the authorization message to <kbd>self</kbd> to begin the greeters' creation process:</p>
<pre>case GreetersCreationAuthorised =&gt;<br/>  (1 to numGreeters).foreach { id =&gt;<br/>    context.actorOf(Props[Greeter], greeterFromId(id)) }<br/>  log.info(s"Created $numGreeters greeters")<br/>  requester ! JobDone<br/>  context become baseReceive</pre>
<p><kbd>GreetersCreationAuthorised</kbd> is a branch that will only be executed once it is safe to create new greeters. It will create new greeters from a loop:</p>
<pre>(1 to numGreeters).foreach { id =&gt;<br/>  context.actorOf(Props[Greeter], greeterFromId(id)) }</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p>Here, the second argument to <kbd>actorOf</kbd> is defined as follows:</p>
<pre>def greeterFromId(id: Any) = s"greeter-$id"</pre>
<p>Next, we notify the requesting actor that the job of creating the greeters is completed. Finally, we switch the context back to <kbd>baseReceive</kbd>. Now, let's write a test program to see how the example works:</p>
<pre>implicit val timeout: Timeout = 3 seconds<br/>val system = ActorSystem("hierarchy-demo")<br/>val gm = system.actorOf(Props[this.GreetingsManager], "greetings-manager")<br/><br/>def printState(childrenEmpty: Boolean, isHelloMessage: Boolean) =<br/>  Future { println(s"\n=== Children: ${if (childrenEmpty) "empty" else "present"}, " +<br/>    s"Message: ${if (isHelloMessage) "SayHello" else "SpawnGreeters"}") }<br/><br/>Await.ready(for {<br/>  _ &lt;- printState(true, true)<br/>  _ &lt;- gm ? SayHello("me")<br/><br/>  _ &lt;- printState(true, false)<br/>  _ &lt;- gm ? SpawnGreeters(3)<br/><br/>  _ &lt;- printState(false, false)<br/>  _ &lt;- gm ? SpawnGreeters(3)<br/><br/>  _ &lt;- printState(false, true)<br/>  _ &lt;- gm ? SayHello("me")<br/>} yield (), 5 seconds)</pre>
<p>We first send a hello message to an empty greeter manager. Then, we spawn the greeters with a corresponding message. Then we send the <kbd>SpawnGreeters</kbd> message once more, to see how the greeters manager will first kill its existing greeters and only then spawn the new ones. Finally, we send the <kbd>SayHello</kbd> message again.</p>
<p>We have two messages and two possible states of the manager's children greeters. This gives us four possible combinations. Every one of the messages in the example checks the behavior of each of these cases. Notice, how we are using the ask pattern to block the execution flow asynchronously until the actor responds that it has completed the operation. This makes sure that we do not send messages too early.</p>
<p class="mce-root"/>
<p>The output of the message looks as follows:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/e79ee941-80c6-459d-9a3e-26d3ece93739.png"/></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>In this chapter, we discussed the Akka framework, which is a de-facto standard for actor-oriented programming in Scala. We have learnt how to create new actors, how to define them, and how to run an actor-based application. We saw how actors are organized into actor systems, and how they work together in hierarchies. Also, we briefly discussed the patterns that Akka provides for working with actors and futures.</p>
<p>In the next chapter, we will see the usage of the actors model in practice by looking at an example application implemented with this model.</p>
<p class="mce-root"/>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Questions</h1>
                </header>
            
            <article>
                
<ol>
<li>What are the principles of the Actor model in Akka's implementation?</li>
<li>How do you define an actor in Akka?</li>
<li>How do you create a new actor?</li>
<li>How do you send a message to an actor?</li>
<li>What is the ask pattern and how do you use it?</li>
<li>What is the pipe pattern and how do you use it?</li>
</ol>


            </article>

            
        </section>
    </body></html>