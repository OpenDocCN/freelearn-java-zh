<html><head></head><body>
<div id="_idContainer039">
<h1 class="chapter-number" id="_idParaDest-145"><a id="_idTextAnchor150"/><span class="koboSpan" id="kobo.1.1">6</span></h1>
<h1 id="_idParaDest-146"><a id="_idTextAnchor151"/><span class="koboSpan" id="kobo.2.1">Metaprogramming</span></h1>
<p><span class="koboSpan" id="kobo.3.1">In a book about refactoring, it may seem a bit strange to talk about metaprogramming. </span><span class="koboSpan" id="kobo.3.2">More than refactoring per se, in our opinion, talking about metaprogramming and tools that use it can be useful concerning clean code, and writing clean code means “preventing” the refactoring, which is indeed still relevant to </span><span class="No-Break"><span class="koboSpan" id="kobo.4.1">our goal.</span></span></p>
<p><span class="koboSpan" id="kobo.5.1">As we will see shortly, metaprogramming involves writing programs that work on programs. </span><span class="koboSpan" id="kobo.5.2">In our context, we will endorse the usage of frameworks written by others (the first virtue of a good software engineer: laziness) that help us write less code (</span><span class="No-Break"><span class="koboSpan" id="kobo.6.1">told you!).</span></span></p>
<p><span class="koboSpan" id="kobo.7.1">Writing less code (or rather, having it written by tools) is a good thing: it means less code to maintain, trivially, and it means that those portions of code are in charge of dedicated tools that will then write that code in the best </span><span class="No-Break"><span class="koboSpan" id="kobo.8.1">possible way.</span></span></p>
<p><span class="koboSpan" id="kobo.9.1">In this chapter, we’re going to cover the following </span><span class="No-Break"><span class="koboSpan" id="kobo.10.1">main topics:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.11.1">What </span><span class="No-Break"><span class="koboSpan" id="kobo.12.1">is metaprogramming?</span></span></li>
<li><span class="koboSpan" id="kobo.13.1">Exploring compile-time and runtime </span><span class="No-Break"><span class="koboSpan" id="kobo.14.1">metaprogramming tools</span></span></li>
<li><span class="koboSpan" id="kobo.15.1">Lombok </span><span class="No-Break"><span class="koboSpan" id="kobo.16.1">and MapStruct</span></span></li>
<li><span class="koboSpan" id="kobo.17.1">Weighing the pros and cons </span><span class="No-Break"><span class="koboSpan" id="kobo.18.1">of metaprogramming</span></span></li>
</ul>
<h1 id="_idParaDest-147"><a id="_idTextAnchor152"/><span class="koboSpan" id="kobo.19.1">What is metaprogramming?</span></h1>
<p><span class="koboSpan" id="kobo.20.1">When we encounter software designed to create, manipulate, or interact with other software in </span><a id="_idIndexMarker486"/><span class="koboSpan" id="kobo.21.1">various ways, we are engaging in </span><strong class="bold"><span class="koboSpan" id="kobo.22.1">metaprogramming</span></strong><span class="koboSpan" id="kobo.23.1">. </span><span class="koboSpan" id="kobo.23.2">This technique allows computer programs to treat other programs as their data. </span><span class="koboSpan" id="kobo.23.3">In my opinion, it represents a very powerful instrument in the hands of wise people; as with everything in life, it also has some drawbacks that we’ll </span><span class="No-Break"><span class="koboSpan" id="kobo.24.1">analyze later.</span></span></p>
<p><span class="koboSpan" id="kobo.25.1">Metaprogramming means writing software (or, as we’ll see in a moment, using software) that can be set up to do things such as read, create, analyze, or change other programs. </span><span class="koboSpan" id="kobo.25.2">It can even tweak its own code while it’s running. </span><span class="koboSpan" id="kobo.25.3">This cool trick allows developers to write solutions with less code, saving time. </span><span class="koboSpan" id="kobo.25.4">Plus, it makes programs more flexible so that they can handle new situations without needing a </span><span class="No-Break"><span class="koboSpan" id="kobo.26.1">full rewrite.</span></span></p>
<p><span class="koboSpan" id="kobo.27.1">Just as with any programming language, grasping the fundamentals of metaprogramming and adopting sound software development practices is crucial for enhancing the overall quality of applications, including those that incorporate </span><span class="No-Break"><span class="koboSpan" id="kobo.28.1">metaprogramming techniques.</span></span></p>
<p><span class="koboSpan" id="kobo.29.1">First and foremost, metaprogramming promotes </span><strong class="bold"><span class="koboSpan" id="kobo.30.1">code reusability</span></strong><span class="koboSpan" id="kobo.31.1">. </span><span class="koboSpan" id="kobo.31.2">It accomplishes this by allowing </span><a id="_idIndexMarker487"/><span class="koboSpan" id="kobo.32.1">developers to create code generators and templates that eliminate redundancy in their code bases. </span><span class="koboSpan" id="kobo.32.2">This not only reduces the likelihood of errors but also streamlines maintenance efforts. </span><span class="koboSpan" id="kobo.32.3">When code is generated automatically, developers can make changes in one place, and those changes will propagate throughout the code base. </span><span class="koboSpan" id="kobo.32.4">This results in more maintainable, cleaner, and less </span><span class="No-Break"><span class="koboSpan" id="kobo.33.1">error-prone code.</span></span></p>
<p><span class="koboSpan" id="kobo.34.1">One of the most compelling aspects of metaprogramming is its capacity to enable dynamic behavior in programs. </span><span class="koboSpan" id="kobo.34.2">This dynamic behavior empowers software systems to adapt to changing conditions at runtime. </span><span class="koboSpan" id="kobo.34.3">In practical terms, this means that the behavior of a </span><a id="_idIndexMarker488"/><span class="koboSpan" id="kobo.35.1">program can be adjusted or configured without the need for extensive code modifications and recompilation. </span><span class="koboSpan" id="kobo.35.2">As a result, metaprogramming is particularly valuable in scenarios where a program’s behavior must be flexible, configurable, or subject to </span><span class="No-Break"><span class="koboSpan" id="kobo.36.1">frequent changes.</span></span></p>
<p><span class="koboSpan" id="kobo.37.1">Furthermore, metaprogramming has a direct impact on developer productivity. </span><span class="koboSpan" id="kobo.37.2">By automating repetitive coding tasks, it allows developers to focus on higher-level design and problem-solving. </span><span class="koboSpan" id="kobo.37.3">This, in turn, leads to faster development cycles and more efficient code bases. </span><span class="koboSpan" id="kobo.37.4">The time and effort saved through metaprogramming can be channeled into improving the overall quality of </span><span class="No-Break"><span class="koboSpan" id="kobo.38.1">the software.</span></span></p>
<p><span class="koboSpan" id="kobo.39.1">Metaprogramming is </span><a id="_idIndexMarker489"/><span class="koboSpan" id="kobo.40.1">not limited to making code more efficient; it also promotes the creation of </span><strong class="bold"><span class="koboSpan" id="kobo.41.1">domain-specific languages</span></strong><span class="koboSpan" id="kobo.42.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.43.1">DSLs</span></strong><span class="koboSpan" id="kobo.44.1">). </span><span class="koboSpan" id="kobo.44.2">These DSLs are tailored to specific problem domains, enabling developers to express complex ideas more naturally and concisely. </span><span class="koboSpan" id="kobo.44.3">DSLs abstract away the intricacies of general-purpose programming languages and allow developers to communicate directly with the domain’s concepts, significantly improving communication between technical and non-technical stakeholders. </span><span class="koboSpan" id="kobo.44.4">To illustrate this concept, imagine you are working on a financial application, and you need to calculate the interest on a loan. </span><span class="koboSpan" id="kobo.44.5">In Java, using a general-purpose language, it might look </span><span class="No-Break"><span class="koboSpan" id="kobo.45.1">like this:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.46.1">
double principal = 10000;
double rate = 0.05;
int years = 3;
double interest = principal * rate * years;</span></pre> <p><span class="koboSpan" id="kobo.47.1">In this Java code, you are dealing with low-level details such as variable types, operators, </span><span class="No-Break"><span class="koboSpan" id="kobo.48.1">and calculations.</span></span></p>
<p><span class="koboSpan" id="kobo.49.1">Now, let’s see </span><a id="_idIndexMarker490"/><span class="koboSpan" id="kobo.50.1">how a DSL could make this </span><span class="No-Break"><span class="koboSpan" id="kobo.51.1">more domain-specific:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.52.1">
LoanDSL loan = LoanDSL.builder()
        .principal(10000.0)
        .interestRate(0.05)
        .term(3)
        .build();
double interest = loan.calculateInterest();</span></pre> <p><span class="koboSpan" id="kobo.53.1">In this example, </span><strong class="source-inline"><span class="koboSpan" id="kobo.54.1">LoanDSL</span></strong><span class="koboSpan" id="kobo.55.1"> is a DSL that’s designed to work with financial calculations. </span><span class="koboSpan" id="kobo.55.2">It abstracts away the low-level details and provides a higher-level interface that directly communicates with the financial domain’s concepts, making it easier to understand and work with. </span><span class="koboSpan" id="kobo.55.3">This can greatly improve communication between developers and domain experts </span><span class="No-Break"><span class="koboSpan" id="kobo.56.1">in finance.</span></span></p>
<p><span class="koboSpan" id="kobo.57.1">Lastly, metaprogramming helps in building efficient abstractions. </span><span class="koboSpan" id="kobo.57.2">These abstractions hide the underlying implementation details, making the code more understandable and maintainable. </span><span class="koboSpan" id="kobo.57.3">By encapsulating complexity and exposing only essential information, metaprogramming enhances the code base’s overall clarity and comprehensibility. </span><span class="koboSpan" id="kobo.57.4">Metaprogramming can be split into two main categories: compile-time and runtime. </span><span class="koboSpan" id="kobo.57.5">Let’s taste a bit of each </span><span class="No-Break"><span class="koboSpan" id="kobo.58.1">of them.</span></span></p>
<h1 id="_idParaDest-148"><a id="_idTextAnchor153"/><span class="koboSpan" id="kobo.59.1">Exploring compile-time metaprogramming tools</span></h1>
<p><span class="koboSpan" id="kobo.60.1">Compile-time metaprogramming involves code transformations and generation that occur during </span><a id="_idIndexMarker491"/><span class="koboSpan" id="kobo.61.1">the compilation phase. </span><span class="koboSpan" id="kobo.61.2">In other words, operations, transformations, or code generation are performed on a program during the compilation process – that is, before the program is executed. </span><span class="koboSpan" id="kobo.61.3">Macros, code generators, and annotation processors are common tools for compile-time metaprogramming in Java. </span><span class="koboSpan" id="kobo.61.4">Given the subject of this book, compile-time metaprogramming will be our main focus since we think that the instruments and frameworks that fall under this definition are the best ways to keep your code clean. </span><span class="koboSpan" id="kobo.61.5">In particular, we’ll focus on code generator tools: programming languages and tools that provide facilities for generating code based on certain specifications or models (in the following section, we will focus specifically on Lombok and MapStruct). </span><span class="koboSpan" id="kobo.61.6">The code generated by these tools can be customized according to the specific requirements of </span><span class="No-Break"><span class="koboSpan" id="kobo.62.1">the program.</span></span></p>
<h2 id="_idParaDest-149"><a id="_idTextAnchor154"/><span class="koboSpan" id="kobo.63.1">Lombok</span></h2>
<p><strong class="bold"><span class="koboSpan" id="kobo.64.1">Project Lombok</span></strong><span class="koboSpan" id="kobo.65.1"> (born in 2009) is a popular Java library that simplifies Java development </span><a id="_idIndexMarker492"/><span class="koboSpan" id="kobo.66.1">by reducing boilerplate code and making the code cleaner and </span><span class="No-Break"><span class="koboSpan" id="kobo.67.1">more concise.</span></span></p>
<p><span class="koboSpan" id="kobo.68.1">In Java (at least until version 14 with the introduction of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.69.1">record</span></strong><span class="koboSpan" id="kobo.70.1"> keyword), there is often a </span><a id="_idIndexMarker493"/><span class="koboSpan" id="kobo.71.1">significant amount of boilerplate code that needs to be written for basic tasks such as defining getter and setter methods, constructors, and the </span><strong class="source-inline"><span class="koboSpan" id="kobo.72.1">toString()</span></strong><span class="koboSpan" id="kobo.73.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.74.1">equals()</span></strong><span class="koboSpan" id="kobo.75.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.76.1">hashCode()</span></strong><span class="koboSpan" id="kobo.77.1"> methods. </span><span class="koboSpan" id="kobo.77.2">This boilerplate code can be time-consuming to write and maintain, making the code base longer and harder </span><span class="No-Break"><span class="koboSpan" id="kobo.78.1">to read.</span></span></p>
<p><strong class="bold"><span class="koboSpan" id="kobo.79.1">Lombok</span></strong><span class="koboSpan" id="kobo.80.1"> addresses this issue by providing annotations that automatically generate this boilerplate code during compilation. </span><span class="koboSpan" id="kobo.80.2">This means developers don’t have to write these repetitive code elements themselves, reducing the likelihood of errors and making the code base </span><span class="No-Break"><span class="koboSpan" id="kobo.81.1">more concise.</span></span></p>
<p><span class="koboSpan" id="kobo.82.1">Lombok functions as an annotation processor that enhances your classes by introducing additional code during the compilation phase. </span><span class="koboSpan" id="kobo.82.2">Annotation processing was introduced to the Java compiler in version 5. </span><span class="koboSpan" id="kobo.82.3">The concept involves users placing annotation processors, whether self-authored or obtained from third-party dependencies such as Lombok, in the build classpath. </span><span class="koboSpan" id="kobo.82.4">During the compilation process, as the compiler encounters an annotation, it effectively inquires, “Is anyone in the classpath concerned with this </span><strong class="source-inline"><span class="koboSpan" id="kobo.83.1">@Annotation</span></strong><span class="koboSpan" id="kobo.84.1">?” </span><span class="koboSpan" id="kobo.84.2">For those processors answering yes, the compiler delegates control to them, along with the compilation context, allowing them to perform their </span><span class="No-Break"><span class="koboSpan" id="kobo.85.1">respective tasks.</span></span></p>
<p><span class="koboSpan" id="kobo.86.1">Lombok’s annotation processing involves making adjustments to the compiler’s data structures </span><a id="_idIndexMarker494"/><span class="koboSpan" id="kobo.87.1">that represent the code, specifically </span><a id="_idIndexMarker495"/><span class="koboSpan" id="kobo.88.1">the </span><strong class="bold"><span class="koboSpan" id="kobo.89.1">abstract syntax tree</span></strong><span class="koboSpan" id="kobo.90.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.91.1">AST</span></strong><span class="koboSpan" id="kobo.92.1">). </span><span class="koboSpan" id="kobo.92.2">Think of the AST as a roadmap for the computer </span><a id="_idIndexMarker496"/><span class="koboSpan" id="kobo.93.1">program. </span><span class="koboSpan" id="kobo.93.2">It shows all the necessary steps that must be taken to create the final program. </span><span class="koboSpan" id="kobo.93.3">In Java, it is created before the </span><a id="_idIndexMarker497"/><span class="koboSpan" id="kobo.94.1">actual program code (</span><strong class="bold"><span class="koboSpan" id="kobo.95.1">bytecode</span></strong><span class="koboSpan" id="kobo.96.1">) is made. </span><span class="koboSpan" id="kobo.96.2">The cool thing is that you can change and work with this AST in Java. </span><span class="koboSpan" id="kobo.96.3">Through these modifications to the compiler’s AST, Lombok indirectly influences the generation of the final bytecode. </span><span class="koboSpan" id="kobo.96.4">To achieve this functionality, Lombok is required to intercept and manage calls that are made to the Java compiler for handling the generation of intermediate code. </span><span class="koboSpan" id="kobo.96.5">This interception </span><a id="_idIndexMarker498"/><span class="koboSpan" id="kobo.97.1">process is facilitated using plugins, which can be configured within your </span><strong class="bold"><span class="koboSpan" id="kobo.98.1">integrated development environment</span></strong><span class="koboSpan" id="kobo.99.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.100.1">IDE</span></strong><span class="koboSpan" id="kobo.101.1">), such as IntelliJ, VS Code, or Eclipse, or integrated into your build automation tools, such as Maven, Gradle, or Make. </span><span class="koboSpan" id="kobo.101.2">It’s important to note that if your IDE or build management system lacks compatibility with Lombok, it may result in compilation issues for your code; anyway, that simply will not happen with modern versions of the most used IDEs (they support Lombok out of </span><span class="No-Break"><span class="koboSpan" id="kobo.102.1">the box).</span></span></p>
<p><span class="koboSpan" id="kobo.103.1">As we already said, Lombok works with a bunch of very simple annotations. </span><span class="koboSpan" id="kobo.103.2">Let’s see some examples of its magic. </span><span class="koboSpan" id="kobo.103.3">We’ll provide you with the basics. </span><span class="koboSpan" id="kobo.103.4">However, there’s much more to discover in the Lombok official documentation, which you can find in the </span><em class="italic"><span class="koboSpan" id="kobo.104.1">Further </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.105.1">reading</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.106.1"> section.</span></span></p>
<h3><span class="koboSpan" id="kobo.107.1">Getting started with Lombok with an example</span></h3>
<p><span class="koboSpan" id="kobo.108.1">Let’s start </span><a id="_idIndexMarker499"/><span class="koboSpan" id="kobo.109.1">with the most basic form of a Java class: a </span><strong class="bold"><span class="koboSpan" id="kobo.110.1">POJO</span></strong><span class="koboSpan" id="kobo.111.1">. </span><span class="koboSpan" id="kobo.111.2">The acronym, born more by habit than by a standard, stands for </span><strong class="bold"><span class="koboSpan" id="kobo.112.1">Plain Old Java Object</span></strong><span class="koboSpan" id="kobo.113.1">, and it usually </span><a id="_idIndexMarker500"/><span class="koboSpan" id="kobo.114.1">describes a simple Java type that does not adhere to any particular framework or contain any business logic; just a bunch of fields with their accessor methods, one or more constructors, maybe a </span><strong class="source-inline"><span class="koboSpan" id="kobo.115.1">toString()</span></strong><span class="koboSpan" id="kobo.116.1"> method, an often </span><strong class="source-inline"><span class="koboSpan" id="kobo.117.1">equals()</span></strong><span class="koboSpan" id="kobo.118.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.119.1">hashcode()</span></strong><span class="koboSpan" id="kobo.120.1"> to complete the picture. </span><span class="koboSpan" id="kobo.120.2">It’s faster to write one than to describe it (the following code is </span><span class="No-Break"><span class="koboSpan" id="kobo.121.1">intentionally long):</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.122.1">
class Person {
    private String name;
    private String surname;
    private Date birthDate;
    public Person() {
    }
    public Person(String name, String surname, Date birthDate) {
        this.name = name;
        this.surname = surname;
        this.birthDate = birthDate;
    }
    public Person(Person anotherPerson) {
        if (anotherPerson == null) {
            throw new NullPointerException("AnotherPerson cannot be null");
        }
        this.name = anotherPerson.getName();
        this.surname = anotherPerson.getSurname();
        this.birthDate = anotherPerson.getBirthDate();
    }
    public String getName() {
        return name;
    }
    public void setName(String name) {
        this.name = name;
    }
    public String getSurname() {
        return surname;
    }
    public void setSurname(String surname) {
        this.surname = surname;
    }
    public Date getBirthDate() {
        return birthDate;
    }
    public void setBirthDate(Date birthDate) {
        this.birthDate = birthDate;
    }
    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        Person person = (Person) o;
        return Objects.equals(name, person.name) &amp;&amp; Objects.equals(surname, person.surname) &amp;&amp; Objects.equals(birthDate, person.birthDate);
    }
    @Override
    public int hashCode() {
        return Objects.hash(name, surname, birthDate);
    }
    @Override
    public String toString() {
        return "Person{" +
                "name='" + name + '\'' +
                ", surname='" + surname + '\'' +
                ", birthDate=" + birthDate +
                '}';
    }
}</span></pre> <p><span class="koboSpan" id="kobo.123.1">It should be simple to understand what this class does: nothing! </span><span class="koboSpan" id="kobo.123.2">It has three fields, all of which are </span><strong class="source-inline"><span class="koboSpan" id="kobo.124.1">private</span></strong><span class="koboSpan" id="kobo.125.1">, three constructors (the default one with no argument and one with all the fields – one that takes another instance of the same object), one getter and one setter for each of the fields, </span><strong class="source-inline"><span class="koboSpan" id="kobo.126.1">equals</span></strong><span class="koboSpan" id="kobo.127.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.128.1">hashcode</span></strong><span class="koboSpan" id="kobo.129.1"> methods that involve all of the fields, and finally a </span><strong class="source-inline"><span class="koboSpan" id="kobo.130.1">toString</span></strong><span class="koboSpan" id="kobo.131.1"> method. </span><span class="koboSpan" id="kobo.131.2">All of this code has been generated from my IDE; this class </span><a id="_idIndexMarker501"/><span class="koboSpan" id="kobo.132.1">just represents a piece of information. </span><span class="koboSpan" id="kobo.132.2">It is what is called a </span><strong class="bold"><span class="koboSpan" id="kobo.133.1">data class</span></strong><span class="koboSpan" id="kobo.134.1"> in other languages. </span><span class="koboSpan" id="kobo.134.2">And just for this, we have more than 70 lines of code! </span><span class="koboSpan" id="kobo.134.3">Let’s see how Lombok can </span><span class="No-Break"><span class="koboSpan" id="kobo.135.1">rescue us.</span></span></p>
<p><span class="koboSpan" id="kobo.136.1">First things first, add Project Lombok to your classpath. </span><span class="koboSpan" id="kobo.136.2">If you are using Maven, you just have to add </span><a id="_idIndexMarker502"/><span class="koboSpan" id="kobo.137.1">the dependency to your </span><strong class="source-inline"><span class="koboSpan" id="kobo.138.1">pom.xml</span></strong><span class="koboSpan" id="kobo.139.1"> file (we’re going to use the latest version at the time </span><span class="No-Break"><span class="koboSpan" id="kobo.140.1">of writing):</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.141.1">
&lt;dependency&gt;
    &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;
    &lt;artifactId&gt;lombok&lt;/artifactId&gt;
    &lt;version&gt;1.18.30&lt;/version&gt;
&lt;/dependency&gt;</span></pre> <p><span class="koboSpan" id="kobo.142.1">One funny thing is that if you just start typing Lombok’s annotations into your code, some IDEs, such as IntelliJ IDEA, will suggest that you include Lombok in your classpath. </span><span class="koboSpan" id="kobo.142.2">It is </span><span class="No-Break"><span class="koboSpan" id="kobo.143.1">that smooth.</span></span></p>
<p><span class="koboSpan" id="kobo.144.1">As we said, Lombok works by adding annotations to the source code, which implement some behaviors considered </span><em class="italic"><span class="koboSpan" id="kobo.145.1">boilerplate</span></em><span class="koboSpan" id="kobo.146.1">. </span><span class="koboSpan" id="kobo.146.2">For example, in the </span><em class="italic"><span class="koboSpan" id="kobo.147.1">copy constructor</span></em><span class="koboSpan" id="kobo.148.1"> of the object, we can see an </span><strong class="source-inline"><span class="koboSpan" id="kobo.149.1">if</span></strong><span class="koboSpan" id="kobo.150.1"> statement that checks for the possible nullity of the parameter that’s passed in </span><span class="No-Break"><span class="koboSpan" id="kobo.151.1">as input:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.152.1">
public Person(Person anotherPerson) {
    if (anotherPerson == null) {
        throw new NullPointerException("AnotherPerson cannot be null");
    }
    this.name = anotherPerson.getName();
    this.surname = anotherPerson.getSurname();
    this.birthDate = anotherPerson.getBirthDate();
}</span></pre> <p><span class="koboSpan" id="kobo.153.1">This </span><strong class="source-inline"><span class="koboSpan" id="kobo.154.1">if</span></strong><span class="koboSpan" id="kobo.155.1"> statement can be replaced with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.156.1">@NonNull</span></strong><span class="koboSpan" id="kobo.157.1"> annotation next to the parameter in the </span><a id="_idIndexMarker503"/><span class="koboSpan" id="kobo.158.1">constructor: the null check takes the form of an </span><strong class="source-inline"><span class="koboSpan" id="kobo.159.1">if</span></strong><span class="koboSpan" id="kobo.160.1"> statement, </span><strong class="source-inline"><span class="koboSpan" id="kobo.161.1">if (param == null) throw new NullPointerException("param is marked non-null but is null")</span></strong><span class="koboSpan" id="kobo.162.1">, and will be placed at the beginning of your method. </span><span class="koboSpan" id="kobo.162.2">In the case of constructors, the null check will be inserted right after any explicit </span><strong class="source-inline"><span class="koboSpan" id="kobo.163.1">this()</span></strong><span class="koboSpan" id="kobo.164.1"> or </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.165.1">super()</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.166.1"> calls:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.167.1">
public Person(@NonNull Person anotherPerson) {
    this.name = anotherPerson.getName();
    this.surname = anotherPerson.getSurname();
    this.birthDate = anotherPerson.getBirthDate();
}</span></pre> <p><span class="koboSpan" id="kobo.168.1">Now, let’s look at the </span><span class="No-Break"><span class="koboSpan" id="kobo.169.1">default constructor:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.170.1">
public Person() {
}</span></pre> <p><span class="koboSpan" id="kobo.171.1">With the </span><strong class="source-inline"><span class="koboSpan" id="kobo.172.1">@NoArgsConstructor</span></strong><span class="koboSpan" id="kobo.173.1"> annotation, we can get rid of the default constructor. </span><span class="koboSpan" id="kobo.173.2">A constructor with no parameters will be automatically generated. </span><span class="koboSpan" id="kobo.173.3">However, if this isn’t feasible due to the presence of final fields, a compiler error will occur. </span><span class="koboSpan" id="kobo.173.4">This will happen unless you explicitly annotate with </span><strong class="source-inline"><span class="koboSpan" id="kobo.174.1">@NoArgsConstructor(force = true)</span></strong><span class="koboSpan" id="kobo.175.1">, in which case all final fields will be initialized with default values (</span><strong class="source-inline"><span class="koboSpan" id="kobo.176.1">0</span></strong><span class="koboSpan" id="kobo.177.1"> for numeric types, </span><strong class="source-inline"><span class="koboSpan" id="kobo.178.1">false</span></strong><span class="koboSpan" id="kobo.179.1"> for Boolean, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.180.1">null</span></strong><span class="koboSpan" id="kobo.181.1"> for </span><span class="No-Break"><span class="koboSpan" id="kobo.182.1">reference types).</span></span></p>
<p><span class="koboSpan" id="kobo.183.1">The second </span><a id="_idIndexMarker504"/><span class="koboSpan" id="kobo.184.1">constructor we can get rid of is the </span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.185.1">all-arguments</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.186.1"> constructor:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.187.1">
public Person(String name, String surname, Date birthDate) {
    this.name = name;
    this.surname = surname;
    this.birthDate = birthDate;
}</span></pre> <p><span class="koboSpan" id="kobo.188.1">We can replace these lines of code with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.189.1">@AllArgsConstructor</span></strong><span class="koboSpan" id="kobo.190.1"> annotation, which produces a constructor that accepts one parameter for each field within </span><span class="No-Break"><span class="koboSpan" id="kobo.191.1">your class.</span></span></p>
<p><span class="koboSpan" id="kobo.192.1">Should any </span><a id="_idIndexMarker505"/><span class="koboSpan" id="kobo.193.1">of the arguments be </span><strong class="source-inline"><span class="koboSpan" id="kobo.194.1">final</span></strong><span class="koboSpan" id="kobo.195.1">, this means that only some of the fields </span><span class="No-Break"><span class="koboSpan" id="kobo.196.1">are required:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.197.1">
private final String name;
private String surname;
private Date birthDate;</span></pre> <p><span class="koboSpan" id="kobo.198.1">In this case, we can use </span><strong class="source-inline"><span class="koboSpan" id="kobo.199.1">@RequiredArgsConstructor</span></strong><span class="koboSpan" id="kobo.200.1">, which generates a constructor with one parameter for each field that necessitates specific treatment. </span><span class="koboSpan" id="kobo.200.2">This includes all non-initialized final fields, as well as any fields annotated with </span><strong class="source-inline"><span class="koboSpan" id="kobo.201.1">@NonNull</span></strong><span class="koboSpan" id="kobo.202.1"> that haven’t been initialized where they are declared. </span><span class="koboSpan" id="kobo.202.2">For the fields marked with </span><strong class="source-inline"><span class="koboSpan" id="kobo.203.1">@NonNull</span></strong><span class="koboSpan" id="kobo.204.1">, an explicit null check is also created. </span><span class="koboSpan" id="kobo.204.2">If any of the parameters intended for </span><strong class="source-inline"><span class="koboSpan" id="kobo.205.1">@NonNull</span></strong><span class="koboSpan" id="kobo.206.1"> fields contain null, the constructor will throw a </span><strong class="source-inline"><span class="koboSpan" id="kobo.207.1">NullPointerException</span></strong><span class="koboSpan" id="kobo.208.1"> error. </span><span class="koboSpan" id="kobo.208.2">The parameter order corresponds to the order in which the fields are defined in </span><span class="No-Break"><span class="koboSpan" id="kobo.209.1">your class.</span></span></p>
<p><span class="koboSpan" id="kobo.210.1">The next features </span><a id="_idIndexMarker506"/><span class="koboSpan" id="kobo.211.1">of Lombok are the </span><strong class="bold"><span class="koboSpan" id="kobo.212.1">accessor methods</span></strong><span class="koboSpan" id="kobo.213.1"> – that is, the getters and the setters. </span><span class="koboSpan" id="kobo.213.2">You have the option to apply the </span><strong class="source-inline"><span class="koboSpan" id="kobo.214.1">@Getter</span></strong><span class="koboSpan" id="kobo.215.1"> and/or </span><strong class="source-inline"><span class="koboSpan" id="kobo.216.1">@Setter</span></strong><span class="koboSpan" id="kobo.217.1"> annotations to any field, allowing Lombok to automatically generate default getter and </span><span class="No-Break"><span class="koboSpan" id="kobo.218.1">setter methods:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.219.1">
@Getter @Setter private String name;
@Getter @Setter private String surname;
@Getter @Setter private Date birthDate;</span></pre> <p><span class="koboSpan" id="kobo.220.1">A default getter method essentially retrieves the field’s value and follows the </span><strong class="source-inline"><span class="koboSpan" id="kobo.221.1">getName</span></strong><span class="koboSpan" id="kobo.222.1"> naming convention if the field is named </span><strong class="source-inline"><span class="koboSpan" id="kobo.223.1">name</span></strong><span class="koboSpan" id="kobo.224.1"> (or </span><strong class="source-inline"><span class="koboSpan" id="kobo.225.1">isName</span></strong><span class="koboSpan" id="kobo.226.1"> if the field is of the Boolean type). </span><span class="koboSpan" id="kobo.226.2">Meanwhile, a default setter method named </span><strong class="source-inline"><span class="koboSpan" id="kobo.227.1">setName</span></strong><span class="koboSpan" id="kobo.228.1"> is used if the field is named </span><strong class="source-inline"><span class="koboSpan" id="kobo.229.1">name</span></strong><span class="koboSpan" id="kobo.230.1">, returns </span><strong class="source-inline"><span class="koboSpan" id="kobo.231.1">void</span></strong><span class="koboSpan" id="kobo.232.1">, and accepts a single parameter of the same type as the field. </span><span class="koboSpan" id="kobo.232.2">This setter method simply assigns the field the </span><span class="No-Break"><span class="koboSpan" id="kobo.233.1">provided value.</span></span></p>
<p><span class="koboSpan" id="kobo.234.1">It’s also possible to apply the </span><strong class="source-inline"><span class="koboSpan" id="kobo.235.1">@Getter</span></strong><span class="koboSpan" id="kobo.236.1"> and/or </span><strong class="source-inline"><span class="koboSpan" id="kobo.237.1">@Setter</span></strong><span class="koboSpan" id="kobo.238.1"> annotation to a class itself. </span><span class="koboSpan" id="kobo.238.2">In such cases, it’s as </span><a id="_idIndexMarker507"/><span class="koboSpan" id="kobo.239.1">though you’ve annotated all non-static fields within that class with the same annotation. </span><span class="koboSpan" id="kobo.239.2">So, the previous code snippet can be also written in the </span><span class="No-Break"><span class="koboSpan" id="kobo.240.1">following manner:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.241.1">
@Getter
@Setter
class Person {
    private String name;
    private String surname;
    private Date birthDate;
    //other code here...
</span><span class="koboSpan" id="kobo.241.2">}</span></pre> <p><span class="koboSpan" id="kobo.242.1">By default, the generated getter and setter methods are public, unless you explicitly specify </span><strong class="source-inline"><span class="koboSpan" id="kobo.243.1">AccessLevel</span></strong><span class="koboSpan" id="kobo.244.1">. </span><span class="koboSpan" id="kobo.244.2">The access levels that you can use are </span><strong class="source-inline"><span class="koboSpan" id="kobo.245.1">PUBLIC</span></strong><span class="koboSpan" id="kobo.246.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.247.1">PROTECTED</span></strong><span class="koboSpan" id="kobo.248.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.249.1">PACKAGE</span></strong><span class="koboSpan" id="kobo.250.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.251.1">PRIVATE</span></strong><span class="koboSpan" id="kobo.252.1">. </span><span class="koboSpan" id="kobo.252.2">For example, you could write </span><span class="No-Break"><span class="koboSpan" id="kobo.253.1">the following:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.254.1">
@Setter(AccessLevel.PROTECTED) private String name;</span></pre> <p><span class="koboSpan" id="kobo.255.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.256.1">equals</span></strong><span class="koboSpan" id="kobo.257.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.258.1">hashcode</span></strong><span class="koboSpan" id="kobo.259.1"> methods can be generated by adding the </span><strong class="source-inline"><span class="koboSpan" id="kobo.260.1">@EqualsAndHashCode</span></strong><span class="koboSpan" id="kobo.261.1"> annotation: this allows Lombok to automatically generate implementations for the </span><strong class="source-inline"><span class="koboSpan" id="kobo.262.1">equals(Object other)</span></strong><span class="koboSpan" id="kobo.263.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.264.1">hashCode()</span></strong><span class="koboSpan" id="kobo.265.1"> methods. </span><span class="koboSpan" id="kobo.265.2">By default, it includes all non-static, non-transient fields. </span><span class="koboSpan" id="kobo.265.3">However, you have the flexibility to customize which fields are included (and even specify that the results of certain methods should be considered) by annotating type members with </span><strong class="source-inline"><span class="koboSpan" id="kobo.266.1">@EqualsAndHashCode.Include</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.267.1">or </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.268.1">@EqualsAndHashCode.Exclude</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.269.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.270.1">Alternatively, you can precisely specify the fields or methods you want to include by annotating them with </span><strong class="source-inline"><span class="koboSpan" id="kobo.271.1">@EqualsAndHashCode.Include</span></strong><span class="koboSpan" id="kobo.272.1"> and </span><span class="No-Break"><span class="koboSpan" id="kobo.273.1">using </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.274.1">@EqualsAndHashCode</span></strong></span><strong class="source-inline"><span class="koboSpan" id="kobo.275.1"> (onlyExplicitlyIncluded = </span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.276.1">true)</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.277.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.278.1">Last but not least, you have the chance to make Lombok generate a </span><strong class="source-inline"><span class="koboSpan" id="kobo.279.1">toString</span></strong><span class="koboSpan" id="kobo.280.1"> method simply by adding the </span><strong class="source-inline"><span class="koboSpan" id="kobo.281.1">@ToString</span></strong><span class="koboSpan" id="kobo.282.1"> annotation. </span><span class="koboSpan" id="kobo.282.2">Configuration options are used to determine whether </span><a id="_idIndexMarker508"/><span class="koboSpan" id="kobo.283.1">field names should be included. </span><span class="koboSpan" id="kobo.283.2">Otherwise, the format follows a fixed structure, which is the class name followed by parentheses containing fields separated by commas – as an example, it appears as </span><strong class="source-inline"><span class="koboSpan" id="kobo.284.1">Person(name=charlie, surname=brown)</span></strong><span class="koboSpan" id="kobo.285.1">. </span><span class="koboSpan" id="kobo.285.2">To enhance the clarity (although it may increase the length) of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.286.1">toString()</span></strong><span class="koboSpan" id="kobo.287.1"> method’s output, you can set the </span><strong class="source-inline"><span class="koboSpan" id="kobo.288.1">includeFieldNames</span></strong><span class="koboSpan" id="kobo.289.1"> parameter to </span><strong class="source-inline"><span class="koboSpan" id="kobo.290.1">true</span></strong><span class="koboSpan" id="kobo.291.1">. </span><span class="koboSpan" id="kobo.291.2">By default, all non-static fields are printed. </span><span class="koboSpan" id="kobo.291.3">If you wish to exclude certain fields, you can annotate them with </span><strong class="source-inline"><span class="koboSpan" id="kobo.292.1">@ToString.Exclude</span></strong><span class="koboSpan" id="kobo.293.1">. </span><span class="koboSpan" id="kobo.293.2">Alternatively, you can precisely specify which fields to include by using </span><strong class="source-inline"><span class="koboSpan" id="kobo.294.1">@ToString(onlyExplicitlyIncluded = true)</span></strong><span class="koboSpan" id="kobo.295.1"> and then marking each field you want to include </span><span class="No-Break"><span class="koboSpan" id="kobo.296.1">with </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.297.1">@ToString.Include</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.298.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.299.1">In the end, our 70-lines-long code is reduced to </span><span class="No-Break"><span class="koboSpan" id="kobo.300.1">the following:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.301.1">
@NoArgsConstructor
@AllArgsConstructor
@Getter
@Setter
@EqualsAndHashCode
@ToString
class Person {
    private String name;
    private String surname;
    private Date birthDate;
    public Person(@NonNull Person anotherPerson) {
        this.name = anotherPerson.getName();
        this.surname = anotherPerson.getSurname();
        this.birthDate = anotherPerson.getBirthDate();
    }
}</span></pre> <p><span class="koboSpan" id="kobo.302.1">Still not </span><a id="_idIndexMarker509"/><span class="koboSpan" id="kobo.303.1">satisfied? </span><span class="koboSpan" id="kobo.303.2">You can use </span><strong class="source-inline"><span class="koboSpan" id="kobo.304.1">@Data</span></strong><span class="koboSpan" id="kobo.305.1">, a convenient shortcut annotation that bundles the features of </span><strong class="source-inline"><span class="koboSpan" id="kobo.306.1">@ToString</span></strong><span class="koboSpan" id="kobo.307.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.308.1">@EqualsAndHashCode</span></strong><span class="koboSpan" id="kobo.309.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.310.1">@Getter</span></strong><span class="koboSpan" id="kobo.311.1"> / </span><strong class="source-inline"><span class="koboSpan" id="kobo.312.1">@Setter</span></strong><span class="koboSpan" id="kobo.313.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.314.1">@</span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.315.1">RequiredArgsConstructor</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.316.1"> together:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.317.1">
@AllArgsConstructor
@NoArgsConstructor
@Data
class Person {
    private String name;
    private String surname;
    private Date birthDate;
    public Person(@NonNull Person anotherPerson) {
        this.name = anotherPerson.getName();
        this.surname = anotherPerson.getSurname();
        this.birthDate = anotherPerson.getBirthDate();
    }
}</span></pre> <p><span class="koboSpan" id="kobo.318.1">If you want to preserve immutability (and you definitively should!), you can use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.319.1">@Value</span></strong><span class="koboSpan" id="kobo.320.1"> annotation, which is the immutable variant of </span><strong class="source-inline"><span class="koboSpan" id="kobo.321.1">@Data</span></strong><span class="koboSpan" id="kobo.322.1">. </span><span class="koboSpan" id="kobo.322.2">In this case, all fields are automatically set as </span><strong class="source-inline"><span class="koboSpan" id="kobo.323.1">private</span></strong><span class="koboSpan" id="kobo.324.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.325.1">final</span></strong><span class="koboSpan" id="kobo.326.1"> by default, and no setters are generated. </span><span class="koboSpan" id="kobo.326.2">Additionally, the class itself is made </span><strong class="source-inline"><span class="koboSpan" id="kobo.327.1">final</span></strong><span class="koboSpan" id="kobo.328.1"> by default because enforcing immutability on a subclass is not feasible. </span><span class="koboSpan" id="kobo.328.2">Similar to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.329.1">@Data</span></strong><span class="koboSpan" id="kobo.330.1"> annotation, it includes helpful </span><strong class="source-inline"><span class="koboSpan" id="kobo.331.1">toString()</span></strong><span class="koboSpan" id="kobo.332.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.333.1">equals()</span></strong><span class="koboSpan" id="kobo.334.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.335.1">hashCode()</span></strong><span class="koboSpan" id="kobo.336.1"> methods generation. </span><span class="koboSpan" id="kobo.336.2">Each field is equipped with a getter method, and a constructor is generated to encompass all arguments (excluding </span><strong class="source-inline"><span class="koboSpan" id="kobo.337.1">final</span></strong><span class="koboSpan" id="kobo.338.1"> fields, which are initialized in the </span><span class="No-Break"><span class="koboSpan" id="kobo.339.1">field declaration).</span></span></p>
<p><span class="koboSpan" id="kobo.340.1">This is just a </span><a id="_idIndexMarker510"/><span class="koboSpan" id="kobo.341.1">general overview of Lombok’s annotations. </span><span class="koboSpan" id="kobo.341.2">Using their properties (and also some other configurations that can be added to the project through a file called </span><strong class="source-inline"><span class="koboSpan" id="kobo.342.1">lombok.config</span></strong><span class="koboSpan" id="kobo.343.1"> (the link for the official documentation can be found in the </span><em class="italic"><span class="koboSpan" id="kobo.344.1">Further reading</span></em><span class="koboSpan" id="kobo.345.1"> section)), it is possible to make the behavior of Lombok much more granular, acting at the level of a single field, a single method, or customizing the implementation generated by this powerful library. </span><span class="koboSpan" id="kobo.345.2">This was just the proverbial tip of </span><span class="No-Break"><span class="koboSpan" id="kobo.346.1">the iceberg.</span></span></p>
<h3><span class="koboSpan" id="kobo.347.1">Lombok’s builder</span></h3>
<p><span class="koboSpan" id="kobo.348.1">In </span><a href="B20912_05.xhtml#_idTextAnchor117"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.349.1">Chapter 5</span></em></span></a><span class="koboSpan" id="kobo.350.1">, we saw what the builder pattern is: a design pattern that helps construct complex objects </span><a id="_idIndexMarker511"/><span class="koboSpan" id="kobo.351.1">by separating their construction from their representation, making it easier to create objects with </span><span class="No-Break"><span class="koboSpan" id="kobo.352.1">various configurations.</span></span></p>
<p><span class="koboSpan" id="kobo.353.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.354.1">@Builder</span></strong><span class="koboSpan" id="kobo.355.1"> annotation lets you create a </span><em class="italic"><span class="koboSpan" id="kobo.356.1">builder</span></em><span class="koboSpan" id="kobo.357.1"> class for your type with basically no effort. </span><span class="koboSpan" id="kobo.357.2">If we take the </span><strong class="source-inline"><span class="koboSpan" id="kobo.358.1">Person</span></strong><span class="koboSpan" id="kobo.359.1"> class we wrote at the end of the previous section and add the </span><strong class="source-inline"><span class="koboSpan" id="kobo.360.1">@Builder</span></strong><span class="koboSpan" id="kobo.361.1"> annotation on top of it, Lombok will generate some code that we can use to instantiate a </span><strong class="source-inline"><span class="koboSpan" id="kobo.362.1">Person</span></strong><span class="koboSpan" id="kobo.363.1"> instance in the </span><span class="No-Break"><span class="koboSpan" id="kobo.364.1">following manner:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.365.1">
Person p = Person.builder()
        .name("Luke")
        .surname("Skywalker")
        .birthDate(parseDate("1951-09-25"))
        .build();</span></pre> <p><span class="koboSpan" id="kobo.366.1">In this example, you’re creating an instance of </span><strong class="source-inline"><span class="koboSpan" id="kobo.367.1">Person</span></strong><span class="koboSpan" id="kobo.368.1"> using a fluent and readable builder pattern. </span><span class="koboSpan" id="kobo.368.2">You set the values of the fields using the generated builder’s methods and then call </span><strong class="source-inline"><span class="koboSpan" id="kobo.369.1">.build()</span></strong><span class="koboSpan" id="kobo.370.1"> to create the </span><span class="No-Break"><span class="koboSpan" id="kobo.371.1">final instance.</span></span></p>
<p><span class="koboSpan" id="kobo.372.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.373.1">@Builder</span></strong><span class="koboSpan" id="kobo.374.1"> annotation can also handle optional fields and default values, making it a convenient way to create objects with a variable number </span><span class="No-Break"><span class="koboSpan" id="kobo.375.1">of properties.</span></span></p>
<p><span class="koboSpan" id="kobo.376.1">Lombok’s </span><strong class="source-inline"><span class="koboSpan" id="kobo.377.1">@Builder</span></strong><span class="koboSpan" id="kobo.378.1"> annotation is especially useful in scenarios where you need to construct complex objects with many optional parameters or when you want to create immutable objects. </span><span class="koboSpan" id="kobo.378.2">It eliminates the need to write repetitive, verbose, and error-prone boilerplate code for building objects, making your code more concise </span><span class="No-Break"><span class="koboSpan" id="kobo.379.1">and maintainable.</span></span></p>
<p><span class="koboSpan" id="kobo.380.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.381.1">@Builder</span></strong><span class="koboSpan" id="kobo.382.1"> annotation can generate “singular” methods for collection parameters/fields, which accept a single element rather than an entire list, and add that element to </span><a id="_idIndexMarker512"/><span class="koboSpan" id="kobo.383.1">the collection. </span><span class="koboSpan" id="kobo.383.2">Let’s look at the </span><span class="No-Break"><span class="koboSpan" id="kobo.384.1">following example:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.385.1">
@Builder
class Team {
    private String name;
    @Singular
    private List&lt;String&gt; members;
}</span></pre> <p><span class="koboSpan" id="kobo.386.1">Notice the </span><strong class="source-inline"><span class="koboSpan" id="kobo.387.1">@Singular</span></strong><span class="koboSpan" id="kobo.388.1"> annotation that was put on a collection field. </span><span class="koboSpan" id="kobo.388.2">When you annotate a parameter in a method or constructor with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.389.1">@Singular</span></strong><span class="koboSpan" id="kobo.390.1"> annotation or a field in a class with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.391.1">@Singular</span></strong><span class="koboSpan" id="kobo.392.1"> annotation, Lombok treats that builder node as a collection. </span><span class="koboSpan" id="kobo.392.2">As a result, Lombok generates two </span><strong class="bold"><span class="koboSpan" id="kobo.393.1">adder</span></strong><span class="koboSpan" id="kobo.394.1"> methods instead of a </span><strong class="bold"><span class="koboSpan" id="kobo.395.1">setter</span></strong><span class="koboSpan" id="kobo.396.1"> method. </span><span class="koboSpan" id="kobo.396.2">The first adder method allows you to add a single element to the collection, while the second adder method allows you to add all elements from another collection to the existing collection. </span><span class="koboSpan" id="kobo.396.3">Lombok does not generate a setter method that replaces the entire collection. </span><span class="koboSpan" id="kobo.396.4">Additionally, Lombok generates a </span><strong class="bold"><span class="koboSpan" id="kobo.397.1">clear</span></strong><span class="koboSpan" id="kobo.398.1"> method for </span><span class="No-Break"><span class="koboSpan" id="kobo.399.1">the collection.</span></span></p>
<p><span class="koboSpan" id="kobo.400.1">For example, you could write the following code for the previously shown </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.401.1">Team</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.402.1"> class:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.403.1">
Team myTeam = Team.builder()
        .member("John")
        .member("Susan")
        .member("Chris")
        .build();</span></pre> <p><span class="koboSpan" id="kobo.404.1">Alternatively, you could also write </span><span class="No-Break"><span class="koboSpan" id="kobo.405.1">the following:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.406.1">
var members = List.of("John", "Susan", "Chris");
Team myTeam = Team.builder()
        .members(members)
        .build();</span></pre> <p><span class="koboSpan" id="kobo.407.1">You will get the </span><span class="No-Break"><span class="koboSpan" id="kobo.408.1">same result.</span></span></p>
<p><span class="koboSpan" id="kobo.409.1">If a particular </span><a id="_idIndexMarker513"/><span class="koboSpan" id="kobo.410.1">field or parameter is not explicitly set during the object construction process, it will default to values such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.411.1">0</span></strong><span class="koboSpan" id="kobo.412.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.413.1">null</span></strong><span class="koboSpan" id="kobo.414.1">, or </span><strong class="source-inline"><span class="koboSpan" id="kobo.415.1">false</span></strong><span class="koboSpan" id="kobo.416.1">, depending on its type. </span><span class="koboSpan" id="kobo.416.2">When you use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.417.1">@Builder</span></strong><span class="koboSpan" id="kobo.418.1"> annotation in a class (rather than a method or constructor), you can define a default value directly on the field and annotate it with </span><strong class="source-inline"><span class="koboSpan" id="kobo.419.1">@Builder.Default</span></strong><span class="koboSpan" id="kobo.420.1">. </span><span class="koboSpan" id="kobo.420.2">Look at the following code as </span><span class="No-Break"><span class="koboSpan" id="kobo.421.1">an example:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.422.1">
@Builder
class Team {
    private String name;
    @Builder.Default private Long created = System.currentTimeMillis();
    @Singular
    private List&lt;String&gt; members;
}</span></pre> <p><span class="koboSpan" id="kobo.423.1">In this example, if the created field is not set during object construction, it will default to the result of </span><strong class="source-inline"><span class="koboSpan" id="kobo.424.1">System.currentTimeMillis()</span></strong><span class="koboSpan" id="kobo.425.1">, ensuring that it always has a valid </span><span class="No-Break"><span class="koboSpan" id="kobo.426.1">timestamp value.</span></span></p>
<p><span class="koboSpan" id="kobo.427.1">When used in a sentence, Lombok’s builder feature is particularly useful because it simplifies the creation of complex objects with a fluent and concise syntax, reducing the need for manual builder pattern implementation in Java. </span><span class="koboSpan" id="kobo.427.2">However, there are also some drawbacks to using this library, which we will investigate in the </span><span class="No-Break"><span class="koboSpan" id="kobo.428.1">following section.</span></span></p>
<h3><span class="koboSpan" id="kobo.429.1">Some final considerations about Lombok’s pros and cons</span></h3>
<p><span class="koboSpan" id="kobo.430.1">By reducing the boilerplate code, Lombok helps improve code cleanliness and readability. </span><span class="koboSpan" id="kobo.430.2">Developers can focus on writing the essential business logic of their classes, making the </span><a id="_idIndexMarker514"/><span class="koboSpan" id="kobo.431.1">code base more understandable and maintainable. </span><span class="koboSpan" id="kobo.431.2">It also reduces the chances of introducing bugs in the manually written </span><span class="No-Break"><span class="koboSpan" id="kobo.432.1">boilerplate code.</span></span></p>
<p><span class="koboSpan" id="kobo.433.1">With Lombok, maintaining the code becomes more straightforward. </span><span class="koboSpan" id="kobo.433.2">When you need to add or remove fields from a class, you don’t have to update all the related methods manually. </span><span class="koboSpan" id="kobo.433.3">Lombok’s annotations take care of these changes automatically </span><span class="No-Break"><span class="koboSpan" id="kobo.434.1">during compilation.</span></span></p>
<p><span class="koboSpan" id="kobo.435.1">Most modern IDEs support Lombok out of the box. </span><span class="koboSpan" id="kobo.435.2">They can recognize Lombok annotations and provide code completion, navigation, and refactoring assistance as if the code were written manually. </span><span class="koboSpan" id="kobo.435.3">This ensures a seamless development experience </span><span class="No-Break"><span class="koboSpan" id="kobo.436.1">for developers.</span></span></p>
<p><span class="koboSpan" id="kobo.437.1">In our humble opinion, Project Lombok is a valuable tool in the Java ecosystem that simplifies code development by automating the generation of common code elements, reducing boilerplate, and improving code readability. </span><span class="koboSpan" id="kobo.437.2">It allows developers to focus on the core functionality of their classes and reduces the chances of introducing errors in repetitive code. </span><span class="koboSpan" id="kobo.437.3">This makes Java code cleaner, more concise, and easier </span><span class="No-Break"><span class="koboSpan" id="kobo.438.1">to maintain.</span></span></p>
<p><span class="koboSpan" id="kobo.439.1">However, to give a complete and honest overview, we have to highlight some common criticisms about Lombok. </span><span class="koboSpan" id="kobo.439.2">Let’s start with the most subjective (almost a “gut feeling” some people have) criticism: Lombok’s unique and sometimes forceful way of doing things (in particular, modifying the bytecode) has often made people see it as a bit of a workaround. </span><span class="koboSpan" id="kobo.439.3">We see it as a clever, technically sound, and innovative solution rather than a negative hack. </span><span class="koboSpan" id="kobo.439.4">However, some developers still see it as a workaround and avoid using Lombok for that reason. </span><span class="koboSpan" id="kobo.439.5">That’s a valid perspective, but in our experience, Lombok’s advantages in terms of productivity are more significant than any worries about its approach. </span><span class="koboSpan" id="kobo.439.6">We’ve been using it happily in real-life projects for </span><span class="No-Break"><span class="koboSpan" id="kobo.440.1">many years.</span></span></p>
<p><span class="koboSpan" id="kobo.441.1">It is useless to deny that, since Lombok intervenes as a sort of “extra step” at the time of compilation, the time to carry out this practice increases. </span><span class="koboSpan" id="kobo.441.2">As the code base increases, of course, the times increase proportionally. </span><span class="koboSpan" id="kobo.441.3">As high as the efficiency is and the Lombok team actively working on further improvements, it is undeniable that projects compile faster </span><span class="No-Break"><span class="koboSpan" id="kobo.442.1">without Lombok.</span></span></p>
<p><span class="koboSpan" id="kobo.443.1">There could also be problems related to compatibility between different versions of Java. </span><span class="koboSpan" id="kobo.443.2">With each version change, Java could change the way your AST is generated and/or interpreted. </span><span class="koboSpan" id="kobo.443.3">Consequently, it is not certain that Lombok can generate the code correctly or that it succeeds at all. </span><span class="koboSpan" id="kobo.443.4">The code may stop compiling. </span><span class="koboSpan" id="kobo.443.5">Unfortunately, we would only notice this after upgrading Java, but it is also true that new versions of the library are released before the final versions of Java. </span><span class="koboSpan" id="kobo.443.6">However, there is still one possibility to </span><span class="No-Break"><span class="koboSpan" id="kobo.444.1">be considered.</span></span></p>
<p><span class="koboSpan" id="kobo.445.1">This eventuality leads us to another problematic aspect, namely the fact that Lombok makes the code we write non-standard; since we need the Lombok plugin to compile, it is undeniable that the code we are writing, in a sense, is not valid. </span><span class="koboSpan" id="kobo.445.2">We will always depend on tools that are “external” </span><span class="No-Break"><span class="koboSpan" id="kobo.446.1">to Java.</span></span></p>
<p><span class="koboSpan" id="kobo.447.1">The last possible </span><a id="_idIndexMarker515"/><span class="koboSpan" id="kobo.448.1">flaw that comes to mind is not a defect in my opinion, but something I have often heard. </span><span class="koboSpan" id="kobo.448.2">It’s true that Lombok greatly reduces the number of lines of code, eliminating the so-called boilerplate, but it is also true that all IDEs can generate that boilerplate in a couple of clicks. </span><span class="koboSpan" id="kobo.448.3">This is a pseudo-criticism of Lombok. </span><span class="koboSpan" id="kobo.448.4">While it is certainly true that getters, setters, equals, builders, and more are generated in a moment by any IDE worthy of the name, it is also true that all of this code must then be maintained. </span><span class="koboSpan" id="kobo.448.5">How many times have we added a field to a class and forgotten to update the </span><strong class="source-inline"><span class="koboSpan" id="kobo.449.1">equals</span></strong><span class="koboSpan" id="kobo.450.1"> method? </span><span class="koboSpan" id="kobo.450.2">How many times have we had to change the getters and setters of a field because we changed its name or type? </span><span class="koboSpan" id="kobo.450.3">With Lombok, the chances of all these errors occurring simply do </span><span class="No-Break"><span class="koboSpan" id="kobo.451.1">not exist.</span></span></p>
<p><span class="koboSpan" id="kobo.452.1">I hope I’ve given you some interesting ideas to think about so far. </span><span class="koboSpan" id="kobo.452.2">Unfortunately, I don’t have a one-size-fits-all solution for all these considerations. </span><span class="koboSpan" id="kobo.452.3">As always, we recommend evaluating each situation individually and trying to reach a </span><span class="No-Break"><span class="koboSpan" id="kobo.453.1">team agreement.</span></span></p>
<p><span class="koboSpan" id="kobo.454.1">In the next section, we will tell you about another library that can save you from a lot of manual work, especially when it comes to converting one type into another, which is something that unfortunately needs to be done in practically every project. </span><span class="koboSpan" id="kobo.454.2">MapStruct will free you from this burden or at least make </span><span class="No-Break"><span class="koboSpan" id="kobo.455.1">it easier.</span></span></p>
<h2 id="_idParaDest-150"><a id="_idTextAnchor155"/><span class="koboSpan" id="kobo.456.1">MapStruct</span></h2>
<p><span class="koboSpan" id="kobo.457.1">While it’s </span><a id="_idIndexMarker516"/><span class="koboSpan" id="kobo.458.1">not great to say, part of our job as software engineers is shipping </span><a id="_idIndexMarker517"/><span class="koboSpan" id="kobo.459.1">information from one place to another. </span><span class="koboSpan" id="kobo.459.2">Sometimes, this shipping becomes a mere translation of a model into another model. </span><span class="koboSpan" id="kobo.459.3">Sad, </span><span class="No-Break"><span class="koboSpan" id="kobo.460.1">but true.</span></span></p>
<p><span class="koboSpan" id="kobo.461.1">Object mapping (sometimes </span><a id="_idIndexMarker518"/><span class="koboSpan" id="kobo.462.1">referred to as </span><strong class="bold"><span class="koboSpan" id="kobo.463.1">object adapting</span></strong><span class="koboSpan" id="kobo.464.1">) refers to the process of transforming data between different data models, such as from objects in an object-oriented programming language to database tables and vice versa. </span><span class="koboSpan" id="kobo.464.2">This process also includes objects belonging to different subdomains or even different layers of the application. </span><span class="koboSpan" id="kobo.464.3">Another notable example of mapping that is done frequently is when you have to call an external service (for example, via an HTTP/REST call) and you have to map the response you get from that service into your objects or your model. </span><span class="koboSpan" id="kobo.464.4">This situation is represented in the </span><span class="No-Break"><span class="koboSpan" id="kobo.465.1">following diagram:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer038">
<span class="koboSpan" id="kobo.466.1"><img alt="Figure 6.1 – Mapping between client and service request models and back to the client model" src="image/B20912_06_1.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.467.1">Figure 6.1 – Mapping between client and service request models and back to the client model</span></p>
<p><span class="koboSpan" id="kobo.468.1">Writing </span><a id="_idIndexMarker519"/><span class="koboSpan" id="kobo.469.1">mapping code can be very boring, and it’s prone to mistakes. </span><span class="koboSpan" id="kobo.469.2">But what if there was a tool that could do all this grunt work with minimal effort? </span><span class="koboSpan" id="kobo.469.3">Luckily for us, there are quite a few such tools out there, and our top pick </span><span class="No-Break"><span class="koboSpan" id="kobo.470.1">is MapStruct.</span></span></p>
<p><strong class="bold"><span class="koboSpan" id="kobo.471.1">MapStruct</span></strong><span class="koboSpan" id="kobo.472.1"> is an open </span><a id="_idIndexMarker520"/><span class="koboSpan" id="kobo.473.1">source Java-based code generation library that simplifies the process of mapping between Java beans (POJOs). </span><span class="koboSpan" id="kobo.473.2">It is specifically designed for generating mapping codes between objects, eliminating the need to write this code manually, which can be time-consuming and error-prone. </span><span class="koboSpan" id="kobo.473.3">MapStruct’s primary purpose is to provide a straightforward and efficient way to convert data between different Java </span><span class="No-Break"><span class="koboSpan" id="kobo.474.1">bean classes.</span></span></p>
<p><span class="koboSpan" id="kobo.475.1">MapStruct serves as an annotation processor that’s seamlessly integrated into the Java compiler, making it compatible with command-line build tools such as Maven and Gradle, and equally suitable for use within your favorite IDE. </span><span class="koboSpan" id="kobo.475.2">While MapStruct provides sensible defaults for mapping, it also allows you to configure and implement specific behaviors when needed, giving you flexibility without imposing </span><span class="No-Break"><span class="koboSpan" id="kobo.476.1">rigid constraints.</span></span></p>
<p><span class="koboSpan" id="kobo.477.1">Let’s see how MapStruct works. </span><span class="koboSpan" id="kobo.477.2">Suppose you have the following </span><span class="No-Break"><span class="koboSpan" id="kobo.478.1">two classes:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.479.1">
public class Person {
    private String name;
    private String surname;
    private Integer age;
   // getters and setters...
</span><span class="koboSpan" id="kobo.479.2">}
public class PersonDTO {
    private String name;
    private String lastName;
    private LocalDate birthDate;
    // getters and setters...
</span><span class="koboSpan" id="kobo.479.3">}</span></pre> <p><span class="koboSpan" id="kobo.480.1">We need </span><a id="_idIndexMarker521"/><span class="koboSpan" id="kobo.481.1">to transfer the data from an </span><a id="_idIndexMarker522"/><span class="koboSpan" id="kobo.482.1">instance of </span><strong class="source-inline"><span class="koboSpan" id="kobo.483.1">PersonDTO</span></strong><span class="koboSpan" id="kobo.484.1"> to an instance of </span><strong class="source-inline"><span class="koboSpan" id="kobo.485.1">Person</span></strong><span class="koboSpan" id="kobo.486.1">. </span><span class="koboSpan" id="kobo.486.2">To do it in plain Java, we would need to write </span><span class="No-Break"><span class="koboSpan" id="kobo.487.1">the following:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.488.1">
public Person from(PersonDTO personDTO) {
    if (personDTO == null) {
        return null;
    }
    Person person = new Person();
    person.setName(personDTO.getName());
    person.setSurname(personDTO.getLastName());
    person.setAge(calculateCurrentAge(personDTO.getBirthDate()));
    return person;
}
private Integer calculateCurrentAge(LocalDate birthDate) {
    return Period.between(birthDate, LocalDate.now()).getYears();
}</span></pre> <p><span class="koboSpan" id="kobo.489.1">That is quite </span><a id="_idIndexMarker523"/><span class="koboSpan" id="kobo.490.1">a lot of code for only three fields; it’s boring, time-consuming, </span><span class="No-Break"><span class="koboSpan" id="kobo.491.1">and error-prone.</span></span></p>
<p><span class="koboSpan" id="kobo.492.1">Using </span><a id="_idIndexMarker524"/><span class="koboSpan" id="kobo.493.1">MapStruct, we could just write an interface and let it do </span><span class="No-Break"><span class="koboSpan" id="kobo.494.1">the magic:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.495.1">
@Mapper
public interface PersonMapper {
    PersonMapper INSTANCE = Mappers.getMapper(PersonMapper.class);
    @Mapping(source="lastName", target="surname")
    Person personDtoToPerson(PersonDTO personDto);
}</span></pre> <p><span class="koboSpan" id="kobo.496.1">The presence of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.497.1">@Mapper</span></strong><span class="koboSpan" id="kobo.498.1"> annotation designates the interface as a mapping interface and triggers the MapStruct processor to engage during the compilation process. </span><span class="koboSpan" id="kobo.498.2">In the mapping method itself, you can freely select its name, and it should accept the </span><strong class="source-inline"><span class="koboSpan" id="kobo.499.1">source</span></strong><span class="koboSpan" id="kobo.500.1"> object as a parameter while returning the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.501.1">target</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.502.1"> object.</span></span></p>
<p><span class="koboSpan" id="kobo.503.1">To handle attributes with distinct names in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.504.1">source</span></strong><span class="koboSpan" id="kobo.505.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.506.1">target</span></strong><span class="koboSpan" id="kobo.507.1"> objects, you can employ the </span><strong class="source-inline"><span class="koboSpan" id="kobo.508.1">@Mapping</span></strong><span class="koboSpan" id="kobo.509.1"> annotation to specify the desired configuration. </span><span class="koboSpan" id="kobo.509.2">When necessary and feasible, type conversions will be carried out for attributes with differing types in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.510.1">source</span></strong><span class="koboSpan" id="kobo.511.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.512.1">target</span></strong><span class="koboSpan" id="kobo.513.1"> objects. </span><span class="koboSpan" id="kobo.513.2">For instance, an enumeration type may be transformed into </span><span class="No-Break"><span class="koboSpan" id="kobo.514.1">a string.</span></span></p>
<p><span class="koboSpan" id="kobo.515.1">It’s worth </span><a id="_idIndexMarker525"/><span class="koboSpan" id="kobo.516.1">noting that a single interface can host multiple mapping methods, each of which will have an implementation </span><a id="_idIndexMarker526"/><span class="koboSpan" id="kobo.517.1">auto-generated by MapStruct. </span><span class="koboSpan" id="kobo.517.2">You can obtain an instance of the interface’s implementation through the </span><strong class="source-inline"><span class="koboSpan" id="kobo.518.1">Mappers</span></strong><span class="koboSpan" id="kobo.519.1"> class. </span><span class="koboSpan" id="kobo.519.2">As a convention, the interface typically includes a member called </span><strong class="source-inline"><span class="koboSpan" id="kobo.520.1">INSTANCE</span></strong><span class="koboSpan" id="kobo.521.1">, offering clients a means to access the </span><span class="No-Break"><span class="koboSpan" id="kobo.522.1">mapper implementation.</span></span></p>
<p><span class="koboSpan" id="kobo.523.1">MapStruct will generate all the needed code </span><span class="No-Break"><span class="koboSpan" id="kobo.524.1">for you.</span></span></p>
<p><span class="koboSpan" id="kobo.525.1">You might have noticed that we’re missing the mapping from </span><strong class="source-inline"><span class="koboSpan" id="kobo.526.1">birthdate</span></strong><span class="koboSpan" id="kobo.527.1"> to </span><strong class="source-inline"><span class="koboSpan" id="kobo.528.1">age</span></strong><span class="koboSpan" id="kobo.529.1">; this cannot be done automatically by MapStruct since a little bit of logic is involved (to calculate the current age from the birth date). </span><span class="koboSpan" id="kobo.529.2">In this case – and in any case, we should need it – we can implement specific mappings; also, in this case, the method names are not important since MapStruct will choose the right one based on the parameter and </span><span class="No-Break"><span class="koboSpan" id="kobo.530.1">return types:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.531.1">
@Mapper
public interface PersonMapper {
    PersonMapper INSTANCE = Mappers.getMapper(PersonMapper.class);
    @Mapping(source="lastName", target="surname")
    @Mapping(source="birthDate", target="age")
    Person personDtoToPerson(PersonDTO personDto);
    default Integer calculateCurrentAge(LocalDate birthDate) {
        return Period.between(birthDate, LocalDate.now()).getYears();
    }
}</span></pre> <p><span class="koboSpan" id="kobo.532.1">In the auto-generated implementation of the method, MapStruct will choose the </span><strong class="source-inline"><span class="koboSpan" id="kobo.533.1">calculateCurrentAge</span></strong><span class="koboSpan" id="kobo.534.1"> method just because it takes a </span><strong class="source-inline"><span class="koboSpan" id="kobo.535.1">LocalDate</span></strong><span class="koboSpan" id="kobo.536.1"> parameter and returns an </span><strong class="source-inline"><span class="koboSpan" id="kobo.537.1">Integer</span></strong><span class="koboSpan" id="kobo.538.1"> value. </span><span class="koboSpan" id="kobo.538.2">It is also possible to specify Java expressions and other stuff in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.539.1">@Mapping</span></strong><span class="koboSpan" id="kobo.540.1"> annotation, but I recommend reading the documentation to dig a little </span><span class="No-Break"><span class="koboSpan" id="kobo.541.1">bit deeper.</span></span></p>
<p><span class="koboSpan" id="kobo.542.1">With that, we’ve </span><a id="_idIndexMarker527"/><span class="koboSpan" id="kobo.543.1">seen how MapStruct </span><a id="_idIndexMarker528"/><span class="koboSpan" id="kobo.544.1">works and how it can make our lives easier by handling time-consuming tasks. </span><span class="koboSpan" id="kobo.544.2">As I mentioned, these were static metaprogramming tools – they work directly on the code. </span><span class="koboSpan" id="kobo.544.3">Now, let’s look at runtime metaprogramming tools, which work on the running </span><span class="No-Break"><span class="koboSpan" id="kobo.545.1">program instead.</span></span></p>
<h1 id="_idParaDest-151"><a id="_idTextAnchor156"/><span class="koboSpan" id="kobo.546.1">Exploring runtime metaprogramming tools</span></h1>
<p><strong class="bold"><span class="koboSpan" id="kobo.547.1">Runtime metaprogramming</span></strong><span class="koboSpan" id="kobo.548.1"> operates while the program is being executed. </span><span class="koboSpan" id="kobo.548.2">It enables the </span><a id="_idIndexMarker529"/><span class="koboSpan" id="kobo.549.1">program to inspect and modify its own code and data structures during runtime, often using techniques such as reflection, dynamic code generation, and dynamic proxy. </span><span class="koboSpan" id="kobo.549.2">Learning about runtime metaprogramming tools can empower you to manipulate and adapt the behavior of a running program dynamically, enhancing flexibility and customization within </span><span class="No-Break"><span class="koboSpan" id="kobo.550.1">your software.</span></span></p>
<p><span class="koboSpan" id="kobo.551.1">Now, let’s talk about reflection since it is the most used feature in </span><span class="No-Break"><span class="koboSpan" id="kobo.552.1">runtime metaprogramming.</span></span></p>
<h2 id="_idParaDest-152"><a id="_idTextAnchor157"/><span class="koboSpan" id="kobo.553.1">Reflection</span></h2>
<p><strong class="bold"><span class="koboSpan" id="kobo.554.1">Reflection</span></strong><span class="koboSpan" id="kobo.555.1"> is a feature </span><a id="_idIndexMarker530"/><span class="koboSpan" id="kobo.556.1">in programming </span><a id="_idIndexMarker531"/><span class="koboSpan" id="kobo.557.1">languages such as Java that allows a program to examine or </span><em class="italic"><span class="koboSpan" id="kobo.558.1">reflect</span></em><span class="koboSpan" id="kobo.559.1"> upon its structure, data, and behavior during runtime. </span><span class="koboSpan" id="kobo.559.2">In Java, reflection is primarily used to inspect and manipulate classes, objects, methods, fields, and other elements of the program </span><span class="No-Break"><span class="koboSpan" id="kobo.560.1">at runtime.</span></span></p>
<p><span class="koboSpan" id="kobo.561.1">Reflection allows you to perform the following tasks </span><span class="No-Break"><span class="koboSpan" id="kobo.562.1">in Java:</span></span></p>
<ol>
<li><strong class="bold"><span class="koboSpan" id="kobo.563.1">Inspect classes</span></strong><span class="koboSpan" id="kobo.564.1">: You can </span><a id="_idIndexMarker532"/><span class="koboSpan" id="kobo.565.1">obtain information about classes, including their name, superclass, implemented interfaces, constructors, methods, </span><span class="No-Break"><span class="koboSpan" id="kobo.566.1">and fields</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.567.1">Inspect objects</span></strong><span class="koboSpan" id="kobo.568.1">: You can </span><a id="_idIndexMarker533"/><span class="koboSpan" id="kobo.569.1">examine the properties and fields of objects, even if their types are not known at </span><span class="No-Break"><span class="koboSpan" id="kobo.570.1">compile time</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.571.1">Invoke methods</span></strong><span class="koboSpan" id="kobo.572.1">: You can </span><a id="_idIndexMarker534"/><span class="koboSpan" id="kobo.573.1">invoke methods on objects, even if you don’t know the method’s name </span><span class="No-Break"><span class="koboSpan" id="kobo.574.1">until runtime</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.575.1">Access fields</span></strong><span class="koboSpan" id="kobo.576.1">: You can </span><a id="_idIndexMarker535"/><span class="koboSpan" id="kobo.577.1">read or modify the values of fields within an object, even if you don’t know the field’s name </span><span class="No-Break"><span class="koboSpan" id="kobo.578.1">until runtime</span></span></li>
</ol>
<p><span class="koboSpan" id="kobo.579.1">For example, let’s add </span><a id="_idIndexMarker536"/><span class="koboSpan" id="kobo.580.1">the following method to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.581.1">Person</span></strong><span class="koboSpan" id="kobo.582.1"> class (see the </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.583.1">MapStruct</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.584.1"> section):</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.585.1">
public void greet(){
    System.out.printf("Hello I'm %s%n", name);
}</span></pre> <p><span class="koboSpan" id="kobo.586.1">Now, let’s </span><a id="_idIndexMarker537"/><span class="koboSpan" id="kobo.587.1">create another class that operates on it </span><span class="No-Break"><span class="koboSpan" id="kobo.588.1">using reflection:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.589.1">
public class ReflectionExample {
    public static void main(String[] args) throws Exception {
        // Obtain the class object
        Class&lt;?&gt; personClass = Class.forName("com.example.demo3.mapstruct.Person");
        // Create an instance of the Person class
        Object personInstance = personClass.getConstructor(String.class, String.class, Integer.class)
                .newInstance("Alice", "Smith", 30);
        // Access and modify fields using reflection
        Field nameField = personClass.getDeclaredField("name");
        nameField.setAccessible(true); // Bypass private access
                                       // modifier
        String nameValue = (String) nameField.get(personInstance);
        System.out.println("Original Name: " + nameValue);
        nameField.set(personInstance, "Bob");
        // Access and invoke methods using reflection
        Method greetMethod = personClass.getDeclaredMethod("greet");
        greetMethod.invoke(personInstance);
        // Verify the modified name
        String modifiedName = (String) nameField.get(personInstance);
        System.out.println("Modified Name: " + modifiedName);
    }
}</span></pre> <p><span class="koboSpan" id="kobo.590.1">In this example, we do </span><span class="No-Break"><span class="koboSpan" id="kobo.591.1">the following:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.592.1">We obtain the </span><strong class="source-inline"><span class="koboSpan" id="kobo.593.1">Class</span></strong><span class="koboSpan" id="kobo.594.1"> object representing the </span><strong class="source-inline"><span class="koboSpan" id="kobo.595.1">Person</span></strong><span class="koboSpan" id="kobo.596.1"> class using </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.597.1">Class.forName(" com.example.demo3.mapstruct.Person")</span></strong></span></li>
<li><span class="koboSpan" id="kobo.598.1">We create an instance of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.599.1">Person</span></strong><span class="koboSpan" id="kobo.600.1"> class dynamically using </span><span class="No-Break"><span class="koboSpan" id="kobo.601.1">its constructor</span></span></li>
<li><span class="koboSpan" id="kobo.602.1">We access the private name field, bypassing the access modifier and modifying </span><span class="No-Break"><span class="koboSpan" id="kobo.603.1">its value</span></span></li>
<li><span class="koboSpan" id="kobo.604.1">We invoke the </span><strong class="source-inline"><span class="koboSpan" id="kobo.605.1">greet</span></strong><span class="koboSpan" id="kobo.606.1"> method of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.607.1">Person</span></strong><span class="koboSpan" id="kobo.608.1"> instance </span><span class="No-Break"><span class="koboSpan" id="kobo.609.1">using reflection</span></span></li>
<li><span class="koboSpan" id="kobo.610.1">We verify that the name field has been </span><span class="No-Break"><span class="koboSpan" id="kobo.611.1">modified successfully</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.612.1">Please note that while this example demonstrates the use of reflection, it is essential to exercise caution when using reflection in practice. </span><span class="koboSpan" id="kobo.612.2">Reflection should be used judiciously, and you should be aware of the potential risks and performance implications associated </span><span class="No-Break"><span class="koboSpan" id="kobo.613.1">with it.</span></span></p>
<p><span class="koboSpan" id="kobo.614.1">For example, there could be security risks because reflection can bypass Java’s access controls, allowing you to access and modify private members of classes. </span><span class="koboSpan" id="kobo.614.2">While this flexibility can be beneficial, it can also introduce security vulnerabilities if it’s not used with due care. </span><span class="koboSpan" id="kobo.614.3">Unauthorized access to sensitive data or the manipulation of internal program states </span><a id="_idIndexMarker538"/><span class="koboSpan" id="kobo.615.1">can occur, which is why it’s crucial to employ security measures to </span><span class="No-Break"><span class="koboSpan" id="kobo.616.1">prevent abuse.</span></span></p>
<p><span class="koboSpan" id="kobo.617.1">Another very </span><a id="_idIndexMarker539"/><span class="koboSpan" id="kobo.618.1">common problem is type safety: reflection operates at a low level and doesn’t provide the same level of type safety as traditional Java code. </span><span class="koboSpan" id="kobo.618.2">This can lead to unexpected type errors at runtime. </span><span class="koboSpan" id="kobo.618.3">For instance, you might call a method with the wrong parameters, and the error won’t be discovered until your code is running. </span><span class="koboSpan" id="kobo.618.4">This lack of compile-time checks can result in hard-to-debug runtime exceptions. </span><span class="koboSpan" id="kobo.618.5">It is also true that most of the modern IDEs warn the developer about this risk at the moment of </span><span class="No-Break"><span class="koboSpan" id="kobo.619.1">writing code.</span></span></p>
<p><span class="koboSpan" id="kobo.620.1">There are also some other challenges, concerning reflection in association with the clean code, that we will expand on in the </span><span class="No-Break"><span class="koboSpan" id="kobo.621.1">following section.</span></span></p>
<h3><span class="koboSpan" id="kobo.622.1">Reflection and clean code</span></h3>
<p><span class="koboSpan" id="kobo.623.1">In a chapter about metaprogramming, we felt we had the duty to tell you something about runtime metaprogramming and its most (in)famous declination, which is reflection. </span><span class="koboSpan" id="kobo.623.2">But let’s think a bit about what reflection involves in terms of keeping your code </span><span class="No-Break"><span class="koboSpan" id="kobo.624.1">base clean.</span></span></p>
<p><span class="koboSpan" id="kobo.625.1">Reflection and </span><strong class="bold"><span class="koboSpan" id="kobo.626.1">clean code</span></strong><span class="koboSpan" id="kobo.627.1"> can sometimes </span><a id="_idIndexMarker540"/><span class="koboSpan" id="kobo.628.1">be at odds with each other as reflection introduces complexities and potential code readability issues. </span><span class="koboSpan" id="kobo.628.2">However, when used carefully and thoughtfully, reflection can be employed in a clean and maintainable way. </span><span class="koboSpan" id="kobo.628.3">Let’s explore how reflection can impact clean code principles and how to strike a balance </span><span class="No-Break"><span class="koboSpan" id="kobo.629.1">between them:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.630.1">Readability</span></strong><span class="koboSpan" id="kobo.631.1">: Clean code promotes readability. </span><span class="koboSpan" id="kobo.631.2">Reflection can make code less readable as it </span><a id="_idIndexMarker541"/><span class="koboSpan" id="kobo.632.1">often involves working with class names and method names as strings, which are error-prone and can lead to code that is challenging to understand. </span><span class="koboSpan" id="kobo.632.2">To mitigate this, document your use of reflection thoroughly and provide clear comments explaining </span><span class="No-Break"><span class="koboSpan" id="kobo.633.1">your intentions.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.634.1">Maintainability</span></strong><span class="koboSpan" id="kobo.635.1">: Reflection can make code harder to maintain because it bypasses some </span><a id="_idIndexMarker542"/><span class="koboSpan" id="kobo.636.1">of the compile-time checks that the Java compiler provides. </span><span class="koboSpan" id="kobo.636.2">If you’re using reflection to access private members or perform operations that wouldn’t be allowed through normal means, it can lead to unexpected behavior or maintenance challenges. </span><span class="koboSpan" id="kobo.636.3">You should consider alternatives, such as making the necessary changes to the code structure, </span><span class="No-Break"><span class="koboSpan" id="kobo.637.1">whenever possible.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.638.1">Simplicity</span></strong><span class="koboSpan" id="kobo.639.1">: Clean code encourages simplicity. </span><span class="koboSpan" id="kobo.639.2">Reflection, being a complex feature, can introduce </span><a id="_idIndexMarker543"/><span class="koboSpan" id="kobo.640.1">unnecessary complexity. </span><span class="koboSpan" id="kobo.640.2">It’s essential to ensure that your use of reflection is justified and that you are not introducing complexity where it’s </span><span class="No-Break"><span class="koboSpan" id="kobo.641.1">not needed.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.642.1">Consistency</span></strong><span class="koboSpan" id="kobo.643.1">: Clean code aims for consistency and a uniform style. </span><span class="koboSpan" id="kobo.643.2">Reflection can lead to </span><a id="_idIndexMarker544"/><span class="koboSpan" id="kobo.644.1">inconsistent code because different parts of your program might access and manipulate elements in a variety of ways. </span><span class="koboSpan" id="kobo.644.2">To maintain consistency, consider establishing conventions and patterns for your use </span><span class="No-Break"><span class="koboSpan" id="kobo.645.1">of reflection.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.646.1">Testing</span></strong><span class="koboSpan" id="kobo.647.1">: Clean code emphasizes testability. </span><span class="koboSpan" id="kobo.647.2">Reflection can make it challenging to write unit </span><a id="_idIndexMarker545"/><span class="koboSpan" id="kobo.648.1">tests since it allows you to bypass encapsulation. </span><span class="koboSpan" id="kobo.648.2">You might need to rely on integration tests or mock objects, which can be less ideal for isolated unit testing. </span><span class="koboSpan" id="kobo.648.3">Whenever possible, prefer to design your code for easy unit testing without relying heavily </span><span class="No-Break"><span class="koboSpan" id="kobo.649.1">on reflection.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.650.1">Performance</span></strong><span class="koboSpan" id="kobo.651.1">: Clean code should be efficient. </span><span class="koboSpan" id="kobo.651.2">Reflection can introduce performance </span><a id="_idIndexMarker546"/><span class="koboSpan" id="kobo.652.1">overhead due to its dynamic nature. </span><span class="koboSpan" id="kobo.652.2">Before using reflection, profile your code and ensure that the performance impact is acceptable. </span><span class="koboSpan" id="kobo.652.3">In performance-critical applications, you might need to explore </span><span class="No-Break"><span class="koboSpan" id="kobo.653.1">alternative approaches.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.654.1">Documentation</span></strong><span class="koboSpan" id="kobo.655.1">: Clean code aims to have no technical documentation at all since the </span><a id="_idIndexMarker547"/><span class="koboSpan" id="kobo.656.1">code is so clear that it explains itself. </span><span class="koboSpan" id="kobo.656.2">However, since reflection decreases readability (we just said that a few words ago), the need for clear documentation or comments becomes essential. </span><span class="koboSpan" id="kobo.656.3">When using reflection, think about providing comprehensive documentation explaining the purpose, expected behavior, and potential risks associated with your </span><span class="No-Break"><span class="koboSpan" id="kobo.657.1">reflective code.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.658.1">So, reflection is a powerful but potentially dangerous feature in Java, and it should be used sparingly and with caution. </span><span class="koboSpan" id="kobo.658.2">It’s essential to weigh the benefits of using reflection against the added complexity and potential drawbacks it introduces to your code base. </span><span class="koboSpan" id="kobo.658.3">If you decide to use reflection, do so thoughtfully and document your code thoroughly to maintain clarity and transparency. </span><span class="koboSpan" id="kobo.658.4">Clean code principles should remain a top priority, even when you’re using reflection, to ensure your code base remains maintainable, readable, and efficient (nevertheless, it is worth noticing that reflection is often used “under the hood” in many </span><span class="No-Break"><span class="koboSpan" id="kobo.659.1">metaprogramming frameworks).</span></span></p>
<p><span class="koboSpan" id="kobo.660.1">Now that we’ve learned what metaprogramming is, both in its static and runtime flavor, let’s add some considerations about the pros and cons of these very </span><span class="No-Break"><span class="koboSpan" id="kobo.661.1">powerful tools.</span></span></p>
<h1 id="_idParaDest-153"><a id="_idTextAnchor158"/><span class="koboSpan" id="kobo.662.1">Weighing the pros and cons of metaprogramming</span></h1>
<p><span class="koboSpan" id="kobo.663.1">Metaprogramming and clean code are two essential concepts in software development, and while they </span><a id="_idIndexMarker548"/><span class="koboSpan" id="kobo.664.1">can sometimes appear to be at odds, they can also work in harmony when </span><span class="No-Break"><span class="koboSpan" id="kobo.665.1">used effectively.</span></span></p>
<p><span class="koboSpan" id="kobo.666.1">Metaprogramming, in essence, involves dynamically manipulating or generating code during compilation or runtime. </span><span class="koboSpan" id="kobo.666.2">It offers the ability to automate repetitive tasks, create abstractions, and introduce flexibility into software development. </span><span class="koboSpan" id="kobo.666.3">Clean code, on the other hand, is a coding philosophy that emphasizes writing code that is easily readable, understandable, and maintainable. </span><span class="koboSpan" id="kobo.666.4">It promotes principles such as meaningful naming, eliminating redundancy, small and focused functions, and adhering to established </span><span class="No-Break"><span class="koboSpan" id="kobo.667.1">coding conventions.</span></span></p>
<p><span class="koboSpan" id="kobo.668.1">Metaprogramming can aid in generating clean code by automating the creation of repetitive code structures and reducing clutter in source code files (for example, eliminating some boilerplate code, as we saw in the case </span><span class="No-Break"><span class="koboSpan" id="kobo.669.1">of Lombok).</span></span></p>
<p><span class="koboSpan" id="kobo.670.1">Moreover, it can facilitate the development of abstractions that hide implementation details, leading to cleaner and more </span><span class="No-Break"><span class="koboSpan" id="kobo.671.1">maintainable code.</span></span></p>
<p><span class="koboSpan" id="kobo.672.1">However, not all that glitters is gold; you must ensure that the generated code is clean and adheres to clean code principles. </span><span class="koboSpan" id="kobo.672.2">Automation should not result in messy or cryptic code. </span><span class="koboSpan" id="kobo.672.3">In this sense, using well-known and well-tested frameworks with a solid community </span><a id="_idIndexMarker549"/><span class="koboSpan" id="kobo.673.1">and a lot of documentation is probably the way to go. </span><span class="koboSpan" id="kobo.673.2">We don’t endorse reinventing the wheel, never; it’s very unlikely that you will find yourself in a situation where metaprogramming from scratch is what you need unless it’s for very small and limited </span><span class="No-Break"><span class="koboSpan" id="kobo.674.1">use cases.</span></span></p>
<p><span class="koboSpan" id="kobo.675.1">You also have to balance the advantages of automation with code readability and understandability since metaprogramming can introduce complexity. </span><span class="koboSpan" id="kobo.675.2">I once found myself in front of a Java method that returned a string containing an HTML web page! </span><span class="koboSpan" id="kobo.675.3">Without getting to sadness peaks like that, be sure that your teammates (and don’t forget your future self) can expand or modify your software with only a reasonable amount of headaches. </span><span class="koboSpan" id="kobo.675.4">We invite you to discuss every metaprogramming choice with the team. </span><span class="koboSpan" id="kobo.675.5">Avoid excessive “magic” in your code as it can obscure the understanding of the underlying processes. </span><span class="koboSpan" id="kobo.675.6">This obscurity may result in the emergence of bugs or unpredictable </span><span class="No-Break"><span class="koboSpan" id="kobo.676.1">performance issues.</span></span></p>
<p><span class="koboSpan" id="kobo.677.1">If you just have to go for metaprogramming, document complex metaprogramming solutions thoroughly, providing clear explanations to assist future developers. </span><span class="koboSpan" id="kobo.677.2">Provide examples and write comments; in a single word, </span><span class="No-Break"><span class="koboSpan" id="kobo.678.1">be merciful.</span></span></p>
<p><span class="koboSpan" id="kobo.679.1">Having said that, we think that clean code’s advantages in terms of testing and debugging are notable, especially when dealing with compile-time metaprogramming tools such as Lombok and MapStruct. </span><span class="koboSpan" id="kobo.679.2">The essence of that advantage is that not only do you have cleaner code (because, for instance, the usage of Lombok facilitates object immutability) but you have less code. </span><span class="koboSpan" id="kobo.679.3">Having as little code as possible should be one of your </span><span class="No-Break"><span class="koboSpan" id="kobo.680.1">top priorities.</span></span></p>
<p><span class="koboSpan" id="kobo.681.1">Metaprogramming and clean code can coexist harmoniously. </span><span class="koboSpan" id="kobo.681.2">Combining the advantages of automation and flexibility with a commitment to writing clean and maintainable code ensures that software projects remain both efficient and sustainable in the </span><span class="No-Break"><span class="koboSpan" id="kobo.682.1">long run.</span></span></p>
<p><span class="koboSpan" id="kobo.683.1">While talking </span><a id="_idIndexMarker550"/><span class="koboSpan" id="kobo.684.1">about metaprogramming’s pros and cons, it is worth mentioning the so-called </span><strong class="bold"><span class="koboSpan" id="kobo.685.1">Not-Invented-Here</span></strong><span class="koboSpan" id="kobo.686.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.687.1">NIH</span></strong><span class="koboSpan" id="kobo.688.1">) syndrome. </span><span class="koboSpan" id="kobo.688.2">NIH syndrome refers to the tendency of some development teams or individuals to prefer creating their own solutions or tools rather than adopting existing, external solutions. </span><span class="koboSpan" id="kobo.688.3">This can happen even when existing solutions are well-established, proven, and </span><span class="No-Break"><span class="koboSpan" id="kobo.689.1">readily available.</span></span></p>
<p><span class="koboSpan" id="kobo.690.1">NIH syndrome </span><a id="_idIndexMarker551"/><span class="koboSpan" id="kobo.691.1">can lead to several issues, including increased development time, reinvention of the wheel, and missed opportunities to leverage the expertise and contributions of the broader development community. </span><span class="koboSpan" id="kobo.691.2">It’s often considered a counterproductive behavior, and many software development communities encourage a more open-minded approach to adopting existing solutions </span><span class="No-Break"><span class="koboSpan" id="kobo.692.1">when appropriate.</span></span></p>
<p><span class="koboSpan" id="kobo.693.1">Teams and developers are encouraged to weigh the pros and cons of building something in-house versus using external libraries or frameworks while considering factors such as time, expertise, maintenance, and the availability of well-established solutions in the open </span><span class="No-Break"><span class="koboSpan" id="kobo.694.1">source community.</span></span></p>
<h1 id="_idParaDest-154"><a id="_idTextAnchor159"/><span class="koboSpan" id="kobo.695.1">Summary</span></h1>
<p><span class="koboSpan" id="kobo.696.1">In this chapter, we talked about metaprogramming: what it is, how it works, and how it can or cannot be useful concerning clean code and refactoring. </span><span class="koboSpan" id="kobo.696.2">In particular, we looked at two very popular libraries that involve metaprogramming, especially code auto-generation: Lombok </span><span class="No-Break"><span class="koboSpan" id="kobo.697.1">and MapStruct.</span></span></p>
<p><span class="koboSpan" id="kobo.698.1">We also warned you about the potential risks of using reflection and, in general, spoke about the pros and cons of using </span><span class="No-Break"><span class="koboSpan" id="kobo.699.1">metaprogramming tools.</span></span></p>
<p><span class="koboSpan" id="kobo.700.1">In the next chapter, we will dive into static analysis, a method of code inspection that checks for issues without executing the code, and dynamic analysis, which involves evaluating code during its execution to </span><span class="No-Break"><span class="koboSpan" id="kobo.701.1">identify problems.</span></span></p>
<h1 id="_idParaDest-155"><a id="_idTextAnchor160"/><span class="koboSpan" id="kobo.702.1">Further reading</span></h1>
<ul>
<li><span class="koboSpan" id="kobo.703.1">Lombok’s official </span><span class="No-Break"><span class="koboSpan" id="kobo.704.1">documentation: </span></span><a href="https://projectlombok.org/features/"><span class="No-Break"><span class="koboSpan" id="kobo.705.1">https://projectlombok.org/features/</span></span></a></li>
<li><em class="italic"><span class="koboSpan" id="kobo.706.1">Lombok: The Good, The Bad, and The Controversial</span></em><span class="koboSpan" id="kobo.707.1">, by Felix </span><span class="No-Break"><span class="koboSpan" id="kobo.708.1">Coutinho </span></span><a href="https://www.linkedin.com/pulse/lombok-good-bad-controversial-felix-coutinho/"><span class="No-Break"><span class="koboSpan" id="kobo.709.1">https://www.linkedin.com/pulse/lombok-good-bad-controversial-felix-coutinho/</span></span></a></li>
<li><span class="koboSpan" id="kobo.710.1">MapStruct’s official </span><span class="No-Break"><span class="koboSpan" id="kobo.711.1">website: </span></span><a href="https://mapstruct.org/"><span class="No-Break"><span class="koboSpan" id="kobo.712.1">https://mapstruct.org/</span></span></a></li>
</ul>
</div>
</body></html>