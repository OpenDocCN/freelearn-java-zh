<html><head></head><body><div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Using Multithreading on Enterprise Context</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root"><span class="calibre8">This chapter covers the following recipes:</span><br class="calibre9"/></p>
<ul class="calibre13">
<li class="calibre14">Building asynchronous tasks with returning results</li>
<li class="calibre14">Using transactions with asynchronous tasks</li>
<li class="calibre14">Checking the status of a<span class="calibre5">synchronous</span> tasks</li>
<li class="calibre14">Building managed threads<span class="calibre5"> with returning results</span></li>
<li class="calibre14">Scheduling a<span class="calibre5">synchronous</span> tasks<span class="calibre5"> with returning results</span></li>
<li class="calibre14">Using injected proxies for asynchronous tasks</li>
</ul>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Introduction</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root"><strong class="calibre7">Threading</strong> is a common issue in most software projects, no matter which language or other technology is involved. When talking about enterprise applications, things become even more important, and sometimes harder.</p>
<p class="mce-root">A single mistake in some thread can affect the whole system, or even the whole infrastructure. Think about some resources that are never released, memory consumption that never stops increasing, and so on.</p>
<p class="mce-root">The Java EE environment has some great features for dealing with these and plenty of other challenges, and this chapter will show you some of them.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Building asynchronous tasks with returning results</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">One of the first challenges you will face if you have never worked with asynchronous tasks is: how on Earth do you return results from an asynchronous task if you don't know when<span class="calibre8"> </span><span class="calibre8">the execution</span><span class="calibre8"> will end?</span></p>
<p class="mce-root">Well, this recipe show you how. <kbd class="calibre16">AsyncResponse</kbd> for the win!</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">Let's first add our Java EE 8 dependency:</p>
<pre class="calibre21">        &lt;dependency&gt;<br class="calibre2"/>            &lt;groupId&gt;javax&lt;/groupId&gt;<br class="calibre2"/>            &lt;artifactId&gt;javaee-api&lt;/artifactId&gt;<br class="calibre2"/>            &lt;version&gt;8.0&lt;/version&gt;<br class="calibre2"/>            &lt;scope&gt;provided&lt;/scope&gt;<br class="calibre2"/>        &lt;/dependency&gt;</pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article class="calibre2">
                
<ol class="calibre19">
<li class="chapter">First, we create a <kbd class="calibre16">User</kbd> POJO:</li>
</ol>
<pre class="mce-root2">package com.eldermoraes.ch09.async.result;<br class="calibre2"/><br class="calibre2"/>/**<br class="calibre2"/> *<br class="calibre2"/> * @author eldermoraes<br class="calibre2"/> */<br class="calibre2"/>public class User {<br class="calibre2"/><br class="calibre2"/>    private Long id;<br class="calibre2"/>    private String name;<br class="calibre2"/><br class="calibre2"/>    public Long getId() {<br class="calibre2"/>        return id;<br class="calibre2"/>    }<br class="calibre2"/><br class="calibre2"/>    public void setId(Long id) {<br class="calibre2"/>        this.id = id;<br class="calibre2"/>    }<br class="calibre2"/><br class="calibre2"/>    public String getName() {<br class="calibre2"/>        return name;<br class="calibre2"/>    }<br class="calibre2"/><br class="calibre2"/>    public void setName(String name) {<br class="calibre2"/>        this.name = name;<br class="calibre2"/>    }<br class="calibre2"/>    <br class="calibre2"/>    public User(Long id, String name) {<br class="calibre2"/>        this.id = id;<br class="calibre2"/>        this.name = name;<br class="calibre2"/>    }<br class="calibre2"/>    <br class="calibre2"/>    @Override<br class="calibre2"/>    public String toString() {<br class="calibre2"/>        return "User{" + "id=" + id + ", name="<br class="calibre2"/>                     + name + '}';<br class="calibre2"/>    }<br class="calibre2"/>}</pre>
<ol start="2" class="calibre19">
<li class="chapter">Then we create <kbd class="calibre16">UserService</kbd> to emulate a <em class="calibre28">remote</em> slow endpoint:</li>
</ol>
<pre class="mce-root2">@Stateless<br class="calibre2"/>@Path("userService")<br class="calibre2"/>public class UserService {<br class="calibre2"/>    <br class="calibre2"/>    @GET<br class="calibre2"/>    public Response userService(){<br class="calibre2"/>        try {<br class="calibre2"/>            TimeUnit.SECONDS.sleep(5);<br class="calibre2"/>            long id = new Date().getTime();<br class="calibre2"/>            return Response.ok(new User(id, "User " + id)).build();<br class="calibre2"/>        } catch (InterruptedException ex) {<br class="calibre2"/>            return <br class="calibre2"/>            Response.status(Response.Status.INTERNAL_SERVER_ERROR)<br class="calibre2"/>            .entity(ex).build();<br class="calibre2"/>        }<br class="calibre2"/>    }<br class="calibre2"/>}</pre>
<ol start="3" class="calibre19">
<li class="chapter">Now we create an asynchronous client that will reach that endpoint and get the result:</li>
</ol>
<pre class="mce-root2">@Stateless<br class="calibre2"/>public class AsyncResultClient {<br class="calibre2"/><br class="calibre2"/>    private Client client;<br class="calibre2"/>    private WebTarget target;<br class="calibre2"/><br class="calibre2"/>    @PostConstruct<br class="calibre2"/>    public void init() {<br class="calibre2"/>        client = ClientBuilder.newBuilder()<br class="calibre2"/>                .readTimeout(10, TimeUnit.SECONDS)<br class="calibre2"/>                .connectTimeout(10, TimeUnit.SECONDS)<br class="calibre2"/>                .build();<br class="calibre2"/>        target = client.target("http://localhost:8080/<br class="calibre2"/>                 ch09-async-result/userService");<br class="calibre2"/>    }<br class="calibre2"/><br class="calibre2"/>    @PreDestroy<br class="calibre2"/>    public void destroy(){<br class="calibre2"/>        client.close();<br class="calibre2"/>    }<br class="calibre2"/>    <br class="calibre2"/>    public CompletionStage&lt;Response&gt; getResult(){<br class="calibre2"/>        return <br class="calibre2"/>        target.request(MediaType.APPLICATION_JSON).rx().get();<br class="calibre2"/>    }<br class="calibre2"/>    <br class="calibre2"/>}</pre>
<ol start="4" class="calibre19">
<li class="chapter">And finally, we create a service (endpoint) that will use the client to write the result in the response:</li>
</ol>
<pre class="mce-root2">@Stateless<br class="calibre2"/>@Path("asyncService")<br class="calibre2"/>public class AsyncService {<br class="calibre2"/><br class="calibre2"/>    @Inject<br class="calibre2"/>    private AsyncResultClient client;<br class="calibre2"/><br class="calibre2"/>    @GET<br class="calibre2"/>    public void asyncService(@Suspended AsyncResponse response)<br class="calibre2"/>    {<br class="calibre2"/>        try{<br class="calibre2"/>            client.getResult().thenApply(this::readResponse)<br class="calibre2"/>            .thenAccept(response::resume);<br class="calibre2"/>        } catch(Exception e){<br class="calibre2"/>            response.resume(Response.status(Response.Status.<br class="calibre2"/>            INTERNAL_SERVER_ERROR).entity(e).build());<br class="calibre2"/>        }<br class="calibre2"/>    }<br class="calibre2"/><br class="calibre2"/>    private String readResponse(Response response) {<br class="calibre2"/>        return response.readEntity(String.class);<br class="calibre2"/>    }<br class="calibre2"/>}</pre>
<p class="mce-root">To run this example, just deploy it in GlassFish 5 and open this URL in your browser:</p>
<p class="mce-root"><kbd class="calibre16">http://localhost:8080/ch09-async-result/asyncService</kbd></p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">First, our remote endpoint is creating <kbd class="calibre16">User</kbd> and converting it to a response entity:</p>
<pre class="calibre21">return Response.ok(new User(id, "User " + id)).build();</pre>
<p class="mce-root">So, with no effort at all, your <kbd class="calibre16">User</kbd> is now a JSON object.</p>
<p class="mce-root">Now let's take a look at the key method in <kbd class="calibre16">AsyncResultClient</kbd>:</p>
<pre class="calibre21">    public CompletionStage&lt;Response&gt; getResult(){<br class="calibre2"/>        return target.request(MediaType.APPLICATION_JSON).rx().get();<br class="calibre2"/>    }</pre>
<p class="mce-root">The <kbd class="calibre16">rx()</kbd> method is a part of the Reactive Client API introduced in Java EE 8. We'll discuss reactive in more detail in the next chapter. It basically returns <kbd class="calibre16">CompletionStageInvoker</kbd>, which will allow you to get <kbd class="calibre16">CompletionStage&lt;Response&gt;</kbd> (the returning value for this method).</p>
<p class="mce-root">In other words, this is an asynchronous/non-blocking code that gets results from the remote endpoint.</p>
<p class="mce-root">Note that we use the <kbd class="calibre16">@Stateless</kbd> annotation with this client so that we can inject it into our main endpoint:</p>
<pre class="calibre21">    @Inject<br class="calibre2"/>    private AsyncResultClient client;</pre>
<p class="mce-root">Here's our asynchronous method for writing a response:</p>
<pre class="calibre21">    @GET<br class="calibre2"/>    public void asyncService(@Suspended AsyncResponse response) {<br class="calibre2"/>        client.getResult().thenApply(this::readResponse)<br class="calibre2"/>        .thenAccept(response::resume);<br class="calibre2"/>    }</pre>
<p class="mce-root">Note that it's a <kbd class="calibre16">void</kbd> method. It doesn't return anything because it will return the result to a callback.</p>
<p class="mce-root">The <kbd class="calibre16">@Suspended</kbd> annotation combined with <kbd class="calibre16">AsyncResponse</kbd> will make the response resume once the processing is done, and this happens because we are using the beautiful, one-line, Java 8-style code:</p>
<pre class="calibre21">client.getResult().thenApply(this::readResponse)<br class="calibre2"/>.thenAccept(response::resume);</pre>
<p class="mce-root">Before going into the details, let's just clarify our <span class="calibre8">local</span><span class="calibre8"> </span><kbd class="calibre16">readResponse</kbd><span class="calibre8"> method:</span></p>
<pre class="calibre21">    private String readResponse(Response response) {<br class="calibre2"/>        return response.readEntity(String.class);<br class="calibre2"/>    }</pre>
<p class="mce-root">It just reads the <kbd class="calibre16">User</kbd> entity embedded in <kbd class="calibre16">Response</kbd> and transforms it to a <kbd class="calibre16">String</kbd> object (a JSON string).</p>
<p class="mce-root">Another way that this one-line code could be written is like this:</p>
<pre class="calibre21">        client.getResult()<br class="calibre2"/>                .thenApply(r -&gt; readResponse(r))<br class="calibre2"/>                .thenAccept(s -&gt; response.resume(s));</pre>
<p class="mce-root">But the first way is more concise, less verbose, and more fun!</p>
<p class="mce-root">The key is the <kbd class="calibre16">resume</kbd> method from the <kbd class="calibre16">AsyncReponse</kbd> object. It will write the response to the callback and return it to whoever asked it.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">See also</h1>
                </header>
            
            <article class="calibre2">
                
<ul class="calibre13">
<li class="calibre14">The full source code of this recipe is at <a href="https://github.com/eldermoraes/javaee8-cookbook/tree/master/chapter09/ch09-async-result" target="_blank" class="pcalibre pcalibre3 pcalibre1 calibre12 pcalibre2">https://github.com/eldermoraes/javaee8-cookbook/tree/master/chapter09/ch09-async-result</a>.</li>
</ul>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Using transactions with asynchronous tasks</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">Using asynchronous tasks could be already a challenge: what if you need to add some spice and add a transaction to it?</p>
<p class="mce-root">Usually, a transaction means something like <em class="calibre17">code blocking</em>. Isn't it awkward to combine two opposing concepts? Well, it's not! They can work together nicely, as this recipe will show you.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">Let's first add our Java EE 8 dependency:</p>
<pre class="calibre21">        &lt;dependency&gt;<br class="calibre2"/>            &lt;groupId&gt;javax&lt;/groupId&gt;<br class="calibre2"/>            &lt;artifactId&gt;javaee-api&lt;/artifactId&gt;<br class="calibre2"/>            &lt;version&gt;8.0&lt;/version&gt;<br class="calibre2"/>            &lt;scope&gt;provided&lt;/scope&gt;<br class="calibre2"/>        &lt;/dependency&gt;</pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article class="calibre2">
                
<ol class="calibre19">
<li class="chapter">Let's first create a <kbd class="calibre16">User</kbd> POJO:</li>
</ol>
<pre class="mce-root2">public class User {<br class="calibre2"/><br class="calibre2"/>    private Long id;<br class="calibre2"/>    private String name;<br class="calibre2"/><br class="calibre2"/>    public Long getId() {<br class="calibre2"/>        return id;<br class="calibre2"/>    }<br class="calibre2"/><br class="calibre2"/>    public void setId(Long id) {<br class="calibre2"/>        this.id = id;<br class="calibre2"/>    }<br class="calibre2"/><br class="calibre2"/>    public String getName() {<br class="calibre2"/>        return name;<br class="calibre2"/>    }<br class="calibre2"/><br class="calibre2"/>    public void setName(String name) {<br class="calibre2"/>        this.name = name;<br class="calibre2"/>    }<br class="calibre2"/>    <br class="calibre2"/>    public User(Long id, String name) {<br class="calibre2"/>        this.id = id;<br class="calibre2"/>        this.name = name;<br class="calibre2"/>    }<br class="calibre2"/>    <br class="calibre2"/>    @Override<br class="calibre2"/>    public String toString() {<br class="calibre2"/>        return "User{" + "id=" + id + ",<br class="calibre2"/>                     name=" + name + '}';<br class="calibre2"/>    } <br class="calibre2"/>}</pre>
<ol start="2" class="calibre19">
<li class="chapter">And here is a slow bean that will return <kbd class="calibre16">User</kbd>:</li>
</ol>
<pre class="mce-root2">@Stateless<br class="calibre2"/>public class UserBean {<br class="calibre2"/>    <br class="calibre2"/>    public User getUser(){<br class="calibre2"/>        try {<br class="calibre2"/>            TimeUnit.SECONDS.sleep(5);<br class="calibre2"/>            long id = new Date().getTime();<br class="calibre2"/>            return new User(id, "User " + id);<br class="calibre2"/>        } catch (InterruptedException ex) {<br class="calibre2"/>            System.err.println(ex.getMessage());<br class="calibre2"/>            long id = new Date().getTime();<br class="calibre2"/>            return new User(id, "Error " + id);<br class="calibre2"/>        }<br class="calibre2"/>    }<br class="calibre2"/>}</pre>
<ol start="3" class="calibre19">
<li class="chapter">Now we create a task to be executed that will return <kbd class="calibre16">User</kbd> using some transaction stuff:</li>
</ol>
<pre class="mce-root2">public class AsyncTask implements Callable&lt;User&gt; {<br class="calibre2"/><br class="calibre2"/>    private UserTransaction userTransaction;<br class="calibre2"/>    private UserBean userBean;<br class="calibre2"/><br class="calibre2"/>    @Override<br class="calibre2"/>    public User call() throws Exception {<br class="calibre2"/>        performLookups();<br class="calibre2"/>        try {<br class="calibre2"/>            userTransaction.begin();<br class="calibre2"/>            User user = userBean.getUser();<br class="calibre2"/>            userTransaction.commit();<br class="calibre2"/>            return user;<br class="calibre2"/>        } catch (IllegalStateException | SecurityException | <br class="calibre2"/>          HeuristicMixedException | HeuristicRollbackException | <br class="calibre2"/>          NotSupportedException | RollbackException | <br class="calibre2"/>          SystemException e) {<br class="calibre2"/>            userTransaction.rollback();<br class="calibre2"/>            return null;<br class="calibre2"/>        }<br class="calibre2"/>    }<br class="calibre2"/><br class="calibre2"/>    private void performLookups() throws NamingException{<br class="calibre2"/>        userBean = CDI.current().select(UserBean.class).get();<br class="calibre2"/>        userTransaction = CDI.current()<br class="calibre2"/>        .select(UserTransaction.class).get();<br class="calibre2"/>    }    <br class="calibre2"/>}</pre>
<ol start="4" class="calibre19">
<li class="chapter">And finally, here is the service endpoint that will use the task to write the result to a response:</li>
</ol>
<pre class="mce-root2">@Path("asyncService")<br class="calibre2"/>@RequestScoped<br class="calibre2"/>public class AsyncService {<br class="calibre2"/>    <br class="calibre2"/>    private AsyncTask asyncTask;<br class="calibre2"/>    <br class="calibre2"/>    @Resource(name = "LocalManagedExecutorService")<br class="calibre2"/>    private ManagedExecutorService executor; <br class="calibre2"/>    <br class="calibre2"/>    @PostConstruct<br class="calibre2"/>    public void init(){<br class="calibre2"/>        asyncTask = new AsyncTask();<br class="calibre2"/>    }<br class="calibre2"/>    <br class="calibre2"/>    @GET<br class="calibre2"/>    public void asyncService(@Suspended AsyncResponse response){<br class="calibre2"/>        <br class="calibre2"/>        Future&lt;User&gt; result = executor.submit(asyncTask);<br class="calibre2"/>        <br class="calibre2"/>        while(!result.isDone()){<br class="calibre2"/>            try {<br class="calibre2"/>                TimeUnit.SECONDS.sleep(1);<br class="calibre2"/>            } catch (InterruptedException ex) {<br class="calibre2"/>                System.err.println(ex.getMessage());<br class="calibre2"/>            }<br class="calibre2"/>        }<br class="calibre2"/>        <br class="calibre2"/>        try {<br class="calibre2"/>            response.resume(Response.ok(result.get()).build());<br class="calibre2"/>        } catch (InterruptedException | ExecutionException ex) {<br class="calibre2"/>            System.err.println(ex.getMessage());<br class="calibre2"/>            response.resume(Response.status(Response<br class="calibre2"/>            .Status.INTERNAL_SERVER_ERROR)<br class="calibre2"/>            .entity(ex.getMessage()).build());<br class="calibre2"/>        }<br class="calibre2"/>        <br class="calibre2"/>    }<br class="calibre2"/>}</pre>
<p class="mce-root">To try this code, just deploy it to GlassFish 5 and open this URL:</p>
<p class="mce-root"><kbd class="calibre16">http://localhost:8080/ch09-async-transaction/asyncService</kbd></p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">The magic happens in the <kbd class="calibre16">AsyncTask</kbd> class, where we will first take a look at the <span class="calibre8"><kbd class="calibre16">performLookups</kbd> </span>method:</p>
<pre class="calibre21">    private void performLookups() throws NamingException{<br class="calibre2"/>        Context ctx = new InitialContext();<br class="calibre2"/>        userTransaction = (UserTransaction) <br class="calibre2"/>        ctx.lookup("java:comp/UserTransaction");<br class="calibre2"/>        userBean = (UserBean) ctx.lookup("java:global/<br class="calibre2"/>        ch09-async-transaction/UserBean");<br class="calibre2"/>    }</pre>
<p class="mce-root">It will give you the instances of both <kbd class="calibre16">UserTransaction</kbd> and <kbd class="calibre16">UserBean</kbd> from the application server. Then you can relax and rely on the things already instantiated for you.</p>
<p class="mce-root">As our task implements a <kbd class="calibre16">Callabe&lt;V&gt;</kbd> object that it needs to implement the <kbd class="calibre16">call()</kbd> method:</p>
<pre class="calibre21">    @Override<br class="calibre2"/>    public User call() throws Exception {<br class="calibre2"/>        performLookups();<br class="calibre2"/>        try {<br class="calibre2"/>            userTransaction.begin();<br class="calibre2"/>            User user = userBean.getUser();<br class="calibre2"/>            userTransaction.commit();<br class="calibre2"/>            return user;<br class="calibre2"/>        } catch (IllegalStateException | SecurityException | <br class="calibre2"/>                HeuristicMixedException | HeuristicRollbackException <br class="calibre2"/>                | NotSupportedException | RollbackException | <br class="calibre2"/>                SystemException e) {<br class="calibre2"/>            userTransaction.rollback();<br class="calibre2"/>            return null;<br class="calibre2"/>        }<br class="calibre2"/>    }</pre>
<p class="mce-root">You can see <kbd class="calibre16">Callable</kbd> as a <kbd class="calibre16">Runnable</kbd> interface that returns a result. </p>
<p class="mce-root">Our transaction code lives here:</p>
<pre class="calibre21">            userTransaction.begin();<br class="calibre2"/>            User user = userBean.getUser();<br class="calibre2"/>            userTransaction.commit();</pre>
<p class="mce-root">And if anything goes wrong, we have the following:</p>
<pre class="calibre21">        } catch (IllegalStateException | SecurityException | <br class="calibre2"/>           HeuristicMixedException | HeuristicRollbackException <br class="calibre2"/>           | NotSupportedException | RollbackException | <br class="calibre2"/>           SystemException e) {<br class="calibre2"/>            userTransaction.rollback();<br class="calibre2"/>            return null;<br class="calibre2"/>        }</pre>
<p class="mce-root">Now we will look at <kbd class="calibre16">AsyncService</kbd>. First, we have some declarations:</p>
<pre class="calibre21">    private AsyncTask asyncTask;<br class="calibre2"/>    <br class="calibre2"/>    @Resource(name = "LocalManagedExecutorService")<br class="calibre2"/>    private ManagedExecutorService executor; <br class="calibre2"/>    <br class="calibre2"/>    @PostConstruct<br class="calibre2"/>    public void init(){<br class="calibre2"/>        asyncTask = new AsyncTask();<br class="calibre2"/>    }</pre>
<div class="packt_infobox">We are asking the container to give us an instance from <kbd class="calibre25">ManagedExecutorService</kbd>, which It is responsible for executing the task in the enterprise context.</div>
<p class="mce-root">Then we call an <kbd class="calibre16">init()</kbd> method, and the bean is constructed (<kbd class="calibre16">@PostConstruct</kbd>). This instantiates the task.</p>
<p class="mce-root">Now we have our task execution:</p>
<pre class="calibre21">    @GET<br class="calibre2"/>    public void asyncService(@Suspended AsyncResponse response){<br class="calibre2"/>        <br class="calibre2"/>        Future&lt;User&gt; result = executor.submit(asyncTask);<br class="calibre2"/>        <br class="calibre2"/>        while(!result.isDone()){<br class="calibre2"/>            try {<br class="calibre2"/>                TimeUnit.SECONDS.sleep(1);<br class="calibre2"/>            } catch (InterruptedException ex) {<br class="calibre2"/>                System.err.println(ex.getMessage());<br class="calibre2"/>            }<br class="calibre2"/>        }<br class="calibre2"/>        <br class="calibre2"/>        try {<br class="calibre2"/>            response.resume(Response.ok(result.get()).build());<br class="calibre2"/>        } catch (InterruptedException | ExecutionException ex) {<br class="calibre2"/>            System.err.println(ex.getMessage());<br class="calibre2"/>            response.resume(Response.status(Response.<br class="calibre2"/>            Status.INTERNAL_SERVER_ERROR)<br class="calibre2"/>            .entity(ex.getMessage()).build());<br class="calibre2"/>        }<br class="calibre2"/>        <br class="calibre2"/>    }</pre>
<p class="mce-root">Note that the executor returns <kbd class="calibre16">Future&lt;User&gt;</kbd>:</p>
<pre class="calibre21">Future&lt;User&gt; result = executor.submit(asyncTask);</pre>
<p class="mce-root">This means this task will be executed asynchronously. Then we check its execution status until it's done:</p>
<pre class="calibre21">        while(!result.isDone()){<br class="calibre2"/>            try {<br class="calibre2"/>                TimeUnit.SECONDS.sleep(1);<br class="calibre2"/>            } catch (InterruptedException ex) {<br class="calibre2"/>                System.err.println(ex.getMessage());<br class="calibre2"/>            }<br class="calibre2"/>        }</pre>
<p class="mce-root">And once it's done, we write it down to the asynchronous response:</p>
<pre class="calibre21">response.resume(Response.ok(result.get()).build());</pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">See also</h1>
                </header>
            
            <article class="calibre2">
                
<ul class="calibre13">
<li class="calibre14">The full source code of this recipe is at <a href="https://github.com/eldermoraes/javaee8-cookbook/tree/master/chapter09/ch09-async-transaction" target="_blank" class="pcalibre pcalibre3 pcalibre1 calibre12 pcalibre2">https://github.com/eldermoraes/javaee8-cookbook/tree/master/chapter09/ch09-async-transaction</a>.</li>
</ul>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Checking the status of asynchronous tasks</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">Beyond executing asynchronous tasks, which opens up a lot of possibilities, sometimes it is useful and necessary to get the status of those tasks.</p>
<p class="mce-root">For example, you could use it as a check the time elapsed on each task stage. You should also think about logging and monitoring.</p>
<p class="mce-root">This recipe will show you an easy way to do this.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">Let's first add our Java EE 8 dependency:</p>
<pre class="calibre21">        &lt;dependency&gt;<br class="calibre2"/>            &lt;groupId&gt;javax&lt;/groupId&gt;<br class="calibre2"/>            &lt;artifactId&gt;javaee-api&lt;/artifactId&gt;<br class="calibre2"/>            &lt;version&gt;8.0&lt;/version&gt;<br class="calibre2"/>            &lt;scope&gt;provided&lt;/scope&gt;<br class="calibre2"/>        &lt;/dependency&gt;</pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article class="calibre2">
                
<ol class="calibre19">
<li class="chapter">Let's first create a <kbd class="calibre16">User</kbd> POJO:</li>
</ol>
<pre class="mce-root2">public class User {<br class="calibre2"/><br class="calibre2"/>    private Long id;<br class="calibre2"/>    private String name;<br class="calibre2"/><br class="calibre2"/>    public Long getId() {<br class="calibre2"/>        return id;<br class="calibre2"/>    }<br class="calibre2"/><br class="calibre2"/>    public void setId(Long id) {<br class="calibre2"/>        this.id = id;<br class="calibre2"/>    }<br class="calibre2"/><br class="calibre2"/>    public String getName() {<br class="calibre2"/>        return name;<br class="calibre2"/>    }<br class="calibre2"/><br class="calibre2"/>    public void setName(String name) {<br class="calibre2"/>        this.name = name;<br class="calibre2"/>    }<br class="calibre2"/>    <br class="calibre2"/>    public User(Long id, String name) {<br class="calibre2"/>        this.id = id;<br class="calibre2"/>        this.name = name;<br class="calibre2"/>    }<br class="calibre2"/>    <br class="calibre2"/>    @Override<br class="calibre2"/>    public String toString() {<br class="calibre2"/>        return "User{" + "id=" + id + ", <br class="calibre2"/>        name=" + name + '}';<br class="calibre2"/>    }<br class="calibre2"/>}</pre>
<ol start="2" class="calibre19">
<li class="chapter">Then we create a slow bean for returning <kbd class="calibre16">User</kbd>:</li>
</ol>
<pre class="mce-root2">public class UserBean {<br class="calibre2"/>    <br class="calibre2"/>    public User getUser(){<br class="calibre2"/>        try {<br class="calibre2"/>            TimeUnit.SECONDS.sleep(5);<br class="calibre2"/>            long id = new Date().getTime();<br class="calibre2"/>            return new User(id, "User " + id);<br class="calibre2"/>        } catch (InterruptedException ex) {<br class="calibre2"/>            long id = new Date().getTime();<br class="calibre2"/>            return new User(id, "Error " + id);<br class="calibre2"/>        }<br class="calibre2"/>    }<br class="calibre2"/>}</pre>
<ol start="3" class="calibre19">
<li class="chapter">Now we create a managed task so we can monitor it:</li>
</ol>
<pre class="mce-root2">@Stateless<br class="calibre2"/>public class AsyncTask implements Callable&lt;User&gt;, ManagedTaskListener {<br class="calibre2"/><br class="calibre2"/>    private final long instantiationMili = new Date().getTime();<br class="calibre2"/>    <br class="calibre2"/>    private static final Logger LOG = Logger.getAnonymousLogger();<br class="calibre2"/>    <br class="calibre2"/>    @Override<br class="calibre2"/>    public User call() throws Exception {<br class="calibre2"/>        return new UserBean().getUser();<br class="calibre2"/>    }<br class="calibre2"/><br class="calibre2"/>    @Override<br class="calibre2"/>    public void taskSubmitted(Future&lt;?&gt; future, <br class="calibre2"/>    ManagedExecutorService mes, Object o) {<br class="calibre2"/>        long mili = new Date().getTime();<br class="calibre2"/>        LOG.log(Level.INFO, "taskSubmitted: {0} - <br class="calibre2"/>        Miliseconds since instantiation: {1}",<br class="calibre2"/>        new Object[]{future, mili - instantiationMili});<br class="calibre2"/>    }<br class="calibre2"/><br class="calibre2"/>    @Override<br class="calibre2"/>    public void taskAborted(Future&lt;?&gt; future, <br class="calibre2"/>    ManagedExecutorService mes, Object o, Throwable thrwbl) <br class="calibre2"/>    {<br class="calibre2"/>        long mili = new Date().getTime();<br class="calibre2"/>        LOG.log(Level.INFO, "taskAborted: {0} - <br class="calibre2"/>        Miliseconds since instantiation: {1}", <br class="calibre2"/>        new Object[]{future, mili - instantiationMili});<br class="calibre2"/>    }<br class="calibre2"/><br class="calibre2"/>    @Override<br class="calibre2"/>    public void taskDone(Future&lt;?&gt; future, <br class="calibre2"/>    ManagedExecutorService mes, Object o, <br class="calibre2"/>    Throwable thrwbl) {<br class="calibre2"/>        long mili = new Date().getTime();<br class="calibre2"/>        LOG.log(Level.INFO, "taskDone: {0} -<br class="calibre2"/>        Miliseconds since instantiation: {1}", <br class="calibre2"/>        new Object[]{future, mili - instantiationMili});<br class="calibre2"/>    }<br class="calibre2"/><br class="calibre2"/>    @Override<br class="calibre2"/>    public void taskStarting(Future&lt;?&gt; future, <br class="calibre2"/>    ManagedExecutorService mes, Object o) {<br class="calibre2"/>        long mili = new Date().getTime();<br class="calibre2"/>        LOG.log(Level.INFO, "taskStarting: {0} - <br class="calibre2"/>        Miliseconds since instantiation: {1}", <br class="calibre2"/>        new Object[]{future, mili - instantiationMili});<br class="calibre2"/>    }<br class="calibre2"/><br class="calibre2"/>}</pre>
<ol start="4" class="calibre19">
<li class="chapter">And finally, we create a service endpoint to execute our task and return its results:</li>
</ol>
<pre class="mce-root2">@Stateless<br class="calibre2"/>@Path("asyncService")<br class="calibre2"/>public class AsyncService {<br class="calibre2"/><br class="calibre2"/>    @Resource<br class="calibre2"/>    private ManagedExecutorService executor;<br class="calibre2"/><br class="calibre2"/>    @GET<br class="calibre2"/>    public void asyncService(@Suspended AsyncResponse response) {<br class="calibre2"/>        int i = 0;<br class="calibre2"/><br class="calibre2"/>        List&lt;User&gt; usersFound = new ArrayList&lt;&gt;();<br class="calibre2"/>        while (i &lt; 4) {<br class="calibre2"/>            Future&lt;User&gt; result = executor.submit(new AsyncTask());<br class="calibre2"/><br class="calibre2"/>            while (!result.isDone()) {<br class="calibre2"/>                try {<br class="calibre2"/>                    TimeUnit.SECONDS.sleep(1);<br class="calibre2"/>                } catch (InterruptedException ex) {<br class="calibre2"/>                    System.err.println(ex.getMessage());<br class="calibre2"/>                }<br class="calibre2"/>            }<br class="calibre2"/><br class="calibre2"/>            try {<br class="calibre2"/>                usersFound.add(result.get());<br class="calibre2"/>            } catch (InterruptedException | ExecutionException ex) {<br class="calibre2"/>                System.err.println(ex.getMessage());<br class="calibre2"/>            }<br class="calibre2"/><br class="calibre2"/>            i++;<br class="calibre2"/>        }<br class="calibre2"/><br class="calibre2"/>        response.resume(Response.ok(usersFound).build());<br class="calibre2"/>    }<br class="calibre2"/><br class="calibre2"/>}</pre>
<p class="mce-root">To try this code, just deploy it to GlassFish 5 and open this URL:</p>
<p class="mce-root"><kbd class="calibre16">http://localhost:8080/ch09-task-status/asyncService</kbd></p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">If you have been through the last recipe, you will already be familiar with the <kbd class="calibre16">Callable</kbd> task, so I won't give you more details about it here. But now, we are implementing our task using both the <kbd class="calibre16">Callable</kbd> and <kbd class="calibre16">ManagedTaskListener</kbd> interfaces. The second one gives us all the methods for checking the task's status:</p>
<pre class="calibre21">    @Override<br class="calibre2"/>    public void taskSubmitted(Future&lt;?&gt; future, <br class="calibre2"/>    ManagedExecutorService mes, Object o) {<br class="calibre2"/>        long mili = new Date().getTime();<br class="calibre2"/>        LOG.log(Level.INFO, "taskSubmitted: {0} - <br class="calibre2"/>        Miliseconds since instantiation: {1}", <br class="calibre2"/>        new Object[]{future, mili - instantiationMili});<br class="calibre2"/>    }<br class="calibre2"/><br class="calibre2"/>    @Override<br class="calibre2"/>    public void taskAborted(Future&lt;?&gt; future, <br class="calibre2"/>    ManagedExecutorService mes, Object o, Throwable thrwbl) {<br class="calibre2"/>        long mili = new Date().getTime();<br class="calibre2"/>        LOG.log(Level.INFO, "taskAborted: {0} - <br class="calibre2"/>        Miliseconds since instantiation: {1}", <br class="calibre2"/>        new Object[]{future, mili - instantiationMili});<br class="calibre2"/>    }<br class="calibre2"/><br class="calibre2"/>    @Override<br class="calibre2"/>    public void taskDone(Future&lt;?&gt; future, <br class="calibre2"/>    ManagedExecutorService mes, Object o, Throwable thrwbl) {<br class="calibre2"/>        long mili = new Date().getTime();<br class="calibre2"/>        LOG.log(Level.INFO, "taskDone: {0} - <br class="calibre2"/>        Miliseconds since instantiation: {1}", <br class="calibre2"/>        new Object[]{future, mili - instantiationMili});<br class="calibre2"/>    }<br class="calibre2"/><br class="calibre2"/>    @Override<br class="calibre2"/>    public void taskStarting(Future&lt;?&gt; future, <br class="calibre2"/>    ManagedExecutorService mes, Object o) {<br class="calibre2"/>        long mili = new Date().getTime();<br class="calibre2"/>        LOG.log(Level.INFO, "taskStarting: {0} - <br class="calibre2"/>        Miliseconds since instantiation: {1}", <br class="calibre2"/>        new Object[]{future, mili - instantiationMili});<br class="calibre2"/>    }</pre>
<p class="mce-root">The best part is that you don't need to call any of them—<kbd class="calibre16">ManagedExecutorService</kbd> (<span class="calibre8"><span class="calibre8">explained next</span></span>) will do it for you.</p>
<p class="mce-root">Finally, we have <kbd class="calibre16">AsyncService</kbd>. The first declaration is for our executor:</p>
<pre class="calibre21">    @Resource<br class="calibre2"/>    private ManagedExecutorService executor;</pre>
<p class="mce-root">In the service itself, we are getting four users from our asynchronous task:</p>
<pre class="calibre21">        List&lt;User&gt; usersFound = new ArrayList&lt;&gt;();<br class="calibre2"/>        while (i &lt; 4) {<br class="calibre2"/>            Future&lt;User&gt; result = executor.submit(new AsyncTask());<br class="calibre2"/><br class="calibre2"/>            while (!result.isDone()) {<br class="calibre2"/>                try {<br class="calibre2"/>                    TimeUnit.SECONDS.sleep(1);<br class="calibre2"/>                } catch (InterruptedException ex) {<br class="calibre2"/>                    System.err.println(ex.getMessage());<br class="calibre2"/>                }<br class="calibre2"/>            }<br class="calibre2"/><br class="calibre2"/>            try {<br class="calibre2"/>                usersFound.add(result.get());<br class="calibre2"/>            } catch (InterruptedException | ExecutionException ex) {<br class="calibre2"/>                System.err.println(ex.getMessage());<br class="calibre2"/>            }<br class="calibre2"/><br class="calibre2"/>            i++;<br class="calibre2"/>        }</pre>
<p class="mce-root">Once it's done, it's written to the asynchronous response:</p>
<pre class="calibre21">response.resume(Response.ok(usersFound).build());</pre>
<p class="mce-root">Now, if you look at your server log output, there are messages from the <kbd class="calibre16">ManagedTaskListener</kbd> interface. </p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">See also</h1>
                </header>
            
            <article class="calibre2">
                
<ul class="calibre13">
<li class="calibre14">See the full source code of this recipe at <a href="https://github.com/eldermoraes/javaee8-cookbook/tree/master/chapter09/ch09-task-status" target="_blank" class="pcalibre pcalibre3 pcalibre1 calibre12 pcalibre2">https://github.com/eldermoraes/javaee8-cookbook/tree/master/chapter09/ch09-task-status</a>.</li>
</ul>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Building managed threads with returning results</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">Sometimes you need to improve the way you look at the threads you are using; maybe to improve your logging features, maybe to manage their priorities. It would be nice if you could also get the results back from them. This recipe will show you how to do it.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">Let's first add our Java EE 8 dependency:</p>
<pre class="calibre21">        &lt;dependency&gt;<br class="calibre2"/>            &lt;groupId&gt;javax&lt;/groupId&gt;<br class="calibre2"/>            &lt;artifactId&gt;javaee-api&lt;/artifactId&gt;<br class="calibre2"/>            &lt;version&gt;8.0&lt;/version&gt;<br class="calibre2"/>            &lt;scope&gt;provided&lt;/scope&gt;<br class="calibre2"/>        &lt;/dependency&gt;</pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article class="calibre2">
                
<ol class="calibre19">
<li class="chapter">Let's first create a <kbd class="calibre16">User</kbd> POJO:</li>
</ol>
<pre class="mce-root2">public class User {<br class="calibre2"/><br class="calibre2"/>    private Long id;<br class="calibre2"/>    private String name;<br class="calibre2"/><br class="calibre2"/>    public Long getId() {<br class="calibre2"/>        return id;<br class="calibre2"/>    }<br class="calibre2"/><br class="calibre2"/>    public void setId(Long id) {<br class="calibre2"/>        this.id = id;<br class="calibre2"/>    }<br class="calibre2"/><br class="calibre2"/>    public String getName() {<br class="calibre2"/>        return name;<br class="calibre2"/>    }<br class="calibre2"/><br class="calibre2"/>    public void setName(String name) {<br class="calibre2"/>        this.name = name;<br class="calibre2"/>    }<br class="calibre2"/>    <br class="calibre2"/>    public User(Long id, String name) {<br class="calibre2"/>        this.id = id;<br class="calibre2"/>        this.name = name;<br class="calibre2"/>    }<br class="calibre2"/>    <br class="calibre2"/>    @Override<br class="calibre2"/>    public String toString() {<br class="calibre2"/>        return "User{" + "id=" + id + ",<br class="calibre2"/>        name=" + name + '}';<br class="calibre2"/>    } <br class="calibre2"/>}</pre>
<ol start="2" class="calibre19">
<li class="chapter">And then, we create a slow bean to return <kbd class="calibre16">User</kbd>:</li>
</ol>
<pre class="mce-root2">@Stateless<br class="calibre2"/>public class UserBean {<br class="calibre2"/>    <br class="calibre2"/>    @GET<br class="calibre2"/>    public User getUser(){<br class="calibre2"/>        try {<br class="calibre2"/>            TimeUnit.SECONDS.sleep(5);<br class="calibre2"/>            long id = new Date().getTime();<br class="calibre2"/>            return new User(id, "User " + id);<br class="calibre2"/>        } catch (InterruptedException ex) {<br class="calibre2"/>            long id = new Date().getTime();<br class="calibre2"/>            return new User(id, "Error " + id);<br class="calibre2"/>        }<br class="calibre2"/>    }<br class="calibre2"/>}</pre>
<ol start="3" class="calibre19">
<li class="chapter">And finally, we create an endpoint to get the result from the task:</li>
</ol>
<pre class="mce-root2">@Stateless<br class="calibre2"/>@Path("asyncService")<br class="calibre2"/>public class AsyncService {<br class="calibre2"/><br class="calibre2"/>    @Inject<br class="calibre2"/>    private UserBean userBean;<br class="calibre2"/><br class="calibre2"/>    @Resource(name = "LocalManagedThreadFactory")<br class="calibre2"/>    private ManagedThreadFactory factory;<br class="calibre2"/><br class="calibre2"/>    @GET<br class="calibre2"/>    public void asyncService(@Suspended AsyncResponse <br class="calibre2"/>    response) {<br class="calibre2"/>        Thread thread = factory.newThread(() -&gt; {<br class="calibre2"/>            response.resume(Response.ok(userBean<br class="calibre2"/>            .getUser()).build());<br class="calibre2"/>        });<br class="calibre2"/>        <br class="calibre2"/>        thread.setName("Managed Async Task");<br class="calibre2"/>        thread.setPriority(Thread.MIN_PRIORITY);<br class="calibre2"/>        thread.start();<br class="calibre2"/>    }<br class="calibre2"/><br class="calibre2"/>}</pre>
<p class="mce-root">To try this code, just deploy it to GlassFish 5 and open this URL:</p>
<p class="mce-root"><kbd class="calibre16">http://localhost:8080/ch09-managed-thread/asyncService</kbd></p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">The only way you should use threads in an enterprise context, and if you really want to use it, is when the application server creates the thread. So here, we are kindly asking the container to do it using <kbd class="calibre16">factory</kbd>:</p>
<pre class="calibre21">    @Resource(name = "LocalManagedThreadFactory")<br class="calibre2"/>    private ManagedThreadFactory factory;</pre>
<p class="mce-root">Using some functional-style code, we create our thread:</p>
<pre class="calibre21">        Thread thread = factory.newThread(() -&gt; {<br class="calibre2"/>            response.resume(Response.ok(userBean.getUser()).build());<br class="calibre2"/>        });</pre>
<p class="mce-root">Now, moving to the managed stuff, we can set the name and priority of the just-created thread:</p>
<pre class="calibre21">        thread.setName("Managed Async Task");<br class="calibre2"/>        thread.setPriority(Thread.MIN_PRIORITY);</pre>
<p class="mce-root">And don't forget to ask the container to start it:</p>
<pre class="calibre21">        thread.start();</pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">See also</h1>
                </header>
            
            <article class="calibre2">
                
<ul class="calibre13">
<li class="calibre14">See the full source code of this recipe at <a href="https://github.com/eldermoraes/javaee8-cookbook/tree/master/chapter09/ch09-managed-thread" target="_blank" class="pcalibre pcalibre3 pcalibre1 calibre12 pcalibre2">https://github.com/eldermoraes/javaee8-cookbook/tree/master/chapter09/ch09-managed-thread</a>.</li>
</ul>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Scheduling asynchronous tasks with returning results</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">Using tasks means also being able to define when they should be executed. This recipe is all about this topic, and also about getting the returning results whenever they return.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">Let's first add our Java EE 8 dependency:</p>
<pre class="calibre21">        &lt;dependency&gt;<br class="calibre2"/>            &lt;groupId&gt;javax&lt;/groupId&gt;<br class="calibre2"/>            &lt;artifactId&gt;javaee-api&lt;/artifactId&gt;<br class="calibre2"/>            &lt;version&gt;8.0&lt;/version&gt;<br class="calibre2"/>            &lt;scope&gt;provided&lt;/scope&gt;<br class="calibre2"/>        &lt;/dependency&gt;</pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article class="calibre2">
                
<ol class="calibre19">
<li class="chapter">Let's first create a <kbd class="calibre16">User</kbd> POJO:</li>
</ol>
<pre class="mce-root2">public class User {<br class="calibre2"/><br class="calibre2"/>    private Long id;<br class="calibre2"/>    private String name;<br class="calibre2"/><br class="calibre2"/>    public Long getId() {<br class="calibre2"/>        return id;<br class="calibre2"/>    }<br class="calibre2"/><br class="calibre2"/>    public void setId(Long id) {<br class="calibre2"/>        this.id = id;<br class="calibre2"/>    }<br class="calibre2"/><br class="calibre2"/>    public String getName() {<br class="calibre2"/>        return name;<br class="calibre2"/>    }<br class="calibre2"/><br class="calibre2"/>    public void setName(String name) {<br class="calibre2"/>        this.name = name;<br class="calibre2"/>    }<br class="calibre2"/>    <br class="calibre2"/>    public User(Long id, String name) {<br class="calibre2"/>        this.id = id;<br class="calibre2"/>        this.name = name;<br class="calibre2"/>    }<br class="calibre2"/>    <br class="calibre2"/>    @Override<br class="calibre2"/>    public String toString() {<br class="calibre2"/>        return "User{" + "id=" + id + ",<br class="calibre2"/>        name=" + name + '}';<br class="calibre2"/>    }<br class="calibre2"/>}</pre>
<ol start="2" class="calibre19">
<li class="chapter">And then, we create a slow bean to return <kbd class="calibre16">User</kbd>:</li>
</ol>
<pre class="mce-root2">public class UserBean {<br class="calibre2"/>    <br class="calibre2"/>    public User getUser(){<br class="calibre2"/>        try {<br class="calibre2"/>            TimeUnit.SECONDS.sleep(5);<br class="calibre2"/>            long id = new Date().getTime();<br class="calibre2"/>            return new User(id, "User " + id);<br class="calibre2"/>        } catch (InterruptedException ex) {<br class="calibre2"/>            long id = new Date().getTime();<br class="calibre2"/>            return new User(id, "Error " + id);<br class="calibre2"/>        }<br class="calibre2"/>    }<br class="calibre2"/>}</pre>
<ol start="3" class="calibre19">
<li class="chapter">Now we create a simple <kbd class="calibre16">Callable</kbd> task to communicate with the bean:</li>
</ol>
<pre class="mce-root2">public class AsyncTask implements Callable&lt;User&gt; {<br class="calibre2"/><br class="calibre2"/>    private final UserBean userBean = <br class="calibre2"/>    CDI.current().select(UserBean.class).get();<br class="calibre2"/><br class="calibre2"/>    @Override<br class="calibre2"/>    public User call() throws Exception {<br class="calibre2"/>        return userBean.getUser();<br class="calibre2"/>    }<br class="calibre2"/>}</pre>
<ol start="4" class="calibre19">
<li class="chapter">And finally, we create our service to schedule and write the task's result in the response:</li>
</ol>
<pre class="mce-root2">@Stateless<br class="calibre2"/>@Path("asyncService")<br class="calibre2"/>public class AsyncService {<br class="calibre2"/><br class="calibre2"/>    @Resource(name = "LocalManagedScheduledExecutorService")<br class="calibre2"/>    private ManagedScheduledExecutorService executor;<br class="calibre2"/><br class="calibre2"/>    @GET<br class="calibre2"/>    public void asyncService(@Suspended AsyncResponse response) {<br class="calibre2"/><br class="calibre2"/>        ScheduledFuture&lt;User&gt; result = executor.schedule<br class="calibre2"/>        (new AsyncTask(), 5, TimeUnit.SECONDS);<br class="calibre2"/><br class="calibre2"/>        while (!result.isDone()) {<br class="calibre2"/>            try {<br class="calibre2"/>                TimeUnit.SECONDS.sleep(1);<br class="calibre2"/>            } catch (InterruptedException ex) {<br class="calibre2"/>                System.err.println(ex.getMessage());<br class="calibre2"/>            }<br class="calibre2"/>        }<br class="calibre2"/><br class="calibre2"/>        try {<br class="calibre2"/>            response.resume(Response.ok(result.get()).build());<br class="calibre2"/>        } catch (InterruptedException | ExecutionException ex) {<br class="calibre2"/>            System.err.println(ex.getMessage());<br class="calibre2"/>            response.resume(Response.status(Response.Status<br class="calibre2"/>           .INTERNAL_SERVER_ERROR).entity(ex.getMessage())<br class="calibre2"/>           .build());<br class="calibre2"/>        }<br class="calibre2"/>        <br class="calibre2"/>    }<br class="calibre2"/><br class="calibre2"/>}</pre>
<p class="mce-root">To try this code, just deploy it to GlassFish 5 and open this URL:</p>
<p class="mce-root"><kbd class="calibre16">http://localhost:8080/ch09-scheduled-task/asyncService</kbd></p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">All the magic relies on the <kbd class="calibre16">AsyncService</kbd> class, so we will focus on that.</p>
<p class="mce-root">First, we ask the server an instance of an executor:</p>
<pre class="calibre21">    @Resource(name = "LocalManagedScheduledExecutorService")<br class="calibre2"/>    private ManagedScheduledExecutorService executor;</pre>
<p class="mce-root">But it is not just any executor—it's an executor that's specific to scheduling:</p>
<pre class="calibre21">ScheduledFuture&lt;User&gt; result = executor.schedule(new AsyncTask(), <br class="calibre2"/>5, TimeUnit.SECONDS);</pre>
<p class="mce-root">So, we are scheduling our task to be executed in five seconds. Note that we are also not using a regular <kbd class="calibre16">Future</kbd>, but <kbd class="calibre16">ScheduledFuture</kbd>.</p>
<p class="mce-root">The rest is a usual task execution:</p>
<pre class="calibre21">        while (!result.isDone()) {<br class="calibre2"/>            try {<br class="calibre2"/>                TimeUnit.SECONDS.sleep(1);<br class="calibre2"/>            } catch (InterruptedException ex) {<br class="calibre2"/>                System.err.println(ex.getMessage());<br class="calibre2"/>            }<br class="calibre2"/>        }</pre>
<p class="mce-root">And this is how we write the results to the response:</p>
<pre class="calibre21">response.resume(Response.ok(result.get()).build());</pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">See also</h1>
                </header>
            
            <article class="calibre2">
                
<ul class="calibre13">
<li class="calibre14">See the full source code of this recipe at <a href="https://github.com/eldermoraes/javaee8-cookbook/tree/master/chapter09/ch09-scheduled-task" target="_blank" class="pcalibre pcalibre3 pcalibre1 calibre12 pcalibre2">https://github.com/eldermoraes/javaee8-cookbook/tree/master/chapter09/ch09-scheduled-task</a>.</li>
</ul>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Using injected proxies for asynchronous tasks</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">When using tasks, you could also create your own executor. If you have very specific needs, it could be really handy.</p>
<p class="mce-root">This recipe will show you how to create a proxy executor that can be injected and used in the whole context of your application.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">Let's first add our Java EE 8 dependency:</p>
<pre class="calibre21">        &lt;dependency&gt;<br class="calibre2"/>            &lt;groupId&gt;javax&lt;/groupId&gt;<br class="calibre2"/>            &lt;artifactId&gt;javaee-api&lt;/artifactId<span class="calibre5"><span class="calibre5">&gt;</span></span><br class="calibre2"/>            &lt;version&gt;8.0&lt;/version&gt;<br class="calibre2"/>            &lt;scope&gt;provided&lt;/scope&gt;<br class="calibre2"/>        &lt;/dependency&gt;</pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article class="calibre2">
                
<ol class="calibre19">
<li class="chapter">First, we create a <kbd class="calibre16">User</kbd> POJO:</li>
</ol>
<pre class="mce-root2">public class User implements Serializable{<br class="calibre2"/><br class="calibre2"/>    private Long id;<br class="calibre2"/>    private String name;<br class="calibre2"/><br class="calibre2"/>    public Long getId() {<br class="calibre2"/>        return id;<br class="calibre2"/>    }<br class="calibre2"/><br class="calibre2"/>    public void setId(Long id) {<br class="calibre2"/>        this.id = id;<br class="calibre2"/>    }<br class="calibre2"/><br class="calibre2"/>    public String getName() {<br class="calibre2"/>        return name;<br class="calibre2"/>    }<br class="calibre2"/><br class="calibre2"/>    public void setName(String name) {<br class="calibre2"/>        this.name = name;<br class="calibre2"/>    }<br class="calibre2"/>    <br class="calibre2"/>    public User(Long id, String name) {<br class="calibre2"/>        this.id = id;<br class="calibre2"/>        this.name = name;<br class="calibre2"/>    }<br class="calibre2"/>    <br class="calibre2"/>    @Override<br class="calibre2"/>    public String toString() {<br class="calibre2"/>        return "User{" + "id=" + id + ", <br class="calibre2"/>        name=" + name + '}';<br class="calibre2"/>    }<br class="calibre2"/>}</pre>
<ol start="2" class="calibre19">
<li class="chapter">Then we create a slow bean to return <kbd class="calibre16">User</kbd>:</li>
</ol>
<pre class="mce-root2">public class UserBean {<br class="calibre2"/>    <br class="calibre2"/>    public User getUser(){<br class="calibre2"/>        try {<br class="calibre2"/>            TimeUnit.SECONDS.sleep(5);<br class="calibre2"/>            long id = new Date().getTime();<br class="calibre2"/>            return new User(id, "User " + id);<br class="calibre2"/>        } catch (InterruptedException ex) {<br class="calibre2"/>            long id = new Date().getTime();<br class="calibre2"/>            return new User(id, "Error " + id);<br class="calibre2"/>        }<br class="calibre2"/>    }<br class="calibre2"/>}</pre>
<ol start="3" class="calibre19">
<li class="chapter">Now we create a simple <kbd class="calibre16">Callable</kbd> task to communicate with the slow bean:</li>
</ol>
<pre class="mce-root2">@Stateless<br class="calibre2"/>public class AsyncTask implements Callable&lt;User&gt;{<br class="calibre2"/><br class="calibre2"/>    @Override<br class="calibre2"/>    public User call() throws Exception {<br class="calibre2"/>        return new UserBean().getUser();<br class="calibre2"/>    }<br class="calibre2"/><br class="calibre2"/>}</pre>
<ol start="4" class="calibre19">
<li class="chapter">Here, we call our proxy:</li>
</ol>
<pre class="mce-root2">@Singleton<br class="calibre2"/>public class ExecutorProxy {<br class="calibre2"/><br class="calibre2"/>    @Resource(name = "LocalManagedThreadFactory")<br class="calibre2"/>    private ManagedThreadFactory factory;<br class="calibre2"/><br class="calibre2"/>    @Resource(name = "LocalContextService")<br class="calibre2"/>    private ContextService context;<br class="calibre2"/><br class="calibre2"/>    private ExecutorService executor;<br class="calibre2"/><br class="calibre2"/>    @PostConstruct<br class="calibre2"/>    public void init(){<br class="calibre2"/>        executor = new ThreadPoolExecutor(1, 5, 10, <br class="calibre2"/>        TimeUnit.SECONDS, new ArrayBlockingQueue&lt;&gt;(5),<br class="calibre2"/>        factory);<br class="calibre2"/>    }<br class="calibre2"/>    <br class="calibre2"/>    public Future&lt;User&gt; submit(Callable&lt;User&gt; task){<br class="calibre2"/>        Callable&lt;User&gt; ctxProxy = <br class="calibre2"/>        context.createContextualProxy(task, Callable.class);<br class="calibre2"/>        return executor.submit(ctxProxy);<br class="calibre2"/>    }<br class="calibre2"/>}</pre>
<ol start="5" class="calibre19">
<li class="chapter">And finally, we create the endpoint that will use the proxy:</li>
</ol>
<pre class="mce-root2">@Stateless<br class="calibre2"/>@Path("asyncService")<br class="calibre2"/>public class AsyncService {<br class="calibre2"/><br class="calibre2"/>    @Inject<br class="calibre2"/>    private ExecutorProxy executor;<br class="calibre2"/><br class="calibre2"/>    @GET<br class="calibre2"/>    public void asyncService(@Suspended AsyncResponse response) <br class="calibre2"/>    {<br class="calibre2"/>        Future&lt;User&gt; result = executor.submit(new AsyncTask());<br class="calibre2"/>        response.resume(Response.ok(result).build());<br class="calibre2"/>    }<br class="calibre2"/><br class="calibre2"/>}</pre>
<p class="mce-root">To try this code, just deploy it to GlassFish 5 and open this URL:</p>
<p class="mce-root"><kbd class="calibre16">http://localhost:8080/ch09-proxy-task/asyncService</kbd></p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">The magic really happens here in the <kbd class="calibre16">ExecutorProxy</kbd> task. First note that we are defining it as follows:</p>
<pre class="calibre21">@Singleton</pre>
<p class="mce-root">We are making sure to have one and only one instance of it in the context.</p>
<p class="mce-root">Now note that even though we are creating our own executor, we are still relying on the application server context for it:</p>
<pre class="calibre21">    @Resource(name = "LocalManagedThreadFactory")<br class="calibre2"/>    private ManagedThreadFactory factory;<br class="calibre2"/><br class="calibre2"/>    @Resource(name = "LocalContextService")<br class="calibre2"/>    private ContextService context;</pre>
<p class="mce-root">This guarantees that you don't violate any context rules and ruin your application for good.</p>
<p class="mce-root">Then we create a pool for executing threads:</p>
<pre class="calibre21">    private ExecutorService executor;<br class="calibre2"/><br class="calibre2"/>    @PostConstruct<br class="calibre2"/>    public void init(){<br class="calibre2"/>        executor = new ThreadPoolExecutor(1, 5, 10,<br class="calibre2"/>        TimeUnit.SECONDS, new ArrayBlockingQueue&lt;&gt;(5), factory);<br class="calibre2"/>    }</pre>
<p class="mce-root">And finally, we create the method for sending tasks to the executing queue:</p>
<pre class="calibre21">    public Future&lt;User&gt; submit(Callable&lt;User&gt; task){<br class="calibre2"/>        Callable&lt;User&gt; ctxProxy = context.createContextualProxy(task, <br class="calibre2"/>        Callable.class);<br class="calibre2"/>        return executor.submit(ctxProxy);<br class="calibre2"/>    }</pre>
<p class="mce-root">Now our proxy is ready to be injected:</p>
<pre class="calibre21">    @Inject<br class="calibre2"/>    private ExecutorProxy executor;</pre>
<p class="mce-root">It is also ready to be called and to return results:</p>
<pre class="calibre21">    @GET<br class="calibre2"/>    public void asyncService(@Suspended AsyncResponse response) {<br class="calibre2"/>        Future&lt;User&gt; result = executor.submit(new AsyncTask());<br class="calibre2"/>        response.resume(Response.ok(result).build());<br class="calibre2"/>    }</pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">See also</h1>
                </header>
            
            <article class="calibre2">
                
<ul class="calibre13">
<li class="calibre14">See the full source code of this recipe at <a href="https://github.com/eldermoraes/javaee8-cookbook/tree/master/chapter09/ch09-proxy-task" target="_blank" class="pcalibre pcalibre3 pcalibre1 calibre12 pcalibre2">https://github.com/eldermoraes/javaee8-cookbook/tree/master/chapter09/ch09-proxy-task</a>.</li>
</ul>
<p class="mce-root"/>


            </article>

            
        </section>
    </div>



  </body></html>