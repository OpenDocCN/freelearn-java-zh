- en: Tweaking Message Delivery
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: 调整消息投递
- en: What happens to messages that end up stuck in queues? Do they just disappear?
    What is the best way to prevent messages from being dropped silently, without
    warning? In this chapter, we will answers these questions thoroughly, looking
    in detail at message **time to live** (**TTL**) and dead-letter exchanges and
    queues. This chapter will also cover how the broker should react if a message
    cannot be routed to a specific queue using a mandatory flag. Additionally, the
    chapter will explain policies and the default exchange.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 消息最终陷入队列中会发生什么？它们会消失吗？防止消息无声无息地被丢弃的最佳方法是什么？在本章中，我们将彻底回答这些问题，详细探讨消息**存活时间**（**TTL**）和死信交换机及队列。本章还将涵盖如果使用强制标志无法将消息路由到特定队列时，代理应该如何反应。此外，本章将解释策略和默认交换机。
- en: 'Expect to learn important information about the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 期待了解以下主题的重要信息：
- en: Handling dead letters
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理死信
- en: Making delivery mandatory
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 强制投递
- en: Technical requirements
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: The code files of this chapter can be found on GitHub at [https://github.com/PacktPublishing/RabbitMQ-Essentials-Second-Edition/tree/master/Chapter04](https://github.com/PacktPublishing/RabbitMQ-Essentials-Second-Edition/tree/master/Chapter04).
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码文件可以在GitHub上找到：[https://github.com/PacktPublishing/RabbitMQ-Essentials-Second-Edition/tree/master/Chapter04](https://github.com/PacktPublishing/RabbitMQ-Essentials-Second-Edition/tree/master/Chapter04)。
- en: Handling dead letters
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理死信
- en: 'Things are going very well at **Complete Car** (**CC**). The driver-information
    message feature is gaining traction as more and more drivers join the company.
    After a few months of activity, one thing becomes clear: not all taxi drivers
    log in to the application every day, which leads to messages piling up in taxi
    inbox queues.'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在**Complete Car**（**CC**）公司，一切进行得非常顺利。随着越来越多的司机加入公司，驾驶员信息消息功能越来越受欢迎。经过几个月的活动，一个事实变得明显：并非所有出租车司机每天都登录应用程序，这导致消息在出租车收件箱队列中堆积。
- en: Though the amount of data is not detrimental to the system, the idea of having
    messages lying around in queues, potentially forever, is not satisfactory. Imagine
    a taxi driver logging in after a couple of weeks of vacation and being flooded
    with obsolete messages—this is the negative type of user experience that CC is
    keen to avoid.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管数据量对系统没有害处，但消息在队列中滞留，可能永远无法处理的想法并不令人满意。想象一下，一名出租车司机在休假几周后登录，被大量过时的消息淹没——这是CC公司竭力避免的负面用户体验。
- en: 'CC decides to address this by specifying a new rule: after one week, any message
    that is not delivered will be dealt with in one of two ways:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: CC决定通过指定新规则来解决这个问题：一周后，任何未送达的消息将以以下两种方式之一进行处理：
- en: It will be emailed to the user if it's an important information message.
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果是重要信息消息，将会通过电子邮件发送给用户。
- en: 'It will be discarded if it''s an information message concerning the current
    traffic situation or other important information:'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果是关于当前交通状况或其他重要信息的消息，将会被丢弃：
- en: '![](img/2698fa62-27a5-4b24-a0f5-7091f839eff7.png)'
  id: totrans-13
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/2698fa62-27a5-4b24-a0f5-7091f839eff7.png)'
- en: Fig 4.1: Email important information messages, discard other messages
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.1：发送重要信息消息，丢弃其他消息
- en: 'The developers look at what is offered in terms of message expiration in RabbitMQ
    and list the following possible options that can be implemented:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 开发者查看RabbitMQ提供的消息过期选项，并列出以下可以实施的可能选项：
- en: Standard AMQP message expiration property for published messages
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标准AMQP消息过期属性，用于已发布消息
- en: Custom RabbitMQ extension that allows users to define a message TTL per queue
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 允许用户为每个队列定义消息TTL的定制RabbitMQ扩展
- en: Custom RabbitMQ extension that allows users to define a TTL for the queue itself
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 允许用户为队列本身定义TTL的定制RabbitMQ扩展
- en: The first option is interesting because it is a standard AMQP option; however,
    after reading more about how it is supported in RabbitMQ, it turns out that these
    messages are only discarded when the message reaches the head, or beginning, of
    a queue. Even if they have expired, the messages would still sit in the queue,
    which would defeat the purpose of what they're trying to achieve. CC rules out
    the last option as well, as they do not want the queue to be deleted. This leaves
    us with the second option of configuring each taxi inbox queue with a TTL that
    is enforced by RabbitMQ whether the queue is being consumed or not.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个选项很有趣，因为它是一个标准的 AMQP 选项；然而，在阅读更多关于它在 RabbitMQ 中如何支持的内容后，我们发现这些消息只有在达到队列头部或开始位置时才会被丢弃。即使它们已经过期，消息仍然会留在队列中，这会违背他们试图实现的目的。CC
    也排除了最后一个选项，因为他们不希望删除队列。这让我们只剩下了第二个选项，即为每个出租车收件箱队列配置一个由 RabbitMQ 强制执行的 TTL，无论队列是否正在被消费。
- en: This is all fine and dandy, but what actually happens to messages when they
    expire? CC wants to consume these important messages in order to email them. So
    how do we achieve this? This is where RabbitMQ's **dead letter exchange** (**DLX**)
    comes in handy.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 这一切看起来都很顺利，但消息过期后实际上会发生什么呢？CC 希望消费这些重要的消息以便通过电子邮件发送。那么我们如何实现这一点呢？这正是 RabbitMQ
    的**死信交换**（**DLX**）发挥作用的地方。
- en: A dead letter is a message that can't be delivered, either because the intended
    target cannot be accessed or because it has expired. In the case of CC, messages
    that reach their TTL will become dead letters.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 死信是指无法投递的消息，这可能是因为目标无法访问，或者因为消息已过期。在 CC 的情况下，达到其 TTL 的消息将变成死信。
- en: RabbitMQ offers the option to automatically route these dead letters to a specific
    exchange, a so-called DLX. Since CC wants to receive messages sent to this exchange,
    they must bind a queue to it, consume it, and take care of received messages.
    This queue acts as a **dead letter queue** (**DLQ**), the ultimate destination
    for dead messages.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: RabbitMQ 提供了自动将这些死信路由到特定交换机的选项，这被称为 DLX。由于 CC 希望接收发送到该交换机的消息，他们必须将其绑定到一个队列上，消费它，并处理接收到的消息。这个队列充当**死信队列**（**DLQ**），死信的最终目的地。
- en: 'The following diagram illustrates the overall DLX architecture that CC intends
    to roll out:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表说明了 CC 打算推出的整体 DLX 架构：
- en: '![](img/a7f8f9de-5464-4306-bd1d-b90418bd6ea9.png)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/a7f8f9de-5464-4306-bd1d-b90418bd6ea9.png)'
- en: 'Fig 4.2: Dead-letter-handling architecture'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.2：死信处理架构
- en: A message that reaches its TTL is rerouted via the dead letter exchange to the
    **taxi-****dlx** queue and finally handled by the consumer.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 达到其 TTL 的消息将通过死信交换机重路由到 **taxi-****dlx** 队列，并由消费者最终处理。
- en: Note that when messages expire, they are published to the DLX using the original
    routing key they had when they were delivered to their taxi inbox queue. This
    behavior can be modified as RabbitMQ allows the definition of a specific routing
    key to use when messages are published to the DLX. The default suits CC, as the
    original routing key is an interesting bit of information they will use to find
    out the ID of the taxi. Therefore, the DLX exchange is constructed as a fanout
    in order to have all messages routed in the DLQ, whatever their original routing
    key may have been.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，当消息过期时，它们会使用在它们被投递到出租车收件箱队列时的原始路由键发布到 DLX。此行为可以被修改，因为 RabbitMQ 允许定义在消息发布到
    DLX 时使用的特定路由键。默认设置对 CC 来说很合适，因为原始路由键是他们用来找出出租车 ID 的有趣信息。因此，DLX 交换机被构建为一个扇出，以便将所有消息路由到
    DLQ，无论它们的原始路由键可能是什么。
- en: The battle plan is ready. It's now time to roll it out!
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 战斗计划已经准备好了。现在是时候实施它了！
- en: Refactoring queues
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 重构队列
- en: The first step in rolling out this architecture consists of configuring the
    taxi queues with the desired TTL of one week and a dead letter exchange equal
    to `taxi-dlx`.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 实施此架构的第一步是配置出租车队列，使其具有一周的期望 TTL 和等于 `taxi-dlx` 的死信交换机。
- en: By using the RabbitMQ extensions to AMQP, this can be achieved by respectively
    defining the `'x-message-ttl'` and `"x-dead-letter-exchange"` arguments when declaring
    the queue. Messages published to a queue that expires after the TTL are rerouted
    to the exchange with the given `x-dead-letter-routing-key`.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用 RabbitMQ 扩展 AMQP，这可以通过在声明队列时分别定义 `'x-message-ttl'` 和 `"x-dead-letter-exchange"`
    参数来实现。在 TTL 过期后发布的消息将被重路由到具有给定 `x-dead-letter-routing-key` 的交换机。
- en: 'It’s tempting to jump right to the code editor and modify the Ruby code written
    in [Chapter 3](4e1d39f3-47d1-4423-916c-2c2c01c75887.xhtml), *Sending Messages
    to Multiple Taxi Drivers*, by using the following arguments:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 很有诱惑直接跳到代码编辑器，并通过以下参数修改[第3章](4e1d39f3-47d1-4423-916c-2c2c01c75887.xhtml)，*向多个出租车司机发送消息*中编写的Ruby代码：
- en: '[PRE0]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: However, this would be wrong on several levels. The main issue is that the declaration
    would be changing from a queue with no arguments to one with three arguments.
    Remember that in [Chapter 2](377ec533-342d-4a08-9011-7176de197886.xhtml), *Creating
    a Taxi Application*, queue (or exchange) declaration is idempotent only if all
    the parameters that are used are the same. Any discrepancy in the declaration
    yields an exception and will be punished with an immediate channel termination.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这在几个层面上都是错误的。主要问题是声明将从没有参数的队列更改为具有三个参数的队列。记住，在[第2章](377ec533-342d-4a08-9011-7176de197886.xhtml)，*创建出租车应用程序*中，队列（或交换）的声明只有在所有使用的参数都相同的情况下才是幂等的。声明中的任何差异都会产生异常，并将立即终止通道。
- en: Make it a habit to double-check that the same attributes/parameters are always
    used when declaring existing queues and exchanges. Any difference will cause errors
    and terminate channels.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 做一个习惯，确保在声明现有队列和交换时始终使用相同的属性/参数。任何差异都会导致错误并终止通道。
- en: The other problem is that this change will only apply when taxi drivers log
    in. This is when the taxi queue is declared; however, it would not fulfill the
    requirement to apply the expiration rule to all existing queues independent of
    user actions. Finally, another thing to consider is that if these properties were
    configured at the queue declaration level, any change to one of them would require
    us to delete and recreate all of the queues. Clearly, the TTL and DLX configurations
    are cross-cutting concerns and should be configured in a more global fashion.
    Is that even possible?
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个问题是在出租车司机登录时才会应用这个更改。这是出租车队列被声明的时候；然而，它不会满足将过期规则应用于所有现有队列，而不依赖于用户操作的要求。最后，还需要考虑的是，如果这些属性在队列声明级别进行配置，则对其中任何一个的任何更改都需要我们删除并重新创建所有队列。显然，TTL和DLX配置是跨切面关注点，应该以更全局的方式配置。这是否可能呢？
- en: The answer is yes! RabbitMQ has a simple and elegant solution to this problem
    in the concept of policies. RabbitMQ supports policies that define specific behaviors,
    and these policies can be applied to queues or exchanges. Policies are applied
    not only when a queue or exchange is declared, but also to an existing queue or
    exchange.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 答案是肯定的！RabbitMQ在策略的概念中提供了一个简单而优雅的解决方案来解决这个问题。RabbitMQ支持定义特定行为的策略，并且可以将这些策略应用于队列或交换。策略不仅在与队列或交换声明时应用，还可以应用于现有的队列或交换。
- en: Both the queue message TTL and dead letter exchange are configurable via policies,
    but only a single policy can apply to a queue or exchange. Therefore, CC will
    craft a policy that combines both the TTL and DLX settings and apply it to all
    taxi inbox queues. This cannot be achieved via the AMQP protocol or by using the
    RabbitMQ client. Instead, the powerful command-line tools provided by RabbitMQ
    are the best way to achieve the policies needed.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 队列消息的TTL和死信交换都可以通过策略进行配置，但只能有一个策略应用于一个队列或交换。因此，CC将创建一个结合了TTL和DLX设置的策略，并将其应用于所有出租车收件箱队列。这不能通过AMQP协议或使用RabbitMQ客户端来实现。相反，RabbitMQ提供的强大命令行工具是实现所需策略的最佳方式。
- en: 'This strategy to refactor the existing queues is achieved with the following
    single command-line operation:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 通过以下单个命令行操作实现了对现有队列的重构策略：
- en: '[PRE1]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Let''s take some time to dissect the preceding command:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们花点时间来分析前面的命令：
- en: '`sudo rabbitmqctl set_policy`: This part of the command uses the `set_policy`
    control command.'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sudo rabbitmqctl set_policy`: 命令的这一部分使用了`set_policy`控制命令。'
- en: '`-p cc-dev-vhost`: This part of the command applies the message to the development
    virtual host.'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-p cc-dev-vhost`: 命令的这一部分将消息应用于开发虚拟主机。'
- en: '`Q_TTL_DLX`: This part of the command names the policy to make it obvious that
    it pertains to queue TTL and dead letter exchange.'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Q_TTL_DLX`: 命令的这一部分命名了策略，使其明显与队列TTL和死信交换相关。'
- en: '`"taxi\.\d+"`: This part of the command uses some regex to apply the entire
    command to the taxi queues only by selecting them by name.'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`"taxi\.\d+"`: 命令的这一部分使用了一些正则表达式，通过选择名称来仅将整个命令应用于出租车队列。'
- en: '`''{"message-ttl":604800000, "dead-letter-exchange":"taxi-dlx"}''`: This part
    of the command uses a policy definition composed of a TTL of seven days in milliseconds
    and the name of the DLX.'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`''{"message-ttl":604800000, "dead-letter-exchange":"taxi-dlx"}''`：此命令部分使用了一个由七天毫秒TTL和DLX名称组成的策略定义。'
- en: '`--apply-to queues`: This part of the command ensures that this policy is only
    applied to queues, which is somewhat redundant with the regex, but acts as a safety
    net because it selects RabbitMQ entities by type instead of name.'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--apply-to queues`：此命令部分确保此策略仅应用于队列，这与正则表达式有些重复，但作为安全网的作用是通过对类型而不是名称选择RabbitMQ实体。'
- en: Ready to run this command? Not so fast—the `"taxi-dlx"` exchange must be created
    and bound to the `"taxi-dlq"` queue. Applying this policy right now means that
    there will be seven days available to roll out the missing exchange and queue.
    Sure, this is plenty of time, but smart developers don't like to work against
    the clock if they can avoid it.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 准备运行此命令？别急——必须创建`taxi-dlx`交换机并将其绑定到`taxi-dlq`队列。立即应用此策略意味着将有七天时间来部署缺失的交换机和队列。当然，这足够多了，但聪明的开发者不喜欢在无法避免的情况下与时间赛跑。
- en: Instead of running the command right now, take the time to create the infrastructure
    in charge of dealing with the dead letters and roll it out to the application
    before applying the `"Q_TTL_DLX"` policy.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 不要立即运行此命令，而是花时间创建处理死信的基础设施，并在应用`"Q_TTL_DLX"`策略之前将其部署到应用中。
- en: The policies are now set up, and it's time to add some code for the missing
    exchanges and queues.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 策略现在已经设置好了，现在是时候添加一些代码来创建缺失的交换机和队列。
- en: Undertaking messages
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 承担消息
- en: The necessary infrastructure must be created to deal with expired messages.
    The dead letter queue needs to be declared, as well as the new dead letter fanout
    exchange. These need to be bound to each other.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 必须创建必要的基础设施来处理过期消息。需要声明死信队列以及新的死信扇出交换机。这些需要相互绑定。
- en: 'The following needs to be done:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 需要执行以下操作：
- en: Declare the `taxi-dlq` queue.
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 声明`taxi-dlq`队列。
- en: Declare the `taxi-dlx` fanout exchange.
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 声明`taxi-dlx`扇出交换机。
- en: Bind the `taxi-dlq` to the `taxi-dlx` fanout.
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将`taxi-dlq`绑定到`taxi-dlx`扇出交换机。
- en: Create a subscriber of the `taxi-dlq` queue that consumes and emails the dead
    letters.
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个订阅`taxi-dlq`队列的订阅者，该订阅者消费并发送死信邮件。
- en: 'To implement this behavior, simply add the exchange and queue with the following
    code to create the exchange and bind the queue to it:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 要实现此行为，只需添加以下代码中的交换机和队列以创建交换机并将队列绑定到它：
- en: 'Start by declaring two queues with `x-message-ttl` set to `604800000`:'
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先声明两个队列，`x-message-ttl`设置为`604800000`：
- en: '[PRE2]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Declare a fanout exchange `taxi-fanout`:'
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明一个扇出交换机`taxi-fanout`：
- en: '[PRE3]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Bind both queues to the exchange:'
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将两个队列绑定到交换机：
- en: '[PRE4]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Declare a dead letter queue, `taxi-dlq`:'
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明一个死信队列，`taxi-dlq`：
- en: '[PRE5]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Declare a dead letter fanout exchange, `taxi-dlx`:'
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明一个死信扇出交换机，`taxi-dlx`：
- en: '[PRE6]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Now `taxi-dlx` needs to be bound to `taxi-dlq`:'
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在`taxi-dlx`需要绑定到`taxi-dlq`：
- en: '[PRE7]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Finally, publish a message:'
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，发布一条消息：
- en: '[PRE8]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: As you can see, this is just a standard fanout exchange declaration along with
    the related queue declaration and binding. The same logic was used when implementing
    the public address system in [Chapter 3](4e1d39f3-47d1-4423-916c-2c2c01c75887.xhtml),
    *Sending Messages to Multiple Drivers*.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，这只是一个标准的扇出交换机声明，以及相关的队列声明和绑定。在[第3章](4e1d39f3-47d1-4423-916c-2c2c01c75887.xhtml)实现公共地址系统时使用了相同的逻辑，*向多个司机发送消息*。
- en: To simplify things even more, make sure that you log enough contextual data
    when an exception occurs. Always consider what information will be needed to perform
    forensics for a particular exception, if necessary.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 为了进一步简化问题，确保在发生异常时记录足够的环境数据。始终考虑在必要时执行特定异常的取证分析所需的信息。
- en: 'After rolling out this code to the application servers, note that the dead
    letter exchange and queue have been correctly created. Now it is time to set the
    `"Q_TTL_DLX"` policy, as shown in the following code:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在将此代码部署到应用服务器后，请注意死信交换机和队列已正确创建。现在，是时候设置`"Q_TTL_DLX"`策略，如下代码所示：
- en: '[PRE9]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: After running this script, use the management console to see what's been changed
    on the user inbox queue definitions.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 运行此脚本后，使用管理控制台查看用户收件箱队列定义中发生了什么变化。
- en: 'The following screenshot shows a few of these queues:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了这些队列中的几个：
- en: '![](img/87912e1d-5b01-4c2b-9340-01304c9b04e1.png)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![](img/87912e1d-5b01-4c2b-9340-01304c9b04e1.png)'
- en: Fig 4.3: The Q_TTL_DLX policy is applied to all taxi queues
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.3：Q_TTL_DLX策略应用于所有出租车队列
- en: 'The following screenshot demonstrates that the Q_TTL_DLX policy has been applied
    to the taxi queue, while other queues, such as `taxi-dlq`, haven''t been affected:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 以下屏幕截图演示了Q_TTL_DLX策略已应用于出租车队列，而其他队列，如`taxi-dlq`，则未受到影响：
- en: '![](img/8a7d7c12-fa47-4b75-9de1-52ccf8b5f2fa.png)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8a7d7c12-fa47-4b75-9de1-52ccf8b5f2fa.png)'
- en: 'Fig 4.4: The Q_TTL_DLX policy is applied to the taxi-inbox.1 queue'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.4：Q_TTL_DLX策略应用于taxi-inbox.1队列
- en: 'In the management interface, click on the Admin tab and then the Policies tab
    (on the right). Note how the custom policy is visible in the following screenshot:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在管理界面中，点击“管理员”标签页，然后点击“策略”标签页（在右侧）。注意以下屏幕截图中的自定义策略：
- en: '![](img/3b96d66e-7c30-42ed-9a3f-a4b418353ddb.png)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3b96d66e-7c30-42ed-9a3f-a4b418353ddb.png)'
- en: 'Fig 4.5: The Q_TTL_DLX policy is in the admin view'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.5：Q_TTL_DLX策略在管理员视图中
- en: At this point, any message created that will stay for more than 7 days in a
    taxi queue will be unmercifully moved to the `taxi_dlq`, consumed, potentially
    emailed, and buried for real! But what should be done with the existing messages
    that were created before the policy was rolled out?
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个阶段，任何将在出租车队列中停留超过7天的消息都将被无情地移动到`taxi_dlq`，被消费，可能被发送电子邮件，并真正地被埋葬！但是，对于在政策实施之前创建的现有消息应该怎么办呢？
- en: There is, unfortunately, no out-of-the-box solution to this problem, so the
    somewhat drastic measure to purge all the queues that are not empty and have no
    active subscribers must be taken. This is rough, but it is the only way to get
    out of the current situation. Moreover, it's a solution that is easily implemented
    with a simple script.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 很遗憾，对于这个问题没有现成的解决方案，因此必须采取一种相对激进的措施，清除所有非空且没有活跃订阅者的队列。这很粗糙，但这是摆脱当前状况的唯一方法。此外，这是一个可以通过简单的脚本轻松实现的解决方案。
- en: Thus far, the `rabbitmqctl` script has been used to manage the RabbitMQ broker.
    The next steps require the installation of a new script that comes bundled with
    the management console installed in [Chapter 1](4f4722d3-131f-4c38-9ea0-4c03e8545175.xhtml),
    *A Rabbit Springs to Life*. This script, called `rabbitmqadmin`, can be downloaded
    by simply browsing to a particular URL in the management interface, namely `http://localhost:15672/cli/`.
    After following the displayed download instructions, install the script in a location
    that makes it available to all users (typically `/usr/local/bin` on a Linux machine).
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，`rabbitmqctl`脚本已被用于管理RabbitMQ代理。下一步需要安装一个新脚本，该脚本包含在[第1章](4f4722d3-131f-4c38-9ea0-4c03e8545175.xhtml)中安装的管理控制台，即“A
    Rabbit Springs to Life”。这个名为`rabbitmqadmin`的脚本可以通过简单地浏览管理界面中的特定URL来下载，即`http://localhost:15672/cli/`。在遵循显示的下载说明后，将脚本安装在一个对所有用户都可用的地方（在Linux机器上通常是`/usr/local/bin`）。
- en: More information on the `rabbitmqadmin` script can be found at [http://www.rabbitmq.com/management-cli.html](http://www.rabbitmq.com/management-cli.html).
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 关于`rabbitmqadmin`脚本的更多信息可以在[http://www.rabbitmq.com/management-cli.html](http://www.rabbitmq.com/management-cli.html)找到。
- en: 'The following code shows how to create a script that will drop all consumerless
    queues that are not empty:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码展示了如何创建一个脚本，该脚本将删除所有无消费者的非空队列：
- en: '[PRE10]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Note that both `rabbitmqctl` and `rabbitmqadmin` were used to achieve the goal,
    the former with the ability to list specific attributes of queues in a way that's
    easy to parse and the latter with the ability to purge queues. After executing
    this script as a superuser, the state of the RabbitMQ broker is fit for purpose
    and the TTL and DLX policies will keep it that way in the long run!
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`rabbitmqctl`和`rabbitmqadmin`都被用来达到目标，前者具有以易于解析的方式列出队列特定属性的能力，而后者具有清除队列的能力。在以超级用户身份执行此脚本后，RabbitMQ代理的状态适合使用，TTL和DLX策略将长期保持这种状态！
- en: CC now wants to send out a survey to all customers that have completed a ride
    with the taxi a few minutes after the completed ride. Let's see how it is possible
    to use dead letter exchanges and TTL to delay message delivery within RabbitMQ.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: CC现在希望在完成行程后的几分钟内向所有完成出租车行程的客户发送调查问卷。让我们看看如何使用死信交换和TTL在RabbitMQ中延迟消息投递。
- en: Delayed messages with RabbitMQ
  id: totrans-95
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用RabbitMQ的延迟消息
- en: While finishing off the work with this feature, the back office realizes that
    they can publish messages with a fixed delay so that consumers don’t see them
    immediately. This is a perfect feature for their survey, which should be sent
    out to customers 5 minutes after a finished ride. The AMQP protocol doesn't have
    a native delayed queue feature, but one can easily be emulated by combining the
    message TTL function and the dead-lettering function.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用此功能完成工作后，后台意识到他们可以发布具有固定延迟的消息，这样消费者就不会立即看到它们。这对于他们的调查来说是一个完美的功能，因为调查应该在行程完成后5分钟发送给客户。AMQP协议没有原生的延迟队列功能，但可以通过组合消息TTL功能和死信功能轻松模拟。
- en: The Delayed Message Plugin is available for RabbitMQ 3.5.3 and later versions
    of RabbitMQ. The Delayed Message Plugin adds a new exchange type to RabbitMQ.
    It is possible to delay messages routed via that exchange by adding a delay header
    to a message. You can read more about the plugin at [https://github.com/rabbitmq/rabbitmq-delayed-message-exchange](https://github.com/rabbitmq/rabbitmq-delayed-message-exchange).
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 延迟消息插件适用于RabbitMQ 3.5.3及更高版本的RabbitMQ。延迟消息插件为RabbitMQ添加了一个新的交换机类型。通过向消息添加延迟头，可以延迟通过该交换机路由的消息。您可以在[https://github.com/rabbitmq/rabbitmq-delayed-message-exchange](https://github.com/rabbitmq/rabbitmq-delayed-message-exchange)上了解更多关于插件的信息。
- en: CC decides to publish survey request messages to a delayed queue once the driver
    has marked a ride as completed. All survey request messages are set to expire
    after a TTL of 5 minutes. The routing key of the message is then changed to the
    same as the destination queue name. This means that the survey request message
    will end up in the queue from which the survey request should be sent.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 当司机标记行程已完成后，CC决定将调查请求消息发布到一个延迟队列。所有调查请求消息都被设置为在TTL（生存时间）为5分钟后过期。然后，消息的路由键被更改为与目标队列名称相同。这意味着调查请求消息将最终进入应该发送调查请求的队列。
- en: 'The following is an example of the code that CC would use. Messages are first
    delivered to the `DELAYED_QUEUE` called `work.later`. After 300,000 ms, messages
    are dead lettered and routed to the `DESTINATION_QUEUE` called `work.now`:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个CC会使用的代码示例。消息首先被发送到名为`work.later`的`DELAYED_QUEUE`。在300,000毫秒后，消息被标记为死信并路由到名为`work.now`的`DESTINATION_QUEUE`：
- en: 'We start by assigning the variables:'
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们首先分配变量：
- en: '[PRE11]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'After that, we define the publish method. There are a lot of things happening
    here:'
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 之后，我们定义发布方法。这里发生了很多事情：
- en: First, the delayed queue, `DELAYED_QUEUE`, is declared and `x-dead-letter-exchange` is
    set to the default queue.
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，声明延迟队列`DELAYED_QUEUE`，并将`x-dead-letter-exchange`设置为默认队列。
- en: A routing key for dead-lettering messages is set via the `x-dead-letter-routing-key`
    argument to `DESTINATION_QUEUE`.
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过`x-dead-letter-routing-key`参数设置为`DESTINATION_QUEUE`来设置用于死信消息的路由键。
- en: The number of milliseconds to delay a message is specified in the message TTL `x-message-ttl`
    argument.
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 消息延迟的毫秒数在消息TTL的`x-message-ttl`参数中指定。
- en: 'Finally, a message is published to the default exchange, where `DELAYED_QUEUE`
    is used as a routing key:'
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，将消息发布到默认交换机，其中`DELAYED_QUEUE`用作路由键：
- en: '[PRE12]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Then we define the subscribe method and handle the message:'
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们定义订阅方法并处理消息：
- en: '[PRE13]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Lastly, we call both methods:'
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们调用这两个方法：
- en: '[PRE14]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: That's it! The survey request feature is implemented. But, of course, a new
    feature is requested immediately. The back office wants to be able to send messages
    to single drivers and to also make sure that all drivers, even drivers without
    a RabbitMQ taxi inbox, receive the message. Let's look at the mandatory delivery
    of messages in RabbitMQ.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样！调查请求功能已实现。但，当然，立即提出了新的功能请求。后台希望能够向单个司机发送消息，并确保所有司机，包括没有RabbitMQ出租车收件箱的司机，都能收到消息。让我们看看RabbitMQ中的消息强制投递。
- en: Making delivery mandatory
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 强制投递
- en: So far, the back office team at CC has been relying only on emails to interact
    with *individual* drivers. CC recently added the RabbitMQ-powered system discussed
    in [Chapter 3](4e1d39f3-47d1-4423-916c-2c2c01c75887.xhtml), *Sending Messages
    to Multiple Taxi Drivers*, allowing the back office to send information messages
    to all drivers. They now want to explore the possibility of sending messages to
    individual drivers from the back office service. Furthermore, if possible, CC
    would like drivers who do not have an inbox queue set up on RabbitMQ to get the
    message emailed to them immediately.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，CC的后台团队一直只依赖电子邮件与*个人*司机互动。CC最近添加了[第3章](4e1d39f3-47d1-4423-916c-2c2c01c75887.xhtml)“向多个出租车司机发送消息”中讨论的由RabbitMQ驱动的系统，允许后台向所有司机发送信息消息。他们现在想探索从后台服务向个别司机发送消息的可能性。此外，如果可能的话，CC希望没有在RabbitMQ上设置收件箱队列的司机能够立即收到电子邮件消息。
- en: 'In terms of messaging architecture, this is a known territory—the exact same
    model was put in place in [Chapter 2](377ec533-342d-4a08-9011-7176de197886.xhtml),
    *Creating a Taxi Application*, for client-to-taxi messages, as illustrated in
    the following diagram:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在消息架构方面，这是一个已知领域——在[第2章](377ec533-342d-4a08-9011-7176de197886.xhtml)“创建出租车应用程序”中，为客户端到出租车消息实现了完全相同的模型，如下所示：
- en: '![](img/b7f2b129-f8ab-44ab-844b-a6cc54321137.png)'
  id: totrans-116
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/b7f2b129-f8ab-44ab-844b-a6cc54321137.png)'
- en: 'Fig 4.6: The back office team will use the taxi direct exchange for direct
    messages to drivers'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.6：后台团队将使用出租车直接交换来发送给司机的直接消息
- en: A direct exchange is used. The only difference is that, unlike the main application,
    the back office will not create and bind a taxi queue prior to sending a message.
    Instead, the back office will have to somehow detect that no such queue exists
    already and revert to email delivery for the message.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 使用了直接交换。唯一的不同之处在于，与主应用程序不同，后台在发送消息之前不会创建和绑定出租车队列。相反，后台必须以某种方式检测到不存在此类队列，并将消息的投递回退到电子邮件。
- en: 'What''s unclear is how to achieve the second part of these requirements: how
    can the back office check for the existence of a queue? The AMQP specification
    doesn''t specify a direct way to do this. The RabbitMQ management plugin exposes
    a REST API that could be used to check the existence of a queue, which is a tempting
    approach, but not what AMQP offers by default, which is preferred. Moreover, this
    could expose the process to a check-then-act type of race condition.'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 不清楚的是如何实现这些要求的第二部分：后台如何检查队列的存在？AMQP规范没有指定直接的方法来做这件事。RabbitMQ管理插件公开了一个REST API，可以用来检查队列的存在，这是一个诱人的方法，但不是AMQP默认提供的，这是首选的方法。此外，这可能会使过程暴露于检查-行动类型的竞争条件。
- en: Indeed, the queue could be created by another process after it is verified that
    it doesn't exist. Digging deep into the AMQP specification uncovers a feature
    that will handle this more elegantly, namely mandatory delivery. The `mandatory` field
    is part of the AMQP specification that tells RabbitMQ how to react if a message
    cannot be routed to a queue.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，队列可以在确认它不存在后由另一个进程创建。深入研究AMQP规范可以发现一个更优雅处理此问题的功能，即强制投递。`mandatory`字段是AMQP规范的一部分，它告诉RabbitMQ如果消息无法路由到队列时如何反应。
- en: Consider the management REST API of RabbitMQ for cases when the AMQP specification
    doesn't have any way to support the functionality required. You can access the
    REST API documentation on the RabbitMQ broker at `http://localhost:15672/api/`.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到当AMQP规范没有提供支持所需功能的方法时，可以使用RabbitMQ的管理REST API。您可以在RabbitMQ代理上访问REST API文档，网址为`http://localhost:15672/api/`。
- en: When a message is published on an exchange with the `mandatory` flag set to
    `true`, it will be returned by RabbitMQ if the message cannot be delivered to
    a queue. A message cannot be delivered to a queue either because no queue is bound
    to the exchange or because none of the bound queues have a routing key that would
    match the routing rules of the exchange. In the current case, this would mean
    that no taxi inbox queue is bound to a routing key that matches the taxi ID.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 当消息在一个设置了`mandatory`标志为`true`的交换上发布时，如果消息无法投递到队列，它将被RabbitMQ返回。消息无法投递到队列的原因可能是没有队列绑定到交换，或者没有绑定队列具有与交换的路由规则匹配的路由键。在当前情况下，这意味着没有出租车收件箱队列绑定到与出租车ID匹配的路由键。
- en: 'The trick with returned messages is that RabbitMQ doesn''t return them synchronously
    as a response to the publish operation: it returns them in an asynchronous fashion.
    This means that, for the developer, a specific message handler will have to be
    registered with RabbitMQ in order to receive the returned messages.'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 返回消息的技巧是RabbitMQ不会同步地将它们作为发布操作的响应返回：它是异步返回的。这意味着对于开发者来说，必须将特定的消息处理器注册到RabbitMQ，以便接收返回的消息。
- en: 'This leads to the overall architecture illustrated in the following diagram:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 这导致以下图中展示的整体架构：
- en: '![](img/93516428-6fa5-42a2-8683-183185be0952.png)'
  id: totrans-125
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/93516428-6fa5-42a2-8683-183185be0952.png)'
- en: 'Fig 4.7: A dedicated handler takes care of returned messages'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.7：一个专门的处理器负责处理返回的消息
- en: Messages published to a queue that does not exist are returned to the return
    handler. This handler is now in charge of making sure that the information message
    reaches the driver in some other way—for example, through email.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 发布到不存在队列的消息会被返回到返回处理器。现在，这个处理器负责确保信息消息以某种方式到达司机——例如，通过电子邮件。
- en: The default exchange type will be described before the new back office sender
    will be implemented.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在实现新的后台发送器之前，将先描述默认交换的类型。
- en: Default exchanges in RabbitMQ
  id: totrans-129
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: RabbitMQ的默认交换
- en: Each time a queue is created, it gets automatically bound to the default exchange
    with its queue name as the routing key. By publishing a message to the default
    exchange using the queue name as the routing key, the message will end up in the
    designated queue. This is also something that is going to be added into the following
    code example, in the *Implementing the back office sender *section.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 每次创建队列时，它都会自动绑定到默认交换，其队列名称作为路由键。通过使用队列名称作为路由键向默认交换发布消息，消息最终会到达指定的队列。这也是将在以下代码示例的“实现后台发送器”部分中添加的内容。
- en: What is this mysterious default exchange? It is a direct and durable exchange
    named `" "` (an empty string) that is automatically created by RabbitMQ for each
    virtual host.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 这神秘的默认交换是什么？它是一个名为`""`（一个空字符串）的直接且持久的交换，由RabbitMQ为每个虚拟主机自动创建。
- en: 'To make the default exchange visible in the management console, its empty string
    name is rendered as the AMQP default, as shown in the following screenshot:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在管理控制台中使默认交换可见，其空字符串名称被渲染为AMQP默认值，如下面的截图所示：
- en: '![](img/cf0f4854-9d45-48c6-9a46-83f359885da5.png)'
  id: totrans-133
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/cf0f4854-9d45-48c6-9a46-83f359885da5.png)'
- en: Fig 4.8: The default exchange is one among several built-in exchanges
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.8：默认交换是几个内置交换之一
- en: As you can see, there are a host of other predeclared exchanges that are automatically
    created for every virtual host. They are easy to spot because their names start
    with amq. These exchanges are meant for testing and prototyping purposes only,
    so there is no need to use them in production.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，对于每个虚拟主机，都会自动创建许多其他预定义的交换。它们很容易识别，因为它们的名称以amq开头。这些交换仅用于测试和原型设计目的，因此在生产环境中无需使用它们。
- en: Sending messages to the default exchange is a convenient way to reach a particular
    queue; however, do not overuse this pattern. It creates tight coupling between
    producers and consumers because the producer becomes aware of particular queue
    names.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 向默认交换发送消息是到达特定队列的便捷方式；然而，不要过度使用这种模式。因为它会在生产者和消费者之间创建紧密耦合，因为生产者会知道特定的队列名称。
- en: With this explained, it's now time to add the necessary code to build this feature
    that was requested by the back office, which is implemented if a driver doesn't
    have an existing inbox queue.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 解释到这里，现在是时候添加必要的代码来构建后台请求的这个功能了，该功能是在没有现有收件箱队列的驱动程序中实现的。
- en: Implementing the back office sender
  id: totrans-138
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现后台发送器
- en: CC's back office is now adding support for messages that were sent to drivers
    without a taxi inbox queue, messages that were returned. The Ruby client library,
    among other libraries, supports this feature very elegantly. The following is
    the required code to support the mandatory delivery of messages to taxi inboxes
    and to handle potentially returned messages.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: CC的后台现在正在添加对发送给没有出租车收件箱队列的司机的消息的支持，以及返回的消息。Ruby客户端库等库优雅地支持此功能。以下是需要支持强制将消息发送到出租车收件箱并处理可能返回的消息的代码。
- en: 'Start out by requiring the `bunny` client library and then set up a connection
    and a channel to RabbitMQ, as described in [Chapter 2](377ec533-342d-4a08-9011-7176de197886.xhtml),
    *Creating a Taxi Application*:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，需要 `bunny` 客户端库，然后设置一个连接和一个通道到 RabbitMQ，如 [第 2 章](377ec533-342d-4a08-9011-7176de197886.xhtml)
    所述，*创建出租车应用程序*：
- en: '[PRE15]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Then, declare a default exchange:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，声明一个默认交换：
- en: '[PRE16]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'A return handler is created, which handles the returned message:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 创建了一个返回处理程序，用于处理返回的消息：
- en: '[PRE17]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Next, declare a durable inbox queue—in this example, named `taxi-inbox.100`:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，声明一个持久的邮箱队列——在这个例子中，命名为 `taxi-inbox.100`：
- en: '[PRE18]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Subscribe to messages from RabbitMQ and give a simple notification to the developer.
    At this point, an email is sent, but please note that this example is kept short
    on purpose and doesn''t include the method for actually sending the email:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 订阅来自 RabbitMQ 的消息并向开发者发送简单通知。在此阶段，会发送一封电子邮件，但请注意，这个例子故意保持简短，不包括实际发送电子邮件的方法：
- en: '[PRE19]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Messages are published with `routing_key` to target a particular taxi with
    the `mandatory` flag set to `true`. Since this queue is created and exists, this
    message should not be returned:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 消息通过 `routing_key` 发布以针对具有 `mandatory` 标志设置为 `true` 的特定出租车。由于这个队列已被创建并存在，这条消息不应该被返回：
- en: '[PRE20]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Another mandatory message is published, but this time to a random queue. This
    message is going to be returned and handled by the return handler:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 另一条强制消息被发布，但这次是到一个随机队列。这条消息将被返回并由返回处理程序处理：
- en: '[PRE21]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Finally, close the connection:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，关闭连接：
- en: '[PRE22]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The preceding code example includes one message published to a queue that exists,
    while the other message is published to a queue with a random key name, a queue
    that does not exist. More code examples can be found at [http://rubybunny.info/articles/exchanges.html](http://rubybunny.info/articles/exchanges.html).
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码示例包括一条发布到已存在的队列的消息，而另一条消息是发布到一个具有随机键名的队列，一个不存在的队列。更多代码示例可以在 [http://rubybunny.info/articles/exchanges.html](http://rubybunny.info/articles/exchanges.html)
    找到。
- en: That is all! The feature is ready to go live. Messages are returned asynchronously
    and there is no need to handle them the right way.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 就这些！功能已准备好上线。消息异步返回，无需正确处理。
- en: Summary
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This chapter included information about message TTL and explored how to use
    message property name expiration values while looking at other important topics
    about tweaking message delivery. The information also described the use of dead-letter
    exchanges and queues. The chapter then took a look at how to use the default exchange
    and how to send mandatory messages.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 本章包含了有关消息 TTL 的信息，探讨了在查看其他关于调整消息投递的重要主题时如何使用消息属性名称过期值。信息还描述了使用死信交换和队列的使用。然后，本章探讨了如何使用默认交换以及如何发送强制消息。
- en: CC is growing into a proper company and its platform is keeping right up with
    new features to meet the demands of drivers, customers, and back-office staff.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: CC 正在成长为一个正规公司，其平台也在不断推出新功能以满足司机、客户和后台工作人员的需求。
- en: So far, only asynchronous interactions with RabbitMQ have been discussed, which
    makes sense because it's the core premise of messaging. That said, it's possible
    to perform synchronous operations too, as the next chapter demonstrates. The following
    chapter will include information on the direct interaction between the taxi and
    the client. What will the next feature rollout entail? The only way to find out
    is to keep reading!
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，只讨论了与 RabbitMQ 的异步交互，这是有意义的，因为它是消息传递的核心前提。话虽如此，也可以执行同步操作，下一章将演示这一点。下一章将包括有关出租车与客户之间直接交互的信息。下一个功能发布将包括哪些内容？唯一找到答案的方法是继续阅读！
