- en: Chapter 7. The UI as a Function
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far we have taken a journey through managing complexity by efficiently handling
    and modeling asynchronous workflows in terms of streams of data. In particular,
    [Chapter 4](part0033_split_000.html#page "Chapter 4. Introduction to core.async"),
    *Introduction to core.async* and [Chapter 5](part0040_split_000.html#page "Chapter 5. Creating
    Your Own CES Framework with core.async"), *Creating Your Own CES Framework with
    core.async* explored what's involved in libraries that provide primitives and
    combinators for **Compositional Event Systems**. We also built a simple ClojureScript
    application that made use of our framework.
  prefs: []
  type: TYPE_NORMAL
- en: One thing you might have noticed is that none of the examples so far have dealt
    with what happens to the data once we are ready to present it to our users. It's
    still an open question that we, as application developers, need to answer.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will look at one way to handle Reactive User Interfaces
    in web applications using React (see [http://facebook.github.io/react/](http://facebook.github.io/react/)),
    a modern JavaScript framework developed by Facebook, as well as:'
  prefs: []
  type: TYPE_NORMAL
- en: Learn how React renders user interfaces efficiently
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Be introduced to Om, a ClojureScript interface to React
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learn how Om leverages persistent data structures for performance
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Develop two fully working ClojureScript applications with Om, including the
    use of `core.async` for intercomponent communication
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The problem with complex web UIs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With the rise of single-page web applications, it became a must to be able to
    manage the growth and complexity of a JavaScript codebase. The same applies to
    ClojureScript.
  prefs: []
  type: TYPE_NORMAL
- en: In an effort to manage this complexity, a plethora of JavaScript MVC frameworks
    have emerged such as AngularJS, Backbone.js, Ember.js, and KnockoutJS to name
    a few.
  prefs: []
  type: TYPE_NORMAL
- en: 'They are very different, but share a few common features:'
  prefs: []
  type: TYPE_NORMAL
- en: Give single-page applications more structure by providing models, views, controllers,
    templates, and so on
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Provide client-side routing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Two-way data binding
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this chapter, we'll be focusing on the last goal.
  prefs: []
  type: TYPE_NORMAL
- en: Two-way data binding is absolutely crucial if we are to develop even a moderately
    complex single-page web application. Here's how it works.
  prefs: []
  type: TYPE_NORMAL
- en: Suppose we're developing a phone book application. More than likely, we will
    have a model—or entity, map, what have you—that represents a contact. The contact
    model might have attributes such as name, phone number, and e-mail address.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, this application would not be all that useful if users couldn't update
    contact information, so we will need a form which displays the current details
    for a contact and lets you update the contact's information.
  prefs: []
  type: TYPE_NORMAL
- en: 'The contact model might have been loaded via an AJAX request and then might
    have used explicit DOM manipulation code to display the form. This would look
    something like the following pseudo-code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'But what happens when the user updates someone''s information? We need to store
    it somehow. On clicking on save, a function such as the following would do the
    trick, assuming you''re using jQuery:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: This seemingly harmless code poses a big problem. The contact model for this
    particular person is now out of date. If we were still developing web applications
    the old way, where we reload the page at every update, this wouldn't be a problem.
    However, the whole point of single-page web applications is to be responsive,
    so it keeps a lot of state on the client, and it is important to keep our models
    synced with our views.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is where two-way data binding comes in. An example from AngularJS would
    look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Angular isn't the target of this chapter, so I won't dig into the details. All
    we need to know from this example is that `$scope` is how we tell Angular to make
    our contact model available to our views. In the view, the custom attribute `ng-model`
    tells Angular to look up that property in the scope. This establishes a two-way
    relationship in such a way that when your model data changes in the scope, Angular
    refreshes the UI. Similarly, if the user edits the form, Angular updates the model,
    keeping everything in sync.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are, however, two main problems with this approach:'
  prefs: []
  type: TYPE_NORMAL
- en: It can be slow. The way Angular and friends implement two-way data binding is,
    roughly speaking, by attaching event handlers and watchers to view both custom-
    attributes and model attributes. For complex enough user interfaces, you will
    start noticing that the UI becomes slower to render, diminishing the user experience.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It relies heavily on mutation. As functional programmers, we strive to limit
    side effects to a minimum.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The slowness that comes with this and similar approaches is two-fold: firstly,
    AngularJS and friends have to "watch" all properties of every model in the scope
    in order to track updates. Once the framework determines that data has changed
    in the model, it then looks up parts of the UI, which depend on that information—such
    as the fragments using `ng-model` above—and then it re-renders them.'
  prefs: []
  type: TYPE_NORMAL
- en: Secondly, the DOM is the slowest part of most single-page web applications.
    If we think about it for a moment, these frameworks are triggering dozens or perhaps
    hundreds of DOM event handlers in order to keep the data in sync, each of which
    ends up updating a node—or several—in the DOM.
  prefs: []
  type: TYPE_NORMAL
- en: 'Don''t take my word for it though. I ran a simple benchmark to compare a pure
    calculation versus locating a DOM element and updating its value to the result
    of the said calculation. Here are the results—I''ve used JSPerf to run the benchmark,
    and these results are for Chrome 37.0.2062.94 on Mac OS X Mavericks (see [http://jsperf.com/purefunctions-vs-dom](http://jsperf.com/purefunctions-vs-dom)):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Updating the DOM is orders of magnitude slower than performing a simple calculation.
    It seems logical that we would want to do this in the most efficient manner possible.
  prefs: []
  type: TYPE_NORMAL
- en: However, if we don't keep our data in sync, we're back at square one. There
    should be a way by which we can drastically reduce the amount of rendering being
    done, while retaining the convenience of two-way data binding. Can we have our
    cake and eat it too?
  prefs: []
  type: TYPE_NORMAL
- en: Enter React.js
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we'll see in this chapter, the answer to the question posed in the previous
    section is a resounding yes and, as you might have guessed, it involves React.js.
  prefs: []
  type: TYPE_NORMAL
- en: But what makes it special?
  prefs: []
  type: TYPE_NORMAL
- en: It's wise to start with what React is not. It is not an MVC framework and as
    such it is not a replacement for the likes of AngularJS, Backbone.js, and so on.
    React focuses solely on the V in MVC, and presents a refreshingly different way
    to think about user interfaces. We must take a slight detour in order to explore
    how it does that.
  prefs: []
  type: TYPE_NORMAL
- en: Lessons from functional programming
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As functional programmers, we don't need to be convinced of the benefits of
    immutability. We bought into the premise long ago. However, should we not be able
    to use immutability efficiently, it would not have become commonplace in functional
    programming languages.
  prefs: []
  type: TYPE_NORMAL
- en: We owe it to the huge amount of research that went into **Purely Functional
    Data Structures**—first by Okasaki in his book of the same title (see [http://www.amazon.com/Purely-Functional-Structures-Chris-Okasaki/dp/0521663504/ref=sr_1_1?ie=UTF8&qid=1409550695&sr=8-1&keywords=purely+functional+data+structures](http://www.amazon.com/Purely-Functional-Structures-Chris-Okasaki/dp/0521663504/ref=sr_1_1?ie=UTF8&qid=1409550695&sr=8-1&keywords=purely+functional+data+structures))
    and then improved by others.
  prefs: []
  type: TYPE_NORMAL
- en: Without it, our programs would be ballooning, both in space and runtime complexity.
  prefs: []
  type: TYPE_NORMAL
- en: 'The general idea is that given a data structure, the only way to update it
    is by creating a copy of it with the desired delta applied:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '![Lessons from functional programming](img/00022.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: In the preceding image, we have a simplistic view of how `conj` operates. On
    the left, you have the underlying data structure representing the vector we wish
    to update. On the right, we have the newly created vector, which, as we can see,
    shares some structure with the previous vector, as well as containing our new
    item.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In reality, the underlying data structure is a tree and the representation was
    simplified for the purposes of this book. I highly recommend referring to Okasaki's
    book should the reader want more details on how purely functional data structures
    work.
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, these functions are considered pure. That is, it relates every
    input to a single output and does nothing else. This is, in fact, remarkably similar
    to how React handles user interfaces.
  prefs: []
  type: TYPE_NORMAL
- en: If we think of a UI as a visual representation of a data structure, which reflects
    the current state of our application, we can, without too much effort, think of
    UI updates as a simple function whose input is the application state and the output
    is a DOM representation.
  prefs: []
  type: TYPE_NORMAL
- en: You'll have noticed I didn't say the output is rendering to the DOM—that would
    make the function impure as rendering is clearly a side effect. It would also
    make it just as slow as the alternatives.
  prefs: []
  type: TYPE_NORMAL
- en: This DOM representation is essentially a tree of DOM nodes that model how your
    UI should look, and nothing else.
  prefs: []
  type: TYPE_NORMAL
- en: React calls this representation a **Virtual DOM** *,* and roughly speaking,
    instead of watching individual bits and pieces of application state that trigger
    a DOM re-render upon change, React turns your UI into a function to which you
    give the whole application state.
  prefs: []
  type: TYPE_NORMAL
- en: 'When you give this function the new updated state, React renders that state
    to the Virtual DOM. Remember the Virtual DOM is simply a data structure, so the
    rendering is extremely fast. Once it''s done, React does one of two things:'
  prefs: []
  type: TYPE_NORMAL
- en: It commits the Virtual DOM to the actual DOM if this is the first render.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Otherwise, it compares the new Virtual DOM with the current Virtual DOM, cached
    from the previous render of the application. It then uses an efficient diff algorithm
    to compute the minimum set of changes required to update the real DOM. Finally,
    it commits this delta to the DOM.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Without digging into the nuts and bolts of React, this is essentially how it
    is implemented and the reason it is faster than the alternatives. Conceptually,
    React hits the "refresh" button whenever your application state changes.
  prefs: []
  type: TYPE_NORMAL
- en: Another great benefit is that by thinking of your UI as a function from application
    state to a Virtual DOM, we recover some of the reasoning we're able to do when
    working with immutable data structures in functional languages.
  prefs: []
  type: TYPE_NORMAL
- en: In the upcoming sections, we will understand why this is a big win for us Clojure
    developers.
  prefs: []
  type: TYPE_NORMAL
- en: ClojureScript and Om
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Why have I spent six pages talking about JavaScript and React in a Clojure book?
    I promise I'm not trying to waste your precious time; we simply needed some context
    to understand what's to come.
  prefs: []
  type: TYPE_NORMAL
- en: Om is a ClojureScript interface to React.js developed by the prolific and amazing
    individual David Nolen, from Cognitect. Yes, he has also developed `core.logic`,
    `core.match`, and the ClojureScript compiler. That's how prolific. But I digress.
  prefs: []
  type: TYPE_NORMAL
- en: When Facebook released React, David immediately saw the potential and, more
    importantly, how to take advantage of the assumptions we are able to make when
    programming in Clojure, the most important of which is that data structures don't
    change.
  prefs: []
  type: TYPE_NORMAL
- en: React provides several component life-cycle functions that allow developers
    to control various properties and behaviors. One in particular, `shouldComponentUpdate`,
    is used to decide whether a component needs to be re-rendered.
  prefs: []
  type: TYPE_NORMAL
- en: React has a big challenge here. JavaScript is inherently mutable, so it is extremely
    hard, when comparing Virtual DOM Trees, to identify which nodes have changed in
    an efficient way. React employs a few heuristics in order to avoid *O(n* *3* *)*
    worst-case performance and is able to do it in *O(n)* most of the time. Since
    heuristics aren't perfect, we can choose to provide our own implementation of
    `shouldComponentUpdate` and take advantage of the knowledge we possess when rendering
    a component.
  prefs: []
  type: TYPE_NORMAL
- en: 'ClojureScript, on the other hand, uses immutable data structures. As such,
    Om provides the simplest and most efficient implementation possible for `shouldComponentUpdate`:
    a simple reference equality check.'
  prefs: []
  type: TYPE_NORMAL
- en: Because we're always dealing with immutable data structures, in order to know
    whether two trees are the same, all we need to do is compare whether their roots
    are the same. If they are, we're done. Otherwise, descend and repeat the process.
    This is guaranteed to yield *O(log n)* runtime complexity and allows Om to always
    render the UI from the root efficiently.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, performance isn't the only thing that's good about Om—we will now
    explore what makes an Om application.
  prefs: []
  type: TYPE_NORMAL
- en: Building a simple Contacts application with Om
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter has been very text heavy so far. It's time we get our hands dirty
    and build a simple Om application. Since we talked about contacts before, that's
    what we will start with.
  prefs: []
  type: TYPE_NORMAL
- en: The main driver behind React and Om is the ability to build highly reusable,
    self-contained components and, as such, even in a simple *Contacts* application,
    we will have multiple components working in concert to achieve a common goal.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is what our users should be able to do in the application:'
  prefs: []
  type: TYPE_NORMAL
- en: Display a list of contacts currently in storage
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Display the details of a given contact
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Edit the details of a specific contact
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'And once we''re done, it will look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Building a simple Contacts application with Om](img/00023.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The Contacts application state
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As mentioned previously, Om/React will eventually render the DOM based on our
    application state. We''ll be using data that''s in memory to keep the example
    simple. Here''s what our application state will look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The reason we keep the state in an atom is that Om uses that to re-render the
    application if we `swap!` or `reset!` it, for instance, if we load some data from
    the server after the application has been rendered for the first time.
  prefs: []
  type: TYPE_NORMAL
- en: The data in the state itself should be mostly self-explanatory. We have a map
    containing all contacts, a key representing whether there is currently a contact
    selected, and a flag that indicates whether we are currently editing the selected
    contact. What might look odd is that both`:selected-contact-id` and `:editing
    keys` point to a vector. Just bear with me for a moment; the reason for this will
    become clear shortly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have a draft of our application state, it''s time we think about
    how the state will flow through the different components in our app. A picture
    is worth a thousand words, so the following diagram shows the high-level architecture
    through which our data will flow:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The Contacts application state](img/00024.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: In the preceding image, each function corresponds to an Om component. At the
    very least, they take some piece of data as their initial state. What is interesting
    in this image is that as we descend into our more specialized components, they
    request less state than the main component, `contacts-app`. For instance, the
    `contacts-view` component needs all contacts as well as the ID of the selected
    contact. The `details-panel-view` component, on the other hand, only needs the
    currently selected contact, and whether it's being edited or not. This is a common
    pattern in Om and we usually want to avoid over-sharing the application state.
  prefs: []
  type: TYPE_NORMAL
- en: With a rough understanding of our high-level architecture, we are ready to start
    building our Contacts application.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up the Contacts project
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Once again, we will use a leiningen template to help us get started. This time
    we''ll be using `om-start` (see [https://github.com/magomimmo/om-start-template](https://github.com/magomimmo/om-start-template)),
    also by Mimmo Cosenza (see [https://github.com/magomimmo](https://github.com/magomimmo)).
    Type this in the terminal to create a base project using this template:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, let''s open the `project.clj` file and make sure we have the same versions
    for the various different dependencies the template pulls in. This is just so
    that we don''t have any surprises with incompatible versions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'To validate the new project skeleton, still in the terminal, type the following
    to auto-compile your ClojureScript source files:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Now, we should see the template default "Hello World" page if we open the `dev-resources/public/index.html`
    file in the browser.
  prefs: []
  type: TYPE_NORMAL
- en: Application components
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The next thing we''ll do is open the `src/cljs/contacts/core.cljs` file, which
    is where our application code will go, and make sure it looks like the following
    so that we have a clean slate with the appropriate namespace declaration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Every Om application starts with a root component created by the `om/root` function.
    It takes as arguments a function representing a component—`contacts-app`—the initial
    state of the application—`app-state`—and a map of options of which the only one
    we care about is `:target`, which tells Om where to mount our root component on
    the DOM.
  prefs: []
  type: TYPE_NORMAL
- en: In this instance, it will mount on a DOM element whose ID is `app`. This element
    was given to us by the `om-start` template and is located in the `dev-resources/public/index.html`
    file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Of course, this code won''t compile yet, as we don''t have the `contacts-app`
    template. Let''s solve that and create it above the preceding declaration—we''re
    implementing the components bottom-up:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Clojure uses reify to implement protocols or Java interfaces on the fly, without
    the need to create a new type. You can read more about this on the data types
    page of the Clojure documentation at [http://clojure.org/datatypes](http://clojure.org/datatypes).
  prefs: []
  type: TYPE_NORMAL
- en: 'The `render` function must return an `Om/React` component or something React
    knows how to render—such as a DOM representation of the component. The arguments
    to `contacts-app` are straightforward: `data` is the component state and `owner`
    is the backing React component.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Moving down the source file, in the implementation of `render`, we have the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: If we recall from our application state, the value of `:selected-contact-id`
    is, at this stage, an empty vector. Here, then, we are destructuring this vector
    and giving it a name. What you might be wondering now is why we bound the vector
    to a variable named `selected-id-cursor`. This is to reflect the fact that at
    this point in the life cycle of a component, `selected-id-cursor` isn't a vector
    any longer but rather it is a cursor.
  prefs: []
  type: TYPE_NORMAL
- en: Om cursors
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Once `om/root` creates our root component, sub-components don't have direct
    access to the state atom any longer. Instead, components receive a cursor created
    from the application state.
  prefs: []
  type: TYPE_NORMAL
- en: 'Cursors are data structures that represent a place in the original state atom.
    You can use cursors to read, delete, update, or create a value with no knowledge
    of the original data structure. Let''s take the `selected-id-cursor` cursor as
    an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Om cursors](img/00025.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: At the top, we have our original application state, which Om turns into a cursor.
    When we request the `:selected-contact-id` key from it, Om gives us another cursor
    representing that particular place in the data structure. It just so happens that
    its value is the empty vector.
  prefs: []
  type: TYPE_NORMAL
- en: What is interesting about this cursor is that if we update its value using one
    of Om's state transition functions such as `om/transact!` and `om/update!`—we
    will explain these shortly—it knows how to propagate the change up the tree and
    all the way back to the application state atom.
  prefs: []
  type: TYPE_NORMAL
- en: This is important because as we have briefly stated before, it is common practice
    to have our more specialized components depend on specific parts of the application
    state required for its correct operation.
  prefs: []
  type: TYPE_NORMAL
- en: By using cursors, we can easily propagate changes without knowing what the application
    state looks like, thus avoiding the need to access the global state.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can think of cursors as zippers. Conceptually, they serve a similar purpose
    but have different APIs.
  prefs: []
  type: TYPE_NORMAL
- en: Filling in the blanks
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Moving down the `contacts-app` component, we now have the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The `dom` namespace contains thin wrappers around React's DOM classes. It's
    essentially the data structure representing what the application will look like.
    Next, we see two examples of how we can create Om components inside another Om
    component. We use the `om/build` function for that and create the `contacts-view`
    and `details-panel-view` components. The `om/build` function takes as arguments
    the component function, the component state, and, optionally, a map of options
    which aren't important for this example.
  prefs: []
  type: TYPE_NORMAL
- en: At this point, we have already started to limit the state we will pass into
    the sub-components by creating sub-cursors.
  prefs: []
  type: TYPE_NORMAL
- en: 'According to the source code, the next component we should look at is `contacts-view`.
    Here it is in full:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Hopefully, the source of this component looks a little more familiar now. As
    before, we reify `om/IRender` to provide a DOM representation of our component.
    It comprises a single `div` element. This time we give as the second argument
    to `dom/div` a hash-map representing HTML attributes. We are using some inline
    styles, but ideally we would use an external style sheet.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you are not familiar with the `#js {…}` syntax, it's simply a reader macro
    that expands to (`clj->js {…}`) in order to convert a ClojureScript hash-map into
    a JavaScript object. The only thing to watch for is that it is not recursive,
    as evidenced by the nested use of `#js`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The third argument to `dom/div` is slightly more complex than what we have
    seen so far:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Each contact will be represented by a `li` (list item) HTML node, so we start
    by wrapping the result into a `dom/ul` element. Then, we use `om/build-all` to
    build a list of contact-`summary-view` components. Om will, in turn, call `om/build`
    for each contact in `vals contacts`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Lastly, we use the third argument to `om/build-all`—the options map—to demonstrate
    how we can share state between components without the use of global state. We''ll
    see how that''s used in the next component, `contact-summary-view`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: If we think of our application as a tree of components, we have now reached
    one of its leaves. This component simply returns a `dom/li` node with the contact's
    name and phone in it, wrapped in `dom/span` nodes.
  prefs: []
  type: TYPE_NORMAL
- en: It also installs a handler to the `dom/li onClick` event, which we can use to
    update the state cursor.
  prefs: []
  type: TYPE_NORMAL
- en: 'We use `om/get-shared` to access the shared state we installed earlier and
    pass the resulting cursor into `select-contact!` We also pass the current contact,
    but, if you look closely, we have to `deref` it first:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The reason for this is that Om doesn''t allow us to manipulate cursors outside
    of the render phase. By derefing the cursor, we have its most recent underlying
    value. Now `select-contact`! has all it needs to perform the update:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: We simply use `om/update!` to set the value of the `selected-id-cursor` cursor
    at index `0` to the `id` of the contact. As mentioned previously, the cursor takes
    care of propagating the change.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can think of `om/update!` as the cursors version of `clojure.core/reset!`
    used in atoms. Conversely, the same applies to `om/transact!` and `clojure.core/swap!`,
    respectively.
  prefs: []
  type: TYPE_NORMAL
- en: 'We are moving at a good pace. It''s time we look at the next component, `details-panel-view`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'This component should now look fairly familiar. All it does is build two other
    components, `contact-details-view` and `contact-details-form-view`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The `contact-details-view` component receives two pieces of state: the contact
    and the editing flag. If we have a contact, we simply render the component. However,
    we use the editing flag to hide it, if we are editing it. This is so that we can
    show the edit form in the next component. We also install an `onClick` handler
    to the Edit button so that we can update the editing cursor.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `contact-details-form-view` component receives the same arguments but renders
    the following form instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'This is the component responsible for actually updating the contact information
    based on the form. It does so by calling `update-contact!` with the JavaScript
    event, the contact cursor, and the key representing the attribute to be updated:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: As before, we simply use `om/update!` instead of `om/transact!` as we are simply
    replacing the value of the cursor attribute with the current value of the form
    field which triggered the event `e`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If you''re not familiar with the `..` syntax, it''s simply a convenience macro
    for Java and JavaScript interoperability. The previous example expands to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: This and other interoperability operators are described in the Java Interop
    page of the Clojure website (see [http://clojure.org/java_interop](http://clojure.org/java_interop)).
  prefs: []
  type: TYPE_NORMAL
- en: 'This is it. Make sure your code is still compiling—or if you haven''t yet,
    start the auto-compilation by typing the following in the terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Then, open up `dev-resources/public/index.html` again in your browser and take
    our Contacts app for a spin! Note in particular how the application state is always
    in sync while you edit the contact attributes.
  prefs: []
  type: TYPE_NORMAL
- en: If there are any issues at this stage, make sure the `src/cljs/contacts/core.cljs`
    file matches the companion code for this book.
  prefs: []
  type: TYPE_NORMAL
- en: Intercomponent communication
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In our previous example, the components we built communicated with each other
    exclusively through the application state, both for reading and transacting data.
    While this approach works, it is not always the best except for very simple use
    cases. In this section, we will learn an alternate way of performing this communication
    using `core.async` channels.
  prefs: []
  type: TYPE_NORMAL
- en: The application we will build is a super simple virtual agile board. If you've
    heard of it, it's similar to Trello (see [https://trello.com/](https://trello.com/)).
    If you haven't, fear not, it's essentially a task management web application in
    which you have cards that represent tasks and you move them between columns such
    as **Backlog**, **In Progress**, and **Done**.
  prefs: []
  type: TYPE_NORMAL
- en: 'By the end of this section, the application will look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Intercomponent communication](img/00026.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'We''ll limit ourselves to a single feature: moving cards between columns by
    dragging and dropping them. Let''s get started.'
  prefs: []
  type: TYPE_NORMAL
- en: Creating an agile board with Om
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We''re already familiar with the `om-start` (see [https://github.com/magomimmo/om-start-template](https://github.com/magomimmo/om-start-template))
    leiningen template, and since there is no reason to change it, that''s what we
    will use to create our project—which I called `om-pm` for **Om Project Management**:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'As before, we should ensure we have the right dependencies in our `project.clj`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Now validate that we are in good shape by making sure the project compiles
    properly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, open the `src/cljs/om_pm/core.cljs` file and add the namespaces that
    we will be using to build the application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: The main difference this time is that we are requiring `core.async` functions
    and macros. We don't yet have an `om-pm.util` namespace, but we'll get to that
    at the end.
  prefs: []
  type: TYPE_NORMAL
- en: The board state
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'It''s time we think what our application state will look like. Our main entity
    in this application is the **card**, which represents a task and has the attributes
    `id`, `title`, and `description`. We will start by defining a couple of cards:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'This isn''t our application state yet, but rather a part of it. Another important
    piece of state is a way to track which cards are on which columns. To keep things
    simple, we will work with only three columns: **Backlog**, **In Progress**, and
    **Done**. By default, all cards start out in the backlog:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: This is all the state we need. Columns have a `:title` and a `:cards` attribute,
    which contains the IDs of all cards in that column.
  prefs: []
  type: TYPE_NORMAL
- en: 'Additionally, we will have a helper function to make finding cards more convenient:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Beware of lazy sequences**'
  prefs: []
  type: TYPE_NORMAL
- en: 'You might have noticed the use of `mapv` instead of `map` for retrieving the
    cards IDs. This is a subtle but important difference: `map` is lazy by default,
    but Om can only create cursors for maps and vectors. Using `mapv` gives us a vector
    back, avoiding laziness altogether.'
  prefs: []
  type: TYPE_NORMAL
- en: Had we not done that, Om would consider the list of IDs as a normal value and
    we would not be able to transact it.
  prefs: []
  type: TYPE_NORMAL
- en: Components overview
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are many ways to slice up an Om application into components, and in this
    section, we will present one way as we walk through each component's implementation.
  prefs: []
  type: TYPE_NORMAL
- en: The approach we will follow is similar to our previous application in that from
    this point on, we present the components bottom-up.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we see our first component, however, we should start with Om''s own
    `root` component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'This gives us a hint as to what our next component will be, `project-view`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Lifecycle and component local state
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The previous component is fairly different from the ones we have seen so far.
    More specifically, it implements two new protocols: `om/IInitState` and `om/IWillMount`.
    Additionally, we dropped `om/IRender` altogether in favor of `om/IRenderState`.
    Before we explain what these new protocols are good for, we need to discuss our
    high-level design.'
  prefs: []
  type: TYPE_NORMAL
- en: The `project-view` component is our application's main entry point and receives
    the whole application state as its first argument. As in our earlier *Contacts*
    application, it then instantiates the remaining components with the data they
    need.
  prefs: []
  type: TYPE_NORMAL
- en: Different from the *Contacts* example, however, it creates a `core.async` channel—`transfer-chan`—which
    works as a message bus. The idea is that when we drag a card from one column and
    drop it on another, one of our components will put a transfer event in this channel
    and let someone else—most likely a `go` block—perform the actual move operation.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is done in the following snippet taken from the component shown earlier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: This creates what Om calls the component local state. It uses a different lifecycle
    protocol, `om/IInitState`, which is guaranteed to be called only once. After all,
    we need a single channel for this component. `init-state` should return a map
    representing the local state.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have the channel, we need to install a `go-loop` to handle messages
    sent to it. For this purpose, we use a different protocol:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Like the previous protocol, `om/IWillMount` is also guaranteed to be called
    once in the component life cycle. It is called when it is about to be mounted
    into the DOM and is the perfect place to install the `go-loop` into our channel.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When creating `core.async` channels in Om applications, it is important to avoid
    creating them inside life-cycle functions that are called multiple times. Besides
    non-deterministic behavior, this is a source of memory leaks.
  prefs: []
  type: TYPE_NORMAL
- en: We get hold of it from the component local state using the `om/get-state` function.
    Once we get a message, we transact the state. We will see what `transfer-data`
    looks like very shortly.
  prefs: []
  type: TYPE_NORMAL
- en: 'We complete the component by implementing its render function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: The `om/IRenderState` function serves the same purpose of `om/IRender`, that
    is, it should return the DOM representation of what the component should look
    like. However, it defines a different function, `render-state`, which receives
    the component local state as its second argument. This state contains the map
    we created during the `init-state` phase.
  prefs: []
  type: TYPE_NORMAL
- en: Remaining components
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Next, we will build multiple `column-view` components, one per column. Each
    of them receives the list of cards from the application state as their shared
    state. We will use that to retrieve the card details from the IDs we store in
    each column.
  prefs: []
  type: TYPE_NORMAL
- en: 'We also use the `:init-state` key to initialize the local state of each column
    view with our channel, since all columns need a reference to it. Here''s what
    the component looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: The code should look fairly familiar at this point. We used inline CSS in the
    example to keep it simple, but in a real application, we would probably have used
    an external style sheet.
  prefs: []
  type: TYPE_NORMAL
- en: 'We implement `render-state` once more to retrieve the transfer channel, which
    will be used when handling the `onDrop` JavaScript event. This event is fired
    by the browser when a user drops a draggable DOM element onto this component.
    `handle-drop` takes care of that like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: This function creates the transfer data—a map with the keys `:card-id`, `:source-column`,
    and `:destination-column`—which is everything we need to move the cards between
    columns. Finally, we `put!` it into the transfer channel.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we build a number or `card-view` components. As mentioned previously,
    Om can''t create cursors from lazy sequences, so we use `filterv` to give each
    `card-view` a vector containing their respective cards. Let''s see its source:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: As this component doesn't need any local state, we go back to using the `IRender`
    protocol. Additionally, we make it draggable and install an event handler on the
    `onDragStart` event, which will be triggered when the user starts dragging the
    card.
  prefs: []
  type: TYPE_NORMAL
- en: This event handler sets the transfer data, which we use from `handle-drop`.
  prefs: []
  type: TYPE_NORMAL
- en: We have glossed over the fact that these components use a few utility functions.
    That's OK, as we will now define them in a new namespace.
  prefs: []
  type: TYPE_NORMAL
- en: Utility functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Go ahead and create a new file under `src/cljs/om_pm/` called `util.cljs` and
    add the following namespace declaration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'For consistency, we will look at the functions bottom-up, starting with `move-card!`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: The `move-card!` function receives a cursor for the columns in our application
    state and simply moves `card-id` between the source and destination. You will
    notice we didn't need any access to `core.async` or Om specific functions, which
    means this function is pure and therefore easy to test.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we have the functions that handle transfer data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: These functions use JavaScript interoperability to interact with HTML's `DataTransfer`
    (see [https://developer.mozilla.org/en-US/docs/Web/API/DataTransfer](https://developer.mozilla.org/en-US/docs/Web/API/DataTransfer))
    object. This is how browsers share data related to drag and drop events.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's simply save the file and make sure the code compiles properly. We
    can finally open `dev-resources/public/index.html` in the browser and play around
    with the product of our work!
  prefs: []
  type: TYPE_NORMAL
- en: Exercises
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this exercise, we will modify the `om-pm` project we created in the previous
    section. The objective is to add keyboard shortcuts so that power users can operate
    the agile board more efficiently.
  prefs: []
  type: TYPE_NORMAL
- en: 'The shortcuts to be supported are:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `up`, `down`, `left`, and `right` arrow keys: These allow the user to navigate
    through the cards, highlighting the current one'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `n` and `p` keys: These are used to move the current card to the next (right)
    or previous (left) column, respectively'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The key insight here is to create a new `core.async` channel, which will contain
    key press events. These events will then trigger the actions outlined previously.
    We can use the Google closure library to listen for events. Just add the following
    `require` to the application namespace:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, use this function to create a channel from DOM events:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: The actual logic of moving the cards around based on keyboard shortcuts can
    be implemented in a number of ways, so don't forget to compare your solution with
    the answers provided in this book's companion code.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we saw a different approach on how to handle reactive web interfaces
    by Om and React. In turn, these frameworks make this possible and painless by
    applying functional programming principles such as immutability and persistent
    data structures for efficient rendering.
  prefs: []
  type: TYPE_NORMAL
- en: We also learned to think the Om way by structuring our applications as a series
    of functions, which receive state and output a DOM representation of state changes.
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, we saw that by structuring application state transitions through
    `core.async` channels, we separate the presentation logic from the code, which
    will actually perform the work, making our components even easier to reason about.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the next chapter, we will turn to an often overlooked yet useful tool for
    creating reactive applications: **Futures**.'
  prefs: []
  type: TYPE_NORMAL
