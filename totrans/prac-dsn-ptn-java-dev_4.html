<html><head></head><body>
		<div id="_idContainer059">
			<h1 id="_idParaDest-122" class="chapter-number"><a id="_idTextAnchor172"/>4</h1>
			<h1 id="_idParaDest-123"><a id="_idTextAnchor173"/>Applying Structural Design Patterns</h1>
			<p>Every piece of software has a purpose or, in other words, an expected behavior that it should fulfill. While the previous chapter described in detail creational design patterns, this chapter will focus on designing maintainable and flexible source code for objects created. Structural patterns attempt to bring clarity to relationships between created instances, not only to maintain an application but also to easily understand its purpose. Let us dive deeper and start examining the <span class="No-Break">following topics:</span></p>
			<ul>
				<li>Incompatible object collaboration with the <span class="No-Break">adapter pattern</span></li>
				<li>Decoupling and developing objects independently with the <span class="No-Break">bridge pattern</span></li>
				<li>Treating objects the same way using the <span class="No-Break">composite pattern</span></li>
				<li>Extending object functionality by using the <span class="No-Break">decorator pattern</span></li>
				<li>Simplifying communication with the <span class="No-Break">facade pattern</span></li>
				<li>Using conditions to select desired objects with the <span class="No-Break">filter pattern</span></li>
				<li>Sharing objects across an application with the <span class="No-Break">flyweight pattern</span></li>
				<li>Handling requests with the <span class="No-Break">front-controller pattern</span></li>
				<li>Identifying instances using the <span class="No-Break">marker pattern</span></li>
				<li>Exploring the concept of modules with the <span class="No-Break">module pattern</span></li>
				<li>Providing a placeholder for an object employing the <span class="No-Break">proxy pattern</span></li>
				<li>Discovering multiple inheritance in Java with the <span class="No-Break">twin pattern</span></li>
			</ul>
			<p>By the end of this chapter, you’ll have a solid understanding of how to structure a code base around <span class="No-Break">created instances.</span></p>
			<h1 id="_idParaDest-124"><a id="_idTextAnchor174"/>Technical requirements</h1>
			<p>You can find the code files for this chapter on GitHub <span class="No-Break">at </span><a href="https://github.com/PacktPublishing/Practical-Design-Patterns-for-Java-Developers/tree/main/Chapter04"><span class="No-Break">https://github.com/PacktPublishing/Practical-Design-Patterns-for-Java-Developers/tree/main/Chapter04</span></a><span class="No-Break">.</span></p>
			<h1 id="_idParaDest-125"><a id="_idTextAnchor175"/>Incompatible object collaboration with the adapter pattern</h1>
			<p>The main goal of the adapter pattern<a id="_idIndexMarker293"/> is to connect the source<a id="_idIndexMarker294"/> class interface to another interface that clients will expect. The adapter pattern allows classes to work together that otherwise couldn’t due to an incompatible abstraction or implementation. It is considered one of the most common patterns and is one of the <strong class="bold">Gang of Four</strong> (<strong class="bold">GoF</strong>) <span class="No-Break">design patterns.</span></p>
			<h2 id="_idParaDest-126"><a id="_idTextAnchor176"/>Motivation</h2>
			<p>The adapter pattern<a id="_idIndexMarker295"/> is also known as <strong class="bold">wrapper</strong>. An adapter wraps the behavior<a id="_idIndexMarker296"/> of the adaptee (connected class) and allows access to the adaptee without modification using an already existing interface. Commonly, an adaptee uses an incompatible interface, and an adapter consolidates such behavior and transparently provides access to the <span class="No-Break">required functionality.</span></p>
			<h2 id="_idParaDest-127"><a id="_idTextAnchor177"/>Finding it in the JDK</h2>
			<p>The <strong class="source-inline">java.base</strong> module provides<a id="_idIndexMarker297"/> multiple implementations of the adapter pattern. The <strong class="source-inline">Collections</strong> utility class from the <strong class="source-inline">java.util</strong> package provides a <strong class="source-inline">list</strong> method, which accepts an <strong class="source-inline">Enumeration</strong> interface and adapts the result into an <span class="No-Break"><strong class="source-inline">ArrayList</strong></span><span class="No-Break"> instance.</span></p>
			<h2 id="_idParaDest-128"><a id="_idTextAnchor178"/>Sample code</h2>
			<p>The adapter pattern can be implemented<a id="_idIndexMarker298"/> in several ways. One of them is considered in the example of a vehicle that can have different types of engines (<span class="No-Break"><em class="italic">Example 4.1</em></span><span class="No-Break">):</span></p>
			<pre class="source-code">
public static<a id="_idTextAnchor179"/> void<a id="_idTextAnchor180"/> main(String[] args) {
    System.out.println("Adapter Pattern: engines");
    var electricEngine = new ElectricEngine();
    var enginePetrol = new PetrolEngine();
    var vehicleElectric = new Vehicle(electricEngine);
    var vehiclePetrol = new Vehicle(enginePetrol);
    vehicleElectric.drive();
    vehicleElectric.refuel();
    vehiclePetrol.drive();
    vehiclePetrol.refuel();
}</pre>
			<p>Here<a id="_idIndexMarker299"/> is <span class="No-Break">the output:</span></p>
			<pre class="source-code">
<strong class="bold">Adapter Pattern: engines</strong>
<strong class="bold">...</strong>
<strong class="bold">Vehicle, stop</strong>
<strong class="bold">Vehicle needs recharge</strong>
<strong class="bold">ElectricEngine, check plug</strong>
<strong class="bold">ElectricEngine, recharging</strong>
<strong class="bold">...</strong>
<strong class="bold">Vehicle needs petrol</strong>
<strong class="bold">PetrolEngine, tank</strong></pre>
			<p class="SC---Link" lang="en-US" xml:lang="en-US">Example 4.1 – Although each type of vehicle shares similar logic, the behavior of the refuel method varies by engine type</p>
			<p>These engines share some similar functionalities and features, but not all. They are very different from each other (<span class="No-Break"><em class="italic">Figure 4</em></span><span class="No-Break"><em class="italic">.1</em></span><span class="No-Break">):</span></p>
			<div>
				<div id="_idContainer047" class="IMG---Figure">
					<img src="image/B18884_04_01.jpg" alt="Figure 4.1 – UML class diagram highlighting engine type differences"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.1 – UML class diagram highlighting engine type differences</p>
			<p>In this example, the <strong class="source-inline">Vehicle</strong> class and its instance play<a id="_idIndexMarker300"/> the role of adapter. In the case of the <strong class="source-inline">drive</strong> method, both motors behave similarly. The <strong class="source-inline">tank</strong> method execution is a different scenario because the vehicle adapter needs to know the exact engine type to correctly execute the <strong class="source-inline">refuel</strong> method (<span class="No-Break"><em class="italic">Example 4.2</em></span><span class="No-Break">):</span></p>
			<pre class="source-code">
class Vehicle {
    private final Engine engine;
  ...
    void refuel(){
        System.out.println("Vehicle, stop");
        switch (engine){
            case ElectricEngine de -&gt; {
                System.out.println("Vehicle needs diesel");
                de.checkPlug();
                de.tank();
            }
            case PetrolEngine pe -&gt; {
                System.out.println("Vehicle needs petrol");
                pe.tank();
            }
            default -&gt; throw new IllegalStateException
               ("Vehicle has no engine");
        }
        engine.tank();
    }
}</pre>
			<p class="SC---Link" lang="en-US" xml:lang="en-US">Example 4.2 – The Vehicle instance operates with an engine based on its type, identified by the pattern-matching functionality</p>
			<p>New language features <a id="_idIndexMarker301"/>such as <strong class="source-inline">switch</strong> statement enhancements can be very useful as there is no need to keep the exact adaptee instance reference for the adapter. The <strong class="source-inline">sealed</strong> classes enforce the desired purpose and increase maintainability by protecting their intent, such as by avoiding <span class="No-Break">unwanted extensions.</span></p>
			<p>Both engine types considered may still implement similar abstraction in order to maintain the concept of the engine (<span class="No-Break"><em class="italic">Example 4.3</em></span><span class="No-Break">):</span></p>
			<pre class="source-code">
sealed interface Engine permits ElectricEngine,
    PetrolEngine  {
    void run();
    void tank();
}</pre>
			<p class="SC---Link" lang="en-US" xml:lang="en-US">Example 4.3 – The Engine interface allows only certain classes to implement its methods</p>
			<p>The <strong class="source-inline">Vehicle</strong> adapter provides the required logic to handle<a id="_idIndexMarker302"/> the different engine implementations properly. The <strong class="source-inline">ElectricEngine</strong> implementation provides an additional <strong class="source-inline">checkPlug</strong> method (<span class="No-Break"><em class="italic">Example 4.4</em></span><span class="No-Break">):</span></p>
			<pre class="source-code">
final class ElectricEngine implements Engine{
    @Override
    public void run() {
        System.out.println("ElectricEngine, run");
    }
    @Override
    public void tank() {
        System.out.println("ElectricEngine, recharging");
    }
    public void checkPlug(){
        System.out.println("ElectricEngine, check plug");
    }
}</pre>
			<p class="SC---Link" lang="en-US" xml:lang="en-US">Example 4.4 – ElectricEngine implements additional logic that is not shareable with the general Engine concept</p>
			<h2 id="_idParaDest-129"><a id="_idTextAnchor181"/>Conclusion</h2>
			<p>The adapter structural design pattern<a id="_idIndexMarker303"/> has a valid place in development as it represents a maintainable way to connect different functionalities and control them through a similar interface. The adapter is properly encapsulated and can be even more abstract. The new <strong class="source-inline">sealed</strong> classes support the pattern concept of maintainability and clarity. The consequence of using the adapter pattern may be that the adapter needs to commit to a specific adaptee or interface. The adapter may extend some of the adaptee functionalities as a subclass. The adapter pattern is worth considering when additional third-party libraries or APIs are to be implemented. It provides<a id="_idIndexMarker304"/> a transparent and decoupled way to interact with libraries, following the SOLID concept. Solutions can also be <span class="No-Break">easily refactored.</span></p>
			<p>This look at the adapter pattern has shown the approach of using incompatible APIs. Next, let us investigate how to use different <span class="No-Break">replaceable implementations.</span></p>
			<h1 id="_idParaDest-130"><a id="_idTextAnchor182"/>Decoupling and developing objects independently with the bridge pattern</h1>
			<p>The goal of this pattern<a id="_idIndexMarker305"/> is to separate the abstraction<a id="_idIndexMarker306"/> from its implementation so that both can change independently. The bridge pattern was described by <span class="No-Break">the GoF.</span></p>
			<h2 id="_idParaDest-131"><a id="_idTextAnchor183"/>Motivation</h2>
			<p>The bridge pattern<a id="_idIndexMarker307"/> is about prioritizing composition over inheritance. The implementation details are moved from the hierarchy to another object with a separate hierarchy. The bridge pattern uses encapsulation and aggregation, and may use inheritance to separate responsibilities into <span class="No-Break">different classes.</span></p>
			<h2 id="_idParaDest-132"><a id="_idTextAnchor184"/>Finding it in the JDK</h2>
			<p>Uses of the bridge pattern<a id="_idIndexMarker308"/> can be found in the <strong class="source-inline">java.util.logging</strong> package and the implementation of the <strong class="source-inline">Logger</strong> class. The class is located in the <strong class="source-inline">java.logging</strong> module. It implements the <strong class="source-inline">Filter</strong> interface. This interface is used to gain additional control over logged content beyond the standard <span class="No-Break">log level.</span></p>
			<h2 id="_idParaDest-133"><a id="_idTextAnchor185"/>Sample code</h2>
			<p>Let us see an example of two types<a id="_idIndexMarker309"/> of vehicles: a sport car and a pickup. The vehicles vary in engine type: petrol and diesel. The intention is to enforce a separate development for the <strong class="source-inline">Vehicle</strong> and <strong class="source-inline">Engine</strong> abstraction source code. The example case creates vehicles and executes <strong class="source-inline">drive</strong> and <strong class="source-inline">stop</strong> methods (<span class="No-Break"><em class="italic">Example 4.5</em></span><span class="No-Break">):</span></p>
			<pre class="source-code">
public static void main(String[] args) {
    System.out.println("Pattern Bridge, vehicle
        engines...");
    Vehicle sportVehicle = new SportVehicle(new
        PetrolEngine(), 911);
    Vehicle pickupVehicle = new PickupVehicle(new
        DieselEngine(), 300);
    sportVehicle.drive();
    sportVehicle.stop();
    pickupVehicle.drive();
    pickupVehicle.stop();
}</pre>
			<p>Here is <span class="No-Break">the output:</span></p>
			<pre class="source-code">
<strong class="bold">Pattern Bridge, vehicle engines...</strong>
<strong class="bold">SportVehicle, starting engine</strong>
<strong class="bold">PetrolEngine, on</strong>
<strong class="bold">SportVehicle, engine started, hp:911</strong>
<strong class="bold">SportVehicle, stopping engine</strong>
<strong class="bold">PetrolEngine, self check</strong>
<strong class="bold">PetrolEngine, off</strong>
<strong class="bold">SportVehicle, engine stopped</strong>
<strong class="bold">PickupVehicle, starting engine</strong>
<strong class="bold">DieselEngine, on</strong>
<strong class="bold">PickupVehicle, engine started, hp:300</strong>
<strong class="bold">PickupVehicle, stopping engine</strong>
<strong class="bold">DieselEngine, off</strong>
<strong class="bold">PickupVehicle, engine stopped</strong></pre>
			<p class="SC---Link" lang="en-US" xml:lang="en-US">Example 4.5 – The vehicles use different engines; they can be developed separately due to the bridge pattern’s isolation</p>
			<p>Each vehicle<a id="_idIndexMarker310"/> extends the <strong class="source-inline">Vehicle</strong> abstraction class that runs the engine and encapsulates the basic functions. The <strong class="source-inline">Engine</strong> interface, used by the vehicle abstraction, plays the role of a bridge, as shown in the following diagram (<span class="No-Break"><em class="italic">Figure 4</em></span><span class="No-Break"><em class="italic">.2</em></span><span class="No-Break">):</span></p>
			<div>
				<div id="_idContainer048" class="IMG---Figure">
					<img src="image/B18884_04_02.jpg" alt=""/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US"> </p>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.2 – The UML class diagram shows how the Engine interface bridges access to a specific implementation</p>
			<p>The engines already behave differently, and due<a id="_idIndexMarker311"/> to the bridge they may continue evolving (<span class="No-Break"><em class="italic">Example 4.6</em></span><span class="No-Break">):</span></p>
			<pre class="source-code">
class DieselEngine implements Engine{
        ...
    @Override
    public void turnOff() {...}
}
class PetrolEngine implements Engine{
        ...
    @Override
    public void turnOff() {
       selfCheck();
       ...
    }
    private void selfCheck(){ ...}
}</pre>
			<p class="SC---Link" lang="en-US" xml:lang="en-US">Example 4.6 – The engines differ in implementation</p>
			<p>The vehicle abstraction<a id="_idIndexMarker312"/> does not have any engine implementation details, which may vary even in the class hierarchy. The vehicle only needs to rely on the <span class="No-Break">provided interface.</span></p>
			<h2 id="_idParaDest-134"><a id="_idTextAnchor186"/>Conclusion</h2>
			<p>The bridge pattern is a good idea<a id="_idIndexMarker313"/> to consider when the <a id="_idTextAnchor187"/>application so<a id="_idTextAnchor188"/><a id="_idTextAnchor189"/>urce code requires reducing bindings to specific implementation classes. Due to the bridge pattern, the decision about a specific implementation can be deferred until runtime. The bridge pattern helps to encourage SOLID design principles through responsibility separation and encapsulation. The implementation can be freely tested and shared as required through the application source code. It is required to keep in mind not to add unwanted responsibilities to the bridge implementation and consider alternative approaches in terms of design patterns when such a situation takes <span class="No-Break">a place.</span></p>
			<p>The bridge pattern can open the door to better composition of implementation specifics, as we’ll explore in the <span class="No-Break">next<a id="_idTextAnchor190"/> pattern.</span></p>
			<h1 id="_idParaDest-135"><a id="_idTextAnchor191"/>Treating objects the same way using the composite pattern</h1>
			<p>The composite pattern<a id="_idIndexMarker314"/> is a remarkable solution<a id="_idIndexMarker315"/> for handling objects<a id="_idIndexMarker316"/> uniformly while arranging them in a tree structure, which simplifies access to instances. The demand for i<a id="_idTextAnchor192"/><a id="_idTextAnchor193"/>t naturally came from industry, and the pattern was soon identified and described by <span class="No-Break">the GoF.</span></p>
			<h2 id="_idParaDest-136"><a id="_idTextAnchor194"/>Motivation</h2>
			<p>Grouping objects around the underlying<a id="_idIndexMarker317"/> business logic is a powerful approach. A composite design pattern outlines a way to achieve such a state. Since each member of the group is treated uniformly, it is possible to create hierarchical tree structures and part-whole hierarchies. It helps to establish the logical relationships of the application and the composition of the <span class="No-Break">desired objects.</span></p>
			<h2 id="_idParaDest-137"><a id="_idTextAnchor195"/>Finding it in the JDK</h2>
			<p>In the JDK, the composite<a id="_idIndexMarker318"/> pattern can be found in the <strong class="source-inline">java.base</strong> module, the <strong class="source-inline">java.util</strong> package, and the <strong class="source-inline">Properties</strong> class. The <strong class="source-inline">Properties</strong> class implements the <strong class="source-inline">Map</strong> interface through its <strong class="source-inline">Hashtable</strong> implementation, and also contains a <strong class="source-inline">ConcurrentHashMap</strong> instance to store the property values internally. Although the <strong class="source-inline">Properties</strong> class’s <strong class="source-inline">put</strong> operation remains synchronized due to the <strong class="source-inline">Hashtable</strong> implementation, the <strong class="source-inline">get</strong> operation does not, as it is simple to read into the <span class="No-Break">concurrent map.</span></p>
			<h2 id="_idParaDest-138"><a id="_idTextAnchor196"/>Sample code</h2>
			<p>To explore the power of the composition<a id="_idIndexMarker319"/> pattern, consider the <strong class="source-inline">SportVehicle</strong> class, which implements the <strong class="source-inline">Vehicle</strong> interface. It is standard knowledge that every vehicle is a collection of parts and every part is a grouping of smaller parts (<span class="No-Break"><em class="italic">Figure 4</em></span><span class="No-Break"><em class="italic">.3</em></span><span class="No-Break">):</span></p>
			<div>
				<div id="_idContainer049" class="IMG---Figure">
					<img src="image/B18884_04_03.jpg" alt="Figure 4.3 – The UML class diagram shows how SportVehicle is composed of VehiclePart types"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.3 – The UML class diagram shows how SportVehicle is composed of VehiclePart types</p>
			<p>When the vehicle manufacturing<a id="_idIndexMarker320"/> process starts, the composition pattern provides a complete collection of every part that is present in the final results (<span class="No-Break"><em class="italic">Example 4.7</em></span><span class="No-Break">):</span></p>
			<pre class="source-code">
public static void main(String[] args) {
    System.out.println("Pattern Composite, vehicle
        parts...");
    var fastVehicle = new SportVehicle("sport");
    var engine = new VehiclePart("fast-engine");
    engine.addPart(new VehiclePart("cylinder-head"));
    var brakes = new VehiclePart("super-brakes");
    var transmission = new VehiclePart("automatic-
        transmission");
    fastVehicle.addPart(engine);
    fastVehicle.addPart(brakes);
    fastVehicle.addPart(transmission);
    fastVehicle.printParts();
}</pre>
			<p>Here’s <span class="No-Break">the</span><span class="No-Break"><a id="_idIndexMarker321"/></span><span class="No-Break"> output:</span></p>
			<pre class="source-code">
<strong class="bold">Pattern Composite, vehicle parts...</strong>
<strong class="bold">SportCar, type'sport', parts:'</strong>
<strong class="bold">[{type='fast-engine', parts=[{type='cylinder-head',</strong>
<strong class="bold">  parts=[]}]},</strong>
<strong class="bold">{type='super-brakes', parts=[]},</strong>
<strong class="bold">{type='automatic-transmission', parts=[]}]'</strong></pre>
			<p class="SC---Link" lang="en-US" xml:lang="en-US">Example 4.7 – Reviewing the SportVehicle instance composition</p>
			<h2 id="_idParaDest-139"><a id="_idTextAnchor197"/>Conclusion</h2>
			<p>The composite pattern<a id="_idIndexMarker322"/> allows the representation of the composition of a class in granular detail. It takes into account the smaller parts of the composite by creating part-whole hierarchies. While this provides advantages because each part is treated uniformly, it can lead to ignoring differences between parts. On the other hand, the composite pattern holds all the involved parts together in a <span class="No-Break">transparent form.</span></p>
			<p>Let us now examine how an individual object can be extended with additional functionality without changing <span class="No-Break">the API.</span></p>
			<h1 id="_idParaDest-140"><a id="_idTextAnchor198"/>Extending object functionality by using the decorator pattern</h1>
			<p>The decorator pattern<a id="_idIndexMarker323"/> provides the ability to add new functionality<a id="_idIndexMarker324"/> to objects by placing those objects in a decorator, Sothat a<a id="_idTextAnchor199"/> decorated instance provides extended functionality. The implementation of the decorator pattern is relatively simple and dynamic in languages such as Python and Kotlin. On the other hand, Java may provide more stability and maintainability of the source code through visibility<a id="_idIndexMarker325"/> and new enhancemen<a id="_idTextAnchor200"/>ts, which <a id="_idIndexMarker326"/>c<a id="_idTextAnchor201"/>an b<a id="_idTextAnchor202"/>e very valuable. The decorator pattern was identified and described by <span class="No-Break">the GoF.</span></p>
			<h2 id="_idParaDest-141"><a id="_idTextAnchor203"/>Motivation</h2>
			<p>With the decorator<a id="_idIndexMarker327"/> pattern, you can dynamically attach additional responsibilities to an object. A decorator provides a flexible alternative to subclasses to extend the functionality of a class. The decorator can be added statically or dynamically without altering the current behavior of <span class="No-Break">an object.</span></p>
			<h2 id="_idParaDest-142"><a id="_idTextAnchor204"/>Finding it in the JDK</h2>
			<p>Uses of the decorator pattern<a id="_idIndexMarker328"/> can be found in the Java collections framework, the <strong class="source-inline">java.base</strong> module, and the <strong class="source-inline">java.util</strong> package. The <strong class="source-inline">Collection</strong> class contains different ways to use the decorator pattern. For example, the <strong class="source-inline">unmodifiableCollection</strong> method wraps the requested collection into an unmodifiable collection represented by an <strong class="source-inline">UnmodifiableCollection</strong> instance that acts as a decorator for the provided collection type, similar to other methods starting with <strong class="source-inline">unmodifiable...</strong> words. Another example is methods starting with the word <strong class="source-inline">synchronized...</strong> of the <strong class="source-inline">Collections</strong> <span class="No-Break">utility class.</span></p>
			<h2 id="_idParaDest-143"><a id="_idTextAnchor205"/>Sample code</h2>
			<p>When you think about the previous examples<a id="_idIndexMarker329"/> of vehicles, the decorator pattern can be considered a tuned vehicle. The standard <strong class="source-inline">SportVehicle</strong> class is like this. It implements the <strong class="source-inline">Vehicle</strong> interface to fulfill standard functions. The application designer later decides to improve the current state and creates a <strong class="source-inline">TunedVehicleDecorator</strong> class that wraps the standard vehicle, without having to change previous functions (<span class="No-Break"><em class="italic">Figure 4</em></span><span class="No-Break"><em class="italic">.4</em></span><span class="No-Break">):</span></p>
			<div>
				<div id="_idContainer050" class="IMG---Figure">
					<img src="image/B18884_04_04.jpg" alt="Figure 4.4 – The UML class diagram highlights the relationship between SportVehicle and TunedVehicleDecorator types"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.4 – The UML class diagram highlights the relationship between SportVehicle and TunedVehicleDecorator types</p>
			<p>All considered vehicles<a id="_idIndexMarker330"/> expose similar APIs to execute their implementations (<span class="No-Break"><em class="italic">Example 4.8)</em></span><span class="No-Break">:</span></p>
			<pre class="source-code">
public static void main(String[] args) {
    System.out.println("Pattern Decorator, vehicle 1");
    Vehicle standardVehicle = new StandardVehicle();
    Vehicle vehicleToBeTuned = new StandardVehicle();
    Vehicle tunedVehicle = new SportVehicle
        (vehicleToBeTuned, 200);
    System.out.println("Drive a standard vehicle");
    standardVehicle.move();
    System.out.println("Drive a tuned vehicle");
    tunedVehicle.move();
}</pre>
			<p>Here is <span class="No-Break">the output:</span></p>
			<pre class="source-code">
<strong class="bold">Pattern Decorator, tuned vehicle</strong>
<strong class="bold">Drive a standard vehicle</strong>
<strong class="bold">Vehicle, move</strong>
<strong class="bold">Drive a tuned vehicle</strong>
<strong class="bold">SportVehicle, activate horse power:200</strong>
<strong class="bold">TunedVehicleDecorator, turbo on</strong>
<strong class="bold">Vehicle, move</strong></pre>
			<p class="SC---Link" lang="en-US" xml:lang="en-US">Example 4.8 – The tuned car abstraction extends the features of the SportVehicle type by adding more horsepower (200)</p>
			<p>The decorator pattern may be introduced<a id="_idIndexMarker331"/> in multiple ways. In the presented example, <strong class="source-inline">TunedVehicleDecorator</strong> is an abstract class that holds the reference to the vehicle. The <strong class="source-inline">SportVehicle</strong> instance extends newly implemented functionality (<span class="No-Break"><em class="italic">Example 4.9)</em></span><span class="No-Break">:</span></p>
			<pre class="source-code">
sealed abstract class TunedVehicleDecorator implements
    Vehicle permits SportV<a id="_idTextAnchor206"/>ehicle {
    private final Vehicle vehicle;
    TunedVehicleDecorator(Vehicle vehicle) {
        this.vehicle = vehicle;
    }
    @Override
    public void move() {
        System.out.println("TunedVehicleDecorator,
           turbo on");
        vehicle.move();
    }
}
final class SportVehicle extends TunedVehicleDecorator {
    private final int horsePower;
    public SportVehicle(Vehicle vehicle, int horsePower) {
        super(vehicle);
        this.horsePower = horsePower;
    }
    @Override
    public void move() {
        System.out.println("SportVehicle, activate horse
            power:" + horsePower);
        super.move();
    }
}</pre>
			<p class="SC---Link" lang="en-US" xml:lang="en-US">Example 4.9 – Decorator wraps the Vehicle instance and extends its functionality</p>
			<h2 id="_idParaDest-144"><a id="_idTextAnchor207"/>Conclusion</h2>
			<p>Class decoration<a id="_idIndexMarker332"/> can be very useful in many cases during application development. The decorator pattern can be used to migrate application logic where previous functionalities should remain hidden or unwanted subclassing should be avoided. The example showed how sealed classes can contribute to code maintainability and comprehensibility. Decoration helps not only to add new features but also to remove obsolete features. The decorator pattern is a transparent way to modify an object without disrupting the <span class="No-Break">current interface.</span></p>
			<p>Sometimes it makes sense to use the decorator pattern together with another design pattern we’ll examine – the <span class="No-Break">façade pattern.</span></p>
			<h1 id="_idParaDest-145"><a id="_idTextAnchor208"/>Simplifying communication with the facade pattern</h1>
			<p>Th<a id="_idTextAnchor209"/>e facade pattern<a id="_idIndexMarker333"/> provides a unified interface to a set of underlying<a id="_idIndexMarker334"/> subsystems. In other words, a facade defines a higher-level interface that facilitates use. The facade pattern was described by <span class="No-Break">the GoF.</span></p>
			<h2 id="_idParaDest-146"><a id="_idTextAnchor210"/>Motivation</h2>
			<p>As subsystems evolve, they often become<a id="_idIndexMarker335"/> more complex. Most patterns, when used, result in smaller classes, thus making the subsystem more reusable and easier to customize, but also making it more difficult for all clients to work with. The facade pattern provides a simple default view of the subsystem that is good enough for most clients. Only clients who need more customizations will need to look beyond the <span class="No-Break">façade pattern.</span></p>
			<h2 id="_idParaDest-147"><a id="_idTextAnchor211"/>Finding it in the JDK</h2>
			<p>The Java collections framework<a id="_idIndexMarker336"/> resides in the <strong class="source-inline">java.base</strong> module and <strong class="source-inline">java.util</strong> has already been mentioned several times. It is a widely used part of the JDK, especially for internal logic implementation. Interfaces such as <strong class="source-inline">List</strong>, <strong class="source-inline">Set</strong>, <strong class="source-inline">Queue</strong>, <strong class="source-inline">Map</strong>, and <strong class="source-inline">Enumeration</strong> can be considered facades of a particular implementation. Let us review the <strong class="source-inline">List</strong> interface in more detail. It is implemented by the commonly used <strong class="source-inline">ArrayList</strong> or <strong class="source-inline">LinkedList</strong> classes and others. Implementation specifics vary in detail, some of which were mentioned in <a href="B18884_02.xhtml#_idTextAnchor037"><span class="No-Break"><em class="italic">Chapter 2</em></span></a>, <em class="italic">Discovering the Java Platform for Design Patterns</em> (<em class="italic">Tables 2.3</em>, <em class="italic">2.4</em>, <span class="No-Break">and </span><span class="No-Break"><em class="italic">2.5</em></span><span class="No-Break">).</span></p>
			<h2 id="_idParaDest-148"><a id="_idTextAnchor212"/>Sample code</h2>
			<p>The facade pattern is a frequently<a id="_idIndexMarker337"/> used design pattern in software engineering and is easily presented. Consider a case where a driver obtains their driving license for a vehicle. The driver’s license entitles them to drive both gasoline and diesel cars and, of course, to refuel them. The driver gets both types as a reward (<span class="No-Break"><em class="italic">Example 4.10</em></span><span class="No-Break">):</span></p>
			<pre class="source-code">
public static void main(String[] args) {
    System.out.println("Pattern Facade, vehicle types");
    List&lt;Vehicle&gt; vehicles = Arrays.asList(new
        DieselVehicle(), new PetrolVehicle());
    for (var vehicle: vehicles){
        vehicle.start();
        vehicle.refuel();
    }
}</pre>
			<p>Here’s <span class="No-Break">the</span><span class="No-Break"><a id="_idIndexMarker338"/></span><span class="No-Break"> output:</span></p>
			<pre class="source-code">
<strong class="bold">Pattern Facade, vehicle types</strong>
<strong class="bold">DieselVehicle, engine warm up</strong>
<strong class="bold">DieselVehicle, engine start</strong>
<strong class="bold">DieselVehicle, refuel diesel</strong>
<strong class="bold">PetrolVehicle, engine start</strong>
<strong class="bold">PetrolVehicle, refuel petrol</strong></pre>
			<p class="SC---Link" lang="en-US" xml:lang="en-US">Example 4.10 – The facade pattern promotes a standardized control interface</p>
			<p>Consolidating vehicle types has a positive impact on code structure that is easy to implement (<span class="No-Break"><em class="italic">Figure 4</em></span><span class="No-Break"><em class="italic">.5</em></span><span class="No-Break">):</span></p>
			<div>
				<div id="_idContainer051" class="IMG---Figure">
					<img src="image/B18884_04_05.jpg" alt="Figure 4.5 – The UML class diagram of the facade pattern usage for Vehicle implementations"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.5 – The UML class diagram of the facade pattern usage for Vehicle implementations</p>
			<h2 id="_idParaDest-149"><a id="_idTextAnchor213"/>Conclusion</h2>
			<p>The heavy use of the facade pattern<a id="_idIndexMarker339"/> makes it a good candidate to consider at any stage of application development. It promotes not only the principle of interface segregation but the entire SOLID concept. It helps implement internal dependencies while remaining customizable and maintainable. Facade helps introduce loose coupling and separates clients, forcing the removal of unwilling dependencies. The facade pattern naturally supports the horizontal scaling of the source code. Although the facade pattern provides a lot of benefits, misuse caused by unmaintained source code can turn into unwanted state. The solution is to re-evaluate the current implementation and apply improvements according to the <span class="No-Break">SOLID principles.</span></p>
			<p>Next, we’ll examine how to select the correct object from a collection based on <span class="No-Break">a rule.</span></p>
			<h1 id="_idParaDest-150"><a id="_idTextAnchor214"/>Using conditions to select desired objects with the filter pattern</h1>
			<p>The filter pattern – sometimes<a id="_idIndexMarker340"/> called the criteria<a id="_idIndexMarker341"/> pattern – is a design pattern<a id="_idIndexMarker342"/> that allows clients to filter a set of objects using different criteria, or rules, and chain them separately using <span class="No-Break">logical operations.</span></p>
			<h2 id="_idParaDest-151"><a id="_idTextAnchor215"/>Motivation</h2>
			<p>The filter pattern<a id="_idIndexMarker343"/> helps simplify the code base to work like container objects that use subtyping instead of parameterization (generics) for an extensible class structure. It allows the client to easily extend and expose the filtering capability of container-like objects. Different filtering conditions can be dynamically added or removed without notifying <span class="No-Break">the client.</span></p>
			<h2 id="_idParaDest-152"><a id="_idTextAnchor216"/>Finding it in the JDK</h2>
			<p>Let us consider a filter<a id="_idIndexMarker344"/> as an interface with a single function and a logical Boolean result. A nice example of the filter pattern is the <strong class="source-inline">Predicate</strong> class, found in the <strong class="source-inline">java.base</strong> module and the <strong class="source-inline">java.util.function</strong> package. <strong class="source-inline">Predicate</strong> represents a Boolean function and is intended for use in the <em class="italic">Java Stream API</em> (discussed earlier, in <a href="B18884_02.xhtml#_idTextAnchor037"><span class="No-Break"><em class="italic">Chapter 2</em></span></a>, <em class="italic">Discovering the Java Platform for Design Patterns</em>), more specifically in the <strong class="source-inline">filter</strong> method, which accepts a predicate and returns a true or <span class="No-Break">false primitive.</span></p>
			<h2 id="_idParaDest-153"><a id="_idTextAnchor217"/>Sample code</h2>
			<p>A nice example of using the filter pattern<a id="_idIndexMarker345"/> would be an application that requires the selection of desired sensors in a vehicle. Every vehicle these days contains a huge number of sensors, so it can be difficult for a client to research each one individually (<span class="No-Break"><em class="italic">Example 4.11</em></span><span class="No-Break">):</span></p>
			<pre class="source-code">
private static final List&lt;Sensor&gt; vehicleSensors = new
    ArrayList&lt;&gt;();
static {
    vehicleSensors.add(new Sensor("fuel", true));
    vehicleSensors.add(new Sensor("fuel", false));
    vehicleSensors.add(new Sensor("speed", false));
    vehicleSensors.add(new Sensor("speed", true));
}
public static void main(String[] args) {
    ...
    Rule analog = new RuleAnalog();
    Rule speedSensor = new RuleType("speed");
    ...
    var analogAndSpeedSensors = new RuleAnd(analog,
        speedSensor);
    var analogOrSpeedSensors = new RuleOr(analog,
        speedSensor);
    System.out.println("analogAndSpeedSensors=" +
        analogAndSpeedSensors.validateSensors
            (vehicleSensors));
    System.out.println("analogOrSpeedSensors=" +
          analogOrSpeedSensors.validateSensors
              (vehicleSensors));
}</pre>
			<p>Here’s <span class="No-Break">the</span><span class="No-Break"><a id="_idIndexMarker346"/></span><span class="No-Break"> output:</span></p>
			<pre class="source-code">
<strong class="bold">Pattern Filter, vehicle sensors</strong>
<strong class="bold">AnalogSensors: [Sensor[type=fuel, analog=true],</strong>
<strong class="bold">    Sensor[type=speed, analog=true]]</strong>
<strong class="bold">SpeedSensors: [Sensor[type=speed, analog=false],</strong>
<strong class="bold">    Sensor[type=speed, analog=true]]</strong>
<strong class="bold">analogAndSpeedSensors=[Sensor[type=speed, analog=true]]</strong>
<strong class="bold">analogOrSpeedSensors=[Sensor[type=fuel, analog=true],</strong>
<strong class="bold">    Sensor[type=speed, analog=true], Sensor[type=speed,</strong>
<strong class="bold">        analog=false]]</strong></pre>
			<p class="SC---Link" lang="en-US" xml:lang="en-US">Example 4.11 – Chaining a particular group of vehicle sensors with the filter pattern is simple and transparent</p>
			<p>Let’s draw an example (<span class="No-Break"><em class="italic">Figure 4</em></span><span class="No-Break"><em class="italic">.6</em></span><span class="No-Break">):</span></p>
			<div>
				<div id="_idContainer052" class="IMG---Figure">
					<img src="image/B18884_04_06.jpg" alt="Figure 4.6 – The UML class diagram of possible rules used by the container to select the proper Sensor instance"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.6 – The UML class diagram of possible rules used by the container to select the proper Sensor instance</p>
			<p>The <strong class="source-inline">Rule</strong> interface fulfills<a id="_idIndexMarker347"/> the expectation of the functional interface as it contains only one method, <strong class="source-inline">validateSensors</strong>. It also means that the compiler treats and optimizes the <strong class="source-inline">Rule</strong> interfaces like other annotated functional interfaces. Each rule can contain a specific implementation (<span class="No-Break"><em class="italic">Example 4.12</em></span><span class="No-Break">):</span></p>
			<pre class="source-code">
@FunctionalInterface
interface Rule {
    Collection&lt;Sensor&gt; validateSensors(Collection&lt;Sensor&gt;
        sensors);
}
class RuleAnalog implements Rule {
    @Override
    public Collection&lt;Sensor&gt; validateSensors
        (Collection&lt;Sensor&gt; sensors) {
        return sensors.stream()
                .filter(Sensor::analog)
                .collect(Collectors.toList());
    }
}
record RuleAnd(Rule rule, Rule additionalRule) implements
    Rule {
    @Override
    public Collection&lt;Sensor&gt; validateSensors
        (Collection&lt;Sensor&gt; sensors) {
        Collection&lt;Sensor&gt; initRule = rule.validateSensors
            (sensors);
        return additionalRule.validateSensors(initRule);
    }
}</pre>
			<p class="SC---Link" lang="en-US" xml:lang="en-US">Example 4.12 – Rules can contain trivial logic such as RuleAnalog, or advanced logic, such as RuleAnd, with respect to other rules running in the decision process</p>
			<p>The sample application<a id="_idIndexMarker348"/> can be easily extended with any additional, more complex rule through a transparently <span class="No-Break">defined interface.</span></p>
			<h2 id="_idParaDest-154"><a id="_idTextAnchor218"/>Conclusion</h2>
			<p>Filtering or better selection<a id="_idIndexMarker349"/> of the correct instances may be required in places such as joining different request types or database results present in the Java heap. The filter pattern has shown its flexibility and that each rule can be developed independently, that is, optimized without the involvement of others, which makes it a suitable candidate when a client needs to work with <span class="No-Break">container structures.</span></p>
			<p>The next pattern represents a possible way to reduce the memory footprint by <span class="No-Break">sharing instances.</span></p>
			<h1 id="_idParaDest-155"><a id="_idTextAnchor219"/>Sharing objects across an application with the flyweight pattern</h1>
			<p>The flyweight pattern<a id="_idIndexMarker350"/> is used to minimize memory usage<a id="_idIndexMarker351"/> or computational cost by sharing as much as possible with similar objects. The flyweight pattern was described by the GoF <span class="No-Break">author group.</span></p>
			<h2 id="_idParaDest-156"><a id="_idTextAnchor220"/>Motivation</h2>
			<p>When a newly developed application<a id="_idIndexMarker352"/> uses many objects that are not required by the client. Memory maintenance costs can be high not only because of the large number of instances but also because of the creation of a new object. In many cases, such groups of objects can be successfully replaced by a relatively small number of instances. These instances can be transparently shared between the desired clients. This will reduce the pressure on the garbage collection algorithm. In addition, an application can reduce the number of open sockets when instances use such <span class="No-Break">communication types.</span></p>
			<h2 id="_idParaDest-157"><a id="_idTextAnchor221"/>Finding it in the JDK</h2>
			<p>The flyweight pattern<a id="_idIndexMarker353"/> can easily be found in the JDK. It may not be obvious to many. For example, in the implementation of primitive wrapper types, the <strong class="source-inline">java.base</strong> module and the <strong class="source-inline">java.lang</strong> package use this pattern to reduce memory overhead. A pattern is particularly useful when an application needs to handle many repeated values. Classes such as <strong class="source-inline">Integer</strong>, <strong class="source-inline">Byte</strong>, and <strong class="source-inline">Character</strong> provide a <strong class="source-inline">valueOf</strong> method, and its implementation uses an internal cache to store <span class="No-Break">repeated </span><span class="No-Break"><a id="_idIndexMarker354"/></span><span class="No-Break">elements.</span></p>
			<h2 id="_idParaDest-158"><a id="_idTextAnchor222"/>Sample code</h2>
			<p>Let us examine an example case<a id="_idIndexMarker355"/> where a garage continually hires out specific vehicle types. The garage contains some vehicles that can be hired. Each has already prepared vehicle documents by default. When another vehicle is required, the new document is put into the system on demand (<span class="No-Break"><em class="italic">Example 4.13</em></span><span class="No-Break">):</span></p>
			<pre class="source-code">
public static void main(String[] args) {
    System.out.println("Pattern Flyweight, sharing
        templates");
    Vehicle car1 = VehicleGarage.borrow("sport");
    car1.move();
    Vehicle car2 = VehicleGarage.borrow("sport");
    System.out.println("Similar template:" +
        (car1.equals(car2)));
}</pre>
			<p>Here’s <span class="No-Break">the output:</span></p>
			<pre class="source-code">
<strong class="bold">Pattern Flyweight, sharing vehicles</strong>
<strong class="bold">VehicleGarage, borrowed type:sport</strong>
<strong class="bold">Vehicle, type:'sport-car', confirmed</strong>
<strong class="bold">VehicleGarage, borrowed type:sport</strong>
<strong class="bold">Similar template: true</strong></pre>
			<p class="SC---Link" lang="en-US" xml:lang="en-US">Example 4.13 – Sharing a template with the flyweight pattern is transparent and does not pollute memory</p>
			<p>The heart of our next example (<em class="italic">Example 4.14</em>) is the implementation of <strong class="source-inline">VehicleGarage</strong>, which contains<a id="_idIndexMarker356"/> the cache for storing <span class="No-Break">registration templates:</span></p>
			<pre class="source-code">
class VehicleGarage {
    private static final Map&lt;String, Vehicle&gt; vehicleByType
        = new HashMap&lt;&gt;();
    static {
        vehicleByType.put("common", new VehicleType
            ("common-car"));
        vehicleByType.put("sport", new VehicleType("sport-
            car"));
    }
    private VehicleGarage() {
    }
    static Vehicle borrow(String type){
        Vehicle v = vehicleByType.get(type);
        if(v == null){
            v =  new VehicleType(type);
            vehicleByType.put(type, v);
        }
        System.out.println("VehicleGarage, borrowed type:"
            + type);
        return v;
    }
}</pre>
			<p class="SC---Link" lang="en-US" xml:lang="en-US">Example 4.14 – The VehicleGarage implementation allows you to add a missing type on demand in order to control template size</p>
			<p>The following example diagram<a id="_idIndexMarker357"/> shows that the client is not aware of the <strong class="source-inline">VehicleType</strong> class because it is not required (<span class="No-Break"><em class="italic">Figure 4</em></span><span class="No-Break"><em class="italic">.7</em></span><span class="No-Break">):</span></p>
			<div>
				<div id="_idContainer053" class="IMG---Figure">
					<img src="image/B18884_04_07.jpg" alt="Figure 4.7 – The UML class diagram shows which classes VehicleGarage requires"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.7 – The UML class diagram shows which classes VehicleGarage requires</p>
			<h2 id="_idParaDest-159"><a id="_idTextAnchor223"/>Conclusion</h2>
			<p>The big advantage of the flyweight pattern<a id="_idIndexMarker358"/> is the ability to administrate a large number of requests for the required objects. It instantiates objects on demand and allows you to obtain control over the present instances. The application does not need to depend on the identity (<strong class="source-inline">hashCode</strong> and <strong class="source-inline">equals</strong>) of the object. The flyweight pattern provides a transparent way to obtain access to the object and its implementation enforces the SOLID design concept and <span class="No-Break">DRY approach.</span></p>
			<p>The next section describes how to consolidate incoming requests in a <span class="No-Break">controlled manner.</span></p>
			<h1 id="_idParaDest-160"><a id="_idTextAnchor224"/>Handling requests with the front-controller pattern</h1>
			<p>The goal of the pattern<a id="_idIndexMarker359"/> is to create a common service for most of the client<a id="_idIndexMarker360"/> requirements. The pattern defines a procedure that allows common functions such as authentication, security, custom manipulation, and logging to be encapsulated at a <span class="No-Break">single location.</span></p>
			<h2 id="_idParaDest-161"><a id="_idTextAnchor225"/>Motivation</h2>
			<p>This pattern is commonly<a id="_idIndexMarker361"/> seen within web applications. It implements and defines the standard handler used by the controller. It is the handler’s responsibility to evaluate the validity of all incoming requests, although the handler itself may be available in many incarnations at runtime. The code is encapsulated in one place and referenced by <span class="No-Break">the clients.</span></p>
			<h2 id="_idParaDest-162"><a id="_idTextAnchor226"/>Finding it in the JDK</h2>
			<p>Usage of the front-controller pattern<a id="_idIndexMarker362"/> can be found in the <strong class="source-inline">jdk.httpserver</strong> module, the <strong class="source-inline">sun.net.httpserver</strong> package, and the <strong class="source-inline">HttpServer</strong> abstract class. The class implements the <strong class="source-inline">createContext</strong> abstract method, which accepts the <strong class="source-inline">HttpHander</strong> interface. Handler instances participate in HTTP request processing by executing the handler method. The release of JDK 18 comes with the <strong class="source-inline">SimpleFileServer</strong> wrapper of the underlying <strong class="source-inline">HttpServer</strong> implementations, available also as the standalone command <strong class="source-inline">jwebserver</strong> (<em class="italic">JEP-408: Simple </em><span class="No-Break"><em class="italic">Web Server</em></span><span class="No-Break">).</span></p>
			<h2 id="_idParaDest-163"><a id="_idTextAnchor227"/>Sample code</h2>
			<p>Let us create a simple theoretical<a id="_idIndexMarker363"/> example not focused on parsing the web request (<span class="No-Break"><em class="italic">Example 4.15</em></span><span class="No-Break">):</span></p>
			<pre class="source-code">
public static void main(String[] args) {
    System.out.println("Pattern FrontController, vehicle
        system");
    var vehicleController = new VehicleController();
    vehicleController.processRequest("engine");
    vehicleController.authorize();
    vehicleController.processRequest("engine");
    vehicleController.processRequest("brakes");
}</pre>
			<p>Here’s <span class="No-Break">the</span><span class="No-Break"><a id="_idIndexMarker364"/></span><span class="No-Break"> output:</span></p>
			<pre class="source-code">
<strong class="bold">Pattern FrontController, vehicle system</strong>
<strong class="bold">VehicleController, log:'engine'</strong>
<strong class="bold">VehicleController, is authorized</strong>
<strong class="bold">VehicleController, not authorized request:'engine'</strong>
<strong class="bold">VehicleController, authorization</strong>
<strong class="bold">VehicleController, log:'engine'</strong>
<strong class="bold">VehicleController, is authorized</strong>
<strong class="bold">EngineUnit, start</strong>
<strong class="bold">VehicleController, log:'brakes'</strong>
<strong class="bold">VehicleController, is authorized</strong>
<strong class="bold">BrakesUnit, activated</strong></pre>
			<p class="SC---Link" lang="en-US" xml:lang="en-US">Example 4.15 – The vehicle system uses the front-controller pattern to process incoming commands</p>
			<p>Imagine that vehicles contain a controller that is responsible for controlling brakes and motor units. All incoming commands are processed in this controller (<span class="No-Break"><em class="italic">Figure 4</em></span><span class="No-Break"><em class="italic">.8</em></span><span class="No-Break">):</span></p>
			<div>
				<div id="_idContainer054" class="IMG---Figure">
					<img src="image/B18884_04_08.jpg" alt="Figure 4.8 – The front-controller pattern enforces a loose coupling of the controller and dispatcher"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.8 – The front-controller pattern enforces a loose coupling of the controller and dispatcher</p>
			<p>The <strong class="source-inline">VehicleController</strong> object requires<a id="_idIndexMarker365"/> an instance of a specific handler. A handler is defined by an instance of the <strong class="source-inline">RequestDispatcher</strong> class (<span class="No-Break"><em class="italic">Example 4.16</em></span><span class="No-Break">):</span></p>
			<pre class="source-code">
record RequestDispatcher(BrakesUnit brakesUnit, EngineUnit
    engineUnit) {
    void dispatch(String command) {
        switch (command.toLowerCase()) {
            case "engine" -&gt; engineUnit.start();
            case "brakes" -&gt; brakesUnit.activate();
            default -&gt; throw new IllegalArgumentException
                ("not implemented:" + command);
        }
    }
}
class VehicleController {
    private final RequestDispatcher dispatcher;
    ...
    void processRequest(String request) {
        logRequest(request);
        if (isAuthorized()) {
            dispatcher.dispatch(request);
        } else {
            System.out.printf("""
                VehicleController, not authorized request:
                    '%s'%n""", request);
        }
    }
}</pre>
			<p class="SC---Link" lang="en-US" xml:lang="en-US">Example 4.16 – The request handler representation RequestDispatcher instance needs to be injected into VehicleController</p>
			<p>Both the <strong class="source-inline">BrakesUnit</strong> and <strong class="source-inline">EngineUnit</strong> classes<a id="_idIndexMarker366"/> are separated from the handling or control logic and can be <span class="No-Break">developed independently.</span></p>
			<h2 id="_idParaDest-164"><a id="_idTextAnchor228"/>Conclusion</h2>
			<p>The main use of the front-controller<a id="_idIndexMarker367"/> pattern is in web frameworks, in addition to encapsulating requests for handling requests and increasing the portability of different types of handlers. These tools only need to be properly registered and run at runtime. Based on the implementation, the pattern supports dynamic handling behavior without the requirement to replace the class at runtime. The front-controller pattern introduces a centralized mechanism for processing <span class="No-Break">incoming information.</span></p>
			<p>Software design sometimes requires the dissemination of specific information for a group<a id="_idIndexMarker368"/> of classes. For such purposes, tagging is well worth considering. Let’s dive deeper into it in the <span class="No-Break">next section.</span></p>
			<h1 id="_idParaDest-165"><a id="_idTextAnchor229"/>Identifying instances using the marker pattern</h1>
			<p>This pattern is extremely useful<a id="_idIndexMarker369"/> in identifying instances at runtime<a id="_idIndexMarker370"/> for specific treatment, such as triggering the desired action when an instance <span class="No-Break">is available.</span></p>
			<h2 id="_idParaDest-166"><a id="_idTextAnchor230"/>Motivation</h2>
			<p>The marker interface pattern <a id="_idIndexMarker371"/>represents an empty interface. Such an interface is used to identify a special group of classes at runtime. Because of this fact, the maker pattern<a id="_idIndexMarker372"/> is sometimes called tagging, as its sole purpose is to distinguish a special type of instance. The application thus provides the possibility to use special handling for such cases at runtime. Logic can be separated and properly encapsulated. Because annotation represents a special form of interface, Java implements the marker interface in two ways – a class can inherit from an interface or <span class="No-Break">be annotated.</span></p>
			<h2 id="_idParaDest-167"><a id="_idTextAnchor231"/>Finding it in the JDK</h2>
			<p>A clearer example of using the marker <a id="_idIndexMarker373"/>interface in the JDK can be found in the <strong class="source-inline">java.base</strong> module. The <strong class="source-inline">java.io</strong> package defines the <strong class="source-inline">Serializable</strong> interface and the <strong class="source-inline">java.lang</strong> package provides the <strong class="source-inline">Cloneable</strong> interface. Both do not implement any method, and both are used to inform the runtime about special handling. The <strong class="source-inline">Serializable</strong> interface is important during the serialization and deserialization processes (the <strong class="source-inline">writeObject</strong> and <strong class="source-inline">readObject</strong> methods), where each nested field requires an interface implementation to obtain the state of the instance while traversing the object graph. In a similar way, the <strong class="source-inline">Cloneable</strong> interface informs the JVM that the <strong class="source-inline">Object.clone()</strong> method is being used and it can create a field-to-field copy of the object. It is good to be aware of the field differences. The primitive types provide values but object-only references. It means that objects require an implementation of the <strong class="source-inline">Cloneable</strong> interface to provide <span class="No-Break">a copy.</span></p>
			<h2 id="_idParaDest-168"><a id="_idTextAnchor232"/>Sample code</h2>
			<p>Let us draw a simple real-world example<a id="_idIndexMarker374"/> where a vehicle contains multiple sensors (<span class="No-Break"><em class="italic">Figure 4</em></span><span class="No-Break"><em class="italic">.9</em></span><span class="No-Break">):</span></p>
			<div>
				<div id="_idContainer055" class="IMG---Figure">
					<img src="image/B18884_04_09.jpg" alt="Figure 4.9 – UML class diagram of certified sensor tags (CertifiedSensor and CertifiedAnnotation) using the marker interface pattern"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.9 – UML class diagram of certified sensor tags (CertifiedSensor and CertifiedAnnotation) using the marker interface pattern</p>
			<p>The vehicle controller needs to identify special groups of the sensors that are certified for delivering specific information (<span class="No-Break"><em class="italic">Example 4.17</em></span><span class="No-Break">):</span></p>
			<pre class="source-code">
public static void main(String[] args) {
    System.out.println("Pattern Marker, sensor
        identification");
    var sensors = Arrays
            .asList(new BrakesSensor(), new EngineSensor()
                    , new ConsumptionSensor());
    sensors.forEach(sensor -&gt; {
        if(sensor.getClass().isAnnotationPresent
            (CertifiedAnnotation.class)){
            System.out.println("Sensor with Marker
                annotation:" + sensor);
        } else {
            switch (sensor){
                case CertifiedSensor cs -&gt; System.out.
                    println("Sensor with Marker interface:
                        " + cs);
                case Sensor s -&gt; System.out.println
                    ("Sensor without identification:"+ s);
            }
        }
    });
}</pre>
			<p>Here is <span class="No-Break">the</span><span class="No-Break"><a id="_idIndexMarker375"/></span><span class="No-Break"> output:</span></p>
			<pre class="source-code">
<strong class="bold">Pattern Marker, sensor identification</strong>
<strong class="bold">Sensor without identification:BrakesSensor[]</strong>
<strong class="bold">Sensor with Marker interface:chapter04.marker</strong>
<strong class="bold">  .EngineSensor@776ec8df</strong>
<strong class="bold">Sensor with Marker annotation:chapter04.marker</strong>
<strong class="bold">  .ConsumptionSensor@30dae81</strong></pre>
			<p class="SC---Link" lang="en-US" xml:lang="en-US">Example 4.17 – The marker interface pattern for sensor identification using the switch pattern-matching construct</p>
			<p>This example introduced both types of pattern usage. It defines the <strong class="source-inline">CertifiedAnnotation</strong> and <span class="No-Break"><strong class="source-inline">CertifiedSensor</strong></span><span class="No-Break"> interface.</span></p>
			<p>To group all sensor kinds during the implementation, the <strong class="source-inline">Sensor</strong> interface is used (<span class="No-Break"><em class="italic">Example 4.18</em></span><span class="No-Break">):</span></p>
			<pre class="source-code">
@Retention(RetentionPolicy.RUNTIME)
@interface CertifiedAnnotation {}
public interface CertifiedSensor extends Sensor {}
public interface Sensor {
    void activate();
}</pre>
			<p class="SC---Link" lang="en-US" xml:lang="en-US">Example 4.18 – Implementation of the tagging interfaces CertifiedAnnotation and CertifiedSensor, and Sensor abstraction with methods</p>
			<p>Using tags is trivial. A class<a id="_idIndexMarker376"/> must be annotated or inherit the marker interface (<span class="No-Break"><em class="italic">Example 4.19</em></span><span class="No-Break">):</span></p>
			<pre class="source-code">
@CertifiedAnnotation
class ConsumptionSensor implements Sensor {
    @Override
    public void activate() {...}
}
final class EngineSensor implements CertifiedSensor {
    @Override
    public void activate() {...}
}</pre>
			<p class="SC---Link" lang="en-US" xml:lang="en-US">Example 4.19 – Marker usage for the sensor identification</p>
			<h2 id="_idParaDest-169"><a id="_idTextAnchor233"/>Conclusion</h2>
			<p>The marker interface pattern<a id="_idIndexMarker377"/> can be a powerful tool at runtime, but it must be used wisely as it can have some drawbacks. One is that the purpose of using the marker pattern may be forgotten, or it may become obsolete as the application evolves. The second is the implementation of special handling logic. Distributing such logic can negatively affect application behavior. On the other hand, a marker interface can simplify application logic, and in many cases, an interface is preferred over an annotation<a id="_idIndexMarker378"/> because it is <span class="No-Break">more traceable.</span></p>
			<p>Let us introduce a vehicle unit’s modularity in the <span class="No-Break">next pattern.</span></p>
			<h1 id="_idParaDest-170"><a id="_idTextAnchor234"/>Exploring the concept of modules with the module pattern</h1>
			<p>This pattern implements<a id="_idIndexMarker379"/> the concept of software modules defined by modular programming. The pattern is used in cases where the programming language does not have direct support for such a concept or the application <span class="No-Break">requires it.</span></p>
			<h2 id="_idParaDest-171"><a id="_idTextAnchor235"/>Motivation</h2>
			<p>This pattern can be implemented<a id="_idIndexMarker380"/> in several ways depending on the application requirements. The module pattern concentrates or encapsulates the composition of an application’s functionality into precisely identified modules. The Java platform has already implemented basic support for the module concept through the Jigsaw project, available since the release of JDK 9, but it is possible to try to create it programmatically in a similar way, although not entirely in isolation, as the source code can influence its <span class="No-Break">modularization approach.</span></p>
			<h2 id="_idParaDest-172"><a id="_idTextAnchor236"/>Finding it in the JDK</h2>
			<p>The best example that can<a id="_idIndexMarker381"/> be found in the JDK of the module pattern is the Java platform modules. This concept was discussed in great detail in <a href="B18884_02.xhtml#_idTextAnchor037"><span class="No-Break"><em class="italic">Chapter 2</em></span></a>, <em class="italic">Discovering the Java Platform for Design Patterns</em>, in the <em class="italic">Getting to grips with the Java Module </em><span class="No-Break"><em class="italic">System</em></span><span class="No-Break"> section.</span></p>
			<h2 id="_idParaDest-173"><a id="_idTextAnchor237"/>Sample code</h2>
			<p>Let us imagine a vehicle<a id="_idIndexMarker382"/> that need to have isolated brakes and engine systems. This is pretty much<a id="_idTextAnchor238"/> according to a real-world scenario. Each module will operate independently, and only one provider is present at runtime. Before the vehicle can be used, both modules need to be activated (<span class="No-Break"><em class="italic">Example 4.20</em></span><span class="No-Break">):</span></p>
			<pre class="source-code">
class ModuleMain {
    ...
    private static void initModules() {
        brakesModule = BrakesModule.getInstance();
        engineModule = EngineModule.getInstance();
        engineModule.init();
    }
    ...
    public static void main(String[] args) {
        initModules();
        printStatus();
    }
}</pre>
			<p>Here’s <span class="No-Break">the</span><span class="No-Break"><a id="_idIndexMarker383"/></span><span class="No-Break"> output:</span></p>
			<pre class="source-code">
<strong class="bold">BrakesModule, unit:BrakesModule@5ca881b5</strong>
<strong class="bold">EngineModule, unit:EngineModule@4517d9a3</strong>
<strong class="bold">EngineModule, init</strong>
<strong class="bold">BrakesModule, ready:false</strong>
<strong class="bold">EngineModule, ready:true</strong></pre>
			<p class="SC---Link" lang="en-US" xml:lang="en-US">Example 4.20 – The client function initModules activates the modules correctly in encapsulation</p>
			<p>The following diagram emphasizes the separation of modules, although the programmatic approach allows sharing or implementing shared abstractions (<span class="No-Break"><em class="italic">Figure 4</em></span><span class="No-Break"><em class="italic">.10</em></span><span class="No-Break">):</span></p>
			<div>
				<div id="_idContainer056" class="IMG---Figure">
					<img src="image/B18884_04_10.jpg" alt="Figure 4.10 – UML class diagram showing a pattern implementation realized by the provided VehicleModule interface"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.10 – UML class diagram showing a pattern implementation realized by the provided VehicleModule interface</p>
			<p>Each module is represented<a id="_idIndexMarker384"/> as a singleton instance in order to ensure only one instance provides a transparent gateway to access the <span class="No-Break">module functionality:</span></p>
			<pre class="source-code">
class EngineModule implements VehicleModule {
    private static volatile EngineModule INSTANCE;
    static EngineModule getInstance() {
       ...
        return INSTANCE;
    }
    private boolean ready;
     ...
    @Override
    public void init() {...}
    @Override
    public void status() {...}
}</pre>
			<p class="SC---Link" lang="en-US" xml:lang="en-US">Example 4.21 – The EngineModule and BrakesModule example implementations are represented by singletons and have a similar structure</p>
			<h2 id="_idParaDest-174"><a id="_idTextAnchor239"/>Conclusion</h2>
			<p>The module pattern<a id="_idIndexMarker385"/> introduces structure to the source code in a very transparent way. Each module can be developed independently without influence. Because a programmatic solution may not fully enforce source code isolation, it is necessary to extend modules wisely. Another drawback may be module initialization, as a singleton may not be an acceptable solution. On the other hand, the module pattern provides a workflow to develop a source code with all SOLID concepts <span class="No-Break">in mind.</span></p>
			<p>What about using proxies instead of modules and implementations? Let us dive deeper in the <span class="No-Break">next section.</span></p>
			<h1 id="_idParaDest-175"><a id="_idTextAnchor240"/>Providing a placeholder for an object using the proxy pattern</h1>
			<p>The proxy pattern<a id="_idIndexMarker386"/> is considered a placeholder that manages<a id="_idIndexMarker387"/> access to another object in order to gain control of it. The pattern may also be known by the name surrogate. The proxy pattern was described by <span class="No-Break">the GoF.</span></p>
			<h2 id="_idParaDest-176"><a id="_idTextAnchor241"/>Motivation</h2>
			<p>In its most general form, a proxy<a id="_idIndexMarker388"/> is a class acting as an interface to the client. A proxy is considered a wrapper or agent ob<a id="_idTextAnchor242"/>ject that is used by a client. The client accesses the actual object through the same interface and the actual implementation stays hidden from the client in the bac<a id="_idTextAnchor243"/>kground<a id="_idTextAnchor244"/>. Communication between the client and the implementation remains transparent, thanks to the <span class="No-Break">proxy pattern.</span></p>
			<p>By using a proxy, the client can access the actual object, or it can provide <span class="No-Break">additional logic.</span></p>
			<h2 id="_idParaDest-177"><a id="_idTextAnchor245"/>Finding it in the JDK</h2>
			<p>The proxy design pattern<a id="_idIndexMarker389"/> also has a place in the JDK. The most well-known one is the public <strong class="source-inline">Proxy</strong> class, which you can find in the <strong class="source-inline">java.reflect</strong> package of the <strong class="source-inline">java.base</strong> module. The <strong class="source-inline">Proxy</strong> class provides several static methods for creating objects used for <span class="No-Break">method invocation.</span></p>
			<h2 id="_idParaDest-178"><a id="_idTextAnchor246"/>Sample code</h2>
			<p>The given example<a id="_idIndexMarker390"/> can be considered as the remote control of a vehicle. A controller, represented by a proxy design pattern, provides exactly the same functionality as a real vehicle, also managing the connection between the real vehicle instance (<span class="No-Break"><em class="italic">Example 4.22</em></span><span class="No-Break">):</span></p>
			<pre class="source-code">
public static void main(String[] args) {
    System.out.println("Pattern Proxy, remote vehicle
        controller");
    Vehicle vehicle = new VehicleProxy();
    vehicle.move();
    vehicle.move();
}</pre>
			<p>Here’s <span class="No-Break">the</span><span class="No-Break"><a id="_idIndexMarker391"/></span><span class="No-Break"> output:</span></p>
			<pre class="source-code">
<strong class="bold">Pattern Proxy, remote vehicle controller</strong>
<strong class="bold">VehicleProxy, real vehicle connected</strong>
<strong class="bold">VehicleReal, move</strong>
<strong class="bold">VehicleReal, move</strong></pre>
			<p class="SC---Link" lang="en-US" xml:lang="en-US">Example 4.22 – The VehicleProxy instance works like a real vehicle</p>
			<p>The real vehicle implementation is defined by the generic abstraction provided by the <strong class="source-inline">Vehicle</strong> interfaces (<span class="No-Break"><em class="italic">Figure 4</em></span><span class="No-Break"><em class="italic">.11</em></span><span class="No-Break">):</span></p>
			<div>
				<div id="_idContainer057" class="IMG---Figure">
					<img src="image/B18884_04_11.jpg" alt="Figure 4.11 – An example of a vehicle proxy can be depicted by a UML class diagram"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.11 – An example of a vehicle proxy can be depicted by a UML class diagram</p>
			<p>This allows seamlessly extending the types of controlled vehicles, as shown in the proxy pattern<a id="_idIndexMarker392"/> implementation (<span class="No-Break"><em class="italic">Example 4.23</em></span><span class="No-Break">):</span></p>
			<pre class="source-code">
class VehicleProxy implements Vehicle{
    private Vehicle vehicleReal;
    @Override
    public void move() {
        if(vehicleReal == null){
            System.out.println("VehicleProxy, real vehicle
                connected");
            vehicleReal = new VehicleReal();
        }
        vehicleReal.move();
    }
}</pre>
			<p class="SC---Link" lang="en-US" xml:lang="en-US">Example 4.23 – The VehicleProxy class contains a reference to the actual Vehicle instance</p>
			<h2 id="_idParaDest-179"><a id="_idTextAnchor247"/>Conclusion</h2>
			<p>The proxy design pattern<a id="_idIndexMarker393"/> brings many advantages to the source code, for example, the implementation can be replaced at runtime. In addition to being used to fully control access to the actual instance, it can also be used for lazy initiation, as we saw in <em class="italic">Example 4.23</em>. The proxy has its legitimate place in driver implementation or network connections as it naturally enforces not only logging possibilities but also code separation through the segregation of the interfaces and other SOLID principles. It is useful to consider when an application requires <span class="No-Break">I/O operations.</span></p>
			<p>Java as a language does not support multiple inheritance, but it is still possible to achieve. Let us examine how in the <span class="No-Break">next section.</span></p>
			<h1 id="_idParaDest-180"><a id="_idTextAnchor248"/>Discovering multiple inheritance in Java with the twin pattern</h1>
			<p>This pattern allows you to combine functions<a id="_idIndexMarker394"/> of objects that tend to be used<a id="_idIndexMarker395"/> together, which is a common paradigm<a id="_idIndexMarker396"/> used by languages without multiple <span class="No-Break">inheritance support.</span></p>
			<h2 id="_idParaDest-181"><a id="_idTextAnchor249"/>Motivation</h2>
			<p>The twin pattern presents<a id="_idIndexMarker397"/> the possibility to implement multiple inheritance in Java. Multiple inheritance is not a supported concept as it may lead to compiler inconsistency, known as the diamond problem. The diamond problem<a id="_idIndexMarker398"/> defines a state through class abstraction where the compiler may turn out to be inconsistent. This state is due to the lack of information due to multiple abstract classes. The compiler does not have enough information about which methods <span class="No-Break">should execute.</span></p>
			<h2 id="_idParaDest-182"><a id="_idTextAnchor250"/>Sample code</h2>
			<p>This pattern is not supported<a id="_idIndexMarker399"/> by the platform and is rarely required for development. For these reasons, the pattern most likely does not exist inside the released JDK, as described. However, let us examine a possible example to better understand the pattern. Imagine the vehicle initiation sequence. During initiation, the engine and brake units need to be initiated together. In other words, when the engine is initiated, the brakes must be initiated too, and the other way around (<span class="No-Break"><em class="italic">Example 4.24</em></span><span class="No-Break">):</span></p>
			<pre class="source-code">
public static void main(String[] args) {
        System.out.println("Pattern Twin, vehicle
            initiation sequence");
        var vehicleBrakes1  = new VehicleBrakes();
        var vehicleEngine1 = new VehicleEngine();
        vehicleBrakes1.setEngine(vehicleEngine1);
        vehicleEngine1.setBrakes(vehicleBrakes1);
        vehicleEngine1.init();
    }</pre>
			<p>Here’s <span class="No-Break">the output:</span></p>
			<pre class="source-code">
<strong class="bold">Pattern Twin, vehicle initiation sequence</strong>
<strong class="bold">AbstractVehiclePart, constructor</strong>
<strong class="bold">AbstractVehiclePart, constructor</strong>
<strong class="bold">VehicleBrakes, initiated</strong>
<strong class="bold">VehicleEngine, initiated</strong></pre>
			<p class="SC---Link" lang="en-US" xml:lang="en-US">Example 4.24 – The twin pattern gives a guarantee that both units are always initiated</p>
			<p>The following diagram<a id="_idIndexMarker400"/> shows us tight coupling <span class="No-Break">between units:</span></p>
			<div>
				<div id="_idContainer058" class="IMG---Figure">
					<img src="image/B18884_04_12.jpg" alt="Figure 4.12 – Both considered units, VehicleEngine and VehicleBrakes, are very closely coupled"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.12 – Both considered units, VehicleEngine and VehicleBrakes, are very closely coupled</p>
			<p>The coupling also translates into a code<a id="_idIndexMarker401"/> base that can be very fragile for future development (<span class="No-Break"><em class="italic">Example 4.25</em></span><span class="No-Break">):</span></p>
			<pre class="source-code">
public class VehicleBrakes extends AbstractVehiclePart {
    private VehicleEngine twin;
    VehicleBrakes() {
    }
    void setEngine(VehicleEngine engine) {
        this.twin = engine;
    }
    @Override
    void init() {
        if (twin.isReady()) {
            setReady();
        } else {
            setReady();
            twin.init();
        }
        System.out.println("VehicleBrakes, initiated");
    }
}</pre>
			<p class="SC---Link" lang="en-US" xml:lang="en-US">Example 4.25 – The VehicleBrakes class implementation shows a tight coupling with its twin, VehicleEngine</p>
			<h2 id="_idParaDest-183"><a id="_idTextAnchor251"/>Conclusion</h2>
			<p>The twin pattern<a id="_idIndexMarker402"/> can be used to achieve multiple inheritance in Java. It must be used wisely, as a logical unwritten requirement is to guarantee complete separation of the objects under consideration. In other words, the twin design pattern allows twins to function as a single instance with extended functionality <span class="No-Break">and features.</span></p>
			<h1 id="_idParaDest-184"><a id="_idTextAnchor252"/>Summary</h1>
			<p>Knowledge of structural patterns along with newly added Java syntax enhancements not only improves maintainability but also enforces all previously learned OOP concepts and improves responsiveness to potential deviations in code behavior such as exceptions, unexpected crashes, or <span class="No-Break">logical issues.</span></p>
			<p>We built a solid foundation through the examples in this chapter and learned how to use the adapter pattern to create collaboration between mutually incompatible objects, and also how to transparently separate an object’s implementation from its abstraction using the bridge pattern. The composite pattern presented a way to organize and wrap objects into a tree structure around the underlying business logic. We investigated the possibility of expanding an object’s functionality by using the decorator pattern. A way to simplify communication between objects was presented by the facade pattern, followed by the filter pattern, which allows us to select only the instances we want. We learned how the flyweight design pattern allows us to re-use already created runtime instances, and the approach of processing the incoming information was presented by the front-controller pattern, so that the client can only respond to valid requests. We discovered how the marker pattern allows a client to handle a specific group of objects in a unique way. We explored the possibility of modularizing the code base by implementing the module pattern. We saw how to use the proxy pattern to let a client indirectly gain control of an object without being aware of its implementation details, and we saw how to use the twin pattern to implement multiple inheritance in Java even though the language does not <span class="No-Break">support it.</span></p>
			<p>With the knowledge gained about creational and structural design patterns, the underlying source code structure is well organized and open to continuous application development. The next chapter examines the behavioral design patterns that help organize communication and responsibilities between <span class="No-Break">targeted instances.</span></p>
			<h1 id="_idParaDest-185"><a id="_idTextAnchor253"/>Questions</h1>
			<ol>
				<li>What challenges do structural design <span class="No-Break">patterns solve?</span></li>
				<li>Which structural design patterns are described by the Gang <span class="No-Break">of Four?</span></li>
				<li>Which design pattern is appropriate for creating a tree structure of <span class="No-Break">related objects?</span></li>
				<li>Which structural design pattern can be used to identify an object <span class="No-Break">at runtime?</span></li>
				<li>Which design pattern can be used for indirect object access, with the same functionality of the <span class="No-Break">object itself?</span></li>
				<li>Which design pattern promotes the separation of logic from <span class="No-Break">its abstraction?</span></li>
			</ol>
			<h1 id="_idParaDest-186"><a id="_idTextAnchor254"/>Further reading</h1>
			<ul>
				<li><em class="italic">Design Patterns: Elements of Reusable Object-Oriented Software</em> by Erich Gamma, Richard Helm, Ralph Johnson, and John Vlissides, <span class="No-Break">Addison-Wesley, 1995</span></li>
				<li><em class="italic">Design Principles and Design Patterns</em> by Robert C. Martin, Object <span class="No-Break">Mentor, 2000</span></li>
				<li><em class="italic">JSR-376: Java Platform Module </em><span class="No-Break"><em class="italic">System</em></span><span class="No-Break">, </span><a href="https://openjdk.java.net/projects/jigsaw/spec/"><span class="No-Break">https://openjdk.java.net/projects/jigsaw/spec/</span></a></li>
				<li><em class="italic">JSR-408: Simple Web </em><span class="No-Break"><em class="italic">Server</em></span><span class="No-Break">, </span><a href="https://openjdk.org/jeps/408"><span class="No-Break">https://openjdk.org/jeps/408</span></a></li>
				<li><em class="italic">Clean Code</em> by Robert C. Martin, Pearson Education, <span class="No-Break">Inc, 2009</span></li>
				<li><em class="italic">Effective Java – Third edition</em> by Joshua Bloch, <span class="No-Break">Addison-Wesley, 2018</span></li>
				<li><em class="italic">Twin – A Design Pattern for Modelling Multiple Inheritance</em>, Hanspeter Mössenböck, University of Linz, Institute for System Software, <span class="No-Break">1999, </span><a href="https://ssw.jku.at/Research/Papers/Moe99/Paper.pdf"><span class="No-Break">https://ssw.jku.at/Research/Papers/Moe99/Paper.pdf</span></a></li>
			</ul>
		</div>
	</body></html>