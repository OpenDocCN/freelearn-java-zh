<html><head></head><body><div class="book" title="Chapter&#xA0;9.&#xA0;Java EE MVC Framework" id="aid-2IV0U1"><div class="book"><div class="book"><div class="book"><h1 class="title"><a id="ch09" class="calibre1"/>Chapter 9. Java EE MVC Framework</h1></div></div></div><div class="blockquote"><table border="0" cellspacing="0" cellpadding="0" class="blockquote1" summary="Block quote"><tr class="calibre12"><td valign="top" class="calibre13"> </td><td valign="top" class="calibre13"><p class="calibre14"><span><em class="calibre15">"Compared even to the development of the phone or TV, the Web developed very quickly."</em></span></p></td><td valign="top" class="calibre13"> </td></tr><tr class="calibre12"><td valign="top" class="calibre13"> </td><td colspan="2" valign="top" class="calibre16">--<span><span><em class="calibre15">Sir Tim Berners-Lee, inventor of the World Wide Web</em></span></span></td></tr></table></div><p class="calibre7">In the past couple of chapters, we reviewed the web application service from the perspective of the client side. For this last chapter, we will return to the digital application written mainly on the server-side. We will examine a brand new specification under the Java EE umbrella. It is <a id="id935" class="calibre1"/>called <span class="strong"><strong class="calibre8">Model-View-Controller</strong></span> (<span class="strong"><strong class="calibre8">MVC</strong></span>) and falls under the Java EE 8 release (March 2017) with JSR 371 (<a class="calibre1" href="https://jcp.org/en/jsr/detail?id=371">https://jcp.org/en/jsr/detail?id=371</a>). At the time of writing this book, there <a id="id936" class="calibre1"/>was already an Early Draft Release of Java EE MVC that demonstrates the <a id="id937" class="calibre1"/>working of the reference implementation called Ozark (<a class="calibre1" href="https://ozark.java.net/index.html">https://ozark.java.net/index.html</a>).</p><p class="calibre7">The MVC framework is based on a design pattern that was invented in the Smalltalk programming language and environment, which was particularly common in the early user interface applications. The idea is that the Model refers to the component that stores the application data such as a value object or data transfer objects. The View is the component that renders or is responsible for the delivery of a representation of the application's data to the user and the Controller is the component that contains the logic to process the input and output between the two former components: the View and Model. The design pattern is extremely popular because it embraces the separation of concerns, which is a key concept in a good pragmatic object-oriented design.</p><p class="calibre7">In 2014, Oracle issued a public open survey to the wider Java EE community and collected the results (<a class="calibre1" href="https://java.net/downloads/javaee-spec/JavaEE8_Community_Survey_Results.pdf">https://java.net/downloads/javaee-spec/JavaEE8_Community_Survey_Results.pdf</a>). Thousands of technologists responded to this survey. One key question in the survey was, <span class="strong"><em class="calibre9">Should Java EE provide support for MVC, along with JSF?</em></span> The correspondence was 60.8 percent in favor with a yes vote, 20 percent with a no vote, and 19.2 percent were unsure. This was enough to sanction the MVC 1.0 specification to be a part of Java EE 8.</p><div class="book" title="Java EE 8 MVC"><div class="book"><div class="book"><div class="book"><h1 class="title"><a id="ch09lvl1sec80" class="calibre1"/>Java EE 8 MVC</h1></div></div></div><p class="calibre7">Before we continue on to the programming, I should warn you that the information here is subject to change, because MVC is evolving right in front of our eyes. As an avid reader, you should<a id="id938" class="calibre1"/> certainly verify, at least, that the API is with the current or final <a id="id939" class="calibre1"/>specification.</p><p class="calibre7">With all this said, the MVC framework certainly—even at this early stage—will be a leading specification for the future digital web development framework for many years to come, and not just because it is now officially part of the Java EE umbrella drivetrain. MVC leverages the JAX-RS (Java for RESTful Services) API and currently integrates with the other Java EE technologies including CDI and Bean Validation.</p><p class="calibre7">The expert group made the decision to layer on top of JAX-RS rather than the older Java servlet API, because JAX-RS fits the modern programming practice to use full semantics of the HTTP mapping capabilities. They also felt that adopting servlet would expose the developer to the lower-level programming interfaces that are already duplicated in the JAX-RS specification.</p><p class="calibre7">From a digital developer's and modern web practices' points of view, the layering of MVC on top of JAX-RS is really a good adoption. The servlet specification has been criticized severely by the likes of the Play framework and others as being a wide and thick Context Map abstraction (Eric Evans' Domain-Driven Design) and a blocker to the natural design of the web and HTTP utilization.</p><p class="calibre7">We will be working with the Java EE 8 MVC reference implementation called Ozark. At the time of writing, Ozark is still a work in progress. However, the milestone release contains the essential components and interfaces of the MVC applications.</p></div></div>
<div class="book" title="MVC controllers"><div class="book" id="aid-2JTHG2"><div class="book"><div class="book"><h1 class="title"><a id="ch09lvl1sec81" class="calibre1"/>MVC controllers</h1></div></div></div><p class="calibre7">There is a new <a id="id940" class="calibre1"/>package structure reserved for MVC under <code class="email">javax.mvc</code>. The <code class="email">@javac.mvc.Controller</code> annotation declares a class type or method as a controller component. Here is an example of its use in a method:</p><div class="informalexample"><pre class="programlisting">@Controller
public String greet()
{
  return "Greetings, Earthling";
}</pre></div><p class="calibre7">This controller method is missing the HTTP semantics and this is where the JAX-RS annotations help. It is also useless from an MVC perspective because there are associations with either a Model or View component.</p><p class="calibre7">So, first let's turn the method into a proper RESTful resource, starting with the model object:</p><div class="informalexample"><pre class="programlisting">package uk.co.xenonique.basic.mvc;
import javax.enterprise.context.RequestScoped;
import javax.inject.Named;
@Named(value="user")
@RequestScoped
public class User {
  private String name;
  public User() {}
  public String getName() {return name; }
  public void setName(String name) {this.name = name; }
}</pre></div><p class="calibre7">The User component<a id="id941" class="calibre1"/> serves as our Model component. It has one property: the name of the person whom we are greeting politely. We can, therefore, write an MVC resource endpoint and inject this model instance into it.</p><p class="calibre7">Here is the initial version of our controller:</p><div class="informalexample"><pre class="programlisting">package uk.co.xenonique.basic.mvc;
/* ... */
import javax.mvc.Controller;
import javax.mvc.Viewable;
import javax.ws.rs.*;

@Path("/hello")
@Stateless
public class AlienGreetings {
  @Inject User user;

  @GET
  @Controller
  @Path("simple1")
  @Produces("text/html")
  public String simple1( @QueryParam("name") String name )
  {
    user.setName(name);
    return "/hello.jsp";
  }
}</pre></div><p class="calibre7">We will annotate a JAX RS <code class="email">@Path</code> element to our <code class="email">AlienGreetings</code> class in order to declare that it is a resource endpoint. Although our type is defined as an EJB stateless session bean, MVC is expected to work with the CDI scopes such as <code class="email">@ApplicationScoped</code> and <code class="email">@SessionScoped</code>. The reference implementation is changing as I write this.</p><p class="calibre7">We will annotate the <code class="email">simple1()</code> method as an MVC <code class="email">@Controller</code> annotation. This method accepts one argument name as <code class="email">@QueryParam</code>. We will add the other JAX-RS annotations in order to define the HTTP method protocol <code class="email">@GET</code>, relative URI <code class="email">@Path</code>, and MIME content type <code class="email">@Produces</code>. The method sets the name property in the <code class="email">User</code> instance and returns a reference string, which is the name of the view: <code class="email">/hello.jsp</code>.</p><p class="calibre7">An MVC controller <a id="id942" class="calibre1"/>method can return a string, which means that the servlet container takes over the rendering of the final view. However, MVC can also render different views due to an extendible implementation. We will see more on this later. Behind the scenes, MVC converts the string to a view type. The Java interface <code class="email">javax.mvc.Viewable</code> represents the abstraction of a view technology. The Viewable is an association between <code class="email">javax.mvc.ViewEngine</code> and <code class="email">javax.mvc.Models</code>.</p><p class="calibre7">The abstract class type <code class="email">javax.mvc.Engine</code> has the responsibility to render a model to a technology choice. Engineers can develop or add this engine to render the views. At the moment, Ozark supports many rendering styles, from Apache Velocity to AsciiDoc.</p><p class="calibre7">The Java interface <code class="email">javax.mvc.Models</code> represents a key value store that is passed from the view to the rendering engine. The model's type is a request-scoped map collection.</p><p class="calibre7">So, let's extend the <code class="email">AlienGreeting</code> controller with a few more methods. The following <code class="email">simple2()</code> method returns a <code class="email">Viewable</code> instance:</p><div class="informalexample"><pre class="programlisting">  @GET
  @Controller
  @Path("simple2")
  @Produces("text/html")
  public Viewable simple2( @QueryParam("name") String name )
  {
    user.setName(name);
    return new Viewable("/hello.jsp");
  }</pre></div><p class="calibre7">As you can see, the <code class="email">simple2()</code> method is a variation on <code class="email">simple1()</code>, and MVC is rather flexible. It even supports the void methods that do not return types. We will annotate the subsequent <code class="email">simple3()</code> method with <code class="email">@javax.mvc.View</code> in order to declare the next view:</p><div class="informalexample"><pre class="programlisting">  @GET
  @Controller
  @Path("simple3")
  @Produces("text/html")
  @View("/hello.jsp")
  public void simple3( @QueryParam("name") String name )
  {
    user.setName(name);
  }</pre></div><p class="calibre7">All of the three methods are HTTP GET requests so far. As MVC is layered on top of JAX-RS, we can utilize other protocol methods too. It is straightforward to write an HTML form handler <a id="id943" class="calibre1"/>that handles an HTTP POST request.</p><p class="calibre7">Here is the code extract for the <code class="email">helloWebForm()</code> method:</p><div class="informalexample"><pre class="programlisting">  @POST
  @Controller
  @Path("webform")
  @Produces("text/html")
  public Viewable helloWebForm( @FormParam("name") String name )
  {
    user.setName(name);
    return new Viewable("/hello.jsp");
  }</pre></div><p class="calibre7">The preceding controller method, <code class="email">helloWebForm()</code>, accepts an HTML form named parameter. It sets the model object and returns a view instance. In the HTML5 standard, the form element officially supports the HTTP GET and POST requests. The popular web browsers tend to have access only to the HTTP PUT and DELETE protocol requests through JavaScript. This limitation does not, however, prevent the MVC controllers being annotated with <code class="email">@PUT</code> or <code class="email">@DELETE</code>.</p><p class="calibre7">The MVC controllers have access to a full gamut of the URI space that is available to the JAX-RS endpoints. The following example illustrates the path parameter:</p><div class="informalexample"><pre class="programlisting">  @GET
  @Controller
  @Path("view/{name}")
  @Produces("text/html")
  public Viewable helloWebPath( @PathParam("name") String name )
  {
    user.setName(name);
    return new Viewable("/hello.jsp");
  }</pre></div><p class="calibre7">The preceding controller method, <code class="email">helloWebPath()</code>, accepts a path parameter as the user's name. The <code class="email">@PathParam</code> annotation establishes the parameter token used in the relative URI. The URI is defined by the <code class="email">@Path</code> annotation. The full URL will be <code class="email">http://localhost:8080/javaee-basic-mvc/rest/hello/view/Curtis</code>.</p><div class="book" title="MVC page views and templates"><div class="book"><div class="book"><div class="book"><h2 class="title1"><a id="ch09lvl2sec103" class="calibre1"/>MVC page views and templates</h2></div></div></div><p class="calibre7">Under the <a id="id944" class="calibre1"/>MVC specification, a <code class="email">view</code> instance can be treated as a <a id="id945" class="calibre1"/>templating technology reference. We have seen only JavaServer Page views up until now. A view can be anything that a developer can imagine, as long as there is a corresponding <code class="email">ViewEngine</code> instance that knows exactly how to process (render) a view from the associated model and the other results from a controller.</p><p class="calibre7">Let's look at<a id="id946" class="calibre1"/> the first basic JSP view, <code class="email">index.jsp</code>, in the sample<a id="id947" class="calibre1"/> source code project from this book (<code class="email">ch09/basic-javaee-mvc</code>):</p><div class="informalexample"><pre class="programlisting">&lt;%@ page import="uk.co.xenonique.basic.mvc.AlienGreetings" %&gt;
&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt; ...
  &lt;link href="${pageContext.request.contextPath}/styles/bootstrap.css" rel="stylesheet"&gt;
  &lt;link href="${pageContext.request.contextPath}/styles/main.css" rel="stylesheet"&gt;
&lt;/head&gt;
&lt;body&gt;
  &lt;div class="main-content"&gt; ...
    &lt;div class="other-content"&gt;
      &lt;h2&gt;Simple MVC Controller&lt;/h2&gt;
      &lt;p&gt;
        HTTP GET Request with query parameter and invocation of 
        &lt;code&gt;&lt;%= AlienGreetings.class.getSimpleName() %&gt;
        &lt;/code&gt; with HTML Form:&lt;br&gt;
        &lt;a href="${pageContext.request.contextPath}
          /rest/hello/simple1?name=James" 
          class="btn btn-primary"&gt; Person called James
        &lt;/a&gt;
      &lt;/p&gt;
      &lt;p&gt;...
        &lt;a href="${pageContext.request.contextPath}
          /rest/hello/simple2?name=Patricia" 
          class="btn btn-primary"&gt; Person called Patricia
        &lt;/a&gt;
      &lt;/p&gt;
      &lt;p&gt;...
        &lt;a href="${pageContext.request.contextPath}
          /rest/hello/simple3?name=Aliiyah" 
          class="btn btn-primary"&gt; Person called Aliiyah
        &lt;/a&gt;
      &lt;/p&gt;
      &lt;p&gt;      
        &lt;form action="${pageContext.request.contextPath}
          /rest/hello/webform"method="POST" &gt;
          &lt;div class="form-group"&gt;
            &lt;label for="elementName"&gt;Name&lt;/label&gt;
            &lt;input type="text" class="form-control" 
              id="elementName" name="name" placeholder="Jane Doe"&gt;
          &lt;/div&gt;
        &lt;/form&gt;
      &lt;/p&gt;
      ...
    &lt;/div&gt;
  &lt;/body&gt;
&lt;/html&gt;</pre></div><p class="calibre7">In this JSP view, we<a id="id948" class="calibre1"/> will take advantage of an EL to generate <a id="id949" class="calibre1"/>a URL with the context path for the web application, namely <code class="email">pageContext.request.contextPath</code>. There are three HTML anchor elements that invoke the <code class="email">AlienGreeting</code> controller methods: <code class="email">simple1()</code>, <code class="email">simple2()</code>, and <code class="email">simple3()</code>. The HTML form invokes the <code class="email">helloWebForm()</code> method.</p><p class="calibre7">The page extract JSP view called <code class="email">hello.jsp</code> looks as follows:</p><div class="informalexample"><pre class="programlisting">&lt;div class="main-content"&gt;
  &lt;div class="page-header"&gt;
    &lt;h1&gt; Java EE 8 MVC - Hello&lt;/h1&gt;
    &lt;p&gt; Model View Controller &lt;/p&gt;
  &lt;/div&gt;
  &lt;div class="other-content"&gt;
    &lt;div class="jumbotron"&gt;
      &lt;p&gt; Hello ${user.name} &lt;/p&gt;
    &lt;/div&gt;
    &lt;p&gt; How are you?&lt;/p&gt;
  &lt;/div&gt;
&lt;/div&gt;</pre></div><p class="calibre7">The view template is very straightforward; we will use the request-scoped user instance to supply the name.</p><p class="calibre7">At the time of writing this, Ozark supported the following view rendition technologies in the beta reference implementation, as shown in the following table:</p><div class="informalexample"><table border="1" class="blockquote1"><colgroup class="calibre18"><col class="calibre19"/><col class="calibre19"/></colgroup><thead class="calibre20"><tr class="calibre21"><th valign="bottom" class="calibre22">
<p class="calibre14">Template name</p>
</th><th valign="bottom" class="calibre22">
<p class="calibre14">Description</p>
</th></tr></thead><tbody class="calibre23"><tr class="calibre21"><td valign="top" class="calibre13">
<p class="calibre14">AsciiDoc</p>
</td><td valign="top" class="calibre13">
<p class="calibre14">This a <a id="id950" class="indexterm"/>text document <a id="id951" class="indexterm"/>format to write notes, documents, articles, books, e-books, slideshows, man pages, and blogs.</p>
<p class="calibre14">
<a class="indexterm" href="https://github.com/asciidoctor/asciidoctorj">https://github.com/asciidoctor/asciidoctorj</a>
</p>
</td></tr><tr class="calibre21"><td valign="top" class="calibre13">
<p class="calibre14">Freemarker</p>
</td><td valign="top" class="calibre13">
<p class="calibre14">This is a<a id="id952" class="indexterm"/> Java template engine that generates HTML, RTF, and <a id="id953" class="indexterm"/>source code.</p>
<p class="calibre14">
<a class="indexterm" href="http://freemarker.org/">http://freemarker.org/</a>
</p>
</td></tr><tr class="calibre21"><td valign="top" class="calibre13">
<p class="calibre14">Handlebars</p>
</td><td valign="top" class="calibre13">
<p class="calibre14">This is a multiple language and platform extension to the original Mustache<a id="id954" class="indexterm"/> templating specification with helpful utilities tokens.</p>
<p class="calibre14">JavaScript<a id="id955" class="indexterm"/> version: <a class="indexterm" href="http://handlebarsjs.com/">http://handlebarsjs.com/</a> and Java port: <a class="indexterm" href="https://github.com/jknack/handlebars.java/">https://github.com/jknack/handlebars.java/</a>
</p>
</td></tr><tr class="calibre21"><td valign="top" class="calibre13">
<p class="calibre14">JSR 223</p>
</td><td valign="top" class="calibre13">
<p class="calibre14">This is an<a id="id956" class="indexterm"/> extension of the MVC framework that supports <a id="id957" class="indexterm"/>JSR 223 for a dynamic scripting language such as Groovy and Jython.</p>
<p class="calibre14">
<a class="indexterm" href="https://www.jcp.org/en/jsr/detail?id=223">https://www.jcp.org/en/jsr/detail?id=223</a>
</p>
</td></tr><tr class="calibre21"><td valign="top" class="calibre13">
<p class="calibre14">Mustache</p>
</td><td valign="top" class="calibre13">
<p class="calibre14">This is a<a id="id958" class="indexterm"/> simple web template language that separates the presentation from the business view logic. It is available on multiple <a id="id959" class="indexterm"/>platforms and languages.</p>
<p class="calibre14">
<a class="indexterm" href="https://github.com/spullara/mustache.java">https://github.com/spullara/mustache.java</a>
</p>
</td></tr><tr class="calibre21"><td valign="top" class="calibre13">
<p class="calibre14">Thymeleaf</p>
</td><td valign="top" class="calibre13">
<p class="calibre14">This is a <a id="id960" class="indexterm"/>Java-based HTML5 template library that works in the web and non-web environments. It is associated strongly <a id="id961" class="indexterm"/>with the string framework.</p>
<p class="calibre14">
<a class="indexterm" href="http://www.thymeleaf.org/">http://www.thymeleaf.org/</a>
</p>
</td></tr><tr class="calibre21"><td valign="top" class="calibre13">
<p class="calibre14">Velocity</p>
</td><td valign="top" class="calibre13">
<p class="calibre14">Apache Velocity is<a id="id962" class="indexterm"/> a suite of the templating tools. The Velocity engine is the component library that provides templating. It was one of the first web template frameworks that was written for<a id="id963" class="indexterm"/> server-side Java.</p>
<p class="calibre14">
<a class="indexterm" href="http://velocity.apache.org/">http://velocity.apache.org/</a>
</p>
</td></tr></tbody></table></div><div class="informalexample" title="Note"><h3 class="title2"><a id="tip42" class="calibre1"/>Tip</h3><p class="calibre7">MVC is a<a id="id964" class="calibre1"/> server-side template solution. Don't confuse the<a id="id965" class="calibre1"/> world of client-side templating with the backend variety.</p></div></div><div class="book" title="MVC models"><div class="book"><div class="book"><div class="book"><h2 class="title1"><a id="ch09lvl2sec104" class="calibre1"/>MVC models</h2></div></div></div><p class="calibre7">The MVC specification<a id="id966" class="calibre1"/> supports two forms of models. The first is based on the <code class="email">javax.mvc.Models</code> instance and the second form leverages the CDI <code class="email">@Named</code> beans. The <code class="email">Models</code> interface types map the key names to the values in a map collection. All the view engines must mandatorily support <code class="email">Models</code>. A view engine may optionally support CDI. The specification recommends that the view engine implementers provide the CDI beans support.</p><p class="calibre7">The default implementation of the <code class="email">Models</code> interface is a request-scoped bean: <code class="email">com.oracle.ozark.core.ModelsImpl</code>. This class delegates to a <code class="email">java.util.Map</code> collection. Developers normally never instantiate this type but prefer to inject the <code class="email">Models</code> type. As you will see later, it is sometimes necessary to create an instance for a particular view engine.</p><p class="calibre7">Let's demonstrate the practical use of the <code class="email">Models</code> interface in a second version of our controller class:</p><div class="informalexample"><pre class="programlisting">@Path("/hello2")
@Stateless
public class PhobosGreetings {
  @Inject
  Models models;

  @GET
  @Controller
  @Path("simple2")
  @Produces("text/html")
  public Viewable simple1(  @QueryParam("name") String name )
  {
    models.put("users", new User(name));
    return new Viewable("/hello2.jsp");
  }
}</pre></div><p class="calibre7">In <code class="email">PhobosGreetings</code>, we will replace the CDI injection of the <code class="email">User</code> type with a <code class="email">Models</code> instance. We will <a id="id967" class="calibre1"/>create a <code class="email">User</code> instance and store this under the property key, <code class="email">user</code>. After the method returns, the framework will retrieve all of the properties in the <code class="email">Models</code> instance and place them in the attributes collection of <code class="email">HttpServlerResponse</code>. Therefore, a JSP template view has access to the data through an EL or inline scripting.</p></div><div class="book" title="Response and redirects"><div class="book"><div class="book"><div class="book"><h2 class="title1"><a id="ch09lvl2sec105" class="calibre1"/>Response and redirects</h2></div></div></div><p class="calibre7">MVC also <a id="id968" class="calibre1"/>supports the controller that returns an instance of the <a id="id969" class="calibre1"/>JAX RS Response type. This is especially useful to the sites that shove the Grunt work of rendering to the client side. A highly scalable web application may choose to send the megabytes of a JSON response rather than render on the server through a template.</p><p class="calibre7">We will now inspect another MVC controller called <code class="email">RedirectController</code>:</p><div class="informalexample"><pre class="programlisting">@Path("redirect")
@Stateless
@Controller
public class RedirectController {
  @GET
  @Path("string")
  public String getString() {
      return "redirect:redirect/here";
  }

  @GET
  @Path("response1")
  public Response getResponse1() {
    return Response.seeOther(
      URI.create("redirect/here")).build();
  }

  @GET
  @Path("deliberateError1")
  public Response getErrorResponse1() {
    return Response.status(Response.Status.BAD_REQUEST)
      .entity("/error.jsp").build();
  }

  @GET
  @Path("here")
  @Produces("text/html")
  public String getRedirectedView() {
    return "redirected.jsp";
  }
}</pre></div><p class="calibre7">We will annotate <code class="email">RedirectController</code> with JAX-RS <code class="email">@Path</code> and we must pay particular attention to the base value, <code class="email">redirect</code>.</p><p class="calibre7">The <code class="email">getString()</code> method performs a URI redirection using the special prefix operator, redirect. This<a id="id970" class="calibre1"/> method has a unique relative URI of <code class="email">redirect/string</code>. MVC detects the prefix internally and builds a JAX-RS Response as a redirect request. The <a id="id971" class="calibre1"/>URI that is returned is a reference to the <code class="email">getRedirectedView()</code> controller, which has a relative path URI of <code class="email">redirect/here</code>.</p><p class="calibre7">We can directly build the response ourselves as seen in the <code class="email">getResponse()</code> method. Invoking the static <code class="email">Response.seeOther()</code> method with a URI is the equivalent of achieving an HTTP redirect response. This method has its own unique relative URI of <code class="email">redirect/response1</code>.</p><p class="calibre7">The <code class="email">getRedirectedView()</code> method simply navigates to the view template, <code class="email">redirected.jsp</code>. This controller method is the eventual target of the other controller methods: <code class="email">getString()</code> and <code class="email">getResponse()</code>.</p><div class="informalexample" title="Note"><h3 class="title2"><a id="tip43" class="calibre1"/>Tip</h3><p class="calibre7">At the time of writing this, the MVC specification was designing the HTTP redirect approach. There was a question about providing a Flash scope or an equivalent of a JSF View scope bean for the MVC applications in order to save the data among the multiple request scopes. I strongly recommend you to check for updates on the specification.</p></div><p class="calibre7">Finally, an MVC controller can also return HTTP error responses. The <code class="email">getErrorResponse()</code> method has a relative URI of <code class="email">redirect/deliberateError1</code> and returns a Response instance with an HTTP Bad Request error code (401). The controller also informs the MVC framework to serve the view template under the view ID <code class="email">error.jsp</code>. <code class="email">RedirectController</code> represents the simplest form <a id="id972" class="calibre1"/>of an MVC controller. We can enrich it with the injection<a id="id973" class="calibre1"/> of <code class="email">Models</code> or other CDI beans. We can also use the Viewable instances instead of the dumb strings as entities in a Response builder.</p><p class="calibre7">Let's move on to the different templating technologies, and this is the unique selling point of MVC so far.</p><div class="book" title="Reconfiguring the view root"><div class="book"><div class="book"><div class="book"><h3 class="title2"><a id="ch09lvl3sec47" class="calibre1"/>Reconfiguring the view root</h3></div></div></div><p class="calibre7">In the working MVC early draft release, the view root is set by default to <code class="email">WEB-INF/views</code>. Programmatically, this is found in the static property of <code class="email">ViewEngine.DEFAULT_VIEW_ENGINE</code>.</p><p class="calibre7">This may be<a id="id974" class="calibre1"/> inconvenient for the digital engineers with relative URI, especially in the redirection of the page views. Luckily, the Ozark implementation can be reconfigured from the web XML descriptor (<code class="email">web.xml</code>), as follows:</p><div class="informalexample"><pre class="programlisting">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;web-app  ...&gt;
  ...
  &lt;servlet&gt;
    &lt;servlet-name&gt;javax.ws.rs.core.Application&lt;/servlet-name&gt;
    &lt;init-param&gt;
      &lt;param-name&gt;javax.mvc.engine.ViewEngine.viewFolder&lt;/param-name&gt;
      &lt;param-value&gt;/&lt;/param-value&gt;
    &lt;/init-param&gt;
    &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;
    &lt;async-supported&gt;true&lt;/async-supported&gt;
  &lt;/servlet&gt;...
&lt;/web-app&gt;</pre></div><p class="calibre7">We will override the <code class="email">javax.mvc.engine.ViewEngine.viewFolder</code> property in the web page root in order to achieve the behavior that we want.</p></div></div></div>
<div class="book" title="Handlebars Java"><div class="book" id="aid-2KS222"><div class="book"><div class="book"><h1 class="title"><a id="ch09lvl1sec82" class="calibre1"/>Handlebars Java</h1></div></div></div><p class="calibre7">The Handlebars framework<a id="id975" class="calibre1"/> is a templating library for a developing web application. In its JavaScript incantation (<a class="calibre1" href="http://handlebarsjs.com/">http://handlebarsjs.com/</a>), you might already have heard the digital interface developers raving<a id="id976" class="calibre1"/> about it. We will use the Handlebars Java<a id="id977" class="calibre1"/> port for the rest of this chapter.</p><p class="calibre7">The Handlebars framework permits the developers along with designers to write semantic templates. It is based<a id="id978" class="calibre1"/> on a slightly older templating framework called Mustache (<a class="calibre1" href="https://mustache.github.io/">https://mustache.github.io/</a>). Both of these refer to the masculine<a id="id979" class="calibre1"/> facial hair that can be seen if you squint your eyes and look at a curly bracket rotated by 90 degrees.</p><p class="calibre7">Templating frameworks drive home the separation of concerns and reduction of mixing the business logic in the rendered page view as much as possible. The Handlebars framework borrows the double curly bracket notation from Mustache. For our masculine readers, this is a deliberate play on words and an idiosyncrasy of computer programming. The Handlebars framework has a clear advantage of leveraging the same template engine on the server side that also works on the client side.</p><div class="book" title="A compiled-inline template servlet"><div class="book"><div class="book"><div class="book"><h2 class="title1"><a id="ch09lvl2sec106" class="calibre1"/>A compiled-inline template servlet</h2></div></div></div><p class="calibre7">We will start <a id="id980" class="calibre1"/>with a servlet example as an introduction. We will create a Java servlet with just one dependency, which is the<a id="id981" class="calibre1"/> Handlebars Java implementation. We are not considering the MVC framework just yet. Our servlet will instantiate the templating framework, invoke an inline template script, and then return the output as a straightforward direct response.</p><p class="calibre7">Here is our servlet:</p><div class="informalexample"><pre class="programlisting">package uk.co.xenonique.basic.mvc;
import com.github.jknack.handlebars.*;
import javax.servlet.*;
/* ... other imports omitted */

@WebServlet("/compiled")
public class CompileInlineServlet extends HttpServlet {
  @Override
  protected void doGet(HttpServletRequest request, HttpServletResponse response)
    throws ServletException, IOException
  {
    final Handlebars handlebars = new Handlebars();
    final Template template = handlebars.compileInline(
         "Hello {{this}}!");
    final String text = template.apply("Handlebars.java");
    response.setContentType("text/plain");
    response.getOutputStream().println(text);
  }
}</pre></div><p class="calibre7">The <code class="email">CompileInlineServlet</code> class illustrates how to compile a basic Handlers template example in <a id="id982" class="calibre1"/>the Java code. We will instantiate <a id="id983" class="calibre1"/>a Handlebars engine template and then compile the template inline, as shown in the following text:</p><div class="informalexample"><pre class="programlisting">Hello {{this}}!</pre></div><p class="calibre7">After compilation, we will obtain a <code class="email">Template</code> instance that contains the content. We will then call the <code class="email">apply()</code> method with a simple string and this will serve as the context for the template. The <code class="email">{{this}}</code> placeholder refers to the context object. We will then retrieve the text representation and send the response back to the web browser. We will see the following plain text output:</p><div class="informalexample"><pre class="programlisting">Hello Handlebars.java!</pre></div><p class="calibre7">There are no dependencies in Handlebars Java that tie the framework to Java EE. Therefore, it can also be used in Java SE as a standalone Java executable.</p></div><div class="book" title="Template expressions in Handlebars"><div class="book"><div class="book"><div class="book"><h2 class="title1"><a id="ch09lvl2sec107" class="calibre1"/>Template expressions in Handlebars</h2></div></div></div><p class="calibre7">Here is <a id="id984" class="calibre1"/>another example of a Handlebars template with a different context:</p><div class="informalexample"><pre class="programlisting">&lt;div class="trade-entry"&gt;
  &lt;h1&gt;{{title}}&lt;/h1&gt;
  &lt;div class="trade-detail"&gt;
    {{detail}}
  &lt;/div&gt;
&lt;/div&gt;</pre></div><p class="calibre7">The template renders<a id="id985" class="calibre1"/> in a DIV layer with a token name substitution with an embedded expression. An expression is reserved and activated between the double curly brackets. It renders an output for the domain of the trading system. In both Handlebars and Mustache notation, the double curly bracket surrounding a variable name denotes a placeholder entry. A placeholder entry in a template means that it can be replaced with a dynamic content. Therefore, during the template rendering process, the <code class="email">{{title}}</code> placeholder is replaced with the trade entry headline and the <code class="email">{{detail}}</code> is replaced with the trade detail. The expression value may be literal strings or they could be an embedded HTML5 markup.</p><p class="calibre7">Let's write another Java servlet that renders this view using the Handlebars framework:</p><div class="informalexample"><pre class="programlisting">package uk.co.xenonique.basic.mvc;
import com.github.jknack.handlebars.*;
import com.github.jknack.handlebars.io.*;
/* ... imports omitted */

@WebServlet("/tradeinfo")
public class TradeInfoServlet extends HttpServlet {
  @Override
  protected void doGet(HttpServletRequest request,
     HttpServletResponse response)
      throws ServletException, IOException
  {
    final TemplateLoader loader = 
      new ServletContextTemplateLoader(
         request.getServletContext());
    final Handlebars handlebars = new Handlebars(loader);
    final Template template = handlebars.compile("trade");
    final Map&lt;String,String&gt; context = 
        new HashMap&lt;String,String&gt;() {{
      put("title", "12345FUND-EURO-FUTURE6789");
      put("detail", "Nominal 1.950250M EUR");
      put("trade-date", "23-07-2015");
      put("maturity-date", "23-07-2018");
    }};
    final String text = template.apply(context);
    response.setContentType("text/html");
    response.getOutputStream().println(text);
  }
}</pre></div><p class="calibre7">This <code class="email">TradeInfoServlet</code> servlet is almost the same as the previous one, <code class="email">CompileInlineServlet</code>; but this time, we will utilize the <code class="email">ServletContextTemplateLoader</code> class. This is a loader class that retrieves the view templates from the Java EE web context via the servlet engine. We will create the loader and pass this <a id="id986" class="calibre1"/>as an argument during the construction of a <a id="id987" class="calibre1"/>Handlebar instance. We will then compile a template using a reference name, trade. The framework invokes the loader to retrieve the view template, which by default is suffixed as <code class="email">trade.hbs</code>.</p><p class="calibre7">We built a literal map collection of the keys and values. They will serve as our collection of placeholders in the view, and we will apply them to the template. Navigating to the web browser with <code class="email">http://localhost:8080/handlebars-javaee-mvc-1.0-SNAPSHOT/tradeinfo</code> should display the following screenshot:</p><div class="mediaobject"><img src="../Images/image00425.jpeg" alt="Template expressions in Handlebars" class="calibre10"/><div class="caption"><p class="calibre24">Screenshot of the TradeInfoServlet</p></div></div><p class="calibre11"> </p><p class="calibre7">In addition to <a id="id988" class="calibre1"/>straightforward replacements, Handlebars <a id="id989" class="calibre1"/>supports the <code class="email">Block</code>, <code class="email">Partials</code>, and <code class="email">Helper</code> expressions. The Handlebars framework provides the standard building blocks; however, engineers can register custom helpers. In the JavaScript implementation, developers usually define the compiled script templates in the page in order to reuse the content. <code class="email">Handlebars.js</code> tends to be used with one or the other JavaScript framework such as RequireJS or EmberJS in order to deliver reusable content.</p><p class="calibre7">We will proceed to write a CRUD example with Handlebars Java. Our application will allow the user to manipulate a basic product catalog. We will need a welcome page, so let's create it with the template framework.</p></div><div class="book" title="The welcome controller"><div class="book"><div class="book"><div class="book"><h2 class="title1"><a id="ch09lvl2sec108" class="calibre1"/>The welcome controller</h2></div></div></div><p class="calibre7">In the Java <a id="id990" class="calibre1"/>port, we do not have to register or compile the<a id="id991" class="calibre1"/> templates because the page content is delivered from the server side. The project for this is called <code class="email">handlebars-javaee-mvc</code>. The first thing to do is cause an HTTP redirect in an initial JSP, as follows:</p><div class="informalexample"><pre class="programlisting">&lt;%@ page contentType="text/html;charset=UTF-8" language="java" %&gt;
&lt;html&gt;
&lt;body&gt;
&lt;meta http-equiv="refresh" content="0; 
  url=${pageContext.request.contextPath}/rest/welcome" /&gt;
&lt;/body&gt;
&lt;/html&gt;</pre></div><p class="calibre7">The preceding code will immediately redirect the web browser to send an HTTP GET request to the URI, <code class="email">handler-javeee-mvc-1.0/rest/welcome</code>. In this URI path, we already have an MVC controller waiting for this invocation:</p><div class="informalexample"><pre class="programlisting">@Path("/welcome")
@Stateless
public class WelcomeController {
  @Inject Models models;

  @GET
  @Controller
  @Produces("text/html")
  public Viewable welcome()
  {
    models.put("pageTitle", "Handlebars.java Java EE 8 MVC" );
    models.put("title", "Welcome");
    return new Viewable("/welcome.hbs");
  }
}</pre></div><p class="calibre7">After populating a couple properties in the model instance, the <code class="email">WelcomeController</code> progresses the response to the Handlebars Java template <code class="email">/welcomee.hbs</code>. The absolute <a id="id992" class="calibre1"/>URI with the forward slash character ensures<a id="id993" class="calibre1"/> that the MVC framework searches for the page template from the web context root. The suffix extension <code class="email">*.hbs</code> is generally reserved for the Handlebars view templates in both the client and server editions.</p><p class="calibre7">Let's look at the following Handlebars template (<code class="email">welcome.hbs</code>):</p><div class="informalexample"><pre class="programlisting">&lt;!DOCTYPE html&gt;
&lt;html&gt;
{{&gt; header }}
&lt;body&gt;
  {{&gt; navbar }}

  &lt;div class="main-content"&gt;
    ...
  &lt;/div&gt;

  {{&gt; footer}}
&lt;/body&gt;
{{&gt; bottom }}
&lt;/html&gt;</pre></div><p class="calibre7">Handlebars support the concept of Partials. A partial is a template that is used in another template. They are extremely useful for page composition. The syntax begins with <code class="email">{{&gt; NAME }}</code>, where <code class="email">NAME</code> refers to another template. In a JavaScript stack, the partials must be registered beforehand; however, the Java port knows how to find the partial template by loading them from the servlet container. Therefore, the partial template reference, <code class="email">{{&gt; header }}</code>, instructs Handlebars to load the <code class="email">header.hbs</code> view.</p><p class="calibre7">There are<a id="id994" class="calibre1"/> four partial templates in the <code class="email">welcome.hbs</code> view: <code class="email">header.hbs</code>, <code class="email">navbar.hbs</code>, <code class="email">footer.hbs</code>, and <code class="email">bottom.hbs</code>. You can examine the <a id="id995" class="calibre1"/>source code for these templates in this book's code distribution.</p></div><div class="book" title="The custom view engine"><div class="book"><div class="book"><div class="book"><h2 class="title1"><a id="ch09lvl2sec109" class="calibre1"/>The custom view engine</h2></div></div></div><p class="calibre7">Handlebars Java <a id="id996" class="calibre1"/>ships with several template view engines. The default extension view engine, unfortunately, does not provide all of the features that we would like to use. For one, Handlebars does not render the decimal numbers readily, and so, we must register our own function. Luckily, it is reasonable to <a id="id997" class="calibre1"/>write a view engine extension with CDI, as follows:</p><div class="informalexample"><pre class="programlisting">package uk.co.xenonique.basic.mvc;
import com.github.jknack.handlebars.*;
import com.github.jknack.handlebars.io.*;
import com.oracle.ozark.engine.ViewEngineBase;
// ... other imports ommitted

@ApplicationScoped
public class MyHandlebarsViewEngine extends ViewEngineBase {
  @Inject private ServletContext servletContext;

  @Override
  public boolean supports(String view) {
    return view.endsWith(".hbs") || view.endsWith(".handlebars");
  }

  @Override
  public void processView(ViewEngineContext context) throws ViewEngineException {
    final Models models = context.getModels();
    final String viewName = context.getView();

    try (PrintWriter writer = context.getResponse().getWriter();
         InputStream resourceAsStream = 
         servletContext.getResourceAsStream(resolveView(context));
         InputStreamReader in = 
            new InputStreamReader(resourceAsStream, "UTF-8");
       BufferedReader buffer = new BufferedReader(in);) {
      final String viewContent = buffer.lines()
        .collect(Collectors.joining());
      final TemplateLoader loader = 
        new ServletContextTemplateLoader(servletContext);
      final Handlebars handlebars = new Handlebars(loader);
      models.put("webContextPath", 
         context.getRequest().getContextPath());
      models.put("page", context.getRequest().getRequestURI());
      models.put("viewName", viewName);
      models.put("request", context.getRequest());
      models.put("response", context.getResponse());
      handlebars.registerHelper("formatDecimal", new Helper&lt;BigDecimal&gt;() {
          @Override
          public CharSequence apply(BigDecimal number, Options options) throws IOException {
            final DecimalFormat formatter = 
               new DecimalFormat("###0.##");
            return formatter.format(number.doubleValue());
          }
      });
      Template template = handlebars.compileInline(viewContent);
      template.apply(models, writer);
    } catch (IOException e) {
        throw new ViewEngineException(e);
    }
  }
}</pre></div><p class="calibre7">We will <a id="id998" class="calibre1"/>annotate our <code class="email">MyHandlebarsViewEngine</code> class as an application-scoped bean and also ensure that it subclasses <code class="email">ViewEngineBase</code> from Ozark. We will inject <code class="email">ServletContext</code> into this class because we<a id="id999" class="calibre1"/> need to retrieve certain properties from it such as the web context path.</p><p class="calibre7">We will override the <code class="email">supports()</code> method so as to establish the support for the Handlebars files. The MVC View type is passed as a single argument.</p><p class="calibre7">The real work happens in the <code class="email">processView()</code> method, and we are totally responsible for rendering the Handlebars View template. The MVC framework supplies <code class="email">javax.mvc.engine.ViewEngineContext</code>, which provides access to the current <code class="email">View</code> and <code class="email">Models</code> instances. We can establish the name of the View template that we need to retrieve. From here on, we can create the <code class="email">ServletContextTemplateLoader</code> and <code class="email">Handlebars</code> instances to load a view as we saw in the earlier <code class="email">TradeInfoServlet</code> class. Then we have to navigate some tricky waters a little bit by reading the contents of the current view in a buffer. <code class="email">ViewEngineBase</code> provides a <code class="email">resolve()</code> method that helps us immensely and returns <code class="email">InputStream</code>. By the way, the Java 7 acquire/resource syntax for the try-catch statements reduces the boilerplate code. At the end of the method, we can compile the view inline because we have the content in a buffer.</p><p class="calibre7">We will add a couple of useful features in <code class="email">MyHandlebarsViewEngine</code>. First, we will add extra properties to the <code class="email">Models</code> instance. We will add the web context path and request and response objects to the <code class="email">Models</code> instance. Second, we will register a Handlebars helper in order to better render the BigDecimal types.</p><p class="calibre7">When our <a id="id1000" class="calibre1"/>application is deployed, Ozark relies on CDI to<a id="id1001" class="calibre1"/> find the <code class="email">ViewEngineBase</code> types. Ozark scans the classpath of JAR files and classes to find types of <code class="email">ViewEengineBase</code> objects. It builds an internal list of available renders. <code class="email">MyHandlebarsViewEngine</code> is the place presently where you can add additional helpers and utilities in the rendering phase. Keep a watch on the MVC specification to see if any of these interfaces are exposed in a meaningful public accessible API.</p><p class="calibre7">We will move on to our controller and the product list view.</p></div><div class="book" title="The product controller"><div class="book"><div class="book"><div class="book"><h2 class="title1"><a id="ch09lvl2sec110" class="calibre1"/>The product controller</h2></div></div></div><p class="calibre7">Our domain <a id="id1002" class="calibre1"/>object is the humble <code class="email">Product</code> entity, which has<a id="id1003" class="calibre1"/> an outline that resembles the following form:</p><div class="informalexample"><pre class="programlisting">@Entity
@NamedQueries({
  @NamedQuery(name="Product.findAll",
    query = "select p from Product p order by p.name"),
  @NamedQuery(name="Product.findById",
    query = "select p from Product p where p.id = :id"),
})
public class Product {
  @Id
  @GeneratedValue(strategy = GenerationType.AUTO)
  private Integer id;
  @NotEmpty @Size(max=64) private String name;
  @NotEmpty @Size(max=256) private String description;
  @NotNull @DecimalMin("0.010") private BigDecimal price;

  public Product() { this(null, null, null); }

  public Product(String name, String description, BigDecimal price) {
    this.name = name;
    this.description = description;
    this.price = price;
  }
  /* ... */
}</pre></div><p class="calibre7">Note that <code class="email">Product</code> takes full advantage of the Bean Validation annotations. In particular, it uses a BigDecimal type for the accurate prices and the <code class="email">@DecimalMin</code> annotation prevents storage negative and zero prices at the bounded context.</p><p class="calibre7">Given our<a id="id1004" class="calibre1"/> entity object, we will need <code class="email">ProductController</code> to <a id="id1005" class="calibre1"/>interface the domain to the presentation view:</p><div class="informalexample"><pre class="programlisting">@Path("/products")
@Stateless
public class ProductController {
  @Inject Models models;
  @Inject ValidatorFactory validatorFactory;
  @Inject FormErrorMessage formError;
  @EJB ProductService productService;

  private void defineCommonModelProperties(String title ) {
    models.put("pageTitle", "Handlebars.java Java EE 8 MVC" );
    models.put("title", title);
  }

  private void retrieveAll() {
    final List&lt;Product&gt; products = productService.findAll();
    models.put("products", products );
    models.put("title", "Products");
  }

  @GET
  @Controller
  @Path("list")
  @Produces("text/html")
  public Viewable listProducts()
  {
    retrieveAll();
    defineCommonModelProperties("Products");
    return new Viewable("/products.hbs");
  }
  /* ... */
}</pre></div><p class="calibre7">As usual, we will annotate <code class="email">ProductController</code> with the JAX-RS annotations in order to bring in the RESTful service space. We will be using Bean Validation to verify the state of our input objects, and therefore, we will inject <code class="email">ValidatorFactory</code> from the Java EE container. We will inject the <code class="email">Models</code> instance for the MVC operations. We also have a custom <code class="email">FormErrorBean</code> POJO to capture the error messages, and finally, there is an EJB, <code class="email">ProductService</code>, to persist the records to a database.</p><p class="calibre7">The <code class="email">listProducts()</code> controller method delegates to the shared methods: <code class="email">retrieveAll()</code> and <code class="email">defineCommonModelProperties()</code>. The <code class="email">retreieveAll()</code> method pulls all the products from the database using the EJB. It saves the list collection in <code class="email">Models</code> under a known property key. The <code class="email">defineCommonModelProperties()</code> method <a id="id1006" class="calibre1"/>saves a title as a key in the same <code class="email">Models</code> instance. It <a id="id1007" class="calibre1"/>turns out that many controller methods need the same functionality and so we refactored it. We will place the retrieved product collection in a <code class="email">Models</code> key property called products. Finally, <code class="email">listProducts()</code> forwards it to the Handlebars Java view template, <code class="email">product.hbs</code>. After our controller method is returned, Ozark will eventually delegate to our custom view engine: <code class="email">MyHandlebarsViewEngine</code>.</p><div class="book" title="Block expressions"><div class="book"><div class="book"><div class="book"><h3 class="title2"><a id="ch09lvl3sec48" class="calibre1"/>Block expressions</h3></div></div></div><p class="calibre7">We can take<a id="id1008" class="calibre1"/> a look at the view and learn about the useful block expressions. The following is the extract of the view template, <code class="email">/products.hbs</code>:</p><div class="informalexample"><pre class="programlisting">&lt;div class="other-content"&gt;
  &lt;div class="jumbotron"&gt;
      &lt;p&gt; {{title}} &lt;/p&gt;
  &lt;/div&gt;

  &lt;p&gt;
    &lt;a href="{{webContextPath}}/rest/products/preview-create" 
      class="btn-primary btn"&gt;Add New Product&lt;/a&gt;
  &lt;/p&gt;

  &lt;table class="product-container-table table table-bordered table-responsive table-striped"&gt;
    &lt;tr&gt;
      &lt;th&gt; Product Name &lt;/th&gt;
      &lt;th&gt; Description &lt;/th&gt;
      &lt;th&gt; Unit Price &lt;/th&gt;
      &lt;th&gt; Action &lt;/th&gt;
    &lt;/tr&gt;

    {{#each products}}
      &lt;tr&gt;
        &lt;td&gt; {{this.name}} &lt;/td&gt;
        &lt;td&gt; {{this.description}} &lt;/td&gt;
        &lt;td&gt; {{formatDecimal this.price}} &lt;/td&gt;
        &lt;td&gt;
          &lt;a class="btn" href="{{webContextPath}}/rest/products/view/{{this.id}}" &gt;&lt;i class="glyphicon glyphicon-edit"&gt;&lt;/i&gt;&lt;/a&gt;
          &lt;a class="btn" href="{{webContextPath}}/rest/products/preview-delete/{{this.id}}" &gt;&lt;i class="glyphicon glyphicon-trash"&gt;&lt;/i&gt;&lt;/a&gt;
        &lt;/td&gt;
      &lt;/tr&gt;
    {{/each}}
  &lt;/table&gt;
&lt;/div&gt;</pre></div><p class="calibre7">As you<a id="id1009" class="calibre1"/> can see, we actually used the <code class="email">{{title}}</code> expression in this view template, which was set in the <code class="email">defineCommonModelProperties()</code> method. The value for the <code class="email">{{webContextPath}}</code> placeholder is set in our extension class, <code class="email">MyHandlebarsViewEngine</code>.</p><p class="calibre7">There are two new expressions: <code class="email">{{#each}}</code> and <code class="email">{{/each}}</code>. These are the built-in block expressions that allow us to loop over a context element. In this case, we will iterate over the products. The product element at the heart of the loop becomes accessible under the <code class="email">{{this}}</code> placeholder.</p><p class="calibre7">In order to print the BigDecimal price correctly, we will invoke the <code class="email">{{formatDecimal}}</code> helper function that was defined in our custom view engine. A helper function can accept more than one parameter. The result is a rendered table of the products with their names, descriptions, and prices with the anchor links to edit or delete an item.</p><p class="calibre7">Here is the screenshot for the view template, <code class="email">products.jsp</code>:</p><div class="mediaobject"><img src="../Images/image00426.jpeg" alt="Block expressions" class="calibre10"/><div class="caption"><p class="calibre24">A product listing view template rendered by Handlebars</p></div></div><p class="calibre11"> </p></div><div class="book" title="The retrieve and edit operations"><div class="book"><div class="book"><div class="book"><h3 class="title2"><a id="ch09lvl3sec49" class="calibre1"/>The retrieve and edit operations</h3></div></div></div><p class="calibre7">Once a <a id="id1010" class="calibre1"/>customer selects a product to edit, then we will need to retrieve the data from the database and push them to a different view template. This is the purpose of the preview edit method in the controller, as follows:</p><div class="informalexample"><pre class="programlisting">  @GET
  @Controller
  @Path("view/{id}")
  @Produces("text/html")
  public Viewable retrieveProduct( @PathParam("id") int id )
  {
      final List&lt;Product&gt; products = productService.findById(id);
      models.put("product", products.get(0) );
      defineCommonModelProperties("Product");
      return new Viewable("/edit-product.hbs");
  }</pre></div><p class="calibre7">We will annotate this controller method, <code class="email">retrieveProduct()</code>, with <code class="email">@PathParam</code> in order to retrieve the product ID. With the identifier, we will simply look up the <code class="email">Product</code> entity and put the result in the request-scoped <code class="email">Models</code> property. Obviously, for a production <a id="id1011" class="calibre1"/>application, we would probably be really defensive-minded in checking whether the identifier is valid or not. The method progresses the final delivery of the response to the view template, <code class="email">/edit-products.hbs</code>. The source code for the view template is available with this book's source distribution.</p><p class="calibre7">We will move on to the next part when the user has submitted the HTML form on this page view template. If the customer submits the form, then their journey will invoke the next controller method in <code class="email">ProductController</code>, which is called <code class="email">editProduct()</code>:</p><div class="informalexample"><pre class="programlisting">@POST
@Controller
@Path("edit/{id}")
@Produces("text/html")
public Response editProduct( 
  @PathParam("id") int id,
  @FormParam("action") String action,
  @FormParam("name") String name,
  @FormParam("description") String description,
  @FormParam("price") BigDecimal price)
{
  defineCommonModelProperties("Edit Product");
  if ("Save".equalsIgnoreCase(action)) {
    final List&lt;Product&gt; products = 
      productService.findById(id);
    final Product product2 = new Product(
      name, description, price );
    final Set&lt;ConstraintViolation&lt;Product&gt;&gt; set = 
      validatorFactory.getValidator().validate(product2);
    if (!set.isEmpty()) {
      final ConstraintViolation&lt;?&gt; cv = set.iterator().next();
      final String property = cv.getPropertyPath().toString();
      formError.setProperty(
        property.substring(property.lastIndexOf('.') + 1));
      formError.setValue(cv.getInvalidValue());
      formError.setMessage(cv.getMessage());
      models.put("formError",formError);
      return Response.status(BAD_REQUEST).
         entity("error.hbs").build();
    }
    final Product product = products.get(0);
    product.setName(name);
    product.setDescription(description);
    product.setPrice(price);
    productService.saveProduct(product);
    models.put("product", product);
  }
  retrieveAll();
  return Response.status(OK).entity("/products.hbs").build();
}</pre></div><p class="calibre7">Our controller <a id="id1012" class="calibre1"/>method is invoked on the submission of the HTML form and so we will annotate it with the necessary <code class="email">@PathParam</code> and <code class="email">@FormParam</code> declarations in order to receive the product ID and properties. Our controller expects a form parameter with the <code class="email">name</code>, action. The customer may cancel the operation and if so the action does not match the <code class="email">Save</code> operation. Therefore nothing occurs and the method progress the response to the product list view.</p><p class="calibre7">With the <code class="email">Save</code> action, our method will utilize the injected <code class="email">ValidatorFactory</code> instance so as to manually validate the form parameters. As the entity product has the validation annotations, we will construct a temporary instance with the form parameter and then create a validator to check it. We do not directly change a persisted entity at this juncture because the data may be invalid. If this is the case, then the Java EE container will raise <code class="email">javax.persistence.RollbackException</code> after the controller method exits because the thread of control passes through a transaction barrier. After validating the temporary instance, a collection of the <code class="email">ConstraintViolation</code> elements is returned.</p><p class="calibre7">Let's assume that the form data is invalid. We will retrieve the information from the first violation and populate the details in a request scope <code class="email">FormErrorMessage</code> bean. The form errors are accessible in the view template from the property key, <code class="email">formError</code>. The controller method then builds a response with the HTTP Bad Request error code and then forwards to a view template, <code class="email">/error.hbs</code>.</p><p class="calibre7">On the other hand, if the form is valid according to the Bean Validation check, then we will proceed to retrieve the <code class="email">Product</code> entity from the database by the product ID. We will update the <code class="email">Product</code> entity from the form properties and then save it in the database. As we have already checked the data manually, there should not be an error in saving the data. We will build an HTTP OK response and forward to the view template, <code class="email">/products.hbs</code>.</p><div class="informalexample" title="Note"><h3 class="title2"><a id="tip44" class="calibre1"/>Tip</h3><p class="calibre7">At the time of writing this, the MVC specification leads were still developing the validation and binding of the parameters post the Early Draft Release of MVC. Notably, if a controller injected the <code class="email">javax.mvc.BindingResult</code> instance, then it would be possible to handle the form validation in a precise and narrow user story instead of globally, as in the case of a straight JAX-RS API.</p></div><p class="calibre7">To complete the picture, here is the compact version of the <code class="email">FormErrorMessage</code> bean:</p><div class="informalexample"><pre class="programlisting">@Named("error")
@RequestScoped
public class FormErrorMessage {
  private String property;
  private Object value;
  private String message;

  /* ... getters and setters omitted */
}</pre></div><p class="calibre7">This is a<a id="id1013" class="calibre1"/> request-scoped bean and we will render the information in a Handlebars view template, <code class="email">error.hbs</code>:</p><div class="informalexample"><pre class="programlisting">&lt;div class="page-header"&gt;
  &lt;h1&gt; {{pageTitle}} &lt;/h1&gt;
&lt;/div&gt;
&lt;div class="other-content"&gt; ...
  &lt;div class="main-content" &gt;
    &lt;table class="table table-stripped table-bordered table-responsive"&gt;
      &lt;tr&gt;
        &lt;th&gt;Name&lt;/th&gt;&lt;th&gt;Value&lt;/th&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
        &lt;td&gt;Property&lt;/td&gt; &lt;td&gt;{{formError.property}}&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
        &lt;td&gt;Message&lt;/td&gt; &lt;td&gt;{{formError.message}}&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
        &lt;td&gt;Value&lt;/td&gt; &lt;td&gt;{{formError.value}}&lt;/td&gt;
      &lt;/tr&gt;
    &lt;/table&gt;
  &lt;/div&gt; ...
&lt;/div&gt;</pre></div><p class="calibre7">This view renders the error message in the <code class="email">FormErrorMessage</code> bean. You might be wondering why we are sending the form validation errors to a separate view. The answer is simple: baby steps. In a professional digital application, we would take advantage of an AJAX validation and a JavaScript framework such as jQuery on the client side. Our client-side JavaScript module would invoke an HTTP POST request to an MVC controller method in order to validate the property information. This method called, say <code class="email">validateCheck()</code>, would check on a temporary instance and report with a JSON response containing the constraint violations, if any. Perhaps the members of the JSR-371 expert group will ease this part of the development for Digital.</p></div><div class="book" title="The JAX-RS global validation"><div class="book"><div class="book"><div class="book"><h3 class="title2"><a id="ch09lvl3sec50" class="calibre1"/>The JAX-RS global validation</h3></div></div></div><p class="calibre7">The problem with the <code class="email">editProduct()</code> method is that we are forced to use manual validation steps. The<a id="id1014" class="calibre1"/> only alternative at the moment is to fall back on the JAX-RS validation.</p><p class="calibre7">So, let's inspect a new version of the controller method called <code class="email">altEditProduct()</code>:</p><div class="informalexample"><pre class="programlisting">@POST
@Controller
@Path("alt-edit/{id}")
@Produces("text/html")
public Response altEditProduct( 
  @PathParam("id") int id,
  @FormParam("action") String action,
  @NotNull @NotEmpty @FormParam("name") String name,
  @NotNull @NotEmpty @FormParam("description") String description,
  @NotNull @DecimalMin("0.0") @FormParam("price") BigDecimal price )
{
  defineCommonModelProperties("Edit Product");
  if ("Save".equalsIgnoreCase(action)) {
    final List&lt;Product&gt; products = productService.findById(id);
    final Product product = products.get(0);
    product.setName(name);
    product.setDescription(description);
    product.setPrice(price);
    productService.saveProduct(product);
    models.put("product", product);
  }
  retrieveAll();
  return Response.status(OK).entity("/products.hbs").build();
}</pre></div><p class="calibre7">This time, we will inscribe the Bean Validation annotations directly on the controller method, <code class="email">altEditProduct()</code>. You might be concerned that this is duplication, with the annotation already on the Entity bean. You would be correct, but let's continue. The <code class="email">altEditMethod()</code> method is shorter, which is great. There is a problem now with this approach in that the validation is delegated globally to JAX-RS. If the customer submits an HTML form to <code class="email">altEditMethod()</code>, then they will send an HTTP Bad Request error response and a user-unfriendly error message direct from the application server. Obviously, the UX team would be throwing a fit! What can we do?</p><p class="calibre7">The JAX-RS specification permits an application to provide a handler for an error response. The way to achieve this goal is to configure a provider through CDI, as follows:</p><div class="informalexample"><pre class="programlisting">package uk.co.xenonique.basic.mvc;
import javax.annotation.Priority;
import javax.mvc.*;
import javax.ws.rs.*;
/* ... other import omitted ... */
import static javax.ws.rs.core.Response.Status.*;

@Provider
@Priority(Priorities.USER)
public class ConstraintViolationExceptionMapper
  implements ExceptionMapper&lt;ConstraintViolationException&gt; {
  @Context HttpServletRequest request;

  @Override
  public Response toResponse(
    final ConstraintViolationException exception) {
    final Models models = new com.oracle.ozark.core.ModelsImpl();
    final ConstraintViolation&lt;?&gt; cv = 
      exception.getConstraintViolations().iterator().next();
    final String property = cv.getPropertyPath().toString();
    final FormErrorMessage formError = new FormErrorMessage();
    formError.setProperty(
      property.substring(property.lastIndexOf('.') + 1));
    formError.setValue(cv.getInvalidValue());
    formError.setMessage(cv.getMessage());
    models.put("formError",formError);
    request.setAttribute("formError", formError);
    final Viewable viewable = new Viewable("error.hbs", models);
    return Response.status(BAD_REQUEST).entity(viewable).build();
  }
}</pre></div><p class="calibre7">This <code class="email">ConstraintViolationExceptionMapper</code> class is a JAX-RS provider because we annotated it with <code class="email">@javax.ws.rs.ext.Provider</code>. The class is generically typed to <code class="email">ConstraintViolationException</code> and therefore, it handles all the failures in the web application! There is no leeway here. We will inject into the <code class="email">HttpServletRequest</code> POJO in order to<a id="id1015" class="calibre1"/> get access to the web context. The <code class="email">toResponse()</code> method transforms the constraint violation into a new response. We will need an implementation of the <code class="email">Models</code> instance, so we will instantiate the class in the Ozark framework. We will build a <code class="email">FormErrorMessage</code> POJO directly and populate it from the first instance of a <code class="email">javax.validation.ConstraintViolation</code> type. We will set a key property in the <code class="email">Models</code> instance and servlet request scope. From here, we will create a <code class="email">Viewable</code> instance with the view template reference, <code class="email">error.hbs</code>, and the <code class="email">Models</code> instance and then build and return a response.</p><p class="calibre7">It is worth looking at some of the internals of the reference implementation, Ozark. We have always seen <code class="email">ViewEngineBase</code> and <code class="email">ViewEngineContext</code>. Here is a diagram of some of the<a id="id1016" class="calibre1"/> important internal classes and their packages:</p><div class="mediaobject"><img src="../Images/image00427.jpeg" alt="The JAX-RS global validation" class="calibre10"/></div><p class="calibre11"> </p></div></div><div class="book" title="An MVC binding result validation"><div class="book"><div class="book"><div class="book"><h2 class="title1"><a id="ch09lvl2sec111" class="calibre1"/>An MVC binding result validation</h2></div></div></div><p class="calibre7">The MVC <a id="id1017" class="calibre1"/>specification has an API for fine grain validation, which is still being decided on. There are two interface types—<code class="email">BindingResult</code> and <code class="email">BindingError</code>—in the <code class="email">javax.mvc.binding</code> package.</p><p class="calibre7">
<code class="email">BindingResult</code> captures the constraint violations during an attempt to validate the input arguments of an MVC controller method, which is annotated with <code class="email">@FormParam</code>. The specification describes the term binding to reflect the association between the form parameter and actual type of the property that is being validated and the possible constraint violations that could occur. Therefore, an integer property cannot be bound if the HTML form parameter, which is a string, cannot be converted to a number in a meaningful manner. The interface for <code class="email">BindingResult</code> is as follows:</p><div class="informalexample"><pre class="programlisting">package javax.mvc.binding;
public interface BindingResult {
  boolean isFailed();
  List&lt;String&gt; getAllMessages();
  Set&lt;BindingError&gt; getAllBindingErrors();
  BindingError getBindingError(String param);
  Set&lt;ConstraintViolation&lt;?&gt;&gt; getViolations(String param);
  ConstraintViolation&lt;?&gt; getViolation(String param);
}</pre></div><p class="calibre7">The interesting members of <code class="email">BindingResult</code> are <code class="email">isFailed()</code>, <code class="email">getAllViolations()</code>, and <code class="email">getAllBindingErrors()</code>.</p><p class="calibre7">The <code class="email">BindingError</code> type is designed to represent a single error that occurs while binding a parameter to<a id="id1018" class="calibre1"/> a controller method. Here is the condensed interface API for this type:</p><div class="informalexample"><pre class="programlisting">package javax.mvc.binding;
public interface BindingError {
  String getMessage();
  String getMessageTemplate();
  String getParamName();
}</pre></div><p class="calibre7">The <code class="email">BindingError</code> type works similarly to the Bean Validation specification for an interpolated message. Therefore, it is helpful for internationalization because the messages may be retrieved from <code class="email">java.util.ResourceBundle</code>.</p><p class="calibre7">For our final example, we will use <code class="email">BindingResult</code> to validate our new <code class="email">editMethod()</code> method:</p><div class="informalexample"><pre class="programlisting">@Path("/products")
@Stateless
public class ProductController {
  @Inject BindingResult br;
  
  /* ... */

  @POST
  @Controller
  @Path("edit/{id}")
  @Produces("text/html")
  @ValidateOnExecution(type = ExecutableType.NONE)
  public Response editProduct( 
    @PathParam("id") int id,
    @FormParam("action") String action,
    @Valid @BeanParam Product incomingProduct)
  {
    defineCommonModelProperties("Edit Product");
    if ("Save".equalsIgnoreCase(action)) {
      Set&lt;ConstraintViolation&lt;?&gt;&gt; set = vr.getAllViolations();
      if (!set.isEmpty()) {
        final ConstraintViolation&lt;?&gt; cv = set.iterator().next();
        final String property = cv.getPropertyPath().toString();
        formError.setProperty(
            property.substring(property.lastIndexOf('.') + 1));
        formError.setValue(cv.getInvalidValue());
        formError.setMessage(cv.getMessage());
        models.put("formError",formError);
        return Response.status(BAD_REQUEST).
          entity("error.hbs").build();
      }
      final List&lt;Product&gt; products = productService.findById(id);
      final Product product = products.get(0);
      product.setName(incomingProduct.getName());
      product.setDescription(incomingProduct.getDescription());
      product.setPrice(incomingProduct.getPrice());
      productService.saveProduct(product);
      models.put("product", product);
    }
    retrieveAll();
    return Response.status(OK).entity("/products.hbs").build();
  }
}</pre></div><p class="calibre7">In order to get<a id="id1019" class="calibre1"/> the benefit of fine grain validation, we will inject <code class="email">@BindingResult</code> as a property into <code class="email">ProductController</code>. We will change the annotations around the <code class="email">editProduct()</code> method. In order to ensure that JAX-RS performs the validation and the CDI and Bean Validation do not abort the process, we will annotate <code class="email">@ValidateOnExecution</code> and set the type parameter to <code class="email">ExecutableType.NONE</code>. According to the Bean Validation specification, the <code class="email">@ValidateOnExecution</code> annotation is used to selectively enable and disable the violation. Switching off the validation allows JAX RS to take over our controller method, <code class="email">editProduct()</code>. We will also use <code class="email">@Valid</code> and <code class="email">@BeanParam</code> to direct the MVC provider to validate the <code class="email">Product</code> entity bean.</p><p class="calibre7">MVC takes over the validation when it notices that the controller class has injected the <code class="email">BindingResult</code> instance or has a JavaBean setter method that accepts <code class="email">BindingResult</code>. In the <code class="email">editProduct()</code> method, we will check the Boolean status of the validation by calling the <code class="email">isFailed()</code> method. If the input failed to get validated, we will grab the first constraint violation from the <code class="email">BindResult</code> result and then populate the <code class="email">FormErrorMessage</code> bean as before. We will then send an HTTP response with a Bad Request error code that forwards to the <code class="email">error.hbs</code> view template.</p><p class="calibre7">Note that we will write the <code class="email">editProduct()</code> method with a separate named variable argument, <code class="email">incomingProduct</code>, in order to keep a temporary holder of the HTML form data. We will copy the properties of this variable over the product entity that is retrieved from the database and save it. By the time we reach the end of the controller method, the entity bean must be valid. We will retrieve a list of the products and return an OK response. With <code class="email">BindingResult</code>, it is clear to the developers that this validation is easier to program <a id="id1020" class="calibre1"/>with. There is less code to deliberate over.</p></div></div>
<div class="book" title="Design considerations" id="aid-2LQIK1"><div class="book"><div class="book"><div class="book"><h1 class="title"><a id="ch09lvl1sec83" class="calibre1"/>Design considerations</h1></div></div></div><p class="calibre7">MVC is a very promising specification, and at the moment, the view technology solution is usual for digital developers. There is still a story to be developed regarding the handling of an HTTP redirects response and especially a way to hold over a form state. Many digital <a id="id1021" class="calibre1"/>web developers are already familiar with the design pattern, HTTP POST– REDIRECT–GET (<a class="calibre1" href="https://en.wikipedia.org/wiki/Post/Redirect/Get">https://en.wikipedia.org/wiki/Post/Redirect/Get</a>), and therefore, they would be looking for an equivalent and safe option in the MVC specification.</p><p class="calibre7">On the other <a id="id1022" class="calibre1"/>side of the equation lies the question about an HTML form validation; however, there may be breaking news on this front. The story on form validation shares much of the ground as HTTP redirect requests. Developers want to take advantage of the Bean Validation on an entity but they also want to seamlessly invoke the validation in a controller and introspect the validation result. The fact is that JAX-RS allows the validation through a global provider. However, this approach does not provide fine-grain validation handling and it cannot map constraint violation instances to individual HTML form input elements. Nevertheless, the post Early Draft Release snapshots have shown early promise in this regard.</p><p class="calibre7">As we have seen in the Handlebars Java code examples, there is a design consideration and trade-off for many digital architects. How much of the presentation logic resides in the client against the server side?</p><div class="book" title="Majority server-side templating"><div class="book"><div class="book"><div class="book"><h2 class="title1"><a id="ch09lvl2sec112" class="calibre1"/>Majority server-side templating</h2></div></div></div><p class="calibre7">Considering the <a id="id1023" class="calibre1"/>option of mostly server-side templating, why would a technical architect choose this mode? There are a lot of <a id="id1024" class="calibre1"/>reasons for this approach. One reason may be that the team is slightly intimidated by JavaScript programming and wants minimum dependencies and time-to-market. This is a skill, training, and maintenance trade-off. Another reason might be that the final end client devices are sufficiently underpowered, such as an Internet of Things device. It is unlikely that a digital thermostat would have to render retina edition images. Yet another reason could be an easier migration for a very old legacy application in order to bring it up to date: this is digital transformation. MVC can help here with the extensive view templates support.</p></div><div class="book" title="Majority client-side templating"><div class="book"><div class="book"><div class="book"><h2 class="title1"><a id="ch09lvl2sec113" class="calibre1"/>Majority client-side templating</h2></div></div></div><p class="calibre7">This design <a id="id1025" class="calibre1"/>choice implies that the client side renders much of the content on a device. It has been said that smartphones <a id="id1026" class="calibre1"/>with JavaScript and HTML5 have orders of magnitude of computing power over the rocket ship computers that took humankind to the moon. One reason that a technical architect might want to delegate the load to a client is to reduce the load on a server application. This is a trade-off in scalability on the server. Handlebars.js is a JavaScript view templating implementation that is perfectly adequate for this requirement among the other competing JavaScript frameworks out there on the Internet. The MVC controllers in this mode become thin layers of architecture that truly bind the view to the model. This mode may also be appropriate if your team features very strong interface designers and developers or if they have a lack of experience with the modern Java EE development. On the UI front, there may be a valid reason to have customer journeys that map to a page-by-page navigation. Therefore, the architecture avoids single page applications and this might rule out frameworks such as AngularJS.</p></div><div class="book" title="Shared templating"><div class="book"><div class="book"><div class="book"><h2 class="title1"><a id="ch09lvl2sec114" class="calibre1"/>Shared templating</h2></div></div></div><p class="calibre7">The final design<a id="id1027" class="calibre1"/> choice is to combine both the client-side <a id="id1028" class="calibre1"/>and server-side templating and share the responsibility of the presentation view. This may be a favored strategy for the digital technical architects working across cross-functional teams. If there is a strong interface development team and server-side Java EE team and they communicate well, then this is a reasonable approach. Apart from human resource considerations in an agile team, this approach technically favors an architecture where there is a shared template and vision to organize the digital assets. Let's say the architecture is decided on Handlebars Java on the server and Handlebars.js on the client-side; the team is immediately faced with the organization of the view templates. Which templates are compiled on the JavaScript frontend and which templates matter on the server side? The resolution to this design choice will result in the construction of the MVC controllers on the server side.</p><p class="calibre7">Let me leave you with one note of warning about these three design considerations. If you are worth your salt, you will consider the effect of the UX changes and sudden surprises. Therefore, a digital technical architect must factor the effect of design changes into his or her calculations.</p></div></div>
<div class="book" title="Summary" id="aid-2MP361"><div class="book"><div class="book"><div class="book"><h1 class="title"><a id="ch09lvl1sec84" class="calibre1"/>Summary</h1></div></div></div><p class="calibre7">In this final chapter of the book, we covered the burgeoning MVC specification from the ground up. We covered the essential elements of the models, views, and controllers. We saw that MVC is a layering on top of JAX-RS and it reuses the same annotations, including <code class="email">@GET</code>, <code class="email">@FormParam</code>, <code class="email">@Path</code>, <code class="email">@FormParam</code>, and <code class="email">@POST</code>.</p><p class="calibre7">In order to establish a method as an MVC controller, we annotated them with <code class="email">@Controller</code>. We wrote controllers that generate either the response instance or, if they returned a void type, we would annotate the method with <code class="email">@View</code>.</p><p class="calibre7">You learned about the various view technologies that are supported by the MVC reference specification, Ozark. We used the Handlebars Java view template to build the elements of a CRUD example. We also understood that the MVC specification might change in respect to the redirection and validation APIs.</p></div>
<div class="book" title="Exercises" id="aid-2NNJO1"><div class="book"><div class="book"><div class="book"><h1 class="title"><a id="ch09lvl1sec85" class="calibre1"/>Exercises</h1></div></div></div><p class="calibre7">Here are the questions and exercises for this chapter:</p><div class="book"><ol class="orderedlist"><li class="listitem">What are the constituent components of the Java EE MVC framework? What does MVC attempt to solve?</li><li class="listitem">What is the difference between <code class="email">@Controller</code>, <code class="email">@Model</code>, and <code class="email">@View</code>?</li><li class="listitem">What is the difference between the Response and Viewable types?</li><li class="listitem">Given that the standard HTML form element does not send an HTTP PUT or DELETE request, just how would you handle the removing of a record from the database using MVC? What does this mean for the businesses that already have full RESTful interfaces?</li><li class="listitem">By the time this book is published, the MVC framework will be further along and there is likely to be many milestone releases. Update your knowledge. What has changed? Look especially at the redirection and validation.</li><li class="listitem">Download the <code class="email">handlebars-javaee-mvc-validation</code> project from the book's source code repository and adapt the product instance in order to include the <code class="email">description</code> (<code class="email">string</code>), <code class="email">manufacturer</code> (<code class="email">string</code>), and <code class="email">manufacturedDate</code> (<code class="email">java.util.Date</code>) properties. What needs to happen in order to display a formatted date correctly (say, MMM-dd-yyyy or dd-MMM-yyyy)?</li><li class="listitem">Working from the previous exercise, ensure that the proper validation techniques are in place using MVC. How would you validate the user input?</li><li class="listitem">If you are reasonably comfortable with the JavaScript programming, write a module to invoke validation over AJAX. (Hint: you will probably need to understand the JQuery REST requests and responses.)</li><li class="listitem">In this exercise, take the <code class="email">Product</code> entity and <code class="email">ProductController</code> controller classes and use them as a basis to experiment with another view template technology with the Ozark reference implementation. There are plenty of choices. Adapt a new templating framework to the product CRUD application—try Thymeleaf or even AsciiDoc. What is the difference between the templating choices? What are the benefits? What are the disadvantages?</li><li class="listitem">Write a short essay that proposes the MVC framework to your current team for a particular project. What are the design considerations of the MVC approach? Does your target audience suit a single page navigation or page-by-page navigation or a mixture of both the ideas? (Hint: personas might be useful; you can write a proposal aimed to convince the technical leader in your team or you might be a technical leader aiming to convince the members in your team.)</li></ol><div class="calibre25"/></div></div></body></html>