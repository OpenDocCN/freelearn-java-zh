- en: '2'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Code, Compile, and Execute
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With Java installed, we are almost ready to look at coding. Before we get to
    that, though, we need to learn how to code, compile, and execute Java applications.
    While an **integrated development environment** (**IDE**) will likely be what
    you will use for most of your work, understanding how to code without the hand-holding
    of an IDE is what makes the difference between a Java tinkerer and a Java professional.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will look at working from the command line and then from
    some of the most widely used IDEs. This chapter will not be a tutorial on IDEs
    but rather a review of what they offer to a programmer. The fundamental operation
    of any IDE is very similar to that of the most commonly used IDEs. Before we examine
    the various ways to use Java, we will look at a small program that we will use.
    This book is a *Hello World!* free zone, which means that example number one does
    something useful.
  prefs: []
  type: TYPE_NORMAL
- en: 'The goal of this chapter is to make you familiar with the four approaches to
    compiling and executing Java code as well as introduce you to the IDE tools available
    to developers. We will be covering the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: The first program
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: JShell – REPL in Java
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The two-step compile and execute process – `javac` and `java`/`javaw`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Launch Single-File Source-Code Programs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Integrated development environments
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To follow the examples in this chapter, you will need the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Java 17 installed
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A text editor, such as Notepad
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can find the code files for this chapter on GitHub at [https://github.com/PacktPublishing/Transitioning-to-Java/tree/chapter02](https://github.com/PacktPublishing/Transitioning-to-Java/tree/chapter02).
  prefs: []
  type: TYPE_NORMAL
- en: The first program
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before we can learn how to compile and execute Java code, we need a Java program
    to work with. Our first program will calculate compound interest. There is a quote
    attributed to Albert Einstein, who is said to have stated, “*Compound interest
    is the eighth wonder of the world*.” Whether he ever said this remains in doubt.
    Regardless, calculating interest on interest is one of the most important financial
    calculations that can be performed. Here is the formula that we will implement:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B19088_02_001.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Here, *P* is the principal amount deposited into a compound interest account,
    *r* is the interest rate typically expressed as an annual rate, *n* is the number
    of compounding periods (if compounded monthly, then the value is 12), and *t*
    is the time the money will compound for. This is expressed in years and must be
    divided by the number of compounding periods, which, in this case, will also be
    12.
  prefs: []
  type: TYPE_NORMAL
- en: In *Part 2* of this book, we will examine the syntax and structure of the language.
    There, we will explore the code of this program. For this reason, we will just
    use this program, which is simple to understand. You can download it from this
    book’s GitHub repository.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the code for a simple program in Java that will calculate what a fixed
    amount of money will be worth after a length of time has passed at a fixed rate
    of interest:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: All Java programs must consist of at least one structure known as a **class**.
    Whereas C++ allows you to mix the structured style and the object-oriented style,
    Java requires the latter style.
  prefs: []
  type: TYPE_NORMAL
- en: With that, you’ve seen your first complete Java program. If you are coming from
    a C++ or C# background, you likely understand how it works. If you don’t have
    an **object-oriented programming** (**OOP**) background, you can look at it as
    a structured program. In *Part 2* of this book, we will explore the syntax of
    Java. Next, we will run this program in three different ways from the command
    line.
  prefs: []
  type: TYPE_NORMAL
- en: JShell – REPL in Java
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Read-Eval-Print Loop** (**REPL**) is an environment where code can execute
    one line at a time. REPL became a standard part of Java in version 9\. It is implemented
    in a tool called JShell. It serves two purposes:'
  prefs: []
  type: TYPE_NORMAL
- en: It provides an environment for learning Java without any background in programming.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It provides a way to quickly test concepts, syntax, and libraries.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As such, you can execute Java code without the need for the usual decorations.
  prefs: []
  type: TYPE_NORMAL
- en: There are two ways we can use JShell. The first is to just enter the code that’s
    necessary to use the formula. Imagine that you want to verify the formula for
    compound interest, as shown in the source code. You can do that by just entering
    the necessary code to perform the calculation.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following code block, we have entered the four variable declarations
    with the values required for the calculation, followed by the line of code that
    performs the calculation and assigns it to a variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Follow these steps in JShell to enter these five lines of code:'
  prefs: []
  type: TYPE_NORMAL
- en: 'On Windows, open the Command Prompt. If you are working on a macOS/Linux system,
    go to the Terminal. If necessary, set the `Path` and `JAVA_HOME` values. Then,
    enter the `jshell` command. The console will look like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 2.1 – Running JShell](img/Figure_2.1_B19088.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.1 – Running JShell
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we can enter the following five lines of code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 2.2 – Executing one line at a time in JShell ](img/Figure_2.2_B19088.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.2 – Executing one line at a time in JShell
  prefs: []
  type: TYPE_NORMAL
- en: Note that each line is being executed as it is being entered and JShell reports
    the value that’s been assigned to each variable. Java does not format values on
    its own, so the result is a raw floating-point number.
  prefs: []
  type: TYPE_NORMAL
- en: 'Can we assume that since it was executed without any errors, the result is
    correct? Absolutely not! Especially for calculations, you need a second source
    for the result. This is where a spreadsheet is invaluable. Here is the result
    of the calculation after using the formula in Microsoft Excel:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.3 – The compound interest calculation in Excel](img/Figure_2.3_B19088.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.3 – The compound interest calculation in Excel
  prefs: []
  type: TYPE_NORMAL
- en: If any errors occurred while you entered your code, which means that your code
    doesn’t match the result in the spreadsheet, then you can clear everything you
    entered into JShell with the `/reset` command and start over. JShell always preserves
    the last piece of code you entered unless you reset it. JShell also maintains
    a history of everything you entered and is not lost when you use `/reset`. **History**,
    which can be accessed with the up and down arrows, will just allow you to enter
    the code you used previously into what you are currently working on.
  prefs: []
  type: TYPE_NORMAL
- en: The second way that we can use JShell is by using an editor and making an entire
    program available to the tool. Before we provide JShell with the complete program,
    we must use the `/reset` command to remove what we entered previously.
  prefs: []
  type: TYPE_NORMAL
- en: 'To execute the entire program, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: JShell has a basic editor that supports multi-line Java code. Use the `/edit`
    command to open the editor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This editor cannot open files, so you will need to open the `CompoundInterest01.java`
    file in your text editor, copy the file’s contents, and paste it into the JShell
    editor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'When you click on **Accept**, the code from the JShell editor will be transferred
    to JShell:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 2.4 – The program after being pasted into the default JShell editor](img/Figure_2.4_B19088.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.4 – The program after being pasted into the default JShell editor
  prefs: []
  type: TYPE_NORMAL
- en: Now, you must click **Exit** to leave the editor, which will restore the JShell
    prompt.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, you can run the `main` method by entering `CompoundInterest01.main(null)`
    in the JShell prompt, which will cause the program to execute. The `main` method
    expects a parameter. Should you not have a parameter to pass to the `main` method,
    then you will automatically pass null:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 2.5 – Running the program in JShell after it has been transferred
    from the editor](img/Figure_2.5_B19088.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.5 – Running the program in JShell after it has been transferred from
    the editor
  prefs: []
  type: TYPE_NORMAL
- en: 'You do not have to use the basic editor in `/set editor` command and include
    the path to the editor of your choice, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.6 – Changing the editor in JShell](img/Figure_2.6_B19088.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.6 – Changing the editor in JShell
  prefs: []
  type: TYPE_NORMAL
- en: Here, I have set the editor to Notepad++ for Windows. Note that there are double
    backslashes for the path separators in the `/set editor` command as it is being
    entered on a Windows system. On a Linux or Mac system, the path separator is a
    forward slash and is not doubled. As there are spaces in the path, they must be
    enclosed in quotation marks.
  prefs: []
  type: TYPE_NORMAL
- en: When using an external editor with JShell, you must exit the editor to transfer
    what you have typed to JShell. This is because there is no *Accept* button.
  prefs: []
  type: TYPE_NORMAL
- en: The JShell tool can be useful for testing or learning a new feature or syntax
    in Java. It can also be quite useful for teaching Java to absolute beginners.
    Familiarize yourself with this tool as soon as possible.
  prefs: []
  type: TYPE_NORMAL
- en: The two-step compile and execute process – javac and java/javaw
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The most common approach to running a Java program involves two steps. First,
    you must compile the code with javac and then execute the code in the **Java Virtual
    Machine** (**JVM**) with Java or on Windows with javaw.
  prefs: []
  type: TYPE_NORMAL
- en: The first step of preparing Java source code for execution is to compile it
    into **bytecode**. This is the machine language of the JVM. Every Java source
    file that is part of an application must be compiled into bytecode.
  prefs: []
  type: TYPE_NORMAL
- en: The second step is to execute the bytecode in a JVM. Unlike C or C++, there
    is no link step. The link step combines all compiled code into a single executable
    file. In Java, all the bytecode files must be on the classpath, which is the path
    to all bytecode files, and not necessarily combined into a single file. This may
    seem confusing as there is a tool called **jlink**, but its purpose is to combine
    the Java runtime with your code so that the end user does not need the Java version
    that was previously installed on their computer. We will examine **jlink** in
    [*Chapter 16*](B19088_16.xhtml#_idTextAnchor315), *Deploying Java in Standalone
    Packages* *and Containers*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us compile and execute our `CompoundInterest01` program:'
  prefs: []
  type: TYPE_NORMAL
- en: First, place the `CompoundInterest01.java` file in a folder of its own. This
    is not a requirement, but it is easier to manage the code if it has its own folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, open a console in that folder; if you are not using an admin installation
    of Java, set the `Path` and `JAVA_HOME` properties as shown in the previous chapter.
    Now, you can compile the program with `javac CompoundInterest01.java`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 2.7 – Compiling the Java program](img/Figure_2.7_B19088.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.7 – Compiling the Java program
  prefs: []
  type: TYPE_NORMAL
- en: If compiling your code does not result in any errors, then the compiler will
    not display anything in the console. The folder will now contain a new file called
    `CompoundInterest01.class`. Notice that it is larger than the Java source code
    file.
  prefs: []
  type: TYPE_NORMAL
- en: A Java class file contains the necessary **bytecode** and source code. The presence
    of the source code in this file supports the concepts of **reflection** and **introspection**.
  prefs: []
  type: TYPE_NORMAL
- en: Introspection allows you to write code that can examine the type or properties
    of an object at runtime, whereas reflection allows you to write code that can
    examine and modify the structure of an object at runtime. These two features are
    rarely used in business programming. .
  prefs: []
  type: TYPE_NORMAL
- en: With the code compiled, we can run it. Here, we are using the `java` executable
    to run our program.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A common myth is to believe that the `java` executable is the JVM. It is not.
    It is the loader of the JVM, made up of other files that are part of the installation
    of the JDK. The JVM utilizes its `ClassLoader` component to locate and execute
    a bytecode file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us run the `CompoundInterest01` program. In the console, enter `java CompountInterest01`.
    There’s no need to include the `.class` extension as that is the only acceptable
    extension:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.8 – Running the Java program](img/Figure_2.8_B19088.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.8 – Running the Java program
  prefs: []
  type: TYPE_NORMAL
- en: Here, you can see the program’s output.
  prefs: []
  type: TYPE_NORMAL
- en: On Windows systems, there is a second JVM loader called javaw that is used to
    execute a GUI application without opening a console. If you create a Windows shortcut
    to run a GUI Java program and use `java.exe`, then a console window will open,
    followed by the program’s GUI window. If you use `javaw.exe`, the console window
    will not appear.
  prefs: []
  type: TYPE_NORMAL
- en: In most situations, using javac and then java is the most common way to work
    with Java code at the command line. A program that may consist of multiple files
    will require each file to be compiled, but only the file that contains the `main`
    method is executed. Let us look at one last way to compile and execute a Java
    program in a single step.
  prefs: []
  type: TYPE_NORMAL
- en: Launch Single-File Source-Code Programs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before Java 11, the process of going from source code to execution was a two-step
    process: you compiled the code and then ran the code. Beginning with Java 11,
    another way to run a Java program was introduced, called **Launch Single-File
    Source-Code Programs**. This allows you to compile, start up the JVM, and execute
    the program in a single line. We’ll see how this works for Windows, macOS, and
    Linux before examining a unique way for Linux and macOS.'
  prefs: []
  type: TYPE_NORMAL
- en: For Windows, macOS, and Linux
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Open a Command Prompt or Terminal in the same folder as the file you wish to
    run and, if necessary, update the `Path` and `JAVA_HOME` properties. Now, simply
    enter `java` and the name of the source file:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.9 – Running a Java program ](img/Figure_2.9_B19088.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.9 – Running a Java program
  prefs: []
  type: TYPE_NORMAL
- en: 'As the name of this technique implies, your program can only consist of a single
    file. This source file may contain more than one class and the first class in
    the file must have a `main` method. Let us look at a new version of the program
    that is split into two classes in one file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The first class in this file just contains the `main` method, which is required.
    The second class, shown in the following code block, is in the same file; this
    is where the actual work is carried out:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The two classes are `CompoundInterest02` and `CompoundInterestCalculator02`.
    In the Command Prompt or Terminal, enter `java CompoundInterest02.java`; you will
    get the same result:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.10 – Running a Java program with two classes in the java file](img/Figure_2.10_B19088.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.10 – Running a Java program with two classes in the java file
  prefs: []
  type: TYPE_NORMAL
- en: This technique does not create a bytecode `.class` file; it is only created
    in memory.
  prefs: []
  type: TYPE_NORMAL
- en: For macOS and Linux – Shebang files
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There is a unique way to use Launch Single-File Source-Code Programs that is
    only available on macOS or Linux: `java` command. This makes single-file Java
    programs usable as a script file akin to Bash. Shebang is the name given to the
    `#!` Characters.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s look at the beginning of the source code with the Shebang added:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add `#!` to the source code, as shown here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The first line that begins with the Shebang includes the path to the Java executable
    and the `–source version` switch. The version is the numbered version of Java
    you are using, which in this case is `17`. To use this technique, the file must
    not have the `.java` extension. Rename the Java source code file to remove the
    extension.
  prefs: []
  type: TYPE_NORMAL
- en: The next step is to make the file executable. Use `chmod +x CompoundInterest03`
    to do so.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Finally, you must execute the file by entering `./CompoundInterest03`. Here
    is the output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 2.11 – Running a Java program with a Shebang in Linux](img/Figure_2.11_B19088.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.11 – Running a Java program with a Shebang in Linux
  prefs: []
  type: TYPE_NORMAL
- en: Here, we are running our Java program as if it were just a regular Linux or
    macOS program.
  prefs: []
  type: TYPE_NORMAL
- en: This concludes our topic on using Java from the command line. We started by
    looking at REPL in JShell, then the classic two-step approach, and ended with
    the Launch Single-File Source-Code Programs approach. We also covered the unique
    Shebang technique. Now, let us learn about the four most widely used IDEs.
  prefs: []
  type: TYPE_NORMAL
- en: Integrated development environments
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It is time for a little honesty – very few Java developers work with just a
    text editor such as **vi** or **Notepad**. Knowing how to work with a standalone
    text editor and compile/execute at the command line is an important skill, but
    when given the choice of tooling, we will always go for an IDE. The features we
    will look at in this section will explain why this is so.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we will briefly review four of the most widely used IDEs available.
    Each IDE has a unique build system, which we will discuss in [*Chapter 3*](B19088_03.xhtml#_idTextAnchor062),
    *The Maven Build Tool*, and all the IDEs support the same external build systems.
    This means that in a team, each member can use the IDE that they feel makes them
    the most productive while being able to freely move code between team members
    without the need to make changes for a particular IDE. Before I introduce these
    IDEs, let us look at the features they all share.
  prefs: []
  type: TYPE_NORMAL
- en: Feature 1 – the code editor
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The heart of every IDE is its editor. Like any ordinary text editor, it supports
    the usual list of features, such as cut, copy, and paste. What sets the IDE editor
    apart from these is that every keystroke is monitored. Should you mistype the
    name of a variable or method, you will immediately be informed on your screen
    of the error.
  prefs: []
  type: TYPE_NORMAL
- en: The editors also share JShell’s ability to execute code one line at a time.
    This occurs out of sight. If you are executing code that generates an error –
    such as referring to a library that is not part of the project – you will be told
    of the error in the editor as you type rather than when you try to compile and
    execute the code. Most errors in your code, though not all, are detected as you
    type.
  prefs: []
  type: TYPE_NORMAL
- en: Another invaluable feature of these editors is called **code completion**. Microsoft
    calls this feature **IntelliSense**. Code completion can mean several things –
    for example, if you write an opening brace, bracket, or parenthesis, the IDE will
    add the closing one.
  prefs: []
  type: TYPE_NORMAL
- en: 'In Java, like some other OOP languages, the dot operator (`.`) indicates that
    you wish to call upon a member method or instance variable of an object. Code
    completion supports listing all the possible choices after the dot operator. The
    following figure shows all the choices for `percentFormat`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.12 – Example of code completion in NetBeans](img/Figure_2.12_B19088.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.12 – Example of code completion in NetBeans
  prefs: []
  type: TYPE_NORMAL
- en: Code completion can also recommend changes in your code that are more efficient
    or modern. For example, the original Java **switch** statement is identical to
    the C switch. Recent enhancements to the switch syntax can effectively eliminate
    the ancient switch. If the IDE recognizes that the modern syntax could be used,
    then you will be advised and, with your permission, the IDE will rewrite your
    switch in the new format.
  prefs: []
  type: TYPE_NORMAL
- en: Feature 2 – server management
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Servers** represent external services that your code may need to interact
    with. Examples include database servers such as **MySQL** and **PostgreSQL** and
    web servers such as **Payara** and **WildFly**. From within the IDE, it is possible
    to stop and start these services. For database servers, you can connect the IDE
    to the server and write **SQL** queries and see the results. Applications or web
    servers can also be started and stopped. You can deploy or undeploy your compiled
    code to the server.'
  prefs: []
  type: TYPE_NORMAL
- en: Feature 3 – debugging and profiling
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Single-stepping through code is an invaluable feature of debugging tools. Modern
    IDEs provide such debugging capabilities; it is invaluable when your code runs
    but returns the wrong result. When running with a debugger, you can follow the
    execution of your program in the source code. You can inspect the state of the
    variables. Errors in the syntax of your coding are mostly recognized by the editor.
  prefs: []
  type: TYPE_NORMAL
- en: Profiling allows you to monitor your application while it runs. The profiler
    reports memory usage and the CPU time that a method consumes. This can be invaluable
    information in identifying where a program executes more slowly than you expected.
    Even if you did not suspect a problem with program speed, a profiler can provide
    you with the data you need to improve the performance of your program.
  prefs: []
  type: TYPE_NORMAL
- en: Feature 4 –  source control management
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Modern IDEs support interaction with source control management tools such as
    **Git**, **Mercurial**, and **Subversion**. These tools maintain your code in
    a repository. There is no need to use a standalone client tool to push or pull
    from a repository. Should a push result in a conflict, then the IDE can present
    what is currently in the repository and what you want to push and allow you to
    decide how to resolve the conflict.
  prefs: []
  type: TYPE_NORMAL
- en: Feature 5 – build systems
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The only code we have seen so far has consisted of a single file. As we learn
    more about Java, we will discover that applications typically consist of multiple
    files. These files may be placed in multiple folders. Then, there are external
    libraries that provide capabilities that are not part of Java, such as the code
    necessary to interact with specific databases. A build system is responsible for
    ensuring that all the components and libraries are available. It is also responsible
    for running the Java compiler and then running the program.
  prefs: []
  type: TYPE_NORMAL
- en: All IDEs each have their own build system. The external build systems known
    as Apache Maven and Gradle, which are independent of an IDE, will be covered in
    the next chapter. The four IDEs we will cover in this chapter all support these
    external build systems. This means that if you write a program with IntelliJ that’s
    been configured to use Maven, then the same files can be opened in NetBeans if
    it’s been configured to use Maven.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let us take a brief look at the four most widely used IDEs.
  prefs: []
  type: TYPE_NORMAL
- en: Eclipse Foundation – Eclipse
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Eclipse IDE was originally developed by IBM as a replacement for their existing
    Java IDE called VisualAge, which was written in Smalltalk. In 2001, IBM released
    the Eclipse platform, written in Java and released as an open source project.
    A board made up of companies working with Java was formed to oversee the development
    of Eclipse. As more and more companies joined the board, it was decided to create
    an independent open source organization. In 2004, the Eclipse Foundation was created,
    with the Eclipse IDE as its first open source project. Eclipse can run on Windows,
    macOS, and Linux.
  prefs: []
  type: TYPE_NORMAL
- en: You can download Eclipse from [https://www.eclipse.org/downloads/packages/](https://www.eclipse.org/downloads/packages/).
    There is the Eclipse IDE for Java developers for primarily desktop software development.
    A second version called the Eclipse IDE for enterprise Java and web developers
    adds support for server-side programming. Eclipse supports a range of plugins
    that add additional capabilities.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us see what the compound interest program – the one we wrote in *The first
    program* section – looks like in the Eclipse IDE:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.13 – The compound interest program in Eclipse](img/Figure_2.13_B19088.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.13 – The compound interest program in Eclipse
  prefs: []
  type: TYPE_NORMAL
- en: Here, you can see the output and what it looks like when you compile and execute
    it at the command line. All the IDEs capture the console output and display it
    in a window in the IDE.
  prefs: []
  type: TYPE_NORMAL
- en: Apache NetBeans
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**NetBeans** began as a student project in 1996 in the Czech Republic. When
    James Gosling first encountered NetBeans while he was traveling to promote Java,
    he was so impressed by it that upon his return, he convinced the management at
    Sun Microsystems to buy the company behind NetBeans. In 2010, Oracle acquired
    Sun Microsystems, and in 2016, Oracle donated the NetBeans source code to the
    **Apache Foundation**. NetBeans runs on Windows, macOS, and Linux.'
  prefs: []
  type: TYPE_NORMAL
- en: NetBeans has adopted an update cadence like Java, with new versions expected
    every 6 months. While not as feature-rich as some other IDEs, it is the simplest
    of the four to work with. As such, it is the ideal candidate when teaching Java
    or when you wish to use an IDE without a steep learning curve. As an Apache open
    source project, it is also the easiest to become involved with and contribute
    to.
  prefs: []
  type: TYPE_NORMAL
- en: You can download Apache NetBeans from [https://netbeans.apache.org/](https://netbeans.apache.org/).
    There is just one version and it supports desktop and server-side development.
    In addition, some plugins add additional functionality, such as support for frameworks
    such as Spring.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us see what the compound interest program – the one we wrote in *The first
    program* section – looks like in Apache NetBeans:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.14 – The compound interest program in NetBeans](img/Figure_2.14_B19088.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.14 – The compound interest program in NetBeans
  prefs: []
  type: TYPE_NORMAL
- en: Here, you can see how NetBeans shows the output of the compound interest program.
  prefs: []
  type: TYPE_NORMAL
- en: Microsoft Visual Studio Code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Visual Studio Code** (**VS Code**) was introduced by **Microsoft** in 2016\.
    Its purpose was to be a development environment for a wide range of languages
    such as JavaScript, C++, Python, and Java, among others. The program consists
    of a core component that is released as open source. Support for specific languages
    is handled by extensions. The primary Java extension was developed by Red Hat,
    and unlike Microsoft-authored extensions, this one is open source.'
  prefs: []
  type: TYPE_NORMAL
- en: VS Code is written in **TypeScript** and uses the open source Electron framework
    for creating desktop applications. VS Code is available for Windows, macOS, and
    Linux, though not all extensions work on every OS.
  prefs: []
  type: TYPE_NORMAL
- en: You can download VS Code along with several Java extensions from [https://code.visualstudio.com/docs/languages/java](https://code.visualstudio.com/docs/languages/java).
    You will want to download the Coding Pack for Java, which contains VS Code plus
    the Java extensions. If you have already downloaded the basic version of VS Code,
    you can add Java support to an existing installation by downloading the Java Extension
    Pack.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s what the compound interest program – the one we wrote in *The first
    program* section – looks like in VS Code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.15 – The compound interest program in VS Code](img/Figure_2.15_B19088.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.15 – The compound interest program in VS Code
  prefs: []
  type: TYPE_NORMAL
- en: Here, you can see how VS Code shows the output of the compound interest program.
  prefs: []
  type: TYPE_NORMAL
- en: JetBrains IntelliJ IDEA
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**IntelliJ IDEA** from the JetBrains company, written in Java, was introduced
    in 2001\. It comes in two flavors. First, there is a free Community edition with
    an open source license for developing desktop Java applications. A second commercial
    version, called Ultimate, includes support for additional Java frameworks such
    as Java EE/Jakarta EE and Spring. The commercial version requires an annual paid
    subscription.'
  prefs: []
  type: TYPE_NORMAL
- en: IntelliJ is considered the most feature-rich of the Java IDEs. This does not
    necessarily mean it is the best, but it is the most widely used of all the IDEs.
    You can download it from [https://www.jetbrains.com/idea/download/](https://www.jetbrains.com/idea/download/).
    As already mentioned, the Community edition is free, while the Ultimate version
    requires a subscription.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us see what the compound interest program – the one we wrote in *The first
    program* section – looks like in IntelliJ IDEA:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.16 – The compound interest program in IntelliJ IDEA](img/Figure_2.16_B19088.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.16 – The compound interest program in IntelliJ IDEA
  prefs: []
  type: TYPE_NORMAL
- en: Here, you can see the output in IntelliJ IDEA. This is what it looks like when
    you compile and execute at the command line.
  prefs: []
  type: TYPE_NORMAL
- en: Which IDE should you use?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are two factors to consider when choosing an IDE:'
  prefs: []
  type: TYPE_NORMAL
- en: The first is whether the company you work for mandates a specific IDE. If so,
    then the choice has been made for you.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The second is how you feel when using the IDE. All four of the IDEs shown here
    can support whatever you are coding in Java. They can also be used for other languages,
    such as C, C++, PHP, and JavaScript.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: I can only explain what my choice was and the reasons for that choice. I needed
    an IDE that required the minimum amount of classroom instruction. I taught Java
    project courses in the final year of a 3-year computer science program at a college
    in Quebec. I needed to teach advanced desktop programming and introduce the students
    to server-side programming. I did not want to teach an IDE. For these reasons,
    I chose NetBeans. Students were permitted to use any of the other three IDEs if
    they used the external Maven build system, but if they ran into trouble with the
    IDE, I could only provide minimal assistance.
  prefs: []
  type: TYPE_NORMAL
- en: So, I recommend that you take the time to experiment with each of the IDEs.
    Select your personal IDE based on how you feel about using it. They are all effectively
    the same while presenting unique methods to get things done. All of this book’s
    source code, which can be found in this book’s GitHub repository, will run on
    all four IDEs mentioned here.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we examined the various ways in which we can write, compile,
    and execute Java programs from the command line. We looked at REPL in JShell to
    run snippets of code quickly. Then, we saw the classic way that Java is compiled
    and executed in two steps. Finally, we looked at Launch Single-File Source-Code
    Programs for executing Java programs written in a single file. With the Shebang
    concept found in macOS and Linux, we saw how Java could even be used as a scripting
    language. We ended by briefly looking at the four most common IDEs.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you know how to write, compile, and execute Java programs, in the next
    chapter, we will explore an external build system that can be used from the command
    line or within an IDE. This topic will help explain why your choice of IDE is
    personal. You will see why developers can work together while members of the team
    may use a different IDE.
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To learn more about the topics that were covered in this chapter, take a look
    at the following resources:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Java Platform, Standard Edition – Java Shell User’s* *Guide*: [https://docs.oracle.com/javase/10/jshell/JSHEL.pdf](https://docs.oracle.com/javase/10/jshell/JSHEL.pdf)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*JEP 330: Launch Single-File Source-Code* *Programs*: [https://openjdk.org/jeps/330](https://openjdk.org/jeps/330)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Eclipse* *Foundation*: [https://www.eclipse.org/](https://www.eclipse.org/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Apache* *NetBeans*: [https://netbeans.apache.org/](https://netbeans.apache.org/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Visual Studio* *Code*: [https://code.visualstudio.com/](https://code.visualstudio.com/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*JetBrains IntelliJ* *IDEA*: [https://www.jetbrains.com/idea](https://www.jetbrains.com/idea)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
