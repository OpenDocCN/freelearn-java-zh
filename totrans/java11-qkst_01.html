<html><head></head><body><div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Type inference</h1>
                </header>
            
            <article class="calibre2">
                
<p class="calibre6">Type inference with local variables, or <kbd class="calibre9">var</kbd>, is one of the most talked about, star feature of Java 10. It reduces the verbosity of the language, without compromising on Java's dependable static binding and type safety. The compiler infers the type using the information that is already available in the code and adds it to the bytecode it generates.</p>
<p class="calibre6">Every new concept has its own set of benefits, limitations and complexities. Using type inference with <kbd class="calibre9">var</kbd> is no exception. As you work through this chapter, you'll see how using <kbd class="calibre9">var</kbd> will enthrall you, frustrate you and yet emerge triumphant.</p>
<p class="calibre6">In this chapter, we'll cover the following topics:</p>
<ul class="calibre10">
<li class="calibre11">What is type inference?</li>
<li class="calibre11">Type inference with <kbd class="calibre9">var</kbd></li>
<li class="calibre11">Do's and don'ts of working with <kbd class="calibre9">var</kbd></li>
<li class="calibre11">Type inference versus dynamic binding</li>
</ul>
<p class="calibre6"> </p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">What is type inference?</h1>
                </header>
            
            <article class="calibre2">
                
<p class="calibre6">Imagine solving a riddle, like the one shown in the following image with multiple constraints in the form of hints. You resolve the constraints to derive the answer. You can compare type inference with generating constraints and then resolving them to determine the data types in a programming language. Type inference is the capability of compiler to determine the type of the data, by using the information that is already available in the code; literal values, method invocations and their declaration. For a developer, type inference reduces verbosity:</p>
<div class="cdpaligncenter"><img src="Images/ddbd1594-2680-4b3f-b98f-efdeb5ac4bec.png" class="calibre12"/></div>
<p class="calibre6">For your reference, answer to the preceding riddle is 87 (just invert the image and you'll find the numbers in a sequence).</p>
<div class="packt_infobox">Type inference is not new to Java. It has been taken to the next level with introduction of <kbd class="calibre13">var</kbd> with local variables in Java 10.</div>
<p class="calibre6">Let's deep dive using examples with <kbd class="calibre9">var</kbd>.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Type inference with var</h1>
                </header>
            
            <article class="calibre2">
                
<p class="calibre6">The following lines of code show how you have been defining your local variable (and all other variables), prior to Java 10:</p>
<pre class="calibre14">String name = "Java11"; 
LocalDateTime dateTime = new LocalDateTime.now(); </pre>
<p class="calibre6">Starting with Java 10, using <kbd class="calibre9">var</kbd>, you can drop the mandatory explicit type in the declaration of local variables, as follows:</p>
<pre class="calibre14">var name = "Java11";         // variable 'name' inferred as String 
var dateTime = new LocalDateTime.now();  // var 'dateTime' inferred as LocalDateTime </pre>
<p class="calibre6">Do you think that the preceding code doesn't seem to offer a lot of benefits? What if, instead of the following?</p>
<pre class="calibre14">HashMap&lt;Integer, String&gt; map = new HashMap&lt;Integer, String&gt;(); </pre>
<p class="calibre6">You could use the following:</p>
<pre class="calibre14">var map = new HashMap&lt;Integer, String&gt;();  </pre>
<p class="calibre6">The preceding example drops quite a lot of letters on the left-hand side, making it leaner.</p>
<p class="calibre6">When you move away from stating the data type of the variables explicitly, the compiler takes over to determine or infer the variable type. Type inference is compiler's ability to evaluate the information already present in the code, like, the literal values, operations, method invocation or their declaration to determine the variable type. It follows a set of rules to infer the variable type. As a developer, when you choose type inference with <kbd class="calibre9">var</kbd>, you should be aware of compiler's inference algorithm and other rules, so that you don't get unexpected results.</p>
<p class="calibre6">With every new feature, you should adhere to a few rules, restrictions and try to follow best practices to benefit from it. Let's start with the compulsory initialization of the variables that are defined using <kbd class="calibre9">var</kbd>.</p>
<div class="packt_infobox">Type inference with <kbd class="calibre13">var</kbd> is not dynamic typing; Java is still a strong static typed language. Usage of var makes your code leaner; you can drop the type of the local variable from its definition.</div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Compulsory non-null initialization</h1>
                </header>
            
            <article class="calibre2">
                
<p class="calibre6">A local variable defined with <kbd class="calibre9">var</kbd> must be initialized with its declaration, or else the code won't compile. The compiler can't infer the type of an uninitialized variable or a variable that is assigned a null value. The following code won't compile:</p>
<pre class="calibre14">var minAge;                   // uninitialized variable 
var age = null;               // variable assigned a null value  </pre>
<p class="calibre6">The following image illustrates what would happen if the un-initialized variable <kbd class="calibre9">age</kbd> went to seek entrance to Mr. Java compiler place. The compiler won't let it in:</p>
<div class="cdpaligncenter"><img src="Images/a6d20187-0b64-4afc-9f03-a0ffa1090cfc.png" width="1623" height="608" class="calibre15"/></div>
<div class="packt_infobox">Variable definition using <kbd class="calibre13">var</kbd> must always be accompanied with its initialization; or else the code will fail to compile.</div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Local variables</h1>
                </header>
            
            <article class="calibre2">
                
<p class="calibre6">The usage of <kbd class="calibre9">var</kbd> is limited to the local variables. These variables are used to store intermediate values and have the shortest life span, when compared to the instance and static variables. The local variables are defined within a method, constructor or initializer blocks (both instance or static). Within a method or initializer, they can be defined within constructs such as <kbd class="calibre9">if</kbd>-<kbd class="calibre9">else</kbd> loops, <kbd class="calibre9">switch</kbd> statements or <kbd class="calibre9">try-with-resources</kbd> construct. Here's an example of <kbd class="calibre9">Person</kbd> <span class="calibre8">class</span>, which defines local variables, at multiple places:</p>
<pre class="calibre14">public class Person { 
    { 
        var name = "Aqua Blue";         // instance initializer block 
    } 
 
    static { 
        var anotherLocalVar = 19876;    // static initializer block 
    } 
 
    Person() { 
        var ctr = 10;                   // constructor 
        for (var loopCtr = 0; loopCtr &lt; 10; ++loopCtr) {    // loop - for initializer 
            switch(loopCtr) { 
                case 7 :{ 
                            var probability = ctr / loopCtr;    // switch 
                            System.out.println(probability); 
                            break; 
                        } 
            } 
        } 
    } 
 
    public String readFile() throws IOException { 
        var filePath = "data.txt"; 
        try (var reader = new BufferedReader(new FileReader(filePath))) {   // try-with-resources 
            return reader.readLine(); 
        } 
    } 
}  </pre>
<p class="calibre6">Since that's a lot of places, you might find it difficult to remember them. We just requested Google Maps to find all its possible occurrences and this is what we got:</p>
<div class="cdpaligncenter"><img src="Images/be886487-7f1d-4450-9f41-848e72490309.jpg" width="1140" height="1479" class="calibre16"/></div>
<div class="packt_infobox">This chapter includes a couple of code check exercises for you to quickly try out a new topic. The exercises use names of two hypothetical programmers Pavni and Aarav.</div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Code check – part 1</h1>
                </header>
            
            <article class="calibre2">
                
<p class="calibre6">One of our programmers, Aarav, refactored code by his team member, Pavni. The code no longer outputs the <kbd class="calibre9">char</kbd> and its corresponding ASCII numbers of the values stored by a <kbd class="calibre9">char</kbd> array. Can you help Aarav? Here's the code:</p>
<pre class="calibre14">class Foo {   
    public static void main(String   args[]) {   
        try {   
           char[] name = new char[]{'S','t','r','i','n','g'};   
           for (var c : name) {   
               System.out.println(c + ":"   + (c + 1 - 1));   
           }   
        }   
        catch (var e) {   
            //code   
        }   
    }   
}   </pre>
<p class="calibre6">Answer to code check—<kbd class="calibre9">var</kbd> type can't be used to specify the type of exceptions in the catch handler <kbd class="calibre9">(var e)</kbd>.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Using var with primitive data types</h1>
                </header>
            
            <article class="calibre2">
                
<p class="calibre6">This seems to be simplest of all, but appearances can be deceptive. Try to execute the following code:</p>
<pre class="calibre14">var counter = 9_009_998_992_887;       // code doesn't compile </pre>
<p class="calibre6">You might assume that an integer literal value (<kbd class="calibre9">9_009_998_992_887</kbd> in this case) that doesn't fit into the range of primitive <kbd class="calibre9">int</kbd> type will be inferred to be a <kbd class="calibre9">long</kbd> type. However, this doesn't happen. Since the default type of an integer literal value is <kbd class="calibre9">int</kbd>, you'll need to append the preceding value with the suffix <kbd class="calibre9">L</kbd> or <kbd class="calibre9">l</kbd>, as follows:</p>
<pre class="calibre14">var counter = 9_009_998_992_887L;       // code compiles </pre>
<p class="calibre6">Similarly, for an <kbd class="calibre9">int</kbd> literal value to be inferred as a <kbd class="calibre9">char</kbd> type, you must use an explicit cast, as follows:</p>
<pre class="calibre14">var aChar = (char)91; </pre>
<p class="calibre6">What is the result when you divide <kbd class="calibre9">5</kbd> by <kbd class="calibre9">2</kbd>? Did you say <kbd class="calibre9">2.5</kbd>? But this isn't how it (always) works in Java! When integer values are used as operands in division, the result is not a decimal number, but an integer value. The fraction part is dropped to get the result as an integer. Though this is usual, this might seem to be weird, when you expect the compiler to infer the type of your variable. Here's an example:</p>
<pre class="calibre14">// type of result inferred as int; 'result' stores 2 <br class="calibre2"/>var divResult = 5/2; <br class="calibre2"/><br class="calibre2"/>// result of (5/2), that is 2 casted to a double; divResult stores 2.0 <br class="calibre2"/>var divResult = (double)(5/ 2); <br class="calibre2"/><br class="calibre2"/>// operation of a double and int results in a double; divResult stores 2.5 <br class="calibre2"/>var divResult = (double)5/ 2;  </pre>
<p class="calibre6">Though these cases aren't specifically related to the <kbd class="calibre9">var</kbd> type, developer's assumption that the compiler will infer a specific type, results in a mismatch. Here's a quick image to help you remember this.</p>
<div class="cdpaligncenter"><img src="Images/5e881452-9834-4f24-93d1-259747a883af.jpg" width="1380" height="753" class="calibre17"/></div>
<div class="packt_infobox">The default type of integer literals is <kbd class="calibre13">int</kbd> and of floating point numbers is <kbd class="calibre13">double</kbd>. Assigning <kbd class="calibre13">100</kbd> to a variable defined with <kbd class="calibre13">var</kbd> will infer its type as <kbd class="calibre13">int</kbd>; not <kbd class="calibre13">byte</kbd> or <kbd class="calibre13">short</kbd>.</div>
<p class="calibre6">In an arithmetic operation, if either of the operand is <kbd class="calibre9">char</kbd>, <kbd class="calibre9">byte</kbd>, <kbd class="calibre9">short</kbd> or <kbd class="calibre9">int</kbd>, the result is at least promoted to an <kbd class="calibre9">int</kbd>.</p>
<pre class="calibre14">byte b1 = 10; 
char c1 = 9; 
var sum = b1 + c1;        // inferred type of sum is int  </pre>
<p class="calibre6">Similarly, for an arithmetic operation that includes at least one operand as a <kbd class="calibre9">long</kbd>, <kbd class="calibre9">float</kbd>, or <kbd class="calibre9">double</kbd> value, the result is promoted to type <kbd class="calibre9">long</kbd>, <kbd class="calibre9">float</kbd> or <kbd class="calibre9">double</kbd> respectively:</p>
<pre class="calibre14">byte cupsOfCoffee = 10; 
long population = 10L; 
float weight = 79.8f; 
double distance = 198654.77; 
 
var total1 = cupsOfCoffee + population;     // inferred type of total1 is long 
var total2 = distance + population;        // inferred type of total2 is double 
var total3 = weight + population;    // inferred type of total3 is float  </pre>
<div class="packt_infobox">Rules of implicit widening of primitive variables play an important role to understand how the Java compiler infers variables with primitive values.</div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Type inference with derived classes</h1>
                </header>
            
            <article class="calibre2">
                
<p class="calibre6">With JDK 9 and previous versions, you could define a variable of base class and assign to it an instance of its derived class. The members that you could access using this variable was limited to the ones that were defined in the base class. This is no longer the case with <kbd class="calibre9">var</kbd>; since the type of the variable is inferred using the specific type of the instance that is assigned to it.</p>
<p class="calibre6">Imagine the <span class="calibre8"><kbd class="calibre9">Child</kbd> </span>class extends <span class="calibre8"> the <kbd class="calibre9">Parent</kbd> </span>class. When you create a local variable and assign it an instance of the <kbd class="calibre9">Child</kbd> class, the type of the variable is inferred as <kbd class="calibre9">Child</kbd>. This looks simple. Here's an example:</p>
<pre class="calibre14">class Parent { 
    void whistle() { 
        System.out.println("Parent-Whistle"); 
    } 
} 
class Child extends Parent { 
    void whistle() { 
        System.out.println("Child-Whistle"); 
    } 
    void stand() { 
        System.out.println("Child-stand"); 
    } 
} 
class Test{ 
    public static void main(String[] args) { 
        var obj = new Child();                             
        obj.whistle(); 
        obj.stand();     // type of obj inferred as Child 
    } 
}  </pre>
<p class="calibre6">What happens, if you assign the value of the variable <kbd class="calibre9">obj</kbd> using a method that can return instance of class <kbd class="calibre9">Child</kbd> or <kbd class="calibre9">Parent</kbd>? Here's the modified code:</p>
<pre class="calibre14">class Parent { 
    void whistle() { 
        System.out.println("Parent-Whistle"); 
    } 
} 
 
class Child extends Parent { 
    void whistle() { 
        System.out.println("Child-Whistle"); 
    } 
    void stand() { 
        System.out.println("Child-stand"); 
    } 
} 
 
class Test{ 
    public static Parent getObject(String type) { 
        if (type.equals("Parent")) 
            return new Parent(); 
        else 
            return new Child(); 
    } 
 
    public static void main(String[] args) { 
        var obj = getObject("Child"); 
        obj.whistle(); 
        obj.stand();              // This line doesn't compile 
    } 
} </pre>
<p class="calibre6">In the preceding code, the type of the instance returned by method <kbd class="calibre9">getObject()</kbd> can't be determined before the code execution. During compilation, type of variable <kbd class="calibre9">obj</kbd> is inferred as <kbd class="calibre9">Parent</kbd>; return type of the <kbd class="calibre9">getObject()</kbd> <span class="calibre8">method.</span> Since the <kbd class="calibre9">Parent</kbd> <span class="calibre8">class </span>doesn't define the <kbd class="calibre9">stand()</kbd>, <kbd class="calibre9">main()</kbd> <span class="calibre8">method</span> fails to compile.</p>
<div class="packt_infobox">Type of variables defined using <kbd class="calibre13">var</kbd> are inferred at compile time. If the return type of a method is used to assign a variable defined using <kbd class="calibre13">var</kbd>, its inferred type is the return type of the method; not the type of instance returned during run time.</div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Type inference – with interfaces</h1>
                </header>
            
            <article class="calibre2">
                
<p class="calibre6">Let's extend our learning from the preceding section to usage of interfaces. Imagine a <kbd class="calibre9">Child</kbd> <span class="calibre8">class</span> implements an <kbd class="calibre9">MarathonRunner</kbd> <span class="calibre8">interface:</span></p>
<pre class="calibre14">interface MarathonRunner{ 
    default void run() { 
        System.out.println("I'm a marathon runner"); 
    } 
} 
 
class Child implements MarathonRunner { 
    void whistle() { 
        System.out.println("Child-Whistle"); 
    } 
    void stand() { 
        System.out.println("Child-stand"); 
    } 
}  </pre>
<p class="calibre6">Let's define a <kbd class="calibre9">obj</kbd> <span class="calibre8">local variable </span>assigning it an instance of the <kbd class="calibre9">Child</kbd> class:</p>
<pre class="calibre14">class Test{ 
    public static void main(String[] args) { 
        var obj = new Child();              // inferred type of var obj is Child 
        obj.whistle(); 
        obj.stand();                     
        obj.run(); 
    } 
}  </pre>
<p class="calibre6">If the same variable is initialized using a method whose return type is <kbd class="calibre9">MarathonRunner</kbd>, its inferred type is <kbd class="calibre9">MarathonRunner</kbd> (irrespective of the type of the instance returned by it):</p>
<pre class="calibre14">class Test{ 
    public static MarathonRunner getObject() { 
        return new Child(); 
    } 
    public static void main(String[] args) { 
        var obj = getObject();     // inferred type of var obj is MarathonRunner 
        obj.whistle(); 
        obj.stand(); 
        obj.run(); 
    } 
} </pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Using var with arrays</h1>
                </header>
            
            <article class="calibre2">
                
<p class="calibre6">Using <kbd class="calibre9">var</kbd> doesn't imply just dropping the type of the local variable; what remains should enable the compiler to infer its type. Imagine a method which defines an array of <kbd class="calibre9">char</kbd> type as follows:</p>
<pre class="calibre14">char name[] = {'S','t','r','i','n','g'};  </pre>
<p class="calibre6">You can't drop its type and define it using either of the following code:</p>
<pre class="calibre14">var name[] = {'S','t','r','i','n','g'}; 
var[] name = {'S','t','r','i','n','g'}; 
var name = {'S','t','r','i','n','g'};  </pre>
<p class="calibre6">Here's one of the ways to include relevant information to enable the compiler to infer the type:</p>
<pre class="calibre14">var name = new char[]{'S','t','r','i','n','g'}; </pre>
<p class="calibre6">Seems like the Java compiler is already struggling with this assumption by the programmers, as shown in the following image:</p>
<div class="cdpaligncenter"><img src="Images/474a407f-8ba4-4eb8-a9a0-edd3fcd0397f.jpg" width="1381" height="534" class="calibre18"/></div>
<p class="calibre6">You can't just drop the data types to use <kbd class="calibre9">var</kbd>. What remains should enable the compiler to infer the type of the value being assigned.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Type inference with generics</h1>
                </header>
            
            <article class="calibre2">
                
<p class="calibre6">The motivation of introducing generics was to include type safety. It enabled developers to specify their intention of using classes, interfaces and collection classes with fixed or range of types. Violations in these intentions were enforced with compilation errors, rather than runtime exception; raising compliance bar.</p>
<p class="calibre6">For example, here's how you would define an <kbd class="calibre9">ArrayList</kbd> to store <kbd class="calibre9">String</kbd> values (repeating <kbd class="calibre9">&lt;String&gt;</kbd> is optional on the right-hand side of the assignment):</p>
<pre class="calibre14">List&lt;String&gt; names = new ArrayList&lt;&gt;();  </pre>
<p class="calibre6">However, replacing <kbd class="calibre9">List&lt;String&gt;</kbd> with <kbd class="calibre9">var</kbd> will put type safety in generics at stake:</p>
<pre class="calibre14">var names = new ArrayList&lt;&gt;(); 
names.add(1); 
names.add("Mala"); 
names.add(10.9); 
names.add(true); </pre>
<p class="calibre6">The preceding code allows addition of multiple data types to <kbd class="calibre9">names</kbd>, which is not the intention. With generics, the preferred approach is to make relevant information available to the compiler, so that it can infer its type correctly:</p>
<pre class="calibre14">var names = new ArrayList&lt;String&gt;(); </pre>
<div class="packt_tip">When using <kbd class="calibre13">var</kbd> with generics, ensure you pass relevant data types within the angular brackets on the right-hand side of the assignment; so that you don't lose type safety.</div>
<p class="calibre6">Time for our next code check.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Code check – part 2</h1>
                </header>
            
            <article class="calibre2">
                
<p class="calibre6">One of our programmers, Pavni, tried using <kbd class="calibre9">var</kbd> with generics and collection classes, but her code doesn't seem to output the sorted collection of pens. Can you help?</p>
<pre class="calibre14">class Pen implements Comparable&lt;Pen&gt; {   
    String name;   
    double price;   
    Pen(String name, double price) {   
        this.name = name;   
        this.price = price;   
    }   
    public int compareTo(Pen pen) {   
        return ((int)(this.price-pen.price));   
    }   
    public String toString() {   
        return name;   
    }   
   
    public static void main(String   args[]) {   
        var pen1 = new Pen("Lateral",   219.9);   
        var pen2 = new Pen("Pinker",   19.9);   
        var pen3 = new Pen("Simplie",   159.9);   
   
        var penList = List.of(pen1, pen2,   pen3);   
   
        Collections.sort(penList);   
        for (var a : penList)    
            System.out.println(a);   
    }   
}   </pre>
<p class="calibre6">Answer to code check—the issue is trying to modify the immutable collection, using <kbd class="calibre9">Collections.sort()</kbd>. This is to emphasize that all issues are not related to the usage of <kbd class="calibre9">var</kbd>.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Passing inferred variables to a method</h1>
                </header>
            
            <article class="calibre2">
                
<p class="calibre6">Though the usage of <kbd class="calibre9">var</kbd> is limited to declaration of local variables, these variables (both primitive and reference) can be passed to methods as values. The inferred types and the types expected by the methods must match to let the code compile.</p>
<p class="calibre6">In the following example code, the <kbd class="calibre9">Child</kbd> class implements the <kbd class="calibre9">MarathonRunner</kbd> <span class="calibre8">interface.</span> The <kbd class="calibre9">start()</kbd> <span class="calibre8">method</span> in the <kbd class="calibre9">Marathon</kbd> class expects the <kbd class="calibre9">MarathonRunner</kbd> object (instances of class implementing this interface) as its method argument. Inferred type of variable, <kbd class="calibre9">aRunner</kbd> is <kbd class="calibre9">Child</kbd>. Since the <kbd class="calibre9">Child</kbd> class implements <kbd class="calibre9">MarathonRunner</kbd>, <kbd class="calibre9">aRunner</kbd> can be passed to the <kbd class="calibre9">start()</kbd> <span class="calibre8">method,</span> the inferred type of <kbd class="calibre9">aRunner</kbd> (<kbd class="calibre9">Child</kbd>) and expected type of <kbd class="calibre9">start()</kbd> (<kbd class="calibre9">MarathonRunner</kbd>) match, allowing the code to compile.</p>
<p class="calibre6">Here's the code:</p>
<pre class="calibre14">interface MarathonRunner { 
    default void run() { 
        System.out.println("I'm a marathon runner"); 
    } 
} 
class Child implements MarathonRunner { 
    void whistle() { 
        System.out.println("Child-Whistle"); 
    } 
    void stand() { 
        System.out.println("Child-stand"); 
    } 
} 
class Marathon { 
    public static void main(String[] args) { 
        var aRunner = new Child();         // Inferred type is Child 
        start(aRunner);    // ok to pass it to start (param - MarathonRunner) 
    } 
    public static void start(MarathonRunner runner) { 
        runner.run(); 
    } 
}  </pre>
<div class="packt_infobox">As long as the inferred type of a variable matches with the type of method parameter, it can be passed to it as an argument.</div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Reassigning value to inferred variables</h1>
                </header>
            
            <article class="calibre2">
                
<p class="calibre6">As applicable to all non-final variables, you can reassign a value to inferred variables. Just ensure that the reassigned value matches with the its inferred type. The type of a variable is inferred just once.</p>
<pre class="calibre14"> 
var age = 9;     // type inferred as int 
age = 10.9;      // won't compile 
 
StringBuilder query = new StringBuilder("SELECT"); // Type - StringBuilder 
query = query.toString() + "FROM" + "TABLE";       // won't compile;  
                          // can't convert String  
                          // to StringBuilder 
 </pre>
<div class="packt_infobox">The type of a local variable defined using <kbd class="calibre13">var</kbd> is inferred only once.</div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Explicit casting with inferred variables</h1>
                </header>
            
            <article class="calibre2">
                
<p class="calibre6"><span class="calibre8">Imagine a co-programmer assigned <kbd class="calibre9">29</kbd> to an inferred local variable, say <kbd class="calibre9">age</kbd>, assuming the compiler would infer the type of variable <kbd class="calibre9">age</kbd> as <kbd class="calibre9">byte</kbd>:</span></p>
<pre class="calibre14">var age = 29;           // inferred type of age is int </pre>
<p class="calibre6"><span class="calibre8">However, the compiler would infer the type of the variable <kbd class="calibre9">age</kbd> as <kbd class="calibre9">int</kbd>, since the default type of an integer literal value is <kbd class="calibre9">int</kbd>.  To fix the preceding assumption, y</span>ou can either use the explicit data type or override compiler's default inference mechanism by using explicit casting, as follows:</p>
<pre class="calibre14">byte age = 29;                // Option 1 - no type inference <br class="calibre2"/>var age = (byte)29;           // Option 2 - explicit casting </pre>
<div class="packt_tip">By using explicit casting type inference, you can override the compiler's default type inference mechanism. This might be required to fix the assumptions in existing code. </div>
<p class="calibre6"><span class="calibre8"><span class="calibre8">Similarly,</span></span> you can use explicit casting with other primitive data types like <kbd class="calibre9">char</kbd> and <kbd class="calibre9">float</kbd>:</p>
<pre class="calibre14">var letter = (char)97;        // inferred type of letter is char 
var debit = (float)17.9;      // inferred type of debit is float  </pre>
<p class="calibre6">Without the explicit casting in the preceding examples, variables that are assigned integer literal values would be inferred as <kbd class="calibre9">int</kbd> and decimal as <kbd class="calibre9">double</kbd>.</p>
<p class="calibre6">The following example is of explicit casting with reference variables:</p>
<pre class="calibre14">class Automobile {} 
class Car extends Automobile { 
    void check() {} 
} 
class Test{ 
    public static void main(String[] args) { 
        var obj = (Automobile)new Car();                             
        obj.check();     // Won't compile; type of obj is Automobile 
    } 
} </pre>
<div class="packt_infobox">Use explicit casting with type inference to fix any existing assumptions. I wouldn't recommend using explicit casting to initialize inferred variables; it beats the purpose of using <kbd class="calibre13">var</kbd>.</div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Assigning null with explicit casting</h1>
                </header>
            
            <article class="calibre2">
                
<p class="calibre6">Again, though it doesn't make sense to use explicit casting will null to assign it to a <kbd class="calibre9">var</kbd> type, it is a valid code:</p>
<pre class="calibre14">var name = (String)null;             // Code compiles </pre>
<p class="calibre6">Though the preceding line of code is correct syntax wise, it is a bad coding practice. Avoid it!</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Type inference in previous versions of Java</h1>
                </header>
            
            <article class="calibre2">
                
<p class="calibre6">Though <kbd class="calibre9">var</kbd> takes inference to a new level in Java 10, the concept of type inference existed in its previous versions. Let's see examples of type inference in the previous versions of Java.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Type inference in Java 5</h1>
                </header>
            
            <article class="calibre2">
                
<p class="calibre6">Generics introduced a type system to enable the developers to abstract over types. It restricted a class, interface or method to work with instances of specified types, providing compile type safety. Generics were defined to add compile time safety to the Collection framework. Generics enables programs to detect certain bugs during compilation so they can't creep into the run time code. It's easier to fix a bug during development phase than fixing it in production.</p>
<p class="calibre6">Java used type inference for generic method type arguments in Java 5. Instead of the following code:</p>
<pre class="calibre14">List&lt;Integer&gt; myListOfIntegers = Collections.&lt;Integer&gt;emptyList(); // 1 </pre>
<p class="calibre6">You could use:</p>
<pre class="calibre14"> List&lt;Integer&gt; myListOfIntegers = Collections.emptyList(); // 1 </pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Type inference in Java 7</h1>
                </header>
            
            <article class="calibre2">
                
<p class="calibre6">Java 7 introduced type inference for constructor arguments with generics. This essentially means that the following line of code:</p>
<pre class="calibre14">List&lt;String&gt; myThings = new ArrayList&lt;String&gt;(); </pre>
<p class="calibre6">can be replaced with:</p>
<pre class="calibre14">List&lt;String&gt; myThings = new ArrayList&lt;&gt;();  </pre>
<p class="calibre6">The preceding shouldn't be confused with the following, which is trying to mix the generics with the raw types:</p>
<pre class="calibre14">List&lt;String&gt; myThings = new ArrayList();  </pre>
<p class="calibre6">Java 7 also allowed type inference to invoke generic methods. For a generic method, say, <kbd class="calibre9">print()</kbd> defined in a class, say, <kbd class="calibre9">MyClass</kbd>:</p>
<pre class="calibre14">class MyClass&lt;T&gt; { 
   public &lt;X&gt; void print(X x) { 
         System.out.println(x.getClass()); 
   } 
}  </pre>
<p class="calibre6">It can be called as follows in either of the following ways (the third line of code uses type inference to infer type of argument passed to the method <kbd class="calibre9">print()</kbd>:</p>
<pre class="calibre14">MyClass&lt;String&gt; myClass = new MyClass&lt;&gt;(); 
myClass.&lt;Boolean&gt;deliver(new Boolean("true"));     
myClass.deliver(new Boolean("true")); </pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Type inference in Java 8</h1>
                </header>
            
            <article class="calibre2">
                
<p class="calibre6">Java 8 introduced functional programming in Java with lambda functions. The lambda expressions can infer the type of it's formal parameters. So instead of the following line of code:</p>
<pre class="calibre14">Consumer&lt;String&gt; consumer = (String s) -&gt; System.out.println(s);  </pre>
<p class="calibre6">You can write:</p>
<pre class="calibre14">Consumer&lt;String&gt; consumer = s -&gt; System.out.print(s); </pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Challenges</h1>
                </header>
            
            <article class="calibre2">
                
<p class="calibre6">Usage of <kbd class="calibre9">var</kbd> isn't without its share of challenges, both for the developers of the Java language and for its users. Let's start with the reason why <kbd class="calibre9">var</kbd> has limited usage.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Limiting the scope of failed assumptions</h1>
                </header>
            
            <article class="calibre2">
                
<p class="calibre6">As you know, the usage of <kbd class="calibre9">var</kbd> types is limited to the local variables in Java. They are not allowed in public API, as method parameters or as return type of methods. Some languages support type inference for all types of variables. Java may allow you to do so in future (who knows? Will it happen? If yes, when?).</p>
<p class="calibre6">However, there are strong reasons for limiting the scope of the inferred variables, to spot the errors due to mismatch of assumptions and the actual, early on. The contracts of the public API's should be explicit. Type inference with public API would allow for these errors to be caught and corrected much later.</p>
<div class="packt_infobox">The contract of the public API should be explicit, they shouldn't depend on type inference.</div>
<p class="calibre6">Here's a practical example of how mismatch in the assumptions and actual can lead to errors.</p>
<p class="calibre6">Recently my child was travelling overseas with her school for a student exchange program. The school asked me to send back a set of photographs for her visa application. I called up my photographer, requesting him to print photos for visa (specifying the country). Two days later, the school asked me to resubmit the photos because the earlier photos didn't match the rules.</p>
<p class="calibre6">What went wrong? Neither the school nor I were explicit with the specifications of the photograph. The school assumed that I would know the specifications; I assumed that the photographer would know the specifications (because he was doing it for years). In this case, at least one person assumed the result to conform to a specific output, without explicitly specifying the output. Without an explicit contract, there is always a scope of mismatch of expectation and actual.</p>
<p class="calibre6">Despite the confusion, the mistake was spotted and corrected before the applications were submitted to the embassy.</p>
<p class="calibre6">Here's a fun image to reason why the usage of type inference is limited to local variables, when the local instance and static variables were competing in a race, only the local variables could make it to the finish line:</p>
<div class="cdpaligncenter"><img src="Images/47bc58b4-f8ac-4287-a2cc-9d746f7e5a9b.png" width="1172" height="859" class="calibre19"/></div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Breaking existing code</h1>
                </header>
            
            <article class="calibre2">
                
<p class="calibre6">Code that used <kbd class="calibre9">var</kbd> as name of a class, interface, method, method parameters or variables, will no longer compile with JDK 10 and later releases. Here's an example of code that uses <kbd class="calibre9">var</kbd> at multiple places; and won't compile:</p>
<pre class="calibre14">class var {}          // can't use var as class name<br class="calibre2"/>interface var {}      // can't use var as interface name<br class="calibre2"/>class Demo {<br class="calibre2"/>    int var = 100;               // can't use var as instance variable name<br class="calibre2"/>    static long var = 121;       // can't use var as static variable name<br class="calibre2"/><br class="calibre2"/>    void var() {                 // can't use var as method name<br class="calibre2"/>        int var = 10;            // cant use var as the name of a local variable<br class="calibre2"/>    }<br class="calibre2"/>    void aMethod(String var) {}  // can't use var as the name of method parameter<br class="calibre2"/>}</pre>
<div class="packt_tip">Its important to test your production code with the latest Java release versions, even if you are not planning to deploy your production code to them. It will help iron-out any compatibility issues with your production code; helping to migrate it to a future Java version release. </div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Non-denotable types</h1>
                </header>
            
            <article class="calibre2">
                
<p class="calibre6">Java types that you can use in a program, like <kbd class="calibre9">int</kbd>, <kbd class="calibre9">Byte</kbd>, <kbd class="calibre9">Comparable</kbd> or <kbd class="calibre9">String</kbd> are called <strong class="calibre20">denotable types</strong>. The types used by a compiler internally, like, subclass of an anonymous class, which you can't write in your program, are called non-denotable types.</p>
<p class="calibre6">Till now, type inference with variables seemed to be quite easy to implement, just get the information about the values passed to a method, returned from a method, and infer the type. But it isn't as simple as that, when it comes to inference with non-denotable types—<kbd class="calibre9">null</kbd> type, intersection types, anonymous class type and the capture types.</p>
<p class="calibre6">For example, what do you think is the type of the following inferred variables:</p>
<pre class="calibre14">// inferred type java.util.ImmutableCollections$ListN 
var a = List.of(1, "2", new StringBuilder());<br class="calibre2"/>var b = List.of(new ArrayList&lt;String&gt;(), LocalTime.now());  </pre>
<p class="calibre6">The preceding cases are not one of the types. They are neither banned from being inferred, nor are they normalized to a denotable type.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Meaningful variable names</h1>
                </header>
            
            <article class="calibre2">
                
<p class="calibre6">A new feature should be used responsibly. When you drop the explicit data type with a variable name, the name takes the center stage. With inferred types, it is your responsibility to use descriptive and appropriate variable names, so that they make more sense in code. As you know, a piece of code is written once, but read many times.</p>
<p class="calibre6">For example, the following line of code won't make much sense to you after some time, or to your team members (especially with a big or distributed team):</p>
<pre class="calibre14">var i = getData();             // what does getData() return? Is 'i' a good name? </pre>
<p class="calibre6">Key questions are - what is the variable <kbd class="calibre9">i</kbd> used for, what does the method <kbd class="calibre9">getData()</kbd> return? Imagine the plight of the maintenance team that will work with this code, after you leave.</p>
<p class="calibre6">Also, it doesn't help to define variables names that are mismatched with their purpose. For example, it doesn't make much sense to create a connection object named <kbd class="calibre9">database</kbd> and assign a <kbd class="calibre9">URL</kbd> instance to it, or, say, to define a variable with the name <kbd class="calibre9">query</kbd> and assign a <kbd class="calibre9">Connection</kbd> instance to it:</p>
<pre class="calibre14">var database = new URL("http://www.eJavaGuru.com/malagupta.html"); 
var query = con.getConnection(); </pre>
<div class="packt_infobox">When you drop the explicit type of a local variable, its name takes the center stage. Choose their name carefully and responsibly, which makes their purpose unambiguous.</div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Code refactoring</h1>
                </header>
            
            <article class="calibre2">
                
<p class="calibre6">Type inference with <kbd class="calibre9">var</kbd> has been introduced to reduce the verbosity of the Java language. It will help the programmers to type less in their methods. The compiler infers the type of the variables declared using <kbd class="calibre9">var</kbd> and inserts it in the byte code.</p>
<p class="calibre6">I see no reason of refactoring existing or legacy code to replace explicit data types in the methods, replacing them with <kbd class="calibre9">var</kbd>. It won't offer any benefits in any dimension.</p>
<div class="packt_infobox">Don't refactor your existing or legacy code, replacing existing explicit types in methods with <kbd class="calibre13">var</kbd>. It doesn't offer any benefits.</div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Type inference versus dynamic binding</h1>
                </header>
            
            <article class="calibre2">
                
<p class="calibre6">Type inference with <kbd class="calibre9">var</kbd> isn't pushing Java towards the dynamic binding domain. Java is still a strongly typed static language. Type inference in Java is syntactic sugar. The compiler infers the type and adds it to the byte code. In dynamic binding, a variable type is inferred at run time. This can lead to more errors being discovered, later.</p>
<p class="calibre6">Debugging an application is a costly affair, in terms of the time and efforts required to find a bug and then fix it. The sooner you can detect a bug, the easier it is to fix it. It is easier to fix a bug during unit testing than it is to fix the same bug during integration testing, or say, when it shows up months later after an application goes live. A bug is easier to fix in the development phase than it is to fix in the production of maintenance stage.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article class="calibre2">
                
<p class="calibre6">In this chapter, you covered local variable inference, or <kbd class="calibre9">var</kbd>, introduced in Java 10. The <kbd class="calibre9">var</kbd> type enables you to drop the explicit data type for a local variable in a method. You covered the various do's and don'ts for the usage of <kbd class="calibre9">var</kbd>. Limited to local variables, variables defined using <kbd class="calibre9">var</kbd> must be initialized with a non-null value. They can be used with all type of variables—primitives and objects. Variables defined with <kbd class="calibre9">var</kbd> can also be passed to methods and returned from methods, method declaration compatibility rules apply.</p>
<p class="calibre6">To avoid risking your type safety with generics, ensure you pass relevant information, while using <kbd class="calibre9">var</kbd> with generics. Though it doesn't make a lot of sense, using explicit casting is allowed with variables defined using <kbd class="calibre9">var</kbd>. You also covered type inference existed in previous versions of Java, namely, 5, 7, and 8. Towards the end, you also covered why type inference is limited to the local variables and not allowed in the public API.</p>
<p class="calibre6">Usage of meaning variable names has always been recommended and it is important. With <kbd class="calibre9">var</kbd>, it becomes more important. Since <kbd class="calibre9">var</kbd> offers syntactic sugar, it doesn't make any sense to refactor your existing or legacy code to use <kbd class="calibre9">var</kbd> in it.</p>


            </article>

            
        </section>
    </div>



  </body></html>