- en: Chapter 6. Clustering with SSL
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous two chapters, we have learnt to use `JK` and `mod_cluster` as
    the load balancer to proxy user requests to EAP6 backend servers, and all the
    communications between load balancer and EAP6 servers are transferred in *plaintext*.
    In practice, there are situations where we need to secure the transportation layer
    by enabling **SSL**. In this chapter, we'll learn how to enable SSL in the clustering
    environment. We'll first learn how to enable SSL when using JBoss EAP6 independently,
    and then we'll learn how to enable SSL in a clustering environment that has httpd
    and EAP6 servers running together. For the clustering environment, we'll use `JK`
    as a load balancer in this chapter. Because using `mod_cluster` has provided a
    more fine-grained integration with SSL, we'll talk about this topic in the next
    chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You need to have some basic knowledge of public key cryptography and SSL before
    reading this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Using SSL in JBoss EAP6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: First let us see how to enable SSL in EAP6 directly. This is useful when we
    are using EAP6 as a standalone server and it doesn't have any load balancing in
    front. JBoss EAP6 provides SSL support out of the box and in this section, let's
    see how to enable it.
  prefs: []
  type: TYPE_NORMAL
- en: Enabling SSL in EAP6
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To enable SSL in EAP6, we need to create an x.509 certificate for the EAP6 server.
    First prepare a clean copy of `JBoss EAP 6.1.0.Final` to make sure the configurations
    are default. After the clean copy of EAP6 server is ready for use, please start
    it in the standalone mode, and then deploy `cluster-demo1` to the running server
    and then stop the server. That's all we need to do for preparation. We'll use
    it to test the HTTPS connection later.
  prefs: []
  type: TYPE_NORMAL
- en: Now let's create a directory called `certs` in the EAP6 base path. We'll use
    it to store the server certificate.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then we need to navigate to the `certs` directory and use the `keytool` command
    provided by **Java Runtime Environment** (**JRE**) to generate a certificate for
    the EAP6 server. Here is the command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The running process is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Enabling SSL in EAP6](img/2432_06_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The **keystore password** and **key password** is **packt000** . Please note
    that in a production environment, we must set **CN** to the hostname of our website.
    For this example, my hostname is called **mini**, so I use it as **CN** of the
    certificate. Now let''s check the generated `keystore` file and the key that is
    contained in it:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Enabling SSL in EAP6](img/2432_06_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As shown in the preceding screenshot, our generated key and its certificate
    are stored in `keystore`. The default **Alias name** of the key is **mykey**,
    and its certificate is associated with it. If we look carefully, we can see that
    the **Issuer** and the **Owner** of this certificate are the same. That means
    this is a self-signed certificate. In a production environment, we need to find
    an authority (like **VeriSign**) to sign this certificate. After the authority
    has signed it, the **Issuer** will be changed to the authority.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we need to configure the EAP6 web subsystem to use the key together with
    its certificate. Let''s open `standalone.xml` and find the subsystem `urn:jboss:domain:web:1.4`.
    Then we need to find an HTTP connector and change its scheme to HTTPS. Next we
    need to add an SSL element to tell EAP6 the position of our `keystore` and the
    alias name of our key. The modifications should be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Enabling SSL in EAP6](img/2432_06_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'That''s all we need to configure in `standalone.xml`. In addition, please note
    the port used by HTTPS in the configuration file is `8443`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'So we need to use this port to access the EAP6 web subsystem. Now we can start
    the EAP6 server and test the HTTPS connection:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The `-k` option of **cURL** is to bypass the certificate verification. Since
    our certificate is not signed by an authority, by default it's not trusted by
    cURL or any other web browsers.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we have learned how to enable SSL in the EAP6 standalone mode.
    Enabling SSL in the domain mode is similar; we also need to set the web subsystem
    to use the HTTPS scheme and add the certificate information in the SSL element.
    I'd like to leave this work to you.
  prefs: []
  type: TYPE_NORMAL
- en: Using SSL in the JBoss EAP6 cluster
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In a clustering environment, applying SSL does not seem as straightforward
    as in a single-server environment. We have a load balancer and worker nodes in
    a cluster, so we need to decide in which place we should enable SSL. Here are
    the two possible places:'
  prefs: []
  type: TYPE_NORMAL
- en: The communication between users and the load balancer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The communication between the load balancer and the worker nodes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In practice, we usually enable SSL between users and the load balancer to secure
    their communication, and use *cleartext* communication between the load balancer
    and the worker nodes. Here is the deployment diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Using SSL in the JBoss EAP6 cluster](img/2432_06_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This is reasonable because the worker nodes are usually protected by a firewall,
    and the purpose of using SSL is not only for encrypting communication channel,
    but a certificate signed by an authority can also help the customers' web browsers
    to verify the identity of the web server.
  prefs: []
  type: TYPE_NORMAL
- en: Enabling SSL communication between the load balancer and the worker node also
    creates many overheads in the communication layer, and encrypting/decrypting network
    data consumes CPU power.
  prefs: []
  type: TYPE_NORMAL
- en: '`JK` doesn''t support the SSL communication between the load balancer and the
    worker node, and this is not a problem in most situations as I explained earlier,
    `mod_cluster` supports the secure connection between the load balancer and the
    worker node, and we will see how to configure it in the next chapter.'
  prefs: []
  type: TYPE_NORMAL
- en: Configuring JK with SSL
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now let''s start to learn how to enable SSL with `JK`. Let''s see the deployment
    diagram first:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Configuring JK with SSL](img/2432_06_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Actually what we need to do is just enable SSL in Apache httpd. As we know,`mod_jk`
    is a lightweight load balancer and it only supports the AJP connection to worker
    nodes. That means the communication between `JK` and EAP6 servers will be *cleartext*
    AJP13 protocol.
  prefs: []
  type: TYPE_NORMAL
- en: To enable SSL in httpd, we need to do some preparation work. Please restore
    httpd with `JK` installed, we'll configure SSL based on it. If you've forgotten
    how to configure httpd and `JK` properly, please read [Chapter 4](ch04.html "Chapter 4. Load
    Balancing with mod_jk"), *Load Balancing with mod_j* *k* again.
  prefs: []
  type: TYPE_NORMAL
- en: Generating a certificate for httpd
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now let''s prepare the server certificate for httpd to use. First, let''s create
    a `certs` directory in httpd:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Then we need to navigate to the `certs` directory and generate a certificate
    for httpd. For httpd, we'll need to use **OpenSSL** to generate a certificate,
    because httpd doesn't support the `keystore` format used by Java applications.
    Actually, the certificate formats are all the same, but the storing structures
    generated by `keytool` and OpenSSL are different. OpenSSL separates the keys and
    certificates into standalone files, but `keytool` stores them in a single `keystore`
    file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let''s generate a key, and here is the command and its process:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Next we need to generate a certificate file relative to this key file. Here
    is the command and its process:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we get the certificate request file `lb.csr` and its related key file `lb.key`.
    Next is to sign the certificate request file. Because this certificate is for
    testing, we don''t need to find an authority to sign it. We can use the key file
    to sign its own certificate request file. So this is a self-signed certificate.
    Here is the command and the running process:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The signed certificate file is generated and the name is `lb.crt`. This file
    is in the standard format, so we can also use `keytool` to check its content,
    as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'From the previous code snippet, we can see that the `Owner` and `Issuer` of
    this certificate are same. That was the process to generate a self-signed certificate
    with OpenSSL. Actually, we can wrap up the preceding processes into a single command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Using the preceding command, we can generate a key file and its self-signed
    certificate in one step.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring httpd to use certificates
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We need to add several directives into `httpd.conf`. The first step is to ask
    httpd to listen to port `443`, this is the standard port of https. I''m reusing
    the cluster configuration from the previous two chapters, so I''m still running
    my httpd on the machine `lb`, and I''ll configure it to listen to the public SSL
    port:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'And don''t forget to comment out the access to port 80, because we don''t want
    users to connect without HTTPS:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we need to configure `JK`, and its configuration file is in `conf.d/httpd-jk.conf`.
    Please delete all the contents inside and replace it with the following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: As shown in the preceding configuration, we have added a `VirtualHost` bound
    to the port `443`. In addition, we have enabled the SSL engine and provided the
    server certificate and its key files to use. Moreover, we have put the JkMount
    point inside this virtual host, so the user requests to HTTPS will be proxied
    by `JK` and sent to the EAP6 servers in behind.
  prefs: []
  type: TYPE_NORMAL
- en: 'That''s all we need to configure in httpd. Because the communication between
    httpd and the EAP6 servers are still using the plaintext AJP13 protocol, so we
    don''t need to change any configuration in EAP6\. Now we can start the EAP6 servers
    and the httpd server. During the httpd server startup, it needs us to input the
    pass phrase of our key. The process is shown in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Some of your private key files are encrypted for security reasons.
  prefs: []
  type: TYPE_NORMAL
- en: In order to read them you have to provide the pass phrases.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'If you have set `LogLevel` to `debug` in `httpd.conf`, you can see many SSL-related
    log outputs in `logs/error_log`. It''s a good source to do analysis if anything
    goes wrong. Now we can access the load balancer by using HTTPS and see that the
    requests are forwarded to the EAP6 servers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'If we use **Wireshark** to monitor the proxy channel between httpd and EAP6,
    we can see they are still using the *plaintext* AJP13 protocol to communicate:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Configuring httpd to use certificates](img/2432_06_17.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have got an overview on applying SSL to EAP6 and the clustering
    environment, and we have seen how to configure SSL and `JK` together into httpd.
    In the next chapter, we'll learn how to apply SSL with `mod_cluster`.
  prefs: []
  type: TYPE_NORMAL
