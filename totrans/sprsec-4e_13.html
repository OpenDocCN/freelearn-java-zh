<html><head></head><body>
<div id="sbo-rt-content"><div id="_idContainer105">
<h1 class="chapter-number" id="_idParaDest-273"><a id="_idTextAnchor415"/>13</h1>
<h1 id="_idParaDest-274"><a id="_idTextAnchor416"/>Custom Authorization</h1>
<p>In this chapter, we will write some custom implementations for <strong class="source-inline">Spring Security</strong>’s key authorization APIs. Once we have done this, we will use our understanding of the custom implementations to understand how <strong class="source-inline">Spring Security</strong>’s authorization <span class="No-Break">architecture works.</span></p>
<p>Throughout this chapter, we will cover the <span class="No-Break">following topics:</span></p>
<ul>
<li>Gaining an understanding of how <span class="No-Break">authorization works</span></li>
<li>Writing a custom <strong class="source-inline">SecurityMetaDataSource</strong> backed by a database instead of <span class="No-Break"><strong class="source-inline">requestMatchers()</strong></span><span class="No-Break"> methods</span></li>
<li>Creating <a id="_idIndexMarker874"/>custom <strong class="bold">Spring Expression Language</strong> (<span class="No-Break"><strong class="bold">SpEL</strong></span><span class="No-Break">) expressions</span></li>
<li>Implementing a custom <strong class="source-inline">PermissionEvaluator</strong> object that allows our permissions to <span class="No-Break">be encapsulated</span></li>
<li>Declaring a <span class="No-Break">custom </span><span class="No-Break"><strong class="source-inline">AuthorizationManager</strong></span></li>
</ul>
<p>This chapter’s code in action link is <span class="No-Break">here: </span><a href="https://packt.link/e630f"><span class="No-Break">https://packt.link/e630f</span></a><span class="No-Break">.</span></p>
<h1 id="_idParaDest-275"><a id="_idTextAnchor417"/>Authorizing the Requests</h1>
<p>As in the authentication process, <strong class="source-inline">Spring Security</strong> provides an <strong class="source-inline">o.s.s.web.access.intercept.FilterSecurityInterceptor</strong> servlet filter, which is <a id="_idIndexMarker875"/>responsible for coming up with a decision as to whether a particular request will be accepted or denied. At the point the filter is invoked, the principal has already been authenticated, so the system knows that a valid user has logged in; remember that we implemented the <strong class="source-inline">List&lt;GrantedAuthority&gt;</strong> <strong class="source-inline">getAuthorities()</strong> method, which returns a list of authorities for the principal, in <a href="B21757_03.xhtml#_idTextAnchor068"><span class="No-Break"><em class="italic">Chapter 3</em></span></a>, <em class="italic">Custom Authentication</em>. In general, the authorization process will use the information from this method (defined by the <strong class="source-inline">Authentication</strong> interface) to determine, for a particular request, whether or not the request should <span class="No-Break">be allowed.</span></p>
<p>This method serves as a means for an <strong class="source-inline">AuthorizationManager</strong> instance to acquire a precise String representation of the <strong class="source-inline">GrantedAuthority</strong>. By providing a representation as a String, most <strong class="source-inline">AuthorizationManager</strong> implementations can easily <strong class="source-inline">read</strong> the <strong class="source-inline">GrantedAuthority</strong>. If a <strong class="source-inline">GrantedAuthority</strong> cannot be accurately represented as a String, it is considered <strong class="source-inline">complex</strong>, and the <strong class="source-inline">getAuthority()</strong> method must <span class="No-Break">return </span><span class="No-Break"><strong class="source-inline">null</strong></span><span class="No-Break">.</span></p>
<p>A prime example of a complex <strong class="source-inline">GrantedAuthority</strong> would be an implementation storing a list of operations and authority thresholds related to various customer account numbers. Trying to represent this intricate <strong class="source-inline">GrantedAuthority</strong> as a String would pose considerable challenges. Consequently, the <strong class="source-inline">getAuthority()</strong> method should return <strong class="source-inline">null</strong>. This signals to any <strong class="source-inline">AuthorizationManager</strong> that it needs to support the specific <strong class="source-inline">GrantedAuthority</strong> implementation to comprehend <span class="No-Break">its contents.</span></p>
<p><strong class="source-inline">Spring Security</strong> features a concrete <strong class="source-inline">GrantedAuthority</strong> implementation named <strong class="source-inline">SimpleGrantedAuthority</strong>. This implementation enables the conversion of any user-specified String into a <strong class="source-inline">GrantedAuthority</strong>. All <strong class="source-inline">AuthenticationProvider</strong> instances integrated into the security architecture utilize <strong class="source-inline">SimpleGrantedAuthority</strong> to populate the <span class="No-Break"><strong class="source-inline">Authentication</strong></span><span class="No-Break"> object.</span></p>
<p>By default, role-based authorization rules involve the prefix <strong class="source-inline">ROLE_</strong>. Therefore, if an authorization rule mandates a security context to possess the role of <strong class="source-inline">USER</strong>, <strong class="source-inline">Spring Security</strong> will automatically seek a <strong class="source-inline">GrantedAuthority#getAuthority</strong> that <span class="No-Break">returns </span><span class="No-Break"><strong class="source-inline">ROLE_USER</strong></span><span class="No-Break">.</span></p>
<p>Remember that authorization is a binary decision—a user either has access to a secured resource or does not. There is no ambiguity when it comes <span class="No-Break">to authorization.</span></p>
<p>A smart object-oriented design is pervasive within the <strong class="source-inline">Spring Security</strong> framework, and authorization decision management is <span class="No-Break">no exception.</span></p>
<p>In <strong class="source-inline">Spring Security</strong>, the <strong class="source-inline">o.s.s.access.AccessDecisionManager</strong> interface <a id="_idIndexMarker876"/>specifies two simple and logical methods that fit sensibly into the processing decision flow of requests, <span class="No-Break">as follows:</span></p>
<ul>
<li><strong class="source-inline">supports</strong>: This logical operation actually comprises two methods that allow the <strong class="source-inline">AccessDecisionManager</strong> implementation to report whether or not it supports the <span class="No-Break">current request.</span></li>
<li><strong class="source-inline">decide</strong>: This allows the <strong class="source-inline">AccessDecisionManager</strong> implementation to verify, based on the request context and security configuration, whether or not access should be allowed and the request accepted. The <strong class="source-inline">Decide</strong> method actually has no return value, and instead reports the denial of a request by throwing an exception to <span class="No-Break">indicate rejection.</span></li>
</ul>
<p>Specific types of exceptions can further dictate the action to be taken by the application to resolve authorization decisions. The <strong class="source-inline">o.s.s.access.AccessDeniedException</strong> interface is the most common exception thrown in the area of authorization and merits special handling by the <span class="No-Break">filter chain.</span></p>
<p>The implementation of <strong class="source-inline">AccessDecisionManager</strong> is completely configurable using standard Spring bean binding and references. The default <strong class="source-inline">AccessDecisionManager</strong> implementation provides an access granting mechanism based on <strong class="source-inline">AccessDecisionVoter</strong> and <span class="No-Break">vote aggregation.</span></p>
<p>A voter is an actor in the authorization sequence whose job is to evaluate any or all of the <span class="No-Break">following things:</span></p>
<ul>
<li>The context of the request for a secured resource (such as a URL requesting an <span class="No-Break">IP address)</span></li>
<li>The credentials (if any) presented by <span class="No-Break">the user</span></li>
<li>The secured resource <span class="No-Break">being accessed</span></li>
<li>The configuration <a id="_idIndexMarker877"/>parameters of the system, and the <span class="No-Break">resource itself</span></li>
</ul>
<p>After demonstrating the process of authorizing requests, we will delve into the management <span class="No-Break">of invocations.</span></p>
<h1 id="_idParaDest-276"><a id="_idTextAnchor418"/>Handling of Invocations</h1>
<p><strong class="source-inline">Spring Security</strong> offers interceptors that are responsible for governing access to secure objects, be it method invocations<a id="_idIndexMarker878"/> or web requests. <strong class="source-inline">AuthorizationManager</strong> instances play a crucial role in making pre-invocation decisions regarding whether the invocation is permitted to proceed. Additionally, these instances contribute to post-invocation decisions, determining whether a particular value may <span class="No-Break">be returned.</span></p>
<h2 id="_idParaDest-277"><a id="_idTextAnchor419"/>The AuthorizationManager class</h2>
<p><strong class="source-inline">AuthorizationManager</strong> takes precedence over both <strong class="source-inline">AccessDecisionManager</strong> and <strong class="source-inline">AccessDecisionVoter</strong>. Applications that customize either an <strong class="source-inline">AccessDecisionManager</strong> or an <strong class="source-inline">AccessDecisionVoter</strong> are advised to transition <span class="No-Break">using </span><span class="No-Break"><strong class="source-inline">AuthorizationManager</strong></span><span class="No-Break">.</span></p>
<p><strong class="source-inline">Spring Security</strong>’s request-based, method-based, and message-based authorization <a id="_idIndexMarker879"/>components invoke <strong class="source-inline">AuthorizationManager</strong> instances, assigning them the responsibility of making definitive access <span class="No-Break">control decisions.</span></p>
<p>The <strong class="source-inline">check</strong> method of <strong class="source-inline">AuthorizationManager</strong> receives all the pertinent information necessary to render an authorization decision. Specifically, passing the secure object allows the examination of arguments within the actual invocation of the secure object. For instance, if the secure object is a <strong class="source-inline">MethodInvocation</strong>, querying it for any client argument becomes straightforward. Subsequently, security logic can be implemented in the <strong class="source-inline">AuthorizationManager</strong> to ensure that the principal is authorized to operate on that customer. Implementations are expected to return a positive <strong class="source-inline">AuthorizationDecision</strong> if access is granted, a negative <strong class="source-inline">AuthorizationDecision</strong> if access is denied, and a null <strong class="source-inline">AuthorizationDecision</strong> when abstaining from making <span class="No-Break">a decision.</span></p>
<p>The verify function invokes <strong class="source-inline">check</strong> and throws an <strong class="source-inline">AccessDeniedException</strong> if a negative <strong class="source-inline">AuthorizationDecision</strong> <span class="No-Break">is reached.</span></p>
<h2 id="_idParaDest-278"><a id="_idTextAnchor420"/>Delegate-based AuthorizationManager Implementations</h2>
<p>Although users have the<a id="_idIndexMarker880"/> flexibility to<a id="_idIndexMarker881"/> implement their own <strong class="source-inline">AuthorizationManager</strong> to govern all facets of authorization, <strong class="source-inline">Spring Security</strong> comes with a delegating <strong class="source-inline">AuthorizationManager</strong> designed to work in tandem with <span class="No-Break">individual </span><span class="No-Break"><strong class="source-inline">AuthorizationManagers</strong></span><span class="No-Break">.</span></p>
<p>The <strong class="source-inline">RequestMatcherDelegatingAuthorizationManager</strong> aligns the request with the most suitable delegate <strong class="source-inline">AuthorizationManager</strong>. For method security, <strong class="source-inline">AuthorizationManagerBeforeMethodInterceptor</strong> and <strong class="source-inline">AuthorizationManagerAfterMethodInterceptor</strong> can <span class="No-Break">be employed.</span></p>
<p>The relevant classes for <strong class="source-inline">AuthorizationManager</strong> implementations are outlined for reference in <span class="No-Break"><em class="italic">Figure 13</em></span><span class="No-Break"><em class="italic">.1</em></span><span class="No-Break">:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer100">
<img alt="Figure 13.1 – Implementations of AuthorizationManager" height="476" src="image/B21757_13_1.jpg" width="1323"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 13.1 – Implementations of AuthorizationManager</p>
<p>With this approach, a collection of <strong class="source-inline">AuthorizationManager</strong> implementations can be consulted for an <span class="No-Break">authorization decision.</span></p>
<p>In the following subsections, we will take a deeper look at some <span class="No-Break">authorization managers.</span></p>
<h3>AuthorityAuthorizationManager</h3>
<p>The predominant <strong class="source-inline">AuthorizationManager</strong> provided<a id="_idIndexMarker882"/> by <strong class="source-inline">Spring Security</strong> is the <strong class="source-inline">AuthorityAuthorizationManager</strong>. It is configured with a specific set of authorities to check for in the <a id="_idIndexMarker883"/>current <strong class="source-inline">Authentication</strong>. If the <strong class="source-inline">Authentication</strong> contains any of the configured authorities, it will yield a positive <strong class="source-inline">AuthorizationDecision</strong>; otherwise, it will result in a <span class="No-Break">negative </span><span class="No-Break"><strong class="source-inline">AuthorizationDecision</strong></span><span class="No-Break">.</span></p>
<h3>AuthenticatedAuthorizationManager</h3>
<p>Another manager available <a id="_idIndexMarker884"/>is the <strong class="source-inline">AuthenticatedAuthorizationManager</strong>. It proves<a id="_idIndexMarker885"/> useful in distinguishing between <em class="italic">anonymous</em>, <em class="italic">fully-authenticated</em>, and <em class="italic">remember-me</em> authenticated users. Some websites grant limited access under <em class="italic">remember-me</em> authentication but necessitate users to confirm their identity by logging in for <span class="No-Break">complete access.</span></p>
<h3>AuthorizationManagers</h3>
<p><strong class="source-inline">AuthorizationManagers</strong> also offer<a id="_idIndexMarker886"/> useful static factories for combining <a id="_idIndexMarker887"/>individual <strong class="source-inline">AuthorizationManagers</strong> into more <span class="No-Break">intricate expressions.</span></p>
<h3>Custom AuthorizationManagers</h3>
<p>Certainly, you have the<a id="_idIndexMarker888"/> option to <a id="_idIndexMarker889"/>implement a custom <strong class="source-inline">AuthorizationManager</strong>, allowing for the inclusion of virtually any access control logic. It may be tailored to your application, related to business logic, or involve security administration logic. For instance, you can create an implementation capable of <a id="_idIndexMarker890"/>querying <a id="_idIndexMarker891"/>Open Policy Agent or your own <span class="No-Break">authorization database.</span></p>
<p>After delving into the management of invocations, we will proceed to examine the customization of <strong class="source-inline">AccessDecisionManager</strong> <span class="No-Break">and </span><span class="No-Break"><strong class="source-inline">AccessDecisionVoter</strong></span><span class="No-Break">.</span></p>
<h1 id="_idParaDest-279"><a id="_idTextAnchor421"/>Modifying AccessDecisionManager and AccessDecisionVoter</h1>
<p>Before the <a id="_idIndexMarker892"/>introduction of <strong class="source-inline">AuthorizationManager</strong>, <strong class="source-inline">Spring Security</strong> introduced <strong class="source-inline">AccessDecisionManager</strong> <span class="No-Break">and </span><span class="No-Break"><strong class="source-inline">AccessDecisionVoter</strong></span><span class="No-Break">.</span></p>
<p>In certain <a id="_idIndexMarker893"/>scenarios, such as when migrating an older application, it might be preferable to incorporate an <strong class="source-inline">AuthorizationManager</strong> that invokes an <strong class="source-inline">AccessDecisionManager</strong> <span class="No-Break">or </span><span class="No-Break"><strong class="source-inline">AccessDecisionVoter</strong></span><span class="No-Break">.</span></p>
<p>To invoke an existing <strong class="source-inline">AccessDecisionManager</strong>, you <span class="No-Break">can use:</span></p>
<pre class="source-code">
@Component
public class AccessDecisionManagerAuthorizationManagerAdapter implements AuthorizationManager {
    private final AccessDecisionManager accessDecisionManager;
    private final SecurityMetadataSource securityMetadataSource;
    @Override
    public AuthorizationDecision check(Supplier&lt;Authentication&gt; authentication, Object object) {
       try {
          Collection&lt;ConfigAttribute&gt; attributes = this.securityMetadataSource.getAttributes(object);
          this.accessDecisionManager.decide(authentication.get(), object, attributes);
          return new AuthorizationDecision(true);
       } catch (AccessDeniedException ex) {
          return new AuthorizationDecision(false);
       }
    }
    @Override
    public void verify(Supplier&lt;Authentication&gt; authentication, Object object) {
       Collection&lt;ConfigAttribute&gt; attributes = this.securityMetadataSource.getAttributes(object);
       this.accessDecisionManager.decide(authentication.get(), object, attributes);
    }
}</pre> <p>Subsequently, integrate <a id="_idIndexMarker894"/>it into <span class="No-Break">your </span><span class="No-Break"><strong class="source-inline">SecurityFilterChain</strong></span><span class="No-Break">.</span></p>
<p>Alternatively, if you <a id="_idIndexMarker895"/>wish to only invoke an <strong class="source-inline">AccessDecisionVoter</strong>, you <span class="No-Break">can use:</span></p>
<pre class="source-code">
@Component
public class AccessDecisionVoterAuthorizationManagerAdapter implements AuthorizationManager {
    private final AccessDecisionVoter accessDecisionVoter;
    private final SecurityMetadataSource securityMetadataSource;
    @Override
    public AuthorizationDecision check(Supplier&lt;Authentication&gt; authentication, Object object) {
       Collection&lt;ConfigAttribute&gt; attributes = this.securityMetadataSource.getAttributes(object);
       int decision = this.accessDecisionVoter.vote(authentication.get(), object, attributes);
       switch (decision) {
          case ACCESS_GRANTED:
             return new AuthorizationDecision(true);
          case ACCESS_DENIED:
             return new AuthorizationDecision(false);
       }
       return null;
    }
}</pre> <p>Afterward, integrate <a id="_idIndexMarker896"/>it into <a id="_idIndexMarker897"/><span class="No-Break">your </span><span class="No-Break"><strong class="source-inline">SecurityFilterChain</strong></span><span class="No-Break">.</span></p>
<h1 id="_idParaDest-280"><a id="_idTextAnchor422"/>Legacy Authorization Components</h1>
<p>In this section, we <a id="_idIndexMarker898"/>will take a closer look at certain authorization components that existed in <strong class="source-inline">Spring Security</strong> but have been deprecated with the introduction of <strong class="source-inline">Spring </strong><span class="No-Break"><strong class="source-inline">Security 6</strong></span><span class="No-Break">.</span></p>
<h2 id="_idParaDest-281"><a id="_idTextAnchor423"/>The AccessDecisionManager</h2>
<p>The <strong class="source-inline">AbstractSecurityInterceptor</strong> invokes <a id="_idIndexMarker899"/>the <strong class="source-inline">AccessDecisionManager</strong>, which is <a id="_idIndexMarker900"/>tasked with making conclusive access control decisions. The <strong class="source-inline">AccessDecisionManager</strong> interface encompasses <span class="No-Break">three methods:</span></p>
<pre class="source-code">
void decide(Authentication authentication, Object secureObject,
       Collection&lt;ConfigAttribute&gt; attrs) throws AccessDeniedException;
boolean supports(ConfigAttribute attribute);
boolean supports(Class clazz);</pre> <p>The <strong class="source-inline">decide</strong> method of the <strong class="source-inline">AccessDecisionManager</strong> receives all the pertinent information required to make an authorization decision. Specifically, passing the secure object allows the inspection of arguments within the actual invocation of the secure object. For instance, if the secure object is a <strong class="source-inline">MethodInvocation</strong>, you can inquire about any <strong class="source-inline">Customer</strong> argument in the <strong class="source-inline">MethodInvocation</strong> and then implement security logic in the <strong class="source-inline">AccessDecisionManager</strong> to verify whether the principal is authorized <a id="_idIndexMarker901"/>to operate on that customer. Implementations <a id="_idIndexMarker902"/>are expected to throw an <strong class="source-inline">AccessDeniedException</strong> if access <span class="No-Break">is denied.</span></p>
<p>The <strong class="source-inline">supports(ConfigAttribute</strong>) method is invoked by the <strong class="source-inline">AbstractSecurityInterceptor</strong> during startup to determine whether the <strong class="source-inline">AccessDecisionManager</strong> can handle the provided <strong class="source-inline">ConfigAttribute</strong>. The <strong class="source-inline">supports(Class clazz)</strong> method is called by a security interceptor implementation to ensure that the configured <strong class="source-inline">AccessDecisionManager</strong> supports the type of secure object presented by the <span class="No-Break">security interceptor.</span></p>
<h2 id="_idParaDest-282"><a id="_idTextAnchor424"/>AccessDecisionManager Implementations Based on Voting</h2>
<p>Although <a id="_idIndexMarker903"/>users have the flexibility to implement their own <strong class="source-inline">AccessDecisionManager</strong> to oversee all aspects of authorization, <strong class="source-inline">Spring Security</strong> provides various <strong class="source-inline">AccessDecisionManager</strong> implementations <a id="_idIndexMarker904"/>grounded in a voting mechanism. The relevant classes are explained in the <strong class="bold">Voting </strong><span class="No-Break"><strong class="bold">Decision Manager</strong></span><span class="No-Break">.</span></p>
<p>The <strong class="source-inline">AccessDecisionManager</strong> interface is illustrated in the <span class="No-Break">following figure:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer101">
<img alt="Figure 13.2 – Voting Decision Manager" height="311" src="image/B21757_13_2.jpg" width="524"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 13.2 – Voting Decision Manager</p>
<p>Through this approach, a sequence of <strong class="source-inline">AccessDecisionVoter</strong> implementations is consulted <a id="_idIndexMarker905"/>for an authorization decision. The <strong class="source-inline">AccessDecisionManager</strong> subsequently determines whether or not to throw an <strong class="source-inline">AccessDeniedException</strong> based on its evaluation of <span class="No-Break">the votes.</span></p>
<p><strong class="source-inline">Spring Security</strong> provides three concrete <strong class="source-inline">AccessDecisionManager </strong>implementations to aggregate votes. The <strong class="source-inline">ConsensusBased</strong> implementation allows or denies access based on the consensus of non-abstain votes. Configurable properties govern behavior in case of vote equality or if all votes abstain. The <strong class="source-inline">AffirmativeBased</strong> implementation grants access if one or more <strong class="source-inline">ACCESS_GRANTED</strong> votes are received (ignoring deny votes as long as there is at least one grant vote). Similar to <strong class="source-inline">ConsensusBased</strong>, it has a parameter controlling behavior if all voters abstain. The <strong class="source-inline">UnanimousBased</strong> implementation requires unanimous <strong class="source-inline">ACCESS_GRANTED</strong> votes for access, disregarding abstains. It denies access with any <strong class="source-inline">ACCESS_DENIED</strong> vote. Like the others, it has a parameter governing behavior if all <span class="No-Break">voters abstain.</span></p>
<p>Custom <strong class="source-inline">AccessDecisionManager</strong> instances can be implemented to customize vote tallying. For instance, votes from a specific <strong class="source-inline">AccessDecisionVoter</strong> might carry additional weight, and a deny vote from a particular voter could have a <span class="No-Break">veto effect.</span></p>
<h3>RoleVoter</h3>
<p>The <strong class="source-inline">RoleVoter</strong>, the most <a id="_idIndexMarker906"/>commonly utilized <strong class="source-inline">AccessDecisionVoter</strong> provided by <strong class="source-inline">Spring Security</strong>, interprets configuration attributes as role names and votes to grant access if the user has been assigned <span class="No-Break">that role.</span></p>
<p>It casts a <a id="_idIndexMarker907"/>vote if any <strong class="source-inline">ConfigAttribute</strong> starts with the <strong class="source-inline">ROLE_</strong> prefix. Access is granted if there is a <strong class="source-inline">GrantedAuthority</strong> that returns a String representation (via the <strong class="source-inline">getAuthority()</strong> method) exactly matching one or more <strong class="source-inline">ConfigAttribute</strong> instances, starting with the <strong class="source-inline">ROLE_</strong> prefix. If there is no precise match for any <strong class="source-inline">ConfigAttribute</strong> starting with <strong class="source-inline">ROLE_</strong>, <strong class="source-inline">RoleVoter</strong> votes to deny access. If no <strong class="source-inline">ConfigAttribute</strong> starts with <strong class="source-inline">ROLE_</strong>, the <span class="No-Break">voter abstains.</span></p>
<h3>AuthenticatedVoter</h3>
<p>Another <a id="_idIndexMarker908"/>implicit voter is the <strong class="source-inline">AuthenticatedVoter</strong>, useful for distinguishing between <em class="italic">anonymous</em>, <em class="italic">fully-authenticated</em>, and <em class="italic">remember-me</em> authenticated users. Many websites allow limited access <a id="_idIndexMarker909"/>under <em class="italic">remember-me</em> authentication but necessitate user confirmation of identity by logging in for <span class="No-Break">full access.</span></p>
<p>The processing of the <strong class="source-inline">IS_AUTHENTICATED_ANONYMOUSLY</strong> attribute for granting anonymous access is handled by the <strong class="source-inline">AuthenticatedVoter</strong>, as seen in <span class="No-Break">previous examples.</span></p>
<h3>Custom Voters</h3>
<p>Implementing <a id="_idIndexMarker910"/>a custom <strong class="source-inline">AccessDecisionVoter</strong> enables the inclusion of virtually any access control logic. It may be tailored <a id="_idIndexMarker911"/>to your application, related to business logic, or involve security administration logic. For instance, a blog article on the Spring website outlines using a voter to deny real-time access to users with <span class="No-Break">suspended accounts.</span></p>
<h3>Expression-based request authorization</h3>
<p>As you <a id="_idIndexMarker912"/>might expect, <strong class="bold">SpEL</strong> handling is supplied <a id="_idIndexMarker913"/>by a different <strong class="source-inline">Voter</strong> implementation, <strong class="source-inline">o.s.s.web.access.expression.WebExpressionVoter</strong>, which understands how to evaluate the SpEL expressions. The <strong class="source-inline">WebExpressionVoter</strong> class relies on an implementation of the <strong class="source-inline">SecurityExpressionHandler</strong> interface for this purpose. The <strong class="source-inline">SecurityExpressionHandler</strong> interface is responsible both for evaluating the expressions and for supplying the security-specific methods that are referenced in the expressions. The default implementation of this interface exposes methods defined in the <span class="No-Break"><strong class="source-inline">o.s.s.web.access.expression.WebSecurityExpressionRoot</strong></span><span class="No-Break"> class.</span></p>
<p>The <a id="_idIndexMarker914"/>flow and relationship <a id="_idIndexMarker915"/>between these classes are shown in the <span class="No-Break">following diagram:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer102">
<img alt="Figure 13.3 – Relationship between WebSecurityExpressionRoot and AccessDecisionManager" height="1021" src="image/B21757_13_3.jpg" width="1300"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 13.3 – Relationship between WebSecurityExpressionRoot and AccessDecisionManager</p>
<p>Now that we know how request authorization work<a id="_idTextAnchor425"/>s, let’s solidify our understanding by making a few custom implementations of some <span class="No-Break">key interfaces.</span></p>
<p>The real <a id="_idIndexMarker916"/>power of <strong class="source-inline">Spring Security</strong>’s authorization is demonstrated by how adaptable it is to custom requirements. Let’s <a id="_idIndexMarker917"/>explore a fe<a id="_idTextAnchor426"/>w scenarios that will help reinforce our understanding of the <span class="No-Break">overall architecture.</span></p>
<h1 id="_idParaDest-283"><a id="_idTextAnchor427"/>Dynamically defining access control to URLs</h1>
<p><strong class="source-inline">Spring Security</strong> provides several methods for mapping <strong class="source-inline">ConfigAttribute</strong> objects to a resource. For example, the <strong class="source-inline">requestMatchers()</strong> method ensures it is simple for <a id="_idIndexMarker918"/>developers to restrict access to specific HTTP requests in their web applications. Behind the scenes, an implementation of <strong class="source-inline">o.s.s.acess.SecurityMetadataSource</strong> is populated with these mappings and queried to determine what is required in order to be authorized to make any given <span class="No-Break">HTTP request.</span></p>
<p>While the <strong class="source-inline">requestMatchers()</strong> method is very simple, there may be times when it would be desirable to provide a custom mechanism for determining the URL mappings. An example of this might be if an application needs to be able to dynamically provide access control rules. Let’s demonstrate what it would take to<a id="_idTextAnchor428"/> move our URL aut<a id="_idTextAnchor429"/>horization configuration into <span class="No-Break">a database.</span></p>
<h2 id="_idParaDest-284"><a id="_idTextAnchor430"/>Configuring the RequestConfigMappingService</h2>
<p>The first step is to be able to obtain the necessary information from the database. This will replace <a id="_idIndexMarker919"/>the logic that reads in the <strong class="source-inline">requestMatchers()</strong> methods from our security bean configuration. In order to do this, the chapter’s sample code contains <strong class="source-inline">JpaRequestConfigMappingService</strong>, which will obtain a mapping of an <strong class="source-inline">Ant Pattern</strong> and an expression from the database represented as <strong class="source-inline">RequestConfigMapping</strong>. The rather simple implementation is <span class="No-Break">as follows:</span></p>
<pre class="source-code">
//src/main/java/com/packtpub/springsecurity/web/access/intercept/JpaRequestConfigMappingService.java
@Repository
public class JpaRequestConfigMappingService implements RequestConfigMappingService {
    private final SecurityFilterMetadataRepository securityFilterMetadataRepository;
    public JpaRequestConfigMappingService(final SecurityFilterMetadataRepository securityFilterMetadataRepository) {
          this.securityFilterMetadataRepository = securityFilterMetadataRepository;
    }
    public List&lt;RequestConfigMapping&gt; getRequestConfigMappings() {
          return securityFilterMetadataRepository
                .findAll()
                .stream()
                .sorted(Comparator.comparingInt(SecurityFilterMetadata::getSortOrder))
                .map(md -&gt; new RequestConfigMapping(
                      new AntPathRequestMatcher(md.getAntPattern()),
                      new SecurityConfig(md.getExpression()))).toList();
    }
}</pre> <p>It is important to <a id="_idIndexMarker920"/>notice that, just as with the <strong class="source-inline">requestMatchers()</strong> methods, order matters. Therefore, we ensure the results are sorted by the <strong class="source-inline">sort_order</strong> column. The service creates an <strong class="source-inline">AntRequestMatcher</strong> and associates it with <strong class="source-inline">SecurityConfig</strong>, an instance of <strong class="source-inline">ConfigAttribute</strong>. This will provide a mapping of the HTTP request to <strong class="source-inline">ConfigAttribute</strong> objects that can be used by <strong class="source-inline">Spring Security</strong> to secure <span class="No-Break">our URLs.</span></p>
<p>We need <a id="_idIndexMarker921"/>to create a domain object to use <a id="_idIndexMarker922"/>for <strong class="bold">Jakarta Persistence</strong> (<strong class="bold">JPA</strong>) to map to, <span class="No-Break">as follows:</span></p>
<pre class="source-code">
//src/main/java/com/packtpub/springsecurity/domain/SecurityFilterMetadata.java
@Entity
@Table(name = "security_filter_metadata")
public class SecurityFilterMetadata implements Serializable {
    @Id
    @GeneratedValue(strategy = GenerationType.AUTO)
    private Integer id;
    private String antPattern;
    private String expression;
    private Integer sortOrder;
... setters / getters ...
}</pre> <p>Finally, we need to create a Spring Data repository object, <span class="No-Break">as follows:</span></p>
<pre class="source-code">
//src/main/java/com/packtpub/springsecurity/repository/ SecurityFilterMetadataRepository.java
public interface SecurityFilterMetadataRepository extends JpaRepository&lt;SecurityFilterMetadata, Integer&gt; {}</pre> <p>In order for the new service to work, we will need to initialize our database with the schema and the access control mappings, just as with the service implementation. The <strong class="source-inline">security_filter_metadata</strong> table schema can be auto-generated <span class="No-Break">by </span><span class="No-Break"><strong class="source-inline">spring-data-jpa</strong></span><span class="No-Break">.</span></p>
<p>We can <a id="_idIndexMarker923"/>then use the same <strong class="source-inline">requestMatchers()</strong> mappings from our <strong class="source-inline">SecurityConfig.java</strong> file to produce the <span class="No-Break"><strong class="source-inline">data.sql</strong></span><span class="No-Break"> file:</span></p>
<pre class="source-code">
//src/main/resources/data.sql
insert into security_filter_metadata(id,ant_pattern,expression,sort_order) values (115, '/','permitAll',15);
insert into security_filter_metadata(id,ant_pattern,expression,sort_order) values (120, '/login/*','permitAll',20);
insert into security_filter_metadata(id,ant_pattern,expression,sort_order) values (130, '/logout','permitAll',30);
insert into security_filter_metadata(id,ant_pattern,expression,sort_order) values (140, '/signup/*','permitAll',40);
insert into security_filter_metadata(id,ant_pattern,expression,sort_order) values (150, '/errors/**','permitAll',50);
insert into security_filter_metadata(id,ant_pattern,expression,sort_order) values (160, '/admin/**','hasRole("ADMIN")',60);
insert into security_filter_metadata(id,ant_pattern,expression,sort_order) values (170, '/events/','hasRole("ADMIN")',70);
insert into security_filter_metadata(id,ant_pattern,expression,sort_order) values (180, '/**','hasRole("USER")',80);</pre> <p>Once <a id="_idIndexMarker924"/>the <strong class="source-inline">RequestConfigMappingService</strong> is configured, we’ll explore the implementation of a <span class="No-Break">custom </span><span class="No-Break"><strong class="source-inline">SecurityMetadataSource</strong></span><span class="No-Break">.</span></p>
<h3>Custom SecurityMetadataSource implementation</h3>
<p>In order for <strong class="source-inline">Spring Security</strong> to be aware of our URL mappings, we need to provide <a id="_idIndexMarker925"/>a custom <strong class="source-inline">FilterInvocationSecurityMetadataSource</strong> implementation. The <strong class="source-inline">FilterInvocationSecurityMetadataSource</strong> package extends the <strong class="source-inline">SecurityMetadataSource</strong> interface which, given a particular HTTP request, is what provides <strong class="source-inline">Spring Security</strong> with the information necessary for determining whether access should be granted. Let’s take a look at how we can utilize our<strong class="source-inline"> RequestConfigMappingService</strong> interface to implement a <span class="No-Break"><strong class="source-inline">SecurityMetadataSource</strong></span><span class="No-Break"> interface:</span></p>
<pre class="source-code">
//src/main/java/com/packtpub/springsecurity/web/access/intercept/FilterInvocationServiceSecurityMetadataSource.java
@Component
public class FilterInvocationServiceSecurityMetadataSource implements FilterInvocationSecurityMetadataSource {
    private FilterInvocationSecurityMetadataSource delegate;
    private final RequestConfigMappingService requestConfigMappingService;
    public FilterInvocationServiceSecurityMetadataSource (RequestConfigMappingService filterInvocationService) {
          this.requestConfigMappingService = filterInvocationService;
    }
    public Collection&lt;ConfigAttribute&gt; getAllConfigAttributes() {
          return this.delegate.getAllConfigAttributes();
    }
    public Collection&lt;ConfigAttribute&gt; getAttributes(Object object) {
          if (delegate == null)
             getDelegate();
          return this.delegate.getAttributes(object);
    }
    public boolean supports(Class&lt;?&gt; clazz) {
         return this.delegate.supports(clazz);
    }
    public void getDelegate() {
          List&lt;RequestConfigMapping&gt; requestConfigMappings = requestConfigMappingService.getRequestConfigMappings();
          LinkedHashMap&lt;RequestMatcher, Collection&lt;ConfigAttribute&gt;&gt; requestMap = new LinkedHashMap&lt;RequestMatcher, Collection&lt;ConfigAttribute&gt;&gt;(requestConfigMappings.size());
          for (RequestConfigMapping requestConfigMapping : requestConfigMappings) {
             RequestMatcher matcher = requestConfigMapping.getMatcher();
             requestMap.put(matcher, requestConfigMapping.getAttributes());
          }
          this.delegate = new ExpressionBasedFilterInvocationSecurityMetadataSource(requestMap, new DefaultWebSecurityExpressionHandler());
    }
}</pre> <p>We <a id="_idIndexMarker926"/>are able to use our <strong class="source-inline">RequestConfigMappingService</strong> interface to create a map of <strong class="source-inline">RequestMatcher</strong> objects that map to <strong class="source-inline">ConfigAttribute</strong> objects. We then delegate to an instance of <strong class="source-inline">ExpressionBasedFilterInvocationSecurityMetadataSource</strong> to do all the work. For simplicity, the current implementation would require restarting the application to pick up changes. Howev<a id="_idTextAnchor431"/>er, with a few minor changes, we could avoid <span class="No-Break">this inconvenience.</span></p>
<h2 id="_idParaDest-285"><a id="_idTextAnchor432"/>Registering a custom SecurityMetadataSource</h2>
<p>Now, all <a id="_idIndexMarker927"/>that is left is for us to configure <strong class="source-inline">FilterInvocationServiceSecurityMetadataSource</strong>. The only problem is that <strong class="source-inline">Spring Security</strong> does not support configuring a custom <strong class="source-inline">FilterInvocationServiceSecurityMetadataSource</strong> interface directly. This is not too difficult, so we will register this <strong class="source-inline">SecurityMetadataSource</strong> with our <strong class="source-inline">FilterSecurityInterceptor</strong> in our <span class="No-Break"><strong class="source-inline">SecurityConfig</strong></span><span class="No-Break"> file:</span></p>
<pre class="source-code">
//src/main/java/com/packtpub/springsecurity/configuration/ SecurityConfig.java
@Configuration
@EnableWebSecurity
@EnableMethodSecurity
public class SecurityConfig {
@Bean
public SecurityFilterChain filterChain(HttpSecurity http,
       FilterInvocationServiceSecurityMetadataSource metadataSource,
       AccessDecisionManager accessDecisionManager) throws Exception {
    http.authorizeRequests().anyRequest().authenticated();
    http.authorizeRequests().accessDecisionManager(accessDecisionManager);
    http.authorizeRequests()
          .withObjectPostProcessor(new ObjectPostProcessor&lt;FilterSecurityInterceptor&gt;() {
             public &lt;O extends FilterSecurityInterceptor&gt; O postProcess(
                   O fsi) {
                fsi.setPublishAuthorizationSuccess(true);
                fsi.setSecurityMetadataSource(metadataSource);
                return fsi;
             }
          });
...omitted for brevity
    return http.build();
}</pre> <p>This sets up our custom <strong class="source-inline">SecurityMetadataSource</strong> interface with the<strong class="source-inline"> FilterSecurityInterceptor</strong> object as the default <span class="No-Break">metadata source.</span></p>
<p>Now that the database is being used to map our security configuration, we can remove the <strong class="source-inline">requestMatchers()</strong> method from our <span class="No-Break"><strong class="source-inline">SecurityConfig.java</strong></span><span class="No-Break"> file.</span></p>
<p>You should <a id="_idIndexMarker928"/>now be able to start the application and test to ensure that our URLs are secure, as they should be. Our users will not notice a difference, but we know that our URL mappings are persisted in a <span class="No-Break">database now.</span></p>
<p class="callout-heading">Important note</p>
<p class="callout">Your code should now look like <span class="No-Break">this: </span><span class="No-Break"><strong class="source-inline">calendar13.01-calendar</strong></span><span class="No-Break">.</span></p>
<h1 id="_idParaDest-286"><a id="_idTextAnchor433"/>Creating a custom expression</h1>
<p>The <strong class="source-inline">o.s.s.access.expression.SecurityExpresssionHandler</strong> interface is how <strong class="source-inline">Spring Security</strong> abstracts how the Spring expressions are created and initialized. Just as <a id="_idIndexMarker929"/>with the <strong class="source-inline">SecurityMetadataSource</strong> interface, there is an implementation for creating expressions for web requests and creatin<a id="_idTextAnchor434"/>g expressions for securing methods. In this section, we<a id="_idTextAnchor435"/> will explore how we can easily add <span class="No-Break">new expressions.</span></p>
<h2 id="_idParaDest-287"><a id="_idTextAnchor436"/>Configuring a custom SecurityExpressionRoot</h2>
<p>Let’s assume that we want to support a custom <strong class="source-inline">Web Expression</strong> named <strong class="source-inline">isLocal</strong> that will return <strong class="source-inline">true</strong> if the host is <strong class="source-inline">localhost</strong> and <strong class="source-inline">false</strong> otherwise. This new method could be used to provide additional security for our SQL console by ensuring that it is only accessed from the <a id="_idIndexMarker930"/>same machine that the web application is <span class="No-Break">deployed from.</span></p>
<p>This is an artificial example that does not add any security benefits since the host comes from the headers of the HTTP request. This means a malicious user could inject a header stating that the host is <strong class="source-inline">localhost</strong> even if they are requesting to an <span class="No-Break">external domain.</span></p>
<p>All of the expressions that we have seen are available because the <strong class="source-inline">SecurityExpressionHandler</strong> interface makes them available via an instance of <strong class="source-inline">o.s.s.access.expression.SecurityExpressionRoot</strong>. If you open this object, you will find the methods and properties we use in Spring expressions (that is, <strong class="source-inline">hasRole</strong>, <strong class="source-inline">hasPermission</strong>, and so on), which are common in both web and method security. A subclass provides the methods that are specific to the web and method expressions. For example, <strong class="source-inline">o.s.s.web.access.expression.WebSecurityExpressionRoot</strong> provides the <strong class="source-inline">hasIpAddress</strong> method for <span class="No-Break">web requests.</span></p>
<p>To create a custom <a id="_idIndexMarker931"/>web <strong class="source-inline">SecurityExpressionhandler</strong>, we will first need to create a subclass of <strong class="source-inline">WebSecurityExpressionRoot</strong> that defines our <strong class="source-inline">isLocal</strong> method, <span class="No-Break">as follows:</span></p>
<pre class="source-code">
//src/main/java/com/packtpub/springsecurity/web/access/expression/ CustomWebSecurityExpressionRoot.java
public class CustomWebSecurityExpressionRoot extends WebSecurityExpressionRoot {
    public CustomWebSecurityExpressionRoot(Authentication a, FilterInvocation fi) {
       super(a, fi);
    }
    public boolean isLocal() {
       return "localhost".equals(request.getServerName());
    }
}</pre> <p class="callout-heading">Important note</p>
<p class="callout">It is important to note that <strong class="source-inline">getServerName()</strong> returns the value that is provided in the <strong class="source-inline">Host</strong> header value. This means that a malicious user can inject a different value into the header to bypass constraints. However, most application servers and proxies can enforce the value of the <strong class="source-inline">Host</strong> header. Please read the appropriate documentation before leveraging such an approach to e<a id="_idTextAnchor437"/>nsure that malicious users do not inject a <strong class="source-inline">Host</strong> header value to bypass such <span class="No-Break">a constraint.</span></p>
<h2 id="_idParaDest-288"><a id="_idTextAnchor438"/>Configuring a custom SecurityExpressionHandler</h2>
<p>In order <a id="_idIndexMarker932"/>for our new method to become available, we need to create a custom <strong class="source-inline">SecurityExpressionHandler</strong> interface that utilizes our new root object. This is as simple as extending <strong class="source-inline">WebSecurityExpressionHandler</strong>, <span class="No-Break">as follows:</span></p>
<pre class="source-code">
//src/main/java/com/packtpub/springsecurity/web/access/expression/ CustomWebSecurityExpressionHandler.java
@Component
public class CustomWebSecurityExpressionHandler extends DefaultWebSecurityExpressionHandler {
    private final AuthenticationTrustResolver trustResolver = new AuthenticationTrustResolverImpl();
    @Override
    protected SecurityExpressionOperations createSecurityExpressionRoot(Authentication authentication, FilterInvocation fi) {
       WebSecurityExpressionRoot root = new CustomWebSecurityExpressionRoot(authentication, fi);
       root.setPermissionEvaluator(getPermissionEvaluator());
       root.setTrustResolver(trustResolver);
       root.setRoleHierarchy(getRoleHierarchy());
       return root;
    }
}</pre> <p>We <a id="_idIndexMarker933"/>perform the same steps that the superclass does, except that we use<strong class="source-inline"> CustomWebSecurityExpressionRoot</strong>, which contains the <span class="No-Break">new method.</span></p>
<p>The <strong class="source-inline">CustomWebSecurityExpressionRoot</strong> becomes the root of our <span class="No-Break">SpEL expression.</span></p>
<p class="callout-heading">Important note</p>
<p class="callout">For further <a id="_idIndexMarker934"/>details, refer to the SpEL documentation within the Spring Reference <span class="No-Break">documentation: </span><a href="https://docs.spring.io/spring-framework/reference/core/expressions.xhtml"><span class="No-Break">https://docs.spring.io/spring-framework/reference/core/expressions.xhtml</span></a><span class="No-Break">.</span></p>
<h2 id="_idParaDest-289"><a id="_idTextAnchor439"/>Configuring and using CustomWebSecurityExpressionHandler</h2>
<p>We now need to configure <strong class="source-inline">CustomWebSecurityExpressionHandler</strong>. Fortunately, this can be <a id="_idIndexMarker935"/>done easily using the <strong class="source-inline">Spring Security</strong> namespace configuration support. Add the following configuration to the <span class="No-Break"><strong class="source-inline">SecurityConfig.java</strong></span><span class="No-Break"> file:</span></p>
<pre class="source-code">
// Web Expression Handler:
http.authorizeRequests()
       .expressionHandler(customWebSecurityExpressionHandler);</pre> <p>Now, let’s update our initialization SQL query to use the new expression. Update the <strong class="source-inline">data.sql</strong> file so that it requires the user to be <strong class="source-inline">ROLE_ADMIN</strong> and requested from the local machine. You will notice that we are able to write local instead of <strong class="source-inline">isLocal</strong>, since SpEL supports Java <span class="No-Break">Bean conventions:</span></p>
<pre class="source-code">
//src/main/resources/data.sql
insert into security_filter_metadata(id,ant_pattern,expression,sort_order) values (160, '/admin/**','local and hasRole("ADMIN")',60);</pre> <p>Restart the <span class="P---Regular-Char">application</span> and access the H2 console using <strong class="source-inline">localhost:8080/admin/h2</strong> and <strong class="source-inline">admin1@example.com/admin1</strong> to see the <span class="No-Break">admin console.</span></p>
<p>If the <a id="_idIndexMarker936"/>H2 console is accessed using <strong class="source-inline">127.0.0.1:8080/admin/h2</strong> and <strong class="source-inline">admin1@example.com/admin1</strong>, the <strong class="bold">Access Denied</strong> page will <span class="No-Break">be displayed.</span></p>
<p class="callout-heading">Important note</p>
<p class="callout">Your code should now look like <span class="No-Break">this: </span><span class="No-Break"><strong class="source-inline">calendar13.02-calendar</strong></span><span class="No-Break">.</span></p>
<h2 id="_idParaDest-290"><a id="_idTextAnchor440"/>Alternative to a CustomWebSecurityExpressionHandler</h2>
<p>Following <a id="_idIndexMarker937"/>an examination of the <strong class="source-inline">CustomWebSecurityExpressionHandler</strong> usage, we will investigate alternative <a id="_idIndexMarker938"/>approaches by employing a custom <strong class="source-inline">PermissionEvaluator</strong> to enhance the security of <span class="No-Break">our </span><span class="No-Break"><strong class="source-inline">CalendarService</strong></span><span class="No-Break">.</span></p>
<h3>How does method security work?</h3>
<p>The access decision mechanism<a id="_idIndexMarker939"/> for method security—whether or not a given request is allowed—is conceptually the same as the access decision logic for web request access. <strong class="source-inline">AccessDecisionManager</strong> polls a set of <strong class="source-inline">AccessDecisionVoter</strong> instances, each of which can provide a decision to grant or deny access or abstain from voting. The specific implementation of <strong class="source-inline">AccessDecisionManager</strong> aggregates the voter decisions and arrives at an overall decision to allow for the <span class="No-Break">method invocation.</span></p>
<p>Web request access decision-making is less complicated, due to the fact that the availability of servlet filters makes the interception (and summary rejection) of securable requests relatively straightforward. As method invocation can happen from anywhere, including areas of code that are not directly configured by <strong class="source-inline">Spring Security</strong>, the <strong class="source-inline">Spring Security</strong> designers chose to use a Spring-managed <strong class="bold">Aspect-</strong><strong class="bold">O</strong><strong class="bold">riented Programming</strong> (<strong class="bold">AOP</strong>) approach <a id="_idIndexMarker940"/>to recognize, evaluate, and secure <span class="No-Break">method invocations.</span></p>
<p>The following high-level flow illustrates the main players involved in authorization decisions for <a id="_idIndexMarker941"/><span class="No-Break">method invocation:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer103">
<img alt="Figure 13.4 – Main classes involved in authorization decisions for method invocation" height="856" src="image/B21757_13_4.jpg" width="1211"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 13.4 – Main classes involved in authorization decisions for method invocation</p>
<p>We can see that <strong class="source-inline">Spring Security</strong>’s <strong class="source-inline">o.s.s.access.intercept.aopalliance.MethodSecurityInterceptor</strong> is invoked by the standard Spring AOP runtime to intercept method calls of interest. From here, the logic of whether or not to allow a method call is relatively straightforward, as per the previous <span class="No-Break">flow diagram.</span></p>
<p>At this point, we might wonder about the performance of the method security feature. Obviously, <strong class="source-inline">MethodSecurityInterceptor</strong> can’t be invoked for every method call in the application—so how do annotations on methods or classes result in <span class="No-Break">AOP interception?</span></p>
<p>First of all, AOP proxying isn’t invoked for all Spring-managed beans by default. Instead, if <strong class="source-inline">@EnableMethodSecurity</strong> is defined in the <strong class="source-inline">Spring Security</strong> configuration, a standard Spring AOP <strong class="source-inline">o.s.beans.factory.config.BeanPostProcessor</strong> will be registered that will introspect the AOP configuration to see whether any AOP advisors indicate that proxying (and the interception) is required. This workflow is standard Spring AOP <a id="_idIndexMarker942"/>handling (known as <strong class="bold">AOP auto-proxying</strong>) and doesn’t inherently have any functionality specific to <strong class="source-inline">Spring Security</strong>. All registered <strong class="source-inline">BeanPostProcessor</strong> instances run upon initialization of the Spring <strong class="source-inline">ApplicationContext</strong>; after all, Spring bean configurations <span class="No-Break">have occurred.</span></p>
<p>The AOP auto-proxy functionality queries all registered <strong class="source-inline">PointcutAdvisor</strong> instances, to see if there are AOP pointcuts that resolve method invocations that should have AOP advice applied. <strong class="source-inline">Spring Security</strong> implements the <strong class="source-inline">o.s.s.access.intercept.aopalliance.MethodSecurityMetadataSourceAdvisor</strong> class, which examines any and all configured method security annotations and sets up appropriate AOP interception. Take note that only interfaces or classes with declared <a id="_idIndexMarker943"/>method security annotations will be proxied <span class="No-Break">for AOP!</span></p>
<p class="callout-heading">Important note</p>
<p class="callout">Be aware that it is strongly encouraged to declare AOP rules (and other security annotations) on interfaces, and not on implementation classes. The use of classes, while available using CGLIB proxying with Spring, may unexpectedly change the behavior of your application, and is generally less semantically correct than security declarations (through AOP) on interfaces. <strong class="source-inline">MethodSecurityMetadataSourceAdvisor</strong> delegates the decision to affect methods with the AOP advice to an <strong class="source-inline">o.s.s.access.method.MethodSecurityMetadataSource</strong> instance. The different forms of method security annotation each have their own <strong class="source-inline">MethodSecurityMetadataSource</strong> implementation, which is used to introspect each method, class in turn, and add AOP advice to be executed <span class="No-Break">at runtime.</span></p>
<p>The following diagram illustrates how this <span class="No-Break">process occurs:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer104">
<img alt="Figure 13.5 – AOP interceptors for method security" height="718" src="image/B21757_13_5.jpg" width="1303"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 13.5 – AOP interceptors for method security</p>
<p>Depending on the number of Spring beans configured in your application and the number of secured method annotations you have, adding method security proxying may increase <a id="_idIndexMarker944"/>the time required to initialize your <strong class="source-inline">ApplicationContext</strong>. Once your Spring context is initialized, however, there is a negligible performance impact on individual <span class="No-Break">proxied beans.</span></p>
<p>Now that we have an understanding of how we can use AOP to apply <strong class="source-inline">Spring Security</strong>, let’s strengthen our grasp of <strong class="source-inline">Spring Security</strong> authorization by creating a <span class="No-Break">custom </span><span class="No-Break"><strong class="source-inline">PermissionEvaluator</strong></span><span class="No-Break">.</span></p>
<h3>Creating a custom PermissionEvaluator</h3>
<p>In the previous <a id="_idIndexMarker945"/>chapter, we demonstrated that we<a id="_idIndexMarker946"/> could use <strong class="source-inline">Spring Security</strong>’s built-in <strong class="source-inline">PermissionEvaluator</strong> implementation, <strong class="source-inline">AclPermissionEvaluator</strong>, to restrict access to our application. While powerful, this can often be more complicated than necessary. We have also discovered how <strong class="source-inline">SpEL</strong> can formulate complex <a id="_idIndexMarker947"/>expressions that are able to secure our application. While simple, one of the downsides of using complex expressions is that the logic is not centralized. Fortunately, we can easily create a custom <strong class="source-inline">PermissionEvaluator</strong> th<a id="_idTextAnchor441"/>at is able to<a id="_idIndexMarker948"/> centralize our authorization logic and still avoid the complexity of <span class="No-Break">using ACLs.</span></p>
<h3>The CalendarPermissionEvaluator Class</h3>
<p>A simplified <a id="_idIndexMarker949"/>version of our custom <strong class="source-inline">PermissionEvaluator</strong> that does<a id="_idIndexMarker950"/> not contain any validation can be seen <span class="No-Break">as follows:</span></p>
<pre class="source-code">
//src/main/java/com/packtpub/springsecurity/access/CalendarPermissionEvalua tor.java
public final class CalendarPermissionEvaluator implements PermissionEvaluator {
    private final EventDao eventDao;
    public CalendarPermissionEvaluator(EventDao eventDao) {
        this.eventDao = eventDao;
    }
    @Override
    public boolean hasPermission(Authentication authentication, Object targetDomainObject, Object permission) {
        if(targetDomainObject instanceof Event) {
            return hasPermission(authentication, (Event) targetDomainObject, permission);
        }
        return targetDomainObject == null;
    }
    @Override
    public boolean hasPermission(Authentication authentication, Serializable targetId, String targetType,
                                 Object permission) {
        if(!Event.class.getName().equals(targetType)) {
            throw new IllegalArgumentException("targetType is not supported. Got "+targetType);
        }
        if(!(targetId instanceof Integer)) {
            throw new IllegalArgumentException("targetId type is not supported. Got "+targetType);
        }
        Event event = eventDao.getEvent((Integer)targetId);
        return hasPermission(authentication, event, permission);
    }
    private boolean hasPermission(Authentication authentication, Event event, Object permission) {
        if(event == null) {
            return true;
        }
        String currentUserEmail = authentication.getName();
        String ownerEmail = extractEmail(event.getOwner());
        if("write".equals(permission)) {
            return currentUserEmail.equals(ownerEmail);
        } else if("read".equals(permission)) {
            String attendeeEmail = extractEmail(event.getAttendee());
            return currentUserEmail.equals(attendeeEmail) || currentUserEmail.equals(ownerEmail);
        }
        throw new IllegalArgumentException("permission "+permission+" is not supported.");
    }
    private String extractEmail(CalendarUser user) {
        if(user == null) {
            return null;
        }
        return user.getEmail();
    }
}</pre> <p>The logic is<a id="_idIndexMarker951"/> fairly similar to the Spring expressions that we have already used, except that it differentiates read and write access. If the current user’s username matches the owner’s email <a id="_idIndexMarker952"/>of the <strong class="source-inline">Event</strong> object, then both read and write access is granted. If the current user’s email matches the attendee’s email, then read access is granted. Otherwise, access <span class="No-Break">is denied.</span></p>
<p class="callout-heading">Important note</p>
<p class="callout">It should be noted that a single <strong class="source-inline">PermissionEvaluator</strong> is used for every domain object. So, in a real-world situation, we must perform <strong class="source-inline">instanceof</strong> checks first. For example, if we were also securing our <strong class="source-inline">CalendarUser</strong> objects, these could be passed into this same instance. For a full example of these minor changes, refer to the sample code included in <span class="No-Break">the book.</span></p>
<h3>Configuring CalendarPermissionEvaluator</h3>
<p>We can then leverage the <strong class="source-inline">CustomAuthorizationConfig.java</strong> configuration that is provided <a id="_idIndexMarker953"/>with this chapter to provide an <strong class="source-inline">ExpressionHandler</strong> that uses <a id="_idIndexMarker954"/>our <strong class="source-inline">CalendarPermissionEvaluator</strong>, <span class="No-Break">like so:</span></p>
<pre class="source-code">
//src/main/java/com/packtpub/springsecurity/configuration/ CustomAuthorizationConfig.java
@Bean
public DefaultMethodSecurityExpressionHandler defaultExpressionHandler(EventDao eventDao){
    DefaultMethodSecurityExpressionHandler deh = new DefaultMethodSecurityExpressionHandler();
    deh.setPermissionEvaluator(
            new CalendarPermissionEvaluator(eventDao));
    return deh;
}</pre> <p>The configuration should look similar to the configuration from <a href="B21757_12.xhtml#_idTextAnchor375"><span class="No-Break"><em class="italic">Chapter 12</em></span></a>, <em class="italic">Access Control Lists</em>, except that we now use our <strong class="source-inline">CalendarPermissionEvalulator</strong> class instead <span class="No-Break">of </span><span class="No-Break"><strong class="source-inline">AclPermissionEvaluator</strong></span><span class="No-Break">.</span></p>
<h3>Securing our CalendarService</h3>
<p>Lastly, we can <a id="_idIndexMarker955"/>secure our <strong class="source-inline">CalendarService getEvent(int eventId)</strong> method with a <strong class="source-inline">@PostAuthorize</strong> annotation. You will notice that this step is exactly the <a id="_idIndexMarker956"/>same as what we did in <a href="B21757_01.xhtml#_idTextAnchor015"><span class="No-Break"><em class="italic">Chapter 1</em></span></a>, <em class="italic">Anatomy of an Unsafe Application</em>, and we have only changed the implementation <span class="No-Break">of </span><span class="No-Break"><strong class="source-inline">PermissionEvaluator</strong></span><span class="No-Break">:</span></p>
<pre class="source-code">
//src/main/java/com/packtpub/springsecurity/service/CalendarService.java
@PostAuthorize("hasPermission(returnObject,'read')")
Event getEvent(int eventId);</pre> <p>If you have not done so already, restart the application, log in with the username/password <strong class="source-inline">admin1@example.com/admin1</strong>, and visit the <strong class="bold">Conference Call Event</strong> (<strong class="source-inline">events/101</strong>) using the link on the <strong class="bold">Welcome</strong> page. The <strong class="bold">Access Denied</strong> page will <span class="No-Break">be displayed.</span></p>
<p class="callout-heading">Important note</p>
<p class="callout">Your code should now look like <span class="No-Break">this: </span><span class="No-Break"><strong class="source-inline">calendar13.03-calendar</strong></span><span class="No-Break">.</span></p>
<p>However, we would like <strong class="source-inline">ROLE_ADMIN</strong> users to be able to access <span class="No-Break">all events.</span></p>
<h3>Benefits of a custom PermissionEvaluator</h3>
<p>With only a<a id="_idIndexMarker957"/> single method being protected, it would be trivial to update the annotation to check whether the user has the role of <strong class="source-inline">ROLE_ADMIN</strong> or has permission. However, if we had <a id="_idIndexMarker958"/>protected all of our service methods that use an event, it would have become quite cumbersome. Instead, we could just update our <strong class="source-inline">CalendarPermissionEvaluator</strong>. Make the <span class="No-Break">following changes:</span></p>
<pre class="source-code">
  private boolean hasPermission(Authentication authentication, Event event, Object permission) {
      if(event == null) {
          return true;
      }
// Custom Role verification
GrantedAuthority adminRole = new SimpleGrantedAuthority("ROLE_ADMIN");
if(authentication.getAuthorities().contains(adminRole)) {
    return true;
... omitted for brevity
}
  }</pre> <p>Now, restart the application and repeat the previous exercise. This time, the<strong class="bold"> Conference Call Event</strong> will <span class="No-Break">display successfully.</span></p>
<p>You <a id="_idIndexMarker959"/>can see that the ability to encapsulate our authorization<a id="_idIndexMarker960"/> logic can be extremely beneficial. However, sometimes, it may be useful to extend the <span class="No-Break">expressions themselves.</span></p>
<p class="callout-heading">Important note</p>
<p class="callout">Your code should now look like <span class="No-Break">this: </span><span class="No-Break"><strong class="source-inline">calendar13.04-calendar</strong></span><span class="No-Break">.</span></p>
<h3>Removing the CustomWebSecurityExpressionHandler class</h3>
<p>There is a <a id="_idIndexMarker961"/>much simpler<a id="_idIndexMarker962"/> way of defining custom <span class="No-Break"><strong class="bold">Web Expressions</strong></span><span class="No-Break">.</span></p>
<p>In our previous example, you can remove the following <span class="No-Break">classes: </span><span class="No-Break"><strong class="source-inline">CustomWebSecurity</strong></span><strong class="source-inline">
ExpressionHandler</strong> <span class="No-Break">and </span><span class="No-Break"><strong class="source-inline">CustomWebSecurityExpressionRoot</strong></span><span class="No-Break">.</span></p>
<p>Declare a Spring bean containing the custom <span class="No-Break"><strong class="source-inline">Web Expression</strong></span><span class="No-Break">:</span></p>
<pre class="source-code">
//src/main/java/com/packtpub/springsecurity/access/expression/ CustomWebExpression.java
@Component
public class CustomWebExpression {
    public boolean isLocalHost(final HttpServletRequest request) {
       return "localhost".equals(request.getServerName());
    }
}</pre> <p>In the <strong class="source-inline">CustomAuthorizationConfig</strong> class, add the <span class="No-Break">following bean:</span></p>
<pre class="source-code">
//src/main/java/com/packtpub/springsecurity/configuration/ CustomAuthorizationConfig.java
@Bean
public DefaultWebSecurityExpressionHandler customWebSecurityExpressionHandler (){
    return new DefaultWebSecurityExpressionHandler();
}</pre> <p>We can then remove the following declaration to the <strong class="source-inline">CustomWebSecurityExpressionHandler</strong> inside the <span class="No-Break"><strong class="source-inline">SecurityConfig</strong></span><span class="No-Break"> class:</span></p>
<pre class="source-code">
//src/main/java/com/packtpub/springsecurity/configuration/ SecurityConfig.java
// Line of Expression Handler needs to be removed
http.authorizeRequests()
.expressionHandler(customWebSecurityExpressionHandler);</pre> <p>Now, let’s <a id="_idIndexMarker963"/>update our initialization SQL query to adapt the syntax of the new expression. Update the <strong class="source-inline">data.sql</strong> <span class="No-Break">as follows:</span></p>
<pre class="source-code">
//src/main/resources/data.sql
insert into security_filter_metadata(id,ant_pattern,expression,sort_order) values (160, '/admin/**','@customWebExpression.isLocalHost(request) and hasRole("ADMIN")',60);</pre> <p>Restart the application and test the application access with the user <strong class="source-inline">admin1@example.com/admin1</strong> for <span class="No-Break">both URLs:</span></p>
<ul>
<li><strong class="source-inline">http://127.0.0.1:8080/admin/h2</strong>: <span class="P---Regular-Char">Access should </span><span class="No-Break"><span class="P---Regular-Char">be </span></span><span class="No-Break"><strong class="source-inline">denied</strong></span></li>
<li><strong class="source-inline">http://localhost:8080/admin/h2</strong>: <span class="P---Regular-Char">Access should </span><span class="No-Break"><span class="P---Regular-Char">be </span></span><span class="No-Break"><strong class="source-inline">allowed</strong></span></li>
</ul>
<p class="callout-heading">Important note</p>
<p class="callout">Your code should now look like <span class="No-Break">this: </span><span class="No-Break"><strong class="source-inline">calendar13.05-calendar</strong></span><span class="No-Break">.</span></p>
<h2 id="_idParaDest-291"><a id="_idTextAnchor442"/>Declaring a custom AuthorizationManager</h2>
<p><strong class="source-inline">Spring Security 6</strong> has deprecated the usage of the <strong class="source-inline">AccessDecissionManager</strong> <span class="No-Break">and </span><span class="No-Break"><strong class="source-inline">AccessDecisionVoter</strong></span><span class="No-Break">.</span></p>
<p>The recommended approach is to implement a custom <strong class="source-inline">AuthorizationManager</strong>, as explained <a id="_idIndexMarker964"/>in the introduction of this chapter. To achieve this goal, you can follow the <span class="No-Break">next steps.</span></p>
<p>First, we will create a custom implementation <span class="P---Regular-Char">of</span> the <strong class="source-inline">AuthorizationManager</strong> that checks for the allowed permissions<a id="_idIndexMarker965"/> based on the <strong class="source-inline">security_filter_metadata</strong><span class="P---Regular-Char"> </span><span class="No-Break">table definition:</span></p>
<pre class="source-code">
//src/main/java/com/packtpub/springsecurity/access/ CustomAuthorizationManager.java
@Component
public class CustomAuthorizationManager implements AuthorizationManager&lt;RequestAuthorizationContext&gt; {
    private final SecurityExpressionHandler&lt;RequestAuthorizationContext&gt; expressionHandler;
    private final RequestConfigMappingService requestConfigMappingService;
    private static final Logger logger = LoggerFactory.getLogger(CustomAuthorizationManager.class);
    public CustomAuthorizationManager(DefaultHttpSecurityExpressionHandler expressionHandler, RequestConfigMappingService requestConfigMappingService) {
       this.expressionHandler = expressionHandler;
       this.requestConfigMappingService = requestConfigMappingService;
    }
    @Override
    public AuthorizationDecision check(Supplier&lt;Authentication&gt; authentication, RequestAuthorizationContext context) {
       List&lt;RequestConfigMapping&gt; requestConfigMappings = requestConfigMappingService.getRequestConfigMappings();
       LinkedHashMap&lt;RequestMatcher, Collection&lt;ConfigAttribute&gt;&gt; requestMap = new LinkedHashMap&lt;&gt;(requestConfigMappings.size());
       for (RequestConfigMapping requestConfigMapping : requestConfigMappings) {
          RequestMatcher matcher = requestConfigMapping.getMatcher();
          if (matcher.matches(context.getRequest())) {
             requestMap.put(matcher, requestConfigMapping.getAttributes());
             String expressionStr = requestConfigMapping.getAttributes().iterator().next().getAttribute();
             Expression expression = this.expressionHandler.getExpressionParser().parseExpression(expressionStr);
             try {
                EvaluationContext evaluationContext = this.expressionHandler.createEvaluationContext(authentication, context);
                boolean granted = ExpressionUtils.evaluateAsBoolean(expression, evaluationContext);
                return new ExpressionAuthorizationDecision(granted, expression);
             } catch (AccessDeniedException ex) {
                logger.error("Access denied exception: {}", ex.getMessage());
                return new AuthorizationDecision(false);
             }
          }
       }
       return new AuthorizationDecision(false);
    }
}</pre> <p>Then, we will <a id="_idIndexMarker966"/>inject the <strong class="source-inline">AuthorizationManager</strong><span class="P---Regular-Char"> into the </span><strong class="source-inline">SecurityFilterChain</strong> bean, <span class="No-Break">as follows:</span></p>
<pre class="source-code">
//src/main/java/com/packtpub/springsecurity/configuration/ SecurityConfig.java
@Bean
public SecurityFilterChain filterChain(HttpSecurity http, AuthorizationManager&lt;RequestAuthorizationContext&gt; authorizationManager) throws Exception {
    http
          .authorizeHttpRequests(authorize -&gt; authorize
                .anyRequest()
                .access(authorizationManager));
...omitted for brevity
    return http.build();
}</pre> <p>We will <a id="_idIndexMarker967"/>update the <strong class="source-inline">CustomAuthorizationConfig</strong> configuration by replacing the bean of type <strong class="source-inline">DefaultWebSecurityExpressionHandler</strong> with another one of type <strong class="source-inline">DefaultHttpSecurityExpressionHandler</strong>, as we have chosen to use <strong class="source-inline">http.authorizeHttpRequest()</strong> instead <span class="No-Break">of </span><span class="No-Break"><strong class="source-inline">http.authorizeRequests()</strong></span><span class="No-Break">:</span></p>
<pre class="source-code">
//src/main/java/com/packtpub/springsecurity/configuration/ CustomAuthorizationConfig.java
@Bean
public DefaultHttpSecurityExpressionHandler defaultHttpSecurityExpressionHandler(){
    return new DefaultHttpSecurityExpressionHandler();
}</pre> <p>You can <a id="_idIndexMarker968"/>remove the <strong class="source-inline">FilterInvocationServiceSecurityMetadataSource</strong> and restart your application. You should have the same results as the <span class="No-Break">previous example.</span></p>
<p class="callout-heading">Important note</p>
<p class="callout">Your code should now look like <span class="No-Break">this: </span><span class="No-Break"><strong class="source-inline">calendar13.06-calendar</strong></span><span class="No-Break">.</span></p>
<h1 id="_idParaDest-292"><a id="_idTextAnchor443"/>Summary</h1>
<p>After reading this chapter, you should have a firm understanding of how <strong class="source-inline">Spring Security</strong> authorization works for HTTP requests and methods. With this knowledge, and the provided concrete examples, you should also know how to extend authorization to meet your needs. Specifically, in this chapter, we covered the <strong class="source-inline">Spring Security</strong> authorization architecture for both HTTP requests and methods. We also demonstrated how to configure secured URLs from <span class="No-Break">a database.</span></p>
<p>We also saw how to create a custom <strong class="source-inline">AuthorizationManager</strong>, <strong class="source-inline">PermissionEvaluator</strong> object, and custom <strong class="source-inline">Spring </strong><span class="No-Break"><strong class="source-inline">Security</strong></span><span class="No-Break"> expression.</span></p>
<p>In the next chapter, we will explore how <strong class="source-inline">Spring Security</strong> performs session management. We will also gain an understanding of how it can be used to restrict access to <span class="No-Break">our application.</span></p>
</div>
</div>

<div id="sbo-rt-content"><div class="Content" id="_idContainer106">
<h1 id="_idParaDest-293" lang="en-US" xml:lang="en-US"><a id="_idTextAnchor444"/>Part 5: Advanced Security Features and Deployment Optimization</h1>
<p>This part commences with an explanation of session fixation attacks and Spring Security’s defense mechanisms against them. It proceeds to explore methods for managing logged-in users and limiting the number of concurrent sessions per user. The association of a user to <strong class="source-inline">HttpSession</strong> by Spring Security and techniques for customizing this behavior are <span class="No-Break">also detailed.</span></p>
<p>Then, we delve into common security vulnerabilities such as <strong class="bold">Cross-Site Scripting</strong> (<strong class="bold">XSS</strong>), <strong class="bold">Cross-Site Request Forgery</strong> (<strong class="bold">CSRF</strong>), synchronizer tokens, and clickjacking, along with strategies to mitigate these <span class="No-Break">risks effectively.</span></p>
<p>Following this, we present a migration path to Spring Security 6, highlighting notable configuration changes, class and package migrations, and significant new features, including support for Java 17 and enhanced authentication mechanisms with <span class="No-Break">OAuth 2.</span></p>
<p>Subsequently, we explore microservices-based architectures and examine the role of OAuth 2 with <strong class="bold">JSON Web Tokens</strong> (<strong class="bold">JWTs</strong>) in securing microservices within a Spring-based application. Additionally, we discuss the implementation of <strong class="bold">Single Sign-On</strong> (<strong class="bold">SSO</strong>) using the <strong class="bold">Central Authentication </strong><span class="No-Break"><strong class="bold">Service</strong></span><span class="No-Break"> (</span><span class="No-Break"><strong class="bold">CAS</strong></span><span class="No-Break">).</span></p>
<p>Concluding this part, we delve into the process of building native images using GraalVM, offering insights into enhancing performance and security within Spring <span class="No-Break">Security applications.</span></p>
<p>This part has the <span class="No-Break">following chapters:</span></p>
<ul>
<li><a href="B21757_14.xhtml#_idTextAnchor445"><em class="italic">Chapter 14</em></a>, <em class="italic">Session Management</em></li>
<li><a href="B21757_15.xhtml#_idTextAnchor479"><em class="italic">Chapter 15</em></a>, <em class="italic">Additional Spring Security Features</em></li>
<li><a href="B21757_16.xhtml#_idTextAnchor512"><em class="italic">Chapter 16</em></a>, <em class="italic">Migration to Spring Security 6</em></li>
<li><a href="B21757_17.xhtml#_idTextAnchor537"><em class="italic">Chapter 17</em></a>, <em class="italic">Microservice Security with OAuth 2 and JSON Web Tokens</em></li>
<li><a href="B21757_18.xhtml#_idTextAnchor591"><em class="italic">Chapter 18</em></a>, <em class="italic">Single Sign-On with the Central Authentication Service</em></li>
<li><a href="B21757_19.xhtml#_idTextAnchor625"><em class="italic">Chapter 19</em></a>, <em class="italic">Build GraalVM Native Images</em></li>
</ul>
</div>
<div>
<div id="_idContainer107">
</div>
</div>
<div>
<div class="Basic-Graphics-Frame" id="_idContainer108">
</div>
</div>
</div></body></html>