- en: Chapter 3. Functions
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 3 章。函数
- en: In the previous chapter, we covered the object-oriented aspects of Scala, such
    as classes, objects, pattern matching, self-types, case classes, and so on. We
    also implemented object-oriented concepts that we learned in our chatbot application.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们介绍了 Scala 的面向对象方面，例如类、对象、模式匹配、自类型、案例类等。我们还在我们的聊天机器人应用程序中实现了我们学到的面向对象概念。
- en: In this chapter, we will cover functional programming with Scala and how object-oriented
    and functional approaches complete each other. We will also cover generic classes,
    which are often used with pattern matching. We will also cover how to create user-defined
    pattern matching and why is it useful.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍使用 Scala 进行函数式编程以及面向对象和函数式方法如何相互补充。我们还将介绍泛型类，它们通常与模式匹配一起使用。我们还将介绍如何创建用户定义的模式匹配以及为什么它是有用的。
- en: 'By the end of this chapter, you will be able to:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将能够：
- en: Identify the basics of functional programming
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 识别函数式编程的基本知识
- en: Identify the basics of generic types in Scala
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 识别 Scala 中泛型类型的基本知识
- en: Implement user-defined pattern matching
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现用户定义的模式匹配
- en: Recognize and use functional compositional patterns
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 识别和使用函数式组合模式
- en: Functions
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数
- en: In this section, we will introduce the fundamentals of functional programming,
    such as function values and high-order functions.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将介绍函数式编程的基础，例如函数值和高阶函数。
- en: Function Values
  id: totrans-10
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 函数值
- en: 'What is a function? We are familiar with methods, which must be defined in
    a scope (class or objects):'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 函数是什么？我们熟悉的方法必须在作用域（类或对象）中定义：
- en: '[PRE0]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'In Scala, we can also define a function value:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Scala 中，我们还可以定义一个函数值：
- en: '[PRE1]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Here, we define the function value, with a type of `(Int,Int) => Int`. Of course,
    as with all type declarations, the type can be omitted if it can be deduced from
    the context. So, an alternative syntax for this can be:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们定义了一个函数值，其类型为 `(Int,Int) => Int`。当然，与所有类型声明一样，如果可以从上下文中推断出类型，则可以省略类型。因此，此的另一种语法可以是：
- en: '[PRE2]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Both `f1(1,2)` and `f2(1,2)` will force evaluation. The difference between `f1`
    and `f2` is that the second is a value, which can be stored in a variable or passed
    to another function.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '`f1(1,2)` 和 `f2(1,2)` 都将强制评估。`f1` 和 `f2` 之间的区别在于第二个是一个值，它可以存储在变量中或传递给另一个函数。'
- en: 'Functions which accept other functions as parameters are named high-order functions,
    for example:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 接受其他函数作为参数的函数称为高阶函数，例如：
- en: '[PRE3]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'This function returns functions, which apply parameters twice. An example of
    this usage is as follows:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数返回函数，这些函数将参数应用两次。此用法的示例如下：
- en: '[PRE4]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'In general, the syntax for function definitions is as follows:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，函数定义的语法如下：
- en: '[PRE5]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The type signature can be omitted if it is possible to deduce types from the
    context.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 如果可以从上下文中推断出类型，则可以省略类型签名。
- en: Now, let's look at how to define a function variable.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看如何定义一个函数变量。
- en: 'Define the function variable in the REPL of IDE worksheet:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在 IDE 工作表的 REPL 中定义函数变量：
- en: '[PRE6]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Function from an OO Point of View
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从面向对象的角度定义函数
- en: 'When looking at Scala sources, we will see the following definition:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 当查看 Scala 源代码时，我们将看到以下定义：
- en: '[PRE7]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Here, `Function1` is a base trait for a function with one argument. `Function1`
    has one abstract method: `apply`. Scala provides syntax sugar for the call of
    the `apply` method with syntax.'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`Function1` 是一个具有一个参数的函数的基础特质。`Function1` 有一个抽象方法：`apply`。Scala 为 `apply`
    方法的调用提供了语法糖。
- en: '`T1` and `R` are type parameters of `Function1`. `T1` is a type of the first
    argument, while `R` is a result type.'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '`T1` 和 `R` 是 `Function1` 的类型参数。`T1` 是第一个参数的类型，而 `R` 是结果类型。'
- en: 'Symbols before type parameters [ `-T1, +R` ] mean `contravariance` and `covariance`
    of parameters; we will speak about one in detail later. For now, let''s write
    a definition:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 类型参数前的符号 [ `-T1, +R` ] 表示参数的 `逆变` 和 `协变`；我们将在稍后详细讨论一个。现在，让我们编写一个定义：
- en: '[PRE8]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The value of a function with one argument, `f: A => B`, is just an instance
    of a trait, `Function1[A,B]`. For functions with two arguments, we have `Function2[T1,T2,R]`
    and so on. We can rewrite an example with `twice` using OO facilities in the next
    form:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '一个具有一个参数的函数的值，`f: A => B`，只是一个 `Function1[A,B]` 特质的实例。对于具有两个参数的函数，我们有 `Function2[T1,T2,R]`
    等等。我们可以使用面向对象的设施以以下形式重写使用 `twice` 的示例：'
- en: '[PRE9]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Here, we define the `Twice` object with the same behavior of the previously
    described function:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们定义了一个具有之前描述的函数相同行为的 `Twice` 对象：
- en: '[PRE10]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'To summarize, we can say:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，我们可以这样说：
- en: The function value is an instance of an appropriative function trait.
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数值是适当函数特质的实例。
- en: The call of a function value is a call of the `apply()` method in a function
    trait.
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数值的调用是函数特质中 `apply()` 方法的调用。
- en: Now, it's time to create a few functions.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，是时候创建一些函数了。
- en: Open a blank worksheet in your project.
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的项目中打开一个空白工作表。
- en: 'Define the function which accepts the binary function and arguments, and return
    an application of such a function:'
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个接受二元函数和参数的函数，并返回该函数的应用：
- en: '[PRE11]'
  id: totrans-45
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Make the syntax better by reformulating the function using currying:'
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过使用柯里化重新表述函数来改善语法：
- en: '[PRE12]'
  id: totrans-47
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Partial application: Write the `fix` function, which accepts binary function
    and an argument and returns an unary function, which will apply the placed function
    and argument. For example, with definition `g` as : `val g = fix1((x,y)=>x+y,3)`.'
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 部分应用：编写 `fix` 函数，该函数接受二元函数和参数，并返回一个一元函数，该函数将应用放置的函数和参数。例如，定义 `g` 为：`val g =
    fix1((x,y)=>x+y,3)`。
- en: '`g(2)` should be evaluated to `5`.'
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`g(2)` 应该被评估为 `5`。'
- en: '[PRE13]'
  id: totrans-50
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Conversions
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 转换
- en: We have methods and functional values, which can do the same thing. It is logical
    to expect a conversion between them, for example, the ability to assign a method
    to a functional variable or pass a function as an OO interface.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有方法和函数值，它们可以完成相同的事情。期望它们之间有转换是合乎逻辑的，例如，将方法分配给函数变量或将函数作为面向对象接口传递的能力。
- en: Scala provides a special syntax for converting a method to a value. We just
    need to add the underscore (_) after the name of the method.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: Scala 提供了一种特殊的语法，用于将方法转换为值。我们只需在方法名称后添加下划线（_）即可。
- en: 'For example:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 例如：
- en: '[PRE14]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Also, a functional value can be implicitly converted to a so-called SAM (Single
    Abstract Method) trait. A SAM trait has only one abstract method, and we can pass
    a function in its context, where the SAM trait is required (and the function type
    conforms to the method signature).:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，一个函数值可以隐式转换为所谓的 SAM（单抽象方法）特质。SAM 特质只有一个抽象方法，我们可以在需要 SAM 特质（并且函数类型符合方法签名）的上下文中传递一个函数：
- en: '[PRE15]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Here, we pass the function with zero parameters to the `Thread` constructor,
    which accepts the `Runnable` interface.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将零参数的函数传递给 `Thread` 构造函数，该构造函数接受 `Runnable` 接口。
- en: In Scala, we have three different ways of implementing deferred call functionality.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Scala 中，我们有三种不同的方式来实现延迟调用功能。
- en: Defining and Measuring the Time of a Unit Function
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义和测量单元函数的时间
- en: Define a function which accepts a function which runs a unit function and measures
    the time in nanoseconds. How long does this take? Implement this in three different
    ways.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 定义一个函数，该函数接受一个运行单元函数并测量纳秒时间的函数。这需要多长时间？以三种不同的方式实现它。
- en: 'Write a function which accepts other functions. Run one and measure the execution
    time:'
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个接受其他函数的函数。运行一个并测量执行时间：
- en: '[PRE16]'
  id: totrans-63
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Write a function which accepts the by-name parameter. Run one and measure the
    execution time:'
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个接受按名参数的函数。运行一个并测量执行时间：
- en: '[PRE17]'
  id: totrans-65
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Write an object which extends the `Function1` trait and do the same in the
    `apply` method:'
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个扩展 `Function1` 特质的对象，并在 `apply` 方法中做同样的事情：
- en: '[PRE18]'
  id: totrans-67
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Syntax Sugar in a Function Definition
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 函数定义中的语法糖
- en: 'Sometimes, writing expressions such as `x => x+1` look too verbose. To solve
    this, syntax sugar exists, which allows you to write small functional expressions
    in a compact and idiomatic way. Don''t write the left part at all, and, while
    writing, use _ (underscore) instead of an argument. The first underscore means
    the first argument, the second underscore means the second argument, and so on:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，编写如 `x => x+1` 这样的表达式看起来过于冗长。为了解决这个问题，存在语法糖，它允许你以紧凑和惯用的方式编写小的函数表达式。根本不需要写左边的部分，在编写时，使用
    _（下划线）代替参数。第一个下划线表示第一个参数，第二个下划线表示第二个参数，依此类推：
- en: '[PRE19]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Some functions such as `(x,y) => x*x + y` can't be represented in such a notation.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 一些函数，如 `(x,y) => x*x + y`，不能用这种表示法表示。
- en: Partial Functions
  id: totrans-72
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 部分函数
- en: Partial functions are better known as partially defined functions—some values
    exist in the domain of the function input, where this function is undefined.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 部分函数也被称为部分定义函数——一些值存在于函数输入域中，其中该函数未定义。
- en: 'Let''s look at a simplified definition:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个简化的定义：
- en: '[PRE20]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Along with the apply method we have a `isDefinedAt` method, which returns `true`
    if our function is applicable for an argument, and a special syntax:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 除了 apply 方法外，还有一个 `isDefinedAt` 方法，它返回 `true` 如果我们的函数适用于一个参数，并且有一个特殊的语法：
- en: '[PRE21]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'We can combine a few partial functions into a new set of standard combinators—
    `orElse`:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将几个部分函数组合成一组新的标准组合子—`orElse`：
- en: '[PRE22]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Note that type annotation is needed to give a correct context for type deduction.
    Otherwise, the compiler will not be able to deduce the type of inline function
    argument.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，类型注解是必需的，以给出正确的上下文以进行类型推导。否则，编译器将无法推导内联函数参数的类型。
- en: 'One useful combinator— `andThen`, which allows building pipelines, is also
    necessary:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 一个有用的组合子—`andThen`，它允许构建管道，也是必要的：
- en: '[PRE23]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Now, define a function which accepts a function and provides a transformed
    function. For example, let the input function be `f`: `Int => Int`, and let''s
    build `g(f)`: `g(f)(x) = f(x) + x.` If `f` is not defined at `x`, `g(f)` must
    not be defined either.'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，定义一个接受函数并提供转换函数的函数。例如，让输入函数为`f`：`Int => Int`，然后构建`g(f)`：`g(f)(x) = f(x) +
    x`。如果`f`在`x`处未定义，`g(f)`也不能定义。
- en: 'Copy the following class:'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 复制以下类：
- en: '[PRE24]'
  id: totrans-85
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Or as a case-expression with an `if` clause:'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 或者作为一个带有`if`子句的case表达式：
- en: '[PRE25]'
  id: totrans-87
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: We'll now implement a partial function for constructing an association between
    names and values.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将实现一个部分函数，用于在名称和值之间构建关联。
- en: 'Write a function for a pair as a class with parameters (name,value), which
    is defined only if the argument is equal to name:'
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个函数，作为具有参数（name,value）的类，仅在参数等于name时定义：
- en: '[PRE26]'
  id: totrans-90
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Use the `orElse` combinator to combine such pairs into a bigger function:'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`orElse`组合子将这样的对组合成更大的函数：
- en: '[PRE27]'
  id: totrans-92
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Exploring Pattern Matching
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索模式匹配
- en: Now we will return to pattern matching and learn about extending capabilities
    behind case classes. As you will remember from the previous chapter, we can use
    pattern matching against case classes, where fields of a class can be bound to
    the variables in the scope of an appropriative case clause. Can we do this for
    our non-case classes and embed our own custom logic for matching?
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将回到模式匹配，并了解扩展case类背后的功能。正如你将从上一章中记住的那样，我们可以对case类使用模式匹配，其中类的字段可以绑定到适当case子句作用域内的变量。我们能否为我们的非case类做这件事，并嵌入我们自己的自定义匹配逻辑？
- en: In this section, we will learn how to write our own pattern matcher and get
    acquainted with some standard generic classes which are often used with pattern
    matching.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将学习如何编写我们自己的模式匹配器，并熟悉一些常用于模式匹配的标准通用类。
- en: Now, let's get started with the minimal example.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们从一个最小示例开始。
- en: 'First, we write the following code in the IDE:'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们在IDE中编写以下代码：
- en: '[PRE28]'
  id: totrans-98
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Under the hood, the compiler compiled this to the next intermediate form:'
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在底层，编译器将其编译为下一个中间形式：
- en: '[PRE29]'
  id: totrans-100
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The `unapply` method of the companion object is called, which must return the
    class with the methods get and `isDefined`.
  id: totrans-101
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 伴随对象的`unapply`方法被调用，它必须返回具有get和`isDefined`方法的类。
- en: 'When we have more than one binding variable, the resulting container should
    contain a tuple. For example, for the point intermediate form, this will be the
    resulting code:'
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当我们有一个以上的绑定变量时，结果容器应包含一个元组。例如，对于点中间形式，这将产生以下代码：
- en: '[PRE30]'
  id: totrans-103
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The standard Scala library provides the `Option` type, although it is possible
    to define your own type with such methods (which can be useful in some heavy optimization
    scenarios).
  id: totrans-104
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标准Scala库提供了`Option`类型，尽管你可以使用这样的方法（这在某些重优化场景中可能很有用）来定义自己的类型。
- en: 'Define the class:'
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义类：
- en: '[PRE31]'
  id: totrans-106
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Here, we see the algebraic type (such as the hierarchy of case classes/objects)
    with the generic type parameter: A. You may have heard of the abbreviation GADT
    (Generic Algebraic Data Type) when referring to such constructs.'
  id: totrans-107
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在这里，我们看到带有通用类型参数A的代数类型（例如case类/对象的层次结构）。你可能听说过在提到这种结构时使用的缩写GADT（通用代数数据类型）。
- en: Informal value of `Option[A]` – the container from one or zero elements, or
    elements which can or cannot exist. Some(a) – when an element exists, None – for
    its absence.
  id: totrans-108
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Option[A]`的非正式值——一个包含一个或零个元素或可能存在或可能不存在的元素的容器。Some(a)——当元素存在时，None——对于其不存在。'
- en: '`None` extends `Option[Nothing]`. Nothing is a `minimal` type in the Scala
    typesystem, which is a subtype of any type.'
  id: totrans-109
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`None`扩展了`Option[Nothing]`。`Nothing`是Scala类型系统中的一个`最小`类型，它是任何类型的子类型。'
- en: 'So, to define the custom pattern matcher, we need to create an object with
    the `unapply` method and put logic inside of it which returns a binding variable
    (or a tuple with binding variables) in an option container:'
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 因此，为了定义自定义模式匹配器，我们需要创建一个具有`unapply`方法的对象，并在其中放置逻辑，该逻辑在选项容器中返回一个绑定变量（或绑定变量的元组）：
- en: '[PRE32]'
  id: totrans-111
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Let''s define the pattern matcher `Diagonal`, which will match only points
    situated in the diagonal:'
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们定义一个模式匹配器`Diagonal`，它将只匹配位于对角线上的点：
- en: '[PRE33]'
  id: totrans-113
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: We'll now implement the `unapply` custom.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将实现`unapply`自定义。
- en: Define object `Axis` (Numbered Bullet)
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义对象`Axis`（编号项目符号）
- en: Define method `unapply` (Numbered Bullet END)
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义方法`unapply`（编号项目符号结束）
- en: Determinate, if object is on X axis(Apply BULLET INSIDE BULLET to all three
    points)
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确定对象是否在X轴上（将BULLET INSIDE BULLET应用于所有三个点）
- en: Determinate, if object is on Y axis
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确定对象是否在Y轴上
- en: Otherwise, return `None`.
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 否则，返回`None`。
- en: Binding a Sequence of Variables in the Pattern Matcher
  id: totrans-120
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在模式匹配器中绑定变量序列
- en: 'Sometimes, we need a particular type of pattern matcher where the number of
    binding variables can vary. For example, regular expressions in standard Scala
    library are as follows:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，我们需要一种特定的模式匹配器，其中绑定变量的数量可以变化。例如，标准Scala库中的正则表达式如下：
- en: '[PRE34]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Here, we can see that that `r1` is matched with one variable, but `r2` uses
    two binding variables. Another convention exists for this case: a companion object
    should provide the `unapplySeq` method instead of `unapply`, which returns a sequence
    wrapped in an option.'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我们可以看到`r1`与一个变量匹配，但`r2`使用了两个绑定变量。对于这种情况，存在另一个约定：伴生对象应该提供`unapplySeq`方法而不是`unapply`，它返回一个包裹在选项中的序列。
- en: We will learn more about sequences during the next chapter, but for now we can
    say that `Seq[A]` – is a generic trait for sequences. The `apply` operator in
    sequences works as index access (for example, `seq(n)` returns the nth element
    of the sequence, and it is possible to create default sequence using the `Seq`
    companion class, `Seq(1,2,3)`.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在下一章中学习更多关于序列的知识，但到目前为止，我们可以这样说，`Seq[A]`是一个用于序列的泛型特质。序列中的`apply`操作符作为索引访问工作（例如，`seq(n)`返回序列的第n个元素，并且可以使用`Seq`伴生类创建默认序列，例如`Seq(1,2,3)`）。
- en: Let's now implement the custom `unapplySeq` method. This is defined on strings
    and returns a sequence of words.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来实现自定义的`unapplySeq`方法。这个方法定义在字符串上，并返回一个单词序列。
- en: Define the `Words` object.
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义`Words`对象。
- en: 'Define the `unapplySeq` method. Transform the array to `seq`, using the .`toSeq`
    method in Scala Array:'
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义`unapplySeq`方法。将数组转换为`seq`，使用Scala Array中的`.toSeq`方法：
- en: '[PRE35]'
  id: totrans-128
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Write a test which compares words for the following strings:'
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个测试，比较以下字符串的单词：
- en: '[PRE36]'
  id: totrans-130
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Sometimes, when binding variables into sequence, we don't need var for each
    value in the sequence, but only the first value and the rest of the sequence.
  id: totrans-131
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有时候，当将变量绑定到序列中时，我们不需要为序列中的每个值使用`var`，而只需要第一个值和序列的其余部分。
- en: 'We can use the pattern with the syntax for a variable function call in a pattern,
    for example:'
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以使用模式匹配中的变量函数调用语法，例如：
- en: '[PRE37]'
  id: totrans-133
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Partial Functions in Practice
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实践中的部分函数
- en: Now that we have learned a lot about functions and pattern matching, let's apply
    our theoretical knowledge to practical programming.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经学到了很多关于函数和模式匹配的知识，让我们将我们的理论知识应用到实际编程中。
- en: Let's get our chatbot, which we developed during the previous chapter, and change
    the modes to partial functions instead of classes.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们获取我们在上一章中开发的聊天机器人，并将模式改为部分函数而不是类。
- en: Note
  id: totrans-137
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Open `/Lesson 3/5-project` in the supplement materials and import the project
    into the IDE.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在补充材料中打开`/Lesson 3/5-project`，并将项目导入IDE。
- en: Representing ChatbotMode as a Partial Function
  id: totrans-139
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将ChatbotMode表示为部分函数
- en: 'Let''s navigate to the `scala` file package in `com.packt.courseware.l4`:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们导航到`com.packt.courseware.l4`中的`scala`文件包：
- en: '[PRE38]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Here, we see the `package` object, which was not mentioned previously in our
    chapters.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我们看到`package`对象，这是我们之前章节中没有提到的。
- en: The `package` object is an object which is associated with a package. When you
    import a package with a wildcard, then you import the current scope content of
    the package object if one exists.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '`package`对象是与包相关联的对象。当你使用通配符导入一个包时，如果存在，则导入包对象的当前作用域内容。'
- en: So, the `package` object is a good way to store some utility definitions and
    functions, which should be available in a package.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，`package`对象是一个存储一些实用定义和函数的好方法，这些函数应该在包中可用。
- en: 'The next sentence is a type alias for `ChatbotMode`: we define one as a partial
    function from ( `String`, `EffectsProvider`) to `Processed`.'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个句子是`ChatbotMode`的类型别名：我们将其定义为一个从（`String`，`EffectsProvider`）到`Processed`的部分函数。
- en: As you will remember, `Processed` is a `LineStepResult` which is a trait, united
    with Processed or Failed. With partial functions, we don't need a `Failed` variant;
    instead, `isDefined` in our mode will be set to `false`.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所记，`Processed`是一个`LineStepResult`特质，与Processed或Failed联合。使用部分函数，我们不需要`Failed`变体；相反，我们模式中的`isDefined`将被设置为`false`。
- en: 'Now let''s look at some simple mode:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来看一些简单的模式：
- en: '[PRE39]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: So, we can write partial functions just as we do `vars`.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们可以像写`vars`一样编写部分函数。
- en: In the previous version, we have `OrMode`, which combines modes in combination.
    Can we do the same with partial functions?
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个版本中，我们有`OrMode`，它组合了模式。我们能否用部分函数做同样的事情？
- en: '[PRE40]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: We use the `andThen` combinator for postprocessing the result of applying `frs`
    and `snd` in order to insert `nextMode` in the or chain and return those functions
    in the `orElse` combinator.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`andThen`组合子来后处理`frs`和`snd`应用的结果，以便在或链中插入`nextMode`，并通过`orElse`组合子返回这些函数。
- en: So, as we can see, modes can be described with the help of partial functions.
    The resultant code is a little shorter, but we only lose the fancy syntax for
    combining modes.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，正如我们所见，我们可以借助部分函数来描述模式。生成的代码稍微短一些，但我们只失去了组合模式的复杂语法。
- en: 'The main mode now looks like this:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 主模式现在看起来是这样的：
- en: '[PRE41]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Let's now implement partial functions. In l4, some modes are removed from the
    source code. Can you move them back, in the form of partial functions?
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来实现部分函数。在l4中，一些模式已从源代码中删除。你能以部分函数的形式将它们移回来吗？
- en: '**Steps for Completion:**'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '**完成步骤：**'
- en: Open `Lesson 3/5-project.`
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`Lesson 3/5-project`。
- en: Implement the `currentTime`, `otherwise,` and `interestingIgnore` modes.
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现当前的`currentTime`、`otherwise`和`interestingIgnore`模式。
- en: Ensure that the tests are running.
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保测试正在运行。
- en: Implementing RemindStore as a Set of Partial Functions
  id: totrans-161
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将提醒存储实现为部分函数的集合
- en: Let's look at the implementation of `RemindStore`. Navigate to `com/packt/courseware/l4/RemindCommand.scala`.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看`RemindStore`的实现。导航到`com/packt/courseware/l4/RemindCommand.scala`。
- en: 'Look at using regular expressions in patterns:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在模式中使用正则表达式：
- en: '[PRE42]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Note that `RemindedState` has a memory leak: what will be the behavior of the
    function when we ask our chatbot to store the same word a few times?'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 注意`RemindedState`有一个内存泄漏：当我们要求我们的聊天机器人存储相同的单词几次时，函数的行为会是什么？
- en: Note
  id: totrans-166
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '**Note**'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: A memory leak is a situation where we allocate an object but keep it accessible
    after usage.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 内存泄漏是一种情况，我们分配了一个对象，但在使用后仍然可以访问它。
- en: Let's now find and fix a memory leak in `StoreRemindCommand`.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来查找并修复`StoreRemindCommand`中的内存泄漏。
- en: Open `Lesson 3/5-project`.
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`Lesson 3/5-project`。
- en: Analyze the case where we stored the same work a few times.
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 分析我们存储相同工作几次的情况。
- en: Consider how it's possible to write a unit test for this (`***`)?
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 考虑如何为这个写单元测试（`***`）？
- en: Fix the memory leak.
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修复内存泄漏。
- en: As we have seen, it is possible to build modes in chatbot as partial functions.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所见，在聊天机器人中构建模式作为部分函数是可能的。
- en: Using Lifting for Conversations between Total and Partial Functions
  id: totrans-175
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用提升进行全函数和部分函数之间的对话
- en: 'Such a design has drawbacks:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 这样的设计有一些缺点：
- en: 'The first drawback is that our partial function always accepts one parameter:
    a tuple of input and effects. This can be a source of confusion.'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个缺点是我们的部分函数始终接受一个参数：输入和效果的元组。这可能是一个混淆的来源。
- en: 'Also note that a decision where we process input or reject (and it will be
    passed to the next chain by a combinator) should be written twice: first in `isDefinedAt`,
    then in apply. In simple cases, this is hidden from us by case syntax, where `isDefinedAt`
    is produced automatically.'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 还要注意，在处理输入或拒绝（它将通过组合子传递到下一个链）的决策中，应该写两次：首先在`isDefinedAt`中，然后在`apply`中。在简单的情况下，这通过case语法隐藏起来，其中`isDefinedAt`是自动生成的。
- en: It looks like a loss of a binary operator syntax is the third problem. However,
    this is not a real problem. We will learn how it is possible to define our own
    syntax on third-party classes in [Chapter 5](ch05.html "Chapter 5. Scala Type
    System"), *Scala Type System*.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 它看起来像丢失了二元运算符语法是第三个问题。然而，这并不是一个真正的问题。我们将在[第五章](ch05.html "第五章。Scala类型系统")中学习如何在第三方类上定义自己的语法。
- en: Can we have one point of decision and work with a partially defined value?
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 我们能否有一个决策点并处理一个部分定义的值？
- en: 'Let''s look at the next method from the standard library:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看标准库中的下一个方法：
- en: '[PRE43]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: We can represent a partial function as a total function with the result wrapped
    in `Option`. For a combinator of partial functions, we have very similar methods
    to `Option`.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将部分函数表示为将结果包装在`Option`中的全函数。对于部分函数的组合器，我们有与`Option`非常类似的方法。
- en: Let's change the design of our modes again.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再次改变我们模式的设计。
- en: Look at `Lesson 3/6-project`.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 查看`Lesson 3/6-project`。
- en: '`ChatbotMode` is a trait once more:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '`ChatbotMode`是一个特质：'
- en: '[PRE44]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'But we can define simple modes with the help of partial functions and transform
    one to our traits using the `helper` constructor:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 但我们可以通过部分函数的帮助定义简单的模式，并使用`helper`构造函数将它们转换到我们的特质中：
- en: '[PRE45]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'After that, we can do this:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们可以这样做：
- en: '[PRE46]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Also note that we can initialize `ChatbotMode` from the function because `ChatbotMode`
    is a SAM type:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 还要注意，我们可以从函数初始化`ChatbotMode`，因为`ChatbotMode`是一个SAM类型：
- en: '[PRE47]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Also, we can compare the implementation of `OrMode` with the previous variant,
    based on partial function combinators:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们可以将`OrMode`的实现与基于部分函数组合器的先前变体进行比较：
- en: '[PRE48]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'As you can see, that structure is very similar: map used `andThen` instead
    in the partial function, and Option also uses `orElse`. We can say that the domains
    `PartialFunction[A,B]` and `Function[A,Option[B]]` are isomorphic.'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，该结构非常相似：在部分函数中使用`andThen`代替，Option也使用了`orElse`。我们可以说，`PartialFunction[A,B]`和`Function[A,Option[B]]`的域是同构的。
- en: There is a default transformer from a partial function to a function of an option,
    and it is named `lift`.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 从部分函数到选项函数的默认转换器，命名为`lift`。
- en: 'This is a method of a partial function:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个部分函数的方法：
- en: '[PRE49]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'This will have the same effect as this:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 这将产生与这个相同的效果：
- en: '[PRE50]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Let''s write an inverse transformer, `unlift`:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们编写一个逆转换器，`unlift`：
- en: '[PRE51]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'It is a good practice to provide more efficient chain operations, for example:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 提供更高效的链式操作是一种好习惯，例如：
- en: '[PRE52]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Here, we call the underlying `f` once.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我们调用底层的`f`一次。
- en: Let's now add a simple TODO list to our chatbot.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们给我们的聊天机器人添加一个简单的TODO列表。
- en: We will change our model of evaluation by allowing more than one mode to evaluate
    input. A combinator will choose the best evaluation.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过允许多个模式评估输入来改变我们的评估模型。组合器将选择最佳的评估。
- en: Open `Lesson 3/6-project.`
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`Lesson 3/6-project`。
- en: Add the `Processed`, `relevance` parameter between 0 and 1.
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Processed`和`relevance`参数之间添加0到1。
- en: Modify the `or` combinator to evaluate both of the child modes and select answer,
    based on its relevance.
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改`or`组合器，以评估两个子模式并基于其相关性选择答案。
- en: Add a test to the `test` cases.
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`test`用例中添加一个测试。
- en: Summary
  id: totrans-213
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we have covered functional programming with Scala and how object-oriented
    and functional approaches complete each other. We also covered generic classes,
    which are often used with pattern matching. Finally, we covered how to create
    user-defined pattern matching and learned why is it useful.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了Scala的函数式编程以及面向对象和函数式方法如何相互补充。我们还介绍了泛型类，它们通常与模式匹配一起使用。最后，我们介绍了如何创建用户定义的模式匹配，并学习了为什么它是有用的。
- en: In the next chapter, we'll cover important Scala collections such as `Sets`
    and `Maps`. We'll also discuss mutable and immutable collections and their applicability
    in Scala code.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将介绍重要的Scala集合，如`Sets`和`Maps`。我们还将讨论可变和不可变集合及其在Scala代码中的应用。
