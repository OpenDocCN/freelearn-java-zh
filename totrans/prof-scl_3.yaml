- en: Chapter 3. Functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we covered the object-oriented aspects of Scala, such
    as classes, objects, pattern matching, self-types, case classes, and so on. We
    also implemented object-oriented concepts that we learned in our chatbot application.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will cover functional programming with Scala and how object-oriented
    and functional approaches complete each other. We will also cover generic classes,
    which are often used with pattern matching. We will also cover how to create user-defined
    pattern matching and why is it useful.
  prefs: []
  type: TYPE_NORMAL
- en: 'By the end of this chapter, you will be able to:'
  prefs: []
  type: TYPE_NORMAL
- en: Identify the basics of functional programming
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Identify the basics of generic types in Scala
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implement user-defined pattern matching
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Recognize and use functional compositional patterns
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will introduce the fundamentals of functional programming,
    such as function values and high-order functions.
  prefs: []
  type: TYPE_NORMAL
- en: Function Values
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'What is a function? We are familiar with methods, which must be defined in
    a scope (class or objects):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'In Scala, we can also define a function value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we define the function value, with a type of `(Int,Int) => Int`. Of course,
    as with all type declarations, the type can be omitted if it can be deduced from
    the context. So, an alternative syntax for this can be:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Both `f1(1,2)` and `f2(1,2)` will force evaluation. The difference between `f1`
    and `f2` is that the second is a value, which can be stored in a variable or passed
    to another function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Functions which accept other functions as parameters are named high-order functions,
    for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'This function returns functions, which apply parameters twice. An example of
    this usage is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'In general, the syntax for function definitions is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The type signature can be omitted if it is possible to deduce types from the
    context.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's look at how to define a function variable.
  prefs: []
  type: TYPE_NORMAL
- en: 'Define the function variable in the REPL of IDE worksheet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Function from an OO Point of View
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When looking at Scala sources, we will see the following definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, `Function1` is a base trait for a function with one argument. `Function1`
    has one abstract method: `apply`. Scala provides syntax sugar for the call of
    the `apply` method with syntax.'
  prefs: []
  type: TYPE_NORMAL
- en: '`T1` and `R` are type parameters of `Function1`. `T1` is a type of the first
    argument, while `R` is a result type.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Symbols before type parameters [ `-T1, +R` ] mean `contravariance` and `covariance`
    of parameters; we will speak about one in detail later. For now, let''s write
    a definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The value of a function with one argument, `f: A => B`, is just an instance
    of a trait, `Function1[A,B]`. For functions with two arguments, we have `Function2[T1,T2,R]`
    and so on. We can rewrite an example with `twice` using OO facilities in the next
    form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we define the `Twice` object with the same behavior of the previously
    described function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'To summarize, we can say:'
  prefs: []
  type: TYPE_NORMAL
- en: The function value is an instance of an appropriative function trait.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The call of a function value is a call of the `apply()` method in a function
    trait.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now, it's time to create a few functions.
  prefs: []
  type: TYPE_NORMAL
- en: Open a blank worksheet in your project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Define the function which accepts the binary function and arguments, and return
    an application of such a function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Make the syntax better by reformulating the function using currying:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Partial application: Write the `fix` function, which accepts binary function
    and an argument and returns an unary function, which will apply the placed function
    and argument. For example, with definition `g` as : `val g = fix1((x,y)=>x+y,3)`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`g(2)` should be evaluated to `5`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Conversions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We have methods and functional values, which can do the same thing. It is logical
    to expect a conversion between them, for example, the ability to assign a method
    to a functional variable or pass a function as an OO interface.
  prefs: []
  type: TYPE_NORMAL
- en: Scala provides a special syntax for converting a method to a value. We just
    need to add the underscore (_) after the name of the method.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Also, a functional value can be implicitly converted to a so-called SAM (Single
    Abstract Method) trait. A SAM trait has only one abstract method, and we can pass
    a function in its context, where the SAM trait is required (and the function type
    conforms to the method signature).:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Here, we pass the function with zero parameters to the `Thread` constructor,
    which accepts the `Runnable` interface.
  prefs: []
  type: TYPE_NORMAL
- en: In Scala, we have three different ways of implementing deferred call functionality.
  prefs: []
  type: TYPE_NORMAL
- en: Defining and Measuring the Time of a Unit Function
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Define a function which accepts a function which runs a unit function and measures
    the time in nanoseconds. How long does this take? Implement this in three different
    ways.
  prefs: []
  type: TYPE_NORMAL
- en: 'Write a function which accepts other functions. Run one and measure the execution
    time:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Write a function which accepts the by-name parameter. Run one and measure the
    execution time:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Write an object which extends the `Function1` trait and do the same in the
    `apply` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Syntax Sugar in a Function Definition
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Sometimes, writing expressions such as `x => x+1` look too verbose. To solve
    this, syntax sugar exists, which allows you to write small functional expressions
    in a compact and idiomatic way. Don''t write the left part at all, and, while
    writing, use _ (underscore) instead of an argument. The first underscore means
    the first argument, the second underscore means the second argument, and so on:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Some functions such as `(x,y) => x*x + y` can't be represented in such a notation.
  prefs: []
  type: TYPE_NORMAL
- en: Partial Functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Partial functions are better known as partially defined functions—some values
    exist in the domain of the function input, where this function is undefined.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at a simplified definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Along with the apply method we have a `isDefinedAt` method, which returns `true`
    if our function is applicable for an argument, and a special syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'We can combine a few partial functions into a new set of standard combinators—
    `orElse`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Note that type annotation is needed to give a correct context for type deduction.
    Otherwise, the compiler will not be able to deduce the type of inline function
    argument.
  prefs: []
  type: TYPE_NORMAL
- en: 'One useful combinator— `andThen`, which allows building pipelines, is also
    necessary:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, define a function which accepts a function and provides a transformed
    function. For example, let the input function be `f`: `Int => Int`, and let''s
    build `g(f)`: `g(f)(x) = f(x) + x.` If `f` is not defined at `x`, `g(f)` must
    not be defined either.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Copy the following class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Or as a case-expression with an `if` clause:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We'll now implement a partial function for constructing an association between
    names and values.
  prefs: []
  type: TYPE_NORMAL
- en: 'Write a function for a pair as a class with parameters (name,value), which
    is defined only if the argument is equal to name:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Use the `orElse` combinator to combine such pairs into a bigger function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Exploring Pattern Matching
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now we will return to pattern matching and learn about extending capabilities
    behind case classes. As you will remember from the previous chapter, we can use
    pattern matching against case classes, where fields of a class can be bound to
    the variables in the scope of an appropriative case clause. Can we do this for
    our non-case classes and embed our own custom logic for matching?
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we will learn how to write our own pattern matcher and get
    acquainted with some standard generic classes which are often used with pattern
    matching.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's get started with the minimal example.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we write the following code in the IDE:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Under the hood, the compiler compiled this to the next intermediate form:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `unapply` method of the companion object is called, which must return the
    class with the methods get and `isDefined`.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'When we have more than one binding variable, the resulting container should
    contain a tuple. For example, for the point intermediate form, this will be the
    resulting code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The standard Scala library provides the `Option` type, although it is possible
    to define your own type with such methods (which can be useful in some heavy optimization
    scenarios).
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Define the class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Here, we see the algebraic type (such as the hierarchy of case classes/objects)
    with the generic type parameter: A. You may have heard of the abbreviation GADT
    (Generic Algebraic Data Type) when referring to such constructs.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Informal value of `Option[A]` – the container from one or zero elements, or
    elements which can or cannot exist. Some(a) – when an element exists, None – for
    its absence.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`None` extends `Option[Nothing]`. Nothing is a `minimal` type in the Scala
    typesystem, which is a subtype of any type.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'So, to define the custom pattern matcher, we need to create an object with
    the `unapply` method and put logic inside of it which returns a binding variable
    (or a tuple with binding variables) in an option container:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Let''s define the pattern matcher `Diagonal`, which will match only points
    situated in the diagonal:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We'll now implement the `unapply` custom.
  prefs: []
  type: TYPE_NORMAL
- en: Define object `Axis` (Numbered Bullet)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Define method `unapply` (Numbered Bullet END)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Determinate, if object is on X axis(Apply BULLET INSIDE BULLET to all three
    points)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Determinate, if object is on Y axis
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Otherwise, return `None`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Binding a Sequence of Variables in the Pattern Matcher
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Sometimes, we need a particular type of pattern matcher where the number of
    binding variables can vary. For example, regular expressions in standard Scala
    library are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we can see that that `r1` is matched with one variable, but `r2` uses
    two binding variables. Another convention exists for this case: a companion object
    should provide the `unapplySeq` method instead of `unapply`, which returns a sequence
    wrapped in an option.'
  prefs: []
  type: TYPE_NORMAL
- en: We will learn more about sequences during the next chapter, but for now we can
    say that `Seq[A]` – is a generic trait for sequences. The `apply` operator in
    sequences works as index access (for example, `seq(n)` returns the nth element
    of the sequence, and it is possible to create default sequence using the `Seq`
    companion class, `Seq(1,2,3)`.
  prefs: []
  type: TYPE_NORMAL
- en: Let's now implement the custom `unapplySeq` method. This is defined on strings
    and returns a sequence of words.
  prefs: []
  type: TYPE_NORMAL
- en: Define the `Words` object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Define the `unapplySeq` method. Transform the array to `seq`, using the .`toSeq`
    method in Scala Array:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Write a test which compares words for the following strings:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Sometimes, when binding variables into sequence, we don't need var for each
    value in the sequence, but only the first value and the rest of the sequence.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We can use the pattern with the syntax for a variable function call in a pattern,
    for example:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Partial Functions in Practice
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have learned a lot about functions and pattern matching, let's apply
    our theoretical knowledge to practical programming.
  prefs: []
  type: TYPE_NORMAL
- en: Let's get our chatbot, which we developed during the previous chapter, and change
    the modes to partial functions instead of classes.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Open `/Lesson 3/5-project` in the supplement materials and import the project
    into the IDE.
  prefs: []
  type: TYPE_NORMAL
- en: Representing ChatbotMode as a Partial Function
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s navigate to the `scala` file package in `com.packt.courseware.l4`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Here, we see the `package` object, which was not mentioned previously in our
    chapters.
  prefs: []
  type: TYPE_NORMAL
- en: The `package` object is an object which is associated with a package. When you
    import a package with a wildcard, then you import the current scope content of
    the package object if one exists.
  prefs: []
  type: TYPE_NORMAL
- en: So, the `package` object is a good way to store some utility definitions and
    functions, which should be available in a package.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next sentence is a type alias for `ChatbotMode`: we define one as a partial
    function from ( `String`, `EffectsProvider`) to `Processed`.'
  prefs: []
  type: TYPE_NORMAL
- en: As you will remember, `Processed` is a `LineStepResult` which is a trait, united
    with Processed or Failed. With partial functions, we don't need a `Failed` variant;
    instead, `isDefined` in our mode will be set to `false`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let''s look at some simple mode:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: So, we can write partial functions just as we do `vars`.
  prefs: []
  type: TYPE_NORMAL
- en: In the previous version, we have `OrMode`, which combines modes in combination.
    Can we do the same with partial functions?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: We use the `andThen` combinator for postprocessing the result of applying `frs`
    and `snd` in order to insert `nextMode` in the or chain and return those functions
    in the `orElse` combinator.
  prefs: []
  type: TYPE_NORMAL
- en: So, as we can see, modes can be described with the help of partial functions.
    The resultant code is a little shorter, but we only lose the fancy syntax for
    combining modes.
  prefs: []
  type: TYPE_NORMAL
- en: 'The main mode now looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Let's now implement partial functions. In l4, some modes are removed from the
    source code. Can you move them back, in the form of partial functions?
  prefs: []
  type: TYPE_NORMAL
- en: '**Steps for Completion:**'
  prefs: []
  type: TYPE_NORMAL
- en: Open `Lesson 3/5-project.`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Implement the `currentTime`, `otherwise,` and `interestingIgnore` modes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Ensure that the tests are running.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Implementing RemindStore as a Set of Partial Functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's look at the implementation of `RemindStore`. Navigate to `com/packt/courseware/l4/RemindCommand.scala`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Look at using regular expressions in patterns:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that `RemindedState` has a memory leak: what will be the behavior of the
    function when we ask our chatbot to store the same word a few times?'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Note**'
  prefs: []
  type: TYPE_NORMAL
- en: A memory leak is a situation where we allocate an object but keep it accessible
    after usage.
  prefs: []
  type: TYPE_NORMAL
- en: Let's now find and fix a memory leak in `StoreRemindCommand`.
  prefs: []
  type: TYPE_NORMAL
- en: Open `Lesson 3/5-project`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Analyze the case where we stored the same work a few times.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Consider how it's possible to write a unit test for this (`***`)?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Fix the memory leak.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: As we have seen, it is possible to build modes in chatbot as partial functions.
  prefs: []
  type: TYPE_NORMAL
- en: Using Lifting for Conversations between Total and Partial Functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Such a design has drawbacks:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The first drawback is that our partial function always accepts one parameter:
    a tuple of input and effects. This can be a source of confusion.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Also note that a decision where we process input or reject (and it will be
    passed to the next chain by a combinator) should be written twice: first in `isDefinedAt`,
    then in apply. In simple cases, this is hidden from us by case syntax, where `isDefinedAt`
    is produced automatically.'
  prefs: []
  type: TYPE_NORMAL
- en: It looks like a loss of a binary operator syntax is the third problem. However,
    this is not a real problem. We will learn how it is possible to define our own
    syntax on third-party classes in [Chapter 5](ch05.html "Chapter 5. Scala Type
    System"), *Scala Type System*.
  prefs: []
  type: TYPE_NORMAL
- en: Can we have one point of decision and work with a partially defined value?
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at the next method from the standard library:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: We can represent a partial function as a total function with the result wrapped
    in `Option`. For a combinator of partial functions, we have very similar methods
    to `Option`.
  prefs: []
  type: TYPE_NORMAL
- en: Let's change the design of our modes again.
  prefs: []
  type: TYPE_NORMAL
- en: Look at `Lesson 3/6-project`.
  prefs: []
  type: TYPE_NORMAL
- en: '`ChatbotMode` is a trait once more:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'But we can define simple modes with the help of partial functions and transform
    one to our traits using the `helper` constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'After that, we can do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Also note that we can initialize `ChatbotMode` from the function because `ChatbotMode`
    is a SAM type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Also, we can compare the implementation of `OrMode` with the previous variant,
    based on partial function combinators:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, that structure is very similar: map used `andThen` instead
    in the partial function, and Option also uses `orElse`. We can say that the domains
    `PartialFunction[A,B]` and `Function[A,Option[B]]` are isomorphic.'
  prefs: []
  type: TYPE_NORMAL
- en: There is a default transformer from a partial function to a function of an option,
    and it is named `lift`.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is a method of a partial function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'This will have the same effect as this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s write an inverse transformer, `unlift`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'It is a good practice to provide more efficient chain operations, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: Here, we call the underlying `f` once.
  prefs: []
  type: TYPE_NORMAL
- en: Let's now add a simple TODO list to our chatbot.
  prefs: []
  type: TYPE_NORMAL
- en: We will change our model of evaluation by allowing more than one mode to evaluate
    input. A combinator will choose the best evaluation.
  prefs: []
  type: TYPE_NORMAL
- en: Open `Lesson 3/6-project.`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add the `Processed`, `relevance` parameter between 0 and 1.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Modify the `or` combinator to evaluate both of the child modes and select answer,
    based on its relevance.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a test to the `test` cases.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have covered functional programming with Scala and how object-oriented
    and functional approaches complete each other. We also covered generic classes,
    which are often used with pattern matching. Finally, we covered how to create
    user-defined pattern matching and learned why is it useful.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we'll cover important Scala collections such as `Sets`
    and `Maps`. We'll also discuss mutable and immutable collections and their applicability
    in Scala code.
  prefs: []
  type: TYPE_NORMAL
