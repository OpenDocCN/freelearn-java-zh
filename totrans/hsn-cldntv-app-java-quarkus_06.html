<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Adding Web Interfaces to Quarkus Services</h1>
                </header>
            
            <article>
                
<p class="mce-root">So far, we have learned how to build a simple REST application with Quarkus and covered the actions that should be put in place to build, test, and deploy our application on a Kubernetes environment.</p>
<p class="mce-root">We could stop at this point and be happy with what we have achieved; however, there are still lots of milestones to reach. For example, we haven't used any web interfaces to access Quarkus services. As you will see in this chapter, Quarkus features some extensions that allow us to reuse standard enterprise APIs such as Servlets and web sockets. At the same time, you can use lighter JavaScript/HTML 5 frameworks as user interfaces for your services. We will explore both approaches in this chapter.</p>
<p class="mce-root"><span><span>In this chapter, we will cover the following topics</span></span>:</p>
<ul>
<li class="mce-root">Adding web content to Quarkus applications</li>
<li class="mce-root">Running our application on Minishift</li>
<li class="mce-root">Adding enterprise web components to our application such as Servlet and WebSockets</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Technical requirements</h1>
                </header>
            
            <article>
                
<p>You can find the source code for the project in this chapter on GitHub at <a href="https://github.com/PacktPublishing/Hands-On-Cloud-Native-Applications-with-Java-and-Quarkus/tree/master/Chapter04">https://github.com/PacktPublishing/Hands-On-Cloud-Native-Applications-with-Java-and-Quarkus/tree/master/Chapter04</a>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Adding web content to Quarkus applications</h1>
                </header>
            
            <article>
                
<p class="mce-root">In the examples we've discussed so far, we've tested the web server capabilities of Quarkus by adding RESTful services. Under the hood, Quarkus uses the following core components to handle web requests:</p>
<ul>
<li class="mce-root"><strong>Vert.x Web server</strong>: It is the core web component in Quarkus delivering RESTful services as long as <strong>real-time</strong> (server push) web applications. We will discuss more in detail about Vert.x in <a href="3ca131cb-e293-4c25-a7c8-29d05a409ccd.xhtml" target="_blank">Chapter 9</a>, <em>Unifying Imperative and Reactive with Vert.x</em> of this book.</li>
<li class="mce-root"><strong>Undertow Web server</strong>: It is a flexible product, built by combining different small single-purpose handlers, that comes into play in Quarkus when delivering <kbd>WebSocket</kbd> applications.</li>
</ul>
<p class="mce-root">As already discussed, we can add static web content (HTML, JavaScript, images) to our applications by including them under the <kbd>resources/META-INF/resources</kbd> folder of your project. What is the purpose of having static web content in a microservice-styled application? As a matter of fact, static content can be used in several contexts, including microservices. For example, we could provide helper pages for the service itself. We could also mix and match Quarkus with existing frameworks such as Swagger UI to test our REST endpoints without even writing complex user interfaces.</p>
<p class="mce-root">With this premise, we are going to demonstrate how to build a <strong>Create, Read, Update, Delete</strong> (<strong>CRUD</strong>) application that uses JSON to consume and produce data. Then, we will enrich our application with a thin web interface made from a <span>JavaScript-based web framework</span>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Building a CRUD application</h1>
                </header>
            
            <article>
                
<p class="mce-root">Within the GitHub source folder for this chapter, you will find two examples. The first one is located in the <kbd>Chapter04/customer-service/basic</kbd> folder and will be discussed in this section. We recommend importing the project into your IDE before you move on.</p>
<p class="mce-root">If you take a look at the project's structure, you will see that it is made up of three main components:</p>
<ol>
<li class="mce-root">First of all, there is a model class that records customer entries:</li>
</ol>
<pre class="mce-root" style="padding-left: 60px">package com.packt.quarkus.chapter4;<br/> <br/>public class Customer {<br/>     private Integer id;<br/>     private String name;<br/>     private String surname;<br/> <br/>     public Integer getId() {<br/>         return id;<br/>     }<br/> <br/>     public void setId(Integer id) {<br/>         this.id = id;<br/>     }<br/> <br/>     public String getName() {<br/>         return name;<br/>     }<br/> <br/>     public void setName(String name) {<br/>         this.name = name;<br/>     }<br/> <br/>     public String getSurname() {<br/>         return surname;<br/>     }<br/> <br/>     public void setSurname(String surname) {<br/>         this.surname = surname;<br/>     }<br/> }</pre>
<p class="mce-root" style="padding-left: 90px">The <kbd>Customer</kbd> class is the minimal definition of a <kbd>Customer</kbd> record. It is defined as a Plain Old Java Object that should be stored in memory.</p>
<ol start="2">
<li class="mce-root">Next, take a look at the <kbd>CustomerRepository</kbd> class, which contains the core functionalities that we'll use to manage our model:</li>
</ol>
<pre class="mce-root" style="padding-left: 60px">package com.packt.quarkus.chapter4;<br/> <br/>import javax.enterprise.context.ApplicationScoped;<br/>import java.util.ArrayList;<br/>import java.util.List;<br/> <br/> <br/>@ApplicationScoped<br/>public class CustomerRepository {<br/> <br/>     List&lt;Customer&gt; customerList = new ArrayList();<br/>     int counter;<br/> <br/>     public int getNextCustomerId() {<br/>         return counter++;<br/>     }<br/> <br/>     public List&lt;Customer&gt; findAll() {<br/>         return customerList;<br/>     }<br/> <br/>     public Customer findCustomerById(Integer id) {<br/>         for (Customer c:customerList) {<br/>             if (c.getId().equals(id))  {<br/>                 return c;<br/>             }<br/>         }<br/>         throw new CustomerException("Customer not found!");<br/>     }<br/> <br/>     public void updateCustomer(Customer customer) {<br/>         Customer customerToUpdate = <br/>          findCustomerById(customer.getId());<br/>         customerToUpdate.setName(customer.getName());<br/>         customerToUpdate.setSurname(customer.getSurname());<br/>     }<br/> <br/>     public void createCustomer(Customer customer) {<br/>         customer.setId(getNextCustomerId());<br/>         findAll().add(customer);<br/>     }<br/> <br/>     public void deleteCustomer(Integer customerId) {<br/>         Customer c = findCustomerById(customerId);<br/>         findAll().remove(c);<br/>     }<br/>}</pre>
<p class="mce-root" style="padding-left: 90px">As you can see, it's just a vanilla implementation of a repository that serves as a pattern that stores and retrieves our data. In upcoming chapters, we will be adding other features, such as persistent storage and asynchronous behavior. Due to this, it's good to start with a service-agnostic example.</p>
<ol start="3">
<li class="mce-root">The customer service is completed by the <kbd>CustomerEndpoint</kbd> class, which has the following implementation:</li>
</ol>
<pre class="mce-root" style="padding-left: 60px">package com.packt.quarkus.chapter4;<br/> <br/>import javax.enterprise.context.ApplicationScoped;<br/>import javax.inject.Inject;<br/>import javax.ws.rs.*;<br/>import javax.ws.rs.core.Response;<br/>import java.util.List;<br/> <br/> <br/>@Path("customers")<br/>@ApplicationScoped<br/>@Produces("application/json")<br/>@Consumes("application/json")<br/>public class CustomerEndpoint {<br/> <br/>     @Inject CustomerRepository customerRepository;<br/> <br/>     @GET<br/>     public List&lt;Customer&gt; getAll() {<br/>         return customerRepository.findAll();<br/>     }<br/> <br/>     @POST<br/>     public Response create(Customer customer) {<br/>         customerRepository.createCustomer(customer);<br/>         return Response.status(201).build();<br/> <br/>     }<br/> <br/>     @PUT<br/>     public Response update(Customer customer) {<br/>         customerRepository.updateCustomer(customer);<br/>         return Response.status(204).build();<br/>     }<br/>     @DELETE<br/>     public Response delete(@QueryParam("id") Integer customerId) {<br/>         customerRepository.deleteCustomer(customerId);<br/>         return Response.status(204).build();<br/>     }<br/> <br/>} </pre>
<p class="mce-root">As you can see, <kbd>CustomerEndpoint</kbd> is a thin REST layer over the <kbd>CustomerRepository</kbd> class and contains a method for each CRUD action, where it maps each one to the appropriate HTTP method. When using this approach, it would suffice to have a single REST path for the whole application (<kbd>/customers</kbd>) since the REST engine will call the appropriate method based on the HTTP request method.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Adding a UI to our customer service</h1>
                </header>
            
            <article>
                
<p class="mce-root">As we mentioned in <a href="0e04a6a1-5a50-4557-be00-f4a3406fa1dd.xhtml" target="_blank">Chapter 1</a>, <em>Introduction to Quarkus Core Concepts</em>, you can include static resources such as HTML pages, JavaScript, CSS, or images in the <kbd>src/main/resources/META-INF/resources</kbd> folder. An <kbd>index.html</kbd> page is provided as a marker in our project, as shown in the project's hierarchy:</p>
<pre class="mce-root"><strong>$ tree src</strong><br/><strong> src</strong><br/><strong> ├── main</strong><br/><strong> │   ├── docker</strong><br/><strong> │   ├── java</strong><br/><strong> │   │   └── com</strong><br/><strong> │   │       └── packt</strong><br/><strong> │   │           └── quarkus</strong><br/><strong> │   │               └── chapter4</strong><br/><strong> │   │                   ├── CustomerEndpoint.java</strong><br/><strong> │   │                   ├── Customer.java</strong><br/><strong> │   │                   ├── CustomerRepository.java</strong><br/><strong> │   └── resources</strong><br/><strong> │       ├── application.properties</strong><br/><strong> │       └── META-INF</strong><br/><strong> │           └── resources</strong><br/><strong> │               ├── index.html </strong></pre>
<p class="mce-root">In order to connect to our REST endpoint, we will include a JavaScript framework called AngularJS and some CSS styling in the head section of our <kbd>index.html</kbd> page:</p>
<pre class="mce-root">&lt;link rel="stylesheet" type="text/css" href="stylesheet.css" media="screen" /&gt;<br/>&lt;script src="//ajax.googleapis.com/ajax/libs/angularjs/1.4.8/angular.min.js"&gt;&lt;/script&gt;</pre>
<p class="mce-root">Also, within the head section of the <kbd>index.html</kbd> page, we will include the <strong>AngularJS Controller</strong>, which contains a function that we can use to access REST endpoint methods. We will pass the HTML form data as an argument, which we will discuss next:</p>
<pre class="mce-root">&lt;script type="text/javascript"&gt;<br/>       var app = angular.module("customerManagement", []);<br/>       angular.module('customerManagement').constant('SERVER_URL',<br/>        '/customers');<br/>       //Controller Part<br/>       app.controller("customerManagementController",  function <br/>        ($scope, $http, SERVER_URL) {<br/>         //Initialize page with default data which is blank in this<br/>         //example<br/>         $scope.customers = [];<br/>         $scope.form = {<br/>           id: -1,<br/>           name: "",<br/>           surname: ""<br/>         };<br/>         //Now load the data from server<br/>         _refreshPageData();<br/>         //HTTP POST/PUT methods for add/edit customers<br/>         $scope.update = function () {<br/>           var method = "";<br/>           var url = "";<br/>           var data = {};<br/>           if ($scope.form.id == -1) {<br/>             //Id is absent so add customers - POST operation<br/>             method = "POST";<br/>             url = SERVER_URL;<br/>             data.name = $scope.form.name;<br/>             data.surname = $scope.form.surname;<br/>           } else {<br/>             //If Id is present, it's edit operation - PUT operation<br/>             method = "PUT";<br/>             url = SERVER_URL;<br/>             data.id = $scope.form.id;<br/>             data.name = $scope.form.name;<br/>             data.surname = $scope.form.surname;<br/>           }<br/>           $http({<br/>             method: method,<br/>             url: url,<br/>             data: angular.toJson(data),<br/>             headers: {<br/>               'Content-Type': 'application/json'<br/>             }<br/>           }).then(_success, _error);<br/>         };<br/>         //HTTP DELETE- delete customer by id<br/>         $scope.remove = function (customer) {<br/> <br/>           $http({<br/>             method: 'DELETE',<br/>             url: SERVER_URL+'?id='+customer.id<br/>           }).then(_success, _error);<br/>         };<br/>         //In case of edit customers, populate form with customer<br/>        // data<br/>         $scope.edit = function (customer) {<br/>           $scope.form.name = customer.name;<br/>           $scope.form.surname = customer.surname;<br/>           $scope.form.id = customer.id;<br/>         };<br/>           /* Private Methods */<br/>         //HTTP GET- get all customers collection<br/>         function _refreshPageData() {<br/>           $http({<br/>             method: 'GET',<br/>             url: SERVER_URL<br/>           }).then(function successCallback(response) {<br/>             $scope.customers = response.data;<br/>           }, function errorCallback(response) {<br/>             console.log(response.statusText);<br/>           });<br/>         }<br/>         function _success(response) {<br/>           _refreshPageData();<br/>           _clearForm()<br/>         }<br/>         function _error(response) {<br/>           alert(response.data.message || response.statusText);<br/>         }<br/>         //Clear the form<br/>         function _clearForm() {<br/>           $scope.form.name = "";<br/>           $scope.form.surname = "";<br/>           $scope.form.id = -1;<br/>         }<br/>       });<br/>     &lt;/script&gt;<br/> &lt;/head&gt;</pre>
<p class="mce-root">An in-depth discussion of AngularJS is beyond the scope of this book; however, in a nutshell, Angular applications rely on controllers to manage their flow of data. Each controller accepts <kbd>$scope</kbd> as a parameter. This parameter refers to the module or application that the controller needs to handle.</p>
<p class="mce-root">The purpose of our controller will be to reach out to our REST application using different HTTP methods (<kbd>GET</kbd>, <kbd>POST</kbd>, <kbd>PUT</kbd>, and <kbd>DELETE</kbd>).</p>
<p>The final part of the <kbd>index.html</kbd> page contains the form data, which can be used to insert new customers and edit existing ones:</p>
<pre class="mce-root">&lt;body ng-app="customerManagement" ng-controller="customerManagementController"&gt;<br/> &lt;div class="divTable blueTable"&gt;<br/>     &lt;h1&gt;Quarkus CRUD Example&lt;/h1&gt;<br/>     &lt;h2&gt;Enter Customer:&lt;/h2&gt;<br/>     &lt;form ng-submit="update()"&gt;<br/>         &lt;div class="divTableRow"&gt;<br/>             &lt;div class="divTableCell"&gt;Name:&lt;/div&gt;<br/>             &lt;div class="divTableCell"&gt;&lt;input type="text"         <br/>              placeholder="Name" ng-model=<br/>              "form.name" size="60"/&gt;&lt;/div&gt;<br/>         &lt;/div&gt;<br/>         &lt;div class="divTableRow"&gt;<br/>             &lt;div class="divTableCell"&gt;Surname:&lt;/div&gt;<br/>             &lt;div class="divTableCell"&gt;&lt;input type="text" <br/>              placeholder="Surname" ng-model="form.surname" <br/>             size="60"/&gt;<br/>        &lt;/div&gt;<br/>         &lt;/div&gt;<br/>         &lt;input type="submit" value="Save"/&gt;<br/>     &lt;/form&gt;<br/>     &lt;div class="divTable blueTable"&gt;<br/>         &lt;div class="divTableHeading"&gt;<br/>             &lt;div  class="divTableHead"&gt;Customer Name&lt;/div&gt;<br/>             &lt;div  class="divTableHead"&gt;Customer Address&lt;/div&gt;<br/>             &lt;div  class="divTableHead"&gt;Action&lt;/div&gt;<br/>         &lt;/div&gt;<br/>         &lt;div class="divTableRow" ng-repeat="customer in customers"&gt;<br/>             &lt;div class="divTableCell"&gt;{{ customer.name }}&lt;/div&gt;<br/>             &lt;div class="divTableCell"&gt;{{ customer.surname }}&lt;/div&gt;<br/>             &lt;div class="divTableCell"&gt;&lt;a ng-click="edit( customer )" <br/>             class="myButton"&gt;Edit&lt;/a&gt;<br/>             &lt;a ng-click="remove( customer )"<br/>             class="myButton"&gt;Remove&lt;/a&gt;&lt;/div&gt;<br/>         &lt;/div&gt;<br/>     &lt;/div&gt;<br/> &lt;/body&gt;<br/>&lt;/html&gt;</pre>
<p class="mce-root">Now that we're done with the <kbd>index.html</kbd> page, we can write a test class for our application.</p>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Testing our application</h1>
                </header>
            
            <article>
                
<p class="mce-root">Before testing our application, it is worth mentioning that the <kbd>quarkus-jsonb</kbd> dependency has been included in this project in order to produce JSON content through the REST endpoint and to create JSON objects programmatically in the test class. The following is the dependency we have included in the <kbd>pom.xml</kbd> file:</p>
<pre class="mce-root">&lt;dependency&gt;<br/>   &lt;groupId&gt;io.quarkus&lt;/groupId&gt;<br/>   &lt;artifactId&gt;quarkus-jsonb&lt;/artifactId&gt;<br/>&lt;/dependency&gt;</pre>
<p class="mce-root">The following is our <kbd>CustomerEndpointTest</kbd> class, which can be used to validate the <kbd>Customer</kbd> application:</p>
<pre class="mce-root">@QuarkusTest<br/>public class CustomerEndpointTest {<br/> <br/>     @Test<br/>     public void testCustomerService() {<br/> <br/>         JsonObject obj = Json.createObjectBuilder()<br/>                 .add("name", "John")<br/>                 .add("surname", "Smith").build();<br/> <br/>         // Test POST<br/>         given()<br/>                 .contentType("application/json")<br/>                 .body(obj.toString())<br/>                 .when()<br/>                 .post("/customers")<br/>                 .then()<br/>                 .statusCode(201);<br/> <br/>         // Test GET<br/>         given()<br/>                 .when().get("/customers")<br/>                 .then()<br/>                 .statusCode(200)<br/>                 .body(containsString("John"),<br/>                       containsString("Smith"));<br/> <br/>         obj = Json.createObjectBuilder()<br/>                 .add("id", "0")<br/>                 .add("name", "Donald")<br/>                 .add("surname", "Duck").build();<br/> <br/>         // Test PUT<br/>         given()<br/>                 .contentType("application/json")<br/>                 .body(obj.toString())<br/>                 .when()<br/>                 .put("/customers")<br/>                 .then()<br/>                 .statusCode(204);<br/> <br/>         // Test DELETE<br/>         given()<br/>                 .contentType("application/json")<br/>                 .when()<br/>                 .delete("/customers?id=0")<br/>                 .then()<br/>                 .statusCode(204);<br/> <br/>     }<br/> } </pre>
<p class="mce-root">Let's switch gears and look a little more closely at the test class. Most of the content here should look familiar to you, except for the <kbd>Json.createObjectBuilder</kbd> API, which is a convenient factory method that we can use to fluently create JSON objects. In our code, we have used it to produce two instances of <kbd>javax.json.JsonObject</kbd>. The first one has been serialized as a string and sent to our <kbd>CustomerEndpoint</kbd> via an HTTP <kbd>POST</kbd> call. The second one has been adopted to update the customer via the HTTP <kbd>PUT</kbd> call.</p>
<p class="mce-root">You can package and test the application with the following command:</p>
<pre class="mce-root"><strong>$ mvn package</strong></pre>
<p class="mce-root">The output will show the test result, which should be successful:</p>
<pre class="mce-root"><strong>[INFO] Results:</strong><br/><strong>[INFO] Tests run: 1, Failures: 0, Errors: 0, Skipped: 0</strong></pre>
<p>The <kbd>testCustomerService</kbd> method completed successfully. Now that we have a tested REST application, we'll learn how to get our application running in a browser.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Running the example</h1>
                </header>
            
            <article>
                
<p class="mce-root">Now that the full project is at our fingertips, let's see it in action! You can start the application with the following command:</p>
<pre class="mce-root"><strong>$ mvn quarkus:dev</strong></pre>
<p class="mce-root">Then, go to the home page at <kbd>http://localhost:8080</kbd>. You should be able to see the following UI, where you can add new customers:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/2063641a-ff2f-462e-9c0d-b51c8dae5814.png" style=""/></div>
<div class="packt_tip">As you already know, the embedded Vert.x server will serve content from under the root context. If you want to vary this, you can configure the <kbd>quarkus.http.root-path</kbd> key in <kbd>application.properties</kbd> to set the context path.</div>
<p><span>Once you have some data, other actions (such as</span><span> </span><span class="packt_screen">Edit </span><span>and </span><span class="packt_screen">Delete</span><span>) will be available:</span></p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/3cd1c02c-5776-4c27-a149-b851814d1b73.png" style=""/></div>
<p><span>Cool! You can try editing and deleting data to verify that all the REST methods work properly. Now, we will learn how to deploy our application on Minishift.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Running our application on Minishift</h1>
                </header>
            
            <article>
                
<p class="mce-root">Start your Minishift environment as usual and execute the following command to build the native executable Docker image of your application and deploy it in a Pod:</p>
<pre class="mce-root"><strong>$ mvn package -Pnative -Dnative-image.docker-build=true</strong></pre>
<p>Building the native image of your application will take a minute or so. Next, we will upload the application as a binary build into a Minishift namespace. You should already be familiar with these steps, so we will just include the script to be executed, along with some inline comments. Execute each line and verify that the output is successful for all the commands:</p>
<pre>#Create a new Project named quarkus-customer-service<br/><strong>$ oc new-project quarkus-customer-service</strong><br/><br/># Binary Build definition <br/><strong>$ oc new-build --binary --name=quarkus-customer-service -l app=quarkus-customer-service</strong><br/><br/># Add the dockerfilePath location to our Binary Build<br/><strong>$ oc patch bc/quarkus-customer-service -p '{"spec":{"strategy":{"dockerStrategy":{"dockerfilePath":"src/main/docker/Dockerfile.native"}}}}'</strong><br/><br/># Uploading directory "." as binary input for the build<br/><strong>$ oc start-build quarkus-customer-service --from-dir=. --follow</strong><br/><br/># Create a new application using as source the Binary Build<br/><strong>$ oc new-app --image-stream=quarkus-customer-service:latest</strong><br/><br/># Create a Route for external clients<br/><strong>$ oc expose svc/quarkus-customer-service</strong></pre>
<p class="mce-root">Now, you should be able to see the Pod where your application is running in the <span class="packt_screen">Overview</span> panel, which can be reached through the <span class="packt_screen">Route - External Traffic</span> link: <span class="packt_screen">http://quarkus-customer-service-quarkus-customer-service.192.168.42.53.nip.io</span> (the actual route address depends on the IP address that's been assigned to your environment):</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/78836d82-1c4b-45ef-bb7c-d06ea32f4ddb.png"/></div>
<p class="mce-root">By clicking on the <span class="packt_screen">Route - External Traffic</span> link, you will be able to verify that your application works in a Kubernetes environment, just like your local copy does.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Configuring Cross-Origin Resource Sharing in Quarkus</h1>
                </header>
            
            <article>
                
<p>In this chapter, we have used JavaScript to drive a request into Quarkus' service. In a more complex scenario where your JavaScript code is deployed in its own service on a distinct host or context, you will have to implement <strong>Cross-Origin Resource Sharing</strong> (<strong>CORS</strong>) to make it work. In a nutshell, CORS allows web clients to make HTTP requests to servers hosted on different origins. By <strong>origin</strong>, we mean a combination of the URI scheme, hostname, and port number.</p>
<p>This is especially challenging for client-side languages such as JavaScript because all modern browsers require a same-origin policy for scripting languages.</p>
<p>To make this work, we need to put our server applications in charge of deciding who can make requests and what type of requests are allowed in using HTTP headers. In practice, when the server receives a request from a different origin, it can reply and state which clients are allowed to access the API, which HTTP methods or headers are allowed, and finally whether cookies are allowed in the request.</p>
<p>How does that translate into Quarkus configurations? As you may have guessed, the configuration has to be applied to the <kbd>application.properties</kbd> file, under the <kbd>quarkus.http.cors</kbd> namespace. The following is a sample configuration that allows CORS for all domains, all HTTP methods, and all common headers:</p>
<pre>quarkus.http.cors=true<br/>quarkus.http.cors.origins=*<br/>quarkus.http.cors.methods=GET,PUT,POST,DELETE, OPTIONS<br/>quarkus.http.cors.headers=X-Custom,accept, authorization, content-type, x-requested-with<br/>quarkus.http.cors.exposed-headers=Content-Disposition</pre>
<p>In real-world scenarios, you would probably set the list of allowed origins to the domain asking to connect remotely, as follows:</p>
<pre>quarkus.http.cors.origins=http://custom.origin.com</pre>
<p>Now that we've clarified this, we can look at another example where we'll use a Java Enterprise component, such as <kbd>WebSocket</kbd>, to reach our Quarkus service.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Adding Enterprise web components</h1>
                </header>
            
            <article>
                
<p>In our customer service example, the frontend application used a JavaScript structural framework (AngularJS) to test our application. Now, we will consider a different use case: a new external service is going to connect to our application using a different protocol stack. Besides JAX-RS endpoints, Quarkus has native support for the <kbd>WebSocket</kbd> technology that runs in the embedded Undertow web server. Therefore, in this example, we will add a <kbd>WebSocket</kbd> endpoint to our existing application. This will be paired with another <kbd>WebSocket</kbd> running in a different application.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Introducing WebSockets</h1>
                </header>
            
            <article>
                
<p>First off, let's briefly introduce new components for our application. <kbd>WebSocket</kbd>, as defined by its enterprise specification, is an API that establishes <strong>socket</strong> connections between a browser and a server endpoint. This is pretty much similar to standard TCP sockets due to its persistent connection between the client and the server, where both parties can start sending data at any time.</p>
<p>Typically, you would open a <kbd>WebSocket</kbd> connection simply by calling the <kbd>WebSocket</kbd> constructor in your JavaScript code:</p>
<pre>var connection = new WebSocket('ws://localhost:8080/hello');</pre>
<div class="packt_tip">Notice the URL schema for <kbd>WebSocket</kbd> connections (<kbd>ws:</kbd>). We also have <kbd>wss:</kbd> for secure <kbd>WebSocket</kbd> connections, which is used in the same way as <kbd>https:</kbd> is for secure HTTP connections.</div>
<p>We can attach some event handlers to the connection to help us determine when the connection status is open, receiving messages, or when errors occur.</p>
<p>We can declare a Java class <kbd>WebSocket</kbd> server endpoint on the server-side by annotating it with <kbd>@ServerEndpoint</kbd>. The URI where the endpoint is deployed needs to be specified as well, as shown in the following example:</p>
<pre>@ServerEndpoint(value = "/hello")<br/>public class WebSocketEndpoint {<br/>  <br/>     @OnOpen<br/>     public void onOpen(Session session) throws IOException {<br/>         // Establish connection<br/>     }<br/>  <br/>     @OnMessage<br/>     public void onMessage(Session session, Message message) throws <br/>    IOException {<br/>         // Handle Websocket messages<br/>     }<br/>  <br/>     @OnClose<br/>     public void onClose(Session session) throws IOException {<br/>     }<br/>  <br/>     @OnError<br/>     public void onError(Session session, Throwable throwable) {<br/>     }<br/>}</pre>
<p>In the next section, we will be adding a <kbd>WebSocket</kbd> layer to our existing project and then creating another thin project to remotely access <kbd>WebSocket</kbd> and add new customers.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Building a project that uses Websockets</h1>
                </header>
            
            <article>
                
<p>You will find two distinct projects within the <kbd>Chapter04/customer-service/websockets</kbd> folder in this book's GitHub repository:</p>
<ul>
<li>An updated <kbd>customer-service</kbd> project that ships with a <kbd>WebSocket</kbd> endpoint</li>
<li>A project called <kbd>customer-service-fe</kbd> that features a minimal JavaScript frontend for our <kbd>WebSocket</kbd> application</li>
</ul>
<p>You should import both projects into your IDE before moving on.</p>
<p>First, let's discuss the <kbd>customer-service</kbd> project. The main enhancement we have added is a <kbd>WebSocket</kbd> endpoint, which is in charge of inserting a new customer (using the <kbd>CustomerRepository</kbd> bean) and returning a tabular view of our customers. The following is the content of the <kbd>WebsocketEndpoint</kbd> class:</p>
<pre>@ServerEndpoint(value="/customers", encoders = {MessageEncoder.class})<br/> <br/>public class WebsocketEndpoint {<br/>     @Inject<br/>     CustomerRepository customerRepository;<br/><br/>     public List&lt;Customer&gt;  addCustomer(String message, Session <br/>     session) {<br/>        Jsonb jsonb = JsonbBuilder.create();<br/><br/>        Customer customer = jsonb.fromJson(message, Customer.class);<br/>        customerRepository.createCustomer(customer);<br/>        return customerRepository.findAll();<br/>     }<br/>     @OnOpen<br/>     public void myOnOpen(Session session) {<br/>         System.out.println("WebSocket opened: " + session.getId());<br/>     }<br/>     @OnClose<br/>     public void myOnClose(CloseReason reason) {<br/>         System.out.println("Closing a due to " + <br/>          reason.getReasonPhrase());<br/>     }<br/>     @OnError<br/>     public void error(Throwable t) {<br/> <br/>     }<br/> <br/> }</pre>
<p>There are two things to notice here, as follows:</p>
<ul>
<li>The method tagged with <kbd>@OnMessage</kbd> receives the customer to be added in JSON format as input and returns an updated list of customers.</li>
<li>This class uses an <strong>encoder</strong> in order to customize the message that's returned to the client. An encoder takes a Java object and produces its serialized representation, which can then be transmitted to the client. For example, an encoder is typically in charge of producing JSON, XML, and binary representations. In our case, it encodes the customer list in JSON format.</li>
</ul>
<p>Now, let's take a look at the <kbd>MessageEncoder</kbd> class:</p>
<pre>public class MessageEncoder implements Encoder.Text&lt;java.util.List&lt;Customer&gt;&gt;  {<br/> <br/>     @Override<br/>     public String encode(List&lt;Customer&gt; list) throws EncodeException {<br/>         JsonArrayBuilder jsonArray = Json.createArrayBuilder();<br/>         for(Customer c : list) {<br/>             jsonArray.add(Json.createObjectBuilder()<br/>                     .add("Name", c.getName())<br/>                     .add("Surname", c.getSurname()));<br/>         }<br/>         JsonArray array = jsonArray.build();<br/>         StringWriter buffer = new StringWriter();<br/>         Json.createWriter(buffer).writeArray(array);<br/>         return buffer.toString();<br/>     }<br/> <br/>     @Override<br/>     public void init(EndpointConfig config) {<br/>         System.out.println("Init");<br/>     }<br/> <br/>     @Override<br/>     public void destroy() {<br/>         System.out.println("destroy");<br/>     }<br/> <br/>}</pre>
<p>As you can see, an <kbd>Encoder</kbd> must implement either of the following interfaces:</p>
<ul>
<li><kbd>Encoder.Text&lt;T&gt;</kbd> for text messages</li>
<li><kbd>Encoder.Binary&lt;T&gt;</kbd> for binary messages</li>
</ul>
<p>In our case, <kbd>List&lt;Customer&gt;</kbd> is received as a generic type in the <kbd>encode</kbd> method and transformed into a JSON string array.</p>
<p>To be compiled, our project needs the <kbd>quarkus-undertow-websockets</kbd> extension, which can be added manually into the <kbd>pom.xml</kbd> file. Alternatively, you can let the Maven plugin do it for you with the following command:</p>
<pre><strong>$ mvn quarkus:add-extension -Dextensions="quarkus-undertow-websockets"</strong></pre>
<p>You will see the following output on your console, which confirms that the extension has been added to our configuration:</p>
<pre>Adding extension io.quarkus:quarkus-undertow-websockets</pre>
<p>The server project is now complete. You can compile it and run it with the following command:</p>
<pre><strong>$ mvn compile quarkus:dev</strong></pre>
<p>Now, let's create a new frontend project with a thin <kbd>WebSocket</kbd> JavaScript client.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Creating a WebSocket client project</h1>
                </header>
            
            <article>
                
<p><kbd>WebSocket</kbd> clients, just like their server counterparts, can be written in many different languages. Since modern browsers have native support for <kbd>WebSocket</kbd>, we will write a simple JavaScript client so that we don't have to install any additional tools or SDKs to run our example.</p>
<p>Within the <kbd>customer-service-fe</kbd> folder, you will find the frontend project that can be used to reach our <kbd>WebSocket</kbd> example.</p>
<p>Our project contains a landing page named <kbd>index.html</kbd>, which is served when we request the root web context of our application. Within this page, we have included an HTML form and a table to display a list of customers:</p>
<pre>&lt;html&gt;<br/> &lt;head&gt;<br/>     &lt;meta http-equiv="content-type" content="text/html; charset=ISO-<br/>      8859-1"&gt;<br/>     &lt;link rel="stylesheet" type="text/css" href="stylesheet.css" <br/>      media="screen" /&gt;<br/>     &lt;script src="https://ajax.googleapis.com/ajax/libs/jquery/2.1.1<br/>        /jquery.min.js"&gt;&lt;/script&gt;<br/>     &lt;script src="functions.js"&gt;&lt;/script&gt;<br/> &lt;/head&gt;<br/> <br/> &lt;meta charset="utf-8"&gt;<br/> &lt;body&gt;<br/> &lt;h1 style="text-align: center;"&gt;Connect to Quarkus Websocket Endpoint&lt;/h1&gt;<br/> &lt;br&gt;<br/> <br/> &lt;div&gt;<br/>     <br/>     &lt;form id="form1" action=""&gt;<br/>         &lt;div&gt;&lt;h3&gt;Enter Customer&lt;/h3&gt;&lt;/div&gt;<br/>         &lt;div class="divTableRow"&gt;<br/>             &lt;div class="divTableCell"&gt;Name:&lt;/div&gt;<br/>             &lt;div class="divTableCell"&gt;&lt;input type="text" <br/>              placeholder="Name" name="name" size="60"/&gt;&lt;/div&gt;<br/>         &lt;/div&gt;<br/>         &lt;div class="divTableRow"&gt;<br/>             &lt;div class="divTableCell"&gt;Surname:&lt;/div&gt;<br/>             &lt;div class="divTableCell"&gt;&lt;input type="text" <br/>              placeholder="Surname" name="surname"  <br/>              size="60"/&gt;&lt;/div&gt;<br/>         &lt;/div&gt;<br/> <br/>         &lt;br/&gt;<br/>         &lt;input onclick="send_message()" value="Insert" type="button" <br/>          class="myButton"&gt;<br/>     &lt;/form&gt;<br/>     &lt;br/&gt;<br/> <br/> &lt;/div&gt;<br/> <br/> &lt;table id="customerDataTable" class="blueTable" /&gt;<br/> &lt;div id="output"&gt;&lt;/div&gt;<br/> &lt;/body&gt;<br/>&lt;/html&gt;</pre>
<p>The connection to the <kbd>WebSocket</kbd> endpoint takes place in an external JavaScript file named <kbd>function.js</kbd> (you can find this in the <kbd>customer-service-fe/src/main/resources/META-INF/resources</kbd> folder in this book's GitHub repository). Then following is the content of this file:</p>
<pre>var wsUri = "ws://localhost:8080/customers";<br/><br/>function init() {<br/>     output = document.getElementById("output");<br/>}<br/> <br/>function send_message() {<br/>     websocket = new WebSocket(wsUri);<br/>     websocket.onopen = function(evt) {<br/>         onOpen(evt)<br/>     };<br/>     websocket.onmessage = function(evt) {<br/>         onMessage(evt)<br/>     };<br/>     websocket.onerror = function(evt) {<br/>         onError(evt)<br/>     };<br/>}<br/> <br/>function onOpen(evt) {<br/>     doSend(name.value);<br/>}<br/> <br/>function onMessage(evt) {<br/>     buildHtmlTable('#customerDataTable', evt.data);<br/>}<br/> <br/>function onError(evt) {<br/>     writeToScreen('&lt;span style="color: red;"&gt;ERROR:&lt;/span&gt; <br/>      ' + evt.data);<br/>}<br/> <br/>function doSend(message) {<br/>     var json = toJSONString(document.getElementById("form1"));<br/>     websocket.send(json);<br/> <br/>}</pre>
<p>As you can see, there are several callback methods (<kbd>onOpen</kbd>, <kbd>onMessage</kbd>, <kbd>onError</kbd>) that are coupled with server events once the connection is established. Here, we will be adding a new customer, serialized as a JSON string, in the <kbd>doSend</kbd> method, while the <kbd>onMessage</kbd> callback method will receive the list of customers that was produced by our <kbd>WebSocket</kbd> encoder. This data will eventually be included in an HTML table.</p>
<p>You can run the project with the following command:</p>
<pre><strong>$ mvn compile quarkus:dev -Dquarkus.http.port=9080 -Ddebug=6005</strong></pre>
<p>As you can see, we have shifted the HTTP and debug port with an offset of <kbd>1000</kbd> so that it doesn't conflict with the <kbd>customer-service</kbd> project.</p>
<p>Browsing to <kbd>http://localhost:9080</kbd> will let you into the <kbd>WebSocket</kbd> client application. Add some sample data to verify that customers can be included in the table:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/27c0ff2a-9cbd-476c-8657-ef9151bfed99.png" style=""/></div>
<p>Verify that the same data is also displayed in the AngularJS frontend, which is available at <kbd>http://localhost:8080</kbd>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Adding an AJAX handler</h1>
                </header>
            
            <article>
                
<p>Our JavaScript client is primarily required when it comes to testing our <kbd>WebSocket</kbd> example. However, one more enhancement you will find in this project is a Java Servlet that will let you remove any hardcoded links to your backend so that both services can still communicate as we move our example to a different machine or port.</p>
<p>The following Servlet determines server endpoint information from an environment variable named <kbd>CUSTOMER_SERVICE</kbd> by using the <kbd>ws://localhost:8080/customers</kbd> string:</p>
<pre>@WebServlet("/AjaxHandler")<br/>public class AjaxHandler extends HttpServlet {<br/> <br/>     public AjaxHandler() {<br/>         super();<br/>     }<br/> <br/>     protected void doGet(HttpServletRequest request, <br/>      HttpServletResponse response)<br/>      throws ServletException, IOException {<br/>         String endpoint = System.getenv("CUSTOMER_SERVICE")<br/>         != null ? System.getenv("CUSTOMER_SERVICE") : <br/>         "ws://localhost:8080/customers";<br/> <br/>         PrintWriter out = response.getWriter();<br/>         out.println(endpoint);<br/>         out.flush();<br/> <br/>     }<br/> <br/>     protected void doPost(HttpServletRequest request, <br/>         HttpServletResponse response) throws<br/>         ServletException, IOException {<br/>         doGet(request, response);<br/>     }<br/>}</pre>
<p>This change needs to be reflected in our JavaScript client so that it doesn't use a hardcoded endpoint for our web socket. In the final version of the <kbd>function.js</kbd> file, you will find the following JavaScript function, which queries our Servlet via AJAX:</p>
<pre>var wsUri = "";<br/>function callAjax() {<br/> <br/>     httpRequest = new XMLHttpRequest();<br/> <br/>     if (!httpRequest) {<br/>         console.log('Unable to create XMLHTTP instance');<br/>         return false;<br/>     }<br/>     httpRequest.open('GET', 'AjaxHandler');<br/>     httpRequest.responseType = 'text';<br/>     httpRequest.send();<br/>     httpRequest.onreadystatechange = function() {<br/>         if (httpRequest.readyState === XMLHttpRequest.DONE) {<br/>             if (httpRequest.status === 200) {<br/>                 <strong>wsUri = httpRequest.response;</strong><br/>             } else {<br/>                 console.log('Something went wrong..!!');<br/>             }<br/>         }<br/>     }<br/>}</pre>
<p>This function is called when the HTML page is loaded:</p>
<pre><span>&lt;body </span><span>onload=</span><span>"callAjax()"</span><span>&gt;</span></pre>
<p>Now, start the server from the same shell so that it reads the environment variable:</p>
<pre><strong>$ mvn quarkus:dev</strong></pre>
<p>Now, go to <kbd>http://localhost:9080</kbd> and verify that the output produced by the <kbd>WebSocket</kbd> request is the same as when the server endpoint address was statically defined.</p>
<p>You can take this example one step further by varying <kbd>quarkus.http.port</kbd> in your <kbd>customer-service</kbd> application. For example, you could set it to <kbd>8888</kbd>:</p>
<pre><strong>$ mvn quarkus:dev -Dquarkus.http.port=8888</strong></pre>
<p><kbd>customer-service-fe</kbd> will be able to connect to the <kbd>WebSocket</kbd> endpoint once you have set the <kbd>CUSTOMER_SERVICE</kbd> environment variable accordingly:</p>
<pre><strong>$ export CUSTOMER_SERVICE=ws://localhost:8888/customers</strong></pre>
<p>Great! In this section, we removed any static hardcoded information from our client application, which now uses an environment variable to reach out to the customer service.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>In this chapter, we looked at the different paths we can take to add web content to our Quarkus applications. First, we learned how to create a CRUD in-memory application to manage a set of Java objects. The example application was then accessed by a JavaScript layer (AngularJS) with some peculiar APIs to handle REST calls. We also looked at some configuration parameters that are needed when we want to enable CORS in Quarkus projects. Next, we added a <kbd>WebSocket</kbd> layer to introduce full-duplex communication between the initial project and the client frontend.</p>
<p>By completing this chapter, you now know how to use the embedded Vert.x and Undertow server to leverage REST APIs (<kbd>quarkus-resteasy</kbd>) and <kbd>WebSocket</kbd>/Servlet APIs (<kbd>quarkus-undertow-websockets</kbd>).</p>
<p>In the next chapter, we will add database storage for our application using the Hibernate ORM and Hibernate Panache extensions.</p>


            </article>

            
        </section>
    </body></html>