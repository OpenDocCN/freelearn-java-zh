- en: Chapter 6. Implicits
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we covered the `type` system and polymorphism. We also
    covered the different types of variance which provide ways to constrain parameterized
    types. Finally, we covered some advanced `types` such as abstract type members,
    option, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will cover implicit parameters and implicit conversions.
    We'll be learning about how they work, how to use them, and what kind of benefits
    and perils they provide.
  prefs: []
  type: TYPE_NORMAL
- en: When using a third-party library in your code, you usually have to take its
    code as it is. This can make some libraries unpleasant to deal with. It can be
    either the code style that differs from the one in your code base or simply some
    functionality that the library lacks that you can't elegantly supply.
  prefs: []
  type: TYPE_NORMAL
- en: Some languages have come up with solutions to alleviate this problem. Ruby has
    modules, Smalltalk allows packages to add to each other's classes, and C# 3.0
    has static extension methods.
  prefs: []
  type: TYPE_NORMAL
- en: Scala has implicit parameters and conversions. When used in a controlled manner,
    implicits can make working with external libraries more pleasant, and also enable
    some elegant patterns that you can use in your own code.
  prefs: []
  type: TYPE_NORMAL
- en: 'By the end of this chapter, you will be able to:'
  prefs: []
  type: TYPE_NORMAL
- en: Describe implicits and how the Scala compiler handles them
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Explain the design patterns that implicits enable
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Analyze the common issues that may arise by overusing implicits
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implicit Parameters and Implicit Conversions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Scala has implicit parameters and conversions. When used in a controlled manner,
    implicit can make working with external libraries more pleasant, and also enable
    some elegant patterns that you can use in your own code.
  prefs: []
  type: TYPE_NORMAL
- en: Implicit Parameters
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Implicit parameters** are a way to make the compiler automatically fill in
    some arguments when a method call misses them for some (or all) of the (implicit)
    parameters. The compiler will look for definitions labelled implicit of the required
    types. For example, suppose you want to write a program that prompts the user
    for some action, after displaying a message. You want to customize both the message
    and the string that appear on the prompt. We can assume that the prompt string
    will have a more default value than the message, so one way to implement it using
    implicit parameters is like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'With the previous implementation, you can call the message function, supplying
    an argument to the prompt parameter explicitly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: However, if we want to reuse the prompt in different message calls, we can create
    a default object.
  prefs: []
  type: TYPE_NORMAL
- en: '`default`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'We can then bring that `default` into scope when we use the message method
    and avoid having to explicitly supply the prompt parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: There can be only one implicit parameter list per method, but it can have multiple
    parameters. The implicit parameter list must be the last parameter list of the
    function.
  prefs: []
  type: TYPE_NORMAL
- en: 'The eligible arguments for an implicit parameter are identifiers that can be
    accessed at the point of the method call without a prefix and that denote an implicit
    definition or an implicit parameter, and members of companion modules of the implicit
    parameter''s type that are labelled implicit. For example, in the previous example,
    if you were to put the `defaultPrompt` implicit in the companion object of `Prompt`,
    it wouldn''t be necessary to import `Prompt` to put `defaultPrompt` into scope
    on calls to message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Implicit Conversions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Implicit** **conversions** provide a way to transparently convert between
    `types`. Implicit conversions are useful when you need a `type` that you don''t
    control (from an external library, for example) to adhere to a specified interface.
    For example, suppose you want to handle an integer as a traversable, so you can
    iterate through its digits. One way to do this is by supplying an implicit conversion:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The `intToIterable` implicit conversion works as a normal method. The special
    thing is the implicit keyword at the start of the definition. You can still apply
    the conversion explicitly or leave it out and get the same behavior:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The best thing about implicit conversions is that they support conversions
    for a type that''s needed at some point in the code. For example, if you have
    the following function, which returns an ordered `Seq` from a `Traversable`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can pass an `Int` to `orderedSeq`, since there's an implicit conversion
    from `Int` to `Traversable[Int]`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: When used indiscriminately, implicits can be dangerous, as they can enable runtime
    errors in locations where we would preferably want the compiler to not compile
    the code.
  prefs: []
  type: TYPE_NORMAL
- en: You should avoid implicit conversions between common types. The Scala compiler
    signals implicit conversions as dangerous by warning when you define one by default.
  prefs: []
  type: TYPE_NORMAL
- en: As seen before, implicit conversions enable syntax-like extensions to the language.
    The pattern is common throughout the standard library and libraries in the Scala
    ecosystem. The pattern is usually called "rich wrappers", so when you see a class
    named `RichFoo`, it is likely that it is adding syntax-like extensions to the
    Foo type.
  prefs: []
  type: TYPE_NORMAL
- en: 'To provide allocation-free extension methods, you can use implicit classes
    combined with value classes. For example, if you have the following `RichInt`
    definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: A call to `3.toHexString`, for example, will result in a method call in a `static`
    object ( `RichInt$.MODULE$.extension$toHexString(3)`) rather than a method call
    on a newly instantiated one.
  prefs: []
  type: TYPE_NORMAL
- en: Implicit Resolution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It is important to know where the compiler looks for implicits and, even more
    importantly, how it decides which implicit to use in situations of apparent ambiguity.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'For more information on implicit resolution, refer to: [https://docs.scala-lang.org/tutorials/FAQ/finding-implicits.html](https://docs.scala-lang.org/tutorials/FAQ/finding-implicits.html).'
  prefs: []
  type: TYPE_NORMAL
- en: 'For choosing the most specific implicit definition based on the rules of static
    overloading resolution, refer to: [http://scala-lang.org/files/archive/spec/2.11/06-expressions.html](http://scala-lang.org/files/archive/spec/2.11/06-expressions.html).'
  prefs: []
  type: TYPE_NORMAL
- en: The rules of implicit resolution are a bit challenging to remember, so experimenting
    with them can give you more intuition over the Scala compiler.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following list defines where the compiler looks for implicits:'
  prefs: []
  type: TYPE_NORMAL
- en: Implicits which are defined in the current scope
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Explicit Imports
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Wildcard Imports
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Companion Objects of Type
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implicit Scope of an Argument's Type
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implicit Scope of Type Arguments
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Outer Objects for Nested Types
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Activity: Creation of Extension Methods'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this activity, we'll be creating extension methods for the `Int` type by
    relying on implicit conversions.
  prefs: []
  type: TYPE_NORMAL
- en: Start by defining a new class, `RichInt`, which will implement your desired
    methods.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create an implicit conversion from `Int` to `RichInt`. You can either create
    an implicit method or an implicit value class. Since it's important to avoid the
    runtime overhead, an implicit value class is advisable.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Implement the methods `square` and `plus`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Make sure the implicit conversion is in scope, and experiment with calling `square`
    and `plus` on values of type `Int`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This section covered implicit parameters and implicit conversions. We saw how
    to enable elegant extension methods for your code. We also had a look at how the
    Scala compiler resolves implicits.
  prefs: []
  type: TYPE_NORMAL
- en: Ad Hoc Polymorphism and Type Classes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we'll be exploring ad hoc polymorphism, but through the usage
    of type classes.
  prefs: []
  type: TYPE_NORMAL
- en: Types of Polymorphism
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In computer science, polymorphism is the provision of a single interface to
    entities of different types. Polymorphism consists of three types: subtyping,
    parametric polymorphism, and ad hoc polymorphism.'
  prefs: []
  type: TYPE_NORMAL
- en: Subtyping enables polymorphism by having different implementations of the same
    method (but keeping the interface) in the different subclasses. Parametric polymorphism
    enables polymorphism by allowing code to be written without the mention of a specific
    type. For example, when you operate over a generic `List`, you're applying parametric
    polymorphism. Ad hoc polymorphism enables polymorphism by allowing different and
    heterogeneous implementations depending on specified types. Method overloading
    is an example of ad hoc polymorphism.
  prefs: []
  type: TYPE_NORMAL
- en: Type Classes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Type classes are a construct that enable ad hoc polymorphism. They originally
    appeared in Haskell, which has native support for them, but transitioned to Scala
    through the use of implicits.
  prefs: []
  type: TYPE_NORMAL
- en: At its core, a `type` class is a class with a `type` parameter that aims to
    bridge type hierarchies. That is, we want to provide behavior to a type hierarchy
    by parameterizing our `type` class and providing specific implementations for
    concrete types. Type classes provide an easy way to extend libraries without touching
    existing code.
  prefs: []
  type: TYPE_NORMAL
- en: 'As a running example throughout this section, consider the following implementation
    of JSON:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'We will be introducing a type class called `JsonWriter[A]`, whose interface
    has a single method `write`, which, given an `A`, returns a `JsValue`. Let''s
    define `JsonWriter` and provide two implementations of it, one for `Int` and another
    for `String`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: We can use these specific implementations of `JsonWriter` to convert `Ints`
    and Strings to JSON. For example, we can call `IntJsonWriter.write(4)` and `StringJsonWriter.write("Hello
    World")`. However, we don't want to be calling writers explicitly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead of calling `JsonWriters` explicitly, we introduce the `toJson` method,
    which is capable of converting a type to JSON, provided that there is a `JsonWriter`
    in the scope:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: We have now introduced ad hoc polymorphism in the `toJson` function. Based on
    the type of value provided to `toJson`, we have different behaviors for the `toJson`
    function, controlled by the `JsonWriters` available in scope. The matter of scope
    is important. Recall that there is precedence to the implicit resolution. As such,
    library authors can provide their own default implementations for their type classes,
    but you can always override it in your client code while keeping the same interface.
  prefs: []
  type: TYPE_NORMAL
- en: Context Bounds and Implicitly
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Context bounds** are syntactic sugar that reduce verbosity when you need
    to pass implicits around. By using a context bound, you reduce the need of an
    implicit parameter list. However, when using a context bound, you lose access
    to the implicit argument used when calling the method. To provide access to it,
    you can use the `implicitly` function. Implicitly provides access to the implicit
    of the requested type in scope. Its implementation is simply this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Type Classes in the Standard Library
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The type class pattern is heavily used in the Scala standard library. Prime
    examples of its usage are the `Ordering` type classes previously introduced and
    the `CanBuildFrom` type class, which represents builder factories for Scala collections.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Please take a look at the `Ordering` and `CanBuildFrom` type classes on your
    own. A good overview of the `CanBuildFrom` type class can be obtained from the
    following guide: [http://docs.scala-lang.org/overviews/core/architecture-of-scala-collections.html](http://docs.scala-lang.org/overviews/core/architecture-of-scala-collections.html).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Activity: Implementing Type Classes to Support Conversion'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this activity, we'll be implementing `type` classes to support conversions
    to `JsValue` for common Scala types. Consider the `JsValue` ADT that was introduced
    in the beginning of the section.
  prefs: []
  type: TYPE_NORMAL
- en: 'Start by defining, if you haven''t already, the `toJson` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Implement `JsonWriter` for `Int`, `String,` and `Boolean`. The implementation
    for `Int` and `String` was already provided. A good place to put those implementations,
    according to the implicit resolution rules previously introduced, is in the companion
    object of `JsonWriter`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Implement `JsonWriter` for `List`, `Set,` and `Map`. In these generic collections,
    note that you can provide a `JsonWriter[List[A]]`, for example, if you have a
    `JsonWriter` for `A`. Not all maps are convertible to JSON, so only provide a
    `Js``onWriter[Map[String, A]]`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we covered implicit parameters and implicit conversions. We
    saw how to enable elegant extension methods for your code. We also had a look
    at how the Scala compiler resolves implicits. Finally, we covered how implicits
    work, how to use them, and what kind of benefits they provide.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we'll cover the core concepts of functional programming
    such as Pure functions, immutability, and higher-order functions. We'll build
    upon this understanding and introduce some of the design patterns that are prevalent
    in large functional programs that you'll no doubt run into once you start to use
    Scala libraries that focus on functional programming. Finally, we'll cover two
    popular functional programming libraries called `Cats` and `Doobie`, and use them
    to write some interesting programs.
  prefs: []
  type: TYPE_NORMAL
