- en: '6'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Concurrency Design Patterns
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Previous chapters on creational, structural, and behavioral patterns proposed
    a design that concerns the base code. Their main focus was on the maintainable
    base code that operates in the main single application thread. In other words,
    the generated byte code is executed in a defined sequence to achieve the desired
    results.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: Nowadays, business requirements have shifted the application expectations described
    by the GoF’s book over the years more and more within a concurrent and parallel
    world. This has been succeeded by a massive improvement in hardware.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: 'The Java platform provides concurrency functionality under the hood from the
    very beginning. The Flight Recorder tool of Mission Control set helps collect
    data points about thread behavior and displays them visually, improving our awareness
    of application dynamics. In this chapter, we are going to examine some of the
    most common scenarios in the information technology industry:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
- en: Decoupling a method execution with an active object pattern
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Non-blocking tasks using an async method invocation pattern
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Delaying execution until the previous task has been completed with the balking
    pattern
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Providing a unique object instance with a double-checked locking pattern
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using purposeful thread blocking via a read-write lock pattern
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Decoupling the execution logic with the producer-consumer pattern
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Executing isolated tasks with the scheduler pattern
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Effective thread utilization with the thread-pool pattern
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of this chapter, we will have built a solid foundation for understanding
    the concurrency possibilities of the Java platform and starting to apply them
    effectively.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You can find the code files for this chapter on GitHub at [https://github.com/PacktPublishing/Practical-Design-Patterns-for-Java-Developers/tree/main/Chapter06](https://github.com/PacktPublishing/Practical-Design-Patterns-for-Java-Developers/tree/main/Chapter06).
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: Decoupling a method execution with an active object pattern
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The active object design pattern separates and defers method execution from
    method invocation by running its own control thread.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: Motivation
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The active object pattern introduces a transparently concurrent model to the
    application. It creates and starts an internal thread that executes the required
    logical, critical section. An active object instance exposes a public interface
    that a client can use to run an encapsulated critical section. An external, client-initiated
    event is queued and ready to execute. The execution step is performed by the internal
    scheduler. The result can be passed to the appropriate handler in a callback style.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: Sample code
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let us introduce an example of a moving vehicle with a radio system (*Example
    6.1*):'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Here''s the output:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Example 6.1 – The SportVehicle instance allows the client to create an event
    by using its public methods
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: 'The newly created abstract class, `MovingVehicle`, defines public methods –
    `move`, `turnOnRadio`, `turnOffRadio`, and `stopVehicle`. In addition to the control
    thread, the class defines a conditional queue for incoming events (*Example 6.2*):'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Example 6.2 – MovingVehicle contains an active flag for purpose of scheduling
    events
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: 'Events in the queue are received and fired based on an internal period. `LinkedBlockingDeque`
    provides additional functions for inserting or removing elements from the top
    or bottom, which is useful when the vehicle needs to be stopped. The `StopVehicle`
    event has priority over the radios (*Example 6.3*):'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Example 6.3 – The received events are added to the queue conditionally
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: 'A lifecycle of the `SportVehicle` instance does not interfere with the main
    application thread. It is predictable and does not block the application (*Figure
    6**.1*):'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.1 – The moving-vehicle thread shows the sequence of commands](img/B18884_06_01.jpg)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
- en: Figure 6.1 – The moving-vehicle thread shows the sequence of commands
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: 'The components introduced in the example seamlessly cooperate (*Figure 6**.2*):'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.2 – The UML class diagram shows the SportVehicle class’s relation
    to the Java concurrency features](img/B18884_06_02.jpg)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
- en: Figure 6.2 – The UML class diagram shows the SportVehicle class’s relation to
    the Java concurrency features
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: Conclusion
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A well-developed active object pattern respects the SOLID design approaches
    because it encapsulates the critical parts and only exposes the control interface
    required. The instance does not interfere with the application and the whole approach
    can be generalized to the desired level. An active object can be a good candidate
    for introducing a concurrency model into an application, but there are a few challenges
    to keep in mind. One of these challenges is the number of possible application
    threads, where a high number can make the application fragile or lead to instability
    as it depends on available resources.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: Let’s explore the asynchronous nature of events in the next section.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: Non-blocking tasks using async method invocation pattern
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The asynchronous method invocation pattern is a way to solve the challenge of
    not penalizing the main process thread with possibly time-consuming tasks.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: Motivation
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Asynchronous method invocation patterns introduce the ability to receive a result
    by a callback from an asynchronously running task without blocking the main process
    thread. The pattern presents the threading model and level of parallelism for
    processing the required task types. The task results are processed by dedicated
    callback handlers and provided to the main process regardless of the task’s execution
    time. These handlers may already belong to the main process.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: Sample code
  id: totrans-45
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let us look at a trivial scenario of several vehicle temperature sensors required
    to provide results to the driver, which is the client (*Example 6.4*):'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Here’s the output:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Example 6.4 – The example task temp:26, is asynchronously executed in thread-0
    thread
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 6.4 – 示例任务 temp:26 在线程-0 线程中异步执行
- en: 'The instance of `TempSensorCallback` that monitors all results resides in the
    `main` process thread (*Figure 6**.3*):'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 监控所有结果的 `TempSensorCallback` 实例位于 `main` 进程线程中（*图 6**.3*）：
- en: '![Figure 6.3 - TemperatoreSensorCallback instance is called asynchronously,
    therefore different thread finish times](img/B18884_06_03.jpg)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.3 - 温度传感器回调实例异步调用，因此不同线程的完成时间不同](img/B18884_06_03.jpg)'
- en: Figure 6.3 - TemperatoreSensorCallback instance is called asynchronously, therefore
    different thread finish times
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.3 - 温度传感器回调实例异步调用，因此不同线程的完成时间不同
- en: '`TempSensorTask` instances are handled by custom `TempSensorExecutor` instances,
    which not only provides control over initiated threads, but can also terminate
    long-running measurements of a particular sensor by providing a task reference.
    The `TempSensorExecutor` instance exposes a measure public method that provides
    a `TempSensorResult` instance of a long-running task (*Example 6.5*):'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '`TempSensorTask` 实例由自定义的 `TempSensorExecutor` 实例处理，它不仅提供了对启动线程的控制，还可以通过提供任务引用来终止特定传感器的长时间运行测量。`TempSensorExecutor`
    实例公开了一个测量公共方法，该方法提供了一个长时间运行任务的 `TempSensorResult` 实例（*示例 6.5*）：'
- en: '[PRE6]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Example 6.5 – Each new thread specific long-term measurement will pass its result
    to the callback handler
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 6.5 – 每个新的特定于线程的长期测量都会将结果传递给回调处理程序
- en: 'The nature of processing the information served by multiple temperature sensors
    is clearly parallel. The asynchronous method invocation patterns provide a very
    small set of classes to solve this challenge (*Figure 6**.4*):'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 处理由多个温度传感器提供的信息的性质显然是并行的。异步方法调用模式提供了一组非常小的类来解决这个挑战（*图 6**.4*）：
- en: '![Figure 6.4 – The UML class diagram draws how data are acquired from temperature
    sensors](img/B18884_06_04.jpg)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.4 – UML 类图展示了如何从温度传感器获取数据](img/B18884_06_04.jpg)'
- en: Figure 6.4 – The UML class diagram draws how data are acquired from temperature
    sensors
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.4 – UML 类图展示了如何从温度传感器获取数据
- en: Conclusion
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 结论
- en: The given examples clearly show how to handle a long-running task with a preliminary
    detachment from the main processing thread. In other words, it is not causing
    by delas. The Java platform provides multiple options to create this pattern.
    One of them is to employ the `Callable` interface and send an instance to the
    `ExecutorService` using its `submit` method. The `submit` method returns a result
    that implements the `Future` interface. The `Future` has similarities to the sample
    `TempSensorResult` instance but does not provide a callback function that needs
    to be handled differently. Another possibility can be explored using `CompletableFuture`,
    which not only exposes the `supplyAsync` method, but also provides many other
    useful functions. All of the suggestions mentioned can be found in the `java.base`
    module and the `java.util.concurren`t package.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 给出的示例清楚地说明了如何通过初步与主处理线程分离来处理长时间运行的任务。换句话说，这不是由延迟引起的。Java 平台提供了多种选项来创建这种模式。其中之一是使用
    `Callable` 接口，并通过其 `submit` 方法将实例发送到 `ExecutorService`。`submit` 方法返回一个实现 `Future`
    接口的结果。`Future` 与示例 `TempSensorResult` 实例有相似之处，但不提供需要不同处理的回调函数。另一种可能性是使用 `CompletableFuture`，它不仅公开了
    `supplyAsync` 方法，还提供了许多其他有用的函数。所有提到的建议都可以在 `java.base` 模块和 `java.util.concurrent`
    包中找到。
- en: The next section shows how to delay the execution of a task until the previous
    one is complete; let’s get to it.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个部分将展示如何延迟任务的执行，直到前一个任务完成；让我们开始吧。
- en: Delay execution until the previous task is completed with the balking pattern
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 balking 模式延迟执行直到前一个任务完成
- en: Sometimes it is required to consider the task state changes to properly execute
    next task and fulfill the goal.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 有时需要考虑任务状态的变化，以便正确执行下一个任务并实现目标。
- en: Motivation
  id: totrans-65
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 动机
- en: Although the instance mutability is not a desirable state, especially not in
    the concurrency field the ability to depend on the object state may come handy.
    The case where multiple threads try to acquire an object to execute its critical
    sections can be limited by the object state. The state can decide whether the
    processing time will be used or not in order to coordinate the resources available.
    For example, a vehicle cannot stop without being in motion.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: Sample code
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Consider the example of one `Vehicle` instance sharing two groups of drivers.
    Although there are multiple groups, only one vehicle can operate at a time (*Example
    6.6*):'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Here’s the output:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Example 6.6 – Driver groups are represented by provided threads created by ExecutorService
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: 'The balking pattern provides a solution in which the critical section of the
    task is executed based on the `Vehicle` instance state represented by the `VehicleState`
    enum (*Example 6.7*):'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Example 6.7 – The usage of the synchronized keyword makes the driver groups
    aware of whether the Vehicle instance is ready to use or not
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: 'The driver group threads are blocked and only one is active at a time (*Figure
    6**.5*):'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.5 – The blue and green colors represent group activity while the
    other is blocked](img/B18884_06_05.jpg)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
- en: Figure 6.5 – The blue and green colors represent group activity while the other
    is blocked
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: 'The example presented requires a very minimal number of created classes, which
    are clearly encapsulated (*Figure 6**.6*):'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.6 – The UML class diagram shows the two most required custom classes,
    Vehicle and VehicleState](img/B18884_06_06.jpg)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
- en: Figure 6.6 – The UML class diagram shows the two most required custom classes,
    Vehicle and VehicleState
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: Conclusion
  id: totrans-82
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The balking pattern is easy to implement in the Java platform. It is important
    to keep the Java memory model in mind in order to properly handle object state
    volatility. It may be particularly useful to consider using atomic types (`AtomicInteger`
    and `AtomicBoolean`, for example), which automatically come with a happens-before
    guarantee. This guarantee is part of the Java memory model to maintain memory
    consistency across the interacting threads, as we learned in [*Chapter 2*](B18884_02.xhtml#_idTextAnchor037),
    *Discovering the Java Platform for Design Patterns*. Another option to consider
    is the `volatile` keyword, which comes with a guarantee of equal-value visibility
    across threads.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: The next section examines guaranteed instance uniqueness – let’s roll.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: Providing a unique object instance with a double-checked locking pattern
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The double-checked locking pattern solves the problem of an application requiring
    only one instance of a particular class at runtime.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: Motivation
  id: totrans-87
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Java platform is multi-threaded by default, as we learned in [*Chapter 2*](B18884_02.xhtml#_idTextAnchor037),
    *Discovering the Java Platform for Design Patterns*. It’s not just the garbage
    collection threads that take care of the main program lifecycle. Different frameworks
    introduce additional tread models, which may have an unintended impact on a class
    institution’s process. A double-checked locking pattern ensures that only one
    instance of a class is present at runtime. This state can become challenging in
    a multi-threaded environment, as it may depend on its implementation.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: Sample code
  id: totrans-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s use a simple `Vehicle` instance to demonstrate the importance of a double-checked
    locking pattern in a multithreading environment. The example presents two different
    implementations of the singleton pattern. `VehicleSingleton` is expected to keep
    its promise due to multiple threads accessing the `getInstance` method (*Example
    6.8*):'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Here’s the output:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Example 6.8 – The VehicleSingleton constructor has been called multiple times,
    which violates the given promise through multiple instantiations (see the hashCode
    values)
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: 'The `ExecutorService` instance provided by `Executors.newFixedThreadPool` receives
    multiple instances of the `Runnable` interface. The `Runnable` method’s implementation
    represents the critical section of the `getInstance` method’s call in both cases
    (*Figure 5**.5*):'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: "![Figure 6.7 – All pool threads continuously execute the getInstance method\
    \ and VehicleSingletonCheck i\uFEFFs cre\uFEFFated only once](img/B18884_06_07.jpg)"
  id: totrans-96
  prefs: []
  type: TYPE_IMG
- en: Figure 6.7 – All pool threads continuously execute the getInstance method and
    VehicleSingletonCheck is created only once
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: 'Both implementations differ in the very small details of the `getInstance`
    method implementation (*Example 6.9*):'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Example 6.9 – The getInstance method’s implementation of VehicleSingletonChecked
    uses a synchronized keyword to ensure the thread stack frame state
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: 'In both cases, the UML diagram remains the same (*Figure 6**.8*):'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.8 – The UML class diagram does not highlight the implementation
    details of the double-checked singleton pattern](img/B18884_06_08.jpg)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
- en: Figure 6.8 – The UML class diagram does not highlight the implementation details
    of the double-checked singleton pattern
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: Conclusion
  id: totrans-104
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This example has shown a possible way to implement a double-check locking pattern.
    The Java platform may also enforce double-checked locking patterns by using an
    `Enum` construct, which provides only one element – its `INSTANCE` object of desired
    type.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: The next section demonstrates how to deal with locking exclusivity.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: Using purposeful thread blocking via a read-write lock pattern
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A concurrent application may consider granting exclusive access to a critical
    section just to update the information of the specific instance. This particular
    challenge can be solved by using a read-write lock pattern.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: Motivation
  id: totrans-109
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The read-write locking pattern introduces natural exclusivity for lock acquisition.
    This context is used to differentiate the whether the critical section can be
    executed. In other words, the write action takes precedence by its nature before
    reading, as the goal of any reader is to get the most accurate and up-to-date
    value possible. Under the hood, this means that all readers are blocked when the
    writer thread is modifying data and unblocked when the writer completes its task.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: Sample code
  id: totrans-111
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Suppose that multiple sensors inside a vehicle require accurate information
    about the temperature value, but there is only one temperature device capable
    of updating the temperature value (*Example 6.10*):'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Here’s the output:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Example 6.10 – The SensorWriter instance that runs its own thread obtains exclusive
    access to the Sensor instance
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: 'Readers continuously read the sensor value without being blocked. The situation
    changes when the writer enters the game – at which point, readers are blocked
    and have to wait for the `SensorWriter` instance to finish (*Figure 6**.9*):'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.9 – Thread activity highlighting writer lock exclusivity when reader
    threads are being blocked](img/B18884_06_09.jpg)'
  id: totrans-118
  prefs: []
  type: TYPE_IMG
- en: Figure 6.9 – Thread activity highlighting writer lock exclusivity when reader
    threads are being blocked
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: 'The critical section is served by two methods, `writeValue` and `readValue`.
    Both belong to the `Sensor` class (*Example 6.11*):'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Example 6.11 – readLock is paused when writeLock is acquired
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: 'It is important to note that lock instances reside in the main thread of execution
    and are acquired by the threads provided by the `ExecutorService` instance (*Figure
    6**.10*):'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.10 – The UML class diagram for a read-write lock pattern](img/B18884_06_10.jpg)'
  id: totrans-124
  prefs: []
  type: TYPE_IMG
- en: Figure 6.10 – The UML class diagram for a read-write lock pattern
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: Conclusion
  id: totrans-126
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The read-write lock is very powerful and can contribute very positively to the
    stability of the application. It clearly separates the participant from the critical
    section code that drives the logic. Each example class can be generalized or adapted
    according to SOLID design principles upon request.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: The JDK defines another approach worth considering for exchanging the sensor
    value. The `java.base` module package, `java.util.concurrent`, contains the `Exchanger`
    class, which provides the required synchronization guarantees.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: Let’s examine another common pattern where the instance is broadcasted to the
    target.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: Decoupling the execution logic with a producer-consumer pattern
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The common industrial scenario represents producing and consuming values without
    blocking the main application thread. The producer-consumer pattern helps to solve
    this challenge by decoupling the logic and separating the lines.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: Motivation
  id: totrans-132
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A common industrial scenario involves producing and consuming values without
    blocking the main execution thread. The producer-consumer pattern is designed
    exactly to rise to the challenge by decoupling the logic and separating the target
    receivers.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: Sample code
  id: totrans-134
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Another scenario is where the vehicle produces multiple events from multiple
    sources and these events need to be broadcasted and delivered to consumers (*Example
    6.12*):'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Here’s the output:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Example 6.12 – Compared to producers, consumers are in the minority, not only
    in terms of quantity but also in terms of available resources
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: 'Each of the `ExecutorService` instances uses a `ProdConThreadFactory` object
    type to provide meaningful thread names (*Figure 6**.11*):'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.11 – Consumers are in the minority and sometimes may be blocked
    as the event storage is full](img/B18884_06_11.jpg)'
  id: totrans-141
  prefs: []
  type: TYPE_IMG
- en: Figure 6.11 – Consumers are in the minority and sometimes may be blocked as
    the event storage is full
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: 'The participant classes are decoupled and ready for extension (*Figure 6**.12*):'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.12 – The UML class diagram shows how event classes are related to
    the internals of the Java platform](img/B18884_06_12.jpg)'
  id: totrans-144
  prefs: []
  type: TYPE_IMG
- en: Figure 6.12 – The UML class diagram shows how event classes are related to the
    internals of the Java platform
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: Conclusion
  id: totrans-146
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the field of distributed systems, the production-consumer approach is widely
    used. It is advantageous for clearly separating and defining groups of event senders
    and receivers. The groups can be placed in different threads according to the
    desired thread model.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: The JDK 19 release comes with the newly added concept of virtual threads. Virtual
    threads attempt to simplify the use of core platform threads by introducing thread-like
    frames, and wrappers. The virtual thread wrappers are scheduled by the JVM to
    run on available platform threads by using newly added executors – for example,
    `Executors.newVirtualThreadPerTaskExecutor`. This approach fulfills the definition
    of the producer-consumer pattern, in which the producer is an application that
    uses new virtual thread executors and the platform consumes scheduled virtual
    threads.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: Let’s uncover the scheduler approach in the next section in more detail.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: Executing isolated tasks with the scheduler pattern
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An application behaving deterministically can play a critical role in its success.
    A scheduler pattern can help to achieve the desired goal.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: Motivation
  id: totrans-152
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Although schedulers are sometimes poorly designed to keep the application busy,
    their main purpose is important. The importance of using patterns comes to light
    more with microservices or distributed approaches in which the system is required
    to behave predictably. The general goal is to determine when a specific task is
    performed so that the underlying resources are properly used or a budget estimate
    can be created for the required resources described in site reliability engineering.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: Sample code
  id: totrans-154
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following example brings us to temperature measurement. Every vehicle contains
    temperature sensors in a mechanical or digital form. Temperature sensors play
    a key role in vehicle operation (*Example 6.13*):'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Here’s the output:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Example 6.13 – The CustomScheduler instance executes a SensorTask instance from
    the blocking queue every 100 milliseconds
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: '`CustomerScheduler` shows a trivial implementation that administers the execution
    process (*Figure 6**.14*):'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.13 – Each task execution has a 100 ms time window allocated](img/B18884_06_13.jpg)'
  id: totrans-161
  prefs: []
  type: TYPE_IMG
- en: Figure 6.13 – Each task execution has a 100 ms time window allocated
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: 'The scheduler instantiation prepares a thread with an active flag to control
    the lifecycle (*Example 6.14*):'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Example 6.14 – CustomScheduler ensures that the time window is maintained
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: 'The task of creating a simple scheduler is trivial, but beyond that, it’s good
    to keep in mind the threading model – as in, where and how execution takes place
    (*Figure 6**.14*):'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.14 – The UML class diagram highlights the CustomScheduler threading
    model](img/B18884_06_14.jpg)'
  id: totrans-167
  prefs: []
  type: TYPE_IMG
- en: Figure 6.14 – The UML class diagram highlights the CustomScheduler threading
    model
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: 'In the case of the scheduler pattern, it is only fair to mention the second
    example. The second example uses the built-in JDK functions and their customizations.
    The planning process is fully managed by the platform. The application example
    is, again, similar to the first example, temperature measurement (*Example 6.15*):'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Here’s the output:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Example 6.15 – The period is set to 100 ms and the SensorTask instance is reused
    for each iteration
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: 'An extended `CustomScheduledThreadPoolExecutor` instance can provide additional
    information based on task execution by overriding an available method such as
    `beforeExecute` or `afterExecute`. Using the JDK internals makes it easy to scale
    a `SensorTask` instance across threads (*Figure 6**.15*):'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.15 – A CustomScheduledThreadPoolExecutor instance facilitates easier
    thread management and easier management of other JDK internals](img/B18884_06_15.jpg)'
  id: totrans-175
  prefs: []
  type: TYPE_IMG
- en: Figure 6.15 – A CustomScheduledThreadPoolExecutor instance facilitates easier
    thread management and easier management of other JDK internals
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: 'Leveraging the JDK internals for scheduling does not require you to create
    a customized solution while gaining better visibility into the scheduling cycle
    (*Figure 6**.16*):'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.16 – The UML class diagram shows the minimal effort required to
    create a custom scheduler with all the internals](img/B18884_06_16.jpg)'
  id: totrans-178
  prefs: []
  type: TYPE_IMG
- en: Figure 6.16 – The UML class diagram shows the minimal effort required to create
    a custom scheduler with all the internals
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: Conclusion
  id: totrans-180
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Both preset examples show possible uses of the scheduler pattern. Using the
    JDK internals has a number of advantages to consider. It gives the platform the
    ability to more efficiently use and optimize available resources, such as the
    dynamic JIT translation we learned about in [*Chapter 2*](B18884_02.xhtml#_idTextAnchor037)*,*
    *Discovering the Java Platform for* *Design Patterns*.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: Effective thread utilization using a thread-pool pattern
  id: totrans-182
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It is not always necessary to create a new thread for each task, as this can
    lead to improper resource usage. A thread-pool pattern may be a good solution
    to this challenge.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: Motivation
  id: totrans-184
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A short-lived task does not need to create a new thread every time it runs,
    because each instantiation of a thread is related to the allocation of underlying
    resources. Wasting resources could result in an application throughput or performance
    penalty. A better option is described by the thread-pool pattern, which defines
    the required number of reusable threads to execute a critical section. Specific
    workers can transparently operate above the critical section code that needs to
    be executed.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: Sample code
  id: totrans-186
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let us imagine again a temperature measurement by sensors with different measurement
    dynamics (*Example 6.16*):'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Here’s the output:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Example 6.16 – The thread pool runs the worker temperature measurement task
    on demand
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: 'A thread pool helps to use and manage created threads so that there is always
    a task to process. This positively affects the application behavior and facilitates
    planning based on the resources available (*Figure 6**.17*):'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.17 – The behavior of the thread pool shows the usage of the created
    thread](img/B18884_06_17.jpg)'
  id: totrans-193
  prefs: []
  type: TYPE_IMG
- en: Figure 6.17 – The behavior of the thread pool shows the usage of the created
    thread
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: 'The core example element is `SensorWorker`. The worker implements a `Runnable`
    interface and is responsible for the `TemperatureTask` evaluation (*Example 6.17*):'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Example 6.17 – The SensorTask instance can provide additional logic for the
    task evaluation wrapped around it
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: 'The example implementation does not require any additional custom class types
    to introduce concurrency (*Figure 6**.16*):'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.18 – The UML class diagram highlights that all the required thread
    pool elements are provided by the Java platform](img/B18884_06_18.jpg)'
  id: totrans-199
  prefs: []
  type: TYPE_IMG
- en: Figure 6.18 – The UML class diagram highlights that all the required thread
    pool elements are provided by the Java platform
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: Conclusion
  id: totrans-201
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A thread-pool pattern can provide another acceptable way to introduce concurrency
    into an application. It not only supports the execution of class types that inherit
    the `Runnable` interface but also the `Callable` interface. Using a `Callable`
    interface allows you to create a result through a `Future` interface. The result
    of executing a `Callable` instance into an instance of the `Future` type is that
    the execution of the critical section is done asynchronously by the controlling
    thread. In other words, the time required to produce a result is not known.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: The thread-pool pattern is also another SOLID approach to properly structuring
    your code base to ensure maintainability and resource utilization.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: Let us briefly summarize the lessons learned in this chapter.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-205
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter demonstrated some of the most commonly used approaches to solving
    concurrent problems. It also showed the importance of previously acquired knowledge,
    concurrent application development requires more precision and discipline to achieve
    the desired result, similar to the knowledge of Java platform internals discussed
    in [*Chapter 2*](B18884_02.xhtml#_idTextAnchor037), *Discovering the Java Platform
    for* *Design Patterns*.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: Each currently adopted pattern forces the creation of a sustainable, clean application
    code base. Many of them clearly follow and use discussed development approaches
    such as APIE or SOLID.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: The evolution of the Java platform tends to simplify how to approach the platform’s
    concurrency capabilities. One good example has been already mentioned in some
    of the sections in this chapter. Features such as `CompletableFuture` or `Executors`
    utils have been around for a while, but upcoming ones might be worth considering.
    The tentative goal with virtual threads is to increase application throughput
    while making proper use of the underlying resources and still maintaining threading
    conveniences such as debugging and providing relevant stack frames. Structure
    concurrency, on the other hand, attempts to provide a framework for simply designing
    callbacks while using an imperative code style. In addition to upcoming features
    that try to improve application throughput or simplify the usage of the concurrency
    framework, we should not forget about the immutability of the instances served
    by the `record` type. The `record` type provides a strong state contract due to
    equality. Instance immutability can play a critical role in thread interactions.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: The entire application development can sometimes deviate from the desired goal.
    Some common symptoms have already been identified in this kind of situation. These
    signals could signal our attention to reconsider the direction of development.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: We will touch on some of them in the next chapter.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  id: totrans-211
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What challenges are solved by the double-check singleton pattern?
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the best way to create the desired thread pool with the JDK?
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Which concurrent design pattern reflects the variability of an instance to process
    the next step?
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the best pattern for handling a repeatable task?
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What pattern helps separate the dispatch logic and event handling?
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  id: totrans-217
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*Design Patterns: Elements of Reusable Object-Oriented Software* by Erich Gamma,
    Richard Helm, Ralph Johnson, and John Vlissides, Addison-Wesley, 1995'
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Design Principles and Design Patterns* by Robert C. Martin, Object Mentor,
    2000'
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*JEP-425: Virtual* *Threads*, [https://openjdk.org/jeps/425](https://openjdk.org/jeps/425)'
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*JSR-428: Structured Concurrency (**Incubator)* ([https://openjdk.org/jeps/428](https://openjdk.org/jeps/428))'
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Patterns of Enterprise Application Architecture* by Martin Fowler, Pearson
    Education, Inc, 2003'
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Effective Java, Third Edition* by Joshua Bloch, Addison-Wesley, 2018'
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*JDK 17: Class* *Exchanger* ([https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/util/concurrent/Exchanger.html](https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/util/concurrent/Exchanger.html))'
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*JDK 17: Class* *CompletableFuture* ([https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/util/concurrent/CompletableFuture.html](https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/util/concurrent/CompletableFuture.html))'
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*JDK 17: Class* *Executors* ([https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/util/concurrent/Executors.html](https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/util/concurrent/Executors.html))'
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Java Mission* *Control* ([https://wiki.openjdk.org/display/jmc](https://wiki.openjdk.org/display/jmc))'
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Answers
  id: totrans-228
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The challenge solved by the double-checked singleton pattern is ensuring that
    only one class instance is present in the running JVM to avoid possible leaks
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The usage of the `Executors` utility that resides in the `java.base` module
    and `java.util.concurrent` package
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The balking pattern depends on the instance stat
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The scheduler pattern
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The producer-consumer pattern is one of the most common concurrent design patterns,
    with clearly separated and addressed logic
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
