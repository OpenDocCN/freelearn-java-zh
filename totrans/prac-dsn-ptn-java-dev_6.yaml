- en: '6'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Concurrency Design Patterns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Previous chapters on creational, structural, and behavioral patterns proposed
    a design that concerns the base code. Their main focus was on the maintainable
    base code that operates in the main single application thread. In other words,
    the generated byte code is executed in a defined sequence to achieve the desired
    results.
  prefs: []
  type: TYPE_NORMAL
- en: Nowadays, business requirements have shifted the application expectations described
    by the GoF’s book over the years more and more within a concurrent and parallel
    world. This has been succeeded by a massive improvement in hardware.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Java platform provides concurrency functionality under the hood from the
    very beginning. The Flight Recorder tool of Mission Control set helps collect
    data points about thread behavior and displays them visually, improving our awareness
    of application dynamics. In this chapter, we are going to examine some of the
    most common scenarios in the information technology industry:'
  prefs: []
  type: TYPE_NORMAL
- en: Decoupling a method execution with an active object pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Non-blocking tasks using an async method invocation pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Delaying execution until the previous task has been completed with the balking
    pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Providing a unique object instance with a double-checked locking pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using purposeful thread blocking via a read-write lock pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Decoupling the execution logic with the producer-consumer pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Executing isolated tasks with the scheduler pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Effective thread utilization with the thread-pool pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of this chapter, we will have built a solid foundation for understanding
    the concurrency possibilities of the Java platform and starting to apply them
    effectively.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You can find the code files for this chapter on GitHub at [https://github.com/PacktPublishing/Practical-Design-Patterns-for-Java-Developers/tree/main/Chapter06](https://github.com/PacktPublishing/Practical-Design-Patterns-for-Java-Developers/tree/main/Chapter06).
  prefs: []
  type: TYPE_NORMAL
- en: Decoupling a method execution with an active object pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The active object design pattern separates and defers method execution from
    method invocation by running its own control thread.
  prefs: []
  type: TYPE_NORMAL
- en: Motivation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The active object pattern introduces a transparently concurrent model to the
    application. It creates and starts an internal thread that executes the required
    logical, critical section. An active object instance exposes a public interface
    that a client can use to run an encapsulated critical section. An external, client-initiated
    event is queued and ready to execute. The execution step is performed by the internal
    scheduler. The result can be passed to the appropriate handler in a callback style.
  prefs: []
  type: TYPE_NORMAL
- en: Sample code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let us introduce an example of a moving vehicle with a radio system (*Example
    6.1*):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Example 6.1 – The SportVehicle instance allows the client to create an event
    by using its public methods
  prefs: []
  type: TYPE_NORMAL
- en: 'The newly created abstract class, `MovingVehicle`, defines public methods –
    `move`, `turnOnRadio`, `turnOffRadio`, and `stopVehicle`. In addition to the control
    thread, the class defines a conditional queue for incoming events (*Example 6.2*):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Example 6.2 – MovingVehicle contains an active flag for purpose of scheduling
    events
  prefs: []
  type: TYPE_NORMAL
- en: 'Events in the queue are received and fired based on an internal period. `LinkedBlockingDeque`
    provides additional functions for inserting or removing elements from the top
    or bottom, which is useful when the vehicle needs to be stopped. The `StopVehicle`
    event has priority over the radios (*Example 6.3*):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Example 6.3 – The received events are added to the queue conditionally
  prefs: []
  type: TYPE_NORMAL
- en: 'A lifecycle of the `SportVehicle` instance does not interfere with the main
    application thread. It is predictable and does not block the application (*Figure
    6**.1*):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.1 – The moving-vehicle thread shows the sequence of commands](img/B18884_06_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.1 – The moving-vehicle thread shows the sequence of commands
  prefs: []
  type: TYPE_NORMAL
- en: 'The components introduced in the example seamlessly cooperate (*Figure 6**.2*):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.2 – The UML class diagram shows the SportVehicle class’s relation
    to the Java concurrency features](img/B18884_06_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.2 – The UML class diagram shows the SportVehicle class’s relation to
    the Java concurrency features
  prefs: []
  type: TYPE_NORMAL
- en: Conclusion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A well-developed active object pattern respects the SOLID design approaches
    because it encapsulates the critical parts and only exposes the control interface
    required. The instance does not interfere with the application and the whole approach
    can be generalized to the desired level. An active object can be a good candidate
    for introducing a concurrency model into an application, but there are a few challenges
    to keep in mind. One of these challenges is the number of possible application
    threads, where a high number can make the application fragile or lead to instability
    as it depends on available resources.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s explore the asynchronous nature of events in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Non-blocking tasks using async method invocation pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The asynchronous method invocation pattern is a way to solve the challenge of
    not penalizing the main process thread with possibly time-consuming tasks.
  prefs: []
  type: TYPE_NORMAL
- en: Motivation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Asynchronous method invocation patterns introduce the ability to receive a result
    by a callback from an asynchronously running task without blocking the main process
    thread. The pattern presents the threading model and level of parallelism for
    processing the required task types. The task results are processed by dedicated
    callback handlers and provided to the main process regardless of the task’s execution
    time. These handlers may already belong to the main process.
  prefs: []
  type: TYPE_NORMAL
- en: Sample code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let us look at a trivial scenario of several vehicle temperature sensors required
    to provide results to the driver, which is the client (*Example 6.4*):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Here’s the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Example 6.4 – The example task temp:26, is asynchronously executed in thread-0
    thread
  prefs: []
  type: TYPE_NORMAL
- en: 'The instance of `TempSensorCallback` that monitors all results resides in the
    `main` process thread (*Figure 6**.3*):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.3 - TemperatoreSensorCallback instance is called asynchronously,
    therefore different thread finish times](img/B18884_06_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.3 - TemperatoreSensorCallback instance is called asynchronously, therefore
    different thread finish times
  prefs: []
  type: TYPE_NORMAL
- en: '`TempSensorTask` instances are handled by custom `TempSensorExecutor` instances,
    which not only provides control over initiated threads, but can also terminate
    long-running measurements of a particular sensor by providing a task reference.
    The `TempSensorExecutor` instance exposes a measure public method that provides
    a `TempSensorResult` instance of a long-running task (*Example 6.5*):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Example 6.5 – Each new thread specific long-term measurement will pass its result
    to the callback handler
  prefs: []
  type: TYPE_NORMAL
- en: 'The nature of processing the information served by multiple temperature sensors
    is clearly parallel. The asynchronous method invocation patterns provide a very
    small set of classes to solve this challenge (*Figure 6**.4*):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.4 – The UML class diagram draws how data are acquired from temperature
    sensors](img/B18884_06_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.4 – The UML class diagram draws how data are acquired from temperature
    sensors
  prefs: []
  type: TYPE_NORMAL
- en: Conclusion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The given examples clearly show how to handle a long-running task with a preliminary
    detachment from the main processing thread. In other words, it is not causing
    by delas. The Java platform provides multiple options to create this pattern.
    One of them is to employ the `Callable` interface and send an instance to the
    `ExecutorService` using its `submit` method. The `submit` method returns a result
    that implements the `Future` interface. The `Future` has similarities to the sample
    `TempSensorResult` instance but does not provide a callback function that needs
    to be handled differently. Another possibility can be explored using `CompletableFuture`,
    which not only exposes the `supplyAsync` method, but also provides many other
    useful functions. All of the suggestions mentioned can be found in the `java.base`
    module and the `java.util.concurren`t package.
  prefs: []
  type: TYPE_NORMAL
- en: The next section shows how to delay the execution of a task until the previous
    one is complete; let’s get to it.
  prefs: []
  type: TYPE_NORMAL
- en: Delay execution until the previous task is completed with the balking pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sometimes it is required to consider the task state changes to properly execute
    next task and fulfill the goal.
  prefs: []
  type: TYPE_NORMAL
- en: Motivation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Although the instance mutability is not a desirable state, especially not in
    the concurrency field the ability to depend on the object state may come handy.
    The case where multiple threads try to acquire an object to execute its critical
    sections can be limited by the object state. The state can decide whether the
    processing time will be used or not in order to coordinate the resources available.
    For example, a vehicle cannot stop without being in motion.
  prefs: []
  type: TYPE_NORMAL
- en: Sample code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Consider the example of one `Vehicle` instance sharing two groups of drivers.
    Although there are multiple groups, only one vehicle can operate at a time (*Example
    6.6*):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Here’s the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Example 6.6 – Driver groups are represented by provided threads created by ExecutorService
  prefs: []
  type: TYPE_NORMAL
- en: 'The balking pattern provides a solution in which the critical section of the
    task is executed based on the `Vehicle` instance state represented by the `VehicleState`
    enum (*Example 6.7*):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Example 6.7 – The usage of the synchronized keyword makes the driver groups
    aware of whether the Vehicle instance is ready to use or not
  prefs: []
  type: TYPE_NORMAL
- en: 'The driver group threads are blocked and only one is active at a time (*Figure
    6**.5*):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.5 – The blue and green colors represent group activity while the
    other is blocked](img/B18884_06_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.5 – The blue and green colors represent group activity while the other
    is blocked
  prefs: []
  type: TYPE_NORMAL
- en: 'The example presented requires a very minimal number of created classes, which
    are clearly encapsulated (*Figure 6**.6*):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.6 – The UML class diagram shows the two most required custom classes,
    Vehicle and VehicleState](img/B18884_06_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.6 – The UML class diagram shows the two most required custom classes,
    Vehicle and VehicleState
  prefs: []
  type: TYPE_NORMAL
- en: Conclusion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The balking pattern is easy to implement in the Java platform. It is important
    to keep the Java memory model in mind in order to properly handle object state
    volatility. It may be particularly useful to consider using atomic types (`AtomicInteger`
    and `AtomicBoolean`, for example), which automatically come with a happens-before
    guarantee. This guarantee is part of the Java memory model to maintain memory
    consistency across the interacting threads, as we learned in [*Chapter 2*](B18884_02.xhtml#_idTextAnchor037),
    *Discovering the Java Platform for Design Patterns*. Another option to consider
    is the `volatile` keyword, which comes with a guarantee of equal-value visibility
    across threads.
  prefs: []
  type: TYPE_NORMAL
- en: The next section examines guaranteed instance uniqueness – let’s roll.
  prefs: []
  type: TYPE_NORMAL
- en: Providing a unique object instance with a double-checked locking pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The double-checked locking pattern solves the problem of an application requiring
    only one instance of a particular class at runtime.
  prefs: []
  type: TYPE_NORMAL
- en: Motivation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Java platform is multi-threaded by default, as we learned in [*Chapter 2*](B18884_02.xhtml#_idTextAnchor037),
    *Discovering the Java Platform for Design Patterns*. It’s not just the garbage
    collection threads that take care of the main program lifecycle. Different frameworks
    introduce additional tread models, which may have an unintended impact on a class
    institution’s process. A double-checked locking pattern ensures that only one
    instance of a class is present at runtime. This state can become challenging in
    a multi-threaded environment, as it may depend on its implementation.
  prefs: []
  type: TYPE_NORMAL
- en: Sample code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s use a simple `Vehicle` instance to demonstrate the importance of a double-checked
    locking pattern in a multithreading environment. The example presents two different
    implementations of the singleton pattern. `VehicleSingleton` is expected to keep
    its promise due to multiple threads accessing the `getInstance` method (*Example
    6.8*):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Here’s the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Example 6.8 – The VehicleSingleton constructor has been called multiple times,
    which violates the given promise through multiple instantiations (see the hashCode
    values)
  prefs: []
  type: TYPE_NORMAL
- en: 'The `ExecutorService` instance provided by `Executors.newFixedThreadPool` receives
    multiple instances of the `Runnable` interface. The `Runnable` method’s implementation
    represents the critical section of the `getInstance` method’s call in both cases
    (*Figure 5**.5*):'
  prefs: []
  type: TYPE_NORMAL
- en: "![Figure 6.7 – All pool threads continuously execute the getInstance method\
    \ and VehicleSingletonCheck i\uFEFFs cre\uFEFFated only once](img/B18884_06_07.jpg)"
  prefs: []
  type: TYPE_IMG
- en: Figure 6.7 – All pool threads continuously execute the getInstance method and
    VehicleSingletonCheck is created only once
  prefs: []
  type: TYPE_NORMAL
- en: 'Both implementations differ in the very small details of the `getInstance`
    method implementation (*Example 6.9*):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Example 6.9 – The getInstance method’s implementation of VehicleSingletonChecked
    uses a synchronized keyword to ensure the thread stack frame state
  prefs: []
  type: TYPE_NORMAL
- en: 'In both cases, the UML diagram remains the same (*Figure 6**.8*):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.8 – The UML class diagram does not highlight the implementation
    details of the double-checked singleton pattern](img/B18884_06_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.8 – The UML class diagram does not highlight the implementation details
    of the double-checked singleton pattern
  prefs: []
  type: TYPE_NORMAL
- en: Conclusion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This example has shown a possible way to implement a double-check locking pattern.
    The Java platform may also enforce double-checked locking patterns by using an
    `Enum` construct, which provides only one element – its `INSTANCE` object of desired
    type.
  prefs: []
  type: TYPE_NORMAL
- en: The next section demonstrates how to deal with locking exclusivity.
  prefs: []
  type: TYPE_NORMAL
- en: Using purposeful thread blocking via a read-write lock pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A concurrent application may consider granting exclusive access to a critical
    section just to update the information of the specific instance. This particular
    challenge can be solved by using a read-write lock pattern.
  prefs: []
  type: TYPE_NORMAL
- en: Motivation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The read-write locking pattern introduces natural exclusivity for lock acquisition.
    This context is used to differentiate the whether the critical section can be
    executed. In other words, the write action takes precedence by its nature before
    reading, as the goal of any reader is to get the most accurate and up-to-date
    value possible. Under the hood, this means that all readers are blocked when the
    writer thread is modifying data and unblocked when the writer completes its task.
  prefs: []
  type: TYPE_NORMAL
- en: Sample code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Suppose that multiple sensors inside a vehicle require accurate information
    about the temperature value, but there is only one temperature device capable
    of updating the temperature value (*Example 6.10*):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Here’s the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Example 6.10 – The SensorWriter instance that runs its own thread obtains exclusive
    access to the Sensor instance
  prefs: []
  type: TYPE_NORMAL
- en: 'Readers continuously read the sensor value without being blocked. The situation
    changes when the writer enters the game – at which point, readers are blocked
    and have to wait for the `SensorWriter` instance to finish (*Figure 6**.9*):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.9 – Thread activity highlighting writer lock exclusivity when reader
    threads are being blocked](img/B18884_06_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.9 – Thread activity highlighting writer lock exclusivity when reader
    threads are being blocked
  prefs: []
  type: TYPE_NORMAL
- en: 'The critical section is served by two methods, `writeValue` and `readValue`.
    Both belong to the `Sensor` class (*Example 6.11*):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Example 6.11 – readLock is paused when writeLock is acquired
  prefs: []
  type: TYPE_NORMAL
- en: 'It is important to note that lock instances reside in the main thread of execution
    and are acquired by the threads provided by the `ExecutorService` instance (*Figure
    6**.10*):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.10 – The UML class diagram for a read-write lock pattern](img/B18884_06_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.10 – The UML class diagram for a read-write lock pattern
  prefs: []
  type: TYPE_NORMAL
- en: Conclusion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The read-write lock is very powerful and can contribute very positively to the
    stability of the application. It clearly separates the participant from the critical
    section code that drives the logic. Each example class can be generalized or adapted
    according to SOLID design principles upon request.
  prefs: []
  type: TYPE_NORMAL
- en: The JDK defines another approach worth considering for exchanging the sensor
    value. The `java.base` module package, `java.util.concurrent`, contains the `Exchanger`
    class, which provides the required synchronization guarantees.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s examine another common pattern where the instance is broadcasted to the
    target.
  prefs: []
  type: TYPE_NORMAL
- en: Decoupling the execution logic with a producer-consumer pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The common industrial scenario represents producing and consuming values without
    blocking the main application thread. The producer-consumer pattern helps to solve
    this challenge by decoupling the logic and separating the lines.
  prefs: []
  type: TYPE_NORMAL
- en: Motivation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A common industrial scenario involves producing and consuming values without
    blocking the main execution thread. The producer-consumer pattern is designed
    exactly to rise to the challenge by decoupling the logic and separating the target
    receivers.
  prefs: []
  type: TYPE_NORMAL
- en: Sample code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Another scenario is where the vehicle produces multiple events from multiple
    sources and these events need to be broadcasted and delivered to consumers (*Example
    6.12*):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Here’s the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Example 6.12 – Compared to producers, consumers are in the minority, not only
    in terms of quantity but also in terms of available resources
  prefs: []
  type: TYPE_NORMAL
- en: 'Each of the `ExecutorService` instances uses a `ProdConThreadFactory` object
    type to provide meaningful thread names (*Figure 6**.11*):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.11 – Consumers are in the minority and sometimes may be blocked
    as the event storage is full](img/B18884_06_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.11 – Consumers are in the minority and sometimes may be blocked as
    the event storage is full
  prefs: []
  type: TYPE_NORMAL
- en: 'The participant classes are decoupled and ready for extension (*Figure 6**.12*):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.12 – The UML class diagram shows how event classes are related to
    the internals of the Java platform](img/B18884_06_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.12 – The UML class diagram shows how event classes are related to the
    internals of the Java platform
  prefs: []
  type: TYPE_NORMAL
- en: Conclusion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the field of distributed systems, the production-consumer approach is widely
    used. It is advantageous for clearly separating and defining groups of event senders
    and receivers. The groups can be placed in different threads according to the
    desired thread model.
  prefs: []
  type: TYPE_NORMAL
- en: The JDK 19 release comes with the newly added concept of virtual threads. Virtual
    threads attempt to simplify the use of core platform threads by introducing thread-like
    frames, and wrappers. The virtual thread wrappers are scheduled by the JVM to
    run on available platform threads by using newly added executors – for example,
    `Executors.newVirtualThreadPerTaskExecutor`. This approach fulfills the definition
    of the producer-consumer pattern, in which the producer is an application that
    uses new virtual thread executors and the platform consumes scheduled virtual
    threads.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s uncover the scheduler approach in the next section in more detail.
  prefs: []
  type: TYPE_NORMAL
- en: Executing isolated tasks with the scheduler pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An application behaving deterministically can play a critical role in its success.
    A scheduler pattern can help to achieve the desired goal.
  prefs: []
  type: TYPE_NORMAL
- en: Motivation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Although schedulers are sometimes poorly designed to keep the application busy,
    their main purpose is important. The importance of using patterns comes to light
    more with microservices or distributed approaches in which the system is required
    to behave predictably. The general goal is to determine when a specific task is
    performed so that the underlying resources are properly used or a budget estimate
    can be created for the required resources described in site reliability engineering.
  prefs: []
  type: TYPE_NORMAL
- en: Sample code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following example brings us to temperature measurement. Every vehicle contains
    temperature sensors in a mechanical or digital form. Temperature sensors play
    a key role in vehicle operation (*Example 6.13*):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Here’s the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Example 6.13 – The CustomScheduler instance executes a SensorTask instance from
    the blocking queue every 100 milliseconds
  prefs: []
  type: TYPE_NORMAL
- en: '`CustomerScheduler` shows a trivial implementation that administers the execution
    process (*Figure 6**.14*):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.13 – Each task execution has a 100 ms time window allocated](img/B18884_06_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.13 – Each task execution has a 100 ms time window allocated
  prefs: []
  type: TYPE_NORMAL
- en: 'The scheduler instantiation prepares a thread with an active flag to control
    the lifecycle (*Example 6.14*):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Example 6.14 – CustomScheduler ensures that the time window is maintained
  prefs: []
  type: TYPE_NORMAL
- en: 'The task of creating a simple scheduler is trivial, but beyond that, it’s good
    to keep in mind the threading model – as in, where and how execution takes place
    (*Figure 6**.14*):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.14 – The UML class diagram highlights the CustomScheduler threading
    model](img/B18884_06_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.14 – The UML class diagram highlights the CustomScheduler threading
    model
  prefs: []
  type: TYPE_NORMAL
- en: 'In the case of the scheduler pattern, it is only fair to mention the second
    example. The second example uses the built-in JDK functions and their customizations.
    The planning process is fully managed by the platform. The application example
    is, again, similar to the first example, temperature measurement (*Example 6.15*):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Here’s the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Example 6.15 – The period is set to 100 ms and the SensorTask instance is reused
    for each iteration
  prefs: []
  type: TYPE_NORMAL
- en: 'An extended `CustomScheduledThreadPoolExecutor` instance can provide additional
    information based on task execution by overriding an available method such as
    `beforeExecute` or `afterExecute`. Using the JDK internals makes it easy to scale
    a `SensorTask` instance across threads (*Figure 6**.15*):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.15 – A CustomScheduledThreadPoolExecutor instance facilitates easier
    thread management and easier management of other JDK internals](img/B18884_06_15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.15 – A CustomScheduledThreadPoolExecutor instance facilitates easier
    thread management and easier management of other JDK internals
  prefs: []
  type: TYPE_NORMAL
- en: 'Leveraging the JDK internals for scheduling does not require you to create
    a customized solution while gaining better visibility into the scheduling cycle
    (*Figure 6**.16*):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.16 – The UML class diagram shows the minimal effort required to
    create a custom scheduler with all the internals](img/B18884_06_16.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.16 – The UML class diagram shows the minimal effort required to create
    a custom scheduler with all the internals
  prefs: []
  type: TYPE_NORMAL
- en: Conclusion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Both preset examples show possible uses of the scheduler pattern. Using the
    JDK internals has a number of advantages to consider. It gives the platform the
    ability to more efficiently use and optimize available resources, such as the
    dynamic JIT translation we learned about in [*Chapter 2*](B18884_02.xhtml#_idTextAnchor037)*,*
    *Discovering the Java Platform for* *Design Patterns*.
  prefs: []
  type: TYPE_NORMAL
- en: Effective thread utilization using a thread-pool pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It is not always necessary to create a new thread for each task, as this can
    lead to improper resource usage. A thread-pool pattern may be a good solution
    to this challenge.
  prefs: []
  type: TYPE_NORMAL
- en: Motivation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A short-lived task does not need to create a new thread every time it runs,
    because each instantiation of a thread is related to the allocation of underlying
    resources. Wasting resources could result in an application throughput or performance
    penalty. A better option is described by the thread-pool pattern, which defines
    the required number of reusable threads to execute a critical section. Specific
    workers can transparently operate above the critical section code that needs to
    be executed.
  prefs: []
  type: TYPE_NORMAL
- en: Sample code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let us imagine again a temperature measurement by sensors with different measurement
    dynamics (*Example 6.16*):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Here’s the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Example 6.16 – The thread pool runs the worker temperature measurement task
    on demand
  prefs: []
  type: TYPE_NORMAL
- en: 'A thread pool helps to use and manage created threads so that there is always
    a task to process. This positively affects the application behavior and facilitates
    planning based on the resources available (*Figure 6**.17*):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.17 – The behavior of the thread pool shows the usage of the created
    thread](img/B18884_06_17.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.17 – The behavior of the thread pool shows the usage of the created
    thread
  prefs: []
  type: TYPE_NORMAL
- en: 'The core example element is `SensorWorker`. The worker implements a `Runnable`
    interface and is responsible for the `TemperatureTask` evaluation (*Example 6.17*):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Example 6.17 – The SensorTask instance can provide additional logic for the
    task evaluation wrapped around it
  prefs: []
  type: TYPE_NORMAL
- en: 'The example implementation does not require any additional custom class types
    to introduce concurrency (*Figure 6**.16*):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.18 – The UML class diagram highlights that all the required thread
    pool elements are provided by the Java platform](img/B18884_06_18.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.18 – The UML class diagram highlights that all the required thread
    pool elements are provided by the Java platform
  prefs: []
  type: TYPE_NORMAL
- en: Conclusion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A thread-pool pattern can provide another acceptable way to introduce concurrency
    into an application. It not only supports the execution of class types that inherit
    the `Runnable` interface but also the `Callable` interface. Using a `Callable`
    interface allows you to create a result through a `Future` interface. The result
    of executing a `Callable` instance into an instance of the `Future` type is that
    the execution of the critical section is done asynchronously by the controlling
    thread. In other words, the time required to produce a result is not known.
  prefs: []
  type: TYPE_NORMAL
- en: The thread-pool pattern is also another SOLID approach to properly structuring
    your code base to ensure maintainability and resource utilization.
  prefs: []
  type: TYPE_NORMAL
- en: Let us briefly summarize the lessons learned in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter demonstrated some of the most commonly used approaches to solving
    concurrent problems. It also showed the importance of previously acquired knowledge,
    concurrent application development requires more precision and discipline to achieve
    the desired result, similar to the knowledge of Java platform internals discussed
    in [*Chapter 2*](B18884_02.xhtml#_idTextAnchor037), *Discovering the Java Platform
    for* *Design Patterns*.
  prefs: []
  type: TYPE_NORMAL
- en: Each currently adopted pattern forces the creation of a sustainable, clean application
    code base. Many of them clearly follow and use discussed development approaches
    such as APIE or SOLID.
  prefs: []
  type: TYPE_NORMAL
- en: The evolution of the Java platform tends to simplify how to approach the platform’s
    concurrency capabilities. One good example has been already mentioned in some
    of the sections in this chapter. Features such as `CompletableFuture` or `Executors`
    utils have been around for a while, but upcoming ones might be worth considering.
    The tentative goal with virtual threads is to increase application throughput
    while making proper use of the underlying resources and still maintaining threading
    conveniences such as debugging and providing relevant stack frames. Structure
    concurrency, on the other hand, attempts to provide a framework for simply designing
    callbacks while using an imperative code style. In addition to upcoming features
    that try to improve application throughput or simplify the usage of the concurrency
    framework, we should not forget about the immutability of the instances served
    by the `record` type. The `record` type provides a strong state contract due to
    equality. Instance immutability can play a critical role in thread interactions.
  prefs: []
  type: TYPE_NORMAL
- en: The entire application development can sometimes deviate from the desired goal.
    Some common symptoms have already been identified in this kind of situation. These
    signals could signal our attention to reconsider the direction of development.
  prefs: []
  type: TYPE_NORMAL
- en: We will touch on some of them in the next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What challenges are solved by the double-check singleton pattern?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the best way to create the desired thread pool with the JDK?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Which concurrent design pattern reflects the variability of an instance to process
    the next step?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the best pattern for handling a repeatable task?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What pattern helps separate the dispatch logic and event handling?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*Design Patterns: Elements of Reusable Object-Oriented Software* by Erich Gamma,
    Richard Helm, Ralph Johnson, and John Vlissides, Addison-Wesley, 1995'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Design Principles and Design Patterns* by Robert C. Martin, Object Mentor,
    2000'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*JEP-425: Virtual* *Threads*, [https://openjdk.org/jeps/425](https://openjdk.org/jeps/425)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*JSR-428: Structured Concurrency (**Incubator)* ([https://openjdk.org/jeps/428](https://openjdk.org/jeps/428))'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Patterns of Enterprise Application Architecture* by Martin Fowler, Pearson
    Education, Inc, 2003'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Effective Java, Third Edition* by Joshua Bloch, Addison-Wesley, 2018'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*JDK 17: Class* *Exchanger* ([https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/util/concurrent/Exchanger.html](https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/util/concurrent/Exchanger.html))'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*JDK 17: Class* *CompletableFuture* ([https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/util/concurrent/CompletableFuture.html](https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/util/concurrent/CompletableFuture.html))'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*JDK 17: Class* *Executors* ([https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/util/concurrent/Executors.html](https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/util/concurrent/Executors.html))'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Java Mission* *Control* ([https://wiki.openjdk.org/display/jmc](https://wiki.openjdk.org/display/jmc))'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Answers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The challenge solved by the double-checked singleton pattern is ensuring that
    only one class instance is present in the running JVM to avoid possible leaks
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The usage of the `Executors` utility that resides in the `java.base` module
    and `java.util.concurrent` package
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The balking pattern depends on the instance stat
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The scheduler pattern
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The producer-consumer pattern is one of the most common concurrent design patterns,
    with clearly separated and addressed logic
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
