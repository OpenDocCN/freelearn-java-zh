<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">SpringWebFlux for Microservices</h1>
                </header>
            
            <article>
                
<p>Up until this point, we have discussed Reactor as a standalone framework. We have also seen how we can build publishers and subscribe to them. Reactor  is well suited to handling the <span>exchanging of </span><span>large volumes of data, but it is important to note that Reactor is not limited to standalone programming only; it can also be used to build web applications.</span></p>
<p>Traditionally, we built enterprise-grade web applications using the SpringMVC framework, a synchronous and blocking framework from the Spring ecosystem. SpringMVC can also serve asynchronous non-blocking data using Servlet 3.1, but then it moves away from the concepts of request mappers and filters. This makes the framework quite difficult to work with. Furthermore, when building microservice architecture for high performance, the framework may not be the optimum choice. With such an architecture, we would like to have independent, scalable, and resilient services. SpringMVC doesn't define any of these characteristics. As discussed in <a href="56427f5d-9ba0-4582-be2a-1b7f3f116287.xhtml" target="_blank">Chapter 1</a>, <em><span>Getting Started with Reactive Streams,</span></em> the previously discussed non-functional requirements are the characteristics of the Reactive Manifesto.</p>
<p>Noticing this gap, the Spring community came up with the SpringWebFlux <span>framework</span>. This framework is based on <span>Reactor and enables the creation of web-based microservices. Not just non-blocking, SpringWebFlux is a functional framework, which allows us to use Java 8 lambda functions as web endpoints. The framework offers a complete solution for non-blocking web stacks.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Technical requirements</h1>
                </header>
            
            <article>
                
<ul>
<li>Java Standard Edition, JDK 8 or above</li>
<li><span>IntelliJ IDEA IDE  2018.1 or above</span></li>
</ul>
<p>The GitHub link for this chapter is <a href="https://github.com/PacktPublishing/Hands-On-Reactive-Programming-with-Reactor/tree/master/Chapter05">https://github.com/PacktPublishing/Hands-On-Reactive-Programming-with-Reactor/tree/master/Chapter05</a>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Introduction to SpringWebFlux</h1>
                </header>
            
            <article>
                
<p>To enable us to build web-based services, SpringWebFlux offers the following programming models:</p>
<ul>
<li><strong>Annotations</strong>: Annotations were originally part of the SpringMVC stack. These annotations are also supported by the SpringWebFlux framework. This is the easiest way of getting started with the SpringWebFlux stack.</li>
<li><strong>Functional endpoints</strong>: This model allows us to build Java 8 functions as web endpoints. The application can be configured as a set of routes, handlers, and filters. It then enables passing all of these as lambda functions in order to build the application in a functional paradigm.</li>
</ul>
<p>In order to work with SpringWebFlux, we need to configure an underlying server. While writing this book, Netty, Tomcat, Jetty, and Undertow are the choices currently offered here. Netty is often used as the standard choice because it performs well for asynchronous, non-blocking applications. It is also a non-servlet-based server, unlike Tomcat and Jetty. The following diagram depicts this:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/d262aa1a-cecf-41cc-b454-11fba6e16c16.png" style=""/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Configuring annotations</h1>
                </header>
            
            <article>
                
<p>SpringWebFlux supports annotation-based controllers. This is in line with SpringMVC. There are two annotations used to create controllers:</p>
<ul>
<li><kbd>@Controller</kbd>: The annotation defines a generic web component. Given a request, it creates a model object and  generates a dynamic view response for it.</li>
<li><kbd>@RestController</kbd>: The annotation defines a RESTful web service. Given a request, it returns a response as JSON or XML. This is unlike the generic controller, which is capable of generating a dynamic web page for a request.</li>
</ul>
<p>Each of the controllers serves a request pattern. The following are annotations that can be used to define the request patterns served by a controller:</p>
<ul>
<li><kbd>@RequestMapping</kbd>: This annotation is used to mark a controller. It defines a request pattern prefix. It can also be used to define request headers, media types, HTTP methods, and so on.</li>
<li><kbd>@GetMapping</kbd>: <span>This </span>annotation is specific to the <kbd>GET</kbd> HTTP method. It can be used to define a <kbd>GET</kbd> HTTP request URL. </li>
<li><kbd>@PostMapping</kbd>: <span>This </span><span>annotation is specific to the <kbd>POST</kbd> HTTP method. It can be used to define a <kbd>POST</kbd> HTTP request URL. </span></li>
<li><kbd>@PutMapping</kbd>: <span>This </span><span>annotation is specific to the <kbd>PUT</kbd> HTTP method. It can be used to define a <kbd>PUT</kbd> HTTP request URL. </span></li>
<li><kbd>@DeleteMapping</kbd>: <span>This </span><span>annotation is specific to the <kbd>DELETE</kbd> HTTP method. It can be used to define a <kbd>DELETE</kbd> HTTP request URL. </span></li>
<li><kbd>@PatchMapping</kbd>: <span>This </span><span>annotation is specific to the <kbd>PATCH</kbd> HTTP method. It can be used to define a <kbd>PATCH</kbd> HTTP request URL. </span></li>
</ul>
<p>It is important to note that <span><kbd>@RequestMapping</kbd> matches all HTTP request methods, unlike the rest of the specific method annotations.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">SpringBoot Starter</h1>
                </header>
            
            <article>
                
<p><span>Now, let's try to define a RESTful Fibonacci web service using the previously discussed annotations support. To do this, we are going to use </span>Spring Boot as it offers a quick way to create enterprise-grade Spring applications. The Spring Boot project provides starter dependencies for all Spring modules. Each starter has assumed default conventions to ensure that a project is up and running without a fuss.</p>
<p>In order to use SpringWebFlux, we need to add the <kbd>spring-boot-starter-webflux</kbd> dependency to our project. Let's revisit our <kbd>build.gradle</kbd>, as shown here:</p>
<pre>buildscript {<br/>    repositories {<br/>        maven { url 'https://repo.spring.io/libs-snapshot' }<br/>    }<br/><br/>    dependencies {<br/>        classpath 'org.springframework.boot:spring-boot-gradle-plugin:2.0.3.RELEASE'<br/>        compile 'org.springframework.boot:spring-boot-starter-webflux'<br/><br/>    }<br/>}<br/><br/>apply plugin: 'org.springframework.boot'<br/>apply plugin: 'java'<br/>apply plugin: 'io.spring.dependency-management'</pre>
<p>In the preceding <kbd>build.gradle</kbd>, we have the following changes:</p>
<ol>
<li> The <kbd><span>spring-boot</span></kbd> plugin has been added to our <kbd>gradle</kbd> build.</li>
<li>The <kbd>spring-boot-dependency</kbd> plugin has been added to our <kbd>gradle</kbd> build. The plugin adds a Maven-like dependency management capability to our <kbd>gradle</kbd> build.</li>
<li><kbd>spring-boot-starter-webflux</kbd> has been added as a dependency. This project brings in transitive dependencies for other <kbd>webflux</kbd>-related projects, such as <kbd>webflux</kbd>, <kbd>netty-core</kbd>, and so on.</li>
<li>The <kbd>spring-boot-gradle</kbd> plugin has been added under the plugins configuration. This enables us to run the Spring application from the command line using the <kbd>gradlew bootrun</kbd> command.</li>
</ol>
<div class="packt_tip">By default, <kbd>Spring-boot-start-webflux</kbd> will bring a Netty dependency. If we decide to use Tomcat or any other server, we would exclude <kbd>spring-boot-starter-reactor-netty</kbd> and include said server dependency.</div>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Adding a controller</h1>
                </header>
            
            <article>
                
<p>We need to add a controller that can serve Fibonacci numbers. As discussed in the preceding sections, we need to add a class with the <kbd>@RestController</kbd> annotation. Let's look at the following controller: </p>
<pre>@RestController<br/>public class ReactiveController {<br/><br/> @GetMapping("/fibonacci")<br/> @ResponseBody<br/> public Publisher&lt;Long&gt;fibonacciSeries() {<br/> Flux&lt;Long&gt; fibonacciGenerator = Flux.generate(() -&gt; Tuples.&lt;Long,<br/>   Long&gt;of(0L, 1L), (state, sink) -&gt; {<br/>   if (state.getT1() &lt; 0)<br/>   sink.complete();<br/>   else<br/>   sink.next(state.getT1());<br/>   return Tuples.of(state.getT2(), state.getT1() + state.getT2());<br/> });<br/> return fibonacciGenerator;<br/> }<br/><br/>}</pre>
<p>In the preceding class, we have done the following:</p>
<ol>
<li class="mce-root"><span>Added</span> <kbd>@RestController</kbd> <span>to the</span> <kbd>ReactiveController</kbd> <span>class. This enables the class as a RESTful web service:</span></li>
</ol>
<pre style="color: black;padding-left: 60px">public class ReactiveController</pre>
<ol start="2">
<li>Added <kbd>@GetMapping</kbd> to the <kbd>fibonacciSeries</kbd> method. This allows us to invoke the method on receiving a HTTP <kbd>GET</kbd> request for the <kbd>/fibonacci</kbd> URL.</li>
<li>It is important to note here that the <kbd>fibonacciSeries</kbd> method returns a <kbd>Flux&lt;Long&gt;</kbd>.</li>
</ol>
<p>Now, we also need to add a <kbd>Main</kbd> class, which can run <kbd>SpringApplication</kbd>. The <kbd>Main</kbd> class must be annotated with <kbd>@EnableWebFlux</kbd> to ensure that the Spring context instantiates and registers SpringWebFlux-related classes. This is depicted using the following code:</p>
<pre>@SpringBootApplication<br/>@Configuration<br/>@ComponentScan("com.sample.web")<br/>@EnableWebFlux<br/>public class ReactorMain {<br/> public static void main(String[] args){<br/>  SpringApplication.run(ReactorMain.class, args);<br/> }<br/>}</pre>
<p>Run the application using the <kbd>gradlew bootrun</kbd> command. This will start the Netty server on<span> </span><span>port</span><span> </span><kbd>8080</kbd><span>. Lastly, look up</span> <kbd>http://localhost:8080/fibonacci</kbd><span> to receive the following result:</span></p>
<div class="mce-root CDPAlignCenter CDPAlign"><img src="assets/6e5eb5b5-51b0-4239-a8e3-b9073d10773d.png" style=""/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Method parameters</h1>
                </header>
            
            <article>
                
<p>In the preceding code, the <kbd>fibonacciSeries</kbd> request method did not accept any arguments. This is because we did not expect any input. In case we foresee any input parameters, they can be bound with the following annotations:</p>
<ul>
<li><kbd>@PathVariable</kbd>: <span>This annotation is used to access values for URI template variables. These templates are automatically converted into an appropriate type. If no matching type is found, a <kbd>TypeMismatchException</kbd> is raised:</span></li>
</ul>
<pre style="padding-left: 60px">@GetMapping("/contact/{deptId}/employee/{empId}")<br/>public Employee findEmployee(@PathVariable Long deptId, @PathVariable Long empId) {<br/>// Find the employee.<br/>}</pre>
<ul>
<li><kbd>@RequestParam</kbd>: The annotation is used to determine values passed as query parameters. Here, data type conversion is also performed automatically:</li>
</ul>
<pre style="padding-left: 60px">@GetMapping("/contact/employee")<br/>public Employee findEmployee(@RequstParam("deptId")Long deptId, @RequstParam("empId") Long empId) {<br/>// Find the employee.<br/>}</pre>
<ul>
<li><kbd>@RequestHeader</kbd>: <span>The annotation is used to determine values passed in request headers. Data type conversion into the target type is performed automatically:</span></li>
</ul>
<pre style="padding-left: 60px">@GetMapping("/fibonacci")<br/>public List&lt;Long&gt; fibonacci(@RequestHeader("Accept-Encoding") String encoding) {<br/>// Determine Series<br/>}</pre>
<ul>
<li><kbd>@RequestBody</kbd>: <span>The annotation is used to determine values passed in the request body. Data type conversion into the target type is performed automatically.</span> SpringWebFlux <span>supports reading data as reactive types of Flux and <kbd>Mono</kbd>, and thus performs a non-blocking read:</span></li>
</ul>
<pre style="padding-left: 60px">@PostMapping("/department")<br/>public void createDept(@RequestBody Mono&lt;Department&gt; dept) {<br/>// Add new department<br/>}</pre>
<ul>
<li><kbd>@CookieValue</kbd>: <span>This annotation is used to determine the HTTP cookie value as part of the request. Data type conversion into the target type is performed automatically.</span></li>
<li><kbd>@ModelAttribute</kbd><span>: </span><span>This annotation is used to determine an attribute from the request model or instantiate one if not present. Once created, property values of the attribute are initialized using the query parameters passed and the submitted form fields:</span></li>
</ul>
<pre style="padding-left: 60px">@PostMapping("/department")<br/>public void createdept(@ModelAttribute Department dept) {<br/>// Add new department<br/>}</pre>
<ul>
<li><kbd>@SessionAttribute</kbd>: <span>This annotation is used to determine preexisting session attributes. Data type conversion into the target type is performed automatically.</span></li>
<li><kbd>@RequestAttribute</kbd>: <span>This annotation is used to determine preexisting request attributes created by a previous filter execution. Data type conversion into the target type is performed automatically.</span></li>
</ul>
<p>Apart from the method parameters, there is <kbd>@ResponseBody</kbd>, which is used to serialize the <kbd>return</kbd> <span>method</span><span> </span><span>using the appropriate HTTP writer. This can be used to return JSON and XML type responses from the request method.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Exception handling</h1>
                </header>
            
            <article>
                
<p>Applications often raise exceptions while processing requests. These exceptions must be handled properly, otherwise they will send back a HTTP 500 error to the requesting client. SpringWebFlux supports exception handling by creating methods that are annotated with <kbd>@ExceptionHandler</kbd>.  These exception handlers can have the exception <span>raised</span><span> </span><span>as an argument:</span></p>
<pre>@RestController<br/>public class ReactiveController {<br/> @ExceptionHandler<br/> public String handleError(RuntimeException ex) {<br/> // ...<br/> }<br/>}</pre>
<p>An exception handler can have the same return types as request methods. Optionally, we would like to set the HTTP status as part of exception handling, but Spring does not do this automatically. It can be accomplished by returning a <kbd>ResponseEntity</kbd>, which contains the response body as well as the required HTTP status code.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Configuring functions</h1>
                </header>
            
            <article>
                
<p>In the preceding section, we configured SpringWebFlux using the traditional annotation approach. Now, we will see how we can use Java 8 lambdas to configure SpringWebFlux in a functional manner. Let's looks at the key components required to get this up and running.</p>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The handler function</h1>
                </header>
            
            <article>
                
<p>The handler function is responsible for serving a given request. It takes the request in the form of a <kbd>ServerRequest</kbd> class and generates the response as <kbd>ServerResponse</kbd>. Both <kbd>ServerRequest</kbd> and <kbd>ServerResponse</kbd> are immutable Java 8 classes. These classes support reactive types of <kbd>Mono</kbd> and Flux for reading/writing data passed in the body of the request/response. Let's try to build our first <kbd>hello-world</kbd> example using the preceding components:</p>
<pre>HandlerFunction&lt;ServerResponse&gt; helloHandler = request -&gt; {<br/>            Optional&lt;String&gt;name=request.queryParam("name");<br/>            return ServerResponse.ok().body(fromObject("Hello to " +name.orElse("the world.")));<br/>        };</pre>
<p>In the preceding code, we are doing the following:</p>
<ul>
<li>The lambda takes a <kbd><span>ServerRequest</span></kbd> input request type </li>
<li>It tries to determine whether a <kbd>name</kbd> query parameter has been passed</li>
<li>The function returns the OK(HTTP 200) response</li>
<li>The response body contains <kbd>Hello to the world</kbd></li>
</ul>
<p>This was only a simple example but it clearly demonstrates what can be accomplished using Java 8 lambdas. We can add a query to a reactive database such as Mongo, or an external invocation, and return the response as Mono or Flux. If we look closely at <kbd>ServerRequest</kbd>, the following methods have been provided to convert request-body  as reactive type:</p>
<ul>
<li><kbd>bodyToMono(Class&lt;T&gt; type)</kbd>: This reads a single object of the specified type as a Mono response</li>
<li><kbd>bodyToFlux(<span>Class&lt;T&gt; type</span>)</kbd><span>: This reads  multiple objects of the specified type as a Flux response</span></li>
</ul>
<p>If we look at the preceding code, we have used the <kbd>BodyInserters.fromObject()</kbd> static method to write to the response body. This is not the only method to do this. There are many methods to write back the response body, some of which are as follows:</p>
<ul>
<li><kbd>fromObject</kbd>: This method writes back data as an object</li>
<li><kbd>fromPublisher</kbd>: <span>This </span>method writes back data from a given Reactive Streams publisher</li>
</ul>
<ul>
<li><kbd>fromFormData</kbd>: <span>This </span>method writes back the given key-value pair and form data</li>
<li><kbd>fromMultipartData</kbd>: <span>This </span>method writes back the given data as multipart data</li>
</ul>
<div class="packt_tip">Handler functions written as lambdas are quite convenient but they become difficult to read and maintain in the long run. It is often recommended to group the handler functions for a particular functionality in one single handler class.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The router function</h1>
                </header>
            
            <article>
                
<p>The router function is responsible for routing incoming requests to the correct handler function. If we compare this to the annotation approach, then it is analogous to the <kbd>@RequestMapping</kbd> annotation.</p>
<p> A request is matched using <kbd>RequestPredicate</kbd>, which tries to validate the intended matching criteria. Our previously created <kbd>helloHandler</kbd> can be configured in the following manner:</p>
<pre>RouterFunction&lt;ServerResponse&gt; route =          RouterFunctions.route(RequestPredicates.path("/hello"),hellowHandler);</pre>
<p>The preceding code is doing the following:</p>
<ol>
<li>It registers a predicate for the <kbd>/hello</kbd> path</li>
<li>If a request matches this path, the router invokes <kbd>helloHandler</kbd></li>
</ol>
<p>If we look at <kbd>RequestPredicate</kbd>, this is a functional interface in which we need to implement the test method only:</p>
<pre>public interface RequestPredicate {<br/> boolean test(ServerRequest var1);<br/> default RequestPredicate and(RequestPredicate other) {..  }<br/> default RequestPredicate negate() {..}<br/> default RequestPredicate or(RequestPredicate other) {..}<br/> default Optional&lt;ServerRequest&gt; nest(ServerRequest request) {..}<br/>}</pre>
<p>However, implementing <kbd>RequestPredicate</kbd> is not required. The framework provides the <kbd>RequestPredicates</kbd> utility class with most commonly used predicates. The utility provides routing based on HTTP methods, HTTP headers, query parameters, URL path, and so on. Let's looks at the <span>methods offered by the <kbd>RequestPredicates</kbd> utils class</span>:</p>
<table border="1" style="border-collapse: collapse;width: 100%">
<tbody>
<tr>
<td style="width: 27.686%"><strong>Methods</strong></td>
<td style="width: 71.4876%"><strong>Match</strong></td>
</tr>
<tr>
<td style="width: 27.686%"><kbd><span>path(String pattern)</span></kbd></td>
<td style="width: 71.4876%"><span>Predicate matches</span> t<span>he </span>passed<span> URL</span></td>
</tr>
<tr>
<td style="width: 27.686%"><kbd><span>pattern</span><span>DELETE(String pattern)</span></kbd></td>
<td style="width: 71.4876%"><span>Predicate matches the passed URL pattern when HTTP method is </span><kbd>DELETE</kbd></td>
</tr>
<tr>
<td style="width: 27.686%"><kbd><span>GET(String pattern)</span></kbd></td>
<td style="width: 71.4876%"><span>Predicate matches the passed URL pattern when HTTP method is </span><kbd>GET</kbd></td>
</tr>
<tr>
<td style="width: 27.686%"><kbd><span>PUT(String pattern)</span></kbd></td>
<td style="width: 71.4876%"><span>Predicate matches the passed URL pattern when HTTP method is </span><kbd>PUT</kbd></td>
</tr>
<tr>
<td style="width: 27.686%"><kbd><span>POST(String pattern)</span></kbd></td>
<td style="width: 71.4876%"><span>Predicate matches the passed URL pattern when HTTP method is </span><kbd>POST</kbd></td>
</tr>
<tr>
<td style="width: 27.686%"><kbd><span>PATCH(String pattern)</span></kbd></td>
<td style="width: 71.4876%"><span>Predicate matches the passed URL pattern when HTTP method is </span><kbd>PATCH</kbd></td>
</tr>
<tr>
<td style="width: 27.686%"><kbd><span>HEAD(String pattern)</span></kbd></td>
<td style="width: 71.4876%"><span>Predicate matches the passed URL pattern when HTTP method is </span><kbd>HEAD</kbd></td>
</tr>
<tr>
<td style="width: 27.686%"><kbd><span>method(HttpMethod method)</span></kbd></td>
<td style="width: 71.4876%"><span>Predicate determines if the request method is the same as that passed</span></td>
</tr>
<tr>
<td style="width: 27.686%"><kbd><span> one</span><span>accept(MediaType type)</span></kbd></td>
<td style="width: 71.4876%"><span>Predicate determines if</span> the request accepts header <span>contains the given </span><kbd>MediaType</kbd></td>
</tr>
<tr>
<td style="width: 27.686%"><kbd><span>contentType(mediaType type)</span></kbd></td>
<td style="width: 71.4876%"><span>Predicate determines if the request's <kbd>contentType</kbd> header contains the given <kbd>MediaType</kbd></span></td>
</tr>
<tr>
<td style="width: 27.686%"><kbd><span>headers(Predicate headerPredicate)</span></kbd></td>
<td style="width: 71.4876%"><span>Predicate determines if the request header matches the predicate query</span></td>
</tr>
<tr>
<td style="width: 27.686%"><kbd><span> Param(String name, String value)</span></kbd></td>
<td style="width: 71.4876%"><span>Predicate determines if the request query parameters contain the key-value pair  </span></td>
</tr>
<tr>
<td style="width: 27.686%"><kbd><span>all()</span></kbd></td>
<td style="width: 71.4876%"><span>Predicate always matches the request</span></td>
</tr>
</tbody>
</table>
<p> </p>
<p>We can combine one or more of these predicates to build composite matching criteria. The criteria can be combined using the following methods of <kbd>RequestPredicate</kbd>:</p>
<ul>
<li><kbd>RequestPredicate.and(RequestPredicate)</kbd>: Builds the logical <kbd>AND</kbd> criteria, where both must match</li>
<li class="mce-root"><kbd>RequestPredicate.or(RequestPredicate)</kbd>: <span>Builds the logical <kbd>OR</kbd> criteria, where either can match</span></li>
<li><span><kbd>RequestPredicate.negate()</kbd>: Builds the logical <kbd>NOT</kbd> criteria, which it must not match</span></li>
</ul>
<p><kbd>RequestPredicates</kbd> are configured using the <kbd>Route</kbd> functions from the <kbd>RouterFunctions</kbd> utility <span>class</span><span>. Additional routes can be configured using the following methods from</span> <kbd>RouterFunction</kbd><span>:</span></p>
<ul>
<li><kbd><span>RouterFunctions.router(predicate,handler)</span></kbd></li>
<li><kbd><span>RouterFunction.andRoute(predicate,handler)</span></kbd></li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">HandlerFilter</h1>
                </header>
            
            <article>
                
<p><kbd>HandlerFilter</kbd> is analogous to the Servlet filter. This executes before the request gets processed by <kbd>HandlerFunction</kbd>. There could be chain filters that get executed before the request gets served. If a filter sends back a <kbd>ServerResponse</kbd>, then the request is terminated as follows:</p>
<pre>helloRoute.filter((request, next) -&gt; {<br/>    <span>if </span>(request.headers().acceptCharset().contains(Charset.<span>forName</span>(<span>"UTF-8"</span>))) {<br/>        <span>return </span>next.handle(request);<br/>    }<br/>    <span>else </span>{<br/>        <span>return </span>ServerResponse.<span>status</span>(HttpStatus.<span>BAD_REQUEST</span>).build();<br/>    }<br/>});</pre>
<p>The preceding code is doing the following:</p>
<ol>
<li>Adding a filter to <kbd>helloRoute</kbd> using the <kbd>filter()</kbd> method </li>
<li>The filter takes a request and the next handler function</li>
<li>Validating whether or not the request headers contain the <kbd>UTF-8</kbd> charset in the <span class="packt_screen">Accept-Language</span> header</li>
<li>If so, forward the request to the next function</li>
<li>If not, then build a <kbd>ServerResponse</kbd> with the status as <kbd>BAD_REQUEST</kbd>:</li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img src="assets/da920649-70ec-46c0-a396-7fed5ef78992.png" style=""/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">HttpHandler</h1>
                </header>
            
            <article>
                
<p>Now that we have mapped a request using the handler and router, the only step <span>left</span><span> is to start the server.</span> SpringWebFlux <span>enables us to programmatically start the server. In order to do so, we have to get </span><kbd>HttpHandler</kbd> <span>from</span> <kbd>RouterFunction</kbd> <span>and then start the required server:</span></p>
<pre>HttpHandler httpHandler = RouterFunctions.<span>toHttpHandler</span>(helloRoute);<br/>ReactorHttpHandlerAdapter adapter = <span>new </span>ReactorHttpHandlerAdapter(httpHandler);<br/>HttpServer server = HttpServer.<span>create</span>(<span>"127.0.0.1"</span>, <span>8080</span>);<br/>server.newHandler(adapter).block();</pre>
<p>The preceding code is specific to Netty, as we are using <kbd>reactor-netty</kbd> in our current example. In the preceding code, we are doing the following:</p>
<ul>
<li>Converting the <kbd>helloRoute</kbd> to a <kbd>HttpHandler</kbd> using <kbd>RoterFunctions.toHttpHandler</kbd></li>
<li>Instantiating Netty's <kbd>ReactorHttpHandlerAdapter</kbd> and using it to configure the Netty <kbd>HttpServer</kbd></li>
<li>Finally, we block to listen for incoming requests and serve them</li>
</ul>
<p>The preceding configuration is specific to the underlying server. While working with <kbd>Undertow</kbd>, the configuration can be built using the following code:</p>
<pre>HttpHandler httpHandler =  RouterFunctions.<span>toHttpHandler</span>(helloRoute);<br/>UndertowHttpHandlerAdapter adapter = new UndertowHttpHandlerAdapter(httpHandler);<br/>Undertow server = Undertow.builder().addHttpListener(8080, "127.0.0.1").setHandler(adapter).build();<br/>server.start();</pre>
<p><span> The following code is applicable to Tomcat:</span></p>
<pre>HttpHandler httpHandler = RouterFunctions.<span>toHttpHandler</span>(helloRoute);<br/>Servlet servlet = new TomcatHttpHandlerAdapter(httpHandler);<br/>Tomcat server = new Tomcat();<br/>File root = new File(System.getProperty("java.io.tmpdir"));<br/>Context rootContext = server.addContext("", root.getAbsolutePath());<br/>Tomcat.addServlet(rootContext, "ctx", servlet);<br/>rootContext.addServletMappingDecoded("/", "ctx");<br/>server.setHost(host);<br/>server.setPort(port);<br/>server.start();</pre>
<p>Alternatively, we can leave all this configuration to Spring and use the Spring <kbd>DispatcherHandler</kbd>-based configuration to start the server. The configuration is Java annotation-based. The configuration automatically registers the following additional components to support functional endpoints:</p>
<ul>
<li><kbd>RouterFunctionMapping</kbd>: â€‰This determines the list of  <kbd>RouterFunction</kbd> <kbd>&lt;?&gt;</kbd> beans in the Spring configuration. This combines them and routes the request to the correct <kbd>RouterFunction</kbd>.</li>
<li><kbd>HandlerFunctionAdapter</kbd>: This invokes the correct <kbd>HandlerFunction</kbd> when a request is received.</li>
<li><kbd>ServerResponseResultHandler</kbd>: This writes back the <kbd>ServerResponse</kbd> from the <kbd>HandlerFunction</kbd> invocation.</li>
</ul>
<p>All the preceding components are registered by Spring when we use the <kbd>@EnableWebFlux</kbd> annotation.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Fibonacci functional router</h1>
                </header>
            
            <article>
                
<p>Now that we have seen the basics of functional mappings, let's try to render the Fibonacci series using them. We will use the same Fibonacci generator developed in the previous section. We have seen that we can write a Reactive Stream publisher into <kbd>ServerResponse</kbd>, as demonstrated in the following code snippet:</p>
<pre><span>@Configuration<br/></span><span>class </span>FibonacciConfigurer {<br/>    <br/>    <span>@Bean<br/></span><span>    </span>RouterFunction&lt;ServerResponse&gt; fibonacciEndpoint() {<br/>        Flux&lt;Long&gt; fibonacciGenerator = Flux.<span>generate</span>(() -&gt; Tuples.&lt;Long,<br/>                Long&gt;<span>of</span>(<span>0L</span>, <span>1L</span>), (state, sink) -&gt; {<br/>            <span>if </span>(state.getT1() &lt; <span>0</span>)<br/>                sink.complete();<br/>            <span>else<br/></span><span>                </span>sink.next(state.getT1());<br/>            <span>return </span>Tuples.<span>of</span>(state.getT2(), state.getT1() + state.getT2());<br/>        });<br/>        RouterFunction&lt;ServerResponse&gt; fibonacciRoute =<br/>                RouterFunctions.<span>route</span>(RequestPredicates.<span>path</span>(<span>"/fibonacci"</span>),<br/>                        request -&gt; ServerResponse.<span>ok</span>().body(<span>fromPublisher</span>(<span>fibonacciGenerator</span>, Long.<span>class</span>)));<br/>        <span>return </span>fibonacciRoute;<br/>    }<br/>}</pre>
<p>In the preceding code, we did the following:</p>
<ol>
<li>Created a <kbd>FibonacciGenerator</kbd> to generate the series</li>
<li>Configured a route for <kbd>/fibonacci</kbd> and then sent back the response of Fibonacci numbers</li>
<li>The method is annotated with <kbd>@Bean</kbd>, which will automatically register this route with <kbd>SpringContext</kbd></li>
<li>The class is <span>annotated with <kbd>@Configuration</kbd></span></li>
</ol>
<p>Now, all that remains is to configure SpringWebFlux to pick this configuration. This is done by creating a <kbd>Main</kbd> class and annotating it with the required annotations:</p>
<pre><span>@SpringBootApplication<br/></span><span>@Configuration<br/></span><span>@ComponentScan</span>(<span>"com.sample.web"</span>)<br/><span>@EnableWebFlux<br/></span><span>public class </span>ReactorMain {<br/>    <span>public static void </span>main(String[] args) {<br/>        SpringApplication.<span>run</span>(ReactorMain.<span>class</span>, args);<br/>    }<br/>}</pre>
<p>The preceding class is exactly the same as we used to work with annotations in SpringWebFlux. Now, let's run the server using the <kbd>spring-boot</kbd> plugin:</p>
<pre><strong>gradlew bootrun</strong></pre>
<p>This brings up Netty  on <span>port</span> <kbd>8080</kbd>. Let's submit the <kbd>http://localhost:8080/fibonacci</kbd> URL to determine the response:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/b9b25ad7-bdeb-44b4-bd2b-1f3df4240645.png" style="width:36.75em;height:24.00em;"/> </div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>In this chapter, we looked at using the SpringWebFlux framework to build web-based microservices. We also discussed the various server options offered by the project and looked at the traditional annotation-based approach to building microservices. We discovered that all annotations from the SpringMVC project are supported by the SpringWebFlux project. Next, we took the functional approach to building microservices. We configured the router and handler functions to build the Fibonacci web service.</p>
<p>In the next chapter, we will look at ways to add other web features, such as web page templates, security, and much more, to a SpringWebFlux-based web service.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Questions</h1>
                </header>
            
            <article>
                
<ol>
<li>How can we configure the SpringWebFlux project?</li>
<li>What <kbd>MethodParameter</kbd> annotations are supported by SpringWebFlux?</li>
<li>What is the use of <kbd>ExceptionHandler</kbd>?</li>
<li>What is the use of  <kbd>HandlerFunction</kbd>?</li>
<li>What is the use of <kbd>RouterFunction</kbd>?</li>
<li>What is the use of <kbd>HandlerFilter</kbd>?</li>
</ol>


            </article>

            
        </section>
    </body></html>