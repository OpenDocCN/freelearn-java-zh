<html><head></head><body>
		<div id="_idContainer031">
			<h1 id="_idParaDest-16"><em class="italic"><a id="_idTextAnchor015"/>Chapter 1</em>: Getting Started with Java 17</h1>
			<p>This chapter is about how to start learning Java 17 and Java in general. We will begin with the basics, first explaining what Java is and its main terms, followed by how to install the necessary tools to write and run (execute) a program. In this respect, Java 17 is not much different from the previous Java versions, so this chapter’s content applies to the older versions too.</p>
			<p>We will describe and demonstrate all the necessary steps for building and configuring a Java programming environment. This is the bare minimum that should have on your computer to start programming. We also describe the basic Java language constructs and illustrate them with examples that can be executed immediately.</p>
			<p>The best way to learn a programming language—or any language, for that matter—is to use it, and this chapter guides readers on how they can do this with Java. We will cover the following topics in this chapter:</p>
			<ul>
				<li>How to install and run Java</li>
				<li>How to install and run an <strong class="bold">integrated development environment</strong> (<strong class="bold">IDE</strong>)</li>
				<li>Java primitive types and operators</li>
				<li>String types and literals</li>
				<li><strong class="bold">Identifiers</strong> (<strong class="bold">IDs</strong>) and variables</li>
				<li>Java statements</li>
			</ul>
			<h1 id="_idParaDest-17"><a id="_idTextAnchor016"/>Technical requirements</h1>
			<p>To be able to execute the code examples provided in this chapter, you will need the following:</p>
			<ul>
				<li>A computer with a Microsoft Windows, Apple macOS, or Linux operating system</li>
				<li>Java SE version 17 or later</li>
				<li>An IDE or your preferred code editor </li>
			</ul>
			<p>The instructions for how to set up a Java <strong class="bold">Standard Edition</strong> (<strong class="bold">SE</strong>) and IntelliJ IDEA editor will be provided later in this chapter. The files with the code examples for this chapter are available on GitHub in the <a href="https://github.com/PacktPublishing/Learn-Java-17-Programming.git">https://github.com/PacktPublishing/Learn-Java-17-Programming.git</a> repository, in the <strong class="source-inline">examples/src/main/java/com/packt/learnjava/ch01_start</strong> folder.</p>
			<h1 id="_idParaDest-18"><a id="_idTextAnchor017"/>How to install and run Java</h1>
			<p>When <a id="_idIndexMarker000"/>somebody<a id="_idIndexMarker001"/> says “<em class="italic">Java</em>”, they may mean quite different things. They could be referring to any of the following:</p>
			<ul>
				<li><strong class="bold">Java programming language</strong>: A high-level programming language that allows an<a id="_idIndexMarker002"/> intent (a program) to be expressed in a human-readable format that can be translated into binary code that is executable by a computer</li>
				<li><strong class="bold">Java compiler</strong>: A program <a id="_idIndexMarker003"/>that can read a text written in the Java programming language and translate it into bytecode that can be interpreted by the <strong class="bold">Java Virtual Machine</strong> (<strong class="bold">JVM</strong>) into <a id="_idIndexMarker004"/>binary code that is executable by a computer</li>
				<li><strong class="bold">JVM</strong>: A program that reads bytecode of the compiled Java program and interprets it into binary code that is executable by a computer</li>
				<li><strong class="bold">Java Development Kit</strong> (<strong class="bold">JDK</strong>): A <a id="_idIndexMarker005"/>collection of programs (tools and utilities), including the Java compiler, the JVM, and supporting libraries, which allow the compilation and execution of a program written in the Java language</li>
			</ul>
			<p>The following section walks you through the installation of the JDK of Java 17 and the basic <a id="_idIndexMarker006"/>related terms<a id="_idIndexMarker007"/> and commands. </p>
			<h2 id="_idParaDest-19"><a id="_idTextAnchor018"/>What is the JDK and why do we need it?</h2>
			<p>As we have <a id="_idIndexMarker008"/>mentioned<a id="_idIndexMarker009"/> already, the JDK includes a Java compiler and the JVM. The task of the compiler is to read a <strong class="source-inline">.java</strong> file that contains the text of a program written in Java (called source code) and transform (compile) it into bytecode stored in a <strong class="source-inline">.class</strong> file. The JVM can then read the <strong class="source-inline">.class</strong> file, interpret the bytecode into binary code, and send it to the operating system for execution. Both the compiler and the JVM have to be invoked explicitly from the command line.  </p>
			<p>The hierarchy of languages used by Java programs goes like this: </p>
			<ul>
				<li>You write Java code (<strong class="source-inline">.java</strong> file).</li>
				<li>The compiler converts your Java code into bytecode (<strong class="source-inline">.class</strong> file).</li>
				<li>The JVM converts the bytecode into machine-level assembly instructions (run on hardware).</li>
			</ul>
			<p>Have a look at the following example:</p>
			<p><strong class="source-inline">int a = b + c;</strong></p>
			<p>When you write the preceding code, the compiler adds the following bytecode to the <strong class="source-inline">.class</strong> file:</p>
			<pre class="source-code">ILOAD b</pre>
			<pre class="source-code">ILOAD c</pre>
			<pre class="source-code">IADD</pre>
			<pre class="source-code">ISTORE a</pre>
			<p><em class="italic">Write once, run anywhere</em> is the most famous programming marketing jingle driving worldwide adoption. Oracle claims more than 10 million developers use Java, which runs on 13 billion devices. You write Java and compile it into bytecode in <strong class="source-inline">.class</strong> files. There is a different JVM for Windows, Mac, Unix, Linux, and more, but the same <strong class="source-inline">.class</strong> file works on all of them.</p>
			<p>To support the <strong class="source-inline">.java</strong> file compilation and its bytecode execution, the JDK installation also includes standard Java <a id="_idIndexMarker010"/>libraries called the <strong class="bold">Java Class Library</strong> (<strong class="bold">JCL</strong>). If the program uses a third-party library, it has to be present during compilation and execution. It has to be referred from the same command line that invokes the compiler, and later when the bytecode is executed by the JVM. JCL, on the other hand, does not need to be referred to explicitly. It is assumed that the standard Java libraries reside in the default location of the JDK installation so that the compiler and the JVM know where to find them. </p>
			<p>If you do not need to compile a Java program and would like to run only the already compiled <strong class="source-inline">.class</strong> files, you can download and install the <strong class="bold">Java Runtime Environment</strong> (<strong class="bold">JRE</strong>). For <a id="_idIndexMarker011"/>example, it consists of a subset of the JDK and does not include a compiler.</p>
			<p>Sometimes, the JDK is<a id="_idIndexMarker012"/> referred to as a <strong class="bold">software development kit</strong> (<strong class="bold">SDK</strong>), which is a general name for a collection of software tools and supporting libraries that allow the creation of an executable version of source code written using a certain programming language. So, the JDK is an SDK for Java. This means it is possible to call the JDK an SDK.</p>
			<p>You may <a id="_idIndexMarker013"/>also<a id="_idIndexMarker014"/> hear the terms <em class="italic">Java platform</em> and <em class="italic">Java edition</em> applied to the JDK. A typical platform is an operating system that allows a software program to be developed and executed. Since the JDK provides its own operating environment, it is called a platform too. An edition is a variation of a Java platform (JDK) assembled for a specific purpose. There are<a id="_idIndexMarker015"/> four Java platform editions, as listed here:</p>
			<ul>
				<li><strong class="bold">Java Platform SE</strong> (<strong class="bold">Java SE</strong>): This<a id="_idIndexMarker016"/> includes <a id="_idIndexMarker017"/>the JVM, JCL, and other tools and utilities.</li>
				<li><strong class="bold">Java Platform Enterprise Edition</strong> (<strong class="bold">Java EE</strong>): This includes Java SE, servers (computer<a id="_idIndexMarker018"/> programs<a id="_idIndexMarker019"/> that provide services to the applications), JCL, other libraries, code samples, tutorials, and other documentation for developing and deploying large-scale, multi-tiered, and secure network applications.</li>
				<li><strong class="bold">Java Platform Micro Edition</strong> (<strong class="bold">Java ME</strong>): This is a subset of Java SE with some <a id="_idIndexMarker020"/>specialized<a id="_idIndexMarker021"/> libraries for developing and deploying Java applications for embedded and mobile devices, such as phones, personal digital assistants, TV set-top boxes, printers, and sensors. A variation of Java ME (with its own JVM implementation) is called the Android SDK, which was developed by Google for Android programming.</li>
				<li><strong class="bold">Java Card</strong>: This <a id="_idIndexMarker022"/>is the smallest of the Java editions<a id="_idIndexMarker023"/> and is intended for developing and deploying Java applications onto small embedded devices such as smart cards. It has two editions: Java Card Classic Edition, for smart<a id="_idIndexMarker024"/> cards, (based on <strong class="bold">International Organization for Standardization</strong> (<strong class="bold">ISO</strong>) <em class="italic">7816</em> and ISO <em class="italic">14443</em> communication), and Java Card Connected Edition, which supports a web application model and <strong class="bold">Transmission Control Protocol/Internet Protocol</strong> (<strong class="bold">TCP/IP</strong>) as a basic protocol <a id="_idIndexMarker025"/>and runs on high-end secure microcontrollers.</li>
				<li>So, to install Java means to install the JDK, which also means to install the Java platform on one of the listed editions. In this book, we are going to talk about and use <a id="_idIndexMarker026"/>only <a id="_idIndexMarker027"/>Java SE (which includes the JVM, JCL, and other tools and utilities necessary to compile your Java program into bytecode, interpret it into binary code, and automatically send it to your operating system for execution).</li>
			</ul>
			<h2 id="_idParaDest-20"><a id="_idTextAnchor019"/>Installing Java SE</h2>
			<p>All the recently<a id="_idIndexMarker028"/> released JDKs are listed on the official Oracle page at <a href="https://www.oracle.com/java/technologies/downloads/#java17">https://www.oracle.com/java/technologies/downloads/#java17</a> (we will call this the <em class="italic">installation home page</em> for further references in later chapters).</p>
			<p>Here are the steps that need to be followed to install Java SE:</p>
			<ol>
				<li>Select the Java SE tab with your operating system.</li>
				<li>Click on the link to the installer that fits your operating system and the format (extension) you are familiar with.</li>
				<li>If in doubt, click the <strong class="bold">Installation Instructions</strong> link below and read the installation instructions for your operating system.</li>
				<li>Follow the steps that correspond to your operating system.</li>
				<li>The JDK is installed successfully when the <strong class="source-inline">java -version</strong> command on your computer displays the correct Java version, as demonstrated in the following example<a id="_idIndexMarker029"/> screenshot:</li>
			</ol>
			<div>
				<div id="_idContainer005" class="IMG---Figure">
					<img src="image/B18388_Figure_1.1.jpg" alt=""/>
				</div>
			</div>
			<h2 id="_idParaDest-21"><a id="_idTextAnchor020"/>Commands, tools, and utilities</h2>
			<p>If you follow<a id="_idIndexMarker030"/> the<a id="_idIndexMarker031"/> installation<a id="_idIndexMarker032"/> instructions, you may have noticed a link (<strong class="bold">Installed Directory Structure</strong> of the JDK) given under <strong class="bold">Table of Contents</strong>. This brings you to a page that describes the location of the installed JDK on your computer and the content of each directory of the JDK root directory. The <strong class="source-inline">bin</strong> directory contains all executables that constitute Java commands, tools, and utilities. If the <strong class="source-inline">bin</strong> directory is not added to the <strong class="source-inline">PATH</strong> environment variable automatically, consider doing so manually so that you can launch a Java executable from any directory.</p>
			<p>In the previous section, we have already demonstrated the <strong class="source-inline">java -version</strong> Java command. A list of the other Java executables available (commands, tools, and utilities) can be found in the Java SE documentation (<a href="https://www.oracle.com/technetwork/java/javase/documentation/index.html">https://www.oracle.com/technetwork/java/javase/documentation/index.html</a>) by clicking the <strong class="bold">Java Platform Standard Edition Technical Documentation</strong> site link, and then the <strong class="bold">Tools Reference link</strong> on the next page. You can learn more about each executable tool by clicking its link.</p>
			<p>You can also run each of the listed executables on your computer using one of the following options: </p>
			<p><strong class="source-inline">-?</strong>, <strong class="source-inline">-h</strong>, <strong class="source-inline">--help</strong>, or <strong class="source-inline">-help</strong> </p>
			<p>These will display a brief description of the executable and all its options.</p>
			<p>The most important Java commands are listed here:</p>
			<ul>
				<li><strong class="source-inline">javac</strong>: This reads a <strong class="source-inline">.java</strong> file, compiles it, and creates one or more corresponding <strong class="source-inline">.class</strong> files, depending on how many Java classes are defined in the <strong class="source-inline">.java</strong> file.</li>
				<li><strong class="source-inline">java</strong>: This executes a <strong class="source-inline">.class</strong> file.</li>
			</ul>
			<p>These are the commands that make programming possible. Every Java programmer must have a good understanding of their structure and capabilities, but if you are new to Java programming and use an IDE (see the <em class="italic">How to install and run an IDE</em> section), you do not need to master these commands immediately. A good IDE hides them from you by<a id="_idIndexMarker033"/> compiling a <strong class="source-inline">.java</strong> file <a id="_idIndexMarker034"/>automatically every time you make<a id="_idIndexMarker035"/> a change to it. It also provides a graphical element that runs the program every time you click it.</p>
			<p>Another very useful Java tool is jcmd. This facilitates communication with, and diagnosis of, any currently running Java processes (JVM) and has many options. But in its simplest form, without any option, it lists all currently running Java processes and their <strong class="bold">process IDs</strong> (<strong class="bold">PIDs</strong>). You <a id="_idIndexMarker036"/>can use it to see whether you have runaway Java processes. If you have, you can then kill such a process using the PID provided.</p>
			<h1 id="_idParaDest-22"><a id="_idTextAnchor021"/>How to install and run an IDE</h1>
			<p>What used<a id="_idIndexMarker037"/> to be<a id="_idIndexMarker038"/> just a specialized editor that allowed checking the syntax of a written program the same way a Word editor checks the syntax of an English sentence gradually evolved into an IDE. This bears its main function in the name. It integrates all the tools necessary for writing, compiling, and then executing a program <a id="_idIndexMarker039"/>under one <strong class="bold">graphical user interface</strong> (<strong class="bold">GUI</strong>). Using the power of Java<a id="_idIndexMarker040"/> compiler, the IDE identifies syntax errors immediately and<a id="_idIndexMarker041"/> then helps to improve code quality by providing context-dependent help and suggestions. </p>
			<h2 id="_idParaDest-23"><a id="_idTextAnchor022"/>Selecting an IDE</h2>
			<p>There are <a id="_idIndexMarker042"/>several IDEs available for a Java programmer, such as NetBeans, Eclipse, IntelliJ IDEA, BlueJ, DrJava, JDeveloper, JCreator, jEdit, JSource, and jCRASP, to name a few. You can read a review of the top Java IDEs and details about each by following this link: <a href="https://www.softwaretestinghelp.com/best-java-ide-and-online-compilers">https://www.softwaretestinghelp.com/best-java-ide-and-online-compilers</a>. The most popular ones are NetBeans, Eclipse, and IntelliJ IDEA.</p>
			<p>NetBeans development started in 1996 as a Java IDE student project at Charles University in Prague. In 1999, the project and the company created around the project were acquired by Sun Microsystems. After Oracle acquired Sun Microsystems, NetBeans became open source, and many Java developers have since contributed to the project. It was bundled with JDK 8 and became an official IDE for Java development. In 2016, Oracle donated it to the Apache Software Foundation.</p>
			<p>There is a NetBeans IDE for Windows, Linux, Mac, and Oracle Solaris. It supports multiple programming languages and can be extended with plugins. As of the time of writing, NetBeans is bundled only with JDK 8, but NetBeans 8.2 can work with JDK 9 too and uses features introduced with JDK 9 such as Jigsaw, for example. On <a href="http://netbeans.apache.org">netbeans.apache.org</a>, you can read more about the NetBeans IDE and download the latest version, which is 12.5 as of the time of this writing.</p>
			<p><em class="italic">Eclipse</em> is the most widely used Java IDE. The list of plugins that add new features to the IDE is constantly growing, so it is not possible to enumerate all the IDE’s capabilities. The Eclipse IDE project has been developed <a id="_idIndexMarker043"/>since 2001 as <strong class="bold">open source software</strong> (<strong class="bold">OSS</strong>). A non-profit, member-supported corporation Eclipse Foundation was created in 2004 to provide the infrastructure (<strong class="bold">version control systems</strong> (<strong class="bold">VCSs</strong>), code<a id="_idIndexMarker044"/> review systems, build servers, download sites, and so on) and a structured process. None of the 30-something employees of the Eclipse Foundation is working on any of the 150 Eclipse-supported projects.</p>
			<p>The sheer number and variety of Eclipse IDE plugins create a certain challenge for a beginner because you have to find your way around different implementations of the same—or similar—features that can, on occasion, be incompatible and may require deep investigation, as well as a clear understanding of all the dependencies. Nevertheless, the Eclipse IDE is very popular and has solid community support. You can read about the Eclipse IDE and download the latest release from <a href="http://www.eclipse.org/ide">www.eclipse.org/ide</a>.</p>
			<p>IntelliJ IDEA has two versions: a paid one and a free community edition. The paid version is consistently ranked as the best Java IDE, but the community edition is listed among the three leading Java IDEs too. The JetBrains software company that develops the IDE has offices in Prague, Saint Petersburg, Moscow, Munich, Boston, and Novosibirsk. The IDE is known for its deep intelligence that is “<em class="italic">giving relevant suggestions in every context: instant and clever code completion, on-the-fly code analysis, and reliable refactoring tools</em>”, as<a id="_idIndexMarker045"/> stated by the authors while describing the product on their website (<a href="http://www.jetbrains.com/idea">www.jetbrains.com/idea</a>). In the <em class="italic">Installing and configuring IntelliJ IDEA</em> section, we will walk you through the installation and configuration of IntelliJ IDEA’s community edition.</p>
			<h2 id="_idParaDest-24"><a id="_idTextAnchor023"/>Installing and configuring IntelliJ IDEA</h2>
			<p>These <a id="_idIndexMarker046"/>are the <a id="_idIndexMarker047"/>steps you need to follow in order to download and install IntelliJ IDEA:</p>
			<ol>
				<li value="1">Download an installer of the IntelliJ community edition from <a href="http://www.jetbrains.com/idea/download">www.jetbrains.com/idea/download</a>.</li>
				<li>Launch the installer and accept all the default values.</li>
				<li>Select <strong class="source-inline">.java</strong> on the <strong class="bold">Installation Options</strong> screen. We assume you have installed the JDK already, so you do not check the <strong class="bold">Download and install JRE</strong> option.</li>
				<li>The last installation screen has a <strong class="bold">Run IntelliJ IDEA</strong> checkbox that you can check to start the IDE automatically. Alternatively, you can leave the checkbox unchecked and launch the IDE manually once the installation is complete.</li>
				<li>When the IDE starts for the first time, it provides you with an <strong class="bold">Import IntelliJ IDEA settings</strong> option. Check the <strong class="bold">Do not import settings</strong> checkbox if you have not used IntelliJ IDEA before.</li>
				<li>The next couple of screens ask whether you accept the <strong class="bold">JetBrains Privacy Policy</strong> and whether you would like to pay for the license or prefer to continue to use the free community edition or free trial (this depends on the particular download you get).</li>
				<li>Answer the questions whichever way you prefer, and if you accept the privacy policy, the <strong class="bold">Customize IntelliJ IDEA</strong> screen will ask you to choose a theme: <strong class="bold">white (IntelliJ)</strong> or <strong class="bold">dark (Darcula)</strong>.</li>
				<li>Accept the default settings.</li>
				<li>If you decide <a id="_idIndexMarker048"/>to change the set values, you can do so later by <a id="_idIndexMarker049"/>selecting from the topmost menu, <strong class="bold">File</strong> | <strong class="bold">Settings</strong>, on Windows, or <strong class="bold">Preferences</strong> on Linux and macOS.</li>
			</ol>
			<h2 id="_idParaDest-25"><a id="_idTextAnchor024"/>Creating a project</h2>
			<p>Before you <a id="_idIndexMarker050"/>start writing your program, you need to create a project. There are several ways to create a project in IntelliJ IDEA, which is the same for any IDE, as follows:</p>
			<ol>
				<li value="1"><strong class="bold">New Project</strong>: This creates a new project from scratch.</li>
				<li><strong class="bold">Open</strong>: This facilitates reading of the existing project from the filesystem.</li>
				<li><strong class="bold">Get from VCS</strong>: This facilitates reading of the existing project from the VCS.</li>
			</ol>
			<p>In this book, we will walk you through the first option only—using the sequence of guided steps provided by the IDE. Options <em class="italic">2</em> and <em class="italic">3</em> include many settings that are automatically set by importing an existing project that has those settings. Once you have learned how to create a new project from scratch, the other ways to bring up a project in the IDE will be very easy for you.</p>
			<p>Start by clicking the <strong class="bold">New Project</strong> link and proceed further as follows:</p>
			<ol>
				<li value="1">Select <strong class="bold">Maven</strong> in the left panel and a value for <strong class="bold">Project SDK</strong> (Java Version 17, if you have installed JDK 17 already), and click <strong class="bold">Next</strong>.</li>
				<li>Maven is a project configuration tool whose primary function is to manage project dependencies. We will talk about it shortly. For now, we will use its other responsibility: to define and hold the project code identity using three <strong class="bold">Artifact Coordinates</strong> properties (see next).</li>
				<li>Type the project name—for example, <strong class="source-inline">myproject</strong>.</li>
				<li>Select the desired project location in the <strong class="bold">Location field</strong> setting (this is where your new code will reside).</li>
				<li>Click <strong class="bold">Artifact Coordinates</strong>, and the following properties will appear:<ul><li><strong class="source-inline">GroupId</strong>: This is the base package name that identifies a group of projects within an organization<a id="_idIndexMarker051"/> or an open source community. In our case, l et's type <strong class="source-inline">com.mywork</strong>. </li><li><strong class="source-inline">ArtifactId</strong>: To identify a particular project within the group. Leave it as <strong class="source-inline">myproject</strong>.</li><li><strong class="source-inline">Version</strong>: To identify the version of the project. Leave it as <strong class="source-inline">1.0-SNAPSHOT</strong>.</li></ul></li>
			</ol>
			<p>The main goal is to make the identity of a project unique among all projects in the world. To help avoid a <strong class="source-inline">GroupId</strong> clash, the convention requires that you start building it from the organization domain name in reverse. For example, if a company has a <strong class="source-inline">company.com</strong> domain name, the <strong class="source-inline">GroupId</strong> properties of its projects should start with <strong class="source-inline">com.company</strong>. That is why for this demonstration we use <strong class="source-inline">com.mywork</strong>, and for the code in this book, we use the <strong class="source-inline">com.packt.learnjava</strong> <strong class="source-inline">GroupID</strong> value.</p>
			<ol>
				<li value="6">Click <strong class="bold">Finish</strong>.</li>
				<li>You will see the following project structure and generated <strong class="source-inline">pom.xml</strong> file:</li>
			</ol>
			<div>
				<div id="_idContainer006" class="IMG---Figure">
					<img src="image/B18388_Figure_1.2.jpg" alt=""/>
				</div>
			</div>
			<p>Now, if somebody would like to use the code of your project in their application, they would refer to <a id="_idIndexMarker052"/>it by the three values shown, and Maven (if they use it) will bring it in (if you upload your project to the publicly shared Maven repository, of course). Read more about Maven at <a href="https://maven.apache.org/guides">https://maven.apache.org/guides</a>. Another function of the <strong class="source-inline">GroupId</strong> value is to define the root directory of the folders tree that holds your project code. The <strong class="source-inline">java</strong> folder under <strong class="source-inline">main</strong> will hold the application code, while the <strong class="source-inline">java</strong> folder under <strong class="source-inline">test</strong> will hold the test code.</p>
			<p>Let’s create our first program using the following steps:</p>
			<ol>
				<li value="1">Right-click on <strong class="source-inline">java</strong>, select <strong class="bold">New</strong>, and then click <strong class="bold">Package</strong>, as illustrated in the following screenshot:</li>
			</ol>
			<div>
				<div id="_idContainer007" class="IMG---Figure">
					<img src="image/B18388_Figure_1.3.jpg" alt=""/>
				</div>
			</div>
			<ol>
				<li value="2">In the <strong class="bold">New Package window</strong> provided, type <strong class="source-inline">com.mywork.myproject</strong> and press <em class="italic">Enter</em>.</li>
			</ol>
			<p>You should <a id="_idIndexMarker053"/>see in the left panel the following set of new folders:</p>
			<div>
				<div id="_idContainer008" class="IMG---Figure">
					<img src="image/B18388_Figure_1.4.jpg" alt=""/>
				</div>
			</div>
			<ol>
				<li value="3">Right-click on <strong class="source-inline">com.mywork.myproject</strong>, select <strong class="bold">New</strong>, and then click <strong class="bold">Java Class</strong>, as illustrated in the following screenshot:</li>
			</ol>
			<div>
				<div id="_idContainer009" class="IMG---Figure">
					<img src="image/B18388_Figure_1.5.jpg" alt=""/>
				</div>
			</div>
			<ol>
				<li value="4">In the <a id="_idIndexMarker054"/>input window provided, type <strong class="source-inline">HelloWorld</strong>, as follows:<div id="_idContainer010" class="IMG---Figure"><img src="image/B18388_Figure_1.6.jpg" alt=""/></div></li>
			</ol>
			<ol>
				<li value="5">Press <em class="italic">Enter</em> and you will see your first Java class, <strong class="source-inline">HelloWorld</strong>, created in the <strong class="source-inline">com.mywork.myproject</strong> package, as illustrated in the following screenshot:</li>
			</ol>
			<div>
				<div id="_idContainer011" class="IMG---Figure">
					<img src="image/B18388_Figure_1.7.jpg" alt=""/>
				</div>
			</div>
			<p>The package reflects the Java class location in the filesystem. We will talk about this more in <a href="B18388_02_ePub.xhtml#_idTextAnchor045"><em class="italic">Chapter 2</em></a>, <em class="italic">Java Object-Oriented Programming (OOP)</em>. Now, in order to run a program, we<a id="_idIndexMarker055"/> create a <strong class="source-inline">main()</strong> method. If present, this method can be executed to serve as an entry point into the application. It has a certain format, as shown here:</p>
			<div>
				<div id="_idContainer012" class="IMG---Figure">
					<img src="image/B18388_Figure_1.8.jpg" alt=""/>
				</div>
			</div>
			<p>This has to have the following attributes:</p>
			<ul>
				<li><strong class="source-inline">public</strong>: Freely accessible from outside the package</li>
				<li><strong class="source-inline">static</strong>: Should be able to be called without creating an object of the class it belongs to</li>
			</ul>
			<p>It should also have the following:</p>
			<ul>
				<li>Return <strong class="source-inline">void</strong> (nothing)</li>
			</ul>
			<p>Accept a <strong class="source-inline">String</strong> array as an input, or <strong class="source-inline">varargs</strong>, as we have done. We will talk about <strong class="source-inline">varargs</strong> in <a href="B18388_02_ePub.xhtml#_idTextAnchor045"><em class="italic">Chapter 2</em></a>, <em class="italic">Java Object-Oriented Programming (OOP)</em>. For now, suffice to say that <strong class="source-inline">String[] args</strong> and <strong class="source-inline">String... args</strong> essentially define the same input format. </p>
			<p>We explain how to run the <strong class="source-inline">main</strong> class using a command line in the <em class="italic">Executing examples from the command line</em> section. You can read more about Java command-line arguments in the official Oracle documentation at <a href="https://docs.oracle.com/javase/tutorial/essential/environment/cmdLineArgs.html">https://docs.oracle.com/javase/tutorial/essential/environment/cmdLineArgs.html</a>. It is also possible to run the examples from IntelliJ IDEA.</p>
			<p>Notice the two green triangles to the left in the screenshot shown next. By clicking any of them, you can execute the <strong class="source-inline">main()</strong> method. For example, let’s display <strong class="source-inline">Hello, world!</strong>.</p>
			<p>In order to do <a id="_idIndexMarker056"/>this, type the following line inside the <strong class="source-inline">main()</strong> method:</p>
			<pre class="source-code">System.out.println("Hello, world!");</pre>
			<p>The following screenshot shows how the program should look afterward:</p>
			<div>
				<div id="_idContainer013" class="IMG---Figure">
					<img src="image/B18388_Figure_1.9.jpg" alt=""/>
				</div>
			</div>
			<p>Then, click one of the green triangles, and you should get the following output in the Terminal area:</p>
			<div>
				<div id="_idContainer014" class="IMG---Figure">
					<img src="image/B18388_Figure_1.10.jpg" alt=""/>
				</div>
			</div>
			<p>From now on, every time we are going to discuss code examples, we will run them the same way, by using the <strong class="source-inline">main()</strong> method. While doing this, we will not capture a screenshot but put the result in comments, because such a style is easier to follow. For example, the following code snippet displays how the previous code demonstration would look in this style:</p>
			<pre class="source-code">System.out.println("Hello, world!"); //prints: Hello, world!</pre>
			<p>It is possible to add a comment (any text) to the right of the code line separated by a double slash <strong class="source-inline">//</strong>. The compiler does not read this text and just keeps it as it is. The presence of a<a id="_idIndexMarker057"/> comment does not affect performance and is used to explain the programmer’s intent to humans.</p>
			<h2 id="_idParaDest-26"><a id="_idTextAnchor025"/>Importing a project</h2>
			<p>We are going <a id="_idIndexMarker058"/>to demonstrate project importing using the source code for this book. We assume that you have Maven installed (<a href="https://maven.apache.org/install.html">https://maven.apache.org/install.html</a>) on your computer and that you have Git (<a href="https://gist.github.com/derhuerst/1b15ff4652a867391f03">https://gist.github.com/derhuerst/1b15ff4652a867391f03</a>) installed too, and can use it. We also assume that you have installed JDK 17, as was described in the <em class="italic">Installing Java SE</em> section.</p>
			<p>To import the project with the code examples for this book, follow these steps: </p>
			<ol>
				<li value="1">Go to the source repository (<a href="https://github.com/PacktPublishing/Learn-Java-17-Programming">https://github.com/PacktPublishing/Learn-Java-17-Programming</a>) and click the <strong class="bold">Code</strong> drop-down menu, as shown in the following screenshot:<div id="_idContainer015" class="IMG---Figure"><img src="image/B18388_Figure_1.11.jpg" alt=""/></div></li>
			</ol>
			<ol>
				<li value="2">Copy the <a id="_idIndexMarker059"/>provided <strong class="bold">Uniform Resource Locator</strong> (<strong class="bold">URL</strong>) (click the <em class="italic">copy</em> symbol to the right of the URL), as illustrated in the following screenshot:</li>
			</ol>
			<div>
				<div id="_idContainer016" class="IMG---Figure">
					<img src="image/B18388_Figure_1.12.jpg" alt=""/>
				</div>
			</div>
			<ol>
				<li value="3">Select a directory on your computer where you would like the source code to be placed and then run the <strong class="source-inline">git clone https://github.com/PacktPublishing/Learn-Java-17-Programming.git</strong> Git<a id="_idIndexMarker060"/> command and observe similar output to that shown in the following screenshot: </li>
			</ol>
			<div>
				<div id="_idContainer017" class="IMG---Figure">
					<img src="image/B18388_Figure_1.13.jpg" alt=""/>
				</div>
			</div>
			<ol>
				<li value="4">A new <strong class="source-inline">Learn-Java-17-Programming</strong> folder is created.</li>
			</ol>
			<p>Alternatively, instead of cloning, you can download the source as a <strong class="source-inline">.zip</strong> file using the <strong class="source-inline">Download ZIP</strong> link shown in the screenshot just before. Unarchive the downloaded source in a directory on your computer where you would like the source code to be placed, and then rename the newly created folder by removing the <strong class="source-inline">-master</strong> suffix from its name, making sure that the folder’s name is <strong class="source-inline">Learn-Java-17-Programming</strong>.</p>
			<ol>
				<li value="5">The new <strong class="source-inline">Learn-Java-17-Programming</strong> folder contains the Maven project with all the source code from this book. If you prefer, you can rename this folder however you like. In our case, we renamed it <strong class="source-inline">LearnJava</strong> for brevity.</li>
				<li>Now, run IntelliJ IDEA and click <strong class="bold">Open</strong>. Navigate to the location of the project and select the just-created folder (<strong class="source-inline">LearnJava</strong>, in our case), then click the <strong class="bold">Open</strong> button.</li>
				<li>If the<a id="_idIndexMarker061"/> following popup shows in the bottom-right corner, click <strong class="bold">Load</strong>:</li>
			</ol>
			<div>
				<div id="_idContainer018" class="IMG---Figure">
					<img src="image/B18388_Figure_1.14.jpg" alt=""/>
				</div>
			</div>
			<ol>
				<li value="8">Also, click <strong class="bold">Trust project...</strong>, as shown in the following screenshot:</li>
			</ol>
			<div>
				<div id="_idContainer019" class="IMG---Figure">
					<img src="image/B18388_Figure_1.15.jpg" alt=""/>
				</div>
			</div>
			<ol>
				<li value="9">Then, click the <strong class="bold">Trust Project</strong> button on the following popup:<div id="_idContainer020" class="IMG---Figure"><img src="image/B18388_Figure_1.16.jpg" alt=""/></div></li>
			</ol>
			<ol>
				<li value="10">Now, go to <strong class="bold">Project Structure</strong> (cogwheel symbol in the upper-right corner) and make sure that Java 17 is selected as an SDK, as shown in the following screenshot:</li>
			</ol>
			<div>
				<div id="_idContainer021" class="IMG---Figure">
					<img src="image/B18388_Figure_1.17.jpg" alt=""/>
				</div>
			</div>
			<ol>
				<li value="11">Click <strong class="bold">Apply</strong> and make sure that<a id="_idIndexMarker062"/> the default <strong class="bold">Project SDK</strong> is set to Java <strong class="bold">version 17</strong> and <strong class="bold">Project language level</strong> is set to <strong class="bold">17</strong>, as in the following screenshot: <div id="_idContainer022" class="IMG---Figure"><img src="image/B18388_Figure_1.18.jpg" alt=""/></div></li>
			</ol>
			<ol>
				<li value="12">Click <strong class="bold">Apply</strong> and then (optionally) remove the <strong class="source-inline">LearnJava</strong> module by selecting it and clicking <strong class="source-inline">"-"</strong>, as follows:</li>
			</ol>
			<div>
				<div id="_idContainer023" class="IMG---Figure">
					<img src="image/B18388_Figure_1.19.jpg" alt=""/>
				</div>
			</div>
			<ol>
				<li value="13">Confirm the <strong class="source-inline">LearnJava</strong> module removal on the popup by clicking <strong class="bold">Yes</strong>, as follows:</li>
			</ol>
			<div>
				<div id="_idContainer024" class="IMG---Figure">
					<img src="image/B18388_Figure_1.20.jpg" alt=""/>
				</div>
			</div>
			<ol>
				<li value="14">Here's how the final list of modules should look:<div id="_idContainer025" class="IMG---Figure"><img src="image/B18388_Figure_1.21.jpg" alt=""/></div></li>
			</ol>
			<p>Click <strong class="bold">OK</strong> in the <a id="_idIndexMarker063"/>bottom-right corner and get back to your project. Click examples in the left pane and continue going down the source tree until you see the following list of classes:</p>
			<div>
				<div id="_idContainer026" class="IMG---Figure">
					<img src="image/B18388_Figure_1.22.jpg" alt=""/>
				</div>
			</div>
			<p>Click on the green arrow in the right pane and execute the <strong class="source-inline">main()</strong> method of any class you want. For example, let’s execute the <strong class="source-inline">main()</strong> method of the <strong class="source-inline">PrimitiveTypes</strong> class. The result <a id="_idIndexMarker064"/>you will be able to see in the <strong class="bold">Run</strong> window should be similar to this:</p>
			<div>
				<div id="_idContainer027" class="IMG---Figure">
					<img src="image/B18388_Figure_1.23.jpg" alt=""/>
				</div>
			</div>
			<h2 id="_idParaDest-27"><a id="_idTextAnchor026"/>Executing examples from the command line</h2>
			<p>To execute the <a id="_idIndexMarker065"/>examples from the command line, go to the <strong class="source-inline">examples</strong> folder, where the <strong class="source-inline">pom.xml</strong> file is located, and run the <strong class="source-inline">mvn clean package</strong> command. If the command is executed successfully, you can run any <strong class="source-inline">main()</strong> method in any of the programs in the <strong class="source-inline">examples</strong> folder from the command line. For example, to execute the <strong class="source-inline">main()</strong> method in the <strong class="source-inline">ControlFlow.java</strong> file, run the following command as one line:</p>
			<p class="source-code">java -cp target/examples-1.0-SNAPSHOT.jar   com.packt.learnjava.ch01_start.ControlFlow</p>
			<p>You will see the following results:</p>
			<div>
				<div id="_idContainer028" class="IMG---Figure">
					<img src="image/B18388_Figure_1.24.jpg" alt=""/>
				</div>
			</div>
			<p>This way, you can run any class that has the <strong class="source-inline">main()</strong> method in it. The content of the <strong class="source-inline">main()</strong> method <a id="_idIndexMarker066"/>will be executed.</p>
			<h1 id="_idParaDest-28"><a id="_idTextAnchor027"/>Java primitive types and operators</h1>
			<p>With all the<a id="_idIndexMarker067"/> main<a id="_idIndexMarker068"/> programming tools in place, we can start talking about Java as a language. The language syntax is defined by the <em class="italic">Java Language Specification</em>, which you can find at <a href="https://docs.oracle.com/javase/specs">https://docs.oracle.com/javase/specs</a>. Don’t hesitate to refer to it every time you need some clarification—it is not as daunting as many people assume. </p>
			<p>All the values in Java are divided into two categories: reference types and primitive types. We start with primitive types and operators as the natural entry point to any programming language. In this chapter, we will also discuss one reference type called <strong class="source-inline">String</strong> (see the <em class="italic">String types and literals</em> section). </p>
			<p>All primitive types can be divided into two groups: Boolean types and numeric types.</p>
			<h2 id="_idParaDest-29"><a id="_idTextAnchor028"/>Boolean types</h2>
			<p>There are <a id="_idIndexMarker069"/>only <a id="_idIndexMarker070"/>two Boolean type values in Java: <strong class="source-inline">true</strong> and <strong class="source-inline">false</strong>. Such a value can only be assigned to a variable of a <strong class="source-inline">boolean</strong> type, as in the following example:</p>
			<pre class="source-code">boolean b = true;</pre>
			<p>A <strong class="source-inline">boolean</strong> variable is typically used in control flow statements, which we are going to discuss in the <em class="italic">Java statements</em> section. Here is one example:</p>
			<pre class="source-code">boolean b = x &gt; 2;</pre>
			<pre class="source-code">if(b){ </pre>
			<pre class="source-code">    //do something</pre>
			<pre class="source-code">}</pre>
			<p>In the preceding code, we assign to the <strong class="source-inline">b</strong> variable the result of the evaluation of the <strong class="source-inline">x &gt; 2</strong> expression. If the value of <strong class="source-inline">x</strong> is greater than <strong class="source-inline">2</strong>, the <strong class="source-inline">b</strong> variable gets the assigned value, <strong class="source-inline">true</strong>. Then, the code inside the braces (<strong class="source-inline">{}</strong>) is executed.</p>
			<h2 id="_idParaDest-30"><a id="_idTextAnchor029"/>Numeric types</h2>
			<p>Java<a id="_idIndexMarker071"/> numeric <a id="_idIndexMarker072"/>types form two groups: integral types (<strong class="source-inline">byte</strong>, <strong class="source-inline">char</strong>, <strong class="source-inline">short</strong>, <strong class="source-inline">int</strong>, and <strong class="source-inline">long</strong>) and floating-point types (<strong class="source-inline">float</strong> and <strong class="source-inline">double</strong>).</p>
			<h3>Integral types</h3>
			<p>Integral<a id="_idIndexMarker073"/> types<a id="_idIndexMarker074"/> consume the following amount of memory:</p>
			<ul>
				<li><strong class="source-inline">byte</strong>: 8 bits</li>
				<li><strong class="source-inline">char</strong>: 16 bits</li>
				<li><strong class="source-inline">short</strong>: 16 bits</li>
				<li><strong class="source-inline">int</strong>: 32 bits</li>
				<li><strong class="source-inline">long</strong>: 64 bits </li>
			</ul>
			<p>The <strong class="source-inline">char</strong> type is an unsigned integer that can hold a value (called a code point) from 0 to 65,535 inclusive. It represents a Unicode character, which means there are 65,536 Unicode characters. Here are three records from the basic Latin list of Unicode characters:</p>
			<div>
				<div id="_idContainer029" class="IMG---Figure">
					<img src="image/B18388_Table_1.1.jpg" alt=""/>
				</div>
			</div>
			<p>The following code demonstrates the properties of the <strong class="source-inline">char</strong> type (execute the <strong class="source-inline">main()</strong> method<a id="_idIndexMarker075"/> of <a id="_idIndexMarker076"/>the <strong class="source-inline">com.packt.learnjava.ch01_start.PrimitiveTypes</strong> class—see the <strong class="source-inline">charType()</strong> method):</p>
			<pre class="source-code">char x1 = '\u0032';</pre>
			<pre class="source-code">System.out.println(x1);  //prints: 2</pre>
			<pre class="source-code">char x2 = '2';</pre>
			<pre class="source-code">System.out.println(x2);  //prints: 2</pre>
			<pre class="source-code">x2 = 65;</pre>
			<pre class="source-code">System.out.println(x2);  //prints: A</pre>
			<pre class="source-code">char y1 = '\u0041';</pre>
			<pre class="source-code">System.out.println(y1);  //prints: A</pre>
			<pre class="source-code">char y2 = 'A';</pre>
			<pre class="source-code">System.out.println(y2);  //prints: A</pre>
			<pre class="source-code">y2 = 50;</pre>
			<pre class="source-code">System.out.println(y2);  //prints: 2</pre>
			<pre class="source-code">System.out.println(x1 + x2);  //prints: 115</pre>
			<pre class="source-code">System.out.println(x1 + y1);  //prints: 115</pre>
			<p>The last two lines from the preceding code example explain why the <strong class="source-inline">char</strong> type is considered an integral type because <strong class="source-inline">char</strong> values can be used in arithmetic operations. In such a case, each <strong class="source-inline">char</strong> value is represented by its code point.</p>
			<p>The range of values of other integral types is shown here:</p>
			<ul>
				<li><strong class="source-inline">byte</strong>: from -128 to 127 inclusive</li>
				<li><strong class="source-inline">short</strong>: from -32,768 to 32,767 inclusive</li>
				<li><strong class="source-inline">int</strong>: from -2.147.483.648 to 2.147.483.647 inclusive</li>
				<li><strong class="source-inline">long</strong>: from -9,223,372,036,854,775,808 to 9,223,372,036,854,775,807 inclusive</li>
			</ul>
			<p>You <a id="_idIndexMarker077"/>can <a id="_idIndexMarker078"/>always retrieve the maximum and minimum value of each primitive type from a corresponding Java constant, as follows (execute the <strong class="source-inline">main()</strong> method of the <strong class="source-inline">com.packt.learnjava.ch01_start.PrimitiveTypes</strong> class—see the <strong class="source-inline">minMax()</strong> method):</p>
			<pre class="source-code">System.out.println(Byte.MIN_VALUE);      //prints: -128</pre>
			<pre class="source-code">System.out.println(Byte.MAX_VALUE);      //prints:  127</pre>
			<pre class="source-code">System.out.println(Short.MIN_VALUE);     //prints: -32768</pre>
			<pre class="source-code">System.out.println(Short.MAX_VALUE);     //prints:  32767</pre>
			<pre class="source-code">System.out.println(Integer.MIN_VALUE);   //prints: -2147483648</pre>
			<pre class="source-code">System.out.println(Integer.MAX_VALUE);   //prints:  2147483647</pre>
			<pre class="source-code">System.out.println(Long.MIN_VALUE);      </pre>
			<pre class="source-code">                                 //prints: -9223372036854775808</pre>
			<pre class="source-code">System.out.println(Long.MAX_VALUE);</pre>
			<pre class="source-code">                                  //prints: 9223372036854775807</pre>
			<pre class="source-code">System.out.println((int)Character.MIN_VALUE); //prints: 0</pre>
			<pre class="source-code">System.out.println((int)Character.MAX_VALUE); //prints: 65535</pre>
			<p>The construct (<strong class="source-inline">int</strong>) in the last two lines is an example of cast operator usage. It forces the conversion of a value from one type to another in cases where such a conversion is not always guaranteed to be successful. As you can see from our examples, some types allow bigger values than other types. But a programmer may know that the value of a certain variable can never exceed the maximum value of the target type, and the cast operator is the way the programmer can force their opinion on the compiler. Otherwise, without a cast operator, the compiler would raise an error and would not allow the assignment. However, the programmer may be mistaken and the value may become bigger. In <a id="_idIndexMarker079"/>such a<a id="_idIndexMarker080"/> case, a runtime error will be raised during execution time.</p>
			<p>There are types that, in principle, cannot be cast to other types, though, or at least not to all types—for example, a Boolean type value cannot be cast to an integral type value.</p>
			<h3>Floating-point types</h3>
			<p>There are<a id="_idIndexMarker081"/> two<a id="_idIndexMarker082"/> types in this group of primitive types—<strong class="source-inline">float</strong> and <strong class="source-inline">double</strong>. These consume the following amount of memory: </p>
			<ul>
				<li><strong class="source-inline">float</strong>: 32 bit</li>
				<li><strong class="source-inline">double</strong>: 64 bit</li>
			</ul>
			<p>Their positive maximum and minimum possible values are shown here (execute the <strong class="source-inline">main()</strong> method of the <strong class="source-inline">com.packt.learnjava.ch01_start.PrimitiveTypes</strong> class—see the <strong class="source-inline">minMax()</strong> method):</p>
			<pre class="source-code">System.out.println(Float.MIN_VALUE);  //prints: 1.4E-45</pre>
			<pre class="source-code">System.out.println(Float.MAX_VALUE);  //prints: 3.4028235E38</pre>
			<pre class="source-code">System.out.println(Double.MIN_VALUE); //prints: 4.9E-324</pre>
			<pre class="source-code">System.out.println(Double.MAX_VALUE); </pre>
			<pre class="source-code">                               //prints: 1.7976931348623157E308</pre>
			<p>The maximum and minimum negative values are the same as those just shown, only with a minus sign (<strong class="source-inline">-</strong>) in front of them. So, effectively, the <strong class="source-inline">Float.MIN_VALUE</strong> and <strong class="source-inline">Double.MIN_VALUE</strong> values are not the minimal values, but the precision of the corresponding type. A zero value can be either 0.0 or -0.0 for each of the floating-point types. </p>
			<p>A special feature of the floating-point type is the presence of a dot (<strong class="source-inline">.</strong>) that separates integer and fractional parts of the number. By default, in Java, a number with a dot is assumed to be a <strong class="source-inline">double</strong> type. For example, the following is assumed to be a <strong class="source-inline">double </strong>value:</p>
			<p><strong class="source-inline">42.3</strong></p>
			<p>This means<a id="_idIndexMarker083"/> that <a id="_idIndexMarker084"/>the following assignment causes a compilation error:</p>
			<pre class="source-code">float f = 42.3;</pre>
			<p>To indicate that you would like it to be treated as a <strong class="source-inline">float</strong> type, you need to add either <strong class="source-inline">f</strong> or <strong class="source-inline">F</strong>. For example, the following assignments do not cause an error (execute the <strong class="source-inline">main()</strong> method of the <strong class="source-inline">com.packt.learnjava.ch01_start.PrimitiveTypes</strong> class—see the <strong class="source-inline">casting()</strong> method):</p>
			<pre class="source-code">float f = 42.3f;</pre>
			<pre class="source-code">float d = 42.3F;</pre>
			<pre class="source-code">double a = 42.3f;</pre>
			<pre class="source-code">double b = 42.3F;</pre>
			<pre class="source-code">float x = (float)42.3d;</pre>
			<pre class="source-code">float y = (float)42.3D;</pre>
			<p>As you may have noticed from the preceding example, <strong class="source-inline">d</strong> and <strong class="source-inline">D</strong> indicate a <strong class="source-inline">double</strong> type, but we were able to cast them to the <strong class="source-inline">float</strong> type because we are confident that <strong class="source-inline">42.3</strong> is <a id="_idIndexMarker085"/>well<a id="_idIndexMarker086"/> inside the range of possible <strong class="source-inline">float</strong>-type values.</p>
			<h2 id="_idParaDest-31"><a id="_idTextAnchor030"/>Default values of primitive types</h2>
			<p>In some cases, a<a id="_idIndexMarker087"/> variable has to be assigned a value even when a programmer did not want to do that. We will talk about such cases in <a href="B18388_02_ePub.xhtml#_idTextAnchor045"><em class="italic">Chapter 2</em></a>, <em class="italic">Java Object-Oriented Programming (OOP)</em>. The default primitive type value in such cases is outlined here:</p>
			<ul>
				<li><strong class="source-inline">byte</strong>, <strong class="source-inline">short</strong>, <strong class="source-inline">int</strong>, and <strong class="source-inline">long</strong> types have a default value of 0.</li>
				<li>The <strong class="source-inline">char</strong> type has a default value of <strong class="source-inline">\u0000</strong>, with the code point 0. </li>
				<li><strong class="source-inline">float</strong> and <strong class="source-inline">double</strong> types have a default value of 0.0.</li>
				<li>The <strong class="source-inline">boolean</strong> type has a default value of <strong class="source-inline">false</strong>.</li>
			</ul>
			<h2 id="_idParaDest-32"><a id="_idTextAnchor031"/>Literals of primitive types</h2>
			<p>The representation <a id="_idIndexMarker088"/>of a value is called a literal. The <strong class="source-inline">boolean</strong> type has two literals: <strong class="source-inline">true</strong> and <strong class="source-inline">false</strong>. Literals of <strong class="source-inline">byte</strong>, <strong class="source-inline">short</strong>, <strong class="source-inline">int</strong>, and <strong class="source-inline">long</strong> integral types have an <strong class="source-inline">int</strong> type by default, as illustrated here:</p>
			<pre class="source-code">byte b = 42;</pre>
			<pre class="source-code">short s = 42;</pre>
			<pre class="source-code">int i = 42;</pre>
			<pre class="source-code">long l = 42;</pre>
			<p>In addition, to indicate a literal of a <strong class="source-inline">long</strong> type, you can append the letter <strong class="source-inline">l</strong> or <strong class="source-inline">L</strong> to the end, like this:</p>
			<pre class="source-code">long l1 = 42l;</pre>
			<pre class="source-code">long l2 = 42L;</pre>
			<p>The letter <strong class="source-inline">l</strong> can be easily confused with the number <strong class="source-inline">1</strong>, so using <strong class="source-inline">L</strong> (instead of <strong class="source-inline">l</strong>) for this purpose is a good practice.</p>
			<p>So far, we have expressed integral literals in a decimal number system. Meanwhile, literals of <strong class="source-inline">byte</strong>, <strong class="source-inline">short</strong>, <strong class="source-inline">int</strong>, and <strong class="source-inline">long</strong> types can also be expressed in binary (base 2, digits 0-1), octal (base 8, digits 0-7), and hexadecimal (base 16, digits 0-9, and a-f) number systems. A binary literal starts with 0b (or 0B), followed by the value expressed in a binary system. For example, the decimal 42 is expressed as 101010 = 2^0*0 + 2^1*1 + 2^2*0 + 2^3 *1  + 2^4 *0  + 2^5 *1 (we start from the right 0). An octal literal starts with 0, followed by the value expressed in an octal system, so 42 is expressed as 52 = 8^0*2+ 8^1*5. A hexadecimal literal starts with 0x (or with 0X), followed by a value expressed in a hexadecimal system. So, 42 is expressed as 2a = 16^0*a + 16^1*2 because, in the hexadecimal system, the symbols <strong class="source-inline">a</strong> to <strong class="source-inline">f</strong> (or <strong class="source-inline">A</strong> to <strong class="source-inline">F</strong>) map to the decimal values 10 to 15. Here <a id="_idIndexMarker089"/>is the demonstration code (execute the <strong class="source-inline">main()</strong> method of the <strong class="source-inline">com.packt.learnjava.ch01_start.PrimitiveTypes</strong> class—see the <strong class="source-inline">literals()</strong> method):</p>
			<pre class="source-code">int i = 42;</pre>
			<pre class="source-code">System.out.println(Integer.toString(i, 2));       // 101010</pre>
			<pre class="source-code">System.out.println(Integer.toBinaryString(i));    // 101010</pre>
			<pre class="source-code">System.out.println(0b101010);                     // 42</pre>
			<pre class="source-code">System.out.println(Integer.toString(i, 8));       // 52</pre>
			<pre class="source-code">System.out.println(Integer.toOctalString(i));     // 52</pre>
			<pre class="source-code">System.out.println(052);                           // 42</pre>
			<pre class="source-code">System.out.println(Integer.toString(i, 10));       // 42</pre>
			<pre class="source-code">System.out.println(Integer.toString(i));           // 42</pre>
			<pre class="source-code">System.out.println(42);                            // 42</pre>
			<pre class="source-code">System.out.println(Integer.toString(i, 16));       // 2a</pre>
			<pre class="source-code">System.out.println(Integer.toHexString(i));        // 2a</pre>
			<pre class="source-code">System.out.println(0x2a);                          // 42</pre>
			<p>As you can see, Java provides methods that convert decimal system values to systems with different bases. All these expressions of numeric values are called literals.</p>
			<p>One feature of numeric literals makes them human-friendly. If the number is large, it is possible to break it into triples separated by an underscore (<strong class="source-inline">_</strong>) sign. Observe the following, for example:</p>
			<pre class="source-code">int i = 354_263_654;</pre>
			<pre class="source-code">System.out.println(i);  //prints: 354263654</pre>
			<pre class="source-code">float f = 54_436.98f;</pre>
			<pre class="source-code">System.out.println(f);  //prints: 54436.98</pre>
			<pre class="source-code">long l = 55_763_948L;</pre>
			<pre class="source-code">System.out.println(l);  //prints: 55763948</pre>
			<p>The compiler ignores an embedded underscore sign.</p>
			<p>The <strong class="source-inline">char</strong> type has <a id="_idIndexMarker090"/>two kinds of literals: a single character or an escape sequence. We have seen examples of <strong class="source-inline">char</strong>-type literals when discussing numeric types, and you can see some others here:</p>
			<pre class="source-code">char x1 = '\u0032';</pre>
			<pre class="source-code">char x2 = '2';</pre>
			<pre class="source-code">char y1 = '\u0041';</pre>
			<pre class="source-code">char y2 = 'A';</pre>
			<p>As you can see, the character has to be enclosed in single quotes. </p>
			<p>An escape sequence starts with a backslash (<strong class="source-inline">\</strong>) followed by a letter or another character. Here is a full list of escape sequences:</p>
			<ul>
				<li><strong class="source-inline">\</strong>b: backspace BS, Unicode escape <strong class="source-inline">\u0008</strong></li>
				<li>\t: horizontal tab HT, Unicode escape <strong class="source-inline">\u0009</strong></li>
				<li>\n: line feed LF, Unicode escape <strong class="source-inline">\u000a</strong></li>
				<li>\f: form feed FF, Unicode escape <strong class="source-inline">\u000c</strong></li>
				<li>\r: carriage return CR, Unicode escape <strong class="source-inline">\u000d</strong></li>
				<li>\”: double quote “, Unicode escape <strong class="source-inline">\u0022</strong></li>
				<li>\’: single quote ‘, Unicode escape <strong class="source-inline">\u0027</strong></li>
				<li>\\: backslash \, Unicode escape <strong class="source-inline">\u005c</strong></li>
			</ul>
			<p>From the eight escape sequences, only the last three are represented by a symbol. They are used when this symbol cannot be otherwise displayed. Observe the following, for example:</p>
			<pre class="source-code">System.out.println("\"");   //prints: "</pre>
			<pre class="source-code">System.out.println('\'');   //prints: '</pre>
			<pre class="source-code">System.out.println('\\');   //prints: \</pre>
			<p>The rest are used <a id="_idIndexMarker091"/>more as control codes that direct the output device to do something, as in the following example:</p>
			<pre class="source-code">System.out.println("The back\bspace");</pre>
			<pre class="source-code">                                        //prints: The backspace</pre>
			<pre class="source-code">System.out.println("The horizontal\ttab"); </pre>
			<pre class="source-code">                                   //prints: The horizontal tab</pre>
			<pre class="source-code">System.out.println("The line\nfeed"); </pre>
			<pre class="source-code">                                        //prints: The line feed</pre>
			<pre class="source-code">System.out.println("The form\ffeed");      </pre>
			<pre class="source-code">                                        //prints: The form feed</pre>
			<pre class="source-code">System.out.println("The carriage\rreturn");//prints: return</pre>
			<p>As you can see, <strong class="source-inline">\b </strong>deletes a previous symbol, <strong class="source-inline">\t</strong> inserts a tab space, <strong class="source-inline">\n</strong> breaks the line and begins the new one, <strong class="source-inline">\f</strong> forces the printer to eject the current page and to continue printing <a id="_idIndexMarker092"/>at the top of another, and <strong class="source-inline">\r</strong> starts the current line anew.</p>
			<h2 id="_idParaDest-33"><a id="_idTextAnchor032"/>New compact number format</h2>
			<p>The <strong class="source-inline">java.text.NumberFormat</strong> class presents numbers in various formats. It also allows formats<a id="_idIndexMarker093"/> to be adjusted to those provided, including locales. A new feature added to this class in Java 12 is called a compact or short number format.</p>
			<p>It represents a number in a locale-specific, human-readable form. Observe the following, for example (execute the <strong class="source-inline">main()</strong> method of the <strong class="source-inline">com.packt.learnjava.ch01_start.PrimitiveTypes</strong> class—see the <strong class="source-inline">newNumberFormat()</strong> method):</p>
			<pre class="source-code">NumberFormat fmt = NumberFormat.getCompactNumberInstance(Locale.US, NumberFormat.Style.SHORT);</pre>
			<pre class="source-code">System.out.println(fmt.format(42_000));          //prints: 42K</pre>
			<pre class="source-code">System.out.println(fmt.format(42_000_000));      //prints: 42M</pre>
			<pre class="source-code">NumberFormat fmtP = NumberFormat.getPercentInstance();</pre>
			<pre class="source-code">System.out.println(fmtP.format(0.42));          //prints: 42%</pre>
			<p>As you can see, to access this capability, you have to acquire a particular instance of the <strong class="source-inline">NumberFormat</strong> class, sometimes based on the locale and style provided.</p>
			<h2 id="_idParaDest-34"><a id="_idTextAnchor033"/>Operators</h2>
			<p>There are 44 operators<a id="_idIndexMarker094"/> in Java. These are listed in the following table:</p>
			<div>
				<div id="_idContainer030" class="IMG---Figure">
					<img src="image/B18388_Table_1.2.jpg" alt=""/>
				</div>
			</div>
			<p>We will not describe the not-often-used <strong class="source-inline">&amp;=</strong>, <strong class="source-inline">|=</strong>, <strong class="source-inline">^=</strong>, <strong class="source-inline">&lt;&lt;=</strong>, <strong class="source-inline">&gt;&gt;=</strong>, <strong class="source-inline">&gt;&gt;&gt;=</strong> assignment operators and bitwise operators, but you can read about them in the Java specification (<a href="https://docs.oracle.com/javase/specs">https://docs.oracle.com/javase/specs</a>). Arrow ( <strong class="source-inline">-&gt;</strong>) and method reference (<strong class="source-inline">::</strong>) operators will be described in <a href="B18388_14_ePub.xhtml#_idTextAnchor296"><em class="italic">Chapter 14</em></a>, <em class="italic">Java Standard Streams</em>. The <strong class="source-inline">new</strong> instance creation operator, the <strong class="source-inline">.</strong> field access/method invocation operator, and the <strong class="source-inline">instanceof</strong> type<a id="_idIndexMarker095"/> comparison operator will be discussed in <a href="B18388_02_ePub.xhtml#_idTextAnchor045"><em class="italic">Chapter 2</em></a>, <em class="italic">Java Object-Oriented Programming (OOP)</em>. As for the cast operator, we have already described it in the <em class="italic">Integral types</em> section.</p>
			<h3>Arithmetic unary (+ and -) and binary (+, -, *, /, and %) operators</h3>
			<p>Most <a id="_idIndexMarker096"/>of the<a id="_idIndexMarker097"/> arithmetic <a id="_idIndexMarker098"/>operators<a id="_idIndexMarker099"/> and positive and negative signs (unary operators) are quite familiar to us. The modulus operator (<strong class="source-inline">%</strong>) divides the left-hand operand by the right-hand operand and returns the remainder, as follows (execute the <strong class="source-inline">main()</strong> method of the <strong class="source-inline">com.packt.learnjava.ch01_start.Operators</strong> class—see the <strong class="source-inline">integerDivision()</strong> method:</p>
			<pre class="source-code">int x = 5;</pre>
			<pre class="source-code">System.out.println(x % 2);   //prints: 1</pre>
			<p>It is also worth mentioning that the division of two integer numbers in Java loses the fractional part because Java assumes the result should be an integer number <strong class="source-inline">2</strong>, as follows:</p>
			<pre class="source-code">int x = 5;</pre>
			<pre class="source-code">System.out.println(x / 2);   //prints: 2</pre>
			<p>If you need the fractional part of the result to be preserved, convert one of the operands into a floating-point type. Here are a few ways (among many) in which to do this:</p>
			<pre class="source-code">int x = 5;</pre>
			<pre class="source-code">System.out.println(x / 2.);           //prints: 2.5</pre>
			<pre class="source-code">System.out.println((1. * x) / 2);     //prints: 2.5</pre>
			<pre class="source-code">System.out.println(((float)x) / 2);   //prints: 2.5</pre>
			<pre class="source-code">System.out.println(((double) x) / 2); //prints: 2.5</pre>
			<h3>Increment and decrement unary operators (++ and --)</h3>
			<p>The <strong class="source-inline">++</strong> operator<a id="_idIndexMarker100"/> increases<a id="_idIndexMarker101"/> the <a id="_idIndexMarker102"/>value of an <a id="_idIndexMarker103"/>integral type by 1, while the <strong class="source-inline">--</strong> operator decreases it by 1. If placed before the variable (prefix), it changes its value by 1 before the variable value is returned. But when placed after the variable (postfix), it changes its value by 1 after the variable value is returned. Here are a few examples (execute the <strong class="source-inline">main()</strong> method of the <strong class="source-inline">com.packt.learnjava.ch01_start.Operators</strong> class—see the <strong class="source-inline">incrementDecrement()</strong> method):</p>
			<pre class="source-code">int i = 2;</pre>
			<pre class="source-code">System.out.println(++i);   //prints: 3</pre>
			<pre class="source-code">System.out.println(i);     //prints: 3</pre>
			<pre class="source-code">System.out.println(--i);   //prints: 2</pre>
			<pre class="source-code">System.out.println(i);     //prints: 2</pre>
			<pre class="source-code">System.out.println(i++);   //prints: 2</pre>
			<pre class="source-code">System.out.println(i);     //prints: 3</pre>
			<pre class="source-code">System.out.println(i--);   //prints: 3</pre>
			<pre class="source-code">System.out.println(i);     //prints: 2</pre>
			<h3>Equality operators (== and !=)</h3>
			<p>The <strong class="source-inline">==</strong> operator <a id="_idIndexMarker104"/>means <a id="_idIndexMarker105"/>equals, while the <strong class="source-inline">!=</strong> operator means not equals. They are used to compare values of the same type and return a <strong class="source-inline">true</strong> Boolean value if the operand’s values are <strong class="source-inline">equal</strong>, or <strong class="source-inline">false</strong> otherwise. Observe the following, for example (execute the  <strong class="source-inline">main()</strong> method of the <strong class="source-inline">com.packt.learnjava.ch01_start.Operators</strong>, class—see the <strong class="source-inline">equality()</strong> method):</p>
			<pre class="source-code">int i1 = 1;</pre>
			<pre class="source-code">int i2 = 2;</pre>
			<pre class="source-code">System.out.println(i1 == i2);        //prints: false</pre>
			<pre class="source-code">System.out.println(i1 != i2);        //prints: true</pre>
			<pre class="source-code">System.out.println(i1 == (i2 - 1));  //prints: true</pre>
			<pre class="source-code">System.out.println(i1 != (i2 - 1));  //prints: false</pre>
			<p>Exercise caution, though, while comparing values of floating-point types, especially when you compare the results of calculations. Using relational operators (<strong class="source-inline">&lt;</strong>, <strong class="source-inline">&gt;</strong>, <strong class="source-inline">&lt;=</strong>, and <strong class="source-inline">&gt;=</strong>) in such cases is much more reliable, because calculations such as 1/3—for example—result <a id="_idIndexMarker106"/>in a never-ending fractional part 0.33333333... and<a id="_idIndexMarker107"/> ultimately depend on precision implementation (a complex topic that is beyond the scope of this book).</p>
			<h3>Relational operators (&lt;, &gt;, &lt;=, and &gt;=)</h3>
			<p>Relational<a id="_idIndexMarker108"/> operators<a id="_idIndexMarker109"/> compare values and return a Boolean value. Observe the following, for example (execute the <strong class="source-inline">main()</strong> method of the <strong class="source-inline">com.packt.learnjava.ch01_start.Operators</strong> class—see the <strong class="source-inline">relational()</strong> method):</p>
			<pre class="source-code">int i1 = 1;</pre>
			<pre class="source-code">int i2 = 2;</pre>
			<pre class="source-code">System.out.println(i1 &gt; i2);         //prints: false</pre>
			<pre class="source-code">System.out.println(i1 &gt;= i2);        //prints: false</pre>
			<pre class="source-code">System.out.println(i1 &gt;= (i2 - 1));  //prints: true</pre>
			<pre class="source-code">System.out.println(i1 &lt; i2);         //prints: true</pre>
			<pre class="source-code">System.out.println(i1 &lt;= i2);        //prints: true</pre>
			<pre class="source-code">System.out.println(i1 &lt;= (i2 - 1));  //prints: true</pre>
			<pre class="source-code">float f = 1.2f;</pre>
			<pre class="source-code">System.out.println(i1 &lt; f);          //prints: true</pre>
			<h3>Logical operators (!, &amp;, and |)</h3>
			<p>Logical <a id="_idIndexMarker110"/>operators<a id="_idIndexMarker111"/> can be defined as follows:</p>
			<ul>
				<li>The <strong class="source-inline">!</strong> binary operator returns <strong class="source-inline">true</strong> if the operand is <strong class="source-inline">false</strong>; otherwise, it returns <strong class="source-inline">false</strong>.</li>
				<li>The <strong class="source-inline">&amp;</strong> binary operator returns <strong class="source-inline">true</strong> if both of the operands are <strong class="source-inline">true</strong>.</li>
				<li>The <strong class="source-inline">|</strong> binary operator returns <strong class="source-inline">true</strong> if at least one of the operands is <strong class="source-inline">true</strong>. </li>
			</ul>
			<p>Here is an example (execute the <strong class="source-inline">main()</strong> method of the <strong class="source-inline">com.packt.learnjava.ch01_start.Operators</strong> class—see the <strong class="source-inline">logical()</strong> method):</p>
			<pre class="source-code">boolean b = true;</pre>
			<pre class="source-code">System.out.println(!b);    //prints: false</pre>
			<pre class="source-code">System.out.println(!!b);   //prints: true</pre>
			<pre class="source-code">boolean c = true;</pre>
			<pre class="source-code">System.out.println(c &amp; b); //prints: true</pre>
			<pre class="source-code">System.out.println(c | b); //prints: true</pre>
			<pre class="source-code">boolean d = false;</pre>
			<pre class="source-code">System.out.println(c &amp; d); //prints: false</pre>
			<pre class="source-code">System.out.println(c | d); //prints: true</pre>
			<h3>Conditional operators (&amp;&amp;, ||, and ? :)</h3>
			<p>The <strong class="source-inline">&amp;&amp;</strong> and <strong class="source-inline">||</strong> operators <a id="_idIndexMarker112"/>produce the <a id="_idIndexMarker113"/>same results as the <strong class="source-inline">&amp;</strong> and <strong class="source-inline">|</strong> logical operators we have just demonstrated, as follows (execute the <strong class="source-inline">main()</strong> method of the <strong class="source-inline">com.packt.learnjava.ch01_start.Operators</strong> class—see the <strong class="source-inline">conditional()</strong> method):</p>
			<pre class="source-code">boolean b = true;</pre>
			<pre class="source-code">boolean c = true;</pre>
			<pre class="source-code">System.out.println(c &amp;&amp; b); //prints: true</pre>
			<pre class="source-code">System.out.println(c || b); //prints: true</pre>
			<pre class="source-code">boolean d = false;</pre>
			<pre class="source-code">System.out.println(c &amp;&amp; d); //prints: false</pre>
			<pre class="source-code">System.out.println(c || d); //prints: true</pre>
			<p>The difference is that the <strong class="source-inline">&amp;&amp;</strong> and <strong class="source-inline">||</strong> operators do not always evaluate the second operand. For example, in the case of the <strong class="source-inline">&amp;&amp;</strong> operator, if the first operand is <strong class="source-inline">false</strong>, the second operand is not<a id="_idIndexMarker114"/> evaluated because the result of the whole expression will be <strong class="source-inline">false</strong> anyway. Similarly, in the case of the <strong class="source-inline">||</strong> operator, if the first operand is <strong class="source-inline">true</strong>, the whole expression will be clearly evaluated to <strong class="source-inline">true</strong> without evaluating the second operand. We can demonstrate this in the following code snippet:</p>
			<pre class="source-code">int h = 1;</pre>
			<pre class="source-code">System.out.println(h &gt; 3 &amp;&amp; h++ &lt; 3);  //prints: false</pre>
			<pre class="source-code">System.out.println(h);                //prints: 2</pre>
			<pre class="source-code">System.out.println(h &gt; 3 &amp;&amp; h++ &lt; 3); //prints: false</pre>
			<pre class="source-code">System.out.println(h);                //prints: 2</pre>
			<p>The <strong class="source-inline">? :</strong> operator is called a ternary operator. It evaluates a condition (before the <strong class="source-inline">?</strong> sign), and if it results in <strong class="source-inline">true</strong>, assigns to a variable the value calculated by the first expression (between the <strong class="source-inline">?</strong> and <strong class="source-inline">:</strong> signs); otherwise, it assigns a value calculated by the second expression (after the <strong class="source-inline">:</strong> sign), as illustrated in the following code snippet:</p>
			<pre class="source-code">int n = 1, m = 2;</pre>
			<pre class="source-code">float k = n &gt; m ? (n * m + 3) : ((float)n / m); </pre>
			<pre class="source-code">System.out.println(k);           //prints: 0.5</pre>
			<h3>Assignment operators (=, +=, -=, *=, /=, and %=)</h3>
			<p>The <strong class="source-inline">=</strong> operator just<a id="_idIndexMarker115"/> assigns a<a id="_idIndexMarker116"/> specified value to a variable, like this:</p>
			<pre class="source-code">x = 3;</pre>
			<p>Other assignment operators calculate a new value before assigning it, as follows:</p>
			<ul>
				<li><strong class="source-inline">x += 42</strong> assigns to <strong class="source-inline">x</strong> the result of the <strong class="source-inline">x = x + 42</strong> addition operation.</li>
				<li><strong class="source-inline">x -= 42</strong> assigns to <strong class="source-inline">x</strong> the result of the <strong class="source-inline">x = x - 42</strong> subtraction operation.</li>
				<li><strong class="source-inline">x *= 42</strong> assigns to <strong class="source-inline">x</strong> the result of the <strong class="source-inline">x = x * 42</strong> multiplication operation.</li>
				<li><strong class="source-inline">x /= 42</strong> assigns to <strong class="source-inline">x</strong> the result of the <strong class="source-inline">x = x / 42</strong> division operation.</li>
				<li><strong class="source-inline">x %= 42</strong> assigns the remainder of the <strong class="source-inline">x = x + x % 42</strong> division operation.</li>
			</ul>
			<p>Here is how these operators work (execute the <strong class="source-inline">main()</strong> method of the <strong class="source-inline">com.packt.learnjava.ch01_start.Operators</strong> class—see the <strong class="source-inline">assignment()</strong> method):</p>
			<pre class="source-code">float a = 1f;</pre>
			<pre class="source-code">a += 2;</pre>
			<pre class="source-code">System.out.println(a); //prints: 3.0</pre>
			<pre class="source-code">a -= 1;</pre>
			<pre class="source-code">System.out.println(a); //prints: 2.0</pre>
			<pre class="source-code">a *= 2;</pre>
			<pre class="source-code">System.out.println(a); //prints: 4.0</pre>
			<pre class="source-code">a /= 2;</pre>
			<pre class="source-code">System.out.println(a); //prints: 2.0</pre>
			<pre class="source-code">a %= 2;</pre>
			<pre class="source-code">System.out.println(a); //prints: 0.0</pre>
			<h1 id="_idParaDest-35"><a id="_idTextAnchor034"/>String types and literals</h1>
			<p>We have just <a id="_idIndexMarker117"/>described the <a id="_idIndexMarker118"/>primitive value types of the Java language. All the other value types in Java belong to a category of reference types. Each reference type is a more complex construct than just a value. It is described by a class, which serves as a template for creating an object, and a memory area that contains values and methods (the processing code) defined in the class. An object is created by the <strong class="source-inline">new</strong> operator. We will talk about classes and objects in more detail in <a href="B18388_02_ePub.xhtml#_idTextAnchor045"><em class="italic">Chapter 2</em></a>, <em class="italic">Java Object-Oriented Programming (OOP)</em>. </p>
			<p>In this chapter, we will talk about one of the reference types called <strong class="source-inline">String</strong>. It is represented by the <strong class="source-inline">java.lang.String</strong> class, which belongs, as you can see, to the most foundational package of the JDK, <strong class="source-inline">java.lang</strong>. The reason we’re introducing the <strong class="source-inline">String</strong> class so early is that it behaves in some respects very similar to primitive types, despite being a reference type.</p>
			<p>A reference type is so-called because, in the code, we do not deal with values of this type directly. A value of a reference type is more complex than a primitive-type value. It is called an object and requires more complex memory allocation, so a reference-type variable contains a memory reference. It points (refers) to the memory area where the object resides, hence the name.</p>
			<p>This nature of the reference type requires particular attention when a reference-type variable is passed into a method as a parameter. We will discuss this in more detail in <a href="B18388_03_ePub.xhtml#_idTextAnchor079"><em class="italic">Chapter 3</em></a>, <em class="italic">Java Fundamentals</em>. For now, we will see how <strong class="source-inline">String</strong>, being a reference type, helps to optimize memory usage by storing each <strong class="source-inline">String</strong> value only once.</p>
			<h2 id="_idParaDest-36"><a id="_idTextAnchor035"/>String literals</h2>
			<p>The <strong class="source-inline">String</strong> class<a id="_idIndexMarker119"/> represents character strings in Java programs. We have seen several such strings. We have seen <strong class="source-inline">Hello, world!</strong>, for example. That is a <strong class="source-inline">String</strong> literal.</p>
			<p>Another example of a literal is <strong class="source-inline">null</strong>. Any reference class can refer to a <strong class="source-inline">null</strong> literal. It represents a reference value that does not point to any object. In the case of a <strong class="source-inline">String</strong> type, it looks like this:</p>
			<pre class="source-code">String s = null;</pre>
			<p>But a literal that consists of characters enclosed in double quotes (<strong class="source-inline">"abc"</strong>, <strong class="source-inline">"123"</strong>, and <strong class="source-inline">"a42%$#"</strong>, for example) can only be of a <strong class="source-inline">String</strong> type. In this respect, the <strong class="source-inline">String</strong> class, being a reference type, has something in common with primitive types. All <strong class="source-inline">String</strong> literals are stored in a dedicated section of memory called a string pool, and two literals are equally spelled to represent the same value from the pool (execute the <strong class="source-inline">main()</strong> method of the <strong class="source-inline">com.packt.learnjava.ch01_start.StringClass</strong> class—see the <strong class="source-inline">compareReferences()</strong> method):</p>
			<pre class="source-code">String s1 = "abc";</pre>
			<pre class="source-code">String s2 = "abc";</pre>
			<pre class="source-code">System.out.println(s1 == s2);    //prints: true</pre>
			<pre class="source-code">System.out.println("abc" == s1); //prints: true</pre>
			<p>The JVM authors have chosen such an implementation to avoid duplication and improve memory usage. The previous code examples look very much like operations involving primitive types, don’t they? But when a <strong class="source-inline">String</strong> object is created using a <strong class="source-inline">new</strong> operator, the memory for the new object is allocated outside the string pool, so references of two <strong class="source-inline">String</strong> objects—or any other objects, for that matter—are always different, as we can see here:</p>
			<pre class="source-code">String o1 = new String("abc");</pre>
			<pre class="source-code">String o2 = new String("abc");</pre>
			<pre class="source-code">System.out.println(o1 == o2);    //prints: false</pre>
			<pre class="source-code">System.out.println("abc" == o1); //prints: false</pre>
			<p>If necessary, it is possible to move the string value created with the <strong class="source-inline">new</strong> operator to the string pool using the <strong class="source-inline">intern()</strong> method, like this:</p>
			<pre class="source-code">String o1 = new String("abc");</pre>
			<pre class="source-code">System.out.println("abc" == o1);          //prints: false</pre>
			<pre class="source-code">System.out.println("abc" == o1.intern()); //prints: true</pre>
			<p>In the previous code snippet, the <strong class="source-inline">intern()</strong> method attempted to move the newly created <strong class="source-inline">"abc"</strong> value into the string pool but discovered that such a literal exists there already, so it reused the literal from the string pool. That is why the references in the last line in the preceding example are equal.</p>
			<p>The good news is that you probably will not need to create <strong class="source-inline">String</strong> objects using the <strong class="source-inline">new</strong> operator, and most Java programmers never do this. But when a <strong class="source-inline">String</strong> object is passed into your code as an input and you have no control over its origin, comparison<a id="_idIndexMarker120"/> by reference only may cause an incorrect result (if the strings have the same spelling but were created by the <strong class="source-inline">new</strong> operator). That is why, when the equality of two strings by spelling (and case) is necessary, to compare two literals or <strong class="source-inline">String</strong> objects, the <strong class="source-inline">equals()</strong> method is a better choice, as illustrated here:</p>
			<pre class="source-code">String o1 = new String("abc");</pre>
			<pre class="source-code">String o2 = new String("abc");</pre>
			<pre class="source-code">System.out.println(o1.equals(o2));       //prints: true</pre>
			<pre class="source-code">System.out.println(o2.equals(o1));       //prints: true</pre>
			<pre class="source-code">System.out.println(o1.equals("abc"));    //prints: true</pre>
			<pre class="source-code">System.out.println("abc".equals(o1));    //prints: true</pre>
			<pre class="source-code">System.out.println("abc".equals("abc")); //prints: true</pre>
			<p>We will talk about the <strong class="source-inline">equals()</strong> method and other methods of the <strong class="source-inline">String</strong> class shortly.</p>
			<p>Another feature that makes <strong class="source-inline">String</strong> literals and objects look like primitive values is that they can be added using the <strong class="source-inline">+</strong> arithmetic operator, like this (execute the <strong class="source-inline">main()</strong> method of the <strong class="source-inline">com.packt.learnjava.ch01_start.StringClass</strong> class—see the <strong class="source-inline">operatorAdd()</strong> method):</p>
			<pre class="source-code">String s1 = "abc";</pre>
			<pre class="source-code">String s2 = "abc";</pre>
			<pre class="source-code">String s = s1 + s2;</pre>
			<pre class="source-code">System.out.println(s);              //prints: abcabc</pre>
			<pre class="source-code">System.out.println(s1 + "abc");     //prints: abcabc</pre>
			<pre class="source-code">System.out.println("abc" + "abc");  //prints: abcabc</pre>
			<pre class="source-code">String o1 = new String("abc");</pre>
			<pre class="source-code">String o2 = new String("abc");</pre>
			<pre class="source-code">String o = o1 + o2;</pre>
			<pre class="source-code">System.out.println(o);              //prints: abcabc</pre>
			<pre class="source-code">System.out.println(o1 + "abc");     //prints: abcabc </pre>
			<p>No other arithmetic <a id="_idIndexMarker121"/>operator can be applied to a <strong class="source-inline">String</strong> literal or an object.</p>
			<p>A new <strong class="source-inline">String</strong> literal, called a text block, was introduced with Java 15. It facilitates the preservation of indents and multiple lines without adding white spaces in quotes. For example, here is how a programmer would add indentation before Java 15 and use <strong class="source-inline">\n</strong> to break the line:</p>
			<pre class="source-code">String html = "&lt;html&gt;\n" +</pre>
			<pre class="source-code">              "   &lt;body&gt;\n" +</pre>
			<pre class="source-code">              "       &lt;p&gt;Hello World.&lt;/p&gt;\n" +</pre>
			<pre class="source-code">              "   &lt;/body&gt;\n" +</pre>
			<pre class="source-code">              "&lt;/html&gt;\n";</pre>
			<p>And here is how the same result is achieved with Java 15:</p>
			<pre class="source-code">String html = """</pre>
			<pre class="source-code">               &lt;html&gt;</pre>
			<pre class="source-code">                   &lt;body&gt;</pre>
			<pre class="source-code">                       &lt;p&gt;Hello World.&lt;/p&gt;</pre>
			<pre class="source-code">                   &lt;/body&gt;</pre>
			<pre class="source-code">               &lt;/html&gt;</pre>
			<pre class="source-code">              """;</pre>
			<p>To see how it <a id="_idIndexMarker122"/>works, execute the <strong class="source-inline">main()</strong> method of the <strong class="source-inline">com.packt.learnjava.ch01_start.StringClass</strong> class—see the <strong class="source-inline">textBlock()</strong> method.</p>
			<h2 id="_idParaDest-37"><a id="_idTextAnchor036"/>String immutability</h2>
			<p>Since all <strong class="source-inline">String</strong> literals<a id="_idIndexMarker123"/> can be shared, the JVM authors make sure that, once stored, a <strong class="source-inline">String</strong> variable cannot be changed. This helps not only avoid the problem of concurrent modification of the same value from different places of the code but also prevents unauthorized modification of a <strong class="source-inline">String</strong> value, which often represents a username or password.</p>
			<p>The following code looks like a <strong class="source-inline">String</strong> value modification:</p>
			<pre class="source-code">String str = "abc";</pre>
			<pre class="source-code">str = str + "def";</pre>
			<pre class="source-code">System.out.println(str);       //prints: abcdef</pre>
			<pre class="source-code">str = str + new String("123");</pre>
			<pre class="source-code">System.out.println(str);       //prints: abcdef123</pre>
			<p>But, behind the scenes, the original <strong class="source-inline">"abc"</strong> literal remains intact. Instead, a few new literals were created: <strong class="source-inline">"def"</strong>, <strong class="source-inline">"abcdef"</strong>, <strong class="source-inline">"123"</strong>, and <strong class="source-inline">"abcdef123"</strong>. To prove this, we have executed the following code:</p>
			<pre class="source-code">String str1 = "abc";</pre>
			<pre class="source-code">String r1 = str1;</pre>
			<pre class="source-code">str1 = str1 + "def";</pre>
			<pre class="source-code">String r2 = str1;</pre>
			<pre class="source-code">System.out.println(r1 == r2);      //prints: false</pre>
			<pre class="source-code">System.out.println(r1.equals(r2)); //prints: false</pre>
			<p>As you can see, the <strong class="source-inline">r1</strong> and <strong class="source-inline">r2</strong> variables refer to different memories, and the objects they refer to<a id="_idIndexMarker124"/> are spelled differently too.</p>
			<p>We will talk more about strings in <a href="B18388_05_ePub.xhtml#_idTextAnchor121"><em class="italic">Chapter 5</em></a>, <em class="italic">Strings, Input/Output, and Files</em>.</p>
			<h1 id="_idParaDest-38"><a id="_idTextAnchor037"/>IDs and variables</h1>
			<p>From our school days, we have an intuitive understanding of what a variable is. We think of it as a name that represents a value. We solve problems using such variables as <em class="italic">x</em> gallons of water or <em class="italic">n</em> miles of distance, and similar. In Java, the name of a variable is called an ID and can be constructed by certain rules. Using an ID, a variable can be declared (defined) and initialized.</p>
			<h2 id="_idParaDest-39"><a id="_idTextAnchor038"/>ID</h2>
			<p>According <a id="_idIndexMarker125"/>to the <em class="italic">Java Language Specification</em> (<a href="https://docs.oracle.com/javase/specs">https://docs.oracle.com/javase/specs</a>), an ID (a variable name) can be a sequence of Unicode characters that represent letters, digits 0-9, a dollar sign (<strong class="source-inline">$</strong>), or an underscore (<strong class="source-inline">_</strong>).</p>
			<p>Other limitations are outlined here:</p>
			<ul>
				<li>The first symbol of an ID cannot be a digit.</li>
				<li>An ID cannot have the same spelling as a keyword (see the <em class="italic">Java keywords</em> section of <a href="B18388_03_ePub.xhtml#_idTextAnchor079"><em class="italic">Chapter 3</em></a>, <em class="italic">Java Fundamentals</em>).</li>
				<li>It cannot be spelled as a <strong class="source-inline">true</strong> or <strong class="source-inline">false</strong> Boolean literal or as a <strong class="source-inline">null</strong> literal.</li>
				<li>And since Java 9, an ID cannot be just an underscore (<strong class="source-inline">_</strong>).</li>
			</ul>
			<p>Here are a few unusual but legal examples of IDs:</p>
			<pre class="source-code">$</pre>
			<pre class="source-code">_42</pre>
			<pre class="source-code">αρετη</pre>
			<pre class="source-code">String</pre>
			<h2 id="_idParaDest-40"><a id="_idTextAnchor039"/>Variable declaration (definition) and initialization</h2>
			<p>A variable has <a id="_idIndexMarker126"/>a name (an ID) and a type. Typically, it refers to the memory where a value is stored, but may refer to nothing (<strong class="source-inline">null</strong>) or not refer to anything at all (then, it is not initialized). It can represent a class property, an array element, a method parameter, and a local variable. The last one is the most frequently used kind of variable. </p>
			<p>Before a variable can be used, it has to be declared and initialized. In some other programming languages, a variable can also be defined, so Java programmers sometimes use the word <em class="italic">definition</em> as a synonym of declaration, which is not exactly correct.</p>
			<p>Here is a terminology review with examples:</p>
			<pre class="source-code">int x;      //declaration of variable x</pre>
			<pre class="source-code">x = 1;      //initialization of variable x</pre>
			<pre class="source-code">x = 2;      //assignment of variable x</pre>
			<p>Initialization and assignment look the same. The difference is in their sequence: the first assignment is called initialization. Without an initialization, a variable cannot be used.</p>
			<p>Declaration and initialization can be combined in a single statement. Observe the following, for example:</p>
			<pre class="source-code">float $ = 42.42f;</pre>
			<pre class="source-code">String _42 = "abc";</pre>
			<pre class="source-code">int αρετη = 42;</pre>
			<pre class="source-code">double String = 42.;</pre>
			<h3>var type holder </h3>
			<p>In Java 10, a sort <a id="_idIndexMarker127"/>of type holder, <strong class="source-inline">var</strong>, was introduced. The <em class="italic">Java Language Specification</em> defines it thus: “<em class="italic">var is not a keyword, but an identifier with special meaning as the type of a local variable declaration</em>.”</p>
			<p>In practical terms, it lets a compiler figure out the nature of the declared variable, as follows (see the <strong class="source-inline">var()</strong> method in the <strong class="source-inline">com.packt.learnjava.ch01_start.PrimitiveTypes</strong> class):</p>
			<pre class="source-code">var x = 1;</pre>
			<p>In the preceding example, the compiler can reasonably assume that <strong class="source-inline">x</strong> has the <strong class="source-inline">int </strong>primitive type.</p>
			<p>As you may have guessed, to accomplish that, a declaration on its own would not suffice, as we can see here:</p>
			<pre class="source-code">var x;    //compilation error</pre>
			<p>That is, without <a id="_idIndexMarker128"/>initialization, the compiler cannot figure out the type of the variable when <strong class="source-inline">var</strong> is used.</p>
			<h1 id="_idParaDest-41"><a id="_idTextAnchor040"/>Java statements</h1>
			<p>A Java statement is a<a id="_idIndexMarker129"/> minimal construct that can be executed. It describes an action and ends with a semicolon (<strong class="source-inline">;</strong>). We have seen many statements already. For example, here are three statements:</p>
			<pre class="source-code">float f = 23.42f;</pre>
			<pre class="source-code">String sf = String.valueOf(f);</pre>
			<pre class="source-code">System.out.println(sf);</pre>
			<p>The first line is a declaration statement combined with an assignment statement. The second line is also a declaration statement combined with an assignment statement and method invocation statement. The third line is just a method invocation statement.</p>
			<p>Here is a list of Java statement types:</p>
			<ul>
				<li>An empty statement that consists of only one symbol, <strong class="source-inline">;</strong> (semicolon)</li>
				<li>A class or interface declaration statement (we will talk about this in <a href="B18388_02_ePub.xhtml#_idTextAnchor045"><em class="italic">Chapter 2</em></a>, <em class="italic">Java Object-Oriented Programming (OOP)</em>)</li>
				<li>A local variable declaration statement: <strong class="source-inline">int x</strong>;</li>
				<li>A synchronized statement: this is beyond the scope of this book</li>
				<li>An expression statement</li>
				<li>A control flow statement </li>
			</ul>
			<p>An expression statement can be one of the following:</p>
			<ul>
				<li>A method invocation statement: <strong class="source-inline">someMethod();</strong></li>
				<li>An assignment statement: <strong class="source-inline">n = 23.42f;</strong></li>
				<li>An object creation statement: <strong class="source-inline">new String("abc");</strong></li>
				<li>A unary increment or decrement statement: <strong class="source-inline">++x ; or --x; or x++; or x--;</strong></li>
			</ul>
			<p>We will talk more about expression statements in the <em class="italic">Expression statements</em> section.</p>
			<p>A control flow statement can be one of the following:</p>
			<ul>
				<li>A selection statement: <strong class="source-inline">if-else</strong> or <strong class="source-inline">switch-case</strong></li>
				<li>An iteration statement: <strong class="source-inline">for</strong>, <strong class="source-inline">or while</strong>, or <strong class="source-inline">do-while</strong></li>
				<li>An exception-handling statement: <strong class="source-inline">throw</strong>, <strong class="source-inline">try-catch</strong>, or <strong class="source-inline">try-catch-finally</strong> </li>
				<li>A <a id="_idIndexMarker130"/>branching statement: <strong class="source-inline">break</strong>, <strong class="source-inline">continue</strong>, or <strong class="source-inline">return</strong> </li>
			</ul>
			<p>We will talk more about control statements in the <em class="italic">Control flow statements</em> section.</p>
			<h2 id="_idParaDest-42"><a id="_idTextAnchor041"/>Expression statements</h2>
			<p>An expression<a id="_idIndexMarker131"/> statement consists of one or more <a id="_idIndexMarker132"/>expressions. An expression typically includes one or more operators. It can be evaluated, which means it can produce a result of one of the following types:</p>
			<ul>
				<li>A variable: <strong class="source-inline">x = 1</strong>, for example</li>
				<li>A value: <strong class="source-inline">2*2</strong>, for example</li>
			</ul>
			<p>It returns nothing when the expression is an invocation of a method that returns <strong class="source-inline">void</strong>. Such a method is said to produce only a side effect: <strong class="source-inline">void someMethod()</strong>, for example.</p>
			<p>Consider the following expression:</p>
			<pre class="source-code">x = y++; </pre>
			<p>The preceding expression assigns a value to an <strong class="source-inline">x</strong> variable and has a side effect of adding 1 to the value of the <strong class="source-inline">y</strong> variable.</p>
			<p>Another example would be a method that prints a line, like this:</p>
			<pre class="source-code">System.out.println(x); </pre>
			<p>The <strong class="source-inline">println()</strong> method returns nothing and has a side effect of printing something.</p>
			<p>By its form, an expression can be one of the following:</p>
			<ul>
				<li>A primary expression: a literal, a new object creation, a field or method access (invocation).</li>
				<li>A unary operator expression: <strong class="source-inline">x++</strong>, for example.</li>
				<li>A binary operator expression: <strong class="source-inline">x*y</strong>, for example.</li>
				<li>A ternary operator expression: <strong class="source-inline">x &gt; y ? true : false</strong>, for example.</li>
				<li>A lambda expression: <strong class="source-inline">x -&gt; x + 1</strong> (see <a href="B18388_14_ePub.xhtml#_idTextAnchor296"><em class="italic">Chapter 14</em></a>, <em class="italic">Java Standard Streams</em>).</li>
				<li>If an <a id="_idIndexMarker133"/>expression consists of other expressions, parentheses<a id="_idIndexMarker134"/> are often used to identify each of the expressions clearly. This way, it is easier to understand and to set the expressions’ precedence.</li>
			</ul>
			<h2 id="_idParaDest-43"><a id="_idTextAnchor042"/>Control flow statements</h2>
			<p>When a<a id="_idIndexMarker135"/> Java<a id="_idIndexMarker136"/> program is executed, it is executed statement by statement. Some statements have to be executed conditionally, based on the result of an expression evaluation. Such statements are called control flow statements because, in computer science, a control flow (or flow of control) is the order in which individual statements are executed or evaluated.</p>
			<p>A control flow statement can be one of the following:</p>
			<ul>
				<li>A<a id="_idIndexMarker137"/> selection<a id="_idIndexMarker138"/> statement: <strong class="source-inline">if-else</strong> or <strong class="source-inline">switch-case</strong></li>
				<li>An iteration statement: <strong class="source-inline">for</strong>, <strong class="source-inline">while</strong>, or <strong class="source-inline">do-while</strong></li>
				<li>An exception-handling statement: <strong class="source-inline">throw</strong>, <strong class="source-inline">try-catch</strong>, or <strong class="source-inline">try-catch-finally</strong> </li>
				<li>A branching statement: <strong class="source-inline">break</strong>, <strong class="source-inline">continue</strong>, or <strong class="source-inline">return</strong> </li>
			</ul>
			<h3>Selection statements</h3>
			<p>Selection<a id="_idIndexMarker139"/> statements are based on an expression <a id="_idIndexMarker140"/>evaluation and have four variations, as outlined here:</p>
			<ul>
				<li><strong class="source-inline">if</strong> (expression) {do something}</li>
				<li><strong class="source-inline">if</strong> (expression) {do something} <strong class="source-inline">else</strong> {do something else}</li>
				<li><strong class="source-inline">if</strong> (expression) {do something} <strong class="source-inline">else if</strong> {do something else} <strong class="source-inline">else</strong> {do something else}</li>
				<li><strong class="source-inline">switch...case</strong> statement</li>
			</ul>
			<p>Here are some examples of <strong class="source-inline">if</strong> statements:</p>
			<pre class="source-code">if(x &gt; y){</pre>
			<pre class="source-code">    //do something</pre>
			<pre class="source-code">}</pre>
			<pre class="source-code">if(x &gt; y){</pre>
			<pre class="source-code">    //do something</pre>
			<pre class="source-code">} else {</pre>
			<pre class="source-code">    //do something else</pre>
			<pre class="source-code">}</pre>
			<pre class="source-code">if(x &gt; y){</pre>
			<pre class="source-code">    //do something</pre>
			<pre class="source-code">} else if (x == y){</pre>
			<pre class="source-code">    //do something else</pre>
			<pre class="source-code">} else {</pre>
			<pre class="source-code">    //do something different</pre>
			<pre class="source-code">}</pre>
			<p>A <strong class="source-inline">switch...case</strong> statement<a id="_idIndexMarker141"/> is a variation<a id="_idIndexMarker142"/> of an <strong class="source-inline">if...else</strong> statement, as illustrated here:</p>
			<pre class="source-code">switch(x){</pre>
			<pre class="source-code">    case 5:               //means: if(x = 5)</pre>
			<pre class="source-code">        //do something </pre>
			<pre class="source-code">        break;</pre>
			<pre class="source-code">    case 7:             </pre>
			<pre class="source-code">        //do something else</pre>
			<pre class="source-code">        break;</pre>
			<pre class="source-code">    case 12:</pre>
			<pre class="source-code">        //do something different</pre>
			<pre class="source-code">        break;</pre>
			<pre class="source-code">    default:             </pre>
			<pre class="source-code">        //do something completely different</pre>
			<pre class="source-code">        //if x is not 5, 7, or 12</pre>
			<pre class="source-code">}</pre>
			<p>As you can see, the <strong class="source-inline">switch...case</strong> statement forks the execution flow based on the value of the variable. The <strong class="source-inline">break</strong> statement allows the <strong class="source-inline">switch...case</strong> statement to be executed. Otherwise, all the following cases would be executed.</p>
			<p>In Java 14, a new <strong class="source-inline">switch...case</strong> statement<a id="_idIndexMarker143"/> has been introduced in a less verbose form, as <a id="_idIndexMarker144"/>illustrated here:</p>
			<pre class="source-code">void switchStatement(int x){</pre>
			<pre class="source-code">    switch (x) {</pre>
			<pre class="source-code">        case 1, 3 -&gt; System.out.print("1 or 3");</pre>
			<pre class="source-code">        case 4    -&gt; System.out.print("4");</pre>
			<pre class="source-code">        case 5, 6 -&gt; System.out.print("5 or 6");</pre>
			<pre class="source-code">        default   -&gt; System.out.print("Not 1,3,4,5,6");</pre>
			<pre class="source-code">    }</pre>
			<pre class="source-code">    System.out.println(": " + x);</pre>
			<pre class="source-code">}</pre>
			<p>As you can see, it uses an arrow (<strong class="source-inline">-&gt;</strong>) and does not use a <strong class="source-inline">break</strong> statement. </p>
			<p>Execute the <strong class="source-inline">main()</strong> method of the <strong class="source-inline">com.packt.learnjava.ch01_start.ControlFlow</strong> class—see the <strong class="source-inline">selection()</strong> method that calls the <strong class="source-inline">switchStatement()</strong> method with different parameters, as follows:</p>
			<pre class="source-code">switchStatement(1);    //prints: 1 or 3: 1</pre>
			<pre class="source-code">switchStatement(2);    //prints: Not 1,3,4,5,6: 2</pre>
			<pre class="source-code">switchStatement(5);    //prints: 5 or 6: 5</pre>
			<p>You can see the results from the comments.</p>
			<p>If several lines of code have to be executed in each case, you can just put braces (<strong class="source-inline">{}</strong>) around the block of code, as follows:</p>
			<pre class="source-code">switch (x) {</pre>
			<pre class="source-code">    case 1, 3 -&gt; { </pre>
			<pre class="source-code">                    //do something</pre>
			<pre class="source-code">                 }</pre>
			<pre class="source-code">    case 4    -&gt; {</pre>
			<pre class="source-code">                    //do something else </pre>
			<pre class="source-code">                 }</pre>
			<pre class="source-code">    case 5, 6 -&gt; System.out.println("5 or 6");</pre>
			<pre class="source-code">    default   -&gt; System.out.println("Not 1,3,4,5,6");</pre>
			<pre class="source-code">}</pre>
			<p>The<a id="_idIndexMarker145"/> Java 14 <strong class="source-inline">switch...case</strong> statement <a id="_idIndexMarker146"/>can even return a value, thus becoming in effect a <strong class="source-inline">switch</strong> expression. For example, here is a case when another variable has to be assigned based on the <strong class="source-inline">switch...case</strong> statement result:</p>
			<pre class="source-code">void switchExpression1(int i){</pre>
			<pre class="source-code">    boolean b = switch(i) {</pre>
			<pre class="source-code">        case 0, 1 -&gt; false;</pre>
			<pre class="source-code">        case 2 -&gt; true;</pre>
			<pre class="source-code">        default -&gt; false;</pre>
			<pre class="source-code">    };</pre>
			<pre class="source-code">    System.out.println(b);</pre>
			<pre class="source-code">}</pre>
			<p>If we execute the <strong class="source-inline">switchExpression1()</strong> method (see the <strong class="source-inline">selection()</strong> method of the <strong class="source-inline">com.packt.learnjava.ch01_start.ControlFlow</strong> class), the results are going to look like this:</p>
			<pre class="source-code">switchExpression1(0);    //prints: false</pre>
			<pre class="source-code">switchExpression1(1);    //prints: false</pre>
			<pre class="source-code">switchExpression1(2);    //prints: true</pre>
			<p>The following example of a <strong class="source-inline">switch</strong> expression is based on a constant:</p>
			<pre class="source-code">static final String ONE = "one", TWO = "two", THREE = "three", </pre>
			<pre class="source-code">                    FOUR = "four", FIVE = "five";</pre>
			<pre class="source-code">void switchExpression2(String number){</pre>
			<pre class="source-code">    var res = switch(number) {</pre>
			<pre class="source-code">        case ONE, TWO -&gt; 1;</pre>
			<pre class="source-code">        case THREE, FOUR, FIVE -&gt; 2;</pre>
			<pre class="source-code">        default -&gt; 3;</pre>
			<pre class="source-code">    };</pre>
			<pre class="source-code">    System.out.println(res);</pre>
			<pre class="source-code">}</pre>
			<p>If we<a id="_idIndexMarker147"/> execute the  <strong class="source-inline">switchExpression2()</strong> method (see<a id="_idIndexMarker148"/> the <strong class="source-inline">selection()</strong> method of the <strong class="source-inline">com.packt.learnjava.ch01_start.ControlFlow</strong> class), the results are going to look like this:        </p>
			<pre class="source-code">switchExpression2(TWO);            //prints: 1</pre>
			<pre class="source-code">switchExpression2(FOUR);           //prints: 2</pre>
			<pre class="source-code">switchExpression2("blah");         //prints: 3</pre>
			<p>Here’s yet another example of a <strong class="source-inline">switch</strong> expression, this time based on the <strong class="source-inline">enum</strong> value:</p>
			<pre class="source-code">enum Num { ONE, TWO, THREE, FOUR, FIVE }</pre>
			<pre class="source-code">void switchExpression3(Num number){</pre>
			<pre class="source-code">    var res = switch(number) {</pre>
			<pre class="source-code">        case ONE, TWO -&gt; 1;</pre>
			<pre class="source-code">        case THREE, FOUR, FIVE -&gt; 2;</pre>
			<pre class="source-code">    };</pre>
			<pre class="source-code">    System.out.println(res);</pre>
			<pre class="source-code">}</pre>
			<p>If we execute the <strong class="source-inline">switchExpression3()</strong> method (see the <strong class="source-inline">selection()</strong> method of the <strong class="source-inline">com.packt.learnjava.ch01_start.ControlFlow</strong> class), the results are going to look like this:        </p>
			<pre class="source-code">switchExpression3(Num.TWO);        //prints: 1</pre>
			<pre class="source-code">switchExpression3(Num.FOUR);       //prints: 2</pre>
			<pre class="source-code">//switchExpression3("blah"); //does not compile</pre>
			<p>In case a block of code has to be executed based on a particular input value, it is not possible to<a id="_idIndexMarker149"/> use a <strong class="source-inline">return</strong> statement<a id="_idIndexMarker150"/> because it is reserved already for the returning value from a method. That is why, to return a value from a block, we have to use a <strong class="source-inline">yield</strong> statement, as shown in the following example:</p>
			<pre class="source-code">void switchExpression4(Num number){</pre>
			<pre class="source-code">    var res = switch(number) {</pre>
			<pre class="source-code">        case ONE, TWO -&gt; 1;</pre>
			<pre class="source-code">        case THREE, FOUR, FIVE -&gt; {</pre>
			<pre class="source-code">            String s = number.name();</pre>
			<pre class="source-code">            yield s.length();</pre>
			<pre class="source-code">        }</pre>
			<pre class="source-code">    };</pre>
			<pre class="source-code">    System.out.println(res);</pre>
			<pre class="source-code">}</pre>
			<p>If we execute the <strong class="source-inline">switchExpression4()</strong> method (see the <strong class="source-inline">selection()</strong> method of the <strong class="source-inline">com.packt.learnjava.ch01_start.ControlFlow</strong> class), the results are going to look like this:</p>
			<pre class="source-code">switchExpression4(Num.TWO);        //prints: 1</pre>
			<pre class="source-code">switchExpression4(Num.THREE);      //prints: 5</pre>
			<h3>Iteration statements</h3>
			<p>An iteration<a id="_idIndexMarker151"/> statement can take one of the following <a id="_idIndexMarker152"/>three forms:</p>
			<ul>
				<li>A <strong class="source-inline">while</strong> statement</li>
				<li>A <strong class="source-inline">do...while</strong> statement</li>
				<li>A <strong class="source-inline">for</strong> statement, also called a <strong class="source-inline">loop</strong> statement</li>
			</ul>
			<p>A <strong class="source-inline">while</strong> statement looks like this:</p>
			<pre class="source-code">while (boolean expression){</pre>
			<pre class="source-code">      //do something</pre>
			<pre class="source-code">}</pre>
			<p>Here is a specific example (execute the <strong class="source-inline">main()</strong> method of the <strong class="source-inline">com.packt.learnjava.ch01_start.ControlFlow</strong> class—see the <strong class="source-inline">iteration()</strong> method):</p>
			<pre class="source-code">int n = 0;</pre>
			<pre class="source-code">while(n &lt; 5){</pre>
			<pre class="source-code"> System.out.print(n + " "); //prints: 0 1 2 3 4 </pre>
			<pre class="source-code"> n++;</pre>
			<pre class="source-code">}</pre>
			<p>In some examples, instead of the <strong class="source-inline">println()</strong> method, we use the <strong class="source-inline">print()</strong> method, which does not feed another line (does not add a line feed control at the end of its output). The <strong class="source-inline">print()</strong> method displays the output in one line.</p>
			<p>A <strong class="source-inline">do...while</strong> statement has a very similar form, as we can see here:</p>
			<pre class="source-code">do {</pre>
			<pre class="source-code">    //do something</pre>
			<pre class="source-code">} while (boolean expression)</pre>
			<p>It differs from a <strong class="source-inline">while</strong> statement by always executing the block of statements at least once before evaluating the expression, as illustrated in the following code snippet:</p>
			<pre class="source-code">int n = 0;</pre>
			<pre class="source-code">do {</pre>
			<pre class="source-code">    System.out.print(n + " ");   //prints: 0 1 2 3 4</pre>
			<pre class="source-code">    n++;</pre>
			<pre class="source-code">} while(n &lt; 5);</pre>
			<p>As you can see, it behaves the same way when the expression is <strong class="source-inline">true</strong> at the first iteration. But if the <a id="_idIndexMarker153"/>expression evaluates to <strong class="source-inline">false</strong>, the <a id="_idIndexMarker154"/>results are different, as we can see here:</p>
			<pre class="source-code">int n = 6;</pre>
			<pre class="source-code">while(n &lt; 5){</pre>
			<pre class="source-code">    System.out.print(n + " ");   //prints nothing</pre>
			<pre class="source-code">    n++;</pre>
			<pre class="source-code">}</pre>
			<pre class="source-code">n = 6;</pre>
			<pre class="source-code">do {</pre>
			<pre class="source-code">    System.out.print(n + " ");   //prints: 6</pre>
			<pre class="source-code">    n++;</pre>
			<pre class="source-code">} while(n &lt; 5);</pre>
			<p><strong class="source-inline">for</strong> statement syntax looks like this:</p>
			<pre class="source-code">for(init statements; boolean expression; update statements) {</pre>
			<pre class="source-code"> //do what has to be done here</pre>
			<pre class="source-code">}</pre>
			<p>Here is how a <strong class="source-inline">for</strong> statement works:</p>
			<ol>
				<li value="1"><strong class="source-inline">init</strong> statements initialize a variable.</li>
				<li>A Boolean expression is evaluated using the current variable value: if <strong class="source-inline">true</strong>, the block of statements is executed; otherwise, the <strong class="source-inline">for</strong> statement exits.</li>
				<li><strong class="source-inline">update</strong> statements update the variable, and the Boolean expression is evaluated again with this new value: if <strong class="source-inline">true</strong>, the block of statements is executed; otherwise, the <strong class="source-inline">for</strong> statement exits.</li>
				<li>Unless exited, the final step is repeated.</li>
			</ol>
			<p>As you can<a id="_idIndexMarker155"/> see <a id="_idIndexMarker156"/>here, if you aren’t careful, you can get into an infinite loop:</p>
			<pre class="source-code">for (int x = 0; x &gt; -1; x++){</pre>
			<pre class="source-code">    System.out.print(x + " ");  //prints: 0 1 2 3 4 5 6 ...</pre>
			<pre class="source-code">}</pre>
			<p>So, you have to make sure that the Boolean expression guarantees eventual exit from the loop, like this:</p>
			<pre class="source-code">for (int x = 0; x &lt; 3; x++){</pre>
			<pre class="source-code">    System.out.print(x + " ");  //prints: 0 1 2</pre>
			<pre class="source-code">}</pre>
			<p>The following example demonstrates multiple initialization and <strong class="source-inline">update</strong> statements:</p>
			<pre class="source-code">for (int x = 0, y = 0; x &lt; 3 &amp;&amp; y &lt; 3; ++x, ++y){</pre>
			<pre class="source-code">    System.out.println(x + " " + y);</pre>
			<pre class="source-code">}</pre>
			<p>And here is a variation of the preceding code for statements for demonstration purposes:</p>
			<pre class="source-code">for (int x = getInitialValue(), i = x == -2 ? x + 2 : 0, </pre>
			<pre class="source-code">             j = 0; i &lt; 3 || j &lt; 3 ; ++i, j = i) {</pre>
			<pre class="source-code"> System.out.println(i + " " + j);</pre>
			<pre class="source-code">}</pre>
			<p>If the <strong class="source-inline">getInitialValue()</strong> method is implemented like <strong class="source-inline">int getInitialValue(){ return -2; }</strong>, then the preceding two <strong class="source-inline">for</strong> statements produce exactly the same results.</p>
			<p>To iterate over an array of values, you can use an array index, like so:</p>
			<pre class="source-code">int[] arr = {24, 42, 0};</pre>
			<pre class="source-code">for (int i = 0; i &lt; arr.length; i++){</pre>
			<pre class="source-code">    System.out.print(arr[i] + " ");  //prints: 24 42 0</pre>
			<pre class="source-code">}</pre>
			<p>Alternatively, you <a id="_idIndexMarker157"/>can use a more compact form<a id="_idIndexMarker158"/> of a <strong class="source-inline">for</strong> statement that produces the same result, as follows:</p>
			<pre class="source-code">int[] arr = {24, 42, 0};</pre>
			<pre class="source-code">for (int a: arr){</pre>
			<pre class="source-code">    System.out.print(a + " ");  //prints: 24 42 0</pre>
			<pre class="source-code">}</pre>
			<p>This last form is especially useful with a collection, as shown here:</p>
			<pre class="source-code">List&lt;String&gt; list = List.of("24", "42", "0");</pre>
			<pre class="source-code">for (String s: list){</pre>
			<pre class="source-code">    System.out.print(s + " ");  //prints: 24 42 0</pre>
			<pre class="source-code">}</pre>
			<p>We will talk about collections in <a href="B18388_06_ePub.xhtml#_idTextAnchor141"><em class="italic">Chapter 6</em></a>, <em class="italic">Data Structures, Generics, and Popular Utilities</em>.</p>
			<h3>Exception-handling statements</h3>
			<p>In Java, there are<a id="_idIndexMarker159"/> classes called <a id="_idIndexMarker160"/>exceptions that represent events that disrupt the normal execution flow. They typically have names that end with <strong class="source-inline">Exception</strong>: <strong class="source-inline">NullPointerException</strong>, <strong class="source-inline">ClassCastException</strong>, <strong class="source-inline">ArrayIndexOutOfBoundsException</strong>, to name but a few.</p>
			<p>All the exception classes extend the <strong class="source-inline">java.lang.Exception</strong> class, which, in turn, extends the <strong class="source-inline">java.lang.Throwable</strong> class (we will explain what this means in <a href="B18388_02_ePub.xhtml#_idTextAnchor045"><em class="italic">Chapter 2</em></a>, <em class="italic">Java Object-Oriented Programming (OOP)</em>). That’s why all exception objects have common behavior. They contain information about the cause of the exceptional condition and the location of its origination (line number of the source code).</p>
			<p>Each exception object can be generated (thrown) either automatically by the JVM or by the application code, using the <strong class="source-inline">throw</strong> keyword. If a block of code throws an exception, you can use a <strong class="source-inline">try-catch</strong> or <strong class="source-inline">try-catch-finally</strong> construct to capture the thrown exception object and redirect the execution flow to another branch of code. If the surrounding code does not catch the exception object, it propagates all the way out of the application into the JVM and forces it to exit (and abort the application execution). So, it is good practice to use <strong class="source-inline">try-catch</strong> or <strong class="source-inline">try-catch-finally</strong> in all the places where an exception can be raised and you do not want your application to abort execution.</p>
			<p>Here is a typical example of exception handling:</p>
			<pre class="source-code">try {</pre>
			<pre class="source-code">    //x = someMethodReturningValue();</pre>
			<pre class="source-code">    if(x &gt; 10){</pre>
			<pre class="source-code">        throw new RuntimeException("The x value is out</pre>
			<pre class="source-code">                                    of range: " + x);</pre>
			<pre class="source-code">    }</pre>
			<pre class="source-code">    //normal processing flow of x here</pre>
			<pre class="source-code">} catch (RuntimeException ex) {</pre>
			<pre class="source-code">    //do what has to be done to address the problem</pre>
			<pre class="source-code">}</pre>
			<p>In the preceding code snippet, normal processing flow will be not executed in the case of <strong class="source-inline">x &gt; 10</strong>. Instead, the <strong class="source-inline">do what has to be done</strong> block will be executed. But, in the <strong class="source-inline">x &lt;= 10</strong> case, the normal processing flow block will be run and the <strong class="source-inline">do what has to be done</strong> block will be ignored.</p>
			<p>Sometimes, it is necessary to execute a block of code anyway, whether an exception was thrown/caught or not. Instead of repeating the same code block in two places, you can put it in a <strong class="source-inline">finally</strong> block, as<a id="_idIndexMarker161"/> follows (execute<a id="_idIndexMarker162"/> the <strong class="source-inline">main()</strong> method of the <strong class="source-inline">com.packt.learnjava.ch01_start.ControlFlow</strong> class—see the <strong class="source-inline">exception()</strong> method):</p>
			<pre class="source-code">try {</pre>
			<pre class="source-code">    //x = someMethodReturningValue();</pre>
			<pre class="source-code">    if(x &gt; 10){</pre>
			<pre class="source-code">        throw new RuntimeException("The x value is out </pre>
			<pre class="source-code">                                    of range: " + x);</pre>
			<pre class="source-code">    }</pre>
			<pre class="source-code">    //normal processing flow of x here</pre>
			<pre class="source-code">} catch (RuntimeException ex) {</pre>
			<pre class="source-code">   System.out.println(ex.getMessage());   </pre>
			<pre class="source-code">   //prints: The x value is out of range: ...</pre>
			<pre class="source-code">   //do what has to be done to address the problem</pre>
			<pre class="source-code">} finally {</pre>
			<pre class="source-code">   //the code placed here is always executed</pre>
			<pre class="source-code">}</pre>
			<p>We will talk about exception handling in more detail in <a href="B18388_04_ePub.xhtml#_idTextAnchor110"><em class="italic">Chapter 4</em></a>, <em class="italic">Exception Handling</em>.</p>
			<h3>Branching statements</h3>
			<p>Branching<a id="_idIndexMarker163"/> statements allow breaking of the <a id="_idIndexMarker164"/>current execution flow and continuation of execution from the first line after the current block or from a certain (labeled) point of the control flow.</p>
			<p>A branching statement can be one of the following:</p>
			<ul>
				<li><strong class="source-inline">break</strong> </li>
				<li><strong class="source-inline">continue</strong> </li>
				<li><strong class="source-inline">return</strong> </li>
			</ul>
			<p>We have seen how <strong class="source-inline">break</strong> was used in <strong class="source-inline">switch-case</strong> statements. Here is another example (execute the <strong class="source-inline">main()</strong> method of the <strong class="source-inline">com.packt.learnjava.ch01_start.ControlFlow</strong> class—see the <strong class="source-inline">branching()</strong> method):</p>
			<pre class="source-code">String found = null;</pre>
			<pre class="source-code">List&lt;String&gt; list = List.of("24", "42", "31", "2", "1");</pre>
			<pre class="source-code">for (String s: list){</pre>
			<pre class="source-code">    System.out.print(s + " ");         //prints: 24 42 31</pre>
			<pre class="source-code">    if(s.contains("3")){</pre>
			<pre class="source-code">        found = s;</pre>
			<pre class="source-code">        break;</pre>
			<pre class="source-code">    }</pre>
			<pre class="source-code">}</pre>
			<pre class="source-code">System.out.println("Found " + found);  //prints: Found 31</pre>
			<p>If we need to find the first list element that contains <strong class="source-inline">"3"</strong>, we can stop executing as soon as the <strong class="source-inline">s.contains("3")</strong> condition is evaluated to <strong class="source-inline">true</strong>. The remaining list elements are ignored.</p>
			<p>In a more complicated scenario, with nested <strong class="source-inline">for</strong> statements, it is possible to set a label (with <strong class="source-inline">a : column</strong>) that indicates which <strong class="source-inline">for</strong> statement has to be exited, as follows: </p>
			<pre class="source-code">String found = null;</pre>
			<pre class="source-code">List&lt;List&lt;String&gt;&gt; listOfLists = List.of(</pre>
			<pre class="source-code">        List.of("24", "16", "1", "2", "1"),</pre>
			<pre class="source-code">        List.of("43", "42", "31", "3", "3"),</pre>
			<pre class="source-code">        List.of("24", "22", "31", "2", "1")</pre>
			<pre class="source-code">);</pre>
			<pre class="source-code">exit: for(List&lt;String&gt; l: listOfLists){</pre>
			<pre class="source-code">    for (String s: l){</pre>
			<pre class="source-code">        System.out.print(s + " "); //prints: 24 16 1 2 1 43</pre>
			<pre class="source-code">        if(s.contains("3")){</pre>
			<pre class="source-code">            found = s;</pre>
			<pre class="source-code">            break exit;</pre>
			<pre class="source-code">        }</pre>
			<pre class="source-code">    }</pre>
			<pre class="source-code">}</pre>
			<pre class="source-code">System.out.println("Found " + found);  //prints: Found 43</pre>
			<p>We have<a id="_idIndexMarker165"/> chosen<a id="_idIndexMarker166"/> a label name of <strong class="source-inline">exit</strong>, but we could call it any other name too.</p>
			<p>A <strong class="source-inline">continue</strong> statement works similarly, as follows:</p>
			<pre class="source-code">String found = null;</pre>
			<pre class="source-code">List&lt;List&lt;String&gt;&gt; listOfLists = List.of(</pre>
			<pre class="source-code">                List.of("24", "16", "1", "2", "1"),</pre>
			<pre class="source-code">                List.of("43", "42", "31", "3", "3"),</pre>
			<pre class="source-code">                List.of("24", "22", "31", "2", "1")</pre>
			<pre class="source-code">);</pre>
			<pre class="source-code">String checked = "";</pre>
			<pre class="source-code">cont: for(List&lt;String&gt; l: listOfLists){</pre>
			<pre class="source-code">        for (String s: l){</pre>
			<pre class="source-code">           System.out.print(s + " "); </pre>
			<pre class="source-code">                  //prints: 24 16 1 2 1 43 24 22 31</pre>
			<pre class="source-code">           if(s.contains("3")){</pre>
			<pre class="source-code">               continue cont;</pre>
			<pre class="source-code">           }</pre>
			<pre class="source-code">           checked += s + " ";</pre>
			<pre class="source-code">        }</pre>
			<pre class="source-code">}</pre>
			<pre class="source-code">System.out.println("Found " + found);  //prints: Found 43</pre>
			<pre class="source-code">System.out.println("Checked " + checked);  </pre>
			<pre class="source-code">                            //prints: Checked 24 16 1 2 1 24 22</pre>
			<p>It <a id="_idIndexMarker167"/>differs<a id="_idIndexMarker168"/> from <strong class="source-inline">break</strong> by stating which of the <strong class="source-inline">for</strong> statements need to continue and not exit.</p>
			<p>A <strong class="source-inline">return</strong> statement is used to return a result from a method, as follows:</p>
			<pre class="source-code">String returnDemo(int i){</pre>
			<pre class="source-code">    if(i &lt; 10){</pre>
			<pre class="source-code">        return "Not enough";</pre>
			<pre class="source-code">    } else if (i == 10){</pre>
			<pre class="source-code">        return "Exactly right";</pre>
			<pre class="source-code">    } else {</pre>
			<pre class="source-code">        return "More than enough";</pre>
			<pre class="source-code">    }</pre>
			<pre class="source-code">}</pre>
			<p>As you can see, there can be several <strong class="source-inline">return</strong> statements in a method, each returning a different value in different circumstances. If the method returns nothing (<strong class="source-inline">void</strong>), a <strong class="source-inline">return</strong> statement is <a id="_idIndexMarker169"/>not required, although<a id="_idIndexMarker170"/> it is frequently used for better readability, as follows:</p>
			<pre class="source-code">void returnDemo(int i){</pre>
			<pre class="source-code">    if(i &lt; 10){</pre>
			<pre class="source-code">        System.out.println("Not enough");</pre>
			<pre class="source-code">        return;</pre>
			<pre class="source-code">    } else if (i == 10){</pre>
			<pre class="source-code">        System.out.println("Exactly right");</pre>
			<pre class="source-code">        return;</pre>
			<pre class="source-code">    } else {</pre>
			<pre class="source-code">        System.out.println("More than enough");</pre>
			<pre class="source-code">        return;</pre>
			<pre class="source-code">    }</pre>
			<pre class="source-code">}</pre>
			<p>Execute the <strong class="source-inline">returnDemo()</strong> method by running the <strong class="source-inline">main()</strong> method of the <strong class="source-inline">com.packt.learnjava.ch01_start.ControlFlow</strong> class (see the <strong class="source-inline">branching()</strong> method). The results are going to look like this:</p>
			<pre class="source-code">String r = returnDemo(3);</pre>
			<pre class="source-code">System.out.println(r);      //prints: Not enough</pre>
			<pre class="source-code">r = returnDemo(10);</pre>
			<pre class="source-code">System.out.println(r);      //prints: Exactly right </pre>
			<pre class="source-code">r = returnDemo(12);</pre>
			<pre class="source-code">System.out.println(r);      //prints: More than enough</pre>
			<p>Statements are the building blocks of Java programming. They are like sentences in English—complete expressions of intent that can be acted upon. They can be compiled and executed. Programming is like expressing an action plan in statements.</p>
			<p>With this, the <a id="_idIndexMarker171"/>explanation of the basics of Java<a id="_idIndexMarker172"/> is concluded. Congratulations on getting through it!</p>
			<h1 id="_idParaDest-44"><a id="_idTextAnchor043"/>Summary</h1>
			<p>This chapter introduced you to the exciting world of Java programming. We started with explaining the main terms, and then explained how to install the necessary tools—the JDK and the IDE—and how to configure and use them.</p>
			<p>With a development environment in place, we have provided readers with the basics of Java as a programming language. We have described Java primitive types, the <strong class="source-inline">String</strong> type, and their literals. We have also defined what an ID is and what a variable is and finished with a description of the main types of Java statements. All the points of the discussion were illustrated by specific code examples.</p>
			<p>In the next chapter, we are going to talk about the <strong class="bold">object-oriented</strong> (<strong class="bold">OO</strong>) aspects of Java. We will introduce the main concepts, explain what a class is, what an interface is, and the relationship between them. The terms <em class="italic">overloading</em>, <em class="italic">overriding</em>, and <em class="italic">hiding</em> will also be defined and demonstrated in code examples, as well as usage of the <strong class="source-inline">final</strong> keyword.</p>
			<h1 id="_idParaDest-45"><a id="_idTextAnchor044"/>Quiz</h1>
			<ol>
				<li value="1">What does JDK stand for?<ol><li>Java Document Kronos</li><li>June Development Karate</li><li>Java Development Kit</li><li>Java Developer Kit</li></ol></li>
				<li>What does JCL stand for?<ol><li>Java Classical Library</li><li>Java Class Library</li><li>Junior Classical Liberty</li><li>Java Class Libras</li></ol></li>
				<li>What does Java SE stand for?<ol><li>Java Senior Edition</li><li>Java Star Edition</li><li>Java Structural Elections</li><li>Java Standard Edition</li></ol></li>
				<li>What does IDE stand for?<ol><li>Initial Development Edition</li><li>Integrated Development Environment</li><li>International Development Edition</li><li>Integrated Development Edition</li></ol></li>
				<li>What are Maven's functions?<ol><li>Project building</li><li>Project configuration</li><li>Project documentation</li><li>Project cancellation</li></ol></li>
				<li>Which of the following are Java primitive types?<ol><li><strong class="source-inline">boolean</strong></li><li><strong class="source-inline">numeric</strong></li><li><strong class="source-inline">integer</strong></li><li><strong class="source-inline">string</strong></li></ol></li>
				<li>Which of the following are Java numeric types?<ol><li><strong class="source-inline">long</strong></li><li><strong class="source-inline">bit</strong></li><li><strong class="source-inline">short</strong></li><li><strong class="source-inline">byte</strong></li></ol></li>
				<li>What is a <em class="italic">literal</em>?<ol><li>A letter-based string</li><li>A number-based string</li><li>A variable representation</li><li>A value representation</li></ol></li>
				<li>Which of the following are literals?<ol><li><strong class="source-inline">\\</strong></li><li><strong class="source-inline">2_0</strong></li><li><strong class="source-inline">2__0f</strong></li><li><strong class="source-inline">\f</strong></li></ol></li>
				<li>Which of the following are Java operators?<ol><li><strong class="source-inline">%</strong></li><li><strong class="source-inline">$</strong></li><li><strong class="source-inline">&amp;</strong></li><li><strong class="source-inline">-&gt;</strong></li></ol></li>
				<li>What does the following code snippet print?<p class="source-code">int i = 0; System.out.println(i++);</p><ol><li><strong class="source-inline">0</strong></li><li><strong class="source-inline">1</strong></li><li><strong class="source-inline">2</strong></li><li><strong class="source-inline">3</strong></li></ol></li>
				<li>What does the following code snippet print?<p class="source-code">boolean b1 = true;</p><p class="source-code"> boolean b2 = false;</p><p class="source-code"> System.out.println((b1 &amp; b2) + " " + (b1 &amp;&amp; b2));</p><ol><li><strong class="source-inline">false true</strong></li><li><strong class="source-inline">false false</strong></li><li><strong class="source-inline">true false</strong></li><li><strong class="source-inline">true true</strong></li></ol></li>
				<li>What does the following code snippet print?<p class="source-code">int x = 10;</p><p class="source-code"> x %= 6;</p><p class="source-code"> System.out.println(x);</p><ol><li><strong class="source-inline">1</strong></li><li><strong class="source-inline">2</strong></li><li><strong class="source-inline">3</strong></li><li><strong class="source-inline">4</strong></li></ol></li>
				<li>What is the result of the following code snippet?<p class="source-code">System.out.println("abc" - "bc");</p><ol><li><strong class="source-inline">a</strong></li><li><strong class="source-inline">abc-bc</strong></li><li>Compilation error</li><li>Execution error</li></ol></li>
				<li>What does the following code snippet print?<p class="source-code">System.out.println("A".repeat(3).lastIndexOf("A"));</p><ol><li><strong class="source-inline">1</strong></li><li><strong class="source-inline">2</strong></li><li><strong class="source-inline">3</strong></li><li><strong class="source-inline">4</strong></li></ol></li>
				<li>Which of the following are correct IDs?<ol><li><strong class="source-inline">int __</strong> (two underscores)</li><li><strong class="source-inline">2a</strong></li><li><strong class="source-inline">a2</strong></li><li><strong class="source-inline">$</strong></li></ol></li>
				<li>What does the following code snippet print?<p class="source-code">for (int i=20, j=-1; i &lt; 23 &amp;&amp; j &lt; 0; ++i, ++j){</p><p class="source-code">         System.out.println(i + " " + j + " ");</p><p class="source-code"> }</p><ol><li><strong class="source-inline">20 -1 21 0</strong></li><li>Endless loop</li><li><strong class="source-inline">21 0</strong></li><li><strong class="source-inline">20 -1</strong></li></ol></li>
				<li>What does the following code snippet print?<p class="source-code">int x = 10;</p><p class="source-code">try {</p><p class="source-code">    if(x++ &gt; 10){</p><p class="source-code">        throw new RuntimeException("The x value is out of the range: " + x);</p><p class="source-code">    }</p><p class="source-code">    System.out.println("The x value is within the range: " + x);</p><p class="source-code">} catch (RuntimeException ex) {</p><p class="source-code">    System.out.println(ex.getMessage());</p><p class="source-code">}</p><ol><li>Compilation error</li><li>The <strong class="source-inline">x</strong> value is out of the range: 11</li><li>The <strong class="source-inline">x</strong> value is within the range: 11</li><li>Execution time error</li></ol></li>
				<li>What does the following code snippet print?</li>
			</ol>
			<pre class="source-code">int result = 0;</pre>
			<pre class="source-code">List&lt;List&lt;Integer&gt;&gt; source = List.of(</pre>
			<pre class="source-code">        List.of(1, 2, 3, 4, 6),</pre>
			<pre class="source-code">        List.of(22, 23, 24, 25),</pre>
			<pre class="source-code">        List.of(32, 33)</pre>
			<pre class="source-code">);</pre>
			<pre class="source-code">cont: for(List&lt;Integer&gt; l: source){</pre>
			<pre class="source-code">    for (int i: l){</pre>
			<pre class="source-code">        if(i &gt; 7){</pre>
			<pre class="source-code">            result = i;</pre>
			<pre class="source-code">            continue cont;</pre>
			<pre class="source-code">        }</pre>
			<pre class="source-code">     }</pre>
			<pre class="source-code">}</pre>
			<pre class="source-code">System.out.println("result=" + result);</pre>
			<ol>
				<li><strong class="source-inline">result = 22</strong></li>
				<li><strong class="source-inline">result = 23</strong></li>
				<li><strong class="source-inline">result = 32</strong></li>
				<li><strong class="source-inline">result = 33</strong></li>
			</ol>
			<ol>
				<li value="20">Select all the following statements that are correct:<ol><li>A variable can be declared.</li><li>A variable can be assigned.</li><li>A variable can be defined.</li><li>A variable can be determined.</li></ol></li>
				<li>Select all the correct Java statement types from the following:<ol><li>An executable statement</li><li>A selection statement</li><li>A method end statement</li><li>An increment statement</li></ol></li>
			</ol>
		</div>
	</body></html>