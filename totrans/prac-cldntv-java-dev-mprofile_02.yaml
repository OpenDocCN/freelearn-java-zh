- en: '*Chapter 1*: Cloud-Native Applications'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第一章*: 云原生应用'
- en: 'When talking about **cloud-native applications**, it is important to have a
    shared understanding of what cloud-native means. There is often an assumption
    that cloud-native and microservices are the same thing, but actually, microservices
    are just *one* architectural pattern that can be used when building cloud-native
    applications. That leads us to the questions: what is a cloud-native application,
    and what are the best practices for building them? This will be the focus of this
    chapter.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 当谈论**云原生应用**时，重要的是对云原生意味着什么有一个共同的理解。通常有一个假设，即云原生和微服务是同一件事，但实际上，微服务只是构建云原生应用时可以使用的*一种*架构模式。这引出了以下问题：什么是云原生应用，构建它们的最佳实践是什么？这将是本章的重点。
- en: 'In particular, we will cover these main topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 尤其是我们将涵盖以下主要主题：
- en: What is a cloud-native application?
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是云原生应用？
- en: Introducing distributed computing
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍分布式计算
- en: Exploring cloud-native application architectures
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索云原生应用架构
- en: Cloud-native development best practices
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 云原生开发最佳实践
- en: This chapter will provide some grounding for understanding the rest of the book
    as well as helping you to be successful when building cloud-native applications.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将为理解本书的其余部分提供一些基础，同时帮助你在构建云原生应用时取得成功。
- en: What is a cloud-native application?
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是云原生应用？
- en: Back in 2010, Paul Freemantle wrote an early blog post about cloud-native ([http://pzf.fremantle.org/2010/05/cloud-native.html](http://pzf.fremantle.org/2010/05/cloud-native.html))
    and used the analogy of trying to drive a horse-drawn cart on a 6-lane highway.
    No matter how much better a highway is as a road, there is a limit to how much
    a cart can transport and how quickly. You need vehicles that are designed for
    driving on a highway. The same is true of applications.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 回到2010年，Paul Freemantle写了一篇关于云原生的早期博客文章([http://pzf.fremantle.org/2010/05/cloud-native.html](http://pzf.fremantle.org/2010/05/cloud-native.html))，并使用了试图在6车道高速公路上驾驶马车类比。无论高速公路作为道路有多好，马车能运输的货物和运输速度都是有限的。你需要为高速公路设计的车辆。应用也是如此。
- en: An application designed to run in a traditional data center is not going to
    run well on the cloud compared to one that was designed specifically to take advantage
    of the cloud. In other words, a cloud-native application is one that has been
    specifically designed to take advantage of the capabilities provided by the cloud.
    The **Stock Trader** application from [*Chapter 8*](B17377_08_Final_SB_epub.xhtml#_idTextAnchor159),
    *Building and Testing Cloud-Native Applications*, is an example of such an application.
    A real-world example of microservices is Netflix.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 设计在传统数据中心运行的应用程序与专门设计以利用云的能力的应用程序相比，在云上运行效果不佳。换句话说，云原生应用是专门设计以利用云提供的功能的。来自[*第8章*](B17377_08_Final_SB_epub.xhtml#_idTextAnchor159)的**股票交易员**应用程序，*构建和测试云原生应用*，就是这样一个应用的例子。微服务的真实世界例子是Netflix。
- en: Perhaps at its core, the promise of the cloud is being able to get compute resources
    on-demand, in minutes or seconds rather than days or weeks, and being charged
    based on incremental usage rather than upfront for potential usage – although,
    for many, the attraction is just no longer having to manage and maintain multiple
    data centers. The commoditization of compute resources that the cloud provides
    leads to a very different way of thinking about, planning for, and designing applications,
    and these differences significantly affect the application. One of the key changes
    in application design is the degree to which applications are distributed.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 也许在核心上，云的承诺是能够按需获取计算资源，几分钟或几秒钟而不是几天或几周，并且根据增量使用量而不是潜在使用量进行收费——尽管，对于许多人来说，吸引力仅仅是不再需要管理和维护多个数据中心。云提供的计算资源商品化导致了对应用的设计、规划和设计有非常不同的思考方式，这些差异显著影响了应用。应用设计中的一个关键变化是应用的分布式程度。
- en: Introducing distributed computing
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍分布式计算
- en: 'Most cloud-native architectures involve splitting an application into several
    discrete services that communicate over a network link rather than an in-process
    method invocation. This makes cloud-native applications implicitly distributed
    applications, and while **distributed computing** is nothing new, it does increase
    the need to understand the benefits and pitfalls of distributed computing. When
    building distributed applications, it is important to consider and understand
    the eight fallacies of distributed computing. These are as follows:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数云原生架构涉及将应用程序拆分为几个离散的服务，这些服务通过网络链接而不是进程内方法调用进行通信。这使得云原生应用隐式地成为分布式应用，尽管**分布式计算**并不是什么新鲜事物，但它确实增加了理解分布式计算优势和陷阱的需求。在构建分布式应用时，重要的是要考虑和理解分布式计算的八个谬误。这些如下：
- en: The network is reliable.
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 网络是可靠的。
- en: Latency is zero.
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 延迟为零。
- en: Bandwidth is infinite.
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 带宽是无限的。
- en: The network is secure.
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 网络是安全的。
- en: Topology doesn't change.
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 拓扑不会改变。
- en: There is one administrator.
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 只有一个管理员。
- en: Transport cost is zero.
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 传输成本为零。
- en: The network is homogeneous.
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 网络是同质的。
- en: In essence, what these fallacies mean is that a network call is slower, less
    secure, less reliable, and harder to fix than invoking a Java method call or a
    C procedure. When creating cloud-native applications, care needs to be taken to
    ensure these fallacies are correctly accounted for, otherwise, the application
    will be slow, unreliable, insecure, and impossible to debug.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 从本质上讲，这些谬误意味着网络调用比调用Java方法或C过程要慢，安全性更低，可靠性更差，更难修复。在创建云原生应用时，需要仔细考虑以确保这些谬误得到正确考虑，否则，应用将会运行缓慢、不可靠、不安全，且难以调试。
- en: An application consisting of multiple services interacting across the network
    can produce many benefits, such as the ability to individually scale and update
    services, but care must be taken to design services to minimize the number of
    network interactions required to deliver the ultimate business solution.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 由多个服务通过网络交互组成的程序可以产生许多好处，例如能够单独扩展和更新服务，但必须注意设计服务以最小化实现最终商业解决方案所需的网络交互次数。
- en: As a result, several cloud-native architectures can be used to build cloud-native
    applications that present different tradeoffs between the benefits and challenges
    of distributed computing.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，可以使用几种云原生架构来构建云原生应用，这些架构在分布式计算的优势和挑战之间提供了不同的权衡。
- en: Exploring cloud-native application architectures
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索云原生应用架构
- en: Since 2019, there has been increasing discussion in the industry about the pros
    and cons of microservices as a **cloud-native application architecture**. This
    has been driven by many microservice-related failures and as a result, people
    are now discussing whether some applications would be better off using different
    architectures. There has even been the start of a renaissance around the idea
    of building monoliths, after several years of those kinds of applications being
    seen as an anti-pattern.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 自2019年以来，关于微服务作为**云原生应用架构**的优缺点在业界引发了越来越多的讨论。这主要是由于许多与微服务相关的失败，因此，人们现在正在讨论是否有些应用使用不同的架构会更好。甚至有关于重建单体应用的复兴开始出现，在过去的几年里，这类应用被视为反模式。
- en: 'While it is attractive to think of cloud-native as just being a technology
    choice, it is important to understand how the development processes, organization
    structure, and culture affect the evolution of cloud-native applications, the
    system architecture, and any ultimate success. Conway''s Law states the following:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然将云原生视为仅仅是技术选择很有吸引力，但了解开发流程、组织结构和文化如何影响云原生应用的演变、系统架构以及任何最终的成功是很重要的。康威定律指出以下内容：
- en: '*Any organization that designs a system will produce a design whose structure
    is a copy of the organization''s communication structure.*'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '*任何设计系统的组织都会产生一个结构，其结构与组织的沟通结构相匹配。*'
- en: A simple way of thinking of this is if your development organization is successful
    at building monoliths, it is unlikely to be successful at building microservices
    without some kind of reorganization. That doesn't mean every team wanting to do
    cloud-native should go out and reorganize; it means that you should understand
    your strengths and weaknesses when deciding what architecture to adopt. You should
    also be open to reorganizing if necessary.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 将这种想法简单化的一种方式是，如果你的开发组织在构建单体应用方面很成功，那么在没有某种重组的情况下，它不太可能成功构建微服务。这并不意味着每个想要进行云原生开发的团队都应该出去重组；这意味着在决定采用什么架构时，你应该了解自己的优势和劣势。如果需要，你也应该开放地考虑重组。
- en: This section discusses a number of the more popular cloud-native application
    architectures out there and the pros and cons of using them. Let's start with
    microservices.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 本节讨论了目前一些更受欢迎的云原生应用架构及其优缺点。让我们从微服务开始。
- en: Microservices
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 微服务
- en: Although Netflix didn't invent the idea of **microservices**, their use of the
    architecture did popularize it. A single microservice is designed to do one thing.
    It doesn't, despite the name, mean that service is small or lightweight – a single
    microservice could be *millions* of lines of code, but the code in the microservice
    has a high level of cohesion. A microservice would never handle ATM withdrawals
    and also sell movie tickets. Identifying the best way to design a cloud-native
    application into a series of well-designed microservices is not a simple task;
    different people might take different views of whether a deposit into and withdrawal
    from a bank account would warrant a single microservice or two.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然Netflix并没有发明微服务的概念，但他们对该架构的使用确实使其流行起来。单个微服务被设计用来做一件事情。尽管名字上听起来服务很小或轻量级，但实际上并不一定如此——一个单独的微服务可能有*数百万*行代码，但微服务中的代码具有高度的凝聚力。微服务永远不会处理ATM取款和出售电影票。确定将云原生应用程序设计成一系列精心设计的微服务的最佳方式并不是一个简单的任务；不同的人可能会有不同的观点，认为银行账户的存取是否需要单个微服务或两个。
- en: Microservices usually integrate with each other via REST interfaces or messaging
    systems, although gRPC and GraphQL are growing in popularity. A web-facing microservice
    is likely to use a REST or GraphQL interface, but an internal one is more likely
    to use a messaging system such as Apache Kafka. Messaging systems are generally
    very resilient to network issues, since once the messaging system has accepted
    the message, it will store the message until it can be successfully processed.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务通常通过REST接口或消息系统相互集成，尽管gRPC和GraphQL越来越受欢迎。面向Web的微服务可能会使用REST或GraphQL接口，但内部微服务更有可能使用Apache
    Kafka等消息系统。消息系统通常对网络问题具有很强的容错能力，因为一旦消息系统接受了消息，它就会存储该消息，直到它可以成功处理。
- en: The key promise of the microservice-based architecture is that each microservice
    can be independently deployed, updated, and scaled, allowing teams that own disparate
    microservices to work in parallel, making updates without the need to coordinate.
    This is perhaps the biggest challenge with microservice architectures. It is relatively
    common for well-meaning developers who set out to build microservices to end up
    building a distributed monolith instead. This often occurs because of poorly defined
    and poorly documented APIs between services and insufficient acceptance testing,
    resulting in a lack of trust in updating a single microservice without impacting
    the others. This is called a *distributed monolith* because you end up with all
    the disadvantages of a monolith and microservices and miss out on the benefits.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 基于微服务的架构的关键承诺是每个微服务都可以独立部署、更新和扩展，允许拥有不同微服务的团队并行工作，无需协调即可进行更新。这可能是在微服务架构中最大的挑战。有良好意愿的开发者开始构建微服务时，最终可能会构建一个分布式单体，这种情况相对常见。这通常是由于服务之间定义不明确和文档不充分，以及验收测试不足，导致在更新单个微服务时缺乏对其他服务的信任。这被称为*分布式单体*，因为最终你得到了单体和微服务的所有缺点，却失去了它们的优点。
- en: In an ideal world, a development organization building microservices will align
    the microservices with an individual development team. This may be difficult if
    there are more microservices than development teams. As the number of microservices
    a team manages increases, more time will be spent managing the services rather
    than evolving them.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在理想的世界里，一个构建微服务的开发组织会将微服务与单个开发团队对齐。如果微服务的数量超过开发团队的数量，这可能很困难。随着一个团队管理的微服务数量增加，将会有更多的时间用于管理服务而不是演进服务。
- en: Monoliths
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 单体应用
- en: '**Monoliths** are strongly associated with pre-cloud application architectures
    and are considered an anti-pattern for cloud-native applications. For that reason,
    it might seem strange that this appears in a discussion of cloud-native architecture.
    However, there are some reasons for including them.'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '**单体应用**与云前的应用架构紧密相关，被认为是云原生应用的反模式。因此，在讨论云原生架构时，这似乎有些奇怪。然而，有一些原因包括它们在内。'
- en: The first is really just the reality that monoliths are the simplest kind of
    application to build. While the individual services cannot be independently scaled,
    as long as the monolith has been designed to scale, this may not be an issue.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 第一点实际上只是现实，即单体应用是构建最简单的一种应用。虽然单个服务不能独立扩展，但只要单体应用设计得可以扩展，这可能不是问题。
- en: The second is that there are a lot of monoliths out there and many enterprises
    are moving them to the cloud. **MicroProfile** provides additional APIs to retrofit
    many cloud-native behaviors into an existing app.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 第二点是，现在有很多单体应用，许多企业正在将它们迁移到云端。**MicroProfile**提供了额外的API，可以将许多云原生行为重构到现有应用程序中。
- en: The trick with a monolith is ensuring that despite the colocation of services
    in a single deployment artifact, the monolith can start quickly enough to enable
    dynamic scaling and restart if there is an application failure.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 单体应用的技巧是确保尽管服务位于单个部署工件中，但单体应用可以快速启动，以便在应用程序失败时启用动态扩展和重启。
- en: Typically, a small development organization will benefit from monoliths since
    there is only a single application to build, deploy, and manage.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，小型开发组织会从单体应用中受益，因为只有一个应用程序需要构建、部署和管理。
- en: Macroservices
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 宏服务
- en: '**Macroservices** sit somewhere between a monolith and a microservice architecture
    and are also referred to as *modular monoliths*. With macroservices, the services
    are combined into a small number of monoliths that interoperate in the same way
    that a series of microservices would.'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '**宏服务**位于单体应用和微服务架构之间，也被称为*模块化单体应用*。在宏服务中，服务被组合成少量单体应用，它们以与一系列微服务相同的方式交互操作。'
- en: This provides many of the benefits of microservices but significantly simplifies
    the operations environment since there are fewer things to manage. If a macro-service
    has been written well, then individual services in that macro-service can be broken
    out if they would benefit from an independent life cycle. A well-known example
    of a macro-service is **Stack Overflow**. Stack Overflow ([https://www.infoq.com/news/2015/06/scaling-stack-overflow/](https://www.infoq.com/news/2015/06/scaling-stack-overflow/))
    is famously a monolith except for the tagging capability, which is handled in
    another application due to the different performance needs. This split moves it
    from being a pure monolith into the realm of macroservices (although Stack Overflow
    uses the term *monolith-plus*).
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 这提供了许多微服务的好处，但显著简化了操作环境，因为要管理的事物更少。如果一个宏服务编写得很好，那么其中的单个服务如果从独立的生命周期中受益，就可以将其拆分出来。一个著名的宏服务例子是**Stack
    Overflow**。Stack Overflow ([https://www.infoq.com/news/2015/06/scaling-stack-overflow/](https://www.infoq.com/news/2015/06/scaling-stack-overflow/))
    众所周知是一个单体应用，除了标签功能，由于性能需求不同，该功能由另一个应用程序处理。这种拆分使其从纯单体应用转变为宏服务领域（尽管Stack Overflow使用术语*monolith-plus*）。
- en: This architecture can work especially well when a development organization is
    organized into a smaller number of teams than the number of services.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 当开发组织被组织成比服务数量更少的团队时，这种架构可以特别有效。
- en: Function as a Service
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 函数即服务
- en: '**Function as a Service** (**FaaS**), often referred to as *serverless*, is
    an architecture where a service is created as a function that is run when an event
    occurs. The function is intended to be fast starting and fast executing and can
    be triggered by things such as HTTP requests or messages being received. FaaS
    promises that you can deploy the function to a cloud, and it is started and executed
    by the event trigger, rather than having to have the function running *just in
    case*. Typically, public cloud providers that support FaaS only charge for the
    time the function is running. This is very attractive if the event is relatively
    uncommon since there is no financial cost in having a system running for when
    an uncommon event occurs.'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '**函数即服务**（**FaaS**），通常被称为*无服务器*，是一种服务创建为在事件发生时运行的函数的架构。该函数旨在快速启动和快速执行，可以通过诸如HTTP请求或接收到的消息等事件触发。FaaS承诺你可以将函数部署到云中，并由事件触发器启动和执行，而不是必须让函数一直运行以备不时之需。通常，支持FaaS的公共云提供商只对函数运行时间收费。如果事件相对不常见，这非常吸引人，因为没有在罕见事件发生时让系统运行的经济成本。'
- en: The challenge with this architecture is that your function needs to be able
    to start quickly and usually has to finish executing quickly too; as a result,
    it isn't suitable for long-running processes. It also doesn't remove the server;
    the server is still there. Instead, it just shifts the cost from the developer
    to the cloud provider. If the cloud provider is a public cloud, then that is their
    problem, since they are charging for the function runtime, but if you are deploying
    to a private cloud, this becomes your problem, thereby removing some of the benefits.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 这种架构的挑战在于，你的函数需要能够快速启动，并且通常也需要快速执行完成；因此，它不适合长时间运行的过程。它也没有移除服务器；服务器仍然存在。相反，它只是将成本从开发者转移到了云服务提供商。如果云服务提供商是公共云，那么这是他们的问题，因为他们会根据函数运行时间收费，但如果你部署到私有云，这就会成为你的问题，从而消除了部分好处。
- en: Event sourcing
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 事件溯源
- en: Often, we think of services as providing a REST endpoint, and services make
    calls to them. In fact, factor VII of the Twelve-Factor App (discussed in the
    next section) *explicitly* states this. The problem with this approach is that
    a REST call is implicitly synchronous and prone to issues if the service provider
    is running slow or failing.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，我们认为服务提供REST端点，并且服务会调用它们。实际上，十二要素应用（在下一节中讨论）的第VII要素*明确*指出这一点。这种方法的缺点是，REST调用是隐式同步的，如果服务提供者运行缓慢或失败，则容易出现问题。
- en: When providing an external API to a mobile app or a web browser, a REST API
    is often the best option. However, for services within an enterprise, there are
    many benefits to using a messaging system such as Kafka and using **asynchronous**
    **events** instead. A messaging system that can guarantee that the message will
    be delivered allows the client and service to be decoupled such that an issue
    with the service provider doesn't prevent the request from occurring; it just
    means it'll be processed later. A one-to-many event system makes it easy for a
    single service to trigger multiple different actions with just a simple message
    send. Different actions can be taken by different services receiving a copy of
    the message and if new behavior is required, an additional service can receive
    the same message without having to change the sending service. A simple illustration
    of this might be that an event that orders an item can be processed by the payment
    service, the dispatch service, a reorder service, and a recommendation service
    that provides recommendations based on past purchases.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 当为移动应用或网页浏览器提供外部API时，REST API通常是最佳选择。然而，对于企业内部的服务，使用如Kafka的消息系统以及使用**异步****事件**有许多好处。能够保证消息将被传递的消息系统允许客户端和服务解耦，这样服务提供者的问题不会阻止请求的发生；只是意味着它会被稍后处理。一对一的事件系统使得单个服务通过简单的消息发送就能触发多个不同的动作。不同的服务可以通过接收消息副本采取不同的动作，如果需要新的行为，额外的服务可以接收相同的消息，而无需更改发送服务。一个简单的例子可能是，一个订购商品的订单事件可以被支付服务、调度服务、补货服务和基于过去购买提供推荐的服务处理。
- en: One of the trends with cloud-native applications is that data is moved from
    a centralized data store closer to the individual services. Each service operates
    on data it holds, so if something happens to slow down the data store for one
    service, it doesn't have a knock-on effect on others. This means that new mechanisms
    are required to ensure data consistency. Using events to handle data updates helps
    with this, since a single event can be distributed to every service that needs
    to process the update independently. The updates can take effect even if the service
    is down when the update is triggered. Another advantage of this approach is that
    if the data store fails, it can be reconstructed by replaying all the events.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 云原生应用程序的一个趋势是数据从集中的数据存储移动到更靠近单个服务的地方。每个服务都操作它持有的数据，因此如果某个服务的数据存储变慢，它不会对其他服务产生连锁反应。这意味着需要新的机制来确保数据一致性。使用事件来处理数据更新有助于这一点，因为单个事件可以被分发到每个需要独立处理更新的服务。即使服务在更新触发时处于关闭状态，更新也可以生效。这种方法的另一个优点是，如果数据存储失败，可以通过重放所有事件来重建它。
- en: Having chosen the architecture (or architectures) for building your cloud-native
    application, the next step is to start building it, and to do that, it is a good
    idea to understand some of the industry best practices around cloud-native application
    development.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在选择了构建你的云原生应用程序的架构（或架构）之后，下一步是开始构建它，为此，了解一些关于云原生应用程序开发的行业最佳实践是个好主意。
- en: Cloud-native development best practices
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 云原生开发最佳实践
- en: There are many best practices that, if followed, will improve the chances that
    your cloud-native application will be a success. Following these best practices
    doesn't guarantee success, just as ignoring them doesn't guarantee failure, but
    they do encode key practices that have been shown to enhance the chances of success.
    The most famous set of best practices is the **Twelve-Factor App**.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多最佳实践，如果遵循这些实践，将提高你的云原生应用程序成功的可能性。遵循这些最佳实践并不能保证成功，正如忽视它们并不能保证失败一样，但它们确实编码了已被证明可以增加成功机会的关键实践。最著名的最佳实践集合是**十二要素应用**。
- en: Twelve-Factor App
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 十二要素应用
- en: 'The Twelve-Factor App ([https://12factor.net](https://12factor.net)) is a set
    of 12 best practices that, if followed, can significantly improve the chance of
    success when building cloud-native applications. Some of the factors would be
    considered obvious by many software developers even outside of cloud-native, but
    taken together, they form a popular methodology for building cloud-native applications.
    The 12 factors are as follows:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 十二要素应用([https://12factor.net](https://12factor.net))是一套12个最佳实践，如果遵循这些实践，可以显著提高构建云原生应用程序成功的可能性。其中一些因素对于许多软件开发者来说可能很显然，即使是在云原生之外，但综合起来，它们形成了一种构建云原生应用程序的流行方法。以下是12个要素：
- en: Code base
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代码库
- en: Dependencies
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 依赖项
- en: Config
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置
- en: Backing services
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 后端服务
- en: Build, release, run
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建、发布、运行
- en: Process
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 进程
- en: Port binding
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 端口绑定
- en: Concurrency
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 并发
- en: Disposability
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可丢弃性
- en: Dev/prod parity
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开发/生产一致性
- en: Logs
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 日志
- en: Admin processes
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管理进程
- en: I – Code base
  id: totrans-70
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: I – 代码库
- en: The first factor states that a cloud-native application consists of a single
    **code base** that is tracked in a version control system, such as Git, and that
    code base will be deployed multiple times. A deployment might be to a test, staging,
    or production environment. That doesn't mean that the code in the environments
    will be identical; a test environment will obviously contain code changes that
    are proposed but haven't been proven as safe for production, but that is still
    one code base.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个要素指出，云原生应用程序由一个单一的**代码库**组成，该代码库在版本控制系统（如Git）中跟踪，并且该代码库将被部署多次。部署可能是在测试、预发布或生产环境中。这并不意味着这些环境中的代码将是相同的；显然，测试环境将包含尚未被证明对生产环境安全但被提出的代码更改，但仍然是一个代码库。
- en: II – Dependencies
  id: totrans-72
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: II – 依赖项
- en: It has been common development practice for Java applications to use **dependencies**
    stored in Maven repositories such as Maven Central for some time. Tools such as
    Maven and Gradle require you to express your dependencies in order to build against
    them. While this practice absolutely requires this, it goes beyond just build-time
    dependencies to runtime ones as well. A 12-factor application packages its dependencies
    into the application to ensure that a single development artifact can be reliably
    deployed in any suitable environment. This means that having an administrator
    provide the libraries in a well-known place on the filesystem is not acceptable
    since there is always a chance the administrator-deployed library and the application-required
    one are not compatible.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Java应用程序来说，使用存储在Maven仓库（如Maven Central）中的**依赖项**作为常见的开发实践已经有一段时间了。例如，Maven和Gradle工具要求你表达你的依赖项，以便针对它们进行构建。虽然这种做法绝对需要这样做，但它不仅限于构建时的依赖项，还包括运行时的依赖项。12因素应用程序将依赖项打包到应用程序中，以确保单个开发工件可以在任何合适的环境中可靠地部署。这意味着管理员在文件系统上的知名位置提供库是不可接受的，因为总是有可能管理员部署的库与应用程序所需的库不兼容。
- en: When considering this practice, it is important to make a clear decision about
    what the cloud-native application is, since at some point there will be a split
    between what the application provides and what the deployment environment provides.
    This factor triggered a trend in enterprise Java away from `WAR` files to executable
    `JAR` files, since many viewed the application server as an implicit dependency.
    However, that just shifted the implicit dependency down a level; it didn't remove
    it. Now the implicit dependency is Java. To a certain extent, containerization
    addresses this issue and at the same time, it removes the need to rearchitect
    around an executable `JAR` file.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在考虑这种实践时，明确决定云原生应用程序的定义非常重要，因为最终应用程序提供的内容和部署环境提供的内容之间将会有所分离。这个因素促使企业Java从`WAR`文件转向可执行的`JAR`文件，因为许多人认为应用程序服务器是一个隐含的依赖。然而，这仅仅是将隐含的依赖降低了一个级别；它并没有消除它。现在，隐含的依赖是Java。在某种程度上，容器化解决了这个问题，同时消除了围绕可执行`JAR`文件重新架构的需求。
- en: III – Config
  id: totrans-75
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: III – 配置
- en: Since a 12-factor application may have many deployments and each deployment
    may connect to different systems with different credentials, it is critical that
    **configuration** be externalized into the environment. It is also common to read
    in the media about security issues caused by a developer accidentally checking
    credentials into a version control system, which would not happen if the configuration
    was stored externally to the code base.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 由于12因素应用程序可能有多个部署，并且每个部署可能连接到不同的系统，使用不同的凭证，因此将**配置**外部化到环境中至关重要。在媒体上关于开发者意外将凭证检查到版本控制系统中导致的安全问题也很常见，如果配置存储在代码库外部，这种情况就不会发生。
- en: Although this factor states that configuration is stored in environment variables,
    there are many who are uneasy about the idea of storing security-sensitive configuration
    in environment variables. The key thing here is to externalize configuration in
    a way that can be simply provided in production.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这个因素表明配置存储在环境变量中，但许多人对于在环境变量中存储安全敏感的配置感到不安。这里的关键是要以简单的方式外部化配置，以便在生产环境中提供。
- en: IV – Backing services
  id: totrans-78
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: IV – 后端服务
- en: '**Backing services** are treated as attached resources. It should be possible
    to change from one database to another with a simple change in configuration.'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '**后端服务**被视为附加资源。应该能够通过简单的配置更改从一种数据库切换到另一种数据库。'
- en: V – Build, release, run
  id: totrans-80
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: V – 构建、发布、运行
- en: All applications go through some kind of **build, release, run** process, but
    a 12-factor application has strict separation between those phases. The build
    phase involves turning the application source into the application artifact. The
    release phase combines the application artifact with the configuration so it can
    be deployed. The run phase is when it is actually executing. This strict separation
    means that a configuration change is never made in the run phase since there is
    no way to roll it back to the release stage. Instead, if a configuration change
    is required, a new release is made and run. The same is true if a code change
    is required. There is no changing the code that is running without going through
    a build and a run. This makes sure that you always know what is running and can
    easily reproduce issues or roll back to a prior version.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 所有应用都会经历某种**构建、发布、运行**的过程，但12因子应用在这三个阶段之间有严格的分离。构建阶段涉及将应用源代码转换为应用工件。发布阶段将应用工件与配置结合，以便可以部署。运行阶段是实际执行的时候。这种严格的分离意味着运行阶段永远不会进行配置更改，因为没有方法可以将其回滚到发布阶段。相反，如果需要配置更改，则创建一个新的发布并运行。如果需要代码更改，也是如此。没有通过构建和运行来更改正在运行中的代码。这确保了你始终知道正在运行什么，并且可以轻松地重现问题或回滚到先前的版本。
- en: VI – Process
  id: totrans-82
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: VI – 进程
- en: A 12-factor application consists of one or more **stateless processes**. This
    does not mean that each request is mapped to a single process; it is perfectly
    reasonable in Java to have a single JVM processing multiple requests at the same
    time. This means that the application should not rely on any one process being
    available from one request to another. If a single client is making 20 requests,
    the assumption must be that each request is handled by a separate process with
    no state being retained between processes. It is a common pattern to store the
    server-side state associated with a user. This state should always be persisted
    to an external datastore, so if a follow-on request is sent to a different process,
    there is no impact on the client.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 一个12因子应用由一个或多个**无状态进程**组成。这并不意味着每个请求都映射到一个单独的进程；在Java中，一个JVM同时处理多个请求是完全合理的。这意味着应用不应该依赖于某个进程在请求之间保持可用。如果一个客户端发送了20个请求，必须假设每个请求都是由一个独立的进程处理的，且进程之间不保留任何状态。将服务器端与用户关联的状态存储为一个常见模式。这个状态应该始终持久化到外部数据存储中，这样如果后续请求发送到不同的进程，就不会对客户端产生影响。
- en: VII – Port binding
  id: totrans-84
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: VII – 端口绑定
- en: Applications export services via **port binding**. What this means is that an
    HTTP application should not rely on being installed into a web container, but
    instead it should declare a dependency on the HTTP server and cause it to open
    a port during startup. This has led many to take the view that a 12-factor Java
    application must be built as an uber-jar, but this is just one realization of
    the idea of building a single deployment artifact that binds to ports. An alternative
    and significantly more useful interpretation is to use containers; containers
    are very much built around the idea of port binding. It should be noted that this
    practice does not always apply; for example, a microservice driven by a Kafka
    message would not bind to a port. Also, many FaaS platforms do not provide an
    API for port binding.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 应用通过**端口绑定**导出服务。这意味着HTTP应用不应该依赖于被安装到Web容器中，而应该声明对HTTP服务器的依赖，并在启动时打开一个端口。这导致许多人认为12因子Java应用必须构建为一个uber-jar，但这只是构建单个部署工件并绑定端口的想法之一。一个替代方案并且更有用的一种解释是使用容器；容器在很大程度上是围绕端口绑定的概念构建的。应该注意的是，这种做法并不总是适用；例如，由Kafka消息驱动的微服务就不会绑定到端口。此外，许多FaaS平台不提供端口绑定的API。
- en: VIII – Concurrency
  id: totrans-86
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: VIII – 并发
- en: '**Concurrency** in Java is typically achieved by increasing the resources allocated
    to a process so more threads can be created. With 12-factor, you increase the
    number of instances rather than the compute capacity. There is a limit to how
    easy it is to add compute capacity to a single machine, but adding a new virtual
    machine of equivalent size is relatively easy. This practice is related to factor
    VI, so they complement and reinforce each other. Although this could be read to
    suggest a single process per request model, a Java-based application is more than
    capable of running multiple threads more efficiently than having a 1:1 ratio between
    process and request.'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: IX – Disposability
  id: totrans-88
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Every application should be treated as **disposable**. This means making sure
    the process starts quickly, shuts down promptly, and copes with termination. Taking
    this approach makes the application scale out well and quickly, as well as being
    resilient to unexpected failure, since a process can be quickly and easily restarted
    from the last release.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: X – Dev/prod parity
  id: totrans-90
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Lots of application problems manifest themselves because of differences between
    **development and staging environments**. In the past, this happened because installing
    and starting all the downstream software was difficult, but the advent of containers
    has significantly simplified this experience, making it possible to run many of
    these systems in earlier environments. The advantage of this is that you no longer
    experience problems because your development database interprets SQL differently
    from the dev environment.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: XI – Logs
  id: totrans-92
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Applications should write `log` function, which follows the process output and
    not the log files.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: 'XII: Admin processes'
  id: totrans-94
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Admin processes** should be run as one-off processes separate from the application
    and they should not run in line with application startup. The code for these application
    processes should be managed with the main application such that the release used
    for normal flow can be used to execute the admin task. This makes sure the application
    and the admin code do not diverge.'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: Other best practices
  id: totrans-96
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The concept of the 12-factor application has been around for a while; it is
    important to remember with any methodology that what works for some people may
    not work for others, and sometimes the methodology needs to evolve as our understanding
    of how to be successful does. As a result, several other best practices are often
    added to the 12 factors discussed previously. The most common relates to the importance
    of describing the service API and how to test it to ensure that changes to one
    service do not require the coordinated deployment of client services.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: APIs and contract testing
  id: totrans-98
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: While the 12-factor methodology details a lot of useful practices for the creation
    and execution of cloud-native applications, it does little to talk about how application
    services interact and how to ensure that changing one doesn't cause another to
    need to change. Well-designed and clearly documented **APIs** are critical to
    ensuring that changes to a service do not affect the clients.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然12因素方法详细介绍了创建和执行云原生应用程序的大量有用实践，但它很少讨论应用程序服务如何交互以及如何确保更改一个服务不会导致另一个服务需要更改。设计良好且文档清晰的**API**对于确保服务更改不会影响客户端至关重要。
- en: It isn't enough to just have documentation for the API; it is also important
    to ensure that changes to the service provider do not negatively affect the client.
    Since any bug fix could result in a change, it is often possible for the provider
    to believe a change is safe and accidentally break a client. This is where **contract
    testing** can come in. The advantage of contract testing is that each system (the
    client and the server) can be tested to ensure that changes to either do not violate
    the contract.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 仅对API有文档是不够的；还必须确保服务提供商的更改不会对客户端产生负面影响。由于任何错误修复都可能引起更改，因此提供商可能认为更改是安全的，并意外地破坏客户端。这就是**契约测试**可以发挥作用的地方。契约测试的优势在于，每个系统（客户端和服务器）都可以进行测试，以确保对任一方的更改不会违反契约。
- en: Security
  id: totrans-101
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 安全性
- en: One of the most noticeable gaps in the 12-factor methodology is the lack of
    best practices around security. From a certain perspective, this is because there
    is an existing set of best practices for securing applications and these apply
    as much to cloud-native applications as they do to traditional applications. For
    example, the third practice on config addresses, at least partly, how to protect
    credentials (or other secrets) by externalizing them outside of the application,
    However, this factor doesn't talk about how to securely inject secrets into the
    environment and how they are stored and secured. Something that depends on the
    deployment environment. This is discussed in more detail in [*Chapter 7*](B17377_07_Final_SB_epub.xhtml#_idTextAnchor146),
    *MicroProfile Ecosystem with Open Liberty, Docker, and Kubernetes*.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 12因素方法中最明显的差距之一是关于安全性的最佳实践的缺乏。从某个角度来看，这是因为已经存在一套用于保护应用程序的最佳实践，这些最佳实践同样适用于云原生应用程序和传统应用程序。例如，关于配置地址的第三项实践，至少部分地解决了如何通过外部化来保护凭证（或其他机密信息）的问题。然而，这个因素并没有讨论如何安全地将机密信息注入环境以及它们是如何被存储和保护的，这取决于部署环境。这在[*第7章*](B17377_07_Final_SB_epub.xhtml#_idTextAnchor146)，“使用Open
    Liberty、Docker和Kubernetes的MicroProfile生态系统”中进行了更详细的讨论。
- en: Breaking things down into microservices adds additional complexity that doesn't
    apply in a monolith. With a monolith, you can trust the various components of
    the application because they are co-deployed often in the same process space.
    However, when a monolith is broken down into microservices and network connections
    are used, other mechanisms need to be used to maintain trust. The use of **JSON
    Web Tokens** (**JWTs**) is one such mechanism of managing and establishing trust
    between microservices. This is discussed in more detail in [*Chapter 5*](B17377_05_Final_SB_epub.xhtml#_idTextAnchor091),
    *Enhancing Cloud-Native Applications*.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 将系统分解为微服务会增加额外的复杂性，这在单体架构中并不适用。在单体架构中，你可以信任应用程序的各个组件，因为它们通常在相同的过程空间中共同部署。然而，当单体被分解为微服务并使用网络连接时，需要使用其他机制来维持信任。使用**JSON
    Web Tokens**（JWTs）就是这样一种在微服务之间管理和建立信任的机制。这在[*第5章*](B17377_05_Final_SB_epub.xhtml#_idTextAnchor091)，“增强云原生应用程序”中进行了更详细的讨论。
- en: GraphQL
  id: totrans-104
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: GraphQL
- en: There is a default assumption involved in much of cloud-native thought that
    the APIs exposed are REST-based ones. However, this can lead to increased network
    calls and excessive data being sent across the network. **GraphQL** is a relatively
    new innovation that allows a service client to request the exact information it
    needs from a data store over an HTTP connection. A traditional REST API has to
    provide all the data about the resource, but often only a subset is required.
    Network bandwidth and client-side data processing is often wasted when using RESTful
    APIs since data is provided that the client does not use. GraphQL solves this
    by allowing the client to send a query to the service requesting exactly the data
    they need and no more. This reduces the data being transported and fetched from
    the backing data store. MicroProfile provides a Java-based API for writing a GraphQL
    backend, which makes it easy to write a service that provides such a query-based
    API for clients.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多云原生思想中存在一个默认假设，即暴露的API是基于REST的。然而，这可能导致网络调用增加和通过网络发送的数据过多。**GraphQL**是一种相对较新的创新，它允许服务客户端通过HTTP连接从数据存储请求所需的确切信息。传统的REST
    API必须提供有关资源的所有数据，但通常只需要一部分。当使用RESTful API时，由于提供了客户端不使用的数据，网络带宽和客户端数据处理通常会被浪费。GraphQL通过允许客户端向服务发送查询，请求他们确切需要的数据，而不需要更多数据，从而解决了这个问题。这减少了传输和从后端数据存储检索的数据量。MicroProfile提供了一个基于Java的API来编写GraphQL后端，这使得编写为客户端提供基于查询的API的服务变得容易。
- en: Summary
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we have learned what a cloud-native application is and learned
    about some architectures for building them. We have also learned about some best
    practices for building cloud-native applications and why they exist, so we can
    determine whether and when to apply them. This provides a good grounding for applying
    what you'll learn in the rest of the book to be able to be successful in building
    and deploying cloud-native applications.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了什么是云原生应用，并了解了一些构建它们的架构。我们还学习了构建云原生应用的一些最佳实践以及它们存在的原因，这样我们就可以确定何时以及如何应用它们。这为将本书中剩余部分所学内容应用于构建和部署云原生应用提供了良好的基础。
- en: In the next chapter, we will explore what MicroProfile is and how it can be
    used to build cloud-native applications.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨MicroProfile是什么以及如何用它来构建云原生应用。
