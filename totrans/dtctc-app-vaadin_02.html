<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Modularization and Main Screens</h1>
                </header>
            
            <article>
                
<p>The main purpose of modularization is to decrease the complexity of a system. By dividing the functionality into many modules, developers can <em>forget</em> about parts of the system that are not relevant to the functionality under development. It also enables a more powerful deployment process by, for example, allowing activation of features depending on environments or customers, and the creation of third-party modules to customize and extend the capabilities of the application.</p>
<p class="p1"><span class="s1">This chapter demonstrates how to modularize your applications to make them more manageable and maintainable, and how to implement a main screen that supports the registration of new modules at runtime.</span></p>
<p class="p1"><span class="s1">This chapter covers the following topics:</span></p>
<ul class="ul1">
<li class="li1">Modularization of Vaadin applications</li>
<li class="li2"><span class="s1">Implementation of an application's main screens</span></li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Technical requirements</h1>
                </header>
            
            <article>
                
<p>You will be<span> </span>required<span> </span>to have Java SE Development Kit and Java EE SDK version 8 or later. You also need Maven version 3 or later. A Java IDE with Maven support, such as IntelliJ IDEA, Eclipse, or NetBeans is recommended. Finally, to use the Git repository of this book, you need to install Git.</p>
<p>The code files of this chapter can be found on GitHub:<br/>
<a href="https://github.com/PacktPublishing/Data-centric-Applications-with-Vaadin-8/tree/master/chapter-02">https://github.com/PacktPublishing/Data-centric-Applications-with-Vaadin-8/tree/master/chapter-02</a></p>
<p>Check out the following video to see the code in action:<br/>
<a href="https://goo.gl/VnLouE">https://goo.gl/VnLouE</a></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Creating a multi-module Maven project</h1>
                </header>
            
            <article>
                
<p>A <em>multi-module</em> Maven project aggregates several Maven projects into a single one. In this chapter, we will create three modules that form the whole application:</p>
<ul>
<li><kbd>webapp</kbd>: A Vaadin web application packaged as a WAR file that includes everything needed to deploy it to a server such as Tomcat, Wildfly, Jetty, or any other Java server</li>
<li><kbd>api</kbd>: A Java API packaged as a JAR used by the webapp and any <em>functional module</em></li>
<li><kbd>example-module</kbd>: An example <em>functional module</em> that uses the <kbd>api</kbd> JAR to add functionality to the application</li>
</ul>
<p>All these modules are aggregated into a single Maven project with the name <kbd>chapter-02</kbd>. Let's start by creating this aggregator project by using t<span class="s1">he </span><kbd><span class="s2">pom-root</span></kbd><span class="s1"> Maven archetype. Run the following in a terminal:</span></p>
<pre class="p2">mvn archetype:generate \<br/>-DarchetypeGroupId=org.codehaus.mojo.archetypes \<br/>-DarchetypeArtifactId=pom-root \<br/>-DarchetypeVersion=RELEASE</pre>
<p class="p1"><span class="s1">Use the following properties when prompted:</span></p>
<ul class="ul1">
<li><kbd>groupId</kbd>: <kbd>packt.vaadin.datacentric</kbd></li>
<li class="li5"><kbd><span class="s1">artifactId</span></kbd>: <kbd><span class="s1">chapter-02</span></kbd></li>
<li class="li5"><kbd><span class="s1">version</span></kbd>: <kbd><span class="s1">1.0-SNAPSHOT</span></kbd></li>
<li class="li5"><kbd><span class="s1">package</span></kbd>: <kbd><span class="s1">packt.vaadin.datacentric.chapter02</span></kbd></li>
</ul>
<p class="p1"><span class="s1">When using this archetype, Maven generates a</span> <kbd><span class="s2">pom.xml</span></kbd> <span class="s1">file for a top-level multi-module or aggregator project. You can remove the</span> <kbd><span class="s2">&lt;name&gt;</span></kbd> <span class="s1">tag as it’s redundant for our purposes. Modify the file to include a property for the Vaadin version:</span></p>
<pre class="p6">&lt;project  xsi:schemaLocation="…"&gt;<br/>    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;<br/><br/>    &lt;groupId&gt;packt.vaadin.datacentric&lt;/groupId&gt;<br/>    &lt;artifactId&gt;chapter-02&lt;/artifactId&gt;<br/>    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;</pre>
<pre class="p6">    &lt;packaging&gt;pom&lt;/packaging&gt;<br/><br/>    &lt;properties&gt;<br/>        <strong>&lt;vaadin.version&gt;8.3.2&lt;/vaadin.version&gt;</strong><br/>    &lt;/properties&gt;<br/>&lt;/project&gt;</pre>
<div class="p4 packt_infobox"><span class="s1">Note that in the code provided with this book, you'll find a</span> <kbd><span class="s2">&lt;parent&gt;</span></kbd> <span class="s1">section in the</span> <kbd><span class="s2">pom.xml</span></kbd> <span class="s1">file of the</span> <kbd><span class="s2">chapter-02</span></kbd><span class="s1"> project. This is because all the demo applications of the book have been aggregated into a single <kbd>Data-centric-Applications-with-Vaadin-8</kbd> Maven project for your convenience. You don’t need to add any</span> <kbd><span class="s2">&lt;parent&gt;</span></kbd> <span class="s1">sections to your project if you are following the steps in this chapter.</span></div>
<p class="p1"><span class="s1">This project (</span><kbd><span class="s2">chapter-02</span></kbd><span class="s1">) can be seen as the root directory for a full-blown application that contains several Maven modules, each one dedicated to a specific aspect of the functionality of the system.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Implementing an application's main screen</h1>
                </header>
            
            <article>
                
<p class="p2"><span class="s1">Let's start by implementing a concrete component: A main screen, something every web application needs. Please keep in mind that there's not only one way of implementing main screens. The example presented here may be good for your own application, or it might inspire you to develop even more sophisticated implementations.</span></p>
<p class="p2"><span class="s1">The main screen in this example consists of a <em>header</em>, a <em>menu,</em> and a <em>working area</em> where other components are shown when the user selects an option from the main menu. </span><span class="s1">To the external world, this component should include the following functionality:</span></p>
<ul class="ul1">
<li class="li2"><span class="s1">Adding components to the header</span></li>
<li class="li2"><span class="s1">Adding components to the working area</span></li>
<li class="li2"><span class="s1">Adding options to the main menu</span></li>
<li class="li2"><span class="s1">Adding listeners to respond to menu actions</span></li>
<li class="li3"><span class="s1">Getting components from the working area and the header</span></li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Defining an API for an application's main screen</h1>
                </header>
            
            <article>
                
<p class="p2"><span class="s1">In order to explore and learn about API design in web development with Vaadin, let's assume we want the main screen to be a general purpose component not intended to be used only in this demo application. For this reason, we need to provide the component in a separate JAR file. Start by creating a new Maven module inside the <kbd>chapter-02</kbd> project using the</span> <kbd><span class="s2">maven-archetype-simple</span></kbd> <span class="s1">archetype as follows:</span></p>
<pre class="p3"><strong>cd chapter-02</strong><br/><strong>mvn archetype:generate -DarchetypeGroupId=org.apache.maven.archetypes -DarchetypeArtifactId=maven-archetype-quickstart</strong></pre>
<p class="p2"><span class="s1">Use the following properties when prompted:</span></p>
<ul class="ul1">
<li class="li4"><kbd><span class="s1">groupId: packt.vaadin.datacentric.chapter02</span></kbd></li>
<li class="li4"><kbd><span class="s1">artifactId: api</span></kbd></li>
<li class="li4"><kbd><span class="s1">version: 1.0-SNAPSHOT</span></kbd></li>
<li class="li4"><kbd><span class="s1">package: packt.vaadin.datacentric.chapter02.api</span></kbd></li>
</ul>
<p class="p5"><span class="s1">Check that the new</span> <kbd><span class="s2">api</span></kbd> <span class="s1">module is listed in the</span> <kbd><span class="s2">chapter-02/pom.xml</span></kbd> <span class="s1">file:</span></p>
<pre><span>&lt;</span><span>project ...</span><span>&gt;</span><br/>    ...<br/>    <span>&lt;</span><span>modules</span><span>&gt;</span><br/>        <span>&lt;</span><span>module</span><span>&gt;</span>api<span>&lt;/</span><span>module</span><span>&gt;</span><br/>    <span>&lt;/</span><span>modules</span><span>&gt;</span><br/><span>&lt;/</span><span>project</span><span>&gt;</span></pre>
<p class="p5"><span class="s1">Clean up as desired and add the Vaadin BOM and the</span> <kbd><span class="s2">vaadin-server</span></kbd> <span class="s1">dependency. You can also delete the generated</span> <kbd><span class="s2">App</span></kbd> <span class="s1">and</span> <kbd><span class="s2">AppTest</span></kbd> <span class="s1">classes. You will also need to configure Java 8 using properties, similar to how it was done in the previous chapter</span><span class="s1">.</span></p>
<div class="p6 packt_infobox"><span class="s1">You can find the full</span> <kbd><span class="s2">pom.xml</span></kbd> <span class="s1">file in the</span> <kbd><span class="s2">Data-centric-Applications-with-Vaadin-8\chapter-02\api</span></kbd> <span class="s1">Maven project of the source code that accompanies this book.</span></div>
<p class="p2"><span class="s1">The API should allow developers to create additional concrete main screen implementations with similar functionality. Abstracting this functionality can be done by defining a Java interface like the following:</span></p>
<pre class="p7">public interface ApplicationLayout extends<strong> Component</strong> {<br/> <br/> void addHeaderComponent(Component component);<br/> <br/> void addWorkingAreaComponent(<strong>WorkingAreaComponent</strong><br/>         component);<br/> <br/> Collection&lt;Component&gt; getHeaderComponents();<br/> <br/> Collection&lt; WorkingAreaComponent&gt; getWorkingAreaComponents();<br/> <br/> void addMenuOption(<strong>MenuOption</strong> menuOption,<br/>         <strong>Serializable</strong><strong>Consumer&lt;MenuOption&gt;</strong> clickListener);<br/> <br/>}</pre>
<div class="p6 packt_infobox"><span class="s1">The</span> <kbd><span class="s2">ApplicationLayout</span></kbd> <span class="s1">interface and related classes are located in the</span> <kbd><span class="s2">Data-centric-Applications-with-Vaadin-8/chapter-02/api</span></kbd> <span class="s1">Maven project of the source code that accompanies this book.</span></div>
<p class="p9"><span class="s1">This interface extends</span> <kbd><span class="s2">Component</span></kbd><span class="s1">, so any concrete implementation can be used as a regular UI component and added into any Vaadin component container, such as <kbd>VerticalLayout</kbd>, for instance. Concrete implementations will extend</span> <kbd><span class="s2">Composite</span></kbd><span class="s1">, as will be shown later.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Implementing support classes</h1>
                </header>
            
            <article>
                
<p class="p2"><span class="s1">The previous interface won<span><span>'</span></span>t compile. There are two classes that need to be implemented:</span> <kbd><span class="s2">WorkingAreaComponent</span></kbd> <span class="s1">and</span> <kbd><span class="s2">MenuOption</span></kbd><span class="s1">. The</span> <kbd><span class="s2">addWorkingAreaComponent(WorkingAreaComponent)</span></kbd> <span class="s1">method expects a</span> <kbd><span class="s2">WorkingAreaComponent</span></kbd><span class="s1"> that encapsulates a caption and the corresponding Vaadin component to be shown. This interface is defined as follows:</span></p>
<pre class="p3">public interface ApplicationLayout extends Component {<br/><br/>    public static class <strong>WorkingAreaComponent</strong><br/>            implements Serializable {<br/><br/>        private final <strong>String caption</strong>;<br/>        private final <strong>Component component</strong>;<br/><br/>        public WorkingAreaComponent(String caption,<br/>                Component component) {<br/>            this.caption = caption;<br/>            this.component = component;<br/>        }<br/><br/>       ... hashCode(), equals(), and getters <br/>    }<br/>    ...<br/>}</pre>
<div class="p6 packt_infobox packt_tip"><span class="s1">The</span> <kbd><span class="s2">WorkingAreaComponent</span></kbd> <span class="s1">class implements</span> <kbd><span class="s2">Serializable</span></kbd><span class="s1">. Vaadin is mostly a server-side framework. Components are stored in HTTP sessions. In order to serialize the session, all contained objects must be</span> <kbd><span class="s2">Serializable</span></kbd><span class="s1">. This serialization is done, for example, when you stop a web container such as Jetty or Tomcat. All HTTP sessions are serialized to the disk, and the next time the server starts, sessions are restored. Notice also how <kbd>SerializableConsumer</kbd> was used in the <kbd>ApplicationLayout</kbd> interface for the same reasons.</span></div>
<p class="p2"><span class="s1">Why is that needed? Why not simply let the</span> <kbd><span class="s2">addWorkingAreaComponent(WorkingAreaComponent)</span></kbd> <span class="s1">method have the parameters for the caption and component, as shown in the following snippet of code?</span></p>
<pre class="p7"><span class="s1">void addWorkingAreaComponent(String caption, Component component);</span></pre>
<p class="p2"><span class="s1">If you were a hundred percent sure that a caption and a component are the only things you need to have when you add a new component to the working area, that would be fine. However, you don't know how concrete</span> <kbd>ApplicationLayout<span class="s2">s</span></kbd> <span class="s1">will evolve. What if an icon is needed? What about a color or a help text?</span></p>
<p class="p2"><span class="s1">Suppose you have decided to implement the method as</span> <kbd><span class="s2">addWorkingAreaComponent(String, Component)</span></kbd> <span class="s1">and some months after the component is released, some application that uses the component needs to have an icon for each component added into the working area. A possible solution is to modify the method to accept a new parameter for the icon, as follows:</span></p>
<pre class="p3">void addWorkingAreaComponent(String caption, Component component,<br/>        Resource icon);</pre>
<p class="p2"><span class="s1">This modification will break any existing client that references the old method's signature. Another approach is to overload the method by adding a new parameter. However, this will break all current implementations of</span> <kbd><span class="s2">ApplicationLayout</span></kbd><span class="s1">. Encapsulating what is subject to change is always a good idea.</span></p>
<p class="p2"><span class="s1">Another reason to encapsulate the parameters of</span> <kbd><span class="s2">addWorkingAreaComponent(WorkingAreaComponent)</span></kbd> <span class="s1">is the</span> <kbd><span class="s2">getWorkingAreaComponents()</span></kbd> <span class="s1">method. Suppose you want to implement a concrete</span> <kbd><span class="s2">ApplicationLayout</span></kbd> <span class="s1">that allows users to switch between tabs and windows. In order to implement this functionality, you need to get all the current components shown in the working area (using the</span> <kbd><span class="s2">getWorkingAreaComponents(WorkingAreaComponent)</span></kbd> <span class="s1">method) and place them in tabs or windows accordingly. For each component, you need to create a tab or a window, set its caption, and add the corresponding Vaadin component. You need both, the caption and the component. Encapsulating these objects in a single class greatly simplifies this task; otherwise, we would need to have an extra method that returns the captions as an ordered collection. Additionally, the</span> <kbd><span class="s2">getWorkingAreaComponents()</span></kbd> <span class="s1">method should return an ordered collection as well.</span></p>
<p class="p8"><span class="s1">The last thing to notice about the</span> <kbd><span class="s2">ApplicationLayout</span></kbd> <span class="s1">class is the</span> <kbd><span class="s2">addMenuOption(MenuOption, SerializableConsumer&lt;MenuOption&gt;)</span></kbd> <span class="s1">method. This method expects a</span> <kbd><span class="s2">MenuOption</span></kbd> <span class="s1">(that encapsulates the caption to render) and a <kbd>SerializableConsumer</kbd></span><span class="s1"> that serves as a click listener for the menu option. When the user clicks the option, the</span> <kbd><span class="s2">Consumer.accept(MenuOption)</span></kbd> <span class="s1">method is called, passing the clicked</span> <kbd><span class="s2">MenuOption</span></kbd> <span class="s1">as its parameter.</span></p>
<div class="p6 packt_infobox"><span class="s2"><kbd>SerializableConsumer</kbd> is a serializable version of the <kbd>Consumer</kbd> class,</span> <span class="s1">a functional interface introduced in Java 8. A functional interface has only one abstract method. This allows clients to create instances of the interface using lambda expressions. For more information about functional interfaces see:<br/></span> <a href="http://docs.oracle.com/javase/8/docs/api/java/lang/FunctionalInterface.html"><span class="s4">http://docs.oracle.com/javase/8/docs/api/java/lang/FunctionalInterface.html</span></a><span class="s1">.</span></div>
<p class="p2"><span class="s1">The</span> <kbd><span class="s2">MenuOption</span></kbd> <span class="s1">class can be implemented as follows:</span></p>
<pre class="p3">public interface ApplicationLayout extends Component {<br/><br/>    public static class <strong>MenuOption</strong> implements Serializable {<br/>        private final String caption;<br/><br/>        public MenuOption(String caption) {<br/>            this.caption = caption;<br/>        }<br/><br/>        public String getCaption() {<br/>            return caption;<br/>        }<br/>    }<br/>}</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Implementing a concrete application's main screen</h1>
                </header>
            
            <article>
                
<p class="p2"><span class="s1">This section explains how to implement and use a basic tab-based layout using the</span> <kbd><span class="s2">ApplicationLayout</span></kbd> <span class="s1">interface developed in the previous section. The layout includes a header on the top and a lateral menu on the left. When users click an option on the main menu a new component is added inside a new tab. The following is a screenshot of this layout:</span></p>
<div class="CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-190 image-border" src="assets/e1c3e7cb-52b4-472c-aaa4-66a94bcae509.png" style=""/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Adding and configuring the required UI components</h1>
                </header>
            
            <article>
                
<p class="p2"><span class="s1">The first step is to create the required Vaadin UI components and configure them using the standard Vaadin API. This can be done as follows:</span></p>
<pre class="p3">public class TabBasedApplicationLayout extends Composite {<br/><br/>    private VerticalLayout mainLayout = new VerticalLayout();<br/>    private HorizontalLayout header = new HorizontalLayout();<br/>    private HorizontalSplitPanel splitPanel<br/>            = new HorizontalSplitPanel();<br/>    private VerticalLayout menuLayout = new VerticalLayout();<br/>    private TabSheet tabSheet = new TabSheet();<br/><br/>    public TabBasedApplicationLayout(String caption) {<br/>        ... layout and components configuration<br/>    }<br/>}</pre>
<div class="p6 packt_infobox"><span class="s1">The code to configure the UI elements is omitted, as it is not the purpose of this book to explain Vaadin UI components' basic usage and configuration. The full implementation can be found in the</span> <kbd><span class="s3">Data-centric-Applications-with-Vaadin-8\chapter-02\api</span></kbd> <span class="s1">Maven project of the source code that accompanies this book.</span></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Implementing the ApplicationLayout interface</h1>
                </header>
            
            <article>
                
<p class="p2"><span class="s1">The next step is to implement the</span> <kbd><span class="s2">ApplicationLayout</span></kbd> <span class="s1">interface and add the required methods:</span></p>
<ul class="ul1">
<li class="li3"><kbd><span class="s1">void addHeaderComponent(Component)</span></kbd></li>
<li class="li3"><kbd><span class="s1">void addWorkingAreaComponent(WorkingAreaComponent)</span></kbd></li>
<li class="li3"><kbd><span class="s1">Collection&lt;Component&gt; getHeaderComponents()</span></kbd></li>
<li class="li3"><kbd><span class="s1">Collection&lt;WorkingAreaComponent&gt; getWorkingAreaComponents()</span></kbd></li>
<li class="li3"><kbd><span class="s1">void addMenuOption(MenuOption, SerializableConsumer&lt;MenuOption&gt;)</span></kbd></li>
</ul>
<p class="p2"><span class="s1">Implementing the</span> <kbd><span class="s2">addHeaderComponent(Component)</span></kbd> <span class="s1">method is quite straightforward:</span></p>
<pre class="p4">@Override<br/>public void <strong>addHeaderComponent</strong>(Component component) {<br/>    component.setWidth(null);<br/>    header.addComponent(component);<br/>    header.setComponentAlignment(component,<br/>            Alignment.MIDDLE_RIGHT);<br/>}</pre>
<p class="p2"><span class="s1">The</span> <kbd><span class="s2">addWorkingAreaComponent(WorkingAreaComponent)</span></kbd> <span class="s1">method should avoid adding two tabs with the same caption. Instead of adding the same tab twice it should select the corresponding existing tab. A</span> <kbd><span class="s2">Collection</span></kbd> <span class="s1">is used to keep track of the added components, as shown in the following code:</span></p>
<pre class="p4">public class TabBasedApplicationLayout extends CustomComponent<br/>        <strong>implements ApplicationLayout</strong> {<br/>    ...<br/><br/>    private Collection&lt;WorkingAreaComponent&gt; workingAreaComponents<br/>            = new HashSet&lt;&gt;();<br/><br/>    @Override<br/>    public void <strong>addWorkingAreaComponent</strong>(WorkingAreaComponent<br/>            component) {<br/>        <strong>addWorkingAreaComponent</strong>(component, true);<br/>    }<br/><br/>    public void <strong>addWorkingAreaComponent</strong>(WorkingAreaComponent<br/>            component, boolean closable) {<br/>        if (!workingAreaComponents.contains(component)) {<br/>            TabSheet.Tab tab = tabSheet.addTab(<br/>                    component.getComponent(),<br/>                            component.getCaption());<br/>            tab.setClosable(closable);<br/>            tabSheet.setSelectedTab(tab);<br/>            workingAreaComponents.add(component);<br/>        } else {<br/>            <strong>showComponent</strong>(component.getCaption());<br/>        }<br/>    }<br/><br/>    public void <strong>showComponent</strong>(String caption) {<br/>        IntStream.range(0, tabSheet.getComponentCount())<br/>                .mapToObj(tabSheet::getTab)<br/>                .filter(tab -&gt; tab.getCaption().equals(caption))<br/>                .forEach(tabSheet::setSelectedTab);<br/>    }<br/>}</pre>
<p class="p2"><span class="s1">Because this concrete implementation is based on a</span> <kbd><span class="s2">TabSheet</span></kbd> <span class="s1">where each tab can or cannot be closed, it makes sense to overload the</span> <kbd><span class="s5">ApplicationLayout.addWorkingAreaComponent(WorkingAreaComponent)</span></kbd> <span class="s1">method to allow clients to specify this behavior.</span></p>
<p class="p2"><span class="s1">An interesting part of the previous code is the</span> <kbd><span class="s2">showComponent(String)</span></kbd> <span class="s1">method, which selects a tab by its caption. This method uses an</span> <kbd><span class="s2">IntStream</span></kbd> <span class="s1">to loop through the tabs in the</span> <kbd><span class="s2">TabSheet</span></kbd><span class="s1">. This method is equivalent to the following one:</span></p>
<pre class="p4">public void showComponent(String caption) {<br/>   for(int i = 0; i &lt; tabSheet.getComponentCount(); i++) {<br/>       TabSheet.Tab tab = tabSheet.getTab(i);<br/> <br/>       if(tab.getCaption().equals(caption)) {<br/>           tabSheet.setSelectedTab(tab);<br/>       }<br/>   }<br/>}</pre>
<div class="p10 packt_infobox"><span class="s1">The implementation of</span> <kbd><span class="s2">showComponents(String)</span></kbd> <span class="s1">uses two Java 8 features called streams and pipelines. For more information on streams and pipelines, see </span><a href="http://docs.oracle.com/javase/tutorial/collections/streams/index.html"><span class="s1">http://docs.oracle.com/javase/tutorial/collections/streams/index.html</span></a><span class="s6">.</span></div>
<p class="p2"><span class="s1">The next method to implement is</span> <kbd><span class="s2">getHeaderComponents()</span></kbd><span class="s1">:</span></p>
<pre class="p4">@Override<br/>public Collection&lt;Component&gt; <strong>getHeaderComponents</strong>() {<br/>    return IntStream.range(0, header.getComponentCount())<br/>            .mapToObj(header::getComponent)<br/>            .collect(Collectors.toList());<br/>}</pre>
<p class="p2"><span class="s1">This method uses an</span> <kbd><span class="s2">IntStream</span></kbd> <span class="s1">similar to the one in the</span> <kbd><span class="s2">showComponent(String)</span></kbd> <span class="s1">method. A</span> <kbd><span class="s2">Collector</span></kbd> <span class="s1">is used to create a </span><kbd><span class="s2">List</span></kbd> <span class="s1">containing all the components in the header.</span></p>
<p class="p2"><span class="s1">Since we already have a</span> <kbd><span class="s2">Collection</span></kbd><span class="s1"> object with all the components in the working area, the</span> <kbd><span class="s2">getWorkingAreaComponents()</span></kbd> <span class="s1">method implementation is just a regular getter:</span></p>
<pre class="p4">@Override<br/>public Collection&lt;WorkingAreaComponent&gt; <strong>getWorkingAreaComponents</strong>() {<br/>    return workingAreaComponents;<br/>}</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Implementing the menu</h1>
                </header>
            
            <article>
                
<p class="p2"><span class="s1">To make the menu work, we can implement the</span> <kbd><span class="s2">addMenuOption(MenuOption, SerializableConsumer&lt;MenuOption&gt;)</span></kbd> <span class="s1">method as follows:</span></p>
<pre class="p3">public class TabBasedApplicationLayout ... {<br/>    ...<br/>    private Collection&lt;String&gt; <strong>menuButtonStyles</strong> = new HashSet&lt;&gt;();<br/>    ...<br/><br/>    @Override<br/>    public void <strong>addMenuOption</strong>(MenuOption menuOption,<br/>            SerializableConsumer&lt;MenuOption&gt; clickListener) {<br/>        Button button = new Button(menuOption.getCaption(),<br/>                <strong>event -&gt; clickListener.accept(menuOption)</strong>);<br/>        menuButtonStyles.forEach(button::addStyleName);<br/>        menuLayout.addComponent(button);<br/>    }<br/>    ...<br/>}</pre>
<p class="p2"><span class="s1">This method iterates over the</span> <kbd><span class="s2">menuButtonStyles</span></kbd> <span class="s1">collection to add each style to the new button. Lastly, the methods to set styles for menu options and also for the header should look as follows:</span></p>
<pre class="p3">public void <strong>setHeaderStyleName</strong>(String styleName) {<br/>    header.setStyleName(styleName);<br/>}<br/><br/>public void <strong>addHeaderStyleName</strong>(String styleName) {<br/>    header.addStyleName(styleName);<br/>}<br/><br/>public void <strong>setMenuButtonsStyleName</strong>(String styleName) {<br/>    menuButtonStyles.clear();<br/>    menuButtonStyles.add(styleName);<br/>    updateMenuButtonsStyle(styleName,<br/>            Component::setStyleName);<br/>}<br/><br/>public void <strong>addMenuButtonsStyleName</strong>(String styleName) {<br/>    menuButtonStyles.add(styleName);<br/>    updateMenuButtonsStyle(styleName,<br/>            Component::addStyleName);<br/>}<br/><br/>private void <strong>updateMenuButtonsStyle</strong>(String styleName,<br/>        BiConsumer&lt;Component, String&gt; setOrAddStyleMethod) {<br/>    IntStream.range(0, menuLayout.getComponentCount())<br/>            .mapToObj(menuLayout::getComponent)<br/>            .forEach(component -&gt;<br/>                    setOrAddStyleMethod.accept(<br/>                            component, styleName));<br/>}</pre>
<p class="p2"><span class="s1">The component is now ready! We can use it in any Vaadin application now. You can create a Vaadin application in a similar way as we did in the previous chapter, or use a standard Vaadin Maven archetype. The <kbd>chapter-02</kbd> module includes the <kbd>webapp</kbd> submodule, a Vaadin web application. The following is the init method of the <kbd>UI</kbd> implementation in the <kbd>webapp</kbd> module:</span></p>
<pre class="p3">protected void init(VaadinRequest request) {<br/>    TabBasedApplicationLayout <strong>layout</strong> <strong>=</strong><br/>            <strong>new TabBasedApplicationLayout("Caption")</strong>;<br/>    IntStream.range(1, 4)<br/>            .mapToObj(i -&gt; new Label("Component " + i))<br/>            .map(l -&gt; new ApplicationLayout.WorkingAreaComponent(<br/>                    l.getValue(), l))<br/>            .forEach(c -&gt; layout.addMenuOption(<br/>                    new ApplicationLayout.MenuOption(<br/>                            c.getCaption()),<br/>                    (option) -&gt;<br/>                            layout.addWorkingAreaComponent(<br/>                                    c, true)));<br/>    layout.setMenuButtonsStyleName(ValoTheme.BUTTON_LINK);<br/>    setContent(<strong>layout</strong>);<br/>}</pre>
<p class="p2"><span class="s1">Remember to add the</span> <kbd><span class="s2">api</span></kbd> <span class="s1">dependency to the <kbd>pom.xml</kbd> file of the</span> <kbd><span class="s2">webapp</span></kbd> <span class="s1">module before compiling and running the application again:</span></p>
<pre class="p3">&lt;dependency&gt;<br/>    &lt;groupId&gt;packt.vaadin.datacentric.chapter02&lt;/groupId&gt;<br/>    &lt;artifactId&gt;api&lt;/artifactId&gt;<br/>    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;<br/>&lt;/dependency&gt;</pre>
<p>Although we have learned how to build a bare-bones main screen in the previous sections by using the core of Vaadin Framework, you should consider using the <em>SideMenu Add-on</em> published in the Vaadin Directory website (<a href="https://vaadin.com/directory/component/sidemenu-add-on">https://vaadin.com/directory/component/sidemenu-add-on</a>). This component allows you to quickly implement side menus like the one in the official <em>dashboard demo</em> you can see at <a href="https://demo.vaadin.com/dashboard">https://demo.vaadin.com/dashboard</a>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Modularizing Vaadin applications</h1>
                </header>
            
            <article>
                
<p class="p1"><span class="s1">In this book, we use the term module to refer to a software component that can be independently developed and deployed. In that sense, a modularized application can be customized and extended without distributing or modifying the source code of the original application. For our purposes, when a new module is deployed, it must register with the application. The functionality of the module is incorporated into the application at runtime.</span></p>
<div class="p2 packt_infobox"><span class="s1">Keep in mind that there are also Maven modules. This book uses the full term Maven module or Maven project when referring to this kind of modules.</span></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Identifying alternatives for modularization</h1>
                </header>
            
            <article>
                
<p class="p1"><span class="s1">There are several mechanisms and ways of implementing modularized applications in Java. For example, you can use OSGi if you need to provide hot deployment—that is, the capability of deploying and un-deploying modules at runtime. Another option is <strong>Service Provider Interface</strong> (<strong>SPI</strong>), a set of standard interfaces and classes included in Java SE that help with the development of extensible applications. You can even use <strong>Contexts and Dependency Injection</strong> (<strong>CDI</strong>) or an <em>inversion of control</em> framework such as the one provided by the Spring Framework to develop a custom module system based on the injection mechanism. Moreover, you could go down to the Java Reflection API to create instances of classes not known at compile time.</span></p>
<p class="p1"><span class="s1">Because explaining all these alternatives is out of the scope of this book, we'll use the simplest alternative: SPI.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Registering modules with the application</h1>
                </header>
            
            <article>
                
<p class="p2"><span class="s1">Registering a module with the application means adding the module's functionality into the application. What this module registration performs depends on the application's requirements. For example, if the application includes a main menu, then a possible registration action for a module is to add menu items to the main menu. If the application is based on tabs, a possible registration action can be adding tabs to the main screen. All these actions need to be performed through a shared API. Take the example of adding a menu item. In this case, a possible interface could be something like the following:</span></p>
<pre class="p3">public interface MenuItemRegistration {<br/>    void addMenuItem(MenuBar menu);<br/>}</pre>
<p class="p2"><span class="s1">Modules can implement this interface to add menu items into the existing application's main menu.</span></p>
<p class="p2"><span class="s1">Because we already have an</span> <kbd><span class="s2">ApplicationLayout</span></kbd> <span class="s1">interface, which defines methods to manipulate the layout, the following interface is good enough:</span></p>
<pre class="p3">public interface AppModule {<br/>    void register(ApplicationLayout layout);<br/>}</pre>
<div class="p6 packt_infobox"><span class="s1">The</span> <kbd><span class="s2">AppModule</span></kbd> <span class="s1">interface is located in the</span> <kbd><span class="s2">Data-centric-Applications-with-Vaadin-8\chapter-02\api</span></kbd> <span class="s1">Maven project of the source code that accompanies this book.</span></div>
<p class="p2"><span class="s1">This interface can be packaged in a separate JAR file so it can be distributed to any third-party developers. This JAR should contain all the classes and interfaces that could be needed by module implementations. This is the reason we previously created the</span> <kbd><span class="s2">api</span></kbd> <span class="s1">Maven module. There also is another advantage: The</span> <kbd><span class="s2">api</span></kbd> <span class="s1">JAR can be distributed to third-party developers to allow them to create new functionality for the application without distributing the whole compiled code of your web application.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Discovering modules</h1>
                </header>
            
            <article>
                
<p class="p2"><span class="s1">The</span> <kbd><span class="s2">webapp</span></kbd><span class="s1"> application should detect all the implementations of</span> <kbd><span class="s2">AppModule</span></kbd> <span class="s1">at run-time. For each implementation, it should create a new instance and call the</span> <kbd><span class="s2">register(ApplicationLayout)</span></kbd> <span class="s1">method. Doing this with Java SPI is surprisingly simple:</span></p>
<pre class="p3">public class VaadinUI extends UI {<br/><br/>    protected void init(VaadinRequest vaadinRequest) {<br/>        TabBasedApplicationLayout layout<br/>              = new TabBasedApplicationLayout("Caption");<br/>        setContent(layout);<br/>        <strong>loadModules(layout)</strong>;<br/>    }<br/><br/>    private void <strong>loadModules</strong>(<br/>            ApplicationLayout applicationLayout) {<br/>        ServiceLoader&lt;AppModule&gt; moduleLoader =<br/>                <strong>ServiceLoader.load(AppModule.class)</strong>;<br/>        moduleLoader.forEach(<br/>                module -&gt; <strong>module.register</strong>(applicationLayout));<br/>    }<br/>}</pre>
<p class="p2"><span class="s1">The</span> <kbd><span class="s2">ServiceLoader</span></kbd> <span class="s1">class is used to discover all the classes that implement the</span> <kbd><span class="s2">AppModule</span></kbd> <span class="s1">interface. For each module, we call its</span> <kbd><span class="s2">register</span></kbd> <span class="s1">method, passing the layout of the application to give the module the chance to initialize itself and modify the layout if required.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Implementing new modules</h1>
                </header>
            
            <article>
                
<p class="p2"><span class="s1">New modules have to implement the</span> <kbd><span class="s2">AppModule</span></kbd> <span class="s1">interface and follow the SPI requirements for packaging by adding a new file with the name <kbd>packt.vaadin.datacentric.chapter02.api.AppModule</kbd></span><span class="s1"> into the</span> <kbd><span class="s2">META-INF/services</span></kbd> <span class="s1">directory. This file must contain the name of the fully qualified name of the</span> <kbd><span class="s2">AppModule</span></kbd> <span class="s1">implementation.</span></p>
<p class="p2"><span class="s1">Let's say you want to develop a module that adds an option to the main menu that shows a notification when clicked. This can be easily implemented as follows:</span></p>
<pre class="p3">package com.example;<br/>...<br/><br/>public class ExampleModule implements AppModule {<br/><br/>    @Override<br/>    public void <strong>register</strong>(ApplicationLayout <strong>layout</strong>) {<br/>        ApplicationLayout.MenuOption menuOption<br/>            = new ApplicationLayout.MenuOption("Example module");<br/>        <strong>layout.addMenuOption</strong>(menuOption, this::optionClicked);<br/>    }<br/><br/>    private void optionClicked(<br/>                ApplicationLayout.MenuOption menuOption) {<br/>        Notification.show("It works!",<br/>                Notification.Type.TRAY_NOTIFICATION);<br/>    }<br/>}</pre>
<p class="p6"><span class="s1">This class can be located in a separate Maven project and should include the</span> <kbd><span class="s2">api</span></kbd> <span class="s1">dependency.</span></p>
<div class="p7 packt_infobox"><span class="s1">The</span> <kbd><span class="s2">ExampleModule</span></kbd> <span class="s1">implementation is located in the</span> <kbd><span class="s2">Data-centric-Applications-with-Vaadin-8\chapter-02\example-module</span></kbd> <span class="s1">Maven project of the source code that accompanies this book.</span></div>
<p class="p2"><span class="s1">To make the module discoverable by the </span><kbd><span class="s2">webapp</span></kbd> <span class="s1">application, you must add a file with the name <kbd><span>packt.vaadin.datacentric.chapter02.api.AppModule</span></kbd></span><span class="s1"> in the</span> <kbd><span class="s2">main/resources/META-INF/services</span></kbd> <span class="s1">directory of the new module. The file must contain the fully-qualified name of the</span> <kbd><span class="s2">AppModule</span></kbd> <span class="s1">implementation as follows:</span></p>
<pre>packt.vaadin.datacentric.chapter02.example.module.ExampleModule</pre>
<p class="p6"><span class="s1">Once packaged, you can deploy the JAR file independently and the</span> <kbd><span class="s2">webapp</span></kbd> <span class="s1">application should automatically discover and register the module.</span></p>
<div class="p7 packt_tip"><span class="s1">To deploy a module with the web application, you can add it as a dependency in the</span> <kbd><span class="s2">pom.xml</span></kbd><span class="s1"> file of the</span> <kbd><span class="s2">Data-centric-Applications-with-Vaadin-8/chapter-02/webapp</span></kbd> <span class="s1">Maven project. If you are deploying the application as a WAR file to a servlet container, you can add the JAR to the</span> <kbd><span class="s2">WEB-INF/lib</span></kbd> <span class="s1">directory.</span></div>
<p class="p2"><span class="s1">The following is a screenshot of the application, showing the example module in action:</span></p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/5732e1cf-2f64-419e-9da7-9719ddbecada.png" style=""/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p class="p2"><span class="s1">In this chapter, we developed a self-packaged UI component (a <em>main screen</em> component), <span>created a multi-module Maven project, and learned how to implement application-specific modules that are discovered and registered with a Vaadin application at run-time. While explaining </span>these concepts<span>, we also saw some Java 8 and Vaadin 8 snippets of code that </span>highlighted<span> good practices such as making your code more maintainable and extensible.</span></span></p>
<p class="p2"><span class="s1">In the next chapter, you will learn how to implement a login form with multi-language capabilities.</span></p>


            </article>

            
        </section>
    </body></html>