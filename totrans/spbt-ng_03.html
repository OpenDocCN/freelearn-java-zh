<html><head></head><body>
		<div id="_idContainer030">
			<h1 class="chapter-number" id="_idParaDest-56"><a id="_idTextAnchor058"/>3</h1>
			<h1 id="_idParaDest-57"><a id="_idTextAnchor059"/>Moving into Spring Boot</h1>
			<p>In the previous chapter, you learned how to set up your development environment for developing your REST APIs using Java and your Angular application. We also installed SDKMAN! to manage multiple versions of Java, a REST client to test APIs without the use of third-party tools, Angular DevTools to debug your Angular application, and Git for code versioning <span class="No-Break">and collaboration.</span></p>
			<p>This chapter will now teach you the concepts of Spring Boot. We will deep-dive into Spring Boot’s fundamentals and the essential things we need to learn to develop our backend application. We will also learn how to create a Spring Boot project using <span class="No-Break">Spring Initializr.</span></p>
			<p>In this chapter, we will cover the <span class="No-Break">following topics:</span></p>
			<ul>
				<li>Understanding <span class="No-Break">Spring Boot</span></li>
				<li>Using <span class="No-Break">Spring Initializr</span></li>
				<li><span class="No-Break">Dependency injection</span></li>
				<li>Beans <span class="No-Break">and annotations</span></li>
			</ul>
			<h1 id="_idParaDest-58"><a id="_idTextAnchor060"/>Technical requirements</h1>
			<p>Here is what you need to complete <span class="No-Break">this chapter:</span></p>
			<ul>
				<li><strong class="bold">For building the backend</strong>: JetBrains’ IntelliJ IDEA and the Java <span class="No-Break">17 SDK</span></li>
				<li><strong class="bold">For generating the Java project</strong>: <span class="No-Break">Spring Initializr</span></li>
			</ul>
			<p class="callout-heading">Note</p>
			<p class="callout">There will be no directories of repositories for chapters 1 to 4 because most topics here are only theory and feature some sample code. The actual application project will begin in <em class="italic">w</em>, <em class="italic">Building APIs </em><span class="No-Break"><em class="italic">with Spring</em></span><span class="No-Break">.</span></p>
			<h1 id="_idParaDest-59"><a id="_idTextAnchor061"/>Understanding Spring Boot</h1>
			<p>We have already discussed an overview of Spring in <a href="B18159_01.xhtml#_idTextAnchor015"><span class="No-Break"><em class="italic">Chapter 1</em></span></a>, <em class="italic">Spring Boot and Angular – The Big Picture</em>. In this section, we will have a deeper understanding of the essential concepts of Spring <a id="_idIndexMarker169"/>Boot in building your backend application, but first, let’s recap what Spring Boot is and its <span class="No-Break">significant advantages.</span></p>
			<p><strong class="bold">Spring Boot</strong> is an open source micro-framework from Pivotal. It is an enterprise-level framework for developers to create<a id="_idIndexMarker170"/> standalone applications on <strong class="bold">Java Virtual Machines</strong> (<strong class="bold">JVMs</strong>). Its primary focus is to shorten your code length to make it easier for you to run <span class="No-Break">your application.</span></p>
			<p>The framework extends the Spring Framework, which allows a more opinionated way to configure your applications. In addition, it comes with built-in autoconfiguration capabilities that configure both Spring Framework and third-party packages based on <span class="No-Break">your settings.</span></p>
			<p>Here are the significant advantages <a id="_idIndexMarker171"/>of <span class="No-Break">Spring Boot:</span></p>
			<ul>
				<li><strong class="bold">Auto-configuration</strong>: When configuring your Spring Boot application, it downloads all the dependencies needed to run <span class="No-Break">your application.</span></li>
				<li><strong class="bold">Opinionated approach</strong>: Spring Boot uses a narrow approach to installing dependencies based on your application's needs. Manual configuration is removed as it adds the packages you need for <span class="No-Break">your application.</span></li>
				<li><strong class="bold">Spring starters</strong>: We can choose a list of starter dependencies to define your application’s expected needs during the initialization process. One example is Spring Web, which allows us to initialize a Spring-based <span class="No-Break">web application.</span></li>
			</ul>
			<p>Now, we know what Spring Boot is and its advantages. Let’s now discuss the architecture of <span class="No-Break">Sprint Boot.</span></p>
			<h2 id="_idParaDest-60"><a id="_idTextAnchor062"/>Spring Boot architecture</h2>
			<p>Spring Boot consists of different layers and classes to process the data and logic in your backend. The four layers and their use are<a id="_idIndexMarker172"/> <span class="No-Break">as follows:</span></p>
			<ol>
				<li><strong class="bold">Presentation/display layer</strong>: The presentation layer is responsible for interpreting JSON parameters as <a id="_idIndexMarker173"/>objects. This layer is the upper layer that is also responsible for handling authentication and HTTP requests. After accomplishing JSON translation and authentication, we will now move to the <span class="No-Break">business layer.</span></li>
				<li><strong class="bold">Business layer</strong>: The business layer, as the name suggests, handles all the business logic in the application. It is <a id="_idIndexMarker174"/>composed of service classes that perform authorization and <span class="No-Break">additional validation.</span></li>
				<li><strong class="bold">Persistence layer</strong>: The <a id="_idIndexMarker175"/>persistence layer is mainly responsible for storage logic that converts objects from and to database rows to <span class="No-Break">insert data.</span></li>
				<li><strong class="bold">Database layer</strong>: The database <a id="_idIndexMarker176"/>layer performs <strong class="bold">Create, Read, Update, and Delete</strong> (<strong class="bold">CRUD</strong>) operations. The<a id="_idIndexMarker177"/> layer can consist of <span class="No-Break">multiple databases.</span></li>
			</ol>
			<p>The Spring Boot architecture depends on the Spring Framework. The framework uses all of its features, such as <a id="_idIndexMarker178"/>Spring <strong class="bold">Model-View-Controller</strong> (<strong class="bold">MVC</strong>), Spring Data, and Spring Core. The only difference is that Spring Boot does not<a id="_idIndexMarker179"/> require <strong class="bold">Data Access Object</strong> (<strong class="bold">DAO</strong>) and <span class="No-Break"><strong class="source-inline">DAOimpl</strong></span><span class="No-Break"> classes.</span></p>
			<p>Now, let’s discuss the Spring Boot Flow architecture, where we will see how data is processed inside <span class="No-Break">an application.</span></p>
			<h2 id="_idParaDest-61"><a id="_idTextAnchor063"/>Spring Boot flow architecture</h2>
			<p>The Spring Boot flow architecture<a id="_idIndexMarker180"/> will explain how the HTTP requests are processed and how layers communicate. The flow is composed of controllers, service layers, databases, and models. To have a better understanding, let’s look at the <span class="No-Break">following diagram.</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer024">
					<img alt="Figure 3.1 – Spring Boot flow architecture" src="image/B18159_03_01.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.1 – Spring Boot flow architecture</p>
			<p>In the Spring Boot flow architecture, the first thing that occurs is the client sends a request (an HTTPS request) to the controller. The controller maps the request and decides what to do with it. Next, it calls the service layer, where all business logic is performed, and gets additional dependencies required for operations from repository classes. The service layer is also responsible for performing logic on the data represented as a model and will be used by JPA to be inserted into <span class="No-Break">the database.</span></p>
			<p>We have learned the flow of the Spring Boot architecture. Now, we will discuss <strong class="bold">Representational State Transfer</strong> (<strong class="bold">REST</strong>) and <span class="No-Break">its concepts.</span></p>
			<h2 id="_idParaDest-62"><a id="_idTextAnchor064"/>Understanding REST</h2>
			<p>Before we start <a id="_idIndexMarker181"/>building our backend application, we must first know the concept of REST, as this is the primary architectural approach that we will apply for our backend to be consumable with <span class="No-Break">client applications.</span></p>
			<p>REST is a web service the primary goal of which is to make web services more effective. It allows direct access to applications<a id="_idIndexMarker182"/> through a <strong class="bold">Uniform Resource Identifier</strong> (<strong class="bold">URI</strong>) and can provide the resource in the XML or JSON format, making it <span class="No-Break">more flexible.</span></p>
			<p>The URI is where<a id="_idIndexMarker183"/> communication happens between two applications. Think of it as a bridge where the backend and frontend communicate. The client (frontend) requests a resource and returns a response represented by the XML or JSON format. Requesting a resource is used with the following <span class="No-Break">HTTP methods:</span></p>
			<ul>
				<li><strong class="source-inline">GET</strong>: This is used to get and read <span class="No-Break">a resource.</span></li>
				<li><strong class="source-inline">POST</strong>: This creates a <span class="No-Break">new resource.</span></li>
				<li><strong class="source-inline">PUT</strong>: This updates an <span class="No-Break">existing resource.</span></li>
				<li><strong class="source-inline">DELETE</strong>: This deletes <span class="No-Break">a resource.</span></li>
			</ul>
			<p>Let’s have a simple real-world example (a blog application) where we use HTTP methods to access a resource with the <span class="No-Break">provided endpoints:</span></p>
			<ul>
				<li><strong class="source-inline">GET /user/{id}/blogs</strong>: This gets the list of blogs of a <span class="No-Break">specific user.</span></li>
				<li><strong class="source-inline">POST /user/{id}/blog</strong>: This creates a blog for a <span class="No-Break">specific user.</span></li>
				<li><strong class="source-inline">PATCH /user/{id}/blog/{blog_id}</strong>: This updates an existing blog for a <span class="No-Break">specific user.</span></li>
				<li><strong class="source-inline">DELETE /user/{id}/blog/{blog_id}</strong>: This deletes an existing blog for a <span class="No-Break">specific user.</span></li>
			</ul>
			<p>In the preceding example, we request a resource using HTTP methods and endpoints. The endpoint returns an object in the form of XML or JSON in the response body. REST also supports the standard status code that will define whether our request is successful or not. The list of commonly used status codes is <span class="No-Break">as follows:</span></p>
			<ul>
				<li><strong class="source-inline">200</strong>: Success status for <span class="No-Break">the request</span></li>
				<li><strong class="source-inline">201</strong>: Indicates that an object was <span class="No-Break">successfully created</span></li>
				<li><strong class="source-inline">400</strong>: Indicates a bad request – usually happens when the request body <span class="No-Break">is invalid</span></li>
				<li><strong class="source-inline">401</strong>: Unauthorized access to <span class="No-Break">the resource</span></li>
				<li><strong class="source-inline">404</strong>: Indicates that the resource is <span class="No-Break">not found</span></li>
				<li><strong class="source-inline">500</strong>: Indicates an internal <span class="No-Break">server error</span></li>
			</ul>
			<p>The status codes are<a id="_idIndexMarker184"/> a helpful indication of what the client application will do after <a id="_idIndexMarker185"/>the HTTP call, providing an overview of how we can use REST in client and <span class="No-Break">server communication.</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer025">
					<img alt="Figure 3.2 – Communication between client and server applications" src="image/B18159_03_02.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.2 – Communication between client and server applications</p>
			<p>We learned about the concept and architecture of Spring Boot in this section. We also now know the ideas of REST and how it works to provide backend solutions. In the next section, we will generate our new Spring Boot project using <span class="No-Break">Spring Initializr.</span></p>
			<h1 id="_idParaDest-63"><a id="_idTextAnchor065"/>Using Spring Initializr</h1>
			<p>This section will explain what <strong class="bold">Spring Initializr</strong> is and how to configure and start our project. Spring Initializr is a <a id="_idIndexMarker186"/>web application that can generate a Spring Boot project on the fly. Spring Initializr will configure the build file with the required dependencies to run our project, focusing only on the code in the application. Spring Initializr makes it easier to set up our project, with the help of the <strong class="bold">Spring Boot CLI</strong> on the side, helping us configure our application. Spring Initializr generates a more traditional <span class="No-Break">Java structure.</span></p>
			<p>There are several ways to use <span class="No-Break">Spring Initializr:</span></p>
			<ul>
				<li>Via a <span class="No-Break">web-based interface</span></li>
				<li>Via <span class="No-Break">Intellij IDEA</span></li>
			</ul>
			<p>We will discuss these different ways to generate our Spring <span class="No-Break">Boot application.</span></p>
			<h2 id="_idParaDest-64"><a id="_idTextAnchor066"/>Web-based interface</h2>
			<p>The first way<a id="_idIndexMarker187"/> to use Spring Initializr is using a web-based interface. The application<a id="_idIndexMarker188"/> can be accessed through <a href="https://start.spring.io">https://start.spring.io</a>. You will see the following form once you open <span class="No-Break">the link:</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer026">
					<img alt="Figure 3.3 – Spring Initializr" src="image/B18159_03_03.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.3 – Spring Initializr</p>
			<p>The form will ask you for some basic information about your project. The first question is, <em class="italic">what is your choice between Maven and Gradle to build your project?</em> The app will also need information such as what language you will use, the artifact name, project name, and <a id="_idIndexMarker189"/>package name to be used, and what JDK version will be used when building <span class="No-Break">the application.</span></p>
			<p>Now, on the right side of the interface, you will see the <strong class="bold">Add Dependencies</strong> button. The <strong class="bold">Add Dependencies</strong> feature is one of the most important features of Spring Initializr, as this will allow us to choose the dependencies depending on the needs of our project. For example, we need to have a relational database with JPA access; we should add the Spring <span class="No-Break">Data JPA.</span></p>
			<p>Therefore, we added <strong class="bold">Lombok</strong>, <strong class="bold">Spring Web</strong>, <strong class="bold">Spring Data JPA</strong>, <strong class="bold">PostgreSQL Driver</strong>, and <strong class="bold">Spring Data Reactive Redis</strong> in the following example. We will also discuss each dependency as we go through building our <span class="No-Break">example application.</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer027">
					<img alt="Figure 3.4 – Generating Spring Boot with the dependencies" src="image/B18159_03_04.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.4 – Generating Spring Boot with the dependencies</p>
			<p>We can see in the preceding example that we have already added the dependencies we need in our project. The<a id="_idIndexMarker190"/> last would be generating our application by clicking the <strong class="bold">Generate</strong> button; this will download a zip file that will contain our application. Before generating our project, we can click the <strong class="bold">Explore</strong> button to check our project structure and verify <span class="No-Break">the configuration.</span></p>
			<p>After successfully downloading the generated Spring Boot application, we will extract the file, and we can now open the Spring Boot project with the IDE of our choice. Finally, we are ready to write our code, but first, let’s check out the project structure generated by <span class="No-Break">Spring Initializr.</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer028">
					<img alt="Figure 3.5 – A generated Spring Boot application" src="image/B18159_03_05.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.5 – A generated Spring Boot application</p>
			<p>We can see from the<a id="_idIndexMarker191"/> generated project that there is not much application code included. However, the project consists of <span class="No-Break">the following:</span></p>
			<ul>
				<li><strong class="source-inline">DemoApplication.java</strong>: A class with the <strong class="source-inline">main()</strong> function for the <span class="No-Break">application bootstrap</span></li>
				<li><strong class="source-inline">DemoApplicationTests.java</strong>: An empty JUnit test class for <span class="No-Break">unit testing</span></li>
				<li><strong class="source-inline">Pom.xml</strong>: A Maven build specification that contains the dependencies needed for <span class="No-Break">the application</span></li>
				<li><strong class="source-inline">Application.properties</strong>: A properties file that is used to add <span class="No-Break">configuration properties</span></li>
			</ul>
			<p>We can see on the generated project that empty directories are included, such as the <strong class="source-inline">static</strong> folder; this is significant, as this is used for placing static content such as CSS and <span class="No-Break">JavaScript files.</span></p>
			<p>We have successfully<a id="_idIndexMarker192"/> generated our Spring Boot project using the web interface. Now, we will use Spring Initializr directly in <span class="No-Break">IntelliJ IDEA.</span></p>
			<h2 id="_idParaDest-65"><a id="_idTextAnchor067"/>Via IntelliJ IDEA</h2>
			<p>Another way of<a id="_idIndexMarker193"/> generating our Spring Boot project is by using Spring Initializr directly in IntelliJ IDEA; note that this is only available in the Ultimate edition of IntelliJ. If you are using the Community edition, you can install Spring Assistant at the following link: <a href="https://plugins.jetbrains.com/plugin/10229-spring-assistant">https://plugins.jetbrains.com/plugin/10229-spring-assistant</a>. This will add a Spring Assistant option to<a id="_idIndexMarker194"/> generate your Spring <span class="No-Break">Boot projects.</span></p>
			<p>Execute the <span class="No-Break">following steps:</span></p>
			<ol>
				<li value="1">Select <strong class="bold">New Project</strong> upon opening IntelliJ IDEA to start generating the project, which will open a <span class="No-Break">new modal.</span></li>
				<li>Select <strong class="bold">Spring Initializr</strong>, which will open a form with the same web interface as <span class="No-Break">Spring Initializr.</span></li>
				<li>It will ask for details such as the project name, the language that will be used, the artifact name, and the SDK version that will be used to build <span class="No-Break">the project:</span></li>
			</ol>
			<div>
				<div class="IMG---Figure" id="_idContainer029">
					<img alt="Figure 3.6 – The form for ﻿using Spring Initializr with IntelliJ IDEA" src="image/B18159_03_06.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.6 – The form for using Spring Initializr with IntelliJ IDEA</p>
			<p>We can see in the<a id="_idIndexMarker195"/> preceding figure that we have populated all the required details for <span class="No-Break">our project.</span></p>
			<ol>
				<li value="4">Clicking the <strong class="bold">Next</strong> button will redirect us to the <strong class="bold">Dependencies</strong> selection. We will choose the dependencies we need for the Spring Boot development, which are the same as what we entered in the Sprint <span class="No-Break">Initializr interface.</span></li>
				<li>After successfully<a id="_idIndexMarker196"/> checking the dependencies, click <strong class="bold">Finish</strong>, and our Spring Boot application is configured. Finally, we are ready to write <span class="No-Break">our code.</span></li>
			</ol>
			<p>We have successfully generated our Spring Boot application through the Spring Initializr web interface and built-in IntelliJ IDEA. In the next section, we will learn one of the most important and commonly used concepts in Spring Boot – <span class="No-Break">dependency injection.</span></p>
			<h1 id="_idParaDest-66"><a id="_idTextAnchor068"/>Dependency injection</h1>
			<p>We have successfully<a id="_idIndexMarker197"/> generated our own Spring Boot project, and now, we will start learning the concepts of Spring, and one of the most important concepts we need to understand is <strong class="bold">dependency injection</strong>. As we develop our backend using Spring Boot, we will mainly use dependency injection throughout our development, as this makes our Java program modular and enables easier switching <span class="No-Break">of implementations.</span></p>
			<p>Dependency injection is an<a id="_idIndexMarker198"/> essential feature of <strong class="bold">object-oriented programming languages</strong>, but first, let’s discuss the concept of inversion of control, which is what dependency injection is trying <span class="No-Break">to achiev<a id="_idTextAnchor069"/><a id="_idTextAnchor070"/><a id="_idTextAnchor071"/><a id="_idTextAnchor072"/>e.</span></p>
			<h2 id="_idParaDest-67"><a id="_idTextAnchor073"/>Inversion of control</h2>
			<p><strong class="bold">Inversion of Control</strong> (<strong class="bold">IoC</strong>) is the design pattern used for object-oriented programming languages. IoC is the <a id="_idIndexMarker199"/>concept of inverting the flow of your program, and it is used for decoupling the components in your application, making <a id="_idIndexMarker200"/>your piece of code reusable and modular. Hence, the IoC design pattern will provide us with a way to inject a custom class into other classes of <span class="No-Break">our application.</span></p>
			<p>The injected class will be instantiated in different parts of our application. Instead of letting our class decide its implementations or making its code fixes, we allow the injection of dependencies to change the class’s flow, performance, and code depending on the case. Thus, IoC mainly offers flexibility and modularity, but it also provides several other advantages in designing <span class="No-Break">your applications:</span></p>
			<ul>
				<li>Having control of an object’s life cycle, we can define some objects as a singleton, and some objects can have <span class="No-Break">their instance.</span></li>
				<li>It makes the application more maintainable as your code reduces because of <span class="No-Break">reusable components.</span></li>
				<li>Testing components is more manageable, as we can isolate components and mock their dependencies, not covering other code that will not be included in <span class="No-Break">unit testing.</span></li>
			</ul>
			<p>We have learned about the IoC <a id="_idIndexMarker201"/>pattern and how it is advantageous for <a id="_idIndexMarker202"/>developing our application. Now, we will use dependency injection, which allows us to achieve <span class="No-Break">this pattern.</span></p>
			<h2 id="_idParaDest-68"><a id="_idTextAnchor074"/>The basics of dependency injection</h2>
			<p>We have already discussed how IoC works, and<a id="_idIndexMarker203"/> it is achieved by allowing an implementation to be decided by giving dependencies to the object. So, this idea is mainly <strong class="bold">dependency injection</strong>. We allow objects or classes to accept other dependencies that can provide implementations of different classes without writing them again, making our code flexible and reusable. Dependency injection can be achieved in different ways, and here are the <span class="No-Break">following implementations.</span></p>
			<h3>Constructor-based dependency injection</h3>
			<p><strong class="bold">Constructor-based dependency injection</strong> can be<a id="_idIndexMarker204"/> achieved by creating an object class with a constructor, with <a id="_idIndexMarker205"/>arguments of a specific type representing the dependency we <span class="No-Break">can set.</span></p>
			<p>Let’s have a look at the following <span class="No-Break">code example:</span></p>
			<pre class="source-code">
package com.springexample;
/* Class for Student */
public class Student {
   private Grades grades;
   public Student(grades: Grades) {
      this.grades = grades;
   }
   public void retrieveGrades() {
      grades.getGrades();
   }
}</pre>
			<p>In the preceding example, the <strong class="source-inline">Student</strong> class has a constructor, <strong class="source-inline">public Student() {}</strong>, which accepts a parameter of type <strong class="source-inline">Grades</strong>. The constructor allows us to inject a <strong class="source-inline">Grades</strong> object in <strong class="source-inline">Student</strong>, allowing all implementations of the <strong class="source-inline">Grades</strong> object to be accessible in<a id="_idIndexMarker206"/> the <strong class="source-inline">Student</strong> object. Now, we have accessed the <strong class="source-inline">getGrades()</strong> method in our <strong class="source-inline">Student</strong>. To use the <strong class="source-inline">Student</strong> object, we <a id="_idIndexMarker207"/>will execute the <span class="No-Break">following example:</span></p>
			<pre class="source-code">
package com.springexample;
import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;
public class Main {
   public static void main(String[] args) {
      ApplicationContext context =
        new  ClassPathXmlApplicationContext("Beans.xml");
      Student student =
        (Student) context.getBean("student");
      student.retrieveGrades();
   }
}</pre>
			<p>We can see in the preceding example that we have instantiated a new student in our main class by getting the bean of our <strong class="source-inline">Beans.xml</strong> file. The <strong class="source-inline">Beans.xml</strong> file is our main configuration file for our construction-based injection, which is where we will define our beans together with <span class="No-Break">their dependencies.</span></p>
			<p>Let’s examine the following <a id="_idIndexMarker208"/>example of what <strong class="source-inline">Beans.xml</strong> <span class="No-Break">looks like:</span></p>
			<pre class="source-code">
&lt;?xml version = "1.0" encoding = "UTF-8"?&gt;
&lt;beans xmlns =
   "http://www.springframework.org/schema/beans"
   xmlns:xsi = "http://www.w3.org/2001/XMLSchema-instance"
   xsi:schemaLocation =
     "http://www.springframework.org/schema/beans
      http://www.springframework.org/schema/beans/
      spring-beans-3.0.xsd"&gt;
   &lt;!-- Definition for student bean --&gt;
   &lt;bean id = "student"
     class = "com.springexample.Student"&gt;
     &lt;constructor-arg ref = "grades"/&gt;
   &lt;/bean&gt;
   &lt;!-- Definition for grades bean --&gt;
   &lt;bean id = "grades"
     class ="com.springexample.Grades"&gt;&lt;/bean&gt;
&lt;/beans&gt;</pre>
			<p>In the preceding example, we <a id="_idIndexMarker209"/>have defined the <strong class="source-inline">Student</strong> and <strong class="source-inline">Grades</strong> object as beans. The only difference is that the <strong class="source-inline">Student</strong> object has a <strong class="source-inline">constructor-arg</strong> that references grades; this indicates that we are injecting the <strong class="source-inline">Grades</strong> object into our <span class="No-Break"><strong class="source-inline">Student</strong></span><span class="No-Break"> object.</span></p>
			<p>We have already achieved <a id="_idIndexMarker210"/>constructor-based dependency by using the <strong class="source-inline">Beans.xml</strong> configuration. We can also use<a id="_idIndexMarker211"/> annotations directly in our code to configure our beans and <span class="No-Break">their dependencies.</span></p>
			<p>Let’s look at the following example of how to configure beans and dependencies <span class="No-Break">with annotations:</span></p>
			<pre class="source-code">
@Configuration
public class AppConfig
{
   @Bean
   public Student student() {
       return new Student(grades());
    }
   @Bean
   public Grades grades() {
      return new Grades();
    }
}</pre>
			<p>We can see in the preceding example that instead of using XML, we have used annotations to identify our beans and configuration. For example, the <strong class="source-inline">@Configuration</strong> annotation indicates that the <strong class="source-inline">AppConfig</strong> class is the source of the bean definitions, and the <strong class="source-inline">@Bean</strong> annotation defines the bean in our application. We will discuss annotations and beans intensely as we go throughout <span class="No-Break">this chapter.</span></p>
			<p>We have successfully<a id="_idIndexMarker212"/> learned how to implement constructor-based dependency injection by using <strong class="source-inline">Bean.xml</strong> and annotations. Now, let’s move on to the implementation of setter-based<a id="_idIndexMarker213"/> <span class="No-Break">dependency injection.</span></p>
			<h3>Setter-based dependency injection</h3>
			<p>The injection of dependencies<a id="_idIndexMarker214"/> can be achieved when the container calls the setter methods of our class. So, instead of creating a<a id="_idIndexMarker215"/> constructor for the class, we will create a function that will set the <span class="No-Break">object’s dependency.</span></p>
			<p>Let’s look at a basic <span class="No-Break">code example:</span></p>
			<pre class="source-code">
package com.springexample;
/* Class for Student */
public class Student {
   private Grades grades;
   public void setGrades(grades: Grades) {
      this.grades = grades;
   }
   public Grades getGrades() {
      return grades;
   }
   public void retrieveGrades() {
      grades.getGrades();
   }
}</pre>
			<p>In the preceding example, we can see that we have created a setter method named <strong class="source-inline">setGrades()</strong>, which accepts a <strong class="source-inline">Grades</strong> object, and its primary function is to set a value for the <span class="No-Break"><strong class="source-inline">grades</strong></span><span class="No-Break"> dependency.</span></p>
			<p>Instead of using the constructor <a id="_idIndexMarker216"/>with arguments, we use setters to inject our dependencies into <span class="No-Break">our object.</span></p>
			<p>To use the <strong class="source-inline">Student</strong> object, let’s<a id="_idIndexMarker217"/> see the <span class="No-Break">following example:</span></p>
			<pre class="source-code">
package com.springexample;
import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;
public class Main {
   public static void main(String[] args) {
      ApplicationContext context = new
        ClassPathXmlApplicationContext("Beans.xml");
      Student student =
        (Student) context.getBean("student");
      student.retrieveGrades();
   }
}</pre>
			<p>We can see in the preceding example that it’s the same as how we used setter-based objects and constructor-based objects. The difference here is how we configure our beans <span class="No-Break">in </span><span class="No-Break"><strong class="source-inline">Bean.xml</strong></span><span class="No-Break">.</span></p>
			<p>Let’s see the <strong class="source-inline">Beans.xml</strong> example for setter-based <span class="No-Break">dependency injection:</span></p>
			<pre class="source-code">
&lt;?xml version = "1.0" encoding = "UTF-8"?&gt;
&lt;beans xmlns =
   "http://www.springframework.org/schema/beans"
   xmlns:xsi = "http://www.w3.org/2001/XMLSchema-instance"
   xsi:schemaLocation =
     "http://www.springframework.org/schema/beans
      http://www.springframework.org/schema/beans/
      spring-beans-3.0.xsd"&gt;
   &lt;!-- Definition for student bean --&gt;
   &lt;bean id = "student"
     class =   "com.springexample.Student"&gt;
     &lt;property name="grades" ref = "grades"/&gt;
   &lt;/bean&gt;
   &lt;!-- Definition for grades bean --&gt;
   &lt;bean id = "grades"
     class ="com.springexample.Grades"&gt;&lt;/bean&gt;
&lt;/beans&gt;</pre>
			<p>We configured the<a id="_idIndexMarker218"/> beans in our <strong class="source-inline">Beans.xml</strong>, <strong class="source-inline">Student</strong>, and the <strong class="source-inline">Grades</strong> object in the preceding example. The<a id="_idIndexMarker219"/> only difference here is when we declare dependencies. We use the <strong class="source-inline">property</strong> tag instead of <strong class="source-inline">constructor-arg</strong> to define <span class="No-Break">our dependencies.</span></p>
			<p>We have successfully created our object with setter-based dependency injection, and now, we will discuss field-based <span class="No-Break">dependency injection.</span></p>
			<h3>Field-based dependency injection</h3>
			<p>As the name suggests, <strong class="bold">field-based dependency injection</strong> is a concept where we inject the object’s dependencies directly into the fields. We will not create a constructor or a setter method to <a id="_idIndexMarker220"/>inject our dependencies, but we will use the <strong class="source-inline">@Autowired</strong> annotation <span class="No-Break">for injection.</span></p>
			<p>Let’s see the following<a id="_idIndexMarker221"/> example of injecting dependencies into <span class="No-Break">a field:</span></p>
			<pre class="source-code">
package com.springexample;
/* Class for Student */
public class Student {
   @Autowired
   private Grades grades;
}</pre>
			<p>In the preceding example code, we can see that we didn’t create a constructor or a setter method to inject our dependency. Instead, we only used the <strong class="source-inline">@Autowired</strong> annotation to inject the <span class="No-Break"><strong class="source-inline">Grades</strong></span><span class="No-Break"> object.</span></p>
			<p>The field-based injection may be clean at first glance, having only annotations in our code and fewer methods, but many things happen behind our <strong class="source-inline">@Autowired</strong> dependency. For example, it uses reflection to inject dependencies that are costlier than a constructor and setter-based injection; it also violates the <strong class="bold">single responsibility principle</strong>. We can add more<a id="_idIndexMarker222"/> dependencies directly in the fields <span class="No-Break">without warning.</span></p>
			<p>We have learned the basics of dependency injection and the different ways to implement it in our Java application. Now, we will discuss the concept and importance of annotations and beans <span class="No-Break">in Spring.</span></p>
			<h1 id="_idParaDest-69"><a id="_idTextAnchor075"/>Annotation and beans</h1>
			<p><strong class="bold">Annotation and beans</strong> are essential parts <a id="_idIndexMarker223"/>of developing your Spring applications. They are considered the building blocks of Spring and make our code less boilerplate <span class="No-Break">and maintainable.</span></p>
			<p><strong class="bold">Spring annotations</strong> are used to <a id="_idIndexMarker224"/>define the different types of beans. They are simply a form of metadata that marks our code to provide information. Conversely, <strong class="bold">beans</strong> are objects that <a id="_idIndexMarker225"/>are instantiated and created and can be injected with other beans. We will discuss more as we go through <span class="No-Break">this section.</span></p>
			<h2 id="_idParaDest-70"><a id="_idTextAnchor076"/>Types of annotations</h2>
			<p>Annotations in Spring are categorized<a id="_idIndexMarker226"/> into different types depending on their functionality. The following are annotations grouped into their <span class="No-Break">respective categories.</span></p>
			<h3>Core annotations</h3>
			<p><strong class="bold">Core annotations</strong> are used to<a id="_idIndexMarker227"/> leverage the Spring DI engine in our applications. They can<a id="_idIndexMarker228"/> be found in the <strong class="source-inline">org.springframework.beans.factory.annotation</strong> and <strong class="source-inline">org.springframework.context.annotation</strong> packages. The following is a list of <span class="No-Break">core annotations:</span></p>
			<ul>
				<li><strong class="source-inline">@Required</strong>: This is applied in the setter methods of a bean and implies that the bean must be injected with the dependency at configuration. Otherwise, it will throw <strong class="source-inline">BeanInitializationException</strong>. Let’s look at the following example of how to use the <strong class="source-inline">@</strong><span class="No-Break"><strong class="source-inline">Required</strong></span><span class="No-Break"> annotation:</span><pre class="console">
public class Car</pre><pre class="console">
{</pre><pre class="console">
private String brand;</pre><pre class="console">
@Required</pre><pre class="console">
      public void setBrand(String brand)</pre><pre class="console">
      {</pre><pre class="console">
        this.brand = brand;</pre><pre class="console">
}</pre><pre class="console">
     public Integer getBrand()</pre><pre class="console">
     {</pre><pre class="console">
       return brand;</pre><pre class="console">
     }</pre><pre class="console">
}</pre></li>
			</ul>
			<p>In the preceding example, we can see that the <strong class="source-inline">setBrand()</strong> method was annotated with <strong class="source-inline">@Required</strong>; this indicates that the brand must be populated <span class="No-Break">on initialization.</span></p>
			<ul>
				<li><strong class="source-inline">@Autowired</strong>: We have <a id="_idIndexMarker229"/>encountered the <strong class="source-inline">@Autowired</strong> annotation several times in DI, and this is mainly used to inject dependencies without the<a id="_idIndexMarker230"/> use of constructors and setter methods. Let’s look at the following example of how to use the <strong class="source-inline">@</strong><span class="No-Break"><strong class="source-inline">Autowired</strong></span><span class="No-Break"> annotation:</span><pre class="console">
package com.springexample;</pre><pre class="console">
public class Car {</pre><pre class="console">
   @Autowired</pre><pre class="console">
   private Brand brand;</pre><pre class="console">
}</pre></li>
			</ul>
			<p>We can see in the preceding example that <strong class="source-inline">@Autowired</strong> is applied directly in the field. This is because the annotations use reflection to inject dependencies, with more processes involved than constructors and <span class="No-Break">setter methods.</span></p>
			<ul>
				<li><strong class="source-inline">@ComponentScan</strong>: The annotation is a class-level annotation to indicate the packages we want to be scanned for beans. <strong class="source-inline">@ComponentScan</strong> can accept arguments about what specific packages are to be scanned, and not providing any will allow the<a id="_idIndexMarker231"/> current packages and all sub-packages. Let’s <a id="_idIndexMarker232"/>look at the following example of how to <span class="No-Break">use </span><span class="No-Break"><strong class="source-inline">@ComponentScan</strong></span><span class="No-Break">:</span><pre class="console">
@Configuration</pre><pre class="console">
@ComponentScan</pre><pre class="console">
public class SpringApp</pre><pre class="console">
  {</pre><pre class="console">
   private static ApplicationContext</pre><pre class="console">
     applicationContext;</pre><pre class="console">
   @Bean</pre><pre class="console">
   public SpringBean springBean()</pre><pre class="console">
   {</pre><pre class="console">
      return new SpringBean();</pre><pre class="console">
   }</pre><pre class="console">
   public static void main(String[] args) {</pre><pre class="console">
     applicationContext = new</pre><pre class="console">
       AnnotationConfigApplicationContext(</pre><pre class="console">
        SpringComponentScanApp.class);</pre><pre class="console">
  }</pre><pre class="console">
}</pre></li>
			</ul>
			<p>We can see in the preceding example that the <strong class="source-inline">@ComponentScan</strong> app is applied to the Spring <strong class="source-inline">App</strong> class, and it is usually implemented together with the <strong class="source-inline">@Configuration</strong> annotation. Let’s say that <strong class="source-inline">SpringApp</strong> is found under the <strong class="source-inline">com.example.spring.app</strong> package; this will scan the package and its sub-packages if there are <span class="No-Break">existing beans.</span></p>
			<ul>
				<li><strong class="source-inline">@ComponentScan</strong>: The annotation is also a class-level annotation to indicate that a class is the source of<a id="_idIndexMarker233"/> bean definitions that the Spring <a id="_idIndexMarker234"/>container will process at runtime. Let’s look at the following example of how to use the <strong class="source-inline">@</strong><span class="No-Break"><strong class="source-inline">ComponentScan</strong></span><span class="No-Break"> annotation:</span><pre class="console">
@Configuration</pre><pre class="console">
public class SpringApp {</pre><pre class="console">
    @Bean(name="demoBean")</pre><pre class="console">
    public DemoBean service()</pre><pre class="console">
    {</pre><pre class="console">
    }</pre><pre class="console">
}</pre></li>
			</ul>
			<p>We can see in the preceding example that the <strong class="source-inline">@Configuration</strong> annotation is applied to the <strong class="source-inline">SpringApp</strong> class, which indicates that <strong class="source-inline">SpringApp</strong> will be the source <span class="No-Break">of beans.</span></p>
			<ul>
				<li><strong class="source-inline">@Bean</strong>: The annotation is a method-level annotation, and it is used to tell a method to produce a bean. Let’s look at the following example of how to use the <strong class="source-inline">@</strong><span class="No-Break"><strong class="source-inline">Bean</strong></span><span class="No-Break"> annotation:</span><pre class="console">
@Configuration</pre><pre class="console">
public class AppConfig {</pre><pre class="console">
    @Bean</pre><pre class="console">
    public BeanExample beanExample() {</pre><pre class="console">
        return new BeanExampleImlp();</pre><pre class="console">
    }</pre><pre class="console">
}</pre></li>
			</ul>
			<p>In the preceding example, the <strong class="source-inline">@Bean</strong> annotation is applied to the <strong class="source-inline">beanExample</strong> method. Once <strong class="source-inline">JavaConfig</strong> encounters the method, it will be executed and register the return value as a bean in <strong class="source-inline">BeanFactory</strong>, and the name will be the same as<a id="_idIndexMarker235"/> the method name when none <span class="No-Break">is </span><span class="No-Break"><a id="_idIndexMarker236"/></span><span class="No-Break">specified.</span></p>
			<p>The <strong class="source-inline">@Bean</strong> annotation can also be configured in Spring XML, and the equivalent configuration is <span class="No-Break">the following:</span></p>
			<pre class="console">
&lt;beans&gt;
    &lt;bean name="transferService"
      class="com.acme.TransferServiceImpl"/&gt;
&lt;/beans&gt;</pre>
			<h3>Stereotype annotations</h3>
			<p><strong class="bold">Stereotype annotations</strong> are<a id="_idIndexMarker237"/> mainly used to create Spring beans on the fly in an<a id="_idIndexMarker238"/> application context. The following is a list of <span class="No-Break">stereotype annotations:</span></p>
			<ul>
				<li><strong class="source-inline">@Component</strong>: This is the primary stereotype annotation. As with the <strong class="source-inline">@Bean</strong> annotation, the <strong class="source-inline">@Component</strong> annotation is used to define a bean or a Spring component. The difference between the two is that <strong class="source-inline">@Component</strong> is applied at the class level while <strong class="source-inline">@Bean</strong> is applied at the <span class="No-Break">method level.</span></li>
			</ul>
			<p>The other difference is that the <strong class="source-inline">@Component</strong> class cannot also be used to create a bean if the class is outside the Spring container, whereas we can create a bean using <strong class="source-inline">@Bean</strong> even if the class is found outside the Spring container. Let’s look at the following example of how to use the <strong class="source-inline">@</strong><span class="No-Break"><strong class="source-inline">Component</strong></span><span class="No-Break"> annotation:</span></p>
			<pre class="console">
@Component
public class Car
{
.......
}</pre>
			<p>We can see in the preceding example that <strong class="source-inline">@Component</strong> is applied to the <strong class="source-inline">Car</strong> class. This means that this will create a <strong class="source-inline">car</strong> bean at runtime. We also need to remember that <strong class="source-inline">@Component</strong> cannot be<a id="_idIndexMarker239"/> used with the <strong class="source-inline">@</strong><span class="No-Break"><strong class="source-inline">Configuration</strong></span><span class="No-Break"> annotation.</span></p>
			<ul>
				<li><strong class="source-inline">@Service</strong>: This<a id="_idIndexMarker240"/> annotation, used for the service layer, indicates that a class is used to execute business logic, perform calculations, and call external APIs. <strong class="source-inline">@Service</strong> is a kind of <strong class="source-inline">@</strong><span class="No-Break"><strong class="source-inline">Component</strong></span><span class="No-Break"> annotation.</span></li>
				<li><strong class="source-inline">@Repository</strong>: This annotation is used for classes that directly access a database. This is an indication of a class that executes the role of a data <span class="No-Break">access object.</span></li>
				<li><strong class="source-inline">@Controller</strong>: The annotations used for Spring controller classes. It is also a type of <strong class="source-inline">@Component</strong> annotation, used for Spring MVC and the methods annotated with <strong class="source-inline">@RequestMapping</strong>, which is used <span class="No-Break">for REST.</span></li>
			</ul>
			<h3>Spring Boot annotations</h3>
			<p>These annotations are created explicitly for <a id="_idIndexMarker241"/>Spring Boot, and this is mostly the <a id="_idIndexMarker242"/>combination of several annotations. The following is a list of Spring <span class="No-Break">Boot annotations:</span></p>
			<ul>
				<li><strong class="source-inline">@EnableAutoConfiguration</strong>: This annotation is used to auto-configure the bean present in the classpath and then to configure it to run the methods. The annotation is now rarely used, as <strong class="source-inline">@SpringBootApplication</strong> has already been released in <span class="No-Break">Spring 1.2.0.</span></li>
				<li><strong class="source-inline">@SpringBootApplication</strong>: The annotation is the combination of <strong class="source-inline">@EnableAutoConfiguration</strong>, <strong class="source-inline">@ComponentsScan</strong>, <span class="No-Break">and </span><span class="No-Break"><strong class="source-inline">@Configuration</strong></span><span class="No-Break">.</span></li>
			</ul>
			<h3>REST annotations</h3>
			<p>These are specialized annotations <a id="_idIndexMarker243"/>used to create endpoints, specify the HTTP <a id="_idIndexMarker244"/>requests, and serialize return objects. The following list shows the different <span class="No-Break">REST annotations:</span></p>
			<ul>
				<li><strong class="source-inline">@RequestMapping</strong>: This is used to create endpoints and map web requests. The annotations can be used in a class or <span class="No-Break">a method.</span></li>
				<li><strong class="source-inline">@GetMapping</strong>: This maps the HTTP <strong class="source-inline">GET</strong> requests and is used for fetching data, and it is the equivalent of <strong class="source-inline">@RequestMapping(method = </strong><span class="No-Break"><strong class="source-inline">RequestMethod.GET)</strong></span><span class="No-Break">.</span></li>
				<li><strong class="source-inline">@PostMapping</strong>: This maps the HTTP <strong class="source-inline">POST</strong> requests and is used for creating data, and it is the equivalent of <strong class="source-inline">@RequestMapping(method = </strong><span class="No-Break"><strong class="source-inline">RequestMethod.POST)</strong></span><span class="No-Break">.</span></li>
				<li><strong class="source-inline">@PostMapping</strong>: This maps the HTTP <strong class="source-inline">PUT</strong> requests and is used for updating data, and it is the equivalent of <strong class="source-inline">@RequestMapping(method = </strong><span class="No-Break"><strong class="source-inline">RequestMethod.PUT)</strong></span><span class="No-Break">.</span></li>
				<li><strong class="source-inline">@DeleteMapping</strong>: This maps the HTTP <strong class="source-inline">PUT</strong> requests and is used for deleting data, and it is the equivalent of <strong class="source-inline">@RequestMapping(method = </strong><span class="No-Break"><strong class="source-inline">RequestMethod.DELETE)</strong></span><span class="No-Break">.</span></li>
				<li><strong class="source-inline">@DeleteMapping</strong>: This maps the HTTP <strong class="source-inline">PATCH</strong> requests and is used for partial updates on data, and it is the equivalent of <strong class="source-inline">@RequestMapping(method = </strong><span class="No-Break"><strong class="source-inline">RequestMethod.PATCH)</strong></span><span class="No-Break">.</span></li>
				<li><strong class="source-inline">@RequestBody</strong>: This is used to bind HTTP requests with an object in a method parameter. The Spring framework binds the HTTP request body of the parameter with the <strong class="source-inline">@</strong><span class="No-Break"><strong class="source-inline">RequestBody</strong></span><span class="No-Break"> annotation.</span></li>
				<li><strong class="source-inline">@ResponseBody</strong>: This attaches the method's return value to the response body. The annotation indicates that the return object should be serialized into a JSON or <span class="No-Break">XML format.</span></li>
				<li><strong class="source-inline">@PathVariable</strong>: This is used to get the values from the URI. It is allowed to define multiple <strong class="source-inline">@PathVariable</strong> instances in <span class="No-Break">a method.</span></li>
				<li><strong class="source-inline">@RequestParam</strong>: This is used to <a id="_idIndexMarker245"/>get the query parameters from <span class="No-Break">the URL.</span></li>
				<li><strong class="source-inline">@RequestHeader</strong>: This is used to extract the details about the incoming HTTP request headers. We use this <a id="_idIndexMarker246"/>annotation in the parameters of <span class="No-Break">a method.</span></li>
				<li><strong class="source-inline">@RestController</strong>: This is a combination of the <strong class="source-inline">@Controller</strong> and <strong class="source-inline">@ResponseBody</strong> annotations. The importance of this annotation is that it prevents annotating each method with <strong class="source-inline">@</strong><span class="No-Break"><strong class="source-inline">ResponseBody</strong></span><span class="No-Break">.</span></li>
			</ul>
			<p>We have learned about the different types of annotations and their uses in Spring. Now, we will discuss and understand more in the next section the actual definition and importance of beans in <span class="No-Break">Spring applications.</span></p>
			<h2 id="_idParaDest-71"><a id="_idTextAnchor077"/>Understanding beans</h2>
			<p>We have already<a id="_idIndexMarker247"/> encountered beans several times in the previous section. We have learned how to create and initialize beans using <strong class="source-inline">@Bean</strong> and <strong class="source-inline">@Component</strong> annotations, but the main question is, <em class="italic">what is the primary use of a bean in </em><span class="No-Break"><em class="italic">Spring applications?</em></span></p>
			<p>A <strong class="bold">bean</strong> is the central concept of the Spring Framework we need to understand. It is essential to learn its purpose and functionality to use the Spring <span class="No-Break">Framework effectively.</span></p>
			<p>To define a bean in Spring, it is an object that forms the backbone of your application managed by the Spring IoC container. These are the objects that we mainly use for data and to inject dependencies to create multiple implementations. For better understanding, let’s have some examples <span class="No-Break">of beans.</span></p>
			<p>Let’s assume we have a domain class <span class="No-Break">named </span><span class="No-Break"><strong class="source-inline">Car</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
public class Car
{
  private Brand brand;
  public Car (Brand brand)
  {
  this.brand = brand;
  }
}</pre>
			<p>We can see in the<a id="_idIndexMarker248"/> example that the car needs a <strong class="source-inline">Brand</strong> dependency. The <strong class="source-inline">Brand</strong> class has the <span class="No-Break">following code:</span></p>
			<pre class="source-code">
public class Brand
{
  private String name;
  private int year;
  public Address(String name, int year)
  {
     this.name = name;
     this.year = year;
  }
}</pre>
			<p>The typical approach is to create a new instance of the <strong class="source-inline">Brand</strong> class and pass it as a parameter upon creating a new <strong class="source-inline">Car</strong> class. This approach will work fine, but this can cause issues when we have many classes. So, a better process is that instead of constructing dependencies by themselves, the objects can retrieve their dependencies from an IoC container in the form <span class="No-Break">of beans.</span></p>
			<p>So, what we only need to do is configure the beans and dependencies using annotations or XML to identify the dependencies required for a specific object. Let’s convert the previous example into <span class="No-Break">a bean:</span></p>
			<pre class="source-code">
@Component
public class Car
{
 . . . .
}</pre>
			<p>We will annotate the <strong class="source-inline">Car</strong> class with the <strong class="source-inline">@Component</strong> annotation to identify the class <span class="No-Break">as </span><span class="No-Break"><strong class="source-inline">Bean</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
@Configuration
@ComponentScan(basePackageClasses = Car.class)
public class Config
{
  @Bean
  public Brand getBrand() {
   return new Brand("Toyota", 2021);
  }
}</pre>
			<p>The next thing we need to<a id="_idIndexMarker249"/> do is create a configuration class. In the preceding example, we have annotated the class with <strong class="source-inline">@Configuration</strong> and <strong class="source-inline">@ComponentScan</strong> to identify that this is our configuration class; this will produce a <strong class="source-inline">Bean</strong> of type <strong class="source-inline">Brand</strong>, having configured the <strong class="source-inline">Brand</strong> class as a <strong class="source-inline">Bean</strong>. We will only need to pull the beans in the application context, and the dependencies are <span class="No-Break">already injected:</span></p>
			<pre class="source-code">
ApplicationContext context = new AnnotationConfigApplicationContext(Config.class);
Car car = context.getBean("car", Car.class);
// execute function
car.getName()
car.getYear()</pre>
			<p>In the preceding example<a id="_idIndexMarker250"/> code, we can see that we have extracted the <strong class="source-inline">Car</strong> bean in the application context. Therefore, we can automatically use the getter methods of the <strong class="source-inline">Brand</strong> dependency; this means that the IoC container manages the beans and <span class="No-Break">their dependencies.</span></p>
			<h1 id="_idParaDest-72"><a id="_idTextAnchor078"/>Summary</h1>
			<p>With this, we have reached the end of this chapter. Let’s have a recap of the valuable things you have learned. You have learned the fundamentals of Spring Boot, its architecture, and the basics of REST. You have also learned how to use Spring Initializr to create your own Spring <span class="No-Break">Boot project.</span></p>
			<p>Dependency injection allows objects or classes to accept other dependencies that can implement different classes without writing them again. Annotations define the different types of beans; they are simply a form of metadata that marks our code to <span class="No-Break">provide information.</span></p>
			<p>And finally, beans are objects that form the backbone of an application managed by the Spring <span class="No-Break">IoC container.</span></p>
			<p>In the next chapter, we will be learning how to set up a database and use Spring <span class="No-Break">Data JPA.</span></p>
		</div>
	</body></html>