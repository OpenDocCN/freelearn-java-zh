["```java\npublic void payRent(BigDecimal amount) {\n  User user = getCurrentUser();\n  if(user.payAmount != amount) {\n    System.out.println(\"Cannot pay\");\n  } else {\n    user.money -= amount;\n  }\n}\n```", "```java\npublic boolean payRent(User user, BigDecimal amount, ValidateStrategy strategy) {\n  if(strategy.validatePayment(user, amount)) {\n    user.money -= amount;\n    return true;\n  } else {\n    return false;\n  }\n}\n```", "```java\n(def sample-coll [:one :two :three])\n(def second-sample-coll (conj sample-coll :four))\n(def third-sample-coll (replace {:one 1} sample-coll))\n\nsample-coll ;; [:one :two :three]\nsecond-sample-coll ;; [:one :two :three :four]\nthird-sample-coll ;; [1 :two :three :four]\n```", "```java\n    (def c [1 1 2 2 3 3 4 4 1 1])\n    (distinct c) ;; (1 2 3 4)\n    ```", "```java\n    (take 5 c) ;; (1 1 2 2 3)\n    ```", "```java\n    (map #(+ % 1) c) ;; (2 2 3 3 4 4 5 5 2 2)\n    ```", "```java\n (->> c\n  (distinct)\n  (take 5)\n  (reverse)) ;; (4 3 2 1)\n\n;; This is known as a threading macro, it applies distinct, then take 5 then reverse to the\n;; collection c so this is the same as writing:\n;; (reverse (take 5 (distinct c))) but much more readable\n```", "```java\n[42 4 2 3 4 4 5 5]\n```", "```java\n(vec (range 4)) ;; [0 1 2 3]\n```", "```java\n(def f [some-param & some-other-params] …)\n\n(let [one 1 two (f p p-2 p-3)] …)\n```", "```java\n    (def v [42 24 13 2 11 \"a\"])\n    (v 0) ;; 42\n    (v 99) ;; java.lang.IndexOutOfBoundsException\n    ```", "```java\n    (nth v 0) ;; 42\n    (nth v 99 :not-found) ;; :not-found\n    (nth v 99) ;; java.lang.IndexOutOfBoundsException\n    ```", "```java\n    (get v 0) ;; 42\n    (get v 99 :not-found) ;; :not-found\n    (get v 99) ;; nil\n    ```", "```java\n    {:one 1 :two 2}\n    (hash-map :one 1 :two 2)\n    ```", "```java\n    (sorted-map :sample 5 :map :6) ;; {:sample 5, :map 6}\n    (sorted-map-by > 1 :one 5 :five 3 :three) ;; {5 :five, 3 :three, 1 :one}\n    ```", "```java\n    (def m #{:one 1 :two 2 :three 3})\n    (m :one) ;; 1\n    (m 1) ;; nil\n    ```", "```java\n    (let [{:keys [a b c d]} #{:a 5}]\n      [a b]) ;\n    ; [:a nil]\n    ```", "```java\n    (get m :one) ;; 1\n    (get m 1) ;; nil\n    (get m 1 :not-found) ;; :not-found\n    ```", "```java\n(seq {:one 1 42 :forty-two :6 6}) ;; ([:one 1] [:6 6] [42 :forty-two])\n(doseq [[k v] (seq {:one 1 42 :forty-two :6 6})]\n  (println k v))\n;; :one 1\n;; :6 6\n;; 42 :forty-two\n```", "```java\n    (body-that-uses x))\n```", "```java\n    (doseq [x (->> (sorted-set :b :c :d)\n                            (map name))]\n        (println x))\n    ;; b\n    ;; c\n    ;; d\n    ```", "```java\n    (#{:a :b :c :d} :a);; :a\n    (#{:a :b :c :d} :e);; nil\n    ```", "```java\n    (let [{:keys [b]} #{:b}] b);; :b\n    (let [{:keys [c]} #{:b}] b);; nil\n    (let [{:keys [c]} (sorted-set :b)] c);; nil\n    (let [{:keys [b]} (sorted-set :b)] b);; :b\n    ```", "```java\n    (get #{:a :b :c :d} :e :not-found) ;; :not-found\n    (get #{:a :b :c :d} :a) ;; :a\n    (get #{:a :b :c :d} :e) ;; nil\n    ```", "```java\n(def a #{:a :b :c :d :e})\n(def b #{:a :d :h :i :j :k})\n\n(require '[clojure.set :as s])\n\n(s/union a b) ;; #{:e :k :c :j :h :b :d :i :a}\n(s/difference a b) ;; #{:e :c :b}\n(s/intersection a b) ;; #{:d :a}\n```", "```java\nint factorial(int n) {\n    int result = 1;\n    for (int i = 1; i <= n; i++) {\n        result *= i;\n    }\n    return result;\n}\n```", "```java\nList l = new ArrayList();\ndoSomething(l);\nSystem.out.println(l.size());\n```", "```java\n(map str [1 2 3 4 5 6]) ;; (\"1\" \"2\" \"3\" \"4\" \"5\" \"6\")\n\n(defn factorial [n]\n  (reduce * (range 1 (inc n))))\n\n(factorial 5) ;; 120\n```", "```java\n(def r (range))\n```", "```java\n(take 1 r);; (0)\n(take 5 r);; (0 1 2 3 4)\n```", "```java\n(def odd-numbers (filter odd? r))\n(take 1 odd-numbers)  ;; (1)\n(take 2 odd-numbers)  ;; (1 3)\n(take 3 odd-numbers)  ;; (1 3 5)\n```", "```java\n(defn logging-odd? [number]\n    (println number) ;; This is terrible, it is a side effect and a source for problems\n                     ;; Clojure encourages you to avoid side effects, but it is pragmatic\n                     ;; and relies on you knowing what you are doing\n    (odd? number))\n\n(def odd-numbers (filter logging-odd? r))\n\n(take 1 odd-numbers)\n;; 0\n;; 1\n;; 2\n;; 3\n;; 4\n;; 5\n;; 6\n;; 7\n;; 8\n;; 9\n;; 10\n;; 11\n;; 12\n;; 13\n;; 14\n;; 15\n;; 16\n;; 17\n;; 18\n;; 19\n;; 20\n;; 21\n;; 22\n;; 23\n;; 24\n;; 25\n;; 26\n;; 27\n;; 28\n;; 29\n;; 30\n;; 31\n;; => (1)\n\n(take 1 odd-numbers)\n;; => (1)\n\n(take 2 odd-numbers)\n;; => (1 3)\n\n(take 3 odd-numbers)\n;; => (1 3 5)\n\n(take 4 odd-numbers)\n;; => (1 3 5 7)\n\n(take 10 odd-numbers)\n;; => (1 3 5 7 9 11 13 15 17 19)\n```"]