- en: Building a Commercial Web Application Using REST
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We were playing around till now, but Java is not a toy. We want to use Java
    for something real and serious, commercial and professional. In this chapter,
    we will do that. The example is not something that is only interesting to play
    with, such as Mastermind in the previous three chapters, but rather a real commercial
    application. Not a real-life application actually. You should not expect anything
    like that in a book. It would be too long and not educating enough. However, the
    application that we will develop in this chapter can be extended and can be used
    as a core for a real-life application in case you decided to do so.
  prefs: []
  type: TYPE_NORMAL
- en: In the previous chapter, we created servlets. To do so, we used the servlet
    specification, and we hand-implemented servlets. That is something you will rarely
    do these days. Instead, we will use a readily available framework, this time,
    Spring. It is the most widely used framework for Java commercial applications,
    and I dare say it is the de facto standard. It will do all the tedious work that
    we had to do (at least to understand and learn how a servlet works) in the previous
    chapter. We will also use Spring for dependency injection (why use two frameworks
    when one does it all?), and we will use Tomcat.
  prefs: []
  type: TYPE_NORMAL
- en: In the previous chapter, we used Guice as a DI framework and Jetty as a servlet
    container. They can be a perfectly good choice for some projects. For other projects,
    other frameworks do better. To have the opportunity to look at different tools
    in this book, we will use different frameworks even though all the examples could
    be created by simply using Tomcat and Spring.
  prefs: []
  type: TYPE_NORMAL
- en: The commercial application we will develop will be an ordering system targeting
    resellers. The interface we will provide to the users will not be a web browser;
    rather, it will be REST. The users will themselves develop applications that communicate
    with our system and place orders for different products. The structure of the
    application we will develop will be microservices architecture, and we will use
    soapUI to test the application, in addition to the standard Chrome developer tool
    features.
  prefs: []
  type: TYPE_NORMAL
- en: The MyBusiness web shop
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Imagine that we have a huge trading and logistics company. There are tens of
    thousands of different products on the shelves; hundreds of lorries come to our
    warehouse bringing new goods, and hundreds of lorries deliver goods to our customers.
    To manage the information, we have an inventory system that keeps track of the
    goods every day, hour, and minute to know what we actually have in the warehouse.
    We serve our customers without humans managing the warehouse information. Formerly,
    there were phones, fax machines, and even telex, but today, all we use is the
    Internet and web services. We do not provide a website for our customers. We have
    never directly served the end users in our imagined business, but these days,
    we have a subsidiary that we started off as a separate company to do just that.
    They have a website, and it is totally independent from us. They are just one
    of our hundreds of registered partners who each use a web service interface to
    see the products we have, order products, and track the order status.
  prefs: []
  type: TYPE_NORMAL
- en: Sample business architecture
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our partners are also large companies with automated administration, with several
    programs running on several machines. We have no interest in their architecture
    and the technology they use, but we want to integrate their operations. We want
    to serve them in a way that doesn't require any human interaction for the administration
    to order goods on either of our sides. To do so, a web service interface is provided
    that can be utilized no matter what IT infrastructure they use.
  prefs: []
  type: TYPE_NORMAL
- en: On our side, as we imagine the example, we recently replaced our monolithic
    application with microservices architecture, and though there are still some SOAP-based
    solutions in the system, most of the backend modules communicate using HTTPS and
    REST protocols. Some of the modules still rely on asynchronous file transfers
    done on a daily basis using FTP started from a UNIX `cron` job. The General Ledger
    system was programmed in COBOL. Fortunately, we do not need to deal with these
    dinosaurs.
  prefs: []
  type: TYPE_NORMAL
- en: All this structure is an imagined setup but a realistic one. I made up and described
    these parts to give you a picture of how you may see mixed technologies in a large
    enterprise. What I described here is a very simple setup. There are companies
    that have more than a thousand software modules in their systems using different
    technologies and totally different interfaces, all interconnected with each other.
    This is not because they like the mess, but that is the way it becomes after 30
    years of continuous IT development. New technologies come and old technologies
    fade out. The business changes and you cannot stick to the old technologies if
    you want to stay competitive. At the same time, you just cannot replace the entire
    infrastructure instantaneously. The result is that we see in an enterprise fairly
    old technologies still running and, many times, new technologies. Old technologies
    get rolled out by time. They do not stay forever, and still, we are surprised
    sometimes when a dinosaur comes in front of us.
  prefs: []
  type: TYPE_NORMAL
- en: 'What we have to deal with is the two frontend components that we will develop.
    These are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Product Information
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Order Placement and Tracking
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In the following image, you can see the architectural UML diagram of the structure
    that we look at. The parts we will have interaction with are only the frontend
    components, but it helps understand the working and their role if we have a bigger
    picture:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00049.gif)'
  prefs: []
  type: TYPE_IMG
- en: Product Information delivers information about a single product, but it can
    also deliver a list of products based on the query criteria. Order Placement and
    Tracking provides functions to place an order and also lets the client to query
    the state of past orders.
  prefs: []
  type: TYPE_NORMAL
- en: To provide product information, we need access to the Product Catalog module
    that holds the actual product details.
  prefs: []
  type: TYPE_NORMAL
- en: 'There can be a lot of other tasks that the Product Catalog does, and that is
    the reason it is a separate module. It can have, for example, a workflow and approval
    engine that lets product administrators to enter product data and managers to
    check and approve the data. Approval is usually a complex process, considering
    typos and legal questions (we do not want to trade unlicensed drugs, explosives,
    and so on), and checking the quality and approval state of the source of the goods.
    Many complex tasks are included that make it a backend module. In large enterprise
    applications, the frontend systems rarely do anything else other than the very
    basic functionality of serving the outside parties. But this is good for us; we
    can focus on the service that we have to deliver. And this is also good for the
    architecture. It is the same principle as in object-oriented programming: single
    responsibility.'
  prefs: []
  type: TYPE_NORMAL
- en: The Product Information module also has to consult with the Access Control module
    to see if a certain product can be delivered to the actual customer, and with
    the inventory to see if there is any product left, so we do not offer a product
    that is out of stock.
  prefs: []
  type: TYPE_NORMAL
- en: The Order Placement and Tracking also needs access to Product Inventory and
    Access Control modules to check whether the order can be fulfilled. At the same
    time, it also needs services from the Pricing module, which can calculate the
    price for the order, and from the Logistics module, which triggers the collection
    of goods from the inventory locations and shipment to the customer. Logistics
    also has a connection to invoicing, which has a connection to the General Ledger,
    but these are on the picture only to show that the travel of information does
    not end there. There are many other modules that run the company, all of which
    are none of our interest at the moment.
  prefs: []
  type: TYPE_NORMAL
- en: Microservices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The architecture described in the previous chapter is not a clean microservice
    architecture. You will never meet one in its pure form in any enterprise. It is
    more like something that we really meet in a real company moving from monolithic
    to microservices.
  prefs: []
  type: TYPE_NORMAL
- en: We talk about the microservice architecture when the application is developed
    in the form of many small services that communicate with each other using some
    simple API, usually over HTTP and REST. The services implement business functionalities
    and can be deployed independently. Many times, it is desirable that the service
    deployment is automated.
  prefs: []
  type: TYPE_NORMAL
- en: The individual services can be developed using different programming languages,
    can use different data storage, and can run on different operating systems; thus,
    they are highly independent of each other. They can be, and usually are, developed
    by different teams. The important requirement is that they can cooperate; thus,
    the API one service implements is usable by the other services that build upon
    it.
  prefs: []
  type: TYPE_NORMAL
- en: The microservice architecture is not the Holy Grail of all architectures. It
    gives different answers to some problems from monolithic architectures, and many
    times, these answers work better using modern tools. The applications still have
    to be tested and debugged, performance has to be managed, and bugs and issues
    have to be addressed. The difference is that testing can be separated along different
    technologies; debugging may need more network-related work. These may be good,
    bad, or both at the same time. For the developers, however, the advantage is clear.
    They can work on a smaller unit independently and can see the result of their
    work faster. When developing a single module of a monolithic application, the
    result can be seen when the entire application gets deployed. In the case of a
    large application, that may be rare. A typical deployment cycle in a large corporate
    developing monolithic is every few months, say 3, but it is not rare to see the
    release development twice or even once a year. Developing microservices, the new
    module can be deployed as soon as it is ready and tested.
  prefs: []
  type: TYPE_NORMAL
- en: If you want to read more on microservices, the first and the most authentic
    source is the article by Martin Fowler ([http://www.martinfowler.com/articles/microservices.html](http://www.martinfowler.com/articles/microservices.html)).
  prefs: []
  type: TYPE_NORMAL
- en: Service interface design
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We design the two interfaces that we will implement. When we design interfaces,
    we focus on the functionality first. Formatting and protocol come later. Interfaces
    generally should be simple and, at the same time, should accommodate the future
    change. This is a hard problem because we cannot see the future. Business, logistics,
    and all other experts may see some part of the future: how the world will change
    and what it will impose on the operation of the company and, especially, on the
    interface we provide for our partners.'
  prefs: []
  type: TYPE_NORMAL
- en: The stability of an interface is of utmost importance because the partners are
    outside entities. We cannot refactor the code they use. When we change a Java
    interface in our code, the compiler will complain at all the code locations where
    the change should be followed. In case of an interface that is used outside of
    our realm, this is not the case. Even if it is only a Java interface that we publish
    as open source on *GitHub*, we should be prepared that our users will face issues
    if we change the library in an incompatible way. In that case, their software
    will not compile and work with our library. In the case of an ordering system,
    it means that they will not order from us and we will soon be out of business.
  prefs: []
  type: TYPE_NORMAL
- en: This is one of the reasons why interfaces should be simple. Although this is
    generally true for most of the things in life, it is extremely important for such
    interfaces. It is tempting to provide convenience features for the partners because
    they are easy to implement. In the long run, however, these features may become
    very expensive as they need maintenance, should be kept backward compatible, and,
    in the long run, may not gain as much as they cost.
  prefs: []
  type: TYPE_NORMAL
- en: 'To access product information, we need two functions. One of them lists certain
    products and another returns the details of a specific product. If it were a Java
    API, it would look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Similarly, order placement may look as shown in the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'We provide these functionalities in our application via a web service interface
    and, more specifically, REST using JSON. We will discuss these technologies in
    a bit more detailed manner along with the Spring framework and Model View Controller
    design pattern, but first let''s look at the product information controller to
    get some feeling of how our program will look:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: If you compare the code of the servlet with the preceding code, you can see
    that this is much simpler. We do not need to deal with the `HttpServletRequest`
    object, call an API to get a parameter, or create an HTML output and write it
    to the response. The framework does this. We annotate the `@RestController` class,
    telling Spring that this is a controller that utilizes the *REST* web services;
    thus, it will by default create a **JSON** response from the object we return.
    We do not need to care about the conversion of the object to *JSON*, although
    we can if there is really a need. The object will automatically be converted to
    *JSON* using the field names used in the class and the field values of the instance
    we return. If the object contains more complex structures than just plain `String`,
    `int`, and `double` values, then the converter is prepared for nested structures
    and the most common data types.
  prefs: []
  type: TYPE_NORMAL
- en: To have different code handling and different URLs on the servlet, all we need
    to do is to annotate the method with `@RequestMapping`, providing the path part
    of the URL. The `{productId}` notation inside the mapping string is readable and
    easy to maintain. Spring just cuts the value from there and puts it for us in
    the `productId` variable, as requested by the `@PathVariable` annotation.
  prefs: []
  type: TYPE_NORMAL
- en: The actual lookup of the product is not implemented in the controller. That
    is not the function of the controller. The controller only decides what business
    logic to invoke and what view to use. A part of it is implemented in the framework,
    and the very small part you can see the preceding code. The business logic is
    implemented in a service class. An instance of this class is injected to the `lookup`
    field. This is also done by Spring. The actual work we have to do is to invoke
    the business logic, which this time, since we have only one, is fairly easy.
  prefs: []
  type: TYPE_NORMAL
- en: 'Most of these things seem magic without some more details about what the framework
    does for us. Therefore, before going on, we will have a look at the building blocks:
    JSON, REST, MVC, and a bit of the Spring framework.'
  prefs: []
  type: TYPE_NORMAL
- en: JSON
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**JSON** stands for **JavaScript Object Notation**. It is defined on the site,
    [http://www.json.org/](http://www.json.org/). This is a textual notation in the
    same way as the object literals are defined in JavaScript . An object representation
    starts with the `{` character and ends with the `}` character. The text in between
    defines the fields of the objects in the form, `string : value`. The string is
    the name of the field, and since JSON wants to be language agnostic, it allows
    any characters to be a part of the name of a field, and thus this string (as well
    as any string in JSON) should start and end with the `"` characters.'
  prefs: []
  type: TYPE_NORMAL
- en: 'This may seem strange and, many times, when you start working with JSON, it
    is easy to forget and write `{ myObject : "has a string" }` instead of the correct
    `{ "myObject" : "has a string" }` notation.'
  prefs: []
  type: TYPE_NORMAL
- en: Commas separate the fields. You can also have arrays in JSON. They start and
    end with `[` and `]` characters, respectively, and they contain comma-separated
    values. The value in an object field or in an array can be a string, a number,
    an object, an array, or one of the constants, `true`, `false`, and `null`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Generally speaking, JSON is a very simple notation to describe data that can
    be stored in an object. It is easy to write using text editors and easy to read,
    and thus it is easier to debug any communication that uses JSON instead of more
    complex formats. Ways to convert JSON to a Java object and the other way round,
    are readily available in libraries that we will use in this chapter. A sample
    JSON object that describes a product from our sample code is also available in
    the source code of the program, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Note that the formatting of JSON does not require a new line, but at the same
    time, this is also possible. Program-generated JSON objects are usually compact
    and are not formatted. When we edit some object using a text editor, we tend to
    format the indentation of the fields in the same way as we usually do in Java
    programming.
  prefs: []
  type: TYPE_NORMAL
- en: REST
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There is no exact definition of the **REST** protocol. It stands for **Representational
    state transfer**, which probably does not mean a thing to someone who has never
    heard of it. When we program the REST API, we use the HTTP(S) protocol. We send
    simple requests to the server, and we get simple answers that we program. This
    way, the client of the web server is also a program (by the way, the browser is
    also a program) that consumes the response from the server. The format of the
    response, therefore, is not HTML formatted using CSS and enriched by client-side
    functionalities by JavaScript**,** but rather some data descriptive format such
    as JSON. REST does not set restrictions on the actual format, but these days,
    JSON is the most widely used.
  prefs: []
  type: TYPE_NORMAL
- en: The wiki page that describes REST is available at [https://en.wikipedia.org/wiki/Representational_state_transfer](https://en.wikipedia.org/wiki/Representational_state_transfer).
    REST interfaces are usually made simple. The HTTP requests almost always use the
    `GET` method. It also makes the testing of REST services simple since nothing
    is easier than issuing a `GET` request from a browser. `POST` requests are only
    used when the service performs some transaction or change on the server, and that
    way, the request is sending data to the server rather than getting some data.
  prefs: []
  type: TYPE_NORMAL
- en: In our application, we will use the `GET` method to query a list of products
    and get information about a product, and we will only use `POST` to order products.
    The application that serves these requests will run in a servlet container. You
    have learnt how to create a naked servlet without the use of a framework. In this
    chapter, we will use the Spring framework, which offloads many of the tasks from
    the developer. There are many program constructs in servlet programming that are
    just the same most of the time. They are called boilerplate code. The Spring framework
    utilizes the Model View Controller design pattern to develop web applications;
    thus, we will look at it in brief, before discussing Spring in general.
  prefs: []
  type: TYPE_NORMAL
- en: Model View Controller
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Model View Controller** (**MVC**) is a design pattern. Design patterns are
    programming constructs: simple structures that give some hint on how to solve
    some specific problems. The term, **design pattern** was coined and formally described
    in the book, *Design Patterns, Elements of Reusable Object-Oriented Software*,
    written by Erich Gamma, Richard Helm, Ralph Johnson, and John Vlissides. The book
    defines a design pattern as a structure with a *name*, a *problem*, and a *solution*.
    The *name* describes the pattern and gives the vocabulary for the developer community
    to use when talking about these patterns. It is important that different developers
    use the same language terminology in order to understand each other. The *problem*
    describes the situation, that is, the design problem where the pattern can be
    applied. The *solution* describes classes and objects and the relations between
    them, which contribute to a good design.'
  prefs: []
  type: TYPE_NORMAL
- en: One of them is MVC, which is suitable for programming web applications but generally
    for any application that has a user interface. In our case, we do not have a classical
    user interface because the client is also a program; still, MVC can be and is
    a good choice to use.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00050.gif)'
  prefs: []
  type: TYPE_IMG
- en: 'The MVC pattern, as the name also indicates, has three parts: a model, a view,
    and a controller. This separation follows the single responsibility principle,
    requiring one part for each distinct responsibility. The controller is responsible
    for handling the inputs of the system, and it decides what model and view to use.
    It controls the execution but usually does not do any business logic. The model
    does the business logic and contains the data. View converts the model data to
    a representation that is consumable by the client.'
  prefs: []
  type: TYPE_NORMAL
- en: MVC is a well-known and widely used design pattern, and it is directly supported
    by Spring in such a way that when you create a web application, you program the
    controller built into the framework, using annotations; thus, you essentially
    configure it. You can program the view, but it is more likely that you will use
    one that is built into the framework. You will want to send data to the client
    in XML, JSON**,** or HTML. If you are very exotic, you may want to send YAML,
    but generally, that is it. You do not want to implement a new format that needs
    to be programmed on the server and, since this is new, also on the client.
  prefs: []
  type: TYPE_NORMAL
- en: We create the model, and this time, we also program it. After all, that is the
    business logic. Frameworks can do many things for us, mainly the things that are
    the same for most of the applications but for the business logic. Business logic
    is the code that distinguishes our code from other programs. That is what we have
    to program.
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, that is what we like to do. Focus on the business code and
    avoid all boilerplate provided by the framework.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we know what JSON, REST, and the general Model View Controller design
    pattern are, let's look at how these are managed by Spring and how we can put
    these technologies into action.
  prefs: []
  type: TYPE_NORMAL
- en: Spring framework
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Spring framework is a huge one with several modules. The first version of
    the framework was released in 2003, and since then, there have been four major
    releases delivering new and enhanced features. Currently, Spring is the de facto
    enterprise framework used, perhaps more widely than the standard **EJB 3.0**
  prefs: []
  type: TYPE_NORMAL
- en: Spring supports dependency injection, **Aspect-Oriented Programmin**g (**AOP**),
    persistence for **SQL** and **NoSQL** databases in a conventional and Object Relational
    Mapping way, transactional support, messaging, web programming, and many other
    features. You can configure it using **XML** configuration files, annotations,
    or Java classes.
  prefs: []
  type: TYPE_NORMAL
- en: Architecture of Spring
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Spring is not monolithic. You can use a part of it, or only some of the features.
    You can include some of the modules of Spring that you need and leave out others.
    Some modules depend on some others, but Gradle, Maven, or some other build tool
    handles that.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following image shows you the modules of the Spring framework for version
    4:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00051.gif)'
  prefs: []
  type: TYPE_IMG
- en: Spring is constantly developing since its first release, and it is still considered
    as a modern framework. The core of the framework is a dependency injection container
    similar to the one we saw in the previous chapter. As the framework developed,
    it also supported AOP and many other enterprise functionalities, such as message
    oriented patterns and web programming with an implementation of Model View Controller,
    supporting not only servlets but also portlets and WebSockets. Since Spring targets
    the enterprise application arena, it also supports database handling in many different
    ways. It supports JDBC using templates, **Object Relational Mapping** (**ORM**),
    and transaction management.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the sample program, we use a fairly recent module: Spring boot. This module
    makes it extremely easy to start writing and running applications, assuming a
    lot of configurations that are usually the same for many programs. It contains
    an embedded servlet container that it configures for default settings and configures
    Spring wherever it is possible, so we can focus on the programming aspect rather
    than on the Spring configuration.'
  prefs: []
  type: TYPE_NORMAL
- en: Spring core
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The central element of the core module is the context. When a Spring application
    starts, the container needs a context in which the container can create different
    beans. This is very general and true for any dependency injection container. If
    we programmatically create two different contexts, they may live independent of
    each other in the same **JVM**. If there is a bean declared as a singleton so
    that there should be only one single instance of it, then the container will create
    a single instance of it for a context when we need one instance. The objects representing
    the context have a reference to the object that we have already created. If there
    are multiple contexts, however, they will not know that there is another context
    in the JVM that already has an instance, and the container will create a new instance
    of the singleton bean for the other context.
  prefs: []
  type: TYPE_NORMAL
- en: Usually, we do not use more than one context in a program, but there are numerous
    examples of there being many contexts in a single JVM. When different servlets
    run in the same servlet container, they run in the same JVM separated by the class
    loader and they may each use Spring. In this case, the context will belong to
    the servlet and each will have a new context.
  prefs: []
  type: TYPE_NORMAL
- en: In the previous chapter, we used Guice. The Spring context is similar to the
    Guice injector. In the previous chapter, I was cheating a bit because I was programming
    Guice to create a new injector for each request. This is far from optimal, and
    Guice provides an injector implementation that can handle servlet environments.
    The reason for cheating was that I wanted to focus more on the DI architecture
    essentials, and I did not want to complicate the code by introducing a complex
    (well, more complex) implementation of the injector.
  prefs: []
  type: TYPE_NORMAL
- en: In the Spring context behavior, what it does, is defined by the interface `ApplicationContext`.
    There are two extensions of this interface and many implementations. `ConfigurableApplicationContext`
    extends `ApplicationContext`, defining setters, and `ConfigurableWebApplicationContext`
    defines methods needed in the web environment. When we program web applications,
    we usually do not need to interfere directly with the context. The framework configures
    the servlet container programmatically, and it contains servlets that create the
    context and invoke our methods. This is all boilerplate code created for us.
  prefs: []
  type: TYPE_NORMAL
- en: The context keeps track of the beans created, but it does not create them. To
    create beans, we need bean factories (at least one). The topmost interface of
    bean factories in Spring is `BeanFactory`. The difference between an object and
    a bean is that a bean factory creates the bean, it is registered in the context,
    and it has a `String` name. This way, the program can refer to the bean by the
    name.
  prefs: []
  type: TYPE_NORMAL
- en: Different beans can be configured in several different ways in Spring. The oldest
    approach is to create an XML file that describes the different beans, specifying
    the names, the class that has to be instantiated to create the bean, and fields
    in case the bean needs other beans to be injected for its creation.
  prefs: []
  type: TYPE_NORMAL
- en: The motivation behind this approach is that this way, the bean wiring and configuration
    can be totally independent of the application code. It becomes a configuration
    file that can be maintained separately. If we have a large application that may
    work in several different environments, the access to inventory data may be available
    in multitude ways. In one environment, the inventory is available by calling SOAP
    services. In another environment, the data is accessible in an SQL database. In
    the third environment, it can be available in some NoSQL store. Each of these
    accesses is implemented as a separate class, implementing a common inventory access
    interface. The application code depends only on the interface, and it is the container
    that has to provide one or the other implementation.
  prefs: []
  type: TYPE_NORMAL
- en: When the configuration of the bean wiring is in XML, then only this XML file
    is to be edited, and the code can be started with the implementation of the interface
    that is suitable for that environment.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next possibility is to configure the beans using annotations. Many times,
    we use beans and Spring not because there are many implementations for a bean
    functionality, but because we want to separate the creation of the object instance
    from the functionality. This is a good style: separation of the concerns even
    if the implementation is single without alternatives. However, in this case, creating
    the XML configuration is redundant. If there is an interface and a single implementation
    of it in our code, then why should I specify in an XML that by creating an object
    with a class that implements that interface, I should use the class that implements
    that interface? Quite obvious, isn''t it? We do not like programming things that
    can be automated.'
  prefs: []
  type: TYPE_NORMAL
- en: To signal that a class can be used as a bean, and to possibly provide a name,
    we can use the `@Component` annotation. We do not need to provide a name as an
    argument. In that case, the name will be an empty string, but why have a name
    if we do not refer to it? Spring scans all the classes that are on the classpath
    and recognizes the classes annotated, and it knows that they are the candidates
    to be used for bean creation. When a component needs another bean to be injected,
    the field can be annotated with `@Autowired` or `@Inject`. The `@Autowired` annotation
    is a Spring annotation and existed before the `@Inject` annotation was standardized.
    If you intend to use your code outside of the Spring container, it is recommended
    to use standard annotations. Functionally, they are equivalent.
  prefs: []
  type: TYPE_NORMAL
- en: In our code, when Spring creates an instance of the `ProductInformationController`
    component, it sees that it needs an instance of `ProductLookup`. This is an interface,
    and thus, Spring starts to look for some class that implements this interface,
    creates an instance of it, possibly first creating other beans, and then injects
    it, setting the field. You can decide to annotate the setter of the field instead
    of the field itself. In such a case, Spring will invoke the setter even if the
    setter is private. You can inject dependencies through constructor arguments.
    The major difference between the setter, field injection, and constructor injection
    is that you cannot create a bean without dependency in case you use constructor
    injection. When the bean is instantiated, it should and will have all other beans
    injected so that it depends on using the constructor injection. At the same time,
    the dependencies that need to be injected through the setter injection, or directly
    into a field, could be instantiated later by the container sometime between instantiating
    the class and readying the bean.
  prefs: []
  type: TYPE_NORMAL
- en: This slight difference may not seem interesting or important until your constructor
    code may become more complex than the simple dependency settings or until the
    dependencies become complex. In the case of a complex constructor, the code should
    pay attention to the fact that the object is not fully created. This is generally
    true for any constructor code, but in the case of beans created by a dependency
    injection container, it is even more important. Thus, it may be advisable to use
    constructor injection. In that case, the dependencies are there; if a programmer
    makes a mistake, forgetting that the object is not fully initialized, and uses
    it in the constructor or a method that is called from a constructor, the dependency
    is there. Also, it is clean and well-structured to use the constructor to initialize
    the dependencies and have those fields declared `final`.
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, constructor injection has its downsides.
  prefs: []
  type: TYPE_NORMAL
- en: If different objects depend on each other and there is a ring in the dependency
    graph, then Spring will face a hard time if you use constructor dependencies.
    When class *A* needs class *B* and the other way round, as the simplest circle,
    then neither *A* nor *B* can be created without the other if the dependency injection
    is constructor dependency. In situations like this, the constructor injection
    cannot be used, and the circle should be broken at least as a single dependency.
    In situations like this, setter injection is inevitable.
  prefs: []
  type: TYPE_NORMAL
- en: Setter injection may also be better when there are optional dependencies. Many
    times, some class may not need all its dependencies at the same time. Some class
    may use a database connection or a NoSQL database handle but not both at the same
    time. Although it may also be a code smell and probably a sign of poor OO design,
    it may happen. It may be a deliberate decision to do that because the pure OO
    design would result in too deep object hierarchies and too many classes, beyond
    the maintainable limit. If such is the situation, the optional dependencies may
    be better handled using setter injection. Some are configured and set; some are
    left with default values, usually `null`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Last but not least, we can configure the container using Java classes in case
    the annotations are not enough. For example, there are multiple implementations
    of the `ProductLookup` interface, as it is, in our code base. (Don''t worry if
    you did not recognize that; I have not told you about that yet.) There is a `ResourceBasedProductLookup`
    class that reads properties files from the package and is mainly to test the application,
    and there is `RestClientProductLookup`, which is a production-like implementation
    of the interface. If I have no other configuration than annotating the `lookup`
    field with `@Autowired`, Spring will not know which implementation to use and
    will reward the use during startup with the following error message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: This is a fairly self-explanatory error message; it tells a lot. Now is the
    time when we can configure the bean in XML, but at the same time, we can also
    configure it using Java.
  prefs: []
  type: TYPE_NORMAL
- en: Many developers do not get the point the first time. I did not get it either.
    The whole XML configuration was to separate the configuration from the code. It
    was to create the possibility that a system administrator changes the configuration
    and is free to select one or the other implementation of some interface, wiring
    the application together. Now Spring tells me that it is better to return to the
    programmatic way?
  prefs: []
  type: TYPE_NORMAL
- en: At the same time, I could hear concerns for many years that XML is not really
    any better than Java code. XML writing is essentially programming, except that
    the tooling and IDE support is not as good for XML as it is for Java code (the
    latter developed a lot in recent years, although for Spring XML configuration).
  prefs: []
  type: TYPE_NORMAL
- en: To understand the concept of returning to Java code from XML, we have to get
    back to the pure reason and aim of the XML way of configuration. The main advantage
    of XML Spring configuration is not that the format is not programmatic but rather
    that the configuration code is separated from application code. If we write the
    configuration in Java and keep those configuration classes to the bare minimum,
    and they stay as they should, then the separation of application versus configuration
    code still stands. It is only the format of the configuration that we change from
    XML to Java. The advantages are numerous. One is that the names of the classes
    are recognized by the IDE as we edit and we can have autocomplete in Java (note
    that this also works using XML in some of the IDEs utilizing some of the extensions
    of plugins). In the case of Java, IDE support is ubiquitous. Java is more readable
    than XML. Well, this is a matter of taste, but most of us like Java more than
    XML.
  prefs: []
  type: TYPE_NORMAL
- en: System administrators can also edit Java code. When they edit the XML configuration,
    they usually have to extract it from a JAR or WAR file, edit it, and then package
    the archive again. In the case of Java editing, they also have to issue a `gradle
    war` command or something similar. This should not be a showstopper for a system
    manager who runs Java applications on a server. And again, it is not Java programming.
    It is only editing some Java code files and replacing some class name literals
    and string constants.
  prefs: []
  type: TYPE_NORMAL
- en: 'We follow this approach in our sample application code. We have two configuration
    files in the application: one for local deployment and testing and another for
    production. The `@Profile` annotation specifies which profile the configuration
    should use. The profile, when the code is executed, can be specified on the command
    line as a system property, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The configuration class is annotated with `@Configuration`. The methods that
    are bean factories are annotated with `@Bean`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The bean factory simply returns a new instance of the `ResourceBasedProductLookup`
    class that implements the `ProductLookup` interface. This implementation can be
    used to run the application for local testing when there are no external services
    to rely on. This implementation reads the product data from local resource files
    packaged into the JAR application.
  prefs: []
  type: TYPE_NORMAL
- en: 'The production version of the configuration is not much different, but as it
    may be expected, there are a few more things to configure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'This version of the `ProductLookup` service class uses an external REST service
    to retrieve the data that it will present to the clients. To do so, it needs the
    URLs of these services. Such URLs should usually be configured. In our example,
    we implement a solution where these URLs can be computed on the fly. I tried to
    make up a situation where it may be needed in real life, but all reasoning was
    contorted and I gave up. The real reason is that, this way, we can see code that
    contains a bean that needs another bean to be injected. For now, note that the
    `ProductInformationServiceUrlBuilder` instance bean is defined in the same way
    as the `ProductLookup` bean, and when it has to be injected into the constructor
    of the `ProductLookup` bean, its defining bean method is used and not the following
    expression directly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The latter may work, but not in all situations and we should not use it. For
    the reasons, we will return when we discuss AOP with Spring in a subsequent section.
  prefs: []
  type: TYPE_NORMAL
- en: Also note that there is no need to define an interface to define a bean. The
    type that the bean method returns can also be a class. The context will use the
    method that fits the needed type, and if there are more than one suitable types
    and the configuration is not precise enough, as we saw, the container will log
    an error and will not work.
  prefs: []
  type: TYPE_NORMAL
- en: In the configuration that serves the local profile, we create a `null` value
    for `ProductInformationServiceBuilder`. This is because we do not need it when
    we use local testing. Also, if any method from this class is invoked, it will
    be an error. Errors should be detected as soon as possible; thus, a `null` value
    is a good choice.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `ProductInformationServiceUrlBuilder` class is very simple:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: This bean also needs a constructor parameter, and we used a string constant
    in the configuration. This clearly shows that it is possible to use a simple object
    to initialize some of the dependencies (what would stop us, it is pure Java after
    all), but it may hinder the working of some Spring features.
  prefs: []
  type: TYPE_NORMAL
- en: Service classes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We have two service classes. These classes serve the controllers with data
    and implement the business logic, no matter how simple they are. One of the service
    class implementations calls REST-based services, while the other one reads data
    from properties files. The latter can be used to test the application offline.
    The one that calls REST services is used in the production environment. Both of
    them implement the `ProductLookup` interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '`ResourceBasedProductLookup` stores the whole database in a map called products.
    It is filled from the properties files when one of the service methods is invoked.
    The `private` method `loadProducts` is invoked from each of the service methods
    when they start, but it loads the data only if it is not loaded yet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The class is annotated using `@Service`. This annotation is practically equivalent
    to the `@Component` annotation. This is only an alternative name to the same annotation.
    Spring also handles the `@Component` annotation such that if an annotation interface
    is annotated using the `@Component` annotation, the annotation can also be used
    to signal that a class is a Spring component. You can write your own annotation
    interfaces if you want to signal for better readability that a class is not a
    simple component but some other special type.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, start up your IDE and navigate to the source code of the `org.springframework.stereotype.Service`
    interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The `fromProperties` method creates an instance of `ProductInformation` and
    fills it from the parameters given in the `Properties` object. The `Properties`
    class is an old and widely used type. Although there are more modern formats and
    classes, this is still widely used and it is likely that you will meet this class.
    This is the very reason we use it here.
  prefs: []
  type: TYPE_NORMAL
- en: '`ProductInformation` is a simple **Data Transfer Object** (**DTO**) that contains
    no logic, only fields, setters, and getters. It also contains a constant, `emptyProductInformation`,
    holding a reference to an instance of the class with empty values.'
  prefs: []
  type: TYPE_NORMAL
- en: 'A `Properties` object is similar to a `Map` object. It contains `String` values
    assigned to `String` keys. There are methods, as we will see in our examples,
    that help the programmer to load a `Properties` object from a so-called properties
    file. Such a file usually has the `.properties` extension, and it contains key
    value pairs in the following format:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'For example, the `123.properties` file contains the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The `properties` files are used to store simple configuration values and are
    almost exclusively used to contain language-specific constants. This is a very
    contorted use because `properties` files are **ISO Latin-1** encoded files, and
    in case you need to use some special UTF-8 characters, you have to type them using
    the  `\uXXXX` format or using the native2ascii converter program. You cannot save
    them simply as UTF-8\. Nevertheless, this is the file format used for language-specific
    strings used for program internationalization (also abbreviated as i18n because
    there are 18 characters between the starting i and the last n).
  prefs: []
  type: TYPE_NORMAL
- en: To get the `Properties` object, we have to read the files in the project and
    get them packaged into a JAR file. The Spring class, `PathMatchingResourcePatternResolver`,
    helps us in doing so.
  prefs: []
  type: TYPE_NORMAL
- en: Gosh, yes, I know! We have to get used to these long names when we use Spring.
    Anyway, such long and descriptive names are widely used in an enterprise environment
    and they are needed to explain the functionality of the classes.
  prefs: []
  type: TYPE_NORMAL
- en: 'We declare a map that will contain all the products during the testing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The key is the product ID, which is a string in our example. The values are
    the `ProductInformation` objects that we fill up using the `fromProperties` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The next field signals that the products are not loaded:'
  prefs: []
  type: TYPE_NORMAL
- en: Novice programmers usually use the opposite value with the name `productsAreLoaded`
    and set to `false` by default. In that case, the only place where we will read
    a value will negate the value, or the main branch of the `if` command becomes
    the do nothing part. Neither is a best practice.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The `getResources` method returns all the resources (files) that are on the
    classpath under the `products` directory and that have a`.properties` extension:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The product ID is given by the name of the file. This is calculated using simple
    string manipulation, cutting off the extension. The `Resource` can also provide
    an input stream that the `Properties` class's `load` method can use to load all
    the properties at once from the file. Finally, we save the new `ProductInformation`
    object in the map.
  prefs: []
  type: TYPE_NORMAL
- en: 'We also have a special `noProduct` list that is empty. This is returned if
    there is no product for the query when we want to search for products:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The product lookup service just takes a product from the `Map` and returns
    it, or if it does not exist, it returns an empty product:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The query is a bit more complex. It implements searching for a product by title.
    Real-life implementations may implement a more complex logic, but this version
    is for local testing only; thus, the search by title is enough, perhaps even more
    complex than would be really necessary:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The service class that implements the production functionality is much simpler.
    Strange, but many times the test code is more complex than the production code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The constructor is used to inject the URL builder bean and this is all the
    auxiliary code the class has. The rest are the two service methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'The `byId` method first calls the inventory service to see if there are any
    products on the inventory. This REST service returns a JSON that has the format,
    `{ amount : nnn }`; thus, we need a class (so simple that we do not list here)
    that has the `int amount` field, the setter, and the getter.'
  prefs: []
  type: TYPE_NORMAL
- en: The Spring `RestTemplate` provides an easy way to access a REST service. All
    it needs is the URL template, a type that is used to convert the result, and a
    `Map` object with the parameters. The URL template string may contain parameters
    in the same way as the request mapping in the Spring controllers, the name of
    the parameter being between the `{` and `}` characters. The template class provides
    simple methods to access REST services. It automatically does marshaling, sending
    parameters, and un-marshaling, receiving the response. In the case of a `GET`
    request, the marshaling is not needed. The data is in the request URL, and the
    `{xxx}` placeholders are replaced with the values from the map supplied as a third
    argument. The un-marshaling is readily available for most of the formats. In our
    application, the REST service sends JSON data, and it is indicated in the response
    `Content-Type` HTTP header. `RestTemplate` converts the JSON to the type provided
    as argument. If ever the server decides to send the response in XML, and it will
    also be indicated in the HTTP header, `RestTemplate` will handle the situation
    automatically. As a matter of fact, looking at the code, we cannot tell how the
    response is encoded. This is also nice because it makes the client flexible and
    at the same time, we do not need to deal with such technical details. We can focus
    on the business logic.
  prefs: []
  type: TYPE_NORMAL
- en: At the same time, the class also provides configuration parameters in the case
    of marshaling or some other functionality so that it automatically needs that.
    You can, for example, provide marshaling methods, though I recommend that you
    use whatever is available by default. In most cases, when a developer thinks that
    there is a need for a special version of any of these functions, the original
    design of their code is flawed.
  prefs: []
  type: TYPE_NORMAL
- en: The business logic is very simple. We first ask the inventory if there is any
    product in stock. If there is (more than zero), then we query the product information
    service and return the details. If there is none, then we return an empty record.
  prefs: []
  type: TYPE_NORMAL
- en: 'The other service is even simpler. It simply calls the underpinning service
    and returns the result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Compiling and running the application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We use `gradle` to compile and run the application. Since the application does
    not have any specific configuration that would not appear in most similar applications,
    it is wise to use the Spring boot. The Spring boot makes it extremely simple to
    create and run a web application. We need a Java standard `public static void
    main` method that starts up the application via Spring:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: The method does nothing but start the `StringApplication` class's `run` method.
    It passes the original arguments and also the class that the application is in.
    Spring uses this class to read the annotation. The `@SpringBootApplication` annotation
    signals that this class is a Spring boot application and provides arguments to
    configure the packages that contain the application. To do so, you can provide
    the name of the package that contains the classes, but you can also provide a
    class in the base package that contains all the classes that Spring has to be
    aware of. You may not be able to use the class version of the annotation parameter
    because the root package may not contain any class, only sub-packages. At the
    same time, providing the name of the root package as `String`, will not reveal
    any typo or misalignment during compile time. Some *IDE* may recognize that the
    parameter is supposed to be a package name, or it may scan the strings of the
    program for package names when you refactor or rename a package and give you support
    for that, but this is more heuristics only. It is a common practice to create
    a placeholder class that does nothing in the root package in case there is no
    class there. This class can be used to specify `scanBasePackageClasses` as an
    annotation parameter instead of `scanBasePackages` that needs `String`. In our
    example, we have an empty interface, `SpringScanBase`, as a placeholder.
  prefs: []
  type: TYPE_NORMAL
- en: Spring scans all the classes that are on the classpath, recognizes the components
    and field annotations that it can interpret, and uses this knowledge to create
    beans without configuration when needed.
  prefs: []
  type: TYPE_NORMAL
- en: Note that the abstract class, `ClassLoader`, included in the JDK does not provide
    any class scanning method. Since Java environments and frameworks can implement
    their own `ClassLoaders`, it is possible (but very unlikely) that some implementation
    does not provide the scanning functionality provided by the `URLClassLoader`.
    `URLClassLoader` is a non-abstract implementation of the class loading functionality
    and is a part of the *JDK* just as well as `ClassLoader`. We will discuss the
    intricacies of the class loading mechanism in the subsequent chapters.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `gradle` build file contains the usual things. It specifies the repositories,
    the plugins for Java, the IDEs, and also for Spring boot. It also specifies the
    name of the JAR file that it generates during build. The most important part is
    the dependency list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: We depend on Spring boot packages, some test packages, AOP support (which we
    will look at soon), and also on Spring boot devtools.
  prefs: []
  type: TYPE_NORMAL
- en: 'Spring boot devtools make it possible to restart a web application whenever
    it is recompiled, without restarting the built-in Tomcat server. Suppose, we start
    the application using the following command line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: The Gradle starts up the application and whenever it sees that the classes it
    runs are modified, it reloads them, and we can test the modified application within
    a few seconds.
  prefs: []
  type: TYPE_NORMAL
- en: The `-Dspring.profiles.active=production` argument specifies that the production
    profile should be active. To be able to use this command line parameter, we will
    also need the `bootRun{}` configuration closure in the build file.
  prefs: []
  type: TYPE_NORMAL
- en: Testing the application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The application should have unit tests for each and every class it has except,
    perhaps, for the DTO classes that contain no functionality. The setters and getters
    are created by the IDE and are not typed in by the programmer, so it is unlikely
    that there will be any errors in those. If there is some error related to those
    classes, it is more likely that it is some integration problem that cannot be
    discovered using unit tests. Since we discussed unit tests in the previous chapters
    in detail, we will focus more on integration tests and application tests here.
  prefs: []
  type: TYPE_NORMAL
- en: Integration test
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Integration tests are very similar to unit tests, and many times, novice programmers
    claim they do unit testing when they actually do integration testing.
  prefs: []
  type: TYPE_NORMAL
- en: Integration tests drive the code but do not test the individual classes (units)
    in isolation, mocking everything that the class may use. Rather, they test the
    functionality of most of the classes that are needed to perform a test. This way,
    the integration test does test that the classes are able to work together and
    not only satisfy their own specifications but also ensure that these specifications
    work together.
  prefs: []
  type: TYPE_NORMAL
- en: In integration test, the external world (like external services) and access
    to database are mocked only. That is because the integration tests are supposed
    to run on integration servers, in the same environment where the unit tests are
    executed, and there these external interfaces may not be available. Many times,
    databases are mocked using in-memory SQL, and external services are mocked using
    some mock classes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Spring provides a nice environment to execute such integration tests. In our
    project, we have a sample integration test:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: This is far from being a complete and full-fledged integration test. There are
    many situations that are not tested, but here it is good as an example. To have
    all the support for the Spring environment, we have to use the `SpringRunner`
    class. The `@RunWith` annotation is handled by the JUnit framework, all other
    annotations are for Spring. When the JUnit framework sees that there is a `@RunWith`
    annotation and a runner class specified, it starts that class instead of the standard
    runner. `SpringRunner` sets up a Spring context for the test and handles the annotations.
  prefs: []
  type: TYPE_NORMAL
- en: '`@SpringBootTest` specifies the applications that we need to test. This helps
    Spring to read that class and the annotation on that class, identifying the packages
    to be scanned.'
  prefs: []
  type: TYPE_NORMAL
- en: '`@AutoConfigureMockMvc` tells Spring to configure a mock version of the Model
    View Controller framework, which can be executed without a servlet container and
    web protocol. Using that, we can test our REST services without really going to
    the network.'
  prefs: []
  type: TYPE_NORMAL
- en: '`@ActiveProfiles` tells Spring that the active profile is local and that Spring
    has to use the configuration that is denoted by the annotation, `@Profile("local")`.
    This is a version that uses the .`properties` files instead of external HTTP services;
    thus, this is appropriate for integration testing.'
  prefs: []
  type: TYPE_NORMAL
- en: The test performs `GET` requests inside the mocking framework, executes the
    code in the controller, and tests the returned value using the mocking framework
    and fluent API in a very readable way.
  prefs: []
  type: TYPE_NORMAL
- en: Note that using the properties files and having the service implementation based
    on properties file is a bit of an overkill. I created this so that it is possible
    to start up the application interactively without any real backing service. Consider
    the following command: `gradle -Dspring.profiles.active=local bootRun` .
  prefs: []
  type: TYPE_NORMAL
- en: If we issue the preceding command, then the server starts up using this local
    implementation. If we only aim for integration testing, then the local implementation
    of the service classes should be under the `test` directory and should be much
    simpler, mainly only returning constant responses for any expected request and
    throwing errors if any non-expected request comes.
  prefs: []
  type: TYPE_NORMAL
- en: Application test
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Consider the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: If we start up the application issuing the preceding command and fire up the
    browser to the URL, `http://localhost:8080/pi/123`, we will get a fat error message
    on the browser screen. Ouch...
  prefs: []
  type: TYPE_NORMAL
- en: It says `Internal Server Error, status=500` or something similar. That is because
    our code wants to connect to the backing services, but we do not have any yet.
    To have some to test the application on this level, we should create the backing
    services or at least something that mocks them. The easiest way is to use the
    soapUI program.
  prefs: []
  type: TYPE_NORMAL
- en: The soapUI is a Java program available from [https://www.soapui.org/](https://www.soapui.org/).
    There is an open source and free version of it, and there is a commercial version.
    For our purposes, the free version is enough. We can install it in the simplest
    click-forward way as it has a setup wizard. After that, we can start it up and
    use the graphical user interface.
  prefs: []
  type: TYPE_NORMAL
- en: 'We create a new test project, Catalog and inventory, and set up two REST mock
    services in it: Catalog and Inventory, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00052.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: We set up, for each of the mock services, requests to be matched and responses.
    The content of the response is text and can be typed into the text field on the
    user interface. It is important that we do not forget to set the media type of
    the response to `application/json` (the default is XML).
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00053.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Before starting the services, we have to set the port numbers by clicking on
    the cogwheel to something that is available on the server. Since 8080 is used
    by the Tomcat server executed by Gradle, and 8082 is used by soapUI to list the
    mock services that are currently running, I set the catalog to listen on 8081
    and inventory on 8083\. You can also see these port numbers in the listing of
    the `ProductInformationServiceUrlBuilder` class.
  prefs: []
  type: TYPE_NORMAL
- en: The soapUI saves the project in an XML file, and it is available for you on
    GitHub in the `project` directory.
  prefs: []
  type: TYPE_NORMAL
- en: 'After starting the mock services, the error message disappears from the browser
    screen when we press refresh:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00054.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: What we see is exactly what we typed into soapUI.
  prefs: []
  type: TYPE_NORMAL
- en: 'If now I change the inventory mock service to return 0 instead of 100, as in
    the original version, what I get is the following empty record:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: The testing even on this level can be automated. Now, we were playing around
    using the browser and this is something nice. Somehow, I feel I am producing something
    when there is a program that is really doing something, when I can see that there
    is some response in the browser window. However, after a while, this becomes boring
    and testing manually that the application is still working is cumbersome. It is
    especially boring for those functions that were not changed. The fact is that
    they do change miraculously many times even when we do not touch the code that
    influences them. We touch the code that does influence the function except that
    we are not aware of it. Poor design, poor coding, or maybe we just forgot, but
    it happens. Regression test is inevitable.
  prefs: []
  type: TYPE_NORMAL
- en: 'Although browser testing user interfaces can also be automated, this time,
    we are having a REST service that we can test and that is what soapUI is for.
    We have already installed the tool, we have already started it, and we have some
    mock services running in it. The next thing is to add a New REST service from
    URI to the project and specify the URL, `http://localhost:8080/pi/{id}`, exactly
    the same way as we did for Spring:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00055.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'When we have a REST service defined in the project, we can create a new Test
    Suite and a Test Case inside the suite. We can then add a step to the Test Case
    that will call the REST service using the parameter `123` if we modify the default
    value, which is the same as the name of the parameter, in this case, `id`. We
    can run the test step using the green triangle on the upper-left corner of the
    window, and since we have the tested application and the soapUI mock services
    running, we should get an answer in JSON. We have to select JSON on the response
    side; otherwise, soapUI tries to interpret the response as XML, and since we have
    a JSON response, it is not too fruitful. What we see is the following window:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00056.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: It is the same response that we saw in the browser. There are no miracles when
    we program computers. Sometimes, we do not understand what happens, and some things
    are so complex that they seem to be a miracle, but they are actually not. There
    is an explanation for everything, it may just not be known to us. In this case,
    we certainly know what is happening, but why is it any better to see the JSON
    on the screen of soapUI than it is on the browser? The reason is that soapUI can
    execute assertions and in some cases, further test steps based on the result of
    the REST invocation, and the final result is a simple YES or NO. The test is OK,
    or it FAILS.
  prefs: []
  type: TYPE_NORMAL
- en: To add an assertion, click on the Assertions text on the lower-left corner of
    the window. As you can see in the preceding screenshot, I have already added one
    that compares the `"title"` field of the returned JSON with the text `"Bar Stool"`.
    When we add the assertion, the default value it suggests is the one that was actually
    returned, which is just a very handy feature.
  prefs: []
  type: TYPE_NORMAL
- en: 'After this, running the whole test suite again will run all the test cases
    (we have only one), and all the test steps, one after the other (we again have
    only one), and finally it will display a green FINISHED bar on the UI, as shown
    in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00057.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: This is not all that soapUI can do. This is a well-developed test tool that
    has been in the market for many years. soapUI can test SOAP services and REST
    services, and it can handle JMS messages. You can create tests of many steps with
    these calls, loops, and assertions in calls or in separate tests, and in case
    all else fails, you can do just anything by creating programmed steps in the Groovy
    language or creating extensions in Java.
  prefs: []
  type: TYPE_NORMAL
- en: Servlet filters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The services work fine by now and anyone can query the details of our products.
    That may be a problem. The details of the products are not necessarily public
    information. We have to ensure that we serve the data only to partners who are
    eligible to see it.
  prefs: []
  type: TYPE_NORMAL
- en: To ensure that, we need something in the request that proves that the request
    comes from a partner. This information is typically a password or some other secret.
    It could be placed into the `GET` request parameters or into the HTTP request
    header. It is better to put it into the header because the information is secret
    and not to be seen by anybody.
  prefs: []
  type: TYPE_NORMAL
- en: The GET parameters are a part of the URL, and the browser history remembers
    that. It is also very easy to enter this information into the browser location
    window, copy paste it, and send it over a chat channel or over e-mail. This way,
    a user of the application, who is not so educated and concerned about security,
    may disclose secret information. Although it is not impossible to do the same
    with information that is sent in an HTTP header, it is not likely to happen. If
    the information is in the header and somebody sends the information in an e-mail,
    they probably know what they are doing; they cross a security border willingly
    and not by simple negligence.
  prefs: []
  type: TYPE_NORMAL
- en: To send authentication information along the HTTP request, Spring provides a
    security module that can easily be configured with annotations and configuration
    XMLs and/or classes. This time, we will do it a bit differently to introduce servlet
    filters.
  prefs: []
  type: TYPE_NORMAL
- en: We will require that the vendors insert the `X-PartnerSecret` header into the
    request. This is a non-standard header, and thus it must have the `X-` prefix.
    Following this approach is also some extra security feature. This way, we can
    prevent the user from reaching the service using a simple browser. There is, at
    least, a need for some extra plugin that can insert a custom header or some other
    program such as soapUI. This way, it will ensure that our partners will use the
    interface programmatically, or if ever they need to test the interface ad hoc,
    only users with a certain level of technology can do so. This is important to
    keep the support costs controlled.
  prefs: []
  type: TYPE_NORMAL
- en: Since this secret has to be checked in the case of each and every service, we
    better not insert the checking code into each and every service controller. Even
    if we create the code properly and factor the check for the secret into a separate
    class, the invocation of the method asserting that the secret is there and is
    correct will have to be inserted in each and every controller. The controller
    does the service; checking the client authenticity is an infrastructure issue.
    They are different concerns, and thus, they have to be separated.
  prefs: []
  type: TYPE_NORMAL
- en: The best way that the servlet standard provides for us is a servlet filter.
    A servlet filter is a class invoked by the servlet container before the servlet
    itself if the filter is configured. The filter can be configured in the `web.xml`
    configuration file of the servlet container or by using an annotation when we
    use the Spring boot. The filter does not only get the request and response as
    parameters but also a third argument of the `FilterChain` type that it should
    use to call the servlet or the next filter in the chain.
  prefs: []
  type: TYPE_NORMAL
- en: There can be more than one filter defined and they get chained up. The filter
    may, at its discretion, decide to call or not to call the next in the chain.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00058.gif)'
  prefs: []
  type: TYPE_IMG
- en: 'We put our servlet filter into the `auth` sub-package of our application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: The filter implements the `Filter` interface that defines three methods. In
    our case, we do not have any parameters to consider in the filter, and we do not
    allocate any resources to release; thus, both `init` and `destroy` methods are
    empty. The main work of the filter is the `doFilter` method. It has three parameters,
    two of them are the same as the parameters of a servlet and the third is `FilterChain`.
  prefs: []
  type: TYPE_NORMAL
- en: The request is converted to `HttpServletRequest`, so we can get access to the
    `X-PartnerSecret` header through the `getHeader` method. If the value sent in
    this header field is good, we call the next in the chain. In our application,
    there are no more filters configured; therefore, the next in the chain is the
    servlet. If the secret is not acceptable, then we do not call the next in the
    chain. Instead, we return the *401 Not Authorized* HTTP error to the client.
  prefs: []
  type: TYPE_NORMAL
- en: In this application, the secret is very simple. This is the constant string
    `packt`. This is not really a big secret, especially now that it is published
    in this book. A real-life application would require something more cryptic and
    less known. It is very probable that each partner would use different secrets
    and that the secret has to change from time to time.
  prefs: []
  type: TYPE_NORMAL
- en: When there is an error condition in a servlet that our program handles, it is
    a good practice to use the HTTP error handling mechanism. Instead of sending back
    a message with the status code *200 OK* and explaining, for example, in a JSON
    format that the authentication was not successful, we have to send back the *401
    code*. This is defined by the standard and does not need any further explanation
    or documentation.
  prefs: []
  type: TYPE_NORMAL
- en: There is one thing left in our program, and that is audit logging.
  prefs: []
  type: TYPE_NORMAL
- en: Audit logging and AOP
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have logging in our sample code and for that we use slf4j, which we covered
    in the previous chapter. Logging is more or less the decision of the developer
    and supports technical levels of operation. There, we also touched on a few sentence
    audit loggings. This type of logging is usually explicitly required in a functional
    requirement.
  prefs: []
  type: TYPE_NORMAL
- en: Generally, AOP is separating the different aspects of code functionality into
    separate code fragments, and implementing them independent of each other. This
    is very much the single responsibility principle. This time, it is implemented
    in a way that not only the different functionalities are implemented separately
    but also how we connect them together is defined separately. What is executed
    before and after what other parts are encoded separately gets to the Spring configuration.
    We have seen something similar already. The dependencies that a class needs to
    properly operate are defined in a separate segment (XML or Java code). It is not
    a surprise that in the case of AOP, the same is done using Spring. Aspects are
    configured in the configuration file or class.
  prefs: []
  type: TYPE_NORMAL
- en: A typical aspect is audit logging, and we will use this as an example. There
    are many topics that can be implemented using aspects, and some of them are even
    worth implementing that way.
  prefs: []
  type: TYPE_NORMAL
- en: We do not want to implement the audit logging code in each business method or
    class that needs it. Instead, we implement a general aspect and configure the
    wiring such that whenever a bean method that needs audit logging is invoked, Spring
    invokes the audit logging.
  prefs: []
  type: TYPE_NORMAL
- en: There are other important terminologies that we should understand for AOP and
    especially how AOP can be configured in Spring.
  prefs: []
  type: TYPE_NORMAL
- en: The first and most important is the aspect. This is the functionality that we
    want to implement, in our example, the audit logging.
  prefs: []
  type: TYPE_NORMAL
- en: Join point is the point in execution when an aspect is invoked. When using a
    full-scale aspect solution in Java that modifies the byte code of the generated
    class, a join point can be almost anything. It can be access to a field, read
    or write; it can be the invocation of a method or exception throwing. In the case
    of Spring, the class byte code is not modified; thus, Spring is not able to identify
    the access of a field or an exception throwing. Using Spring, a join point is
    always used when a method is invoked.
  prefs: []
  type: TYPE_NORMAL
- en: An advice is how the aspect is invoked at the join point. It can be before advice,
    after advice, or around advice. When the advice is before, the aspect is invoked
    before the method is called. When the advice is after, the aspect is invoked after
    the method is invoked. Around means that the aspect is invoked before the method
    call, and the aspect also has an argument to call the method and still perform
    some actions after the method is called. This way, the around advice is very similar
    to servlet filters.
  prefs: []
  type: TYPE_NORMAL
- en: The before advice is called before the method call, and after it returns, the
    framework will invoke the method. There is no way for the aspect to prevent the
    invocation of the original method. The only exception is when the aspect, well,
    throws an exception.
  prefs: []
  type: TYPE_NORMAL
- en: The after advice is also affected by exceptions. There can be an after returning
    advice that is invoked when the method is returning. The after throwing is invoked
    only if the method were throwing an exception. After finally is invoked in the
    case of an exception or return.
  prefs: []
  type: TYPE_NORMAL
- en: Pointcut is a special string expression that identifies join points. A pointcut
    expression may match zero, one, or more join points. When the aspect is associated
    with a pointcut expression, the framework will know the join points and when and
    where to invoke the aspect. In other words, pointcut is the string that tells
    when and for which method to invoke the aspect.
  prefs: []
  type: TYPE_NORMAL
- en: Even though Spring implementation of AOP does not use AspectJ and does not modify
    the byte code that was created for the classes, it supports the pointcut expression
    language. Although this expression language provides more features than what Spring
    implements, it is a well-established and widely used and accepted expression language
    to describe pointcuts, and it just would not make sense to invent something new.
  prefs: []
  type: TYPE_NORMAL
- en: '*Introduction* is adding methods or fields to a type that already exists and
    doing it during runtime. Spring allows this AOP functionality to add an interface
    to an existing type and add an implementation of the interface in the form of
    an advice class. In our example, we do not use this functionality.'
  prefs: []
  type: TYPE_NORMAL
- en: '*Target object* is the object that is being advised by the aspect. This is
    the bean that contains the method around the aspect, that is, before or after
    the aspect is invoked.'
  prefs: []
  type: TYPE_NORMAL
- en: 'That was just a condensed set of definitions, almost like in a math book. If
    you did not get the point just reading it, don''t worry. I did not understand
    it either. That is why we have the following example, after which all we just
    covered will make more sense:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: The class is annotated with the `@Configuration` annotation so that Spring knows
    that this class contains the configuration. The `@Aspect` annotation denotes that
    this configuration may also contain aspect definitions. The `@Around` annotation
    on the methods gives the type of advice, and the argument string for the annotation
    is the pointcut expression. If the type of advice is different, one of the annotations,
    `@Before`, `@After`, `@AfterReturning`, or `@AfterThrowing`, should be used.
  prefs: []
  type: TYPE_NORMAL
- en: In our example, we use the `@Around` aspect to demonstrate the most complex
    scenario. We log the execution of the target method before and after the execution
    of the method, and we also call the original method through the `ProceedingJoinPoint`
    object. Because the two objects return different types and we want to log differently,
    we define two aspect methods.
  prefs: []
  type: TYPE_NORMAL
- en: The argument of the advice annotation is the pointcut string. In this case,
    it is a simple one. The first one, `execution(* byId(..))`, says that the aspect
    should be invoked for any execution of any method that has the name byId and has
    any arguments. The second is very similar, except the name of the method is different.
    These are simple pointcut expressions, but in a large application that heavily
    uses AOP, they can be very complex.
  prefs: []
  type: TYPE_NORMAL
- en: 'The pointcut expression syntax in Spring mainly follows the syntax used by
    AspectJ. The expression uses the notion of **point cut designator** (**PCD**)
    that is usually execution. It is followed by the pattern that defines which method
    to intercept. The general format is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Except for the return type part, all other parts are optional. For example,
    we can write the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'This will intercept all `public` methods. The following expression intercepts
    all methods that have a name starting with set:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: We can use the `*` character as a joker in the same way as we can use it on
    the command line in Windows or Unix shell. The argument matching definition is
    a bit more complex. `(..)` means any arguments, `()` means no arguments, and `(*)`
    means exactly one argument of any type. The last one can also be used when there
    are more arguments; for example, `(*,Integer)` means that there are two arguments,
    the second being an `Integer`, and we just do not care what the type of the first
    one is.
  prefs: []
  type: TYPE_NORMAL
- en: Pointcut expressions can be more complex, joining together match expressions
    with the `&&` (and) and `||` (or) logical operators, or using the `!` (negation)
    unary operator.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using the `@Pointcut()` annotation, the configuration can define pointcuts
    putting the annotations on methods. For example, consider the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'It will define a join point for any method that is implemented in any class
    in the `packt.java.9.by.example.service` package. This merely defines the pointcut
    expression and assigns it to the name `businessService`, which is given by the
    name of the method. Later, we can refer to this expression in aspect annotations,
    for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that the use of the method is purely for its name. This method is not
    invoked by Spring. It is only used to borrow its name to the expression that is
    defined on it using the `@Pointcut` annotation. There is a need for something,
    such as a method, to put this annotation on, and since methods have names, why
    not use it: Spring does it. When it scans the configuration classes and sees the
    annotation, it assigns it in its internal structures to the name of the method,
    and when that name (along with the parenthesis, to confuse the novice programmer
    mimicking a method call) is used, it looks up the expression for that name.'
  prefs: []
  type: TYPE_NORMAL
- en: AspectJ defines other designators. Spring AOP recognizes some of them, but it
    throws `IllegalArgumentException` because Spring implements only method execution
    pointcuts. AspectJ, on the other hand, can also intercept object creation for
    which the PCD is initialization, as an example. Some other PCDs, in addition to
    execution, can limit an execution PCD. For example, the PCD, `within`, can be
    used to limit the aspect to join points belonging to classes within certain packages,
    or the `@target` PCD can be used to limit the matching to methods in objects that
    have the annotation given between `(` and `)` after the keyword `@target` in the
    pointcut expression.
  prefs: []
  type: TYPE_NORMAL
- en: There is a PCD that Spring uses that does not exist in AspectJ. This is a bean.
    You can define a pointcut expression that contains `bean(name pattern)` to limit
    the join point to method executions that are in the named bean. The pattern can
    be the entire name or it can be, as almost any PCD expression matching, `*` as
    a joker character.
  prefs: []
  type: TYPE_NORMAL
- en: Dynamic proxy-based AOP
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Spring AOP, when first presented to Java programmers, seems like magic. How
    does it happen that we have a variable of `class``X` and we call some method on
    that object, but instead, it executes some aspect before or after the method execution,
    or even around it, intercepting the call
  prefs: []
  type: TYPE_NORMAL
- en: 'The technique that Spring does is called dynamic proxy. When we have an object,
    which implements an interface, we can create another object—the proxy object—that
    also implements that interface, but each and every method implementation invokes
    a different object called handler, implementing the JDK interface, `InvocationHandler`.
    When a method of the interface is invoked on the proxy object, it will call the
    following method on the handler object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: This method is free to do anything, even calling the original method on the
    target object with the original or modified argument.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00059.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: When we do not have an interface at hand that the class to be proxied implements,
    we cannot use JDK methods. Luckily, there are widely used libraries, such as `cglib`,
    which are also used by Spring and that can do something similar. `Cglib` can create
    a proxy object that extends the original class and implements its methods, invoking
    the handler object's invoke method in a way similar to how the JDK version does
    for the interface methods.
  prefs: []
  type: TYPE_NORMAL
- en: These technologies create and load classes into the Java memory during runtime,
    and they are very deep technical tools. They are advanced topics. I do not say
    not to play with them while being a novice Java programmer. After all, what can
    happen? Java is not a loaded gun. It is, however, important that you do not lose
    your interest when you do not understand some of the details or something does
    not work first. Or second. Or third... Keep swimming.
  prefs: []
  type: TYPE_NORMAL
- en: AOP implementation in Spring works by generating proxy objects for the target
    objects, and the handlers invoke the aspects that we define in the Spring configuration.
    This is the reason you cannot put aspects on `final` classes or on `final` methods.
    Also, you cannot configure aspects on `private` or `protected` methods. The `protected`
    methods could be proxied in principle, but this is not a good practice, and thus
    Spring AOP does not support it. Similarly, you cannot put aspects on classes that
    are not Spring beans. They are created by the code directly and not through Spring
    and have no chance to return a proxy instead of the original object when the object
    is created. Simply put, if Spring is not asked to create the object, it cannot
    create a custom one. The last thing we want to do is to execute the program and
    see how the aspects perform. The implementation of our audit logging is extremely
    simple. We use the standard logging, which is not really sufficient for a real-life
    application of audit logging. The only special thing we do is that we use a logger
    identified by the name, `AUDIT_LOG` and not by the name of a class. This is a
    legitimate use of the loggers in most of the logging frameworks. In spite of the
    fact that we usually use the class to identify the logger, it is absolutely possible
    to use a string to identify a logger. In the case of our logging, this string
    will also be printed on the console in the log lines, and it will visually stand
    out.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'If we again start the application with the preceding command, start soapUI
    for the project, start the mock services, and execute the test, we will see on
    the console the following log lines that the aspects print:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we built a simple business application that supports business-to-business
    transactions. We implemented a REST service in a microservices (almost) architecture
    using the features that are provided by the de facto standard enterprise framework:
    Spring. Looking back at the chapter, it is amazing how few lines of code we wrote
    to achieve all the functionality, and that is good. The less code we need to develop
    what we want, the better. This proves the power of the framework.'
  prefs: []
  type: TYPE_NORMAL
- en: We discussed microservices, HTTP, REST, JSON, and how to use them using the
    MVC design pattern. We learned how Spring is built up, what modules are there,
    how dependency injection works in Spring, and we even touched a bit of AOP. This
    was very important because along with AOP, we discovered how Spring works using
    dynamic proxy objects, and this is something that is very valuable when you need
    to debug Spring or some other framework that uses a similar solution (and there
    are a few frequently used).
  prefs: []
  type: TYPE_NORMAL
- en: We started to test our code using a simple browser, but after that we realized
    that REST services are better tested using some professional testing tool, and
    for that we used soapUI and built up a simple REST test suite with REST test steps
    and mock services.
  prefs: []
  type: TYPE_NORMAL
- en: Having learnt all that, nothing will stop us from extending this application
    using very modern and advanced Java technologies, such as reflection (which we
    have already touched on a bit when we discussed the JDK dynamic proxy), Java streams,
    lambda expressions, and scripting on the server side.
  prefs: []
  type: TYPE_NORMAL
