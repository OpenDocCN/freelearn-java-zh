- en: Introducing the Modular JDK
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous two chapters, you've learnt about the modular API in Java 9
    and how to create your own custom modules. There's much more to Java 9 modules
    than that! The introduction of modularity in Java is not just a new *feature*
    for developers to use; it has resulted in major changes to the Java platform itself.
    In fact, Java 9 also has had perhaps the biggest overhaul of the internal Java
    codebase ever. Java 9 not only comes with the ability for developers to create
    their own modules, the whole Java platform itself has been modularized. In this
    chapter, let's examine these important changes, both to learn what the changes
    are, and to understand *why* they came about. Now that you have warmed up to Java
    modules by writing modules yourself, it's time to put our thinking caps on and
    really understand the problems and the requirements that resulted in this major
    change in the Java language. Not only will it help us appreciate the changes better,
    learning how and why the JDK was modularized will help us apply these lessons
    when we learn how to migrate our own Java code to Java 9 in [Chapter 11](part0172.html#5410O0-ed2405f4162b4f86b565edd6b6d679fb),
    *Migrating Your Code to Java 9*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are the topics that we''ll cover in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: We'll start by examining two aspects of the JDK as they were before Java 9 and
    some problems with them. It's important for us to know the way things were, so
    that we can fully understand the effect of the new changes.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You'll learn how modularity has transformed the Java platform and be introduced
    to the built-in modules.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You'll learn how to browse built-in modules and get information about their
    module definitions.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You'll learn how to understand module relationships in a module graph.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Examining the legacy JDK
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Java has been around for over two decades now. For the most part of its lifetime,
    there have been a few things that haven''t changed. Let''s focus our attention
    on two aspects of the JDK the way they were in Java 8 or earlier:'
  prefs: []
  type: TYPE_NORMAL
- en: '**The JRE structure**: The file and directory structure that **Java Runtime
    Environment** (**JRE**) is installed as when it is set up on a computer'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The state of API encapsulation**: The differences between the *public* Java
    APIs and the internal platform classes'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The JRE structure
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When you install the Java 8 Runtime Environment on any machine and examine
    the installed directory, you''ll see, among other files and folders, the following
    two important directories:'
  prefs: []
  type: TYPE_NORMAL
- en: A `bin` directory with executable files, an important one of which is the Java
    executable that lets you run Java programs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `lib` directory with some key `.jar` files including the all-important `rt.jar`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You may not have had to deal with the `rt.jar` directly when coding in Java,
    but you should know that it's the single most important `jar` file in the runtime.
    Can you guess what it's for?
  prefs: []
  type: TYPE_NORMAL
- en: Understanding rt.jar
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's say you build a Java application that uses some core library classes such
    as collections and threads. When you compile and distribute your application to
    be run on another machine with Java installed, you can get away with packaging
    just the classes you've written in your application, and *not* include the compiled
    `Collection` and `Thread` classes. That's because every runtime comes with all
    the compiled platform classes out-of-the-box, so that every developer doesn't
    have to distribute them with their applications. The way these classes are bundled
    into the JRE is through a single file--`rt.jar`. You'd place your application
    classes in the classpath for the runtime to find, but for any of the platform
    classes, it just finds them in `rt.jar`. The name `rt` stands for **Run Time**,
    and this single jar file holds the entire Java runtime. Yes, you read that right!
    `rt.jar` essentially contains all the compiled classes in the Java platform, all
    bundled into one JAR file. Every. Single. One. Of. Them.
  prefs: []
  type: TYPE_NORMAL
- en: The problem with this model
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This has been the state of affairs for multiple Java releases now. The decision
    to bundle all the platform classes into a single JAR file was made quite early
    in Java's life and it might have been a good idea at the time. But considering
    how much the platform has grown and how many new classes have been added to the
    platform over the years, it's clearly not a good idea anymore. With Java 8, the
    `rt.jar` measures close to 60 MB in size. And even if you might find it bearable
    now, imagine how it would scale, if say, Java continues to grow at a good pace
    for the next 10 years and ends up having a few thousands more classes added. Would
    we still be fine with bundling them all into a single jar file then?
  prefs: []
  type: TYPE_NORMAL
- en: In addition to the platform developers having to deal with the monolithic JAR
    file, here's another logistical challenge that this model brings up. A common
    practice for application developers to distribute their application is to bundle
    their app installers with the Java Runtime Environment. Any Java app requires
    the runtime anyway, but there's no knowing if the users of the Java application
    have the runtime installed on their machines beforehand. So, bundling the app
    with the runtime is a great way to make sure anyone who installs the app has the
    necessary runtime and can execute the app successfully. This is true not just
    for classic desktop application installers, but also for the newer practice of
    creating self-contained micro-services. Developers building micro-services create
    distributables that contain both the compiled micro-services as well as the Java
    runtime so that a micro-service instance can be kicked off on any virtual machine
    on the cloud by a single command.
  prefs: []
  type: TYPE_NORMAL
- en: The size of the runtime is clearly a problem here. No matter the complexity
    of your micro-service or application, irrespective of how many classes in the
    platform you use, you have to bundle in the complete Java runtime with the `rt.jar`
    that contains every Java platform class that's known to exist. So, no matter how
    small your actual application is, bundled with it is at least 60 MB of `rt.jar`
    goodness! Also affected are Java applications that run on smaller devices with
    resource constraints such as IOT and mobile devices. We briefly discussed in [Chapter
    1](part0021.html#K0RQ0-ed2405f4162b4f86b565edd6b6d679fb), *Introducing Java 9
    Modularity*, the CORBA classes in the Java platform and how it exists in all Java
    runtimes since a very long time, although hardly anyone seems to use it anymore.
    As someone creating a self-contained Java executable, it's very fair to ask the
    question--why do I need to include all these classes in the runtime when I don't
    need them?
  prefs: []
  type: TYPE_NORMAL
- en: The attempted solution - Compact profiles
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'With Java 8, there was an introduction of a new concept called **compact profiles**
    to attempt to solve this very problem. Compact profiles are essentially smaller
    versions of the Java runtime that does not have to include the entirety of the
    contents of `rt.jar`. The runtime was broken down at package level to identify
    a closed set of core packages and classes that only depend on themselves so that
    the rest can be broken off and removed. There were three different profiles introduced,
    varying on how much was stripped off. The smallest and the most minimum profile
    is called `compact1`. This version of the runtime contains the very basic language
    features such as IO, collections, util, security, and concurrency. If your needs
    aren''t met with `compact1`, you could also choose between `compact2` and `compact3`,
    and if none of the three work for you, you would go with the full runtime:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00043.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The smallest profile, `compact1`, measures just about 11 MB in size, and is
    a significant improvement from the 60 MB of the full `rt.jar`. But it's obvious
    that we still haven't eliminated the problem of bundling in runtime classes that
    aren't needed. We've just minimized them, and there are still going to be classes
    in whatever profile you choose that your application never uses, but you have
    to include anyway. Additionally, if you have an application that mostly uses classes
    from the `compact1` profile, but needs just a couple of classes from `compact2`,
    well, you have no choice but to bundle the bigger `compact2` profile instead.
  prefs: []
  type: TYPE_NORMAL
- en: I would, however, hesitate to call this a failed attempt at solving this problem.
    In fact, runtime profiles are actually the first steps in the Java platform's
    journey to modularizing of the runtime. However, it is important to note that
    this is the best we could do pre-Java 9 to address the issue of a bulky monolithic
    runtime.
  prefs: []
  type: TYPE_NORMAL
- en: The state of API encapsulation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To best explain the situation (and associated problems) with API encapsulation,
    all we need to do is recall from [Chapter 1](part0021.html#K0RQ0-ed2405f4162b4f86b565edd6b6d679fb),
    *Introducing Java 9 Modularity,* Jack's trouble with his sorting library. He had
    an internal `public` class in his library that wasn't meant for external use,
    but it did end up getting used. If such a small library with the meagerly count
    of two classes could run into this problem, imagine the situation with the Java
    runtime with thousands of classes! The Java language provides documented APIs
    for developers to use. But it also has many supporting classes to facilitate the
    inner workings of those APIs that shouldn't be used by developers. However, surely
    enough, they are all a part of the sole `rt.jar`, so there's nothing stopping
    developers from using those classes either.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding internal APIs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are several internal classes in the Java runtime that developers aren't
    supposed to use. They aren't documented as part of the language specification,
    but are necessary for the internal functioning of the runtime, perhaps for other
    classes that *are* documented. A great example that's much discussed among Java
    developers in online communities is a class called `sun.misc.Unsafe`, which we
    briefly mentioned in [Chapter 1](part0021.html#K0RQ0-ed2405f4162b4f86b565edd6b6d679fb),
    *Introducing Java 9 Modularity*.
  prefs: []
  type: TYPE_NORMAL
- en: The class `sun.misc.Unsafe` was never meant for public consumption. It was always
    supposed to be an internal class meant for use by the Java runtime only. It is
    not documented. It has no public constructors. The source code of the class is
    filled with warnings about the dangers of using the class. It's funny that even
    the fact that the class having the ominous sounding name `Unsafe` hasn't deterred
    some developers from using it. Of course, `sun.misc.Unsafe` is one of a handful
    of internal classes that have been misused by Java developers. But if it's just
    a handful of classes, you might ask, what's the big deal?
  prefs: []
  type: TYPE_NORMAL
- en: The problem with this model
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Java is commonly known to be a very **backwards compatible** language. While
    the language itself has seen major changes over the years, almost all the changes
    have been additions to the language, while still retaining the functionality of
    the older versions. Let's say you picked up a Java codebase written with Java
    1.3 and you compiled and ran it with Java 8\. Would you be surprised if it ran
    without issues? Probably not! That's precisely because of the reputation Java
    has of being backward compatible. And it's a great thing in my opinion, because
    it gives adopters the confidence that there's not a lot of effort and rewrites
    required for every major upgrade. This is an aspect where Java has an edge over
    a few other development platforms.
  prefs: []
  type: TYPE_NORMAL
- en: This backward compatibility comes with a cost, especially when you consider
    the lack of encapsulation of internal APIs. What if there is an internal API that
    developers have inadvertently used because of the lack of encapsulation? To maintain
    backward compatibility, the language team is compelled to not make breaking changes
    to those internal APIs even though they are, by definition, internal. So, the
    burden of backward compatibility gets worse for the language--not only do public
    APIs have to be backward compatible, even the internal runtime classes need to
    be as well!
  prefs: []
  type: TYPE_NORMAL
- en: The attempted solution - Deprecation, warnings, and documentation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We routinely import classes from packages such as `java.*` and `javax.*` in
    our code because the classes in those packages house most of the public APIs in
    the Java language that are meant for public consumption. There are, however, classes
    in other packages such as `sun.*` that are JDK-internal and you wouldn't find
    in any API documentation. Many of these classes have been a part of Java since
    1.0.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since the language had no facility to prevent usage of these internal APIs,
    several other attempts have been made to discourage usage. There was an article
    on the Sun website titled *Why developers should not write programs that call
    ''sun'' packages*. The Sun website isn''t up anymore, but the article''s original
    webpage is still preserved for posterity, thanks to WayBack Machine, and is available
    here: [http://web.archive.org/web/19980215011039/http://java.sun.com/products/jdk/faq/faq-sun-packages.html](http://web.archive.org/web/19980215011039/http://java.sun.com/products/jdk/faq/faq-sun-packages.html):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00044.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Notice the year mentioned on the article! Yes, it's been around as a part of
    the official documentation since back in 1996 (then on java.sun.com)! The warning
    is still around on the Oracle documentation website, by the way. Clearly, 20 years
    of asking developers not to use certain classes hasn't solved the problem! You
    might very well ask, what good is such a warning in documentation if nobody pays
    attention to it? Well, in addition to warnings in documentation, since JDK 6,
    the compiler has been throwing out warnings if your application uses any APIs
    from the `sun.*` packages. However, this is also something that developers could
    easily ignore.
  prefs: []
  type: TYPE_NORMAL
- en: These approaches are clearly not good enough. We need to be able to enforce
    these rules and provide guardrails to *prevent* developers from using internal
    APIs. There was no such feature available in the language so far. The language
    just had to evolve.
  prefs: []
  type: TYPE_NORMAL
- en: Enter Project Jigsaw
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*Project Jigsaw* was the effort to apply the concepts and features of modularity
    to the Java platform itself. The modularization of the platform essentially solves
    both the problems described previously. We''ll look at how later in this chapter,
    but let''s begin looking at the work that was done for *Project Jigsaw* and how
    it affects developers interacting with the Java platform.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The project itself was a huge effort that involved the following high-level
    steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Re-organizing the platform source code to make it more conducive for modularization.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Defining and building modules with predefined input and output interfaces and
    with a clear dependency map.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Encapsulating *internal* classes and allowing usage for only *public* APIs.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Providing tools for generating smaller and modular runtime images as an alternative
    to the monolithic `rt.jar`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Let's deep-dive into the changes now and see how it affects us.
  prefs: []
  type: TYPE_NORMAL
- en: Platform modularity
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With Java 9, the entire Java platform, with every class in it, has been segregated
    and grouped into modules. Yes, all of the platform Java classes from `Collections`
    and `Thread` to `Connection` and `Logger`! It doesn't really matter which one;
    every platform class is now housed in newly created Java modules that come out-of-the-box
    with the runtime and the JDK. The platform team achieved this by going through
    both the public APIs and internal classes, grouping them based on the types that
    usually go well together and are self-contained, and bundling such related classes
    into modules.
  prefs: []
  type: TYPE_NORMAL
- en: 'Take Java logging for example. The native logging functionality in Java comprised
    of a group of classes in the package `java.util.logging`. These classes have now
    been grouped into a newly created module called `java.logging`. The JDBC and SQL
    related classes have all gone into a new module called `java.sql`. XML related
    classes have gone into the module `java.xml`. Here are a few more examples of
    modules that come out-of-the-box with Java 9:'
  prefs: []
  type: TYPE_NORMAL
- en: '`java.scripting`: Provides the scripting APIs for the Java scripting engine'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`java.desktop`: Provides the Java desktop APIs, `awt`, and `swing` packages'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`java.transaction`: Provides transaction related APIs in package `javax.transaction`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There is also a special module named `java.base`. The module `java.base` contains
    APIs and classes that are fundamental to the Java platform and without which one
    could not possibly write any Java code. The `java.base` module contains APIs from
    packages such as `java.lang`, `java.io`, `java.util` and so on. As you can see,
    it covers a lot of basic Java APIs that most of our Java applications use. Now,
    why do I call this module special? Hold that thought! We'll get back to it in
    a bit.
  prefs: []
  type: TYPE_NORMAL
- en: The impact of platform modularity
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: "As you can imagine, the impact of this change is indeed significant, and it\
    \ pretty much affects the way we write all Java code from now on. In Java 8 and\
    \ earlier, you didn't have to think twice about using any Java API. All you had\
    \ to do is import the types you need into your code. Since the JVM knew where\
    \ to find `rt.jar`, the necessary classes were always found by the runtime. That's\
    \ no longer the case with Java 9\\. Remember in [Chapter 3](part0048.html#1DOR00-ed2405f4162b4f86b565edd6b6d679fb),\
    \ *Handling Inter-Module Dependencies* \uFEFF, when you needed a class in the\
    \ `packt.addressbook` module from the `packt.sortutil` module? You couldn't just\
    \ import the class in your code and use it. You had to go to the module definition\
    \ of `packt.addressbook` and specify the dependency on the module using the `requires`\
    \ clause. That's exactly what you'll need to do for native Java platform types\
    \ too!"
  prefs: []
  type: TYPE_NORMAL
- en: 'Need to use Java SQL APIs? They are in the module `java.sql`, so in the module
    where you need them, you need to specify this in the module descriptor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Once you have required the necessary platform module, its APIs are then ready
    for use in your module. Since the `java.sql` module is built on the same Java
    module system that you use to write your code, you can bet that there's code in
    the `module-info` file of the `java.sql` module that exports the `java.sql` and
    `javax.sql` packages that contain the Java SQL API.
  prefs: []
  type: TYPE_NORMAL
- en: This necessity to *require* modules before using them applies not just to our
    own modules; it applies to the Java modules too. For example, the `java.sql` module
    requires logging functionality (for obvious reasons). And the logging APIs are
    in the `java.logging` module. So, there's a `requires` declaration in `java.sql`
    module's `module-info.java` file specifying this requirement. That's the only
    way code in the `java.sql` module can import and use the logging APIs.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is how the `module-info.java` of `java.sql` module should look to enable
    the configuration we''ve discussed so far:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Module graph
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The result of these individual Java modules depending on one another is that
    we can now draw a complete graph of dependencies with the modules as nodes and
    the relationships between nodes as module dependencies. This kind of picture is
    called a **module graph** and is your new best friend to help you track and manage
    module dependencies in your Java 9 modular applications. We looked at a simple
    module graph of the address book application in the previous chapter. Here''s
    a simple module graph that specifies the dependencies between a handful of Java
    platform modules:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00045.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: A line drawn from module *A* to module *B* indicates that module *A* `requires`
    module *B*. So, as this diagram indicates, module `java.transaction` requires
    `java.rmi`, which in turn requires `java.base`. As mentioned before, since `java.base`
    contains APIs that are fundamental to the language, it is one module that every
    other module is sure to need. Which is why, this one module is treated a bit differently.
  prefs: []
  type: TYPE_NORMAL
- en: The java.base module
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [Chapter 2](part0033.html#VF2I0-ed2405f4162b4f86b565edd6b6d679fb), *Creating
    Your First Java Module*, and [Chapter 3](part0048.html#1DOR00-ed2405f4162b4f86b565edd6b6d679fb),
    *Handling Inter-Module Dependencies*, you wrote a few Java 9 modules that used
    some Java APIs such as `Collection` and `System.out`. These APIs happen to come
    from the `java.base` module. You might have noticed something wrong with the picture
    here. Since these core Java APIs are in its own module, shouldn't we have had
    to add the `requires java.base;` line in all our module descriptors before we
    used them? How did the compilation succeed without it? Well, let me assure you
    that there's no trickery involved here. The reason it worked is due to the special
    nature of the `java.base` module.
  prefs: []
  type: TYPE_NORMAL
- en: When was the last time you had to write the line `import java.lang.*` in your
    Java class? Never, I hope! You don't need to import classes from the package `java.lang`
    because it is imported and available to your Java code by default. That's because
    the classes in that package are so commonly used that it's a sensible default
    to always have the types in the package imported.
  prefs: []
  type: TYPE_NORMAL
- en: Java 9 has a similar shortcut for requiring the `java.base` module. This module
    contains the `java.lang` package among other fundamental Java APIs that almost
    no Java module can be written without. So, rather than every Java module in existence
    having to *require* the `java.base` module, it is just required by default, so
    you don't have to explicitly specify it. Now, since the `java.lang` packages are
    in the `java.base` module, the default behavior is seamless in both cases! See
    how that works?
  prefs: []
  type: TYPE_NORMAL
- en: Remember, though, that this is the only module that has this behavior. Every
    other Java module in existence, platform or otherwise, will have to be explicitly
    *required*, if the module is needed as a dependency.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since there is always an implicit dependency on `java.base`, a common practice
    when writing module graphs is to skip the dependency on this base module in order
    to make things more legible. The idea is to show a module depending on `java.base`
    only if the given module''s *only* dependency is `java.base`. If a module depends
    on other modules, we show only that and skip the `java.base` dependency. Here''s
    how the module graph from earlier looks with this approach:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00046.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: I hope you'll agree this graph looks a bit cleaner. This is a practice that
    people seem to be increasingly following, so when you come across such module
    graphs, don't forget the implicit `java.base` dependency. It's always there!
  prefs: []
  type: TYPE_NORMAL
- en: Browsing modules
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that you've looked at some of the modules that come with Java, you might
    be wondering how you can get more information about them. How can you find out
    what the list of modules are that come with the platform? Given an API, how can
    you know which platform module contains it? And given a module, how can you know
    what are the packages it exports?
  prefs: []
  type: TYPE_NORMAL
- en: The answer is a couple of new arguments to the `java` command. First is an option
    called `--list-modules`. This command lets you examine the modules that are available
    for you from the platform.
  prefs: []
  type: TYPE_NORMAL
- en: 'When you run the following command from the Command Prompt, this is what you''ll
    see:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The list you see there is the list of all the Java platform modules! As you
    scroll the list, notice that the modules we discussed previously are all there!
    This is a great way to browse through and get a good idea of what's available.
  prefs: []
  type: TYPE_NORMAL
- en: 'There''s another new option `-d`, which helps in examining the details of a
    single module. The syntax is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also use the longer form  `--describe-module` to do the same:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'For example, if you want to look at more details about the `java.base` module,
    run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The output has been truncated for brevity, but as you scroll down the result
    of the command, you'll notice various details about the module listed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s the output of the command run on the module `java.sql`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'In these module-level outputs, you''ll notice the following categories of information
    displayed:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Exports**: This is the list of all the packages exported by the module. In
    the `java.base` module, you''ll see familiar packages such as `java.io` and `java.lang`
    here. The `java.sql` module exports packages `java.sql` and `javax.sql`. These
    packages marked with `exports` are all the packages that the module exports. Thereby,
    when you `require` the module, (which you do by default with `java.base`), your
    module gets access to the types in the *required* module that also belong to those
    *exported* packages. In the output, you''ll notice some statements in the form 
    `exports <package-name> to <module-name>` . These are called qualified exports.
    We''ll be covering qualified exports in [Chapter 6](part0095.html#2QJ5E0-ed2405f4162b4f86b565edd6b6d679fb),
    *Module Resolution, Readability, and Accessibility*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Contains**: This is the list of internal packages that the module *contains*
    but does not export. These packages are, by definition, not visible outside the
    module. It is still handy for us developers to know what the packages are that
    belong to the *internal* module API because a lot of these had been APIs that
    existed in Java 8 and thus, used to be available publicly earlier. For example,
    look at the packages `jdk.internal.*` and `sun.util.*` in the `java.base` module.
    They are not in the `exports` list so they are now effectively encapsulated in
    the module.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Requires**: This is the list of modules that a given module requires. The
    `java.sql` module requires three other modules--`java.base`, `java.logging`, and
    `java.xml`. The requirement of `java.base` is by default, and so it is qualified
    with a `requires mandated` clause. Note that you *do not* have to do this in your
    own modules, since that''s default behavior. Ignore the `requires transitive`
    clause for now. That''s related to making modules available to dependent modules,
    a concept we''ll explore in detail in [Chapter 6](part0095.html#2QJ5E0-ed2405f4162b4f86b565edd6b6d679fb),
    *Module Resolution, Accessibility, and Readability*. Also, as is obvious, `java.base`
    does not `require` any other module.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Uses and** **provides**: These are related to the concept of Services, which
    we''ll be exploring in [Chapter 7](part0110.html#38STS0-ed2405f4162b4f86b565edd6b6d679fb),
    *Introducing Services*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: I recommend using the `java --list-modules` and `java -d <module-name>` commands
    to explore other modules in the platform. As you start writing modular code in
    Java 9, you'll often need to import platform classes, and that requires the identification
    of modules that export them. Initially, you'll need to use these commands to get
    to the right module, but when you do this a few times, you'll be committing to
    your memory the common packages and the modules that have them available, and
    so you don't need to do this anymore. What also helps is the intuitive names for
    the modules. Need to use SQL classes? You just *know* they are in `java.sql`!
    Granted, some packages may not be all that intuitive, but still, the naming convention
    followed goes a long way in helping developers get to the right modules quickly.
  prefs: []
  type: TYPE_NORMAL
- en: Module types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Speaking of naming conventions, you might have noticed the different prefixes
    to the module names when you ran the `java --list-modules` command. The three
    prefixes to the platform modules are--`java.`, `javafx.`, and `jdk.`. The prefix
    indicates the nature of the module:'
  prefs: []
  type: TYPE_NORMAL
- en: '`java`: Indicates the core Java platform module. These are what''s referred
    to in the official documentation as *standard modules*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`javafx`: Indicates modules of Java FX, the platform for building desktop applications
    in Java.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`jdk`: Indicates core JDK modules. These are not part of the language specification,
    but contain valuable APIs and tools for the Java developer, including the `jdk.compiler`
    and `jdk.javadoc`, as well as debugging and serviceability tools and APIs such
    as `jdk.jdi` and `jdk.jconsole`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`oracle`: If you''ve downloaded the Oracle Open JDK, you might see a couple
    of modules beginning with this prefix. Remember that these are non-standard modules
    that are specific to this flavor of the JDK implementation and they will not be
    available in other implementations. For this reason, it''s a good idea to completely
    ignore these modules.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `java.` prefixed modules themselves can be classified into three categories:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Core Java modules**: These are necessary for the Core Java functionality.
    Modules such as `java.base`, `java.xml`, and so on, which are APIs usually referred
    to as Core Java SE APIs. This is in contrast to Enterprise APIs, the next category.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Enterprise modules**: This category contains modules such as `java.corba`
    that contains APIs leveraging CORBA technology and `java.transaction`, which provide
    database transaction APIs usually required in an Enterprise application context.
    Note that this is different from Java EE, which is the completely different spec.
    However, there has always been a small overlap between what got bundled with the
    Java SE and Java EE SDKs. To avoid this overlap, as of Java 9, these Enterprise
    modules have been marked as deprecated and might be removed in a future Java version.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Aggregator modules**: These are modules that do not contain any APIs by themselves,
    but instead act as a convenient way to bundle multiple modules together. Specifying
    a `requires` dependency on the aggregator module is equivalent to individually
    specifying the `requires` dependency on all the individual modules that the aggregator
    module aggregates. You''ll learn how to build your own custom aggregator modules
    in [Chapter 6](part0095.html#2QJ5E0-ed2405f4162b4f86b565edd6b6d679fb), *Module
    Resolution, Accessibility, and Readability*. For now, note that there are a couple
    of aggregator modules that come bundled with the platform. They are:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`java.se`: This is a convenient aggregator module that gathers all the *standard*
    Java SE modules together.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`java.se.ee`: This aggregator module gathers all the `java.se` modules and
    adds in the APIs that overlap with the Java EE specification.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: While aggregator modules provide a level of convenience, I'd recommend using
    them with care. When writing a Java application, it can be tempting to just `require`
    the `java.se` module, for instance, to pull down the entire Java SE platform.
    That way, you don't have to bother with identifying which platform modules contain
    the APIs you want and thus need to import. With just one line--`requires java.se`,
    you have the whole platform at your disposal. But then, you are losing several
    advantages of the modularization of the platform. You then end up with a bulky
    Java platform with unnecessary classes, no different from Java 8 and earlier.
    The aggregator modules are provided for convenience to be used only when necessary.
    So, make sure you use them right.
  prefs: []
  type: TYPE_NORMAL
- en: Examining platform file structure
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s now examine how these changes to the platform manifest in the file structure
    of the installation. Historically, the Java platform has come in two flavors--The
    **Java Runtime environment** (**JRE**) and the **Java Development Kit** (**JDK**).
    The JDK is the superset, in that it contains the JRE. Here''s a high-level structure
    of the classic JDK with only a few important files shown for the sake of simplicity:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00047.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'The Java 9 JDK looks very different. You can navigate to the directory using
    the `cd $JAVA_HOME` command. Here''s what the new JDK looks like, again with only
    a few important files displayed:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00048.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'There are a couple of important differences that should be noted:'
  prefs: []
  type: TYPE_NORMAL
- en: There is no JRE folder within the main folder anymore. The structure is now
    collapsed into one common folder. JDK 9 moves away from the distinction between
    JRE and JDK to create a common runtime binary file structure. This structure contains
    the `bin`, `lib`, and `conf` folders at the top level, with no nested folders
    for the runtime. This change was implemented to provide the ability to create
    custom runtime images that are now supported in Java 9\. You'll learn more about
    generating such images in [Chapter 8](part0124.html#3M85O0-ed2405f4162b4f86b565edd6b6d679fb),
    *Understanding Linking and Using jlink*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There's a new folder called `jmods` that contains all the packaged platform
    modules that we've learnt about so far. With Java 9, it's time to say goodbye
    to `rt.jar`. There is no single monolithic jar file that houses the entire platform.
    Each platform module has a corresponding file in the `jmods` folder. So, what
    would have formerly been a single `rt.jar` file is now split into separate module
    files, one for each platform module.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Notice the `.jmod` file extension of the module files. Shouldn't those be `.jar`
    files? With Java 9, a new format called JMOD has been introduced as a new way
    of bundling libraries specifically for development time, and not for runtime.
    The traditional jar format is great for bundling classes for runtime use, but
    since they are just a ZIP file of compiled classes, they aren't very useful when
    using them during development time. The new JMOD format goes beyond the JAR format
    by including the ability to bundle in things such as native code and configuration
    files, which makes it useful for distributing libraries for development use. This
    is the format used by the JDK to bundle all built-in platform modules. The details
    of the format are beyond the scope of what we are covering here. Just think of
    it as the new dev-time-only alternative to the JAR format.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Observable modules
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are two module path values we pass to the `javac` and `java` commands--the
    module source path (passed to `javac`) containing the uncompiled Java source modules
    and the module path (passed to `javac` and  `java`) containing the compiled Java
    modules. These options point to the locations of all the modules that are available
    for the compiler and the runtime to look up and use when necessary. Notice that
    we didn't have to add the path to the Java platform modules. That's because the
    Java runtime modules are included by default in the module path for compiling
    with `javac` and executing with `java`. You have to add the path only to the modules
    that are not a part of the platform, but you intend to include for compilation
    or execution.
  prefs: []
  type: TYPE_NORMAL
- en: This complete set of modules including modules in the module path that you supply
    to the platform *and* the out-of-the-box platform modules that are automatically
    available are together referred to as *observable modules*. As the name indicates,
    these are the modules that the platform *observes* in order to satisfy module
    dependencies. If a required module is not among the set of observable modules,
    the platform complains that the module is missing.
  prefs: []
  type: TYPE_NORMAL
- en: How do you know what the observable modules are? When we've used the `java --list-modules`
    command to list the platform modules, what we are actually doing is listing all
    observable modules. And, by default, only the platform modules are observable.
    You can also find out what are the observable modules for a given module path.
    You do that by specifying the `--module-path` option to the same command. You
    can specify as value a set of directory locations that form the module path. In
    that case, the command would display the list of observable modules *for that
    module path*, which would include all the platform modules along with any compiled
    modules in that module path.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, if you were to run the command with the module path being the
    compiled modules in the `out` folder from the previous chapter (`03-two-modules`),
    here''s what you''ll see:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Notice that in addition to the platform modules, there are two of our own modules
    showing up in the list. This is because they are in the module path we've passed
    as a parameter to the command, thus adding them to the list of observable modules
    for that module path. For non-platform modules, the output also includes the path
    of the module. This makes it handy to locate modules when there are multiple directories
    passed to the  `--module-path` option.
  prefs: []
  type: TYPE_NORMAL
- en: Revisiting the two problems
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We started this chapter looking at two issues with the Java platform:'
  prefs: []
  type: TYPE_NORMAL
- en: The monolithic runtime
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The lack of API encapsulation features
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Interestingly, the modularization of the Java platform provides solutions to
    both these problems.
  prefs: []
  type: TYPE_NORMAL
- en: Solving the monolithic runtime
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There is a distinct advantage of knowing which platform modules your application
    belongs to. It is a clear indication of which platform modules it doesn't need--which
    is anything the modules in the application doesn't use! So, for example, if your
    application contains modules that only `require` the platform modules `java.base`
    and `java.logging`, you can essentially create a small subset of the Java platform
    consisting of just those two modules. That slice of the platform is all that your
    application needs to function. If you are bundling the runtime with your application,
    you now know the exact portion of the runtime you need to bundle, no more no less!
  prefs: []
  type: TYPE_NORMAL
- en: Java 9 comes with a brand-new *static linking* step that lets you create custom
    runtime images with only the modules that your applications need. This results
    in smaller and leaner application distributable, micro-service executables, and
    so on. You'll learn more about the linking phase and how to create your own runtimes
    in [Chapter 8](part0124.html#3M85O0-ed2405f4162b4f86b565edd6b6d679fb), *Understanding
    Linking and Using jlink*.
  prefs: []
  type: TYPE_NORMAL
- en: Solving the API encapsulation problem
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Thanks to Java platform modules leveraging the encapsulation concepts of modularity,
    the platform now has the means to effectively protect internal classes from external
    usage. The platform can evolve to modify or even completely remove and replace
    the internal APIs, and still ensure backward compatibility as long as the *public*
    exported APIs remain the same. I believe this enables better and faster evolution
    of the Java platform, and we all get to benefit from it.
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, remember that there are some classes that were publicly accessible
    in earlier Java versions that are now encapsulated in Java platform modules. This
    implies that there are possibly some backward incompatibilities with applications
    that were formerly depending on those internal APIs (even though they really shouldn't)!
    This is a problem many of us will have to tackle when we migrate code written
    in Java 8 or earlier into Java 9\. We'll learn more about that, as well as strategies
    to handle such situations in [Chapter 10](part0161.html#4PHAI0-ed2405f4162b4f86b565edd6b6d679fb),
    *Preparing Your Code for Java 9*.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We've covered a lot of ground in this chapter. We started looking at a couple
    of problems with the earlier versions of the Java platform and how the language
    didn't really provide sufficient features to solve them. We then learned how the
    Java platform has been modularized, what the modules are, and how to browse and
    get information about them. We then wrapped up with how the new modular Java platform
    has effectively solved the two major problems we began the chapter with.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, you'll put these concepts into practice by wiring in the
    Java platform modules into the address book application and getting familiar with
    the process of using platform modules and APIs in your custom Java code.
  prefs: []
  type: TYPE_NORMAL
