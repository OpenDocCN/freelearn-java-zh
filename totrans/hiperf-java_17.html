<html><head></head><body>
		<div id="_idContainer049">
			<h1 class="chapter-number" id="_idParaDest-332"><a id="_idTextAnchor331"/>17</h1>
			<h1 id="_idParaDest-333"><a id="_idTextAnchor332"/>Unit and Performance Testing</h1>
			<p>The importance of thoroughly testing our code cannot be overstated; moreover, this testing should be efficient. As our systems grow in complexity and scale, it becomes increasingly critical for us to ensure that every component of our software functions accurately and efficiently. This is where unit and performance testing comes into play. This is the focus of <span class="No-Break">this chapter.</span></p>
			<p>The chapter starts <a id="_idIndexMarker939"/>by covering <strong class="bold">unit testing</strong>, which we use to verify individual units of code. The goal is to ensure that the units perform efficiently and as expected. Through unit testing, we can catch anomalies (bugs) early, before the code is deployed into a production environment. Performance testing is introduced as a complementary process, whereby we test our software under various conditions to assess behaviors such as responsiveness, availability, scalability, reliability, and scalability. As the chapter demonstrates, performance testing can help us identify potential bottlenecks and ensure our systems can handle anticipated use cases <span class="No-Break">and loads.</span></p>
			<p>Both theoretical and hands-on approaches are taken in this chapter, giving you the opportunity to gain knowledge and experience with unit and performance testing. We will cover overarching strategies to include integrating both types of testing, automation, test environments, continuous testing, and <span class="No-Break">feedback loops.</span></p>
			<p>By the end of this chapter, you will have a thorough understanding of unit and performance testing and be able to leverage them to enhance the reliability and efficiency of your <span class="No-Break">Java applications.</span></p>
			<p>This chapter covers the following <span class="No-Break">main topics:</span></p>
			<ul>
				<li><span class="No-Break">Unit testing</span></li>
				<li><span class="No-Break">Performance testing</span></li>
				<li><span class="No-Break">Overarching strategies</span></li>
			</ul>
			<h1 id="_idParaDest-334"><a id="_idTextAnchor333"/>Technical requirements</h1>
			<p>To follow the examples and instructions in this chapter, you will need the ability to load, edit, and run Java code. If you have not set up your development environment, refer to <a href="B21942_01.xhtml#_idTextAnchor014"><span class="No-Break"><em class="italic">Chapter 1</em></span></a>, <em class="italic">Peeking Inside the Java Virtual </em><span class="No-Break"><em class="italic">Machine (JVM)</em></span><span class="No-Break">.</span></p>
			<p>The finished code for this chapter can be <span class="No-Break">found here:</span></p>
			<p><a href="https://github.com/PacktPublishing/High-Performance-with-Java/tree/main/Chapter17"><span class="No-Break">https://github.com/PacktPublishing/High-Performance-with-Java/</span><span class="No-Break">tree/main/Chapter17</span></a></p>
			<h1 id="_idParaDest-335"><a id="_idTextAnchor334"/>Unit testing</h1>
			<p>The software developer’s adage of “test, test, and test again” still applies to modern systems but in <a id="_idIndexMarker940"/>a more refined way. Instead of testing our systems as a whole, we focus on small components of our code to ensure that they perform efficiently and as expected. These components are referred to as <strong class="bold">units</strong>. When we isolate units of code, we can more easily detect bugs and improve the overall quality of our code. This approach is referred to as unit testing and is the focus of <span class="No-Break">this section.</span></p>
			<p class="callout-heading">Unit testing</p>
			<p class="callout">Unit testing is an approach to software testing that involves testing the smallest sections of a system’s code to ensure that it performs correctly and efficiently <span class="No-Break">in isolation.</span></p>
			<p>The primary <a id="_idIndexMarker941"/>benefits of unit testing include <span class="No-Break">the following:</span></p>
			<ul>
				<li><strong class="bold">Bug detection</strong>: Unit testing enables us to detect bugs early, before the code is published as part of the <span class="No-Break">larger system.</span></li>
				<li><strong class="bold">Code quality</strong>: This testing approach, with its finite focus, results in higher <span class="No-Break">code quality.</span></li>
				<li><strong class="bold">Documentation</strong>: The process of unit testing includes documentation of each unit’s functionality, purpose, connectivity, <span class="No-Break">and dependencies.</span></li>
			</ul>
			<p>Now that we understand what unit testing is and why it is important, let’s look at two popular unit <span class="No-Break">testing frameworks.</span></p>
			<h2 id="_idParaDest-336"><a id="_idTextAnchor335"/>Frameworks</h2>
			<p>One of the <a id="_idIndexMarker942"/>most common unit testing frameworks is <strong class="bold">JUnit</strong>, perhaps <a id="_idIndexMarker943"/>because of its simplicity and ease of integration with <strong class="bold">Integrated Development Environments</strong> (<strong class="bold">IDEs</strong>). Another popular framework is <strong class="bold">TestNG</strong>, which <a id="_idIndexMarker944"/>is comparatively more flexible and has functionality in addition <span class="No-Break">to JUnit.</span></p>
			<p>We will focus on JUnit and demonstrate how to write a unit test in the <span class="No-Break">next section.</span></p>
			<h2 id="_idParaDest-337"><a id="_idTextAnchor336"/>Writing unit tests</h2>
			<p>There <a id="_idIndexMarker945"/>are several ways you can write and implement unit testing. Here is a <span class="No-Break">straightforward approach:</span></p>
			<ol>
				<li>Ensure that <a id="_idIndexMarker946"/>you have a recent version of the <strong class="bold">Java Development Kit</strong> (<span class="No-Break"><strong class="bold">JDK</strong></span><span class="No-Break">) installed.</span></li>
				<li>Download <a id="_idIndexMarker947"/>and install the <strong class="bold">JUnit Jupiter API and Engine JARs</strong>. The process for accomplishing this will depend on <span class="No-Break">your IDE.</span></li>
				<li>Assuming <a id="_idIndexMarker948"/>that you are using Visual Studio Code, install the <strong class="bold">Test Runner for </strong><span class="No-Break"><strong class="bold">Java</strong></span><span class="No-Break"> extension.</span></li>
			</ol>
			<p>To demonstrate unit testing, we will write a simple calculator program, as <span class="No-Break">shown here:</span></p>
			<pre class="source-code">
public class CH17Calculator {
  public int add(int a, int b) {
    return a + b;
  }
  public int subtract(int a, int b) {
    return a - b;
  }
  public int multiply(int a, int b) {
    return a * b;
  }
  public int divide(int a, int b) {
    if (b == 0) {
      throw new IllegalArgumentException("Division by zero");
    }
    return a / b;
  }
}</pre>			<p>As you can see, our application contains methods for adding, subtracting, multiplying, and dividing <a id="_idIndexMarker949"/>two numbers based on passed parameters. Next, let’s create a <span class="No-Break"><strong class="source-inline">testing</strong></span><span class="No-Break"> class:</span></p>
			<pre class="source-code">
import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
public class CH17CalculatorTest {
  private CH17Calculator calculator;
  @BeforeEach
  public void setUp() {
    calculator = new CH17Calculator();
  }
  @Test
  public void testAdd() {
    int result = calculator.add(3, 4);
    Assertions.assertEquals(7, result);
  }
  @Test
  public void testSubtract() {
    int result = calculator.subtract(10, 5);
    Assertions.assertEquals(5, result);
  }
  @Test
  public void testMultiply() {
    int result = calculator.multiply(2, 3);
    Assertions.assertEquals(6, result);
  }
  @Test
  public void testDivide() {
    int result = calculator.divide(8, 2);
    Assertions.assertEquals(4, result);
  }
  @Test
  public void testDivideByZero() {
    Assertions.assertThrows(IllegalArgumentException.class, () -&gt; {
      calculator.divide(1, 0);
    });
  }
}</pre>			<p>As you can see in the preceding code, we have created individual methods to test the methods in the primary class file. The next step is to run the test. Using Visual Studio Code, you can <a id="_idIndexMarker950"/>select the testing icon (the beaker in the leftmost panel). Now you can run individual tests, or all of the tests, by selecting the <strong class="bold">Run Test</strong> button to the right of each <span class="No-Break">test name.</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer047">
					<img alt="Figure 17.1 – The Visual Studio Code navigation panel" src="image/B21942_17_1.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 17.1 – The Visual Studio Code navigation panel</p>
			<p>The test results will be available in the bottom section of your <strong class="bold">Test Results</strong> IDE interface. Here are the test results for the <span class="No-Break"><strong class="source-inline">testMultiple()</strong></span><span class="No-Break"> method:</span></p>
			<pre class="console">
%TESTC  1 v2
%TSTTREE2,CH17CalculatorTest,true,1,false,1,CH17CalculatorTest,,[engine:junit-jupiter]/[class:CH17CalculatorTest]
%TSTTREE3,testMultiply(CH17CalculatorTest),false,1,false,2,testMultiply(),,[engine:junit-jupiter]/[class:CH17CalculatorTest]/[method:testMultiply()]
%TESTS  3,testMultiply(CH17CalculatorTest)
%TESTE  3,testMultiply(CH17CalculatorTest)
%RUNTIME84</pre>			<p>This demonstrates <a id="_idIndexMarker951"/>a simple unit test. Next, let’s review some best practices to help us get the most out of <span class="No-Break">unit testing.</span></p>
			<h2 id="_idParaDest-338"><a id="_idTextAnchor337"/>Best practices</h2>
			<p>A key best <a id="_idIndexMarker952"/>practice for unit testing is to keep the tests as small as possible. This will give us a tighter focus and allow us to more rapidly troubleshoot and resolve issues through <span class="No-Break">code edits.</span></p>
			<p>Another best practice <a id="_idIndexMarker953"/>is to ensure that our tests are <strong class="bold">isolated tests</strong>, which are tests that are independent of any external factors. This helps ensure that any errors or issues we detect are caused by our code and not an external environment. If we do not take this approach, we might struggle to efficiently determine the source of <span class="No-Break">any errors.</span></p>
			<p>A third practice is to ensure that our tests cover a myriad of scenarios, including error conditions and even edge cases. This is a thorough approach that strives to test for any possible situation. The extended time that this approach takes is worth it, as our approach can help ensure that our systems can perform under both routine and <span class="No-Break">irregular conditions.</span></p>
			<p>A fourth <a id="_idIndexMarker954"/>best practice, <strong class="bold">assertions</strong>, will be <span class="No-Break">covered next.</span></p>
			<h3>Assertions</h3>
			<p>Assertions <a id="_idIndexMarker955"/>are an important best practice. This best practice is simply to leverage assertions to validate <span class="No-Break">expected outcomes.</span></p>
			<p class="callout-heading">Assertions</p>
			<p class="callout">Assertions are code statements that are used to check whether a condition <span class="No-Break">is true.</span></p>
			<p>When an <a id="_idIndexMarker956"/>assertion fails, it indicates that the condition <a id="_idIndexMarker957"/>evaluated by the assertion is false, which <a id="_idIndexMarker958"/>usually results in the unit test failing. There are several assertion methods that we can use in JUnit. Let’s look at four of the most common <span class="No-Break">assertion methods.</span></p>
			<p><span class="No-Break"><strong class="bold">Method</strong></span><span class="No-Break">: </span><span class="No-Break"><strong class="source-inline">assertEquals</strong></span></p>
			<p><strong class="bold">Syntax</strong>: <span class="No-Break"><strong class="source-inline">Assertions.assertEquals(expected, actual);</strong></span></p>
			<p><span class="No-Break"><strong class="bold">Example</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
int result = calculator.add(3, 6);
Assertions.assertEquals(9, result, "3 + 6 should equal 9");</pre>			<p><span class="No-Break"><strong class="bold">Method</strong></span><span class="No-Break">: </span><span class="No-Break"><strong class="source-inline">assertNotEquals</strong></span></p>
			<p><strong class="bold">Syntax</strong>: <span class="No-Break"><strong class="source-inline">Assertions.assertNotEquals(unexpected, actual);</strong></span></p>
			<p><span class="No-Break"><strong class="bold">Example</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
int result = calculator.subtract(24, 8);
Assertions.assertNotEquals(10, result, "24 - 8 should not equal 10");</pre>			<p><span class="No-Break"><strong class="bold">Method</strong></span><span class="No-Break">: </span><span class="No-Break"><strong class="source-inline">assertTrue</strong></span></p>
			<p><span class="No-Break"><strong class="bold">Syntax</strong></span><span class="No-Break">: </span><span class="No-Break"><strong class="source-inline">Assertions.assertTrue(condition)</strong></span></p>
			<p><span class="No-Break"><strong class="bold">Example</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
boolean result = someCondition();
Assertions.assertTrue(result, "The condition should be true");</pre>			<p><span class="No-Break"><strong class="bold">Method</strong></span><span class="No-Break">: </span><span class="No-Break"><strong class="source-inline">assertFalse</strong></span></p>
			<p><span class="No-Break"><strong class="bold">Syntax</strong></span><span class="No-Break">: </span><span class="No-Break"><strong class="source-inline">Assertions.assertFalse(condition);</strong></span></p>
			<p><span class="No-Break"><strong class="bold">Example</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
boolean result = someCondition();
Assertions.assertFalse(result, "The condition should be false");</pre>			<p>To use an <a id="_idIndexMarker959"/>assertion in our application, we simply add a line of code to each unit test. For example, as you review the <strong class="source-inline">testAdd()</strong> method in our <strong class="source-inline">CH17CalculatorTest</strong> application, you will see that it uses the <strong class="source-inline">assertEquals()</strong> <span class="No-Break">assertion method:</span></p>
			<pre class="source-code">
public void testAdd() {
  int result = calculator.add(3, 4);
  Assertions.assertEquals(7, result);
}</pre>			<p>Now that we have an understanding of some best practices in writing unit tests, let’s review some <span class="No-Break">common pitfalls.</span></p>
			<h2 id="_idParaDest-339"><a id="_idTextAnchor338"/>Pitfalls</h2>
			<p>As powerful <a id="_idIndexMarker960"/>as unit testing is, it also comes with several pitfalls. Here are three common pitfalls involved with unit testing and how to <span class="No-Break">avoid them:</span></p>
			<table class="No-Table-Style _idGenTablePara-1" id="table001-9">
				<colgroup>
					<col/>
					<col/>
				</colgroup>
				<tbody>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="bold">Pitfall</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="bold">Avoidance strategy</strong></span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p>Ignoring <span class="No-Break">edge cases</span></p>
						</td>
						<td class="No-Table-Style">
							<p>When we ignore edge cases in our unit testing, our systems can have undetected bugs. Ensure that you include a robust edge case strategy in your <span class="No-Break">unit testing.</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break">Over-testing</span></p>
						</td>
						<td class="No-Table-Style">
							<p>Over-testing in our context is creating tests that are too large, covering multiple units. To avoid this pitfall, create unit tests that are isolated from external dependencies and are focused on a single unit <span class="No-Break">of code.</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break">Under-testing</span></p>
						</td>
						<td class="No-Table-Style">
							<p>Under-testing refers to not running tests frequently enough to catch issues, especially when changing environments and scaling systems. To avoid this pitfall, perform <span class="No-Break">tests frequently.</span></p>
						</td>
					</tr>
				</tbody>
			</table>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Table 17.1 – Unit testing pitfalls and avoidance strategies</p>
			<p>We will <a id="_idIndexMarker961"/>conclude our coverage of unit testing with a look at <strong class="bold">Test-Driven </strong><span class="No-Break"><strong class="bold">Development</strong></span><span class="No-Break"> (</span><span class="No-Break"><strong class="bold">TTD</strong></span><span class="No-Break">).</span></p>
			<h2 id="_idParaDest-340"><a id="_idTextAnchor339"/>TDD</h2>
			<p>TTD is <a id="_idIndexMarker962"/>an interesting software development approach <a id="_idIndexMarker963"/>whereby the unit tests are written before <a id="_idIndexMarker964"/>the code is. The TDD cycle is often referred to as <strong class="bold">Red-Green-Refactor</strong> and is illustrated in <span class="No-Break"><em class="italic">Figure 17</em></span><span class="No-Break"><em class="italic">.2</em></span><span class="No-Break">.</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer048">
					<img alt="Figure 17.2 – The TTD cycle" src="image/B21942_17_2.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 17.2 – The TTD cycle</p>
			<p>TDD implementation starts with the Red step, wherein we write a test that fails because the related functionality has not been written. Next, in the Green step, we write the minimum amount of code required so the test will pass. Finally, in the Refactor step, we refactor our code to make it more efficient, improve its readability, and ensure that all related unit tests continue <span class="No-Break">to pass.</span></p>
			<p>The advantages <a id="_idIndexMarker965"/>of implementing TDD include <span class="No-Break">the following:</span></p>
			<ul>
				<li>Promoting <span class="No-Break">clean code</span></li>
				<li>Ensuring that the code <span class="No-Break">is testable</span></li>
				<li>Helping developers thoroughly consider requirements before <span class="No-Break">writing code</span></li>
			</ul>
			<p>There are <a id="_idIndexMarker966"/>also a few challenges to the TDD approach, including <span class="No-Break">the following:</span></p>
			<ul>
				<li>It is <span class="No-Break">not beginner-friendly</span></li>
				<li>It requires a mental <span class="No-Break">paradigm shift</span></li>
				<li>It can slow <span class="No-Break">initial development</span></li>
			</ul>
			<p>Now that we have a firm handle on unit testing, let’s explore performance testing in the <span class="No-Break">next section.</span></p>
			<h1 id="_idParaDest-341"><a id="_idTextAnchor340"/>Performance testing</h1>
			<p>The crux of this book has been to ensure our Java applications perform at the highest possible level. Several strategies, tools, and techniques have been presented to help us achieve our <a id="_idIndexMarker967"/>goal of high performance. In the previous section, we covered unit testing to help us ensure proper functionality. With performance testing, we will test our applications to see whether they can perform under various conditions and loads. This testing strategy involves evaluating the following characteristics of our applications: efficiency (speed), stability, responsiveness, reliability, <span class="No-Break">and scalability.</span></p>
			<p>There are several primary objectives of performance testing, including the determination of whether performance criteria have been met. We also want to identify performance bottlenecks so that we can refine our code. An additional objective is to ensure that our application can handle anticipated system and <span class="No-Break">user loads.</span></p>
			<h2 id="_idParaDest-342"><a id="_idTextAnchor341"/>Types and tools</h2>
			<p>The five <a id="_idIndexMarker968"/>primary types of performance tests are detailed in the table <span class="No-Break">that follows:</span></p>
			<table class="No-Table-Style _idGenTablePara-1" id="table002-3">
				<colgroup>
					<col/>
					<col/>
				</colgroup>
				<tbody>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="bold">Type</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="bold">Focus</strong></span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="bold">Endurance testing</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p>Checks for memory leaks and resource depletion with a sustained load over <span class="No-Break">extended time</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="bold">Load testing</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p>Tests performance with a specific number of <span class="No-Break">concurrent users</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="bold">Scalability testing</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p>Checks scalability by adding transactions <span class="No-Break">and users</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="bold">Spike testing</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p>Determines whether the application can handle a sudden increase <span class="No-Break">in load</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="bold">Stress testing</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p>Pushes the load past capacity to determine the <span class="No-Break">breaking point</span></p>
						</td>
					</tr>
				</tbody>
			</table>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Table 17.2 – Performance test types</p>
			<p>It is important <a id="_idIndexMarker969"/>to implement a performance testing plan that includes each type of performance test with an added focus on the types that are more critical to your specific application <span class="No-Break">and goals.</span></p>
			<p>There are several tools available to help us with performance testing. The three most common ones are featured in the table that follows. The table includes use cases <span class="No-Break">for each:</span></p>
			<table class="No-Table-Style _idGenTablePara-1" id="table003-2">
				<colgroup>
					<col/>
					<col/>
					<col/>
				</colgroup>
				<tbody>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="bold">Tool</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="bold">Description</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="bold">Use case</strong></span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break">Apache Bench</span></p>
						</td>
						<td class="No-Table-Style">
							<p>Basic command-line tool for benchmarking <span class="No-Break">HTTP servers</span></p>
						</td>
						<td class="No-Table-Style">
							<p>Simple load tests of <span class="No-Break">HTTP services</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break">Apache JMeter</span></p>
						</td>
						<td class="No-Table-Style">
							<p>Open source tool for <span class="No-Break">load testing</span></p>
						</td>
						<td class="No-Table-Style">
							<p>Comprehensive testing with a variety of protocols (that is, HTTP, FTP, and <span class="No-Break">so on)</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break">Gatling</span></p>
						</td>
						<td class="No-Table-Style">
							<p>Advanced open source tool that simulates high <span class="No-Break">user loads</span></p>
						</td>
						<td class="No-Table-Style">
							<p>Advanced load <span class="No-Break">testing scenarios</span></p>
						</td>
					</tr>
				</tbody>
			</table>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Table 17.3 – Performance testing tools</p>
			<p>Let’s wrap <a id="_idIndexMarker970"/>up this chapter with a look at big-picture approaches that are specific to unit testing and <span class="No-Break">performance testing.</span></p>
			<h1 id="_idParaDest-343"><a id="_idTextAnchor342"/>Overarching strategies</h1>
			<p>This chapter’s previous two sections were focused on unit testing and performance testing. This final <a id="_idIndexMarker971"/>section considers how we might combine the two types of testing for a cohesive strategy. This duality of testing is critical to our ability to develop and maintain robust and highly efficient <span class="No-Break">Java applications.</span></p>
			<p>We will start with a look at how to integrate the two types <span class="No-Break">of testing.</span></p>
			<h2 id="_idParaDest-344"><a id="_idTextAnchor343"/>Integrating unit and performance testing</h2>
			<p>There are <a id="_idIndexMarker972"/>a few strategies we can adopt <a id="_idIndexMarker973"/>for incorporating both types <a id="_idIndexMarker974"/>of testing. The first approach is <strong class="bold">parallel testing</strong>, which <a id="_idIndexMarker975"/>involves running unit tests and performance <a id="_idIndexMarker976"/>tests in parallel. This approach can save us time. Another approach is <strong class="bold">shared test cases</strong>, which <a id="_idIndexMarker977"/>can make our testing more efficient. This approach allows us to leverage shared test data and potential configurations. A third, more <a id="_idIndexMarker978"/>advanced strategy is to use a <strong class="bold">unified testing framework</strong>. These frameworks support both types of testing and can ensure a seamless transition <span class="No-Break">between them.</span></p>
			<p>Regardless of our implementation approach, we want to ensure that we have comprehensive test coverage. To accomplish this, we should use tools to measure our code coverage for <a id="_idIndexMarker979"/>both testing types. This is referred to as <strong class="bold">coverage analysis</strong> and helps us ensure that all critical paths are tested. We should also use <strong class="bold">incremental testing</strong>, whereby <a id="_idIndexMarker980"/>we gradually increase our test coverage until all code has been covered by tests. Finally, we should conduct a <strong class="bold">cross-validation</strong> of our <a id="_idIndexMarker981"/>test results with performance outcomes. This validation is used to confirm that functionality is accurate and performance efficiency <span class="No-Break">is acceptable.</span></p>
			<h1 id="_idParaDest-345"><a id="_idTextAnchor344"/>Summary</h1>
			<p>This chapter explored the critical role of testing in ensuring the reliability and efficiency of our Java applications. We started with an introduction to unit testing, highlighting its purpose, benefits, and best practices for writing effective tests. We then covered performance testing, explaining its objectives and the various types such as load and stress testing. The chapter concluded with a look at overarching strategies to integrate both testing types seamlessly into the development workflow, emphasizing the need for unified frameworks and comprehensive test coverage to enhance the overall quality and performance of our <span class="No-Break">Java applications.</span></p>
			<p>In the next chapter, we will take an extensive look at how to leverage <strong class="bold">Artificial Intelligence</strong> (<strong class="bold">AI</strong>) tools and technologies to help ensure that our applications are as efficient as possible and that they perform at the highest possible level. The chapter offers several opportunities for developers to harness the power of AI for the betterment of their Java <span class="No-Break">applications’ performance.</span></p>
		</div>
	</body></html>