<html><head></head><body>
<div id="page" style="height:0pt"/><div class="book" title="Chapter&#xA0;5.&#xA0;Multiprojects Build" id="11C3M1-e78ecbb3ac0544f19c59f96d594821c0"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch05" class="calibre1"/>Chapter 5. Multiprojects Build</h1></div></div></div><p class="calibre8">Now that we are familiar with the build script syntax, we are prepared to handle more complex project structures. In this chapter, we will focus on builds spanning across multiple projects, their interdependencies, and many more things in between.</p><p class="calibre8">As the projects code base grows, many times, it is desirable to split it into multiple modules based on layers, responsibilities, artifacts produced, or sometimes even depending on development teams, to effectively break the work down. Whatever is the reason, the reality is big projects are broken down into smaller subprojects sooner or later. Also, a build tool such as Gradle is completely capable of handling the complexity.</p></div>

<div class="book" title="Chapter&#xA0;5.&#xA0;Multiprojects Build" id="11C3M1-e78ecbb3ac0544f19c59f96d594821c0">
<div class="book" title="The multiproject directory layout"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_1"><a id="ch05lvl1sec28" class="calibre1"/>The multiproject directory layout</h1></div></div></div><p class="calibre8">A <a id="id190" class="calibre1"/>multiproject (or multimodule, as some prefer to call it) is a group of projects that are logically related to each other and often have the same develop-build-release cycles. The directory structure is important for laying out the strategy for building such projects. Typically, a top-level root project contains one or more subprojects. The root project may contain source sets of its own, may contain only the integration tests that test the integration of the subprojects, or may even act just as a master build without any source and tests. Gradle supports every such configuration.</p><p class="calibre8">The arrangement of subprojects relative to the root project may be flat, that is, all the subprojects are the direct children of the root project (as shown in sample 1) or are hierarchical, such that the subproject may also have nested child projects (as shown in sample 2) or any hybrid directory structure.</p><p class="calibre8">Let's refer to the following directory structure as sample 1:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre9">sample1</strong></span>
<span class="strong"><strong class="calibre9">├── repository</strong></span>
<span class="strong"><strong class="calibre9">├── services</strong></span>
<span class="strong"><strong class="calibre9">└── web-app</strong></span>
</pre></div><p class="calibre8">In sample 1, we see a fictitious example project in which all the subprojects are the direct children of the root project and are siblings of each other. Just for the sake of this example, we broke our app into three subprojects named <code class="literal">:repository</code>, <code class="literal">:services</code>, and <code class="literal">:web-app</code>. As <a id="id191" class="calibre1"/>their names suggest, a repository contains the data access code, whereas services is the layer encapsulating the business rules in the form of a consumable API. The <code class="literal">web-app</code> contains only the web application-specific code such as controllers and view templates. However, note that the <code class="literal">:web-app</code> project may depend on the <code class="literal">:services</code> project, which in turn may depend on the <code class="literal">:repository</code> project. We will soon see how these dependencies work.</p><div class="informalexample" title="Note"><h3 class="title2"><a id="tip21" class="calibre1"/>Tip</h3><p class="calibre8">Do not confuse the multiproject structure with multiple source directories in a single project.</p></div><p class="calibre8">Let's see a relatively more complex structure and call it sample 2:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre9">sample2</strong></span>
<span class="strong"><strong class="calibre9">├── core</strong></span>
<span class="strong"><strong class="calibre9">│   ├── models</strong></span>
<span class="strong"><strong class="calibre9">│   ├── repository</strong></span>
<span class="strong"><strong class="calibre9">│   └── services</strong></span>
<span class="strong"><strong class="calibre9">├── client</strong></span>
<span class="strong"><strong class="calibre9">│   ├── client-api</strong></span>
<span class="strong"><strong class="calibre9">│   ├── cli-client</strong></span>
<span class="strong"><strong class="calibre9">│   └── desktop-client</strong></span>
<span class="strong"><strong class="calibre9">└── web </strong></span>
<span class="strong"><strong class="calibre9">    ├── webservices</strong></span>
<span class="strong"><strong class="calibre9">    └── webapp</strong></span>
</pre></div><p class="calibre8">Our app has now evolved and to cater for more needs, we have added more functionalities to it. We have created more subprojects such as a desktop client for our app and a command-line interface. In sample 2, the root project is split into three projects (groups), which have their own child projects. In this example, every directory can be treated as a project. The purpose of this sample is to only show one of the possible directory structures. Gradle does not impose one directory structure over another.</p><p class="calibre8">One might wonder, where do we put all the <code class="literal">build.gradle</code> files and what goes in them? It depends on our needs and how we want to structure our build. We will answer all these questions shortly after we understand what is <code class="literal">settings.gradle</code>.</p></div></div>
<div class="book" title="The settings.gradle file" id="12AK81-e78ecbb3ac0544f19c59f96d594821c0"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch05lvl1sec29" class="calibre1"/>The settings.gradle file</h1></div></div></div><p class="calibre8">During <a id="id192" class="calibre1"/>initialization, Gradle reads the <code class="literal">settings.gradle</code> file to figure out which projects are to take part in a build. Gradle creates an object of type <code class="literal">Setting</code>. This happens even before any <code class="literal">build.gradle</code> is parsed. It is usually placed in the root project parallel to <code class="literal">build.gradle</code>. It is recommended to put <code class="literal">setting.gradle</code> in the root project, otherwise we have to explicitly tell Gradle the location to the settings file with the command-line option <code class="literal">-c</code>. Adding these two files to sample 1's directory structure would gives us something as follows:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre9">sample1</strong></span>
<span class="strong"><strong class="calibre9">├── repository</strong></span>
<span class="strong"><strong class="calibre9">│   └── ...</strong></span>
<span class="strong"><strong class="calibre9">├── services</strong></span>
<span class="strong"><strong class="calibre9">│   └── ...</strong></span>
<span class="strong"><strong class="calibre9">├── web-app</strong></span>
<span class="strong"><strong class="calibre9">│   └── ...</strong></span>
<span class="strong"><strong class="calibre9">├── build.gradle</strong></span>
<span class="strong"><strong class="calibre9">└── settings.gradle</strong></span>
</pre></div><p class="calibre8">The most common use of <code class="literal">settings.gradle</code> is to enlist all the subprojects participating in the build:</p><div class="informalexample"><pre class="programlisting">include ':repository', ':services', ':web-app'</pre></div><p class="calibre8">Also, this is all that is required to tell Gradle that the current build is a multiproject build. Of course, this not the end of the story and there is a lot more that we can do with multiproject builds, but this is the bare minimum and sometimes just enough to get multiproject builds working.</p><p class="calibre8">The methods and properties of <code class="literal">Settings</code> are available in the <code class="literal">settings.gradle</code> file and are implicitly called on a <code class="literal">Settings</code> instance just the way the methods of <code class="literal">Project</code> API are available in the <code class="literal">build.gradle</code> file, as we saw in the previous chapter.</p><div class="informalexample" title="Note"><h3 class="title2"><a id="note24" class="calibre1"/>Note</h3><p class="calibre8">Are you wondering why a colon (<code class="literal">:</code>) is used before the project name in the preceding section? It denotes the project path relative to the root project. However, the <code class="literal">include</code> method allows level 1 subproject names to omit the colon. So, the <code class="literal">include</code> call can be rewritten as follows:</p><div class="informalexample"><pre class="programlisting">include 'repository', 'services', 'web-app'</pre></div></div><p class="calibre8">Let's just query the projects by calling the task <code class="literal">projects</code> from the command line. The <code class="literal">projects</code> task <a id="id193" class="calibre1"/>lists all the projects available in a Gradle build:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre9">$ gradle projects</strong></span>
<span class="strong"><strong class="calibre9">:projects</strong></span>
<span class="strong"><strong class="calibre9">------------------------------------------------------------</strong></span>
<span class="strong"><strong class="calibre9">Root project</strong></span>
<span class="strong"><strong class="calibre9">------------------------------------------------------------</strong></span>

<span class="strong"><strong class="calibre9">Root project 'sample1'</strong></span>
<span class="strong"><strong class="calibre9">+--- Project ':repository'</strong></span>
<span class="strong"><strong class="calibre9">+--- Project ':services'</strong></span>
<span class="strong"><strong class="calibre9">\--- Project ':web-app'</strong></span>

<span class="strong"><strong class="calibre9">To see a list of the tasks of a project, run gradle &lt;project-path&gt;:tasks.</strong></span>
<span class="strong"><strong class="calibre9">For example, try running gradle :repository:tasks.</strong></span>

<span class="strong"><strong class="calibre9">BUILD SUCCESSFUL</strong></span>
</pre></div><div class="informalexample" title="Note"><h3 class="title2"><a id="note25" class="calibre1"/>Note</h3><p class="calibre8">In case of nesting that is more than one level deep, like in sample 2, all the projects must be included in the root project <code class="literal">settings.gradle</code> with the syntax as follows:</p><div class="informalexample"><pre class="programlisting">include 'core',
  'core:models', 'core:repository', 'core:services',
  'client' //... so on</pre></div></div><p class="calibre8">We can find more information on <code class="literal">Settings</code> at the <span class="strong"><em class="calibre10">Settings</em></span> DSL documentation (<a class="calibre1" href="http://www.gradle.org/docs/current/dsl/org.gradle.api.initialization.Settings.html">http://www.gradle.org/docs/current/dsl/org.gradle.api.initialization.Settings.html</a>) and the <span class="strong"><em class="calibre10">Settings</em></span> API documentation (<a class="calibre1" href="http://www.gradle.org/docs/current/javadoc/org/gradle/api/initialization/Settings.html">http://www.gradle.org/docs/current/javadoc/org/gradle/api/initialization/Settings.html</a>).</p></div>

<div id="page" style="height:0pt"/><div class="book" title="Organizing build logic in multiproject builds"><div class="book" id="1394Q2-e78ecbb3ac0544f19c59f96d594821c0"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch05lvl1sec30" class="calibre1"/>Organizing build logic in multiproject builds</h1></div></div></div><p class="calibre8">Gradle gives<a id="id194" class="calibre1"/> us the flexibility to create one build file for all projects or individual build file per project; you can also mix and match. Let's start with adding a simple task to our root project's <code class="literal">build.gradle</code>:</p><div class="informalexample"><pre class="programlisting">task sayHello &lt;&lt; {
    println "Hello from multi-project build"
}</pre></div><p class="calibre8">We are creating<a id="id195" class="calibre1"/> a task with an action that just prints a message. Now, let's check what tasks are available on our root project. From the <code class="literal">root</code> directory, let's call the task <code class="literal">tasks</code>:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre9">$ gradle tasks</strong></span>
<span class="strong"><strong class="calibre9">...</strong></span>

<span class="strong"><strong class="calibre9">Other tasks</strong></span>
<span class="strong"><strong class="calibre9">-----------</strong></span>
<span class="strong"><strong class="calibre9">sayHello</strong></span>

<span class="strong"><strong class="calibre9">....</strong></span>
</pre></div><p class="calibre8">No wonder, the <code class="literal">sayHello</code> task is available on the root project. However, what if we just want to see the tasks available on a subproject? Let's say <code class="literal">:repository</code>. For a multiproject build, we can call tasks on any nested project using the <code class="literal">gradle &lt;project-path&gt;:&lt;task-name&gt;</code> syntax or by going into the subproject directory and executing <code class="literal">gradle &lt;task-name&gt;</code>. So now, if we execute the following code, we won't see the <code class="literal">sayHello</code> task:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre9">$ gradle repository:tasks</strong></span>
</pre></div><p class="calibre8">This is because the <code class="literal">sayHello</code> is only defined for the root project; hence, it is not available on the subproject.</p></div>

<div class="book" title="Organizing build logic in multiproject builds">
<div class="book" title="Applying a build logic to all projects"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_1"><a id="ch05lvl2sec47" class="calibre1"/>Applying a build logic to all projects</h2></div></div></div><p class="calibre8">There<a id="id196" class="calibre1"/> are times when we want the same tasks to be available on all projects, including the root project. For example, let's imagine a task that just prints the project name. We have four projects, including the root project, and we want to define the same task for every project. Wouldn't it be an overkill if we had to write identical code four times, one for each project? Certainly yes, and that's why Gradle DSL provides a first-class support for declaring common build elements across all projects.</p><p class="calibre8">Take a look at the following code snippet, which we will add to our root project's <code class="literal">build.gradle</code>:</p><div class="informalexample"><pre class="programlisting">allprojects {
    task whoami &lt;&lt; {println "I am ${project.name}"}
}</pre></div><p class="calibre8">Before trying to understand the code snippet, let's run the familiar task again. Firstly, from the root project:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre9">$ gradle tasks</strong></span>
<span class="strong"><strong class="calibre9">...</strong></span>
<span class="strong"><strong class="calibre9">Other tasks</strong></span>
<span class="strong"><strong class="calibre9">-----------</strong></span>
<span class="strong"><strong class="calibre9">sayHello</strong></span>
<span class="strong"><strong class="calibre9">whoami</strong></span>
<span class="strong"><strong class="calibre9">...</strong></span>
</pre></div><p class="calibre8">Then, from the repository project:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre9">$ gradle repository:tasks</strong></span>
<span class="strong"><strong class="calibre9">...</strong></span>
<span class="strong"><strong class="calibre9">Other tasks</strong></span>
<span class="strong"><strong class="calibre9">-----------</strong></span>
<span class="strong"><strong class="calibre9">whoami</strong></span>
<span class="strong"><strong class="calibre9">...</strong></span>
</pre></div><p class="calibre8">We see<a id="id197" class="calibre1"/> the <code class="literal">whoami</code> task in the repository project as well. Let's uncover the <code class="literal">allprojects</code> method that made it possible.</p><p class="calibre8">The <code class="literal">allprojects</code> method takes a closure and executes it on the project (object) of the build file and all the subprojects of the current project. So, if <code class="literal">allproject</code> is defined in the root project, the block gets applied to all the projects one by one, once with each project object as an implicit reference.</p><p class="calibre8">Now, let's understand the code snippet. The task that we have declared inside the <code class="literal">allprojects</code> block (the closure being passed to <code class="literal">allprojects</code>, to be technically correct) gets applied to all the projects. The task's action prints the name of the project using the <code class="literal">project</code> object reference. Remember that the <code class="literal">project</code> object will refer to different projects depending on the project on which the task is being called. This happens because in the configuration phase, the <code class="literal">allproject</code> block is executed for each project once we have the <code class="literal">project</code> reference for that project.</p><p class="calibre8">The content inside the closure being passed to <code class="literal">allproject</code> would look exactly like a single-project <code class="literal">build.gradle</code> file. We can even apply plugins, declare repositories and dependencies, and so on. So, in essence, we can write any build logic that is common to all projects and then it will be applied to all projects. The <code class="literal">allprojects</code> method can also be used to query the project object in the current build. Refer to the API of the project for more details on <code class="literal">allprojects</code>.</p><p class="calibre8">If we pass the <code class="literal">--all</code> flag to the <code class="literal">tasks</code> task, we will see the <code class="literal">whoami</code> task being present on all the child projects, in addition to the <code class="literal">root</code> project:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre9">$ gradle tasks --all</strong></span>
<span class="strong"><strong class="calibre9">...</strong></span>
<span class="strong"><strong class="calibre9">Other tasks</strong></span>
<span class="strong"><strong class="calibre9">-----------</strong></span>
<span class="strong"><strong class="calibre9">sayHello</strong></span>
<span class="strong"><strong class="calibre9">whoami</strong></span>
<span class="strong"><strong class="calibre9">repository:whoami</strong></span>
<span class="strong"><strong class="calibre9">services:whoami</strong></span>
<span class="strong"><strong class="calibre9">web-app:whoami</strong></span>
<span class="strong"><strong class="calibre9">...</strong></span>
</pre></div><p class="calibre8">If we want to <a id="id198" class="calibre1"/>just execute <code class="literal">whoami</code> on a specific project, let's say <code class="literal">:repository</code>, it's as simple as the following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre9">$ gradle -q repository:whoami</strong></span>
<span class="strong"><strong class="calibre9">I am repository</strong></span>
</pre></div><p class="calibre8">When we execute <code class="literal">whoami</code> without any project path:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre9">$ gradle -q whoami</strong></span>
<span class="strong"><strong class="calibre9">I am root</strong></span>
<span class="strong"><strong class="calibre9">I am repository</strong></span>
<span class="strong"><strong class="calibre9">I am services</strong></span>
<span class="strong"><strong class="calibre9">I am web-app</strong></span>
</pre></div><p class="calibre8">Wow, Gradle goes an extra mile to ensure that the child project tasks with the same name are also executed when we execute the task from the parent project. This comes in very handy when we think about tasks such as <code class="literal">assemble</code>, where we actually want all the subprojects to assemble, or test, which tests the root and also the subprojects.</p><p class="calibre8">However, what about executing a task only on the root project? Indeed, a valid scenario. Remember the absolute task path:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre9">$ gradle -q :whoami</strong></span>
<span class="strong"><strong class="calibre9">I am root</strong></span>
</pre></div><p class="calibre8">The colon makes all the difference. Here, we are referring to <code class="literal">whoami</code> of the <code class="literal">root</code> project only. No other task matches the same path. For example, repository's <code class="literal">whoami</code> has a path <code class="literal">repository:whoami</code>.</p><p class="calibre8">Now, <code class="literal">cd</code> in the <code class="literal">repository</code> directory and then execute the <code class="literal">whoami</code>:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre9">$ gradle –q whoami</strong></span>
<span class="strong"><strong class="calibre9">I am repository</strong></span>
</pre></div><p class="calibre8">So the task execution is context-sensitive. Here, by default, Gradle assumes that the task has to be called on the current project only. Nice, isn't it?</p><p class="calibre8">Let's add a little more dynamic code to our existing <code class="literal">build.gradle</code> file:</p><div class="informalexample"><pre class="programlisting">allprojects {
  task("describe${project.name.capitalize()}") &lt;&lt; {
    println project.name
  }
}</pre></div><p class="calibre8">Here, depending <a id="id199" class="calibre1"/>on the project name, we are setting the task name to be <code class="literal">describe</code>, prefixed to the project name. So all projects get their tasks, but the name won't be the same. We add an action that just prints the project name. If we execute the <code class="literal">tasks</code> on our project now, we can see the task names include the project name:</p><div class="informalexample"><pre class="programlisting">$ gradle tasks 
...
Other tasks
-----------
describeRepository
describeSample1
describeServices
describeWeb-app
sayHello
whoami
...</pre></div><p class="calibre8">Although the example is very trivial, we learn a few things. Firstly, the <code class="literal">allprojects</code> blocks are additive as most of the other methods in Gradle. We added the second <code class="literal">allprojects</code> block and both worked just fine. Secondly, the task name can be dynamically assigned, for example, using the project name.</p><p class="calibre8">Now, we can call any of the <code class="literal">describe*</code> tasks from the project root. Also, as we might guess, the task name is unique; we don't need to prepend the project path:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre9">$ gradle -q describeServices </strong></span>
<span class="strong"><strong class="calibre9">services</strong></span>
</pre></div><p class="calibre8">Let's <code class="literal">cd</code> into the <code class="literal">repository</code> directory and list tasks:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre9">$ gradle -q tasks  </strong></span>
<span class="strong"><strong class="calibre9">...</strong></span>
<span class="strong"><strong class="calibre9">Other tasks</strong></span>
<span class="strong"><strong class="calibre9">-----------</strong></span>
<span class="strong"><strong class="calibre9">describeRepository</strong></span>
<span class="strong"><strong class="calibre9">whoami</strong></span>
</pre></div><p class="calibre8">We see only the <a id="id200" class="calibre1"/>applicable tasks for the current project, which is <code class="literal">repository</code>.</p></div></div>

<div class="book" title="Organizing build logic in multiproject builds">
<div class="book" title="Applying build logic to subprojects"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_2"><a id="ch05lvl2sec48" class="calibre1"/>Applying build logic to subprojects</h2></div></div></div><p class="calibre8">Let's <a id="id201" class="calibre1"/>continue further with our example. Here, the root project will not have any source sets as all the Java code is going to be in one of the three child projects. Hence, wouldn't it be wise to apply a <code class="literal">java</code> plugin to only child projects? This is exactly where the <code class="literal">subprojects</code> method comes into the picture, that is, when we want to apply some build logic only on subprojects without affecting the parent project. Its usage is similar to <code class="literal">allprojects</code>. Let's just apply the <code class="literal">java</code> plugin to all subprojects:</p><div class="informalexample"><pre class="programlisting">subprojects {
  apply plugin: 'java'
}</pre></div><p class="calibre8">Now, running <code class="literal">gradle tasks</code> should show us the tasks added by the <code class="literal">java</code> plugin as well. Although it might appear that these tasks are available on the root project, it's actually not so. Check the output of <code class="literal">gradle -q tasks --all</code> in this case. The tasks being there on the child project can be called from the root project, but this does not mean they are present on the root project. The tasks added by the <code class="literal">java</code> plugin will only be available on subprojects, whereas tasks such as help tasks will be available on all projects.</p></div></div>

<div class="book" title="Organizing build logic in multiproject builds">
<div class="book" title="Dependency on subprojects"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_3"><a id="ch05lvl2sec49" class="calibre1"/>Dependency on subprojects</h2></div></div></div><p class="calibre8">In the <a id="id202" class="calibre1"/>beginning of the chapter, we mentioned that a subproject might depend on another subproject(s) just the way it can depend on the external library dependency. For example, the <code class="literal">services</code> project's compilation depends on the <code class="literal">repository</code> project, which means we need the compiled classes from the <code class="literal">repository</code> project to be available on the compilation classpath of the <code class="literal">services</code> project.</p><p class="calibre8">To achieve this, we can, of course, create a <code class="literal">build.gradle</code> file in the <code class="literal">services</code> project and put the dependency declaration there. However, just for the sake of showing an alternate way, we will put this declaration in the <code class="literal">root</code> project's <code class="literal">build.gradle</code>.</p><p class="calibre8">Unlike <code class="literal">allprojects</code> or <code class="literal">subprojects</code>, we need a finer mechanism to configure only a single project from the <code class="literal">root</code> project's <code class="literal">build.gradle</code>. As it turns out, it is very easy using the <code class="literal">project</code> method. This method accepts a closure just like the <code class="literal">allprojects</code> and <code class="literal">subprojects</code> methods in addition to the project name on which the closure will be applied. In the <a id="id203" class="calibre1"/>configuration phase, the closure is executed on that project's object.</p><p class="calibre8">So, let's add this to the root project's <code class="literal">build.gradle</code>:</p><div class="informalexample"><pre class="programlisting">project(':services') {
  dependencies {
    compile project(':repository')
  }
}</pre></div><p class="calibre8">Here, we are configuring dependencies only for the <code class="literal">services</code> project. In the <code class="literal">dependencies</code> block, we declare that the <code class="literal">:repository</code> project is the compile time dependency for the <code class="literal">services</code> project. This is more or less similar to the external library declaration; instead of the library name in the <code class="literal">group-id:artifact-id:version</code> notation, we used <code class="literal">project(:sub-project)</code> to refer to a subproject.</p><p class="calibre8">We had also said that the <code class="literal">web-app</code> project depends on the <code class="literal">services</code> project. So this time, let's use<code class="literal"> web-app</code>'s own <code class="literal">build.gradle</code> to declare this dependency. We will create a <code class="literal">build.gradle</code> file in the <code class="literal">web-app</code> directory:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre9">root</strong></span>
<span class="strong"><strong class="calibre9">├── build.gradle</strong></span>
<span class="strong"><strong class="calibre9">├── settings.gradle</strong></span>
<span class="strong"><strong class="calibre9">├── repository</strong></span>
<span class="strong"><strong class="calibre9">├── services</strong></span>
<span class="strong"><strong class="calibre9">└── web-app</strong></span>
<span class="strong"><strong class="calibre9">    └── build.gradle</strong></span>
</pre></div><p class="calibre8">As this is a project-specific build file, we can just add the <code class="literal">dependencies</code> block as we would in any other project:</p><div class="informalexample"><pre class="programlisting">dependencies {
  compile project(':services')
}</pre></div><p class="calibre8">Now, let's visualize the dependencies of the web project, using the <code class="literal">dependencies</code> tasks:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre9">$ gradle -q web-app:dependencies</strong></span>

<span class="strong"><strong class="calibre9">------------------------------------------------------------</strong></span>
<span class="strong"><strong class="calibre9">Project :web-app</strong></span>
<span class="strong"><strong class="calibre9">------------------------------------------------------------</strong></span>

<span class="strong"><strong class="calibre9">archives - Configuration for archive artifacts.</strong></span>
<span class="strong"><strong class="calibre9">No dependencies</strong></span>

<span class="strong"><strong class="calibre9">compile - Compile classpath for source set 'main'.</strong></span>
<span class="strong"><strong class="calibre9">\--- project :services</strong></span>
<span class="strong"><strong class="calibre9">     \--- project :repository</strong></span>

<span class="strong"><strong class="calibre9">default - Configuration for default artifacts.</strong></span>
<span class="strong"><strong class="calibre9">\--- project :services</strong></span>
<span class="strong"><strong class="calibre9">     \--- project :repository</strong></span>

<span class="strong"><strong class="calibre9">runtime - Runtime classpath for source set 'main'.</strong></span>
<span class="strong"><strong class="calibre9">\--- project :services</strong></span>
<span class="strong"><strong class="calibre9">     \--- project :repository</strong></span>

<span class="strong"><strong class="calibre9">testCompile - Compile classpath for source set 'test'.</strong></span>
<span class="strong"><strong class="calibre9">\--- project :services</strong></span>
<span class="strong"><strong class="calibre9">     \--- project :repository</strong></span>

<span class="strong"><strong class="calibre9">testRuntime - Runtime classpath for source set 'test'.</strong></span>
<span class="strong"><strong class="calibre9">\--- project :services</strong></span>
<span class="strong"><strong class="calibre9">     \--- project :repository</strong></span>
</pre></div><p class="calibre8">Gradle shows <a id="id204" class="calibre1"/>us the dependencies of the <code class="literal">web-app</code> under various configurations. Also, we can clearly see that Gradle understands the transitive dependency; hence, it shows <code class="literal">web-app</code> transitively dependent on <code class="literal">repository</code> through <code class="literal">services</code>. Note that we have not actually declared any external dependencies (such as <code class="literal">servlet-api</code>) in any of the projects, otherwise they would also show up here.</p><p class="calibre8">It is worth taking a look at the variations of the <code class="literal">configure</code> methods on the <code class="literal">project</code> object in order to filter and configure selected projects. More information on the <code class="literal">configure</code> method can be found at <a class="calibre1" href="https://docs.gradle.org/current/javadoc/org/gradle/api/Project.html">https://docs.gradle.org/current/javadoc/org/gradle/api/Project.html</a>.</p></div></div>
<div class="book" title="Summary" id="147LC1-e78ecbb3ac0544f19c59f96d594821c0"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch05lvl1sec31" class="calibre1"/>Summary</h1></div></div></div><p class="calibre8">In this short chapter, we learned that Gradle supports flexible directory structure for complex project hierarchies and allows us to choose the right structure for our build. We then looked at the importance of <code class="literal">settings.gradle</code> in the context of mutliprojects build. We then saw various ways of applying a build logic to all projects, subprojects, or only a single project. Finally, took a small example of inter-project dependencies.</p><p class="calibre8">This is all we need to worry about in terms of the Gradle syntax. Now the next chapters will majorly focus on the functionalities that various plugins add to our builds and how we can configure them.</p></div></body></html>