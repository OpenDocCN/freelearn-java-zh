<html><head></head><body>
		<div id="_idContainer169">
			<h1 id="_idParaDest-249" class="chapter-number"><a id="_idTextAnchor249"/>10</h1>
			<h1 id="_idParaDest-250"><a id="_idTextAnchor250"/>Interfaces and Abstract Classes</h1>
			<p>In <a href="B19793_09.xhtml#_idTextAnchor205"><span class="No-Break"><em class="italic">Chapter 9</em></span></a>, we learned about another core pillar of OOP, namely inheritance. We saw that Java uses the <strong class="source-inline">extends</strong> keyword to define an “is-a” inheritance relationship between the child and the parent class. The subclass inherits functionality from its parent that enables code reuse, a core benefit of inheritance. Java prevents multiple class inheritance by ensuring you can only extend from one class at <span class="No-Break">a time.</span></p>
			<p>We also took a deep dive into the other remaining pillar of OOP, polymorphism. Polymorphism is enabled by subclasses overriding the parent class instance methods. We saw that, regarding the hierarchy, references can point (across) to objects of their own type and (down) to subclass objects. An exception occurs if a reference attempts to point (up) to parent objects in <span class="No-Break">the hierarchy.</span></p>
			<p>Next, we compared and contrasted method overloading and method overriding. In method overriding, the method signatures must match (except for covariant returns). In method overloading, while the method names are the same, the method signatures must <span class="No-Break">be different.</span></p>
			<p>We also discovered that the order of constructor calls is from the top (base class) down. This is facilitated by the <strong class="source-inline">super()</strong> keyword. To access a parent (non-constructor) member, we can use the <span class="No-Break"><strong class="source-inline">super.</strong></span><span class="No-Break"> syntax.</span></p>
			<p>We then revisited the <strong class="source-inline">protected</strong> access modifier and demonstrated that, for subclasses outside the package to access the protected member, they must do so via inheritance in a very specific manner. In effect, once outside the package, the <strong class="source-inline">protected</strong> member becomes private to subclasses (of the class containing the <span class="No-Break"><strong class="source-inline">protected</strong></span><span class="No-Break"> member).</span></p>
			<p>We then covered two keywords that have an impact on inheritance: <strong class="source-inline">abstract</strong> and <strong class="source-inline">final</strong>. As an <strong class="source-inline">abstract</strong> method has no implementation code, it is intended to be overridden. The first non-abstract (concrete) subclass must provide implementation code for any inherited <strong class="source-inline">abstract</strong> methods. The <strong class="source-inline">final</strong> keyword can be applied in several scenarios. Concerning inheritance, a <strong class="source-inline">final</strong> method cannot be overridden and a <strong class="source-inline">final</strong> class cannot <span class="No-Break">be subclassed.</span></p>
			<p>Next, we discussed <strong class="source-inline">sealed</strong> classes, which enable us to scope parts of the inheritance tree. Using the <strong class="source-inline">sealed</strong> and <strong class="source-inline">permits</strong> keywords, we can state that a class can only be subclassed by certain other named classes. The <strong class="source-inline">non-sealed</strong> keyword ends the scoping task and thus enables us to subclass <span class="No-Break">as normal.</span></p>
			<p>We examined both <strong class="source-inline">instance</strong> and <strong class="source-inline">static</strong> blocks in an inheritance hierarchy. A <strong class="source-inline">static</strong> block is only executed once when a class is first loaded. An <strong class="source-inline">instance</strong> block, on the other hand, is executed every time an object instance is created, making it an ideal place to insert code common to <span class="No-Break">all constructors.</span></p>
			<p>Lastly, we examined upcasting and downcasting. Whereas upcasting is never an issue, downcasting can lead to an exception. Use of the <strong class="source-inline">instanceof</strong> keyword helps prevent <span class="No-Break">this exception.</span></p>
			<p>In this chapter, we will cover <strong class="source-inline">abstract</strong> classes and interfaces. We will compare and contrast them. Interfaces have had several changes over the years. With the aid of examples, we will examine these changes. Java 8 introduced both <strong class="source-inline">static</strong> and <strong class="source-inline">default</strong> methods for interfaces, thereby enabling code to be present in an interface for the first time. In Java 9, to reduce code duplication and improve encapsulation, <strong class="source-inline">private</strong> methods were introduced to interfaces. Finally, Java 17 introduced <strong class="source-inline">sealed</strong> interfaces, which enable us to customize what classes can implement <span class="No-Break">our interface.</span></p>
			<p>This chapter covers the following <span class="No-Break">main topics:</span></p>
			<ul>
				<li>Understanding <span class="No-Break"><strong class="source-inline">abstract</strong></span><span class="No-Break"> classes</span></li>
				<li><span class="No-Break">Mastering interfaces</span></li>
				<li>Examining <strong class="source-inline">default</strong> and <strong class="source-inline">static</strong> <span class="No-Break">interface methods</span></li>
				<li>Explaining <strong class="source-inline">private</strong> <span class="No-Break">interface methods</span></li>
				<li>Exploring <span class="No-Break"><strong class="source-inline">sealed</strong></span><span class="No-Break"> interfaces</span></li>
			</ul>
			<h1 id="_idParaDest-251"><a id="_idTextAnchor251"/>Technical requirements</h1>
			<p>The code for this chapter can be found on GitHub <span class="No-Break">at </span><a href="https://github.com/PacktPublishing/Learn-Java-with-Projects/tree/main/ch10"><span class="No-Break">https://github.com/PacktPublishing/Learn-Java-with-Projects/tree/main/ch10</span></a><span class="No-Break">.</span></p>
			<h1 id="_idParaDest-252"><a id="_idTextAnchor252"/>Understanding abstract classes</h1>
			<p>In <a href="B19793_09.xhtml#_idTextAnchor205"><span class="No-Break"><em class="italic">Chapter 9</em></span></a>, we covered the <strong class="source-inline">abstract</strong> keyword. Let’s review some key points that we discussed. An <strong class="source-inline">abstract</strong> method is exactly that – it is abstract. It has no code. It doesn’t even have curly braces – <strong class="source-inline">{}</strong>. This is typically a design decision. The class containing the <strong class="source-inline">abstract</strong> method <a id="_idIndexMarker748"/>wants subclasses to provide the code. This means that the class itself is “incomplete” and therefore any class defining an <strong class="source-inline">abstract</strong> method must itself be <strong class="source-inline">abstract</strong>. Any subclass of the <strong class="source-inline">abstract</strong> class must either override the <strong class="source-inline">abstract</strong> method or declare that it too is <strong class="source-inline">abstract</strong>. The compiler will <span class="No-Break">complain otherwise.</span></p>
			<p>However, the inverse is not the case – an <strong class="source-inline">abstract</strong> class need not have any <strong class="source-inline">abstract</strong> methods at all. Again, this is a design decision. Since the class is marked as <strong class="source-inline">abstract</strong>, it is considered “incomplete” (even though it may contain code for all the methods). This prevents objects based on <strong class="source-inline">abstract</strong> classes from being instantiated. In other words, you cannot <strong class="source-inline">new</strong> an object based on an <strong class="source-inline">abstract</strong> class. You can, however, have a reference based on an <span class="No-Break"><strong class="source-inline">abstract</strong></span><span class="No-Break"> type.</span></p>
			<p>Please refer to <span class="No-Break"><em class="italic">Figure 9</em></span><em class="italic">.14</em> for a code example of <strong class="source-inline">abstract</strong> methods <span class="No-Break">and classes.</span></p>
			<h1 id="_idParaDest-253"><a id="_idTextAnchor253"/>Mastering interfaces</h1>
			<p>By default, an interface is an <strong class="source-inline">abstract</strong> construct. Before Java 8, all the methods in an interface were <strong class="source-inline">abstract</strong>. In general, when you create an interface, you are defining a contract for <em class="italic">what</em> a class <a id="_idIndexMarker749"/>can do without saying anything about <em class="italic">how</em> the class will do it. A class signs the contract when it implements an interface. A class implementing an interface is agreeing to “obey” the contract defined in the interface. “Obeying” here means that, if a concrete (non-abstract) class is implementing an interface, the compiler will ensure that the class has implementation code for each <strong class="source-inline">abstract</strong> method in the interface. As the Oracle tutorials state, “<em class="italic">Implementing an interface allows a class to become more formal about the behavior it promises </em><span class="No-Break"><em class="italic">to provide</em></span><span class="No-Break">.”</span></p>
			<p>In contrast to classes, where you can (directly) inherit from only one other class, a class can implement many interfaces. Thus, interfaces enable multiple inheritance. Let’s look at <span class="No-Break">an example:</span></p>
			<pre class="source-code">
class Dog extends Animal implements Moveable, Loveable {}</pre>			<p>This line of code states that <strong class="source-inline">Dog</strong> “is-a” <strong class="source-inline">Animal</strong>, <strong class="source-inline">Moveable</strong>, and <strong class="source-inline">Loveable</strong>. Interface names are often adjectives as they often describe a quality of a noun. Thus, interface names often end in “able.” For example, <strong class="source-inline">Iterable</strong> and <strong class="source-inline">Callable</strong> are interface names in the <span class="No-Break">Java API.</span></p>
			<p>n the previous line of code, we are limited to extending from one class but we can implement as many interfaces as we like. This flexibility is very powerful as we can link into hierarchies without forcing artificial class relationships. This is one of the core reasons for interfaces – <em class="italic">to be able to cast to more than one </em><span class="No-Break"><em class="italic">base type</em></span><span class="No-Break">.</span></p>
			<p>As with <strong class="source-inline">abstract</strong> classes, given that interfaces are also <strong class="source-inline">abstract</strong>, you cannot <strong class="source-inline">new</strong> an <strong class="source-inline">interface</strong> type. In <a id="_idIndexMarker750"/>addition, similarly to <strong class="source-inline">abstract</strong> classes, you can (and often do) have references that are <span class="No-Break">interface types.</span></p>
			<p>In later sections, we will discuss the <strong class="source-inline">static</strong>, <strong class="source-inline">default</strong>, and <strong class="source-inline">private</strong> methods, all of which have implementation code. Before that, we will deal with the other type of methods we can use in an interface: <strong class="source-inline">abstract</strong> methods. Additionally, we will discuss <span class="No-Break">interface constants.</span></p>
			<h2 id="_idParaDest-254"><a id="_idTextAnchor254"/>Abstract methods in interfaces</h2>
			<p>Prior to Java 8, all of the <a id="_idIndexMarker751"/>methods in an interface were <a id="_idIndexMarker752"/>implicitly <strong class="source-inline">public</strong> and <strong class="source-inline">abstract</strong> by default. Back then, you could state that an interface was a “purely <span class="No-Break">abstract class.”</span></p>
			<p>Concerning the <strong class="source-inline">public</strong> access modifier, this is still the case, even though Java 9 introduced <strong class="source-inline">private</strong> methods. This means that, you can explicitly mark a method in an interface as <strong class="source-inline">public</strong> or <strong class="source-inline">private</strong>. However, if you do <em class="italic">not</em> specify any access modifier, <strong class="source-inline">public</strong> is <span class="No-Break">the default.</span></p>
			<p>What about their abstract nature? Well, any method that is <em class="italic">not</em> denoted as <strong class="source-inline">static</strong>, <strong class="source-inline">default</strong>, or <strong class="source-inline">private</strong> is still <strong class="source-inline">abstract</strong> by default. <span class="No-Break"><em class="italic">Figure 10</em></span><em class="italic">.1</em> <span class="No-Break">encapsulates this:</span></p>
			<div>
				<div id="_idContainer157" class="IMG---Figure">
					<img src="image/B19793_10_1.jpg" alt="Figure 10.1 – Abstract methods in an interface"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.1 – Abstract methods in an interface</p>
			<p>In this figure, we can see that the <strong class="source-inline">m2()</strong> method is <strong class="source-inline">public</strong> and <strong class="source-inline">abstract</strong>, even though none of those keywords <a id="_idIndexMarker753"/>are explicitly coded. The only other valid access <a id="_idIndexMarker754"/>modifier is <strong class="source-inline">private</strong>, as shown when declaring <strong class="source-inline">m3()</strong> on line 6. The fact that <strong class="source-inline">m4()</strong> does not compile (line 7) demonstrates that <strong class="source-inline">protected</strong> is not a valid access modifier on <span class="No-Break">interface methods.</span></p>
			<p>Can we declare variables in an interface? Yes, we can. Let’s discuss <span class="No-Break">them now.</span></p>
			<h2 id="_idParaDest-255"><a id="_idTextAnchor255"/>Interface constants</h2>
			<p>Any variables <a id="_idIndexMarker755"/>specified in an interface are <strong class="source-inline">public</strong>, <strong class="source-inline">static</strong>, and <strong class="source-inline">final</strong> by default. In effect, they are constants, and thus, their initial values cannot be changed. By placing these constants in the interface, any class implementing the interface has access to them (via inheritance), but they are read-only. <span class="No-Break"><em class="italic">Figure 10</em></span><em class="italic">.2</em> shows some <span class="No-Break">interface constants:</span></p>
			<div>
				<div id="_idContainer158" class="IMG---Figure">
					<img src="image/B19793_10_2.jpg" alt="Figure 10.2 – Interface constants"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.2 – Interface constants</p>
			<p>In the preceding figure, we have two variables, namely <strong class="source-inline">VALUE1</strong> and <strong class="source-inline">VALUE2</strong>. Both are constants. <strong class="source-inline">VALUE1</strong> states explicitly that it is <strong class="source-inline">public</strong>, <strong class="source-inline">static</strong>, and <strong class="source-inline">final</strong>, whereas <strong class="source-inline">VALUE2</strong> does the same implicitly (no keywords <span class="No-Break">are used).</span></p>
			<p>Now, let’s look at an <a id="_idIndexMarker756"/>example where a class implements <span class="No-Break">an interface.</span></p>
			<p><span class="No-Break"><em class="italic">Figure 10</em></span><em class="italic">.3</em> represents a class implementing <span class="No-Break">an interface:</span></p>
			<div>
				<div id="_idContainer159" class="IMG---Figure">
					<img src="image/B19793_10_3.jpg" alt="Figure 10.3 – A class implementing an interface"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.3 – A class implementing an interface</p>
			<p>In this figure, lines 3-6 represent an interface called <strong class="source-inline">Moveable</strong> that declares a constant, <strong class="source-inline">HOW</strong>, and a method, <strong class="source-inline">move()</strong>. The <strong class="source-inline">Dog</strong> class on line 7 declares that it implements <strong class="source-inline">Moveable</strong>. Therefore, since <strong class="source-inline">Dog</strong> is a concrete, non-abstract class, it must provide an implementation <span class="No-Break">for </span><span class="No-Break"><strong class="source-inline">move()</strong></span><span class="No-Break">.</span></p>
			<p>As we know, interface methods are <strong class="source-inline">public</strong> by default. However, this is not the case for classes. In classes, methods are package-private by default; which means, if you do not provide an access modifier on a method in a class, the method is package-private. Therefore, when overriding an interface method in a class, ensure that the method is <strong class="source-inline">public</strong>. As <strong class="source-inline">package-private</strong> (line 9) is weaker than <strong class="source-inline">public</strong> (line 5), we get a compiler error – hence this line is commented out. Line 11 shows that <strong class="source-inline">move()</strong> must be explicitly declared <strong class="source-inline">public</strong> <span class="No-Break">in </span><span class="No-Break"><strong class="source-inline">Dog</strong></span><span class="No-Break">.</span></p>
			<p>Line 15 shows that <strong class="source-inline">HOW</strong>, declared on line 4, is a constant. If uncommented, line 15 gives a compiler error as constants, once assigned a value, <span class="No-Break">cannot change.</span></p>
			<p>Lines 16 and 17 demonstrate both ways we can access the <strong class="source-inline">HOW</strong> constant – either by prepending it with the interface name (line 16) or directly (<span class="No-Break">line 17).</span></p>
			<p>Line 19 shows that once inside a <strong class="source-inline">static</strong> method, which <strong class="source-inline">main()</strong> is, you cannot directly access an instance method, which <strong class="source-inline">move()</strong> is. This is because instance methods are secretly passed a reference to <a id="_idIndexMarker757"/>the (object) instance responsible for calling it, namely the <strong class="source-inline">this</strong> reference. Since <strong class="source-inline">static</strong> methods relate to the class and not a specific instance of the class, there is no <strong class="source-inline">this</strong> reference available in <strong class="source-inline">static</strong> methods. Thus, as per line 20, we need to create an instance and then use that instance to <span class="No-Break">invoke </span><span class="No-Break"><strong class="source-inline">move()</strong></span><span class="No-Break">.</span></p>
			<p>When we run this program, lines 16 and 17 both output the value of the <strong class="source-inline">walk</strong> constant. Line 20 outputs <strong class="source-inline">Dog::move()</strong>, the output from the <strong class="source-inline">Dog</strong> implementation of <strong class="source-inline">move()</strong> (<span class="No-Break">line 12).</span></p>
			<p class="callout-heading">Note</p>
			<p class="callout">Since Java 8, code is allowed in <strong class="source-inline">default</strong> methods. As <strong class="source-inline">default</strong> methods are inheritable, the compiler must step in to prevent multiple inheritance in interfaces from causing an issue. We will return to this when we discuss <strong class="source-inline">default</strong> methods <span class="No-Break">in interfaces.</span></p>
			<p>Now, let’s look at multiple <span class="No-Break">interface inheritance.</span></p>
			<h2 id="_idParaDest-256"><a id="_idTextAnchor256"/>Multiple interface inheritance</h2>
			<p>Unlike classes, where <a id="_idIndexMarker758"/>multiple inheritance is prohibited in Java, multiple inheritance is allowed in interfaces. Note that the issue with multiple class <a id="_idIndexMarker759"/>inheritance is that <em class="italic">if</em> multiple <em class="italic">class</em> inheritance was allowed, you could potentially inherit two distinct implementations for the <span class="No-Break">same method.</span></p>
			<p><span class="No-Break"><em class="italic">Figure 10</em></span><em class="italic">.4</em> shows<a id="_idIndexMarker760"/> an <a id="_idIndexMarker761"/>example of multiple <span class="No-Break">interface inheritance:</span></p>
			<div>
				<div id="_idContainer160" class="IMG---Figure">
					<img src="image/B19793_10_4.jpg" alt="Figure 10.4 – Multiple interface inheritance"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.4 – Multiple interface inheritance</p>
			<p>In this figure, the <strong class="source-inline">MoveableObject</strong> interface on line 2 is an interface with no methods at all. This is known as a tagging interface. A tagging interface is used for type information using <strong class="source-inline">instanceof</strong>. For example, if you wanted to know if an object is an instance of a class that implements <strong class="source-inline">MoveableObject</strong>, you would code <span class="No-Break">the following:</span></p>
			<pre class="source-code">
if (objectRef instanceof MoveableObject) {}</pre>			<p>Lines 3-5 define an interface called <strong class="source-inline">Spherical</strong>. At this point we could simply define a class that directly implements both of these interfaces <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
<strong class="source-inline">class BallGame implements MoveableObject, Spherical{</strong><strong class="source-inline">     @Override doSphericalThings(){}</strong>
<strong class="source-inline">}</strong></pre>
			<p>Line 6 is interesting – we <a id="_idIndexMarker762"/>can define an interface (<strong class="source-inline">Bounceable</strong> in this instance) that <strong class="source-inline">extends</strong> (inherits) from <em class="italic">both</em> of the other interfaces, namely <strong class="source-inline">MoveableObject</strong> and <strong class="source-inline">Spherical</strong>. Therefore, <strong class="source-inline">Bounceable</strong> has two <strong class="source-inline">abstract</strong> methods: one it defined itself, called <strong class="source-inline">bounce()</strong>, and one it inherited from <strong class="source-inline">Spherical</strong>, <span class="No-Break">called </span><span class="No-Break"><strong class="source-inline">doSphericalThings()</strong></span><span class="No-Break">.</span></p>
			<p>Since the <strong class="source-inline">Volleyball</strong> class implements <strong class="source-inline">Bounceable</strong> (line 11), it must override both <strong class="source-inline">bounce()</strong> and <strong class="source-inline">doSphericalThings()</strong>. As <strong class="source-inline">Volleyball</strong> does this, <span class="No-Break">it compiles.</span></p>
			<p>Note that on line 17, the <strong class="source-inline">abstract</strong> class, <strong class="source-inline">Beachball</strong>, states that it implements <strong class="source-inline">Bounceable</strong> also. However, as <strong class="source-inline">Beachball</strong> is <strong class="source-inline">abstract</strong>, the “contract” does not have to be obeyed; meaning, <strong class="source-inline">Beachball</strong> is free to implement all, some, or none of the <strong class="source-inline">abstract</strong> <a id="_idIndexMarker763"/>methods in <strong class="source-inline">Bounceable</strong>. In this example, none of the <strong class="source-inline">abstract</strong> methods required by <strong class="source-inline">Bounceable</strong> were implemented <span class="No-Break">by </span><span class="No-Break"><strong class="source-inline">Beachball</strong></span><span class="No-Break">.</span></p>
			<p>Now that we understand the implication of <strong class="source-inline">abstract</strong> methods in interfaces for implementing classes, let’s examine two of the non-abstract methods in interfaces – the <strong class="source-inline">default</strong> and <span class="No-Break"><strong class="source-inline">static</strong></span><span class="No-Break"> methods.</span></p>
			<h1 id="_idParaDest-257"><a id="_idTextAnchor257"/>Examining default and static interface methods</h1>
			<p>Before Java 8, only <strong class="source-inline">abstract</strong> methods were allowed in interfaces. This meant that if you introduced a new <strong class="source-inline">abstract</strong> method <a id="_idIndexMarker764"/>to an existing interface, the classes that had already implemented that interface would break. This was inconvenient for not only Java developers but also the designers <span class="No-Break">of Java.</span></p>
			<p>This all changed in Java 8, with<a id="_idIndexMarker765"/> the introduction of both <strong class="source-inline">default</strong> and <strong class="source-inline">static</strong> methods. One of the primary drivers for introducing <strong class="source-inline">default</strong> methods was to be able to introduce code into the interface and not break the existing client base. This maintained backward compatibility. In addition, this new code is automatically available to clients implementing <span class="No-Break">that interface.</span></p>
			<p>A primary driver for the<a id="_idIndexMarker766"/> introduction of <strong class="source-inline">static</strong> methods was to keep utility code local to the interface rather than having it in a separate class, which was the case before <span class="No-Break">their introduction.</span></p>
			<p>Let’s discuss them in turn, starting with <span class="No-Break"><strong class="source-inline">default</strong></span><span class="No-Break"> methods.</span></p>
			<h2 id="_idParaDest-258"><a id="_idTextAnchor258"/>‘default’ interface methods</h2>
			<p>An interface uses<a id="_idIndexMarker767"/> the <strong class="source-inline">default</strong> keyword to mark a method as <a id="_idIndexMarker768"/>inheritable by implementing classes. As already stated, if you do not specify an access modifier, they are <strong class="source-inline">public</strong> by default (pardon the pun!). Default methods must have an implementation - a set of curly braces must be present (even if they are empty braces). Classes that implement interfaces inherit any <strong class="source-inline">default</strong> methods. These classes may override the inherited version but this is <span class="No-Break">not necessary.</span></p>
			<p>Let’s look at some <span class="No-Break">example code:</span></p>
			<div>
				<div id="_idContainer161" class="IMG---Figure">
					<img src="image/B19793_10_5.jpg" alt="Figure 10.5 – Interface default methods"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.5 – Interface default methods</p>
			<p>In this figure, we<a id="_idIndexMarker769"/> have an <strong class="source-inline">interface</strong> called <strong class="source-inline">Moveable</strong> (lines 3-8). If line 4 was uncommented, it would not compile since <strong class="source-inline">default</strong> (or <strong class="source-inline">static</strong>) interface methods must have code <a id="_idIndexMarker770"/>bodies. Line 5 defines a <strong class="source-inline">default</strong> method called <strong class="source-inline">move()</strong>. As there are no <strong class="source-inline">abstract</strong> methods in <strong class="source-inline">Moveable</strong>, classes implementing <strong class="source-inline">Moveable</strong> are not required to provide any <span class="No-Break">particular methods.</span></p>
			<p>The <strong class="source-inline">Cheetah</strong> class (lines 9-14) implements <strong class="source-inline">Moveable</strong> and overrides <strong class="source-inline">move()</strong>. The <strong class="source-inline">Elephant</strong> class (line 15) implements <strong class="source-inline">Moveable</strong> also but does not <span class="No-Break">override </span><span class="No-Break"><strong class="source-inline">move()</strong></span><span class="No-Break">.</span></p>
			<p>Thus, <strong class="source-inline">Cheetah</strong> objects will have a custom <strong class="source-inline">move()</strong> implementation, whereas <strong class="source-inline">Elephant</strong> objects will use the version inherited <span class="No-Break">from </span><span class="No-Break"><strong class="source-inline">Moveable</strong></span><span class="No-Break">.</span></p>
			<p>Line 20 shows that, as with <strong class="source-inline">abstract</strong> classes, you cannot <strong class="source-inline">new</strong> an <span class="No-Break">interface type.</span></p>
			<p>Line 21 creates a <strong class="source-inline">Cheetah</strong> object referenced by a <strong class="source-inline">Moveable</strong> reference, namely <strong class="source-inline">cheetah</strong>. This<a id="_idIndexMarker771"/> is perfectly okay for two reasons. Firstly, references can be of the <strong class="source-inline">interface</strong> type and in <a id="_idIndexMarker772"/>many cases are. Secondly, this will compile so long as the object type implements the interface type, either directly (as is the case here) or indirectly (by inheriting from a class that implements the interface for you). Since the <strong class="source-inline">Cheetah</strong> class implements <strong class="source-inline">Moveable</strong>, all <span class="No-Break">is well.</span></p>
			<p>Line 22 executes the <strong class="source-inline">move()</strong> method from <strong class="source-inline">Cheetah</strong> polymorphically, resulting in <strong class="source-inline">Moving very fast!</strong> being output to <span class="No-Break">the screen.</span></p>
			<p>Line 23 creates an <strong class="source-inline">Elephant</strong> object referenced by a <strong class="source-inline">Moveable</strong> reference, namely <strong class="source-inline">elephant</strong>. Since <strong class="source-inline">Elephant</strong> implements <strong class="source-inline">Moveable</strong>, this <span class="No-Break">is ok.</span></p>
			<p>Line 24 is interesting. Since <strong class="source-inline">Elephant</strong> does not provide a custom version of <strong class="source-inline">move()</strong>, the <strong class="source-inline">default</strong> one from <strong class="source-inline">Moveable</strong> (which <strong class="source-inline">Elephant</strong> implements) is used. Thus, <strong class="source-inline">Moving</strong> is output to <span class="No-Break">the screen.</span></p>
			<p>Now, let’s discuss <strong class="source-inline">static</strong> <span class="No-Break">interface methods.</span></p>
			<h2 id="_idParaDest-259"><a id="_idTextAnchor259"/>‘static’ interface methods</h2>
			<p>An interface uses<a id="_idIndexMarker773"/> the <strong class="source-inline">static</strong> keyword to mark a method as a utility method. As with <strong class="source-inline">default</strong> methods, <strong class="source-inline">static</strong> methods <a id="_idIndexMarker774"/>are <strong class="source-inline">public</strong> by default. Similarly, as with <strong class="source-inline">default</strong> methods, <strong class="source-inline">static</strong> methods must have an implementation. However, classes that implement interfaces do not inherit <strong class="source-inline">static</strong> methods. To access a <strong class="source-inline">static</strong> method, you must use the <span class="No-Break"><strong class="source-inline">InterfaceName.staticMethodName()</strong></span><span class="No-Break"> syntax.</span></p>
			<p>Let’s look at an example in terms <span class="No-Break">of code:</span></p>
			<div>
				<div id="_idContainer162" class="IMG---Figure">
					<img src="image/B19793_10_6.jpg" alt="Figure 10.6 – Interface static methods"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.6 – Interface static methods</p>
			<p>In the <a id="_idIndexMarker775"/>preceding<a id="_idIndexMarker776"/> figure, we have an interface, <strong class="source-inline">I</strong>, that has a <strong class="source-inline">static</strong> method called <strong class="source-inline">m1()</strong> on line 5. Note that line 4 is commented out because, as with <strong class="source-inline">default</strong> methods, the code body must be present for <strong class="source-inline">static</strong> <span class="No-Break">methods also.</span></p>
			<p>The <strong class="source-inline">TestStaticMethods</strong> class implements the <strong class="source-inline">I</strong> interface. As there are no <strong class="source-inline">abstract</strong> methods in the interface, no particular methods are implemented. Line 9 shows the incorrect syntax to use and thus generates a compiler error. Line 10 shows the correct syntax to use and outputs <strong class="source-inline">3</strong> <span class="No-Break">when run.</span></p>
			<p>Earlier, we referred to multiple interface inheritance having a potential issue regarding <strong class="source-inline">default</strong> methods. Let’s explore <span class="No-Break">that now.</span></p>
			<h2 id="_idParaDest-260"><a id="_idTextAnchor260"/>Multiple interface inheritance</h2>
			<p>The Diamond of Death (<a href="https://en.wikipedia.org/wiki/Multiple_inheritance#:~:text=The%20”diamond%20problem”%20(sometimes,from%20both%20B%20and%20C">https://en.wikipedia.org/wiki/Multiple_inheritance#:~:text=The%20”diamond%20problem”%20(sometimes,from%20both%20B%20and%20C</a>) arises <a id="_idIndexMarker777"/>when<a id="_idIndexMarker778"/> a class finds that it has inherited two methods of the same name; which one should it work with? This was a concern in C++, where multiple-class inheritance is allowed and was an influencing factor in prohibiting multiple-class inheritance <span class="No-Break">in Java.</span></p>
			<p>However, Java has always allowed a class to implement multiple interfaces. However, now that Java 8 allows <strong class="source-inline">default</strong> methods, which have code bodies that are inheritable, is it not possible for Java 8 to encounter a “Diamond of Death” scenario? Couldn’t a class<a id="_idIndexMarker779"/> implement two (or more) interfaces that have the same <strong class="source-inline">default</strong> methods? What happens then? The good news is that the compiler steps in and forces your class to override the “offending” <span class="No-Break"><strong class="source-inline">default</strong></span><span class="No-Break"> method.</span></p>
			<p>So, that just leaves the question, what if we wanted to access each of the <strong class="source-inline">default</strong> methods? For example, let’s assume we have a <strong class="source-inline">default</strong> method called <strong class="source-inline">foo()</strong> in interface <strong class="source-inline">A</strong> and a <strong class="source-inline">default</strong> method called <strong class="source-inline">foo()</strong> in interface  <strong class="source-inline">B</strong>. What if, in our class, we wanted to execute <a id="_idIndexMarker780"/>the three different versions of <strong class="source-inline">foo()</strong> – the one from <strong class="source-inline">A</strong>, the one from <strong class="source-inline">B</strong>, and the one from our class that the compiler forced us <span class="No-Break">to create?</span></p>
			<p><span class="No-Break"><em class="italic">Figure 10</em></span><em class="italic">.7</em> shows how to do this <span class="No-Break">in code:</span></p>
			<div>
				<div id="_idContainer163" class="IMG---Figure">
					<img src="image/B19793_10_7.jpg" alt="Figure 10.7 – Accessing multiple default code implementations"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.7 – Accessing multiple default code implementations</p>
			<p>In this figure, interface <strong class="source-inline">A</strong> defines its <strong class="source-inline">foo()</strong> method on line 4, whereas interface <strong class="source-inline">B</strong> defines its <strong class="source-inline">foo()</strong> method on line 7. The <strong class="source-inline">TestMultipleInheritance</strong> class implements both <strong class="source-inline">A</strong> and <strong class="source-inline">B</strong>. As there is <strong class="source-inline">foo()</strong> code coming from both <strong class="source-inline">A</strong> and <strong class="source-inline">B</strong>, the compiler has to step in to prevent the “Diamond of Death.” Thus, the <strong class="source-inline">foo()</strong> method in <strong class="source-inline">TestMultipleInheritance</strong> (lines 11-16) is mandatory; otherwise, the code will not compile. As <strong class="source-inline">default</strong> methods are instance methods, when we override the interface version of <strong class="source-inline">foo()</strong>, we must ensure it <span class="No-Break">is non-static.</span></p>
			<p>Line 13 shows the syntax to use to invoke <strong class="source-inline">foo()</strong> from <strong class="source-inline">A</strong>. This syntax is <strong class="source-inline">InterfaceName.super.methodName()</strong>. So in this example, it is <strong class="source-inline">A.super.foo()</strong>. Since <strong class="source-inline">super</strong> is used, the methods must be instance methods. This is because only instance methods have access to (the parent instance using) the <strong class="source-inline">super</strong> reference (and to the current instance using the <span class="No-Break"><strong class="source-inline">this</strong></span><span class="No-Break"> reference).</span></p>
			<p>Similarly, line 15 invokes <strong class="source-inline">foo()</strong> from <strong class="source-inline">B</strong> <span class="No-Break">using </span><span class="No-Break"><strong class="source-inline">B.super.foo()</strong></span><span class="No-Break">.</span></p>
			<p>Note that line 14 does <a id="_idIndexMarker781"/>not compile and is commented out as a result. This is because, with the <strong class="source-inline">A.foo()</strong> syntax, the compiler is looking for a <strong class="source-inline">static</strong> method named <strong class="source-inline">foo()</strong> in interface <strong class="source-inline">A</strong>. However, the <strong class="source-inline">foo()</strong> method in <strong class="source-inline">A</strong> is non-static (<span class="No-Break">line 4).</span></p>
			<p>Interestingly, line 18 fails to compile. This is because, since <strong class="source-inline">main()</strong> is a <strong class="source-inline">static</strong> method (a <strong class="source-inline">static</strong> context), we cannot <span class="No-Break">use </span><span class="No-Break"><strong class="source-inline">super</strong></span><span class="No-Break">.</span></p>
			<p>Line 19 shows how <a id="_idIndexMarker782"/>to execute the custom <strong class="source-inline">foo()</strong> method in the class itself. Recall that we need an instance when calling a non-static (instance) method from a <strong class="source-inline">static</strong> method, hence the <span class="No-Break"><strong class="source-inline">new TestMultipleInheritance()</strong></span><span class="No-Break">.</span></p>
			<p>With that, we’ve covered two types of non-abstract methods, namely <strong class="source-inline">default</strong> and <strong class="source-inline">static</strong> methods. There is one more: <strong class="source-inline">private</strong> <span class="No-Break">interface methods.</span></p>
			<h1 id="_idParaDest-261"><a id="_idTextAnchor261"/>Explaining ‘private’ interface methods</h1>
			<p>Interfaces <a id="_idIndexMarker783"/>can also have <strong class="source-inline">private</strong> methods with code implementations. They<a id="_idIndexMarker784"/> were introduced to reduce code duplication and improve encapsulation. These <strong class="source-inline">private</strong> methods can be both <strong class="source-inline">static</strong> and non-static. As they are <strong class="source-inline">private</strong>, they can only be accessed from within the interface. As with classes, you cannot access a non-static method from a <span class="No-Break"><strong class="source-inline">static</strong></span><span class="No-Break"> method.</span></p>
			<p>Let’s have a look at an <a id="_idIndexMarker785"/>example in code. Firstly, we will examine code that has code duplication. <span class="No-Break"><em class="italic">Figure 10</em></span><em class="italic">.8</em> shows such <span class="No-Break">an interface:</span></p>
			<div>
				<div id="_idContainer164" class="IMG---Figure">
					<img src="image/B19793_10_8.jpg" alt="Figure 10.8 – An interface with code duplication"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.8 – An interface with code duplication</p>
			<p>As this figure <a id="_idIndexMarker786"/>shows, lines 6, 11, and 16 are the same. In addition, lines 8, 13, and 18 are also the same. We will refactor this interface to address this code duplication by using <strong class="source-inline">private</strong> methods. <span class="No-Break"><em class="italic">Figure 10</em></span><em class="italic">.9</em> shows the code <span class="No-Break">for this:</span></p>
			<div>
				<div id="_idContainer165" class="IMG---Figure">
					<img src="image/B19793_10_9.jpg" alt="Figure 10.9 – An interface with private methods"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.9 – An interface with private methods</p>
			<p>In this figure, we <a id="_idIndexMarker787"/>have a <strong class="source-inline">private</strong> <strong class="source-inline">static</strong> method called <strong class="source-inline">hit(String)</strong> that accepts the stroke (shot) to be played. The first thing to notice is that, as with <strong class="source-inline">default</strong> and <strong class="source-inline">static</strong> methods, a code body is expected and <span class="No-Break">is present.</span></p>
			<p>Line 25, which was replicated three times in <span class="No-Break"><em class="italic">Figure 10</em></span><em class="italic">.8</em>, now appears only once. The same is true for line 27. Line 26 outputs the stroke being played. Note that <strong class="source-inline">hit(String)</strong> is <strong class="source-inline">static</strong>. This enables the method to be invoked from <strong class="source-inline">static</strong> methods, such as <strong class="source-inline">forehand()</strong> (<span class="No-Break">line 32).</span></p>
			<p>There is a mix of <strong class="source-inline">default</strong>, <strong class="source-inline">static</strong>, and <strong class="source-inline">private</strong> methods to facilitate further discussion. Firstly, line 29 is a <strong class="source-inline">default</strong> method that invokes the <strong class="source-inline">private</strong> <strong class="source-inline">hit(String)</strong> method, which passes in the <strong class="source-inline">backhand</strong> string. Note that <strong class="source-inline">default</strong> methods cannot also be <a id="_idIndexMarker788"/>marked <strong class="source-inline">private</strong> as they have opposite semantics – <strong class="source-inline">private</strong> methods, as with classes, are not inherited, whereas <strong class="source-inline">default</strong> methods <span class="No-Break">are inherited.</span></p>
			<p>Secondly, the <strong class="source-inline">forehand()</strong> method (lines 30-33) represents invoking <strong class="source-inline">hit(String)</strong> from a <strong class="source-inline">static</strong> context (line 32), passing in <strong class="source-inline">forehand</strong>. Line 31 represents an attempt to call a non-static <strong class="source-inline">private</strong> method called <strong class="source-inline">smash()</strong> from a <strong class="source-inline">static</strong> method. As with classes, this is not allowed and has been commented out as <span class="No-Break">a result.</span></p>
			<p>Lastly, we <a id="_idIndexMarker789"/>can call <strong class="source-inline">private</strong> methods from other <strong class="source-inline">private</strong> methods (<span class="No-Break">line 34).</span></p>
			<p>Line 35 is a reminder that methods that are not marked <strong class="source-inline">default</strong>, <strong class="source-inline">static</strong>, or <strong class="source-inline">private</strong> are <strong class="source-inline">abstract</strong> by default, so no code <span class="No-Break">is permitted.</span></p>
			<p>Let’s examine how to use the <strong class="source-inline">EfficientTennis</strong> interface from a class that <span class="No-Break">implements it:</span></p>
			<div>
				<div id="_idContainer166" class="IMG---Figure">
					<img src="image/B19793_10_10.jpg" alt="Figure 10.10 – An interface with private methods"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.10 – An interface with private methods</p>
			<p>The first thing to <a id="_idIndexMarker790"/>notice is that the <strong class="source-inline">SportTest</strong> class has no methods to implement. This is because <strong class="source-inline">EfficientTennis</strong> does not declare any <strong class="source-inline">abstract</strong> methods, only <strong class="source-inline">default</strong>, <strong class="source-inline">static</strong>, and <span class="No-Break"><strong class="source-inline">private</strong></span><span class="No-Break"> ones.</span></p>
			<p>Line 41 executes the <strong class="source-inline">default</strong> method called <strong class="source-inline">backhand()</strong> and line 42 executes the <strong class="source-inline">static</strong> method called <strong class="source-inline">forehand()</strong>. Note that line 43 attempts to access the <strong class="source-inline">private</strong> method called <strong class="source-inline">hit(String)</strong>. As the method is <strong class="source-inline">private</strong> to the interface, this is not allowed and, as a result, line 43 is commented out. This demonstrates that <strong class="source-inline">hit(String)</strong> is encapsulated from the outside world. In effect, <strong class="source-inline">SportTest</strong> does not know of and is therefore not dependent upon the <strong class="source-inline">hit(String)</strong> method. If <strong class="source-inline">hit(String)</strong> is changed or even deleted, provided that the <strong class="source-inline">backhand()</strong> and <strong class="source-inline">forehand()</strong> methods still work, <strong class="source-inline">SportTest</strong> will not <span class="No-Break">be impacted.</span></p>
			<p>Now, let’s move on to our last topic: <span class="No-Break"><strong class="source-inline">sealed</strong></span><span class="No-Break"> interfaces.</span></p>
			<h1 id="_idParaDest-262"><a id="_idTextAnchor262"/>Exploring sealed interfaces</h1>
			<p>In <a href="B19793_09.xhtml#_idTextAnchor205"><span class="No-Break"><em class="italic">Chapter 9</em></span></a>, we<a id="_idIndexMarker791"/> learned that <strong class="source-inline">sealed</strong> classes enable us to scope our inheritance hierarchy by specifying <a id="_idIndexMarker792"/>which classes can subtype our class. We used both the <strong class="source-inline">sealed</strong> and <strong class="source-inline">permits</strong> keywords as a pair to do this. Once a class has been sealed, each subclass of that class must be <strong class="source-inline">sealed</strong>, <strong class="source-inline">non-sealed</strong>, or <strong class="source-inline">final</strong> – that is, we continue the sealed hierarchy (<strong class="source-inline">sealed</strong>), end the sealed hierarchy (<strong class="source-inline">non-sealed</strong>), or end the hierarchy <span class="No-Break">altogether (</span><span class="No-Break"><strong class="source-inline">final</strong></span><span class="No-Break">).</span></p>
			<p>It is also possible to seal interfaces. We will use the example from <a href="B19793_09.xhtml#_idTextAnchor205"><span class="No-Break"><em class="italic">Chapter 9</em></span></a> with some small changes. Firstly, <span class="No-Break"><em class="italic">Figure 10</em></span><em class="italic">.11</em> shows the relevant UML diagram, which will help explain <span class="No-Break">the code:</span></p>
			<div>
				<div id="_idContainer167" class="IMG---Figure">
					<img src="image/B19793_10_11.jpg" alt="Figure 10.11 – Sealed interface UML diagram"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.11 – Sealed interface UML diagram</p>
			<p>In this figure, we <a id="_idIndexMarker793"/>have an <a id="_idIndexMarker794"/>interface, indicated by <strong class="source-inline">&lt;&lt;interface&gt;&gt;</strong>, called <strong class="source-inline">Driveable</strong>. In UML, to specify that a class implements an interface, the <strong class="source-inline">&lt;&lt;realize&gt;&gt;</strong> keyword is used (plus the dashed line with an arrow referring to <span class="No-Break">the interface).</span></p>
			<p>In this example, we are going to scope the hierarchy as follows: the only class allowed to implement <strong class="source-inline">Driveable</strong> is <strong class="source-inline">Vehicle</strong>, the only <strong class="source-inline">Vehicle</strong> subclass allowed is <strong class="source-inline">Car</strong>, and the only subclass of <strong class="source-inline">Car</strong> allowed <span class="No-Break">is </span><span class="No-Break"><strong class="source-inline">Saloon</strong></span><span class="No-Break">.</span></p>
			<p>When we get to <strong class="source-inline">Saloon</strong>, we want to open up the hierarchy again – unseal it, if you like. This allows <strong class="source-inline">Ford</strong> and <strong class="source-inline">Volvo</strong> to extend from <strong class="source-inline">Saloon</strong>. Note that this is for demonstration <a id="_idIndexMarker795"/>purposes only as any class can now <span class="No-Break">subclass </span><span class="No-Break"><strong class="source-inline">Saloon</strong></span><span class="No-Break">.</span></p>
			<p>The <strong class="source-inline">Chair</strong>, <strong class="source-inline">Table</strong>, and <strong class="source-inline">Window</strong> classes are all unrelated and not part of the <span class="No-Break">sealed hierarchy.</span></p>
			<p><span class="No-Break"><em class="italic">Figure 10</em></span><em class="italic">.12</em> shows some code where a sealed interface <span class="No-Break">is used:</span></p>
			<div>
				<div id="_idContainer168" class="IMG---Figure">
					<img src="image/B19793_10_12.jpg" alt="Figure 10.12 – Sealed interface code"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.12 – Sealed interface code</p>
			<p>The important lines in this figure are lines 3-4. Line 3 states that the <strong class="source-inline">Driveable</strong> interface is <strong class="source-inline">sealed</strong> and that <a id="_idIndexMarker796"/>only one class is allowed to implement it, namely <strong class="source-inline">Vehicle</strong>. <strong class="source-inline">Vehicle</strong> must now implement <strong class="source-inline">Driveable</strong>; otherwise, the code will fail to compile. <strong class="source-inline">Vehicle</strong> does implement <strong class="source-inline">Driveable</strong> (line 4), so all is well. In addition, <strong class="source-inline">Vehicle</strong> is <strong class="source-inline">sealed</strong> and the only subclass permitted <span class="No-Break">is </span><span class="No-Break"><strong class="source-inline">Car</strong></span><span class="No-Break">.</span></p>
			<p>Line 6 states that <strong class="source-inline">Car</strong> subclasses <strong class="source-inline">Vehicle</strong> and that <strong class="source-inline">Saloon</strong> is the only <span class="No-Break">subtype allowed.</span></p>
			<p>Line 7 states that <strong class="source-inline">Saloon</strong> is, as expected, a subclass of <strong class="source-inline">Car</strong>. The fact that <strong class="source-inline">Saloon</strong> is <strong class="source-inline">non-sealed</strong> opens up the hierarchy and enables <strong class="source-inline">Volvo</strong> (line 8) and <strong class="source-inline">Ford</strong> (line 9) to extend <span class="No-Break">from </span><span class="No-Break"><strong class="source-inline">Saloon</strong></span><span class="No-Break">.</span></p>
			<p>Lines 11-13 all fail <a id="_idIndexMarker797"/>to compile. Line 11 reminds us that <strong class="source-inline">Vehicle</strong> permits <strong class="source-inline">Car</strong> subtypes only. Similarly, line 12 <a id="_idIndexMarker798"/>reminds us that <strong class="source-inline">Car</strong> permits <strong class="source-inline">Saloon</strong> subtypes only. Line 13 shows, as per line 3, that the only class that can implement <strong class="source-inline">Driveable</strong> <span class="No-Break">is </span><span class="No-Break"><strong class="source-inline">Vehicle</strong></span><span class="No-Break">.</span></p>
			<p>That completes our discussion on interfaces and <strong class="source-inline">abstract</strong> classes. Now, let’s apply what we <span class="No-Break">have learned!</span></p>
			<h1 id="_idParaDest-263"><a id="_idTextAnchor263"/>Exercises</h1>
			<p>With interfaces and <strong class="source-inline">abstract</strong> classes, we can improve our application structure even further! Take a look at the following exercises to test <span class="No-Break">your knowledge:</span></p>
			<ol>
				<li>Dinosaurs, no matter the exact species, have common behaviors such as eating and moving. Define an interface that encapsulates these behaviors, come up with a logical name for it, and implement it in the <span class="No-Break"><strong class="source-inline">Dinosaur</strong></span><span class="No-Break"> class.</span></li>
				<li>Our park uses different types of vehicles for different purposes. Design an <strong class="source-inline">abstract</strong> class called <strong class="source-inline">Vehicle</strong> and derive concrete classes such as <strong class="source-inline">Jeep</strong> and <strong class="source-inline">Helicopter</strong> <span class="No-Break">from it.</span></li>
				<li>Modify the <strong class="source-inline">Vehicle</strong> class so that it includes an <strong class="source-inline">abstract</strong> method called <strong class="source-inline">travel()</strong> that provides different implementations in <span class="No-Break">its subclasses.</span></li>
				<li>Make our <strong class="source-inline">Dinosaur</strong> class sortable by implementing the <strong class="source-inline">Comparable </strong>interface to compare dinosaurs based on <span class="No-Break">their age.</span></li>
				<li>Similarly, our employees also have common behaviors. Define a <strong class="source-inline">Worker</strong> interface with methods that represent these behaviors and implement it in the <span class="No-Break"><strong class="source-inline">Employee</strong></span><span class="No-Break"> class.</span></li>
				<li>Our dinosaurs are housed in different enclosures. Implement the <strong class="source-inline">List </strong>interface using <strong class="source-inline">ArrayList</strong> to manage dinosaurs for <span class="No-Break">an enclosure.</span></li>
				<li>Dinosaurs have different feeding behaviors based on their diet. Create <strong class="source-inline">Carnivore</strong> and <strong class="source-inline">Herbivore</strong> interfaces and implement them in the appropriate <span class="No-Break">dinosaur subclasses.</span></li>
			</ol>
			<h1 id="_idParaDest-264"><a id="_idTextAnchor264"/>Project – unified park management system</h1>
			<p>In this rather <a id="_idIndexMarker799"/>advanced project, you will elevate the Mesozoic Eden Park Manager application to the next level. You’ll do so by utilizing the classes you created earlier. You can continue to work on the previous project or start <span class="No-Break">from scratch.</span></p>
			<p>The enhanced system will implement polymorphism so that different types of dinosaurs and employees can be managed. This will increase the versatility and functionality of your park management, allowing for diverse dinosaur species and employee roles. The enhanced system should include <span class="No-Break">the following:</span></p>
			<ul>
				<li>The capability to manage various dinosaur species profiles, broadening the diversity of <span class="No-Break">your park</span></li>
				<li>The capacity to manage different types of employee profiles, such as veterinarians, guides, maintenance workers, and <span class="No-Break">security personnel</span></li>
				<li>All other features should also accommodate these new changes, including editing and removing profiles, tracking dinosaurs, managing employee schedules, managing guest admissions, and handling <span class="No-Break">special events</span></li>
			</ul>
			<p>Here’s a step-by-step plan to <span class="No-Break">achieve this:</span></p>
			<ol>
				<li><strong class="bold">Expand data structures</strong>: Extend your <strong class="source-inline">Dinosaur</strong> and <strong class="source-inline">Employee</strong> classes into various subclasses to represent different types of dinosaurs and employees. Make sure you use the principle <span class="No-Break">of polymorphism.</span></li>
				<li><strong class="bold">Enhance initialization</strong>: Upgrade your data initialization so that it supports multiple types of dinosaurs and employees. This might involve creating arrays or lists of <strong class="source-inline">Dinosaur</strong> and <strong class="source-inline">Employee</strong> objects, each of which could be an instance of <span class="No-Break">any subclass.</span></li>
				<li><strong class="bold">Update interaction</strong>: Adapt your interactive console-based interface so that it can handle the new types of dinosaurs and employees. You might need to add new options <span class="No-Break">or submenus.</span></li>
				<li><strong class="bold">Update menu creation</strong>: Your menu should now provide options for managing various types of dinosaurs and employees. Ensure each option corresponds to a particular function in <span class="No-Break">the program.</span></li>
				<li><strong class="bold">Handle actions</strong>: Each menu item should trigger a function that can now handle different types of dinosaurs and employees. For example, selecting the <strong class="source-inline">Manage Dinosaurs</strong> option could now trigger a function to add, remove, or edit profiles for any <span class="No-Break">dinosaur species.</span></li>
				<li><strong class="bold">Exit program</strong>: Provide an option for the user to exit <span class="No-Break">the program.</span></li>
			</ol>
			<p>Your starting <a id="_idIndexMarker800"/>code will be very similar to the code shown in the last two chapters. Some methods, such as <strong class="source-inline">manageDinosaurs()</strong> and <strong class="source-inline">manageEmployees()</strong>, will need to be updated and become a bit <span class="No-Break">more complex:</span></p>
			<pre class="source-code">
public void handleMenuChoice(int choice) {    switch (choice) {
        case 1:
            manageDinosaurs();  // This method now needs
              to handle different types of dinosaurs
            break;
        case 2:
            manageEmployees();  // This method now needs
              to handle different types of employees
            break;
        case 3:
            // manageTickets();
            break;
        case 4:
            // checkParkStatus();
            break;
        case 5:
            // handleSpecialEvents();
            break;
        case 6:
            System.out.println("Exiting...");
            System.exit(0);
    }
}</pre>
			<p>The <strong class="source-inline">manageDinosaurs()</strong>, <strong class="source-inline">manageEmployees()</strong>, <strong class="source-inline">manageTickets()</strong>, <strong class="source-inline">checkParkStatus()</strong>, and <strong class="source-inline">handleSpecialEvents()</strong> methods need to handle the <span class="No-Break">added</span><span class="No-Break"><a id="_idIndexMarker801"/></span><span class="No-Break"> complexity.</span></p>
			<h1 id="_idParaDest-265"><a id="_idTextAnchor265"/>Summary</h1>
			<p>We started this chapter by examining <strong class="source-inline">abstract</strong> classes. An <strong class="source-inline">abstract</strong> class has zero or more <strong class="source-inline">abstract</strong> methods. However, if any method is <strong class="source-inline">abstract</strong>, then the class must be <strong class="source-inline">abstract</strong>. While an <strong class="source-inline">abstract</strong> class cannot be instantiated, a reference can be of an <span class="No-Break"><strong class="source-inline">abstract</strong></span><span class="No-Break"> type.</span></p>
			<p>Before Java 8, interfaces consisted of only <strong class="source-inline">abstract</strong> methods (and constants). We started our discussion on interfaces at this point, where all the methods were <strong class="source-inline">abstract</strong>. While a class can only extend from one class, a class can implement many interfaces. This is one of the main reasons why interfaces were introduced – to be able to cast to more than one <span class="No-Break">base type.</span></p>
			<p>A class that implements an interface signs a “contract” to provide code for each of the <strong class="source-inline">abstract</strong> methods (if any) in the interface. If there is an <strong class="source-inline">abstract</strong> method in the interface and the concrete, non-abstract class does not provide code implementation for it, the compiler complains. Therefore, interfaces are a great way of guaranteeing that certain methods will be present in a class. Variables in an interface are constants by default. These constants are available to implementing classes, but are read-only. We noted that multiple interface inheritance, where an interface can inherit from several other interfaces, is allowed. This contrasts with classes, be they <strong class="source-inline">abstract</strong> or concrete, where multiple inheritance <span class="No-Break">is prohibited.</span></p>
			<p>In Java 8, <strong class="source-inline">default</strong> and <strong class="source-inline">static</strong> methods, both with code bodies, were introduced to interfaces. This was the first time code was allowed in interfaces. Regarding inheritance, <strong class="source-inline">default</strong> methods are inherited by implementing classes, whereas <strong class="source-inline">static</strong> methods are not. Thus, accessing both requires different syntaxes. As <strong class="source-inline">default</strong> methods are inherited, they can be overridden by implementing classes. Both types of methods, as with <strong class="source-inline">abstract</strong> methods, are <strong class="source-inline">public</strong> <span class="No-Break">by default.</span></p>
			<p>Next, we saw how the compiler prevents us from experiencing the “Diamond of Death.” This issue could arise when two interfaces have the same <strong class="source-inline">default</strong> method name. A class that implements these two interfaces is forced to provide a custom implementation to avoid ambiguity. This led nicely to the syntax (using <strong class="source-inline">super</strong>), which enables us the <strong class="source-inline">default</strong> methods in both interfaces and the custom (non-default) version in <span class="No-Break">the class.</span></p>
			<p>Java 9 introduced <strong class="source-inline">private</strong> interface methods, which also have code bodies. They were introduced to reduce code duplication and improve encapsulation. We detailed an example where we refactored code by introducing <strong class="source-inline">private</strong> <span class="No-Break">interface methods.</span></p>
			<p>We concluded this chapter by discussing <strong class="source-inline">sealed</strong> interfaces, which were introduced in Java 17. Much like <strong class="source-inline">sealed</strong> classes (<a href="B19793_09.xhtml#_idTextAnchor205"><span class="No-Break"><em class="italic">Chapter 9</em></span></a>), <strong class="source-inline">sealed</strong> interfaces enable us to scope the hierarchy – that is, when declaring a <strong class="source-inline">sealed</strong> interface, we specify the classes that are permitted to implement it. We presented a UML diagram and some code to explain this in <span class="No-Break">more detail.</span></p>
			<p>That completes our discussion on interfaces and <strong class="source-inline">abstract</strong> classes. In the next chapter, we will <span class="No-Break">cover exceptions.</span></p>
		</div>
	</body></html>