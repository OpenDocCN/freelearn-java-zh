<html><head></head><body>
		<div id="_idContainer073">
			<h1 id="_idParaDest-188"><em class="italic"><a id="_idTextAnchor187"/>Chapter 8</em>: Multithreading and Concurrent Processing</h1>
			<p>In this chapter, we will discuss ways to increase Java application performance by using workers (threads) that process data concurrently. We will explain the concept of Java threads and demonstrate their usage. We will also talk about the difference between parallel and concurrent processing and how to avoid unpredictable results caused by the concurrent modification of a shared resource.</p>
			<p>After finishing this chapter, you will be able to write code for multithreaded processing—creating and executing threads and using a pool of threads in parallel and concurrent cases.</p>
			<p>The following topics will be covered in this chapter:</p>
			<ul>
				<li>Thread versus process</li>
				<li>User thread versus daemon </li>
				<li>Extending the <strong class="source-inline">Thread</strong> class</li>
				<li>Implementing the <strong class="source-inline">Runnable</strong> interface</li>
				<li>Extending <strong class="source-inline">Thread</strong> versus implementing <strong class="source-inline">Runnable</strong></li>
				<li>Using a pool of threads</li>
				<li>Getting results from a thread</li>
				<li>Parallel versus concurrent processing</li>
				<li>Concurrent modification of the same resource</li>
			</ul>
			<h1 id="_idParaDest-189"><a id="_idTextAnchor188"/>Technical requirements</h1>
			<p>To be able to execute the code examples provided in this chapter, you will need the following:</p>
			<ul>
				<li>A computer with a Microsoft Windows, Apple macOS, or Linux operating system</li>
				<li>Java <strong class="bold">Standard Edition</strong> (<strong class="bold">SE</strong>) version 17 or later</li>
				<li>An <strong class="bold">integrated development environment</strong> (<strong class="bold">IDE</strong>) or your preferred code editor </li>
			</ul>
			<p>Instructions on how to set up a Java SE and IntelliJ IDEA editor were provided in <a href="B18388_01_ePub.xhtml#_idTextAnchor015"><em class="italic">Chapter 1</em></a>, <em class="italic">Getting Started with Java 17</em>. Files with code examples for this chapter are available on GitHub in the <a href="https://github.com/PacktPublishing/Learn-Java-17-Programming.git">https://github.com/PacktPublishing/Learn-Java-17-Programming.git</a> repository, in the <strong class="source-inline">examples/src/main/java/com/packt/learnjava/ch08_threads</strong> folder. </p>
			<h1 id="_idParaDest-190"><a id="_idTextAnchor189"/>Thread versus process</h1>
			<p>Java has two units<a id="_idIndexMarker967"/> of execution—a process<a id="_idIndexMarker968"/> and a thread. A <strong class="bold">process</strong> usually represents the whole <strong class="bold">Java virtual machine</strong> (<strong class="bold">JVM</strong>), although an application can create<a id="_idIndexMarker969"/> another process using <strong class="source-inline">java.lang.ProcessBuilder</strong>. But since the multi-process <a id="_idIndexMarker970"/>case is outside the scope of this book, we will focus on the second unit of execution—that is, a <strong class="bold">thread</strong>, which is similar to a process but less isolated from other threads<a id="_idIndexMarker971"/> and requires fewer resources for execution.</p>
			<p>A process can have many threads running<a id="_idIndexMarker972"/> and at least one thread called the <strong class="bold">main thread</strong>—the one that starts the application—which we use in every example. Threads can share resources, including memory and open files, which allows for better efficiency, but this comes at a price: a higher risk of unintended mutual interference, and even blocking of the execution. That is where programming skills and an understanding of concurrency techniques are required. </p>
			<h1 id="_idParaDest-191"><a id="_idTextAnchor190"/>User thread versus daemon</h1>
			<p>There is a particular<a id="_idIndexMarker973"/> kind of thread called<a id="_idIndexMarker974"/> a daemon.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">The word <em class="italic">daemon</em> has an ancient Greek origin, meaning a divinity or supernatural being of nature between gods and humans and an inner or attendant spirit or inspiring force.</p>
			<p>In computer science, the term <em class="italic">daemon</em> has more mundane usage and is applied to <em class="italic">a computer program that runs as a background process, rather than being under the direct control of an interactive user</em>. That is why there are the following two types of threads in Java:</p>
			<ul>
				<li>User thread (default) initiated by an application (the main thread is one such example)</li>
				<li>Daemon thread that works in the background in support of user-thread activity</li>
			</ul>
			<p>That is why all daemon threads exit immediately after the last user thread exits or are terminated by the JVM after an unhandled exception.</p>
			<h1 id="_idParaDest-192"><a id="_idTextAnchor191"/>Extending the Thread class</h1>
			<p>One way to create a thread<a id="_idIndexMarker975"/> is to extend the <strong class="source-inline">java.lang.Thread</strong> class and override its <strong class="source-inline">run()</strong> method. Here’s an example of this:</p>
			<pre class="source-code">class MyThread extends Thread {</pre>
			<pre class="source-code">    private String parameter;</pre>
			<pre class="source-code">    public MyThread(String parameter) {</pre>
			<pre class="source-code">        this.parameter = parameter;</pre>
			<pre class="source-code">    }</pre>
			<pre class="source-code">    public void run() {</pre>
			<pre class="source-code">        while(!"exit".equals(parameter)){</pre>
			<pre class="source-code">           System.out.println((isDaemon() ? "daemon" </pre>
			<pre class="source-code">              : "  user") + " thread " + this.getName() + </pre>
			<pre class="source-code">              "(id=" + this.getId() + ") parameter: " +</pre>
			<pre class="source-code">                                               parameter);</pre>
			<pre class="source-code">            pauseOneSecond();</pre>
			<pre class="source-code">        }</pre>
			<pre class="source-code">        System.out.println((isDaemon() ? "daemon" </pre>
			<pre class="source-code">              : "  user") + " thread " + this.getName() + </pre>
			<pre class="source-code">              "(id=" + this.getId() + ") parameter: " +</pre>
			<pre class="source-code">                                               parameter);</pre>
			<pre class="source-code">    }</pre>
			<pre class="source-code">    public void setParameter(String parameter) {</pre>
			<pre class="source-code">        this.parameter = parameter;</pre>
			<pre class="source-code">    }</pre>
			<pre class="source-code">}</pre>
			<p>If the <strong class="source-inline">run()</strong> method is not overridden, the thread does nothing. In our example, the thread prints its name and other properties<a id="_idIndexMarker976"/> every second, as long as the parameter is not equal to the <strong class="source-inline">"exit"</strong> string; otherwise, it exits. </p>
			<p>The <strong class="source-inline">pauseOneSecond()</strong> method looks like this:</p>
			<pre class="source-code">private static void pauseOneSecond(){</pre>
			<pre class="source-code">    try {</pre>
			<pre class="source-code">        TimeUnit.SECONDS.sleep(1);</pre>
			<pre class="source-code">    } catch (InterruptedException e) {</pre>
			<pre class="source-code">        e.printStackTrace();</pre>
			<pre class="source-code">    }</pre>
			<pre class="source-code">}</pre>
			<p>We can now use the <strong class="source-inline">MyThread</strong> class to run<a id="_idIndexMarker977"/> two threads—one user thread and one daemon thread, as follows:</p>
			<pre class="source-code">public static void main(String... args) {</pre>
			<pre class="source-code">    MyThread thr1 = new MyThread("One");</pre>
			<pre class="source-code">    thr1.start();</pre>
			<pre class="source-code">    MyThread thr2 = new MyThread("Two");</pre>
			<pre class="source-code">    thr2.setDaemon(true);</pre>
			<pre class="source-code">    thr2.start();</pre>
			<pre class="source-code">    pauseOneSecond();</pre>
			<pre class="source-code">    thr1.setParameter("exit");</pre>
			<pre class="source-code">    pauseOneSecond();</pre>
			<pre class="source-code">    System.out.println("Main thread exists");</pre>
			<pre class="source-code">}</pre>
			<p>As you can see, the main thread creates two other threads, pauses for one second, sets the <strong class="source-inline">exit</strong> parameter on the user thread, pauses another second, and finally exits (the <strong class="source-inline">main()</strong> method completes its execution).</p>
			<p>If we run the preceding code, we’ll see something like this (the <strong class="source-inline">id</strong> thread may be different in different operating systems):</p>
			<div>
				<div id="_idContainer061" class="IMG---Figure">
					<img src="image/B18388_Figure_8.1.jpg" alt=""/>
				</div>
			</div>
			<p>The preceding screenshot shows that the daemon thread exits automatically as soon as the last user thread (the main thread, in our example) exits.</p>
			<h1 id="_idParaDest-193"><a id="_idTextAnchor192"/>Implementing the Runnable interface</h1>
			<p>The second way to create<a id="_idIndexMarker978"/> a thread is to use a class that implements <strong class="source-inline">java.lang.Runnable</strong>. Here is an example of such a class that has almost exactly the same functionality as the <strong class="source-inline">MyThread</strong> class:</p>
			<pre class="source-code">class MyRunnable implements Runnable {</pre>
			<pre class="source-code">    private String parameter, name;</pre>
			<pre class="source-code">    public MyRunnable(String name) {</pre>
			<pre class="source-code">        this.name = name;</pre>
			<pre class="source-code">    }</pre>
			<pre class="source-code">    public void run() {</pre>
			<pre class="source-code">        while(!"exit".equals(parameter)){</pre>
			<pre class="source-code">            System.out.println("thread " + this.name + </pre>
			<pre class="source-code">                              ", parameter: " + parameter);</pre>
			<pre class="source-code">            pauseOneSecond();</pre>
			<pre class="source-code">        }</pre>
			<pre class="source-code">        System.out.println("thread " + this.name +</pre>
			<pre class="source-code">                              ", parameter: " + parameter);</pre>
			<pre class="source-code">    }</pre>
			<pre class="source-code">    public void setParameter(String parameter) {</pre>
			<pre class="source-code">        this.parameter = parameter;</pre>
			<pre class="source-code">    }</pre>
			<pre class="source-code">}</pre>
			<p>The difference is that there is no <strong class="source-inline">isDaemon()</strong>, <strong class="source-inline">getId()</strong>, or any other out-of-the-box method. The <strong class="source-inline">MyRunnable</strong> class can be any class that implements the <strong class="source-inline">Runnable</strong> interface, so we cannot print whether the thread is a daemon or not. We have added the <strong class="source-inline">name</strong> property so that we can identify the thread.</p>
			<p>We can use the <strong class="source-inline">MyRunnable</strong> class to create<a id="_idIndexMarker979"/> threads similar to how we have used the <strong class="source-inline">MyThread</strong> class, as follows:</p>
			<pre class="source-code">public static void main(String... args) {</pre>
			<pre class="source-code">    MyRunnable myRunnable1 = new MyRunnable("One");</pre>
			<pre class="source-code">    MyRunnable myRunnable2 = new MyRunnable("Two");</pre>
			<pre class="source-code">    Thread thr1 = new Thread(myRunnable1);</pre>
			<pre class="source-code">    thr1.start();</pre>
			<pre class="source-code">    Thread thr2 = new Thread(myRunnable2);</pre>
			<pre class="source-code">    thr2.setDaemon(true);</pre>
			<pre class="source-code">    thr2.start();</pre>
			<pre class="source-code">    pauseOneSecond();</pre>
			<pre class="source-code">    myRunnable1.setParameter("exit");</pre>
			<pre class="source-code">    pauseOneSecond();</pre>
			<pre class="source-code">    System.out.println("Main thread exists");</pre>
			<pre class="source-code">}</pre>
			<p>The following screenshot proves that the behavior of the <strong class="source-inline">MyRunnable</strong> class is similar to the behavior of the <strong class="source-inline">MyThread</strong> class:</p>
			<div>
				<div id="_idContainer062" class="IMG---Figure">
					<img src="image/B18388_Figure_8.2.jpg" alt=""/>
				</div>
			</div>
			<p>The daemon thread (named <strong class="source-inline">Two</strong>) exits after the last user thread exits—exactly how it happened with the <strong class="source-inline">MyThread</strong> class.</p>
			<h1 id="_idParaDest-194"><a id="_idTextAnchor193"/>Extending Thread versus implementing Runnable</h1>
			<p>Implementation of <strong class="source-inline">Runnable</strong> has the advantage (and in some cases, the only possible option) of allowing the implementation<a id="_idIndexMarker980"/> to extend another class. It is particularly<a id="_idIndexMarker981"/> helpful when you would like to add thread-like behavior to an existing class. Implementing <strong class="source-inline">Runnable</strong> allows more flexibility in usage, but otherwise, there is no difference in functionality compared to the extending of the <strong class="source-inline">Thread</strong> class.</p>
			<p>The <strong class="source-inline">Thread</strong> class has several constructors that allow setting the thread name and the group it belongs to. Grouping of threads helps to manage them in the case of many threads running in parallel. The <strong class="source-inline">Thread</strong> class has also several methods that provide information about the thread’s status and its properties and allows us to control its behavior.</p>
			<p>As you have seen, the thread’s <strong class="bold">identifier</strong> (<strong class="bold">ID</strong>) is generated automatically. It cannot be changed but can be reused after the thread is terminated. Several threads, on the other hand, can be set with the same name.</p>
			<p>The execution priority can also be set programmatically with a value between <strong class="source-inline">Thread.MIN_PRIORITY</strong> and <strong class="source-inline">Thread.MAX_PRIORITY</strong>. The smaller the value, the more time the thread is allowed to run, which means it has a higher priority. If not set, the priority value defaults to <strong class="source-inline">Thread.NORM_PRIORITY</strong>.</p>
			<p>The state of a thread can have one of the following values:</p>
			<ul>
				<li><strong class="source-inline">NEW</strong>: When a thread has not yet started</li>
				<li><strong class="source-inline">RUNNABLE</strong>: When a thread is being executed</li>
				<li><strong class="source-inline">BLOCKED</strong>: When a thread is blocked and is waiting for a monitor lock</li>
				<li><strong class="source-inline">WAITING</strong>: When a thread is waiting indefinitely for another thread to perform a particular action</li>
				<li><strong class="source-inline">TIMED_WAITING</strong>: When a thread is waiting for another thread to perform an action for up to a specified waiting time</li>
				<li><strong class="source-inline">TERMINATED</strong>: When a thread has exited</li>
			</ul>
			<p>Threads—and any objects, for that matter—can also <em class="italic">talk to each other</em> using the <strong class="source-inline">wait()</strong>, <strong class="source-inline">notify()</strong>, and <strong class="source-inline">notifyAll()</strong> methods of the <strong class="source-inline">java.lang.Object</strong> base class, but this aspect of threads’ behavior is outside the scope of this book.</p>
			<h1 id="_idParaDest-195"><a id="_idTextAnchor194"/>Using a pool of threads</h1>
			<p>Each thread requires resources—the <strong class="bold">central processing unit</strong> (<strong class="bold">CPU</strong>) and <strong class="bold">memory</strong>. This means the number<a id="_idIndexMarker982"/> of threads must be controlled, and<a id="_idIndexMarker983"/> one way to do that is to create<a id="_idIndexMarker984"/> a fixed number of them—a pool. Besides, creating an object incurs an overhead that may be significant for some applications. </p>
			<p>In this section, we will look into the <strong class="source-inline">Executor</strong> interfaces and their implementations provided in the <strong class="source-inline">java.util.concurrent</strong> package. They encapsulate thread management and minimize the time an application developer spends on writing code related to threads’ life cycles.</p>
			<p>There are three <strong class="source-inline">Executor</strong> interfaces<a id="_idIndexMarker985"/> defined in the <strong class="source-inline">java.util.concurrent</strong> package, as follows:</p>
			<ul>
				<li>The base <strong class="source-inline">Executor</strong> interface: This has only one <strong class="source-inline">void execute(Runnable r)</strong> method in it.</li>
				<li>The <strong class="source-inline">ExecutorService</strong> interface: This extends <strong class="source-inline">Executor</strong> and adds four groups of methods that manage the life cycle of worker threads and of the executor itself, as follows:<ul><li><strong class="source-inline">submit()</strong> methods, which place a <strong class="source-inline">Runnable</strong> or <strong class="source-inline">Callable</strong> object in the queue<a id="_idIndexMarker986"/> for the execution (<strong class="source-inline">Callable</strong> allows the worker thread to return a value) and return an object of the <strong class="source-inline">Future</strong> interface, which can be used to access the value returned by the <strong class="source-inline">Callable</strong> object and to manage the status of the worker thread</li><li><strong class="source-inline">invokeAll()</strong> methods, which place a collection<a id="_idIndexMarker987"/> of objects of the <strong class="source-inline">Callable</strong> interface in a queue for execution, which then returns a <strong class="source-inline">List</strong> interface of <strong class="source-inline">Future</strong> objects when all worker threads are complete (there is also an overloaded <strong class="source-inline">invokeAll()</strong> method with a timeout)</li><li><strong class="source-inline">invokeAny()</strong> methods, which place a collection of interface <strong class="source-inline">Callable</strong> objects in the queue<a id="_idIndexMarker988"/> for the execution and return one <strong class="source-inline">Future</strong> object of any of the worker threads, which has completed (there is also an overloaded <strong class="source-inline">invokeAny()</strong> method with a timeout)</li></ul></li>
				<li>Methods that manage<a id="_idIndexMarker989"/> worker threads’ status and the service itself, as follows:<ul><li><strong class="source-inline">shutdown()</strong>: Prevents new worker threads from being submitted to the service.</li><li><strong class="source-inline">shutdownNow()</strong>: Interrupts each worker thread that is not completed. A worker thread should be written so that it checks its own status periodically (using <strong class="source-inline">Thread.currentThread().isInterrupted()</strong>, for example) and gracefully shuts down on its own; otherwise, it will continue running even after <strong class="source-inline">shutdownNow()</strong> was called.</li><li><strong class="source-inline">isShutdown()</strong>: Checks whether the shutdown of the executor was initiated.</li><li><strong class="source-inline">awaitTermination(long timeout, TimeUnit timeUnit)</strong>: Waits until all worker threads have completed execution after a shutdown request, or a timeout occurs, or the current thread is interrupted, whichever happens first.</li><li><strong class="source-inline">isTerminated()</strong>: Checks whether all the worker threads have completed after the shutdown was initiated. It never returns <strong class="source-inline">true</strong> unless either <strong class="source-inline">shutdown()</strong> or <strong class="source-inline">shutdownNow()</strong> was called first.</li></ul></li>
				<li>The <strong class="source-inline">ScheduledExecutorService</strong> interface: This extends <strong class="source-inline">ExecutorService</strong> and adds methods that allow scheduling of the execution (one-time and periodic) of worker threads</li>
			</ul>
			<p>A pool-based implementation of <strong class="source-inline">ExecutorService</strong> can be created using the <strong class="source-inline">java.util.concurrent.ThreadPoolExecutor</strong> or <strong class="source-inline">java.util.concurrent.ScheduledThreadPoolExecutor</strong> class. There is also a <strong class="source-inline">java.util.concurrent.Executors</strong> factory class that covers most practical cases. So, before writing custom code for worker threads’ pool creation, we highly recommend looking into using<a id="_idIndexMarker990"/> the following factory methods of the <strong class="source-inline">java.util.concurrent.Executors</strong> class:</p>
			<ul>
				<li><strong class="source-inline">newCachedThreadPool()</strong>: Creates a thread pool that adds a new thread as needed, unless there is an idle thread created before; threads that have been idle for 60 seconds are removed from the pool</li>
				<li><strong class="source-inline">newSingleThreadExecutor()</strong>: Creates an <strong class="source-inline">ExecutorService</strong> (pool) instance that executes worker threads sequentially</li>
				<li><strong class="source-inline">newSingleThreadScheduledExecutor()</strong>: Creates a single-threaded executor that can be scheduled to run after a given delay, or to execute periodically</li>
				<li><strong class="source-inline">newFixedThreadPool(int nThreads)</strong>: Creates a thread pool that reuses a fixed number of worker threads; if a new task is submitted when all the worker threads are still executing, it will be placed into the queue until a worker thread is available</li>
				<li><strong class="source-inline">newScheduledThreadPool(int nThreads)</strong>: Creates a thread pool of a fixed size that can be scheduled to run after a given delay, or to execute periodically</li>
				<li><strong class="source-inline">newWorkStealingThreadPool(int nThreads)</strong>: Creates a thread pool that uses the <em class="italic">work-stealing</em> algorithm used by <strong class="source-inline">ForkJoinPool</strong>, which is particularly useful in case the worker threads generate other threads, such as in a recursive algorithm; it also adapts to the specified number of CPUs, which you may set higher or lower than the actual CPU count on your computer<p class="callout-heading">Work-Stealing Algorithm</p><p class="callout">A work-stealing algorithm allows threads<a id="_idIndexMarker991"/> that have finished their assigned tasks to help other tasks that are still busy with their assignments. As an example, see the description<a id="_idIndexMarker992"/> of fork/join implementation in the official Oracle Java documentation (<a href="https://docs.oracle.com/javase/tutorial/essential/concurrency/forkjoin.html">https://docs.oracle.com/javase/tutorial/essential/concurrency/forkjoin.html</a>).</p></li>
			</ul>
			<p>Each of these methods <a id="_idIndexMarker993"/>has an overloaded version that allows passing in <strong class="source-inline">ThreadFactory</strong> that is used to create a new thread when needed. Let’s see how it all works in a code sample. First, we run another version of the <strong class="source-inline">MyRunnable</strong> class, as follows:</p>
			<pre class="source-code">class MyRunnable implements Runnable {</pre>
			<pre class="source-code">   private String name;</pre>
			<pre class="source-code">   public MyRunnable(String name) {</pre>
			<pre class="source-code">      this.name = name;</pre>
			<pre class="source-code">   }</pre>
			<pre class="source-code">   public void run() {</pre>
			<pre class="source-code">      try {</pre>
			<pre class="source-code">            while (true) {</pre>
			<pre class="source-code">           System.out.println(this.name + </pre>
			<pre class="source-code">                                     " is working...");</pre>
			<pre class="source-code">           TimeUnit.SECONDS.sleep(1);</pre>
			<pre class="source-code">         }</pre>
			<pre class="source-code">      } catch (InterruptedException e) {</pre>
			<pre class="source-code">        System.out.println(this.name + </pre>
			<pre class="source-code">                      " was interrupted\n" + this.name + </pre>
			<pre class="source-code">            " Thread.currentThread().isInterrupted()=" +</pre>
			<pre class="source-code">                  Thread.currentThread().isInterrupted());</pre>
			<pre class="source-code">      }</pre>
			<pre class="source-code">   }</pre>
			<pre class="source-code">}</pre>
			<p>We cannot use the <strong class="source-inline">parameter</strong> property anymore to tell the thread to stop executing because the thread life cycle<a id="_idIndexMarker994"/> is now going to be controlled by the <strong class="source-inline">ExecutorService</strong> interface,  and the way it does it is by calling the <strong class="source-inline">interrupt()</strong> thread method. Also, notice that the thread we created has an infinite loop, so it will never stop executing until forced to (by calling the <strong class="source-inline">interrupt()</strong> method).</p>
			<p>Let’s write code that does the following:</p>
			<ul>
				<li>Creates a pool of three threads</li>
				<li>Makes sure the pool does not accept more threads</li>
				<li>Waits for a fixed time to let all threads finish what they’re doing</li>
				<li>Stops (interrupts) threads that did not finish what they were doing</li>
				<li>Exits</li>
			</ul>
			<p>The following code performs all the actions described in the preceding list:</p>
			<pre class="source-code">ExecutorService pool = Executors.newCachedThreadPool();</pre>
			<pre class="source-code">String[] names = {"One", "Two", "Three"};</pre>
			<pre class="source-code">for (int i = 0; i &lt; names.length; i++) {</pre>
			<pre class="source-code">    pool.execute(new MyRunnable(names[i]));</pre>
			<pre class="source-code">}</pre>
			<pre class="source-code">System.out.println("Before shutdown: isShutdown()=" +</pre>
			<pre class="source-code">            pool.isShutdown() + ", isTerminated()=" + </pre>
			<pre class="source-code">                                pool.isTerminated());</pre>
			<pre class="source-code">pool.shutdown(); </pre>
			<pre class="source-code">           // New threads cannot be added to the pool</pre>
			<pre class="source-code">//pool.execute(new MyRunnable("Four"));    </pre>
			<pre class="source-code">                          //RejectedExecutionException</pre>
			<pre class="source-code">System.out.println("After shutdown: isShutdown()=" +</pre>
			<pre class="source-code">           pool.isShutdown() + ", isTerminated()=" + </pre>
			<pre class="source-code">                               pool.isTerminated());</pre>
			<pre class="source-code">try {</pre>
			<pre class="source-code">  long timeout = 100;</pre>
			<pre class="source-code">  TimeUnit timeUnit = TimeUnit.MILLISECONDS;</pre>
			<pre class="source-code">  System.out.println("Waiting all threads completion for "</pre>
			<pre class="source-code">                      + timeout + " " + timeUnit + "...");</pre>
			<pre class="source-code">         // Blocks until timeout, or all threads complete</pre>
			<pre class="source-code">         // execution, or the current thread is</pre>
			<pre class="source-code">         // interrupted, whichever happens first.</pre>
			<pre class="source-code">  boolean isTerminated = </pre>
			<pre class="source-code">                pool.awaitTermination(timeout, timeUnit);</pre>
			<pre class="source-code">  System.out.println("isTerminated()=" + isTerminated);</pre>
			<pre class="source-code">  if (!isTerminated) {</pre>
			<pre class="source-code">    System.out.println("Calling shutdownNow()...");</pre>
			<pre class="source-code">    List&lt;Runnable&gt; list = pool.shutdownNow();</pre>
			<pre class="source-code">    System.out.println(list.size() + " threads running");</pre>
			<pre class="source-code">    isTerminated = </pre>
			<pre class="source-code">                pool.awaitTermination(timeout, timeUnit);</pre>
			<pre class="source-code">    if (!isTerminated) {</pre>
			<pre class="source-code">     System.out.println("Some threads are still running");</pre>
			<pre class="source-code">    }</pre>
			<pre class="source-code">    System.out.println("Exiting");</pre>
			<pre class="source-code">  }</pre>
			<pre class="source-code">} catch (InterruptedException ex) {</pre>
			<pre class="source-code">    ex.printStackTrace();</pre>
			<pre class="source-code">}</pre>
			<p>The attempt to add another thread<a id="_idIndexMarker995"/> to the pool after <strong class="source-inline">pool.shutdown()</strong> is called generates <strong class="source-inline">java.util.concurrent.RejectedExecutionException</strong>.</p>
			<p>The execution of the preceding code produces the following results:</p>
			<div>
				<div id="_idContainer063" class="IMG---Figure">
					<img src="image/B18388_Figure_8.3.jpg" alt=""/>
				</div>
			</div>
			<p>Notice the <strong class="source-inline">Thread.currentThread().isInterrupted()=false</strong> message in the preceding screenshot. The thread was interrupted. We know this because the thread got an <strong class="source-inline">InterruptedException</strong> message. Why, then, does the <strong class="source-inline">isInterrupted()</strong> method return <strong class="source-inline">false</strong>? This happens because the thread state was cleared immediately after receiving the interrupt message. We’re mentioning it now because it is a source of some programmer mistakes. For example, if the main thread watches the <strong class="source-inline">MyRunnable</strong> thread and calls <strong class="source-inline">isInterrupted()</strong> on it, the return value is going to be <strong class="source-inline">false</strong>, which may be misleading after the thread was interrupted.</p>
			<p>So, in the case where another thread may be monitoring the <strong class="source-inline">MyRunnable</strong> thread, the implementation of <strong class="source-inline">MyRunnable</strong> has to be changed to this. Note in the following code<a id="_idIndexMarker996"/> snippet how the <strong class="source-inline">interrupt()</strong> method is called in the <strong class="source-inline">catch</strong> block: </p>
			<pre class="source-code">class MyRunnable implements Runnable {</pre>
			<pre class="source-code">   private String name;</pre>
			<pre class="source-code">   public MyRunnable(String name) {</pre>
			<pre class="source-code">      this.name = name;</pre>
			<pre class="source-code">   }</pre>
			<pre class="source-code">   public void run() {</pre>
			<pre class="source-code">      try {</pre>
			<pre class="source-code">         while (true) {</pre>
			<pre class="source-code">             System.out.println(this.name + " is working...");</pre>
			<pre class="source-code">             TimeUnit.SECONDS.sleep(1);</pre>
			<pre class="source-code">         }</pre>
			<pre class="source-code">      } catch (InterruptedException e) {</pre>
			<pre class="source-code">         <strong class="bold">Thread.currentThread().interrupt();</strong></pre>
			<pre class="source-code">         System.out.println(this.name + </pre>
			<pre class="source-code">           " was interrupted\n" + this.name + </pre>
			<pre class="source-code">           " Thread.currentThread().isInterrupted()=" + </pre>
			<pre class="source-code">                Thread.currentThread().isInterrupted());</pre>
			<pre class="source-code">      }</pre>
			<pre class="source-code">   }</pre>
			<pre class="source-code">}</pre>
			<p>Now, if we run<a id="_idIndexMarker997"/> this thread using the same <strong class="source-inline">ExecutorService</strong> pool again, this will be the result:</p>
			<div>
				<div id="_idContainer064" class="IMG---Figure">
					<img src="image/B18388_Figure_8.4.jpg" alt=""/>
				</div>
			</div>
			<p>As you can see, the value returned by the <strong class="source-inline">isInterrupted()</strong> method is now <strong class="source-inline">true</strong> and corresponds<a id="_idIndexMarker998"/> to what has happened. To be fair, in many applications, once a thread is interrupted, its status is not checked again. But setting the correct state is a good practice, especially in those cases where you are not the author of the higher-level code that creates a particular thread.</p>
			<p>In our example, we have used a cached thread pool that creates a new thread as needed or, if available, reuses the thread already used, but which completed its job and returned to the pool for a new assignment. We did not worry about too many threads created because our demonstration application had three worker threads at the most and they were quite short-lived.</p>
			<p>But in the case where an application does not have a fixed limit of worker threads it might need or there is no good way to predict how much memory a thread may take or how long it can execute, setting a ceiling on the worker thread count prevents an unexpected degradation of the application performance, running out of memory, or depletion of any other resources the worker threads use. If the thread behavior is extremely unpredictable, a single thread pool might be the only solution, with the option of using a custom thread-pool executor. But in the majority of cases, a fixed-size thread-pool executor is a good practical compromise between the application needs and the code complexity (earlier in this section, we listed all possible pool types created by the <strong class="source-inline">Executors</strong> factory class). </p>
			<p>Setting the size of the pool too low may deprive the application of the chance to utilize the available resources effectively. So, before selecting the pool size, it is advisable to spend some time monitoring the application, with the goal of identifying the idiosyncrasy of the application behavior. In fact, the <em class="italic">deploy-monitor-adjust</em> cycle has to be repeated throughout the application’s life cycle in order to accommodate and take advantage of changes that happened in the code or the executing environment.</p>
			<p>The first characteristic<a id="_idIndexMarker999"/> you take into account is the number of CPUs in your system, so the thread pool size can be at least as big as the CPU count. Then, you can monitor the application and see how much time each thread engages the CPU for and how much time<a id="_idIndexMarker1000"/> it uses other resources (such as <strong class="bold">input/output</strong> (<strong class="bold">I/O</strong>) operations). If the time spent not using the CPU is comparable with the total executing time of the thread, then you can increase the pool size by the following ratio: the time the CPU was not used divided by the total executing time, but that is in the case where another resource (disk or database) is not a subject of contention between threads. If the latter is the case, then you can use that resource instead of the CPU as the delineating factor.</p>
			<p>Assuming the worker threads of your application are not too big or take too long executing, and belong to the mainstream population of the typical working threads that complete their job in a reasonably short period of time, you can increase the pool size by adding the (rounded-up) ratio of the desired response time and the time a thread uses the CPU or another most contentious resource. This means that, with the same desired response time, the less a thread uses the CPU or another concurrently accessed resource, the bigger the pool size should be. If the contentious resource has its own ability to improve concurrent access (such as a connection pool in a database), consider utilizing that feature first.</p>
			<p>If the required number of threads running at the same time changes at runtime in different circumstances, you can make the pool size dynamic and create a new pool with a new size (shutting down the old pool after all its threads have completed). The recalculation of the size of a new pool might also be necessary after you add or remove the available resources. You can use <strong class="source-inline">Runtime.getRuntime().availableProcessors()</strong> to programmatically adjust the pool size based on the current count of the available CPUs, for example.</p>
			<p>If none of the ready-to-use thread pool executor<a id="_idIndexMarker1001"/> implementations that come with the <strong class="bold">Java Development Kit</strong> (<strong class="bold">JDK</strong>) suit the needs of a particular application, before writing the thread-managing code from scratch, try to use the <strong class="source-inline">java.util.concurrent.ThreadPoolExecutor</strong> class first. It has several overloaded constructors.</p>
			<p>To give you an idea of its capabilities, here is the constructor with the biggest number of options:</p>
			<pre class="source-code">ThreadPoolExecutor (int corePoolSize, </pre>
			<pre class="source-code">                    int maximumPoolSize, </pre>
			<pre class="source-code">                    long keepAliveTime, </pre>
			<pre class="source-code">                    TimeUnit unit, </pre>
			<pre class="source-code">                    BlockingQueue&lt;Runnable&gt; workQueue, </pre>
			<pre class="source-code">                    ThreadFactory threadFactory, </pre>
			<pre class="source-code">                    RejectedExecutionHandler handler)</pre>
			<p>These are the parameters<a id="_idIndexMarker1002"/> of the preceding constructor:</p>
			<ul>
				<li><strong class="source-inline">corePoolSize</strong> is the number of threads to keep in the pool, even if they are idle, unless the <strong class="source-inline">allowCoreThreadTimeOut(boolean value)</strong> method is called with a <strong class="source-inline">true</strong> value.</li>
				<li><strong class="source-inline">maximumPoolSize</strong> is the maximum number of threads to allow in the pool.</li>
				<li><strong class="source-inline">keepAliveTime</strong>: When the number of threads is greater than the core, this is the maximum time that excess idle threads will wait for new tasks before terminating.</li>
				<li><strong class="source-inline">unit</strong> is the time unit for the <strong class="source-inline">keepAliveTime</strong> argument.</li>
				<li><strong class="source-inline">workQueue</strong> is the queue to use for holding tasks before they are executed; this queue will hold only <strong class="source-inline">Runnable</strong> objects submitted by the <strong class="source-inline">execute()</strong> method.</li>
				<li><strong class="source-inline">threadFactory</strong> is the factory to use when the executor creates a new thread.</li>
				<li><strong class="source-inline">handler</strong> is the handler to use when the execution is blocked because the thread bounds and queue capacities are reached.</li>
			</ul>
			<p>Each of the previous constructor<a id="_idIndexMarker1003"/> parameters except <strong class="source-inline">workQueue</strong> can also be set via the corresponding setter after an object of the <strong class="source-inline">ThreadPoolExecutor</strong> class has been created, thus allowing more flexibility and dynamic adjustment of existing pool characteristics.</p>
			<h1 id="_idParaDest-196"><a id="_idTextAnchor195"/>Getting results from a thread</h1>
			<p>In our examples so far, we have used the <strong class="source-inline">execute()</strong> method of the <strong class="source-inline">ExecutorService</strong> interface<a id="_idIndexMarker1004"/> to start a thread. In fact, this method comes from the <strong class="source-inline">Executor</strong> base interface. Meanwhile, the <strong class="source-inline">ExecutorService</strong> interface has other methods (listed in the previous <em class="italic">Using a pool of threads</em> section) that can start threads and get back the results of thread execution.</p>
			<p>The object that brings back the result of thread execution is of type <strong class="source-inline">Future</strong>—an interface that has the following methods:</p>
			<ul>
				<li><strong class="source-inline">V get()</strong>: Blocks until the thread finishes; returns the result (<em class="italic">if available</em>)</li>
				<li><strong class="source-inline">V get(long timeout, TimeUnit unit)</strong>: Blocks until the thread finishes or the provided timeout is up; returns the result (if available)</li>
				<li><strong class="source-inline">boolean isDone()</strong>: Returns <strong class="source-inline">true</strong> if the thread has finished</li>
				<li><strong class="source-inline">boolean cancel(boolean mayInterruptIfRunning)</strong>: Tries to cancel the execution of the thread; returns <strong class="source-inline">true</strong> if successful; returns <strong class="source-inline">false</strong> also in the case the thread had finished normally by the time the method was called</li>
				<li><strong class="source-inline">boolean isCancelled()</strong>: Returns <strong class="source-inline">true</strong> if the thread execution was canceled before it had finished normally</li>
			</ul>
			<p>The <em class="italic">if available</em> remark in the description of the <strong class="source-inline">get()</strong> method means that the result is not always available in principle, even when the <strong class="source-inline">get()</strong> method without parameters is called. It all depends on the method used to produce the <strong class="source-inline">Future</strong> object. Here is a list of all methods of <strong class="source-inline">ExecutorService</strong> that return a <strong class="source-inline">Future</strong> object(s):</p>
			<ul>
				<li><strong class="source-inline">Future&lt;?&gt; submit(Runnable task)</strong>: Submits the thread (task) for execution; returns a <strong class="source-inline">Future</strong> object representing<a id="_idIndexMarker1005"/> the task; the <strong class="source-inline">get()</strong> method of the returned <strong class="source-inline">Future</strong> object returns <strong class="source-inline">null</strong>. For example, let’s use the <strong class="source-inline">MyRunnable</strong> class that works only for 100 milliseconds, as follows:<p class="source-code">class MyRunnable implements Runnable {</p><p class="source-code">   private String name;</p><p class="source-code">   public MyRunnable(String name) {</p><p class="source-code">     this.name = name;</p><p class="source-code">   }</p><p class="source-code">   public void run() {</p><p class="source-code">      try {</p><p class="source-code">         System.out.println(this.name + </p><p class="source-code">                                  " is working...");</p><p class="source-code">         TimeUnit.MILLISECONDS.sleep(100);</p><p class="source-code">         System.out.println(this.name + " is done");</p><p class="source-code">      } catch (InterruptedException e) {</p><p class="source-code">         Thread.currentThread().interrupt();</p><p class="source-code">         System.out.println(this.name + </p><p class="source-code">                      " was interrupted\n" + this.name + </p><p class="source-code">            " Thread.currentThread().isInterrupted()=" +</p><p class="source-code">                Thread.currentThread().isInterrupted());</p><p class="source-code">      }</p><p class="source-code">   }</p><p class="source-code">}</p></li>
			</ul>
			<p>And based on the code examples<a id="_idIndexMarker1006"/> of the previous section, let’s create a method that shuts down the pool and terminates all the threads, if necessary, as follows:</p>
			<p class="source-code">void shutdownAndTerminate(ExecutorService pool){</p>
			<p class="source-code">  try {</p>
			<p class="source-code">    long timeout = 100;</p>
			<p class="source-code">    TimeUnit timeUnit = TimeUnit.MILLISECONDS;</p>
			<p class="source-code">    System.out.println("Waiting all threads " + </p>
			<p class="source-code">             "completion for " + timeout + " " + </p>
			<p class="source-code">                               timeUnit + "...");</p>
			<p class="source-code">     //Blocks until timeout or all threads complete</p>
			<p class="source-code">     // execution, or the current thread is</p>
			<p class="source-code">     // interrupted, whichever happens first.</p>
			<p class="source-code">    boolean isTerminated = </p>
			<p class="source-code">          pool.awaitTermination(timeout, timeUnit);</p>
			<p class="source-code">    System.out.println("isTerminated()=" +</p>
			<p class="source-code">                                     isTerminated);</p>
			<p class="source-code">    if(!isTerminated) {</p>
			<p class="source-code">      System.out.println("Calling shutdownNow()...");</p>
			<p class="source-code">      List&lt;Runnable&gt; list = pool.shutdownNow();</p>
			<p class="source-code">      System.out.println(list.size() + </p>
			<p class="source-code">                                 " threads running");</p>
			<p class="source-code">       isTerminated = </p>
			<p class="source-code">            pool.awaitTermination(timeout, timeUnit);</p>
			<p class="source-code">       if (!isTerminated) {</p>
			<p class="source-code">          System.out.println("Some threads are still running");</p>
			<p class="source-code">       }</p>
			<p class="source-code">       System.out.println("Exiting");</p>
			<p class="source-code">     }</p>
			<p class="source-code">  } catch (InterruptedException ex) {</p>
			<p class="source-code">      ex.printStackTrace();</p>
			<p class="source-code">   }</p>
			<p class="source-code">}</p>
			<p>We will use the preceding <strong class="source-inline">shutdownAndTerminate()</strong> method in a <strong class="source-inline">finally</strong> block to make sure no running<a id="_idIndexMarker1007"/> threads were left behind. Here is the code we are going to execute:</p>
			<p class="source-code">ExecutorService pool = Executors.newSingleThreadExecutor();</p>
			<p class="source-code">Future future = pool.submit(new MyRunnable("One"));</p>
			<p class="source-code">System.out.println(future.isDone());         </p>
			<p class="source-code">                                          //prints: false</p>
			<p class="source-code">System.out.println(future.isCancelled());    </p>
			<p class="source-code">                                          //prints: false</p>
			<p class="source-code">try{</p>
			<p class="source-code">    System.out.println(future.get());        </p>
			<p class="source-code">                                           //prints: null</p>
			<p class="source-code">    System.out.println(future.isDone());     </p>
			<p class="source-code">                                           //prints: true</p>
			<p class="source-code">    System.out.println(future.isCancelled());</p>
			<p class="source-code">                                          //prints: false</p>
			<p class="source-code">} catch (Exception ex){</p>
			<p class="source-code">    ex.printStackTrace();</p>
			<p class="source-code">} finally {</p>
			<p class="source-code">    shutdownAndTerminate(pool);</p>
			<p class="source-code">}</p>
			<p>You can see the output<a id="_idIndexMarker1008"/> of this code in the following screenshot:</p>
			<div>
				<div id="_idContainer065" class="IMG---Figure">
					<img src="image/B18388_Figure_8.5.jpg" alt=""/>
				</div>
			</div>
			<p>As expected, the <strong class="source-inline">get()</strong> method of the <strong class="source-inline">Future</strong> object returns <strong class="source-inline">null</strong> because the <strong class="source-inline">run()</strong> method of <strong class="source-inline">Runnable</strong> does not return anything. All we can get back from the returned <strong class="source-inline">Future</strong> object is the information that the task was completed, or not.</p>
			<ul>
				<li><strong class="source-inline">Future&lt;T&gt; submit(Runnable task, T result)</strong>: Submits the thread (task) for execution; returns a <strong class="source-inline">Future</strong> object representing the task with the provided <strong class="source-inline">result</strong> in it; for example, we will use the following class as the result:<p class="source-code">class Result {</p><p class="source-code">    private String name;</p><p class="source-code">    private double result;</p><p class="source-code">    public Result(String name, double result) {</p><p class="source-code">        this.name = name;</p><p class="source-code">        this.result = result;</p><p class="source-code">    }</p><p class="source-code">    @Override</p><p class="source-code">    public String toString() {</p><p class="source-code">        return "Result{name=" + name +</p><p class="source-code">                ", result=" + result + "}";</p><p class="source-code">    }</p><p class="source-code">}</p></li>
			</ul>
			<p>The following code snippet demonstrates<a id="_idIndexMarker1009"/> how the default result is returned by the <strong class="source-inline">Future</strong> object returned by the <strong class="source-inline">submit()</strong> method:</p>
			<p class="source-code">ExecutorService pool = </p>
			<p class="source-code">                Executors.newSingleThreadExecutor();</p>
			<p class="source-code">Future&lt;Result&gt; future = </p>
			<p class="source-code">            pool.submit(new MyRunnable("Two"), </p>
			<p class="source-code">                            new Result("Two", 42.));</p>
			<p class="source-code">System.out.println(future.isDone());   </p>
			<p class="source-code">                                     //prints: false</p>
			<p class="source-code">System.out.println(future.isCancelled());     </p>
			<p class="source-code">                                      //prints: false</p>
			<p class="source-code">try{</p>
			<p class="source-code">    System.out.println(future.get());         </p>
			<p class="source-code">                                       //prints: null</p>
			<p class="source-code">    System.out.println(future.isDone());      </p>
			<p class="source-code">                                       //prints: true</p>
			<p class="source-code">    System.out.println(future.isCancelled());</p>
			<p class="source-code">                                      //prints: false</p>
			<p class="source-code">} catch (Exception ex){</p>
			<p class="source-code">    ex.printStackTrace();</p>
			<p class="source-code">} finally {</p>
			<p class="source-code">    shutdownAndTerminate(pool);</p>
			<p class="source-code">}</p>
			<p>If we execute the preceding<a id="_idIndexMarker1010"/> code, the output is going to look like this:</p>
			<div>
				<div id="_idContainer066" class="IMG---Figure">
					<img src="image/B18388_Figure_8.6.jpg" alt=""/>
				</div>
			</div>
			<p>As expected, the <strong class="source-inline">get()</strong> method of <strong class="source-inline">Future</strong> returns the object passed in as a parameter.</p>
			<ul>
				<li><strong class="source-inline">Future&lt;T&gt; submit(Callable&lt;T&gt; task)</strong>: Submits the thread (task) for execution; returns a <strong class="source-inline">Future</strong> object representing the task with the result produced and returned by the <strong class="source-inline">V call()</strong> method of the <strong class="source-inline">Callable</strong> interface, which is the only <strong class="source-inline">Callable</strong> method the interface has. Here’s an example of this:<p class="source-code">class MyCallable implements Callable {</p><p class="source-code">   private String name;</p><p class="source-code">   public MyCallable(String name) {</p><p class="source-code">        this.name = name;</p><p class="source-code">   }</p><p class="source-code">   public Result call() {</p><p class="source-code">      try {</p><p class="source-code">         System.out.println(this.name + </p><p class="source-code">                                       " is working...");</p><p class="source-code">         TimeUnit.MILLISECONDS.sleep(100);</p><p class="source-code">         System.out.println(this.name + " is done");</p><p class="source-code">         return new Result(name, 42.42);</p><p class="source-code">      } catch (InterruptedException e) {</p><p class="source-code">         Thread.currentThread().interrupt();</p><p class="source-code">         System.out.println(this.name + </p><p class="source-code">                      " was interrupted\n" + this.name + </p><p class="source-code">            " Thread.currentThread().isInterrupted()=" +</p><p class="source-code">                Thread.currentThread().isInterrupted());</p><p class="source-code">      }</p><p class="source-code">      return null;</p><p class="source-code">   }</p></li>
			</ul>
			<p>The result of the preceding code<a id="_idIndexMarker1011"/> looks like this:</p>
			<div>
				<div id="_idContainer067" class="IMG---Figure">
					<img src="image/B18388_Figure_8.7.jpg" alt=""/>
				</div>
			</div>
			<p>As you can see, the <strong class="source-inline">get()</strong> method of the <strong class="source-inline">Future</strong> object<a id="_idIndexMarker1012"/> returns the value produced by the <strong class="source-inline">call()</strong> method of the <strong class="source-inline">MyCallable</strong> class:</p>
			<ul>
				<li><strong class="source-inline">List&lt;Future&lt;T&gt;&gt; invokeAll(Collection&lt;Callable&lt;T&gt;&gt; tasks)</strong>: Executes all <strong class="source-inline">Callable</strong> tasks of the provided collection; returns a list of <strong class="source-inline">Future</strong> objects with the results produced by the executed <strong class="source-inline">Callable</strong> objects</li>
				<li><strong class="source-inline">List&lt;Future&lt;T&gt;&gt; invokeAll(Collection&lt;Callable&lt;T&gt;&gt;</strong>: Executes all <strong class="source-inline">Callable</strong> tasks of the provided collection; returns a list of <strong class="source-inline">Future</strong> objects with the results produced by the executed <strong class="source-inline">Callable</strong> objects or the timeout expires, whichever happens first</li>
				<li><strong class="source-inline">T invokeAny(Collection&lt;Callable&lt;T&gt;&gt; tasks)</strong>: Executes all <strong class="source-inline">Callable</strong> tasks of the provided collection; returns the result of one that has completed successfully (meaning, without throwing an exception), if any do</li>
				<li><strong class="source-inline">T invokeAny(Collection&lt;Callable&lt;T&gt;&gt; tasks, long timeout, TimeUnit unit)</strong>: Executes all <strong class="source-inline">Callable</strong> tasks of the provided collection; returns the result of one that has completed successfully (meaning, without throwing an exception), if such is available before the provided timeout expires</li>
			</ul>
			<p>As you can see, there are many ways to get results from a thread. The method you choose depends on the particular needs of your application.</p>
			<h1 id="_idParaDest-197"><a id="_idTextAnchor196"/>Parallel versus concurrent processing</h1>
			<p>When we hear about working<a id="_idIndexMarker1013"/> threads executing at the same time, we automatically assume that they literally do what they are programmed<a id="_idIndexMarker1014"/> to do in parallel. Only after we look under the hood of such a system do we realize that such parallel processing is possible only when the threads are each executed by a different CPU; otherwise, they time-share the same processing power. We perceive them working at the same time only because the time slots they use are very short—a fraction of the time units we use in our everyday life. When threads share the same resource, in computer science, we say they do it <em class="italic">concurrently</em>.</p>
			<h1 id="_idParaDest-198"><a id="_idTextAnchor197"/>Concurrent modification of the same resource</h1>
			<p>Two or more threads modifying the same value<a id="_idIndexMarker1015"/> while other threads read it is the most general description of one of the problems of concurrent access. Subtler problems include <strong class="bold">thread interference</strong> and <strong class="bold">memory consistency</strong> errors, both of which produce unexpected results<a id="_idIndexMarker1016"/> in seemingly benign fragments<a id="_idIndexMarker1017"/> of code. In this section, we are going to demonstrate such cases and ways to avoid them.</p>
			<p>At first glance, the solution seems quite straightforward: allow only one thread at a time to modify/access the resource, and that’s it. But if access takes a long time, it creates a bottleneck that might eliminate the advantage of having many threads working in parallel. Or, if one thread blocks access to one resource while waiting for access to another resource and the second thread blocks access to a second resource while waiting for access<a id="_idIndexMarker1018"/> to the first one, it creates a problem called a <strong class="bold">deadlock</strong>. These are two very simple examples of possible challenges a programmer may encounter while using multiple threads.</p>
			<p>First, we’ll reproduce a problem caused by the concurrent modification of the same value. Let’s create a <strong class="source-inline">Calculator</strong> interface, as follows:</p>
			<pre class="source-code">interface Calculator {</pre>
			<pre class="source-code">    String getDescription();</pre>
			<pre class="source-code">    double calculate(int i);</pre>
			<pre class="source-code">}</pre>
			<p>We will use the <strong class="source-inline">getDescription()</strong> method to capture the description<a id="_idIndexMarker1019"/> of the implementation. Here is the first implementation:</p>
			<pre class="source-code">class CalculatorNoSync implements Calculator{</pre>
			<pre class="source-code">    private double prop;</pre>
			<pre class="source-code">    private String description = "Without synchronization";</pre>
			<pre class="source-code">    public String getDescription(){ return description; }</pre>
			<pre class="source-code">    public double calculate(int i){</pre>
			<pre class="source-code">        try {</pre>
			<pre class="source-code">            this.prop = 2.0 * i;</pre>
			<pre class="source-code">            TimeUnit.MILLISECONDS.sleep(i);</pre>
			<pre class="source-code">            return Math.sqrt(this.prop);</pre>
			<pre class="source-code">        } catch (InterruptedException e) {</pre>
			<pre class="source-code">            Thread.currentThread().interrupt();</pre>
			<pre class="source-code">            System.out.println("Calculator was interrupted");</pre>
			<pre class="source-code">        }</pre>
			<pre class="source-code">        return 0.0;</pre>
			<pre class="source-code">    }</pre>
			<pre class="source-code">}</pre>
			<p>As you can see, the <strong class="source-inline">calculate()</strong> method assigns a new value to the <strong class="source-inline">prop</strong> property, then does something else (we simulate it by calling the <strong class="source-inline">sleep()</strong> method), and then calculates the square root of the value assigned to the <strong class="source-inline">prop</strong> property. The <strong class="source-inline">"Without synchronization"</strong> description depicts the fact that the value of the <strong class="source-inline">prop</strong> property is changing every time the <strong class="source-inline">calculate()</strong> method is called—without any coordination or <strong class="bold">synchronization</strong>, as it is called in the case of coordination<a id="_idIndexMarker1020"/> between threads when they concurrently modify the same resource.</p>
			<p>We are now going to share<a id="_idIndexMarker1021"/> this object between two threads, which means that the <strong class="source-inline">prop</strong> property is going to be updated and used concurrently. So, some kind of thread synchronization around the <strong class="source-inline">prop</strong> property is necessary, but we have decided that our first implementation does not do it.</p>
			<p>Here is the method we are going to use while executing every <strong class="source-inline">Calculator</strong> implementation we are going to create:</p>
			<pre class="source-code">void invokeAllCallables(Calculator c){</pre>
			<pre class="source-code">    System.out.println("\n" + c.getDescription() + ":");</pre>
			<pre class="source-code">    ExecutorService pool = Executors.newFixedThreadPool(2);</pre>
			<pre class="source-code">    List&lt;Callable&lt;Result&gt;&gt; tasks = </pre>
			<pre class="source-code">                              List.of(new MyCallable("One", c), </pre>
			<pre class="source-code">                                     new MyCallable("Two", c));</pre>
			<pre class="source-code">    try{</pre>
			<pre class="source-code">        List&lt;Future&lt;Result&gt;&gt; futures = pool.invokeAll(tasks);</pre>
			<pre class="source-code">        List&lt;Result&gt; results = new ArrayList&lt;&gt;();</pre>
			<pre class="source-code">        while (results.size() &lt; futures.size()){</pre>
			<pre class="source-code">            TimeUnit.MILLISECONDS.sleep(5);</pre>
			<pre class="source-code">            for(Future future: futures){</pre>
			<pre class="source-code">                if(future.isDone()){</pre>
			<pre class="source-code">                    results.add((Result)future.get());</pre>
			<pre class="source-code">                }</pre>
			<pre class="source-code">            }</pre>
			<pre class="source-code">        }</pre>
			<pre class="source-code">        for(Result result: results){</pre>
			<pre class="source-code">            System.out.println(result);</pre>
			<pre class="source-code">        }</pre>
			<pre class="source-code">    } catch (Exception ex){</pre>
			<pre class="source-code">        ex.printStackTrace();</pre>
			<pre class="source-code">    } finally {</pre>
			<pre class="source-code">        shutdownAndTerminate(pool);</pre>
			<pre class="source-code">    }</pre>
			<pre class="source-code">}</pre>
			<p>As you can see, the preceding method does<a id="_idIndexMarker1022"/> the following:</p>
			<ul>
				<li>Prints a description of the passed-in <strong class="source-inline">Calculator</strong> implementation.</li>
				<li>Creates a fixed-size pool for two threads.</li>
				<li>Creates a list of two <strong class="source-inline">Callable</strong> tasks—objects of the following <strong class="source-inline">MyCallable</strong> class:<p class="source-code">class MyCallable implements Callable&lt;Result&gt; {</p><p class="source-code">    private String name;</p><p class="source-code">    private Calculator calculator;</p><p class="source-code">    public MyCallable(String name, </p><p class="source-code">                      Calculator calculator) {</p><p class="source-code">        this.name = name;</p><p class="source-code">        this.calculator = calculator;</p><p class="source-code">    }</p><p class="source-code">    public Result call() {</p><p class="source-code">        double sum = 0.0;</p><p class="source-code">        for(int i = 1; i &lt; 20; i++){</p><p class="source-code">            sum += calculator.calculate(i);</p><p class="source-code">        }</p><p class="source-code">        return new Result(name, sum);</p><p class="source-code">    }</p><p class="source-code">}</p></li>
				<li>A list of tasks<a id="_idIndexMarker1023"/> is passed into the <strong class="source-inline">invokeAll()</strong> method of the pool, where each of the tasks is executed by invoking the <strong class="source-inline">call()</strong> method; each <strong class="source-inline">call()</strong> method applies the <strong class="source-inline">calculate()</strong> method of the passed-in <strong class="source-inline">Calculator</strong> object to every one of the 19 numbers from 1 to 20 and sums up the results. The resulting sum is returned inside the <strong class="source-inline">Result</strong> object, along with the name of the <strong class="source-inline">MyCallable</strong> object.</li>
				<li>Each <strong class="source-inline">Result</strong> object is eventually returned inside a <strong class="source-inline">Future</strong> object.</li>
				<li>The <strong class="source-inline">invokeAllCallables()</strong> method then iterates over the list of <strong class="source-inline">Future</strong> objects and checks whether each of their tasks has been completed. When a task is completed, the result is added to <strong class="source-inline">List&lt;Result&gt; results</strong>.</li>
				<li>After all tasks are completed, the <strong class="source-inline">invokeAllCallables()</strong> method then prints all elements of <strong class="source-inline">List&lt;Result&gt; results</strong> and terminates the pool.</li>
			</ul>
			<p>Here is the result we got from one of our runs of <strong class="source-inline">invokeAllCallables(new CalculatorNoSync())</strong>:</p>
			<div>
				<div id="_idContainer068" class="IMG---Figure">
					<img src="image/B18388_Figure_8.8.jpg" alt=""/>
				</div>
			</div>
			<p>The actual numbers are slightly different every time we run the preceding code, but the result of the <strong class="source-inline">One</strong> task never equals<a id="_idIndexMarker1024"/> the result of the <strong class="source-inline">Two</strong> task. That is because, in the period between setting the value of the <strong class="source-inline">prop</strong> field and returning its square root in the <strong class="source-inline">calculate()</strong> method, the other thread managed to assign a different value to <strong class="source-inline">prop</strong>. This is a case of thread interference.</p>
			<p>There are several ways to address this problem. We start with an atomic variable as a way to achieve thread-safe concurrent access to a property. Then, we will also demonstrate two methods of thread synchronization.</p>
			<h2 id="_idParaDest-199"><a id="_idTextAnchor198"/>Atomic variable</h2>
			<p>An <strong class="bold">atomic variable</strong> can be updated only when<a id="_idIndexMarker1025"/> its current value<a id="_idIndexMarker1026"/> matches the expected one. In our case, this means that a <strong class="source-inline">prop</strong> value should not be used if it has been changed by another thread.</p>
			<p>The <strong class="source-inline">java.util.concurrent.atomic</strong> package has a dozen classes that support this logic: <strong class="source-inline">AtomicBoolean</strong>, <strong class="source-inline">AtomicInteger</strong>, <strong class="source-inline">AtomicReference</strong>, and <strong class="source-inline">AtomicIntegerArray</strong>, to name a few. Each of these classes has many methods that can be used for different synchronization<a id="_idIndexMarker1027"/> needs. Check the online <strong class="bold">application programming interface</strong> (<strong class="bold">API</strong>) documentation for each<a id="_idIndexMarker1028"/> of these classes (<a href="https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/util/concurrent/atomic/package-summary.html">https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/util/concurrent/atomic/package-summary.html</a>). For the demonstration, we will use only two methods present in all of them, as outlined here:</p>
			<ul>
				<li><strong class="source-inline">V get()</strong>: Returns the current value</li>
				<li><strong class="source-inline">boolean compareAndSet(V expectedValue, V newValue)</strong>: Sets the value to <strong class="source-inline">newValue</strong> if the current value equals via the (<strong class="source-inline">==</strong>) operator the <strong class="source-inline">expectedValue</strong> value; returns <strong class="source-inline">true</strong> if successful or <strong class="source-inline">false</strong> if the actual value was not equal to the expected value</li>
			</ul>
			<p>Here is how the <strong class="source-inline">AtomicReference</strong> class can be used to solve the problem of thread interference while accessing the <strong class="source-inline">prop</strong> property of the <strong class="source-inline">Calculator</strong> object concurrently using these two methods:</p>
			<pre class="source-code">class CalculatorAtomicRef implements Calculator {</pre>
			<pre class="source-code">    private AtomicReference&lt;Double&gt; prop = </pre>
			<pre class="source-code">                              new AtomicReference&lt;&gt;(0.0);</pre>
			<pre class="source-code">    private String description = "Using AtomicReference";</pre>
			<pre class="source-code">    public String getDescription(){ return description; }</pre>
			<pre class="source-code">    public double calculate(int i){</pre>
			<pre class="source-code">       try {</pre>
			<pre class="source-code">          Double currentValue = prop.get();</pre>
			<pre class="source-code">          TimeUnit.MILLISECONDS.sleep(i);</pre>
			<pre class="source-code">          boolean b = </pre>
			<pre class="source-code">           this.prop.compareAndSet(currentValue, 2.0 * i);</pre>
			<pre class="source-code">          //System.out.println(b); </pre>
			<pre class="source-code">                            //prints: true for one thread </pre>
			<pre class="source-code">                            //and false for another thread</pre>
			<pre class="source-code">           return Math.sqrt(this.prop.get());</pre>
			<pre class="source-code">       } catch (InterruptedException e) {</pre>
			<pre class="source-code">         Thread.currentThread().interrupt();</pre>
			<pre class="source-code">         System.out.println("Calculator was interrupted");</pre>
			<pre class="source-code">       }</pre>
			<pre class="source-code">       return 0.0;</pre>
			<pre class="source-code">    }</pre>
			<pre class="source-code">}</pre>
			<p>As you can see, the preceding<a id="_idIndexMarker1029"/> code makes sure<a id="_idIndexMarker1030"/> that the <strong class="source-inline">currentValue</strong> value of the <strong class="source-inline">prop</strong> property does not change while the thread was sleeping. Here is a screenshot of messages produced when we run <strong class="source-inline">invokeAllCallables(new CalculatorAtomicRef())</strong>:</p>
			<div>
				<div id="_idContainer069" class="IMG---Figure">
					<img src="image/B18388_Figure_8.9.jpg" alt=""/>
				</div>
			</div>
			<p>Now, the results produced<a id="_idIndexMarker1031"/> by the threads<a id="_idIndexMarker1032"/> are the same.</p>
			<p>The following classes of the <strong class="source-inline">java.util.concurrent</strong> package provide synchronization support too:</p>
			<ul>
				<li><strong class="source-inline">Semaphore</strong>: Restricts the number of threads that can access a resource</li>
				<li><strong class="source-inline">CountDownLatch</strong>: Allows one or more threads to wait until a set of operations being performed in other threads are completed</li>
				<li><strong class="source-inline">CyclicBarrier</strong>: Allows sets of threads to wait for each other to reach a common barrier point</li>
				<li><strong class="source-inline">Phaser</strong>: Provides a more flexible form of barrier that may be used to control phased computation among multiple threads</li>
				<li><strong class="source-inline">Exchanger</strong>: Allows two threads to exchange objects at a rendezvous point and is useful in several pipeline designs</li>
			</ul>
			<h2 id="_idParaDest-200"><a id="_idTextAnchor199"/>Synchronized method</h2>
			<p>Another way to solve the problem<a id="_idIndexMarker1033"/> is to use a synchronized method. Here is another implementation of the <strong class="source-inline">Calculator</strong> interface<a id="_idIndexMarker1034"/> that uses this method of solving thread interference:</p>
			<pre class="source-code">class CalculatorSyncMethod implements Calculator {</pre>
			<pre class="source-code">    private double prop;</pre>
			<pre class="source-code">    private String description = "Using synchronized method";</pre>
			<pre class="source-code">    public String getDescription(){ return description; }</pre>
			<pre class="source-code">    synchronized public double calculate(int i){</pre>
			<pre class="source-code">       try {</pre>
			<pre class="source-code">           //there may be some other code here</pre>
			<pre class="source-code">           synchronized (this) {</pre>
			<pre class="source-code">              this.prop = 2.0 * i;</pre>
			<pre class="source-code">              TimeUnit.MILLISECONDS.sleep(i);</pre>
			<pre class="source-code">              return Math.sqrt(this.prop);</pre>
			<pre class="source-code">           }</pre>
			<pre class="source-code">       } catch (InterruptedException e) {</pre>
			<pre class="source-code">         Thread.currentThread().interrupt();</pre>
			<pre class="source-code">         System.out.println("Calculator was interrupted");</pre>
			<pre class="source-code">       }</pre>
			<pre class="source-code">       return 0.0;</pre>
			<pre class="source-code">    }</pre>
			<pre class="source-code">}</pre>
			<p>We have just added<a id="_idIndexMarker1035"/> the <strong class="source-inline">synchronized</strong> keyword in front<a id="_idIndexMarker1036"/> of the <strong class="source-inline">calculate()</strong> method. Now, if we run <strong class="source-inline">invokeAllCallables(new CalculatorSyncMethod())</strong>, the results of both threads are always going to be the same, as we can see here:</p>
			<div>
				<div id="_idContainer070" class="IMG---Figure">
					<img src="image/B18388_Figure_8.10.jpg" alt=""/>
				</div>
			</div>
			<p>This is because another thread cannot enter the synchronized method until the current thread (the one that has entered the method already) has exited it. This is probably the simplest solution, but this approach<a id="_idIndexMarker1037"/> may cause performance degradation if the method takes a long time to execute. In such cases, a synchronized block<a id="_idIndexMarker1038"/> can be used, which only wraps several lines of code in an atomic operation.</p>
			<h2 id="_idParaDest-201"><a id="_idTextAnchor200"/>Synchronized block</h2>
			<p>Here is an example of a synchronized block<a id="_idIndexMarker1039"/> used to solve the problem of thread<a id="_idIndexMarker1040"/> interference:</p>
			<pre class="source-code">class CalculatorSyncBlock implements Calculator {</pre>
			<pre class="source-code">    private double prop;</pre>
			<pre class="source-code">    private String description = "Using synchronized block";</pre>
			<pre class="source-code">    public String getDescription(){</pre>
			<pre class="source-code">        return description;</pre>
			<pre class="source-code">    }</pre>
			<pre class="source-code">    public double calculate(int i){</pre>
			<pre class="source-code">        try {</pre>
			<pre class="source-code">            //there may be some other code here</pre>
			<pre class="source-code">            synchronized (this) {</pre>
			<pre class="source-code">                this.prop = 2.0 * i;</pre>
			<pre class="source-code">                TimeUnit.MILLISECONDS.sleep(i);</pre>
			<pre class="source-code">                return Math.sqrt(this.prop);</pre>
			<pre class="source-code">            }</pre>
			<pre class="source-code">        } catch (InterruptedException e) {</pre>
			<pre class="source-code">            Thread.currentThread().interrupt();</pre>
			<pre class="source-code">            System.out.println("Calculator was interrupted");</pre>
			<pre class="source-code">        }</pre>
			<pre class="source-code">        return 0.0;</pre>
			<pre class="source-code">    }</pre>
			<pre class="source-code">}</pre>
			<p>As you can see, the synchronized block<a id="_idIndexMarker1041"/> acquires a lock on the <strong class="source-inline">this</strong> object, which is shared by both threads, and releases<a id="_idIndexMarker1042"/> it only after the threads exit the block. In our demonstration code, the block covers all the code of the method, so there is no difference in performance. But imagine there is more code in the method (we commented the location as <strong class="source-inline">there may be some other code here</strong>). If that is the case, the synchronized section of the code is smaller, thus having fewer chances to become a bottleneck.</p>
			<p>If we run <strong class="source-inline">invokeAllCallables(new CalculatorSyncBlock())</strong>, the results look like this:</p>
			<div>
				<div id="_idContainer071" class="IMG---Figure">
					<img src="image/B18388_Figure_8.11.jpg" alt=""/>
				</div>
			</div>
			<p>As you can see, the results are exactly the same as in the previous two examples. Different types of locks for different needs and with different behavior are assembled in the <strong class="source-inline">java.util.concurrent.locks</strong> package. </p>
			<p>Each object in Java inherits the <strong class="source-inline">wait()</strong>, <strong class="source-inline">notify()</strong>, and <strong class="source-inline">notifyAll()</strong> methods from the base<a id="_idIndexMarker1043"/> object. These methods can also be used to control <a id="_idIndexMarker1044"/>threads’ behavior and their access to the locks.</p>
			<h2 id="_idParaDest-202"><a id="_idTextAnchor201"/>Concurrent collections </h2>
			<p>Another way to address concurrency<a id="_idIndexMarker1045"/> is to use a thread-safe collection<a id="_idIndexMarker1046"/> from the <strong class="source-inline">java.util.concurrent</strong> package. Before you select which collection<a id="_idIndexMarker1047"/> to use, read the <em class="italic">Javadoc</em> documentation (<a href="https://docs.oracle.com/en/java/javase/17/docs/api/index.html">https://docs.oracle.com/en/java/javase/17/docs/api/index.html</a>) to see whether the limitations of the collection are acceptable<a id="_idIndexMarker1048"/> for your application. Here is a list of these collections and some recommendations:</p>
			<ul>
				<li><strong class="source-inline">ConcurrentHashMap&lt;K,V&gt;</strong>: Supports full concurrency of retrievals and high-expected concurrency for updates; use it when the concurrency requirements are very demanding and you need to allow locking on the write operation but do not need to lock the element.</li>
				<li><strong class="source-inline">ConcurrentLinkedQueue&lt;E&gt;</strong>: A thread-safe queue based on linked nodes; employs an efficient non-blocking algorithm.</li>
				<li><strong class="source-inline">ConcurrentLinkedDeque&lt;E&gt;</strong>: A concurrent queue based on linked nodes; both <strong class="source-inline">ConcurrentLinkedQueque</strong> and <strong class="source-inline">ConcurrentLinkedDeque</strong> are an appropriate choice when many threads share access to a common collection.</li>
				<li><strong class="source-inline">ConcurrentSkipListMap&lt;K,V&gt;</strong>: A concurrent <strong class="source-inline">ConcurrentNavigableMap</strong> interface implementation.</li>
				<li><strong class="source-inline">ConcurrentSkipListSet&lt;E&gt;</strong>: A concurrent <strong class="source-inline">NavigableSet</strong> implementation based on the <strong class="source-inline">ConcurrentSkipListMap</strong> class. The <strong class="source-inline">ConcurrentSkipListSet</strong> and <strong class="source-inline">ConcurrentSkipListMap</strong> classes, as per the <em class="italic">Javadoc</em> documentation, “<em class="italic">provide expected average log(n) time cost for the contains, add, and remove operations and their variants. Ascending ordered views and their iterators are faster than descending ones</em>.” Use them when you need to iterate quickly through elements in a certain order.</li>
				<li><strong class="source-inline">CopyOnWriteArrayList&lt;E&gt;</strong>: A thread-safe variant of <strong class="source-inline">ArrayList</strong> in which all mutative operations (add, set, and so on) are implemented by making a fresh copy of the underlying array. As per the <em class="italic">Javadoc</em> documentation, the <strong class="source-inline">CopyOnWriteArrayList</strong> class “<em class="italic">is ordinarily too costly, but may be more efficient than alternatives when traversal operations vastly outnumber mutations, and is useful when you cannot or don't want to synchronize traversals, yet need to preclude interference among concurrent threads</em>.” Use it when you<a id="_idIndexMarker1049"/> do not need to add new elements<a id="_idIndexMarker1050"/> at different positions and do not require sorting; otherwise, use <strong class="source-inline">ConcurrentSkipListSet</strong>.</li>
				<li><strong class="source-inline">CopyOnWriteArraySet&lt;E&gt;</strong>: A set that uses an internal <strong class="source-inline">CopyOnWriteArrayList</strong> class for all of its operations.</li>
				<li><strong class="source-inline">PriorityBlockingQueue</strong>: This is a better choice when a natural order is acceptable and you need fast adding of elements to the tail and fast removing of elements from the head<a id="_idIndexMarker1051"/> of the queue. <strong class="bold">Blocking</strong> means that the queue waits to become non-empty when retrieving an element and waits for space to become available in the queue when storing an element.</li>
				<li><strong class="source-inline">ArrayBlockingQueue</strong>, <strong class="source-inline">LinkedBlockingQueue</strong>, and <strong class="source-inline">LinkedBlockingDeque</strong> have a fixed size (bounded); other queues are unbounded.</li>
			</ul>
			<p>Use these and similar characteristics and recommendations as per the guidelines, but execute comprehensive testing and performance-measuring before and after implementing your functionality. To demonstrate some of these collections’ capabilities, let’s use <strong class="source-inline">CopyOnWriteArrayList&lt;E&gt;</strong>. First, let’s look in the following code snippet at how <strong class="source-inline">ArrayList</strong> behaves when we try to modify it concurrently:</p>
			<pre class="source-code">List&lt;String&gt; list = Arrays.asList("One", "Two");</pre>
			<pre class="source-code">System.out.println(list);</pre>
			<pre class="source-code">try {</pre>
			<pre class="source-code">    for (String e : list) {</pre>
			<pre class="source-code">        System.out.println(e);  //prints: One</pre>
			<pre class="source-code">        list.add("Three");      //UnsupportedOperationException</pre>
			<pre class="source-code">    }</pre>
			<pre class="source-code">} catch (Exception ex) {</pre>
			<pre class="source-code">    ex.printStackTrace();</pre>
			<pre class="source-code">}</pre>
			<pre class="source-code">System.out.println(list);       //prints: [One, Two]</pre>
			<p>As expected, the attempt to modify a list while iterating<a id="_idIndexMarker1052"/> on it generates an exception, and the list<a id="_idIndexMarker1053"/> remains unmodified.</p>
			<p>Now, let’s use <strong class="source-inline">CopyOnWriteArrayList&lt;E&gt;</strong> in the same circumstances, as follows:</p>
			<pre class="source-code">List&lt;String&gt; list = </pre>
			<pre class="source-code">       new CopyOnWriteArrayList&lt;&gt;(Arrays.asList("One", "Two"));</pre>
			<pre class="source-code">System.out.println(list);</pre>
			<pre class="source-code">try {</pre>
			<pre class="source-code">    for (String e : list) {</pre>
			<pre class="source-code">        System.out.print(e + " "); //prints: One Two</pre>
			<pre class="source-code">        list.add("Three");         //adds element Three</pre>
			<pre class="source-code">    }</pre>
			<pre class="source-code">} catch (Exception ex) {</pre>
			<pre class="source-code">    ex.printStackTrace();</pre>
			<pre class="source-code">}</pre>
			<pre class="source-code">System.out.println("\n" + list);</pre>
			<pre class="source-code">                             //prints: [One, Two, Three, Three]</pre>
			<p>The output this code produces looks like this:</p>
			<div>
				<div id="_idContainer072" class="IMG---Figure">
					<img src="image/B18388_Figure_8.12.jpg" alt=""/>
				</div>
			</div>
			<p>As you can see, the list was modified<a id="_idIndexMarker1054"/> without an exception, but not the currently iterated copy. That is the behavior<a id="_idIndexMarker1055"/> you can use if needed.</p>
			<h2 id="_idParaDest-203"><a id="_idTextAnchor202"/>Addressing memory consistency errors</h2>
			<p>Memory consistency errors<a id="_idIndexMarker1056"/> can have many forms and causes in a multithreaded<a id="_idIndexMarker1057"/> environment. They are well discussed in the <em class="italic">Javadoc</em> documentation of the <strong class="source-inline">java.util.concurrent</strong> package. Here, we will mention only the most common case, which is caused by a lack of visibility.</p>
			<p>When one thread changes a property value, the other might not see the change immediately, and you cannot use the <strong class="source-inline">synchronized</strong> keyword for a primitive type. In such a situation, consider using the <strong class="source-inline">volatile</strong> keyword for the property, as this guarantees its read/write visibility between different threads.</p>
			<p>Concurrency problems are not easy to solve, which is why it is not surprising that more and more developers are now taking a more radical approach. Instead of managing an object state, they prefer processing data in a set of stateless operations. We will see examples of such code in <a href="B18388_13_ePub.xhtml#_idTextAnchor281"><em class="italic">Chapter 13</em></a>, <em class="italic">Functional Programming</em>, and <a href="B18388_14_ePub.xhtml#_idTextAnchor296"><em class="italic">Chapter 14</em></a>, <em class="italic">Java Standard Streams</em>. It seems that Java and many modern languages and computer systems are evolving in this direction.</p>
			<h1 id="_idParaDest-204"><a id="_idTextAnchor203"/>Summary</h1>
			<p>In this chapter, we talked about multithreaded processing, ways to organize it, and avoiding unpredictable results caused by concurrent modification of the shared resource. We have shown you how to create threads and execute them using pools of threads. We have also demonstrated how results can be extracted from the threads that have completed successfully and discussed the difference between parallel and concurrent processing. </p>
			<p>In the next chapter, we will provide you with a deeper understanding of JVM and its structure and processes, and we’ll discuss in detail the garbage-collection process that keeps memory from being overflown. By the end of the chapter, you will know what constitutes Java application execution, Java processes inside JVM, garbage collection, and how JVM works in general.</p>
			<h1 id="_idParaDest-205"><a id="_idTextAnchor204"/>Quiz</h1>
			<ol>
				<li>Select all correct statements:<ol><li>A JVM process can have main threads.</li><li>The main thread is the main process.</li><li>A process can launch another process.</li><li>A thread may launch another thread.</li></ol></li>
				<li>Select all correct statements:<ol><li>A daemon is a user thread.</li><li>A daemon thread exits after the first user thread completes.</li><li>A daemon thread exits after the last user thread completes.</li><li>The main thread is a user thread.</li></ol></li>
				<li>Select all correct statements:<ol><li>All threads have <strong class="source-inline">java.lang.Thread</strong> as a base class.</li><li>All threads extend <strong class="source-inline">java.lang.Thread</strong>.</li><li>All threads implement <strong class="source-inline">java.lang.Thread</strong>.</li><li>A daemon thread does not extend <strong class="source-inline">java.lang.Thread</strong>.</li></ol></li>
				<li>Select all correct statements:<ol><li>Any class can implement the <strong class="source-inline">Runnable</strong> interface.</li><li>The <strong class="source-inline">Runnable</strong> interface implementation is a thread.</li><li>The <strong class="source-inline">Runnable</strong> interface implementation is used by a thread.</li><li>The <strong class="source-inline">Runnable</strong> interface has only one method.</li></ol></li>
				<li>Select all correct statements:<ol><li>A thread name has to be unique.</li><li>A thread ID is generated automatically.</li><li>A thread name can be set.</li><li>A thread priority can be set.</li></ol></li>
				<li>Select all correct statements:<ol><li>A thread pool executes threads.</li><li>A thread pool reuses threads.</li><li>Some thread pools can have a fixed count of threads.</li><li>Some thread pools can have an unlimited count of threads.</li></ol></li>
				<li>Select all correct statements:<ol><li>A <strong class="source-inline">Future</strong> object is the only way to get the result from a thread.</li><li>A <strong class="source-inline">Callable</strong> object is the only way to get the result from a thread.</li><li>A <strong class="source-inline">Callable</strong> object allows us to get the result from a thread.</li><li>A <strong class="source-inline">Future</strong> object represents a thread.</li></ol></li>
				<li>Select all correct statements:<ol><li>Concurrent processing can be done in parallel.</li><li>Parallel processing is possible only with several CPUs or cores available on the computer.</li><li>Parallel processing is concurrent processing.</li><li>Without multiple CPUs, concurrent processing is impossible.</li></ol></li>
				<li>Select all correct statements:<ol><li>Concurrent modification always leads to incorrect results.</li><li>An atomic variable protects a property from concurrent modification.</li><li>An atomic variable protects a property from thread interference.</li><li>An atomic variable is the only way to protect a property from concurrent modification.</li></ol></li>
				<li>Select all correct statements:<ol><li>The <strong class="source-inline">synchronized</strong> method is the best way to avoid thread interference.</li><li>The <strong class="source-inline">synchronized</strong> keyword can be applied to any method.</li><li>The <strong class="source-inline">synchronized</strong> method can create a processing bottleneck.</li><li>The <strong class="source-inline">synchronized</strong> method is easy to implement.</li></ol></li>
				<li>Select all correct statements:<ol><li>A <strong class="source-inline">synchronized</strong> block makes sense only when it is smaller than the method.</li><li>A <strong class="source-inline">synchronized</strong> block requires a shared lock.</li><li>Every Java object can provide a lock.</li><li>A <strong class="source-inline">synchronized</strong> block is the best way to avoid thread interference.</li></ol></li>
				<li>Select all correct statements:<ol><li>Using a concurrent collection is preferred over using a non-concurrent one.</li><li>Using a concurrent collection incurs some overhead.</li><li>Not every concurrent collection fits every concurrent processing scenario.</li><li>We can create a concurrent collection by calling the <strong class="source-inline">Collections.makeConcurrent()</strong> method.</li></ol></li>
				<li>Select all correct statements:<ol><li>The only way to avoid a memory consistency error is to declare the <strong class="source-inline">volatile</strong> variable.</li><li>Using the <strong class="source-inline">volatile</strong> keyword guarantees visibility of the value change across all threads.</li><li>One way to avoid concurrency is to avoid any state management.</li><li>Stateless utility methods cannot have concurrency issues.</li></ol></li>
			</ol>
		</div>
	</body></html>