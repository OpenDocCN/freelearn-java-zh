<html><head></head><body><div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">The Spring Project and Framework</h1>
                </header>
            
            <article>
                
<p class="mce-root">The Spring Framework is a mature, enterprise-grade, and open source application development framework that provides a flexible and modern alternative to the official Java EE standard.</p>
<p class="mce-root">Spring Boot is a technology that allows developers to write Spring Framework-based applications while relying on best practices by providing convention over configuration and dependency management for Gradle and Maven to ensure that they have compatible versions of all libraries. This eliminates a lot of tasks that are required when writing enterprise applications or services. Spring Boot also addresses the issue of duplicating and plumbing code by offering a robust integration with other frameworks. Simultaneously, developers are able to diverge from its carefully crafted conventions when necessary.</p>
<p class="mce-root">By the end of this chapter, you will be able to:</p>
<ul>
<li class="mce-root">Describe the Spring Framework</li>
<li class="mce-root">Construct and run a simple project</li>
<li class="mce-root">Utilize the application context of Spring</li>
<li class="mce-root">Use the Project Lombok library</li>
</ul>
<p class="mce-root"/>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Introduction to the Spring Framework</h1>
                </header>
            
            <article>
                
<p>The Spring Framework is an open source application framework that can be used by any Java application. It provides an Inversion of Control (IoC) container for the Java platform. In this section, we will look at an overview of the Spring project itself and will be introduced to the basic building blocks of a Spring application. You are going to learn about the history of the Spring Framework, the key principles that Spring focuses on, Dependency Injection and Inversion of Control. Lastly, we will examine the Spring ecosystem.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">A Short History</h1>
                </header>
            
            <article>
                
<p>The <strong>Spring Framework</strong> was created by Rod Johnson in 2003 as an alternative to the heavyweight and slow J2EE 1.4 stack. The current steward of the project is Pivotal Software, which employs the core developers and steers the development of the project.</p>
<p>The framework itself is source and has a large number of contributors that help in the development of the various modules. But we will come to that shortly</p>
<p>Due to its focus on productivity, Spring gained a lot of market share. Zeroturnaround, a company that creates Java development tools, did a survey in 2016 and 36% of the participants wanted to convert their project to Spring, while only 14% wanted to convert to JEE. It is hard to find concrete market share data for JEE versus Spring, but in Java developer surveys, Spring is usually far beyond 50% while JEE is far below. This is also reflected in job listings, where Spring has trumped JEE for years.</p>
<p>Spring is used worldwide by companies of all sizes. Netflix is, for example, very public about their usage of Spring and they even provide a large part of the Spring Cloud stack.</p>
<div class="packt_infobox"><br/>
For a little more background on the Spring Framework versions, you can read the entry at <a href="https://github.com/spring-projects/spring-framework/wiki/Spring-Framework-Versions">https://github.com/spring-projects/spring-framework/wiki/Spring-Framework-Versions</a>.<br/>
To get a feel for where Spring is used, you can also have a look at <a href="https://stackshare.io/spring/in-stacks">https://stackshare.io/spring/in-stacks</a>.</div>
<p class="mce-root"/>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Spring Key Principles</h1>
                </header>
            
            <article>
                
<p>The development of the Spring Framework is based on a few principles, which have been consistent factors since its inception:</p>
<ul>
<li><strong>Inversion of Control</strong> and <strong>Dependency Injection</strong> builds the core of the whole framework.</li>
<li><strong>Modularity</strong> allows you to plug in different implementations such as logging framework templating engines and internal code, which creates proxies for aspect-oriented programming.</li>
<li><strong>Testability</strong> enables the whole project and is geared toward the creation of testable application code.</li>
<li><strong>Convenience</strong> is offered to developers in many aspects and makes developers productive without being too intrusive.</li>
</ul>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">J2EE Pain Points</h1>
                </header>
            
            <article>
                
<p>The official J2EE standard received a lot of criticism from the developer community within the last two years. The main problems were as follows:</p>
<ul>
<li>The standard was created by a committee, which led to a lot of features that were hard to use.</li>
<li>The committee was slow in adopting new technologies, which led to many projects that were developed outside of the J2EE scope to serve these needs.</li>
<li>The application servers were very expensive and relatively slow in adopting the new standards.</li>
<li>The amount of code that had to be written was way too high in the J2EE 1.0 - 1.4 days.</li>
<li>A huge amount of XML documents were required to configure the application. This either led to errors or required an IDE, which helped to keep everything in sync.</li>
<li>Due to the "specification first" approach, many features were very complicated to use, which led to mistakes or made people abandon certain features completely.</li>
</ul>
<p class="mce-root"/>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Spring as a Counterpart for J2EE</h1>
                </header>
            
            <article>
                
<p>Rod Johnson wanted to change the way that J2EE forced the people to take their coding approach, so he deliberately went the other way in many aspects:</p>
<ul>
<li>In contrast to the ivory tower approach, Spring uses "code first", which has later been adopted in the Java community and committees.</li>
<li>Spring is very modular and extensible, so new technologies are usually added using modules, which are only additional JAR files.</li>
<li>Spring didn't want to wait for the application servers to add features, so a Spring application included everything that was not provided by the application server or servlet container.</li>
<li>In contrast to J2EE, Spring always has less boilerplate code to achieve the same functionality. This advantage is now less relevant because the current versions of JavaEE are heavily inspired by Spring and copied many of its concepts.</li>
<li>In the beginning, Spring also used XML for its configuration, because it was considered state of the art. However, they started moving to annotations and Java-based configuration when Java 1.5 became available.</li>
<li>While it's still hard to get the source code of some JavaEE libraries, Spring always provided source JARs and allowed anyone to peek into the well-designed framework if necessary.</li>
</ul>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Inversion of Control and Dependency Injection</h1>
                </header>
            
            <article>
                
<p><strong>Inversion of Control</strong> (<strong>IoC</strong>) is a paradigm that defines how the application is written on a very low level. It basically flips the control flow, and your application code reacts to events triggered by the application framework.</p>
<p>This overlaps with the <strong>Dependency Inversion</strong> (<strong>DI</strong>) pattern, which is the broader version of Dependency Injection. When your application uses Dependency Injection, you don't create instances of important classes yourself; you let the container create the instances or provide you with existing ones. Especially when using interfaces, you are able to decouple components of your application. This means that you have parts that don't have direct dependencies on each other.</p>
<p>The fact that your application is reacting instead of controlling everything tightly helps to decouple parts of your application. Now, you have code that depends on the framework and much less on its other parts. This leads to less coupling and thus better maintainable and testable code. IoC is also called the Hollywood Principle with the slogan "Don't call us, we'll call you", which perfectly describes what it is.</p>
<div class="packt_infobox"><br/>
For a little more background on the Spring Framework, you can read the article at "TheServerSide", which is a large site related to Java and software development, at <a href="http://www.theserverside.com/news/1321158/A-beginners-guide-to-Dependency-Injection">http://www.theserverside.com/news/1321158/A-beginners-guide-to-Dependency-Injection</a>.</div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Inversion of Control and Dependency Injection Overview</h1>
                </header>
            
            <article>
                
<p>Take a look at the following table that highlights the main concepts:</p>
<div class="packt_figref CDPAlignCenter CDPAlign"><img src="Images/fb3a289e-7ff0-44db-a444-6119634c183d.png" style="width:29.50em;height:28.17em;" width="756" height="723"/></div>
<div class="packt_infobox"><br/>
For a little more background on the problems of a God object, you can read the entry at <a href="https://www.c-sharpcorner.com/article/godobject-a-code-smell/">https://www.c-sharpcorner.com/article/godobject-a-code-smell/</a>.</div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">The Spring Framework</h1>
                </header>
            
            <article>
                
<p>The building blocks of a typical Spring application look like this:</p>
<ul>
<li>The core container that controls the lifecycle of the application and contains the application context, which contains the instances of the classes that are managed by Spring.</li>
<li>Then, there are a number of modules that shape how the control flow in your application is triggered.</li>
<li>For example: Spring MVC, which is among other things responsible for dispatching requests to special classes that you usually write, which handle HTTP requests.</li>
<li>Spring messaging is used to process and send messages between systems.</li>
</ul>
<p>Scheduling is able to execute methods based on time-related events. For example; you have to execute a cleanup job every day at midnight.</p>
<ul>
<li>Spring Integration is able to query or fetch data from other systems using file transfers to process it.</li>
<li>Your code is called from these modules to serve its purpose.</li>
</ul>
<p>During or after your code execution, you often prepare data that needs to be stored in a database or is returned to the user or caller. So, other parts of a Spring application are as follows:</p>
<ul>
<li>The view renderer, which takes prepared data and renders it as an HTML page, for example.</li>
<li><strong>Object</strong> (<strong>un-</strong>)<strong>marshaling</strong> is the process of transforming incoming or outgoing data into another form. This is usually the transformation from and to XML or JSON, but other formats are possible as well.</li>
<li>Depending on the type of application you write, there are also other modules that Spring offers to make software development easier.</li>
</ul>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">The Spring Ecosystem</h1>
                </header>
            
            <article>
                
<p>The modularity of Spring led to the creation of many modules in the last 15+ years. Some have been retired, but the official homepage lists 23 main projects, and some of them even have between five and 10 sub-projects.</p>
<p>This means that, for everything you want to do, there is a good chance that there is a Spring module that can assist you. As a result, you can concentrate on the business objectives instead of writing the 100th message passing framework or other foundational aspects. Of course, this also means that it is very easy to get lost in the sea of projects and dependencies that have to be added and configured.</p>
<p>This was one of the big concerns when people spoke about Spring a few years ago. It required a lot of configuration and the setup of a new project took a long time until everything was working as expected.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Spring Boot Features</h1>
                </header>
            
            <article>
                
<p>This is where Spring Boot rushes in to save the day. Spring Boot is a regular Spring project that aims to make the development experience much more pleasant. This is achieved by relying heavily on the following:</p>
<ul>
<li>Convention over configuration</li>
<li>Auto-detection of features</li>
<li>Dependency management to minimize the pain to find compatible versions of all libraries</li>
</ul>
<p>The focus is on providing production-ready features without any code generation. This enables you to write simple applications that could be exposed to the internet within minutes.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Bootstrapping</h1>
                </header>
            
            <article>
                
<p>We are going to create the first Spring Boot project in this section by using the Spring project generator called <strong>Spring Initializr</strong>. Then, we will have a look at the generated code and start the application for the first time.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Spring Initializr</h1>
                </header>
            
            <article>
                
<p>The Spring Initializr project began in 2013. Today, it supports Maven and Gradle projects, written in Java, Kotlin, or Groovy. The target platforms are JDK 7 up to 9 at the moment. The generator is capable of creating Spring Boot 1.x or 2.x projects.</p>
<p>When you use the project creation wizard in your IDE for a Spring Boot project, it is likely that it uses <kbd>start.spring.io</kbd>, which is the website of the Spring Initializr. IntelliJ and Eclipse both have built-in support for the generator.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Creating the First Spring Initializr Project</h1>
                </header>
            
            <article>
                
<p>The aim is to create a project using the Spring Initializr. <span>After covering this, you will have generated a simple Spring Boot application that can </span><span>be used as a starting point for further development. </span>The steps for completion are as follows:</p>
<ol>
<li>Open <kbd>start.spring.io</kbd>.</li>
<li>Create a simple <strong>Maven project</strong> with <strong>Java</strong> and Spring Boot <strong>2.0.5</strong>.</li>
<li>Enter the following details:</li>
</ol>
<ul>
<li style="list-style-type: none">
<ul>
<li>Group: <kbd>com.packt.springboot</kbd></li>
<li>Artifact: <kbd>blogmania</kbd></li>
</ul>
</li>
</ul>
<p style="padding-left: 60px">Take a look at the following screenshot:</p>
<div class="packt_figref CDPAlignCenter CDPAlign"><img src="Images/bcef0f46-1cb7-4972-95e6-1d9bd18faede.png" width="1204" height="579"/></div>
<ol start="4">
<li>Download and extract the project.</li>
</ol>
<p class="mce-root"/>
<div class="packt_infobox"><br/>
Don't add dependencies for now. However, you can click on the <span class="packt_screen"><span class="packt_screen">Switch</span> to the full version</span> link at the bottom of the page to display the number of available dependencies. You can fill out the name (<strong>BlogMania</strong>) and description (<strong>Self-hosted blogging made easy</strong>) in the full version, if you like.</div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Examining the Project in the IDE</h1>
                </header>
            
            <article>
                
<p>The aim is to open the IDE in order and examine important parts of the generated project. With this sub-section, you will have imported and examined the newly created Spring Boot application. <span>The steps for completion are as follows:</span></p>
<ol>
<li>Open the project using IntelliJ IDE.</li>
</ol>
<ul>
<li style="list-style-type: none">
<ol>
<li>Open IntelliJ.</li>
<li>Use the Menu or Starter Screen to open <kbd>pom.xml</kbd> as a new project.</li>
</ol>
</li>
</ul>
<ol start="2">
<li>Open <kbd>pom.xml</kbd> in the project pane on the left after the import. Have a look at these fragments in the file:</li>
</ol>
<ul>
<li style="list-style-type: none">
<ol>
<li><kbd>&lt;packaging&gt;jar&lt;/packaging&gt;</kbd>: The application will be built as a JAR file. The Spring Boot build plugin will create the remaining assets to make it executable.</li>
<li><kbd>&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/</kbd><br/>
<kbd>groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/</kbd><br/>
<kbd>artifactId&gt; … &lt;/parent&gt;</kbd>: Spring Boot applications usually have spring-boot-starter-parent configured as their parent POM, which provides a lot of preconfiguration of dependencies for the build process of the project.</li>
<li><kbd>&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/</kbd><br/>
<kbd>groupId&gt; &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt;&lt;/dependency&gt;</kbd>: The only real dependency is this starter, which will import the Spring Framework and more Spring Boot-related dependencies (37 in total, which includes test dependencies as well).</li>
</ol>
</li>
<li style="list-style-type: none"> 
<ol start="4">
<li><kbd>&lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/</kbd><br/>
<kbd>groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/</kbd><br/>
<kbd>artifactId&gt; &lt;/plugin&gt;</kbd>: This build plugin is responsible for creating the executable JAR file and to embed all the dependencies into this single file.</li>
</ol>
</li>
</ul>
<ol start="3">
<li>Open <kbd>src/main/java/BlogManiaApplication.java</kbd>. Have a look at these fragments in the file:
<ol>
<li><kbd>@SpringBootApplication</kbd>: This annotation marks the project as a Spring Boot application and tells Spring that this is the main class of this application. Spring Boot scans the classpath for Beans and other classes of interest, and by default it scans every package below the main application class.</li>
<li><kbd>public static void main(String[] args)</kbd><br/>
<kbd>{ SpringApplication.run(BlogManiaApplication.class, args); }</kbd>: This is the main method that is called from the JVM when the application starts. <kbd>SpringApplication.run(...)</kbd> initializes the application and the method call terminates once the Spring context is up. This means that you can have code after this call. The application itself terminates when the Spring context shuts down or the application is terminated from the outside by the operating system. Go to <a href="https://bit.ly/2x9gEUz">https://bit.ly/2x9gEUz</a> to access the code for the <kbd>BlogManiaApplication.java</kbd> file.</li>
</ol>
</li>
</ol>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Running a Project with Different Options</h1>
                </header>
            
            <article>
                
<p>The aim is to examine the various options to run the project. With this sub-section, you will have started the newly created Spring Boot application within IntelliJ or by using Maven. <span>The steps for completion are as follows:</span></p>
<p>To run the application, you have multiple options:</p>
<ol>
<li>In the Terminal:
<ol>
<li>Go to the project directory.</li>
<li>Execute the following command:</li>
</ol>
</li>
</ol>
<pre style="padding-left: 120px">  mvnw spring-boot:run</pre>
<p style="padding-left: 60px">Take a look at the following screenshot:</p>
<p class="mce-root CDPAlignCenter CDPAlign"><img src="Images/b954e7e8-8a3b-4d93-8f47-761b25101c40.png" style="width:50.00em;height:6.08em;" width="1180" height="144"/></p>
<ul>
<li style="list-style-type: none">
<ol start="3">
<li>Execute the following command:</li>
</ol>
</li>
</ul>
<ol start="2">
<li>In the IDE with Maven support:
<ol>
<li>Go to the Maven Tool Window.</li>
<li>Open <kbd>BlogMania/Plugins/spring-boot</kbd>.</li>
<li>Click <kbd>spring-boot:run</kbd>.</li>
</ol>
</li>
</ol>
<p style="padding-left: 60px">Take a look at the following screenshot:</p>
<div class="packt_figref CDPAlignCenter CDPAlign"><img src="Images/8104b205-7982-421e-888a-c3280da53015.png" style="width:31.67em;height:32.50em;" width="598" height="614"/></div>
<ol start="3">
<li>In the IDE using standard Java features:
<ol>
<li>Open <kbd>BlogManiaApplication.java</kbd>.</li>
<li>Right-click the <span class="packt_screen">main</span> method and select <span class="packt_screen">Run</span>.</li>
</ol>
</li>
</ol>
<p style="padding-left: 60px">Take a look at the following screenshot:</p>
<div class="packt_figref CDPAlignCenter CDPAlign"><img src="Images/032bcd4c-0754-4392-9f3b-8c4d2d5adfcd.png" style="width:44.58em;height:47.17em;" width="791" height="839"/></div>
<ol start="4">
<li>In the IntelliJ Ultimate version, you also have a Spring <strong>Run-Dashboard</strong>, which offers a lot of nice features to start and monitors Spring applications in your IDE.
<ol>
<li>This will start the application and you'll see the Spring Boot banner and some additional output from the Framework before the application terminates.</li>
</ol>
</li>
</ol>
<div class="packt_infobox"><br/>
The application terminates almost immediately since there is nothing to do. "Plain Spring" doesn't have a main loop that prevents the application from terminating. As soon as you add the Spring MVC dependencies, for example, the application will start up and wait for requests instead of stopping right away.<br/>
Go to <a href="https://bit.ly/2x9gEUz">https://bit.ly/2x9gEUz</a> to access the code for the <kbd>BlogManiaApplication.java</kbd> file.</div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">The Application Context</h1>
                </header>
            
            <article>
                
<p>In this section, we are going to explore the building blocks of Spring, how they are discovered by Spring, and how we can define them by hand, if necessary.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Spring Bean</h1>
                </header>
            
            <article>
                
<p>A Spring Bean is itself just a simple Java object, but it is the central building block in a Spring application. Its lifecycle is managed by the Spring IoC container. This means that it is created and controlled by the container during its lifetime. The main interface for the container is called <kbd>BeanFactory</kbd>, which is implemented by the <kbd>ApplicationContext</kbd>.</p>
<p>You can make a class a Spring Bean by declaring it as such. This is usually done by adding an annotation such as <kbd>@Component</kbd> to the class. Spring will find the class, create instances, and configure it based on what you have configured.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Spring Bean Stereotypes</h1>
                </header>
            
            <article>
                
<p>There are a number of annotations that you can use to mark a class a Spring Bean. They are used to convey a special meaning of the class. By default, some special types are available such as <kbd>@Component</kbd>, <kbd>@Service</kbd>, <kbd>@Repository</kbd>, and <kbd>@Controller</kbd>.</p>
<p>When you put these on a class, it will be treated as a Spring Bean and one instance will be created when the application starts. Its dependencies are set according to your configuration.</p>
<p>In general, it doesn't matter whether you are using <kbd>@Service</kbd> or <kbd>@Component</kbd> on a class. It's purely cosmetic and helps you to better understand what a class is supposed to do, because there is a semantic difference between these. Let's go over these annotations:</p>
<ul>
<li class="mce-root"><kbd>@Controller</kbd> marks classes in the context of web applications as something that handles requests. This will be covered in a later chapter.</li>
<li><kbd>@Service</kbd> marks classes that are considered services, which means that they often provide business functionality for other services or controllers.</li>
<li><kbd>@Repository</kbd> marks a class as a kind of data provider. A repository, for example, provides access to data by fetching data from a database, external web services, or something similar.</li>
<li><kbd>@Component</kbd> usually marks helper classes that don't fit into one of the other categories.</li>
</ul>
<p>These types are the default building blocks of many-layered architectures.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Exploring Spring Beans</h1>
                </header>
            
            <article>
                
<p>The aim is to enhance your first Spring Boot application by adding a few Beans to it. With this sub-section, you have seen the Spring context in action and you have seen how you can access the Spring context from the main method. <span>The steps for completion are as follows:</span></p>
<ol>
<li>Display the existing Beans.</li>
<li>Open the IDE with the imported project from earlier sub-sections.</li>
<li>Open the <kbd>BlogmaniaApplication.java</kbd> file.</li>
<li>Assign the result of <kbd>SpringApplication.run</kbd> to a variable called context.</li>
<li>Iterate over all defined Bean names that you can access by the <kbd>getBeanDefinitionNames()</kbd> method of the context object in the next line.</li>
<li>Run the application by executing the main method.</li>
</ol>
<div class="packt_infobox"><br/>
Go to <a href="https://bit.ly/2NaOkvJ">https://bit.ly/2NaOkvJ</a> to access the code for the <kbd>BlogManiaApplication.java</kbd> file.<br/>
You can see a number of Beans that are created by default. One of them is the <kbd>blogmaniaApplication</kbd>. By default, Beans are named like the class, beginning with a lowercase character.</div>
<p style="padding-left: 60px">This is how it could look:</p>
<pre style="padding-left: 60px">public static void main(String[] args) {<br/>  ConfigurableApplicationContext context = SpringApplication.<br/>run(BlogmaniaApplication.class, args);<br/>  for (String s : context.getBeanDefinitionNames()) {<br/>     System.out.println(s);<br/>  }<br/>}</pre>
<ol start="7">
<li>Add new Beans to the context.</li>
<li>Create a class called <kbd>BlogService</kbd> <span>as a public class in the same package as</span> <kbd>BlogmaniaApplication.java</kbd><span>.</span></li>
</ol>
<ol start="9">
<li>Create a class called <kbd>BlogRepository</kbd> <span>as a public class in the same package as</span> <kbd>BlogmaniaApplication.java</kbd><span>.</span></li>
<li>Add <kbd>@Repository</kbd> before the <kbd>public class …</kbd> on <kbd>BlogRepository.java</kbd>.</li>
<li>Run the application again.</li>
</ol>
<div class="packt_infobox"><br/>
You will notice that there is a new Bean named <kbd>blogRepository</kbd>, but no Bean named <kbd>blogService</kbd>, because we have not marked the class as a Spring Bean yet.</div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Configuration Classes</h1>
                </header>
            
            <article>
                
<p>Another way to declare Spring Beans is via <strong>configuration classes</strong>. These are used for more complicated Beans that require you to run code to initialize the Bean. Examples are reading configuration from somewhere or just a complicated setup to fulfill the dependencies. This is also used to create Beans from classes that are not under your control, so you can't add the annotations to them.</p>
<p>You can create a Bean by having a public method in a configuration class that is annotated with <kbd>@Bean</kbd> and returns an instance of your class.</p>
<p>The Bean will be named after the name of the method by default, while an annotated class will, by default, result in a Bean named like the class with the lowercase first character:</p>
<pre>@Configuration<br/>class MyConfiguration{<br/><br/>   @Bean<br/>   public Instant date(){<br/>       return Instant.now();<br/>   }<br/>}</pre>
<div class="packt_infobox"><br/>
Spring will make sure that no matter how often you call a <kbd>@Bean</kbd>-annotated method of a configuration class, it will return the correct Bean instance (under the hood, the result is computed only once).<br/>
You can also define something with <kbd>@Bean</kbd> in any Java class and it will be put in the context. Keep in mind that these are "Beans-lite", and many mechanisms won't work on these.</div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Classpath Scanning</h1>
                </header>
            
            <article>
                
<p>When people say Spring does magic, they often mean this mechanism. By default, Spring Boot scans the classpath based on the package the application class is in, or to be exact, the class that is annotated by <kbd>@SpringBootApplication</kbd>.</p>
<p>For example, it searches for known stereotypes (annotations) such as component, service, or repository or factory methods such as the <kbd>@Bean</kbd>-methods. The search covers the classpath, so dependencies that are added to the project are scanned as well!</p>
<p>In this example, <kbd>BlogmaniaApplication</kbd> is in the package <kbd>com.packt.springboot.blogmania</kbd> folder, so the package itself and all packages below it are scanned. Everything that is in <kbd>com.packt.springboot.that</kbd> and below is not scanned. You can modify the default behavior by adding <kbd>@ComponentScan</kbd> with the correct parameters if required, but most of the time, this shouldn't be necessary.</p>
<p class="mce-root">Take a look at the following screenshot:</p>
<div class="packt_figref CDPAlignCenter CDPAlign"><img src="Images/5a599a83-2bc1-4c28-a018-f8da1e4d6861.png" style="width:23.83em;height:23.75em;" width="658" height="654"/></div>
<div class="packt_infobox"><br/>
If you like, you can create a configuration class that defines a Bean and play around with that. We will have more practical sections with configuration classes in <em><a href="f4efef8a-3e71-483b-84be-a741a3f8ff0d.xhtml">Chapter 2</a>: Building a Spring Application</em>.</div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Additional Tools – Project Lombok</h1>
                </header>
            
            <article>
                
<p>In this section, you will recognize some of the boilerplate code in Java and define where <strong>Project Lombok</strong> helps you. This is a Java library that improves your Java by automatically plugging into your editor to build tools.</p>
<div class="packt_infobox"><br/>
Boilerplate code is code that you have to write in order to achieve a goal. This code is almost identical all the time or so similar that you wish you didn't have to write it, since it's obvious.</div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Java Beans</h1>
                </header>
            
            <article>
                
<p>A Java Bean has to follow a certain pattern to be recognized as a Java Bean. For example, all properties should have <strong>Getters</strong> and <strong>Setters</strong> (which return the value of a private member variable), although you might omit the Setter, for example, when a property is read-only. This means that for a data class that just has 10 fields, you also have to write 20 methods that adhere to the correct naming scheme and just store or pass along the property value. This is a prime example for boilerplate code.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Java Class</h1>
                </header>
            
            <article>
                
<p>We have seen that Java Beans have some kind of ceremony around their structure, but the same is true for plain Java classes. For example, the equals(), <kbd>hashCode()</kbd>, and <kbd>compareTo(...)</kbd> methods need to adhere to a set of rules as well.</p>
<p>When a class overrides one of them, it needs to make sure that the other two work as they should in regard to the Java Object contract.</p>
<p>When instance A and instance B are equal, their <kbd>hashCode</kbd> needs to be the same. When you break this contract, you will get weird errors during runtime when using Sets, <kbd>HashMaps</kbd>, and so on. Also, having a <kbd>toString()</kbd> method that really prints the content of your class helps a lot in debugging and logging.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Example Class</h1>
                </header>
            
            <article>
                
<p>An example class looks like this:</p>
<pre>public class BlogEntry {<br/>   private int id;<br/>   private String title;<br/>   private List&lt;String&gt; tags = new ArrayList&lt;&gt;();<br/>   private String text;<br/>   private boolean visible = true;<br/><br/>   //[...]@Override<br/><br/>   public void setVisible(boolean visible) {<br/>       this.visible = visible;<br/>   }<br/>}</pre>
<p>You can see that this is a lot of code for five simple data fields. The whole class definition is approximately 44 lines of code. You can generate a lot of this code in your IDE if you like, but it would be a lot better to not have that code at all!</p>
<div class="packt_infobox"><br/>
Go to <a href="https://bit.ly/2QrH8cT">https://bit.ly/2QrH8cT</a> to access the complete code for the example class file.</div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Project Lombok to the Rescue</h1>
                </header>
            
            <article>
                
<p>There is a library called <strong>Project Lombok</strong> that generates code based on annotations. This makes it much easier to develop Java software.</p>
<p>Project Lombok helps by generating:</p>
<ul>
<li>Getters/Setters</li>
<li><kbd>equals()</kbd>/<kbd>hashCode()</kbd></li>
<li>Constructors</li>
<li>Static loggers</li>
<li>Builder classes</li>
</ul>
<p>To add Lombok to your project, you need to add the following dependency (the version is managed by Spring Boot):</p>
<pre>&lt;dependency&gt;<br/>  &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;<br/>  &lt;artifactId&gt;lombok&lt;/artifactId&gt;<br/>&lt;/dependency&gt;</pre>
<div class="packt_infobox"><br/>
If you add Project Lombok to your project, you might need to enable something that is called <strong>annotation processing</strong> in your IDE and install the Lombok plugin. This is available in the plugin catalog.</div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Project Lombok Enhanced Class</h1>
                </header>
            
            <article>
                
<p>Here is some code with the same functionality:</p>
<pre>@Data<br/>public class BlogEntry {<br/>   private int id;<br/>   private String title;<br/>   private List&lt;String&gt; tags = new ArrayList&lt;&gt;();<br/>   private String text;<br/>   private boolean visible = true;<br/>}</pre>
<p>The <kbd>@Data</kbd> annotation combines the following annotations:</p>
<pre>@ToString:</pre>
<p>generates a <kbd>toString()</kbd> method that prints all fields</p>
<pre>@EqualsAndHashCode:</pre>
<p>generates <kbd>equals()</kbd> and <kbd>hashCode()</kbd> based on all fields</p>
<pre>@Getter:</pre>
<p>generates Getter methods for all fields</p>
<pre>@Setter:</pre>
<p>generates Setter methods for all non-final or non-transient fields</p>
<pre>@RequiredArgsConstructor:</pre>
<p>generates a constructor with all fields as a constructor that need a value (final fields without initialization, not-null fields, and so on)</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Activity: Project Lombok in Action</h1>
                </header>
            
            <article>
                
<p><strong>Aim</strong></p>
<p>To create a class that uses Lombok. You are going to store the class command the name of the Bean in your own data structure.</p>
<p><strong>Scenario</strong></p>
<p>You should reuse the Blogmania application with Beans project and open it in the IDE.</p>
<p><strong>Steps for Completion</strong></p>
<ol>
<li>Create a <kbd>BeanData</kbd> class in the package that contains the <kbd>Application</kbd> class with the required private String fields and annotations.</li>
</ol>
<p style="padding-left: 60px"> Take a look at the following screenshot:</p>
<div class="packt_figref CDPAlignCenter CDPAlign"><img src="Images/2a88c579-ec63-47b8-b698-77b3cd03fc98.png" style="width:71.83em;height:24.25em;" width="1210" height="408"/></div>
<ol start="2">
<li>Fill the data structure and list with the corresponding data for each Bean.</li>
</ol>
<div class="packt_infobox"><br/>
You can fetch the Bean from the context using the Bean name with the <kbd>getBean</kbd> method, for example.</div>
<ol start="3">
<li class="mce-root">Print the <kbd>BeanData</kbd> list content to get the desired outcome.</li>
</ol>
<p>Based on the outcome, you have now created a class that just consists of fields plus two annotations on the class level and have used the constructor and getters that are generated by that. Now, you never have to generate boring getters, setters, and so on your own again.</p>
<p>Take a look at the following output screenshot:</p>
<div class="packt_figref CDPAlignCenter CDPAlign"><img src="Images/e484a587-d596-435a-8939-1fc4f20a0dff.png" style="width:60.92em;height:37.50em;" width="1562" height="962"/></div>
<div class="packt_infobox"><br/>
To refer to the detailed steps, go to the <em>Solutions</em> section at the end of this book on page 249.</div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>In this chapter, you learnt about the history of Spring Project and why it was created. You now know how to create a Spring Boot project using <kbd>start.spring.io</kbd> and how to start it afterwards. The basic building blocks and the application context were also introduced. Last but not least, you saw how Lombok can make your life a lot easier by freeing you from creating or writing the same code over and over again.</p>
<p>In the next chapter, you will finally see how Spring Beans can interact and how you can configure the application.</p>


            </article>

            
        </section>
    </div>



  </body></html>