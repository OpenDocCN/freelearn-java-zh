["```java\nobject HelloWorld extends App {\n  val hello = IO { println(\"Hello\") }\n  val world = IO { println(\"World\") }\n  (hello *> world).unsafeRunSync\n}\n```", "```java\n(hello *> world).unsafeRunSync\n```", "```java\nIO { Thread.sleep(1000) }\n```", "```java\ndef taskHeavy(prefix: String): IO[Nothing] =\n  Monad[IO].tailRecM(0) { i => for {\n    _ <- IO { println(s\"${Thread.currentThread.getName}; $prefix: $i\") }\n    _ <- IO { Thread.sleep(1000) }\n  } yield Left(i + 1) }\n```", "```java\nimplicit val ec: ExecutionContext =\n  ExecutionContext.fromExecutor(Executors.newFixedThreadPool(2))\n```", "```java\ndef bunch(n: Int)(gen: String => IO[Nothing]): IO[List[Fiber[IO, Nothing]]] =\n (1 to n).toList.map(i => s\"Task $i\").traverse(gen(_).start)\n```", "```java\n(1 to n).toList.map(i => s\"Task $i\")\n```", "```java\n.traverse(gen(_).start)\n```", "```java\ngen(_).start\n```", "```java\n(IO.shift *> bunch(1000)(taskHeavy)).unsafeRunSync\n```", "```java\ndef taskLight(prefix: String): IO[Nothing] =\n  Monad[IO].tailRecM(0) { i => for {\n    _ <- IO { println(s\"${Thread.currentThread.getName}; $prefix: $i\") }\n    _ <- IO.sleep(1 second)\n  } yield Left(i + 1) }\n```", "```java\n(IO.shift *> bunch(1000)(taskLight)).unsafeRunSync\n```", "```java\ndef taskHeavy(name: String): Int = {\n  Thread.sleep(1000)\n  println(s\"${Thread.currentThread.getName}: \" +\n    s\"$name: Computed!\")\n  42\n}\n```", "```java\ndef sync(name: String): IO[Int] =\n  IO { taskHeavy(name) }\n```", "```java\ndef benchmark[A](io: IO[A]): IO[(A, Long)] =\n  for {\n    tStart <- Timer[IO].clockMonotonic(SECONDS)\n    res <- io\n    tEnd <- Timer[IO].clockMonotonic(SECONDS)\n  } yield (res, tEnd - tStart)\n```", "```java\ndef benchmarkFlush[A](io: IO[A]): IO[Unit] =\n  benchmark(io).map { case (res, time) =>\n    println(s\"Computed result $res in $time seconds\") }\n```", "```java\ndef bunch(n: Int)(gen: String => IO[Int]): IO[List[Int]] =\n  (1 to n).toList.map(i => s\"Task $i\").traverse(gen(_).start)\n    .flatMap(_.traverse(_.join))\n```", "```java\n.flatMap(_.traverse(_.join))\n```", "```java\nbenchmarkFlush(IO.shift *> bunch(10)(sync)).unsafeRunSync\n```", "```java\nEither[Throwable, A]) ⇒ Unit\n```", "```java\ndef async(name: String): IO[Int] =\n  IO.async { cb =>\n    new Thread(new Runnable { override def run =\n      cb { Right(taskHeavy(name)) } }).start()\n  }\n```", "```java\nbenchmarkFlush(IO.shift *> bunch(10)(async)).unsafeRunSync\n```", "```java\ndef sum(from: Int, to: Int): IO[Int] =\n  Monad[IO].tailRecM((from, 0)) { case (i, runningTotal) =>\n    if (i == to) IO.pure( Right(runningTotal + i) )\n    else if (i > to) IO.pure( Right(runningTotal) )\n    else for {\n      _ <- IO { println(s\"${Thread.currentThread.getName}: \" +\n        s\"Running total from $from to $to, currently at $i: $runningTotal\") }\n      _ <- IO.sleep(500 milliseconds)\n    } yield Left((i + 1, runningTotal + i)) }\n```", "```java\nelse for {\n  _ <- IO { println(s\"${Thread.currentThread.getName}: \" +\n    s\"Running total from $from to $to, currently at $i: $runningTotal\") }\n  _ <- IO.sleep(500 milliseconds)\n} yield Left((i + 1, runningTotal + i))\n```", "```java\ndef sequential: IO[Int] =\n for {\n   s1 <- sum(1 , 10)\n   s2 <- sum(10, 20)\n } yield s1 + s2\n```", "```java\nbenchmarkFlush(sequential).unsafeRunSync\n```", "```java\ndef sequentialTraverse: IO[Int] =\n  List(sum(1, 10), sum(10, 20)).traverse(identity).map(_.sum)\n```", "```java\nbenchmarkFlush(sequentialTraverse).unsafeRunSync\n```", "```java\ndef parallel: IO[Int] =\n  for {\n    f1 <- sum(1 , 10).start\n    f2 <- sum(10, 20).start\n    s1 <- f1.join\n    s2 <- f2.join\n  } yield s1 + s2\n```", "```java\nbenchmarkFlush(parallel).unsafeRunSync\n```", "```java\ndef cancelled: IO[Int] =\n  for {\n    f1 <- sum(1 , 5 ).start\n    f2 <- sum(10, 20).start\n    res <- f1.join\n    _ <- f2.cancel\n  } yield res\n```", "```java\nbenchmarkFlush(cancelled).unsafeRunSync\n```", "```java\nclass DBSession {\n  var closed = false\n  def runStatement(stat: String): IO[List[String]] = {\n    val computation = IO {\n      if (stat.contains(\"user\")) List(\"John\", \"Ann\")\n      else if (stat.contains(\"post\")) List(\"Post1\", \"Post2\")\n      else Nil\n    }\n    if (!closed) computation\n    else IO.raiseError { new RuntimeException(\"Connection is closed\") }\n  }\n  def close(): Unit = closed = true\n  def isClosed = closed\n}\n```", "```java\ndef dbSession: IO[DBSession] = IO { new DBSession }\n\ndef selectUsers(db: DBSession): IO[List[String]] =\n  dbSession.flatMap(_.runStatement(\"select * from user\"))\n```", "```java\nvar sessIntercept: DBSession = null\nval computation: IO[Unit] =\n  dbSession.bracket(sess => for {\n    users <- selectUsers(sess)\n\n    _ = println(s\"Users:\\n${users.mkString(\"\\n\")}\")\n    _ = sessIntercept = sess\n  } yield ())(sess => IO { sess.close() })\n\nprintln(s\"Session intercept before execution: $sessIntercept\")\ncomputation.unsafeRunSync\nprintln(s\"Session intercept after execution: $sessIntercept\")\nprintln(s\"Session intercept closed status: ${sessIntercept.isClosed}\")\n```", "```java\nGET http://localhost:8888/order HTTP/1.0\nUser-Agent: Mozilla/5.0 (Windows NT 6.3; WOW64; rv:39.0) Gecko/20100101 Firefox/39.0\nPragma: no-cache\nContent-Length: 19\nHost: localhost:8888\n```", "```java\nPOST /user\nPOST /post\nGET /user\nGET /post\nPUT /user\nPUT /post\nDELETE /user/{id}\nDELETE /post/{id]\n```", "```java\nversion: '3'\nservices:\n  postgres:\n    container_name: mastering_postgres\n    build: postgres\n    ports:\n      - 5432:5432\n  backend:\n    container_name: mastering_backend\n    build: .\n    ports:\n      - 8888:8888\n    volumes:\n      - ./_volumes/ivy2:/root/.ivy2\n      - ./_volumes/sbt-boot:/root/.sbt/boot\n      - ./_volumes/coursier:/root/.cache\n      - .:/root/examples\n    environment:\n      - POSTGRES_HOST=postgres\n      - POSTGRES_PORT=5432\n    stdin_open: true\n    tty: true\n```", "```java\npostgres:\n  container_name: mastering_postgres\n  build: postgres\n  ports:\n    - 5432:5432\n```", "```java\nbackend:\n  container_name: mastering_backend\n  build: .\n  ports:\n    - 8888:8888\n  volumes:\n    - ./_volumes/ivy2:/root/.ivy2\n    - ./_volumes/sbt-boot:/root/.sbt/boot\n    - ./_volumes/coursier:/root/.cache\n    - .:/root/examples\n  environment:\n    - POSTGRES_HOST=postgres\n    - POSTGRES_PORT=5432\n  stdin_open: true\n  tty: true\n```", "```java\nstdin_open: true\ntty: true\n```", "```java\nFROM postgres:latest\nADD ./*.sql /docker-entrypoint-initdb.d/\n```", "```java\nCREATE TABLE customer (\n  id serial NOT NULL,\n  \"name\" varchar NOT NULL,\n  CONSTRAINT customer_pk PRIMARY KEY (id),\n  CONSTRAINT customer_un UNIQUE (name)\n)\nWITH (\n  OIDS=FALSE\n) ;\nCREATE UNIQUE INDEX customer_name_idx ON public.customer USING btree (name) ;\n\nCREATE TABLE good (\n  id serial NOT NULL,\n  \"name\" varchar NOT NULL,\n  price float4 NOT NULL,\n  stock int4 NOT NULL DEFAULT 0,\n  CONSTRAINT good_pk PRIMARY KEY (id)\n)\nWITH (\n  OIDS=FALSE\n) ;\n\nCREATE TABLE \"order\" (\n  id serial NOT NULL,\n  customer int4 NOT NULL,\n  good int4 NOT NULL,\n  CONSTRAINT store_order_pk PRIMARY KEY (id),\n  CONSTRAINT order_customer_fk FOREIGN KEY (customer) REFERENCES customer(id) ON DELETE CASCADE,\n  CONSTRAINT order_good_fk FOREIGN KEY (good) REFERENCES good(id) ON DELETE CASCADE\n)\nWITH (\n  OIDS=FALSE\n) ;\n\nINSERT INTO good (id, name, price, stock) VALUES(1, 'MacBook Pro 15''', 2500, 15);\nINSERT INTO good (id, name, price, stock) VALUES(2, 'iPhone 10', 1000, 10);\nINSERT INTO good (id, name, price, stock) VALUES(3, 'MacBook Air', 900, 3);\nINSERT INTO good (id, name, price, stock) VALUES(4, 'Samsung Galaxy S5', 500, 8);\nINSERT INTO good (id, name, price, stock) VALUES(5, 'Panasonic Camera', 120, 34);\n```", "```java\nFROM hseeberger/scala-sbt\n\nRUN mkdir -p /root/.sbt/1.0/plugins\nRUN echo \"\\\naddSbtPlugin(\\\"io.get-coursier\\\" % \\\"sbt-coursier\\\" % \\\"1.0.0-RC12-1\\\")\\n\\\naddSbtPlugin(\\\"io.spray\\\" % \\\"sbt-revolver\\\" % \\\"0.9.0\\\" )\\n\\\n\" > /root/.sbt/1.0/plugins/plugins.sbt\n\nWORKDIR /root/examples\n```", "```java\nobject customer extends CustomerDbHelpers {\n  def create(c: Customer): IO[Int] = ???\n  def findByName(name: String): IO[Option[Customer]] = ???\n  def list: IO[List[Customer]] = ???\n  def get(id: Int): IO[Customer] = ???\n  def update(c: Customer): IO[Int] = ???\n  def delete(id: Int): IO[Int] = ???\n}\n\ntrait CustomerDbHelpers {\n  val selectCustomerSql = fr\"select * from customer\"  // to be explained further in the chapter\n}\n```", "```java\ndef create(c: Customer): IO[Int] =\n  sql\"\"\"\n    insert into customer (name)\n    values (${c.name})\n  \"\"\"\n  .update.withUniqueGeneratedKeys[Int](\"id\").transact(tr)\n```", "```java\nvalues (${c.name})\n```", "```java\nimplicit lazy val tr: Transactor[IO] =\n Transactor.fromDriverManager[IO](\n \"org.postgresql.Driver\"\n , s\"jdbc:postgresql://${sys.env(\"POSTGRES_HOST\")}:${sys.env(\"POSTGRES_PORT\")}/postgres\"\n , \"postgres\", \"\")\n```", "```java\ndef list: IO[List[Customer]] =\n  selectCustomerSql.query[Customer].to[List].transact(tr)\n```", "```java\nval selectCustomerSql = fr\"select * from customer\"\n```", "```java\ndef get(id: Int): IO[Customer] =\n  (selectCustomerSql ++ sql\"where id = $id\")\n    .query[Customer].unique.transact(tr)\n```", "```java\ndef findByName(name: String): IO[Option[Customer]] =\n  (selectCustomerSql ++ sql\"\"\"where name = $name\"\"\")\n    .query[Customer].option.transact(tr)\n```", "```java\ndef update(c: Customer): IO[Int] =\n  sql\"\"\"\n    update customer set\n      name = ${c.name}\n    where id = ${c.id}\n  \"\"\"\n  .update.run.transact(tr)\n\ndef delete(id: Int): IO[Int] =\n  sql\"\"\"delete from customer where id = $id\"\"\"\n    .update.run.transact(tr)\n```", "```java\nval customersTest: IO[Unit] = for {\n  id1 <- customer.create(Customer(name = \"John Smith\"))\n  id2 <- customer.create(Customer(name = \"Ann Watson\"))\n\n  _ = println(s\"Looking up customers by name\")\n  c1 <- customer.findByName(\"John Smith\")\n  _ = println(c1)\n  c2 <- customer.findByName(\"Foo\")\n  _ = println(c2)\n\n  _ = println(\"\\nAll customers\")\n  cs <- customer.list\n  _ = println(cs.mkString(\"\\n\"))\n\n  _ = println(s\"\\nCustomer with id $id1\")\n  c3 <- customer.get(id1)\n  _ = println(c3)\n\n  _ = println(s\"\\nUpdate customer with id $id1\")\n  r <- customer.update(c3.copy(name = \"Bob\"))\n  _ = println(s\"Rows affected: $r\")\n  c4 <- customer.get(id1)\n  _ = println(s\"Updated customer: $c4\")\n\n  _ = println(s\"\\nClean-up: remove all customers\")\n  _ <- List(id1, id2).traverse(customer.delete)\n  cx <- customer.list\n  _ = println(s\"Customers table after clean-up: $cx\") \n} yield ()\n\ncustomersTest.unsafeRunSync()\n```", "```java\ndef create(c: Good): IO[Int] =\n  sql\"\"\"\n    insert into good (\n      name\n    , price\n    , stock)\n    values (\n      ${c.name}\n    , ${c.price}\n    , ${c.stock})\n  \"\"\"\n  .update.withUniqueGeneratedKeys[Int](\"id\").transact(tr)\n```", "```java\nval selectGoodSql = fr\"select * from good\"\n\ndef findByName(name: String): IO[Option[Good]] =\n  (selectGoodSql ++ sql\"\"\"where name = $name\"\"\")\n    .query[Good].option.transact(tr)\n\ndef list: IO[List[Good]] =\n  selectGoodSql.query[Good].to[List].transact(tr)\n\ndef get(id: Int): IO[Good] =\n  (selectGoodSql ++ sql\"where id = $id\")\n    .query[Good].unique.transact(tr)\n```", "```java\ndef update(c: Good): IO[Int] =\n  sql\"\"\"\n    update good set\n      name = ${c.name }\n    , price = ${c.price}\n    , stock = ${c.stock}\n    where id = ${c.id}\n  \"\"\"\n  .update.run.transact(tr)\n\ndef delete(id: Int): IO[Int] =\n  sql\"\"\"delete from good where id = $id\"\"\"\n    .update.run.transact(tr)\n```", "```java\nobject order extends OrderDbHelpers {\n  def create(o: Order): IO[Int] =\n    sql\"\"\"\n      insert into \"order\" (customer, good)\n      values (${o.customer}, ${o.good})\n    \"\"\"\n    .update.withUniqueGeneratedKeys[Int](\"id\").transact(tr)\n\n  def list: IO[List[Order]] =\n    selectOrderSql.query[Order].to[List].transact(tr)\n\n  def get(id: Int): IO[Order] =\n    (selectOrderSql ++ sql\"where id = $id\")\n      .query[Order].unique.transact(tr)\n}\n\ntrait OrderDbHelpers {\n  val selectOrderSql = fr\"\"\"select * from \"order\"\"\"\"\n}\n```", "```java\nBlazeBuilder[IO]\n  .bindHttp(8888, \"0.0.0.0\")\n  .mountService(all, \"/\")\n  .serve.compile.drain.unsafeRunSync()\n```", "```java\ndef all = (\n    createCustomer\n<+> placeOrder\n<+> listOrders\n<+> listGoods)\n```", "```java\ndef createCustomer = HttpService[IO] {\n  case req @ POST -> Root / \"customer\" =>\n    for {\n      reqBody <- req.as[Customer]\n      id <- db.customer.create(reqBody)\n      resp <- Ok(success(id.toString))\n    } yield resp\n  }\n```", "```java\nA ⇒ F[B]\n```", "```java\nreqBody <- req.as[Customer]\n```", "```java\nresp <- Ok(success(id.toString))\n```", "```java\ndef success[T](payload: T): Map[String, T] =\n  Map(\"success\" -> payload)\n```", "```java\ndef placeOrder = HttpService[IO] {\n  case req @ POST -> Root / \"order\" =>\n    for {\n      cookieHeader <-\n        headers.Cookie.from(req.headers).map(IO.pure).getOrElse(\n          IO.raiseError(noAuthCookieError))\n      jsonBody <- req.as[Map[String, Int]]\n      cookie <- cookieHeader.values.toList\n        .find(_.name == \"shop_customer_id\").map(IO.pure).getOrElse(\n          IO.raiseError(noAuthCookieError))\n      uId = cookie.content\n\n      oId <- db.order.create(Order(good = jsonBody(\"good\"), customer = uId.toInt))\n      order <- db.order.get(oId)\n      resp <- Ok(success(order))\n    } yield resp\n}\n```", "```java\ncookieHeader <-\n  headers.Cookie.from(req.headers).map(IO.pure).getOrElse(\n    IO.raiseError(noAuthCookieError))\n```", "```java\njsonBody <- req.as[Map[String, Int]]\n```", "```java\nresp <- Ok(success(order))\n```", "```java\ndef listOrders = HttpService[IO] {\n  case req @ GET -> Root / \"order\" =>\n    db.order.list.flatMap(Ok(_))\n}\n\ndef listGoods = HttpService[IO] {\n  case req @ GET -> Root / \"good\" =>\n    db.good.list.flatMap(Ok(_))\n}\n```", "```java\nreStart\n```"]