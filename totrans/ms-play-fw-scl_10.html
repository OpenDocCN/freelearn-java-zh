<html><head></head><body><div class="chapter" title="Chapter&#xA0;10.&#xA0;Debugging and Logging"><div class="titlepage"><div><div><h1 class="title"><a id="ch10"/>Chapter 10. Debugging and Logging</h1></div></div></div><p>Debugging and logging are the tools that a developer can use to identify the root cause of bugs or unexpected behavior of applications.</p><p>The aim of <a id="id371" class="indexterm"/>debugging is to find a defect or pain point in our code, which is responsible for a problem. Logging <a id="id372" class="indexterm"/>gives us information about an application's state and the various stages of processing it. In this chapter, we will cover the following topics:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Debugging a Play application</li><li class="listitem" style="list-style-type: disc">Configuring logging</li><li class="listitem" style="list-style-type: disc">Experimenting in a Scala console</li></ul></div><div class="section" title="Debugging a Play application"><div class="titlepage"><div><div><h1 class="title"><a id="ch10lvl1sec66"/>Debugging a Play application</h1></div></div></div><a id="id373" class="indexterm"/><p>Play <a id="id374" class="indexterm"/>applications can be debugged using a <a id="id375" class="indexterm"/>
<span class="strong"><strong>Java Platform Debugger Architecture</strong></span> (<span class="strong"><strong>JPDA</strong></span>) transport. According to the Oracle documentation (refer to <a class="ulink" href="http://docs.oracle.com/javase/7/docs/technotes/guides/jpda/conninv.html">http://docs.oracle.com/javase/7/docs/technotes/guides/jpda/conninv.html</a>):</p><div class="blockquote"><blockquote class="blockquote"><p><span class="emphasis"><em>A JPDA Transport is a method of communication between a debugger and the virtual machine that is being debugged (hereafter the target VM). The communication is connection oriented - one side acts as a server, listening for a connection. The other side acts as a client and connects to the server. JPDA allows either the debugger application or the target VM to act as the server.</em></span></p></blockquote></div><a id="id376" class="indexterm"/><p>We can start a console in debug mode with any one of the following commands:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">By using <code class="literal">play</code>:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>play debug</strong></span>
</pre></div></li><li class="listitem" style="list-style-type: disc">By using <code class="literal">activator</code>:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>activator -jvm-debug &lt;port&gt;</strong></span>
</pre></div></li><li class="listitem" style="list-style-type: disc">By using <code class="literal">sbt</code>:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>sbt -jvm-debug &lt;port&gt;</strong></span>
</pre></div></li></ul></div><p>All these <a id="id377" class="indexterm"/>commands are just wrappers used to start the target VM in debug mode through the invocation options:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>-Xdebug -Xrunjdwp:transport=dt_socket,server=y,suspend=n,address=&lt;port&gt;</strong></span>
</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note36"/>Note</h3><p>The <code class="literal">play</code> command<a id="id378" class="indexterm"/> uses the <code class="literal">JPDA_PORT</code> or <code class="literal">9999</code> environment variable for the port variable. After setting <code class="literal">JPDA_PORT</code> to the desired port, the target VM will listen to that port.</p></div></div><div class="section" title="Configuring an IDE for debugging"><div class="titlepage"><div><div><h2 class="title"><a id="ch10lvl2sec36"/>Configuring an IDE for debugging</h2></div></div></div><p>Once we<a id="id379" class="indexterm"/> start the console in debug mode, we can connect our IDE and debug the application when it's running. If you are familiar with how this can be done, you can skip this section.</p><p>The process of configuring the IDE will be similar to the one used in all the IDEs. Let's see how it's done in <a id="id380" class="indexterm"/>
<span class="strong"><strong>IntelliJ Idea</strong></span> through the following steps:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Select <span class="strong"><strong>Edit Configurations…</strong></span> from the the <span class="strong"><strong>Run</strong></span> menu. A dialog will pop up. It will be similar to the following screenshot:<div class="mediaobject"><img src="graphics/3803OS_10_01.jpg" alt="Configuring an IDE for debugging"/></div></li><li class="listitem">Click on <span class="strong"><strong>+</strong></span> and <a id="id381" class="indexterm"/>a menu similar to this screenshot will be visible:<div class="mediaobject"><img src="graphics/3803OS_10_02.jpg" alt="Configuring an IDE for debugging"/></div></li><li class="listitem">Select <span class="strong"><strong>Remote</strong></span> and <a id="id382" class="indexterm"/>update the <span class="strong"><strong>Name</strong></span> and <span class="strong"><strong>Port</strong></span> fields:<div class="mediaobject"><img src="graphics/3803OS_10_03.jpg" alt="Configuring an IDE for debugging"/></div></li><li class="listitem">After this, click <a id="id383" class="indexterm"/>on the green bug, which is now visible at the top-right corner of the IDE, and we are ready to start debugging the application:<div class="mediaobject"><img src="graphics/3803OS_10_04.jpg" alt="Configuring an IDE for debugging"/></div></li></ol></div></div></div></div>
<div class="section" title="Experimenting in a Scala console"><div class="titlepage"><div><div><h1 class="title"><a id="ch10lvl1sec67"/>Experimenting in a Scala console</h1></div></div></div><p>A <a id="id384" class="indexterm"/>Scala console<a id="id385" class="indexterm"/> is very handy when you're working on a Scala project. The same console is available in our Play application's console as well. All that we need to do to get the Scala console is execute the <code class="literal">console</code> command in our application console:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>[app]$ console</strong></span>
<span class="strong"><strong>[info] Compiling 3 Scala sources to /home/app/target/scala-2.10/classes...</strong></span>
<span class="strong"><strong>[info] Starting scala interpreter...</strong></span>
<span class="strong"><strong>[info]</strong></span>
<span class="strong"><strong>Welcome to Scala version 2.10.4 (Java HotSpot(TM) 64-Bit Server VM, Java 1.7.0_60).</strong></span>
<span class="strong"><strong>Type in expressions to have them evaluated.</strong></span>
<span class="strong"><strong>Type :help for more information.</strong></span>

<span class="strong"><strong>scala&gt;</strong></span>
</pre></div><p>However, we can only call methods from <a id="id386" class="indexterm"/>
<span class="strong"><strong>models</strong></span> or <a id="id387" class="indexterm"/>
<span class="strong"><strong>utils</strong></span>. If classes or objects within these packages utilize <code class="literal">Play.application.configuration</code> or attempt to fetch data from the DB or some other Play utils, we will not be able to instantiate them. This is because most of the Play components require access to an instance of the currently running Play application. Importing <code class="literal">play.api.Play.current</code> makes this possible but not entirely; we still need a running application, which will be marked as the current application.</p><p>Let's create an application and start it from the Scala console, and then import <code class="literal">play.api.Play.current</code>:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>scala&gt; :pas</strong></span>
<span class="strong"><strong>// Entering paste mode (ctrl-D to finish)</strong></span>

<span class="strong"><strong>import play.api.Play</strong></span>
<span class="strong"><strong> </strong></span>
<span class="strong"><strong>val application = new DefaultApplication(new java.io.File("."), this.getClass.getClassLoader, None, Mode.Dev)</strong></span>
<span class="strong"><strong>Play.start(application)</strong></span>
<span class="strong"><strong> </strong></span>
<span class="strong"><strong>import play.api.Play.current</strong></span>
</pre></div><p>Once we <a id="id388" class="indexterm"/>exit paste mode, the code will be interpreted and the application will be started. We can see this from this output:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>// Exiting paste mode, now interpreting.</strong></span>

<span class="strong"><strong>SLF4J: Class path contains multiple SLF4J bindings.</strong></span>
<span class="strong"><strong>SLF4J: Found binding in [jar:file:/home/.ivy2/cache/ch.qos.logback/logback-classic/jars/logback-classic-1.1.1.jar!/org/slf4j/impl/StaticLoggerBinder.class]</strong></span>
<span class="strong"><strong>SLF4J: Found binding in [jar:file:/home/.ivy2/cache/org.slf4j/slf4j-log4j12/jars/slf4j-log4j12-1.7.2.jar!/org/slf4j/impl/StaticLoggerBinder.class]</strong></span>
<span class="strong"><strong>SLF4J: See http://www.slf4j.org/codes.html#multiple_bindings for an explanation.</strong></span>
<span class="strong"><strong>SLF4J: Actual binding is of type [ch.qos.logback.classic.util.ContextSelectorStaticBinder]</strong></span>
<span class="strong"><strong>[info] play - Application started (Dev)</strong></span>
<span class="strong"><strong>import play.api.Play</strong></span>
<span class="strong"><strong>application: play.api.DefaultApplication = play.api.DefaultApplication@29600952</strong></span>
<span class="strong"><strong>import play.api.Play.current</strong></span>

<span class="strong"><strong>scala&gt;</strong></span>
</pre></div><p>Now, we can view the configuration, view or modify data, and so on. For example, let's try to get the application's configuration:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>scala&gt; Play.application.configuration</strong></span>
<span class="strong"><strong>res7: play.api.Configuration = Configuration(Config(SimpleConfigObject({"akka":{"actor":{"creation-timeout":"20s","debug":{"autoreceive":"off","event-stream":"off","fsm":"off","lifecycle":"off","receive":"off","router-misconfiguration":"off","unhandled":"off"},"default-dispatcher":{"attempt-teamwork":"on","default-executor":{"fallback":"fork-join-executor"},"executor":"default-executor","fork-join-executor":{"parallelism-factor":3,"parallelism-max":64,"parallelism-min":8},"mailbox-requirement":"","shutdown-timeout":"1s","thread-pool-executor":{"allow-core-timeout":"on","core-pool-size-factor":3,"core-pool-size-max":64,"core-pool-size-min":8,"keep-alive-time":"60s","max-pool-size-factor":3,"max-pool-size-max":64,"max-pool-size-min":8,"task-queue-size":-1,"task-queue-type":"linked"},"thro...</strong></span>
</pre></div><p>Nice, isn't it? Yet, this is not enough if we want to call actions and check results for different inputs. For <a id="id389" class="indexterm"/>such cases, we shouldn't use the <code class="literal">console</code> command, but instead, the <code class="literal">test:console</code> command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>[app] $ test:console</strong></span>
<span class="strong"><strong>[info] Starting scala interpreter...</strong></span>
<span class="strong"><strong>[info]</strong></span>
<span class="strong"><strong>Welcome to Scala version 2.10.4 (Java HotSpot(TM) 64-Bit Server VM, Java 1.7.0_60).</strong></span>
<span class="strong"><strong>Type in expressions to have them evaluated.</strong></span>
<span class="strong"><strong>Type :help for more information.</strong></span>

<span class="strong"><strong>scala&gt; :pas</strong></span>
<span class="strong"><strong>// Entering paste mode (ctrl-D to finish)</strong></span>

<span class="strong"><strong>import play.api.test.Helpers._</strong></span>
<span class="strong"><strong>import play.api.test._</strong></span>
<span class="strong"><strong>import play.api.Play</strong></span>

<span class="strong"><strong>val application = FakeApplication()</strong></span>
<span class="strong"><strong>Play.start(application)</strong></span>

<span class="strong"><strong>import play.api.Play.current</strong></span>
<span class="strong"><strong>// Exiting paste mode, now interpreting.</strong></span>
<span class="strong"><strong>…</strong></span>
</pre></div><p>Now, from this Scala console, we can view the configuration, modify data, as well as call an action:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>scala&gt; Play.application.configuration</strong></span>
<span class="strong"><strong>res0: play.api.Configuration = Configuration(Config(SimpleConfigObject({"akka":{"actor":{"creation-timeout":"20s","debug":{"autoreceive":"off","event-stream":"off","fsm":"off","lifecycle":"off","receive":"off","router-misconfiguration":"off","unhandled":"off"},"default-dispatcher":{"attempt-teamwork":"on","default-executor":{"fallback":"fork-join-executor"},"executor":"default-executor","fork-join-executor":{"parallelism-factor":3,"parallelism-max":64,"parallelism-min":8},"mailbox-requirement":"","shutdown-timeout":"1s","thread-pool-executor":{"allow-core-timeout":"on","core-pool-size-factor":3,"core-pool-size-max":64,"core-pool-size-min":8,"keep-alive-time":"60s","max-pool-size-factor":3,"max-pool-size-max":64,"max-pool-size-min":8,"task-queue-size":-1,"task-queue-type":"linked"},"thro...</strong></span>

<span class="strong"><strong>scala&gt; controllers.Application.index("John").apply(FakeRequest())</strong></span>
<span class="strong"><strong>res1: scala.concurrent.Future[play.api.mvc.Result] = scala.concurrent.impl.Promise$KeptPromise@6fbd57ac</strong></span>

<span class="strong"><strong>scala&gt; contentAsString(res1)</strong></span>
<span class="strong"><strong>res2: String = Hello John</strong></span>
</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip06"/>Tip</h3><p>Use <code class="literal">test:console</code> instead of <code class="literal">console</code>; you <a id="id390" class="indexterm"/>need not switch when you decide to check an action.</p></div></div></div>
<div class="section" title="Logging"><div class="titlepage"><div><div><h1 class="title"><a id="ch10lvl1sec68"/>Logging</h1></div></div></div><p>Logging<a id="id391" class="indexterm"/> is the act of recording data about when and why an event occurred for an application. Logs are extremely useful if they've been handled correctly; otherwise, they are just noise. By reviewing the log output, there is a good chance that you can determine the cause of an event.</p><p>Logs are useful not just to handle application errors, but also to protect an application from misuse and malicious attacks as well as understand different aspects of a business.</p></div>
<div class="section" title="Play's logging API"><div class="titlepage"><div><div><h1 class="title"><a id="ch10lvl1sec69"/>Play's logging API</h1></div></div></div><p>Play <a id="id392" class="indexterm"/>exposes the <a id="id393" class="indexterm"/>logging API through<a id="id394" class="indexterm"/> <code class="literal">play.api.Logger</code>. Let's have a look at the class and object definition of it:</p><div class="informalexample"><pre class="programlisting">class Logger(val logger: Slf4jLogger) extends LoggerLike

object Logger extends LoggerLike {

  ...
  val logger = LoggerFactory.getLogger("application")

  def apply(name: String): Logger = new Logger(LoggerFactory.getLogger(name))

  def apply[T](clazz: Class[T]): Logger = new Logger(LoggerFactory.getLogger(clazz))

  ...

}</pre></div><p>The <code class="literal">LoggerLike</code> trait is just <a id="id395" class="indexterm"/>a wrapper over <code class="literal">Slf4jLogger</code>. By default, all application logs are mapped to <code class="literal">Logger</code> with the application name and the Play-related logs are <a id="id396" class="indexterm"/>mapped to <code class="literal">Logger</code> with the Play name.</p><p>After importing <code class="literal">play.api.Logger</code>, we can use the default logger or define a custom one in these ways:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">By using a default logger:<div class="informalexample"><pre class="programlisting">import play.api.Logger
object Task{
  def delete(id:Long) = {
    logger.debug(s"deleting task with id $id")
    ...
  }
}</pre></div></li><li class="listitem" style="list-style-type: disc">By using a logger with its class name:<div class="informalexample"><pre class="programlisting">import play.api.Logger
object Task{
  private lazy val taskLogger = Logger(getClass)
  def delete(id:Long) = {
    taskLogger.debug(s"deleting task with id $id")
    ...
  }
}</pre></div></li><li class="listitem" style="list-style-type: disc">By using a logger with its custom name:<div class="informalexample"><pre class="programlisting">import play.api.Logger
object Task{
  private lazy val taskLogger = Logger("application.model")
  def delete(id:Long) = {
    taskLogger.debug(s"deleting task with id $id")
    ...
  }
}</pre></div></li></ul></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note37"/>Note</h3><p>The methods <a id="id397" class="indexterm"/>supported by <code class="literal">Logger</code> are documented in the API at <a class="ulink" href="https://www.playframework.com/documentation/2.3.x/api/scala/index.html#play.api.Logger">https://www.playframework.com/documentation/2.3.x/api/scala/index.html#play.api.Logger</a>.</p></div></div></div>
<div class="section" title="Log configuration in Play"><div class="titlepage"><div><div><h1 class="title"><a id="ch10lvl1sec70"/>Log configuration in Play</h1></div></div></div><p>The<a id="id398" class="indexterm"/> Play Framework <a id="id399" class="indexterm"/>uses <code class="literal">Logback</code> as the logging engine. The default configuration is as follows:</p><div class="informalexample"><pre class="programlisting">&lt;configuration&gt;
    
  &lt;conversionRule conversionWord="coloredLevel" converterClass="play.api.Logger$ColoredLevel" /&gt;
  
  &lt;appender name="FILE" class="ch.qos.logback.core.FileAppender"&gt;
     &lt;file&gt;${application.home}/logs/application.log&lt;/file&gt;
     &lt;encoder&gt;
       &lt;pattern&gt;%date - [%level] - from %logger in %thread %n%message%n%xException%n&lt;/pattern&gt;
     &lt;/encoder&gt;
   &lt;/appender&gt;

  &lt;appender name="STDOUT" class="ch.qos.logback.core.ConsoleAppender"&gt;
    &lt;encoder&gt;
      &lt;pattern&gt;%coloredLevel %logger{15} - %message%n%xException{5}&lt;/pattern&gt;
    &lt;/encoder&gt;
  &lt;/appender&gt;
  
  &lt;logger name="play" level="INFO" /&gt;
  &lt;logger name="application" level="DEBUG" /&gt;
  
  &lt;!-- Off these ones as they are annoying, and anyway we manage configuration ourself --&gt;
  &lt;logger name="com.avaje.ebean.config.PropertyMapLoader" level="OFF" /&gt;
  &lt;logger name="com.avaje.ebeaninternal.server.core.XmlConfigLoader" level="OFF" /&gt;
  &lt;logger name="com.avaje.ebeaninternal.server.lib.BackgroundThread" level="OFF" /&gt;
  &lt;logger name="com.gargoylesoftware.htmlunit.javascript" level="OFF" /&gt;

  &lt;root level="ERROR"&gt;
    &lt;appender-ref ref="STDOUT" /&gt;
    &lt;appender-ref ref="FILE" /&gt;
  &lt;/root&gt;
  
&lt;/configuration&gt;</pre></div><p>This configuration writes logs in <code class="literal">projectHome/logs/application.log</code>. Due to this, one huge file is generated. We could modify this configuration by providing a custom <code class="literal">logger.xml</code>.</p><p>The custom<a id="id400" class="indexterm"/> log file configuration<a id="id401" class="indexterm"/> can be set in two ways:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">By saving the configuration in <code class="literal">conf/application-logger.xml</code> or <code class="literal">conf/logger.xml</code>. Although using any one of the filenames, such as <code class="literal">application-logger.xml</code> or <code class="literal">logger.xml</code>, works when both are present, the settings of <code class="literal">logger.xml</code> are not applied.</li><li class="listitem" style="list-style-type: disc">By specifying the file via a system property. This method has a higher precedence over the other option.</li></ul></div><p>There are three properties:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">logger.resource</code>: This<a id="id402" class="indexterm"/> property sets a file within the class path</li><li class="listitem" style="list-style-type: disc"><code class="literal">logger.file</code>: This<a id="id403" class="indexterm"/> property sets a file through its absolute path</li><li class="listitem" style="list-style-type: disc"><code class="literal">logger.url</code>: This<a id="id404" class="indexterm"/> property sets a file using a URL in this way:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>[app]$ start -Dlogger.url=http://serverPath/conf/appName/logger.xml</strong></span>
</pre></div></li></ul></div><p>Another important aspect of configuring logging is by setting the desired log level. We will discuss this in the next section.</p><div class="section" title="Log levels"><div class="titlepage"><div><div><h2 class="title"><a id="ch10lvl2sec37"/>Log levels</h2></div></div></div><a id="id405" class="indexterm"/><p>Log levels can be set in <code class="literal">conf/application.conf</code>. The default values are as follows:</p><div class="informalexample"><pre class="programlisting"># Root logger:
logger.root=ERROR

# Logger used by the framework:
logger.play=INFO

# Logger provided to your application:
logger.application=DEBUG</pre></div><p>We can also set the log levels for the classes belonging to specific packages and third-party libraries in this way:</p><div class="informalexample"><pre class="programlisting">logger.com.apache.cassandra = DEBUG</pre></div><p>The supported log levels in the decreasing order of severity are as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">ERROR</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">WARN</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">INFO</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">DEBUG</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">TRACE</code></li></ul></div><p>If we wish <a id="id406" class="indexterm"/>to turn off logging for some classes or packages, we can set the log level as <code class="literal">OFF</code>. This will disable logging for a particular logger.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note38"/>Note</h3><p>Some libraries have transitive dependencies on logging libraries. It is best to exclude these logging packages when defining a dependency. It can be done as follows:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>"orgName" % "packageName" % "version" excludeAll(</strong></span>
<span class="strong"><strong>      ExclusionRule(organization = "org.slf4j"),</strong></span>
<span class="strong"><strong>      ExclusionRule(organization = "ch.qos.logback"))</strong></span>
</pre></div></div></div></div></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch10lvl1sec71"/>Summary</h1></div></div></div><p>In this chapter, we discussed how to configure the debugging of a Play application in the IDE. We also covered how to start a Play application in a Scala console. This chapter also covered the logging API provided by the Play Framework and customizing the log format.</p><p>A lot of web applications make use of the third-party APIs either to avoid rewriting the existing code or to make it easy for users to adopt their applications. In the next chapter, we will be checking out how developers can use existing external APIs in a Play application.</p></div></body></html>