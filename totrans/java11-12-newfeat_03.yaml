- en: AppCDS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Application Class-Data Sharing**, or **AppCDS**, extends the capabilities
    of **Class-Data Sharing **(**CDS**). It enables programmers to include selected
    application classes in the shared archive file, along with the core library classes,
    to reduce the startup time of Java applications. It also results in a reduced
    memory footprint.'
  prefs: []
  type: TYPE_NORMAL
- en: The shared archive file created with AppCDS can include classes from the runtime
    image, application classes from the runtime image, and application classes from
    the classpath.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we''ll cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to CDS
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a shared archive with CDS
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction to AppCDS
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Identifying application files to be placed in the shared archive with AppCDS
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating and using a shared application archive file
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To work with the code in this chapter, you should have JDK version 10 or later
    installed on your system.
  prefs: []
  type: TYPE_NORMAL
- en: All code in this chapter can be accessed at [https://github.com/PacktPublishing/Java-11-and-12-New-Features](https://github.com/PacktPublishing/Java-11-and-12-New-Features).
  prefs: []
  type: TYPE_NORMAL
- en: Since AppCDS extends the capabilities of CDS, it would help to have an understanding
    of CDS before starting with AppCDS. The next section introduces CDS, including
    where to find the shared archive file, how to create or recreate it, and the relevant
    commands to do so. You can skip the next section on CDS if you have practical
    experience of working with it.
  prefs: []
  type: TYPE_NORMAL
- en: What is CDS?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: CDS has been a commercial feature with Oracle JVM since Java 8\. CDS helps in
    two ways—it helps to reduce the startup time of a Java application and reduces its
    memory footprint with multiple **Java Virtual Machines** (**JVMs**).
  prefs: []
  type: TYPE_NORMAL
- en: When you start up your JVM, it performs multiple steps to prepare the environment
    for execution. This includes bytecode loading, verification, linking, and initializing
    of core classes and interfaces. The classes and interfaces are combined into the
    runtime state of JVM so that they can be executed. It also includes method areas
    and constant pools.
  prefs: []
  type: TYPE_NORMAL
- en: These sets of core classes and interfaces don't change unless you update your
    JVM. So, every time you start your JVM, it performs the *same* steps to get the
    environment up for execution. Imagine you could dump the result to a file, which
    could be read by your JVM at startup. The subsequent startups could get the environment
    up and running without performing the intermediate steps of loading, verification,
    linking, and initialization. Welcome to CDS.
  prefs: []
  type: TYPE_NORMAL
- en: When you *install* JRE, CDS creates a shared archive file from a set of predefined
    set of classes from the system `jar` file. Classes are verified by the class loaders
    before they can be used—and this process applies to all the classes. To speed
    up this process, the installation process loads these classes into an internal
    representation and then dumps that representation to `classes.jsa`—a shared archive
    file. When JVM starts or restarts, `classes.jsa` is memory-mapped to save loading
    those classes.
  prefs: []
  type: TYPE_NORMAL
- en: When JVM's metadata is shared among multiple JVM processes, it results in a
    smaller memory footprint. Loading classes from a populated cache is faster than
    loading them from the disk; they are also partially verified. This feature is
    also beneficial for Java applications that start new JVM instances.
  prefs: []
  type: TYPE_NORMAL
- en: Location of the shared archive file
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'By default, the JDK installation process creates the class data-sharing file
    with the name `classes.jsa`. The default location of `classes.jsa` is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Solaris/Linux/macOS: `/lib/[arch]/server/classes.jsa`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Windows platforms: `/bin/server/classes.jsa` (as shown in the following screenshot):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/52ca0d36-5cfc-4b1c-bf8a-2751ee512629.png)'
  prefs: []
  type: TYPE_IMG
- en: The size of the shared archived file, that is, `classes.jsa`, is approximately
    17.2 MB on a Windows system.
  prefs: []
  type: TYPE_NORMAL
- en: Manual creation of classes.jsa
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This shared archive file can also be created manually using the following runtime
    command (you should have enough permissions to write to the target directory):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s a sample output of the preceding command:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8127266a-3eea-4d9a-9930-bddfc7875980.png)'
  prefs: []
  type: TYPE_IMG
- en: As you can see from the output messages in the preceding screenshot, this command
    performs a lot of operations—it loads classes, links them, counts the classes
    that are included in the shared archive, allocates read-write and read-only objects,
    and a lot more.
  prefs: []
  type: TYPE_NORMAL
- en: If the file already exists, the preceding command simply overrides the existing
    file.
  prefs: []
  type: TYPE_NORMAL
- en: The shared archive file that you create with the preceding command doesn't include
    **all** the system API classes or interfaces. It includes the ones that are required
    at startup.
  prefs: []
  type: TYPE_NORMAL
- en: Usage of CDS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You can manually control usage of CDS by switching it on, switching it off,
    or putting it on automode. These are the command-line options to do so:'
  prefs: []
  type: TYPE_NORMAL
- en: '`java -Xshare:off`: Disables CDS'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`java -Xshare:on`: Enables CDS'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`java -Xshare:auto`: The default mode (it enables CDS whenever possible)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s quickly define a class as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s execute the preceding class (`ConquerWorld`) using the shared archive
    file, `classes.jsa`. To view the system class loading from the shared archive,
    you can use a `log` file with class execution, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding command outputs the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s examine the contents of the `myCDSlog.log` file (I''ve highlighted text
    to draw your attention to specific lines; the highlighted text isn''t included
    in the `log` file):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d7fac990-7cee-4e80-9315-c7078f2a5dcf.png)'
  prefs: []
  type: TYPE_IMG
- en: The `classes.jsa` file is also referred to as the **shared objects file**. JVM
    loads approximately 500 classes or interfaces from `classes.jsa` to set up the
    execution environment. It loads the bytecodes of the `ConquerWorld` class from
    the relevant location on the system.
  prefs: []
  type: TYPE_NORMAL
- en: If you scrutinize the `myCDSlog.log` file, you'll notice that a few of the classes
    are not loaded from the shared objects file. This is because they couldn't be
    archived; this can happen in certain cases.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see what happens if you execute the same class (`ConquerWorld`) by stating
    that you don''t want to use the shared objects file. To do so, you can use the
    `-Xshare:off` command, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code will output the same result as it did previously. Let''s
    examine the contents of the `myCDSshareoff.log` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7dd91925-8ecc-43fb-96b3-b8d486459f9c.png)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, since the preceding execution no longer uses the shared objects
    file (which was turned off using the `Xshare:off` option), the system or core
    API classes are loaded at runtime from their respective modules. As highlighted
    at the left bottom of the screenshot, you can also see that this execution takes
    a longer amount of time, that is, approximately 0.110 seconds. This time exceeds
    the execution time of 0.083 seconds for similar execution, which used the shared
    archive (shown in previous screenshot).
  prefs: []
  type: TYPE_NORMAL
- en: With the basic information on how CDS can lower execution time for your code,
    let's get started with AppCDS.
  prefs: []
  type: TYPE_NORMAL
- en: AppCDS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Increased users and usage of technology are driving exploration or formulation
    of better ways to improve performance every day. JEP 310 proposed extension of
    CDS to support application files. In this section, you'll cover how AppCDS is
    improving the performance of Java applications and how to create and use it.
  prefs: []
  type: TYPE_NORMAL
- en: Benefits of AppCDS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: AppCDS extends the benefits of CDS to application classes, enabling you to place
    application classes with the shared archive of core library classes. This takes
    off the work of class loading, linking, and bytecode verification, leading to
    a reduced startup time of an application. Multiple JVMs can access a shared archive,
    resulting in a reduced overall memory footprint.
  prefs: []
  type: TYPE_NORMAL
- en: In the cloud, it is common for servers to scale a Java application, with multiple
    JVMs executing the same application. This is an excellent use case that would
    benefit from AppCDS. Such applications would benefit tremendously from reduced
    startup time and reduced memory footprint.
  prefs: []
  type: TYPE_NORMAL
- en: Serverless cloud services load thousands of application classes at startup.
    AppCDS will significantly reduce their startup time.
  prefs: []
  type: TYPE_NORMAL
- en: Enabling application class data archive
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'With Java 10, the default configuration only enabled class data sharing for
    JVM''s bootstrap class loader. Since the bootstrap class loader doesn''t load
    your application''s files, you were expected to explicitly enable it for the application
    class loader and other class loaders using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'With Java 11, however, AppCDS is automatically enabled with OpenJDK 64-bit
    systems. When including this option, you might get an error message like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5f3002d9-ecba-4112-8bf6-6ac0a61fa056.png)'
  prefs: []
  type: TYPE_IMG
- en: If you are using Java version 11 or later, you can skip this option.
  prefs: []
  type: TYPE_NORMAL
- en: Java runtime options are case sensitive. The `-XX:+UseAppCDS` and `-XX:+useAppCDS` options are
    not the same.
  prefs: []
  type: TYPE_NORMAL
- en: Which application classes to archive
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The next step in creating a shared archive includes specifying the application
    classes to be included. Examine the `myCDSlog.log` file that you created in the
    preceding section. It doesn't include each class or interface that is defined
    in the core Java API.
  prefs: []
  type: TYPE_NORMAL
- en: Similarly, even though your application might include a lot of classes, you
    need not include **all** of them in the shared archive file, simply because not all
    of them are required at startup. This also reduces the size of the shared archive
    file.
  prefs: []
  type: TYPE_NORMAL
- en: Here's an example to find the application classes that should be added to the
    shared archive. To start with, create a `jar` file of your application files.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create four skeleton class files in the `com.ejavaguru.appcds` package:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'And here''s the content of the `AppCDS` class, which uses one of the preceding
    classes. It isn''t defined in the same package:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'If your directory structure matches your package structure, you can create
    a `jar` file using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5a90851f-bffe-470c-888d-50de9ef5c47b.png)'
  prefs: []
  type: TYPE_IMG
- en: 'To determine the application classes that should be placed in the shared archive,
    execute the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: On execution of the previous command, `myappCDS.lst` records the fully qualified
    name (separated using `\`) of all classes (approximately 500) that were loaded
    by JVM. It includes both the core API classes and your application classes.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot includes a few of these class names from the `myappCDS.lst`
    file. I''ve highlighted the names of two application files included in this list—`AppCDS`
    and `com/ejavaguru/appcds/Plastic`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2b81c48e-240c-40c3-86e5-995bf8c2dece.png)'
  prefs: []
  type: TYPE_IMG
- en: If you revisit the code of the `AppCDS` class, you'll notice that it uses just
    one class, that is, `Plastic`, from the `com.ejavaguru.appcds` package. The other
    classes from the same package are not loaded because they are not used. If you
    want to load other specific classes, you should use them in your application.
  prefs: []
  type: TYPE_NORMAL
- en: After accessing the list of application files to be included in the shared archive,
    you can move forward and create it.
  prefs: []
  type: TYPE_NORMAL
- en: Creating an application shared archive file
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To create the shared archive with the application files, you can execute the
    following command in Command Prompt:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: As mentioned in the *Enabling application class data archive* section, if you
    are using Java 11 or a later version on your system, you can skip using the `-XX:+UseAppCDS`
    option (AppCDS was introduced in Java 10; with Java 11, you don't need to enable
    it explicitly). The preceding command uses the list of class names stored in `myappCDS.lst`
    to create the application shared archive file. It also specifies the name of the
    shared archive file as `appCDS.jsa`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s a screenshot of the output from the preceding command:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1f986e4e-e92f-414a-84b7-67d2db9593e3.png)'
  prefs: []
  type: TYPE_IMG
- en: Let's move to the final step—using the shared application archive file.
  prefs: []
  type: TYPE_NORMAL
- en: Using the shared application archive file
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To use the shared application archive file (`appCDS.jsa`) with your AppCDS,
    execute the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code will use the shared application archive file to load the
    predefined core API classes and application classes to memory. This results in
    reduced startup time of user applications. The demo application used in this chapter
    included just four or five classes to demonstrate the process, without overwhelming
    you. You should be able to notice a considerable reduction in startup time for
    bigger user applications. Also, you can share the `.jsa` file between JVMs for
    a reduced memory footprint.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter started with an introduction to AppCDS, which extends the capabilities
    of CDS to your application files. AppCDS reduces the startup time for your applications
    and reduces the memory footprint.
  prefs: []
  type: TYPE_NORMAL
- en: You walked through the process of identifying the application classes to be
    included in the shared application archive file, creating the file, and using
    it.
  prefs: []
  type: TYPE_NORMAL
- en: AppCDS is just one of the ways to improve the performance of Java applications.
    In the next chapter, you'll discover how garbage collection optimizations will
    help to further improve the performance of Java applications.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will look at the various optimizations introduced in
    garbage collectors.
  prefs: []
  type: TYPE_NORMAL
