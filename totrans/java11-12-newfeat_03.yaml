- en: AppCDS
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: AppCDS
- en: '**Application Class-Data Sharing**, or **AppCDS**, extends the capabilities
    of **Class-Data Sharing **(**CDS**). It enables programmers to include selected
    application classes in the shared archive file, along with the core library classes,
    to reduce the startup time of Java applications. It also results in a reduced
    memory footprint.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '**应用程序类数据共享**（**AppCDS**）或**AppCDS**扩展了**类数据共享**（**CDS**）的功能。它允许程序员将选定的应用程序类以及核心库类包含在共享归档文件中，以减少Java应用程序的启动时间。这也导致了内存占用减少。'
- en: The shared archive file created with AppCDS can include classes from the runtime
    image, application classes from the runtime image, and application classes from
    the classpath.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 使用AppCDS创建的共享归档文件可以包括运行时映像中的类、运行时映像中的应用程序类以及类路径中的应用程序类。
- en: 'In this chapter, we''ll cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Introduction to CDS
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CDS简介
- en: Creating a shared archive with CDS
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用CDS创建共享归档
- en: Introduction to AppCDS
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: AppCDS简介
- en: Identifying application files to be placed in the shared archive with AppCDS
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用AppCDS识别要放入共享归档中的应用程序文件
- en: Creating and using a shared application archive file
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建和使用共享应用程序归档文件
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: To work with the code in this chapter, you should have JDK version 10 or later
    installed on your system.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用本章中的代码，你应该在你的系统上安装了JDK版本10或更高版本。
- en: All code in this chapter can be accessed at [https://github.com/PacktPublishing/Java-11-and-12-New-Features](https://github.com/PacktPublishing/Java-11-and-12-New-Features).
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的所有代码都可以在[https://github.com/PacktPublishing/Java-11-and-12-New-Features](https://github.com/PacktPublishing/Java-11-and-12-New-Features)找到。
- en: Since AppCDS extends the capabilities of CDS, it would help to have an understanding
    of CDS before starting with AppCDS. The next section introduces CDS, including
    where to find the shared archive file, how to create or recreate it, and the relevant
    commands to do so. You can skip the next section on CDS if you have practical
    experience of working with it.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 由于AppCDS扩展了CDS的功能，因此在开始使用AppCDS之前了解CDS会有所帮助。下一节介绍了CDS，包括如何找到共享归档文件、如何创建或重新创建它以及相关的命令。如果你有实际使用CDS的经验，可以跳过下一节关于CDS的内容。
- en: What is CDS?
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是CDS？
- en: CDS has been a commercial feature with Oracle JVM since Java 8\. CDS helps in
    two ways—it helps to reduce the startup time of a Java application and reduces its
    memory footprint with multiple **Java Virtual Machines** (**JVMs**).
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 自Java 8以来，CDS一直是Oracle JVM的商业特性。CDS以两种方式帮助——它有助于减少Java应用程序的启动时间，并使用多个**Java虚拟机**（**JVMs**）减少其内存占用。
- en: When you start up your JVM, it performs multiple steps to prepare the environment
    for execution. This includes bytecode loading, verification, linking, and initializing
    of core classes and interfaces. The classes and interfaces are combined into the
    runtime state of JVM so that they can be executed. It also includes method areas
    and constant pools.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 当你启动你的JVM时，它会执行多个步骤来为执行准备环境。这包括字节码加载、验证、链接以及核心类和接口的初始化。类和接口被组合到JVM的运行时状态中，以便它们可以被执行。它还包括方法区域和常量池。
- en: These sets of core classes and interfaces don't change unless you update your
    JVM. So, every time you start your JVM, it performs the *same* steps to get the
    environment up for execution. Imagine you could dump the result to a file, which
    could be read by your JVM at startup. The subsequent startups could get the environment
    up and running without performing the intermediate steps of loading, verification,
    linking, and initialization. Welcome to CDS.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 这些核心类和接口的集合除非你更新了你的JVM，否则不会改变。所以每次你启动你的JVM时，它都会执行相同的步骤来为执行准备环境。想象一下，你可以将结果导出到一个文件中，这个文件可以在JVM启动时被读取。随后的启动可以不执行加载、验证、链接和初始化的中间步骤。欢迎来到CDS的世界。
- en: When you *install* JRE, CDS creates a shared archive file from a set of predefined
    set of classes from the system `jar` file. Classes are verified by the class loaders
    before they can be used—and this process applies to all the classes. To speed
    up this process, the installation process loads these classes into an internal
    representation and then dumps that representation to `classes.jsa`—a shared archive
    file. When JVM starts or restarts, `classes.jsa` is memory-mapped to save loading
    those classes.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 当你*安装*JRE时，CDS会从系统`jar`文件中的一系列预定义类创建一个共享归档文件。在类可以使用之前，它们会被类加载器验证——这个过程适用于所有类。为了加快这个过程，安装过程将这些类加载到内部表示中，然后将该表示导出到`classes.jsa`——一个共享归档文件。当JVM启动或重启时，`classes.jsa`会被内存映射以节省加载这些类的步骤。
- en: When JVM's metadata is shared among multiple JVM processes, it results in a
    smaller memory footprint. Loading classes from a populated cache is faster than
    loading them from the disk; they are also partially verified. This feature is
    also beneficial for Java applications that start new JVM instances.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 当JVM的元数据在多个JVM进程之间共享时，它会导致更小的内存占用。从填充的缓存中加载类比从磁盘加载更快；它们也部分经过验证。此功能对启动新JVM实例的Java应用程序也有益。
- en: Location of the shared archive file
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 共享归档文件的存放位置
- en: 'By default, the JDK installation process creates the class data-sharing file
    with the name `classes.jsa`. The default location of `classes.jsa` is as follows:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，JDK安装过程创建名为`classes.jsa`的类数据共享文件。`classes.jsa`的默认位置如下：
- en: 'Solaris/Linux/macOS: `/lib/[arch]/server/classes.jsa`'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Solaris/Linux/macOS: `/lib/[arch]/server/classes.jsa`'
- en: 'Windows platforms: `/bin/server/classes.jsa` (as shown in the following screenshot):'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Windows平台: `/bin/server/classes.jsa`（如下截图所示）：'
- en: '![](img/52ca0d36-5cfc-4b1c-bf8a-2751ee512629.png)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![](img/52ca0d36-5cfc-4b1c-bf8a-2751ee512629.png)'
- en: The size of the shared archived file, that is, `classes.jsa`, is approximately
    17.2 MB on a Windows system.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在Windows系统上，共享归档文件的大小，即`classes.jsa`，大约为17.2 MB。
- en: Manual creation of classes.jsa
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 手动创建classes.jsa
- en: 'This shared archive file can also be created manually using the following runtime
    command (you should have enough permissions to write to the target directory):'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 此共享归档文件也可以使用以下运行时命令手动创建（你应该有足够的权限写入目标目录）：
- en: '[PRE0]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Here''s a sample output of the preceding command:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是前面命令的示例输出：
- en: '![](img/8127266a-3eea-4d9a-9930-bddfc7875980.png)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8127266a-3eea-4d9a-9930-bddfc7875980.png)'
- en: As you can see from the output messages in the preceding screenshot, this command
    performs a lot of operations—it loads classes, links them, counts the classes
    that are included in the shared archive, allocates read-write and read-only objects,
    and a lot more.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 如前一个屏幕截图中的输出消息所示，此命令执行了许多操作——它加载类、链接它们、计算包含在共享归档中的类数量、分配读写和只读对象，等等。
- en: If the file already exists, the preceding command simply overrides the existing
    file.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 如果文件已存在，前面的命令将简单地覆盖现有文件。
- en: The shared archive file that you create with the preceding command doesn't include
    **all** the system API classes or interfaces. It includes the ones that are required
    at startup.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 使用前面命令创建的共享归档文件不包括**所有**的系统API类或接口。它只包括启动时所需的那些。
- en: Usage of CDS
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: CDS的使用
- en: 'You can manually control usage of CDS by switching it on, switching it off,
    or putting it on automode. These are the command-line options to do so:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过开启、关闭或设置为自动模式来手动控制CDS的使用。以下是这样做的命令行选项：
- en: '`java -Xshare:off`: Disables CDS'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`java -Xshare:off`: 禁用CDS'
- en: '`java -Xshare:on`: Enables CDS'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`java -Xshare:on`: 启用CDS'
- en: '`java -Xshare:auto`: The default mode (it enables CDS whenever possible)'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`java -Xshare:auto`: 默认模式（尽可能启用CDS）'
- en: 'Let''s quickly define a class as follows:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们快速定义一个类如下：
- en: '[PRE1]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Let''s execute the preceding class (`ConquerWorld`) using the shared archive
    file, `classes.jsa`. To view the system class loading from the shared archive,
    you can use a `log` file with class execution, as follows:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用共享归档文件`classes.jsa`执行前面的类（`ConquerWorld`）。要查看从共享归档中加载的系统类，可以使用带有类执行的`log`文件，如下所示：
- en: '[PRE2]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The preceding command outputs the following:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的命令输出以下内容：
- en: '[PRE3]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Let''s examine the contents of the `myCDSlog.log` file (I''ve highlighted text
    to draw your attention to specific lines; the highlighted text isn''t included
    in the `log` file):'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们检查`myCDSlog.log`文件的内容（我已经突出显示文本以引起您对特定行的注意；突出显示的文本不包括在`log`文件中）：
- en: '![](img/d7fac990-7cee-4e80-9315-c7078f2a5dcf.png)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d7fac990-7cee-4e80-9315-c7078f2a5dcf.png)'
- en: The `classes.jsa` file is also referred to as the **shared objects file**. JVM
    loads approximately 500 classes or interfaces from `classes.jsa` to set up the
    execution environment. It loads the bytecodes of the `ConquerWorld` class from
    the relevant location on the system.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '`classes.jsa`文件也被称为**共享对象文件**。JVM从`classes.jsa`加载大约500个类或接口来设置执行环境。它从系统相关位置加载`ConquerWorld`类的字节码。'
- en: If you scrutinize the `myCDSlog.log` file, you'll notice that a few of the classes
    are not loaded from the shared objects file. This is because they couldn't be
    archived; this can happen in certain cases.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你仔细检查`myCDSlog.log`文件，你会注意到有一些类没有从共享对象文件中加载。这是因为它们无法归档；这种情况可能发生在某些情况下。
- en: 'Let''s see what happens if you execute the same class (`ConquerWorld`) by stating
    that you don''t want to use the shared objects file. To do so, you can use the
    `-Xshare:off` command, as follows:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如果你通过声明不使用共享对象文件来执行相同的类（`ConquerWorld`）会发生什么。为此，你可以使用 `-Xshare:off` 命令，如下所示：
- en: '[PRE4]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The preceding code will output the same result as it did previously. Let''s
    examine the contents of the `myCDSshareoff.log` file:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码将输出与之前相同的结果。让我们检查 `myCDSshareoff.log` 文件的内容：
- en: '![](img/7dd91925-8ecc-43fb-96b3-b8d486459f9c.png)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/7dd91925-8ecc-43fb-96b3-b8d486459f9c.png)'
- en: As you can see, since the preceding execution no longer uses the shared objects
    file (which was turned off using the `Xshare:off` option), the system or core
    API classes are loaded at runtime from their respective modules. As highlighted
    at the left bottom of the screenshot, you can also see that this execution takes
    a longer amount of time, that is, approximately 0.110 seconds. This time exceeds
    the execution time of 0.083 seconds for similar execution, which used the shared
    archive (shown in previous screenshot).
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，由于之前的执行不再使用共享对象文件（使用 `Xshare:off` 选项已关闭），系统或核心 API 类在运行时从各自的模块中加载。如截图左下角所突出显示的，你还可以看到这次执行花费了更长的时间，即大约
    0.110 秒。这个时间超过了使用共享存档（如前一个截图所示）的类似执行的 0.083 秒执行时间。
- en: With the basic information on how CDS can lower execution time for your code,
    let's get started with AppCDS.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在了解了 CDS 如何降低代码执行时间的基本信息后，让我们开始使用 AppCDS。
- en: AppCDS
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: AppCDS
- en: Increased users and usage of technology are driving exploration or formulation
    of better ways to improve performance every day. JEP 310 proposed extension of
    CDS to support application files. In this section, you'll cover how AppCDS is
    improving the performance of Java applications and how to create and use it.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 增加的用户和技术使用正在推动每天探索或制定更好的方法来提高性能。JEP 310 提出了将 CDS 扩展到支持应用程序文件。在本节中，你将了解 AppCDS
    如何提高 Java 应用程序的性能以及如何创建和使用它。
- en: Benefits of AppCDS
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: AppCDS 的好处
- en: AppCDS extends the benefits of CDS to application classes, enabling you to place
    application classes with the shared archive of core library classes. This takes
    off the work of class loading, linking, and bytecode verification, leading to
    a reduced startup time of an application. Multiple JVMs can access a shared archive,
    resulting in a reduced overall memory footprint.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: AppCDS 将 CDS 的好处扩展到应用程序类，使你能够将应用程序类与核心库类的共享存档一起放置。这消除了类加载、链接和字节码验证的工作，从而减少了应用程序的启动时间。多个
    JVM 可以访问共享存档，从而减少了整体内存占用。
- en: In the cloud, it is common for servers to scale a Java application, with multiple
    JVMs executing the same application. This is an excellent use case that would
    benefit from AppCDS. Such applications would benefit tremendously from reduced
    startup time and reduced memory footprint.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在云中，服务器扩展 Java 应用程序是很常见的，多个 JVM 执行相同的应用程序。这是一个非常适合 AppCDS 的用例。此类应用程序将从减少启动时间和减少内存占用中受益巨大。
- en: Serverless cloud services load thousands of application classes at startup.
    AppCDS will significantly reduce their startup time.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 无服务器云服务在启动时加载成千上万的应用程序类。AppCDS 将显著减少它们的启动时间。
- en: Enabling application class data archive
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 启用应用程序类数据存档
- en: 'With Java 10, the default configuration only enabled class data sharing for
    JVM''s bootstrap class loader. Since the bootstrap class loader doesn''t load
    your application''s files, you were expected to explicitly enable it for the application
    class loader and other class loaders using the following command:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Java 10 中，默认配置仅启用了 JVM 的引导类加载器的类数据共享。由于引导类加载器不加载你的应用程序文件，因此你预计需要显式地为应用程序类加载器和其他类加载器使用以下命令启用它：
- en: '[PRE5]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'With Java 11, however, AppCDS is automatically enabled with OpenJDK 64-bit
    systems. When including this option, you might get an error message like this:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在 Java 11 中，AppCDS 在 OpenJDK 64 位系统上自动启用。当包含此选项时，你可能会收到如下错误消息：
- en: '![](img/5f3002d9-ecba-4112-8bf6-6ac0a61fa056.png)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/5f3002d9-ecba-4112-8bf6-6ac0a61fa056.png)'
- en: If you are using Java version 11 or later, you can skip this option.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在使用 Java 11 或更高版本，你可以跳过此选项。
- en: Java runtime options are case sensitive. The `-XX:+UseAppCDS` and `-XX:+useAppCDS` options are
    not the same.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: Java 运行时选项对大小写敏感。`-XX:+UseAppCDS` 和 `-XX:+useAppCDS` 选项并不相同。
- en: Which application classes to archive
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 哪些应用程序类需要存档
- en: The next step in creating a shared archive includes specifying the application
    classes to be included. Examine the `myCDSlog.log` file that you created in the
    preceding section. It doesn't include each class or interface that is defined
    in the core Java API.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 创建共享归档的下一步是指定要包含的应用程序类。检查您在前一节中创建的`myCDSlog.log`文件。它不包含在核心Java API中定义的每个类或接口。
- en: Similarly, even though your application might include a lot of classes, you
    need not include **all** of them in the shared archive file, simply because not all
    of them are required at startup. This also reduces the size of the shared archive
    file.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，尽管您的应用程序可能包含很多类，但您不需要将**所有**它们包含在共享归档文件中，仅仅是因为不是所有类在启动时都是必需的。这也减少了共享归档文件的大小。
- en: Here's an example to find the application classes that should be added to the
    shared archive. To start with, create a `jar` file of your application files.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个示例，用于找到应该添加到共享归档中的应用程序类。首先，创建应用程序文件的`jar`文件。
- en: 'Let''s create four skeleton class files in the `com.ejavaguru.appcds` package:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在`com.ejavaguru.appcds`包中创建四个骨架类文件：
- en: '[PRE6]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'And here''s the content of the `AppCDS` class, which uses one of the preceding
    classes. It isn''t defined in the same package:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是`AppCDS`类的内容，它使用前面提到的其中一个类。它不在同一个包中定义：
- en: '[PRE7]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'If your directory structure matches your package structure, you can create
    a `jar` file using the following command:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的目录结构与包结构匹配，您可以使用以下命令创建`jar`文件：
- en: '![](img/5a90851f-bffe-470c-888d-50de9ef5c47b.png)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5a90851f-bffe-470c-888d-50de9ef5c47b.png)'
- en: 'To determine the application classes that should be placed in the shared archive,
    execute the following command:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 要确定应该放入共享归档中的应用程序类，执行以下命令：
- en: '[PRE8]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: On execution of the previous command, `myappCDS.lst` records the fully qualified
    name (separated using `\`) of all classes (approximately 500) that were loaded
    by JVM. It includes both the core API classes and your application classes.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 执行前面的命令后，`myappCDS.lst`记录了由JVM加载的所有类的完全限定名（使用`\`分隔，大约有500个），包括核心API类和您的应用程序类。
- en: 'The following screenshot includes a few of these class names from the `myappCDS.lst`
    file. I''ve highlighted the names of two application files included in this list—`AppCDS`
    and `com/ejavaguru/appcds/Plastic`:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了`myappCDS.lst`文件中的一些类名。我已经突出显示了列表中包含的两个应用程序文件的名字——`AppCDS`和`com/ejavaguru/appcds/Plastic`：
- en: '![](img/2b81c48e-240c-40c3-86e5-995bf8c2dece.png)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2b81c48e-240c-40c3-86e5-995bf8c2dece.png)'
- en: If you revisit the code of the `AppCDS` class, you'll notice that it uses just
    one class, that is, `Plastic`, from the `com.ejavaguru.appcds` package. The other
    classes from the same package are not loaded because they are not used. If you
    want to load other specific classes, you should use them in your application.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您重新查看`AppCDS`类的代码，您会注意到它只使用了一个类，即`com.ejavaguru.appcds`包中的`Plastic`类。同一包中的其他类没有加载，因为它们没有被使用。如果您想加载其他特定的类，您应该在应用程序中使用它们。
- en: After accessing the list of application files to be included in the shared archive,
    you can move forward and create it.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在访问要包含在共享归档中的应用程序文件列表后，您可以继续并创建它。
- en: Creating an application shared archive file
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建应用程序共享归档文件
- en: 'To create the shared archive with the application files, you can execute the
    following command in Command Prompt:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用应用程序文件创建共享归档，您可以在命令提示符中执行以下命令：
- en: '[PRE9]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: As mentioned in the *Enabling application class data archive* section, if you
    are using Java 11 or a later version on your system, you can skip using the `-XX:+UseAppCDS`
    option (AppCDS was introduced in Java 10; with Java 11, you don't need to enable
    it explicitly). The preceding command uses the list of class names stored in `myappCDS.lst`
    to create the application shared archive file. It also specifies the name of the
    shared archive file as `appCDS.jsa`.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 如在*启用应用程序类数据归档*部分所述，如果您在系统上使用Java 11或更高版本，可以跳过使用`-XX:+UseAppCDS`选项（AppCDS是在Java
    10中引入的；在Java 11中，您不需要显式启用它）。前面的命令使用存储在`myappCDS.lst`中的类名列表来创建应用程序共享归档文件。它还指定共享归档文件的名称为`appCDS.jsa`。
- en: 'Here''s a screenshot of the output from the preceding command:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是前面命令的输出截图：
- en: '![](img/1f986e4e-e92f-414a-84b7-67d2db9593e3.png)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1f986e4e-e92f-414a-84b7-67d2db9593e3.png)'
- en: Let's move to the final step—using the shared application archive file.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们进入最后一步——使用共享应用程序归档文件。
- en: Using the shared application archive file
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用共享应用程序归档文件
- en: 'To use the shared application archive file (`appCDS.jsa`) with your AppCDS,
    execute the following command:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用与AppCDS一起的共享应用程序归档文件（`appCDS.jsa`），请执行以下命令：
- en: '[PRE10]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The preceding code will use the shared application archive file to load the
    predefined core API classes and application classes to memory. This results in
    reduced startup time of user applications. The demo application used in this chapter
    included just four or five classes to demonstrate the process, without overwhelming
    you. You should be able to notice a considerable reduction in startup time for
    bigger user applications. Also, you can share the `.jsa` file between JVMs for
    a reduced memory footprint.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 上一段代码将使用共享应用程序归档文件来加载预定义的核心API类和应用程序类到内存中。这导致用户应用程序的启动时间减少。本章中使用的演示应用程序只包含四到五个类来演示这个过程，不会让你感到负担。你应该能够注意到更大用户应用程序启动时间的显著减少。此外，你可以在JVM之间共享`.jsa`文件，以减少内存占用。
- en: Summary
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This chapter started with an introduction to AppCDS, which extends the capabilities
    of CDS to your application files. AppCDS reduces the startup time for your applications
    and reduces the memory footprint.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 本章从介绍AppCDS开始，它扩展了CDS到你的应用程序文件的能力。AppCDS减少了你应用程序的启动时间和内存占用。
- en: You walked through the process of identifying the application classes to be
    included in the shared application archive file, creating the file, and using
    it.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经了解了识别要包含在共享应用程序归档文件中的应用程序类、创建文件以及使用它的过程。
- en: AppCDS is just one of the ways to improve the performance of Java applications.
    In the next chapter, you'll discover how garbage collection optimizations will
    help to further improve the performance of Java applications.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: AppCDS只是提高Java应用程序性能的多种方法之一。在下一章中，你将了解到垃圾回收优化如何进一步帮助提高Java应用程序的性能。
- en: In the next chapter, we will look at the various optimizations introduced in
    garbage collectors.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨垃圾收集器中引入的各种优化。
