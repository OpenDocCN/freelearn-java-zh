<html><head></head><body>
		<div id="_idContainer020">
			<h1 id="_idParaDest-17" class="chapter-number"><a id="_idTextAnchor016"/>1</h1>
			<h1 id="_idParaDest-18"><a id="_idTextAnchor017"/>Getting into Software Design Patterns</h1>
			<p>Every software architect or developer often faces the challenges of structuring code – how to develop a code structure that remains sustainable, just as an artist draws their painting. This chapter will take us on a journey into writing program code. You will explore the challenges behind the structure of code and its organization. Together, we will approach the topic from an early stage described by the pillars of object-oriented programming, known as APIE. We will also review the principles of SOLID to gain clarity in understanding <span class="No-Break">design patterns.</span></p>
			<p>In this chapter, we will cover the <span class="No-Break">following topics:</span></p>
			<ul>
				<li>Code – from symbols <span class="No-Break">to program</span></li>
				<li>Examining OOP <span class="No-Break">and APIE</span></li>
				<li>Understanding the SOLID <span class="No-Break">design principles</span></li>
				<li>The significance of <span class="No-Break">design patterns</span></li>
				<li>Reviewing what challenges design <span class="No-Break">patterns solve</span></li>
			</ul>
			<p>By the end of this chapter, you will have reviewed the basic programming concepts, which will form the basis of the rest of <span class="No-Break">the book.</span></p>
			<h1 id="_idParaDest-19"><a id="_idTextAnchor018"/>Technical requirements</h1>
			<p>You can find the code files for this chapter on GitHub <span class="No-Break">at </span><a href="https://github.com/PacktPublishing/Practical-Design-Patterns-for-Java-Developers/tree/main/Chapter01"><span class="No-Break">https://github.com/PacktPublishing/Practical-Design-Patterns-for-Java-Developers/tree/main/Chapter01</span></a><span class="No-Break">.</span></p>
			<h1 id="_idParaDest-20"><a id="_idTextAnchor019"/>Code – from symbols to program</h1>
			<p>Human speech is fruitful, rich, colorful, and way beyond what the words themselves may express. Nouns, verbs, and adjectives for precisely expressing a moment or action can be used. In contrast, machines do not understand the complex constructions or expressions that humans are able <span class="No-Break">to create.</span></p>
			<p>Machine language is limited, well-defined, extremely <a id="_idIndexMarker000"/>specific, and simplified. Its goal is to provide the precise expression of intent for which it is designed. This contrasts with human language whose purpose is just communication and not necessarily <span class="No-Break">with specifics.</span></p>
			<p>A machine’s intent can be expressed as a defined instruction or a set of them. This means that machines understand the instructions. These instructions must be available to the machine in some form at the time of execution. Each machine normally has a set of instructions. Based on this kind of instruction set, machines can perform the required instructions, as <span class="No-Break">shown here:</span></p>
			<div>
				<div id="_idContainer008" class="IMG---Figure">
					<img src="image/B18884_01_01.jpg" alt="Figure 1.1 – A simplified instruction cycle inside the CPU (instruction is taken from memory and the result is stored﻿)"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.1 – A simplified instruction cycle inside the CPU (instruction is taken from memory and the result is stored)</p>
			<p>Let us explore one individual instruction. The<a id="_idIndexMarker001"/> instruction can be understood as a command given to the processor. The processor is the heart of the machine, or the center of the ordering and executing of processes. The machine may contain one or more of them. It depends on its design, but in any case, there is always one that takes the lead. For further simplification, we will only <a id="_idIndexMarker002"/>consider one – that is, consider a system that only has one <strong class="bold">central processing unit</strong> (<strong class="bold">CPU</strong>) dedicated to executing <span class="No-Break">a program.</span></p>
			<p>A CPU is a device that executes instructions containing a computer program. The CPU must contain such an instruction set, as shown in the previous diagram, to process the <span class="No-Break">requested action.</span></p>
			<p>Because instructions can take<a id="_idIndexMarker003"/> completely different forms depending on the CPU, there is no defined standard. This promotes different CPU platforms, which is not necessarily a bad thing and contributes to evolution. However, the fact remains that the instructions are not easy for people <span class="No-Break">to read.</span></p>
			<p>We have stated that machines can perform instruction collection, ideally as a continuous flow. The flow of instructions can be simplified as a queue in memory, where one instruction goes in and the other leaves. The CPU plays the role of an interpreter who works with this memory cyclically (as we saw in <span class="No-Break"><em class="italic">Figure 1</em></span><em class="italic">.1</em>). Okay, so the CPU interprets, but as the instructions are added to the memory, where do they come from, and how can such a stream <span class="No-Break">be created?</span></p>
			<p>Let us gather some thoughts. Machine instructions, in most cases, originate from <span class="No-Break">a compiler.</span></p>
			<p>What is a compiler? The compiler<a id="_idIndexMarker004"/> can be viewed as a CPU or a platform-specific program that translates text into target actions. The text we use to call the program and the result could be named machine code. The following diagram <span class="No-Break">illustrates this:</span></p>
			<div>
				<div id="_idContainer009" class="IMG---Figure">
					<img src="image/B18884_01_02.jpg" alt="Figure 1.2 – A simplified platform-specific flow from the source code through the compiler program to its resultant action"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.2 – A simplified platform-specific flow from the source code through the compiler program to its resultant action</p>
			<p>Machine code is a low-level language that the machine understands and consists of language instructions that are processed sequentially (see <span class="No-Break"><em class="italic">Figure 1</em></span><em class="italic">.1</em>); the program was compiled, executed, <span class="No-Break">and run.</span></p>
			<p>In the case of Java, there is no <span class="No-Break">machine code:</span></p>
			<div>
				<div id="_idContainer010" class="IMG---Figure">
					<img src="image/B18884_01_03.jpg" alt="Figure 1.3 – A simplified flow for the Java program through the compiler to its platform execution"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.3 – A simplified flow for the Java program through the compiler to its platform execution</p>
			<p>The source code is compiled by the Java compiler into bytecode. The bytecode is running a <strong class="bold">Java virtual machine</strong> (<strong class="bold">JVM</strong>) (see <span class="No-Break"><em class="italic">Figure 1</em></span><em class="italic">.3</em>). In this situation, the JVM plays the role of the interface <a id="_idIndexMarker005"/>between the bytecode and the actual instructions that are executed on the CPU. The JVM emulates a bytecode instruction. It does this using the <strong class="bold">just-in-time</strong> (<strong class="bold">JIT</strong>) compiler<a id="_idIndexMarker006"/> that is part of the JVM. The JIT compiler translates bytecode instructions into native processor instructions. The JVM is a platform-specific interpreter, analogous to directly compiled code (see <span class="No-Break"><em class="italic">Figure 1</em></span><em class="italic">.2</em>). The JVM also provides additional features such as memory management and garbage collection, which is what makes the Java platform so powerful. All these features allow developers to write code once, compile it into bytecode, and run a supported <a id="_idIndexMarker007"/>platform – known as <strong class="bold">write once, run </strong><span class="No-Break"><strong class="bold">anywhere</strong></span><span class="No-Break"> (</span><span class="No-Break"><strong class="bold">WORA</strong></span><span class="No-Break">).</span></p>
			<p>In the context of the previous exploration, Java is a high-level language that is translated to a low level. Java provides a strong abstraction from the details of computer functionality. It allows programmers to create simpler programs for <span class="No-Break">complex challenges.</span></p>
			<p>At this point, we begin our journey of jointly exploring standardized solutions. Later in the book, we will review how to create code that is maintainable and extensible with fewer memory requirements. Together, we will discuss different types of design patterns that can help us to make our daily work understandable, transparent, and <span class="No-Break">more fun.</span></p>
			<h1 id="_idParaDest-21"><a id="_idTextAnchor020"/>Examining OOP and APIE</h1>
			<p>In the previous section, we learned how a program written in one of the high-level languages is converted into machine instructions that are processed by the CPU. The high-level language provides a framework for expressing the desired ideas by following the details of the language implementation. Such languages commonly provide many neat constructions or <a id="_idIndexMarker008"/>statements that do not limit the imagination. In <strong class="bold">object-oriented programming</strong> (<strong class="bold">OOP</strong>) language, the representation of the core carrier is presented by the concept of the object. This book focuses on the Java language. Java is a fully object-oriented language with additional features. What does object-oriented language mean exactly? In computer science, this means that the program focuses on the concept of classes, where instances of these classes represent an object. Next, we will repeat the importance of the OOP paradigm and deal with some <span class="No-Break">basic concepts.</span></p>
			<p>These terms can be expressed by the abbreviation of <strong class="bold">abstraction, polymorphism, inheritance, and encapsulation</strong> (<strong class="bold">APIE</strong>). The letters APIE indicate the four basic pillars of OOP languages. Let’s <a id="_idIndexMarker009"/>examine each word in a separate section in reverse order – so, EIPA. The motivation is to bring more clarity to our understanding of the concept <span class="No-Break">of OOP.</span></p>
			<h2 id="_idParaDest-22"><a id="_idTextAnchor021"/>Only exposing what’s required – encapsulation</h2>
			<p>The first in reverse order is <a id="_idIndexMarker010"/>encapsulation – let’s start with it. OOP languages, including Java, work with the concept of classes. Imagine that a class is a vehicle. The class provides all the fields that can be statically typed or object-specific – that is, initiated after an object is instantiated in the allocated memory. The concept is similar with respect to class or object methods. The method may belong to a class or its instance – in the considered example, to a vehicle. Any method can work over an object or class field and change the internal state of the vehicle or the field values (see <span class="No-Break"><em class="italic">Example 1.1</em></span><span class="No-Break">):</span></p>
			<pre class="source-code">
public class Vehicle {
    private boolean moving;
    public void move(){
        this.moving = true;
        System.out.println("moving...");
    }
    public void stop(){
        this.moving = false;
        System.out.println("stopped...");
    }
}</pre>
			<p class="SC---Link" lang="en-US" xml:lang="en-US">Example 1.1 – The Vehicle class hides an internal state (moving)</p>
			<p>We can apply encapsulation to the example of a vehicle. We imagine a real vehicle – only one. In such an imaginary vehicle, all internal elements and internal functions remain hidden from the driver. It only exposes the functionality it serves, such as the steering wheel, which the driver can control. This is the general principle of encapsulation. The state of an instance can be changed or updated through exposed methods or fields; everything else is hidden from the outside world. It is quite a good practice to use methods to modify the<a id="_idIndexMarker011"/> inner array or arrays of an instance. But we will repeat that later in this book. So far, it’s just a <span class="No-Break">good hint.</span></p>
			<h2 id="_idParaDest-23"><a id="_idTextAnchor022"/>Inevitable evolution – inheritance</h2>
			<p>In the previous section, an<a id="_idIndexMarker012"/> instance of an imaginary vehicle class was created. We encapsulated all the functions that should not be exposed to the driver. This means that the driver may not know how the engine works, only how to <span class="No-Break">use it.</span></p>
			<p>This section is devoted to the property of inheritance, which we will demonstrate in the following example. Assume that the vehicle’s engine is broken. How can we replace it? The goal is to replace the current one with a functional one. An engine that works this way may not necessarily be the same, especially if the vehicle model already has old parts that are not available on <span class="No-Break">the market.</span></p>
			<p>What we do is derived from all the attributes and functions needed to create a new engine. Concerning the class, the new replacement module will be a child in the <span class="No-Break">class hierarchy.</span></p>
			<p>Although the engine will not be a perfect replica and does not have the same unique object identifier, it will match all the <span class="No-Break">parent properties.</span></p>
			<p>With that, we have described the second pillar of inheritance in OOP – the ability to create a new class above the existing subclass. However, software designers should be wary of the fourth pillar, encapsulation, and any violations caused by a subclass depending on the implementation details of <span class="No-Break">its superclass.</span></p>
			<h2 id="_idParaDest-24"><a id="_idTextAnchor023"/>Behavior on demand – polymorphism</h2>
			<p>The third concept is<a id="_idIndexMarker013"/> polymorphism. With a little imagination, this can be understood as “many forms.” So, what does that <span class="No-Break">mean here?</span></p>
			<p>Given the vehicle described previously, it could be defined as the ability to perform a particular action in many ways. This would mean, in the context of a vehicle, that the movement of the other method, <strong class="source-inline">move</strong>, could happen differently based on the inputs or the state of <span class="No-Break">the instance.</span></p>
			<p>Java allows for two types<a id="_idIndexMarker014"/> of polymorphism, both of which differ in their runtime behavior. We will discuss both <span class="No-Break">in detail.</span></p>
			<h3>Method overloading</h3>
			<p>This type is known as <a id="_idIndexMarker015"/>static polymorphism. This means that the correct <a id="_idIndexMarker016"/>method is resolved <a id="_idIndexMarker017"/>during program compilation – so, at compile time. Java provides two types of <span class="No-Break">method overloads:</span></p>
			<ul>
				<li>Changing the input <span class="No-Break">argument type:</span></li>
			</ul>
			<div>
				<div id="_idContainer011" class="IMG---Figure">
					<img src="image/B18884_01_04.jpg" alt="Figure 1.4 – Overloading the method of the Vehicle class by changing the input types"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.4 – Overloading the method of the Vehicle class by changing the input types</p>
			<ul>
				<li>Changing the number of <span class="No-Break">method arguments:</span></li>
			</ul>
			<div>
				<div id="_idContainer012" class="IMG---Figure">
					<img src="image/B18884_01_05.jpg" alt="Figure 1.5 – Overloading the method of the Vehicle class by changing the number of arguments"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.5 – Overloading the method of the Vehicle class by changing the number of arguments</p>
			<p>Now, let’s look at the <a id="_idIndexMarker018"/>second type <span class="No-Break">of polymorphism.</span></p>
			<h3>Method overriding</h3>
			<p>This is sometimes<a id="_idIndexMarker019"/> called dynamic polymorphism. This means that the method performed is known at<a id="_idIndexMarker020"/> runtime. The overridden method is <a id="_idIndexMarker021"/>called through reference to the object instance of belongingness. Let us examine a simple example to illustrate this. Consider the <strong class="source-inline">Vehicle</strong> class a parent class (see <span class="No-Break"><em class="italic">Figure 1</em></span><em class="italic">.6</em> and <em class="italic">Example 1.2</em>) with a method <span class="No-Break">called </span><span class="No-Break"><strong class="source-inline">move</strong></span><span class="No-Break">:</span></p>
			<div>
				<div id="_idContainer013" class="IMG---Figure">
					<img src="image/B18884_01_06.jpg" alt="Figure 1.6 – The relation between the overridden move methods for the parent and child classes"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.6 – The relation between the overridden move methods for the parent and child classes</p>
			<p>We intend to create a child class, <strong class="source-inline">Car</strong>, with a similar method named <strong class="source-inline">move</strong>. The child provides slightly different functions because the <strong class="source-inline">Car</strong> instance moves faster than the parent <span class="No-Break">instance, </span><span class="No-Break"><strong class="source-inline">Vehicle</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
public class Vehicle {
    public void move(){
        System.out.println("moving...");
    }
}
public class Car extends Vehicle {
    @Override
    public void move(){
        System.out.println("moving faster.");
    }
}
Vehicle vehicle = new Car();
vehicle.move();
output: moving faster...</pre>
			<p class="SC---Link" lang="en-US" xml:lang="en-US">Example 1.2 – The Vehicle variable holds the reference to the Car instance and the appropriate move method is executed at runtime (see Figure 1.6)</p>
			<p>We will touch on<a id="_idIndexMarker022"/> this topic in more <a id="_idIndexMarker023"/>detail in <a href="B18884_03.xhtml#_idTextAnchor093"><span class="No-Break"><em class="italic">Chapter 3</em></span></a>, <em class="italic">Working with Creational </em><span class="No-Break"><em class="italic">Design Patterns</em></span><span class="No-Break">.</span></p>
			<h2 id="_idParaDest-25"><a id="_idTextAnchor024"/>Standard features – abstraction</h2>
			<p>The last letter to cover (but the first letter in the abbreviation APIE) leads us to the hitherto unspecified pillar of<a id="_idIndexMarker024"/> abstraction. The key to this concept is the constant removal of specifics or individual details to achieve the generalization of the purpose of <span class="No-Break">the object.</span></p>
			<p>To get the best experience with this concept, let us get into the context with the vehicle example. We do not intend to describe a specific car model that belongs to a group of vehicles. Our goal is to define a common functionality that all types of vehicles under consideration can include in the context of our efforts. With such knowledge, we create a suitable abstraction, an abstract class that can be inherited later when constructing a particular model class (see <span class="No-Break"><em class="italic">Example 1.3</em></span><span class="No-Break">).</span></p>
			<p>This approach allows us to focus our efforts on generalizing and abstracting vehicle characteristics. This can have a positive impact on code reduction <span class="No-Break">and reusability.</span></p>
			<p>The abstraction in Java can be achieved in <span class="No-Break">two ways:</span></p>
			<ul>
				<li>Abstract classes <a id="_idIndexMarker025"/>with abstract methods (see <em class="italic">Example 1.3</em> and <span class="No-Break"><em class="italic">Figure 1</em></span><span class="No-Break"><em class="italic">.7</em></span><span class="No-Break">):</span></li>
			</ul>
			<div>
				<div id="_idContainer014" class="IMG---Figure">
					<img src="image/B18884_01_07.jpg" alt="Figure 1.7 – The AbstractVehicle class with its CommonCar realizations and SportCar classes"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.7 – The AbstractVehicle class with its CommonCar realizations and SportCar classes</p>
			<pre class="source-code">
public abstract class AbstractVehicle {
    abstract public void move();
    public void stop(){
        System.out.println("stopped...");
    }
}
public class CommonCar extends AbstractVehicle{
    @Override
    public void move() {
        System.out.println("move slow...");
    }
}
public class SportCar extends AbstractVehicle{
    @Override
    public void move() {
        System.out.println("move fast...");
    }
}</pre>
			<p class="SC---Link" lang="en-US" xml:lang="en-US">Example 1.3 – The extraction of the common functionality without providing a particular implementation by using an abstract class concept</p>
			<ul>
				<li>Using<a id="_idIndexMarker026"/> interfaces (see <em class="italic">Example 1.4</em> and <span class="No-Break"><em class="italic">Figure 1</em></span><em class="italic">.8</em>) with a generic <span class="No-Break">abstract method:</span></li>
			</ul>
			<div>
				<div id="_idContainer015" class="IMG---Figure">
					<img src="image/B18884_01_08.jpg" alt="Figure 1.8 – The abstraction concept achieved by using interfaces"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.8 – The abstraction concept achieved by using interfaces</p>
			<pre class="source-code">
public interface VehicleInterface {
    void move();
}
public class Truck implements VehicleInterface{
    @Override
    public void move() {
        System.out.println("truck moves...");
    }
}
public class Bus implements VehicleInterface{
    @Override
    public void move() {
        System.out.println("bus moves...");
    }
}</pre>
			<p class="SC---Link" lang="en-US" xml:lang="en-US">Example 1.4 – A similar functionality extraction by using Java interfaces</p>
			<p>Both concepts <a id="_idIndexMarker027"/>of abstraction can be combined (see <span class="No-Break"><em class="italic">Figure 1</em></span><span class="No-Break"><em class="italic">.9</em></span><span class="No-Break">):</span></p>
			<div>
				<div id="_idContainer016" class="IMG---Figure">
					<img src="image/B18884_01_09.jpg" alt="Figure 1.9 – A combination of both abstraction concepts"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.9 – A combination of both abstraction concepts</p>
			<p>Abstract classes and interfaces have their place in the design of code structure. Their use depends on demand, but both have a very positive impact on code maintainability and help in the use of <span class="No-Break">design patterns.</span></p>
			<h2 id="_idParaDest-26"><a id="_idTextAnchor025"/>Gluing parts to APIE</h2>
			<p>The motivation for each <a id="_idIndexMarker028"/>of the pillars mentioned in the previous sections is to introduce structure into the code through a given set of concepts. The pillars are defined and complementary. Let’s just examine one unit, the <strong class="source-inline">Vehicle</strong> class, and its instance. Instance logic and data are encapsulated and exposed through methods to the outside world. Vehicle characteristics can be inherited so that a new vehicle design, such as a new model, can be specified. Exposed methods can provide model-based behavior and incoming arguments with internal instance state changes. When crystalizing thoughts about a new vehicle, we can always generalize its behavior and extract it using an abstract class or interface. </p>
			<p>Let us examine the generalization process over the <strong class="source-inline">Vehicle</strong> class development. When preparing to define a new vehicle model, we can always generalize its characteristics and extract it using an abstract class or interface. Let’s look at the <span class="No-Break">following diagram:</span></p>
			<div>
				<div id="_idContainer017" class="IMG---Figure">
					<img src="image/B18884_01_10.jpg" alt="Figure 1.10 – APIE viewed as a continual improvement process"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.10 – APIE viewed as a continual improvement process</p>
			<p>Although these four pillars seem trivial, it is incredibly difficult to follow them, as we will continue to show in the following sections <span class="No-Break">and chapters.</span></p>
			<p>So far in this section, we learned about the four basic pillars of OOP and examined how these principles affect code design. Next, we will learn more about sustainable code design concepts. Let us roll on<a id="_idIndexMarker029"/> to the <span class="No-Break">following section.</span></p>
			<h1 id="_idParaDest-27"><a id="_idTextAnchor026"/>Understanding the SOLID design principles</h1>
			<p>In the previous sections, the idea of structured work was introduced. The development pillars of APIE were elaborated on in detail using examples. You have gained a foundational understanding of the<a id="_idIndexMarker030"/> concept of class instances in terms of object-oriented principles and how we can create different types of <span class="No-Break">specific objects:</span></p>
			<div>
				<div id="_idContainer018" class="IMG---Figure">
					<img src="image/B18884_01_11.jpg" alt="Figure 1.11 – Vehicle N, where N is a positive integer number, represents an instance of the Vehicle class"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.11 – Vehicle N, where N is a positive integer number, represents an instance of the Vehicle class</p>
			<p>Classes can be instantiated so that an instance becomes an object. The object must fit into free memory. We say that the object allocates memory space. When Java is considered, allocated memory is virtual space inside the physical system’s memory. </p>
			<p>Just a small note – we previously discussed the existence of the JVM, an interpreter of compiled bytecode for the required platform (see <span class="No-Break"><em class="italic">Figure 1</em></span><em class="italic">.3</em>). We mentioned other JVM features, one of which is memory management. In other words, the JVM assumes responsibility for allocating virtual memory space. This virtual memory space can be used to allocate an instance of a class. This virtual memory and its fragmentation are taken care of by the JVM and an unused object cleans up the selected garbage collection algorithm, but this is beyond the scope of this book and would be the subject of further study (see <span class="No-Break"><em class="italic">Reference 1</em></span><span class="No-Break">).</span></p>
			<p>Every programmer, although it may not be obvious at first glance, plays the role of a software designer. The programmer creates the code by writing it. The code carries an idea that is semantically transformed into action depending on the <span class="No-Break">text entered.</span></p>
			<p>Over time, software development has gone through many phases and many articles have been written and published on software maintenance and reusability. One of the milestones in software development may be considered the year 2000 when Robert C. Martin published his paper on <em class="italic">Design Principles and Design Patterns</em> (see <em class="italic">Reference 2</em>). The paper reviews and examines techniques in the design and implementation of software development. These techniques were later simplified in 2004 into the mnemonic<a id="_idIndexMarker031"/> <span class="No-Break">acronym SOLID.</span></p>
			<p>The goal of the SOLID principles is to help software designers make software and its structure more sustainable, reusable, and extensible. In the following sections, we will examine each of the individual terms hidden after the initial letter in the <span class="No-Break">abbreviation SOLID.</span></p>
			<h2 id="_idParaDest-28"><a id="_idTextAnchor027"/>The single-responsibility principle (SRP) – the engine is just an engine</h2>
			<p>The first principle is a well-defined<a id="_idIndexMarker032"/> class goal. We can say that each class should have only one reason to exist. As in, it has the intention<a id="_idIndexMarker033"/> and responsibility for only one part of the functionality. The class should encapsulate this part of the program. Let’s put this in the context of an example. Imagine the previous example of a vehicle and its abstraction. We are now extending this class with the <strong class="source-inline">Engine</strong> and <strong class="source-inline">VehicleComputer</strong> classes, <span class="No-Break">as shown:</span></p>
			<div>
				<div id="_idContainer019" class="IMG---Figure">
					<img src="image/B18884_01_12.jpg" alt="Figure 1.12 – The Vehicle class instance using Engine and VehicleComputer realization but an engine functionality does not interfere with the lights"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.12 – The <strong class="source-inline">Vehicle</strong> class instance using <strong class="source-inline">Engine</strong> and <strong class="source-inline">VehicleComputer</strong> realization but an engine functionality does not interfere with the lights</p>
			<p>The engine can start and stop, but the instance of the <strong class="source-inline">Engine</strong> class cannot control vehicle lights, for example. The light control is the responsibility of the vehicle computer <span class="No-Break">class instance.</span></p>
			<h2 id="_idParaDest-29"><a id="_idTextAnchor028"/>The open-closed principle (OCP)</h2>
			<p>This principle states that the<a id="_idIndexMarker034"/> class or entity under consideration should be open to extension but closed to modifications. It goes hand in hand with the concepts already<a id="_idIndexMarker035"/> mentioned. Let’s put this in the context of an example where we consider the <strong class="source-inline">Car</strong> and <strong class="source-inline">Truck</strong> classes. Both classes inherit the <strong class="source-inline">Vehicle</strong> interface. Both believe that vehicle entities have a <span class="No-Break"><strong class="source-inline">move</strong></span><span class="No-Break"> method.</span></p>
			<p>By not thinking about proper abstraction and without respecting the OCP, code can easily bear unexpected difficulties when classes are not easy to reuse or cannot be handled (see <span class="No-Break"><em class="italic">Example 1.5</em></span><span class="No-Break">):</span></p>
			<pre class="source-code">
public interface Vehicle {}
public class Car implements Vehicle{
    public void move(){}
}
public class Truck implements Vehicle {
    public void move(){}
}
-- usage --
List&lt;Vehicle&gt; vehicles = Arrays.asList(new Truck(), new 
    Car());
vehicles.get(0).move() // ERROR, NOT POSISBLE!</pre>
			<p class="SC---Link" lang="en-US" xml:lang="en-US">Example 1.5 – Although both are considered entities, Truck and Car inherit a Vehicle interface, the move method is compliant, and this causes an issue in extension or execution</p>
			<p>The correction of the example at hand is very trivial in this case (see <span class="No-Break"><em class="italic">Example 1.6</em></span><span class="No-Break">):</span></p>
			<pre class="source-code">
public interface Vehicle {
    void move();    // CORRECTION!
}
--- usage ---
List&lt;Vehicle&gt; vehicles = Arrays.asList(new Truck(), new 
    Car());
vehicles.get(0).move() // CONGRATULATION, ALL WORKS!</pre>
			<p class="SC---Link" lang="en-US" xml:lang="en-US">Example 1.6 – The Vehicle interface provides a move abstraction method</p>
			<p>Obviously, as code <a id="_idIndexMarker036"/>evolves, non-compliance leads to <span class="No-Break">unexpected </span><span class="No-Break"><a id="_idIndexMarker037"/></span><span class="No-Break">challenges.</span></p>
			<h2 id="_idParaDest-30"><a id="_idTextAnchor029"/>The Liskov Substitution Principle (LSP) – substitutability of classes</h2>
			<p>The previous sections <a id="_idIndexMarker038"/>dealt with inheritance and abstraction as two of the key pillars of OOP. It will come as no surprise to those of you <a id="_idIndexMarker039"/>who have read carefully that, given the class hierarchy of parent-child relationships, a child may be replaced or represented by its parent and vice versa (see <em class="italic">Example 1.7</em>). Let us look at the example of <strong class="source-inline">CarWash</strong>, where you can wash <span class="No-Break">any vehicle:</span></p>
			<pre class="source-code">
public interface Vehicle {
    void move();
}
public class CarWash {
    public void wash(Vehicle vehicle){}      
}
public class Car implements Vehicle{
    public void move(){}
}
public class SportCar extends Car {}
--- usage ---
CarWash carWash = new CarWash();
carWash.wash(new Car());
carWash.wash(new SportCar());</pre>
			<p class="SC---Link" lang="en-US" xml:lang="en-US">Example 1.7 – A CarWash example where any Vehicle type can be substituted by appropriate instances of classes in the class hierarchy</p>
			<p>This means that classes of a similar type can act analogously and replace the original class. This statement was first <a id="_idIndexMarker040"/>mentioned during a keynote address by Barbara Liskov in 1988 (see <em class="italic">Reference 3</em>). The <a id="_idIndexMarker041"/>conference focused on data abstraction and hierarchy. The statement was based on the idea of substitutability of class instances and interface segregation. Let’s look at interface <span class="No-Break">segregation next.</span></p>
			<h2 id="_idParaDest-31"><a id="_idTextAnchor030"/>The interface segregation principle (ISP)</h2>
			<p>This principle states that no<a id="_idIndexMarker042"/> instance of a class should be forced to depend on methods that are not used or in their<a id="_idIndexMarker043"/> abstractions. It also provides instructions on how to structure interfaces or abstract classes. In other words, it controls how to divide the intended methods into smaller, more specific entities. The client could use these entities transparently. To point out a malicious implementation, consider <strong class="source-inline">Car</strong> and <strong class="source-inline">Bike</strong> as children of the <strong class="source-inline">Vehicle</strong> interface, which shares all the abstract methods (see <span class="No-Break"><em class="italic">Example 1.8</em></span><span class="No-Break">):</span></p>
			<pre class="source-code">
public interface Vehicle {
    void setMove(boolean moving);
    boolean engineOn();
    boolean pedalsMove();
}
public class Bike implements Vehicle{
    ...
    public boolean engineOn() {
        throw new IllegalStateException("not supported");
    }
    ...
}
public class Car implements Vehicle {
    ...
    public boolean pedalsMove() {
        throw new IllegalStateException("not supported");
    }
}
--- usage ---
private static void printIsMoving(Vehicle v) {
    if (v instanceof Car) { 
        System.out.println(v.engineOn());}
    if(v instanceof Bike) 
        {System.out.println(v.pedalsMove());}
}</pre>
			<p class="SC---Link" lang="en-US" xml:lang="en-US">Example 1.8 – Various implementations of inherited method abstraction</p>
			<p>Some of you with a<a id="_idIndexMarker044"/> keen eye will already notice that such a software <a id="_idIndexMarker045"/>design direction negatively involves software flexibility through unnecessary actions that need to be considered (such as exceptions). The remedy is based on compliance with the ISP in a very transparent way. Consider two additional interfaces, <strong class="source-inline">HasEngine</strong> and <strong class="source-inline">HasPedals</strong>, with their respective functions (see <em class="italic">Example 1.9</em>). This step forces the <strong class="source-inline">printIsMoving</strong> method to overload. The entire code becomes transparent to the client and does not require any special treatment to ensure code stability, with exceptions as an<a id="_idIndexMarker046"/> example (as seen in <span class="No-Break"><em class="italic">Example 1.8</em></span><span class="No-Break">):</span></p>
			<pre class="source-code">
public interface Vehicle {
    void setMove(boolean moving);
}
public interface HasEngine {
    boolean engineOn();
}
public interface HasPedals {
    boolean pedalsMove();
}
public class Bike implements HasPedals, Vehicle {...}
public class Car implements HasEngine, Vehicle {...}
--- usage --- 
private static void printIsMoving(Vehicle v){
    // no access to internal state
}
private static void printIsMoving(Car c) {
    System.out.println(c.engineOn());
}
private static void printIsMoving(Bike b) {
    System.out.println(b.pedalsMove());
}</pre>
			<p class="SC---Link" lang="en-US" xml:lang="en-US">Example 1.9 – The functionality split into smaller units (interfaces) based on the purpose</p>
			<p>Two interfaces, <strong class="source-inline">HasEngine</strong> and <strong class="source-inline">HasPedals</strong>, are introduced, which enforce method code overload <span class="No-Break">and transparency.</span></p>
			<h2 id="_idParaDest-32"><a id="_idTextAnchor031"/>The dependency inversion principle (DIP)</h2>
			<p>Every programmer, or <a id="_idIndexMarker047"/>rather software <a id="_idIndexMarker048"/>designer, will face the challenge of hierarchical class composition throughout their careers. The following DIP is a remarkably simple guide on how to <span class="No-Break">approach it.</span></p>
			<p>The principle suggests that a low-level class should not know about high-level classes. In the opposite direction, this means that the high-level classes, the classes that are above, should have no information about the basic classes at lower levels (see <em class="italic">Example 1.10</em>, with the <span class="No-Break"><strong class="source-inline">SportCar</strong></span><span class="No-Break"> class):</span></p>
			<pre class="source-code">
public interface Vehicle {}
public class Car implements Vehicle{}
public class SportCar extends Car {}
public class Truck implements Vehicle {}
public class Bus implements Vehicle {}
public class Garage {
    private List&lt;Vehicle&gt; parkingSpots = new ArrayList&lt;&gt;();
    public void park(Vehicle vehicle){
        parkingSpots.add(vehicle);
    }
}</pre>
			<p class="SC---Link" lang="en-US" xml:lang="en-US">Example 1.10 – The garage implementation depends on vehicle abstraction, not concrete classes in a hierarchy</p>
			<p>It also means that the implementation of a particular functionality should not depend on specific classes, but rather on their abstractions (see <em class="italic">Example 1.10</em>, with the <span class="No-Break"><strong class="source-inline">Garage</strong></span><span class="No-Break"> class).</span></p>
			<h1 id="_idParaDest-33"><a id="_idTextAnchor032"/>Significance of design patterns</h1>
			<p>The previous <a id="_idIndexMarker049"/>sections introduced two complementary approaches to software design – APIE and SOLID concepts. It has begun to crystallize that having code in a transparent form can be beneficial for a variety of reasons, because every programmer often, if not always, faces the challenge of designing a piece of code that extends or modifies <span class="No-Break">existing ones.</span></p>
			<p>One wise man once said, “<em class="italic">The way to Hell is the path of continual technical debt ignorance...</em>.” Anything that slows down or prevents the development of applications can be considered a technical debt. Translated into a programming language, this would mean that even a small part matters, if not now, then later. It also follows that code readability and purpose are crucial to application logic, as it is possible to verify various hypotheses (for example, <span class="No-Break">application operation).</span></p>
			<p>The inability to perform business-oriented application testing can be considered the first sign of incorrect development trends. It may appear to require the use of different mock-up techniques during verification. This approach can easily turn into providing false-positive results. This can usually be caused by the clutter of the code structure, which forces programmers to <span class="No-Break">use mocks.</span></p>
			<p>Although the SOLID and APIE concepts suggest several principles, they still do not guarantee that the project code base will not start to rot. Adherence to these principles makes it difficult, but there is still room because not all concepts provide the required framework for dealing <span class="No-Break">with rot.</span></p>
			<p>There may be long stories of how software can rot over time, but one fact that remains is that there is a cure for avoiding it or letting it go. The cure is covered by an idea called <strong class="bold">design patterns</strong>. The idea of a design pattern not only covers the readability of the code base and its purpose but also advances the ability to verify required <span class="No-Break">business hypotheses.</span></p>
			<p>What are the ideas behind defining it to get more clarity? The design pattern idea can be described as a set of reusable coding approaches that solve the most common problems encountered during application development. These approaches are in line with the previously mentioned APIE or SOLID concepts and have an incredibly positive impact on bringing transparency, readability, and testability to the development path. Simply put, the idea of design patterns provides a framework for accessing common challenges in <span class="No-Break">software design.</span></p>
			<h1 id="_idParaDest-34"><a id="_idTextAnchor033"/>Reviewing what challenges design patterns solve</h1>
			<p>Take a deep breath and think about the motivation for writing the program. The program is written in a programming language, in our case, Java, and is a human-readable form to address a specific<a id="_idIndexMarker050"/> challenge. Let’s look at it from a <span class="No-Break">different perspective.</span></p>
			<p>We can state that writing a program is considered a goal. The goal has its reason defined by known needs or requirements in most cases. Expectations and limitations are defined. When the goal is known, each action is chosen with the aim of achieving it. The goal is evaluated, organized, and placed in the context of the destination, where the destination means a work program addressing the required challenge. Imagine all the difficulties mentioned in the <span class="No-Break">previous sections.</span></p>
			<p>Day after day, a new solution is posed, instead of a transparent solution. Every day, another local success keeps the project afloat, despite everything looking good on <span class="No-Break">the surface.</span></p>
			<p>Currently, most teams follow the SCRUM framework. Imagine a situation where the team follows the SCRUM framework (see <em class="italic">Reference 4</em>) and application development begins to deviate from the goal. Daily standup meetings run smoothly from time to time: it is mentioned that a fundamental error has been found. A few days later, the bug is successfully fixed with great applause. Interestingly, the frequency of such notifications is growing – more corrections, more applause. But does this really mean that the project is moving towards its goal? Does this mean that the application works? Let’s look at <span class="No-Break">the answer.</span></p>
			<p>There is a darker side – the backlog is growing with features and technical debt. Technical debt is not necessarily a terrible thing. Technical debt can stimulate the project and can be especially useful in the concept validation phase. The problem with technical debt occurs when it is not recognized, ignored, and poorly evaluated – even worse when technical debt starts being labeled as <span class="No-Break">new features.</span></p>
			<p>Although the product backlog should be one entity, it begins to consist of two different and unfortunately incompatible parts – the business and the sprint backlog (mostly technical debt). Of course, the team is working on a sprint backlog that comes from planning meetings, but with increasing technical debt, there is less and less room for the relevant business functions of the product. The trends observed in this way can result in extremely tricky situations during each new sprint planning session, where the development resources should be allocated. Let’s stop for a moment and recall this situation where the team cannot move the product forward due to <span class="No-Break">technical debt.</span></p>
			<p>The values of the SCRUM methodology can be simplified to courage, concentration, determination, respect, and openness. These values are not specific to the SCRUM framework. Because the team’s motivation is to deliver the product, they all sound very logical <span class="No-Break">and fair.</span></p>
			<p>We will now refresh<a id="_idIndexMarker051"/> our memory of the state the team has achieved. A state where it cannot move the project forward and struggles with the definition and proper consolidation of technical departments. This means that the team is doing its job, but may deviate from achieving its ultimate goal. Every discussion is extremely difficult because it is difficult to solve and describe the problem correctly for many different reasons. It may seem that developers may lose their language of communication and begin to misunderstand each other. We can see that the entropy of the software has increased because the coherence is not maintained. The project is beginning to rot and convergence to the inevitable wasted development <span class="No-Break">time increases.</span></p>
			<p>Let us take another deep breath and think together about how to prevent such a situation. It must be possible to identify these tendencies. Usually, each team has some commonality: the team is not always homogeneous in terms of knowledge, but this should not prevent us from identifying the degradation of the <span class="No-Break">learning curve.</span></p>
			<p>The project learning curve can help us identify a rotting project. Instead of gradual improvements towards the goal, the team experiences local successes full of technical repairs and solutions. Such successes do not even correspond to the values of SCRUM and gradual improvement seems unlikely. The solution may not be considered an improvement because it is specific to a particular movement and may violate the specifications of the technology used. During the solution period, the team may not acquire any useful knowledge applicable to the future. This can soon be considered a missing business opportunity due to the inability to supply business elements or only parts <span class="No-Break">of them.</span></p>
			<p>In addition to the degradation of the learning curve, other symptoms can be identified. This can be described as an inability to test a business function. Project code is proving sticky, dependencies are out of control, which can also harm code readability, testability, and, of course, programmer discipline. The daily goal of the software designer can be reduced to closing <span class="No-Break">a ticket.</span></p>
			<p>To avoid getting to this state, this book will provide some guidelines for solving the most common problems in the following chapters by introducing and questioning different types of design patterns. The design patterns are in line with the aforementioned basic pillars of OOP and APIE and<a id="_idIndexMarker052"/> promote the principles <span class="No-Break">of SOLID.</span></p>
			<p>What’s more, design patterns can highlight any misunderstood directions and enforce the <strong class="bold">don’t repeat yourself</strong> (<strong class="bold">DRY</strong>) principle. As a result, there is much less duplication, code testability, and <a id="_idIndexMarker053"/>more fun on <span class="No-Break">the project.</span></p>
			<p>That brings us to the end of <span class="No-Break">this chapter.</span></p>
			<h1 id="_idParaDest-35"><a id="_idTextAnchor034"/>Summary</h1>
			<p>Before we embark on the journey of researching design patterns, let us quickly summarize. This chapter has expanded or improved our understanding of various areas. Each of these areas affects program code from <span class="No-Break">different perspectives:</span></p>
			<ul>
				<li>Code transparency <span class="No-Break">and readability</span></li>
				<li>The ability to solve <span class="No-Break">complex challenges</span></li>
				<li>Following SOLID and <span class="No-Break">OOP principles</span></li>
				<li>Code testability (it’s possible to verify the purpose of <span class="No-Break">the code)</span></li>
				<li>Easy to extend <span class="No-Break">and modify</span></li>
				<li>Supporting <span class="No-Break">continual refactoring</span></li>
				<li>Code <span class="No-Break">is self-explanatory</span></li>
			</ul>
			<p>The program code is written – well done. The next chapter will take us through a survey of the implementation platform – in our case, the Java platform. We will learn in more detail how and what it means to run <span class="No-Break">a program.</span></p>
			<h1 id="_idParaDest-36"><a id="_idTextAnchor035"/>Questions</h1>
			<ol>
				<li value="1">What interprets the Java code to the platform <span class="No-Break">and how?</span></li>
				<li>What does the acronym <span class="No-Break">APIE represent?</span></li>
				<li> What types of polymorphism does the Java <span class="No-Break">language allow?</span></li>
				<li>What principle helps software designers to produce <span class="No-Break">maintainable code?</span></li>
				<li>What does the <span class="No-Break">OCP mean?</span></li>
				<li>What should be considered about <span class="No-Break">design patterns?</span></li>
			</ol>
			<h1 id="_idParaDest-37"><a id="_idTextAnchor036"/>Further reading</h1>
			<ul>
				<li><em class="italic">The Garbage Collection Handbook: The Art of Automatic Memory Management</em>, Anthony Hosking, J. Eliot B. Moss, and Richard Jones, CRC Press, ISBN-13: 978-1420082791, ISBN-10: <span class="No-Break">9781420082791, 1996.</span></li>
				<li><em class="italic">Design Principles and Design Patterns</em>, Robert C. Martin, Object <span class="No-Break">Mentor, 2000.</span></li>
				<li><em class="italic">Keynote address - data abstraction and hierarchy</em>, Barbara Liskov, <a href="https://dl.acm.org/doi/10.1145/62139.62141"><span class="No-Break">https://dl.acm.org/doi/10.1145/62139.62141</span></a><span class="No-Break">, 1988.</span></li>
				<li>The SCRUM framework, <a href="https://www.scrum.org/">https://www.scrum.org/</a>, 2022. </li>
			</ul>
		</div>
	</body></html>