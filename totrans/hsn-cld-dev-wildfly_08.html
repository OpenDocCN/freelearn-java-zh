<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Scaling and Connecting Your Services</h1>
                </header>
            
            <article>
                
<p class="western">In this chapter, we will look in greater detail at the process of deploying, scaling, and connecting your applications. In <a href="461aee71-984a-4158-addc-fc49341d3455.xhtml">Chapter 6</a>, <em>Deploying Applications on the Cloud with OpenShift</em>, you have already learned the basic information about deploying services to the OpenShift cloud. Now it's time to extend this knowledge and learn how to use it in practice.</p>
<p>Let's start with deployments.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Deployments</h1>
                </header>
            
            <article>
                
<p>Let's examine what happens under the hood during deployment of our services. We are going to continue work on an example from the previous chapter.</p>
<div class="packt_infobox">Examples reference: <kbd>chapter8/catalog-service-openshift-load-balancing</kbd>.</div>
<p>You have to open the web console, and navigate to <span class="packt_screen">Applications</span>| <span class="packt_screen">Deployments</span> | <span class="packt_screen">catalog-service</span>:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/9cd46b6b-7ca7-4fca-bd03-009c0bcf94ce.png"/></div>
<p>Now we will be able to see the deployment configuration. This is the graphical representation of OpenShift's <kbd>DeploymentConfiguration</kbd> object.</p>
<p>As you learned in <a href="461aee71-984a-4158-addc-fc49341d3455.xhtml">Chapter 6</a>, <em>Deploying Applications on the Cloud with OpenShift</em>, OpenShift adds another layer on top of Kubernetes to provide a more convenient and productive programmer experience. It does that, among other things, by extending the object model of Kubernetes. <kbd>DeploymentConfiguration</kbd> and <span class="packt_screen">Deployments</span> are OpenShift objects that extend the Kubernetes object model.</p>
<p>The <kbd>DeploymentConfiguration</kbd> object manages the creation of the <span class="packt_screen">Deployments</span> objects. It contains all the necessary information to create <span class="packt_screen">Deployments</span>, which, as its name suggests, represents an instance of deployment. When one of the Deployments triggers happens, the old deployment object is replaced by the new one. All of the deployment objects are based on <kbd>DeploymentConfiguration</kbd>. <span class="packt_screen">Deployments</span>, among others, encapsulate Kubernetes's <kbd>ReplicationController</kbd> object. Let's understand it in greater detail.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Learning the basics of ReplicationController</h1>
                </header>
            
            <article>
                
<p><kbd>ReplicationController</kbd> contains the following information: the pod template, selector, and the number of replicas. Let's examine those further.</p>
<p>The pod template is basically a pod definition. It contains information about the containers, volumes, ports, and labels. Every pod created by this replication controller will be started using this pod template. The selector is used to determine which pods are governed by this <kbd>ReplicationController</kbd>. Finally, the number of replicas is the number of pods that we want to be running. </p>
<p>Kubernetes works in the following way: it monitors the current state of the cluster, and if that state is different from the desired state it takes actions so that the desired state is restored. The same thing happens with <kbd>ReplicationControllers</kbd>. <kbd>ReplicationController</kbd> continuously monitors the number of pods that are associated with it. If the number of the pods is different than the desired number, it starts or stops pods so that the desired state is restored. The pod is started using the pod template.</p>
<p>Let's examine the <kbd>ReplicationController</kbd> that Kubernetes created for our catalog-service. To do this, we will use the CLI:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/e9048a8c-5ec5-4be4-9a53-6c0c4fff0465.png" style=""/></div>
<p>As you will notice in the preceding screenshot, there are three replication controllers created for <span class="packt_screen">catalog-service</span>. This is the case because of each redeployment of the application results in the creation of a new deployment object with its own replication controller. Note that only <span class="packt_screen">catalog-service-3</span> has the desired number of instances greater than <span class="packt_screen">0</span>—the previous deployments have been made inactive when the new deployment was taking place.</p>
<p>Let's take a look at the description of the active controller:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/991f5556-3a23-416b-9029-9fbfcf65d9e5.png"/></div>
<p>The selector has three labels: app, deployment, and deployment-config. It unambiguously identifies the pods associated with the given deployment.</p>
<div class="packt_infobox">Exactly the same labels are used in the pod template. Other parts of the pod template contain the image from which the container is built, and the environment variables that we provided during the creation of the service. Finally, the number of current and desired replicas is set, by default, to one. </div>
<p>OK. So how do we scale our service so that it runs on more than one instance? Let's move to the web console again. We need to navigate to <span class="packt_screen">Application</span> | <span class="packt_screen">Deployments</span> again and enter the <span class="packt_screen">catalog-service</span> configuration:</p>
<div class="mce-root CDPAlignCenter CDPAlign"><img src="assets/b723deee-6a03-417f-9635-512df87f04f7.png" style=""/></div>
<p>To scale the <span class="packt_screen">catalog-service</span> application, we have to adjust the <span class="packt_screen">Replicas</span> field to the number of instances that we want to have. That's it.</p>
<p>When we look at the <kbd>ReplicationControllers</kbd> in the <kbd>oc</kbd>, we will see the following information:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/7ab5e556-694f-4204-a573-6256888f291a.png" style=""/></div>
<p>The number of pods has been changed to <span class="packt_screen">5</span>. As we saw in the <kbd>oc</kbd> output, additional pods have been started and we now have five instances. Let's check in the console (navigate to <span class="packt_screen">Applications</span> | <span class="packt_screen">Pods</span>):</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/870f86c6-83b8-4afa-b501-20d33e004397.png" style=""/></div>
<p>OpenShift has indeed scaled our application according to our needs. </p>
<p>After having worked with OpenShift for some time, you should be able to see what we meant in <a href="461aee71-984a-4158-addc-fc49341d3455.xhtml">Chapter 6</a>, <em>Deploying Applications on the Cloud with OpenShift</em>, when we wrote that OpenShift builds an effective and easy-to-use application development environment on top of Kubernetes. The preceding example showed how it works very well: Kubernetes is responsible for making sure that the state of the cluster equals the description provided. In the preceding example, this description is provided by a <kbd>ReplicationController</kbd> object (which is part of the Kubernetes object model). Note, however, that OpenShift has abstracted away all the nitty-gritty details from us. We have only provided the information such as the address of the code repository or number of replicas that we want to have. The OpenShift layer abstracts away the technical details of cluster configuration and provides us with convenient, easy-to-use tools, which allow the programmer to concentrate on the development.</p>
<p>Let's return to our main topic. The next thing that we will configure is <strong>load balancing</strong>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Load balancing</h1>
                </header>
            
            <article>
                
<p>We have just learned how to scale our service. The next natural step is to configure the load balancer. The good news is that OpenShift will do most of the stuff automatically for us.</p>
<p>In <a href="461aee71-984a-4158-addc-fc49341d3455.xhtml">Chapter 6</a>, <em>Deploying Applications on the Cloud with OpenShift</em>, where we introduced services, we learned that a service is reached using a virtual cluster IP. To understand how load balancing works, let's understand how cluster IP is implemented.</p>
<p>As we have also learned here, each node in a Kubernetes cluster runs a bunch of services, which allow a cluster to provide its functionality. One of those services is <strong>kube-proxy</strong>. Kube-proxy runs on every node and is, among other things, responsible for service implementation. Kube-proxy continuously monitors the object model describing the cluster and gathers information about currently active services and pods on which those services run. When the new service appears, kube-proxy modifies the iptables rules so that the virtual cluster's IP is routed to one of the available pods. The iptables rules are created so that the choice of the pod is random. Also, note that those IP rules have to be constantly rewritten to match the current state of the cluster.</p>
<p>A kube-proxy runs on every node of the cluster. Owing to that, on each node, there is a set of iptables rules, which forward the package to the appropriate pods. As a result, the service is accessible from each node of the cluster on its virtual cluster IP.</p>
<p>What's the implication of that from the client service perspective? The cluster infrastructure is hidden from the service client. The client doesn't need to have any knowledge about nodes, pods, and their dynamic movement inside the cluster. They just invoke the service using its IP as if it was a physical host. </p>
<p>Let's return to our example and look at the load balancing of our host. Let's return to the example in which we are working within this chapter. We statically scaled our catalog service to five instances. Let's enter the web console in order to look at all the pods on which the application currently runs:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/6969b4f4-2a1f-4af4-b46b-c496a13cd544.png" style=""/></div>
<p>Let's trace to which pods are the requests forwarded. In order to achieve that, we implemented a simple REST filter:</p>
<pre><span>package </span>org.packt.swarm.petstore.catalog<span>;<br/></span><span><br/></span><span>import </span><span>javax</span>.ws.rs.container.ContainerResponseFilter<span>;<br/></span><span>import </span><span>javax</span>.ws.rs.container.ContainerRequestContext<span>;<br/></span><span>import </span><span>javax</span>.ws.rs.container.ContainerResponseContext<span>;<br/></span><span>import </span><span>javax</span>.ws.rs.ext.<span>Provider</span><span>;<br/></span><span>import </span>java.io.IOException<span>;<br/></span><span><br/><strong>//1</strong><br/></span><span><strong>@Provider</strong><br/></span><span>public class </span>PodNameResponseFilter <span>implements </span>ContainerResponseFilter {<br/>    <span>public void </span><span>filter</span>(ContainerRequestContext req<span>, </span>ContainerResponseContext res)<br/>            <span>throws </span>IOException<br/>    {<br/>        <strong>//2</strong><br/><strong>        res.getHeaders().add("pod",System.getenv("HOSTNAME"))</strong><span><strong>;</strong><br/></span><span>    </span>}<br/>}</pre>
<p>The preceding filter adds a <kbd>"pod"</kbd> property to the response headers. The filter will be evaluated after the response is processed (1). On each pod, there is a <kbd>"HOSTNAME"</kbd> environment variable set. We can use this variable and add it to the response metadata (2).</p>
<p>As a result, we are ready to trace the load balancing:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/7eecbe42-793c-4170-890a-a21a339d2987.png" style=""/></div>
<p>In the preceding screenshot, note that the request is being automatically load balanced among the available pods.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Service discovery</h1>
                </header>
            
            <article>
                
<p>We have<span> already</span> shown you how to configure balancing for our application. We know now that you have access to the virtual cluster IP address behind which the request is being balanced by OpenShift. However, how do we actually know how to connect to our services? We are going to learn that in the next topic. Before we do that, we must introduce our new services that will be talking to each other.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">New services</h1>
                </header>
            
            <article>
                
<p>In the first chapter, we briefly introduced the pet store application and described the services that constitute it. By now, we have used solely the catalog service in our examples. Now it's time to implement both the pricing service and customer gateway service. These services will serve as an example in this and the future chapters. Let's start with the pricing service.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The pricing service</h1>
                </header>
            
            <article>
                
<p>The pricing service is very similar to catalog service. It can be used to obtain prices for a pet using their names. Let's go straight to the implementation. Initially, we have to create the database. As before, we will use the PostgreSQL template:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/5089d432-68ce-4dd0-9f27-59d4b4d38d0d.png" style=""/></div>
<p>As with the catalog service's database, we would also like to override the labels:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/9fbf091d-5253-4678-b04e-5b33860b96a3.png" style=""/></div>
<p>To populate the database, we have to create the following script:</p>
<pre>vi pets.sql</pre>
<p>Now, enter the sample data:</p>
<pre><span>DROP TABLE </span>IF <span>EXISTS </span>PRICE;                                                                                                                                                                                                        <br/>                                                                                                                                                                                                                                   <br/><span>CREATE TABLE </span>PRICE (id serial <span>PRIMARY KEY</span>, item_id <span>varchar</span>, price <span>smallint</span>);<br/>                                                                                                                                                                                                                                   <br/><span>INSERT INTO </span>PRICE(item_id, price) <span>VALUES </span>(<span>'dbf67f4d-f1c9-4fd4-96a8-65ee1a22b9ff'</span>, <span>50</span>);<br/><span>INSERT INTO </span>PRICE(item_id, price) <span>VALUES </span>(<span>'fc7ee3ea-8f82-4144-bcc8-9a71f4d871bd'</span>, <span>30</span>);<br/><span>INSERT INTO </span>PRICE(item_id, price) <span>VALUES </span>(<span>'725dfad2-0b4d-455c-9385-b46c9f356e9b'</span>, <span>15</span>);<br/><span>INSERT INTO </span>PRICE(item_id, price) <span>VALUES </span>(<span>'a2aa1ca7-add8-4aae-b361-b7f92d82c3f5'</span>, <span>3000</span>);</pre>
<p>To populate the database, we will execute the following script:</p>
<pre>psql -U pricing pricingdb &lt; pets.sql</pre>
<p>Our pricing database is ready. We can now start writing the code.</p>
<div class="packt_infobox">Examples reference: <kbd>chapter8/pricing-service</kbd>.</div>
<p>We have to configure the database in the similar way that we did for <span class="packt_screen">catalog-service</span>.</p>
<pre><span>swarm:<br/></span><span>  datasources:<br/></span><span>    data-sources:<br/></span><strong>      PricingDS:<br/>       driver-name: postgresql</strong><br/><strong>       connection-url: jdbc:postgresql://pricingdb.petstore.svc/pricingdb</strong><br/><strong>       user-name: pricing</strong><br/><strong>       password: pricing</strong><br/>    <span>jdbc-drivers:<br/></span><span>      postgresql:<br/></span><span>        driver-class-name: </span>org.postgresql.Driver<br/>        <span>xa-datasource-name: </span>org.postgresql.xa.PGXADataSource<br/>        <span>driver-module-name: </span>org.postgresql.jdbc</pre>
<p>In order for the database to work, we have to provide the JDBC driver module:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/f4d00ccd-6c6b-4a34-95be-730bda614b66.png" style=""/></div>
<p>As you can see, we also need <kbd>persistence.xml</kbd>:</p>
<pre><span>&lt;?</span><span>xml version=</span><span>"1.0" </span><span>encoding=</span><span>"UTF-8"</span><span>?&gt;<br/></span><span>&lt;persistence<br/></span><span>        </span><span>xmlns:</span><span>xsi</span><span>=</span><span>"http://www.w3.org/2001/XMLSchema-instance"<br/></span><span>        </span><span>version=</span><span>"2.1"<br/></span><span>        </span><span>xmlns=</span><span>"http://xmlns.jcp.org/xml/ns/persistence"<br/></span><span>        </span><span>xsi</span><span>:schemaLocation=</span><span>"http://xmlns.jcp.org/xml/ns/persistence http://xmlns.jcp.org/xml/ns/persistence/persistence_2_1.xsd"</span><span>&gt;<br/></span><span>    &lt;persistence-unit </span><span>name=</span><span>"PricingPU" </span><span>transaction-type=</span><span>"JTA"</span><span>&gt;<br/></span><span>        &lt;jta-data-source&gt;</span>java:jboss/datasources/PricingDS<span>&lt;/jta-data-source&gt;<br/></span><span>    &lt;/persistence-unit&gt;<br/></span><span>&lt;/persistence&gt;</span></pre>
<p>We have to provide an <kbd>Entity</kbd>:</p>
<pre><span>package </span>org.packt.swarm.petstore.pricing<span>;<br/></span><span><br/></span><span>import </span>com.fasterxml.jackson.annotation.<span>JsonIgnore</span><span>;<br/></span><span><br/></span><span>import </span>javax.persistence.<span>Column</span><span>;<br/></span><span>import </span>javax.persistence.<span>Entity</span><span>;<br/></span><span>import </span>javax.persistence.<span>GeneratedValue</span><span>;<br/></span><span>import </span>javax.persistence.GenerationType<span>;<br/></span><span>import </span>javax.persistence.<span>Id</span><span>;<br/></span><span>import </span>javax.persistence.<span>NamedQueries</span><span>;<br/></span><span>import </span>javax.persistence.<span>NamedQuery</span><span>;<br/></span><span>import </span>javax.persistence.<span>SequenceGenerator</span><span>;<br/></span><span>import </span>javax.persistence.<span>Table</span><span>;<br/></span><span><br/></span><strong>//1<br/>@Entity<br/>//2<br/>@Table(name = "Price")</strong><br/><strong>//3</strong><br/><strong>@NamedQueries({</strong><br/><strong>        @NamedQuery(name="Price.findByName",<br/>                query="SELECT p FROM Price p WHERE p.name = :name"),<br/>})</strong><br/><span>public class </span>Price {<br/><br/><strong>    //4</strong><br/><strong>    @Id<br/>    @GeneratedValue(strategy = GenerationType.SEQUENCE, generator = "price_sequence")</strong><br/><strong>    @SequenceGenerator(name = "price_sequence", sequenceName = "price_id_seq")</strong><br/><strong>    //5</strong><br/><strong>    @JsonIgnore<br/>    private int id</strong><span><strong>;</strong><br/></span><span><br/><strong>    //6</strong><br/></span><strong>    @Column(length = 30)</strong><br/><strong>    private String name;<br/>    @Column<br/>    private int price</strong><span><strong>;</strong><br/></span><span><br/></span><span>    public int </span><span>getId</span>() {<br/>        <span>return </span><span>id</span><span>;<br/></span><span>    </span>}<br/><br/>    <span>public void </span><span>setId</span>(<span>int </span>id) {<br/>        <span>this</span>.<span>id </span>= id<span>;<br/></span><span>    </span>}<br/><br/>    <span>public </span>String <span>getName</span>() {<br/>        <span>return </span><span>name</span><span>;<br/></span><span>    </span>}<br/><br/>    <span>public void </span><span>setName</span>(String name) {<br/>        <span>this</span>.<span>name </span>= name<span>;<br/></span><span>    </span>}<br/><br/><br/>    <span>public int </span><span>getPrice</span>() {<br/>        <span>return </span><span>price</span><span>;<br/></span><span>    </span>}<br/><br/>    <span>public void </span><span>setPrice</span>(<span>int </span>price) {<br/>        <span>this</span>.<span>price </span>= price<span>;<br/></span><span>    </span>}<br/>}</pre>
<p class="mce-root">In the preceding snippet, we have created a JPA entity (1), which references the <kbd>"Price"</kbd> table that we have just created (2). We have provided <kbd>NamedQueries</kbd>, which will enable us to search the price of a pet by a name (3). An <kbd>id</kbd>, as in <kbd>catalogdb</kbd>, is generated using the Postgres sequence (4) and is not parsed in the JSON response (5). Finally, we have annotated the fields mapped to the <kbd>price</kbd> and <kbd>name</kbd> columns (6).</p>
<p>As in <kbd>catalog-service</kbd>, we will need a service:</p>
<pre><span>package </span>org.packt.swarm.petstore.pricing<span>;<br/></span><span><br/></span><span>import </span>org.packt.swarm.petstore.pricing.model.Price<span>;<br/></span><span><br/></span><span>import </span>javax.enterprise.context.<span>ApplicationScoped</span><span>;<br/></span><span>import </span>javax.persistence.EntityManager<span>;<br/></span><span>import </span>javax.persistence.<span>PersistenceContext</span><span>;<br/></span><span>import </span>javax.ws.rs.WebApplicationException<span>;<br/></span><span>import </span>java.util.List<span>;<br/></span><span><br/></span><span>@ApplicationScoped<br/></span><span>public class </span><span>PricingService</span> {<br/><br/>    <span>@PersistenceContext</span>(<span>unitName </span>= <span>"PricingPU"</span>)<br/>    <span>private </span>EntityManager <span>em</span><span>;<br/></span><span><br/></span><span>    public </span>Price <span>findByItemId</span>(String itemId) {<br/>        return <span>em</span>.createNamedQuery(<span>"Price.findByItemId"</span><span>, </span>Price.<span>class</span>).setParameter(<span>"itemId"</span><span>, </span>itemId).getSingleResult();<span><br/></span><span>    </span>}<br/>}</pre>
<p>We also need REST resource:</p>
<pre>package org.packt.swarm.petstore.pricing;<br/><br/>import org.packt.swarm.petstore.pricing.model.Price;<br/><br/>import javax.inject.Inject;<br/>import javax.ws.rs.GET;<br/>import javax.ws.rs.Path;<br/>import javax.ws.rs.PathParam;<br/>import javax.ws.rs.Produces;<br/>import javax.ws.rs.core.Context;<br/>import javax.ws.rs.core.MediaType;<br/>import javax.ws.rs.core.Response;<br/>import javax.ws.rs.core.SecurityContext;<br/><br/>@Path("/")<br/>public class PricingResource {<br/><br/>    @Inject<br/>    private PricingService pricingService;<br/><br/>    @GET<br/>    @Path("price/{item_id}")<br/>    @Produces(MediaType.APPLICATION_JSON)<br/>    public Response priceByName(@PathParam("item_id") String itemId) {<br/>        Price result = pricingService.findByItemId(itemId);<br/>        return Response.ok(result).build();<br/>}</pre>
<p>We would also need an application:</p>
<pre><span>package </span>org.packt.swarm.petstore.pricing<span>;<br/></span><span><br/></span><span>import </span>javax.ws.rs.<span>ApplicationPath</span><span>;<br/></span><span>import </span>javax.ws.rs.core.Application<span>;<br/></span><span><br/></span><span>@ApplicationPath</span>(<span>"/"</span>)<br/><span>public class </span>PricingApplication <span>extends </span>Application {<br/>}</pre>
<p>Our second service is ready. It's time to deploy it on OpenShift. Push your application to your GitHub repository and invoke:</p>
<pre><span>oc new-app wildflyswarm-10-centos7~https://github.com/PacktPublishing/Hands-On-Cloud-Development-with-WildFly.git --context-dir=chapter8/pricing-service --name=pricing-service<br/></span></pre>
<p>After your application is deployed, you can create a route to it and verify that it indeed works:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/0fb5813b-9d84-4ff6-a8f6-e5bceb63a29c.png" style=""/></div>
<div class="CDPAlignCenter CDPAlign"/>
<p>It indeed does. Let's move to the second service.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The customer gateway service</h1>
                </header>
            
            <article>
                
<p>In this section, the stuff becomes more interesting again. The <span><span>customer-gateway </span></span>service is a gateway to our application, which would provide the external interface for the web client. The first request that we will implement is obtaining the list of pets. Let's take a look at the following diagram:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/d07150cb-66ec-4f06-b830-675259ac11e7.png" style=""/></div>
<p>When the <kbd>/catalog/item</kbd> request is being executed, the service asks <strong>CATALOG</strong> for available items. Based on that information, the pet store service asks the <strong>PRICE</strong> service about the price of each pet, merges the results, and then returns them to the client. However, how will the gateway service know the addresses of the services? We will find that out soon.</p>
<div class="packt_infobox">Examples reference: <kbd>chapter8/customer-gateway-env</kbd>.</div>
<p>The customer service is configured in a similar way to previous services. If you have doubts regarding some parts of configuration please refer to the description of those. </p>
<p>Let's look at the implementation details of <kbd>catalog/item</kbd> request starting with the REST resource:</p>
<pre><span>package </span>org.packt.swarm.petstore<span>;<br/></span><span><br/></span><span>import </span>org.packt.swarm.petstore.api.CatalogItemView<span>;<br/></span><span><br/></span><span>import </span>javax.inject.<span>Inject</span><span>;<br/></span><span>import </span>javax.ws.<span>rs</span>.<span>GET</span><span>;<br/></span><span>import </span>javax.ws.<span>rs</span>.<span>Path</span><span>;<br/></span><span>import </span>javax.ws.<span>rs</span>.<span>Produces</span><span>;<br/></span><span>import </span>javax.ws.<span>rs</span>.core.MediaType<span>;<br/></span><span>import </span>javax.ws.<span>rs</span>.core.Response<span>;<br/></span><span>import </span>java.util.List<span>;<br/></span><span><br/></span><span>@Path</span>(<span>"/"</span>)<br/><span>public class </span>GatewayResource {<br/><br/>    <span>@Inject<br/></span><span>    </span><span>private </span>GatewayService <span>gatewayService</span><span>;<br/></span><span><br/><strong>    //1</strong><br/></span><strong>    @GET<br/>    @Path("/catalog/item")</strong><br/><strong>    @Produces(MediaType.APPLICATION_JSON)</strong><br/><strong>    public Response getItems() {<br/>        //2</strong><br/><strong>        List&lt;CatalogItemView&gt; result = gatewayService.getItems();<br/>        return Response.ok(result).build();<br/>    }</strong></pre>
<p>The <kbd>getItems</kbd> method gathers the items from the <kbd>CatalogService</kbd> (1), obtains a price for all of them, and merges the obtained results into the list of pets available in the store. Please note that we have introduced <kbd>CatalogItemView</kbd>—a transport object which is a part of the API for the web client.</p>
<p>We have also implemented the service:</p>
<pre><span>package </span>org.packt.swarm.petstore<span>;<br/></span><span><br/></span><span>import </span>org.packt.swarm.petstore.api.CatalogItemView<span>;<br/></span><span>import </span>org.packt.swarm.petstore.catalog.api.CatalogItem<span>;<br/></span><span>import </span>org.packt.swarm.petstore.pricing.api.Price<span>;<br/></span><span>import </span>org.packt.swarm.petstore.proxy.CatalogProxy<span>;<br/></span><span>import </span>org.packt.swarm.petstore.proxy.PricingProxy<span>;<br/></span><span><br/></span><span>import </span>javax.enterprise.context.<span>ApplicationScoped</span><span>;<br/></span><span>import </span>javax.inject.<span>Inject</span><span>;<br/></span><span>import </span>java.util.ArrayList<span>;<br/></span><span>import </span>java.util.List<span>;<br/></span><span><br/></span><span>@ApplicationScoped<br/></span><span>public class </span>GatewayService {<br/><br/><strong>    //2</strong><br/><strong>    @Inject<br/>    private CatalogProxy catalogProxy;<br/><br/>    @Inject<br/>    private PricingProxy pricingProxy</strong><span><strong>;</strong><br/></span><span><br/></span><span><br/></span><span><br/><strong>    //1</strong><br/></span><strong>    public List&lt;CatalogItemView&gt; getItems() {</strong><br/><strong>        List&lt;CatalogItemView&gt; views = new ArrayList&lt;&gt;();<br/>        for(CatalogItem item: catalogProxy.getAllItems()) {</strong><br/><strong>            Price price = pricingProxy.getPrice(item.getItemId());<br/><br/>            CatalogItemView view = new CatalogItemView();<br/>            view.setItemId(item.getItemId());<br/>            view.setName(item.getName());<br/>            view.setPrice(price.getPrice());<br/>            view.setQuantity(item.getQuantity());<br/>            view.setDescription(item.getDescription());<br/><br/></strong></pre>
<pre><strong>            views.add(view);<br/>        }</strong><br/><strong>        return views;<br/>    }</strong><br/><br/>}</pre>
<p><span>The getItems method implementation (1) is pretty straightforward. We are combining data from catalog and pricing services and returning the list of resulting object. The most interesting part here is the proxies which enable us to communicate with those services (2). Let's learn how to implement them.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Environment variables</h1>
                </header>
            
            <article>
                
<p class="mce-root">When the new service is created, its coordinates are written into environment variables in every pod in the cluster. </p>
<p>Let's log in to one of the pods inside the cluster and take a look at it. All the OpenShift environment variable names are written in uppercase, and we need the data about the pricing service:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/3bfc0bb5-3f2a-4b60-9285-181178c10b32.png" style=""/></div>
<p>In the preceding screenshot, note that there are a number of variables describing the coordinates of the service. The property that interests us is the host address:</p>
<pre><span>PRICING_SERVICE_SERVICE_HOST=172.30.104.212</span></pre>
<p>Note that this is the virtual cluster IP again. As a result, as long as the service is not removed, the proxy address will stay the same. Underlying infrastructure changes caused by deployments, node addition, or failures will not result in the change of the previous address.</p>
<p>Let's write proxies that will use this variable in order to connect to the services. We will start with the pricing-service proxy:</p>
<pre><span>package </span>org.packt.swarm.petstore.proxy<span>;<br/></span><span><br/></span><span>import</span><span> </span>org.packt.swarm.petstore.pricing.api.Price<span>;<br/></span><span><br/></span><span>import </span>javax.enterprise.context.<span>ApplicationScoped</span><span>;<br/></span><span>import </span>javax.ws.rs.client.Client<span>;<br/></span><span>import </span>javax.ws.rs.client.ClientBuilder<span>;<br/></span><span>import </span>javax.ws.rs.client.WebTarget<span>;<br/></span><span>import </span>javax.ws.rs.core.MediaType<span>;<br/></span><span><br/></span><span>@ApplicationScoped<br/></span><span>public class </span>PricingProxy {<br/><br/>    <span>private </span>String <span>targetPath</span><span>;<br/></span><span><br/></span><span>    </span><span>PricingProxy</span>(){<br/><strong>        //1<br/>        targetPath = "http://" + System.getenv("PRICING_SERVICE_SERVICE_HOST")+":"+8080</strong><span><strong>;</strong><br/></span><span>    </span>}<br/><br/>    <span>public </span><span>Price</span> <span>getPrice</span>(String name){<br/><strong>        //2<br/>        Client client = ClientBuilder.newClient();<br/>        WebTarget target = client.target(targetPath +"/price/" + name);<br/>        return target.request(MediaType.APPLICATION_JSON).get(Price.class)</strong><span><strong>;</strong><br/></span><span>    </span>}<br/>}</pre>
<p>That's just it. We obtained the <kbd>clusterIP</kbd> of the pricing-service when the proxy was being created (1) and the user straightforward REST Client API to provide an adapter for the <kbd>getPrice</kbd> method invocation (2).</p>
<p>The implementation of <kbd>catalogProxy</kbd> is analogous.</p>
<p>Now we are ready to check whether our application is working. Let's create a route for the <kbd>petstore</kbd> service and check the web browser:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/af7f0316-1188-46d8-be09-6b7b70d36885.png" style=""/></div>
<p class="mce-root">It works indeed. This solution has a major disadvantage though—an ordering problem. If the pod is created before the service, then service coordinates won't be present in the pod environment. Is there a better way to discover the services, then? Yes, through <strong>Domain Name Service</strong> (<strong>DNS</strong>).</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">DNS discovery</h1>
                </header>
            
            <article>
                
<p class="mce-root">Each OpenShift cluster contains a DNS service. This service allows you to discover services easily using the service name. Each service registers to the DNS service during the registration, and later periodically sends live messages to it. The DNS server creates a record using the following pattern:</p>
<pre class="mce-root">${service name}.${application name}.svc</pre>
<p class="mce-root">Let's take the pricing service as an example. We have created the <kbd>petstore</kbd> application. As a result, the name of the service created using the preceding pattern would be pricing-<kbd>service.petstore.svc</kbd>.</p>
<p>We can confirm that information inside web console. Let's navigate to <span class="packt_screen">Applications </span>| <span class="packt_screen">Services </span>| <span class="packt_screen">pricing-service</span>:</p>
<div class="mce-root CDPAlignCenter CDPAlign"><img src="assets/8155956d-79f5-4a9d-a357-d143e73638e0.png" style=""/></div>
<p>Take note of the <kbd>hostname</kbd> field—this is the address that we created previously. Another important thing to note is that those service names are visible only from inside the cluster.</p>
<p>We are now ready to refactor our application to use elegant DNS discovery.</p>
<div class="packt_infobox">Examples reference: <kbd>chapter8/customer-gateway-dns</kbd>.</div>
<p>We have to rewrite both our proxies. Let's start with <kbd>PricingProxy</kbd>:</p>
<pre><span>package </span>org.packt.swarm.petstore.proxy<span>;<br/></span><span><br/></span><span>import </span>org.packt.swarm.petstore.pricing.api.Price<span>;<br/></span><span><br/></span><span>import </span>javax.enterprise.context.<span>ApplicationScoped</span><span>;<br/></span><span>import </span>javax.ws.rs.client.Client<span>;<br/></span><span>import </span>javax.ws.rs.client.ClientBuilder<span>;<br/></span><span>import </span>javax.ws.rs.client.WebTarget<span>;<br/></span><span>import </span>javax.ws.rs.core.MediaType<span>;<br/></span><span><br/></span><span>@ApplicationScoped<br/></span><span>public class </span>PricingProxy {<br/><br/><strong>    //1</strong><br/>    <strong>private final String targetPath = System.getProperty("proxy.pricing.url");</strong><span><br/></span><span><br/></span><span>    public </span>Price <span>getPrice</span>(String itemId){<br/>        Client client = ClientBuilder.<span>newClient</span>()<span>;<br/></span><span>        </span>WebTarget target = client.target(<span>targetPath </span>+ <span>"/price/" </span>+ itemId)<span>;<br/></span><span>        return </span>target.request(MediaType.<span>APPLICATION_JSON</span>).get(Price.<span>class</span>)<span>;<br/></span><span>    </span>}<br/>}<br/><br/></pre>
<p class="mce-root">We defined a <kbd>targetPath</kbd> that we can use repeatedly to connect to services (1). We are going to provide it as a parameter using YAML configuration:</p>
<pre><span>proxy:<br/></span><span>  catalog:<br/></span><span>    url: </span><span>"http://catalog-service.petstore.svc:8080"<br/></span><span>  </span><span>pricing:<br/></span><span>    url: </span><span>"http://pricing-service.petstore.svc:8080"</span></pre>
<p> </p>
<p class="mce-root"/>
<p class="mce-root">Again, <kbd>CatalogProxy</kbd> implementation is analogous.</p>
<p>Now we are ready to redeploy the <span><span>customer-gateway </span></span>service again. You can <span>once again</span> check whether it works correctly. </p>
<p>As you may recall, we were using the name of the service when we were creating the environment file for our databases. Each service in the cluster can be reached using this method.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>In this chapter, you learned how to scale and discover services inside the cluster. As you were able to see throughout this chapter, most of the work was done by OpenShift. Load balancing is implemented automatically by the services, and the integrated DNS service allows for straightforward service discovery.</p>
<p>In the next chapter, you will learn more about networking. You will also learn how to provide resiliency to a service invocation so that underlying network failures won't cause your application to stop working.</p>
<p class="mce-root"/>


            </article>

            
        </section>
    </body></html>