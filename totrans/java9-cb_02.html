<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Fast Track to OOP - Classes and Interfaces</h1>
                </header>
            
            <article>
                
<p>In this chapter, we will cover the following recipes:</p>
<ul>
<li>Implementing object-oriented design using classes</li>
<li>Using inner classes</li>
<li>Using inheritance and composition to make the design extensible</li>
<li>Coding to an interface</li>
<li>Creating interfaces with default and static methods</li>
<li>Creating interfaces with private methods</li>
<li>Using enums to represent constant entities</li>
<li>Using the @Deprecated annotation to deprecate APIs</li>
<li>Using HTML5 in Javadocs</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Introduction</h1>
                </header>
            
            <article>
                
<p>This chapter gives you a quick introduction to the components of OOP and covers the new enhancements in these components in Java 8 and Java 9. We will also try to cover a few good <strong>object-oriented design</strong> (<strong>OOD</strong>) practices wherever applicable.</p>
<p>Throughout the recipes, we will use the new (introduced in Java 8 and Java 9) enhancements, define and demonstrate the concepts of OOD using specific code examples, and present new capabilities for better code documentation.</p>
<p>One can spend many hours reading articles and practical advice on OOD in books and on the Internet. Some of this activity can be beneficial for some people. But, in our experience, the fastest way to get hold of OOD is to try its principles early in your own code. This is exactly the goal of this chapter: to give you a chance to see and use the OOD principles so that the formal definition makes sense immediately.</p>
<p>One of the main criteria of well-written code is its clarity of expressing its intent. A well-motivated and clear design helps achieve this. The code is run by a computer, but it is maintained and extended by humans. Keeping this in mind will assure longevity of the code written by you and perhaps even a few thanks and mentions with appreciation. </p>
<p>In this chapter, you will learn how to use the five basic OOD concepts:</p>
<ul>
<li>Object/Class - Keeping data and procedures together</li>
<li>Encapsulation - Hiding data and/or procedures</li>
<li>Inheritance - Extending another class data and/or procedures</li>
<li>Interface - Deferring the implementation and coding for a type</li>
<li>Polymorphism - Using the base class type for all its extensions when a parent class reference is used to refer to a child class object</li>
</ul>
<p>These concepts will be defined and demonstrated in the code snippets presented in this chapter. If you search the Internet, you may notice that many other concepts and additions to them can be derived from the five points we just discussed.</p>
<p>Although the following text does not require prior knowledge of OOD, some experience of writing code in Java would be beneficial. The code samples are fully functional and compatible with Java 9. For better understanding, we recommend that you try to run the presented examples.</p>
<p>We also encourage you to adapt the tips and recommendations in this chapter to your needs in the context of your team experience. Consider sharing your new-found knowledge with your colleagues and discuss how the described principles can be applied to your domain, for your current project.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Implementing object-oriented design using classes</h1>
                </header>
            
            <article>
                
<p>In this recipe, you will learn about the first two OOD concepts: object/class and encapsulation.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p>The term <em>object</em> usually refers to the coupling of data and procedures that can be applied to these data. Neither data, nor procedures are required, but one of them is--and, typically, both are--always present. The data are called object properties, while procedures are called methods. Properties capture the state of the object. Methods describe objects' behavior. Every object has a type, which is defined by its class (see the following). An object also is said to be an instance of a class.</p>
<div class="packt_infobox">The term <em>class</em> is a collection of the definitions of properties and methods that will be present in each of its instances--the objects created based on this class.<br/>
Encapsulation is the hiding of object properties and methods that should not be accessible by other objects.</div>
<p>Encapsulation is achieved by the Java keywords <kbd>private</kbd> or <kbd>protected</kbd> in the declaration of properties and methods.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<ol>
<li>Create an <kbd>Engine</kbd> class with the <kbd>horsePower</kbd> property, the <kbd>setHorsePower()</kbd> method that sets this property's value, and the <kbd>getSpeedMph()</kbd> method that calculates the speed of a vehicle, based on the time since the vehicle started moving, the vehicle weight, and the engine power:</li>
</ol>
<pre>        public class Engine { <br/>          private int horsePower; <br/>          public void setHorsePower(int horsePower) { <br/>            this.horsePower = horsePower; <br/>          } <br/>          public double getSpeedMph(double timeSec, <br/>                                    int weightPounds) { <br/>            double v = 2.0*this.horsePower*746; <br/>            v = v*timeSec*32.17/weightPounds; <br/>            return Math.round(Math.sqrt(v)*0.68); <br/>          } <br/>        }</pre>
<ol start="2">
<li>Create the <kbd>Vehicle</kbd> class: </li>
</ol>
<pre>        public class Vehicle { <br/>          private int weightPounds; <br/>          private Engine engine; <br/>          public Vehicle(int weightPounds, Engine engine) { <br/>            this.weightPounds = weightPounds; <br/>            this.engine = engine; <br/>          } <br/>          public double getSpeedMph(double timeSec){ <br/>            return this.engine.getSpeedMph(timeSec, weightPounds); <br/>         } <br/>       } </pre>
<ol start="3">
<li>Create the application that will use these classes:</li>
</ol>
<pre>        public static void main(String... arg) { <br/>          double timeSec = 10.0; <br/>          int horsePower = 246; <br/>          int vehicleWeight = 4000;  <br/>          Engine engine = new Engine(); <br/>          engine.setHorsePower(horsePower); <br/>          Vehicle vehicle = new Vehicle(vehicleWeight, engine); <br/>          System.out.println("Vehicle speed (" + timeSec + " sec)=" +<br/>                             vehicle.getSpeedMph(timeSec) + " mph"); <br/>        } </pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>The preceding application produces the following output:</p>
<div class="CDPAlignCenter CDPAlign"><img height="32" width="350" class="image-border" src="assets/588c3c06-9cce-4b44-b151-ef935580b1ff.png"/></div>
<p>As you can see, an <kbd>engine</kbd> object was created by invoking the default constructor of the <kbd>Engine</kbd> class without parameters and with the Java keyword <kbd>new</kbd> that allocated memory for the newly created object on the heap.</p>
<p>The second object, namely <kbd>vehicle</kbd>, was created with the explicitly defined constructor of the <kbd>Vehicle</kbd> class with two parameters. The second parameter of the constructor is an <kbd>engine</kbd> object that carries the <kbd>horsePower</kbd> property with the value set as <kbd>246</kbd>, using the <kbd>setHorsePower()</kbd> method.</p>
<p>It also contains the <kbd>getSpeedMph()</kbd> method that can be called by any other object that has access to the <kbd>engine</kbd> object, as it is done in the <kbd>getSpeedMph()</kbd> method of the <kbd>Vehicle</kbd> class.</p>
<p>It's worth noticing that the <kbd>getSpeedMph()</kbd> method of the <kbd>Vehicle</kbd> class relies on the presence of a value assigned to the <kbd>engine</kbd> property. The object of the <kbd>Vehicle</kbd> class delegates the speed calculation to the object of the <kbd>Engine</kbd> class. If the latter is not set (<kbd>null</kbd> passed in the <kbd>Vehicle()</kbd> constructor, for example), we will get <kbd>NullPointerException</kbd> at runtime. To avoid this, we can place a check for the presence of this value in the <kbd>Vehicle()</kbd> constructor:</p>
<pre>if(engine == null){ <br/>   throw new RuntimeException("Engine" + " is required parameter."); <br/>}   </pre>
<p>Alternatively, we can place a check in the <kbd>getSpeedMph()</kbd> method of the <kbd>Vehicle</kbd> class: </p>
<pre>if(getEngine() == null){ <br/>  throw new RuntimeException("Engine value is required."); <br/>} </pre>
<p>This way, we avoid the ambiguity of <kbd>NullPointerException</kbd> and tell the user exactly what the source of the problem was.</p>
<p>As you may have noticed, the <kbd>getSpeedMph()</kbd> method can be removed from the <kbd>Engine</kbd> class and fully implemented in the <kbd>Vehicle</kbd>: class: </p>
<pre>public double getSpeedMph(double timeSec){<br/>  double v = 2.0 * this.engine.getHorsePower() * 746;<br/>  v = v * timeSec * 32.174 / this.weightPounds;<br/>  return Math.round(Math.sqrt(v) * 0.68);<br/>}</pre>
<p>To do this, we would need to add the public method <kbd>getHorsePower()</kbd> to the <kbd>Engine</kbd> class in order to make it available for usage by the <kbd>getSpeedMph()</kbd> method in the <kbd>Vehicle</kbd> class. For now, we leave the <kbd>getSpeedMph()</kbd> method in the <kbd>Engine</kbd>. class. </p>
<p>This is one of the design decisions you need to make. If you think that an object of the <kbd>Engine</kbd> class is going to be passed around to the objects of different classes (not only <kbd>Vehicle</kbd>), then you would need to keep the <kbd>getSpeedMph()</kbd> method in the <kbd>Engine</kbd> class. Otherwise, if you think that the <kbd>Vehicle</kbd> class is going to be responsible for the speed calculation (which makes sense, since it is the speed of a vehicle, not of an engine), then you should implement the method inside the <kbd>Vehicle</kbd> class.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">There's more...</h1>
                </header>
            
            <article>
                
<p>Java provides a capability to extend a class and allow the subclass to access all of the functionality of the base class. For example, you can decide that every object that could be asked about its speed belongs to a subclass that is derived from the <kbd>Vehicle</kbd> class. In such a case, <kbd>Car</kbd> may look like this:</p>
<pre>public class Car extends Vehicle {<br/>  private int passengersCount;<br/>  public Car(int passengersCount, int weightPounds, <br/>             Engine engine){<br/>    super(weightPounds, engine);<br/>    this.passengersCount = passengersCount;<br/>  }<br/>  public int getPassengersCount() {<br/>    return this.passengersCount;<br/>  }<br/>}</pre>
<p>Now we can change our test code by replacing the <kbd>Vehicle</kbd> class with the <kbd>Car</kbd> class:</p>
<pre>public static void main(String... arg) { <br/>  double timeSec = 10.0; <br/>  int horsePower = 246; <br/>  int vehicleWeight = 4000; <br/>  Engine engine = new Engine(); <br/>  engine.setHorsePower(horsePower); <br/>  Vehicle vehicle = new Car(4, vehicleWeight, engine); <br/>  System.out.println("Car speed (" + timeSec + " sec) = " + <br/>                     vehicle.getSpeedMph(timeSec) + " mph"); <br/>} </pre>
<p>When run, it produces the same value as with an object of the <kbd>Vehicle</kbd> class: </p>
<div class="CDPAlignCenter CDPAlign"><img height="32" width="343" class="image-border" src="assets/9d1e55c8-80ef-4773-9d71-a2a59cca2ec7.png"/></div>
<p>Because of polymorphism, a reference to the object of the <kbd>Car</kbd> class can be assigned to the reference of the base class, that is, <kbd>Vehicle</kbd>. The object of the <kbd>Car</kbd> class has two types: its own type, that is, <kbd>Car</kbd> and the type of the base class, namely <kbd>Vehicle</kbd>.</p>
<p>In Java, a class can also implement multiple interfaces, and the object of such a class would have a type of each of the implemented interfaces too. We will talk about this in subsequent recipes.</p>
<p>There are usually several ways to design an application for the same functionality. It all depends on the needs of your project and the style adopted by the development team. But in any context, clarity of design will help you communicate the intent. Good design contributes to the quality and longevity of the code.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">See also</h1>
                </header>
            
            <article>
                
<p>Refer to the following recipe in this chapter:</p>
<ul>
<li>Using inheritance and composition to make the design extensible</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Using inner classes</h1>
                </header>
            
            <article>
                
<p>In this recipe, you will learn about three types of inner classes:</p>
<ul>
<li><strong>Inner class</strong>: This is a class defined inside another (enclosing) class. Its accessibility from outside the enclosing class is regulated by the <kbd>public</kbd>, <kbd>protected</kbd>, and <kbd>private</kbd> keywords. It can access the private members of the enclosing class, and the enclosing class can access the private members of its inner class.</li>
<li><strong>Method-local inner class</strong>: This is a class defined inside a method. Its scope is restricted to within the method.</li>
<li><strong>Anonymous inner class</strong>: This is an anonymous class defined during object instantiation.</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p>When a class is used by one, and only one, other class, the designer might decide that there is no need to make such a class public. For example, let's assume that the Engine class is used by the <kbd>Vehicle</kbd> class only.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<ol>
<li>Create the <kbd>Engine</kbd> class as an inner class of the <kbd>Vehicle</kbd> class:</li>
</ol>
<pre>        public class Vehicle {<br/>          private int weightPounds;<br/>          private Engine engine;<br/>          public Vehicle(int weightPounds, int horsePower) {<br/>            this.weightPounds = weightPounds;<br/>            this.engine = new Engine(horsePower);<br/>          }<br/>          public double getSpeedMph(double timeSec){<br/>            return this.engine.getSpeedMph(timeSec);<br/>          }<br/>          private int getWeightPounds(){ return weightPounds; }<br/>          private class Engine {<br/>            private int horsePower;<br/>            private Engine(int horsePower) {<br/>              this.horsePower = horsePower;<br/>            }<br/>            private double getSpeedMph(double timeSec){<br/>              double v = 2.0 * this.horsePower * 746;<br/>              v = v * timeSec * 32.174 / getWeightPounds();<br/>              return Math.round(Math.sqrt(v) * 0.68);<br/>            }<br/>          }<br/>        }</pre>
<ol start="2">
<li>Notice that the <kbd>getSpeedMph()</kbd> method of the <kbd>Vehicle</kbd> class has access to the <kbd>Engine</kbd> class (although it is declared <kbd>private</kbd>) and even to the private <kbd>getSpeedMph()</kbd> method of the <kbd>Engine</kbd> class. The inner class has access to all the private elements of the enclosing class too. This is why <kbd>getSpeedMph()</kbd> of the <kbd>Engine</kbd> class has access to the private <kbd>getWeightPounds()</kbd> method of the enclosing <kbd>Vehicle</kbd> class. </li>
<li>Look closer at the usage of the inner class <kbd>Engine</kbd>. Only the <kbd>getSpeedMph()</kbd> method uses it. If the designer believes that it is going to be the case in future too, it would be reasonable to make it method-local inner class, which is the second type of an inner class:</li>
</ol>
<pre>        public class Vehicle {<br/>          private int weightPounds;<br/>          private int horsePower;<br/>          public Vehicle(int weightPounds, int horsePower) {<br/>            this.weightPounds = weightPounds;<br/>            this.horsePower = horsePower;<br/>          }<br/>          private int getWeightPounds() { return weightPounds; }<br/>          public double getSpeedMph(double timeSec){<br/>            class Engine {<br/>              private int horsePower;<br/>              private Engine(int horsePower) {<br/>                this.horsePower = horsePower;<br/>              }<br/>              private double getSpeedMph(double timeSec){<br/>                double v = 2.0 * this.horsePower * 746;<br/>                v = v * timeSec * 32.174 / getWeightPounds();<br/>                return Math.round(Math.sqrt(v) * 0.68);<br/>              }<br/>            }<br/>            Engine engine = new Engine(this.horsePower);<br/>            return engine.getSpeedMph(timeSec);<br/>          }<br/>        }</pre>
<p>Encapsulation--hiding the state and behavior of objects--helps avoid unexpected side effects resulting from an accidental change or overriding. It makes the behavior more predictable and easier to understand. That's why a good design exposes only the functionality that must be accessible from the outside. Typically, this is the main functionality that motivated the class creation in the first place.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>Whether the <kbd>Engine</kbd> class is implemented as an inner class or a method-local inner class, the test code looks the same:</p>
<pre>public static void main(String arg[]) {<br/>  double timeSec = 10.0;<br/>  int engineHorsePower = 246;<br/>  int vehicleWeightPounds = 4000;<br/>  Vehicle vehicle = new Vehicle(vehicleWeightPounds, engineHorsePower);<br/>  System.out.println("Vehicle speed (" + timeSec + " sec) = " + <br/>                     vehicle.getSpeedMph(timeSec) + " mph");<br/>}</pre>
<p>If we run this program, we get the same output:</p>
<div class="CDPAlignCenter CDPAlign"><img height="32" width="330" class="image-border" src="assets/4ce136e8-9e00-42a0-b323-1a0a023d2cfa.png"/></div>
<p>Now, let's assume we need to test different implementations of the <kbd>getSpeedMph()</kbd> method:</p>
<pre>public double getSpeedMph(double timeSec){ return -1.0d; }</pre>
<p>If this speed calculation formula does not make sense to you, you are correct. It does not. We did it for making the result predictable and different from the result of the previous implementation.</p>
<p>There are many ways to introduce this new implementation. We can change the implementation of the <kbd>getSpeedMph()</kbd> method in the <kbd>Engine</kbd> class, for example. Or, we can change the implementation of the same method in the <kbd>Vehicle</kbd> class. </p>
<p>In this recipe, we will do this using the third type of inner class called anonymous inner class. This approach is especially handy when you want to write as little new code as possible or you want to quickly test the new behavior by temporarily overriding the old one. The code would then look like this:</p>
<pre>public static void main(String... arg) {<br/>  double timeSec = 10.0;<br/>  int engineHorsePower = 246;<br/>  int vehicleWeightPounds = 4000;<br/>  Vehicle vehicle = new Vehicle(vehicleWeightPounds, engineHorsePower) {<br/>    public double getSpeedMph(double timeSec){ <br/>      return -1.0d;<br/>    }<br/>  };<br/>  System.out.println("Vehicle speed (" + timeSec + " sec) = " + <br/>                     vehicle.getSpeedMph(timeSec) + " mph");<br/>}</pre>
<p>If we run this program, the result would be as follows:</p>
<div class="CDPAlignCenter CDPAlign"><img height="38" width="368" class="image-border" src="assets/9b37c5de-af1d-4660-bc11-44725cd18112.png"/></div>
<p>We have overridden the <kbd>Vehicle</kbd> class implementation by leaving only one method in it--the <kbd>getSpeedMph()</kbd> method that returns hardcoded value. We could override other methods or add new ones, but we will keep it simple for demonstration purposes. </p>
<p>By definition, anonymous inner class has to be an expression that is part of a statement that ends (as any statement) with a semicolon. The expression is composed of the following:</p>
<ul>
<li>The <kbd>new</kbd> operator</li>
<li>The name of the implemented interface (followed by parentheses <kbd>()</kbd> that represent the default constructor) or a constructor of the extended class (the latter is our case, the extended class being <kbd>Vehicle</kbd>)</li>
<li>The class body with method declarations (statements are not allowed in the body of an anonymous inner class)</li>
</ul>
<p>Like any inner classes, anonymous inner class can access any member of the enclosing class and can capture the values of its variables. To be able to do this, these variables have to be declared <kbd>final</kbd>. Otherwise, they become <kbd>final</kbd> implicitly, which means their values cannot be changed (a good modern IDE will warn you about the violation of this constraint if you try to change such a value).</p>
<p>Using these features, we can modify our sample code and provide more input data for the newly implemented <kbd>getSpeedMph()</kbd> method without passing them as method parameters:</p>
<pre>public static void main(String... arg) {<br/>  double <strong>timeSec</strong> = 10.0;<br/>  int <strong>engineHorsePower</strong> = 246;<br/>  int <strong>vehicleWeightPounds</strong> = 4000;<br/>  Vehicle vehicle = new Vehicle(vehicleWeightPounds, engineHorsePower){<br/>    public double getSpeedMph(double timeSec){<br/>      double v = 2.0 * engineHorsePower * 746;<br/>      v = v * timeSec * 32.174 / vehicleWeightPounds;<br/>      return Math.round(Math.sqrt(v) * 0.68);<br/>    }<br/>  };<br/>  System.out.println("Vehicle speed (" + timeSec + " sec) = " + <br/>                     vehicle.getSpeedMph(timeSec) + " mph");<br/>}</pre>
<p>Notice that the variables <kbd>timeSec</kbd>, <kbd>engineHorsePower</kbd>, and <kbd>vehicleWeightPounds</kbd> are accessible by the <kbd>getSpeedMph()</kbd> method of the inner class and cannot be modified. If we run this code, the result will be the same as before:</p>
<div class="CDPAlignCenter CDPAlign"><img height="34" width="324" class="image-border" src="assets/6c68560b-cb9e-404e-891c-7c6936a8fef9.png"/></div>
<p>In the case of an interface with only one abstract method (called functional interface), a particular type of anonymous inner class, called <strong>lambda expression</strong>, it allows you to have a shorter notation but provides the interface implementation. We are going to discuss functional interface and lambda expression in the next chapter.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">There's more...</h1>
                </header>
            
            <article>
                
<p>An inner class is a non-static nested class. Java also allows you to create a static nested class that can be used when an inner class does not require access to non-public properties and methods of the enclosing class. Here is an example (the keyword <kbd>static</kbd> is added to the <kbd>Engine</kbd> class):</p>
<pre>public class Vehicle {<br/>  private Engine engine;<br/>  public Vehicle(int weightPounds, int horsePower) {<br/>    this.engine = new Engine(horsePower, weightPounds);<br/>  }<br/>  public double getSpeedMph(double timeSec){<br/>    return this.engine.getSpeedMph(timeSec);<br/>  }<br/>  private <strong>static</strong> class Engine {<br/>    private int horsePower;<br/>    private int weightPounds;<br/>    private Engine(int horsePower, int weightPounds) {<br/>      this.horsePower = horsePower;<br/>    }<br/>    private double getSpeedMph(double timeSec){<br/>      double v = 2.0 * this.horsePower * 746;<br/>      v = v * timeSec * 32.174 / this.weightPounds;<br/>      return Math.round(Math.sqrt(v) * 0.68);<br/>    }<br/>  }<br/>}</pre>
<p>Because a static class couldn't access a non-static member (the <kbd>getWeightPounds()</kbd> method of the enclosing class <kbd>Vehicle</kbd>), we were forced to pass the weight value to the <kbd>Engine</kbd> class during its construction (and we removed the <kbd>getWeightPounds()</kbd> method as it was not needed anymore).</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">See also</h1>
                </header>
            
            <article>
                
<p>Refer to the following recipe in this chapter:</p>
<ul>
<li>Going functional</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Using inheritance and composition to make the design extensible</h1>
                </header>
            
            <article>
                
<p>In this recipe, you will learn about two important OOD concepts, namely Inheritance and Polymorphism, which have been mentioned already and used in the examples of the previous recipes.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p>Inheritance is the ability of one class to extend (and, optionally, override) the properties and/or methods of another class. The extended class is called the base class, superclass, or parent class. The new extension of the class is called a subclass or child class.</p>
<div class="packt_infobox">Polymorphism is the ability to use the base class as a type for the references to the objects of its subclasses.</div>
<p>To demonstrate the power of these two concepts, let's create classes that represent cars and trucks, each having weight, engine power, and speed it can reach (as a function of time) with maximum load. In addition, a car, in this case, will be characterized by the number of passengers, while a truck's important feature will be its payload.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<ol>
<li>Look at the <kbd>Vehicle</kbd> class: </li>
</ol>
<pre>        public class Vehicle {<br/>          private int weightPounds, horsePower;<br/>          public Vehicle(int weightPounds, int horsePower) {<br/>            this.weightPounds = weightPounds;<br/>            this.horsePower = horsePower;<br/>          }<br/>          public double getSpeedMph(double timeSec){<br/>            double v = 2.0 * this.horsePower * 746;<br/>            v = v * timeSec * 32.174 / this.weightPounds;<br/>            return Math.round(Math.sqrt(v) * 0.68);<br/>          }<br/>        }</pre>
<p style="padding-left: 60px">There is an obvious commonality between a car and a truck that can be encapsulated in the <kbd>Vehicle</kbd> class as the base class.</p>
<ol start="2">
<li>Create a subclass, called <kbd>Car</kbd>:</li>
</ol>
<pre>        public class Car extends Vehicle {<br/>          private int passengersCount;<br/>          public Car(int passengersCount, int weightPounds, <br/>                     int horsepower){<br/>            super(weightPounds, horsePower);<br/>            this.passengersCount = passengersCount;<br/>          }<br/>          public int getPassengersCount() { <br/>            return this.passengersCount; <br/>          }<br/>        }</pre>
<ol start="3">
<li>Create another subclass, called <kbd>Truck</kbd>:</li>
</ol>
<pre>         public class Truck extends Vehicle {<br/>           private int payload;<br/>           public Truck(int payloadPounds, int weightPounds, <br/>                        int horsePower){<br/>             super(weightPounds, horsePower);<br/>             this.payload = payloadPounds;<br/>           }<br/>           public int getPayload() { <br/>             return this.payload; <br/>           }<br/>         }</pre>
<p>Since the base class <kbd>Vehicle</kbd> has neither an implicit or explicit constructor without parameters (because we have chosen to use an explicit constructor with parameters only), we will have to call the base class constructor <kbd>super()</kbd> as the first line of the constructor of every subclass.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>Let's write a test program:</p>
<pre>public static void main(String... arg) {<br/>  double timeSec = 10.0;<br/>  int engineHorsePower = 246;<br/>  int vehicleWeightPounds = 4000;<br/>  Vehicle vehicle = new Car(4, vehicleWeightPounds, engineHorsePower);<br/>  System.out.println("Passengers count=" + <br/>                     ((Car)vehicle).getPassengersCount());<br/>  System.out.println("Car speed (" + timeSec + " sec) = " + <br/>                     vehicle.getSpeedMph(timeSec) + " mph");<br/>  vehicle = new Truck(3300, vehicleWeightPounds, engineHorsePower);<br/>  System.out.println("Payload=" + <br/>                     ((Truck)vehicle).getPayload() + " pounds");<br/>  System.out.println("Truck speed (" + timeSec + " sec) = " + <br/>                     vehicle.getSpeedMph(timeSec) + " mph");<br/>}</pre>
<p>Notice that the reference <kbd>vehicle</kbd> to the base class <kbd>Vehicle</kbd> points to the object of the subclass <kbd>Car</kbd>. This is made possible by polymorphism, according to which an object has a type of every class in its line of inheritance (including all the interfaces, which we will discuss a bit later).</p>
<p>One needs to cast such a reference to the subclass type, as you can see in the preceding example, in order to invoke a method that exists only in the subclass.</p>
<p>If we run the preceding example, the results will be as follows:</p>
<div class="CDPAlignCenter CDPAlign"><img height="66" width="365" class="image-border" src="assets/8b22a6f7-658c-4f04-b790-1b31f7a1a897.png"/></div>
<p>We should not be surprised to see the same speed, that is, <kbd>117.0 mph</kbd>, calculated for both--the car and the truck--because the same weight and engine power are used to calculate the speed of each. But, intuitively, we feel that a heavily loaded truck should not be able to reach the same speed as a car. To verify this, we need to include the total weight of the car (with the passengers and their luggage) and the truck (with the payload) in the <kbd>getSpeedMph()</kbd> method. One way to do this is to override the <kbd>getSpeedMph()</kbd> method of the base class <kbd>Vehicle</kbd> in each of the subclasses. </p>
<p>Now, add the <kbd>horsePower</kbd> and <kbd>weightPounds</kbd> properties and the following method to the <kbd>Car</kbd> class (we assume that a passenger with a luggage weighs 250 pounds total on average):</p>
<pre>public double getSpeedMph(double timeSec) {<br/>  int <strong>weight</strong> = this.weightPounds + this.passengersCount * 250;<br/>  double v = 2.0 * this.horsePower * 746;<br/>  v = v * timeSec * 32.174 / <strong>weight</strong>;<br/>  return Math.round(Math.sqrt(v) * 0.68);<br/>}</pre>
<p>Also, <span>add the</span> <kbd>horsePower</kbd> <span>and <kbd>weightPounds</kbd> properties and</span> the following method to the <kbd>Truck</kbd> class: </p>
<pre>public double getSpeedMph(double timeSec) {<br/>  int <strong>weight</strong> = this.weightPounds + <span>this.payload</span>;<br/>  double v = 2.0 * this.horsePower * 746;<br/>  v = v * timeSec * 32.174 / <strong>weight</strong>;<br/>  return Math.round(Math.sqrt(v) * 0.68);<br/>}</pre>
<p>The results of these two additions (if we run the same test class) will be as follows:</p>
<div class="CDPAlignCenter CDPAlign"><img height="68" width="347" class="image-border" src="assets/a6c54379-5e48-47eb-815f-e43f033390ca.png"/></div>
<p>These results do confirm our intuition: a fully loaded car or truck does not reach the same speed as an empty one.</p>
<p>The new methods in the subclasses override <kbd>getSpeedMph()</kbd> of the base class <kbd>Vehicle</kbd>, although we access it via the base class reference:</p>
<pre>Vehicle vehicle =  new Car(4, vehicleWeightPounds, engineHorsePower);<br/>System.out.println("Car speed (" + timeSec + " sec) = " + <br/>                   vehicle.getSpeedMph(timeSec) + " mph");</pre>
<p>The overridden method is dynamically bound, which means that the context of the method invocation is determined by the type of the actual object being referred to. Since, in our example, the reference <kbd>vehicle</kbd> points to an object of the subclass <kbd>Car</kbd>, the <kbd>vehicle.getSpeedMph()</kbd> construct invokes the method of the subclass, not the method of the base class.</p>
<p>There is obvious code redundancy in the two new methods, which we can refactor by creating a method in the base class, that is, <kbd>Vehicle</kbd>:</p>
<pre>protected double getSpeedMph(double timeSec, int weightPounds) {<br/>  double v = 2.0 * this.horsePower * 746;<br/>  v = v * timeSec * 32.174 / weightPounds;<br/>  return Math.round(Math.sqrt(v) * 0.68);<br/>}</pre>
<p>Since this method is used by subclasses only, it can be protected (and thus, accessible only to the subclasses).</p>
<p>Here's how the <kbd>getSpeedMph()</kbd> method of the <kbd>Car</kbd> subclass would look now:</p>
<pre>public double getSpeedMph(double timeSec) {<br/>  int weightPounds = this.weightPounds + this.passengersCount * 250;<br/>  return getSpeedMph(timeSec, weightPounds);<br/>}</pre>
<p>This is how it will appear in the <kbd>Truck</kbd> subclass: </p>
<pre>public double getSpeedMph(double timeSec) {<br/>  int weightPounds = this.weightPounds + this.payload;<br/>  return getSpeedMph(timeSec, weightPounds);<br/>}</pre>
<p>Now we need to modify the test class by adding casting. Otherwise, there will be a runtime error because the <kbd>getSpeedMph(int timeSec)</kbd> method does not exist in the base class <kbd>Vehicle</kbd>:</p>
<pre>public static void main(String... arg) {<br/>    double timeSec = 10.0;<br/>    int engineHorsePower = 246;<br/>    int vehicleWeightPounds = 4000;<br/>    Vehicle vehicle = new Car(4, vehicleWeightPounds, engineHorsePower);<br/>    System.out.println("Passengers count=" + <br/>                       ((Car)vehicle).getPassengersCount());<br/>    System.out.println("Car speed (" + timeSec + " sec) = " +<br/>                       <strong>((Car)vehicle)</strong>.getSpeedMph(timeSec) + " mph");<br/>    vehicle = new Truck(3300, vehicleWeightPounds, engineHorsePower);<br/>    System.out.println("Payload=" + <br/>                       ((Truck)vehicle).getPayload() + " pounds");<br/>    System.out.println("Truck speed (" + timeSec + " sec) = " + <br/>                       <strong>((Truck)vehicle)</strong>.getSpeedMph(timeSec) + " mph");<br/>  }<br/>}</pre>
<p>As you may have expected, the test class produces the same values:</p>
<div class="CDPAlignCenter CDPAlign"><img height="65" width="387" class="image-border" src="assets/bf68928d-e7fa-45b2-836f-ad5e6b863228.png"/></div>
<p>To simplify the test code, we can drop casting and write the following instead:</p>
<pre>public static void main(String... arg) {<br/>  double timeSec = 10.0;<br/>  int engineHorsePower = 246;<br/>  int vehicleWeightPounds = 4000;<br/>  Car car = new Car(4, vehicleWeightPounds, engineHorsePower);<br/>  System.out.println("Passengers count=" + car.getPassengersCount());<br/>  System.out.println("Car speed (" + timeSec + " sec) = " + <br/>                     car.getSpeedMph(timeSec) + " mph");<br/>  Truck truck = new Truck(3300, vehicleWeightPounds, engineHorsePower);<br/>  System.out.println("Payload=" + truck.getPayload() + " pounds");<br/>  System.out.println("Truck speed (" + timeSec + " sec) = " + <br/>                     truck.getSpeedMph(timeSec) + " mph");<br/>}</pre>
<p>The speed values produced by this code remain the same.</p>
<p>Yet, there is an even simpler way to achieve the same effect. We can add the <kbd>getMaxWeightPounds()</kbd> method to the base class and each of the subclasses. The <kbd>Car</kbd> class will now look as follows:</p>
<pre>public class Car extends Vehicle {<br/>  private int passengersCount, weightPounds;<br/>  public Car(int passengersCount, int weightPounds, int horsePower){<br/>    super(weightPounds, horsePower);<br/>    this.passengersCount = passengersCount;<br/>    this.weightPounds = weightPounds;<br/>  }<br/>  public int getPassengersCount() { <br/>    return this.passengersCount;<br/>  }<br/>  public int getMaxWeightPounds() {<br/>    return this.weightPounds + this.passengersCount * 250;<br/>  }<br/>}</pre>
<p>Here's how the new version of the <kbd>Truck</kbd> class will look: </p>
<pre>public class Truck extends Vehicle {<br/>  private int payload, weightPounds;<br/>  public Truck(int payloadPounds, int weightPounds, int horsePower) {<br/>    super(weightPounds, horsePower);<br/>    this.payload = payloadPounds;<br/>    this.weightPounds = weightPounds;<br/>  }<br/>  public int getPayload() { return this.payload; }<br/>  public int getMaxWeightPounds() {<br/>    return this.weightPounds + this.payload;<br/>  }<br/>}</pre>
<p>We also need to add the <kbd>getMaxWeightPounds()</kbd><span> method t</span><span>o the base class so it can be used for the speed calculations:</span></p>
<pre>public abstract class Vehicle {<br/>  private int weightPounds, horsePower;<br/>  public Vehicle(int weightPounds, int horsePower) {<br/>    this.weightPounds = weightPounds;<br/>    this.horsePower = horsePower;<br/>  }<br/>  public abstract int getMaxWeightPounds();<br/>  public double getSpeedMph(double timeSec){<br/>    double v = 2.0 * this.horsePower * 746;<br/>    v = v * timeSec * 32.174 / getMaxWeightPounds();<br/>    return Math.round(Math.sqrt(v) * 0.68);<br/>  }<br/>}</pre>
<p><span>Adding an abstract method <kbd>getMaxWeightPounds()</kbd> to the <kbd>Vehicle</kbd> class makes the class abstract. This has a positive side effect: it enforces the implementation of the</span> <kbd>getMaxWeightPounds()</kbd> <span>method</span> <span>in</span> each subclass.</p>
<p>The test class remains the same and produces the same results:</p>
<div class="CDPAlignCenter CDPAlign"><img height="65" width="346" class="image-border" src="assets/b773c1f3-bbdc-4df9-9f70-9c09acda2f24.png"/></div>
<p>There is an even simpler code change for the same effect--to use the maximum weight in the speed calculations in the base class. If we get back to the original version of the classes, all we need to do is to pass the maximum weight to the constructor of the base class <kbd>Vehicle</kbd>. The resulting classes will look like this:</p>
<pre>public class Car extends Vehicle {<br/>  private int passengersCount;<br/>  public Car(int passengersCount, int weightPounds, int horsepower){<br/>    super(<strong>weightPounds + passengersCount * 250</strong>, horsePower);<br/>    this.passengersCount = passengersCount;<br/>  }<br/>  public int getPassengersCount() { <br/>    return this.passengersCount; }<br/>}</pre>
<p>We added the weight of the passengers to the value we pass to the constructor of the superclass; this is the only change in this subclass. There was a similar change in the <kbd>Truck</kbd> subclass: </p>
<pre>public class Truck extends Vehicle {<br/>  private int payload;<br/>  public Truck(int payloadPounds, int weightPounds, int horsePower) {<br/>    super(weightPounds + payloadPounds, horsePower);<br/>    this.payload = payloadPounds;<br/>  }<br/>  public int getPayload() { return this.payload; }<br/>}</pre>
<p>The base class <kbd>Vehicle</kbd> remains the same:</p>
<pre>public class Vehicle {<br/>  private int weightPounds, horsePower;<br/>  public Vehicle(int weightPounds, int horsePower) {<br/>    this.weightPounds = weightPounds;<br/>    this.horsePower = horsePower;<br/>  }<br/>  public double getSpeedMph(double timeSec){<br/>    double v = 2.0 * this.horsePower * 746;<br/>    v = v * timeSec * 32.174 / this.weightPounds;<br/>    return Math.round(Math.sqrt(v) * 0.68);<br/>  }<br/>}</pre>
<p>The test class does not change and produces the same results:</p>
<div class="CDPAlignCenter CDPAlign"><img height="65" width="356" class="image-border" src="assets/695b3517-b722-44bb-b141-70c5175a291d.png"/></div>
<p>This last version--passing the maximum weight to the constructor of the base class--will now be the starting point for further demo code development.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Composition makes the design more extensible</h1>
                </header>
            
            <article>
                
<p>In the preceding example, the speed model is implemented in the <kbd>getSpeedMph()</kbd> method of the <kbd>Vehicle</kbd> class. If we need to use a different speed model (which includes more input parameters and is more tuned to certain driving conditions, for example), we would need to change the <kbd>Vehicle</kbd> class or create a new subclass to override the method. In the case when we need to experiment with tens or even hundreds of different models, this approach becomes untenable.</p>
<p>Also, in real life, modeling based on machine learning and other advanced techniques becomes so involved and specialized, that it is quite common that the modeling of car acceleration is done by a different team, not the team that builds vehicles.</p>
<p>To avoid the proliferation of subclasses and code merge conflicts between vehicle builders and speed model developers, we can create a more extensible design using composition. </p>
<div class="packt_infobox">Composition is an OOD principle for implementing the necessary functionality using the behavior of classes that are not part of the inheritance hierarchy.</div>
<p>We can encapsulate the speed calculations inside the <kbd>SpeedModel</kbd> class in the <kbd>getSpeedMph()</kbd> method: </p>
<pre>private Properties conditions;<br/>  public SpeedModel(Properties drivingConditions){<br/>    this.drivingConditions = drivingConditions;<br/>  }<br/>  public double getSpeedMph(double timeSec, int weightPounds,<br/>                            int horsePower){<br/>    String road = drivingConditions.getProperty("roadCondition","Dry");<br/>    String tire = drivingConditions.getProperty("tireCondition","New");<br/>    double v = 2.0 * horsePower * 746;<br/>    v = v * timeSec * 32.174 / weightPounds;<br/>    return Math.round(Math.sqrt(v) * 0.68) <br/>                      - (road.equals("Dry") ? 2 : 5) <br/>                      - (tire.equals("New") ? 0 : 5);<br/>   }<br/>}</pre>
<p>An object of this class can be created and then set on the <kbd>Vehicle</kbd> class: </p>
<pre>public class Vehicle {<br/>   private SpeedModel speedModel;<br/>   private int weightPounds, horsePower;<br/>   public Vehicle(int weightPounds, int horsePower) {<br/>      this.weightPounds = weightPounds;<br/>      this.horsePower = horsePower;<br/>   }<br/>   public void setSpeedModel(SpeedModel speedModel){<br/>      this.speedModel = speedModel;<br/>   }<br/>   public double getSpeedMph(double timeSec){<br/>      return this.speedModel.getSpeedMph(timeSec,<br/>                       this.weightPounds, this.horsePower);<br/>   }<br/>}</pre>
<p>So, the test class may look like this:</p>
<pre>public static void main(String... arg) {<br/>  double timeSec = 10.0;<br/>  int horsePower = 246;<br/>  int vehicleWeight = 4000;<br/>  Properties drivingConditions = new Properties();<br/>  drivingConditions.put("roadCondition", "Wet");<br/>  drivingConditions.put("tireCondition", "New");<br/>  SpeedModel speedModel = new SpeedModel(drivingConditions);<br/>  Car car = new Car(4, vehicleWeight, horsePower);<br/>  car.setSpeedModel(speedModel);<br/>  System.out.println("Car speed (" + timeSec + " sec) = " + <br/>                     car.getSpeedMph(timeSec) + " mph");<br/>}</pre>
<p>The result will be as follows:</p>
<div class="CDPAlignCenter CDPAlign"><img height="41" width="355" class="image-border" src="assets/f73ccaca-62d9-47e6-adf5-0bc130d5000f.png"/></div>
<p>We isolated the speed calculating functionality in a separate class and can now modify or extend it without changing any class of the <kbd>Vehicle</kbd> hierarchy. This is how the composition design principle allows you to change the behavior of the <kbd>Vehicle</kbd> class and its subclasses without changing their implementation.</p>
<p>In the next recipe, we will show how the OOD concept of Interface unlocks more power of composition and polymorphism, making the design simpler and even more expressive.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">See also</h1>
                </header>
            
            <article>
                
<p>Refer to the following recipes in this chapter:</p>
<ul>
<li>Coding to an interface</li>
<li>Using enums to represent constant entities</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Coding to an interface</h1>
                </header>
            
            <article>
                
<p>In this recipe, you will learn about the last of the OOD concepts, called Interface, and further practice the usage of composition and polymorphism as well as inner classes and inheritance.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p>Interface, in this case, is a reference type that defines the signatures of the methods one can expect to see in the class that implements the interface. It is the public face of the functionality accessible to a client and is thus often called an <strong>Application Program Interface</strong> (<strong>API</strong>). It supports polymorphism and composition and thus facilitates even more flexible and extensible design.</p>
<p>An interface is implicitly abstract, which means it cannot be instantiated (no object can be created based on an interface only). It is used to contain abstract methods (without body) only. Now, since Java 8, it is possible to add default and private methods to an interface--the capability we are going to discuss in the following recipes.</p>
<p>Each interface can extend multiple other interfaces and, similar to class inheritance, inherit all the methods of the extended interfaces.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<ol>
<li>Create interfaces that will describe the API:</li>
</ol>
<pre>        public interface SpeedModel {<br/>          double getSpeedMph(double timeSec, int weightPounds,<br/>                             int horsePower);<br/>        }<br/>        public interface Vehicle {<br/>          void setSpeedModel(SpeedModel speedModel);<br/>          double getSpeedMph(double timeSec);<br/>        }<br/>        public interface Car extends Vehicle {<br/>          int getPassengersCount();<br/>        }<br/>        public interface Truck extends Vehicle {<br/>          int getPayloadPounds();<br/>        }</pre>
<ol start="2">
<li>Use factories, which are classes that generate objects that implement certain interfaces. A factory is an implementation of a pattern for creating objects without having to specify the exact class of the object that is created--specifying an interface only, rather than calling a constructor. It is especially helpful when an instance of object creation requires a complex process and/or significant code duplication.<br/>
In our case, it makes sense to have the <kbd>FactoryVehicle</kbd> class that will create objects for the <kbd>Vehicle</kbd>, <kbd>Car</kbd>, and <kbd>Truck</kbd> interfaces and the <kbd>FactorySpeedModel</kbd> class that will generate objects for the <kbd>SpeedModel</kbd> interface. Such an API will allow you to write the following code:</li>
</ol>
<pre>        public static void main(String... arg) {<br/>          double timeSec = 10.0;<br/>          int horsePower = 246;<br/>          int vehicleWeight = 4000;<br/>          Properties drivingConditions = new Properties();<br/>          drivingConditions.put("roadCondition", "Wet");<br/>          drivingConditions.put("tireCondition", "New");<br/>           SpeedModel speedModel =  FactorySpeedModel<br/>                .generateSpeedModel(drivingConditions);<br/>           Car car = FactoryVehicle.buildCar(4, vehicleWeight, <br/>                                             horsePower);<br/>           car.setSpeedModel(speedModel);<br/>           System.out.println("Car speed (" + timeSec + " sec) = " + <br/>                              car.getSpeedMph(timeSec) + " mph");<br/>        }</pre>
<ol start="3">
<li>Observe that the code behavior is the same:</li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img height="40" width="395" class="image-border" src="assets/4cb4d51f-2ed9-4e45-9cc0-b8a2a275cf7e.png"/></div>
<p style="padding-left: 60px">However, the design is much more extensible.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>We have already seen one possible implementation of the <kbd>SpeedModel</kbd> class. Here is another way to do this inside the <kbd>FactorySpeedModel</kbd> class: </p>
<pre>public class FactorySpeedModel {<br/>  public static SpeedModel generateSpeedModel(<br/>  Properties drivingConditions){<br/>    //if drivingConditions includes "roadCondition"="Wet"<br/>    return new SpeedModelWet(...);<br/>    //if drivingConditions includes "roadCondition"="Dry"<br/>    return new SpeedModelDry(...);<br/>  }<br/>  private class SpeedModelWet implements SpeedModel{<br/>    public double getSpeedMph(double timeSec, int weightPounds, <br/>                              int horsePower){...}<br/>  }<br/>  private class SpeedModelDry implements SpeedModel{<br/>    public double getSpeedMph(double timeSec, int weightPounds, <br/>                              int horsePower){...}<br/>   }<br/>}</pre>
<p>We put comments (as pseudo code) and the <kbd>...</kbd> symbol instead of the code for brevity. </p>
<p>As you can see, the factory class may hide many different private and static nested classes, each containing a specialized model for particular driving conditions. Each model brings different results.</p>
<p>An implementation of the <kbd>FactoryVehicle</kbd> class may look like this:</p>
<pre>public class FactoryVehicle {<br/>  public static Car buildCar(int passengersCount, int weightPounds,<br/>                             int horsePower){<br/>    return new CarImpl(passengersCount, weightPounds, horsePower);<br/>  }<br/>  public static Truck buildTruck(int payloadPounds, int weightPounds,<br/>                                 int horsePower){<br/>    return new TruckImpl(payloadPounds, weightPounds, horsePower);<br/>  }<br/>  class CarImpl extends VehicleImpl implements Car {<br/>    private int passengersCount;<br/>    private CarImpl(int passengersCount, int weightPounds,<br/>                    int horsePower){<br/>      super(weightPounds + passengersCount * 250, horsePower);<br/>      this.passengersCount = passengersCount;<br/>    }<br/>    public int getPassengersCount() { <br/>      return this.passengersCount;<br/>    }<br/>  }<br/>  class TruckImpl extends VehicleImpl implements Truck {<br/>    private int payloadPounds;<br/>    private TruckImpl(int payloadPounds, int weightPounds, <br/>                      int horsePower){<br/>      super(weightPounds+payloadPounds, horsePower);<br/>      this.payloadPounds = payloadPounds;<br/>    }<br/>    public int getPayloadPounds(){ return payloadPounds; }<br/>  }<br/>  abstract class VehicleImpl implements Vehicle {<br/>    private SpeedModel speedModel;<br/>    private int weightPounds, horsePower;<br/>    private VehicleImpl(int weightPounds, int horsePower){<br/>      this.weightPounds = weightPounds;<br/>      this.horsePower = horsePower;<br/>    }<br/>    public void setSpeedModel(SpeedModel speedModel){ <br/>      this.speedModel = speedModel; <br/>    }<br/>    public double getSpeedMph(double timeSec){<br/>      return this.speedModel.getSpeedMph(timeSec, weightPounds, <br/>                                         horsePower);<br/>    }<br/>  }<br/>}</pre>
<p>As you can see, an interface describes how to invoke object behavior; it also allows you to generate different implementations for different requests (and provided values) without changing the code of the main application.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">There's more...</h1>
                </header>
            
            <article>
                
<p>Let's try to model a crew cab--a truck with multiple passenger seats that combines the properties of a car and a truck. Java does not allow multiple inheritances. This is another case where interfaces come to the rescue.</p>
<p>The <kbd>CrewCab</kbd> class may look like this:</p>
<pre>class CrewCab extends VehicleImpl implements Car, Truck {<br/>  private int payloadPounds;<br/>  private int passengersCount;<br/>  private CrewCabImpl(int passengersCount, int payloadPounds,<br/>                      int weightPounds, int horsePower) {<br/>    super(weightPounds + payloadPounds<br/>          + passengersCount * 250, horsePower);<br/>    this.payloadPounds = payloadPounds;<br/>    this. passengersCount = passengersCount;<br/>  }<br/>  public int getPayloadPounds(){ return payloadPounds; }<br/>  public int getPassengersCount() { <br/>    return this.passengersCount;<br/>  }<br/>}</pre>
<p>This class implements both the interfaces--<kbd>Car</kbd> and <kbd>Truck</kbd>--and passes the combined weight of the vehicle, payload, and passengers with their luggage to the base class constructor.</p>
<p>We can also add the following method to <kbd>FactoryVehicle</kbd>:</p>
<pre>public static Vehicle buildCrewCab(int passengersCount, <br/>           int payload, int weightPounds, int horsePower){<br/>  return new CrewCabImpl(passengersCount, payload, <br/>                         weightPounds, horsePower);<br/>}</pre>
<p>The double nature of the <kbd>CrewCab</kbd> object can be demonstrated in the following test:</p>
<pre>public static void main(String... arg) {<br/>  double timeSec = 10.0;<br/>  int horsePower = 246;<br/>  int vehicleWeight = 4000;<br/>  Properties drivingConditions = new Properties();<br/>  drivingConditions.put("roadCondition", "Wet");<br/>  drivingConditions.put("tireCondition", "New");<br/>  SpeedModel speedModel = FactorySpeedModel<br/>                    .generateSpeedModel(drivingConditions);<br/>  Vehicle vehicle = FactoryVehicle<br/>         .buildCrewCab(4, 3300, vehicleWeight, horsePower);<br/>  vehicle.setSpeedModel(speedModel);<br/>  System.out.println("Payload = " +<br/>                     ((Truck)vehicle).getPayloadPounds()) + " pounds");<br/>  System.out.println("Passengers count = " + <br/>                     ((Car)vehicle).getPassengersCount());<br/>  System.out.println("Crew cab speed (" + timeSec + " sec) = "  + <br/>                     vehicle.getSpeedMph(timeSec) + " mph");<br/>}</pre>
<p>As you can see, we can cast the object of the <kbd>CrewCub</kbd> class to each of the interfaces it implements. If we run this program, the results will be as follows:</p>
<div class="CDPAlignCenter CDPAlign"><img height="58" width="356" class="image-border" src="assets/f6bb6903-fd2b-4b30-bedf-658be189bb28.png"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">See also</h1>
                </header>
            
            <article>
                
<p>Refer to the following recipes in this chapter:</p>
<ul>
<li>Creating interfaces with default and static methods</li>
<li>Creating interfaces with private methods</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Creating interfaces with default and static methods</h1>
                </header>
            
            <article>
                
<p>In this recipe, you will learn about two new features that were first introduced in Java 8: default and static methods in an interface. </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p>The default method allows you to add new functionality to an interface without changing the classes that have implemented this interface. The method is called <em>default</em> because it provides functionality in case a method is not implemented by the class. If, however, the class implements it, the interface's default implementation is ignored and overridden by the class implementation.</p>
<p>Having a static method in an interface can provide functionality the same way a static method in a class can. As with a class static method (which can be called without class instantiation), an interface static method can also be called by adding the name of the interface in front of it.</p>
<p>A static interface method cannot be overridden by any class, including the class that implements this interface, and it cannot hide any static method of any class, including the class that implements this interface.</p>
<p>So far, we have created an amazing piece of software that calculates the speed of a vehicle. If this program becomes popular (as it should), it can be used by readers who prefer a metric system of weight units. To address such a need later--after our speed-calculating software has become popular--we have decided to add more methods to the <kbd>Truck</kbd> interface; however, we do not want to break the existing implementation of <kbd>FactoryVehicle</kbd>, created by some other company.</p>
<p>The default interface methods were introduced for exactly such a situation. Using them, we can release a new version of an interface without the need to coordinate it with the development of <kbd>FactoryVehicle</kbd>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<ol>
<li>Enhance the <kbd>Truck</kbd> interface by adding the <kbd>getPayloadKg()</kbd> method, which returns the truck payload in kilograms. You can do this without forcing a change in the <kbd>TruckImpl</kbd> class that implements the <kbd>Truck</kbd> interface inside <kbd>FactoryVehicle</kbd>--by adding a new default method to the <kbd>Truck</kbd> interface:</li>
</ol>
<pre>        public interface Truck extends Vehicle {<br/>          int getPayloadPounds();<br/>          default int getPayloadKg(){<br/>            return (int) Math.round(0.454 * getPayloadPounds());<br/>          }<br/>        }</pre>
<p style="padding-left: 60px">Notice how the new method <kbd>getPayloadKg()</kbd> uses the existing <kbd>getPayloadPounds()</kbd> method as if the latter is implemented inside the interface too when, in fact, it is implemented by a class inside <kbd>FactoryVehicle</kbd>. The magic happens during runtime when this method becomes dynamically bound to the instance of the class that implements this interface.</p>
<p style="padding-left: 60px">We could not make the <kbd>getPayloadKg()</kbd> method static because it would not be able to access the non-static <kbd>getPayloadPounds()</kbd> method, and we must use the <kbd>default</kbd> keyword because only the default or static method of an interface can have a body.</p>
<ol start="2">
<li>Write the demo code that uses the new method:</li>
</ol>
<pre>        public static void main(String... arg) {<br/>          Truck truck = FactoryVehicle.buildTruck(3300, 4000, 246);<br/>          System.out.println("Payload in pounds: " + <br/>                             truck.getPayloadPounds());<br/>          System.out.println("Payload in kg: " + truck.getPayloadKg());<br/>        }</pre>
<ol start="3">
<li>Run the preceding program and see the output:</li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img height="41" width="345" class="image-border" src="assets/d779c3d6-9a12-4182-b28e-4a8f850a6a23.png"/></div>
<ol start="4">
<li>Notice that the new method works even without changing the class that implemented it.</li>
<li>Later, when you decide to improve the implementation of the <kbd>FactoryVehicle</kbd> class, you can do it by adding the corresponding method, for example:</li>
</ol>
<pre>        class TruckImpl extends VehicleImpl implements Truck {<br/>          private int payloadPounds;<br/>          private TruckImpl(int payloadPounds, int weightPounds,<br/>                            int horsePower) {<br/>            super(weightPounds + payloadPounds, horsePower);<br/>            this.payloadPounds = payloadPounds;<br/>          }<br/>          public int getPayloadPounds(){ return payloadPounds; }<br/>          public int getPayloadKg(){ return -2; }<br/>        }</pre>
<p style="padding-left: 60px">We made the <kbd>return -2</kbd> implementation in order to make it obvious which implementation is used.</p>
<ol start="6">
<li>Run the same demo program. The results will be as follows:</li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img height="40" width="325" class="image-border" src="assets/86a7f48c-f9c7-4b14-923d-ec2a9f861d8e.png"/></div>
<p style="padding-left: 60px">As you can see, the method in the <kbd>TruckImpl</kbd> class has overridden the default implementation in the <kbd>Truck</kbd> interface.</p>
<ol start="7">
<li>Enhance the <kbd>Truck</kbd> interface with the ability to enter the payload in kilograms without changing the implementation of <kbd>FactoryVehicle</kbd>. But we would also like the <kbd>Truck</kbd> implementation to remain immutable, and we do not want to add a setter method. With all these limitations, our only recourse is to add <kbd>convertKgToPounds()</kbd> to the <kbd>Truck</kbd> interface, and it has to be <kbd>static</kbd> since we are going to use it before the object that implements the <kbd>Truck</kbd> interface is constructed:</li>
</ol>
<pre>        public interface Truck extends Vehicle {<br/>          int getPayloadPounds();<br/>          default int getPayloadKg(){<br/>            return (int) Math.round(0.454 * getPayloadPounds());<br/>          }<br/>          static int convertKgToPounds(int kgs){<br/>            return (int) Math.round(2.205 * kgs);<br/>          }<br/>        }</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>Fans who love using the metric system of units can now take advantage of the new method:</p>
<pre>public static void main(String... arg) {<br/>  int horsePower = 246;<br/>  int payload = Truck.convertKgToPounds(1500);<br/>  int vehicleWeight = Truck.convertKgToPounds(1800);<br/>  Truck truck = FactoryVehicle <br/>           .buildTruck(payload, vehicleWeight, horsePower);<br/>  System.out.println("Payload in pounds: " + truck.getPayloadPounds());<br/>  int kg = truck.getPayloadKg();<br/>  System.out.println("Payload converted to kg: " + kg);<br/>  System.out.println("Payload converted back to pounds: " + <br/>                     Truck.convertKgToPounds(kg));<br/>}</pre>
<p>The results will be as follows:</p>
<div class="CDPAlignCenter CDPAlign"><img height="55" width="353" class="image-border" src="assets/8ba684a5-eae1-4f97-9deb-7186ea1d6531.png"/></div>
<p>The value 1,502 is close to the original 1,500, while 3,308 is close to 3,312. The difference is caused by the error of approximation during the conversion.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">See also</h1>
                </header>
            
            <article>
                
<p>Refer to the following recipe in this chapter:</p>
<ul>
<li>Creating interfaces with private methods</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Creating interfaces with private methods</h1>
                </header>
            
            <article>
                
<p>In this recipe, you will learn about a new feature introduced in Java 9: private interface method, which <span>is </span>of two types, namely static and non-static.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p>Private methods in an interface are new in Java 9. They allow you to make interface methods (with a body) accessible only to other methods (with a body) in the same interface.</p>
<p>A private method in an interface cannot be overridden anywhere--not by a method of any interface, nor by a method in any class. Its only purpose is to contain functionality that is common between two or more methods with a body, either private or public, in the same interface. It can also be used by one method only in order to make the code easier to understand.</p>
<p>A private interface method must have an implementation. A private interface method not used by other methods of the same interface does not make sense.</p>
<p>A static private interface method can be accessed by non-static and static methods of the same interface. The non-static private interface method can be accessed only by static methods of the same interface.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<ol>
<li>Add the <kbd>getWeightKg()</kbd> implementation too. Since we do not have the <kbd>getWeightPounds()</kbd> method in the interface, the method signature should include an input parameter:</li>
</ol>
<pre>        public interface Truck extends Vehicle {<br/>          int getPayloadPounds();<br/>          default int getPayloadKg(){<br/>            return (int) Math.round(0.454 * getPayloadPounds());<br/>          }<br/>          static int convertKgToPounds(int kilograms){<br/>            return (int) Math.round(2.205 * kilograms);<br/>          }<br/>          default int getWeightKg(int pounds){<br/>            return (int) Math.round(0.454 * pounds);<br/>          }<br/>        }</pre>
<ol start="2">
<li>Remove the redundant code using the private interface method:</li>
</ol>
<pre>        public interface Truck extends Vehicle {<br/>          int getPayloadPounds();<br/>          default int getPayloadKg(int pounds){<br/>            return convertPoundsToKg(pounds);<br/>          }<br/>          static int convertKgToPounds(int kilograms){<br/>            return (int) Math.round(2.205 * kilograms);<br/>          }<br/>          default int getWeightKg(int pounds){<br/>            return convertPoundsToKg(pounds);<br/>          }<br/>          private int convertPoundsToKg(int pounds){<br/>            return (int) Math.round(0.454 * pounds);<br/>          }<br/>        }</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>The following code demonstrates the new addition:</p>
<pre>public static void main(String... arg) {<br/>  int horsePower = 246;<br/>  int payload = Truck.convertKgToPounds(1500);<br/>  int vehicleWeight = Truck.convertKgToPounds(1800);<br/>  Truck truck = FactoryVehicle<br/>            .buildTruck(payload, vehicleWeight, horsePower);<br/>  System.out.println("Weight in pounds: " + vehicleWeight);<br/>  int kg = truck.getWeightKg(vehicleWeight);<br/>  System.out.println("Weight converted to kg: " + kg);<br/>  System.out.println("Weight converted back to pounds: " + <br/>                     Truck.convertKgToPounds(kg));<br/>}</pre>
<p>The results of the test run do not change:</p>
<div class="CDPAlignCenter CDPAlign"><img height="47" width="322" class="image-border" src="assets/acc2484b-046c-4f1e-89bb-6eaebf0e6879.png"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">There's more...</h1>
                </header>
            
            <article>
                
<p>Well, with the <kbd>getWeightKg(int pounds)</kbd> method accepting the input parameter, the method name can be misleading because (by contrast, with <kbd>getPayloadKg()</kbd>) the method does not control the source of the data. The input value can represent anything. After realizing it, we decided that the interface would be better without it, but only after making the <kbd>convertPoundsToKg()</kbd> method public. Since it does not require access to the object elements, it can be static too:</p>
<pre>public interface Truck extends Vehicle {<br/>  int getPayloadPounds();<br/>  default int getPayloadKg(int pounds){<br/>    return convertPoundsToKg(pounds);<br/>  }<br/>  static int convertKgToPounds(int kilograms){<br/>    return (int) Math.round(2.205 * kilograms);<br/>  }<br/>  static int convertPoundsToKg(int pounds){<br/>    return (int) Math.round(0.454 * pounds);<br/>  }<br/>}</pre>
<p>Fans of the metric system will still be able to convert pounds into kilograms and back. Besides, since the converting methods are static, we do not need to create an instance of the class that implements the <kbd>Truck</kbd> interface: </p>
<pre>public static void main(String... arg) {<br/>  int payload = Truck.convertKgToPounds(1500);<br/>  int vehicleWeight = Truck.convertKgToPounds(1800);<br/>  System.out.println("Weight in pounds: " + vehicleWeight);<br/>  int kg = Truck.convertPoundsToKg(vehicleWeight);<br/>  System.out.println("Weight converted to kg: " + kg);<br/>  System.out.println("Weight converted back to pounds: " + <br/>                     Truck.convertKgToPounds(kg));<br/>}</pre>
<p>The results do not change:</p>
<div class="CDPAlignCenter CDPAlign"><img height="49" width="353" class="image-border" src="assets/1911b481-e70a-4ea0-814c-c855c3fd9e66.png"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">See also</h1>
                </header>
            
            <article>
                
<p>Refer to the following recipe of this chapter:</p>
<ul>
<li>Creating interfaces with default and static methods</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Using enums to represent constant entities</h1>
                </header>
            
            <article>
                
<p>In this recipe, you will learn about the special data type <kbd>enum</kbd> that allows you to create a custom type with predefined values.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p>Let's have a quick look at a couple of examples. Here is the simplest possible <kbd>enum</kbd> type:</p>
<pre>public enum RoadCondition {<br/>  DRY, WET, SNOW<br/>}</pre>
<p>Say we run the following loop:</p>
<pre>for(RoadCondition v: RoadCondition.values()){<br/>  System.out.println(v);<br/>}</pre>
<p>The results of this will be as follows:</p>
<div class="CDPAlignCenter CDPAlign"><img height="46" width="165" class="image-border" src="assets/2ff9021e-eb00-4482-9825-3876c3ec2606.png"/></div>
<p>The <kbd>enum</kbd> type implicitly extends <kbd>java.util.Enum</kbd> (so you cannot extend your custom type <kbd>RoadCondition</kbd>, for example) and automatically acquires its methods. In the preceding code, we have already seen one (the most useful) method, <kbd>values()</kbd>, that returns an array of the <kbd>enum</kbd> elements.</p>
<p>Another useful <kbd>enum</kbd> method is <kbd>valueOf(String)</kbd> that returns the constant of the specified <kbd>enum</kbd> type with the specified name (passed in as <kbd>String</kbd>).</p>
<p>The methods of each element include useful ones such as <kbd>equals()</kbd>, <kbd>name()</kbd>, and <kbd>ordinal()</kbd>. Now say we run the following loop:</p>
<pre>for(RoadCondition v: RoadCondition.values()){<br/>  System.out.println(v.ordinal());<br/>  System.out.println(v.name());<br/>  System.out.println(RoadCondition.SNOW.equals(v));<br/>}</pre>
<p>We will get the following result:</p>
<div class="CDPAlignCenter CDPAlign"><img height="104" width="159" class="image-border" src="assets/88928175-8f84-407c-8704-ac44ca3a6dc4.png"/></div>
<p>As you may have guessed, <kbd>ordinal()</kbd> returns the position of the value in the <kbd>enum</kbd> declaration, starting with zero.</p>
<p>Other <kbd>enum</kbd> features include the following:</p>
<ul>
<li>The <kbd>enum</kbd> class body can include a constructor, methods, variables, and constants</li>
<li>The constructor is called automatically when <kbd>enum</kbd> is accessed the first time</li>
<li>The static constant can be accessed via the class name</li>
<li>The non-static constant can be accessed via any of the elements</li>
</ul>
<div class="packt_tip">Java comes with several predefined <kbd>enum</kbd> types, including <kbd>DayOfWeek</kbd> and <kbd>Month</kbd>.</div>
<p>To make it look more like a real-life <kbd>enum</kbd>, let's use traction coefficient as an element value. Such a coefficient reflects the degree of traction between the road and the tires. The higher the value, the better the traction. This value can be used for the improvement of a vehicle speed calculation. For example, <kbd>SpeedModel</kbd> should be able to receive <kbd>RoadCondition.WET</kbd> and extract the traction coefficient <kbd>0.2</kbd> from it. </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<ol>
<li>Define the <kbd>RoadCondition</kbd> enumeration in the <kbd>SpeedModel</kbd> interface (because it is part of the <kbd>SpeedModel</kbd> API):</li>
</ol>
<pre>        public interface SpeedModel {<br/>          double getSpeedMph(double timeSec, int weightPounds,<br/>                             int horsePower);<br/><br/>          enum RoadCondition {<br/>            DRY(1.0), WET(0.2), SNOW(0.04);<br/>            private double traction;<br/>            RoadCondition(double traction){ this.traction = traction;}<br/>            public double getTraction(){ return this.traction; }<br/>          }<br/>        }</pre>
<p style="padding-left: 60px">There is no need to add the <kbd>public</kbd> keyword in front of <kbd>enum RoadCondition</kbd> because, in an interface, it defaults to <kbd>public</kbd> (if the <kbd>private</kbd> keyword is not used instead).</p>
<ol start="2">
<li>Run the following loop:</li>
</ol>
<pre>        for(RoadCondition v: RoadCondition.values()){<br/>          System.out.println(v + " =&gt; " + v.getTraction());<br/>        }</pre>
<ol start="3">
<li>You'll get the following result:</li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img height="69" width="258" class="image-border" src="assets/6926d3f5-dcd9-4a2e-bf05-14ec9220152d.png"/></div>
<ol start="4">
<li>Add <kbd>enum TireCondition</kbd> to the <kbd>iSpeedModel</kbd> interface too:</li>
</ol>
<pre>        enum TireCondition {<br/>          NEW(1.0), WORN(0.2);<br/>          private double traction;<br/>          TireCondition(double traction){ this.traction = traction; }<br/>          public double getTraction(){return this.traction;}<br/>        }</pre>
<ol start="5">
<li>Add <kbd>enum</kbd> for <kbd>DrivingCondition</kbd>:</li>
</ol>
<pre>        enum DrivingCondition {<br/>          ROAD_CONDITION, TIRE_CONDITION<br/>        }</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>With the three <kbd>enum</kbd> types in place, we can calculate the vehicle speed of all the possible combinations of the given driving conditions:</p>
<pre>public static void main(String... arg) {<br/>  double timeSec = 10.0;<br/>  String[] roadConditions = { RoadCondition.WET.toString(), <br/>                              RoadCondition.SNOW.toString() };<br/>  String[] tireConditions = { TireCondition.NEW.toString(), <br/>                              TireCondition.WORN.toString() };<br/>  for(String rc: roadConditions){<br/>    for(String tc: tireConditions){<br/>      Properties drivingCond = new Properties();<br/>      drivingCond.put(DrivingCondition<br/>                      .ROAD_CONDITION.toString(), rc);<br/>      drivingCond.put(DrivingCondition<br/>                      .TIRE_CONDITION.toString(), tc);<br/>      SpeedModel speedModel = FactorySpeedModel<br/>                      .generateSpeedModel(drivingCond);<br/>      Car car = FactoryVehicle.buildCar(4, 4000, 246);<br/>      car.setSpeedModel(speedModel);<br/>      System.out.println("Car speed (" + timeSec + " sec) = " +<br/>                          car.getSpeedMph(timeSec) + " mph");<br/>      }<br/>   }<br/>}</pre>
<p>The results will be as follows:</p>
<div class="CDPAlignCenter CDPAlign"><img height="153" width="381" class="image-border" src="assets/7044df96-2382-4ce6-80a0-c79796543285.png"/></div>
<p>That is how <kbd>enum</kbd> allows you to define an API input and make input data validation unnecessary.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">There's more...</h1>
                </header>
            
            <article>
                
<p>The higher the temperature, the quicker the road dries out, and the traction coefficient is getting higher. To account for this, we can add a <kbd>temperature</kbd> property to <kbd>enum RoadCondition</kbd> and override the <kbd>getTraction()</kbd> method for the <kbd>WET</kbd> element, for example:</p>
<pre>enum RoadCondition {<br/>  public int temperature;<br/>  DRY(1.0),<br/>  WET(0.2) {<br/>    public double getTraction(){ <br/>      RoadCondition return temperature &gt; 60 ? 0.4 : 0.2 <br/>    } <br/>  },<br/>  SNOW(0.04);<br/>  private double traction;<br/>  RoadCondition(double traction){this.traction = traction; }<br/>  public double getTraction(){ return this.traction; }<br/>}</pre>
<p>Now we can set the <kbd>temperature</kbd> property on <kbd>RoadCondition</kbd> before the speed calculation and get a different value of speed for the wet road condition. Add this line before calling the speed calculations:</p>
<pre>RoadCondition.temperature = 63;</pre>
<p>If you do this, the results will be as follows:</p>
<div class="CDPAlignCenter CDPAlign"><img height="123" width="317" class="image-border" src="assets/d678b27a-77e3-4d32-994c-b0a14e981ab5.png"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Using the @Deprecated annotation to deprecate APIs</h1>
                </header>
            
            <article>
                
<p>In this recipe, you will learn about the deprecation of API elements and the enhancements of the <kbd>@Deprecated</kbd>  annotation in Java 9.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p>The <kbd>@Deprecated</kbd> annotation was first introduced in Java 5, while the Javadoc tag <kbd>@deprecated</kbd> was introduced in Java even earlier. The presence of the annotation forces the compiler to generate a warning that can be suppressed by the annotation:</p>
<pre>@SuppressWarnings("deprecation")</pre>
<p>Since Java 9, the annotation can have one or both the methods, namely <kbd>since()</kbd> and <kbd>forRemoval()</kbd>:</p>
<pre>@Deprecated(since = "2.1", forRemoval = true)</pre>
<p>The <kbd>since()</kbd> method allows the setting of the API version (as <kbd>String</kbd>). It depicts the API version from where the particular class or method was deprecated. If not specified, the default value of the <kbd>since()</kbd> method is <kbd>""</kbd> (empty <kbd>String</kbd>).</p>
<p>The <kbd>forRemoval()</kbd> method depicts the intent to remove the marked element (if <kbd>true</kbd>) or not (if <kbd>false</kbd>). If not set, the default value is <kbd>false</kbd>. If the <kbd>forRemoval()</kbd> method is present with the value <kbd>true</kbd> to suppress the warning, one needs to specify the following:</p>
<pre>@SuppressWarnings("removal")</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<ol>
<li>Look at the <kbd>Car</kbd> interface again:</li>
</ol>
<pre>        public interface Truck extends Vehicle {<br/>          int getPayloadPounds();<br/>        }</pre>
<ol start="2">
<li>Instead of the <kbd>getPayloadKg()</kbd> method, introduce a more general method and <kbd>enum</kbd> for supporting the metric system of weight units:</li>
</ol>
<pre>        int getPayload(WeigthUnit weightUnit);<br/>        enum WeigthUnit { Pound, Kilogram }</pre>
<p style="padding-left: 60px">Such an enhancement allows you to have more flexibility in future.</p>
<ol start="3">
<li>Deprecate the <kbd>getPayloadPounds()</kbd> method and add a Javadoc with explanations:</li>
</ol>
<pre>        /**<br/>        * Returns the payload of the truck.<br/>        *<br/>        * @return the payload of the truck in the specified units<br/>        * of weight measurements<br/>        * @deprecated As of API 2.1, to avoid adding methods<br/>        * for each possible weight unit,<br/>        * use {@link #getPayload(WeigthUnit weightUnit)} instead.<br/>        */<br/>        @Deprecated(since = "2.1", forRemoval = true)<br/>        int getPayloadPounds();</pre>
<p style="padding-left: 60px">Each of the methods in the <kbd>@Deprecated</kbd> annotation is optional.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>If we compile the preceding code, there will be a warning <em>this method has been deprecated and marked for removal</em> at every place of its implementation.</p>
<p>If the <kbd>forRemoval()</kbd> method is not present or set to <kbd>false</kbd>, the warning message would say <em>has been deprecated</em> only.</p>
<p>To avoid the warning, we need to either avoid using the deprecated method or suppress the warning as described earlier.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">There's more...</h1>
                </header>
            
            <article>
                
<p>In Java 9, both--the Javadoc tag <kbd>@deprecated</kbd> and <kbd>@Deprecated</kbd> annotation--are required. The presence of only one of them is considered an error.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Using HTML5 in Javadocs</h1>
                </header>
            
            <article>
                
<p>In this recipe, you will learn about the usage of HTML5 tags in the Javadoc comments in Java 9.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p>There are plenty of sources on the Internet that describe HTML5 tags. Since Java 9, one can use any one of them in Javadoc comments.</p>
<p>HTML5 provides better browser compatibility. It is also more mobile-friendly than its predecessor, HTML4. But to take advantage of HTML5, one has to specify the <kbd>-html5</kbd> parameter during Javadoc generation. Otherwise, only HTM4-style comments will continue to be supported.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p>Here is an example of the HTML5 tags used for Javadoc comments:</p>
<pre>/**<br/>&lt;h2&gt;Returns the weight of the car.&lt;/h2&gt;<br/>&lt;article&gt;<br/>  &lt;h3&gt;If life would be often that easy&lt;/h3&gt;<br/>  &lt;p&gt;<br/>    Do you include unit of measurement into the method name or not?<br/>  &lt;/p&gt;<br/>  &lt;p&gt;<br/>    The new signature demonstrates extensible design of an interface.<br/>  &lt;/p&gt;<br/>&lt;/article&gt;<br/>&lt;aside&gt;<br/>  &lt;p&gt; A few other examples could be found<br/>    &lt;a href="http://www.nicksamoylov.com/cat/programming/"&gt;here&lt;/a&gt;.<br/>  &lt;/p&gt;<br/>&lt;/aside&gt;<br/>* @param weightUnit - an element of the enum Car.WeightUnit<br/>* @return the weight of the car in the specified units of weight<br/>*/<br/>int getMaxWeight(WeigthUnit weightUnit);</pre>
<p>If you are using IntelliJ IDEA, go to <span class="packt_screen">Tools</span> | <span class="packt_screen">Generate JavaDoc...</span> and set the <kbd>-html5</kbd> value in the <span class="packt_screen">Other command line arguments</span> field and click on <span class="packt_screen">OK</span>. Without an IDE, use the following command:</p>
<pre><strong>javadoc [options] [packagenames] [sourcefiles] [@files]</strong></pre>
<p>Consider the following example:</p>
<div class="CDPAlignCenter CDPAlign"><img height="51" width="497" class="image-border" src="assets/64f67412-aa5d-4f8b-ae17-162cac5bb934.png"/></div>
<p>Here, <kbd>src</kbd> is the folder that contains the source code in the <kbd>com</kbd> subfolder, and <kbd>api</kbd> is a folder in the current directory where Javadoc is going to be stored. The <kbd>com.cookbook.oop</kbd> is the package for which you want to generate Javadoc.</p>
<p>The resulting Javadoc will look like this:</p>
<div class="CDPAlignCenter CDPAlign"><img height="177" width="680" class=" image-border" src="assets/113f566e-6e34-4e39-9189-c957049dbbd3.png"/></div>
<p class="mce-root CDPAlignLeft CDPAlign">The preceding description is taken from the text inside tags <kbd>&lt;h2&gt;</kbd>, but its font is not different from other lines. Here's how the full description will look:</p>
<div class="CDPAlignCenter CDPAlign"><img height="293" width="459" class=" image-border" src="assets/5462c68d-d7c2-41ce-aae5-edc7aebeb87c.png"/></div>
<p>You can see how prominently the text in tags <kbd>&lt;h2&gt;</kbd> and <kbd>&lt;h3&gt;</kbd> is presented and the <kbd>here</kbd> link is highlighted and can be clicked.</p>


            </article>

            
        </section>
    </body></html>