- en: Chapter 5. Contexts and Dependency Injection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Contexts and Dependency Injection** (**CDI**) was added to the Java EE specification
    in Java EE 6\. It provides several advantages that were previously unavailable
    to Java EE developers, such as allowing any JavaBean to be used as a **JavaServer
    Faces** (**JSF**) managed bean, including stateless and stateful session beans.
    As the name implies, CDI simplifies dependency injection in Java EE applications.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Named beans
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dependency injection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Scopes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Qualifiers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Named beans
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: CDI provides us with the ability to name our beans via the `@Named` annotation.
    Named beans allow us to easily inject our beans into other classes that depend
    on them (see the *Dependency injection* section), and to easily refer to them
    from JSF pages via the unified expression language.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example shows us the `@Named` annotation in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'As we can see, all we need to do to name our class is to decorate it with the
    `@Named` annotation. By default, the name of the bean will be the class name with
    its first letter switched to lowercase; in our example, the name of the bean would
    be `customer`. If we wish to use a different name, we can do so by setting the
    `value` attribute of the `@Named` annotation. For example, if we wanted to use
    the name `customerBean` for our bean in the previous example, we could have done
    so by modifying the `@Named` annotation as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Or, we could have simply used the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Since the `value` attribute's name does not need to be specified, if we don't
    use an attribute name, then `value` is implied.
  prefs: []
  type: TYPE_NORMAL
- en: 'The CDI name can be used to access our bean from JSF pages using the unified
    expression language, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: As we can see, named beans are accessed from JSF pages exactly like standard
    JSF managed beans. This allows JSF to access any named bean, decoupling the Java
    code from the JSF API.
  prefs: []
  type: TYPE_NORMAL
- en: 'When deployed and executed, our simple application looks like the following
    screenshot (shown after the user has entered some data):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Named beans](img/6886EN_05_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Dependency injection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Dependency injection is a technique that is used to supply external dependencies
    to a Java class. Java EE 5 introduced dependency injection via the `@Resource`
    annotation; however, this annotation is limited to injecting resources such as
    database connections, JMS resources, and so on. CDI includes the `@Inject` annotation,
    which can be used to inject instances of Java classes into any dependent objects.
  prefs: []
  type: TYPE_NORMAL
- en: JSF applications typically follow the **Model-View-Controller** (**MVC**) design
    pattern. As such, some JSF-managed beans frequently take on the role of controllers
    in the pattern, while others take on the role of the model. This approach typically
    requires the controller-managed bean to have access to one or more of the model-managed
    beans.
  prefs: []
  type: TYPE_NORMAL
- en: 'Because of the pattern described in the previous paragraph, one of the most
    frequently asked JSF questions is how to access one managed bean from another.
    There is more than one way to do this; however, before CDI, none of the ways were
    straightforward. Before CDI, the easiest way was to declare a managed property
    in the controller-managed bean, which required modifying the application''s `faces-config.xml`
    file; another approach was to use code like the following one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example, `someBean` is the name of the bean as specified in the application''s
    `faces-config.xml`. As we can see, neither approach is simple or easy to remember.
    Fortunately, code like this is not needed anymore thanks to CDI''s dependency
    injection capabilities, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Notice that all we had to do to initialize our customer instance was to decorate
    it with the `@Inject` annotation. When the bean is constructed by the application
    server, an instance of the `Customer` bean is automatically injected into this
    field. Notice that the injected bean is used in the `saveCustomer()` method. As
    we can see, CDI makes accessing one bean from another a snap, a far cry from the
    code we had to use in previous versions of the Java EE specification.
  prefs: []
  type: TYPE_NORMAL
- en: Working with CDI Qualifiers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In some instances, the type of the bean we wish to inject into our code may
    be an interface or a Java superclass, but we may be interested in injecting a
    subclass or a class implementing the interface. For cases like this, CDI provides
    qualifiers that we can use to indicate the specific type we wish to inject into
    our code.
  prefs: []
  type: TYPE_NORMAL
- en: A CDI qualifier is an annotation that must be decorated with the `@Qualifier`
    annotation. This annotation can then be used to decorate the specific subclass
    or interface implementation that we wish to qualify. Additionally, the injected
    field in the client code needs to be decorated with the qualifier as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'Suppose our application could have a special kind of customer; for example,
    frequent customers could be given the status of premium customers. To handle these
    premium customers, we could extend our `Customer` named bean and decorate it with
    the following qualifier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Like we mentioned previously, qualifiers are standard annotations; they typically
    have retention of runtime and can target methods, fields, parameters, or types,
    as illustrated in the previous example by the value of the `@Retention` annotation.
    The only difference between a qualifier and a standard annotation is that qualifiers
    are decorated with the `@Qualifier` annotation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once we have our qualifier in place, we need to use it to decorate the specific
    subclass or interface implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Once we have decorated the specific instance that we need to qualify, we can
    use our qualifiers in the client code to specify the exact type of dependency
    we need:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: As we used our `@Premium` qualifier to decorate the customer field, an instance
    of `PremiumCustomer` is injected into that field, since this class is also decorated
    with the `@Premium qualifier`.
  prefs: []
  type: TYPE_NORMAL
- en: 'As far as our JSF pages go, we simply access our named bean as usual, using
    its name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we are using the default name for our bean, which is the class
    name with the first letter switched to lowercase.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our simple application renders and acts just like a plain (that is, not using
    CDI) JSF application as far as the user is concerned. Take a look at the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Working with CDI Qualifiers](img/6886EN_05_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Named bean scopes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Just like JSF-managed beans, CDI named beans are scoped. This means that CDI
    beans are contextual objects. When a named bean is needed, either because of injection
    or because it is referred from a JSF page, CDI looks for an instance of the bean
    in the scope it belongs to and injects it to the dependent code. If no instance
    is found, one is created and stored in the appropriate scope for future use. The
    different scopes are the context in which the bean exists.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following table lists the different valid CDI scopes:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Scope | Annotation | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Request | `@RequestScoped` | Request scoped beans are shared through the
    duration of a single request. A single request could refer to an HTTP request,
    an invocation to a method in an EJB, a web service invocation, or sending a JMS
    message to a message-driven bean. |'
  prefs: []
  type: TYPE_TB
- en: '| Conversation | `@ConversationScoped` | The conversation scope can span multiple
    requests, but it is typically shorter than the session scope. |'
  prefs: []
  type: TYPE_TB
- en: '| Session | `@SessionScoped` | Session scoped beans are shared across all requests
    in an HTTP session. Each user of an application gets its own instance of a session
    scoped bean. |'
  prefs: []
  type: TYPE_TB
- en: '| Application | `@ApplicationScoped` | Application scoped beans live through
    the whole application lifetime. Beans in this scope are shared across user sessions.
    |'
  prefs: []
  type: TYPE_TB
- en: '| Dependent | `@Dependent` | Dependent scoped beans are not shared; any time
    a dependent scoped bean is injected, a new instance is created. |'
  prefs: []
  type: TYPE_TB
- en: As we can see, CDI includes all scopes supported by JSF; it also adds a couple
    of its own. CDI's request scope differs from JSF's request scope in which a request
    does not necessarily refer to an HTTP request; it could simply be an invocation
    on an EJB method, a web service invocation, or sending a JMS message to a message
    driven bean.
  prefs: []
  type: TYPE_NORMAL
- en: The conversation scope does not exist in JSF. This scope is longer than the
    request scope but shorter than the session scope, and it typically spans three
    or more pages. Classes wishing to access a conversation scoped bean must have
    an instance of `javax.enterprise.context.Conversation` injected. At the point
    where we want to start the conversation, the `begin()` method must be invoked
    on this object. At the point where we want to end the conversation, the `end()`
    method must be invoked on it.
  prefs: []
  type: TYPE_NORMAL
- en: CDI's session scope behaves just like its JSF counterpart. The lifecycle of
    session scoped beans is tied to the life of an HTTP session.
  prefs: []
  type: TYPE_NORMAL
- en: CDI's application scope also behaves just like the equivalent scope in JSF.
    Application scoped beans are tied to the life of an application. A single instance
    of each application scoped beans exists per application, which means that the
    same instance is accessible to all HTTP sessions.
  prefs: []
  type: TYPE_NORMAL
- en: Just like the conversation scope, CDI's dependent scope does not exist in JSF.
    A new dependent scoped bean is instantiated every time it is needed, usually,
    when it is injected into a class that depends on it.
  prefs: []
  type: TYPE_NORMAL
- en: Suppose we wanted to have a user enter some data that would be stored in a single
    named bean; however, this bean has several fields and therefore, we would like
    to split the data entry into several pages. This is a fairly common situation
    and one that was not easy to handle using previous versions of JSF (JSF 2.2 added
    Faces Flows to solve this problem; refer to [Chapter 2](ch02.html "Chapter 2. JavaServer
    Faces"), *JavaServer Faces*) or the servlet API, for that matter. The reason this
    situation is not trivial to manage using these technologies is that we can only
    put a class in the request scope, in which case, the class is destroyed after
    every single request, losing its data in the process; or in session scope, in
    which the class sticks around in the memory long after it is needed.
  prefs: []
  type: TYPE_NORMAL
- en: 'For cases like this, CDI''s conversation scope is a good solution, as shown
    in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: We declare that our bean is conversation scoped by decorating it with the `@ConversationScoped`
    annotation. Conversation scoped beans also need to implement `java.io.Serializable`.
    Other than these two requirements, there is nothing special about our code. It
    is a simple JavaBean code with private properties and corresponding getter and
    setter methods.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We are using the Apache `commons-lang` library in our code to easily implement
    a `toString()` method for our bean. The `commons-lang` library has several utility
    methods like this that implement frequently needed, tedious to code functionality.
    commons-lang is available in the central Maven repositories at [http://commons.apache.org/lang](http://commons.apache.org/lang).
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition to having our conversation scoped bean injected, our client code
    must also have an instance of `javax.enterprise.context.Conversation` injected,
    as illustrated in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Conversations can be either long running or transient. Transient conversations
    finish at the end of a request. Long running conversations span multiple requests.
    In most cases, we will use long running conversations to hold a reference to a
    conversation scoped bean across multiple HTTP requests in a web application.
  prefs: []
  type: TYPE_NORMAL
- en: A long running conversation starts when the `begin()` method is invoked in the
    injected conversation instance, and it ends when we invoke the `end()` method
    on this same object.
  prefs: []
  type: TYPE_NORMAL
- en: 'JSF pages simply access our CDI beans as usual:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: As we navigate from one page to the next, we keep the same instance of our conversation
    scoped bean. Therefore, all user-entered data remains. When the `end()` method
    is called on our conversation bean, the conversation ends and our conversation
    scoped bean is destroyed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Keeping our bean in the conversation scope simplifies the task of implementing
    wizard-style user interfaces, where data can be entered across several pages,
    as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Named bean scopes](img/6886EN_05_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'In our example, after clicking on the **Next** button on the first page, we
    can see our partially populated bean in the GlassFish log:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'At this point, the second page in our simple wizard is displayed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Named bean scopes](img/6886EN_05_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: By clicking on **Next**, we can see that additional fields are populated in
    our conversation scoped bean.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'When we submit the third page in our wizard, additional bean properties corresponding
    to the fields on that page are populated, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Named bean scopes](img/6886EN_05_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'When we are at the point where we don''t need to keep the customer information
    in mind anymore, we need to call the `end()` method on the conversation bean that
    was injected into our code. This is exactly what we do in our code before displaying
    the confirmation page:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: After the request to show the confirmation page is completed, our conversation
    scoped bean is destroyed, as we invoked the `end()` method in our injected `Conversation`
    class.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we provided an introduction to Contexts and Dependency Injection.
    We covered how JSF pages can access CDI named beans as if they were JSF managed
    beans. We also covered how CDI makes it easy to inject dependencies into our code
    via the `@Inject` annotation. Additionally, we explained how we can use qualifiers
    to determine the specific implementation of a dependency to be injected into our
    code. Finally, we covered all the scopes that a CDI bean can be placed into, which
    include the equivalents to all the JSF scopes, plus an additional two scopes not
    included in JSF, namely, the conversation scope and the dependent scope.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will cover processing JavaScript Object Notation (JSON)
    formatted data using the new JSON-P API.
  prefs: []
  type: TYPE_NORMAL
