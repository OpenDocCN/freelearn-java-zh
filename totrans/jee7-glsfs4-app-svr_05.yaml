- en: Chapter 5. Contexts and Dependency Injection
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第5章。上下文和依赖注入
- en: '**Contexts and Dependency Injection** (**CDI**) was added to the Java EE specification
    in Java EE 6\. It provides several advantages that were previously unavailable
    to Java EE developers, such as allowing any JavaBean to be used as a **JavaServer
    Faces** (**JSF**) managed bean, including stateless and stateful session beans.
    As the name implies, CDI simplifies dependency injection in Java EE applications.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '**上下文和依赖注入**（**CDI**）在Java EE 6中添加到Java EE规范中。它为Java EE开发者提供了之前不可用的几个优点，例如允许任何JavaBean用作**JavaServer
    Faces**（**JSF**）管理Bean，包括无状态和有状态会话Bean。正如其名所示，CDI简化了Java EE应用程序中的依赖注入。'
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Named beans
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 命名豆
- en: Dependency injection
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 依赖注入
- en: Scopes
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 范围
- en: Qualifiers
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标准化
- en: Named beans
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 命名豆
- en: CDI provides us with the ability to name our beans via the `@Named` annotation.
    Named beans allow us to easily inject our beans into other classes that depend
    on them (see the *Dependency injection* section), and to easily refer to them
    from JSF pages via the unified expression language.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: CDI通过`@Named`注解为我们提供了命名Bean的能力。命名Bean允许我们轻松地将我们的Bean注入到依赖它们的其他类中（参见*依赖注入*部分），并且可以通过统一表达式语言轻松地从JSF页面引用它们。
- en: 'The following example shows us the `@Named` annotation in action:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例展示了`@Named`注解的实际应用：
- en: '[PRE0]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'As we can see, all we need to do to name our class is to decorate it with the
    `@Named` annotation. By default, the name of the bean will be the class name with
    its first letter switched to lowercase; in our example, the name of the bean would
    be `customer`. If we wish to use a different name, we can do so by setting the
    `value` attribute of the `@Named` annotation. For example, if we wanted to use
    the name `customerBean` for our bean in the previous example, we could have done
    so by modifying the `@Named` annotation as follows:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，我们只需要用`@Named`注解装饰我们的类来命名我们的类。默认情况下，Bean的名称将是类名，其首字母转换为小写；在我们的例子中，Bean的名称将是`customer`。如果我们想使用不同的名称，我们可以通过设置`@Named`注解的`value`属性来实现。例如，如果我们想在前面的例子中使用`customerBean`作为我们的Bean名称，我们可以通过修改`@Named`注解如下所示：
- en: '[PRE1]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Or, we could have simply used the following code:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，我们也可以简单地使用以下代码：
- en: '[PRE2]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Since the `value` attribute's name does not need to be specified, if we don't
    use an attribute name, then `value` is implied.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`value`属性名称不需要指定，如果我们不使用属性名称，则隐含`value`。
- en: 'The CDI name can be used to access our bean from JSF pages using the unified
    expression language, as shown in the following code:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: CDI名称可用于通过统一表达式语言从JSF页面访问我们的Bean，如下面的代码所示：
- en: '[PRE3]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: As we can see, named beans are accessed from JSF pages exactly like standard
    JSF managed beans. This allows JSF to access any named bean, decoupling the Java
    code from the JSF API.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，命名Bean从JSF页面访问的方式与标准JSF管理Bean完全相同。这允许JSF访问任何命名Bean，将Java代码与JSF API解耦。
- en: 'When deployed and executed, our simple application looks like the following
    screenshot (shown after the user has entered some data):'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 当部署和执行时，我们的简单应用程序看起来如下截图（在用户输入一些数据后显示）：
- en: '![Named beans](img/6886EN_05_01.jpg)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![命名豆](img/6886EN_05_01.jpg)'
- en: Dependency injection
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 依赖注入
- en: Dependency injection is a technique that is used to supply external dependencies
    to a Java class. Java EE 5 introduced dependency injection via the `@Resource`
    annotation; however, this annotation is limited to injecting resources such as
    database connections, JMS resources, and so on. CDI includes the `@Inject` annotation,
    which can be used to inject instances of Java classes into any dependent objects.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 依赖注入是一种用于向Java类提供外部依赖的技术。Java EE 5通过`@Resource`注解引入了依赖注入；然而，此注解仅限于注入资源，如数据库连接、JMS资源等。CDI包括`@Inject`注解，可用于将Java类的实例注入到任何依赖对象中。
- en: JSF applications typically follow the **Model-View-Controller** (**MVC**) design
    pattern. As such, some JSF-managed beans frequently take on the role of controllers
    in the pattern, while others take on the role of the model. This approach typically
    requires the controller-managed bean to have access to one or more of the model-managed
    beans.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: JSF应用程序通常遵循**模型-视图-控制器**（**MVC**）设计模式。因此，一些JSF管理Bean经常在模式中扮演控制器的角色，而其他Bean则扮演模型的角色。这种方法通常要求控制器管理Bean能够访问一个或多个模型管理Bean。
- en: 'Because of the pattern described in the previous paragraph, one of the most
    frequently asked JSF questions is how to access one managed bean from another.
    There is more than one way to do this; however, before CDI, none of the ways were
    straightforward. Before CDI, the easiest way was to declare a managed property
    in the controller-managed bean, which required modifying the application''s `faces-config.xml`
    file; another approach was to use code like the following one:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 由于前一段描述的模式，最常被问到的JSF问题之一是如何从一个管理bean访问另一个。有不止一种方法可以实现这一点；然而，在CDI之前，没有一种方法简单直接。在CDI之前，最简单的方法是在控制器管理bean中声明一个管理属性，这需要修改应用程序的`faces-config.xml`文件；另一种方法是使用如下代码：
- en: '[PRE4]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'In this example, `someBean` is the name of the bean as specified in the application''s
    `faces-config.xml`. As we can see, neither approach is simple or easy to remember.
    Fortunately, code like this is not needed anymore thanks to CDI''s dependency
    injection capabilities, as shown in the following code:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，`someBean`是`faces-config.xml`文件中指定的bean的名称。正如我们所看到的，这两种方法都不简单，也不容易记住。幸运的是，由于CDI的依赖注入功能，像这样的代码现在不再需要了，如下面的代码所示：
- en: '[PRE5]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Notice that all we had to do to initialize our customer instance was to decorate
    it with the `@Inject` annotation. When the bean is constructed by the application
    server, an instance of the `Customer` bean is automatically injected into this
    field. Notice that the injected bean is used in the `saveCustomer()` method. As
    we can see, CDI makes accessing one bean from another a snap, a far cry from the
    code we had to use in previous versions of the Java EE specification.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们初始化客户实例所需要做的只是用`@Inject`注解装饰它。当bean由应用服务器构建时，一个`Customer` bean的实例会自动注入到这个字段中。注意，注入的bean在`saveCustomer()`方法中被使用。正如我们所看到的，CDI使得从一个bean访问另一个bean变得非常简单，与之前Java
    EE规范版本中必须使用的代码相比，差距甚远。
- en: Working with CDI Qualifiers
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用CDI限定符
- en: In some instances, the type of the bean we wish to inject into our code may
    be an interface or a Java superclass, but we may be interested in injecting a
    subclass or a class implementing the interface. For cases like this, CDI provides
    qualifiers that we can use to indicate the specific type we wish to inject into
    our code.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，我们希望注入到代码中的bean的类型可能是一个接口或Java超类，但我们可能对注入子类或实现该接口的类感兴趣。对于这种情况，CDI提供了限定符，我们可以使用它们来指明我们希望注入到代码中的特定类型。
- en: A CDI qualifier is an annotation that must be decorated with the `@Qualifier`
    annotation. This annotation can then be used to decorate the specific subclass
    or interface implementation that we wish to qualify. Additionally, the injected
    field in the client code needs to be decorated with the qualifier as well.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: CDI限定符是一个必须用`@Qualifier`注解装饰的注解。这个注解可以用来装饰我们希望限定的特定子类或接口实现。此外，客户端代码中的注入字段也需要用限定符装饰。
- en: 'Suppose our application could have a special kind of customer; for example,
    frequent customers could be given the status of premium customers. To handle these
    premium customers, we could extend our `Customer` named bean and decorate it with
    the following qualifier:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们的应用程序可能有一种特殊的客户类型；例如，常客可能会被赋予高级客户的身份。为了处理这些高级客户，我们可以扩展我们的`Customer`命名bean，并用以下限定符装饰它：
- en: '[PRE6]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Like we mentioned previously, qualifiers are standard annotations; they typically
    have retention of runtime and can target methods, fields, parameters, or types,
    as illustrated in the previous example by the value of the `@Retention` annotation.
    The only difference between a qualifier and a standard annotation is that qualifiers
    are decorated with the `@Qualifier` annotation.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们之前提到的，限定符是标准的注释；它们通常具有运行时保留功能，可以针对方法、字段、参数或类型进行标注，正如前一个示例中通过`@Retention`注解的值所展示的那样。限定符与标准注释之间的唯一区别是，限定符被`@Qualifier`注解所装饰。
- en: 'Once we have our qualifier in place, we need to use it to decorate the specific
    subclass or interface implementation:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们设置了限定符，我们需要用它来装饰特定的子类或接口实现：
- en: '[PRE7]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Once we have decorated the specific instance that we need to qualify, we can
    use our qualifiers in the client code to specify the exact type of dependency
    we need:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们装饰了需要限定的特定实例，我们就可以在客户端代码中使用我们的限定符来指定所需的精确依赖类型：
- en: '[PRE8]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: As we used our `@Premium` qualifier to decorate the customer field, an instance
    of `PremiumCustomer` is injected into that field, since this class is also decorated
    with the `@Premium qualifier`.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们使用`@Premium`限定符来装饰客户字段，因此将`PremiumCustomer`类的实例注入到该字段中，因为这个类也被装饰了`@Premium限定符`。
- en: 'As far as our JSF pages go, we simply access our named bean as usual, using
    its name:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 就我们的JSF页面而言，我们像往常一样通过名称访问我们的命名bean：
- en: '[PRE9]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: In this example, we are using the default name for our bean, which is the class
    name with the first letter switched to lowercase.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们使用bean的默认名称，即类名，首字母小写。
- en: 'Our simple application renders and acts just like a plain (that is, not using
    CDI) JSF application as far as the user is concerned. Take a look at the following
    screenshot:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 从用户的角度来看，我们的简单应用程序渲染和操作就像一个普通的（即不使用CDI）JSF应用程序一样。请看下面的屏幕截图：
- en: '![Working with CDI Qualifiers](img/6886EN_05_02.jpg)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![与CDI限定符一起工作](img/6886EN_05_02.jpg)'
- en: Named bean scopes
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 命名bean作用域
- en: Just like JSF-managed beans, CDI named beans are scoped. This means that CDI
    beans are contextual objects. When a named bean is needed, either because of injection
    or because it is referred from a JSF page, CDI looks for an instance of the bean
    in the scope it belongs to and injects it to the dependent code. If no instance
    is found, one is created and stored in the appropriate scope for future use. The
    different scopes are the context in which the bean exists.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 就像JSF管理的bean一样，CDI命名bean也有作用域。这意味着CDI bean是上下文对象。当需要命名bean时，无论是由于注入还是因为它被JSF页面引用，CDI都会在该bean所属的作用域中查找bean的实例，并将其注入到依赖代码中。如果没有找到实例，就会创建一个并存储在适当的作用域中供将来使用。不同的作用域是bean存在的上下文。
- en: 'The following table lists the different valid CDI scopes:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 下表列出了不同的有效CDI作用域：
- en: '| Scope | Annotation | Description |'
  id: totrans-48
  prefs: []
  type: TYPE_TB
  zh: '| 作用域 | 注解 | 描述 |'
- en: '| --- | --- | --- |'
  id: totrans-49
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| Request | `@RequestScoped` | Request scoped beans are shared through the
    duration of a single request. A single request could refer to an HTTP request,
    an invocation to a method in an EJB, a web service invocation, or sending a JMS
    message to a message-driven bean. |'
  id: totrans-50
  prefs: []
  type: TYPE_TB
  zh: '| 请求 | `@RequestScoped` | 请求作用域的bean在单个请求的持续期间共享。单个请求可能指的是HTTP请求、对EJB方法的方法调用、Web服务调用或向消息驱动bean发送JMS消息。|'
- en: '| Conversation | `@ConversationScoped` | The conversation scope can span multiple
    requests, but it is typically shorter than the session scope. |'
  id: totrans-51
  prefs: []
  type: TYPE_TB
  zh: '| 会话 | `@ConversationScoped` | 会话作用域可以跨越多个请求，但它通常比会话作用域短。|'
- en: '| Session | `@SessionScoped` | Session scoped beans are shared across all requests
    in an HTTP session. Each user of an application gets its own instance of a session
    scoped bean. |'
  id: totrans-52
  prefs: []
  type: TYPE_TB
  zh: '| 会话 | `@SessionScoped` | 会话作用域的bean在HTTP会话的所有请求之间共享。每个应用程序用户都获得自己的会话作用域bean实例。|'
- en: '| Application | `@ApplicationScoped` | Application scoped beans live through
    the whole application lifetime. Beans in this scope are shared across user sessions.
    |'
  id: totrans-53
  prefs: []
  type: TYPE_TB
  zh: '| 应用 | `@ApplicationScoped` | 应用作用域的bean在整个应用程序生命周期中存在。此作用域中的bean在用户会话之间共享。|'
- en: '| Dependent | `@Dependent` | Dependent scoped beans are not shared; any time
    a dependent scoped bean is injected, a new instance is created. |'
  id: totrans-54
  prefs: []
  type: TYPE_TB
  zh: '| 依赖 | `@Dependent` | 依赖作用域的bean不共享；每次注入依赖作用域的bean时，都会创建一个新的实例。|'
- en: As we can see, CDI includes all scopes supported by JSF; it also adds a couple
    of its own. CDI's request scope differs from JSF's request scope in which a request
    does not necessarily refer to an HTTP request; it could simply be an invocation
    on an EJB method, a web service invocation, or sending a JMS message to a message
    driven bean.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，CDI包括了JSF支持的所有作用域；它还增加了一些自己的作用域。CDI的请求作用域与JSF的请求作用域不同，其中请求不一定指的是HTTP请求；它可能只是一个对EJB方法的调用、一个Web服务调用或向消息驱动bean发送JMS消息。
- en: The conversation scope does not exist in JSF. This scope is longer than the
    request scope but shorter than the session scope, and it typically spans three
    or more pages. Classes wishing to access a conversation scoped bean must have
    an instance of `javax.enterprise.context.Conversation` injected. At the point
    where we want to start the conversation, the `begin()` method must be invoked
    on this object. At the point where we want to end the conversation, the `end()`
    method must be invoked on it.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: JSF中不存在会话作用域。这个作用域比请求作用域长，但比会话作用域短，通常跨越三页或更多。希望访问会话作用域bean的类必须注入`javax.enterprise.context.Conversation`实例。在我们想要开始会话的点，必须在这个对象上调用`begin()`方法。在我们想要结束会话的点，必须在这个对象上调用`end()`方法。
- en: CDI's session scope behaves just like its JSF counterpart. The lifecycle of
    session scoped beans is tied to the life of an HTTP session.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: CDI的会话作用域的行为与其JSF对应物相同。会话作用域bean的生命周期与HTTP会话的生命周期绑定。
- en: CDI's application scope also behaves just like the equivalent scope in JSF.
    Application scoped beans are tied to the life of an application. A single instance
    of each application scoped beans exists per application, which means that the
    same instance is accessible to all HTTP sessions.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: CDI的应用程序作用域的行为也与其JSF中的等效作用域相同。应用程序作用域bean与应用程序的生命周期绑定。每个应用程序都有一个应用程序作用域bean的单例存在，这意味着相同的实例对所有HTTP会话都是可访问的。
- en: Just like the conversation scope, CDI's dependent scope does not exist in JSF.
    A new dependent scoped bean is instantiated every time it is needed, usually,
    when it is injected into a class that depends on it.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 就像对话作用域一样，CDI的依赖作用域在JSF中不存在。每次需要时都会实例化一个新的依赖作用域bean，通常是在将其注入依赖于它的类时。
- en: Suppose we wanted to have a user enter some data that would be stored in a single
    named bean; however, this bean has several fields and therefore, we would like
    to split the data entry into several pages. This is a fairly common situation
    and one that was not easy to handle using previous versions of JSF (JSF 2.2 added
    Faces Flows to solve this problem; refer to [Chapter 2](ch02.html "Chapter 2. JavaServer
    Faces"), *JavaServer Faces*) or the servlet API, for that matter. The reason this
    situation is not trivial to manage using these technologies is that we can only
    put a class in the request scope, in which case, the class is destroyed after
    every single request, losing its data in the process; or in session scope, in
    which the class sticks around in the memory long after it is needed.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想要让用户输入一些将被存储在单个命名bean中的数据；然而，这个bean有几个字段，因此，我们希望将数据输入分成几个页面。这是一个相当常见的情况，并且使用JSF的先前版本（JSF
    2.2添加了Faces Flows来解决这个问题；请参阅[第2章](ch02.html "第2章。JavaServer Faces")，*JavaServer
    Faces*）或servlet API处理起来并不容易。这种情况不容易管理的原因是，我们只能将类放在请求作用域中，在这种情况下，类在每次请求后都会被销毁，从而丢失其数据；或者放在会话作用域中，在这种情况下，类在所需之后很长时间仍然留在内存中。
- en: 'For cases like this, CDI''s conversation scope is a good solution, as shown
    in the following code:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 对于此类情况，CDI的对话作用域是一个很好的解决方案，如下面的代码所示：
- en: '[PRE10]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: We declare that our bean is conversation scoped by decorating it with the `@ConversationScoped`
    annotation. Conversation scoped beans also need to implement `java.io.Serializable`.
    Other than these two requirements, there is nothing special about our code. It
    is a simple JavaBean code with private properties and corresponding getter and
    setter methods.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过使用`@ConversationScoped`注解来装饰我们的bean，声明我们的bean是会话作用域的。会话作用域bean还需要实现`java.io.Serializable`。除了这两个要求外，我们的代码没有特别之处。它是一个简单的JavaBean代码，具有私有属性和相应的getter和setter方法。
- en: Note
  id: totrans-64
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: We are using the Apache `commons-lang` library in our code to easily implement
    a `toString()` method for our bean. The `commons-lang` library has several utility
    methods like this that implement frequently needed, tedious to code functionality.
    commons-lang is available in the central Maven repositories at [http://commons.apache.org/lang](http://commons.apache.org/lang).
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在我们的代码中使用Apache `commons-lang`库来轻松实现bean的`toString()`方法。`commons-lang`库有多个这样的实用方法，实现了频繁需要的、编写起来繁琐的功能。`commons-lang`可在中央Maven仓库中找到，网址为[http://commons.apache.org/lang](http://commons.apache.org/lang)。
- en: 'In addition to having our conversation scoped bean injected, our client code
    must also have an instance of `javax.enterprise.context.Conversation` injected,
    as illustrated in the following example:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 除了注入我们的作用域为对话的bean外，我们的客户端代码还必须注入一个`javax.enterprise.context.Conversation`实例，如下面的示例所示：
- en: '[PRE11]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Conversations can be either long running or transient. Transient conversations
    finish at the end of a request. Long running conversations span multiple requests.
    In most cases, we will use long running conversations to hold a reference to a
    conversation scoped bean across multiple HTTP requests in a web application.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 对话可以是长运行的或短暂的。短暂的对话在请求结束时结束。长运行对话跨越多个请求。在大多数情况下，我们将使用长运行对话来在Web应用程序中跨多个HTTP请求保持对作用域为对话的bean的引用。
- en: A long running conversation starts when the `begin()` method is invoked in the
    injected conversation instance, and it ends when we invoke the `end()` method
    on this same object.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 长运行对话在注入的对话实例中调用`begin()`方法时开始，并在我们调用同一对象的`end()`方法时结束。
- en: 'JSF pages simply access our CDI beans as usual:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: JSF页面可以像访问JSF管理bean一样访问我们的CDI bean：
- en: '[PRE12]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: As we navigate from one page to the next, we keep the same instance of our conversation
    scoped bean. Therefore, all user-entered data remains. When the `end()` method
    is called on our conversation bean, the conversation ends and our conversation
    scoped bean is destroyed.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们从一页导航到下一页时，我们保持我们的会话作用域bean的同一实例。因此，所有用户输入的数据都保持不变。当在会话bean上调用`end()`方法时，会话结束，我们的会话作用域bean被销毁。
- en: 'Keeping our bean in the conversation scope simplifies the task of implementing
    wizard-style user interfaces, where data can be entered across several pages,
    as shown in the following screenshot:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 将我们的bean保持在会话作用域中简化了实现向导式用户界面的任务，如图所示，数据可以在多个页面中输入：
- en: '![Named bean scopes](img/6886EN_05_03.jpg)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![命名bean作用域](img/6886EN_05_03.jpg)'
- en: 'In our example, after clicking on the **Next** button on the first page, we
    can see our partially populated bean in the GlassFish log:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的示例中，在第一页上点击**下一步**按钮后，我们可以在GlassFish日志中看到我们的部分填充的bean：
- en: '[PRE13]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'At this point, the second page in our simple wizard is displayed as follows:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们的简单向导的第二页显示如下：
- en: '![Named bean scopes](img/6886EN_05_04.jpg)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![命名bean作用域](img/6886EN_05_04.jpg)'
- en: By clicking on **Next**, we can see that additional fields are populated in
    our conversation scoped bean.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 点击**下一步**，我们可以看到在我们的会话作用域bean中填充了额外的字段。
- en: '[PRE14]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'When we submit the third page in our wizard, additional bean properties corresponding
    to the fields on that page are populated, as shown in the following screenshot:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在向导的第三页提交时，与该页面上字段对应的额外bean属性被填充，如图所示：
- en: '![Named bean scopes](img/6886EN_05_05.jpg)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
  zh: '![命名bean作用域](img/6886EN_05_05.jpg)'
- en: 'When we are at the point where we don''t need to keep the customer information
    in mind anymore, we need to call the `end()` method on the conversation bean that
    was injected into our code. This is exactly what we do in our code before displaying
    the confirmation page:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们到达不再需要记住客户信息的地方时，我们需要在注入到我们的代码中的会话bean上调用`end()`方法。这正是我们在显示确认页面之前在代码中所做的：
- en: '[PRE15]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: After the request to show the confirmation page is completed, our conversation
    scoped bean is destroyed, as we invoked the `end()` method in our injected `Conversation`
    class.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在完成显示确认页面的请求后，我们的会话作用域bean被销毁，因为我们已经在注入的`Conversation`类中调用了`end()`方法。
- en: Summary
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we provided an introduction to Contexts and Dependency Injection.
    We covered how JSF pages can access CDI named beans as if they were JSF managed
    beans. We also covered how CDI makes it easy to inject dependencies into our code
    via the `@Inject` annotation. Additionally, we explained how we can use qualifiers
    to determine the specific implementation of a dependency to be injected into our
    code. Finally, we covered all the scopes that a CDI bean can be placed into, which
    include the equivalents to all the JSF scopes, plus an additional two scopes not
    included in JSF, namely, the conversation scope and the dependent scope.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了上下文和依赖注入。我们介绍了JSF页面如何将CDI命名bean作为JSF管理bean来访问。我们还介绍了CDI如何通过`@Inject`注解使将依赖项注入到我们的代码中变得简单。此外，我们还解释了如何使用限定符来确定要注入到我们的代码中的依赖项的具体实现。最后，我们介绍了CDI
    bean可以放置的所有作用域，包括所有JSF作用域的等效作用域，以及JSF中未包含的两个额外作用域，即会话作用域和依赖作用域。
- en: In the next chapter, we will cover processing JavaScript Object Notation (JSON)
    formatted data using the new JSON-P API.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将介绍如何使用新的JSON-P API处理JavaScript对象表示法（JSON）格式的数据。
