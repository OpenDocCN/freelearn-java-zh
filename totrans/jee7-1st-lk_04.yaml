- en: Chapter 4. The Java Persistence API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This chapter deals with the improvements in APIs for communicating with data
    sources. Although Java is object oriented, it is designed to handle data of relational
    models as objects, which might pose a serious problem because the two concepts
    are not theoretically compatible. In addition to introducing you to the world
    of object-relational mapping, this chapter will show you how to manipulate (create,
    delete, search, or edit) the data of relational models as objects transparently
    and transactional. Topics covered in this chapter are:'
  prefs: []
  type: TYPE_NORMAL
- en: Java Persistence API 2.1
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Java Transaction API 1.2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Java Persistence API 2.1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Java Persistence API 2.1 Specification was developed under **JSR-338**.
    This section just gives you an overview of the improvements in the API. The complete
    document specification (for more information) can be downloaded from [http://jcp.org/aboutJava/communityprocess/final/jsr338/index.html](http://jcp.org/aboutJava/communityprocess/final/jsr338/index.html).
  prefs: []
  type: TYPE_NORMAL
- en: JPA (Java Persistence API)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**JPA** (**Java Persistence API**) is a Java specification that aims to define
    the standard features of **ORM**s (**Object-Relational Mappings**). However, JPA
    is not a product but a set of interfaces that require implementations. The most
    well-known implementations are as follows: **Hibernate**, **Toplink**, **OpenJPA,**
    and **EclipseLink**, which is the reference implementation.'
  prefs: []
  type: TYPE_NORMAL
- en: Briefly, we can say that an ORM is an API used to establish a correspondence
    between the object model and a relational database. It gives you the ability to
    handle the data of your database as if they were objects, without too much worry
    about the physical schema.
  prefs: []
  type: TYPE_NORMAL
- en: JPA in action
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'JPA is based on the concept of entities, in order to make object-relational
    mapping possible. An entity is a simple Java class (like **POJO**) with `@Entity`
    annotation (or XML equivalent) whose name is by default associated with the table
    having the same name in the database. In addition to the `@Entity` annotation,
    an entity class must have at least one primary key equivalent attribute that is
    designated with the `@Id` annotation (or XML equivalent). For the other attributes
    of the entity, the provider associates each of them to the column having the same
    name in the table, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![JPA in action](img/9235OT_04_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The parameters that indicate the database that will be associated to a set of
    entities must be defined in the persistence unit within the `persistence.xml`
    file of your application.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code is an example of the persistence unit of a Java SE Application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Concerning the manipulation of entities, JPA offers through the `EntityManager`
    interface a set of methods to create, read, update, and delete the data (see the
    following table).
  prefs: []
  type: TYPE_NORMAL
- en: 'The following table presents some methods for manipulating the entities:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Method | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `void persist(Object o)` | This is used to save the entity passed as a parameter.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `T merge(T t)` | This allows you to merge the entity passed as a parameter
    with the persistence context. It returns a managed version of the entity to be
    merged. |'
  prefs: []
  type: TYPE_TB
- en: '| `void remove(Object o)` | This allows you to delete the entity passed as
    parameter in the database. |'
  prefs: []
  type: TYPE_TB
- en: '| `T find(Class<T> type, Object o)` | This allows you to search for an entity
    using its identifier. |'
  prefs: []
  type: TYPE_TB
- en: '| `void detach(Object o)` | This allows you to detach an entity from the persistence
    context so that the changes will not be saved |'
  prefs: []
  type: TYPE_TB
- en: 'The following code demonstrates how to save, read, update, and delete the data
    using JPA in a Java SE application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The latest improvements of JPA 2.1 in action
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Since its last version (JPA 2.0), the JPA Specification has had many enhancements.
    The most important enhancements are in the following features: persistence context
    synchronization, Entities, **JPQL**, **Criteria API**, and **Data Definition Language**
    (**DDL**) generation.'
  prefs: []
  type: TYPE_NORMAL
- en: Persistence context synchronization
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Before JPA 2.1, the container-managed persistence context was automatically
    joined to the current transaction, and any update made to the persistence context
    was propagated to the underlying resource manager. With the new specification,
    it is now possible to have a persistence context that will not be automatically
    enlisted in any JTA transaction. This can be done by simply creating a container-managed
    entity manager of synchronization type `SynchronizationType.UNSYNCHRONIZED` as
    shown in the following code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Creation and enlistment of a `SynchronizationType.UNSYNCHRONIZED` persistence
    context:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, you will notice that we called the `EntityManager.joinTransaction()`
    method; this is justified by the fact that a persistence context of type `SynchronizationType.UNSYNCHRONIZED`
    is enlisted in a JTA transaction only after calling the `EntityManager.joinTransaction()`
    method, and after a commit or rollback, the `SynchronizationType.UNSYNCHRONIZED`
    persistence context will be dissociated from the transaction to which it was enlisted.
    You need to call the `EntityManager.joinTransaction()` method again to enlist
    the dissociated persistence context.
  prefs: []
  type: TYPE_NORMAL
- en: Entity
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: An entity listener is a simple Java class (not an entity), which allows you
    to define the lifecycle callback methods that can be invoked for the lifecycle
    events of one or many entities. The JPA 2.1 Specification adds to these classes
    the support of **CDI injection** and the ability to define `@PostConstruct` and
    `@PreDestroy` lifecycle callback methods. These methods are respectively called
    after the dependency injections and before the destruction of the entity listener.
    The following code presents an entity listener that has the post construct and
    pre destroy methods with an **EJB injection**. It is followed by code that shows
    how to associate an entity listener to an entity.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: New annotations
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: JPA 2.1 added an annotation (`@Index`) to create indexes on tables when a schema
    is generated from entities and an annotation (`@ForeignKey`) to designate foreign
    keys of a table.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `@Index` annotation has one mandatory parameter (`columnList`) to list
    the columns that make up the index with different sort orders. It also has two
    optional parameters: the `name` parameter, which allows you to change the default
    name of the index, and the `unique` parameter to set the index as unique or not
    unique. In parallel, `@Index` annotation was added as a part of `Table`, `SecondaryTable`,
    `CollectionTable`, `JoinTable`, and `TableGenerator` annotations.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `@ForeignKey` can be used as element of `JoinColumn`, `JoinColumns`, `MapKeyJoinColumn`,
    `MapKeyJoinColumns`, `PrimaryKeyJoinColumn`, `PrimaryKeyJoinColumns`, `CollectionTable`,
    `JoinTable`, `SecondaryTable`, and `AssociationOverride` annotations to either
    define or modify the foreign key constraints on a table. It takes three parameters:
    name, value for the constraint, and the definition of the foreign key. The three
    parameters are optional.'
  prefs: []
  type: TYPE_NORMAL
- en: 'An example of an entity with a foreign key and indexed columns is shown in
    the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Entity graphs
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When we talk about an entity graph, we have to keep in mind a data structure
    involving several related entities. With the previous version of JPA, the efficient
    loading of data of an entity was essentially managed through the fetch setting.
    The consequence was that it was necessary to set the fetch attribute of some annotations
    before compiling the application (or before deployment in the case of XML configuration)
    in order to request that an entity attribute be loaded **eagerly** (when entity
    is loaded) or **lazily** (when data is needed). Through entity graphs, you can
    now override or change the fetch setting at runtime.
  prefs: []
  type: TYPE_NORMAL
- en: An entity graph can be defined statically by using a vast `NamedEntityGraph`,
    `NamedEntityGraphs`, `NamedSubgraph`, and `NamedAttributeNode` annotations, or
    dynamically through `EntityGraph`, `subgraph`, and `AttributeNode` interfaces.
  prefs: []
  type: TYPE_NORMAL
- en: Static or named entity graphs
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The `@NamedEntityGraph` annotation is used to define an entity graph that can
    be used at runtime when executing queries or using the `find()` method. The following
    code shows an example of the definition of a named entity graph with one field:
    `students`.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Once defined, we need to retrieve our named entity graph using the `getEntityGraph()`
    method of `EntityManager` in order to use it as a property when searching with
    the find method or as a **query hint** with a query. After executing the following
    code, you will notice that in the first search, the `students` attribute will
    not be loaded while in the second search it will be.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code is an example of using a named entity graph:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Dynamic entity graphs
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Entity graphs can also be defined at runtime. To do this, we must use the `createEntityGraph()`
    method of the entity manager and not `getEntityGraph()` as with the named entity
    graphs. Once defined, the **dynamic entity graph** is associated with the `find()`
    method or a query in the same way as a named entity graph as shown in the following
    code.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code is an example of using a dynamic entity graph:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: JPQL
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**JPQL** (**Java Persistence Query Language**) is an object-oriented SQL-like
    query language. It is platform independent and allows you to access your data
    through entities instead of manipulating the physical structure of your database.
    The following code demonstrates how to query for all registered students whose
    ID is greater than 123.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code is an example of a JPQL query:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Despite its power and its vastness, the JPQL continues to receive significant
    improvements. In JPA 2.1, it has among other enhancements integrated support for
    stored procedures, added new reserved identifiers, and the support for creation
    of named queries at runtime.
  prefs: []
  type: TYPE_NORMAL
- en: Support for stored procedures
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: JPA 2.1 now allows you to execute stored procedures. Through the various API
    that it offers, you can define and execute named stored procedures or dynamically
    stored procedures.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following script is an example of a script to create a stored procedure
    in MySQL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The following code demonstrates how to execute the stored procedure `getStudentsName`
    we just created:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: New reserved identifiers
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The JQPL has introduced the following new keywords:'
  prefs: []
  type: TYPE_NORMAL
- en: '`ON`: This keyword allows us to make explicit joins as in SQL with the `ON`
    condition. Before, joins were made with the liaison attributes between the two
    entities, which required minimal configuration. The following code demonstrates
    the use of `ON`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`FUNCTION`: This keyword allows you to invoke functions in your queries other
    than those originally intended by JPQL (such `SUBSTRING`, `LENGTH`, `ABS`, `TRIM`,
    and so on). With this keyword, you can use a database function or functions that
    you have defined yourself. The following query gives us the list of students born
    in July by using the `month()` method of **derby database** in order to extract
    the month from a birth date:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`TREAT`: This keyword allows you to do the **downcasting** of an entity in
    order to obtain a subclass state. It is used in the `FROM` and `WHERE` clauses.
    In the following code, the entity `Appuser` inherits from the entity `Person`;
    with the keyword `TREAT` we can put conditions on attributes that are not contained
    in the base entity (`Person`).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Support for creating named queries at runtime
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Before JPA 2.1, named queries were defined statically as metadata before compiling
    the program. Through the `addNamedQuery` method that was added to the `EntityManagerFactory`
    interface, you can now create a named query at runtime as shown in the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The Criteria API
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'JPA since Version 2.0 offers two options for defining queries on entities.
    The first option is the JPQL which is a query language based on SQL. The second
    option is the Criteria API where a query is constructed essentially with Java
    objects, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Given that the two solutions do not evolve at the same rate, the major changes
    in the Criteria API are support for bulk update/delete and new reserved identifiers.
  prefs: []
  type: TYPE_NORMAL
- en: Support for bulk update/delete
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The bulk update and delete in the Criteria API are respectively constructed
    with `javax.persistence.criteria.CriteriaUpdate` and `javax.persistence.criteria.CriteriaDelete`
    interfaces. The following code demonstrates how to update a lot of information
    with just one Criteria API request:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Support for new reserved identifiers
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Just like the JPQL, the Criteria API incorporates the possibility of making
    downcasts and defines joins using `ON` conditions. To do that, overloaded `treat()`
    methods have been added to the `javax.persistence.criteria.CriteriaBuilder` interface
    for downcasting, while `on()` and `getOn()` methods have been added to some interfaces
    (such as `Join`, `ListJoin`, `SetJoin`, `MapJoin`, `CollectionJoin`,and `Fetch`)
    of the `javax.persistence.criteria` package for joins with `ON` conditions. The
    following query is equivalent to the JPQL downcasting shown in the preceding code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: DDL generation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Since the previous version of the JPA Specification, it is possible to create
    or drop and create tables. However, the support for this feature was not required
    and the specification document made us understand that the use of this feature
    could reduce application portability. Well, with JPA 2.1, the **DDL** (**Data
    Definition Language**) generation was not only standardized but has been expanded
    and is now required.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this case, new properties have been added. You have for example the following
    properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '`javax.persistence.schema-generation.database.action`: This defines the action
    (none, create, drop-and-create, or drop) that should be taken by the provider.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`javax.persistence.schema-generation.create-source`: This defines the source
    (entities, specific scripts, or both) to be used by the provider in the case of
    a DDL generation.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`javax.persistence.schema-generation.drop-source`: This defines the source
    (entities, specific scripts, or both) to be used by the provider in the case of
    drop table.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`javax.persistence.schema-generation.connection`: This defines the **JDBC**
    connection parameters to use for the DDL schema generation in order to take into
    account the management of privileges in some databases such as Oracle. This parameter
    was thought of for Java EE environments.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The following persistence unit provides an example of configuration to generate
    tables at the creation of `EntityManagerFactory`. This generation will be based
    on entities' information (metadata) and it will take place if and only if the
    tables to be created do not exist, because we defined create instead of drop-and-create
    for the action of the provider.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Another aspect of this standardization is the addition of a new method (`Persistence.generateSchema()`),
    which provides more opportunity for the generation. Before (in JPA 2.0), the DDL
    generation was done at the creation of the entity manager. Henceforth, you can
    generate your tables before, during, or after the creation of the `EntityManagerFactory`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code demonstrates how to generate tables regardless of the creation
    of the `EntityManagerFactory`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The following code demonstrates another way to generate the tables at the creation
    of the `EntityManagerFactory`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Java Transaction API 1.2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Java Transaction API 1.2 Specification was developed under JSR 907\. This
    section just gives you an overview of improvement in the API. The complete document
    specification (for more information) can be downloaded from [http://jcp.org/aboutJava/communityprocess/mrel/jsr907/index2.html](http://jcp.org/aboutJava/communityprocess/mrel/jsr907/index2.html).
  prefs: []
  type: TYPE_NORMAL
- en: The Java Transaction API
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The **Java Transaction API** (**JTA**) is a standard Java API for managing
    transactions on one or more resources (distributed transactions) in server environments.
    It consist of three main APIs: `javax.transaction.UserTransaction` interface used
    by applications for explicit transaction demarcation, `javax.transaction.TransactionManager`
    interface used by application servers to demarcate transactions implicitly on
    behalf of the application, and `javax.transaction.xa.XAResource`, which is a Java
    mapping of the standard XA interface for distributed transaction processing.'
  prefs: []
  type: TYPE_NORMAL
- en: JTA in action
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As we said, JTA transactions are used in Java EE environments. In order to
    enable this transaction type, the `transaction-type` attribute of the persistence
    unit should be set to `JTA` instead of `RESOURCE_LOCAL` and the data source (if
    there is one), should be defined within the `<jta-datasource>` element. The following
    code gives an example of a persistence unit to manage transactions using JTA:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: After declaring a `JTA` transaction type persistence unit, the developer can
    either leave the transaction management to the server (by default, the container
    considers a method as a transaction) or take control and define the transaction
    boundaries programmatically.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code is an example of a container-managed transaction:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The following code is an example of bean-managed transaction:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Innovations introduced by JTA 1.2
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Unlike the JPA Specification, JTA has known only a few improvements that can
    be summarized in the following lines. First we have the addition of two new annotations.
    The first is `javax.transaction.Transactional`, which provides the possibility
    to demarcate transactions declaratively on CDI-managed beans or classes defined
    as managed beans by the Java EE Specification. The second annotation added is
    the `javax.transaction.TransactionScoped` annotation, which provides the possibility
    to define beans whose lifecycle is identical with the current transaction. The
    JTA API also added one exception class `javax.transaction.TransactionalException`.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter we have, with examples, presented and analyzed the improvements
    provided by two APIs whose major objective is to facilitate interaction with your
    data base. The first presented was JPA API, which gives you the ability to create,
    read, update, and delete data from a database by using Java objects. The second
    was JTA API, which is an API designed for transparent management of transactions
    in one or more data sources.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we'll talk about **EJB**s and we will make a small example,
    which will consist of putting together most of the APIs that we have studied.
  prefs: []
  type: TYPE_NORMAL
