<html><head></head><body>
		<div id="_idContainer012">
			<h1 id="_idParaDest-25"><em class="italic"><a id="_idTextAnchor024"/>Chapter 2</em>: Customizing the jOOQ Level of Involvement</h1>
			<p>In the previous chapter, we introduced jOOQ in a Spring Boot application and used it for generating and executing a valid non-type-safe SQL statement. In this chapter, we will continue this journey and increase the jOOQ level of involvement via an astonishing feature – the so-called jOOQ <em class="italic">Code Generator</em>. In other words, jOOQ will be in control of the persistence layer via a straightforward flow that begins with type-safe queries, continues by generating <strong class="bold">Plain Old Java Objects </strong>(<strong class="bold">POJOs</strong>) used to map the query results as objects, and ends with generating DAOs used to shortcut the most common queries in object-oriented style.</p>
			<p>By the end of this chapter, you'll know how to write type-safe queries, and how to instruct jOOQ to generate POJOs and DAOs that have custom names in Java and Kotlin applications, using Maven and Gradle. We will cover these topics declaratively (for instance, in XML files) and programmatically.</p>
			<p>The following topics will be covered in this chapter:</p>
			<ul>
				<li>Understanding what type-safe queries are</li>
				<li>Generating a jOOQ Java-based schema</li>
				<li>Writing queries using a Java-based schema</li>
				<li>Configuring jOOQ to generate POJOs</li>
				<li>Configuring jOOQ to generate DAOs</li>
				<li>Configuring jOOQ to generate interfaces</li>
				<li>Tackling programmatic configuration</li>
				<li>Introducing jOOQ settings</li>
			</ul>
			<p>Let's start with a brief discussion about type-safe queries.</p>
			<h1 id="_idParaDest-26"><a id="_idTextAnchor025"/>Technical requirements</h1>
			<p>The code files used in this chapter can be found on GitHub: </p>
			<p><a href="https://github.com/PacktPublishing/jOOQ-Masterclass/tree/master/Chapter02">https://github.com/PacktPublishing/jOOQ-Masterclass/tree/master/Chapter02</a></p>
			<h1 id="_idParaDest-27"><a id="_idTextAnchor026"/>Understanding what type-safe queries are</h1>
			<p>Generally <a id="_idIndexMarker040"/>speaking, what actually is a type-safe API? In short, an API is type-safe if it relies on the type system of a programming language aiming to prevent and report type errors. Specifically, jOOQ enables the compiler to do that via the Code Generator features.</p>
			<p>Working with type-safe SQL is preferable because there is no need to validate every SQL statement via dedicated tests, and it is faster to fix things during coding than while running the application. For example, you can significantly reduce the number of unit tests dedicated to SQL validation and focus on integration tests, which is always a good thing. So, SQL type safety really matters!</p>
			<p>Declaring SQL statements as Java <strong class="source-inline">String</strong> statements (for example, in JPQL style, which is verified at execution time) doesn't take advantage of type safety. In other words, the compiler cannot guarantee that a SQL statement is valid. This happens in each of the following examples that use different choices for the persistence layer. All these examples compile but fail at runtime.</p>
			<p>Let's see a <strong class="source-inline">JdbcTemplate</strong> non-type-safe SQL example (with the wrong order of binding values):</p>
			<pre class="source-code">public Manager findManager(<strong class="bold">Long id, String name</strong>) {</pre>
			<pre class="source-code">  String sql = "SELECT * FROM MANAGER </pre>
			<pre class="source-code">    WHERE MANAGER_ID=? AND MANAGER_NAME=?";               </pre>
			<pre class="source-code">  Manager result = jdbcTemplate</pre>
			<pre class="source-code">    .queryForObject(sql, Manager.class, <strong class="bold">name, id</strong>);</pre>
			<pre class="source-code">}</pre>
			<p>Here, we have a Spring Data example (<strong class="source-inline">name</strong> should be <strong class="source-inline">String</strong>, not <strong class="source-inline">int</strong>):</p>
			<pre class="source-code">@Query(value = "SELECT c.phone, p.cachingDate FROM Customer c </pre>
			<pre class="source-code">       INNER JOIN c.payments p WHERE c.customer_name = ?1")</pre>
			<pre class="source-code">CustomerPojo fetchCustomerWithCachingDateByName(<strong class="bold">int</strong> name);</pre>
			<p>Here is a <a id="_idIndexMarker041"/>Spring Data derived query method example (<strong class="source-inline">name</strong> should be <strong class="source-inline">String</strong>, not <strong class="source-inline">int</strong>):</p>
			<pre class="source-code">Customer findByName(<strong class="bold">int</strong> name);</pre>
			<p>The following is a jOOQ query builder without the Code Generator example (instead of <strong class="source-inline">v</strong>, it should be <strong class="source-inline">v.getOwnerName()</strong>):</p>
			<pre class="source-code">public Customer findCustomer(<strong class="bold">Voucher v</strong>) {        </pre>
			<pre class="source-code">  ctx.select().from(table("CUSTOMER"))                </pre>
			<pre class="source-code">     .where(field("CUSTOMER.CUSTOMER_NAME").eq(<strong class="bold">v</strong>))...;    </pre>
			<pre class="source-code">}</pre>
			<p>Here's another jOOQ query builder without the Code Generator example (in our schema, there is no <strong class="source-inline">OFFICES</strong> table and no <strong class="source-inline">CAPACITY</strong> column):</p>
			<pre class="source-code">ctx.select()</pre>
			<pre class="source-code">   .from(table("OFFICES"))</pre>
			<pre class="source-code">   .where(field("OFFICE.CAPACITY").gt(50));</pre>
			<p>These are just some simple cases that are easy to spot and fix. Imagine a non-type-safe complex query with a significant number of bindings.</p>
			<p>But, if the jOOQ Code Generator is enabled, then jOOQ will compile the SQL statements against an actual Java-based schema that mirrors a database. This way, jOOQ ensures <em class="italic">at least</em> the following:</p>
			<ul>
				<li>The classes and fields that occur in SQL exist, have the expected type, and are mapped to a database.</li>
				<li>There are no type mismatches between the operators and operands.</li>
				<li>The generated query is syntactically valid.<p class="callout-heading">Important Note</p><p class="callout">I said <em class="italic">at least</em> because, besides type safety, jOOQ takes care of many other aspects, such as quotations, qualification, and case sensitivity of identifiers. These aspects are not easy to handle across SQL dialects, and thanks to the Code Generator feature, jOOQ makes the right choices for us upfront almost everywhere. As Lukas Eder said: <em class="italic">"Using jOOQ with the Code Generator is just a little additional setup, but it will help jOOQ to make the right, carefully chosen default choices for so many silly edge cases that are so annoying to handle later on. I can't recommend it enough! :)"</em></p></li>
			</ul>
			<p>Back to <a id="_idIndexMarker042"/>type safety, let's assume that the jOOQ Code Generator has produced the needed artifacts (a suite of classes that mirrors the database tables, columns, routines, views, and so on). In this context, the previous jOOQ examples can be rewritten in a type-safe manner, as follows. Note that none of the following snippets will compile:</p>
			<pre class="source-code">import static jooq.generated.tables.Customer.CUSTOMER;</pre>
			<pre class="source-code">...</pre>
			<pre class="source-code">public Customer findCustomer(<strong class="bold">Voucher v</strong>) {        </pre>
			<pre class="source-code">  ctx.select().from(CUSTOMER)                   </pre>
			<pre class="source-code">     .where(CUSTOMER.CUSTOMER_NAME.eq(<strong class="bold">v</strong>))...;         </pre>
			<pre class="source-code">}</pre>
			<p>Besides being less verbose than the original example, this query is type-safe as well. This time, <strong class="source-inline">CUSTOMER</strong> (which replaced <strong class="source-inline">table("CUSTOMER")</strong>) is a <strong class="source-inline">static</strong> instance (shortcut) of the <strong class="source-inline">Customer</strong> class, representing the <strong class="source-inline">customer</strong> table. Moreover, <strong class="source-inline">CUSTOMER_NAME</strong> (which replaced <strong class="source-inline">field("CUSTOMER.CUSTOMER_NAME")</strong>) is also a <strong class="source-inline">static</strong> field in the <strong class="source-inline">Customer</strong> class, representing the <strong class="source-inline">customer_name</strong> column of the <strong class="source-inline">customer</strong> table. These Java objects have been generated by the jOOQ Code Generator as part of the Java-based schema. Note how this <strong class="source-inline">static</strong> instance was nominally imported here – if you find the technique of importing each <strong class="source-inline">static</strong> artifact cumbersome, then you can simply rely on the neat trick of importing the entire schema as <strong class="source-inline">import static jooq.generated.Tables.*</strong>.</p>
			<p>The <a id="_idIndexMarker043"/>second jOOQ example can be rewritten in a type-safe manner, as follows:</p>
			<pre class="source-code">import static jooq.generated.tables.Office.OFFICE;</pre>
			<pre class="source-code">...</pre>
			<pre class="source-code">ctx.select().from(OFFICES).where(OFFICE.CAPACITY.gt(50));</pre>
			<p>The following figure is a screenshot from the IDE, showing that the compiler complains about the type safety of this SQL:</p>
			<div>
				<div id="_idContainer007" class="IMG---Figure">
					<img src="image/B16833_Figure_2.1.jpg" alt="Figure 2.1 – The compiler reports a type safety error&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 2.1 – The compiler reports a type safety error</p>
			<p class="callout-heading">Important Note</p>
			<p class="callout">Lukas Eder said this: <em class="italic">"As you probably know, the IDEs help writing SQL and JPQL strings, which is nice. But IDEs doesn't fail the build when a column name changes."</em> Well, having type-safe queries covers this aspect, and the IDE can fail the build. So, thanks to jOOQ's fluency and expressiveness, the IDE can provide code completion <a id="_idIndexMarker044"/>and refactoring support. Moreover, with jOOQ, the bind variables are part of a non-dynamic <strong class="bold">Abstract Syntax Tree</strong> (<strong class="bold">AST</strong>); therefore, it is not possible to expose SQL injection vulnerabilities this way.</p>
			<p>OK, but how do we obtain this Java-based schema?</p>
			<h1 id="_idParaDest-28"><a id="_idTextAnchor027"/>Generating a jOOQ Java-based schema</h1>
			<p>All the<a id="_idIndexMarker045"/> previous queries were referencing the database schema explicitly by placing the table or column name between quotes and passing them as arguments to the jOOQ built-in <strong class="source-inline">table()</strong> and <strong class="source-inline">field()</strong> methods respectively.</p>
			<p>But, using the jOOQ Code Generator allows the SQL statements expressed via jOOQ's query DSL API to take advantage of a Java-based schema that mirrors the one from the database. The code generation part is the job of the jOOQ generation tool (its starting point is the <strong class="source-inline">org.jooq.codegen.GenerationTool</strong> class). </p>
			<p>Having a Java-based schema is quite useful. The SQL statements can be expressed via the Java data access layer and executed against the underlying database schema. Besides being type-safe, these SQL statements are not prone to typos, are easy to refactor (for example, to rename a column), and are less verbose than referencing the database schema explicitly.</p>
			<p>jOOQ comes with several solutions for generating the Java-based schema via the jOOQ Code Generator. Mainly, jOOQ can generate the Java-based schema by applying the technique of reverse engineering to the database directly, the DDL files, JPA entities, or XML files containing the schema. Next, we will tackle the first three approaches, starting with the first approach, which generates the Java-based schema directly from the database. Mainly, we will use Flyway to migrate the database (Liquibase is supported as well), which is subsequently reverse engineered by jOOQ to obtain the Java-based schema.</p>
			<h2 id="_idParaDest-29"><a id="_idTextAnchor028"/>Code generation from a database directly</h2>
			<p>The following<a id="_idIndexMarker046"/> figure represents<a id="_idIndexMarker047"/> the jOOQ Java-based schema generation flow:</p>
			<div>
				<div id="_idContainer008" class="IMG---Figure">
					<img src="image/B16833_Figure_2.2.jpg" alt="Figure 2.2 – Java-based schema generation&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 2.2 – Java-based schema generation</p>
			<p>So far, jOOQ will<a id="_idIndexMarker048"/> regenerate the Java-based schema every time the application starts (runs). </p>
			<p>In other <a id="_idIndexMarker049"/>words, even if the database schema has not changed, jOOQ will regenerate the Java-based schema at each run. Obviously, this is preferable to regenerating the Java-based schema only when the underlying database schema is missing or has changed (for instance, a new column has been added to a table); otherwise, this is just a waste of time. </p>
			<p>Conscious schema change management is a good thing, and having a tool for this is great! Most probably, you'll choose between Flyway and Liquibase. While we will only cover the Flyway approach in the next section, Liquibase is very well represented in the jOOQ manual (<a href="https://www.jooq.org/doc/latest/manual/code-generation/codegen-liquibase/)">https://www.jooq.org/doc/latest/manual/code-generation/codegen-liquibase/)</a>.</p>
			<h3>Adding Flyway with Maven</h3>
			<p>Flyway is<a id="_idIndexMarker050"/> a great tool for <a id="_idIndexMarker051"/>database <a id="_idIndexMarker052"/>migration (<a href="https://flywaydb.org/">https://flywaydb.org/</a>). Mainly, Flyway keeps <a id="_idIndexMarker053"/>track of database schema modifications via a table named <strong class="source-inline">flyway_schema_history</strong> (or <strong class="source-inline">schema_version</strong> in Flyway prior to version 5). This table is automatically added to the database and is maintained by Flyway itself.</p>
			<p>Typically, in Spring Boot, Flyway reads and executes all the database migration scripts located in the indicated path (the default path is <strong class="source-inline">src/main/resources/db/migration</strong>). For instance, in this book, we use an explicit path that points to a location outside the applications in the root folder (<strong class="source-inline">${root}/db/migration</strong>). We do this because we want to avoid multiplying the migrations scripts <a id="_idIndexMarker054"/>in every single application. To quickly start with Flyway, simply add to <strong class="source-inline">pom.xml</strong> the following dependency:</p>
			<pre class="source-code">&lt;dependency&gt;</pre>
			<pre class="source-code">  &lt;groupId&gt;org.flywaydb&lt;/groupId&gt;</pre>
			<pre class="source-code">  &lt;artifactId&gt;flyway-core&lt;/artifactId&gt;</pre>
			<pre class="source-code">&lt;/dependency&gt;</pre>
			<p>The <a id="_idIndexMarker055"/>Flyway default Maven phase for a <strong class="source-inline">migrate</strong> operation is <strong class="source-inline">pre-integration-test</strong> (right after <strong class="source-inline">package</strong>). On the other hand, jOOQ needs the migrations to take place in the <strong class="source-inline">generate-sources</strong> phase (right after <strong class="source-inline">validate</strong>), therefore much earlier. </p>
			<p>Mainly, jOOQ triggers a <strong class="source-inline">SELECT</strong> query against the <strong class="source-inline">flyway_schema_history</strong> table to check the schema version. This means that jOOQ needs to wait for migrations to take place and the schema version to be updated. If the version is updated, then jOOQ regenerates the Java-based schema; otherwise, you'll see a message like this: <strong class="source-inline">Existing version 1.1 is up to date with 1.1 for schema classicmodels. Ignoring schema</strong>.</p>
			<p>Scheduling migrations in the <strong class="source-inline">generate-sources</strong> phase can be done via the Flyway Maven plugin, as follows:</p>
			<pre class="source-code"><strong class="bold">&lt;phase&gt;generate-sources&lt;/phase&gt;</strong></pre>
			<p>Let's try using Gradle.</p>
			<h3>Adding Flyway with Gradle</h3>
			<p>If <a id="_idIndexMarker056"/>you prefer to use Gradle, then<a id="_idIndexMarker057"/> you'll need <strong class="source-inline">build.gradle</strong> in the following code:</p>
			<pre class="source-code">plugins { </pre>
			<pre class="source-code">  id 'org.flywaydb.flyway' version '...'</pre>
			<pre class="source-code">}</pre>
			<pre class="source-code">dependencies {        </pre>
			<pre class="source-code">  implementation 'org.flywaydb:flyway-core'   </pre>
			<pre class="source-code">}</pre>
			<pre class="source-code">flyway {</pre>
			<pre class="source-code">  driver = ...</pre>
			<pre class="source-code">  url = ...</pre>
			<pre class="source-code">  ...</pre>
			<pre class="source-code">}</pre>
			<p>Next, let's <a id="_idIndexMarker058"/>add the SQL scripts <a id="_idIndexMarker059"/>following the Flyway naming conventions.</p>
			<h3>Adding SQL scripts for Flyway</h3>
			<p>In the <a id="_idIndexMarker060"/>applications <a id="_idIndexMarker061"/>developed in this book, the scripts read and executed by Flyway are named <strong class="source-inline">V1.1__Create.sql</strong> (this file contains the DDLs of the database schema) and <strong class="source-inline">afterMigrate.sql</strong> (this file contains the DMLs to populate the database) and are placed externally to the applications in the <strong class="source-inline">${root}/db/migration</strong> folder. Adding a new file that respects the Flyway naming convention (for example, <strong class="source-inline">V1.2__AddColumn.sql</strong>) will instruct Flyway to update the database schema and jOOQ to regenerate the Java-based schema. As long as no migrations happen and the jOOQ-generated classes exist, jOOQ doesn't regenerate the Java-based schema.</p>
			<p>The following figure represents the flow, which is particularly interesting for most use cases that contain DDL changes:</p>
			<div>
				<div id="_idContainer009" class="IMG---Figure">
					<img src="image/B16833_Figure_2.3.jpg" alt="Figure 2.3 – Flyway migrations and the jOOQ Java-based schema generation&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 2.3 – Flyway migrations and the jOOQ Java-based schema generation</p>
			<p>Note<a id="_idIndexMarker062"/> how Flyway migrations take place before jOOQ code generation. Finally, it's time to enable the jOOQ Code Generator.</p>
			<p>From a developer perspective, enabling the jOOQ Code Generator is a setup task that gets materialized in a snippet of code, written in standalone migration scripts or <strong class="source-inline">pom.xml</strong> if there is a Maven-based project, or <strong class="source-inline">build.gradle</strong> if there is a Gradle-based project. jOOQ reads this information and uses it to configure and automatically execute the <strong class="source-inline">org.jooq.codegen.GenerationTool</strong> generator accordingly.</p>
			<h3>Running the Code Generator with Maven </h3>
			<p>Mainly, the<a id="_idIndexMarker063"/> jOOQ Code Generator can run in standalone mode or with Maven/Gradle. While there are no big differences between these two approaches, we prefer to go further with the Maven plugin, <strong class="source-inline">jooq-codegen-maven</strong>. Nevertheless, for a quick example of running the Code Generator from the command line in standalone mode, you have everything you need (including a <strong class="source-inline">README</strong> file) packed in a ZIP archive named <strong class="source-inline">standalone-codegen-jooq.zip</strong>. This is available for MySQL, PostgreSQL, SQL Server, and Oracle.</p>
			<p>Now, configuring jOOQ's Code Generator requires some information that can be packed in an XML file. The climax of this file is the <strong class="source-inline">&lt;configuration&gt;</strong> tag used to shape an <strong class="source-inline">org.jooq.meta.jaxb.Configuration</strong> instance. Consider reading carefully each comment of the following jOOQ Code Generator configuration stub, since each <a id="_idIndexMarker064"/>comment provides important details about the tag that precedes it (in the bundled code, you'll see an expanded version of these comments, containing extra details):</p>
			<pre class="source-code">&lt;plugin&gt;</pre>
			<pre class="source-code">  &lt;groupId&gt;...&lt;/groupId&gt;</pre>
			<pre class="source-code">  &lt;artifactId&gt;jooq-codegen-maven&lt;/artifactId&gt;</pre>
			<pre class="source-code">  &lt;executions&gt;</pre>
			<pre class="source-code">    &lt;execution&gt;</pre>
			<pre class="source-code">      &lt;id&gt;...&lt;/id&gt;</pre>
			<pre class="source-code">      &lt;phase&gt;generate-sources&lt;/phase&gt;</pre>
			<pre class="source-code">      &lt;goals&gt;</pre>
			<pre class="source-code">        &lt;goal&gt;generate&lt;/goal&gt;</pre>
			<pre class="source-code">      &lt;/goals&gt;</pre>
			<pre class="source-code">      &lt;configuration xmlns = "..."&gt;</pre>
			<pre class="source-code">        &lt;!-- Configure the database connection here --&gt;</pre>
			<pre class="source-code">        &lt;jdbc&gt;...&lt;/jdbc&gt;</pre>
			<p>Next, the <strong class="source-inline">&lt;generator/&gt;</strong> tag contains all the information needed for customizing the jOOQ generator:</p>
			<pre class="source-code">        &lt;generator&gt;</pre>
			<pre class="source-code">          &lt;!-- The Code Generator: </pre>
			<pre class="source-code">          org.jooq.codegen.{Java/Kotlin/Scala}Generator</pre>
			<pre class="source-code">          Defaults to org.jooq.codegen.JavaGenerator --&gt;</pre>
			<pre class="source-code">          &lt;name&gt;...&lt;/name&gt;</pre>
			<pre class="source-code">          &lt;database&gt;</pre>
			<pre class="source-code">            &lt;!-- The database type. The format here is:    </pre>
			<pre class="source-code">            org.jooq.meta.[database].[database]Database --&gt;</pre>
			<pre class="source-code">            &lt;name&gt;...&lt;/name&gt;</pre>
			<pre class="source-code">            &lt;!-- The database schema--&gt;</pre>
			<pre class="source-code">            &lt;inputSchema&gt;...&lt;/inputSchema&gt;</pre>
			<pre class="source-code">            &lt;!-- What should be included by the generator --&gt;</pre>
			<pre class="source-code">            &lt;includes&gt;...&lt;/includes&gt;</pre>
			<pre class="source-code">            &lt;!-- What should be excluded by the generator --&gt;</pre>
			<pre class="source-code">            &lt;excludes&gt;...&lt;/excludes&gt;</pre>
			<pre class="source-code">            &lt;!-- Schema version provider --&gt;</pre>
			<pre class="source-code">            &lt;schemaVersionProvider&gt;...&lt;/schemaVersionProvider&gt;</pre>
			<pre class="source-code">            &lt;!-- Set generator queries timeout(default 5s) --&gt;</pre>
			<pre class="source-code">            &lt;logSlowQueriesAfterSeconds&gt;</pre>
			<pre class="source-code">              ...</pre>
			<pre class="source-code">            &lt;/logSlowQueriesAfterSeconds&gt;</pre>
			<pre class="source-code">          &lt;/database&gt;</pre>
			<pre class="source-code">          &lt;target&gt;</pre>
			<pre class="source-code">            &lt;!-- The output package of generated classes --&gt;</pre>
			<pre class="source-code">            &lt;packageName&gt;...&lt;/packageName&gt;</pre>
			<pre class="source-code">            &lt;!—The output directory of generated classes --&gt;</pre>
			<pre class="source-code">            &lt;directory&gt;...&lt;/directory&gt;</pre>
			<pre class="source-code">          &lt;/target&gt;</pre>
			<pre class="source-code">        &lt;/generator&gt;</pre>
			<pre class="source-code">      &lt;/configuration&gt;</pre>
			<pre class="source-code">    &lt;/execution&gt;</pre>
			<pre class="source-code">  &lt;/executions&gt;</pre>
			<pre class="source-code">&lt;/plugin&gt;</pre>
			<p>Based on this<a id="_idIndexMarker065"/> stub and the comments, let's try to fill up the missing parts for configuring the jOOQ Code Generator against the <strong class="source-inline">classicmodels</strong> database in MySQL:</p>
			<pre class="source-code">&lt;plugin&gt;</pre>
			<pre class="source-code">  &lt;groupId&gt;org.jooq&lt;/groupId&gt;</pre>
			<pre class="source-code">  &lt;artifactId&gt;jooq-codegen-maven&lt;/artifactId&gt;</pre>
			<pre class="source-code">  &lt;executions&gt;</pre>
			<pre class="source-code">    &lt;execution&gt;</pre>
			<pre class="source-code">      &lt;id&gt;generate-for-mysql&lt;/id&gt;</pre>
			<pre class="source-code">      &lt;phase&gt;generate-sources&lt;/phase&gt;</pre>
			<pre class="source-code">      &lt;goals&gt;</pre>
			<pre class="source-code">        &lt;goal&gt;generate&lt;/goal&gt;</pre>
			<pre class="source-code">      &lt;/goals&gt;</pre>
			<pre class="source-code">      &lt;configuration xmlns = "..."&gt;</pre>
			<pre class="source-code">        &lt;jdbc&gt;</pre>
			<pre class="source-code">          &lt;driver&gt;${spring.datasource.driverClassName}&lt;/driver&gt;</pre>
			<pre class="source-code">          &lt;url&gt;${spring.datasource.url}&lt;/url&gt;</pre>
			<pre class="source-code">          &lt;user&gt;${spring.datasource.username}&lt;/user&gt;</pre>
			<pre class="source-code">          &lt;password&gt;${spring.datasource.password}&lt;/password&gt;</pre>
			<pre class="source-code">        &lt;/jdbc&gt;</pre>
			<pre class="source-code">        &lt;generator&gt;</pre>
			<pre class="source-code">          &lt;name&gt;org.jooq.codegen.JavaGenerator&lt;/name&gt;</pre>
			<pre class="source-code">          &lt;database&gt;</pre>
			<pre class="source-code">            &lt;name&gt;org.jooq.meta.mysql.MySQLDatabase&lt;/name&gt;</pre>
			<pre class="source-code">            &lt;inputSchema&gt;classicmodels&lt;/inputSchema&gt;</pre>
			<pre class="source-code">            &lt;includes&gt;.*&lt;/includes&gt;</pre>
			<pre class="source-code">            &lt;excludes&gt;</pre>
			<pre class="source-code">              flyway_schema_history | sequences </pre>
			<pre class="source-code">              | customer_pgs | refresh_top3_product</pre>
			<pre class="source-code">              | sale_.* | set_.* | get_.* | .*_master</pre>
			<pre class="source-code">            &lt;/excludes&gt;</pre>
			<pre class="source-code">            &lt;schemaVersionProvider&gt;</pre>
			<pre class="source-code">             SELECT MAX(`version`) FROM `flyway_schema_history`</pre>
			<pre class="source-code">            &lt;/schemaVersionProvider&gt;</pre>
			<pre class="source-code">            &lt;logSlowQueriesAfterSeconds&gt;</pre>
			<pre class="source-code">              20</pre>
			<pre class="source-code">            &lt;/logSlowQueriesAfterSeconds&gt;</pre>
			<pre class="source-code">          &lt;/database&gt;</pre>
			<pre class="source-code">          &lt;target&gt;</pre>
			<pre class="source-code">            &lt;packageName&gt;jooq.generated&lt;/packageName&gt;</pre>
			<pre class="source-code">            &lt;directory&gt;target/generated-sources&lt;/directory&gt;</pre>
			<pre class="source-code">          &lt;/target&gt;</pre>
			<pre class="source-code">        &lt;/generator&gt;</pre>
			<pre class="source-code">      &lt;/configuration&gt;</pre>
			<pre class="source-code">    &lt;/execution&gt;</pre>
			<pre class="source-code">  &lt;/executions&gt;</pre>
			<pre class="source-code">&lt;/plugin&gt;</pre>
			<p>For brevity, the alternatives for PostgreSQL, SQL Server, and Oracle are not listed here, but you can find them in the code bundled with this book in the application named <em class="italic">WriteTypesafeSQL</em>.</p>
			<p>Additionally, the Maven plugin <a id="_idIndexMarker066"/>supports the following flags in <strong class="source-inline">&lt;configuration&gt;</strong>:</p>
			<ul>
				<li>Disabling the plugin via a Boolean property/constant:</li>
			</ul>
			<p class="source-code">&lt;skip&gt;false&lt;/skip&gt;</p>
			<ul>
				<li>Specifying an external XML configuration instead of an inline configuration:</li>
			</ul>
			<p class="source-code">&lt;configurationFile&gt;${externalfile}&lt;/configurationFile&gt;</p>
			<ul>
				<li>Alternatively, specifying several external configuration files, merged by using Maven's <strong class="source-inline">combine.children="append"</strong> policy:</li>
			</ul>
			<p class="source-code">&lt;configurationFiles&gt;</p>
			<p class="source-code">  &lt;configurationFile&gt;${file1}&lt;/configurationFile&gt;</p>
			<p class="source-code">  &lt;configurationFile&gt;...&lt;/configurationFile&gt;</p>
			<p class="source-code">&lt;/configurationFiles&gt;</p>
			<p>Next, let's run the jOOQ generator via Gradle.</p>
			<h3>Running the Code Generator with Gradle</h3>
			<p>Running<a id="_idIndexMarker067"/> the Code Generator via <a id="_idIndexMarker068"/>Gradle can be accomplished via <strong class="source-inline">gradle-jooq-plugin</strong> (<a href="https://github.com/etiennestuder/gradle-jooq-plugin/">https://github.com/etiennestuder/gradle-jooq-plugin/</a>). The next snippet of code represents the climax of configuration for Oracle:</p>
			<pre class="source-code">dependencies {        </pre>
			<pre class="source-code">  jooqGenerator 'com.oracle.database.jdbc:ojdbc8'</pre>
			<pre class="source-code">  jooqGenerator 'com.oracle.database.jdbc:ucp'</pre>
			<pre class="source-code">}</pre>
			<pre class="source-code">jooq {</pre>
			<pre class="source-code">  version = '...'</pre>
			<pre class="source-code">  edition = nu.studer.gradle.jooq.JooqEdition.TRIAL_JAVA_8</pre>
			<pre class="source-code">  configurations {</pre>
			<pre class="source-code">    main {</pre>
			<pre class="source-code">      generateSchemaSourceOnCompilation = true  // default</pre>
			<pre class="source-code">      generationTool {</pre>
			<pre class="source-code">        logging = org.jooq.meta.jaxb.Logging.WARN</pre>
			<pre class="source-code">        jdbc {</pre>
			<pre class="source-code">          driver = project.properties['driverClassName']</pre>
			<pre class="source-code">          url = project.properties['url']</pre>
			<pre class="source-code">          user = project.properties['username']</pre>
			<pre class="source-code">          password = project.properties['password']</pre>
			<pre class="source-code">        }</pre>
			<pre class="source-code">        generator {</pre>
			<pre class="source-code">          name = 'org.jooq.codegen.JavaGenerator'</pre>
			<pre class="source-code">          database {</pre>
			<pre class="source-code">            name = 'org.jooq.meta.oracle.OracleDatabase'</pre>
			<pre class="source-code">            inputSchema = 'CLASSICMODELS'</pre>
			<pre class="source-code">            includes = '.*'</pre>
			<pre class="source-code">            schemaVersionProvider = 'SELECT MAX("version") </pre>
			<pre class="source-code">              FROM "flyway_schema_history"'</pre>
			<pre class="source-code">            excludes = '''\</pre>
			<pre class="source-code">              flyway_schema_history | DEPARTMENT_PKG | GET_.*    </pre>
			<pre class="source-code">              | CARD_COMMISSION | PRODUCT_OF_PRODUCT_LINE</pre>
			<pre class="source-code">              ...</pre>
			<pre class="source-code">            '''</pre>
			<pre class="source-code">            logSlowQueriesAfterSeconds = 20</pre>
			<pre class="source-code">          }</pre>
			<pre class="source-code">          target {</pre>
			<pre class="source-code">            packageName = 'jooq.generated'</pre>
			<pre class="source-code">            directory = 'target/generated-sources'</pre>
			<pre class="source-code">          }</pre>
			<pre class="source-code">          strategy.name = </pre>
			<pre class="source-code">            "org.jooq.codegen.DefaultGeneratorStrategy"</pre>
			<pre class="source-code">        }</pre>
			<pre class="source-code">  ...</pre>
			<pre class="source-code">}</pre>
			<p>In addition, we have to bind the jOOQ generator to the Flyway migration tool to execute it only <a id="_idIndexMarker069"/>when it is really needed:</p>
			<pre class="source-code">tasks.named('generateJooq').configure { </pre>
			<pre class="source-code">  // ensure database schema has been prepared by </pre>
			<pre class="source-code">  // Flyway before generating the jOOQ sources</pre>
			<pre class="source-code">  dependsOn tasks.named('flywayMigrate')</pre>
			<pre class="source-code">  // declare Flyway migration scripts as inputs on this task</pre>
			<pre class="source-code">  inputs.files(fileTree('...'))</pre>
			<pre class="source-code">        .withPropertyName('migrations')</pre>
			<pre class="source-code">        .withPathSensitivity(PathSensitivity.RELATIVE)</pre>
			<pre class="source-code">  // make jOOQ task participate in </pre>
			<pre class="source-code">  // incremental builds and build caching</pre>
			<pre class="source-code">  allInputsDeclared = true</pre>
			<pre class="source-code">  outputs.cacheIf { true }</pre>
			<pre class="source-code">}</pre>
			<p>In the bundled code, you can find the complete application (<em class="italic">WriteTypesafeSQL</em>) for MySQL, PostgreSQL, SQL Server, and Oracle, written for Java/Kotlin and Maven/Gradle combos.</p>
			<p>Alternatively, if you prefer <strong class="source-inline">Ant</strong>, then read this: <a href="https://www.jooq.org/doc/latest/manual/code-generation/codegen-ant/">https://www.jooq.org/doc/latest/manual/code-generation/codegen-ant/</a>. Next, let's tackle another <a id="_idIndexMarker070"/>approach to generating the Java-based schema. </p>
			<h2 id="_idParaDest-30"><a id="_idTextAnchor029"/>Code generation from SQL files (DDL)</h2>
			<p>Another<a id="_idIndexMarker071"/> jOOQ approach for obtaining the Java-based schema relies on the DDL Database API, which is capable of accomplishing this task from SQL scripts (a single file or incremental files) containing the database schema. Mainly, the jOOQ SQL parser materializes our SQL scripts into an in-memory H2 database (available out of the box in Spring Boot), and the generation tool will reverse-engineer it to output the Java-based schema. The following figure depicts<a id="_idIndexMarker072"/> this flow:</p>
			<div>
				<div id="_idContainer010" class="IMG---Figure">
					<img src="image/B16833_Figure_2.4.jpg" alt="Figure 2.4 – The jOOQ Java-based schema generation via the DDL Database API&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 2.4 – The jOOQ Java-based schema generation via the DDL Database API</p>
			<p>The climax of the DDL Database API configuration relies on the jOOQ Meta Extensions, represented by <strong class="source-inline">org.jooq.meta.extensions.ddl.DDLDatabase</strong>.</p>
			<h3>Running the Code Generator with Maven </h3>
			<p>In this context, running the <a id="_idIndexMarker073"/>Code Generator via Maven relies on the following XML stub. Read each comment, since they contain valuable information (in the bundled code, you'll see an expanded version of these comments):</p>
			<pre class="source-code">&lt;configuration xmlns = "..."&gt;</pre>
			<pre class="source-code">  &lt;generator&gt;</pre>
			<pre class="source-code">    &lt;name&gt;...&lt;/name&gt;</pre>
			<pre class="source-code">    &lt;database&gt;</pre>
			<pre class="source-code">      &lt;name&gt;org.jooq.meta.extensions.ddl.DDLDatabase&lt;/name&gt;</pre>
			<pre class="source-code">      &lt;properties&gt;</pre>
			<pre class="source-code">        &lt;!-- Specify the location of your SQL script --&gt;</pre>
			<pre class="source-code">        &lt;property&gt;</pre>
			<pre class="source-code">          &lt;key&gt;scripts&lt;/key&gt;</pre>
			<pre class="source-code">          &lt;value&gt;...&lt;/value&gt;</pre>
			<pre class="source-code">        &lt;/property&gt;</pre>
			<pre class="source-code">        &lt;!-- The sort order of scripts in a directory</pre>
			<pre class="source-code">        (semantic, alphanumeric, flyway, none) --&gt;</pre>
			<pre class="source-code">        &lt;property&gt;</pre>
			<pre class="source-code">          &lt;key&gt;sort&lt;/key&gt;</pre>
			<pre class="source-code">          &lt;value&gt;...&lt;/value&gt;</pre>
			<pre class="source-code">        &lt;/property&gt;</pre>
			<pre class="source-code">        &lt;!-- The default schema for unqualified objects</pre>
			<pre class="source-code">        (public, none) --&gt;</pre>
			<pre class="source-code">        &lt;property&gt;</pre>
			<pre class="source-code">          &lt;key&gt;unqualifiedSchema&lt;/key&gt;</pre>
			<pre class="source-code">          &lt;value&gt;...&lt;/value&gt;</pre>
			<pre class="source-code">        &lt;/property&gt;</pre>
			<pre class="source-code">        &lt;!-- The default name case for unquoted objects</pre>
			<pre class="source-code">        (as_is, upper, lower) --&gt;</pre>
			<pre class="source-code">        &lt;property&gt;</pre>
			<pre class="source-code">          &lt;key&gt;defaultNameCase&lt;/key&gt;</pre>
			<pre class="source-code">          &lt;value&gt;...&lt;/value&gt;</pre>
			<pre class="source-code">        &lt;/property&gt;</pre>
			<pre class="source-code">      &lt;/properties&gt;</pre>
			<pre class="source-code">      &lt;inputSchema&gt;PUBLIC&lt;/inputSchema&gt;</pre>
			<pre class="source-code">      &lt;includes&gt;...&lt;/includes&gt;</pre>
			<pre class="source-code">      &lt;excludes&gt;...&lt;/excludes&gt;</pre>
			<pre class="source-code">      &lt;schemaVersionProvider&gt;...&lt;/schemaVersionProvider&gt;</pre>
			<pre class="source-code">      &lt;logSlowQueriesAfterSeconds&gt;</pre>
			<pre class="source-code">      ...</pre>
			<pre class="source-code">      &lt;/logSlowQueriesAfterSeconds&gt;</pre>
			<pre class="source-code">    &lt;/database&gt;</pre>
			<pre class="source-code">    &lt;target&gt;</pre>
			<pre class="source-code">      &lt;packageName&gt;...&lt;/packageName&gt;</pre>
			<pre class="source-code">      &lt;directory&gt;...&lt;/directory&gt;</pre>
			<pre class="source-code">    &lt;/target&gt;</pre>
			<pre class="source-code">  &lt;/generator&gt;</pre>
			<pre class="source-code">&lt;/configuration&gt;</pre>
			<p>In this <a id="_idIndexMarker074"/>context, jOOQ generates the Java-based schema without connecting to the real database. It uses the DDL files to produce an in-memory H2 database that is subsequently reverse-engineered into Java classes. The <strong class="source-inline">&lt;schemaVersionProvider&gt;</strong> tag can be bound to a Maven constant that you have to maintain in order to avoid running the Code Generator when nothing has changed.</p>
			<p>Besides this stub, we need the following dependency:</p>
			<pre class="source-code">&lt;dependency&gt;</pre>
			<pre class="source-code">  &lt;groupId&gt;org.jooq{.trial-java-8}&lt;/groupId&gt;</pre>
			<pre class="source-code">  &lt;artifactId&gt;jooq-meta-extensions&lt;/artifactId&gt;</pre>
			<pre class="source-code">  &lt;version&gt;${jooq.version}&lt;/version&gt;</pre>
			<pre class="source-code">&lt;/dependency&gt;</pre>
			<p>Based on this stub and the explanations from the comments, let's try to fill up the missing parts to configure the jOOQ Code Generator against the <strong class="source-inline">classicmodels</strong> database in PostgreSQL:</p>
			<pre class="source-code">&lt;configuration xmlns = "..."&gt;</pre>
			<pre class="source-code">  &lt;generator&gt;</pre>
			<pre class="source-code">    &lt;name&gt;org.jooq.codegen.JavaGenerator&lt;/name&gt;</pre>
			<pre class="source-code">    &lt;database&gt;</pre>
			<pre class="source-code">      &lt;name&gt;org.jooq.meta.extensions.ddl.DDLDatabase&lt;/name&gt;</pre>
			<pre class="source-code">      &lt;properties&gt;</pre>
			<pre class="source-code">        &lt;property&gt;</pre>
			<pre class="source-code">          &lt;key&gt;scripts&lt;/key&gt;</pre>
			<pre class="source-code">          &lt;value&gt;...db/migration/ddl/postgresql/sql&lt;/value&gt;</pre>
			<pre class="source-code">        &lt;/property&gt;</pre>
			<pre class="source-code">        &lt;property&gt;</pre>
			<pre class="source-code">          &lt;key&gt;sort&lt;/key&gt;</pre>
			<pre class="source-code">          &lt;value&gt;flyway&lt;/value&gt;</pre>
			<pre class="source-code">        &lt;/property&gt;</pre>
			<pre class="source-code">        &lt;property&gt;</pre>
			<pre class="source-code">          &lt;key&gt;unqualifiedSchema&lt;/key&gt;</pre>
			<pre class="source-code">          &lt;value&gt;none&lt;/value&gt;</pre>
			<pre class="source-code">        &lt;/property&gt;</pre>
			<pre class="source-code">        &lt;property&gt;</pre>
			<pre class="source-code">          &lt;key&gt;defaultNameCase&lt;/key&gt;</pre>
			<pre class="source-code">          &lt;value&gt;lower&lt;/value&gt;</pre>
			<pre class="source-code">        &lt;/property&gt;</pre>
			<pre class="source-code">      &lt;/properties&gt;</pre>
			<pre class="source-code">      &lt;inputSchema&gt;PUBLIC&lt;/inputSchema&gt;</pre>
			<pre class="source-code">      &lt;includes&gt;.*&lt;/includes&gt;</pre>
			<pre class="source-code">      &lt;excludes&gt;</pre>
			<pre class="source-code">            flyway_schema_history | akeys | avals | defined </pre>
			<pre class="source-code">          | delete.* | department_topic_arr | dup </pre>
			<pre class="source-code">          |  ...</pre>
			<pre class="source-code">      &lt;/excludes&gt;</pre>
			<pre class="source-code">        &lt;schemaVersionProvider&gt;</pre>
			<pre class="source-code">          ${schema.version} &lt;!-- this is a Maven constant --&gt;</pre>
			<pre class="source-code">        &lt;/schemaVersionProvider&gt;</pre>
			<pre class="source-code">        &lt;logSlowQueriesAfterSeconds&gt;</pre>
			<pre class="source-code">          20</pre>
			<pre class="source-code">        &lt;/logSlowQueriesAfterSeconds&gt;</pre>
			<pre class="source-code">      &lt;/database&gt;</pre>
			<pre class="source-code">    &lt;target&gt;</pre>
			<pre class="source-code">      &lt;packageName&gt;jooq.generated&lt;/packageName&gt;</pre>
			<pre class="source-code">      &lt;directory&gt;target/generated-sources&lt;/directory&gt;</pre>
			<pre class="source-code">    &lt;/target&gt;</pre>
			<pre class="source-code">  &lt;/generator&gt;</pre>
			<pre class="source-code">&lt;/configuration&gt;</pre>
			<p>The Gradle alternative<a id="_idIndexMarker075"/> is available in the bundled code.</p>
			<h3>Preparing the SQL files</h3>
			<p>Currently, it is<a id="_idIndexMarker076"/> impossible to use some vendor-specific stuff; therefore, our SQL files may contain parts that the jOOQ SQL parser may not understand. In such cases, we have to prepare our SQL files by delimiting these parts with the jOOQ default conventions from the following example:</p>
			<pre class="source-code">-- [jooq ignore start]</pre>
			<pre class="source-code">IF OBJECT_ID('payment', 'U') IS NOT NULL </pre>
			<pre class="source-code">  DROP TABLE payment;</pre>
			<pre class="source-code">-- [jooq ignore stop]</pre>
			<p>The <a id="_idIndexMarker077"/>code between <strong class="source-inline">-- [jooq ignore start]</strong> and <strong class="source-inline">-- [jooq ignore stop]</strong> is ignored by the jOOQ SQL parser. Turning on/off ignoring content between such tokens can be done via the <strong class="source-inline">parseIgnoreComments</strong> Boolean property, while customizing these tokens can be done via the <strong class="source-inline">parseIgnoreCommentStart</strong> and <strong class="source-inline">parseIgnoreCommentStop</strong> properties. For more details, refer to <a href="https://www.jooq.org/doc/latest/manual/code-generation/codegen-ddl/">https://www.jooq.org/doc/latest/manual/code-generation/codegen-ddl/</a>.</p>
			<p>In the bundled code, you can see an implementation of this stub for MySQL, PostgreSQL, SQL Server, and Oracle via the Java/Kotlin and Maven/Gradle combos, under the name <em class="italic">DeclarativeDDLDatabase</em>.</p>
			<p>Going forward, while the jOOQ SQL parser will become more powerful, this will be the recommended approach for using the jOOQ Code Generator. The goal is to delegate jOOQ to do more migration work out of the box.</p>
			<h2 id="_idParaDest-31"><a id="_idTextAnchor030"/>Code generation from entities (JPA)</h2>
			<p>Let's assume<a id="_idIndexMarker078"/> that you have a JPA application that relies on a schema shaped as an entity model (JPA-annotated entities) and <a id="_idIndexMarker079"/>you want to obtain the jOOQ Java-based schema. If you cannot isolate the JPA entity model in a separate module of the application, then you can configure jOOQ to generate the Java-based schema directly from the real database (supposing that you have access to the real database schema during the development stage) or from the DDL files (assuming that you have such files). But, if you can easily place the entities in a separate module of the application, then you can rely on jOOQ's JPA Database API (<strong class="source-inline">org.jooq.meta.extensions.jpa.JPADatabase</strong>), which is capable of generating the Java-based schema from the JPA model. The JPA Database API requires entities in a separate module because it has to look them up from the classpath via Spring.</p>
			<p>The following figure depicts the flow of the JPA Database API:</p>
			<div>
				<div id="_idContainer011" class="IMG---Figure">
					<img src="image/B16833_Figure_2.5.jpg" alt="Figure 2.5 – The jOOQ Java-based schema generation via the JPA Database API&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 2.5 – The jOOQ Java-based schema generation via the JPA Database API</p>
			<p>The<a id="_idIndexMarker080"/> flow of <a id="_idIndexMarker081"/>the JPA Database API uses Hibernate internally for generating an in-memory H2 database from the JPA model (entities). Subsequently, jOOQ reverse-engineers this H2 database into jOOQ classes (the Java-based schema).</p>
			<h3>Running the Code Generator with Maven </h3>
			<p>In this <a id="_idIndexMarker082"/>context, running the Code Generator via Maven relies on the following XML stub. Read each comment, since they contain valuable information (in the bundled code, you can find an expanded version of these comments):</p>
			<pre class="source-code">&lt;configuration xmlns="..."&gt;</pre>
			<pre class="source-code">  &lt;!-- JDBC connection to the H2 in-memory database --&gt;</pre>
			<pre class="source-code">  &lt;jdbc&gt;...&lt;/jdbc&gt;</pre>
			<pre class="source-code">  &lt;generator&gt;</pre>
			<pre class="source-code">    &lt;database&gt;</pre>
			<pre class="source-code">      &lt;name&gt;org.jooq.meta.extensions.jpa.JPADatabase&lt;/name&gt;</pre>
			<pre class="source-code">      &lt;properties&gt;</pre>
			<pre class="source-code">        &lt;!-- The properties prefixed with hibernate... or </pre>
			<pre class="source-code">        javax.persistence... will be passed to Hibernate --&gt;</pre>
			<pre class="source-code">        &lt;property&gt;</pre>
			<pre class="source-code">          &lt;key&gt;...&lt;/key&gt;</pre>
			<pre class="source-code">          &lt;value&gt;...&lt;/value&gt;</pre>
			<pre class="source-code">        &lt;/property&gt;</pre>
			<pre class="source-code">        &lt;!-- Java packages (comma separated) that </pre>
			<pre class="source-code">        contains your entities --&gt;</pre>
			<pre class="source-code">        &lt;property&gt;</pre>
			<pre class="source-code">          &lt;key&gt;packages&lt;/key&gt;</pre>
			<pre class="source-code">          &lt;value&gt;...&lt;/value&gt;</pre>
			<pre class="source-code">        &lt;/property&gt;</pre>
			<pre class="source-code">        &lt;!-- Whether JPA 2.1 AttributeConverters should </pre>
			<pre class="source-code">        be auto-mapped to jOOQ Converters (default true) --&gt;</pre>
			<pre class="source-code">        &lt;property&gt;</pre>
			<pre class="source-code">          &lt;key&gt;useAttributeConverters&lt;/key&gt;</pre>
			<pre class="source-code">          &lt;value&gt;...&lt;/value&gt;</pre>
			<pre class="source-code">        &lt;/property&gt;</pre>
			<pre class="source-code">        &lt;!-- The default schema for unqualified objects</pre>
			<pre class="source-code">        (public, none) --&gt;</pre>
			<pre class="source-code">        &lt;property&gt;</pre>
			<pre class="source-code">          &lt;key&gt;unqualifiedSchema&lt;/key&gt;</pre>
			<pre class="source-code">          &lt;value&gt;...&lt;/value&gt;</pre>
			<pre class="source-code">        &lt;/property&gt;</pre>
			<pre class="source-code">      &lt;/properties&gt;</pre>
			<pre class="source-code">      &lt;includes&gt;...&lt;/includes&gt;</pre>
			<pre class="source-code">      &lt;excludes&gt;...&lt;/excludes&gt;</pre>
			<pre class="source-code">      &lt;schemaVersionProvider&gt;...&lt;/schemaVersionProvider&gt;</pre>
			<pre class="source-code">      &lt;logSlowQueriesAfterSeconds&gt;</pre>
			<pre class="source-code">      ...</pre>
			<pre class="source-code">      &lt;/logSlowQueriesAfterSeconds&gt;</pre>
			<pre class="source-code">    &lt;/database&gt;</pre>
			<pre class="source-code">    &lt;target&gt;</pre>
			<pre class="source-code">      &lt;packageName&gt;...&lt;/packageName&gt;</pre>
			<pre class="source-code">      &lt;directory&gt;...&lt;/directory&gt;</pre>
			<pre class="source-code">    &lt;/target&gt;</pre>
			<pre class="source-code">  &lt;/generator&gt;</pre>
			<pre class="source-code">&lt;/configuration&gt;</pre>
			<p>Based <a id="_idIndexMarker083"/>on this stub and the comments, here is an example containing the popular settings (this snippet was extracted from a JPA application that uses MySQL as the real database):</p>
			<pre class="source-code">&lt;configuration xmlns="..."&gt;</pre>
			<pre class="source-code">  &lt;jdbc&gt;</pre>
			<pre class="source-code">    &lt;driver&gt;org.h2.Driver&lt;/driver&gt;</pre>
			<pre class="source-code">    &lt;url&gt;jdbc:h2:~/classicmodels&lt;/url&gt;</pre>
			<pre class="source-code">  &lt;/jdbc&gt;</pre>
			<pre class="source-code">  &lt;generator&gt;</pre>
			<pre class="source-code">    &lt;database&gt;</pre>
			<pre class="source-code">      &lt;name&gt;org.jooq.meta.extensions.jpa.JPADatabase&lt;/name&gt;</pre>
			<pre class="source-code">      &lt;properties&gt;</pre>
			<pre class="source-code">        &lt;property&gt;</pre>
			<pre class="source-code">          &lt;key&gt;hibernate.physical_naming_strategy&lt;/key&gt;</pre>
			<pre class="source-code">          &lt;value&gt;</pre>
			<pre class="source-code">            org.springframework.boot.orm.jpa</pre>
			<pre class="source-code">               .hibernate.SpringPhysicalNamingStrategy</pre>
			<pre class="source-code">          &lt;/value&gt;</pre>
			<pre class="source-code">        &lt;/property&gt;</pre>
			<pre class="source-code">        &lt;property&gt;</pre>
			<pre class="source-code">          &lt;key&gt;packages&lt;/key&gt;</pre>
			<pre class="source-code">          &lt;value&gt;com.classicmodels.entity&lt;/value&gt;</pre>
			<pre class="source-code">        &lt;/property&gt;</pre>
			<pre class="source-code">        &lt;property&gt;</pre>
			<pre class="source-code">          &lt;key&gt;useAttributeConverters&lt;/key&gt;</pre>
			<pre class="source-code">          &lt;value&gt;true&lt;/value&gt;</pre>
			<pre class="source-code">        &lt;/property&gt;</pre>
			<pre class="source-code">        &lt;property&gt;</pre>
			<pre class="source-code">          &lt;key&gt;unqualifiedSchema&lt;/key&gt;</pre>
			<pre class="source-code">          &lt;value&gt;none&lt;/value&gt;</pre>
			<pre class="source-code">        &lt;/property&gt;</pre>
			<pre class="source-code">      &lt;/properties&gt;</pre>
			<pre class="source-code">   </pre>
			<pre class="source-code">      &lt;includes&gt;.*&lt;/includes&gt;</pre>
			<pre class="source-code">       &lt;excludes&gt;</pre>
			<pre class="source-code">             flyway_schema_history | sequences </pre>
			<pre class="source-code">             | customer_pgs | refresh_top3_product</pre>
			<pre class="source-code">             | sale_.* | set_.* | get_.* | .*_master</pre>
			<pre class="source-code">       &lt;/excludes&gt;</pre>
			<pre class="source-code">   </pre>
			<pre class="source-code">       &lt;schemaVersionProvider&gt;</pre>
			<pre class="source-code">         ${schema.version}</pre>
			<pre class="source-code">       &lt;/schemaVersionProvider&gt;                       </pre>
			<pre class="source-code">   </pre>
			<pre class="source-code">       &lt;logSlowQueriesAfterSeconds&gt;</pre>
			<pre class="source-code">         20</pre>
			<pre class="source-code">       &lt;/logSlowQueriesAfterSeconds&gt;</pre>
			<pre class="source-code">     &lt;/database&gt;</pre>
			<pre class="source-code">      &lt;target&gt;</pre>
			<pre class="source-code">        &lt;packageName&gt;jooq.generated&lt;/packageName&gt;</pre>
			<pre class="source-code">        &lt;directory&gt;target/generated-sources&lt;/directory&gt;</pre>
			<pre class="source-code">      &lt;/target&gt;</pre>
			<pre class="source-code">    &lt;/generator&gt;</pre>
			<pre class="source-code">  &lt;/configuration&gt;</pre>
			<p>Besides<a id="_idIndexMarker084"/> this stub, we need the following dependency:</p>
			<pre class="source-code">&lt;dependency&gt;</pre>
			<pre class="source-code">  &lt;groupId&gt;org.jooq{.trial-java-8}&lt;/groupId&gt;</pre>
			<pre class="source-code">  &lt;!-- before jOOQ 3.14.x, jooq-meta-extensions --&gt;</pre>
			<pre class="source-code">  &lt;artifactId&gt;jooq-meta-extensions-hibernate&lt;/artifactId&gt;</pre>
			<pre class="source-code">  &lt;version&gt;${jooq.meta.extensions.hibernate.version}</pre>
			<pre class="source-code">  &lt;/version&gt;</pre>
			<pre class="source-code">&lt;/dependency&gt;</pre>
			<p>This approach and the Gradle alternative are available in the bundled code for Java and Kotlin under the name <strong class="source-inline">DeclarativeJPADatabase</strong>.</p>
			<p>Another approach that you'll find interesting is generating the Java-based schema from XML files: <a href="https://www.jooq.org/doc/latest/manual/code-generation/codegen-xml/">https://www.jooq.org/doc/latest/manual/code-generation/codegen-xml/</a>. This is exemplified in <strong class="source-inline">DeclarativeXMLDatabase</strong> and <strong class="source-inline">ProgrammaticXMLGenerator</strong>.</p>
			<p>Generally speaking, it is highly recommended to read the <em class="italic">Code generation</em> section of the jOOQ manual: <a href="https://www.jooq.org/doc/latest/manual/code-generation/">https://www.jooq.org/doc/latest/manual/code-generation/</a>. This section contains tons of settings and configurations that influence the generated artifacts.</p>
			<p>If you need to manage multiple databases, schemas, catalogs, a shared-schema multitenancy, and so on, then refer to <a href="B16833_17.xhtml#_idTextAnchor330"><em class="italic">Chapter 17</em></a>, <em class="italic">Multitenancy in jOOQ</em>.</p>
			<h1 id="_idParaDest-32"><a id="_idTextAnchor031"/>Writing queries using a Java-based schema</h1>
			<p>Once jOOQ's Code Generator has done its job, we have access to the generated artifacts. Among<a id="_idIndexMarker085"/> these artifacts, we have the <strong class="source-inline">jooq.generated.tables</strong> folder, which contains the database tables mirrored as Java code. The generated artifacts are placed in the specified <strong class="source-inline">/target</strong> folder (in our case, <strong class="source-inline">target/generated-sources</strong>) under the specified package name (in our case, <strong class="source-inline">jooq.generated</strong>).</p>
			<p class="callout-heading">Important Note</p>
			<p class="callout">Typically, you'll instruct the jOOQ Code Generator to store generated code under the <strong class="source-inline">/target</strong> folder (Maven), <strong class="source-inline">/build</strong> folder (Gradle), or <strong class="source-inline">/src</strong> folder. Basically, if you choose the <strong class="source-inline">/target</strong> or <strong class="source-inline">/build</strong> folder, then jOOQ regenerates the code at each build; therefore, you are sure that sources are always up to date. Nevertheless, to decide which path fits best to your strategic case, consider reading Lukas Eder's answer from Stack Overflow: <a href="https://stackoverflow.com/questions/25576538/why-does-jooq-suggest-to-put-generated-code-under-target-and-not-under-src">https://stackoverflow.com/questions/25576538/why-does-jooq-suggest-to-put-generated-code-under-target-and-not-under-src</a>. It is also recommended to check out the <em class="italic">Code generation and version control</em> section from the jOOQ manual, available<a id="_idIndexMarker086"/> at <a href="https://www.jooq.org/doc/latest/manual/code-generation/codegen-version-control/">https://www.jooq.org/doc/latest/manual/code-generation/codegen-version-control/</a>.</p>
			<p>Remember that, in the previous chapter (<a href="B16833_01.xhtml#_idTextAnchor015"><em class="italic">Chapter 1</em></a>, <em class="italic">Starting jOOQ and Spring Boot</em>), we already used the jOOQ DSL API to write the following query:</p>
			<pre class="source-code">ResultQuery&lt;?&gt; query = ctx.selectFrom(table("office")) </pre>
			<pre class="source-code">  .where(field("territory").eq(territory));</pre>
			<p>This query references the database schema (table and columns). Rewriting this query referencing the Java-based schema produces the following code (jOOQ <strong class="source-inline">Record</strong> such as <strong class="source-inline">OfficeRecord</strong> are introduced in the next chapter; for now, think of it as the result set wrapped in a Java object):</p>
			<pre class="source-code">import static jooq.generated.tables.Office.OFFICE; </pre>
			<pre class="source-code">import jooq.generated.tables.records.OfficeRecord;</pre>
			<pre class="source-code">...</pre>
			<pre class="source-code">ResultQuery&lt;OfficeRecord&gt; query = ctx.selectFrom(OFFICE) </pre>
			<pre class="source-code">  .where(OFFICE.TERRITORY.eq(territory));</pre>
			<p>Alternatively, generating<a id="_idIndexMarker087"/> and executing the query immediately can be done as follows (<strong class="source-inline">Office</strong> is a POJO):</p>
			<pre class="source-code">public List&lt;Office&gt; findOfficesInTerritory(String territory) {</pre>
			<pre class="source-code">  List&lt;Office&gt; result = ctx.selectFrom(OFFICE) </pre>
			<pre class="source-code">    .where(OFFICE.TERRITORY.eq(territory))</pre>
			<pre class="source-code">    .fetchInto(Office.class); </pre>
			<pre class="source-code">  return result;</pre>
			<pre class="source-code">}</pre>
			<p>Depending on the database vendor, the generated SQL looks as follows with MySQL (note that jOOQ has correctly generated backticks specific to MySQL queries):</p>
			<pre class="source-code">SELECT</pre>
			<pre class="source-code">  `classicmodels`.`office`.`office_code`, </pre>
			<pre class="source-code">  `classicmodels`.`office`.`city`, </pre>
			<pre class="source-code">  ...</pre>
			<pre class="source-code">  `classicmodels`.`office`.`territory` </pre>
			<pre class="source-code">FROM `classicmodels`.`office` </pre>
			<pre class="source-code">WHERE `classicmodels`.`office`.`territory` = ?</pre>
			<p>The generated SQL looks as follows with PostgreSQL (note that jOOQ has used the qualification containing the PostgreSQL schema):</p>
			<pre class="source-code">SELECT </pre>
			<pre class="source-code">  "public"."office"."office_code", </pre>
			<pre class="source-code">  "public"."office"."city", </pre>
			<pre class="source-code">  ...</pre>
			<pre class="source-code">  "public"."office"."territory" </pre>
			<pre class="source-code">FROM "public"."office" </pre>
			<pre class="source-code">WHERE "public"."office"."territory" = ?</pre>
			<p>The generated SQL looks as follows with Oracle (note that jOOQ has made the identifiers uppercase, exactly as Oracle prefers):</p>
			<pre class="source-code">SELECT</pre>
			<pre class="source-code">  "CLASSICMODELS"."OFFICE"."OFFICE_CODE", </pre>
			<pre class="source-code">  "CLASSICMODELS"."OFFICE"."CITY", </pre>
			<pre class="source-code">  ...</pre>
			<pre class="source-code">  "CLASSICMODELS"."OFFICE"."TERRITORY" </pre>
			<pre class="source-code">FROM "CLASSICMODELS"."OFFICE" </pre>
			<pre class="source-code">WHERE "CLASSICMODELS"."OFFICE"."TERRITORY" = ?</pre>
			<p>The <a id="_idIndexMarker088"/>generated SQL looks as follows with SQL Server (note that jOOQ has used <strong class="source-inline">[]</strong>, specific to SQL Server):</p>
			<pre class="source-code">SELECT</pre>
			<pre class="source-code">  [classicmodels].[dbo].[office].[office_code], </pre>
			<pre class="source-code">  [classicmodels].[dbo].[office].[city], </pre>
			<pre class="source-code">  ...</pre>
			<pre class="source-code">  [classicmodels].[dbo].[office].[territory] </pre>
			<pre class="source-code">FROM [classicmodels].[dbo].[office] </pre>
			<pre class="source-code">WHERE [classicmodels].[dbo].[office].[territory] = ?</pre>
			<p>So, depending on the dialect, jOOQ has produced the expected query. </p>
			<p class="callout-heading">Important Note</p>
			<p class="callout">Note that <strong class="source-inline">selectFrom(table("OFFICE"))</strong> has been rendered as <strong class="source-inline">*</strong>, while <strong class="source-inline">selectFrom(OFFICE)</strong> has been rendered as a list of column names. In the first case, jOOQ cannot infer the columns from the argument table; therefore, it projects <strong class="source-inline">*</strong>. In the second case, thanks to the Java-based schema, jOOQ projects the known columns from the table, which avoids the usage of the controversial <strong class="source-inline">*</strong>. Of course, <strong class="source-inline">*</strong> per se isn't controversial – just the fact that the columns aren't listed explicitly, as this article explains: <a href="https://tanelpoder.com/posts/reasons-why-select-star-is-bad-for-sql-performance/">https://tanelpoder.com/posts/reasons-why-select-star-is-bad-for-sql-performance/</a>.</p>
			<p>Let's try<a id="_idIndexMarker089"/> another example that queries the <strong class="source-inline">ORDER</strong> table. Since <strong class="source-inline">ORDER</strong> is a reserved word in most dialects, let's see how jOOQ will handle it. Note that our query doesn't do anything special to instruct jOOQ about this aspect:</p>
			<pre class="source-code">ResultQuery&lt;OrderRecord&gt; query = ctx.selectFrom(ORDER)    </pre>
			<pre class="source-code">  .where(ORDER.REQUIRED_DATE.between(startDate, endDate));</pre>
			<p>Or, generating and executing it immediately (<strong class="source-inline">Order</strong> is a POJO):</p>
			<pre class="source-code">public List&lt;Order&gt; findOrdersByRequiredDate(</pre>
			<pre class="source-code">      LocalDate startDate, LocalDate endDate) {</pre>
			<pre class="source-code">  List&lt;Order&gt; result = ctx.selectFrom(ORDER)</pre>
			<pre class="source-code">    .where(ORDER.REQUIRED_DATE.between(startDate, endDate))  </pre>
			<pre class="source-code">    .fetchInto(Order.class); </pre>
			<pre class="source-code">  return result;</pre>
			<pre class="source-code">}</pre>
			<p>Let's see the valid SQL generated for MySQL:</p>
			<pre class="source-code">SELECT </pre>
			<pre class="source-code">  `classicmodels`.`order`.`order_id`, </pre>
			<pre class="source-code">  ...</pre>
			<pre class="source-code">  `classicmodels`.`order`.`customer_number` </pre>
			<pre class="source-code">FROM `classicmodels`.`order` </pre>
			<pre class="source-code">WHERE `classicmodels`.`order`.`required_date` </pre>
			<pre class="source-code">  BETWEEN ? AND ? </pre>
			<p>For brevity, we'll <a id="_idIndexMarker090"/>skip the generated SQL for PostgreSQL, Oracle, and SQL Server. Mainly, since jOOQ quotes everything by default, we can use reserved and unreserved names exactly in the same way and get back valid SQL statements.</p>
			<p>Let's tackle one more example:</p>
			<pre class="source-code">ResultQuery&lt;Record2&lt;String, LocalDate&gt;&gt; query = ctx.select(</pre>
			<pre class="source-code">         CUSTOMER.CUSTOMER_NAME, ORDER.ORDER_DATE)      </pre>
			<pre class="source-code">  .from(ORDER)</pre>
			<pre class="source-code">  .innerJoin(CUSTOMER).using(CUSTOMER.CUSTOMER_NUMBER)</pre>
			<pre class="source-code">  .orderBy(ORDER.ORDER_DATE.desc());</pre>
			<p>Or, generating and executing it immediately (<strong class="source-inline">CustomerAndOrder</strong> is a POJO):</p>
			<pre class="source-code">public List&lt;CustomerAndOrder&gt; findCustomersAndOrders() {</pre>
			<pre class="source-code">  List&lt;CustomerAndOrder&gt; result </pre>
			<pre class="source-code">    = ctx.select(CUSTOMER.CUSTOMER_NAME, ORDER.ORDER_DATE)</pre>
			<pre class="source-code">         .from(ORDER)</pre>
			<pre class="source-code">         .innerJoin(CUSTOMER).using(CUSTOMER.CUSTOMER_NUMBER)</pre>
			<pre class="source-code">         .orderBy(ORDER.ORDER_DATE.desc())</pre>
			<pre class="source-code">         .fetchInto(CustomerAndOrder.class); </pre>
			<pre class="source-code">  return result;</pre>
			<pre class="source-code">}</pre>
			<p>This query uses the <strong class="source-inline">JOIN</strong>...<strong class="source-inline">USING</strong> syntax. Basically, instead of a condition via the <strong class="source-inline">ON</strong> clause, you supply a set of fields that have an important particularity – their names are common to both tables to the left and right of the join operator. However, some dialects (for example, Oracle) don't allow us to use qualified names in <strong class="source-inline">USING</strong>. Having qualified names leads to an error such as <strong class="source-inline">ORA-25154: column part of USING clause cannot have qualifier</strong>.</p>
			<p>jOOQ is <a id="_idIndexMarker091"/>aware of this aspect and takes action. Following the Oracle dialect, jOOQ renders <strong class="source-inline">CUSTOMER.CUSTOMER_NUMBER</strong> as <strong class="source-inline">"CUSTOMER_NUMBER"</strong>, not qualified as <strong class="source-inline">"CLASSICMODELS"."CUSTOMER"."CUSTOMER_NUMBER"</strong>. Check this here:</p>
			<pre class="source-code">SELECT </pre>
			<pre class="source-code">  "CLASSICMODELS"."CUSTOMER"."CUSTOMER_NAME", </pre>
			<pre class="source-code">  "CLASSICMODELS"."ORDER"."ORDER_DATE" </pre>
			<pre class="source-code">FROM </pre>
			<pre class="source-code">  "CLASSICMODELS"."ORDER" </pre>
			<pre class="source-code">  JOIN "CLASSICMODELS"."CUSTOMER" USING ("CUSTOMER_NUMBER") </pre>
			<pre class="source-code">ORDER BY</pre>
			<pre class="source-code">  "CLASSICMODELS"."ORDER"."ORDER_DATE" DESC</pre>
			<p>This was just an example of how jOOQ takes care of the generated SQL by emulating the correct syntax, depending on the dialect used! Thanks to jOOQ code generation, we benefit from default choices for so many silly edge cases that are so annoying to handle later on.</p>
			<p>Let's summarize a handful of advantages brought by jOOQ code generation:</p>
			<ul>
				<li>Type-safe SQL queries. Did I mention type-safe SQL queries?!</li>
				<li>No need to worry about the identifier's case sensitivity, quotation, and qualification.</li>
				<li>Using generated code makes for much leaner expressions. There's less wrapping noise such as <strong class="source-inline">field("X", "Y")</strong>, <strong class="source-inline">field(name("X", "Y"))</strong>, or <strong class="source-inline">field(name("X", "Y"), DATA_TYPE)</strong>. Via jOOQ code generation, this would just be <strong class="source-inline">X.Y</strong>.</li>
				<li>The IDE can provide code completion and refactoring support.</li>
				<li>We can use the IDE to find uses of tables and columns because they're Java objects.</li>
				<li>The <a id="_idIndexMarker092"/>code will no longer compile when the columns are renamed, rather than having to run the query for it to fail.</li>
				<li>Avoidance of issues caused by edge cases with vendor-specific data types. </li>
				<li>Since jOOQ quotes everything by default, users don't have to think of quoting reserved names such as <strong class="source-inline">table(name("ORDER"))</strong>. It's just <strong class="source-inline">ORDER</strong>, and jOOQ will produce <strong class="source-inline">`ORDER`</strong>, <strong class="source-inline">"ORDER"</strong>, <strong class="source-inline">[ORDER]</strong>, or whatever is specific to the used dialect.<p class="callout-heading">Important Note</p><p class="callout">As a rule of thumb, always consider jOOQ code generation as the default way to exploit jOOQ. Of course, there are edge cases when code generation cannot be fully exploited (for instance, in the case of schemas that are created/modified dynamically at runtime), but this is a different story.</p></li>
			</ul>
			<p>The application developed in this section is named <em class="italic">WriteTypesafeSQL</em>.</p>
			<h2 id="_idParaDest-33"><a id="_idTextAnchor032"/>jOOQ versus JPA Criteria versus QueryDSL</h2>
			<p>All these<a id="_idIndexMarker093"/> three, jOOQ, JPA Criteria (or the Spring Data JPA Specifications API built on top of the Criteria API), and QueryDSL, can provide type-safe SQL.</p>
			<p>If you come from <a id="_idIndexMarker094"/>a JPA background, then you know that JPA defines a Metamodel API for Criteria queries. So, the Criteria API and the Metamodel API can provide type safety for SQL as well. But, the Criteria API is quite complicated compared to QueryDSL. You don't have to take my word for it – try it! However, the Criteria API is something that you need to learn in addition to JPQL and all the JPA stuff. Also, it is not intuitive, it is poorly documented, and developers describe it as quite slow. Moreover, having 100% type safety means having to write all SQL statements that are prone to type errors via the Criteria API.</p>
			<p>QueryDSL<a id="_idIndexMarker095"/> supports SQL type <a id="_idIndexMarker096"/>safety as well. Having support in Spring Boot, QueryDSL is well covered in this article<a id="_idIndexMarker097"/> at <a href="https://dzone.com/articles/querydsl-vs-jooq-feature">https://dzone.com/articles/querydsl-vs-jooq-feature</a>, which contains a non-exhaustive list of jOOQ support beyond QueryDSL's "feature completeness." Nevertheless, that <a id="_idIndexMarker098"/>article is quite old and may be out of date. Meanwhile, jOOQ has even more advantages that you can find yourself by a quick search on <strong class="source-inline">reddit.com</strong>.</p>
			<p>Next, let's go one step further and give more control to jOOQ.</p>
			<h1 id="_idParaDest-34"><a id="_idTextAnchor033"/>Configuring jOOQ to generate POJOs</h1>
			<p>So far, we<a id="_idIndexMarker099"/> have used our own <strong class="bold">POJOs</strong> as our <a id="_idIndexMarker100"/>primary <strong class="bold">Data</strong> <strong class="bold">Transfer Objects</strong> (<strong class="bold">DTOs</strong>). This is a common approach in<a id="_idIndexMarker101"/> layered applications such as Spring Boot applications.</p>
			<p>The <strong class="source-inline">Office</strong> and <strong class="source-inline">Order</strong> POJOs are Java mirrors of the <strong class="source-inline">OFFICE</strong> and <strong class="source-inline">ORDER</strong> tables, since our queries fetch all the columns from these tables. On the other hand, the <strong class="source-inline">CustomerAndOrder</strong> POJO maps columns from two different tables, <strong class="source-inline">CUSTOMER</strong> and <strong class="source-inline">ORDER</strong>. More precisely, it maps <strong class="source-inline">CUSTOMER_NAME</strong> from <strong class="source-inline">CUSTOMER</strong> and <strong class="source-inline">ORDER_DATE</strong> from <strong class="source-inline">ORDER</strong>.</p>
			<p>Optionally, jOOQ can <a id="_idIndexMarker102"/>generate POJOs on our behalf via the jOOQ Code Generator. In Maven, this feature can be enabled via the following configuration into the <strong class="source-inline">&lt;generator&gt;</strong> tag:</p>
			<pre class="source-code">&lt;generator&gt;</pre>
			<pre class="source-code">  ...</pre>
			<pre class="source-code"><strong class="bold">  &lt;generate&gt;</strong></pre>
			<pre class="source-code"><strong class="bold">    &lt;pojos&gt;true&lt;/pojos&gt;</strong></pre>
			<pre class="source-code"><strong class="bold">  &lt;/generate&gt;</strong></pre>
			<pre class="source-code">  ...</pre>
			<pre class="source-code">&lt;/generator&gt;</pre>
			<p>Additionally, jOOQ can add to the generated POJOs a set of Bean Validation API annotations <a id="_idIndexMarker103"/>to convey type information. More precisely, they<a id="_idIndexMarker104"/> include two well-known validation annotations – <strong class="source-inline">@NotNull</strong> (<strong class="source-inline">javax/jakarta.validation.constraints.NotNull</strong>) and <strong class="source-inline">@Size</strong> (<strong class="source-inline">javax/jakarta</strong><strong class="source-inline">.validation.constraints.Size</strong>). To enable these annotations, the configuration should be as follows:</p>
			<pre class="source-code">&lt;generate&gt;</pre>
			<pre class="source-code">  &lt;pojos&gt;true&lt;/pojos&gt;</pre>
			<pre class="source-code">  &lt;validationAnnotations&gt;true&lt;/validationAnnotations&gt;</pre>
			<pre class="source-code">&lt;/generate&gt;</pre>
			<p>Also, you should add the dependency for <strong class="source-inline">validation-api</strong> as in the bundled code.</p>
			<p>By default, the names of the generated POJOs are the same as the names of the tables in <em class="italic">Pascal</em> case (for instance, the table named <strong class="source-inline">office_has_manager</strong> becomes <strong class="source-inline">OfficeHasManager</strong>). Altering the default behavior can be achieved via so-called <em class="italic">generator strategies</em> – basically, in Maven, a piece of XML delimited by the <strong class="source-inline">&lt;strategy&gt;</strong> tag that relies on regular expressions for producing custom (user-defined) output. For example, if the POJOs are prefixed with the <strong class="source-inline">Jooq</strong> text, then the generator strategy will be the following:</p>
			<pre class="source-code">&lt;strategy&gt;</pre>
			<pre class="source-code">  &lt;matchers&gt;</pre>
			<pre class="source-code">    &lt;tables&gt;</pre>
			<pre class="source-code">      &lt;table&gt;</pre>
			<pre class="source-code">        &lt;pojoClass&gt;</pre>
			<pre class="source-code">          &lt;expression&gt;JOOQ_$0&lt;/expression&gt;</pre>
			<pre class="source-code">          &lt;transform&gt;PASCAL&lt;/transform&gt;</pre>
			<pre class="source-code">        &lt;/pojoClass&gt;</pre>
			<pre class="source-code">      ...</pre>
			<pre class="source-code">&lt;/strategy&gt;</pre>
			<p>This time, the table named <strong class="source-inline">office_has_manager</strong> results in a POJO source named <strong class="source-inline">JooqOfficeHasManager</strong>. More details about the generator strategies (including the programmatic approach) are available in <a href="B16833_18.xhtml#_idTextAnchor338"><em class="italic">Chapter 18</em></a>, <em class="italic">jOOQ SPI (Providers and Listeners)</em>. Also, it is recommended to read <a href="https://www.jooq.org/doc/latest/manual/code-generation/codegen-matcherstrategy/">https://www.jooq.org/doc/latest/manual/code-generation/codegen-matcherstrategy/</a>.</p>
			<p>The Gradle alternative is available in the bundled code.</p>
			<p>By default, jOOQ generates<a id="_idIndexMarker105"/> a POJO for each table in <a id="_idIndexMarker106"/>the database. Therefore, by default, jOOQ can generate a POJO as <strong class="source-inline">Office</strong> and <strong class="source-inline">Order</strong> (or <strong class="source-inline">JooqOffice</strong> and <strong class="source-inline">JooqOrder</strong>, conforming to the preceding strategy), but its purpose is not to generate more complex POJOs, such as composite POJOs or ones containing arbitrary objects (such as <strong class="source-inline">CustomerAndOrder</strong>). The following is the source code of <strong class="source-inline">JooqOffice</strong>, generated by jOOQ:</p>
			<pre class="source-code">public class JooqOffice implements Serializable {</pre>
			<pre class="source-code">  private static final long serialVersionUID = 1821407394;</pre>
			<pre class="source-code">  private String officeCode;</pre>
			<pre class="source-code">  private String city;</pre>
			<pre class="source-code">  ...</pre>
			<pre class="source-code">  private String territory;</pre>
			<pre class="source-code">  public JooqOffice() {}</pre>
			<pre class="source-code">  public JooqOffice(JooqOffice value) {</pre>
			<pre class="source-code">    this.officeCode = value.officeCode;</pre>
			<pre class="source-code">    this.city = value.city;</pre>
			<pre class="source-code">    ...</pre>
			<pre class="source-code">    this.territory = value.territory;</pre>
			<pre class="source-code">  }</pre>
			<pre class="source-code">  public JooqOffice(String officeCode, </pre>
			<pre class="source-code">         String city, ... String territory) {</pre>
			<pre class="source-code">    this.officeCode = officeCode;</pre>
			<pre class="source-code">    this.city = city;</pre>
			<pre class="source-code">    ...</pre>
			<pre class="source-code">    this.territory = territory;</pre>
			<pre class="source-code">  }</pre>
			<pre class="source-code">  @NotNull</pre>
			<pre class="source-code">  @Size(max = 10)</pre>
			<pre class="source-code">  public String getOfficeCode() {</pre>
			<pre class="source-code">    return this.officeCode;</pre>
			<pre class="source-code">  }</pre>
			<pre class="source-code">  public void setOfficeCode(String officeCode) {</pre>
			<pre class="source-code">    this.officeCode = officeCode;</pre>
			<pre class="source-code">  }</pre>
			<pre class="source-code">  // getters and setters and toString() omitted for brevity</pre>
			<pre class="source-code">}</pre>
			<p>Similar POJOs<a id="_idIndexMarker107"/> are generated for each table of the <strong class="source-inline">classicmodels</strong> database. This means that we can still use our <strong class="source-inline">CustomerAndOrder</strong> POJO, but there is no need to write our own POJOs for <strong class="source-inline">Office</strong> and <strong class="source-inline">Order</strong> because we can use those generated by jOOQ. The following code was cut out from <strong class="source-inline">ClassicModelsRepository</strong> and uses <a id="_idIndexMarker108"/>the generated <strong class="source-inline">JooqOffice</strong> and <strong class="source-inline">JooqOrder</strong> (note the imports – jOOQ placed the<a id="_idIndexMarker109"/> POJOs in the <strong class="source-inline">jooq.generated.tables.pojos</strong> package):</p>
			<pre class="source-code">import jooq.generated.tables.pojos.JooqOffice;</pre>
			<pre class="source-code">import jooq.generated.tables.pojos.JooqOrder;</pre>
			<pre class="source-code">...</pre>
			<pre class="source-code">public List&lt;JooqOffice&gt; findOfficesInTerritory(</pre>
			<pre class="source-code">                               String territory) {</pre>
			<pre class="source-code">  List&lt;JooqOffice&gt; result = ctx.selectFrom(OFFICE)</pre>
			<pre class="source-code">    .where(OFFICE.TERRITORY.eq(territory))</pre>
			<pre class="source-code">    .fetchInto(JooqOffice.class); </pre>
			<pre class="source-code">  return result;</pre>
			<pre class="source-code">}</pre>
			<pre class="source-code">public List&lt;JooqOrder&gt; findOrdersByRequiredDate(</pre>
			<pre class="source-code">           LocalDatestartDate, LocalDateendDate) {</pre>
			<pre class="source-code">  List&lt;JooqOrder&gt; result = ctx.selectFrom(ORDER)</pre>
			<pre class="source-code">    .where(ORDER.REQUIRED_DATE.between(startDate, endDate))  </pre>
			<pre class="source-code">      .fetchInto(JooqOrder.class); </pre>
			<pre class="source-code">      return result;</pre>
			<pre class="source-code">}</pre>
			<p>Done! So, jOOQ-generated POJOs can<a id="_idIndexMarker110"/> be used as any regular POJOs. For instance, they can be returned from a <strong class="source-inline">REST</strong> controller, and Spring Boot will serialize them as JSON. We'll detail <a id="_idIndexMarker111"/>more types of supported POJOs later on when we tackle the mapping result set to POJOs.</p>
			<p>The application developed in this section is available as <em class="italic">GeneratePojos</em>. Next, let's see how jOOQ can generate DAOs.</p>
			<h1 id="_idParaDest-35"><a id="_idTextAnchor034"/>Configuring jOOQ to generate DAOs</h1>
			<p>If you are<a id="_idIndexMarker112"/> familiar with Spring Data JPA/JDBC, then you're already used to relying on a DAO layer that wraps the queries. Both Spring Data JDBC and JPA provide a built-in DAO that exposes a set of CRUD operations and can be extended via user-defined repositories.</p>
			<p>jOOQ code generation<a id="_idIndexMarker113"/> can produce similar DAOs. Basically, for each table of the database, jOOQ can generate an <strong class="source-inline">org.jooq.DAO</strong> implementation that exposes methods such as <strong class="source-inline">findById()</strong>, <strong class="source-inline">delete()</strong>, <strong class="source-inline">findAll()</strong>, <strong class="source-inline">insert()</strong>, and <strong class="source-inline">update()</strong>.</p>
			<p>In Maven, this feature can be enabled via the following configuration in the <strong class="source-inline">&lt;generator&gt;</strong> tag:</p>
			<pre class="source-code">&lt;generator&gt;</pre>
			<pre class="source-code">  ...</pre>
			<pre class="source-code"><strong class="bold">  &lt;generate&gt;</strong></pre>
			<pre class="source-code"><strong class="bold">    &lt;daos&gt;true&lt;/daos&gt;</strong></pre>
			<pre class="source-code"><strong class="bold">  &lt;/generate&gt;</strong></pre>
			<pre class="source-code">  ...</pre>
			<pre class="source-code">&lt;/generator&gt;</pre>
			<p>jOOQ DAOs make use of POJOs; therefore, jOOQ will implicitly generate POJOs as well. Since we are in Spring Boot, it will be nice to have the generated DAOs annotated with <strong class="source-inline">@Repository</strong> as the built-in <strong class="source-inline">SimpleJpaRepository</strong>. To achieve this, we use the <strong class="source-inline">&lt;springAnnotations/&gt;</strong> flag, as follows:</p>
			<pre class="source-code">&lt;generate&gt;</pre>
			<pre class="source-code">  &lt;daos&gt;true&lt;/daos&gt;</pre>
			<pre class="source-code">  &lt;springAnnotations&gt;true&lt;/springAnnotations&gt;</pre>
			<pre class="source-code">&lt;/generate&gt;</pre>
			<p>By default, the<a id="_idIndexMarker114"/> names of the generated DAOs are the same as the names of the tables in <em class="italic">Pascal</em> case and suffixed with the word <strong class="source-inline">Dao</strong> (for instance, the table named <strong class="source-inline">office_has_manager</strong> becomes <strong class="source-inline">OfficeHasManagerDao</strong>). Altering the default behavior <a id="_idIndexMarker115"/>can be achieved via so-called <em class="italic">generator strategies</em>. For instance, following the Spring style, we prefer <strong class="source-inline">OfficeHasManagerRepository</strong> instead of <strong class="source-inline">OfficeHasManagerDao</strong>. This can be achieved as follows:</p>
			<pre class="source-code">&lt;strategy&gt;</pre>
			<pre class="source-code">  &lt;matchers&gt;</pre>
			<pre class="source-code">    &lt;tables&gt;</pre>
			<pre class="source-code">      &lt;table&gt;</pre>
			<pre class="source-code">        &lt;daoClass&gt;</pre>
			<pre class="source-code">          &lt;expression&gt;$0_Repository&lt;/expression&gt;</pre>
			<pre class="source-code">          &lt;transform&gt;PASCAL&lt;/transform&gt;</pre>
			<pre class="source-code">        &lt;/daoClass&gt;</pre>
			<pre class="source-code">      ...</pre>
			<pre class="source-code">&lt;/strategy&gt;</pre>
			<p>The Gradle alternative is available in the bundled code. For instance, the generated <strong class="source-inline">OfficeRepository</strong> looks as follows:</p>
			<pre class="source-code">@Repository</pre>
			<pre class="source-code">public class OfficeRepository</pre>
			<pre class="source-code">       extends DAOImpl&lt;OfficeRecord, JooqOffice, String&gt; {</pre>
			<pre class="source-code">  public OfficeRepository() {</pre>
			<pre class="source-code">    super(Office.OFFICE, JooqOffice.class);</pre>
			<pre class="source-code">  }</pre>
			<pre class="source-code">  @Autowired</pre>
			<pre class="source-code">  public OfficeRepository(Configuration configuration) {</pre>
			<pre class="source-code">    super(Office.OFFICE, JooqOffice.class, configuration);</pre>
			<pre class="source-code">  }</pre>
			<pre class="source-code">  @Override</pre>
			<pre class="source-code">  public String getId(JooqOffice object) {</pre>
			<pre class="source-code">    return object.getOfficeCode();</pre>
			<pre class="source-code">  }</pre>
			<pre class="source-code">  public List&lt;JooqOffice&gt; fetchRangeOfOfficeCode(</pre>
			<pre class="source-code">       String lowerInclusive, String upperInclusive) {</pre>
			<pre class="source-code">    return fetchRange(Office.OFFICE.OFFICE_CODE, </pre>
			<pre class="source-code">         lowerInclusive, upperInclusive);</pre>
			<pre class="source-code">  }</pre>
			<pre class="source-code">  // more DAO-methods omitted for brevity</pre>
			<pre class="source-code">}</pre>
			<p>Each generated DAO extends the common base implementation named <strong class="source-inline">DAOImpl</strong>. This implementation supplies common <a id="_idIndexMarker116"/>methods such as <strong class="source-inline">insert()</strong>, <strong class="source-inline">update()</strong>, <strong class="source-inline">delete()</strong>, and <strong class="source-inline">findById()</strong>.</p>
			<p>So far, our <strong class="source-inline">ClassicModelsRepository</strong> contains three query methods, represented by <strong class="source-inline">findOfficesInTerritory()</strong>, <strong class="source-inline">findOrdersByRequiredDate()</strong>, and <strong class="source-inline">findCustomersAndOrders()</strong>.</p>
			<p>However, let's check the query from <strong class="source-inline">findOfficesInTerritory()</strong>:</p>
			<pre class="source-code">List&lt;JooqOffice&gt; result = ctx.selectFrom(OFFICE) </pre>
			<pre class="source-code">  .where(OFFICE.TERRITORY.eq(territory))</pre>
			<pre class="source-code">  .fetchInto(JooqOffice.class);</pre>
			<p>Here, we notice that the generated <strong class="source-inline">OfficeRepository</strong> already covers this query via the <strong class="source-inline">fetchByTerritory(String territory)</strong> method; therefore, we can use this built-in DAO <a id="_idIndexMarker117"/>method directly in our service, <strong class="source-inline">ClassicModelsService</strong>, as follows:</p>
			<pre class="source-code">@Transactional(readOnly = true)</pre>
			<pre class="source-code">public List&lt;JooqOffice&gt; fetchOfficesInTerritory(</pre>
			<pre class="source-code">                               String territory) {</pre>
			<pre class="source-code">  return officeRepository.fetchByTerritory(territory);</pre>
			<pre class="source-code">}</pre>
			<p>Going further, check out the query from <strong class="source-inline">findOrdersByRequiredDate()</strong>:</p>
			<pre class="source-code">List&lt;JooqOrder&gt; result = ctx.selectFrom(ORDER)</pre>
			<pre class="source-code">  .where(ORDER.REQUIRED_DATE.between(startDate, endDate))  </pre>
			<pre class="source-code">  .fetchInto(JooqOrder.class);</pre>
			<p>This time, the previous query is covered in <strong class="source-inline">OrderRepository</strong> by the built-in DAO method, <strong class="source-inline">fetchRangeOfRequiredDate(LocalDate li, LocalDate ui)</strong>. So, we can drop the previous query and rely on <strong class="source-inline">ClassicModelsService</strong> on the built-in one, as follows:</p>
			<pre class="source-code">@Transactional(readOnly = true)</pre>
			<pre class="source-code">public List&lt;JooqOrder&gt; fetchOrdersByRequiredDate(</pre>
			<pre class="source-code">      LocalDate startDate, LocalDate endDate) {</pre>
			<pre class="source-code">  return orderRepository.fetchRangeOfRequiredDate(</pre>
			<pre class="source-code">      startDate, endDate);</pre>
			<pre class="source-code">}</pre>
			<p>At this <a id="_idIndexMarker118"/>point, the<a id="_idIndexMarker119"/> only query method left in <strong class="source-inline">ClassicModelsRepository</strong> is <strong class="source-inline">findCustomersAndOrders()</strong>. This query method doesn't have an alternative in the default generated DAOs; therefore, we still need it.</p>
			<p>For now, you can check the application named <em class="italic">GenerateDaos</em>. Later on, we'll discuss extending and customizing the jOOQ-generated DAO. </p>
			<h1 id="_idParaDest-36"><a id="_idTextAnchor035"/>Configuring jOOQ to generate interfaces</h1>
			<p>Besides <a id="_idIndexMarker120"/>POJOs and DAOs, jOOQ can generate an <a id="_idIndexMarker121"/>interface for each table. Each column is associated with a getter and a setter. In Maven, this can be done as shown here:</p>
			<pre class="source-code">&lt;generate&gt;</pre>
			<pre class="source-code">  &lt;interfaces&gt;true&lt;/interfaces&gt;</pre>
			<pre class="source-code">  &lt;immutableInterfaces&gt;true&lt;/immutableInterfaces&gt;</pre>
			<pre class="source-code">&lt;/generate&gt;</pre>
			<p>Basically, jOOQ generates interfaces that look like Spring Data's so-called <em class="italic">interfaces-based closed projections</em>. We can use these interfaces for mapping results sets exactly as we do with <em class="italic">closed projections</em>.</p>
			<p>Nevertheless, note that at the time of writing, this feature has been proposed to be removed. You can track the deprecation here: <a href="https://github.com/jOOQ/jOOQ/issues/10509">https://github.com/jOOQ/jOOQ/issues/10509</a>.</p>
			<p>Next, let's continue with the programmatic configuration of the jOOQ Code Generator.</p>
			<h1 id="_idParaDest-37"><a id="_idTextAnchor036"/>Tackling programmatic configuration</h1>
			<p>If you prefer<a id="_idIndexMarker122"/> programmatic configurations, then jOOQ exposes a fluent API (<strong class="source-inline">org.jooq.meta.jaxb.*</strong>) that can be used for configuring code generation in programmatic fashion. First, for Maven, add the following dependency in <strong class="source-inline">pom.xml</strong>:</p>
			<pre class="source-code">&lt;dependency&gt;</pre>
			<pre class="source-code">  &lt;groupId&gt;org.jooq{.trial-java-8}&lt;/groupId&gt;</pre>
			<pre class="source-code">  &lt;artifactId&gt;jooq-codegen&lt;/artifactId&gt;</pre>
			<pre class="source-code">&lt;/dependency&gt;</pre>
			<p>Alternatively, in Gradle, add <strong class="source-inline">implementation 'org.jooq{.trial-java-8}:jooq-codegen'</strong>. </p>
			<p>Note that <strong class="source-inline">Configuration</strong> refers to <strong class="source-inline">org.jooq.meta.jaxb.Configuration</strong>, not <strong class="source-inline">org.jooq.Configuration</strong>, which is used for creating <strong class="source-inline">DSLContext</strong> and other jOOQ contexts.</p>
			<p>This programmatic API mirrors the declarative approach and, therefore, is very intuitive. For instance, here it is the programmatic alternative of the declarative approach presented in the <em class="italic">Configuring jOOQ to generate DAOs</em> section for the MySQL <strong class="source-inline">classicmodels</strong> schema:</p>
			<pre class="source-code">Configuration configuration = new Configuration()</pre>
			<pre class="source-code">  .withJdbc(new Jdbc()</pre>
			<pre class="source-code">    .withDriver("com.mysql.cj.jdbc.Driver")</pre>
			<pre class="source-code">    .withUrl("jdbc:mysql://localhost:3306/classicmodels")</pre>
			<pre class="source-code">    .withUser("root")</pre>
			<pre class="source-code">    .withPassword("root"))</pre>
			<pre class="source-code">  .withGenerator(new Generator()</pre>
			<pre class="source-code">    .withName("org.jooq.codegen.JavaGenerator")</pre>
			<pre class="source-code">    .withDatabase(new Database()</pre>
			<pre class="source-code">      .withName("org.jooq.meta.mysql.MySQLDatabase")       </pre>
			<pre class="source-code">      .withInputSchema("classicmodels")</pre>
			<pre class="source-code">      .withIncludes(".*")</pre>
			<pre class="source-code">      .withExcludes("flyway_schema_history | sequences"</pre>
			<pre class="source-code">        + " | customer_pgs | refresh_top3_product"</pre>
			<pre class="source-code">        + " | sale_.* | set_.* | get_.* | .*_master")      </pre>
			<pre class="source-code">      .withSchemaVersionProvider("SELECT MAX(`version`) </pre>
			<pre class="source-code">          FROM `flyway_schema_history`")</pre>
			<pre class="source-code">      .withLogSlowQueriesAfterSeconds(20))</pre>
			<pre class="source-code">  .withGenerate(new Generate()</pre>
			<pre class="source-code">    .withDaos(true)</pre>
			<pre class="source-code">    .withValidationAnnotations(Boolean.TRUE)</pre>
			<pre class="source-code">    .withSpringAnnotations(Boolean.TRUE))</pre>
			<pre class="source-code">  .withStrategy(new Strategy()</pre>
			<pre class="source-code">    .withMatchers(new Matchers()</pre>
			<pre class="source-code">      .withTables(new MatchersTableType()</pre>
			<pre class="source-code">        .withPojoClass(new MatcherRule()</pre>
			<pre class="source-code">         .withExpression("Jooq_$0")</pre>
			<pre class="source-code">         .withTransform(MatcherTransformType.PASCAL))</pre>
			<pre class="source-code">        .withDaoClass(new MatcherRule()</pre>
			<pre class="source-code">          .withExpression("$0_Repository")</pre>
			<pre class="source-code">          .withTransform(MatcherTransformType.PASCAL)))))</pre>
			<pre class="source-code">  .withTarget(new Target()</pre>
			<pre class="source-code">    .withPackageName("jooq.generated")</pre>
			<pre class="source-code">    .withDirectory(System.getProperty("user.dir")</pre>
			<pre class="source-code">    .endsWith("webapp") ? "target/generated-sources"</pre>
			<pre class="source-code">              : "webapp/target/generated-sources")));</pre>
			<pre class="source-code">GenerationTool.generate(configuration);</pre>
			<p>The jOOQ <a id="_idIndexMarker123"/>Code Generator must generate the classes before the application's classes are compiled; therefore, the programmatic Code Generator should be placed in a separate module of your application and invoked at the proper moment before the compilation phase. As you'll see in the bundled code (<em class="italic">ProgrammaticGenerator</em>), this can be achieved via <strong class="source-inline">exec-maven-plugin</strong> for Maven or <strong class="source-inline">JavaExec</strong> for Gradle.</p>
			<p>If you prefer the DDL Database API, then you'll love the programmatic approach from <strong class="source-inline">ProgrammaticDDLDatabase</strong>. If you prefer the JPA Database API, then check out the programmatic approach as well, <em class="italic">ProgrammaticJPADatabase</em>.</p>
			<p>All the applications from this chapter are available for Java/Kotlin and Maven/Gradle combos.</p>
			<h1 id="_idParaDest-38"><a id="_idTextAnchor037"/>Introducing jOOQ settings</h1>
			<p>jOOQ supports a <a id="_idIndexMarker124"/>bunch of optional settings (<strong class="source-inline">org.jooq.conf.Settings</strong>) that are mostly used to customize rendered SQL. While all these settings rely on defaults that have been carefully chosen for a wide range of cases, there are still situations when we have to alter them. </p>
			<p>If you prefer the declarative approach, then you can alter these settings via an XML file, named <strong class="source-inline">jooq-settings.xml</strong>, placed in the application classpath. For instance, if the rendered SQL doesn't contain the name of the catalog/schema, then <strong class="source-inline">jooq-settings.xml</strong> will be as follows:</p>
			<pre class="source-code">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</pre>
			<pre class="source-code">&lt;settings&gt;</pre>
			<pre class="source-code">  &lt;renderCatalog&gt;false&lt;/renderCatalog&gt;</pre>
			<pre class="source-code">  &lt;renderSchema&gt;false&lt;/renderSchema&gt;</pre>
			<pre class="source-code">&lt;/settings&gt;</pre>
			<p>Without these settings, jOOQ renders the name of the catalog/schema for each generated SQL. Here is an example in SQL Server:</p>
			<ul>
				<li>Without these settings, jOOQ renders <strong class="source-inline">[classicmodels].[dbo].[customer].[customer_name]</strong> .</li>
				<li>With these settings, jOOQ doesn't render the schema and catalog names – <strong class="source-inline">[customer].[customer_name]</strong> .</li>
			</ul>
			<p>As you can<a id="_idIndexMarker125"/> see in the corresponding XSD (<strong class="source-inline">https://www.jooq.org/xsd/jooq-runtime-3.x.x.xsd</strong>), jOOQ supports a lot of settings, and most of them are for advanced users and serve only certain scenarios. Nevertheless, some of them are more popular than others, and you'll see them mentioned in the proper context throughout this book. </p>
			<p>Moreover, jOOQ <strong class="source-inline">Settings</strong> can be programmatically shaped via <strong class="source-inline">@Bean</strong>, as follows:</p>
			<pre class="source-code">@Bean</pre>
			<pre class="source-code">public Settings jooqSettings() {</pre>
			<pre class="source-code">  return new Settings()</pre>
			<pre class="source-code">   .withRenderCatalog(Boolean.FALSE)</pre>
			<pre class="source-code">   .withRenderSchema(Boolean.FALSE);</pre>
			<pre class="source-code">}</pre>
			<p>Via <strong class="source-inline">@Bean</strong>, we customize jOOQ settings globally (at the application level), but we can override them locally at the <strong class="source-inline">DSLContext</strong> level via the <strong class="source-inline">DSLContext</strong> constructor (<strong class="source-inline">DSL.using()</strong>), as shown in this example:</p>
			<pre class="source-code">DataSource ds = ...;</pre>
			<pre class="source-code">DSLContext ctx = DSL.using(ds, SQLDialect.MYSQL, </pre>
			<pre class="source-code">  new Settings()</pre>
			<pre class="source-code">    .withRenderCatalog(Boolean.FALSE)</pre>
			<pre class="source-code">    .withRenderSchema(Boolean.FALSE));</pre>
			<p>Alternatively, we can locally define <strong class="source-inline">DSLContext</strong>, derived from the current <strong class="source-inline">DSLContext</strong> (denoted as <strong class="source-inline">ctx</strong>) and having altered <strong class="source-inline">Settings</strong>:</p>
			<pre class="source-code">ctx.configuration().derive(</pre>
			<pre class="source-code">  new Settings()</pre>
			<pre class="source-code">    .withRenderCatalog(Boolean.FALSE)</pre>
			<pre class="source-code">    .withRenderSchema(Boolean.FALSE))).dsl() </pre>
			<pre class="source-code">    ... // some query</pre>
			<p>During this <a id="_idIndexMarker126"/>book, you'll have plenty of occasions to see <strong class="source-inline">Settings</strong> at work, so there is no need to bother too much for the moment.</p>
			<p>It's time to summarize this chapter!</p>
			<h1 id="_idParaDest-39"><a id="_idTextAnchor038"/>Summary</h1>
			<p>In this chapter, we have reached several targets, but the most important was the introduction of the jOOQ Code Generator using configurative and programmatic approaches. More specifically, you saw how to write type-safe queries and how to generate and use POJOs and DAOs. These are fundamental skills in jOOQ that we'll develop during the entire book.</p>
			<p>From this point forward, we'll focus on other topics that will help you to become a jOOQ power user.</p>
			<p>In the next chapter, we will start diving into the jOOQ core concepts.</p>
		</div>
	</body></html>