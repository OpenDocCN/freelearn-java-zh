<html><head></head><body>
<div id="_idContainer051">
<h1 class="chapter-number" id="_idParaDest-119"><a id="_idTextAnchor128"/><span class="koboSpan" id="kobo.1.1">7</span></h1>
<h1 id="_idParaDest-120"><a id="_idTextAnchor129"/><span class="koboSpan" id="kobo.2.1">Driving Design – TDD and SOLID</span></h1>
<p><span class="koboSpan" id="kobo.3.1">So far, we’ve created some basic unit tests that have driven out a simple design for a couple of classes. </span><span class="koboSpan" id="kobo.3.2">We’ve experienced </span><a id="_idIndexMarker262"/><span class="koboSpan" id="kobo.4.1">how </span><strong class="bold"><span class="koboSpan" id="kobo.5.1">test-driven development</span></strong><span class="koboSpan" id="kobo.6.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.7.1">TDD</span></strong><span class="koboSpan" id="kobo.8.1">) makes decision-making about design choices central. </span><span class="koboSpan" id="kobo.8.2">In order to build out to a larger application, we are going to need to be able to handle designs of greater complexity. </span><span class="koboSpan" id="kobo.8.3">To do this, we are going to apply some recommended approaches to assessing what makes one design preferable </span><span class="No-Break"><span class="koboSpan" id="kobo.9.1">to another.</span></span></p>
<p><span class="koboSpan" id="kobo.10.1">The SOLID principles are five design guidelines that steer designs toward being more flexible and modular. </span><span class="koboSpan" id="kobo.10.2">The word </span><em class="italic"><span class="koboSpan" id="kobo.11.1">SOLID</span></em><span class="koboSpan" id="kobo.12.1"> is an acronym, where each letter represents one of five principles whose names begin with that letter. </span><span class="koboSpan" id="kobo.12.2">These principles existed long before they were known by this name. </span><span class="koboSpan" id="kobo.12.3">They have proven helpful in my experience, and it is worth understanding the benefits each one brings and how we can apply them to our code. </span><span class="koboSpan" id="kobo.12.4">To do this, we will use a running code example in this chapter. </span><span class="koboSpan" id="kobo.12.5">It is a simple program that draws</span><a id="_idIndexMarker263"/><span class="koboSpan" id="kobo.13.1"> shapes of various kinds using simple </span><strong class="bold"><span class="koboSpan" id="kobo.14.1">American Standard Code for Information Interchange</span></strong><span class="koboSpan" id="kobo.15.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.16.1">ASCII</span></strong><span class="koboSpan" id="kobo.17.1">) art on </span><span class="No-Break"><span class="koboSpan" id="kobo.18.1">a console.</span></span></p>
<p><span class="koboSpan" id="kobo.19.1">Before we start, let’s think about the best </span><em class="italic"><span class="koboSpan" id="kobo.20.1">order</span></em><span class="koboSpan" id="kobo.21.1"> to learn these five principles. </span><span class="koboSpan" id="kobo.21.2">The acronym </span><em class="italic"><span class="koboSpan" id="kobo.22.1">SOLID</span></em><span class="koboSpan" id="kobo.23.1"> is easy to say, but it isn’t the easiest way to learn the principles. </span><span class="koboSpan" id="kobo.23.2">Some principles build on others. </span><span class="koboSpan" id="kobo.23.3">Experience shows that some are used more than others, especially when doing TDD. </span><span class="koboSpan" id="kobo.23.4">For this reason, we’re going to review the principles in the order </span><em class="italic"><span class="koboSpan" id="kobo.24.1">SDLOI</span></em><span class="koboSpan" id="kobo.25.1">. </span><span class="koboSpan" id="kobo.25.2">It doesn’t sound as good, as I’m sure you will agree, but it makes a better order </span><span class="No-Break"><span class="koboSpan" id="kobo.26.1">of learning.</span></span></p>
<p><span class="koboSpan" id="kobo.27.1">Originally, the SOLID principles were conceived as patterns that applied to classes in </span><strong class="bold"><span class="koboSpan" id="kobo.28.1">object-oriented programming</span></strong><span class="koboSpan" id="kobo.29.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.30.1">OOP</span></strong><span class="koboSpan" id="kobo.31.1">), but they are more general-purpose than that. </span><span class="koboSpan" id="kobo.31.2">They</span><a id="_idIndexMarker264"/><span class="koboSpan" id="kobo.32.1"> equally apply to individual methods in a class as well as the class itself. </span><span class="koboSpan" id="kobo.32.2">They also apply to the design of microservice interconnections and function design in functional programming. </span><span class="koboSpan" id="kobo.32.3">We will be seeing examples applied at both the class level and the method level in </span><span class="No-Break"><span class="koboSpan" id="kobo.33.1">this chapter.</span></span></p>
<p><span class="koboSpan" id="kobo.34.1">In this chapter, we’re going to cover the following </span><span class="No-Break"><span class="koboSpan" id="kobo.35.1">main topics:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.36.1">Test guide–we drive </span><span class="No-Break"><span class="koboSpan" id="kobo.37.1">the design</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.38.1">Single Responsibility Principle</span></strong><span class="koboSpan" id="kobo.39.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.40.1">SRP</span></strong><span class="koboSpan" id="kobo.41.1">)–simple </span><span class="No-Break"><span class="koboSpan" id="kobo.42.1">building blocks</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.43.1">Dependency Inversion Principle</span></strong><span class="koboSpan" id="kobo.44.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.45.1">DIP</span></strong><span class="koboSpan" id="kobo.46.1">)–hiding </span><span class="No-Break"><span class="koboSpan" id="kobo.47.1">irrelevant details</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.48.1">Liskov Substitution Principle</span></strong><span class="koboSpan" id="kobo.49.1"> (</span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.50.1">LSP</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.51.1">)–swappable objects</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.52.1">Open-Closed Principle</span></strong><span class="koboSpan" id="kobo.53.1"> (</span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.54.1">OCP</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.55.1">)–extensible design</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.56.1">Interface Segregation Principle</span></strong><span class="koboSpan" id="kobo.57.1"> (</span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.58.1">ISP</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.59.1">)–effective interfaces</span></span></li>
</ul>
<h1 id="_idParaDest-121"><a id="_idTextAnchor130"/><span class="koboSpan" id="kobo.60.1">Technical requirements</span></h1>
<p><span class="koboSpan" id="kobo.61.1">The code for this chapter can be found at </span><a href="https://github.com/PacktPublishing/Test-Driven-Development-with-Java/tree/main/chapter07"><span class="koboSpan" id="kobo.62.1">https://github.com/PacktPublishing/Test-Driven-Development-with-Java/tree/main/chapter07</span></a><span class="koboSpan" id="kobo.63.1">. </span><span class="koboSpan" id="kobo.63.2">A running example of code that draws shapes using all five SOLID principles </span><span class="No-Break"><span class="koboSpan" id="kobo.64.1">is provided.</span></span></p>
<h1 id="_idParaDest-122"><a id="_idTextAnchor131"/><span class="koboSpan" id="kobo.65.1">Test guide – we drive the design</span></h1>
<p><span class="koboSpan" id="kobo.66.1">In </span><a href="B18384_05.xhtml#_idTextAnchor092"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.67.1">Chapter 5</span></em></span></a><span class="koboSpan" id="kobo.68.1">, </span><em class="italic"><span class="koboSpan" id="kobo.69.1">Writing Our First Test</span></em><span class="koboSpan" id="kobo.70.1">, we </span><a id="_idIndexMarker265"/><span class="koboSpan" id="kobo.71.1">wrote our first test. </span><span class="koboSpan" id="kobo.71.2">To do that, we ran through a number of design decisions. </span><span class="koboSpan" id="kobo.71.3">Let’s review that initial test code and list all the design decisions we had to make, </span><span class="No-Break"><span class="koboSpan" id="kobo.72.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.73.1">
@Test
public void oneIncorrectLetter() {
    var word = new Word("A");
    var score = word.guess("Z");
    assertThat( score.letter(0) ).isEqualTo(Letter.INCORRECT);
}</span></pre>
<p><span class="koboSpan" id="kobo.74.1">We decided on </span><span class="No-Break"><span class="koboSpan" id="kobo.75.1">the following:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.76.1">What </span><span class="No-Break"><span class="koboSpan" id="kobo.77.1">to test</span></span></li>
<li><span class="koboSpan" id="kobo.78.1">What to call </span><span class="No-Break"><span class="koboSpan" id="kobo.79.1">the test</span></span></li>
<li><span class="koboSpan" id="kobo.80.1">What to call the method </span><span class="No-Break"><span class="koboSpan" id="kobo.81.1">under test</span></span></li>
<li><span class="koboSpan" id="kobo.82.1">Which class to put that </span><span class="No-Break"><span class="koboSpan" id="kobo.83.1">method on</span></span></li>
<li><span class="koboSpan" id="kobo.84.1">The signature of </span><span class="No-Break"><span class="koboSpan" id="kobo.85.1">that method</span></span></li>
<li><span class="koboSpan" id="kobo.86.1">The constructor signature of </span><span class="No-Break"><span class="koboSpan" id="kobo.87.1">the class</span></span></li>
<li><span class="koboSpan" id="kobo.88.1">Which other objects </span><span class="No-Break"><span class="koboSpan" id="kobo.89.1">should collaborate</span></span></li>
<li><span class="koboSpan" id="kobo.90.1">The method signatures involved in </span><span class="No-Break"><span class="koboSpan" id="kobo.91.1">that collaboration</span></span></li>
<li><span class="koboSpan" id="kobo.92.1">What form the output of this method </span><span class="No-Break"><span class="koboSpan" id="kobo.93.1">will take</span></span></li>
<li><span class="koboSpan" id="kobo.94.1">How to access that output and assert that </span><span class="No-Break"><span class="koboSpan" id="kobo.95.1">it worked</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.96.1">These are all design decisions that our human minds must make. </span><span class="koboSpan" id="kobo.96.2">TDD leaves us very much hands-on when it comes to designing our code and deciding how it should be implemented. </span><span class="koboSpan" id="kobo.96.3">To be honest, I am happy about that. </span><span class="koboSpan" id="kobo.96.4">Designing is rewarding and TDD provides helpful scaffolding rather than a prescriptive approach. </span><span class="koboSpan" id="kobo.96.5">TDD acts as a guide to remind us to make these design decisions early. </span><span class="koboSpan" id="kobo.96.6">It also provides a way to document these decisions as test code. </span><span class="koboSpan" id="kobo.96.7">Nothing more, but equally, </span><span class="No-Break"><span class="koboSpan" id="kobo.97.1">nothing less.</span></span></p>
<p><span class="koboSpan" id="kobo.98.1">It can be helpful to use techniques such as pair programming or mobbing (also known as ensemble programming) as we make these decisions—then, we add more experience and more </span><a id="_idIndexMarker266"/><span class="koboSpan" id="kobo.99.1">ideas to our solution. </span><span class="koboSpan" id="kobo.99.2">Working alone, we simply have to take the best decisions we can, based on our </span><span class="No-Break"><span class="koboSpan" id="kobo.100.1">own experience.</span></span></p>
<p><span class="koboSpan" id="kobo.101.1">The critical point to get across here is that TDD does not and </span><em class="italic"><span class="koboSpan" id="kobo.102.1">cannot</span></em><span class="koboSpan" id="kobo.103.1"> make these decisions for us. </span><span class="koboSpan" id="kobo.103.2">We must make them. </span><span class="koboSpan" id="kobo.103.3">As such, it is useful to have some guidelines to steer us toward better designs. </span><span class="koboSpan" id="kobo.103.4">A set of five design principles known as the </span><strong class="bold"><span class="koboSpan" id="kobo.104.1">SOLID principles</span></strong><span class="koboSpan" id="kobo.105.1"> are</span><a id="_idIndexMarker267"/><span class="koboSpan" id="kobo.106.1"> helpful. </span><span class="koboSpan" id="kobo.106.2">SOLID is an acronym for the following </span><span class="No-Break"><span class="koboSpan" id="kobo.107.1">five principles:</span></span></p>
<ul>
<li><span class="No-Break"><span class="koboSpan" id="kobo.108.1">SRP</span></span></li>
<li><span class="No-Break"><span class="koboSpan" id="kobo.109.1">OCP</span></span></li>
<li><span class="No-Break"><span class="koboSpan" id="kobo.110.1">LSP</span></span></li>
<li><span class="No-Break"><span class="koboSpan" id="kobo.111.1">ISP</span></span></li>
<li><span class="No-Break"><span class="koboSpan" id="kobo.112.1">DIP</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.113.1">In the following sections, we will learn what these principles are and how they help us write well-engineered code and tests. </span><span class="koboSpan" id="kobo.113.2">We will start with SRP, which is arguably the most foundational </span><a id="_idIndexMarker268"/><span class="koboSpan" id="kobo.114.1">principle of any style of </span><span class="No-Break"><span class="koboSpan" id="kobo.115.1">program design.</span></span></p>
<h1 id="_idParaDest-123"><a id="_idTextAnchor132"/><span class="koboSpan" id="kobo.116.1">SRP – simple building blocks</span></h1>
<p><span class="koboSpan" id="kobo.117.1">In this section, we </span><a id="_idIndexMarker269"/><span class="koboSpan" id="kobo.118.1">will examine the first principle, known as SRP. </span><span class="koboSpan" id="kobo.118.2">We will use a single code example throughout all sections. </span><span class="koboSpan" id="kobo.118.3">This will clarify how each principle is applied to an </span><strong class="bold"><span class="koboSpan" id="kobo.119.1">object-oriented</span></strong><span class="koboSpan" id="kobo.120.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.121.1">OO</span></strong><span class="koboSpan" id="kobo.122.1">) design. </span><span class="koboSpan" id="kobo.122.2">We’re</span><a id="_idIndexMarker270"/><span class="koboSpan" id="kobo.123.1"> going to look at a classic example of OO design: drawing shapes. </span><span class="koboSpan" id="kobo.123.2">The following diagram is an overview of the</span><a id="_idIndexMarker271"/><span class="koboSpan" id="kobo.124.1"> design in </span><strong class="bold"><span class="koboSpan" id="kobo.125.1">Unified Modeling Language</span></strong><span class="koboSpan" id="kobo.126.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.127.1">UML</span></strong><span class="koboSpan" id="kobo.128.1">), describing the code presented in </span><span class="No-Break"><span class="koboSpan" id="kobo.129.1">the chapter:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer046">
<span class="koboSpan" id="kobo.130.1"><img alt="Figure 7.1 – UML diagram for shapes code" src="image/Figure_7.1_B18384.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.131.1">Figure 7.1 – UML diagram for shapes code</span></p>
<p><span class="koboSpan" id="kobo.132.1">This </span><a id="_idIndexMarker272"/><span class="koboSpan" id="kobo.133.1">diagram </span><a id="_idIndexMarker273"/><span class="koboSpan" id="kobo.134.1">shows an overview of the Java code available in the GitHub folder for this chapter. </span><span class="koboSpan" id="kobo.134.2">We’ll be using specific parts of the code to illustrate how each of the SOLID principles has been used to create </span><span class="No-Break"><span class="koboSpan" id="kobo.135.1">this design.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.136.1">UML diagrams</span></p>
<p class="callout"><span class="koboSpan" id="kobo.137.1">UML was created in 1995 by Grady Booch, Ivar Jacobson, and James Rumbaugh. </span><span class="koboSpan" id="kobo.137.2">UML is a way of visualizing OO designs at a high level. </span><span class="koboSpan" id="kobo.137.3">The preceding diagram is a UML class diagram. </span><span class="koboSpan" id="kobo.137.4">UML offers many other kinds of useful diagrams. </span><span class="koboSpan" id="kobo.137.5">You can learn more </span><span class="No-Break"><span class="koboSpan" id="kobo.138.1">at </span></span><a href="https://www.packtpub.com/product/uml-2-0-in-action-a-project-based-tutorial/9781904811558"><span class="No-Break"><span class="koboSpan" id="kobo.139.1">https://www.packtpub.com/product/uml-2-0-in-action-a-project-based-tutorial/9781904811558</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.140.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.141.1">SRP guides us to break code down into pieces that encapsulate a single aspect of our solution. </span><span class="koboSpan" id="kobo.141.2">Maybe that is a technical aspect in nature—such as reading a database table—or maybe it is a business rule. </span><span class="koboSpan" id="kobo.141.3">Either way, we split different aspects into different pieces of code. </span><span class="koboSpan" id="kobo.141.4">Each piece of code is responsible for a single detail, which is where the name </span><em class="italic"><span class="koboSpan" id="kobo.142.1">SRP</span></em><span class="koboSpan" id="kobo.143.1"> comes from. </span><span class="koboSpan" id="kobo.143.2">Another way of looking at this is that a piece of code should only ever have </span><em class="italic"><span class="koboSpan" id="kobo.144.1">one reason to change</span></em><span class="koboSpan" id="kobo.145.1">. </span><span class="koboSpan" id="kobo.145.2">Let’s </span><a id="_idIndexMarker274"/><span class="koboSpan" id="kobo.146.1">examine why this is an advantage in the </span><span class="No-Break"><span class="koboSpan" id="kobo.147.1">following sections.</span></span></p>
<h2 id="_idParaDest-124"><a id="_idTextAnchor133"/><span class="koboSpan" id="kobo.148.1">Too many responsibilities make code harder to work with</span></h2>
<p><span class="koboSpan" id="kobo.149.1">A common programming mistake is to combine too many responsibilities into a single piece of code. </span><span class="koboSpan" id="kobo.149.2">If we have a class that can generate </span><strong class="bold"><span class="koboSpan" id="kobo.150.1">Hypertext Markup Language</span></strong><span class="koboSpan" id="kobo.151.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.152.1">HTML</span></strong><span class="koboSpan" id="kobo.153.1">), execute </span><a id="_idIndexMarker275"/><span class="koboSpan" id="kobo.154.1">a business rule, and fetch data from a database table, that class will have three reasons to change. </span><span class="koboSpan" id="kobo.154.2">Any time a change in one of these areas is necessary, we will risk making a code change that breaks the other two aspects. </span><span class="koboSpan" id="kobo.154.3">The technical term for this is that the</span><a id="_idIndexMarker276"/><span class="koboSpan" id="kobo.155.1"> code is </span><strong class="bold"><span class="koboSpan" id="kobo.156.1">highly coupled.</span></strong><span class="koboSpan" id="kobo.157.1"> This leads to changes in one area rippling out and affecting </span><span class="No-Break"><span class="koboSpan" id="kobo.158.1">other areas.</span></span></p>
<p><span class="koboSpan" id="kobo.159.1">We can visualize this as code block </span><strong class="bold"><span class="koboSpan" id="kobo.160.1">A</span></strong><span class="koboSpan" id="kobo.161.1"> in the </span><span class="No-Break"><span class="koboSpan" id="kobo.162.1">following diagram:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer047">
<span class="koboSpan" id="kobo.163.1"><img alt="Figure 7.2 – Single component: multiple reasons to change" src="image/Figure_7.2_B18384.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.164.1">Figure 7.2 – Single component: multiple reasons to change</span></p>
<p><span class="koboSpan" id="kobo.165.1">Block </span><strong class="bold"><span class="koboSpan" id="kobo.166.1">A</span></strong><span class="koboSpan" id="kobo.167.1"> deals with three things, so a change to any of them implies a change in </span><strong class="bold"><span class="koboSpan" id="kobo.168.1">A</span></strong><span class="koboSpan" id="kobo.169.1">. </span><span class="koboSpan" id="kobo.169.2">To improve this, we apply SRP and separate out the code responsible for creating HTML, applying business rules, and accessing the database. </span><span class="koboSpan" id="kobo.169.3">Each of those three code blocks—</span><strong class="bold"><span class="koboSpan" id="kobo.170.1">A</span></strong><span class="koboSpan" id="kobo.171.1">, </span><strong class="bold"><span class="koboSpan" id="kobo.172.1">B</span></strong><span class="koboSpan" id="kobo.173.1">, and </span><strong class="bold"><span class="koboSpan" id="kobo.174.1">C</span></strong><span class="koboSpan" id="kobo.175.1">—now only has one reason to change. </span><span class="koboSpan" id="kobo.175.2">Changing any single code block should not result in changes rippling out to the </span><span class="No-Break"><span class="koboSpan" id="kobo.176.1">other blocks.</span></span></p>
<p><span class="koboSpan" id="kobo.177.1">We can visualize this in the </span><span class="No-Break"><span class="koboSpan" id="kobo.178.1">following diagram:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer048">
<span class="koboSpan" id="kobo.179.1"><img alt="Figure 7.3 – Multiple components: one reason to change" src="image/Figure_7.3_B18384.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.180.1">Figure 7.3 – Multiple components: one reason to change</span></p>
<p><span class="koboSpan" id="kobo.181.1">Each code block</span><a id="_idIndexMarker277"/><span class="koboSpan" id="kobo.182.1"> deals with one thing and has only one reason to change. </span><span class="koboSpan" id="kobo.182.2">We can see that SRP works to limit the scope of future code changes. </span><span class="koboSpan" id="kobo.182.3">It also makes it easier to find code in a large code base, as it is </span><span class="No-Break"><span class="koboSpan" id="kobo.183.1">logically organized.</span></span></p>
<p><span class="koboSpan" id="kobo.184.1">Applying SRP gives other benefits, </span><span class="No-Break"><span class="koboSpan" id="kobo.185.1">as follows:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.186.1">Ability to </span><span class="No-Break"><span class="koboSpan" id="kobo.187.1">reuse code</span></span></li>
<li><span class="koboSpan" id="kobo.188.1">Simplified </span><span class="No-Break"><span class="koboSpan" id="kobo.189.1">future maintenance</span></span></li>
</ul>
<h2 id="_idParaDest-125"><a id="_idTextAnchor134"/><span class="koboSpan" id="kobo.190.1">Ability to reuse code</span></h2>
<p><span class="koboSpan" id="kobo.191.1">Reusing code has been a goal of software engineering for a long time. </span><span class="koboSpan" id="kobo.191.2">Creating software from scratch takes time, costs money, and prevents a software engineer from doing something else. </span><span class="koboSpan" id="kobo.191.3">It makes sense that if we create something that is generally useful, we use it again wherever possible. </span><span class="koboSpan" id="kobo.191.4">The barrier to this happens when we have created large, application-specific pieces of software. </span><span class="koboSpan" id="kobo.191.5">The fact that they are highly specialized means they can only be used in their </span><span class="No-Break"><span class="koboSpan" id="kobo.192.1">original context.</span></span></p>
<p><span class="koboSpan" id="kobo.193.1">By creating smaller, more general-purpose software components, we will be able to use those again in different contexts. </span><span class="koboSpan" id="kobo.193.2">The smaller the scope of what the component aims to do, the more likely it is that we can reuse it without modification. </span><span class="koboSpan" id="kobo.193.3">If we have a small function or class that does one thing, it becomes easy to reuse that across our code base. </span><span class="koboSpan" id="kobo.193.4">It may even end up as part of a framework or library that we can reuse across </span><span class="No-Break"><span class="koboSpan" id="kobo.194.1">multiple projects.</span></span></p>
<p><span class="koboSpan" id="kobo.195.1">SRP does not guarantee that code will be reusable, but it does aim to reduce the scope of what any piece of code does. </span><span class="koboSpan" id="kobo.195.2">This way of thinking about code as a series of building blocks where each one does a small part of the overall task is more likely to result in </span><span class="No-Break"><span class="koboSpan" id="kobo.196.1">reusable components.</span></span></p>
<h2 id="_idParaDest-126"><a id="_idTextAnchor135"/><span class="koboSpan" id="kobo.197.1">Simplified future maintenance</span></h2>
<p><span class="koboSpan" id="kobo.198.1">As we write</span><a id="_idIndexMarker278"/><span class="koboSpan" id="kobo.199.1"> code, we’re aware that we are not just writing to solve a problem now, but also writing code that might be revisited in the future. </span><span class="koboSpan" id="kobo.199.2">This might be done by other people in the team or maybe by ourselves. </span><span class="koboSpan" id="kobo.199.3">We want to make this future work as simple as possible. </span><span class="koboSpan" id="kobo.199.4">To achieve this, we need to keep our code well-engineered—making it safe and easy to work </span><span class="No-Break"><span class="koboSpan" id="kobo.200.1">with later.</span></span></p>
<p><span class="koboSpan" id="kobo.201.1">Duplicated code is a problem for maintenance—it complicates future code changes. </span><span class="koboSpan" id="kobo.201.2">If we copy and paste a section of code three times, let’s say, it seems quite obvious to us at the time what we are doing. </span><span class="koboSpan" id="kobo.201.3">We have one concept that needs to happen three times, so we paste it three times. </span><span class="koboSpan" id="kobo.201.4">But when it comes time to read the code again, that thought process has been lost. </span><span class="koboSpan" id="kobo.201.5">It just reads as three unrelated pieces of code. </span><em class="italic"><span class="koboSpan" id="kobo.202.1">We lose engineering information by copy and paste</span></em><span class="koboSpan" id="kobo.203.1">. </span><span class="koboSpan" id="kobo.203.2">We will need to reverse-engineer that code to work out that there are three places where we need to </span><span class="No-Break"><span class="koboSpan" id="kobo.204.1">change it.</span></span></p>
<h2 id="_idParaDest-127"><a id="_idTextAnchor136"/><span class="koboSpan" id="kobo.205.1">Counter-example – shapes code that violates SRP</span></h2>
<p><span class="koboSpan" id="kobo.206.1">To see the value of applying SRP, let’s consider a piece of code that doesn’t use it. </span><span class="koboSpan" id="kobo.206.2">The following code </span><a id="_idIndexMarker279"/><span class="koboSpan" id="kobo.207.1">snippet has a list of shapes that all get drawn when we call the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.208.1">draw()</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.209.1"> method:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.210.1">
public class Shapes {
    private final List&lt;Shape&gt; allShapes = new ArrayList&lt;&gt;();
    public void add(Shape s) {
        allShapes.add(s);
    }
    public void draw(Graphics g) {
        </span><strong class="bold"><span class="koboSpan" id="kobo.211.1">for (Shape s : allShapes) {</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.212.1">            switch (s.getType()) {</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.213.1">                case "textbox":</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.214.1">                    var t = (TextBox) s;</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.215.1">                    </span></strong><strong class="bold"><span class="koboSpan" id="kobo.216.1">g.drawText(t.getText());</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.217.1">                    break;</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.218.1">                case "rectangle":</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.219.1">                    var r = (Rectangle) s;</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.220.1">                    for (int row = 0;</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.221.1">                          row &lt; r.getHeight();</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.222.1">                          row++) {</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.223.1">                        g.drawLine(0, r.getWidth());</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.224.1">                    }</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.225.1">            }</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.226.1">        }</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.227.1">    }</span></strong><span class="koboSpan" id="kobo.228.1">
}</span></pre>
<p><span class="koboSpan" id="kobo.229.1">We can see that this code has four responsibilities, </span><span class="No-Break"><span class="koboSpan" id="kobo.230.1">as follows:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.231.1">Managing the list of shapes with the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.232.1">add()</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.233.1"> method</span></span></li>
<li><span class="koboSpan" id="kobo.234.1">Drawing all the shapes in the list with the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.235.1">draw()</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.236.1"> method</span></span></li>
<li><span class="koboSpan" id="kobo.237.1">Knowing every type of shape in the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.238.1">switch</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.239.1"> statement</span></span></li>
<li><span class="koboSpan" id="kobo.240.1">Has implementation details for drawing each shape type in the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.241.1">case</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.242.1"> statements</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.243.1">If we want to add a new type of shape—triangle, for example—then we’ll need to change this code. </span><span class="koboSpan" id="kobo.243.2">This will make it longer, as we need to add details about how to draw the shape inside a new </span><strong class="source-inline"><span class="koboSpan" id="kobo.244.1">case</span></strong><span class="koboSpan" id="kobo.245.1"> statement. </span><span class="koboSpan" id="kobo.245.2">This makes the code harder to read. </span><span class="koboSpan" id="kobo.245.3">The class will also have to have </span><span class="No-Break"><span class="koboSpan" id="kobo.246.1">new tests.</span></span></p>
<p><span class="koboSpan" id="kobo.247.1">Can we</span><a id="_idIndexMarker280"/><span class="koboSpan" id="kobo.248.1"> change this code to make adding a new type of shape easier? </span><span class="koboSpan" id="kobo.248.2">Certainly. </span><span class="koboSpan" id="kobo.248.3">Let’s apply SRP </span><span class="No-Break"><span class="koboSpan" id="kobo.249.1">and refactor.</span></span></p>
<h2 id="_idParaDest-128"><a id="_idTextAnchor137"/><span class="koboSpan" id="kobo.250.1">Applying SRP to simplify future maintenance</span></h2>
<p><span class="koboSpan" id="kobo.251.1">We will refactor this code to apply SRP, taking small steps. </span><span class="koboSpan" id="kobo.251.2">The first thing to do is to move that knowledge of how to draw each type of shape out of this class, </span><span class="No-Break"><span class="koboSpan" id="kobo.252.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.253.1">
package shapes;
import java.util.ArrayList;
import java.util.List;
public class Shapes {
    private final List&lt;Shape&gt; allShapes = new ArrayList&lt;&gt;();
    public void add(Shape s) {
        allShapes.add(s);
    }
    public void draw(Graphics g) {
        for (Shape s : allShapes) {
            switch (s.getType()) {
                case "textbox":
                    var t = (TextBox) s;
                    </span><strong class="bold"><span class="koboSpan" id="kobo.254.1">t.draw(g);</span></strong><span class="koboSpan" id="kobo.255.1">
                    break;
                case "rectangle":
                    var r = (Rectangle) s;
                    </span><strong class="bold"><span class="koboSpan" id="kobo.256.1">r.draw(g);</span></strong><span class="koboSpan" id="kobo.257.1">
            }
        }
    }
}</span></pre>
<p><span class="koboSpan" id="kobo.258.1">The code that </span><a id="_idIndexMarker281"/><span class="koboSpan" id="kobo.259.1">used to be in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.260.1">case</span></strong><span class="koboSpan" id="kobo.261.1"> statement blocks has been moved into the shape classes. </span><span class="koboSpan" id="kobo.261.2">Let’s look at the changes in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.262.1">Rectangle</span></strong><span class="koboSpan" id="kobo.263.1"> class as one example—you can see what’s changed in the following </span><span class="No-Break"><span class="koboSpan" id="kobo.264.1">code snippet:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.265.1">
public class Rectangle {
    private final int width;
    private final int height;
    public Rectangle(int width, int height){
        this.width = width;
        this.height = height;
    }
    </span><strong class="bold"><span class="koboSpan" id="kobo.266.1">public void draw(Graphics g) {</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.267.1">        for (int row=0; row &lt; height; row++) {</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.268.1">            g.drawHorizontalLine(width);</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.269.1">        }</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.270.1">    }</span></strong><span class="koboSpan" id="kobo.271.1">
}</span></pre>
<p><span class="koboSpan" id="kobo.272.1">We can see how the </span><strong class="source-inline"><span class="koboSpan" id="kobo.273.1">Rectangle</span></strong><span class="koboSpan" id="kobo.274.1"> class now has the single responsibility of knowing how to draw a rectangle. </span><span class="koboSpan" id="kobo.274.2">It does nothing else. </span><span class="koboSpan" id="kobo.274.3">The one and only reason it will have to change is if we need to change how a rectangle is drawn. </span><span class="koboSpan" id="kobo.274.4">This is unlikely, meaning that we now have a </span><em class="italic"><span class="koboSpan" id="kobo.275.1">stable abstraction</span></em><span class="koboSpan" id="kobo.276.1">. </span><span class="koboSpan" id="kobo.276.2">In other words, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.277.1">Rectangle</span></strong><span class="koboSpan" id="kobo.278.1"> class is a building block we can rely on. </span><span class="koboSpan" id="kobo.278.2">It is unlikely </span><span class="No-Break"><span class="koboSpan" id="kobo.279.1">to change.</span></span></p>
<p><span class="koboSpan" id="kobo.280.1">If we examine our refactored </span><strong class="source-inline"><span class="koboSpan" id="kobo.281.1">Shapes</span></strong><span class="koboSpan" id="kobo.282.1"> class, we see that it too has improved. </span><span class="koboSpan" id="kobo.282.2">It has one responsibility </span><a id="_idIndexMarker282"/><span class="koboSpan" id="kobo.283.1">less because we moved that out into the </span><strong class="source-inline"><span class="koboSpan" id="kobo.284.1">TextBox</span></strong><span class="koboSpan" id="kobo.285.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.286.1">Rectangle</span></strong><span class="koboSpan" id="kobo.287.1"> classes. </span><span class="koboSpan" id="kobo.287.2">It is simpler to read already, and simpler </span><span class="No-Break"><span class="koboSpan" id="kobo.288.1">to test.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.289.1">SRP</span></p>
<p class="callout"><span class="koboSpan" id="kobo.290.1">Do one thing and do it well. </span><span class="koboSpan" id="kobo.290.2">Have only one reason for a code block </span><span class="No-Break"><span class="koboSpan" id="kobo.291.1">to change.</span></span></p>
<p><span class="koboSpan" id="kobo.292.1">More improvements can be made. </span><span class="koboSpan" id="kobo.292.2">We see that the </span><strong class="source-inline"><span class="koboSpan" id="kobo.293.1">Shapes</span></strong><span class="koboSpan" id="kobo.294.1"> class retains its </span><strong class="source-inline"><span class="koboSpan" id="kobo.295.1">switch</span></strong><span class="koboSpan" id="kobo.296.1"> statement and that every </span><strong class="source-inline"><span class="koboSpan" id="kobo.297.1">case</span></strong><span class="koboSpan" id="kobo.298.1"> statement looks duplicated. </span><span class="koboSpan" id="kobo.298.2">They all do the same thing, which is to call a </span><strong class="source-inline"><span class="koboSpan" id="kobo.299.1">draw()</span></strong><span class="koboSpan" id="kobo.300.1"> method on a shape class. </span><span class="koboSpan" id="kobo.300.2">We can improve this by replacing the </span><strong class="source-inline"><span class="koboSpan" id="kobo.301.1">switch</span></strong><span class="koboSpan" id="kobo.302.1"> statement entirely—but that will have to wait until the next section, where we introduce </span><span class="No-Break"><span class="koboSpan" id="kobo.303.1">the DIP.</span></span></p>
<p><span class="koboSpan" id="kobo.304.1">Before we do that, let’s think about how SRP applies to our test </span><span class="No-Break"><span class="koboSpan" id="kobo.305.1">code itself.</span></span></p>
<h2 id="_idParaDest-129"><a id="_idTextAnchor138"/><span class="koboSpan" id="kobo.306.1">Organizing tests to have a single responsibility</span></h2>
<p><span class="koboSpan" id="kobo.307.1">SRP also helps us to organize our </span><em class="italic"><span class="koboSpan" id="kobo.308.1">tests</span></em><span class="koboSpan" id="kobo.309.1">. </span><span class="koboSpan" id="kobo.309.2">Each test should test only one thing. </span><span class="koboSpan" id="kobo.309.3">Perhaps this would be a single happy path or a single boundary condition. </span><span class="koboSpan" id="kobo.309.4">This makes it simpler to localize any faults. </span><span class="koboSpan" id="kobo.309.5">We find the test that failed, and because it concerns only a single aspect of our code, it is easy to find the code where the defect must be. </span><span class="koboSpan" id="kobo.309.6">The recommendation to only have a single assertion for each test flows naturally </span><span class="No-Break"><span class="koboSpan" id="kobo.310.1">from this.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.311.1">Separating tests with different configurations</span></p>
<p class="callout"><span class="koboSpan" id="kobo.312.1">Sometimes, a group of objects can be arranged to collaborate in multiple different ways. </span><span class="koboSpan" id="kobo.312.2">The tests for this group are often better if we write a single test per configuration. </span><span class="koboSpan" id="kobo.312.3">We end up with multiple smaller tests that are easier to </span><span class="No-Break"><span class="koboSpan" id="kobo.313.1">work with.</span></span></p>
<p class="callout"><span class="koboSpan" id="kobo.314.1">This is an example of applying SRP to each configuration of that group of objects and capturing that by writing one test for each </span><span class="No-Break"><span class="koboSpan" id="kobo.315.1">specific configuration.</span></span></p>
<p><span class="koboSpan" id="kobo.316.1">We’ve seen how</span><a id="_idIndexMarker283"/><span class="koboSpan" id="kobo.317.1"> SRP helps us create simple building blocks for our code that are simpler to test and easier to work with. </span><span class="koboSpan" id="kobo.317.2">The next powerful SOLID principle to look at is DIP. </span><span class="koboSpan" id="kobo.317.3">This is a very powerful tool for </span><span class="No-Break"><span class="koboSpan" id="kobo.318.1">managing complexity.</span></span></p>
<h1 id="_idParaDest-130"><a id="_idTextAnchor139"/><span class="koboSpan" id="kobo.319.1">DIP – hiding irrelevant details</span></h1>
<p><span class="koboSpan" id="kobo.320.1">In this section, we </span><a id="_idIndexMarker284"/><span class="koboSpan" id="kobo.321.1">will learn how the DIP allows us to split code into separate components that can change independently of each other. </span><span class="koboSpan" id="kobo.321.2">We will then see how this naturally leads to the OCP part </span><span class="No-Break"><span class="koboSpan" id="kobo.322.1">of SOLID.</span></span></p>
<p><strong class="bold"><span class="koboSpan" id="kobo.323.1">Dependency inversion</span></strong><span class="koboSpan" id="kobo.324.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.325.1">DI</span></strong><span class="koboSpan" id="kobo.326.1">) means</span><a id="_idIndexMarker285"/><span class="koboSpan" id="kobo.327.1"> that we write code to depend on abstractions, not details. </span><span class="koboSpan" id="kobo.327.2">The opposite of this is having two code blocks, one that depends on the detailed implementation of the other. </span><span class="koboSpan" id="kobo.327.3">Changes to one block will cause changes to another. </span><span class="koboSpan" id="kobo.327.4">To see what this problem looks like in practice, let’s review a counter-example. </span><span class="koboSpan" id="kobo.327.5">The following code snippet begins where we left off with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.328.1">Shapes</span></strong><span class="koboSpan" id="kobo.329.1"> class after </span><a id="_idIndexMarker286"/><span class="koboSpan" id="kobo.330.1">applying SRP </span><span class="No-Break"><span class="koboSpan" id="kobo.331.1">to it:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.332.1">
package shapes;
import java.util.ArrayList;
import java.util.List;
public class Shapes {
    private final List&lt;Shape&gt; allShapes = new ArrayList&lt;&gt;();
    public void add(Shape s) {
        allShapes.add(s);
    }
    public void draw(Graphics g) {
        for (Shape s : allShapes) {
            </span><strong class="bold"><span class="koboSpan" id="kobo.333.1">switch (s.getType())</span></strong><span class="koboSpan" id="kobo.334.1"> {
                case "textbox":
                    var t = (TextBox) s;
                    t.draw(g);
                    break;
                case "rectangle":
                    var r = (Rectangle) s;
                    r.draw(g);
            }
        }
    }
}</span></pre>
<p><span class="koboSpan" id="kobo.335.1">This code does work well to maintain a list of </span><strong class="source-inline"><span class="koboSpan" id="kobo.336.1">Shape</span></strong><span class="koboSpan" id="kobo.337.1"> objects and draw them. </span><span class="koboSpan" id="kobo.337.2">The problem is that it knows too much about the types of shapes it is supposed to draw. </span><span class="koboSpan" id="kobo.337.3">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.338.1">draw()</span></strong><span class="koboSpan" id="kobo.339.1"> method</span><a id="_idIndexMarker287"/><span class="koboSpan" id="kobo.340.1"> features a</span><strong class="bold"><span class="koboSpan" id="kobo.341.1"> switch-on-type</span></strong><em class="italic"> </em><span class="koboSpan" id="kobo.342.1">of object that you can see. </span><span class="koboSpan" id="kobo.342.2">That means that if anything changes about which types of shapes should be drawn, then this code must also change. </span><span class="koboSpan" id="kobo.342.3">If we want to add a new </span><strong class="source-inline"><span class="koboSpan" id="kobo.343.1">Shape</span></strong><span class="koboSpan" id="kobo.344.1"> to the system, then we have to modify this </span><strong class="source-inline"><span class="koboSpan" id="kobo.345.1">switch</span></strong><span class="koboSpan" id="kobo.346.1"> statement and the associated TDD </span><span class="No-Break"><span class="koboSpan" id="kobo.347.1">test code.</span></span></p>
<p><span class="koboSpan" id="kobo.348.1">The technical term for one class knowing about another is that a </span><strong class="bold"><span class="koboSpan" id="kobo.349.1">dependency</span></strong><span class="koboSpan" id="kobo.350.1"> exists between them. </span><span class="koboSpan" id="kobo.350.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.351.1">Shapes</span></strong><span class="koboSpan" id="kobo.352.1"> class </span><em class="italic"><span class="koboSpan" id="kobo.353.1">depends on</span></em><span class="koboSpan" id="kobo.354.1"> the </span><strong class="source-inline"><span class="koboSpan" id="kobo.355.1">TextBox</span></strong><span class="koboSpan" id="kobo.356.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.357.1">Rectangle</span></strong><span class="koboSpan" id="kobo.358.1"> classes. </span><span class="koboSpan" id="kobo.358.2">We can</span><a id="_idIndexMarker288"/><span class="koboSpan" id="kobo.359.1"> represent that visually in the following UML </span><span class="No-Break"><span class="koboSpan" id="kobo.360.1">class diagram:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer049">
<span class="koboSpan" id="kobo.361.1"><img alt="Figure 7.4 – Depending on the details" src="image/Figure_7.4_B18384.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.362.1">Figure 7.4 – Depending on the details</span></p>
<p><span class="koboSpan" id="kobo.363.1">We can see that the </span><strong class="source-inline"><span class="koboSpan" id="kobo.364.1">Shapes</span></strong><span class="koboSpan" id="kobo.365.1"> class depends directly on the detail of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.366.1">Rectangle</span></strong><span class="koboSpan" id="kobo.367.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.368.1">TextBox</span></strong><span class="koboSpan" id="kobo.369.1"> classes. </span><span class="koboSpan" id="kobo.369.2">This is shown by the direction of the arrows in the UML class diagram. </span><span class="koboSpan" id="kobo.369.3">Having these dependencies makes working with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.370.1">Shapes</span></strong><span class="koboSpan" id="kobo.371.1"> class more difficult for the </span><span class="No-Break"><span class="koboSpan" id="kobo.372.1">following reasons:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.373.1">We have to change the </span><strong class="source-inline"><span class="koboSpan" id="kobo.374.1">Shapes</span></strong><span class="koboSpan" id="kobo.375.1"> class to add a new kind </span><span class="No-Break"><span class="koboSpan" id="kobo.376.1">of shape</span></span></li>
<li><span class="koboSpan" id="kobo.377.1">Any changes in the concrete classes such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.378.1">Rectangle</span></strong><span class="koboSpan" id="kobo.379.1"> will cause this code </span><span class="No-Break"><span class="koboSpan" id="kobo.380.1">to change</span></span></li>
<li><span class="koboSpan" id="kobo.381.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.382.1">Shapes</span></strong><span class="koboSpan" id="kobo.383.1"> class will get longer and less easy </span><span class="No-Break"><span class="koboSpan" id="kobo.384.1">to read</span></span></li>
<li><span class="koboSpan" id="kobo.385.1">We will end up with more </span><span class="No-Break"><span class="koboSpan" id="kobo.386.1">test cases</span></span></li>
<li><span class="koboSpan" id="kobo.387.1">Each test case will be coupled to concrete classes such </span><span class="No-Break"><span class="koboSpan" id="kobo.388.1">as </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.389.1">Rectangle</span></strong></span></li>
</ul>
<p><span class="koboSpan" id="kobo.390.1">This is a very procedural approach to creating a class that deals with multiple kinds of shapes. </span><span class="koboSpan" id="kobo.390.2">It violates SRP by doing too much and knowing too much detail about each kind of shape object. </span><span class="koboSpan" id="kobo.390.3">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.391.1">Shapes</span></strong><span class="koboSpan" id="kobo.392.1"> class depends on the details of concrete classes such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.393.1">Rectangle</span></strong><span class="koboSpan" id="kobo.394.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.395.1">TextBox</span></strong><span class="koboSpan" id="kobo.396.1">, which directly causes the </span><span class="No-Break"><span class="koboSpan" id="kobo.397.1">aforementioned problems.</span></span></p>
<p><span class="koboSpan" id="kobo.398.1">Thankfully, there is a better way. </span><span class="koboSpan" id="kobo.398.2">We can use the power of an interface to improve this, by making it</span><a id="_idIndexMarker289"/><span class="koboSpan" id="kobo.399.1"> so that the </span><strong class="source-inline"><span class="koboSpan" id="kobo.400.1">Shapes</span></strong><span class="koboSpan" id="kobo.401.1"> class does </span><em class="italic"><span class="koboSpan" id="kobo.402.1">not</span></em><span class="koboSpan" id="kobo.403.1"> depend on those details. </span><span class="koboSpan" id="kobo.403.2">This is called DI. </span><span class="koboSpan" id="kobo.403.3">Let’s see what that looks </span><span class="No-Break"><span class="koboSpan" id="kobo.404.1">like next.</span></span></p>
<h2 id="_idParaDest-131"><a id="_idTextAnchor140"/><span class="koboSpan" id="kobo.405.1">Applying DI to the shapes code</span></h2>
<p><span class="koboSpan" id="kobo.406.1">We can improve</span><a id="_idIndexMarker290"/><span class="koboSpan" id="kobo.407.1"> the shapes </span><a id="_idIndexMarker291"/><span class="koboSpan" id="kobo.408.1">code by applying the </span><strong class="bold"><span class="koboSpan" id="kobo.409.1">Dependency Inversion Principle (DIP)</span></strong><span class="koboSpan" id="kobo.410.1"> described in the previous chapter. </span><span class="koboSpan" id="kobo.410.2">Let’s add a </span><strong class="source-inline"><span class="koboSpan" id="kobo.411.1">draw()</span></strong><span class="koboSpan" id="kobo.412.1"> method to our </span><strong class="source-inline"><span class="koboSpan" id="kobo.413.1">Shape</span></strong><span class="koboSpan" id="kobo.414.1"> interface, </span><span class="No-Break"><span class="koboSpan" id="kobo.415.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.416.1">
package shapes;
public interface Shape {
    void draw(Graphics g);
}</span></pre>
<p><span class="koboSpan" id="kobo.417.1">This interface is our abstraction of the single responsibility that each shape has. </span><span class="koboSpan" id="kobo.417.2">Each shape must know how to draw itself when we call the </span><strong class="source-inline"><span class="koboSpan" id="kobo.418.1">draw()</span></strong><span class="koboSpan" id="kobo.419.1"> method. </span><span class="koboSpan" id="kobo.419.2">The next step is to make our concrete shape classes implement </span><span class="No-Break"><span class="koboSpan" id="kobo.420.1">this interface.</span></span></p>
<p><span class="koboSpan" id="kobo.421.1">Let’s take the </span><strong class="source-inline"><span class="koboSpan" id="kobo.422.1">Rectangle</span></strong><span class="koboSpan" id="kobo.423.1"> class as an example. </span><span class="koboSpan" id="kobo.423.2">You can see </span><span class="No-Break"><span class="koboSpan" id="kobo.424.1">this here:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.425.1">
public class Rectangle </span><strong class="bold"><span class="koboSpan" id="kobo.426.1">implements Shape</span></strong><span class="koboSpan" id="kobo.427.1"> {
    private final int width;
    private final int height;
    public Rectangle(int width, int height){
        this.width = width;
        this.height = height;
    }
    </span><strong class="bold"><span class="koboSpan" id="kobo.428.1">@Override</span></strong><span class="koboSpan" id="kobo.429.1">
    </span><strong class="bold"><span class="koboSpan" id="kobo.430.1">public void draw(Graphics g) {</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.431.1">        for (int row=0; row &lt; height; row++) {</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.432.1">            g.drawHorizontalLine(width);</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.433.1">        }</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.434.1">    }</span></strong><span class="koboSpan" id="kobo.435.1">
}</span></pre>
<p><span class="koboSpan" id="kobo.436.1">We’ve </span><a id="_idIndexMarker292"/><span class="koboSpan" id="kobo.437.1">now</span><a id="_idIndexMarker293"/><span class="koboSpan" id="kobo.438.1"> introduced the OO concept of polymorphism into our shape classes. </span><span class="koboSpan" id="kobo.438.2">This breaks the dependency that the </span><strong class="source-inline"><span class="koboSpan" id="kobo.439.1">Shapes</span></strong><span class="koboSpan" id="kobo.440.1"> class has on knowing about the </span><strong class="source-inline"><span class="koboSpan" id="kobo.441.1">Rectangle</span></strong><span class="koboSpan" id="kobo.442.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.443.1">TextBox</span></strong><span class="koboSpan" id="kobo.444.1"> classes. </span><span class="koboSpan" id="kobo.444.2">All that the </span><strong class="source-inline"><span class="koboSpan" id="kobo.445.1">Shapes</span></strong><span class="koboSpan" id="kobo.446.1"> class now depends on is the </span><strong class="source-inline"><span class="koboSpan" id="kobo.447.1">Shape</span></strong><span class="koboSpan" id="kobo.448.1"> interface. </span><span class="koboSpan" id="kobo.448.2">It no longer needs to know the type of </span><span class="No-Break"><span class="koboSpan" id="kobo.449.1">each shape.</span></span></p>
<p><span class="koboSpan" id="kobo.450.1">We can refactor the </span><strong class="source-inline"><span class="koboSpan" id="kobo.451.1">Shapes</span></strong><span class="koboSpan" id="kobo.452.1"> class to look </span><span class="No-Break"><span class="koboSpan" id="kobo.453.1">like this:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.454.1">
public class Shapes {
    private final List&lt;Shape&gt; all = new ArrayList&lt;&gt;();
    public void add(Shape s) {
        all.add(s);
    }
</span><strong class="bold"><span class="koboSpan" id="kobo.455.1">    public void draw(Graphics graphics) {</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.456.1">        all.forEach(shape-&gt;shape.draw(graphics));</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.457.1">    }</span></strong><span class="koboSpan" id="kobo.458.1">
}</span></pre>
<p><span class="koboSpan" id="kobo.459.1">This refactoring has completely removed the </span><strong class="source-inline"><span class="koboSpan" id="kobo.460.1">switch</span></strong><span class="koboSpan" id="kobo.461.1"> statement and the </span><strong class="source-inline"><span class="koboSpan" id="kobo.462.1">getType()</span></strong><span class="koboSpan" id="kobo.463.1"> method, making the code much simpler to understand and test.  </span><span class="koboSpan" id="kobo.463.2">If we add a new kind of shape, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.464.1">Shapes</span></strong><span class="koboSpan" id="kobo.465.1"> class </span><em class="italic"><span class="koboSpan" id="kobo.466.1">no longer needs to change</span></em><span class="koboSpan" id="kobo.467.1">. </span><span class="koboSpan" id="kobo.467.2">We have broken that dependency on knowing the details of </span><span class="No-Break"><span class="koboSpan" id="kobo.468.1">shape classes.</span></span></p>
<p><span class="koboSpan" id="kobo.469.1">One minor refactor moves the </span><strong class="source-inline"><span class="koboSpan" id="kobo.470.1">Graphics</span></strong><span class="koboSpan" id="kobo.471.1"> parameter we pass into the </span><strong class="source-inline"><span class="koboSpan" id="kobo.472.1">draw()</span></strong><span class="koboSpan" id="kobo.473.1"> method into a field, initialized</span><a id="_idIndexMarker294"/><span class="koboSpan" id="kobo.474.1"> in the </span><a id="_idIndexMarker295"/><span class="koboSpan" id="kobo.475.1">constructor, as illustrated in the following </span><span class="No-Break"><span class="koboSpan" id="kobo.476.1">code snippet:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.477.1">
public class Shapes {
    private final List&lt;Shape&gt; all = new ArrayList&lt;&gt;();
    </span><strong class="bold"><span class="koboSpan" id="kobo.478.1">private final Graphics graphics;</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.479.1">    public Shapes(Graphics graphics) {</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.480.1">        </span></strong><strong class="bold"><span class="koboSpan" id="kobo.481.1">this.graphics = graphics;</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.482.1">    }</span></strong><span class="koboSpan" id="kobo.483.1">
    public void add(Shape s) {
        all.add(s);
    }
    public void </span><strong class="bold"><span class="koboSpan" id="kobo.484.1">draw()</span></strong><span class="koboSpan" id="kobo.485.1"> {
        all.forEach(shape-&gt;shape.draw(graphics));
    }
}</span></pre>
<p><span class="koboSpan" id="kobo.486.1">This is DIP at work. </span><span class="koboSpan" id="kobo.486.2">We’ve created an abstraction in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.487.1">Shape</span></strong><span class="koboSpan" id="kobo.488.1"> interface. </span><span class="koboSpan" id="kobo.488.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.489.1">Shapes</span></strong><span class="koboSpan" id="kobo.490.1"> class is a consumer of this abstraction. </span><span class="koboSpan" id="kobo.490.2">The classes implementing that interface are providers. </span><span class="koboSpan" id="kobo.490.3">Both sets of classes depend only on the abstraction; they do not depend on details inside each other. </span><span class="koboSpan" id="kobo.490.4">There are no references to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.491.1">Rectangle</span></strong><span class="koboSpan" id="kobo.492.1"> class in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.493.1">Shapes</span></strong><span class="koboSpan" id="kobo.494.1"> class, and there are no references to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.495.1">Shapes</span></strong><span class="koboSpan" id="kobo.496.1"> inside the </span><strong class="source-inline"><span class="koboSpan" id="kobo.497.1">Rectangle</span></strong><span class="koboSpan" id="kobo.498.1"> class. </span><span class="koboSpan" id="kobo.498.2">We can see this inversion of dependencies visualized in the following UML class diagram—see </span><a id="_idIndexMarker296"/><span class="koboSpan" id="kobo.499.1">how </span><a id="_idIndexMarker297"/><span class="koboSpan" id="kobo.500.1">the direction of the dependency arrows has changed compared to </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.501.1">Figure 7</span></em></span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.502.1">.4</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.503.1">:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer050">
<span class="koboSpan" id="kobo.504.1"><img alt="Figure 7.5 – Inverting dependencies" src="image/Figure_7.5_B18384.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.505.1">Figure 7.5 – Inverting dependencies</span></p>
<p><span class="koboSpan" id="kobo.506.1">In this version of the UML diagram, the arrows describing the dependencies between classes point the opposite way. </span><em class="italic"><span class="koboSpan" id="kobo.507.1">The dependencies have been inverted</span></em><span class="koboSpan" id="kobo.508.1">—hence, the name of this principle. </span><span class="koboSpan" id="kobo.508.2">Our </span><strong class="source-inline"><span class="koboSpan" id="kobo.509.1">Shapes</span></strong><span class="koboSpan" id="kobo.510.1"> class now depends on our abstraction, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.511.1">Shape</span></strong><span class="koboSpan" id="kobo.512.1"> interface. </span><span class="koboSpan" id="kobo.512.2">So do all the </span><strong class="source-inline"><span class="koboSpan" id="kobo.513.1">Rectangle</span></strong><span class="koboSpan" id="kobo.514.1"> class and </span><strong class="source-inline"><span class="koboSpan" id="kobo.515.1">TextBox</span></strong><span class="koboSpan" id="kobo.516.1"> class concrete implementations. </span><span class="koboSpan" id="kobo.516.2">We have inverted the dependency graph and turned the arrows upside down. </span><span class="koboSpan" id="kobo.516.3">DI fully decouples classes from each other and, as such, is very powerful. </span><span class="koboSpan" id="kobo.516.4">We will see how this leads to a key technique for TDD testing when we look at </span><a href="B18384_08.xhtml#_idTextAnchor149"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.517.1">Chapter 8</span></em></span></a><span class="koboSpan" id="kobo.518.1">, </span><em class="italic"><span class="koboSpan" id="kobo.519.1">Test Doubles – Stubs </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.520.1">and Mocks</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.521.1">.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.522.1">DIP</span></p>
<p class="callout"><span class="koboSpan" id="kobo.523.1">Make code depend on abstractions and not </span><span class="No-Break"><span class="koboSpan" id="kobo.524.1">on details.</span></span></p>
<p><span class="koboSpan" id="kobo.525.1">We’ve seen how DIP is a major tool we can use to simplify our code. </span><span class="koboSpan" id="kobo.525.2">It allows us to write code that deals with an interface, and then use that code with any concrete class that implements </span><a id="_idIndexMarker298"/><span class="koboSpan" id="kobo.526.1">that</span><a id="_idIndexMarker299"/><span class="koboSpan" id="kobo.527.1"> interface. </span><span class="koboSpan" id="kobo.527.2">This begs a question: can we write a class that implements an interface but will not work correctly? </span><span class="koboSpan" id="kobo.527.3">That’s the subject of our </span><span class="No-Break"><span class="koboSpan" id="kobo.528.1">next section.</span></span></p>
<h1 id="_idParaDest-132"><a id="_idTextAnchor141"/><span class="koboSpan" id="kobo.529.1">LSP – swappable objects</span></h1>
<p><em class="italic"><span class="koboSpan" id="kobo.530.1">Turing Award</span></em><span class="koboSpan" id="kobo.531.1"> winner</span><a id="_idIndexMarker300"/><span class="koboSpan" id="kobo.532.1"> Barbara Liskov is the creator of a rule concerning inheritance that is now commonly known as LSP. </span><span class="koboSpan" id="kobo.532.2">It was brought about by a question in OOP: if we can extend a class and use it in place of the class we extended, how can we be sure the new class will not </span><span class="No-Break"><span class="koboSpan" id="kobo.533.1">break things?</span></span></p>
<p><span class="koboSpan" id="kobo.534.1">We’ve seen in the previous section on DIP how we can use any class that implements an interface in place of the interface itself. </span><span class="koboSpan" id="kobo.534.2">We also saw how those classes can provide any implementation they like for that method. </span><span class="koboSpan" id="kobo.534.3">The interface itself provides no guarantees at all about what might lurk inside that </span><span class="No-Break"><span class="koboSpan" id="kobo.535.1">implementation code.</span></span></p>
<p><span class="koboSpan" id="kobo.536.1">There is, of course, a bad side to this—which LSP aims to avoid. </span><span class="koboSpan" id="kobo.536.2">Let’s explain this by looking at a counter-example in code. </span><span class="koboSpan" id="kobo.536.3">Suppose we made a new class that implemented </span><strong class="source-inline"><span class="koboSpan" id="kobo.537.1">interface Shape</span></strong><span class="koboSpan" id="kobo.538.1">, such as this one (Warning: Do </span><em class="italic"><span class="koboSpan" id="kobo.539.1">NOT</span></em><span class="koboSpan" id="kobo.540.1"> run the code that follows in the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.541.1">MaliciousShape</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.542.1"> class!):</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.543.1">
public class MaliciousShape implements Shape {
    @Override
    public void draw(Graphics g) {
        try {
            String[] deleteEverything = {"rm", "-Rf", "*"};
            Runtime.getRuntime().exec(deleteEverything,null);
            g.drawText("Nothing to see here...");
        } catch (Exception ex) {
            // No action
        }
    }
}</span></pre>
<p><span class="koboSpan" id="kobo.544.1">Notice anything a little odd about that new class? </span><span class="koboSpan" id="kobo.544.2">It contains a Unix command to remove all our files! </span><span class="koboSpan" id="kobo.544.3">This is not what we are expecting when we call the </span><strong class="source-inline"><span class="koboSpan" id="kobo.545.1">draw()</span></strong><span class="koboSpan" id="kobo.546.1"> method on a shape object. </span><span class="koboSpan" id="kobo.546.2">Due to permissions failures, it might not be able to delete anything, but it’s an example of what can </span><span class="No-Break"><span class="koboSpan" id="kobo.547.1">go wrong.</span></span></p>
<p><span class="koboSpan" id="kobo.548.1">An interface in Java can only protect the </span><em class="italic"><span class="koboSpan" id="kobo.549.1">syntax</span></em><span class="koboSpan" id="kobo.550.1"> of method calls we expect. </span><span class="koboSpan" id="kobo.550.2">It cannot enforce any </span><em class="italic"><span class="koboSpan" id="kobo.551.1">semantics</span></em><span class="koboSpan" id="kobo.552.1">. </span><span class="koboSpan" id="kobo.552.2">The problem with the preceding </span><strong class="source-inline"><span class="koboSpan" id="kobo.553.1">MaliciousShape</span></strong><span class="koboSpan" id="kobo.554.1"> class is that it does not respect the intent behind </span><span class="No-Break"><span class="koboSpan" id="kobo.555.1">the interface.</span></span></p>
<p><span class="koboSpan" id="kobo.556.1">LSP guides us </span><a id="_idIndexMarker301"/><span class="koboSpan" id="kobo.557.1">to avoid this error. </span><span class="koboSpan" id="kobo.557.2">In other words, LSP states that any class that implements an interface or extends another class must handle all the input combinations that the original class/interface could. </span><span class="koboSpan" id="kobo.557.3">It must provide the expected outputs, it must not ignore valid inputs, and it must not produce completely unexpected and undesired behavior. </span><span class="koboSpan" id="kobo.557.4">Classes written like this are safe to use through a reference to their interface. </span><span class="koboSpan" id="kobo.557.5">The problem with our </span><strong class="source-inline"><span class="koboSpan" id="kobo.558.1">MaliciousShape</span></strong><span class="koboSpan" id="kobo.559.1"> class is that it was not compatible with LSP—it added some extra totally unexpected and </span><span class="No-Break"><span class="koboSpan" id="kobo.560.1">unwanted behavior.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.561.1">LSP formal definition</span></p>
<p class="callout"><span class="koboSpan" id="kobo.562.1">American computer scientist Barbara Liskov came up with a formal definition: If </span><em class="italic"><span class="koboSpan" id="kobo.563.1">p(x)</span></em><span class="koboSpan" id="kobo.564.1"> is a property provable about objects </span><em class="italic"><span class="koboSpan" id="kobo.565.1">x</span></em><span class="koboSpan" id="kobo.566.1"> of type </span><em class="italic"><span class="koboSpan" id="kobo.567.1">T</span></em><span class="koboSpan" id="kobo.568.1">, then </span><em class="italic"><span class="koboSpan" id="kobo.569.1">p(y)</span></em><span class="koboSpan" id="kobo.570.1"> should be true for objects </span><em class="italic"><span class="koboSpan" id="kobo.571.1">y</span></em><span class="koboSpan" id="kobo.572.1"> of type </span><em class="italic"><span class="koboSpan" id="kobo.573.1">S</span></em><span class="koboSpan" id="kobo.574.1"> where </span><em class="italic"><span class="koboSpan" id="kobo.575.1">S</span></em><span class="koboSpan" id="kobo.576.1"> is a subtype </span><span class="No-Break"><span class="koboSpan" id="kobo.577.1">of </span></span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.578.1">T</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.579.1">.</span></span></p>
<h2 id="_idParaDest-133"><a id="_idTextAnchor142"/><span class="koboSpan" id="kobo.580.1">Reviewing LSP usage in the shapes code</span></h2>
<p><span class="koboSpan" id="kobo.581.1">The </span><a id="_idIndexMarker302"/><span class="koboSpan" id="kobo.582.1">classes that</span><a id="_idIndexMarker303"/><span class="koboSpan" id="kobo.583.1"> implement </span><strong class="source-inline"><span class="koboSpan" id="kobo.584.1">Shape</span></strong><span class="koboSpan" id="kobo.585.1"> all conform to LSP. </span><span class="koboSpan" id="kobo.585.2">This is clear in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.586.1">TextBox</span></strong><span class="koboSpan" id="kobo.587.1"> class, as we can </span><span class="No-Break"><span class="koboSpan" id="kobo.588.1">see here:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.589.1">
public class TextBox implements Shape {
    private final String text;
    public TextBox(String text) {
        this.text = text;
    }
    @Override
    public void draw(Graphics g) {
        g.drawText(text);
    }
}</span></pre>
<p><span class="koboSpan" id="kobo.590.1">The preceding code clearly can handle drawing any valid text provided to its constructor. </span><span class="koboSpan" id="kobo.590.2">It also provides no surprises. </span><span class="koboSpan" id="kobo.590.3">It draws the text, using primitives from the </span><strong class="source-inline"><span class="koboSpan" id="kobo.591.1">Graphics</span></strong><span class="koboSpan" id="kobo.592.1"> class, and does </span><span class="No-Break"><span class="koboSpan" id="kobo.593.1">nothing else.</span></span></p>
<p><span class="koboSpan" id="kobo.594.1">Other examples of LSP compliance can be seen in the </span><span class="No-Break"><span class="koboSpan" id="kobo.595.1">following classes:</span></span></p>
<ul>
<li><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.596.1">Rectangle</span></strong></span></li>
<li><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.597.1">Triangle</span></strong></span></li>
</ul>
<p class="callout-heading"><span class="koboSpan" id="kobo.598.1">LSP</span></p>
<p class="callout"><span class="koboSpan" id="kobo.599.1">A code block can be safely swapped for another if it can handle the full range of inputs and provide (at least) all expected outputs, with no undesired </span><span class="No-Break"><span class="koboSpan" id="kobo.600.1">side effects.</span></span></p>
<p><span class="koboSpan" id="kobo.601.1">There are some surprising violations of LSP. </span><span class="koboSpan" id="kobo.601.2">Perhaps the classic one for the shapes code example is about adding a </span><strong class="source-inline"><span class="koboSpan" id="kobo.602.1">Square</span></strong><span class="koboSpan" id="kobo.603.1"> class. </span><span class="koboSpan" id="kobo.603.2">In mathematics, a square is a kind of rectangle, with the extra constraint that its height and width are equal. </span><span class="koboSpan" id="kobo.603.3">In Java code, should we make the </span><strong class="source-inline"><span class="koboSpan" id="kobo.604.1">Square</span></strong><span class="koboSpan" id="kobo.605.1"> class extend the </span><strong class="source-inline"><span class="koboSpan" id="kobo.606.1">Rectangle</span></strong><span class="koboSpan" id="kobo.607.1"> class? </span><span class="koboSpan" id="kobo.607.2">How about the </span><strong class="source-inline"><span class="koboSpan" id="kobo.608.1">Rectangle</span></strong><span class="koboSpan" id="kobo.609.1"> class </span><span class="No-Break"><span class="koboSpan" id="kobo.610.1">extending </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.611.1">Square</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.612.1">?</span></span></p>
<p><span class="koboSpan" id="kobo.613.1">Let’s apply LSP to decide. </span><span class="koboSpan" id="kobo.613.2">We will imagine some code that expects a </span><strong class="source-inline"><span class="koboSpan" id="kobo.614.1">Rectangle</span></strong><span class="koboSpan" id="kobo.615.1"> class so that it can change its height, but not its width. </span><span class="koboSpan" id="kobo.615.2">If we passed a </span><strong class="source-inline"><span class="koboSpan" id="kobo.616.1">Square</span></strong><span class="koboSpan" id="kobo.617.1"> class to that code, would it work properly? </span><span class="koboSpan" id="kobo.617.2">The answer is no. </span><span class="koboSpan" id="kobo.617.3">You would then have a square with unequal width and height. </span><span class="koboSpan" id="kobo.617.4">This </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.618.1">fails</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.619.1"> LSP.</span></span></p>
<p><span class="koboSpan" id="kobo.620.1">The point of</span><a id="_idIndexMarker304"/><span class="koboSpan" id="kobo.621.1"> LSP</span><a id="_idIndexMarker305"/><span class="koboSpan" id="kobo.622.1"> is about making classes properly conform to interfaces. </span><span class="koboSpan" id="kobo.622.2">In the next section, we’ll look at OCP, which is closely related </span><span class="No-Break"><span class="koboSpan" id="kobo.623.1">to DI.</span></span></p>
<h1 id="_idParaDest-134"><a id="_idTextAnchor143"/><span class="koboSpan" id="kobo.624.1">OCP – extensible design</span></h1>
<p><span class="koboSpan" id="kobo.625.1">In this </span><a id="_idIndexMarker306"/><span class="koboSpan" id="kobo.626.1">section, we’ll see how OCP helps us write code that we can add new features to, without changing the code itself. </span><span class="koboSpan" id="kobo.626.2">This does sound like an impossibility at first, but it flows naturally from DIP combined </span><span class="No-Break"><span class="koboSpan" id="kobo.627.1">with LSP.</span></span></p>
<p><span class="koboSpan" id="kobo.628.1">OCP results in code that is open to extension but closed to modification. </span><span class="koboSpan" id="kobo.628.2">We saw this idea at work when we looked at DIP. </span><span class="koboSpan" id="kobo.628.3">Let’s review the code refactoring we did in the light </span><span class="No-Break"><span class="koboSpan" id="kobo.629.1">of OCP.</span></span></p>
<p><span class="koboSpan" id="kobo.630.1">Let’s start with the original code for the </span><strong class="source-inline"><span class="koboSpan" id="kobo.631.1">Shapes</span></strong><span class="koboSpan" id="kobo.632.1"> class, </span><span class="No-Break"><span class="koboSpan" id="kobo.633.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.634.1">
public class Shapes {
    private final List&lt;Shape&gt; allShapes = new ArrayList&lt;&gt;();
    public void add(Shape s) {
        allShapes.add(s);
    }
    public void draw(Graphics g) {
        </span><strong class="bold"><span class="koboSpan" id="kobo.635.1">for (Shape s : allShapes) {</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.636.1">            switch (s.getType()) {</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.637.1">                case "textbox":</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.638.1">                    var t = (TextBox) s;</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.639.1">                    g.drawText(t.getText());</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.640.1">                    break;</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.641.1">                case "rectangle":</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.642.1">                    var r = (Rectangle) s;</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.643.1">                    for (int row = 0;</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.644.1">                          row &lt; r.getHeight();</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.645.1">                          row++) {</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.646.1">                        g.drawLine(0, r.getWidth());</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.647.1">                    }</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.648.1">            }</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.649.1">        }</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.650.1">    }</span></strong><span class="koboSpan" id="kobo.651.1">
}</span></pre>
<p><span class="koboSpan" id="kobo.652.1">Adding a new type</span><a id="_idIndexMarker307"/><span class="koboSpan" id="kobo.653.1"> of shape requires modification of the code inside the </span><strong class="source-inline"><span class="koboSpan" id="kobo.654.1">draw()</span></strong><span class="koboSpan" id="kobo.655.1"> method. </span><span class="koboSpan" id="kobo.655.2">We will be adding a new </span><strong class="source-inline"><span class="koboSpan" id="kobo.656.1">case</span></strong><span class="koboSpan" id="kobo.657.1"> statement in to support our </span><span class="No-Break"><span class="koboSpan" id="kobo.658.1">new shape.</span></span></p>
<p><span class="koboSpan" id="kobo.659.1">Modifying existing code has several disadvantages, as set </span><span class="No-Break"><span class="koboSpan" id="kobo.660.1">out here:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.661.1">We invalidate prior testing. </span><span class="koboSpan" id="kobo.661.2">This is now different code than we </span><span class="No-Break"><span class="koboSpan" id="kobo.662.1">had tested.</span></span></li>
<li><span class="koboSpan" id="kobo.663.1">We might introduce an error that breaks some of the existing support </span><span class="No-Break"><span class="koboSpan" id="kobo.664.1">for shapes.</span></span></li>
<li><span class="koboSpan" id="kobo.665.1">The code will become longer and more difficult </span><span class="No-Break"><span class="koboSpan" id="kobo.666.1">to read.</span></span></li>
<li><span class="koboSpan" id="kobo.667.1">We might have several developers add shapes at the same time and get a merge conflict when we combine </span><span class="No-Break"><span class="koboSpan" id="kobo.668.1">their work.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.669.1">By applying DIP and refactoring the code, we ended up </span><span class="No-Break"><span class="koboSpan" id="kobo.670.1">with this:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.671.1">
public class Shapes {
    private final List&lt;Shape&gt; all = new ArrayList&lt;&gt;();
    private final Graphics graphics;
    public Shapes(Graphics graphics) {
        this.graphics = graphics;
    }
    public void add(Shape s) {
        all.add(s);
    }
    public void draw() {
        all.forEach(shape-&gt;shape.draw(graphics));
    }
}</span></pre>
<p><span class="koboSpan" id="kobo.672.1">We can now see</span><a id="_idIndexMarker308"/><span class="koboSpan" id="kobo.673.1"> that adding a new type of shape </span><em class="italic"><span class="koboSpan" id="kobo.674.1">does not need modification to this code</span></em><span class="koboSpan" id="kobo.675.1">. </span><span class="koboSpan" id="kobo.675.2">This is an example of OCP at work. </span><span class="koboSpan" id="kobo.675.3">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.676.1">Shapes</span></strong><span class="koboSpan" id="kobo.677.1"> class is </span><em class="italic"><span class="koboSpan" id="kobo.678.1">open</span></em><span class="koboSpan" id="kobo.679.1"> to having new kinds of shapes defined, but it is </span><em class="italic"><span class="koboSpan" id="kobo.680.1">closed</span></em><span class="koboSpan" id="kobo.681.1"> against the need for modification when that new shape is added. </span><span class="koboSpan" id="kobo.681.2">This also means that any tests relating to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.682.1">Shapes</span></strong><span class="koboSpan" id="kobo.683.1"> class will remain unchanged, as there is no difference in behavior for this class. </span><span class="koboSpan" id="kobo.683.2">That is a </span><span class="No-Break"><span class="koboSpan" id="kobo.684.1">powerful advantage.</span></span></p>
<p><span class="koboSpan" id="kobo.685.1">OCP relies on DI to work. </span><span class="koboSpan" id="kobo.685.2">It is more or less a restatement of a consequence of applying DIP. </span><span class="koboSpan" id="kobo.685.3">It also provides us with a technique to support </span><em class="italic"><span class="koboSpan" id="kobo.686.1">swappable behavior</span></em><span class="koboSpan" id="kobo.687.1">. </span><span class="koboSpan" id="kobo.687.2">We can use DIP and OCP to create </span><span class="No-Break"><span class="koboSpan" id="kobo.688.1">plugin systems.</span></span></p>
<h2 id="_idParaDest-135"><a id="_idTextAnchor144"/><span class="koboSpan" id="kobo.689.1">Adding a new type of shape</span></h2>
<p><span class="koboSpan" id="kobo.690.1">To see how</span><a id="_idIndexMarker309"/><span class="koboSpan" id="kobo.691.1"> this works in </span><a id="_idIndexMarker310"/><span class="koboSpan" id="kobo.692.1">practice, let’s create a new type of shape, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.693.1">RightArrow</span></strong><span class="koboSpan" id="kobo.694.1"> class, </span><span class="No-Break"><span class="koboSpan" id="kobo.695.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.696.1">
public class RightArrow implements Shape {
  public void draw(Graphics g) {
    g.drawText( "   \" );
    g.drawText( "-----" );
    g.drawText( "   /" );
  }
}</span></pre>
<p><span class="koboSpan" id="kobo.697.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.698.1">RightArrow</span></strong><span class="koboSpan" id="kobo.699.1"> class implements the </span><strong class="source-inline"><span class="koboSpan" id="kobo.700.1">Shape</span></strong><span class="koboSpan" id="kobo.701.1"> interface and defines a </span><strong class="source-inline"><span class="koboSpan" id="kobo.702.1">draw()</span></strong><span class="koboSpan" id="kobo.703.1"> method. </span><span class="koboSpan" id="kobo.703.2">To demonstrate that nothing in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.704.1">Shapes</span></strong><span class="koboSpan" id="kobo.705.1"> class needs to change in order to use this, let’s review some code that uses both the </span><strong class="source-inline"><span class="koboSpan" id="kobo.706.1">Shapes</span></strong><span class="koboSpan" id="kobo.707.1"> and our new class, </span><strong class="source-inline"><span class="koboSpan" id="kobo.708.1">RightArrow</span></strong><span class="koboSpan" id="kobo.709.1">, </span><span class="No-Break"><span class="koboSpan" id="kobo.710.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.711.1">
package shapes;
public class ShapesExample {
    public static void main(String[] args) {
        new ShapesExample().run();
    }
    private void run() {
        Graphics console = new ConsoleGraphics();
        var shapes = new Shapes(console);
        shapes.add(new TextBox("Hello!"));
        shapes.add(new Rectangle(32,1));
        </span><strong class="bold"><span class="koboSpan" id="kobo.712.1">shapes.add(new RightArrow());</span></strong><span class="koboSpan" id="kobo.713.1">
        shapes.draw();
    }
}</span></pre>
<p><span class="koboSpan" id="kobo.714.1">We see that the </span><strong class="source-inline"><span class="koboSpan" id="kobo.715.1">Shapes</span></strong><span class="koboSpan" id="kobo.716.1"> class is being used in a completely normal way, without change. </span><span class="koboSpan" id="kobo.716.2">In fact, the only change needed to use our new </span><strong class="source-inline"><span class="koboSpan" id="kobo.717.1">RightArrow</span></strong><span class="koboSpan" id="kobo.718.1"> class is to create an object instance and pass it to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.719.1">add()</span></strong><span class="koboSpan" id="kobo.720.1"> method </span><span class="No-Break"><span class="koboSpan" id="kobo.721.1">of shapes.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.722.1">OCP</span></p>
<p class="callout"><span class="koboSpan" id="kobo.723.1">Make code open for new behaviors, but closed </span><span class="No-Break"><span class="koboSpan" id="kobo.724.1">for modifications.</span></span></p>
<p><span class="koboSpan" id="kobo.725.1">The power of OCP should now be clear. </span><span class="koboSpan" id="kobo.725.2">We can extend the capabilities of our code and keep changes limited. </span><span class="koboSpan" id="kobo.725.3">We greatly reduce the risk of breaking code that is already working, as </span><a id="_idIndexMarker311"/><span class="koboSpan" id="kobo.726.1">we no longer need to </span><a id="_idIndexMarker312"/><span class="koboSpan" id="kobo.727.1">change that code. </span><span class="koboSpan" id="kobo.727.2">OCP is a great way to manage complexity. </span><span class="koboSpan" id="kobo.727.3">In the next section, we’ll look at the remaining SOLID </span><span class="No-Break"><span class="koboSpan" id="kobo.728.1">principle: ISP.</span></span></p>
<h1 id="_idParaDest-136"><a id="_idTextAnchor145"/><span class="koboSpan" id="kobo.729.1">ISP – effective interfaces</span></h1>
<p><span class="koboSpan" id="kobo.730.1">In this section, we </span><a id="_idIndexMarker313"/><span class="koboSpan" id="kobo.731.1">will look at a principle that helps us write effective interfaces. </span><span class="koboSpan" id="kobo.731.2">It is known </span><span class="No-Break"><span class="koboSpan" id="kobo.732.1">as ISP.</span></span></p>
<p><span class="koboSpan" id="kobo.733.1">ISP advises us to keep our interfaces small and dedicated to achieving a single responsibility. </span><span class="koboSpan" id="kobo.733.2">By small interfaces, we mean having as few methods as possible on any single interface. </span><span class="koboSpan" id="kobo.733.3">These methods should all relate to some </span><span class="No-Break"><span class="koboSpan" id="kobo.734.1">common theme.</span></span></p>
<p><span class="koboSpan" id="kobo.735.1">We can see that this principle is really just SRP in another form. </span><span class="koboSpan" id="kobo.735.2">We are saying that an effective interface should describe a single responsibility. </span><span class="koboSpan" id="kobo.735.3">It should cover one abstraction, not several. </span><span class="koboSpan" id="kobo.735.4">The methods on the interface should strongly relate to each other and also to that </span><span class="No-Break"><span class="koboSpan" id="kobo.736.1">single abstraction.</span></span></p>
<p><span class="koboSpan" id="kobo.737.1">If we need more abstractions, then we use more interfaces. </span><span class="koboSpan" id="kobo.737.2">We keep each abstraction in its own separate interface, which is where the term </span><em class="italic"><span class="koboSpan" id="kobo.738.1">interface segregation</span></em><span class="koboSpan" id="kobo.739.1"> comes from —we keep different </span><span class="No-Break"><span class="koboSpan" id="kobo.740.1">abstractions apart.</span></span></p>
<p><span class="koboSpan" id="kobo.741.1">The related </span><strong class="bold"><span class="koboSpan" id="kobo.742.1">code smell </span></strong><span class="koboSpan" id="kobo.743.1">to this is a large interface that covers several different topics in one. </span><span class="koboSpan" id="kobo.743.2">We could imagine an interface having hundreds of methods in little groups—some relating to file management, some about editing documents, and some about printing documents. </span><span class="koboSpan" id="kobo.743.3">Such interfaces quickly become difficult to work with. </span><span class="koboSpan" id="kobo.743.4">ISP suggests that we improve this by splitting the interface into several smaller ones. </span><span class="koboSpan" id="kobo.743.5">This split would preserve the groups of methods—so, you might see interfaces for file management, editing, and printing, with relevant methods under each. </span><span class="koboSpan" id="kobo.743.6">We have made our code simpler to </span><a id="_idIndexMarker314"/><span class="koboSpan" id="kobo.744.1">understand by splitting apart these </span><span class="No-Break"><span class="koboSpan" id="kobo.745.1">separate abstractions.</span></span></p>
<h2 id="_idParaDest-137"><a id="_idTextAnchor146"/><span class="koboSpan" id="kobo.746.1">Reviewing ISP usage in the shapes code</span></h2>
<p><span class="koboSpan" id="kobo.747.1">The most </span><a id="_idIndexMarker315"/><span class="koboSpan" id="kobo.748.1">noticeable </span><a id="_idIndexMarker316"/><span class="koboSpan" id="kobo.749.1">use of ISP is in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.750.1">Shape</span></strong><span class="koboSpan" id="kobo.751.1"> interface, as </span><span class="No-Break"><span class="koboSpan" id="kobo.752.1">illustrated here:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.753.1">
interface Shape {
  void draw(Graphics g);
}</span></pre>
<p><span class="koboSpan" id="kobo.754.1">This interface clearly has a single focus. </span><span class="koboSpan" id="kobo.754.2">It is an interface with a very narrow focus, so much so that only one method needs to be specified: </span><strong class="source-inline"><span class="koboSpan" id="kobo.755.1">draw()</span></strong><span class="koboSpan" id="kobo.756.1">. </span><span class="koboSpan" id="kobo.756.2">There is no confusion arising from other mixed-in concepts here and no unnecessary methods. </span><span class="koboSpan" id="kobo.756.3">That single method is both necessary and sufficient. </span><span class="koboSpan" id="kobo.756.4">The other major example is in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.757.1">Graphics</span></strong><span class="koboSpan" id="kobo.758.1"> interface, as </span><span class="No-Break"><span class="koboSpan" id="kobo.759.1">shown here:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.760.1">
public interface Graphics {
    void drawText(String text);
    void drawHorizontalLine(int width);
}</span></pre>
<p><span class="koboSpan" id="kobo.761.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.762.1">Graphics</span></strong><span class="koboSpan" id="kobo.763.1"> interface contains only methods related to drawing graphics primitives on screen. </span><span class="koboSpan" id="kobo.763.2">It has two methods—</span><strong class="source-inline"><span class="koboSpan" id="kobo.764.1">drawText</span></strong><span class="koboSpan" id="kobo.765.1"> to display a text string, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.766.1">drawHorizontalLine</span></strong><span class="koboSpan" id="kobo.767.1"> to draw a line in a horizontal direction. </span><span class="koboSpan" id="kobo.767.2">As these methods are strongly related—known technically as</span><a id="_idIndexMarker317"/><span class="koboSpan" id="kobo.768.1"> exhibiting </span><strong class="bold"><span class="koboSpan" id="kobo.769.1">high cohesion</span></strong><span class="koboSpan" id="kobo.770.1">—and few in number, ISP is satisfied. </span><span class="koboSpan" id="kobo.770.2">This is an effective abstraction over the graphics drawing subsystem, tailored to </span><span class="No-Break"><span class="koboSpan" id="kobo.771.1">our purposes.</span></span></p>
<p><span class="koboSpan" id="kobo.772.1">For completeness, we can implement this interface in a number of ways. </span><span class="koboSpan" id="kobo.772.2">The example in GitHub uses a </span><a id="_idIndexMarker318"/><span class="koboSpan" id="kobo.773.1">simple </span><a id="_idIndexMarker319"/><span class="koboSpan" id="kobo.774.1">text </span><span class="No-Break"><span class="koboSpan" id="kobo.775.1">console implementation:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.776.1">
public class ConsoleGraphics implements Graphics {
    @Override
    public void drawText(String text) {
        print(text);
    }
    @Override
    public void drawHorizontalLine(int width) {
        var rowText = new StringBuilder();
        for (int i = 0; i &lt; width; i++) {
            rowText.append('X');
        }
        print(rowText.toString());
    }
    private void print(String text) {
        System.out.println(text);
    }
}</span></pre>
<p><span class="koboSpan" id="kobo.777.1">That implementation is also LSP-compliant—it can be used wherever the </span><strong class="source-inline"><span class="koboSpan" id="kobo.778.1">Graphics</span></strong><span class="koboSpan" id="kobo.779.1"> interface </span><span class="No-Break"><span class="koboSpan" id="kobo.780.1">is expected.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.781.1">ISP</span></p>
<p class="callout"><span class="koboSpan" id="kobo.782.1">Keep interfaces small and strongly related to a </span><span class="No-Break"><span class="koboSpan" id="kobo.783.1">single idea.</span></span></p>
<p><span class="koboSpan" id="kobo.784.1">We’ve now covered all five of the SOLID principles and shown how they have been applied to the shapes code. </span><span class="koboSpan" id="kobo.784.2">They have guided the design toward compact code, having a well-engineered </span><a id="_idIndexMarker320"/><span class="koboSpan" id="kobo.785.1">structure</span><a id="_idIndexMarker321"/><span class="koboSpan" id="kobo.786.1"> to assist future maintainers. </span><span class="koboSpan" id="kobo.786.2">We know how to incorporate these principles into our own code to gain </span><span class="No-Break"><span class="koboSpan" id="kobo.787.1">similar benefits.</span></span></p>
<h1 id="_idParaDest-138"><a id="_idTextAnchor147"/><span class="koboSpan" id="kobo.788.1">Summary</span></h1>
<p><span class="koboSpan" id="kobo.789.1">In this chapter, we’ve looked at simple explanations of how the SOLID principles help us design both our production code and our tests. </span><span class="koboSpan" id="kobo.789.2">We’ve worked through an example design that uses all five SOLID principles. </span><span class="koboSpan" id="kobo.789.3">In future work, we can apply SRP to help us understand our design and limit the rework involved in future changes. </span><span class="koboSpan" id="kobo.789.4">We can apply DIP to split up our code into independent small pieces, leaving each piece to hide some of the details of our overall program, creating a divide-and-conquer effect. </span><span class="koboSpan" id="kobo.789.5">Using LSP, we can create objects that can be safely and easily swapped. </span><span class="koboSpan" id="kobo.789.6">OCP helps us design software that is simple to add functionality to. </span><span class="koboSpan" id="kobo.789.7">ISP will keep our interfaces small and easy </span><span class="No-Break"><span class="koboSpan" id="kobo.790.1">to understand.</span></span></p>
<p><span class="koboSpan" id="kobo.791.1">The next chapter puts these principles to use to solve a problem in testing—how do we test the collaborations between </span><span class="No-Break"><span class="koboSpan" id="kobo.792.1">our objects?</span></span></p>
<h1 id="_idParaDest-139"><a id="_idTextAnchor148"/><span class="koboSpan" id="kobo.793.1">Questions and answers </span></h1>
<ol>
<li><span class="koboSpan" id="kobo.794.1">Do the SOLID principles only apply to </span><span class="No-Break"><span class="koboSpan" id="kobo.795.1">OO code?</span></span></li>
</ol>
<p><span class="koboSpan" id="kobo.796.1">No. </span><span class="koboSpan" id="kobo.796.2">Although originally applied to an OO context, they have uses in both functional programming and microservice design. </span><span class="koboSpan" id="kobo.796.3">SRP is almost universally useful—sticking to one main focus is helpful for anything, even paragraphs of documentation. </span><span class="koboSpan" id="kobo.796.4">SRP thinking also helps us write a pure function that does only one thing and a test that does only one thing. </span><span class="koboSpan" id="kobo.796.5">DIP and OCP are easily done in functional contexts by passing in the dependency as a pure function, as we do with Java lambdas. </span><span class="koboSpan" id="kobo.796.6">SOLID as a whole gives a set of goals for managing coupling and cohesion among any kind of </span><span class="No-Break"><span class="koboSpan" id="kobo.797.1">software components.</span></span></p>
<ol>
<li value="2"><span class="koboSpan" id="kobo.798.1">Do we have to use SOLID principles </span><span class="No-Break"><span class="koboSpan" id="kobo.799.1">with TDD?</span></span></li>
</ol>
<p><span class="koboSpan" id="kobo.800.1">No. </span><span class="koboSpan" id="kobo.800.2">TDD works by defining the outcomes and public interface of a software component. </span><span class="koboSpan" id="kobo.800.3">How we implement that component is irrelevant to a TDD test, but using principles such as SRP and DIP makes it much easier to write tests against that code by giving us the test access points </span><span class="No-Break"><span class="koboSpan" id="kobo.801.1">we need.</span></span></p>
<ol>
<li value="3"><span class="koboSpan" id="kobo.802.1">Are SOLID principles the only ones we </span><span class="No-Break"><span class="koboSpan" id="kobo.803.1">should use?</span></span></li>
</ol>
<p><span class="koboSpan" id="kobo.804.1">No. </span><span class="koboSpan" id="kobo.804.2">We should use every technique at </span><span class="No-Break"><span class="koboSpan" id="kobo.805.1">our disposal.</span></span></p>
<p><span class="koboSpan" id="kobo.806.1">The SOLID principles make a great starting point in shaping your code and we should take advantage of them, but there are many other valid techniques to design software. </span><span class="koboSpan" id="kobo.806.2">The whole catalog of design patterns, the excellent system of </span><strong class="bold"><span class="koboSpan" id="kobo.807.1">General Responsibility Assignment Software Patterns</span></strong><span class="koboSpan" id="kobo.808.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.809.1">GRASP</span></strong><span class="koboSpan" id="kobo.810.1">) by Craig Larman, the idea of information hiding by David L. </span><span class="koboSpan" id="kobo.810.2">Parnas, and the ideas of coupling and cohesion all apply. </span><span class="koboSpan" id="kobo.810.3">We should use any and every technique we know—or can learn about—to serve our goal of making software that is easy to read and safe </span><span class="No-Break"><span class="koboSpan" id="kobo.811.1">to change.</span></span></p>
<ol>
<li value="4"><span class="koboSpan" id="kobo.812.1">If we do not use the SOLID principles, can we still </span><span class="No-Break"><span class="koboSpan" id="kobo.813.1">do TDD?</span></span></li>
</ol>
<p><span class="koboSpan" id="kobo.814.1">Yes—very much so. </span><span class="koboSpan" id="kobo.814.2">TDD concerns itself with testing the behavior of code, not the details of how it is implemented. </span><span class="koboSpan" id="kobo.814.3">SOLID principles simply help us create OO designs that are robust and simpler </span><span class="No-Break"><span class="koboSpan" id="kobo.815.1">to test.</span></span></p>
<ol>
<li value="5"><span class="koboSpan" id="kobo.816.1">How does SRP relate </span><span class="No-Break"><span class="koboSpan" id="kobo.817.1">to ISP?</span></span></li>
</ol>
<p><span class="koboSpan" id="kobo.818.1">ISP guides us to prefer many shorter interfaces over one large interface. </span><span class="koboSpan" id="kobo.818.2">Each of the shorter interfaces should relate to one single aspect of what a class should provide. </span><span class="koboSpan" id="kobo.818.3">This is usually some kind of role, or perhaps a subsystem. </span><span class="koboSpan" id="kobo.818.4">ISP can be thought of as making sure our interfaces each apply the SRP and do only </span><span class="No-Break"><span class="koboSpan" id="kobo.819.1">one thing—well.</span></span></p>
<ol>
<li value="6"><span class="koboSpan" id="kobo.820.1">How does OCP relate to DIP </span><span class="No-Break"><span class="koboSpan" id="kobo.821.1">and LSP?</span></span></li>
</ol>
<p><span class="koboSpan" id="kobo.822.1">OCP guides us to create software components that can have new capabilities added without changing the component itself. </span><span class="koboSpan" id="kobo.822.2">This is done by using a plugin design. </span><span class="koboSpan" id="kobo.822.3">The component will allow separate classes to be plugged in providing the new capabilities. </span><span class="koboSpan" id="kobo.822.4">The way to do this is to create an abstraction of what a plugin should do in an interface—DIP. </span><span class="koboSpan" id="kobo.822.5">Then, create concrete plugin implementations of this conforming to LSP. </span><span class="koboSpan" id="kobo.822.6">After that, we can inject these new plugins into our component. </span><span class="koboSpan" id="kobo.822.7">OCP relies on DIP and LSP </span><span class="No-Break"><span class="koboSpan" id="kobo.823.1">to work.</span></span></p>
</div>
<div>
<div class="IMG---Figure" id="_idContainer052">
</div>
</div>
</body></html>