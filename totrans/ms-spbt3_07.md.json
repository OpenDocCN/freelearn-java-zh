["```java\n    @RestController\n    public class HelloController {\n        @GetMapping(\"/\")\n        public String hello() {\n            return \"Hello, Spring Boot 3!\";\n        }\n    }\n    ```", "```java` ` ```", "```java\n> jar xf build/libs/demo-0.0.1-SNAPSHOT.jar BOOT-INF/layers.idx\n> cat BOOT-INF/layers.idx\n- \"dependencies\":\n  - \"BOOT-INF/lib/\"\n- \"spring-boot-loader\":\n  - \"org/\"\n- \"snapshot-dependencies\":\n- \"application\":\n  - \"BOOT-INF/classes/\"\n  - \"BOOT-INF/classpath.idx\"\n  - \"BOOT-INF/layers.idx\"\n  - \"META-INF/\"\n```", "```java\n8080. So, we can easily test the response, which should be curl http://localhost:8080.\nWith Docker images sorted, let’s turn our attention to ensuring our applications exit gracefully in a Docker environment. In the following section, we’ll dive into why a graceful shutdown is important and how Spring Boot’s enhanced support for this can safeguard your data and user experience during the inevitable shuffling of Docker containers in production environments.\nEnhancing graceful shutdown capabilities\nWhen it’s time for your program to finish running, you’ll want it to exit smoothly, like how it started. This is what we call a shutdown – making sure that your containerized apps can properly handle termination signals, complete tasks, and not abruptly stop active processes. In Docker setups, where apps are frequently stopped and moved around due to scaling or updates, graceful shutdown isn’t a nicety; it’s crucial for preserving data integrity and providing a user experience.\nSpring Boot 3.0 improves this process by ensuring that your apps can effectively respond to **Signal Terminate** (**SIGTERM**) signals. The method is for instructing a process to stop. Let’s walk through how you can set up and verify that your Spring Boot app gracefully handles shutdowns:\n\n1.  Configure graceful shutdown by adding the following in `'application.properties'`:\n\n    ```", "```java\n\n    `20s` represents the duration that the application waits before it shuts down.\n\n     2.  Let’s rebuild the image and run it in Docker:\n\n    ```", "```java\n\n     3.  After starting your app, send a SIGTERM signal to your Docker container and observe the graceful shutdown.\n\n    ```", "```java\n\n     4.  When you check out the logs of your Docker container, you will see these logs:\n\n    ```", "```java\n\nAs we conclude our exploration of Spring Boot’s containerization capabilities, let’s recap the points and explore how they can be implemented in your projects. You’ll find that whether you want to enhance build efficiency using jars streamline image creation with Buildpacks or ensure smooth shutdowns, Spring Boot 3.0 provides the tools to strengthen your containerized applications for cloud deployment.\nNow that we’ve discussed the way to end services gracefully, let’s delve into how Spring Boot 3.0 helps in managing application configurations within Docker and why it is important for containerized applications. We will also discover how Spring Boot applications thrive within the Kubernetes ecosystem.\nOptimizing Spring Boot apps for Kubernetes\nPicture a harbor where ships come and go non-stop. This harbor relies on a system to manage the traffic smoothly to ensure each ship is in the place at the right time. In the realm of containerized applications, Kubernetes plays the role of this master harbor system. While Docker handles packaging applications into containers, Kubernetes orchestrates which containers should run, scales them as needed, manages traffic flow, and ensures their well-being.\nKubernetes isn’t meant to replace Docker; rather, it complements Docker effectively. Docker excels at containerization and transforming applications into efficient units. On the other hand, Kubernetes takes these units and seamlessly integrates them within the intricate landscape of modern cloud architecture.\nBy leveraging Kubernetes functionalities, developers can now oversee Spring Boot applications with an unprecedented level of efficiency and reliability. From deployments with no downtime to automated scaling capabilities, Kubernetes empowers your containerized applications to perform optimally under workloads and scenarios.\nLet’s dive in by exploring how Spring Boot’s integrated Kubernetes probes collaborate with Kubernetes health check mechanisms to enhance your application’s resilience and uptime.\nIntegrating Kubernetes probes for application health\nIn the dynamic realm of Kubernetes, it’s crucial to make sure your application is in shape and prepared to handle requests. This is where readiness and liveness checks come in, serving as the protectors of your application’s health. Liveness checks inform Kubernetes about the status of your application – whether it is functioning or unresponsive, while readiness checks indicate when your app is set to receive traffic. These checks ensure that operational and ready-to-go instances of your application receive traffic and play a vital role in enhancing the robustness of your deployments.\nUnderstanding probes\nProbes are diagnostic tools used in Kubernetes. Kubernetes uses them to check the status of the component periodically.\nLet’s see what are these probes:\n\n*   **Liveness probe**: This probe checks whether your application is alive. If it fails, Kubernetes restarts the container automatically, offering a self-healing mechanism.\n*   **Readiness probe**: This determines whether your application is ready to receive requests. A failing readiness probe means Kubernetes stops sending traffic to that pod until it’s ready again.\n\nNow, we will be activating probes in Spring Boot 3.0, which simplifies the integration of these probes, thanks to its Actuator endpoints:\n\n1.  **Include Spring Boot Actuator**: Ensure the Spring Boot Actuator dependency is included in your project. It provides the necessary endpoints for Kubernetes probes:\n\n    ```", "```java\n\n     2.  `application.properties`, you can specify the criteria for these probes:\n\n    ```", "```java\n\nThat’s all our application needs to be ready for Kubernetes. Let’s create our first Kubernetes YAML file.\nCreating Kubernetes YAML file\nOur YAML file includes two main sections. Each section defines a Kubernetes object. The following section is Deployment resource:\n\n```", "```java\n\n Let’s break down what we have introduced in this Deployment resource:\n\n*   `metadata.name: spring-boot-demo-app`: This is the unique name of the deployment within the Kubernetes cluster. It’s specific to the application being deployed, in this case, `spring-boot-demo-app`.\n*   `spec:template:metadata:labels:app: spring-boot-demo-app`: This label is crucial for defining which pods belong to this Deployment resource. It must match the selector defined in the Deployment resource and is used by `Service` to route traffic to the pods.\n*   `spec:containers:name: spring-boot-demo-app`: The name of the container running in the pod. It’s more for identification and logging purposes.\n*   `spec:containers:image: demoapp:latest`: This specifies the Docker image to use for the container, which is pivotal as it determines the version of the application to run. The `latest` tag here can be replaced with a specific version tag to ensure consistent environments through deployments.\n*   `spec:containers:ports:containerPort: 8080`: This port number is essential because it must match the application’s configured port. For Spring Boot applications, the default is `8080`, but if your application uses a different port, it needs to be reflected here.\n*   `livenessProbe:` and `readinessProbe:` are configured to check the application’s health and readiness at the `/actuator/health/liveness` and `/actuator/health/readiness` endpoints, respectively. These paths are Spring Boot Actuator endpoints, which are specific to Spring Boot applications. Adjusting the probe configurations (such as `initialDelaySeconds` and `periodSeconds`) may be necessary based on the startup time and behavior of your application.\n\nNow, we will add the load balancer part to our YAML file:\n\n```", "```java\n\n In this part, we have defined the following parameters:\n\n*   `metadata:name: spring-boot-demo-app-service`: This is the name of the `Service` object, which is how you would refer to this service within the Kubernetes cluster. It should be descriptive of the service it provides.\n*   `spec:type: LoadBalancer`: This type makes `Service` accessible through an external IP provided by the cloud hosting the Kubernetes cluster. This detail is crucial for applications that need to be accessible from outside the Kubernetes cluster.\n*   `spec:ports:port: 8080`: This is the port on which `Service` will listen, which must match `containerPort` if you want external traffic to reach your application. It’s specifically tailored to the application’s configuration.\n*   `spec:selector:app: spring-boot-demo-app`: This selector must match the labels of the pods you want `Service` to route traffic to. It’s crucial for connecting `Service` to the appropriate pods.\n\nThis file sets up a basic deployment of a Spring Boot application on Kubernetes, with a single replica, and exposes it externally via a `LoadBalancer` service. It includes health checks to ensure traffic is only sent to healthy instances.\nLet’s now run our first Kubernetes cluster in our local.\nRunning Kubernetes cluster\nIn this book, for everything related to Docker, we have used Docker Desktop. So, we need to enable Kubernetes in our Docker Desktop app first. Please open **Preferences** in Docker Desktop, navigate to **Kubernetes**, check the enable box, and then finally click on the **Save and Restart** button. That’s it! We have Kubernetes in our local machines.\nIn order to run our YAML file, we need to open a terminal and navigate to the folder where we saved our YAML file. Then, we run the following command:\n\n```", "```java\nCurl http://localhost:8080/\n```", "```java\nHello, Spring Boot 3!\n```", "```java\n@RestController\npublic class MessageController {\n    @Value(\"${app.message:Hello from Spring Boot!}\")\n    private String message;\n    @Value(\"${api.key:not very secure}\")\n    private String apiKey;\n    @GetMapping(\"/message\")\n    public String getMessage() {\n        return message;\n    }\n    @GetMapping(\"/apikey\")\n    public String getApiKey() {\n        return apiKey;\n    }\n}\n```", "```java\napiVersion: v1\nkind: ConfigMap\nmetadata:\n  name: app-config\ndata:\n  app.message: 'Hello from ConfigMap!'\n```", "```java\nkubectl create secret generic app-secret --from-literal=api.key=mysecretapikey\n```", "```java\ncontainers:\n  - name: spring-boot-demo-app\n    image: demoapp:latest\n    imagePullPolicy: IfNotPresent\n    ports:\n      - containerPort: 8080\n    env:\n      - name: APP_MESSAGE\n        valueFrom:\n          configMapKeyRef:\n            name: app-config\n            key: app.message\n      - name: API_KEY\n        valueFrom:\n          secretKeyRef:\n            name: app-secret\n            key: api.key\n```", "```java\n./gradlew bootBuildImage --imageName=demoapp\nkubectl rollout restart deployment/spring-boot-demo-app\n```", "```java\n        app.message=Hello from the Test Environment!\n        ```", "```java\n        app.message=Hello from the Production Environment!\n        ```", "```java\n       apiVersion: apps/v1\n       kind: Deployment\n       metadata:\n         name: your-application\n       spec:\n         containers:\n         - name: your-application\n           image: your-application-image\n           env:\n             - name: SPRING_PROFILES_ACTIVE\n               value: \"prod\" # Change this to \"test\" for test environment\n    ```", "```java\n    ./gradlew bootBuildImage --imageName=demoapp\n    kubectl rollout restart deployment/spring-boot-demo-app\n    ```", "```java\n    implementation 'io.micrometer:micrometer-registry-prometheus'\n    ```", "```java\n    management.endpoints.web.exposure.include=health,info,prometheus\n    ```", "```java\n       apiVersion: v1\n       kind: ConfigMap\n       metadata:\n         name: prometheus-config\n       data:\n         prometheus.yml: |\n           global:\n             scrape_interval: 15s\n           scrape_configs:\n             - job_name: 'spring-boot'\n               metrics_path: '/actuator/prometheus'\n               static_configs:\n                 - targets: ['spring-boot-demo-app-service:8080']\n    ```", "```java\n       apiVersion: apps/v1\n       kind: Deployment\n       metadata:\n         name: prometheus-deployment\n       spec:\n         replicas: 1\n         selector:\n           matchLabels:\n             app: prometheus-server\n         template:\n           metadata:\n             labels:\n               app: prometheus-server\n           spec:\n             containers:\n               - name: prometheus-server\n                 image: prom/prometheus:v2.20.1\n                 ports:\n                   - containerPort: 9090\n                 volumeMounts:\n                   - name: prometheus-config-volume\n                     mountPath: /etc/prometheus/prometheus.yml\n                     subPath: prometheus.yml\n             volumes:\n               - name: prometheus-config-volume\n                 configMap:\n                   name: prometheus-config\n    ```", "```java\n       apiVersion: v1\n       kind: Service\n       metadata:\n         name: prometheus-service\n       spec:\n         type: LoadBalancer\n         ports:\n           - port: 9090\n             targetPort: 9090\n             protocol: TCP\n         selector:\n           app: prometheus-server\n    ```", "```java\n    kubectl apply -f prometheus-config.yaml\n    kubectl apply -f prometheus-deployment.yaml\n    ```", "```java\n       apiVersion: apps/v1\n       kind: Deployment\n       metadata:\n         name: grafana-deployment\n       spec:\n         replicas: 1\n         selector:\n           matchLabels:\n             app: grafana\n         template:\n           metadata:\n             labels:\n               app: grafana\n           spec:\n             containers:\n               - name: grafana\n                 image: grafana/grafana:7.2.0\n                 ports:\n                   - containerPort: 3000\n       ---\n       apiVersion: v1\n       kind: Service\n       metadata:\n         name: grafana-service\n       spec:\n         type: LoadBalancer\n         ports:\n           - port: 3000\n             targetPort: 3000\n             protocol: TCP\n         selector:\n           app: grafana\n    ```", "```java\n    admin/admin).\n    ```", "```java\n\n```"]