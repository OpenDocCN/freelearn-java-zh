<html><head></head><body>
<div id="sbo-rt-content" class="calibre1"><div id="_idContainer031" class="calibre2">
<h1 class="chapter-number" id="_idParaDest-39" lang="en-GB"><a id="_idTextAnchor038" class="pcalibre pcalibre2 pcalibre1 calibre6"/>2</h1>
<h1 id="_idParaDest-40" lang="en-GB" class="calibre5"><a id="_idTextAnchor039" class="pcalibre pcalibre2 pcalibre1 calibre6"/>Primitives and Objects in Java Memory</h1>
<p lang="en-GB" class="calibre4">In <a href="B18762_01.xhtml#_idTextAnchor014" class="pcalibre pcalibre2 pcalibre1 calibre6"><span lang=""><em class="italic" lang="">Chapter 1</em></span></a>, we saw the differences between primitives, objects, and references. We learned that primitives are types that come with the Java language; in other words, we do not have to define primitive types, we just use them. For example, <strong class="source-inline" lang="">int x;</strong> defines (creates) a primitive variable, <strong class="source-inline" lang="">x</strong>, which is of (the primitive) type <strong class="source-inline" lang="">int</strong>. This means that <strong class="source-inline" lang="">x</strong> can store whole integer numbers only, for example, -5, 0, 12, and <span lang="">so on.</span></p>
<p lang="en-GB" class="calibre4">We also learned that objects are instantiations of a <strong class="bold" lang="">class</strong> and that we use the <strong class="source-inline" lang="">new</strong> keyword to create instances of objects. For example, assuming a <strong class="source-inline" lang="">Person</strong> class exists, <strong class="source-inline" lang="">new Person();</strong> instantiates (creates) an object of type <strong class="source-inline" lang="">Person</strong>. This object will be stored on <span lang="">the heap.</span></p>
<p lang="en-GB" class="calibre4">We saw that references enable us to manipulate objects and that references are of four different types: <strong class="source-inline" lang="">class</strong>, <strong class="source-inline" lang="">array</strong>, <strong class="source-inline" lang="">interface</strong>, and <strong class="source-inline" lang="">null</strong>. When you create an object, the reference to the object is what you receive back. For example, in the code <strong class="source-inline" lang="">Person p = new Person();</strong>, the reference is <strong class="source-inline" lang="">p</strong> and it is of type <strong class="source-inline" lang="">Person</strong>. Whether the reference is placed on the stack or on the heap depends on the context – more on <span lang="">this later.</span></p>
<p lang="en-GB" class="calibre4">Understanding the differences between references and objects is very important and greatly simplifies core <strong class="bold" lang="">object-oriented programming</strong> (<strong class="bold" lang="">OOP</strong>) concepts, such as <strong class="bold" lang="">inheritance</strong> and <strong class="bold" lang="">polymorphism</strong>. This also helps in fixing <strong class="source-inline" lang="">ClassCastException</strong> errors. Being aware of Java’s call-by-value mechanism and, in particular, how it relates to references can prevent subtle encapsulation issues known as <span lang=""><em class="italic" lang="">escaping references</em></span><span lang="">.</span></p>
<p lang="en-GB" class="calibre4">In this chapter, we will delve more deeply into the <span lang="">following topics:</span></p>
<ul class="calibre10">
<li lang="en-GB" class="calibre11">Understanding primitives on the stack <span lang="">and heap</span></li>
<li lang="en-GB" class="calibre11">Storing objects on <span lang="">the heap</span></li>
<li lang="en-GB" class="calibre11">Managing object references <span lang="">and security</span></li>
</ul>
<h1 id="_idParaDest-41" lang="en-GB" class="calibre5"><a id="_idTextAnchor040" class="pcalibre pcalibre2 pcalibre1 calibre6"/>Technical requirements</h1>
<p lang="en-GB" class="calibre4">The code for this chapter can be found on GitHub <span lang="">at </span><a href="https://github.com/PacktPublishing/B18762_Java-Memory-Management" class="pcalibre pcalibre2 pcalibre1 calibre6"><span lang="">https://github.com/PacktPublishing/B18762_Java-Memory-Management</span></a><span lang="">.</span></p>
<h1 id="_idParaDest-42" lang="en-GB" class="calibre5"><a id="_idTextAnchor041" class="pcalibre pcalibre2 pcalibre1 calibre6"/>Understanding primitives on the stack and heap</h1>
<p lang="en-GB" class="calibre4">Java comes <a id="_idIndexMarker089" class="pcalibre pcalibre2 pcalibre1 calibre6"/>with a predefined set of primitive data types. Primitive data types <a id="_idIndexMarker090" class="pcalibre pcalibre2 pcalibre1 calibre6"/>are always in lowercase, for example, <strong class="source-inline" lang="">double</strong>. Contrast primitives with their associated wrapper counterparts, which are classes in the API, have methods (primitives do not), and wrappers start with a capital letter, for <span lang="">example, </span><span lang=""><strong class="source-inline" lang="">Double</strong></span><span lang="">.</span></p>
<p lang="en-GB" class="calibre4">The primitive data types can be broken down into integral types (whole numbers), namely <strong class="source-inline" lang="">byte</strong>, <strong class="source-inline" lang="">short</strong>, <strong class="source-inline" lang="">int</strong>, <strong class="source-inline" lang="">long</strong>, and <strong class="source-inline" lang="">char</strong>, and floating-point types (decimal numbers), namely <strong class="source-inline" lang="">float</strong>, <strong class="source-inline" lang="">double</strong>, and <strong class="source-inline" lang="">boolean</strong> (<strong class="source-inline" lang="">true</strong> <span lang="">or </span><span lang=""><strong class="source-inline" lang="">false</strong></span><span lang="">).</span></p>
<p lang="en-GB" class="calibre4">Primitives can be stored on both the stack and the heap. They are stored on the stack when they are local variables to methods, in other words, parameters to the method or variables declared inside the method itself. Primitives are stored on the heap when they are members of a class, that is, instance variables. Instance variables are declared within the class scope, in other words, outside all of the methods. Therefore, primitive variables declared within a method go on the stack, whereas instance variables go on the heap (inside <span lang="">the object).</span></p>
<p lang="en-GB" class="calibre4">Now that we understand where primitives are stored, let us turn our attention to <span lang="">storing objects.</span></p>
<h1 id="_idParaDest-43" lang="en-GB" class="calibre5"><a id="_idTextAnchor042" class="pcalibre pcalibre2 pcalibre1 calibre6"/>Storing objects on the heap</h1>
<p lang="en-GB" class="calibre4">In this section, we <a id="_idIndexMarker091" class="pcalibre pcalibre2 pcalibre1 calibre6"/>are going to examine storing objects on the heap. Gaining a full understanding of this area requires a discussion comparing references and objects. We will examine their types, where they are stored, and crucially, their differences. A sample piece of code with an associated diagram will finish <span lang="">the section.</span></p>
<h2 id="_idParaDest-44" lang="en-GB" class="calibre7"><a id="_idTextAnchor043" class="pcalibre pcalibre2 pcalibre1 calibre6"/>References</h2>
<p lang="en-GB" class="calibre4">References <a id="_idIndexMarker092" class="pcalibre pcalibre2 pcalibre1 calibre6"/>refer to objects and enable us to access them. If we are accessing an object instance member, then we use the reference. If we are accessing a static (class) member, we use the <span lang="">class name.</span></p>
<p lang="en-GB" class="calibre4">References can be stored on both the stack and the heap. If the reference is a local variable in a method, then the reference is stored on the stack (in the local method array for that method frame). If the reference is an instance variable, then the reference is stored inside the object, on <span lang="">the heap.</span></p>
<p lang="en-GB" class="calibre4">By way of comparison with objects, we can have a reference of an <strong class="bold" lang="">abstract class</strong> but not an object of an abstract class. The same applies to interfaces – we can have an <strong class="bold" lang="">interface</strong> reference type, but you cannot instantiate an interface; that is, you cannot create an object of an interface type. Both situations are demonstrated in <span lang=""><em class="italic" lang="">Figure 2</em></span><span lang=""><em class="italic" lang="">.1</em></span><span lang="">:</span></p>
<p class="calibre4" lang="en-GB"> </p>
<div class="calibre2">
<div class="img---figure" id="_idContainer017">
<img alt="Figure 2.1 – Object instantiation errors" src="image/Figure_2.1_B18762.jpg" class="calibre27"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 2.1 – Object instantiation errors</p>
<p lang="en-GB" class="calibre4">In <span lang=""><em class="italic" lang="">Figure 2</em></span><em class="italic" lang="">.1</em>, the references declared on lines <strong class="source-inline" lang="">10</strong> and <strong class="source-inline" lang="">13</strong>, an abstract class and an interface reference, respectively, have no issue. However, attempting to create an object of these types on lines <strong class="source-inline" lang="">11</strong> and <strong class="source-inline" lang="">14</strong> causes errors. Feel free to try out this code, contained in <strong class="source-inline" lang="">ch2</strong> folder here: <a href="https://github.com/PacktPublishing/B18762_Java-Memory-Management/tree/main/ch2" class="pcalibre pcalibre2 pcalibre1 calibre6">https://github.com/PacktPublishing/B18762_Java-Memory-Management/tree/main/ch2</a>. The reason for the compiler errors is that you cannot create an object based on an abstract class or interface. We will address these errors in the <span lang="">next section.</span></p>
<p lang="en-GB" class="calibre4">Now that we have discussed references, let us <span lang="">examine objects.</span></p>
<h2 id="_idParaDest-45" lang="en-GB" class="calibre7"><a id="_idTextAnchor044" class="pcalibre pcalibre2 pcalibre1 calibre6"/>Objects</h2>
<p lang="en-GB" class="calibre4">All objects<a id="_idIndexMarker093" class="pcalibre pcalibre2 pcalibre1 calibre6"/> are stored on the heap. To understand objects, we must first understand a fundamental construct in OOP, the class. A class is similar to the plan of a house. With the plan of the house, you can view it and discuss it, but you cannot open any doors, put the kettle on, and so on. This is what classes are in OOP – they are views of what the object will look like in memory. When the house is built, you can now open the doors, have a cup of tea, and so forth. When the object is built, you have an in-memory representation of the class. Using the reference, we can access the instance members using the dot <span lang="">notation syntax.</span></p>
<p lang="en-GB" class="calibre4">Let us address the compiler issues from <span lang=""><em class="italic" lang="">Figure 2</em></span><em class="italic" lang="">.1</em> and, in addition, show the dot notation syntax <span lang="">in operation:</span></p>
<div class="calibre2">
<div class="img---figure" id="_idContainer018">
<img alt="Figure 2.2 – The interface and abstract class references fixed" src="image/Figure_2.2_B18762.jpg" class="calibre28"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 2.2 – The interface and abstract class references fixed</p>
<p lang="en-GB" class="calibre4">In <span lang=""><em class="italic" lang="">Figure 2</em></span><em class="italic" lang="">.2</em>, as lines 11 and 15 compile without any error, they demonstrate that the class must be a non-abstract (concrete) class before an object based on it can be instantiated (created). Lines 12 and 16 demonstrate the dot <span lang="">notation syntax.</span></p>
<p lang="en-GB" class="calibre4">Let us now examine in more detail the creation of <span lang="">an object.</span></p>
<h3 lang="en-GB" class="calibre8">How to create objects</h3>
<p lang="en-GB" class="calibre4">Objects are<a id="_idIndexMarker094" class="pcalibre pcalibre2 pcalibre1 calibre6"/> instantiated (created) using the <strong class="source-inline" lang="">new</strong> keyword. The purpose of <strong class="source-inline" lang="">new</strong> is to create an object on the heap and return its address, which we store in a reference variable. Line 11 from <span lang=""><em class="italic" lang="">Figure 2</em></span><em class="italic" lang="">.2</em> has the following line <span lang="">of code:</span></p>
<p lang="en-GB" class="calibre4"><strong class="source-inline" lang="">h = </strong><span lang=""><strong class="source-inline" lang="">new Person();</strong></span></p>
<p lang="en-GB" class="calibre4">The reference is on the left-hand side of the assignment operator – we are initializing an <strong class="source-inline" lang="">h</strong> reference of <span lang="">type </span><span lang=""><strong class="source-inline" lang="">Human</strong></span><span lang="">.</span></p>
<p lang="en-GB" class="calibre4">The object to be instantiated is on the right-hand side of the assignment operator – we are creating an object of type <strong class="source-inline" lang="">Person</strong>, and the default <strong class="source-inline" lang="">Person</strong> constructor is executed. This default constructor is synthesized by the compiler (as there is no explicit <strong class="source-inline" lang="">Person</strong> constructor present in <span lang="">the code).</span></p>
<p lang="en-GB" class="calibre4">Now that we have looked at both objects and references, let us expand the example and, using a diagram, view both the stack and <span lang="">heap representations.</span></p>
<h2 id="_idParaDest-46" lang="en-GB" class="calibre7"><a id="_idTextAnchor045" class="pcalibre pcalibre2 pcalibre1 calibre6"/>Understanding the differences between references and objects</h2>
<p lang="en-GB" class="calibre4">In order to<a id="_idIndexMarker095" class="pcalibre pcalibre2 pcalibre1 calibre6"/> contrast the stack and the heap, both the <strong class="source-inline" lang="">Person</strong> class <a id="_idIndexMarker096" class="pcalibre pcalibre2 pcalibre1 calibre6"/>and the <strong class="source-inline" lang="">main()</strong> method have <span lang="">been changed:</span></p>
<p class="calibre4" lang="en-GB"> </p>
<div class="calibre2">
<div class="img---figure" id="_idContainer019">
<img alt="Figure 2.3 – Stack and heap code" src="image/Figure_2.3_B18762.jpg" class="calibre29"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 2.3 – Stack and heap code</p>
<p lang="en-GB" class="calibre4"><span lang=""><em class="italic" lang="">Figure 2</em></span><em class="italic" lang="">.3</em> details a <strong class="source-inline" lang="">Person</strong> class<a id="_idIndexMarker097" class="pcalibre pcalibre2 pcalibre1 calibre6"/> containing two instance variables, a constructor taking two<a id="_idIndexMarker098" class="pcalibre pcalibre2 pcalibre1 calibre6"/> parameters, and the <strong class="source-inline" lang="">toString()</strong> instance method. The second class, <strong class="source-inline" lang="">StackAndHeap</strong>, is the driver class (it contains the <strong class="source-inline" lang="">main()</strong> method). In <strong class="source-inline" lang="">main()</strong>, we initialize a local primitive variable, <strong class="source-inline" lang="">x</strong>, and instantiate an instance <span lang="">of </span><span lang=""><strong class="source-inline" lang="">Person</strong></span><span lang="">.</span></p>
<p lang="en-GB" class="calibre4"><span lang=""><em class="italic" lang="">Figure 2</em></span><em class="italic" lang="">.4</em> shows the stack and heap representations after line 27 has <span lang="">been executed:</span></p>
<div class="calibre2">
<div class="img---figure" id="_idContainer020">
<img alt="Figure 2.4 – A stack and heap representation of the code in Figure 2.3" src="image/Figure_2.4_B18762.jpg" class="calibre30"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 2.4 – A stack and heap representation of the code in Figure 2.3</p>
<p lang="en-GB" class="calibre4">Referring<a id="_idIndexMarker099" class="pcalibre pcalibre2 pcalibre1 calibre6"/> to <span lang=""><em class="italic" lang="">Figure 2</em></span><em class="italic" lang="">.3</em>, the first method to execute is <strong class="source-inline" lang="">main()</strong> on line 23. This results in a frame for <strong class="source-inline" lang="">main()</strong> being pushed onto the stack. The local <a id="_idIndexMarker100" class="pcalibre pcalibre2 pcalibre1 calibre6"/>variables <strong class="source-inline" lang="">args</strong> and <strong class="source-inline" lang="">x</strong> are stored in the local variable array in this frame. On line 25, we create an instance of <strong class="source-inline" lang="">Person</strong> passing in the <strong class="source-inline" lang="">String</strong> literal, <strong class="source-inline" lang="">Joe Bloggs</strong>, and the integer literal, <strong class="source-inline" lang="">23</strong>. Any <strong class="source-inline" lang="">String</strong> literal is itself a <strong class="source-inline" lang="">String</strong> object and is stored on the heap. In addition, as it is a <strong class="source-inline" lang="">String</strong> literal, this <strong class="source-inline" lang="">String</strong> object is stored in a special area of the heap<a id="_idIndexMarker101" class="pcalibre pcalibre2 pcalibre1 calibre6"/> called the <strong class="bold" lang="">String Pool</strong> (also known as the String <span lang="">Constant Pool).</span></p>
<p lang="en-GB" class="calibre4">The instance variable <strong class="source-inline" lang="">name</strong> inside the <strong class="source-inline" lang="">Person</strong> object resides on the heap and is a <strong class="source-inline" lang="">String</strong> type; that is, it is a reference variable, and it refers to the <strong class="bold" lang="">Joe Bloggs</strong> object in the String pool. The other instance variable in <strong class="source-inline" lang="">Person</strong>, namely <strong class="source-inline" lang="">age</strong>, is a primitive, and its value of <strong class="source-inline" lang="">23</strong> is stored directly inside the object on the heap. However, the reference to the <strong class="source-inline" lang="">Person</strong> object, <strong class="source-inline" lang="">joeBloggs</strong>, is stored on the stack, in the frame for the <span lang=""><strong class="source-inline" lang="">main()</strong></span><span lang=""> method.</span></p>
<p lang="en-GB" class="calibre4">On line 26 in <span lang=""><em class="italic" lang="">Figure 2</em></span><em class="italic" lang="">.3</em>, we output the local variable, <strong class="source-inline" lang="">x</strong>, which outputs <strong class="source-inline" lang="">0</strong> to the standard output device (typically the screen). Line 27 is then executed, as shown in <span lang=""><em class="italic" lang="">Figure 2</em></span><em class="italic" lang="">.4</em>. First, the <strong class="source-inline" lang="">println()</strong> method from <strong class="source-inline" lang="">PrintStream</strong> (<strong class="source-inline" lang="">out</strong> is of type <strong class="source-inline" lang="">PrintStream</strong>) causes a frame to be pushed onto the stack. In order to simplify the diagram, we have not gone into any detail in that stack frame. Before <strong class="source-inline" lang="">println()</strong> can complete execution, <strong class="source-inline" lang="">joeBloggs.toString()</strong> must first <span lang="">be executed.</span></p>
<p lang="en-GB" class="calibre4">As the <strong class="source-inline" lang="">toString()</strong> method in <strong class="source-inline" lang="">Person</strong> has now been invoked/called, a new frame for <strong class="source-inline" lang="">toString()</strong> is pushed onto the stack on top of the <strong class="source-inline" lang="">println()</strong> frame. Next, <strong class="source-inline" lang="">toString()</strong> builds up a local <strong class="source-inline" lang="">String</strong> variable named <strong class="source-inline" lang="">decoratedName</strong> using <strong class="source-inline" lang="">String</strong> literals and the <span lang="">instance variables.</span></p>
<p lang="en-GB" class="calibre4">As you <a id="_idIndexMarker102" class="pcalibre pcalibre2 pcalibre1 calibre6"/>are<a id="_idIndexMarker103" class="pcalibre pcalibre2 pcalibre1 calibre6"/> probably aware, if you have a <strong class="source-inline" lang="">String</strong> instance on the left or the right of a <strong class="source-inline" lang="">+</strong> operator, the overall operation becomes a <strong class="source-inline" lang="">String</strong> append and you end up with a <span lang=""><strong class="source-inline" lang="">String</strong></span><span lang=""> result.</span></p>
<p lang="en-GB" class="calibre4">These <strong class="source-inline" lang="">String</strong> literals are stored in the String Pool. The final <strong class="source-inline" lang="">String</strong> result is <em class="italic" lang="">My name is Joe Bloggs and I am 23 years old</em>, which is assigned to the local variable, <strong class="source-inline" lang="">decoratedName</strong>. This String is returned from <strong class="source-inline" lang="">toString()</strong> back to the <strong class="source-inline" lang="">println()</strong> statement on line <strong class="source-inline" lang="">27</strong> that called it. The returned <strong class="source-inline" lang="">String</strong> is then echoed to <span lang="">the screen.</span></p>
<p lang="en-GB" class="calibre4">That concludes our section on storing objects on the heap. Now we will turn our attention to areas that can cause subtle issues in your code. However, now that we have separated the reference from the object, these issues will be much easier to understand <span lang="">and fix.</span></p>
<h1 id="_idParaDest-47" lang="en-GB" class="calibre5"><a id="_idTextAnchor046" class="pcalibre pcalibre2 pcalibre1 calibre6"/>Managing object references and security</h1>
<p lang="en-GB" class="calibre4">In this section, we are <a id="_idIndexMarker104" class="pcalibre pcalibre2 pcalibre1 calibre6"/>going to examine object references and a subtle security issue that can arise if references are not managed with due care. This security <a id="_idIndexMarker105" class="pcalibre pcalibre2 pcalibre1 calibre6"/>issue is called <em class="italic" lang="">escaping references</em> and we will explain when and how it occurs with the aid of an example. In addition, we will fix the issue in the example, demonstrating how to address this <span lang="">security concern.</span></p>
<h2 id="_idParaDest-48" lang="en-GB" class="calibre7"><a id="_idTextAnchor047" class="pcalibre pcalibre2 pcalibre1 calibre6"/>Inspecting the escaping references issue</h2>
<p lang="en-GB" class="calibre4">In this section, we will<a id="_idIndexMarker106" class="pcalibre pcalibre2 pcalibre1 calibre6"/> discuss and provide an example of Java’s call-by-value parameter passing mechanism. Once we understand call-by-value, this will enable us to demonstrate the issue that occurs when passing (or returning) references. Let us start with Java’s <span lang="">call-by-value mechanism.</span></p>
<h3 lang="en-GB" class="calibre8">Call-by-value</h3>
<p lang="en-GB" class="calibre4">Java uses<a id="_idIndexMarker107" class="pcalibre pcalibre2 pcalibre1 calibre6"/> call-by-value when passing parameters to methods and returning results from methods. Put simply, this means that Java <em class="italic" lang="">makes a copy of something</em>. In other words, when you are passing an argument to a method, a copy is made of that argument, and when you are returning a result from a method, a copy is made of that result. Why do we care? Well, what you are copying – a primitive or a reference – can <a id="_idIndexMarker108" class="pcalibre pcalibre2 pcalibre1 calibre6"/>have major implications (especially for mutable types, such as <strong class="bold" lang="">StringBuilder</strong> and <strong class="bold" lang="">ArrayList</strong>). This <a id="_idIndexMarker109" class="pcalibre pcalibre2 pcalibre1 calibre6"/>is what we want to dig into further here. We will use a sample program and an associated diagram to help. <span lang=""><em class="italic" lang="">Figure 2</em></span><em class="italic" lang="">.5</em> shows the <span lang="">sample code:</span></p>
<div class="calibre2">
<div class="img---figure" id="_idContainer021">
<img alt="Figure 2.5 – A call-by-value code sample" src="image/Figure_2.5_B18762.jpg" class="calibre31"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 2.5 – A call-by-value code sample</p>
<p lang="en-GB" class="calibre4"><span lang=""><em class="italic" lang="">Figure 2</em></span><em class="italic" lang="">.5</em> details a <a id="_idIndexMarker110" class="pcalibre pcalibre2 pcalibre1 calibre6"/>program where we have a simple <strong class="source-inline" lang="">Person</strong> class with two properties: a <strong class="source-inline" lang="">String</strong> name and an <strong class="source-inline" lang="">int</strong> (primitive) age. The constructor enables us to initialize the object state, and we have accessor/mutator methods for the <span lang="">instance variables.</span></p>
<p lang="en-GB" class="calibre4">The <strong class="source-inline" lang="">CallByValue</strong> class is the driver class. In <strong class="source-inline" lang="">main()</strong> on line <strong class="source-inline" lang="">27</strong>, a local primitive <strong class="source-inline" lang="">int</strong> variable, namely <strong class="source-inline" lang="">age</strong>, is declared and initialized to <strong class="source-inline" lang="">20</strong>. On line <strong class="source-inline" lang="">28</strong>, we create an object of type <strong class="source-inline" lang="">Person</strong>, passing in the <strong class="source-inline" lang="">String</strong> literal, <strong class="source-inline" lang="">John</strong>, and the primitive variable, <strong class="source-inline" lang="">age</strong>. Based on these arguments, we initialize the object state. The reference, namely <strong class="source-inline" lang="">john</strong>, is the local <a id="_idIndexMarker111" class="pcalibre pcalibre2 pcalibre1 calibre6"/>variable used to store the reference to the <strong class="source-inline" lang="">Person</strong> object on the heap. <span lang=""><em class="italic" lang="">Figure 2</em></span><em class="italic" lang="">.6</em> shows the state of memory after line 28 has finished executing. For clarity, we have omitted the <strong class="source-inline" lang="">args</strong> <span lang="">array object.</span></p>
<div class="calibre2">
<div class="img---figure" id="_idContainer022">
<img alt="Figure 2.6 – The initial state of the stack and the heap" src="image/Figure_2.6_B18762.jpg" class="calibre32"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 2.6 – The initial state of the stack and the heap</p>
<p lang="en-GB" class="calibre4">As <span lang=""><em class="italic" lang="">Figure 2</em></span><em class="italic" lang="">.6</em> shows, the frame for the <strong class="source-inline" lang="">main()</strong> method is the current frame on the stack. It contains two local variables: the <strong class="source-inline" lang="">int</strong> primitive age with its value of <strong class="source-inline" lang="">20</strong> and the <strong class="source-inline" lang="">Person</strong> reference, <strong class="source-inline" lang="">john</strong>, referring to the <strong class="source-inline" lang="">Person</strong> object on the heap. The <strong class="source-inline" lang="">Person</strong> object has its two instance variables initialized: the <strong class="source-inline" lang="">age</strong> primitive variable is set to <strong class="source-inline" lang="">20</strong> and the name <strong class="source-inline" lang="">String</strong> instance variable is referring to the <em class="italic" lang="">John</em> <strong class="source-inline" lang="">String</strong> object in the String Pool (as <em class="italic" lang="">John</em> is a <strong class="source-inline" lang="">String</strong> literal, Java stores <span lang="">it there).</span></p>
<p lang="en-GB" class="calibre4">Now, we execute line 29, <strong class="source-inline" lang="">change(john, age);</strong> in <span lang=""><em class="italic" lang="">Figure 2</em></span><em class="italic" lang="">.5</em>. This is where it gets interesting. We call the <strong class="source-inline" lang="">change()</strong> method, passing down the <strong class="source-inline" lang="">john</strong> reference and the <strong class="source-inline" lang="">age</strong> primitive. As Java is call-by-value, a copy is made of each of the arguments. <span lang=""><em class="italic" lang="">Figure 2</em></span><em class="italic" lang="">.7</em> shows the stack and the heap just as we enter the <strong class="source-inline" lang="">change()</strong> method and are about to execute its first instruction on <span lang="">line 34:</span></p>
<div class="calibre2">
<div class="img---figure" id="_idContainer023">
<img alt="  Figure 2.7 – The stack and heap as the change() method is entered" src="image/Figure_2.7_B18762.jpg" class="calibre33"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">  Figure 2.7 – The stack and heap as the change() method is entered</p>
<p lang="en-GB" class="calibre4">In the preceding figure, we<a id="_idIndexMarker112" class="pcalibre pcalibre2 pcalibre1 calibre6"/> can see that a frame has been pushed onto the stack for the <strong class="source-inline" lang="">change()</strong> method. As Java is call-by-value, a copy is made of both arguments into local variables in the method, namely <strong class="source-inline" lang="">age</strong> and <strong class="source-inline" lang="">adult</strong>. The difference here is crucial and requires subsections as <span lang="">a result.</span></p>
<h4 lang="en-GB" class="calibre34">Copying a primitive</h4>
<p lang="en-GB" class="calibre4">Copying a<a id="_idIndexMarker113" class="pcalibre pcalibre2 pcalibre1 calibre6"/> primitive is similar to photocopying a sheet of paper. If you hand the photocopy to someone else, they can do whatever they want to that sheet – you still have the original. This is what is going to happen in this program; the called<strong class="source-inline" lang=""> change()</strong> method will alter the primitive <strong class="source-inline" lang="">age</strong> variable, but the copy of <strong class="source-inline" lang="">age</strong> back in <strong class="source-inline" lang="">main()</strong> will <span lang="">be untouched.</span></p>
<h4 lang="en-GB" class="calibre34">Copying a reference</h4>
<p lang="en-GB" class="calibre4">Copying<a id="_idIndexMarker114" class="pcalibre pcalibre2 pcalibre1 calibre6"/> a reference is similar to copying a remote control for a television. If you hand the second/copy remote to someone else, they can change the channel that you are watching. This is what is going to happen in this program; the called <strong class="source-inline" lang="">change()</strong> method will, using the <strong class="source-inline" lang="">adult</strong> reference, alter the <strong class="source-inline" lang="">name</strong> instance variable in the <strong class="source-inline" lang="">Person</strong> object and the <strong class="source-inline" lang="">john</strong> reference back in <strong class="source-inline" lang="">main()</strong> will see <span lang="">that change.</span></p>
<p lang="en-GB" class="calibre4">Going back to <a id="_idIndexMarker115" class="pcalibre pcalibre2 pcalibre1 calibre6"/>the code example from <span lang=""><em class="italic" lang="">Figure 2</em></span><em class="italic" lang="">.5</em>, <span lang=""><em class="italic" lang="">Figure 2</em></span><em class="italic" lang="">.8</em> shows the stack and heap after lines 34 and 35 have finished executing but <em class="italic" lang="">before</em> the <strong class="source-inline" lang="">change()</strong> method returns <span lang="">to </span><span lang=""><strong class="source-inline" lang="">main()</strong></span><span lang="">:</span></p>
<div class="calibre2">
<div class="img---figure" id="_idContainer024">
<img alt="  Figure 2.8 – The stack and heap as the change() method is exiting" src="image/Figure_2.8_B18762.jpg" class="calibre35"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">  Figure 2.8 – The stack and heap as the change() method is exiting</p>
<p lang="en-GB" class="calibre4">As can be seen, the <strong class="source-inline" lang="">age</strong> primitive in the method frame for <strong class="source-inline" lang="">change()</strong> has been changed to <strong class="source-inline" lang="">90</strong>. In addition, a new <strong class="source-inline" lang="">String</strong> literal object is created for <em class="italic" lang="">Michael</em> in the String Pool and the <strong class="source-inline" lang="">name</strong> instance variable in the <strong class="source-inline" lang="">Person</strong> object is referring to it. This is because <strong class="source-inline" lang="">String</strong> objects are immutable; that is, once initialized, you cannot change the contents of <strong class="source-inline" lang="">String</strong> objects. Note that the <em class="italic" lang="">John</em> <strong class="source-inline" lang="">String</strong> object in the String Pool is now eligible for garbage collection, as there are no references <span lang="">to it.</span></p>
<p lang="en-GB" class="calibre4"><span lang=""><em class="italic" lang="">Figure 2</em></span><em class="italic" lang="">.9</em> show the state of the stack and heap after the <strong class="source-inline" lang="">change()</strong> method has finished executing and control has returned to the <span lang=""><strong class="source-inline" lang="">main()</strong></span><span lang=""> method:</span></p>
<div class="calibre2">
<div class="img---figure" id="_idContainer025">
<img alt="  Figure 2.9 – The stack and heap after the change() method has finished" src="image/Figure_2.9_B18762.jpg" class="calibre36"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">  Figure 2.9 – The stack and heap after the change() method has finished</p>
<p lang="en-GB" class="calibre4">In <span lang=""><em class="italic" lang="">Figure 2</em></span><em class="italic" lang="">.9</em>, the frame<a id="_idIndexMarker116" class="pcalibre pcalibre2 pcalibre1 calibre6"/> on the stack for the <strong class="source-inline" lang="">change()</strong> method has been popped. The frame for the <strong class="source-inline" lang="">main()</strong> method is now, once again, the current frame. You can see that the <strong class="source-inline" lang="">age</strong> primitive is unchanged, that is, it is still <strong class="source-inline" lang="">20</strong>. The reference is also the same. However, the <strong class="source-inline" lang="">change()</strong> method was able to change the instance variable that <strong class="source-inline" lang="">john</strong> was looking at. Line 30, <strong class="source-inline" lang="">System.out.println(john.getName() + " " + age);</strong>, proves what has occurred by outputting <span lang=""><em class="italic" lang="">Michael 20</em></span><span lang="">.</span></p>
<p lang="en-GB" class="calibre4">Now that we understand Java’s call-by-value mechanism, we will now discuss escaping references with the aid of <span lang="">an example.</span></p>
<h4 lang="en-GB" class="calibre34">The problem</h4>
<p lang="en-GB" class="calibre4">The<a id="_idIndexMarker117" class="pcalibre pcalibre2 pcalibre1 calibre6"/> principle of encapsulation in OOP is that a class’s data is <strong class="source-inline" lang="">private</strong> and accessible to external classes via its <strong class="source-inline" lang="">public</strong> API. However, in certain situations, this is not enough to protect your <strong class="source-inline" lang="">private</strong> data due to escaping references. <span lang=""><em class="italic" lang="">Figure 2</em></span><em class="italic" lang="">.10</em> is an example of a class that suffers from <span lang="">escaping references:</span></p>
<div class="calibre2">
<div class="img---figure" id="_idContainer026">
<img alt="   Figure 2.10 – Code with escaping references" src="image/Figure_2.10_B18762.jpg" class="calibre37"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">   Figure 2.10 – Code with escaping references</p>
<p lang="en-GB" class="calibre4">The <a id="_idIndexMarker118" class="pcalibre pcalibre2 pcalibre1 calibre6"/>preceding figure contains a <strong class="source-inline" lang="">Person</strong> class with one <strong class="source-inline" lang="">private</strong> instance variable, a <strong class="source-inline" lang="">StringBuilder</strong> called <strong class="source-inline" lang="">name</strong>. The <strong class="source-inline" lang="">Person</strong> constructor initializes the instance variable based on the argument passed in. The class also provides a <strong class="source-inline" lang="">public getName()</strong> accessor method to enable external classes to retrieve the <strong class="source-inline" lang="">private</strong> <span lang="">instance variable.</span></p>
<p lang="en-GB" class="calibre4">The driver class here is <strong class="source-inline" lang="">EscapingReferences</strong>. In <strong class="source-inline" lang="">main()</strong>, on line 16, a local <strong class="source-inline" lang="">StringBuilder</strong> object is created, containing the <strong class="source-inline" lang="">String</strong> <em class="italic" lang="">Dan</em> and <strong class="source-inline" lang="">sb</strong> is the name of the local reference. This reference is passed into the <strong class="source-inline" lang="">Person</strong> constructor in order to initialize the <strong class="source-inline" lang="">name</strong> instance variable in the <strong class="source-inline" lang="">Person</strong> object. <span lang=""><em class="italic" lang="">Figure 2</em></span><em class="italic" lang="">.11</em> shows the stack and heap at this point, that is, just after line 17 has finished executing. The String Pool is omitted, in the interests <span lang="">of clarity.</span></p>
<div class="calibre2">
<div class="img---figure" id="_idContainer027">
<img alt="Figure 2.11 – Escaping references on the way in" src="image/Figure_2.11_B18762.jpg" class="calibre38"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 2.11 – Escaping references on the way in</p>
<p lang="en-GB" class="calibre4">At this point, the<a id="_idIndexMarker119" class="pcalibre pcalibre2 pcalibre1 calibre6"/> issue of escaping references is emerging. Upon executing the <strong class="source-inline" lang="">Person</strong> constructor, a copy of the <strong class="source-inline" lang="">sb</strong> reference is passed in, where it is stored in the <strong class="source-inline" lang="">name</strong> instance variable. Now, as <span lang=""><em class="italic" lang="">Figure 2</em></span><em class="italic" lang="">.11</em> shows, both the <strong class="source-inline" lang="">name</strong> instance variable and the local <strong class="source-inline" lang="">main()</strong> variable, <strong class="source-inline" lang="">sb</strong>, refer to the same <span lang=""><strong class="source-inline" lang="">StringBuilder</strong></span><span lang=""> object!</span></p>
<p lang="en-GB" class="calibre4">Now, when line 18 executes in <strong class="source-inline" lang="">main()</strong>, that is, <strong class="source-inline" lang="">sb.append("Dan");</strong>, the object is changed to <strong class="source-inline" lang="">DanDan</strong> for <em class="italic" lang="">both</em> the local <strong class="source-inline" lang="">sb</strong> reference and the <strong class="source-inline" lang="">name</strong> instance variable. When we output the instance variable on line 19, it outputs <em class="italic" lang="">DanDan</em>, reflecting <span lang="">the change.</span></p>
<p lang="en-GB" class="calibre4">So, that is one issue on the way in: initializing our instance variables to the (copies of) the references passed in. We will address how to fix that shortly. On the way out, however, we also have an issue. <span lang=""><em class="italic" lang="">Figure 2</em></span><em class="italic" lang="">.12</em> demonstrates <span lang="">this issue:</span></p>
<div class="calibre2">
<div class="img---figure" id="_idContainer028">
<img alt="Figure 2.12 – Escaping references on the way out" src="image/Figure_2.12_B18762.jpg" class="calibre39"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 2.12 – Escaping references on the way out</p>
<p lang="en-GB" class="calibre4"><span lang=""><em class="italic" lang="">Figure 2</em></span><em class="italic" lang="">.12</em> shows<a id="_idIndexMarker120" class="pcalibre pcalibre2 pcalibre1 calibre6"/> the stack and heap after line 21, <strong class="source-inline" lang="">StringBuilder sb2 = p.getName();</strong>, executes. Again, we have a local reference, this time called <strong class="source-inline" lang="">sb2</strong>, which refers to the same object that the <strong class="source-inline" lang="">name</strong> instance variable in the <strong class="source-inline" lang="">Person</strong> object on the heap is referring to. Thus, when we use the <strong class="source-inline" lang="">sb2</strong> reference to append <strong class="source-inline" lang="">Dan</strong> to the <strong class="source-inline" lang="">StringBuilder</strong> object and then output the instance variable, we <span lang="">get </span><span lang=""><strong class="source-inline" lang="">DanDanDan</strong></span><span lang="">.</span></p>
<p lang="en-GB" class="calibre4">At this point, it is clear that just having your data <strong class="source-inline" lang="">private</strong> is not enough. The problem arises because <strong class="source-inline" lang="">StringBuilder</strong> is a mutable type, which means, at any time, you can change the (original) object. Contrast this with <strong class="source-inline" lang="">String</strong> objects, which are immutable (as are the wrapper types, for example: <strong class="source-inline" lang="">Double</strong>, <strong class="source-inline" lang="">Integer</strong>, <strong class="source-inline" lang="">Float</strong>, <span lang="">and </span><span lang=""><strong class="source-inline" lang="">Character</strong></span><span lang="">).</span></p>
<p class="callout-heading" lang="en-GB">Immutability</p>
<p class="callout" lang="en-GB">Java protects <strong class="source-inline1" lang="">String</strong> objects because any change to a <strong class="source-inline1" lang="">String</strong> object results in the creation of a completely new object (with the changes reflected). Thus, the code requesting a <em class="italic" lang="">change</em> will see the requested change (it’s just that it is a completely new object). The original <strong class="source-inline1" lang="">String</strong> object that others may have been looking at is <span lang="">still untouched.</span></p>
<p lang="en-GB" class="calibre4">Now that we have discussed the issues with escaping references, let us examine how to <span lang="">solve them.</span></p>
<h4 lang="en-GB" class="calibre34">Finding a solution</h4>
<p lang="en-GB" class="calibre4">Essentially, the<a id="_idIndexMarker121" class="pcalibre pcalibre2 pcalibre1 calibre6"/> solution revolves around a practice known<a id="_idIndexMarker122" class="pcalibre pcalibre2 pcalibre1 calibre6"/> as <em class="italic" lang="">defensive copying</em>. In this scenario, we do not want to store a copy of the reference for any mutable object. The same holds for returning references to our <strong class="source-inline" lang="">private</strong> mutable data in our accessor methods – we do not want to return a copy of the reference to the <span lang="">calling code.</span></p>
<p lang="en-GB" class="calibre4">Therefore, we need to be careful both on the way in and on the way out. The solution is to copy the object contents completely in both scenarios. This is known as a deep copy (whereas copying the references only is known as a shallow copy). Thus, on the way in, we copy the contents of the object into a new object and store the reference to the new object. On the way out, we copy the contents again and return the reference to the new object. We have protected our code in both scenarios. <span lang=""><em class="italic" lang="">Figure 2</em></span><em class="italic" lang="">.13</em> shows the solution to the previous code from <span lang=""><em class="italic" lang="">Figure 2</em></span><span lang=""><em class="italic" lang="">.10</em></span><span lang="">:</span></p>
<div class="calibre2">
<div class="img---figure" id="_idContainer029">
<img alt="Figure 2.13 – Escaping references code fixed" src="image/Figure_2.13_B18762.jpg" class="calibre40"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 2.13 – Escaping references code fixed</p>
<p lang="en-GB" class="calibre4">Line 7 shows the<a id="_idIndexMarker123" class="pcalibre pcalibre2 pcalibre1 calibre6"/> creation of the copy object on the way in (the constructor). Line 10 shows the creation of the copy object on the way out (the accessor method). Both lines 19 and 23 output <strong class="source-inline" lang="">Dan</strong>, as they should. <span lang=""><em class="italic" lang="">Figure 2</em></span><em class="italic" lang="">.14</em> represents the stack and heap as the program is about <span lang="">to exit:</span></p>
<div class="calibre2">
<div class="img---figure" id="_idContainer030">
<img alt="Figure 2.14 – The stack and heap for escaping references code fix" src="image/Figure_2.14_B18762.jpg" class="calibre41"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 2.14 – The stack and heap for escaping references code fix</p>
<p lang="en-GB" class="calibre4">For clarity, we <a id="_idIndexMarker124" class="pcalibre pcalibre2 pcalibre1 calibre6"/>omit the String Pool. We have numbered the <strong class="source-inline" lang="">StringBuilder</strong> objects 1 to 5. We can match the objects to the code <span lang="">as follows:</span></p>
<ul class="calibre10">
<li lang="en-GB" class="calibre11">Line 16 creates <span lang="">object 1.</span></li>
<li lang="en-GB" class="calibre11">Line 17, which calls line 7, creates object 2. The <strong class="source-inline" lang="">Person</strong> instance variable <strong class="source-inline" lang="">name</strong> refers to <span lang="">this object.</span></li>
<li lang="en-GB" class="calibre11">Line 18 modifies object 1, changing it to <strong class="source-inline" lang="">DanDan</strong> (note, however, that the object referred to by the <strong class="source-inline" lang="">name</strong> instance variable, that is, object 2, <span lang="">is untouched).</span></li>
<li lang="en-GB" class="calibre11">Line 19 creates object 3. The reference is passed back to <strong class="source-inline" lang="">main()</strong> but never stored. As <em class="italic" lang="">Dan</em> is output, this proves that the defensive copying on the way <em class="italic" lang="">in</em> <span lang="">is working.</span></li>
<li lang="en-GB" class="calibre11">Line 21 creates object 4. The local <strong class="source-inline" lang="">main()</strong> reference, <strong class="source-inline" lang="">sb2</strong>, refers <span lang="">to it.</span></li>
<li lang="en-GB" class="calibre11">Line 22 amends object 4 to <em class="italic" lang="">DanDan</em> (leaving the object that the instance variable is referring <span lang="">to untouched).</span></li>
<li lang="en-GB" class="calibre11">Line 23 creates object 5. As <em class="italic" lang="">Dan</em> is output, this proves that the defensive copying on the way <em class="italic" lang="">out</em> <span lang="">is working.</span></li>
</ul>
<p lang="en-GB" class="calibre4"><span lang=""><em class="italic" lang="">Figure 2</em></span><em class="italic" lang="">.14</em> shows<a id="_idIndexMarker125" class="pcalibre pcalibre2 pcalibre1 calibre6"/> that the StringBuilder object referred to by the <strong class="source-inline" lang="">name</strong> instance variable never changes from <em class="italic" lang="">Dan</em>. This is exactly what <span lang="">we wanted.</span></p>
<p lang="en-GB" class="calibre4">That wraps up this chapter. We have covered a lot, so let us recap the <span lang="">major points.</span></p>
<h1 id="_idParaDest-49" lang="en-GB" class="calibre5"><a id="_idTextAnchor048" class="pcalibre pcalibre2 pcalibre1 calibre6"/>Summary</h1>
<p lang="en-GB" class="calibre4">In this chapter, we started by examining how primitives are stored in memory. Primitives are predefined types that come with the language and can be stored on both the stack (local variables) and on the heap (instance variables). It is easy to identify primitives as they have all <span lang="">lowercase letters.</span></p>
<p lang="en-GB" class="calibre4">In contrast, objects are only stored on the heap. In discussing objects, it was necessary to distinguish between references and the objects themselves. We discovered that while references can be of any type (interface, abstract class, and class), objects themselves can only be of proper, concrete classes, meaning the class must not <span lang="">be </span><span lang=""><strong class="bold" lang="">abstract</strong></span><span lang="">.</span></p>
<p lang="en-GB" class="calibre4">Manage object references with care. If not managed properly, you could end up with <em class="italic" lang="">escaping references</em>. Java uses call-by-value, which means a copy is made of the argument passed or returned. Depending on whether the argument is a primitive or reference, it can have major implications. If it’s a copy of a reference to a mutable type, then the calling code can change your supposedly <strong class="source-inline" lang="">private</strong> data. This is not <span lang="">proper encapsulation.</span></p>
<p lang="en-GB" class="calibre4">We examined code with this issue and associated diagrams of the stack and heap. The solution is to use defensive copying, that is, copying the object contents both on the way in and on the way out. <em class="italic" lang="">Thus, the references and the objects they refer to remain private</em>. Lastly, we detailed the code solution and associated diagrams of the stack <span lang="">and heap.</span></p>
<p lang="en-GB" class="calibre4">In the next chapter, we are going to take a closer look at the heap, the area of memory where <span lang="">objects live.</span></p>
</div>
<div class="calibre2">
<div id="_idContainer032" class="calibre2">
</div>
</div>
</div></body></html>