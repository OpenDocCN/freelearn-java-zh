- en: Database Programming
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This chapter covers both basic and commonly used interactions between a Java
    application and a **database** (**DB**), right from connecting to the DB and performing
    CRUD operations to creating transactions, storing procedures, and working with
    **large objects** (**LOBs**). We will cover the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Connecting to a database using JDBC
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up the tables required for DB interactions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Performing CRUD operations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using prepared statements
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using transactions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with large objects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Executing stored procedures
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It is difficult to imagine a complex software application that does not use
    some kind of data storage. A structured and accessible data storage is called
    a database. This is why any modern language implementation includes a framework
    that allows you to access the DB and **create, read, update, and delete** (**CRUD**)
    data in it. In Java, it is the **Java Database Connectivity** (**JDBC**) API that
    provides access to *virtually any data source, from relational databases to spreadsheets
    and flat files*, according to the Javadoc.
  prefs: []
  type: TYPE_NORMAL
- en: The `java.sql` and `javax.sql` packages that compose the JDBC API are included in
    the **Java Platform Standard Edition** (**Java SE**). The `java.sql` package provides
    *the API for accessing and processing data stored in a data source (usually a
    relational database).* The `javax.sql` package provides the API for server-side
    data source access and processing. Specifically, it provides the `DataSource` interface
    for establishing a connection with a database, connection and statement pooling,
    distributed transactions, and rowsets. We will discuss each of these features
    in greater detail in the recipes of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: However, to actually connect `DataSource` to a physical database, one also needs a
    database-specific driver (provided by a database vendor, such as MySQL, Oracle, PostgreSQL,
    or SQL server database, to name a few). These might be written in Java or in a
    mixture of Java and **Java Native Interface** (**JNI**) native methods. This driver
    implements the JDBC API.
  prefs: []
  type: TYPE_NORMAL
- en: 'Working with a database involves eight steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Installing the database by following the vendor instructions.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Adding the dependency on a `.jar` to the application with the database-specific
    driver.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Creating a user, database, and database schema: tables, views, stored procedures,
    and so on.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connecting to the database from the application.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Constructing an SQL statement.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Executing the SQL statement.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Using the result of the execution.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Closing the database connection and other resources.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Steps 1-3 are done only once at the database setup stage before the application
    is run.
  prefs: []
  type: TYPE_NORMAL
- en: Steps 4-8 are performed by the application repeatedly as needed.
  prefs: []
  type: TYPE_NORMAL
- en: Steps 5-7 can be repeated multiple times with the same database connection.
  prefs: []
  type: TYPE_NORMAL
- en: Connecting to a database using JDBC
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, you will learn how to connect to a database.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Select the database you would like to work with. There are good commercial databases
    and good open source databases. The only thing we are going to assume is that
    the database of your choice supports **Structured Query Language** (**SQL**),
    which is a standardized language that allows you to perform CRUD operations on
    a database. In our recipes, we will use the standard SQL and avoid constructs
    and procedures specific to a particular database type.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the database is not installed yet, follow the vendor instructions and install
    it. Then, download the database driver. The most popular ones are types 4 and
    5, written in Java. They are very efficient and talk to the database server through
    a socket connection. If a `.jar` file with such a driver is placed on the classpath,
    it is loaded automatically. Type 4 and 5 drivers are database specific because
    they use database native protocol for accessing the database. We are going to
    assume that you are using a driver of such a type.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If your application has to access several types of databases, then you need
    a driver of type 3\. Such a driver can talk to different databases via a middleware
    application server.
  prefs: []
  type: TYPE_NORMAL
- en: Drivers of type 1 and 2 are used only when there are no other driver types available
    for your database.
  prefs: []
  type: TYPE_NORMAL
- en: Set the downloaded `.jar` file with the driver on your application's classpath. Now
    you can create a database and access it from your application.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Your database might have a console, a GUI, or some other way to interact with
    it. Read the instructions and create first a user, that is, `cook`, and then a
    database, namely `cookbook`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'For example, here are the commands that do this for PostgreSQL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: We selected the `SUPERUSER` role for our user; however, a good security practice
    is to assign such a powerful role to an administrator and create another application-specific
    user who can manage data but cannot change the database structure. It is good
    practice to create another logical layer, called schema, that can have its own
    set of users and permissions. This way, several schemas in the same database could
    be isolated, and each user (one of them is your application) will only have access
    to certain schemas.
  prefs: []
  type: TYPE_NORMAL
- en: Also, at the enterprise level, the common practice is to create synonyms for
    the database schema so that no application can access the original structure directly.
    You can also create a password for each user, but, again, for the purpose of this
    book, this is not needed. So we leave it to the database administrators to establish
    the rules and guidelines suitable to the particular working conditions of each
    enterprise.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now we connect our application to the database. In our demonstration, we will
    use, as you may have probably guessed by now, the open source (free) PostgreSQL
    database.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here is the code fragment that creates connection to our local PostgreSQL database:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The commented lines show how you can set a user and password for your connection.
    Since, for this demo, we keep the database open and accessible to anyone, we could
    use an overloaded `DriverManager.getConnection(String url)` method. However, we
    will show the most general implementation that would allow anyone to read from
    a property file and pass other useful values (`ssl` as true/false, `autoReconnect`
    as true/false, `connectTimeout` in seconds, and so on) to the connection-creating
    method. Many keys for the passed-in properties are the same for all major database
    types, but some of them are database-specific.
  prefs: []
  type: TYPE_NORMAL
- en: Alternatively, for passing only a user and password, we could use the third
    overloaded version, namely `DriverManager.getConnection(String url, String user,
    String password)`. It's worth mentioning that it is good practice to keep the
    password encrypted. We are not going to show how to do this, but there are plenty
    of guides available online.
  prefs: []
  type: TYPE_NORMAL
- en: Also, the `getConnection()` method throws `SQLException`, so we need to wrap
    it in a `try...catch` block.
  prefs: []
  type: TYPE_NORMAL
- en: 'To hide all of this and other plumbing, it is a good idea to keep the connection-establishing
    code inside a method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Another way of connecting to a database is to use the `DataSource` interface.
    Its implementation is typically included in the same `.jar` file as the database
    driver. In the case of PostgreSQL, there are two classes that implement the `DataSource` interface:
    `org.postgresql.ds.PGSimpleDataSource` and `org.postgresql.ds.PGPoolingDataSource`.
    We can use them instead of `DriverManager`. Here is an example of the usage of
    `PGSimpleDataSource`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'And the following is an example of the usage of `PGPoolingDataSource`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The last version of the `getDbConnection()` method is usually the preferred
    way of connecting because it allows you to use connection pooling and some other
    features, in addition to those available when connecting via `DriverManager`.
  prefs: []
  type: TYPE_NORMAL
- en: Whatever version of the `getDbConnection()` implementation you choose, you'll
    need to use it in all the code examples the same way.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'It is good practice to think about closing the connection as soon as you create
    it. The way to do this is using the `try-with-resources` construct, which ensures
    that the resource is closed at the end of the `try...catch` block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Such a construct can be used with any object that implements the `java.lang.AutoCloseable`
    or `java.io.Closeable` interface.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Refer to the following recipe in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Setting up the tables required for DB interactions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up the tables required for DB interactions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, you will learn how to create, change, and delete tables and
    other logical database constructs that compose a database schema.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The standard SQL statement for table creation looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Here, `table_name` and `column_name` have to be alphanumeric and unique (inside
    the schema) identifiers. The limitations for the names and possible data types
    are database-specific. For example, Oracle allows the table name to have 128 characters,
    while in PostgreSQL, the max length of the table name and column name is 63 characters.
    There are differences in the data types too, so read the database documentation.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here is an example of a command that creates the `traffic_unit` table in PostgreSQL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Here, we did not set the size of the columns of the type `VARCHAR`, thus allowing
    those columns to store values of any length. The `integer` type, in this case,
    allows you to store numbers from -2147483648 to +2147483647\. The `NOT NULL` type
    was added because, by default, the column would be nullable and we wanted to make
    sure that all the columns would be populated for each record.
  prefs: []
  type: TYPE_NORMAL
- en: 'We also identified the `id` column as `PRIMARY KEY`, which indicates that the
    column (or the combination of columns) uniquely identifies the record. For example,
    if there is a table that contains information about all the people of all the
    countries, the unique combination would *probably* be their full name, address,
    and date of birth. Well, it is plausible to imagine that in some household, twins
    are born and given the same name, so we said probably. If the chance of such an
    occasion is high, we would need to add another column to the primary key combination,
    which is the order of birth, with the default value of 1\. Here is how we can
    do this in PostgreSQL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: In the case of the `traffic_unit` table, there is no combination of columns
    that can serve as a primary key. Many cars have the same values. But we need to
    refer to a `traffic_unit` record so we could know which units have been selected
    and processed and which were not, for example. This is why, we added an `id` column
    to populate it with a unique generated number, and we would like the database to
    generate this primary key automatically.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you look at the generated table description (`\d traffic_unit`), you will
    see the `nextval(''traffic_unit_id_seq''::regclass)` function assigned to the
    `id` column. This function generates numbers sequentially, starting with 1\. If
    you need some different behavior, create the sequence number generator manually.
    Here''s an example of how to do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: This sequence starts from 1,000 and caches 10 numbers for better performance
    in case there is a need to generate numbers in quick succession.
  prefs: []
  type: TYPE_NORMAL
- en: 'According to the code examples shared in the previous chapters, the values
    of `vehicle_type`, `road_condition`, and `tire_condition` are limited by the `enum`
    type in the code. That''s why when the `traffic_unit` table is populated, we would
    like to make sure that only the values present in the code in `enum` types are
    set in the columns. To accomplish this, we''ll create a lookup table called `enums`
    and populate it with the values from our `enum` types:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: PostgreSQL has an `enum` data type, but it incurs an overhead if the list of
    possible values is not fixed and has to be changed over time. We think it is quite
    possible that the list of values in our application will expand. So, we decided
    not to use a database `enum` type but create the lookup table ourselves.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we can refer to the values of the `enums` table from the `traffic_unit`
    table using their ID as a foreign key. First, we delete the table:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we recreate it with a slightly different SQL command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The columns `vehicle_type`, `road_condition`, and `tire_condition` must now
    be populated by the primary key of the corresponding record of the `enums` table.
    This way, we can make sure that our traffic-analyzing code will be able to match
    the values in these columns to the values of the `enum` types in the code.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `enums` table should not have a duplicate combination of type-value because
    this might lead to confusion, especially when the code that populates the `traffic_unit`
    table looks up the necessary `id` in the `enums` table. Instead of the one value
    that is expected, the query will return two. Which one to pick, then? To avoid
    duplication, we can add a unique constraint to the `enums` table:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Now if we try to add a duplicate, the database will not allow it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another important consideration of database table creation is whether an index
    has to be added. An index is a data structure that helps to accelerate data searches
    in the table without having to check every table record. It can include one or
    more columns of a table. For example, an index for a primary key is created automatically.
    If you bring up the description of the table we have created already, you will
    see the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also add an index ourselves if we think (and have proven by experimentation)
    it will help the application performance. In the case of `traffic_unit`, we discovered
    that our code often searches this table by `vehicle_type` and `passengers_count`.
    So we measured the performance of our code during the search and added these two
    columns to the index:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we measured the performance again. If it had improved, we would have left
    the index in place, but in our case, we removed it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: We did this because an index has an overhead of additional writes and storage
    space.
  prefs: []
  type: TYPE_NORMAL
- en: In our examples of primary key, constraints, and indexes, we followed the naming
    convention of PostgreSQL. If you use a different database, we suggest you look
    up its naming convention and follow it, so that your naming aligns with the names
    created automatically.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Refer to the following recipes in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Performing CRUD operations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with large objects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Performing CRUD operations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, you will learn how to populate, read, change, and delete data
    in the database.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We have already seen examples of SQL statements that create (populate) data
    in the database:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'We''ve also seen examples of instances where several table records have to
    be added:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: If a column has a default value specified, there is no need to list it in the
    `INSERT INTO` statement, unless a different value has to be inserted.
  prefs: []
  type: TYPE_NORMAL
- en: 'The reading of the data is done by a `SELECT` statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'This is also done when all the columns have to be selected in an order:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s a general definition of the `WHERE` clause:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: The `column_name operator value` construct can be combined the with logical
    operators `AND` and `OR` and grouped with the brackets `(` and `)`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The data can be changed with the `UPDATE` statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, it can be deleted with the `DELETE` statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Without the `WHERE` clause, all the records of the table are going to be affected
    by the `UPDATE` or `DELETE` statement.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We have already seen an `INSERT` statement. Here is an example of other types
    of statements:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1cb03683-da6c-4cf4-a5ae-16b25d85f6ab.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The preceding `SELECT` statement requires bringing up all the columns of all
    the rows of the table. If the number of rows was bigger than the number of lines
    on the screen, the database console would show only the first screen and you would
    need to type a command (database-specific) to show the next screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a54b682d-5a42-47ee-96a2-a8c33cce32b0.png)'
  prefs: []
  type: TYPE_IMG
- en: 'This `SELECT` statement has a `WHERE` clause that requires you to show only
    those rows where the value in the `type` column is `vehicle` and the value in
    the `value` column is not `crewcab`. It also requires you to show the rows where
    the value in the `value` column is `new`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7bd17df9-3af0-4055-a889-889a4533fcb2.png)'
  prefs: []
  type: TYPE_IMG
- en: The preceding screenshot captures three statements. The first one is an `UPDATE`
    statement that requires you to change the value in the `value` column to `NEW`,
    but only in the rows where the value in the `value` column is `new` (apparently,
    the value is case-sensitive). The second statement requires you to delete all
    the rows that do not have the value `NEW` in the `value` column. The third statement
    is `SELECT`, which we just discussed.
  prefs: []
  type: TYPE_NORMAL
- en: It worth noting that we would not be able to delete the records of the `enums`
    table if these records were referred to as foreign keys in the `traffic_unit` table.
    Only after deleting the corresponding records of the `traffic_unit` table would
    we be able to do this. But, for now, that is, for demonstration purposes, we keep
    the `traffic_unit` table empty.
  prefs: []
  type: TYPE_NORMAL
- en: 'To execute any of the CRUD operations in the code, one has to acquire a JDBC
    connection first, then create and execute a statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: It is good practice to use the `try-with-resources` construct for the `Statement`
    object too. The closing of the `Connection` object would close the `Statement`
    object automatically. However, when you close the `Statement` object explicitly,
    the cleanup happens immediately instead of waiting for the necessary checks and
    actions to propagate through the layers of the framework.
  prefs: []
  type: TYPE_NORMAL
- en: The `execute()` method is the most generic one among the three methods that
    can execute a statement. The other two include `executeQuery()` (for `SELECT`
    statements only) and `executeUpdate()` (for `UPDATE`, `DELETE`, `CREATE`, or `ALTER`
    statements). As you can see in our example, the `execute()` method returns `boolean`,
    which indicates whether the result is a `ResultSet` object or just a count. This
    means that `execute()` acts as `executeQuery()` for the `SELECT` statement and
    `executeUpdate()` for the other statements that we just listed.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can demonstrate this by running the preceding code with the following sequence
    of statements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'The result will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/896e111f-c133-4b13-8c4d-db39aa2d0ca5.png)'
  prefs: []
  type: TYPE_IMG
- en: We carried out the positional extraction of the values from `ResultSet` because
    this is more efficient than using the column name (as in `rs.getInt("id")` or `rs.getInt("type")`).
    The difference in performance is very small, though, and becomes important only
    when the operation happens many times. Only the actual measuring and testing can
    tell you whether the difference in the case of your application is significant
    or not. Bear in mind that getting values by name provides better code readability,
    which pays well in the long term during application maintenance.
  prefs: []
  type: TYPE_NORMAL
- en: 'We used the `execute()` method for demonstration purposes. In practice, the `executeQuery()` method is
    used for `SELECT` statements because the programmer usually has to extract the
    data in a way specific to the executed SQL statement. By contrast, the call to
    `executeUpdate()` can be wrapped in a generic method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'SQL is a rich language, and we do not have enough space to cover all its features.
    We would just like to enumerate a few of its most popular ones so you are aware
    of their existence and could look them up when needed:'
  prefs: []
  type: TYPE_NORMAL
- en: The `SELECT` statement allows the use of the `DISTINCT` keyword to get rid off
    all the duplicate values
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding the `ORDER BY` keyword presents the result in the specified order
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The keyword `LIKE` allows you to set the search pattern to the `WHERE` clause
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The search pattern can use several wildcard: `%, _`, `[charlist]`, `[^charlist]`,
    or `[!charlist]`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Matching values can be enumerated with the `IN` keyword
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `SELECT` statement can include several tables using the `JOIN` clause
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SELECT * INTO table_2 from table_1 creates table_2` and copies data from `table_1`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`TRUNCATE` is faster and uses fewer resources when removing all the rows of
    a table'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'There are many other useful methods in the `ResultSet` interface as well. Here
    is an example of how some of its methods can be used to write generic code that
    would traverse the returned result and use metadata to print out the column name
    and the returned value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'We used `ResultSetMetaData` only once to collect the returned column names
    and the length (number of columns) of one row. Then, we extracted the values from
    each row by position and created `List<String>` elements with the corresponding
    column names. To print, we used something we are already familiar with--a programmer''s
    delight--the joining collector (we discussed this in a previous chapter). If we
    call the `traverseRS("select * from enums")` method, the result will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/fe5810e8-6253-430d-afc4-1d8bb975532c.png)'
  prefs: []
  type: TYPE_IMG
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Refer to the following recipes in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Using prepared statements
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using transactions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with large objects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Executing stored procedures
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using prepared statements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this recipe, you will learn how to use a prepared statement: a statement
    template that can be stored in the database and executed efficiently with different
    input values.'
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An object of `PreparedStatement`--a subinterface of `Statement`--can be precompiled
    and stored in the database and then used to efficiently execute the SQL statement
    multiple times for different input values. Similar to an object of `Statement` (created
    by the `createStatement()` method), it can be created by the `prepareStatement()`
    method of the same `Connection` object.
  prefs: []
  type: TYPE_NORMAL
- en: There is also a third version of a statement that creates a method called `prepareCall()` that,
    in turn, creates the `CallableStatement` object used to execute a database-stored
    procedure, but we will discuss this in a separate recipe later.
  prefs: []
  type: TYPE_NORMAL
- en: 'The same SQL statement that was used to generate `Statement` can be used to
    generate `PreparedStatement` too. In fact, it is a good idea to consider using
    `PrepdaredStatement` for any SQL statement that is called multiple times because
    it performs better than `Statement`. To do this, all we need to change are these
    two lines in the sample code of the previous section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'We change these lines to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The true usefulness of `PreparedStatement` shines because of its ability to
    accept parameters--the input values that substitute (in the order of appearance)
    the `?` symbol. Here''s an example of this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'The result of this is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4d00bc67-c4b4-4efb-95f6-f562df470f9d.png)'
  prefs: []
  type: TYPE_IMG
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It is not a bad idea to always use prepared statements for CRUD operations.
    They might be slower if executed only once, but you can test and see whether this
    is the price you are willing to pay. What you get with prepared statements is
    consistent (better readable) code, more security (prepared statements are not
    vulnerable to SQL injection), and one fewer decision to make (just reuse the same
    code everywhere).
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Refer to the following recipes in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Using transactions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with large objects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Executing stored procedures
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using transactions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, you will learn what a database transaction is and how it can
    be used in Java code.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A transaction is a unit of work that includes one or many operations that change
    data. If successful, all the data changes are *committed* (applied to the database).
    If one of the operations errors out or the transaction is *rolled back*, then
    none of the changes included in the transaction will be applied to the database.
  prefs: []
  type: TYPE_NORMAL
- en: Transaction properties are set up on the `Connection` object. They can be changed
    without closing the connection, so different transactions can reuse the same `Connection`
    object.
  prefs: []
  type: TYPE_NORMAL
- en: JDBC allows transaction control only for CRUD operations. Table modification
    (`CREATE TABLE`, `ALTER TABLE`, and so on) is committed automatically and cannot
    be controlled from the Java code.
  prefs: []
  type: TYPE_NORMAL
- en: By default, a CRUD operation transaction is set to be autocommitted too. This
    means that every data change that was introduced by an SQL statement is applied
    to the database as soon as the execution of the SQL statement is completed. All
    the preceding examples use this default behavior.
  prefs: []
  type: TYPE_NORMAL
- en: To change this, one has to use the `setAutoCommit()` method of the `Connection` object.
    If set to false, that is, `setAutoCommit(false)`, the data changes will not be
    applied to the database until the `commit()` method on the `Connection` object
    is invoked. If the `rollback()` method is called, all the data changes since the
    beginning of the transaction or since the last call to `commit()` would be discarded.
  prefs: []
  type: TYPE_NORMAL
- en: Explicit programmatic transaction management improves performance, but it is
    insignificant in the case of short atomic operations that are called once and
    not very often. Taking over transaction control becomes crucial when several operations
    introduce changes that have to be applied, either all together or none of them.
    It allows you to group database changes into atomic units and thus avoid accidental
    violation of data integrity.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'First, let''s add an output to the `traverseRS()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: This will help you analyze the output when many different SQL statements are
    executed in the same demo example.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let''s run the following code that reads data from the `enums` table, then
    inserts a row, and then reads all the data from the table again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that we took over transaction control by calling `conn.setAutoCommit(false)`.
    The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4ba8a330-8187-4e84-abff-45aadcb2e6c0.png)'
  prefs: []
  type: TYPE_IMG
- en: 'As you can see, the changes were not applied because the call to `commit()` was
    commented out. When we uncomment it, the result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a4c1bbe0-12aa-4ef8-a906-6330ea3d26cf.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now let''s execute two inserts, but introduce a spelling error in the second
    insert:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'We get a stack trace (we do not show it to save space) of the error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e643bfd1-e947-42f2-9e4e-55a555146ae9.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The second row was not inserted. If there was no `conn.commit()` after the
    first `INSERT INTO` statement, the first insert would not be applied either. This
    is the advantage of the programmatic transaction control in the case of many independent
    data changes: if one fails, we can skip it and continue applying other changes.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let''s try to insert three rows with an error (by not setting a number
    as the `id` value) in the second row:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'We put each insert execution in the `try...catch` block and commit the changes
    before printing out the result (update count or error message). The result will
    be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e676ed35-c821-42a9-897d-555d2ce8bc79.png)'
  prefs: []
  type: TYPE_IMG
- en: You can see that the second row was not inserted, although `conn.rollback()`
    was commented out. Why? This is because the only SQL statement included in this
    transaction failed, so there was nothing to roll back.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let''s create a `test` table using the database console:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1994a329-9e4c-4b24-9caf-20a81cc2a977.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We will use this table to record the vehicle types of the records inserted
    in the `enums` table:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'With `conn.rollback()` commented out, the result will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9371aa64-1517-404f-97a7-1451f1b463e4.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The row with `truck` was not inserted in the `enums` table but added to the
    `test` table, although our intent was to record all the vehicles inserted in `enums`,
    and only them, in the `test` table. This is when the usefulness of a rollback
    can be demonstrated. If we uncomment `conn.rollback()`, the result will be as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1bdc5cde-04b9-4eb2-9bbe-605b8c28f165.png)'
  prefs: []
  type: TYPE_IMG
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Another important property of a transaction is the *transaction isolation level*.
    It defines the boundaries between database users. For example, can other users
    see your database changes before they are committed? The higher the isolation
    (the highest is *serializable*), the more the time it takes a transaction to complete
    in the case of concurrent access to the same records. The less restrictive the
    isolation (the least restrictive is *read uncommitted*), the dirtier the data;
    this is because other users can get the values you are not going to commit eventually.
  prefs: []
  type: TYPE_NORMAL
- en: Usually, it is enough to use the default level, which (although it may be different
    for different databases) is typically `TRANSACTION_READ_COMMITTED`. JDBC allows
    you to get the current transaction isolation level using the `Connection` method
    called `getTransactionIsolation()`, while the `setTransactionIsolation()` method
    allows you to set any other level as needed.
  prefs: []
  type: TYPE_NORMAL
- en: In the case of complex decision-making logic about which changes need to be
    committed and which need to be rolled back, one can use two `Connection` methods to
    create and delete *savepoints*. The `setSavepoint(String savepointName)` method creates
    a new savepoint and returns a `Savepoint` object, which can later be used to roll
    back all the changes up to this point using the `rollback (Savepoint savepoint)`
    method. A savepoint can be deleted by calling `releaseSavepoint(Savepoint savepoint)`.
  prefs: []
  type: TYPE_NORMAL
- en: The most complex type of database transactions is *distributed transactions*.
    They are sometimes called *global transactions*, *XA transactions*, or *JTA transactions* (the
    latter is a Java API that consists of two Java packages, namely `javax.transaction`
    and `javax.transaction.xa`). They allow you to create and execute a transaction
    that spans operations across two different databases. Providing a detailed overview
    of distributed transactions is outside the scope of this book.
  prefs: []
  type: TYPE_NORMAL
- en: Working with large objects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this recipe, you will learn how to store and retrieve a LOB that can be
    one of the three types: **Binary Large Object** (**BLOB**), **Character Large
    Object** (**CLOB**), and **National Character Large Object** (**NCLOB**).'
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The actual processing of LOB objects inside a database is vendor-specific, but
    JDBC APIs hide these implementation details from the application by representing
    the three LOB types as interfaces: `java.sql.Blob`, `java.sql.Clob`, and `java.sql.NClob`.
  prefs: []
  type: TYPE_NORMAL
- en: '`Blob` is usually used to store images or other non-alphanumeric data. On the
    way to the database, an image can be converted into a stream of bytes and stored
    using the `INSERT INTO` statement. The `Blob` interface allows you to find the
    length of the object and convert it into an array of bytes that can be processed
    by Java for the purpose of displaying the image, for example.'
  prefs: []
  type: TYPE_NORMAL
- en: '`Clob` allows you to store character data. `NClob` stores Unicode character
    data as a way to support internationalization. It extends the `Clob` interface
    and provides the same methods. Both interfaces allow you to find the length of
    LOB and a substring inside the value.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The methods in the `ResultSet`, `CallableStatement` (we will discuss this in
    the next recipe) and `PreparedStatement` interfaces allow an application to store
    and access the stored value in a variety of ways: some of them via setters and
    getters of the corresponding objects, while others as `bytes[]`, or as a binary,
    character, or ASCII stream.'
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Each database has its specific way of storing a LOB. In the case of PostgreSQL,
    `Blob` is usually mapped to the `OID` or `BYTEA` data type, while `Clob` and `NClob` are
    mapped to the `TEXT` type. So let''s write a new method that will allow us to
    create tables programmatically:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'This differs from `executeUpdate()`, as it calls the `execute()` method of
    `PreparedStatement` instead of `executeUpdate()`. In principle, we can use `execute()`
    instead of `executeUpdate()` everywhere, but in our implementation of `executeUpdate()`,
    we expect a return value (`count`), which is not returned in the case of creating
    a table; therefore, we wrote this new method. Now we can create three tables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Look at the JDBC interfaces `PreparedStatement` and `ResultSet` and you'll notice
    the setters and getters for the objects--`get/setBlob()`, `get/setClob()`, `get/setNClob()`,
    `get/setBytes()`-- in memory and the methods that use `InputStream` and `Reader` (`get/setBinaryStream()`,
    `get/setAsciiStream()`, or `get/setCharacterStream()`). The big advantage of streaming
    methods is that they move data between the database and source without storing
    the whole LOB in memory.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, the object''s setters and getters are closer to our heart as they
    are used to object-oriented coding. So we will start with them, using not too
    big objects, for demo purposes. We expect the code to work just fine:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, in the case of `Clob`, we write this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'It turns out not all methods available in the JDBC API are actually implemented
    by the drivers of all the databases. For example, `createBlob()` seems to work
    just fine for Oracle and MySQL, but in the case of PostgreSQL, we get this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4a788ba8-abc4-4087-9122-96078f015058.png)'
  prefs: []
  type: TYPE_IMG
- en: 'For the `Clob` example, we get this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/746fbbc3-9a6c-4143-9725-2432107c32c1.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We can try to retrieve an object from `ResultSet` via the getter as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'The result will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/290d67e0-091a-426e-bc12-9a15b1a9aafe.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Apparently, knowing the JDBC API is not enough; one has to read the documentation
    for the database too. Here is what the documentation for PostgreSQL ([https://jdbc.postgresql.org/documentation/80/binary-data.html](https://jdbc.postgresql.org/documentation/80/binary-data.html))
    has to say about LOB handling:'
  prefs: []
  type: TYPE_NORMAL
- en: To use the BYTEA data type you should simply use the getBytes(), setBytes(),
    getBinaryStream(), or setBinaryStream() methods.
  prefs: []
  type: TYPE_NORMAL
- en: To use the Large Object functionality you can use either the LargeObject class
    provided by the PostgreSQL JDBC driver, or by using the getBLOB() and setBLOB()
    methods.
  prefs: []
  type: TYPE_NORMAL
- en: Also, *you must access Large Objects within an SQL transaction block. You can
    start a transaction block by calling setAutoCommit(false)*.
  prefs: []
  type: TYPE_NORMAL
- en: Without knowing such specifics, figuring out a way to handle LOBs would require
    a lot of time and cause much frustration.
  prefs: []
  type: TYPE_NORMAL
- en: 'When dealing with LOBs, we will use the streaming methods first because streaming
    directly from the source into the database or the other way around does not consume
    memory as much as the setters and getters do (which have to load LOB in memory
    first). Here is the code that streams `Blob` in/from PostgreSQL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'This will be your result. We have cut the screenshot arbitrarily on the right-hand
    side; otherwise, it is very long horizontally:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7340788e-cfe4-47d5-addf-012aebd12d91.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Another way to process the retrieved image is to use `byte[]`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'PostgreSQL limits the BYTEA size to 1 GB. Larger binary objects can be stored
    as the **object identifier** (**OID**) data type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'The result will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/31ad56e0-7cf0-4fe1-9754-b26c947d6084.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Note that the `select` statement returns a long value from the `lob` column.
    This is because the `OID` column does not store the value itself like BYTEA does.
    Instead, it stores the reference to the object that is stored somewhere else in
    the database. Such an arrangement makes deleting the row with the OID type not
    as straightforward as this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'If one does just that, it leaves the actual object an orphan that continues
    to consume disk space, but, that is not referred to by any of the application
    tables. To avoid this problem, one has to `unlink` the LOB first by executing
    the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: Only after this can you safely execute the `delete from lobs where id = 100` command.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you forget to `unlink` first, or if you create an orphan LOB accidentally
    (because of an error in the code or something), there is a way to find orphans
    in system tables. Again, database documentation should provide you with instructions
    on how to do this. In the case of PostgreSQL v.9.3 or later, you can check whether
    you have an orphan LOB by executing the `select count(*) from pg_largeobject` command.
    If it returns a count that is bigger than 0, then you can delete all the orphans
    with the following join (assuming that the `lobs` table is the only one that can
    refer to a LOB):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: This is an overhead, though--the price one has to pay for storing a LOB in a
    database. It's worth noticing that although BYTEA does not require such complexity
    during the delete operation, it has a different kind of overhead. According to
    the PostgreSQL documentation, when close to 1 GB, *it would require a huge amount
    of memory to process such a large value.*
  prefs: []
  type: TYPE_NORMAL
- en: 'To read LOB data, one can use the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, one can also use an even simpler version by getting `Blob` directly
    from the `ResultSet` object if the LOB is not too big:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'To store `Clob` in PostgreSQL, one can use the same code as the preceding one.
    While reading from the database, one can convert bytes into a `String` data type
    or something similar (again, if the LOB is not too big):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'However, `Clob` in PostgreSQL can be stored directly as data type `TEXT` that
    is unlimited in size. This code reads the file where this code is written and
    stores/retrieves it in/from the database:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'The result will be as follows (we have shown only the first few lines of the
    output):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/18e521c3-38de-4b3b-8724-816367d8e052.png)'
  prefs: []
  type: TYPE_IMG
- en: 'For bigger objects, streaming methods would be a better (if not the only) choice:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: Note that `setCharacterStream(int, Reader, long)` is not implemented, while `setCharacterStream(int,
    Reader, int)` works just fine.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also read the file from the `texts` table as a character stream and
    limit it to the first 160 characters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'The result will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4d8e1598-e94c-4dbf-b7b7-c347448de32c.png)'
  prefs: []
  type: TYPE_IMG
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here is another recommendation from the PostgreSQL documentation (you can access
    it at [https://jdbc.postgresql.org/documentation/80/binary-data.html](https://jdbc.postgresql.org/documentation/80/binary-data.html)):'
  prefs: []
  type: TYPE_NORMAL
- en: The BYTEA data type is not well suited for storing very large amounts of binary
    data. While a column of type BYTEA can hold up to 1 GB of binary data, it would
    require a huge amount of memory to process such a large value.
  prefs: []
  type: TYPE_NORMAL
- en: The Large Object method for storing binary data is better suited to storing
    very large values, but it has its own limitations. Specifically deleting a row
    that contains a Large Object reference does not delete the Large Object. Deleting
    the Large Object is a separate operation that needs to be performed. Large Objects
    also have some security issues since anyone connected to the database can view
    and/or modify any Large Object, even if they don't have permissions to view/update
    the row containing the Large Object reference.
  prefs: []
  type: TYPE_NORMAL
- en: While deciding to store LOBs in a database, one has to remember that the bigger
    the database, the more difficult it is to maintain it. The speed of access--the
    main advantage of choosing a database as a storage facility--also slows down,
    and it is not possible to create indices for LOB types to improve the search.
    Also, one cannot use LOB columns in a `WHERE` clause, except for a few CLOB cases,
    or use LOB columns in multiple rows of `INSERT` or `UPDATE` statements.
  prefs: []
  type: TYPE_NORMAL
- en: So, before thinking about a database for a LOB, one should always consider whether
    storing the name of a file, keywords, and some other content properties in the
    database would be enough for the solution.
  prefs: []
  type: TYPE_NORMAL
- en: Executing stored procedures
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, you will learn how to execute a database-stored procedure from
    a Java program.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Once in a while, a real-life Java programmer encounters the need to manipulate
    and/or select data in/from several tables and comes up with a set of complex SQL
    statements. In one scenario, a database administrator looks at the suggested procedure
    and improves and optimizes it so much that it becomes impossible or at least impractical
    to implement it in Java. This is when the developed set of SQL statements can
    be wrapped into a stored procedure that is compiled and stored in the database
    and then invoked via the JDBC interface. Or, in another twist of fate, a Java
    programmer might encounter the need for incorporating a call to an existing stored
    procedure into the program. To accomplish this, the interface `CallableStatement` (which
    extends interface `PreparedStatement`) can be used, although some databases allow
    you to call a stored procedure using either interface `Statement` or `PreparedStatement`.
  prefs: []
  type: TYPE_NORMAL
- en: '`CallableStatement` can have parameters of three types: `IN` for an input value,
    `OUT` for the result, and `IN OUT` for either an input or an output value. `OUT`
    parameters must be registered by the `registerOutParameter()` method of `CallableStatement`.
    IN parameters are set the same way as the parameters of `PreparedStatement`.'
  prefs: []
  type: TYPE_NORMAL
- en: Bear in mind that executing a stored procedure from Java programmatically is
    one of the least standardized areas. PostgreSQL, for example, does not support
    stored procedures directly, but they can be invoked as functions, which have been
    modified for this purpose by interpreting `OUT` parameters as return values. Oracle,
    on the other hand, allows `OUT` parameters for functions too.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is why the following difference between database functions and stored
    procedures can serve only as a general guideline, not as a formal definition:'
  prefs: []
  type: TYPE_NORMAL
- en: A function has a return value, but it does not allow `OUT` parameters (except
    for some databases) and can be used in an SQL statement.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A stored procedure does not have a return value (except for some databases);
    it allows `OUT` parameters (for most databases) and can be executed using the
    JDBC interface `CallableStatement`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This is why reading the database documentation in order to learn how to execute
    a stored procedure is as important as, say, handling LOBs, discussed in the previous
    recipe.
  prefs: []
  type: TYPE_NORMAL
- en: Because stored procedures are compiled and stored in the database server, the
    `execute()` method of `CallableStatement` performs better for the same SQL statement
    than the corresponding method of `Statement` or `PreparedStatement`. This is one
    of the reasons a lot of Java code is sometimes replaced by one or several stored
    procedures that include even the business logic. Another reason for such a decision
    is that one can implement the solution the way one is most familiar with. So,
    there is no right answer for all cases and situations, and we will refrain from
    making specific recommendations, except to repeat the familiar mantra about the value
    of testing and the clarity of the code you are writing.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As in the previous recipe, we will continue using the PostgreSQL database for
    demonstration purposes. Before writing custom SQL statements, functions, and stored
    procedures, one should look at the list of already existing functions first. Usually,
    they provide a wealth of functionality.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example of calling the `replace(string text, from text, to text)`
    function that finds all the `from text ` substrings in `string text` and replaces
    them with `to text`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8e199295-8014-439c-a39b-e4bf4849f5e0.png)'
  prefs: []
  type: TYPE_IMG
- en: We will incorporate this function into our custom functions and stored procedures
    in order to show how it can be done.
  prefs: []
  type: TYPE_NORMAL
- en: 'A stored procedure can be without any parameters at all, with `IN` parameters
    only, with `OUT` parameters only, or with both. The result may be one or multiple
    values, or a `ResultSet` object. Here is an example of creating a stored procedure
    without any parameters in PostgreSQL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'We use a method we are already familiar with:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: This stored procedure (it is always a function in PostgreSQL) creates a `texts` table
    (drops this if the table exists already). You can find the syntax of the SQL for
    function creation in the database documentation. The only thing we would like
    to comment here is that instead of the symbol `$$` that denotes the function body,
    you can use single quotes. We prefer `$$` because it helps avoid the escaping
    of single quotes in case we need to include them in the function body.
  prefs: []
  type: TYPE_NORMAL
- en: 'This procedure can be invoked by `CallableStatement`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, it can be invoked with the SQL statement `select createTableTexts()` or `select
    * from createTableTexts()`. Both statements return a `ResultSet` object (which
    is `null` in the case of the `createTableTexts()` function), so we can traverse
    it by our method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: We have already used this method in the previous recipes.
  prefs: []
  type: TYPE_NORMAL
- en: The function can be deleted by the `drop function if exists createTableTexts()` statement.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let''s put all of this together in Java code, create a function, and invoke
    it in three different styles:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/cc42e573-2b09-4dda-a2b5-c0f62aeea46b.png)'
  prefs: []
  type: TYPE_IMG
- en: Note that the name of the function is case-insensitive. We keep it camel case
    for human readability only.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let''s create and call a stored procedure (function) with two input parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'In the function body, the input parameters were referred to by their `$1` and
    `$2` positions. As mentioned before, we also used the built-in `replace()` function
    to manipulate the values of the second input parameter before inserting it in
    the table. We called the newly created stored procedure twice: first via `CallableStatment`
    and then via the `execute()` method, with different input values. Then we looked
    inside the table using `traverseRS("select * from texts")` and dropped the newly
    created function to perform a cleanup (in real code, the function, once created,
    stays and takes advantage of being there, compiled and ready to run). If we run
    this code, we''ll get the following result:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/fa933ce1-3f33-4adc-8036-e089af2e167c.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The following code adds two rows to the `texts` table, then looks into it and
    creates a stored procedure (function) that counts the number of rows in the table
    and returns the result (note the `bigint` value of the returned value and the
    matching type for the `OUT` parameter `Types.BIGINT`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'The newly created stored procedure is executed three times and then deleted.
    The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/faa8f054-3e42-4fb9-b6bf-81bc02e669dc.png)'
  prefs: []
  type: TYPE_IMG
- en: 'An example of a stored procedure with one input parameter (of the type `int`)
    that returns `ResultSet` will look like this (note the return type defined as
    `setof texts`, where `texts` is the name of the table):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'The result will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ad9e4a06-e481-491c-8cf3-4ea71834543f.png)'
  prefs: []
  type: TYPE_IMG
- en: It's worth analyzing the difference in the `ResultSet` content of two different
    calls to the stored procedure. Without `select *`, it contains the name of the
    procedure and the returned object (of the `ResultSet` type). But with `select
    *`, it returns the actual `ResultSet` content from the last SQL statement in the
    procedure.
  prefs: []
  type: TYPE_NORMAL
- en: 'Naturally, the question arises why we could not call this stored procedure
    via `CallableStatement`, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'We tried, but it did not work. Here is what the PostgreSQL documentation has
    to say about it:'
  prefs: []
  type: TYPE_NORMAL
- en: Functions that return data as a set should not be called via the CallableStatement
    interface, but instead should use the normal Statement or PreparedStatement interfaces.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is a way around this limitation, though. The same database documentation
    describes how to retrieve a `refcursor` (a PostgreSQL-specific feature) value
    that can then be cast to `ResultSet`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'A few comments about the preceding code would probably help you understand
    how it was done:'
  prefs: []
  type: TYPE_NORMAL
- en: Autocommit has to be turned off
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Inside the function, `$1` refers to the first `IN` parameter (not counting the
    `OUT` parameter)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The language is set to `plpgsql` in order to access the `refcursor` functionality
    (PL/pgSQL is a loadable procedural language of the PostgreSQL database)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To traverse `ResultSet`, we wrote a new method, as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'So, our old friend can now be refactored into this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'The result will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/23c60d40-e621-4b5c-ab32-5bb63acbead8.png)'
  prefs: []
  type: TYPE_IMG
- en: You can see that the result-traversing methods that do not extract an object
    and cast it to `ResultSet` don't show the correct data in this case.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We covered the most popular cases of calling stored procedures from Java code.
    The scope of this book did not allow us to present more complex and potentially
    useful forms of stored procedures in PostgreSQL and other databases. However,
    we would like to mention them here, so you can have an idea of other possibilities:'
  prefs: []
  type: TYPE_NORMAL
- en: Functions on composite types
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Functions with parameter names
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Functions with variable numbers of arguments
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Functions with default values for arguments
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Functions as table sources
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Functions returning tables
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Polymorphic SQL functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Functions with collations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
