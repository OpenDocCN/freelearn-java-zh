- en: Developing Your First Application with Quarkus
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will be creating our first Quarkus application using the
    tooling that's available to us. As you will soon see, this is a pretty simple
    process that can be bootstrapped from the command line and doesn't require you
    to download any external tools. By using this process, we will be able to compile
    an application into a native executable and have solid evidence of how fast and
    thin a Java application can be when it's turned into native code by Quarkus.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Using the Quarkus Maven plugin to bootstrap our projects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Alternative methods to kick-start your projects (Quarkus CLI)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating and executing our first Quarkus application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Debugging the application from our IDE
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing the application with an extension of the JUnit test framework
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Turning our application into native code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You can find the source code for the project in this chapter on GitHub at [https://github.com/PacktPublishing/Hands-On-Cloud-Native-Applications-with-Java-and-Quarkus/tree/master/Chapter02](https://github.com/PacktPublishing/Hands-On-Cloud-Native-Applications-with-Java-and-Quarkus/tree/master/Chapter02).
  prefs: []
  type: TYPE_NORMAL
- en: Getting started with the Quarkus Maven plugin
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In order to scaffold our first Quarkus application, we will be using Maven,
    which is the most common software and release management tool available. It is
    used by a variety of developers, mostly because it offers the following:'
  prefs: []
  type: TYPE_NORMAL
- en: A standard structure for all your projects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Centralized and automatic management of dependencies
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Maven is distributed in several formats for the user's convenience. You can
    download it from [https://maven.apache.org/download.cgi](https://maven.apache.org/download.cgi).
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you''ve downloaded Maven, do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Unzip the distribution archive (for example, `apache-maven-3.6.1-bin.zip`)
    to the directory that you want Maven to be installed in (for example, in your
    `$HOME/apache` folder):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the Maven libraries to your system path, as shown in the following code.
    This will update the `PATH` environment variable:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Once you have completed your installation, you need to check whether Maven
    has been correctly installed or not. Run `mvn --version` to verify this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: If you get the preceding output, then you have just verified that Maven is installed
    on your system.
  prefs: []
  type: TYPE_NORMAL
- en: Launching the Quarkus Maven plugin
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that Maven has been set up, we can bootstrap our first Quarkus application
    by means of its Maven plugin. A Maven plugin provides a set of goals that can
    be executed to compile and build our artifacts or extend our project with some
    features. Each plugin, like every Maven component, is based on the following coordinates:'
  prefs: []
  type: TYPE_NORMAL
- en: '`groupId`: The ID of the project''s group. This often matches the ID of the
    package root directory.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`artifactId`: The ID of the artifact. This often matches with the final artifact
    name.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`version`: The version of the artifact under the specified group.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You can reference a Maven plugin from the command line by indicating the `<groupId>:<artifactId>`
    coordinates. For Quarkus, the `<groupId>:<artifactId>` combination is `io.quarkus:quarkus-maven-plugin`.
    You can check the available goals and the latest version of it with the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'You will see the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The source code of our first application can be located in the `Chapter02/hello-rest`
    folder of this book''s GitHub repository. For reference, we have created the application
    using the Maven plugin and configured the following set of arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'As a result of the preceding command, the following directory structure has
    been generated in the `hello-rest` folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'In the next section of this chapter, we will learn how to import the project
    into IntelliJ IDEA (the steps are pretty much the same in any IDE, though). Right
    now, let''s stick to the preceding tree view of the project and look at the files
    that are included in this project:'
  prefs: []
  type: TYPE_NORMAL
- en: A **Project Object Model** (`pom.xml`) with the project configuration
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A sample REST service named `SimpleRest.java` and a test class for it named
    `SimpleRestTest.java`, as well as a wrapper class named `NativeSimpleRestIT.java`
    for executing the test against the native executable application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A placeholder for the configuration file (`application.properties`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An `index.html` file to indicate where we can add static web content
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A `Dockerfile` so that we can create a container out of our applications
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A Maven wrapper file (`mvnw/mvnw.cmd`) to allow us to execute Maven goals without
    prior installation of it
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `pom.xml` file will be added to the root of your project. There, you will
    find an upper `dependencyManagement` section, which imports Quarkus' **Bill Of
    Materials**. This allows us to automatically link the exact version of each Quarkus
    extension.
  prefs: []
  type: TYPE_NORMAL
- en: In the 1.0.0.Final version of Quarkus, you will reference the `artifactId` named
    `quarkus-universe-bom`, which belongs to `groupId io.quarkus`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, `quarkus-maven-plugin` has also been included to allow you to package
    your application and generate the native executable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Moving into the dependencies section, you will see that the only runtime dependency
    that''s been added is the following one, which allows you to execute a basic REST
    application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '**RESTEasy** is a portable implementation of the JAX-RS specification that
    is included by default in the WildFly application server ([http://www.wildfly.org](http://www.wildfly.org)).
    You can use it to provide a representation of your service through the standard
    HTTP methods using stateless communication.'
  prefs: []
  type: TYPE_NORMAL
- en: Besides `quarkus-resteasy`, some other libraries have been included in your
    `pom.xml` file for the purpose of testing your applications. This will be discussed
    more in detail in the *Testing Quarkus applications* section.
  prefs: []
  type: TYPE_NORMAL
- en: To add additional libraries to your project, besides editing the `pom.xml` file,
    you can also use `add-extension`, which can be found in Quarkus' Maven plugin.
    An example of this is `$ mvn quarkus:add-extension -Dextensions="io.quarkus:quarkus-jsonp,io.quarkus:quarkus-smallrye-health"`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following `SimpleRest` class has been automatically generated for you in
    `src/main/java/com/packt/quarkus/Chapter02`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, it's a very simple REST endpoint that leverages the JAX-RS API
    to produce a `TEXT_PLAIN` resource when the `/helloworld GET` requests lands on
    the default port.
  prefs: []
  type: TYPE_NORMAL
- en: '**Simpler than JAX-RS!**'
  prefs: []
  type: TYPE_NORMAL
- en: As we mentioned previously, Quarkus simplifies code development to provide sensible
    defaults. However, we don't need to declare an `ApplicationScoped` class to bootstrap
    the REST service anymore since we will get it as the default option.
  prefs: []
  type: TYPE_NORMAL
- en: Running the application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now, we are ready to run our application. Execute the `compile` and `quarkus:dev`
    goals to build it and run it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'After a few seconds, the application will be compiled and executed, as shown
    in the following log:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, you can request the provided endpoint with the browser or a tool such
    as `curl`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: You can stop the application with *Ctrl* + *C*, although we recommend keeping
    it running as we will be testing the **hot reload** feature soon!
  prefs: []
  type: TYPE_NORMAL
- en: Using the Maven plugin to generate a Gradle project
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Quarkus Maven plugin is pretty agnostic in spite of its name. As a matter
    of fact, you can also use it to generate **Gradle** projects. A comparison between
    the two tools is out of the scope of this book; however, a large number of developers
    prefer Gradle as a build tool since it's modeled in a way that is extensible in
    the most fundamental ways and has outstanding performance.
  prefs: []
  type: TYPE_NORMAL
- en: 'That being said, you can generate a Gradle project by simply setting the `buildTool`
    option to `gradle`, which otherwise defaults to `maven`. Here''s how you can generate
    your project with Gradle:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The resulting `build.gradle` file defines the set of available repositories
    and dependencies and sets the core project attributes such as `quarkusPlatformGroupId`,
    `quarkusPlatformArtifactId`, and `quarkusPlatformVersion` as variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: All the preceding variables are retrieved from the `gradle.properties` file,
    which is located at the root of your project.
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see from the configuration, a plugin is also included in the default
    project so that you can easily build your application and start it in development
    mode, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Finally, it is worth mentioning that the Gradle extension is still under development,
    so you may see some changes or updates in the next Quarkus releases.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we will learn how to easily bootstrap our project (either Maven or Gradle)
    using the online Quarkus project generator.
  prefs: []
  type: TYPE_NORMAL
- en: Kick-starting applications using the Quarkus online application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Another option for bootstrapping your Quarkus application is using the online
    application, which is available at the following address: [https://code.quarkus.io/](https://code.quarkus.io/).'
  prefs: []
  type: TYPE_NORMAL
- en: 'By landing on that page, you will be able to generate a basic project with
    an initial endpoint, as well as all the extensions that you checked out in the
    user interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3c622c55-3ea0-45d9-9a42-06292b82d133.png)'
  prefs: []
  type: TYPE_IMG
- en: As shown in the preceding screenshot, by default, just the **RESTEasy** extension
    is selected. From the top-left corner of the interface, you can configure your
    project coordinates (`groupId`, `artifactId`) and the build tool, which can be
    either Maven or Gradle. More options are available through the CONFIGURE MORE
    OPTIONS panel, which lets you configure the package name and the version for the
    project.
  prefs: []
  type: TYPE_NORMAL
- en: By scrolling down the list of available extensions, you can also choose to experiment
    with alternative languages, such as Kotlin or Scala, to develop your Quarkus applications.
    These options are still work in progress, so consider that their API and/or configuration
    may change as the extension matures. The Quarkus team, however, does appreciate
    your feedback if you have tested any preview extension.
  prefs: []
  type: TYPE_NORMAL
- en: 'When you are done setting your options, just click on Start a new application
    to download the artifact as a compressed folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/fa7d5fd7-53b9-45db-aa92-46af103a3160.png)'
  prefs: []
  type: TYPE_IMG
- en: Now, you can just unpack it and import it into your favorite IDE. We will do
    this in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Testing live reload from your IDE
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will use the live reload feature of Quarkus. For this purpose,
    we will import the project into our IDE so that we can apply some changes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Navigate to File | Open and point to the folder where you created the Maven
    project. It will be automatically imported into your IDE. Here is the Files tab
    view of your Java classes:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/67711f22-3b2e-4118-ba1c-3d3d6730d0be.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, let''s look at how live reload works with Quarkus. For this, let''s apply
    a simple change to our code. Here, we have modified the return value for the `hello`
    method, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Hopefully, you haven''t stopped your server. Now, try to call the service once
    more:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, when running in development mode, you can have a live reload
    of your application. Amazing, isn't it?
  prefs: []
  type: TYPE_NORMAL
- en: Live reload also works for resource files such as web pages or the configuration
    property file. Requesting the service triggers a scan of the workspace, and if
    any changes are detected, the Java files are recompiled and the application is
    redeployed. Your request is then serviced by the redeployed application.
  prefs: []
  type: TYPE_NORMAL
- en: Debugging applications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When running in development mode, Quarkus will automatically listen for a debugger
    on port `5005`. You can check that the debugging is active with a basic shell
    command, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s undo these changes in the `hello` method and include another `hello`
    method, which receives a parameter to be inspected as input:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'By using the `@PathParam` expression in our REST service, we will be able to
    debug the value of this expression as a method variable from within our IDE. Now,
    place a breakpoint on the logging statement, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/72d2ab1d-e6b6-460a-8d49-938e69a36da4.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Next, in order to attach the IntelliJ IDEA to the debugger, you have to connect
    to the debugger''s port. In IntelliJ IDEA, you can do this in various ways. The
    simplest way is to select Run | Attach to Process. The runnable process of your
    application will be detected, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/78ff72c9-472d-4f4f-9abf-9b5fb326f637.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Select it and check that you managed to attach to it successfully. You can
    do this from the Debugger Console:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5f7147f7-c716-4343-b4a1-25d0b2d4da2c.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, invoke the application by adding an extra parameter at the end of it so
    that you hit the breakpoint:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'From the debugger prompt, you can inspect the class and method variables from
    its console. You can also control the execution path (Step Over, Step Into, Stop,
    and many more) by clicking on the buttons located on the left-hand side of the
    Debugger Console, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ed190009-53dc-4505-b590-30e79d11bd96.png)'
  prefs: []
  type: TYPE_IMG
- en: If you want to wait for the debugger to attach before starting your Quarkus
    application, you can pass `-Ddebug` on the command line. As soon as your IDE's
    debugger connects, the Quarkus Augmentor will start and your application will
    be executed. On the other hand, if you don't want the debugger at all, you can
    use `-Ddebug=false`.
  prefs: []
  type: TYPE_NORMAL
- en: Testing Quarkus applications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Along with the sample endpoint, the Maven plugin automatically included a test
    class for our REST service:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Under the hood, this test class uses JUnit as the core testing framework and
    the REST Assured library:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: '**REST Assured** is a Java library that can be used to write powerful tests
    for REST APIs using a flexible **Domain Specific Language** (**DSL**). The Fluent
    API that''s available in REST Assured supports the standard patterns from **Behavior-Driven
    Development** (**BDD**) with its `Given/When/Then` syntax. The resulting test
    is simple to read and can include all the steps that we need in order to build
    the test with just one line of code.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we can verify the response body''s content and check that the HTTP response
    status code is 200\. We can verify the test''s execution by running the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'You should see the following output in your console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the test started the Quarkus runtime on the local IP address
    at port `8081`. Therefore, it doesn't interfere with the development/production
    environment that runs on port `8080` by default.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can mix and match multiple conditions in your tests by concatenating them
    using the `and()` method. This method works as simple syntactic sugar, that is,
    it helps make the code more readable. Here''s an example of how to include a check
    on the header''s `Content-Length`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'By using parameterized tests, you can test multiple scenarios within a single
    method by providing different sets of records. REST Assured supports two different
    types of parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Query parameters**: These can be appended at the end of a RESTful API endpoint
    and are identified by the question mark in front of them. Here''s an example:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, using query parameters only requires that we specify their name
    and value by concatenating the `param()` method.
  prefs: []
  type: TYPE_NORMAL
- en: '**Path parameters**: These are specified in a similar fashion, that is, by
    including the `pathParam()` method with the parameter name/value combination:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, it''s worth mentioning that, since Quarkus aims at top performance,
    you can also validate your tests based on the response time. This can be done
    by concatenating `time()` to your condition. Here is an example that sets the
    time to be less than one second when it comes to returning the response:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: In this section, we have covered the most common testing scenarios that we can
    build with the REST Assured API. If you want to checkout some more advanced patterns,
    we recommend having a look at its Wiki, which is available at [https://github.com/rest-assured/rest-assured/wiki/usage](https://github.com/rest-assured/rest-assured/wiki/usage).
  prefs: []
  type: TYPE_NORMAL
- en: Choosing a different port for testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You can change the default port that''s used for testing by Quarkus (`8081`)
    by setting an appropriate value in the `src/main/resources/application.properties`
    file, which is the general configuration file for Quarkus. For example, in order
    to shift the test port to `9081`, you would need to add the following information
    to `application.properties`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: As an alternative, you can also use the same property at startup by passing
    the `-Dquarkus.http.test-port=9081` flag.
  prefs: []
  type: TYPE_NORMAL
- en: Turning your application into a native executable
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now, it''s time to check what Quarkus can do to turn our bytecode into a native
    executable. This kind of magic is done under the hood by a Maven profile named
    `native`, which is included out of the box when you scaffold your application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: In addition, `maven-failsafe-plugin` has been automatically configured to run
    `integration-test goal` since we've set the path where the native image has been
    built as the system property.
  prefs: []
  type: TYPE_NORMAL
- en: Before building your executable, verify that you have set `GRAALVM_HOME` in
    your environment, as described in the previous chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, create a native executable by executing the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: The plugin will start analyzing the classes and packaging that's used in your
    application, along with the call tree. The resulting output will be a super lean
    executable that contains just a thin JVM layer (narrow enough to just execute
    the application) and the application itself.
  prefs: []
  type: TYPE_NORMAL
- en: 'You should see something similar to the following at the end of your output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Along with the JAR file containing the compressed bytecode for your application,
    the following executable will be generated in the `target` folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: The actual name of your application can be varied by setting the `native.image.path`
    environment variable in your `pom.xml` file, which is `${project.build.directory}/${project.build.finalName}-runner`
    by default.
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see, with approximately 20 MB, we have an executable application
    runtime that contains all the libraries and just what it needs from the JVM to
    run our application. You can execute it with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'In as little as 0.006s, we got our service up and running. This can be seen
    in the console log:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s check the memory usage of this compact application by executing the
    `ps` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the output I have collected from my laptop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Although the output may vary depending on your environment, the **Resident Set
    Size** (**RSS**) shows that the process is taking about 18 MB of memory, which
    is a fraction of the minimum memory size required for a Java application.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s execute it to check the result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the result didn't change when we turned our application into
    a native application.
  prefs: []
  type: TYPE_NORMAL
- en: Executing integration tests against the native executable
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Interestingly, native executable code can be tested. When you generated the
    sample project, a `Native<project>Test` class name was included in the test folder.
    This class differs from Java tests as it's annotated with the `@NativeImageTest`
    annotation.
  prefs: []
  type: TYPE_NORMAL
- en: As a result of the Maven failsafe plugin configuration, all rests ending in
    **IT* or annotated with `@NativeImageTest` will be run against the native executable.
  prefs: []
  type: TYPE_NORMAL
- en: 'In terms of code, there''s no need to make any changes as it uses inheritance
    to execute the native executable tests from our `SimpleRestTest` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'The `verify` goal is required to test native executables. Before that, make
    sure you have exported the path where GraalVM has been installed into your environment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, you can run the `verify` goal to test the native executable application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Check that the outcome is the same one that we produced in the *Testing Quarkus
    applications* section, earlier in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Great! We have just managed to test our sample application in both scenarios
    (JVM and native executable).
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we went through our first proof of concept Quarkus project,
    which was generated through `quarkus-maven-plugin`. The default application is
    a prototype of the REST service with all the minimal functionalities and a `Test`
    class that we have progressively enriched. In the second part of this chapter,
    we saw how to turn the Java application code into a thin native executable using
    the appropriate native profile of `quarkus-maven-plugin`.
  prefs: []
  type: TYPE_NORMAL
- en: So far, we have only scratched the surface of what we can do with Quarkus. Now,
    it's time to move on and learn how to create a Container image out of our native
    application and deploy it in a Kubernetes environment. This is what we are going
    to discuss in the next chapter.
  prefs: []
  type: TYPE_NORMAL
