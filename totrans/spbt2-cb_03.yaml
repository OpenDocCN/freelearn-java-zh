- en: Web Framework Behavior Tuning
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will learn about the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Configuring route matching patterns
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuring custom static path mappings
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tuning Tomcat via ServletWebServerFactory
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Choosing embedded servlet containers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding custom connectors
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [Chapter 2](bd85f38d-1b98-47d6-a98a-b22f4478f68e.xhtml), *Configuring Web
    Applications*, we explored how to configure web applications in Spring Boot with
    our custom filters, interceptors, and so on. We will continue to look further
    into enhancing our web application by doing behavior tuning, configuring the custom
    routing rules and patterns, adding additional static asset paths, adding and modifying
    servlet container connectors, and other properties such as enabling SSL.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring route matching patterns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When we build web applications, it is not always the case that a default out-of-the-box
    mapping configuration is applicable. At times, we want to create RESTful URLs
    that contain characters such as dot (`.`), which Spring treats as a delimiter-defining
    format, like `path.xml`; or we might not want to recognize a trailing slash, and
    so on. Conveniently, Spring provides us with a way to accomplish this with ease.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 2](bd85f38d-1b98-47d6-a98a-b22f4478f68e.xhtml), *Configuring Web
    Applications*, we introduced a `WebConfiguration` class, which extends from `WebMvcConfigurerAdapter`.
    This extension allows us to override methods that are geared toward adding filters,
    formatters, and many more. It also has methods that can be overridden in order
    to configure the path match, among other things.
  prefs: []
  type: TYPE_NORMAL
- en: Let's imagine that the ISBN format does allow the use of dots to separate the
    book number from the revision with a pattern looking like `[isbn-number].[revision]`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will configure our application to not use the suffix pattern match of `.*`
    and to not strip the values after the dot when parsing the parameters. Let''s
    perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s add the necessary configuration to our `WebConfiguration` class with
    the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Start the application by running `./gradlew clean bootRun`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let''s open `http://localhost:8080/books/978-1-78528-415-1.1` in the browser
    to see the following results:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/c52ee837-9990-4b10-b1f9-51044d7eb0e8.png)'
  prefs: []
  type: TYPE_IMG
- en: 'If we enter the correct ISBN, we will see a different result, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/e98c6bbe-749f-4f4a-a5eb-08980ad983a1.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s look at what we did in detail. The `configurePathMatch(PathMatchConfigurer
    configurer)` method gives us the ability to set our own behavior in how we want
    Spring to match the request URL path to the controller parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`configurer.setUseSuffixPatternMatch(false)`: This method indicates that we
    don''t want to use the `.*` suffix, so as to strip the trailing characters after
    the last dot. This means that Spring parses out the entire `978-1-78528-415-1.1`
    ISBN as an `{isbn}` parameter for `BookController`. So, `http://localhost:8080/books/978-1-78528-415-1.1`
    and `http://localhost:8080/books/978-1-78528-415-1` will become different URLs.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`configurer.setUseTrailingSlashMatch(true)`: This method indicates that we
    want to use the trailing `/` symbol in the URL as a match as if it were not there.
    This effectively makes `http://localhost:8080/books/978-1-78528-415-1` the same
    as `http://localhost:8080/books/978-1-78528-415-1/`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you want to do further configuration of how the path matching takes place,
    you can provide your own implementation of `PathMatcher` and `UrlPathHelper`,
    but these would be required in the most extreme and custom-tailored situations
    and are not generally recommended.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring custom static path mappings
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous recipe, we looked at how to tune the URL path mapping for requests
    and translate them into controller methods. It is also possible to control how
    our web application deals with static assets and the files that exist on the filesystem
    or are bundled in the deployable archive.
  prefs: []
  type: TYPE_NORMAL
- en: Let's say that we want to expose our internal `application.properties` file
    via the static web URL of `http://localhost:8080/internal/application.properties`
    from our application. To get started with this, proceed with the steps in the
    next section.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s add a new method, `addResourceHandlers`, to the `WebConfiguration` class
    with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Start the application by running `./gradlew clean bootRun`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let''s open `http://localhost:8080/internal/application.properties` in the
    browser to see the following results:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/79dd9179-12be-47de-8845-f1e1e9e9717b.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The method that we overrode, `addResourceHandlers(ResourceHandlerRegistry registry)`,
    is another configuration method from `WebMvcConfigurer`, which gives us the ability
    to define custom mappings for static resource URLs and connect them with the resources
    on the filesystem or application classpath. In our case, we defined a mapping
    of anything that is being accessed via the `/ internal` URL to be looked for in
    the `classpath:/` path of our application (for the production environment, you
    probably don't want to expose the entire classpath as a static resource!).
  prefs: []
  type: TYPE_NORMAL
- en: 'So let''s look at what we did in detail, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The `registry.addResourceHandler("/internal/**")` method adds a resource handler
    to the registry to handle our static resources, and returns  `ResourceHandlerRegistration`
    to us, which can be used to further configure the mapping in a chained fashion.
    The `/internal/**` is a path pattern that will be used to match against the request
    URL using `PathMatcher`. We have seen how `PathMatcher` can be configured in the
    previous example, but by default an `AntPathMatcher` implementation is used. We
    can configure more than one URL pattern to be matched to a particular resource
    location.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `addResourceLocations("classpath:/")` method is called on the newly created
    instance of `ResourceHandlerRegistration`, and it defines the directories where
    the resources should be loaded from. These should be valid filesystems or classpath
    directories, and more than one can be entered. If multiple locations are provided,
    they will be checked in the order in which they were entered.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can also configure a caching interval for the given resource using the `setCachePeriod(Integer
    cachePeriod)` method.
  prefs: []
  type: TYPE_NORMAL
- en: Tuning Tomcat via ServletWebServerFactory
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Spring Boot exposes many of the server properties that can be used to configure
    things such as PORT, SSL, and others by simply setting the values in `application.properties`.
    However, if we need to do any more complex tuning, Spring Boot provides us with
    a `ServletWebServerFactory` interface to programmatically define our configuration.
  prefs: []
  type: TYPE_NORMAL
- en: Even though the session timeout can be easily configured by setting the `server.session.timeout`
    property in `application.properties` to our desired value in seconds, we will
    do it using `ServletWebServerFactory` to demonstrate how it is done.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s say that we want our session to be for one minute. To make this happen,
    we will ad a `ServletWebServerFactory` bean to our `WebConfiguration` class with
    the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Just for the purpose of demonstration, we will get the session from the request
    to force its creation. To do this, we will add a new request mapping to our `BookController`
    class with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Start the application by running `./gradlew clean bootRun`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let''s open `http://localhost:8080/books/session` in the browser to see the
    following results:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/1aa9c9a0-7a91-42e4-98a9-254bda718229.png)'
  prefs: []
  type: TYPE_IMG
- en: If we wait for more than a minute and then reload this page, the session ID
    will change to a different one.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `ServletWebServerFactory` interface defines the `WebServer getWebServer(ServletContextInitializer...
    initializers)` method. Out of the box, Spring Boot provides concrete factory implementations
    for the `TomcatServletWebServerFactory`, `JettyServletWebServerFactory`, and `UndertowServletWebServerFactory`
    application servers. Since we are using Tomcat in our example, we will be using
    the provided `TomcatServletWebServerFactory` class to configure the behavior of
    the session.
  prefs: []
  type: TYPE_NORMAL
- en: During application startup, Spring Boot autoconfiguration detects the presence
    of the factory and invokes the `getWebServer(...)` method, passing the reference
    to a collection of `ServletContextInitializer` beans. Typically, those initializers
    are created and managed by Spring Boot internally, but we can always create some
    custom `ServletContextInitializer` beans to add custom behavior that should be
    executed during the startup life cycle of the application server.
  prefs: []
  type: TYPE_NORMAL
- en: Choosing embedded servlet containers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If we decide that we want to use Jetty as our servlet container, we will need
    to add a Jetty starter to our `build` file.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As Tomcat already comes as a transitive dependency of Spring Boot, we will
    need to exclude it from our `build` dependency tree by adding the following to
    `build.gradle`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'We will also need to add a `compile` dependency to our `build` dependencies
    on Jetty:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: To fix the compiler errors, we will need to remove the bean declaration of Tomcat's
    `RemoteIpFilter` from our `WebConfiguration` class, as the Tomcat dependency has
    been removed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Start the application by running `./gradlew clean bootRun`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'If we now look at the console logs, we will see that our application is running
    in Jetty:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The reason that this works is because of Spring Boot's autoconfiguration magic.
    We had to remove the Tomcat dependency from the `build` file in order to prevent
    a dependency collision between Tomcat and Jetty. Spring Boot does a conditional
    scan of the classes in the classpath and depending on what it detects, it determines
    which servlet container will be used.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we look in the `ServletWebServerFactoryAutoConfiguration` class, we will
    see the following conditional code that checks this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The `@ConditionalOnClass` annotation tells Spring Boot to use only the `EmbeddedJetty`
    configuration if the classes of Jetty, namely `org.eclipse.jetty.server.Server`
    and `org.eclipse.jetty.util.Loader`, are present in the classpath.
  prefs: []
  type: TYPE_NORMAL
- en: Adding custom connectors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Another very common scenario in the enterprise application development and
    deployment is to run the application with two separate HTTP port connectors: one
    for HTTP and the other for HTTPS'
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will start by going back to using Tomcat; so for this recipe, we will undo
    the changes that we implemented in the previous example.
  prefs: []
  type: TYPE_NORMAL
- en: In order to create an HTTPS connector, we will need a few things; but most importantly,
    we will need to generate the certificate keystore that is used to encrypt and
    decrypt the SSL communication with the browser.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you are using Unix or macOS, you can do it by running the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'On Windows, this can be achieved via the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'During the creation of the keystore, you should enter the information that
    is appropriate to you, including passwords, name, and so on. For the purpose of
    this book, we will use the default password: `changeit`. Once the execution is
    complete, a newly generated keystore file will appear in your home directory under
    the name: `keystore`.'
  prefs: []
  type: TYPE_NORMAL
- en: You can find more information about preparing the certificate keystore at [https://tomcat.apache.org/tomcat-8.0-doc/ssl-howto.html#Prepare_the_Certificate_Keystore](https://tomcat.apache.org/tomcat-8.0-doc/ssl-howto.html#Prepare_the_Certificate_Keystore).
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'With the keystore creation complete, we will need to create a separate `properties`
    file in order to store our configuration for the HTTPS connectors, such as port.
    After that, we will create a configuration property binding object and use it
    to configure our new connector. Perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we will create a new properties file named `tomcat.https.properties`
    in the `src/main/resources` directory from the root of our project with the following
    content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we will create a nested static class named `TomcatSslConnectorProperties`
    in our `WebConfiguration` class with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we will need to add our newly created `tomcat.http.properties` file as
    a Spring Boot property source and enable `TomcatSslConnectorProperties` to be
    bound. This can be done by adding the following code right prior to the class
    declaration of the `WebConfiguration` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we will need to modify a `ServletWebServerFactory` Spring bean, where
    we will add our HTTPS connector. We will do that by changing the following code
    in the `WebConfiguration` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Start the application by running `./gradlew clean bootRun`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let''s open `https://localhost:8443/internal/tomcat.https.properties` in the
    browser to see the following results:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/df9a6406-13c4-482a-a005-259cec02915c.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we did a number of things; so let's break them down one change
    at a time.
  prefs: []
  type: TYPE_NORMAL
- en: The first change, ignoring the need to create the keystore, was the creation
    of the `tomcat.https.properties` and `TomcatSslConnectorProperties` objects to
    bind them to. Previously, we already dealt with making changes to the various
    settings in `application.properties` when configuring our datasource. At that
    time, though, we did not have to create any binding objects because Spring Boot
    already had them defined.
  prefs: []
  type: TYPE_NORMAL
- en: 'As we learned earlier, Spring Boot already exposes many properties to configure
    the application settings, including a whole set of settings for the `server` section.
    These values get bound to an internal Spring Boot class: `ServerProperties`'
  prefs: []
  type: TYPE_NORMAL
- en: A complete list of the common application properties can be found in the Spring
    Boot reference documentation at [http://docs.spring.io/spring-boot/docs/current/reference/html/common-application-properties.html](http://docs.spring.io/spring-boot/docs/current/reference/html/common-application-properties.html).
  prefs: []
  type: TYPE_NORMAL
- en: What we did with our addition was simply mimic Spring Boot and create our own
    configuration group with a binding object behind it. The reason that we didn't
    use the already existing `server.tomcat.` prefix, and instead opt for `custom.tomcat`,
    was mostly governed by the need to separate our config values from the default
    ones. Since we are adding a second connector, we want to have a clean separation
    between the default configuration properties and our custom ones.
  prefs: []
  type: TYPE_NORMAL
- en: The `@ConfigurationProperties(prefix = "custom.tomcat.https")` method is an
    important annotation for our `TomcatSslConnectorProperties` object. It tells Spring
    Boot to automatically bind the properties with the `custom.tomcat.https` prefix
    to fields that are declared in `TomcatSslConnectorProperties`. In order for the
    binding to take place—in addition to defining the fields in the class—it is very
    important to define the getters and setters as well. It is also worth mentioning
    that during the binding process, Spring will automatically try to convert the
    property values to their appropriate data types. For example, the value of `custom.tomcat.https.keystore`
    gets automatically bound to a private file keystore field object.
  prefs: []
  type: TYPE_NORMAL
- en: The converters, which we learned about earlier, will also be used during the
    process of converting to custom-defined data types.
  prefs: []
  type: TYPE_NORMAL
- en: The next step is to tell Spring Boot to include the properties that are defined
    in `tomcat.https.properties` in the list of properties. This is achieved by adding
    `@PropertySource("classpath:/tomcat.https.properties")` next to `@Configuration`
    in the `WebConfiguration` class.
  prefs: []
  type: TYPE_NORMAL
- en: 'After the values are imported, we will need to tell Spring Boot to automatically
    create an instance of `TomcatSslConnectorProperties` for us to use. This is done
    by adding the following annotation next to `@Configuration`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: This will instruct Spring Boot to automatically create a bean of type `TomcatSslConnectorProperties`
    and bind it with the values from the specified `classpath:/tomcat.https.properties`
    file. This bean can later be used for autowiring into different places, such as
    when we create a `ServletWebServerFactory` bean.
  prefs: []
  type: TYPE_NORMAL
- en: After all the property support is set and done, we will proceed with the actual
    code to create a second connector. The creation of the `ServletWebServerFactory`
    bean provides Spring Boot with a factory to use in order to create  `WebServer`.
    The convenient `configureConnector(Connector connector)` method, which we added
    to `TomcatSslConnectorProperties`, gives us a good place to encapsulate and consolidate
    all the settings that are needed to configure the newly created `Connector` instance.
  prefs: []
  type: TYPE_NORMAL
