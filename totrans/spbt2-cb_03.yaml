- en: Web Framework Behavior Tuning
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调整Web框架行为
- en: 'In this chapter, we will learn about the following topics:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习以下主题：
- en: Configuring route matching patterns
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置路由匹配模式
- en: Configuring custom static path mappings
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置自定义静态路径映射
- en: Tuning Tomcat via ServletWebServerFactory
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过ServletWebServerFactory调整Tomcat
- en: Choosing embedded servlet containers
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 选择嵌入式servlet容器
- en: Adding custom connectors
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加自定义连接器
- en: Introduction
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: In [Chapter 2](bd85f38d-1b98-47d6-a98a-b22f4478f68e.xhtml), *Configuring Web
    Applications*, we explored how to configure web applications in Spring Boot with
    our custom filters, interceptors, and so on. We will continue to look further
    into enhancing our web application by doing behavior tuning, configuring the custom
    routing rules and patterns, adding additional static asset paths, adding and modifying
    servlet container connectors, and other properties such as enabling SSL.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第2章](bd85f38d-1b98-47d6-a98a-b22f4478f68e.xhtml) *配置Web应用程序* 中，我们探讨了如何在Spring
    Boot中使用自定义过滤器、拦截器等配置Web应用程序。我们将继续深入了解通过行为调整、配置自定义路由规则和模式、添加额外的静态资产路径、添加和修改servlet容器连接器以及其他属性（如启用SSL）来增强我们的Web应用程序。
- en: Configuring route matching patterns
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置路由匹配模式
- en: When we build web applications, it is not always the case that a default out-of-the-box
    mapping configuration is applicable. At times, we want to create RESTful URLs
    that contain characters such as dot (`.`), which Spring treats as a delimiter-defining
    format, like `path.xml`; or we might not want to recognize a trailing slash, and
    so on. Conveniently, Spring provides us with a way to accomplish this with ease.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们构建Web应用程序时，并不总是默认的即插即用的映射配置适用。有时，我们希望创建包含点（`.`）等字符的RESTful URL，Spring将其视为分隔符定义格式，如`path.xml`；或者我们可能不想识别尾随斜杠等。方便的是，Spring提供了一种轻松实现此功能的方法。
- en: In [Chapter 2](bd85f38d-1b98-47d6-a98a-b22f4478f68e.xhtml), *Configuring Web
    Applications*, we introduced a `WebConfiguration` class, which extends from `WebMvcConfigurerAdapter`.
    This extension allows us to override methods that are geared toward adding filters,
    formatters, and many more. It also has methods that can be overridden in order
    to configure the path match, among other things.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第2章](bd85f38d-1b98-47d6-a98a-b22f4478f68e.xhtml) *配置Web应用程序* 中，我们介绍了`WebConfiguration`类，它继承自`WebMvcConfigurerAdapter`。这种扩展允许我们覆盖旨在添加过滤器、格式化程序等的方法。它还具有可以覆盖的方法，例如配置路径匹配等。
- en: Let's imagine that the ISBN format does allow the use of dots to separate the
    book number from the revision with a pattern looking like `[isbn-number].[revision]`.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们假设ISBN格式确实允许使用点来分隔书号和修订版，其模式看起来像`[isbn-number].[revision]`。
- en: How to do it...
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'We will configure our application to not use the suffix pattern match of `.*`
    and to not strip the values after the dot when parsing the parameters. Let''s
    perform the following steps:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将配置应用程序不使用`.*`后缀模式匹配，并在解析参数时不要删除点后面的值。让我们执行以下步骤：
- en: 'Let''s add the necessary configuration to our `WebConfiguration` class with
    the following content:'
  id: totrans-15
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们在`WebConfiguration`类中添加必要的配置，内容如下：
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Start the application by running `./gradlew clean bootRun`.
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过运行`./gradlew clean bootRun`启动应用程序。
- en: 'Let''s open `http://localhost:8080/books/978-1-78528-415-1.1` in the browser
    to see the following results:'
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们在浏览器中打开`http://localhost:8080/books/978-1-78528-415-1.1`以查看以下结果：
- en: '![](img/c52ee837-9990-4b10-b1f9-51044d7eb0e8.png)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c52ee837-9990-4b10-b1f9-51044d7eb0e8.png)'
- en: 'If we enter the correct ISBN, we will see a different result, as follows:'
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们输入正确的ISBN，我们将看到不同的结果，如下所示：
- en: '![](img/e98c6bbe-749f-4f4a-a5eb-08980ad983a1.png)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e98c6bbe-749f-4f4a-a5eb-08980ad983a1.png)'
- en: How it works...
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'Let''s look at what we did in detail. The `configurePathMatch(PathMatchConfigurer
    configurer)` method gives us the ability to set our own behavior in how we want
    Spring to match the request URL path to the controller parameters:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们详细看看我们做了什么。`configurePathMatch(PathMatchConfigurer configurer)`方法使我们能够设置自己的行为，以便Spring能够根据我们的需求将请求URL路径与控制器参数匹配：
- en: '`configurer.setUseSuffixPatternMatch(false)`: This method indicates that we
    don''t want to use the `.*` suffix, so as to strip the trailing characters after
    the last dot. This means that Spring parses out the entire `978-1-78528-415-1.1`
    ISBN as an `{isbn}` parameter for `BookController`. So, `http://localhost:8080/books/978-1-78528-415-1.1`
    and `http://localhost:8080/books/978-1-78528-415-1` will become different URLs.'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`configurer.setUseSuffixPatternMatch(false)`: 这个方法表示我们不希望使用 `.*` 后缀，因此会移除最后一个点后面的尾随字符。这意味着Spring将整个
    `978-1-78528-415-1.1` ISBN解析为 `{isbn}` 参数用于 `BookController`。因此，`http://localhost:8080/books/978-1-78528-415-1.1`
    和 `http://localhost:8080/books/978-1-78528-415-1` 将成为不同的URL。'
- en: '`configurer.setUseTrailingSlashMatch(true)`: This method indicates that we
    want to use the trailing `/` symbol in the URL as a match as if it were not there.
    This effectively makes `http://localhost:8080/books/978-1-78528-415-1` the same
    as `http://localhost:8080/books/978-1-78528-415-1/`.'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`configurer.setUseTrailingSlashMatch(true)`: 这个方法表示我们想要将URL末尾的 `/` 符号用作匹配，就像它不存在一样。这实际上使得
    `http://localhost:8080/books/978-1-78528-415-1` 与 `http://localhost:8080/books/978-1-78528-415-1/`
    相同。'
- en: If you want to do further configuration of how the path matching takes place,
    you can provide your own implementation of `PathMatcher` and `UrlPathHelper`,
    but these would be required in the most extreme and custom-tailored situations
    and are not generally recommended.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要进一步配置路径匹配的方式，你可以提供自己的 `PathMatcher` 和 `UrlPathHelper` 实现，但这些通常只在最极端和定制化的情况下需要，并且通常不推荐这样做。
- en: Configuring custom static path mappings
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置自定义静态路径映射
- en: In the previous recipe, we looked at how to tune the URL path mapping for requests
    and translate them into controller methods. It is also possible to control how
    our web application deals with static assets and the files that exist on the filesystem
    or are bundled in the deployable archive.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的配方中，我们探讨了如何调整URL路径映射以请求并将它们转换为控制器方法。也可以控制我们的Web应用程序如何处理静态资源和存在于文件系统或打包在可部署归档中的文件。
- en: Let's say that we want to expose our internal `application.properties` file
    via the static web URL of `http://localhost:8080/internal/application.properties`
    from our application. To get started with this, proceed with the steps in the
    next section.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想要通过我们应用程序的静态Web URL `http://localhost:8080/internal/application.properties`
    暴露我们的内部 `application.properties` 文件。为了开始这个过程，请按照下一节中的步骤进行操作。
- en: How to do it...
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Let''s add a new method, `addResourceHandlers`, to the `WebConfiguration` class
    with the following content:'
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们在 `WebConfiguration` 类中添加一个新的方法 `addResourceHandlers`，内容如下：
- en: '[PRE1]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Start the application by running `./gradlew clean bootRun`
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过运行 `./gradlew clean bootRun` 启动应用程序
- en: 'Let''s open `http://localhost:8080/internal/application.properties` in the
    browser to see the following results:'
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们在浏览器中打开 `http://localhost:8080/internal/application.properties` 来查看以下结果：
- en: '![](img/79dd9179-12be-47de-8845-f1e1e9e9717b.png)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/79dd9179-12be-47de-8845-f1e1e9e9717b.png)'
- en: How it works...
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The method that we overrode, `addResourceHandlers(ResourceHandlerRegistry registry)`,
    is another configuration method from `WebMvcConfigurer`, which gives us the ability
    to define custom mappings for static resource URLs and connect them with the resources
    on the filesystem or application classpath. In our case, we defined a mapping
    of anything that is being accessed via the `/ internal` URL to be looked for in
    the `classpath:/` path of our application (for the production environment, you
    probably don't want to expose the entire classpath as a static resource!).
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 我们重写的方法 `addResourceHandlers(ResourceHandlerRegistry registry)` 是来自 `WebMvcConfigurer`
    的另一种配置方法，它赋予我们定义自定义映射以静态资源URL并连接到文件系统或应用程序类路径上的资源的能力。在我们的例子中，我们定义了一个映射，将所有通过 `/internal`
    URL 访问的内容映射到我们应用程序的 `classpath:/` 路径上（对于生产环境，你可能不想将整个类路径作为静态资源暴露！）。
- en: 'So let''s look at what we did in detail, as follows:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们详细看看我们做了什么，如下所示：
- en: The `registry.addResourceHandler("/internal/**")` method adds a resource handler
    to the registry to handle our static resources, and returns  `ResourceHandlerRegistration`
    to us, which can be used to further configure the mapping in a chained fashion.
    The `/internal/**` is a path pattern that will be used to match against the request
    URL using `PathMatcher`. We have seen how `PathMatcher` can be configured in the
    previous example, but by default an `AntPathMatcher` implementation is used. We
    can configure more than one URL pattern to be matched to a particular resource
    location.
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`registry.addResourceHandler("/internal/**")` 方法向注册表中添加一个资源处理器来处理我们的静态资源，并返回
    `ResourceHandlerRegistration` 给我们，这可以用来进一步以链式方式配置映射。`/internal/**` 是一个路径模式，它将使用
    `PathMatcher` 来与请求 URL 进行匹配。我们在前面的示例中已经看到了如何配置 `PathMatcher`，但默认情况下使用的是 `AntPathMatcher`
    实现。我们可以配置多个 URL 模式以匹配特定的资源位置。'
- en: The `addResourceLocations("classpath:/")` method is called on the newly created
    instance of `ResourceHandlerRegistration`, and it defines the directories where
    the resources should be loaded from. These should be valid filesystems or classpath
    directories, and more than one can be entered. If multiple locations are provided,
    they will be checked in the order in which they were entered.
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在新创建的 `ResourceHandlerRegistration` 实例上调用 `addResourceLocations("classpath:/")`
    方法，它定义了资源应该从哪些目录加载。这些应该是有效的文件系统或类路径目录，并且可以输入多个。如果提供了多个位置，它们将按照输入的顺序进行检查。
- en: We can also configure a caching interval for the given resource using the `setCachePeriod(Integer
    cachePeriod)` method.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用 `setCachePeriod(Integer cachePeriod)` 方法为给定的资源配置一个缓存间隔。
- en: Tuning Tomcat via ServletWebServerFactory
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过 ServletWebServerFactory 调优 Tomcat
- en: Spring Boot exposes many of the server properties that can be used to configure
    things such as PORT, SSL, and others by simply setting the values in `application.properties`.
    However, if we need to do any more complex tuning, Spring Boot provides us with
    a `ServletWebServerFactory` interface to programmatically define our configuration.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Boot 通过在 `application.properties` 中简单地设置值来公开许多服务器属性，可以用来配置诸如 PORT、SSL
    等事物。然而，如果我们需要进行更复杂的调优，Spring Boot 提供了一个 `ServletWebServerFactory` 接口，可以用来程序化地定义我们的配置。
- en: Even though the session timeout can be easily configured by setting the `server.session.timeout`
    property in `application.properties` to our desired value in seconds, we will
    do it using `ServletWebServerFactory` to demonstrate how it is done.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管会话超时可以通过在 `application.properties` 中设置 `server.session.timeout` 属性为所需的秒数来轻松配置，但我们将使用
    `ServletWebServerFactory` 来演示如何进行配置。
- en: How to do it...
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到...
- en: 'Let''s say that we want our session to be for one minute. To make this happen,
    we will ad a `ServletWebServerFactory` bean to our `WebConfiguration` class with
    the following content:'
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 假设我们想让会话持续一分钟。为了实现这一点，我们将在 `WebConfiguration` 类中添加一个 `ServletWebServerFactory`
    bean，内容如下：
- en: '[PRE2]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Just for the purpose of demonstration, we will get the session from the request
    to force its creation. To do this, we will add a new request mapping to our `BookController`
    class with the following content:'
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 仅为了演示目的，我们将从请求中获取会话以强制其创建。为此，我们将在 `BookController` 类中添加一个新的请求映射，内容如下：
- en: '[PRE3]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Start the application by running `./gradlew clean bootRun`.
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过运行 `./gradlew clean bootRun` 来启动应用程序。
- en: 'Let''s open `http://localhost:8080/books/session` in the browser to see the
    following results:'
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们在浏览器中打开 `http://localhost:8080/books/session` 来查看以下结果：
- en: '![](img/1aa9c9a0-7a91-42e4-98a9-254bda718229.png)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1aa9c9a0-7a91-42e4-98a9-254bda718229.png)'
- en: If we wait for more than a minute and then reload this page, the session ID
    will change to a different one.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们等待超过一分钟然后重新加载这个页面，会话 ID 将会变为另一个。
- en: How it works...
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The `ServletWebServerFactory` interface defines the `WebServer getWebServer(ServletContextInitializer...
    initializers)` method. Out of the box, Spring Boot provides concrete factory implementations
    for the `TomcatServletWebServerFactory`, `JettyServletWebServerFactory`, and `UndertowServletWebServerFactory`
    application servers. Since we are using Tomcat in our example, we will be using
    the provided `TomcatServletWebServerFactory` class to configure the behavior of
    the session.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '`ServletWebServerFactory` 接口定义了 `WebServer getWebServer(ServletContextInitializer...
    initializers)` 方法。Spring Boot 默认提供了 `TomcatServletWebServerFactory`、`JettyServletWebServerFactory`
    和 `UndertowServletWebServerFactory` 应用服务器的具体工厂实现。由于我们在示例中使用 Tomcat，我们将使用提供的 `TomcatServletWebServerFactory`
    类来配置会话的行为。'
- en: During application startup, Spring Boot autoconfiguration detects the presence
    of the factory and invokes the `getWebServer(...)` method, passing the reference
    to a collection of `ServletContextInitializer` beans. Typically, those initializers
    are created and managed by Spring Boot internally, but we can always create some
    custom `ServletContextInitializer` beans to add custom behavior that should be
    executed during the startup life cycle of the application server.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在应用程序启动期间，Spring Boot 自动配置检测到工厂的存在，并调用 `getWebServer(...)` 方法，传递一个 `ServletContextInitializer`
    bean 集合的引用。通常，这些初始化器是由 Spring Boot 内部创建和管理的，但我们可以始终创建一些自定义的 `ServletContextInitializer`
    bean 来添加应在应用程序服务器启动生命周期中执行的自定义行为。
- en: Choosing embedded servlet containers
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 选择嵌入式 servlet 容器
- en: If we decide that we want to use Jetty as our servlet container, we will need
    to add a Jetty starter to our `build` file.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们决定要使用 Jetty 作为我们的 servlet 容器，我们需要在我们的 `build` 文件中添加一个 Jetty starter。
- en: How to do it...
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'As Tomcat already comes as a transitive dependency of Spring Boot, we will
    need to exclude it from our `build` dependency tree by adding the following to
    `build.gradle`:'
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于 Tomcat 已经是 Spring Boot 的传递依赖项，我们需要通过在 `build.gradle` 中添加以下内容来从我们的 `build`
    依赖项树中排除它：
- en: '[PRE4]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'We will also need to add a `compile` dependency to our `build` dependencies
    on Jetty:'
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还需要在我们的 `build` 依赖项中添加一个对 Jetty 的 `compile` 依赖项：
- en: '[PRE5]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: To fix the compiler errors, we will need to remove the bean declaration of Tomcat's
    `RemoteIpFilter` from our `WebConfiguration` class, as the Tomcat dependency has
    been removed.
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了修复编译错误，我们需要从我们的 `WebConfiguration` 类中移除 Tomcat 的 `RemoteIpFilter` 的 bean 声明，因为已经移除了
    Tomcat 依赖。
- en: Start the application by running `./gradlew clean bootRun`
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过运行 `./gradlew clean bootRun` 启动应用程序
- en: 'If we now look at the console logs, we will see that our application is running
    in Jetty:'
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们现在查看控制台日志，我们会看到我们的应用程序正在 Jetty 中运行：
- en: '[PRE6]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: How it works...
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The reason that this works is because of Spring Boot's autoconfiguration magic.
    We had to remove the Tomcat dependency from the `build` file in order to prevent
    a dependency collision between Tomcat and Jetty. Spring Boot does a conditional
    scan of the classes in the classpath and depending on what it detects, it determines
    which servlet container will be used.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 这之所以能工作，是因为 Spring Boot 的自动配置魔法。我们必须从 `build` 文件中移除 Tomcat 依赖，以防止 Tomcat 和 Jetty
    之间的依赖冲突。Spring Boot 对类路径中的类进行条件扫描，并根据其检测到的结果确定将使用哪个 servlet 容器。
- en: 'If we look in the `ServletWebServerFactoryAutoConfiguration` class, we will
    see the following conditional code that checks this:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们查看 `ServletWebServerFactoryAutoConfiguration` 类，我们会看到以下检查此条件的代码：
- en: '[PRE7]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The `@ConditionalOnClass` annotation tells Spring Boot to use only the `EmbeddedJetty`
    configuration if the classes of Jetty, namely `org.eclipse.jetty.server.Server`
    and `org.eclipse.jetty.util.Loader`, are present in the classpath.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '`@ConditionalOnClass` 注解告诉 Spring Boot，如果 Jetty 的类（即 `org.eclipse.jetty.server.Server`
    和 `org.eclipse.jetty.util.Loader`）存在于类路径中，则仅使用 `EmbeddedJetty` 配置。'
- en: Adding custom connectors
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加自定义连接器
- en: 'Another very common scenario in the enterprise application development and
    deployment is to run the application with two separate HTTP port connectors: one
    for HTTP and the other for HTTPS'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在企业应用程序开发和部署中，另一个非常常见的场景是使用两个独立的 HTTP 端口连接器来运行应用程序：一个用于 HTTP，另一个用于 HTTPS
- en: Getting ready
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: We will start by going back to using Tomcat; so for this recipe, we will undo
    the changes that we implemented in the previous example.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先回到使用 Tomcat；因此，对于这个配方，我们将撤销在先前的示例中实现的更改。
- en: In order to create an HTTPS connector, we will need a few things; but most importantly,
    we will need to generate the certificate keystore that is used to encrypt and
    decrypt the SSL communication with the browser.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 为了创建 HTTPS 连接器，我们需要一些东西；但最重要的是，我们需要生成用于加密和解密与浏览器 SSL 通信的证书密钥库。
- en: 'If you are using Unix or macOS, you can do it by running the following command:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用 Unix 或 macOS，你可以通过运行以下命令来实现：
- en: '[PRE8]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'On Windows, this can be achieved via the following command:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Windows 上，可以通过以下命令实现：
- en: '[PRE9]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'During the creation of the keystore, you should enter the information that
    is appropriate to you, including passwords, name, and so on. For the purpose of
    this book, we will use the default password: `changeit`. Once the execution is
    complete, a newly generated keystore file will appear in your home directory under
    the name: `keystore`.'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建密钥库的过程中，你应该输入适合你的信息，包括密码、名称等。为了本书的目的，我们将使用默认密码：`changeit`。一旦执行完成，一个新创建的密钥库文件将出现在你的主目录下，名称为：`keystore`。
- en: You can find more information about preparing the certificate keystore at [https://tomcat.apache.org/tomcat-8.0-doc/ssl-howto.html#Prepare_the_Certificate_Keystore](https://tomcat.apache.org/tomcat-8.0-doc/ssl-howto.html#Prepare_the_Certificate_Keystore).
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 [https://tomcat.apache.org/tomcat-8.0-doc/ssl-howto.html#Prepare_the_Certificate_Keystore](https://tomcat.apache.org/tomcat-8.0-doc/ssl-howto.html#Prepare_the_Certificate_Keystore)
    找到有关准备证书密钥库的更多信息。
- en: How to do it...
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'With the keystore creation complete, we will need to create a separate `properties`
    file in order to store our configuration for the HTTPS connectors, such as port.
    After that, we will create a configuration property binding object and use it
    to configure our new connector. Perform the following steps:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在密钥库创建完成后，我们需要创建一个单独的 `properties` 文件来存储我们的 HTTPS 连接器的配置，例如端口。之后，我们将创建一个配置属性绑定对象，并使用它来配置我们的新连接器。执行以下步骤：
- en: 'First, we will create a new properties file named `tomcat.https.properties`
    in the `src/main/resources` directory from the root of our project with the following
    content:'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们将从项目的根目录在 `src/main/resources` 目录下创建一个名为 `tomcat.https.properties` 的新属性文件，内容如下：
- en: '[PRE10]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Next, we will create a nested static class named `TomcatSslConnectorProperties`
    in our `WebConfiguration` class with the following content:'
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将在 `WebConfiguration` 类中创建一个名为 `TomcatSslConnectorProperties` 的嵌套静态类，内容如下：
- en: '[PRE11]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Now, we will need to add our newly created `tomcat.http.properties` file as
    a Spring Boot property source and enable `TomcatSslConnectorProperties` to be
    bound. This can be done by adding the following code right prior to the class
    declaration of the `WebConfiguration` class:'
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们需要将新创建的 `tomcat.http.properties` 文件添加为 Spring Boot 属性源，并启用 `TomcatSslConnectorProperties`
    的绑定。这可以通过在 `WebConfiguration` 类的类声明之前添加以下代码来完成：
- en: '[PRE12]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Finally, we will need to modify a `ServletWebServerFactory` Spring bean, where
    we will add our HTTPS connector. We will do that by changing the following code
    in the `WebConfiguration` class:'
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们需要修改一个 `ServletWebServerFactory` Spring bean，我们将添加我们的 HTTPS 连接器。我们将通过在
    `WebConfiguration` 类中更改以下代码来实现这一点：
- en: '[PRE13]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Start the application by running `./gradlew clean bootRun`.
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过运行 `./gradlew clean bootRun` 来启动应用程序。
- en: 'Let''s open `https://localhost:8443/internal/tomcat.https.properties` in the
    browser to see the following results:'
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们在浏览器中打开 `https://localhost:8443/internal/tomcat.https.properties` 来查看以下结果：
- en: '![](img/df9a6406-13c4-482a-a005-259cec02915c.png)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/df9a6406-13c4-482a-a005-259cec02915c.png)'
- en: How it works...
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In this recipe, we did a number of things; so let's break them down one change
    at a time.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们做了一些事情；让我们一次分解一个更改。
- en: The first change, ignoring the need to create the keystore, was the creation
    of the `tomcat.https.properties` and `TomcatSslConnectorProperties` objects to
    bind them to. Previously, we already dealt with making changes to the various
    settings in `application.properties` when configuring our datasource. At that
    time, though, we did not have to create any binding objects because Spring Boot
    already had them defined.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个更改，忽略创建密钥库的需要，是创建 `tomcat.https.properties` 和 `TomcatSslConnectorProperties`
    对象以将它们绑定到。在此之前，我们已经处理了在配置我们的数据源时对 `application.properties` 中各种设置的更改。然而，当时我们不需要创建任何绑定对象，因为
    Spring Boot 已经定义了它们。
- en: 'As we learned earlier, Spring Boot already exposes many properties to configure
    the application settings, including a whole set of settings for the `server` section.
    These values get bound to an internal Spring Boot class: `ServerProperties`'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们之前所学的，Spring Boot 已经公开了许多属性来配置应用程序设置，包括 `server` 部分的一整套设置。这些值绑定到一个内部 Spring
    Boot 类：`ServerProperties`
- en: A complete list of the common application properties can be found in the Spring
    Boot reference documentation at [http://docs.spring.io/spring-boot/docs/current/reference/html/common-application-properties.html](http://docs.spring.io/spring-boot/docs/current/reference/html/common-application-properties.html).
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 常见应用程序属性的完整列表可以在 Spring Boot 参考文档中找到，网址为 [http://docs.spring.io/spring-boot/docs/current/reference/html/common-application-properties.html](http://docs.spring.io/spring-boot/docs/current/reference/html/common-application-properties.html)。
- en: What we did with our addition was simply mimic Spring Boot and create our own
    configuration group with a binding object behind it. The reason that we didn't
    use the already existing `server.tomcat.` prefix, and instead opt for `custom.tomcat`,
    was mostly governed by the need to separate our config values from the default
    ones. Since we are adding a second connector, we want to have a clean separation
    between the default configuration properties and our custom ones.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 我们添加的功能只是简单地模仿 Spring Boot，并创建我们自己的配置组，其背后有一个绑定对象。我们没有使用已经存在的 `server.tomcat.`
    前缀，而是选择 `custom.tomcat`，主要是因为我们需要将我们的配置值与默认值分开。由于我们正在添加第二个连接器，我们希望默认配置属性和我们的自定义属性之间有一个清晰的分离。
- en: The `@ConfigurationProperties(prefix = "custom.tomcat.https")` method is an
    important annotation for our `TomcatSslConnectorProperties` object. It tells Spring
    Boot to automatically bind the properties with the `custom.tomcat.https` prefix
    to fields that are declared in `TomcatSslConnectorProperties`. In order for the
    binding to take place—in addition to defining the fields in the class—it is very
    important to define the getters and setters as well. It is also worth mentioning
    that during the binding process, Spring will automatically try to convert the
    property values to their appropriate data types. For example, the value of `custom.tomcat.https.keystore`
    gets automatically bound to a private file keystore field object.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '`@ConfigurationProperties(prefix = "custom.tomcat.https")` 方法是我们 `TomcatSslConnectorProperties`
    对象的一个重要注解。它告诉 Spring Boot 自动将带有 `custom.tomcat.https` 前缀的属性绑定到 `TomcatSslConnectorProperties`
    中声明的字段。为了使绑定发生——除了在类中定义字段之外——定义 getter 和 setter 也是非常重要的。还值得一提的是，在绑定过程中，Spring
    会自动尝试将属性值转换为适当的数据类型。例如，`custom.tomcat.https.keystore` 的值会自动绑定到一个私有的文件密钥库字段对象。'
- en: The converters, which we learned about earlier, will also be used during the
    process of converting to custom-defined data types.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前学到的转换器也将用于将数据转换为自定义定义的数据类型的过程中。
- en: The next step is to tell Spring Boot to include the properties that are defined
    in `tomcat.https.properties` in the list of properties. This is achieved by adding
    `@PropertySource("classpath:/tomcat.https.properties")` next to `@Configuration`
    in the `WebConfiguration` class.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是告诉 Spring Boot 将 `tomcat.https.properties` 中定义的属性包含在属性列表中。这是通过在 `WebConfiguration`
    类中的 `@Configuration` 旁边添加 `@PropertySource("classpath:/tomcat.https.properties")`
    来实现的。
- en: 'After the values are imported, we will need to tell Spring Boot to automatically
    create an instance of `TomcatSslConnectorProperties` for us to use. This is done
    by adding the following annotation next to `@Configuration`:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在值导入后，我们需要告诉 Spring Boot 自动为我们创建一个 `TomcatSslConnectorProperties` 实例。这是通过在 `@Configuration`
    旁边添加以下注解来完成的：
- en: '[PRE14]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This will instruct Spring Boot to automatically create a bean of type `TomcatSslConnectorProperties`
    and bind it with the values from the specified `classpath:/tomcat.https.properties`
    file. This bean can later be used for autowiring into different places, such as
    when we create a `ServletWebServerFactory` bean.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 这将指导 Spring Boot 自动创建一个类型为 `TomcatSslConnectorProperties` 的 bean，并将其与指定的 `classpath:/tomcat.https.properties`
    文件中的值绑定。这个 bean 可以后来用于在不同的地方进行自动装配，例如当我们创建一个 `ServletWebServerFactory` bean 时。
- en: After all the property support is set and done, we will proceed with the actual
    code to create a second connector. The creation of the `ServletWebServerFactory`
    bean provides Spring Boot with a factory to use in order to create  `WebServer`.
    The convenient `configureConnector(Connector connector)` method, which we added
    to `TomcatSslConnectorProperties`, gives us a good place to encapsulate and consolidate
    all the settings that are needed to configure the newly created `Connector` instance.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在设置并完成所有属性支持后，我们将继续编写实际代码来创建第二个连接器。`ServletWebServerFactory` bean 的创建为 Spring
    Boot 提供了一个工厂，用于创建 `WebServer`。我们添加到 `TomcatSslConnectorProperties` 中的方便的 `configureConnector(Connector
    connector)` 方法，为我们提供了一个很好的地方来封装和整合所有配置新创建的 `Connector` 实例所需的设置。
