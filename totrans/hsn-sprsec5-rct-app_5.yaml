- en: Integrating with Spring WebFlux
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the new features introduced as a part of Spring Framework 5 is the introduction
    of a new reactive web application framework, Spring WebFlux. WebFlux lives alongside
    the well-established web application framework Spring MVC. The book aims to introduce
    reactive parts of Spring Security in which Spring WebFlux is one of the core components.
  prefs: []
  type: TYPE_NORMAL
- en: Making your application reactive brings in an asynchronous nature to your application.
    Traditional Java applications used threads to achieve parallel and asynchronous
    nature to the application, however, usage of threads for a web application is
    not scalable and efficient in any manner.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter starts by introducing you to the core differences between Spring
    MVC and Spring WebFlux. It then delves into the Spring Security module and how
    reactive aspects have been brought into it.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Spring MVC versus WebFlux
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reactive support in Spring 5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Spring WebFlux
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Spring WebFlux authentication architecture
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Spring WebFlux authorization
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sample project
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Customization
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Spring MVC versus WebFlux
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Spring WebFlux was brought in as part of Spring 5 to bring in a new alternative
    to existing Spring MVC. Spring WebFlux brings in non-blocking event loop style
    programming to provide asynchronicity.
  prefs: []
  type: TYPE_NORMAL
- en: Event loop was brought in and made famous by Node.js. Node.js was able to perform
    non-blocking operations using single-threaded JavaScript by offloading operations
    to the system kernel whenever possible. The kernel, being multithreaded, is able
    to do these offloaded operations and after successful execution notifies Node.js
    through callbacks. There is a constantly running process that checks the call
    stack (where operations are stacked which need to be executed) and keeps executing
    processes in **First In, First Out** (**FIFO**) manner. If the call stack is empty,
    it looks into the *Event Queue* for operations. It picks them up and then moves
    them to the call stack to be further picked for execution.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram shows what is in both web application frameworks:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c30ee398-d5be-4f01-ad27-1e250e5b0aed.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1: Spring MVC and Spring WebFlux'
  prefs: []
  type: TYPE_NORMAL
- en: As shown in the preceding figure, Spring MVC is based on the Servlet API (works
    on thread pools) and Spring WebFlux is based on reactive streams (it works on
    an event loop mechanism). Both the frameworks, however, supports commonly used
    annotations such as `@Controller` and also support some well-known servers.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see the workings of Spring MVC and Spring WebFlux side-by-side in the
    following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/bf631caa-8c2b-4e35-ab85-e1374c4005be.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2: Working of Spring MVC and Spring WebFlux'
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, the fundamental difference between the working of the two frameworks
    is that Spring MVC is blocking and Spring WebFlux is non-blocking.
  prefs: []
  type: TYPE_NORMAL
- en: In Spring WebFlux, Servlet APIs behave as an adapter layer, enabling it to support
    both servlet containers such as **Tomcat** and **Jetty** and non-servlet runtimes
    such as **Undertow** and **Netty**.
  prefs: []
  type: TYPE_NORMAL
- en: Spring MVC comprises synchronous APIs (Filter, Servlet, and so on) and blocking
    I/O (`InputStream`, `OutputStream`, and so on) as against Spring WebFlux's asynchronous
    APIs (`WebFilter`, `WebHandler`, and so on) and non-blocking I/O (Reactor Mono
    for *0..1* elements and Rector Flux for *0..N* elements).
  prefs: []
  type: TYPE_NORMAL
- en: 'Spring WebFlux supports various asynchronous and Reactive APIs, namely Java
    9 Flow API, RxJava, Reactor, and Akka Streams. By default, it uses Spring''s very
    own reactive framework, Reactor, and it does do its job quite well:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f8ce06eb-8094-44e7-b218-18d92d1711fa.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3: Spring WebFlux reactive API support'
  prefs: []
  type: TYPE_NORMAL
- en: As mentioned earlier, Spring WebFlux was brought in as an alternative to Spring
    MVC. It doesn't mean in any way that Spring MVC is deprecated. Applications written
    in Spring MVC can continue running on the same stack without any migration to
    Spring WebFlux. If needs be, we can bring in reactive coding practices to an existing
    Spring MVC application by running a reactive client to make calls to remote services.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have seen the features of the two web application frameworks in
    Spring, the next section will give an idea as to when to choose what framework
    while building your application.
  prefs: []
  type: TYPE_NORMAL
- en: When to choose what?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Reactive programming is quite good but that doesn't mean that we have to go
    reactive for every application. Along the same lines, not all the applications
    are a good fit for Spring WebFlux. Choose the framework by looking at the requirements
    and how these frameworks can solve them. If an application is working fine with
    Spring MVC as a framework, there is no need to port that to Spring WebFlux. In
    fact, as mentioned earlier, good parts of reactive can be brought into Spring
    MVC if needs be without much trouble.
  prefs: []
  type: TYPE_NORMAL
- en: Also, if the application already has blocking dependencies (JDBC, LDAP, and
    so on), then it's better to stick with Spring MVC as there would be complications
    bringing in reactive concepts. Even if we bring in reactive concepts, many parts
    of the application are in blocking mode, which will prevent taking full advantage
    of such a programming paradigm.
  prefs: []
  type: TYPE_NORMAL
- en: Adopt Spring WebFlux if your application deals with streams of data (input and
    output). Also, consider this as the web application choice if scalability and
    performance is of utmost importance. By their sheer nature, asynchronous and non-blocking,
    these applications would be performant compared to synchronous and blocking. Being
    asynchronous, they can deal with latencies and are more scalable.
  prefs: []
  type: TYPE_NORMAL
- en: Reactive support in Spring 5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Spring Framework 5 has extensive support for a reactive programming paradigm.
    Many of the modules have embraced this concept with both hands and are making
    it a first-class citizen. The following diagram summarizes the Spring 5 support
    of reactive:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/cc2a49cf-86fc-4206-978d-46f156a7d0ca.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4: Spring 5 and reactive support'
  prefs: []
  type: TYPE_NORMAL
- en: Spring WebFlux module is a full-fledged web application framework built on top
    of a reactive programming paradigm (it uses Reactor and RxJava). Some of the early
    adopters of reactive programming in the Spring/Java ecosystem were **Spring Data**,
    **Spring Security**, and **Thymeleaf**. Spring Security has a number of features
    that supports reactive programming.
  prefs: []
  type: TYPE_NORMAL
- en: Spring Data has reactive support for Redis, MongoDB, Couchbase, and Cassandra.
    It also supports infinite streams (records emitted one by one in the form of a
    stream) from the database with `@Tailable`. JDBC inherently is blocking in nature,
    because of which, Spring Data JPA is blocking and cannot be made reactive.
  prefs: []
  type: TYPE_NORMAL
- en: Reactive in Spring MVC
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Even though Spring MVC is inherently blocking, some aspects can be made reactive
    by using reactive programming capabilities available as part of Spring 5.
  prefs: []
  type: TYPE_NORMAL
- en: 'In a Spring MVC controller, you can employ reactive types, `Flux` and `Mono`,
    as shown in the following diagram. The only rule is that you can use these reactive
    types only as the controller''s return values:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a1f41618-09a4-408c-b922-567bdd742bd5.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5: Spring MVC becoming non-blocking with usage of reactive types'
  prefs: []
  type: TYPE_NORMAL
- en: Spring MVC annotations such as `@Controller`, `@RequestMapping`, and so on are
    also supported in Spring WebFlux. So converting a Spring MVC web application to
    Spring WebFlux can be done over a period of time in a slow-paced manner.
  prefs: []
  type: TYPE_NORMAL
- en: Spring WebFlux
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we will go into a bit more detail on Spring WebFlux. There
    are two (programming model) ways by which Spring WebFlux can be used. They are
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Using annotations**: By using annotations such as `@Controller` similar to
    how it is been done in Spring MVC'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Using functional style**: By using routing and handling with Java Lambdas'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following code shows the annotation-based style of using Spring WebFlux.
    We will be going through the entire code sample in subsequent sections in this
    chapter. This section, however, is aimed at giving an introduction before we delve
    deeper:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The functional-style programming model of Spring WebFlux uses two fundamental
    components:'
  prefs: []
  type: TYPE_NORMAL
- en: '`HandlerFunction`: Entrusted to handle an HTTP request. Equivalent to `@Controller`
    handler methods we have seen in our previous code snippet.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`RouterFunction`: Entrusted to route an HTTP request. Equivalent to `@RequestMapping`
    in annotation-based.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: HandlerFunction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`HandlerFunction` accepts a `ServerRequest` object and returns `Mono<ServerResponse>`.
    Both `ServerRequest` and `ServerResponse` objects are immutable and fully reactive,
    built on top of Reactor.'
  prefs: []
  type: TYPE_NORMAL
- en: '`ServerRequest` exposes the body as `Mono` or `Flux`. Traditionally, `BodyExtractor`
    is used to achieve this. However, it also has utility methods which exposes these
    objects as shown in the following code. `ServerRequest` also gives access to all
    HTTP request elements, such as method, URI, and query string parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The `ServerResponse` object gives you access to various HTTP responses. The
    `ServerResponse` object can be created by using a builder, which allows setting
    response status and response headers. It also allows you to set the response body:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '`HandlerFunction` can be created using a Lambda function as in the following
    code and return `ServerResponse` with status 200 OK and with a body based on a
    `String`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'It is recommended to group all `HandlerFunction` objects into a single class
    having multiple methods, each handling a specific function, as shown in the following
    code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: RouterFunction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Incoming requests are intercepted by `RouterFunction`, and, according to the
    configured route, it is navigated to the right `HandlerFunction`. If the route
    is matched; `RouterFunction` takes in `ServerRequest` and returns back `Mono<HandlerFunction>`.
    If not, empty `Mono` is returned.
  prefs: []
  type: TYPE_NORMAL
- en: '`RouterFunction` is created as shown in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '`RequestPredicate` is a utility class that has predefined matching patterns
    for most of the common use cases, such as matching based on path, content type,
    HTTP method, and so on. An example code snippet for `RouterFunction` is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Multiple `RouterFunction` objects can be composed by invoking the following
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'There is also a convenient method, as follows, which is a combination of the
    `RouterFunction.and()` and `RouterFunctions.route()` methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The `RouterFunction` for the previous `HandlerFunction` is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Spring WebFlux server support
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Spring Webflux supports a number of servers, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Netty
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Jetty
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tomcat
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Undertow
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Servlet 3.1+ containers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Spring Boot 2+ uses Netty by default, when the web application framework selected
    is Spring WebFlux.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `RouterFunction` created can be run on any of the servers listed previously.
    To do that, `RouterFunction` needs to be converted to `HttpHandler`, using the
    following method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'If you want to run the previously created `RouterFunction` in Netty, the following
    code snippet can be used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: When we look at our sample application in subsequent sections of this chapter,
    we will look at code for other Spring WebFlux supported servers.
  prefs: []
  type: TYPE_NORMAL
- en: Reactive WebClient
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Spring WebFlux includes a reactive client named `WebClient`, enabling us to
    perform HTTP requests in a non-blocking manner and to use reactive streams. `WebClient`
    can be used as an alternative to `RestTemplate`, which is used more traditionally.
    `WebClient` exposes reactive `ClientHttpRequest` and `ClientHttpResponse` objects.
    The bodies of these objects consist of reactive `Flux<DataBuffer>`, as opposed
    to traditional blocking stream implementation (`InputStream` and `OutputStream`).
  prefs: []
  type: TYPE_NORMAL
- en: 'Create an instance of `WebClient`, perform a request, and then handle the response.
    The following is a code snippet showing the `WebClient` usage:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '`WebClient` can be used from within both Spring MVC and Spring WebFlux web
    applications. `RestTemplate` usage can quite easily be swapped with `WebClient`,
    making use of the reactive advantages it provides.'
  prefs: []
  type: TYPE_NORMAL
- en: In our sample project, we will cover the concepts and functionality of `WebClient`,
    using an example.
  prefs: []
  type: TYPE_NORMAL
- en: Reactive WebTestClient
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Similar to `WebClient`, Spring WebFlux provides you with a non-blocking, reactive
    client named `WebTestClient`, to test your reactive APIs on your server. It has
    utilities that make testing these APIs easily in a test environment setup. `WebTestClient`
    can connect to any of the servers, as detailed earlier over an HTTP connection
    and execute necessary tests. However, the client has the capability of running
    the tests with and without a running server.
  prefs: []
  type: TYPE_NORMAL
- en: '`WebTestClient` also has a number of utilities to verify the response produced
    by executing these server side APIs. It can quite easily bind itself to the WebFlux
    web application and mock necessary request and response objects to ascertain the
    API''s functional aspects. `WebTestClient` can mutate the headers as needed, to
    simulate the desired test environment. You can get an instance of `WebTestClient`
    for your entire application (by using the `WebTestClient.bindToApplicationContext`
    method), or you can restrict it to specific controller (using the `WebTextClient.bindToController`
    method), `RouterFunction` (using the `WebTestClient.bindToRouterFunction` method),
    and so on.'
  prefs: []
  type: TYPE_NORMAL
- en: We will see a detailed example of how `WebTestClient` works in a subsequent
    hands-on section (The *Sample project* section, under the *Testing (WebTestClient)*
    sub-section).
  prefs: []
  type: TYPE_NORMAL
- en: Reactive WebSocket
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Spring WebFlux includes a reactive `WebSocket` client and server support based
    on the Java WebSocket API.
  prefs: []
  type: TYPE_NORMAL
- en: 'On the server, create `WebSocketHandlerAdapter`, and then map each of those
    handlers to the URL. Since we don''t cover `WebSocket` in our sample application,
    let''s go into a bit more detail:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The `handle()` method takes in the `WebSocketSession` object and returns `Mono<Void>`
    when the handling of session is complete. `WebSocketSession` handles inbound and
    outbound messages using the `Flux<WebSocketMessage> receive()` and `Mono<Void>
    send(Publisher<WebSocketMessage>)` methods, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the web application Java configuration, declare a bean for `WebSocketHandlerAdpater`
    and create another bean to map the URL to the appropriate `WebSocketHandler`,
    as shown in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Spring WebFlux also provides `WebSocketClient` and has abstractions for all
    of the web servers discussed earlier, such as Netty, Jetty, and so on. Use appropriate
    server abstractions and create the client, as shown in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'In the client code, we can now subscribe to the `WebSocket`, endpoint and listen
    to messages and do the needful (basic `WebSocket` implementation). The code snippet
    for such a client on the frontend is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: To keep the chapter focused and concise, we will not go over `WebSocket` security
    provided by Spring Security. In the last chapter of this book, we will quickly
    cover the `WebSocket` security, using an example.
  prefs: []
  type: TYPE_NORMAL
- en: Spring WebFlux authentication architecture
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With the core Spring WebFlux concepts covered, we will now get into the crux
    of this chapter; introducing you to Spring Security for Spring WebFlux based reactive
    web applications.
  prefs: []
  type: TYPE_NORMAL
- en: 'As seen earlier, Spring Security in Spring MVC web applications is based on
    ServletFilter, and for Spring WebFlux, it is based on WebFilter:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d1a354e7-4c45-4822-a724-6ffdeff0f5d6.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6: Spring MVC and Spring WebFlux authentication approach'
  prefs: []
  type: TYPE_NORMAL
- en: 'We saw Spring Security in detail in Spring MVC web applications in previous
    chapters. We will now look at the inner details of Spring Security authentication
    for a Spring WebFlux based web application. The following diagram shows the interaction
    of various classes when an authentication process kicks in for a WebFlux application:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/fdb96ba6-52ca-4b7b-8b8f-1b0b76b71397.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7: Spring WebFlux authentication architecture'
  prefs: []
  type: TYPE_NORMAL
- en: The preceding diagram is quite self-explanatory, and is very similar to what
    you saw earlier for Spring MVC. The core difference is that `ServletFilter` is
    now replaced with `WebFilter`, and we have reactive-based classes for other blocking
    classes in Spring MVC. However, the core concepts of Spring Security remain intact
    with `WebFilter` dealing with many aspects in the initial authentication process;
    the core authentication is handled by `ReactiveAuthenticationManager` and related
    classes.
  prefs: []
  type: TYPE_NORMAL
- en: Spring WebFlux authorization
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Similar to authentication, the core concepts, in regard to authorization remains
    similar to what we have seen earlier in Spring MVC. However, the classes performing
    the operation have changed, and are, reactive and non-blocking. The following
    diagram shows the authorization-related main classes and their interactions in
    a Spring WebFlux application:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4cf1b7bb-eb58-4a8c-8658-b59deb16087c.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8: Authorization-related classes in a Spring WebFlux application'
  prefs: []
  type: TYPE_NORMAL
- en: As we all know by now, Spring WebFlux security works on `WebFilter`, and `AuthorizationWebFilter` intercepts
    the request and uses `ReactiveAuthorizationManager` to check whether the `Authentication`
    object has access to a protected resource. `ReactiveAuthorizationManager` has
    two methods, namely, `check` (checks whether access is granted to an `Authentication`
    object) and `verify`(checks whether access has to be granted for an `Authentication`
    object). In the event of any exception, `ExceptionTranslationWebFilter` takes
    care of handling this by following the appropriate paths.
  prefs: []
  type: TYPE_NORMAL
- en: Sample project
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Enough explanation; it's time to get our hands dirty with actual code. In this
    section, we will create a movie catalog site with integrated Spring Security.
    We will be using reactive concepts throughout and will use form-based login. We
    will start with hardcoded users and then see how we can look at a persistent user
    store to authenticate the users against. We will then into testing in more detail
    and finally look at some customizations that we can bring to Spring Security pages.
    Finally, we will touch base on authorization aspects and close the sample application.
  prefs: []
  type: TYPE_NORMAL
- en: WebFlux project setup
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will create a basic WebFlux-based web application first, and will slowly
    add other features, including security, in it. The whole code is available in
    our book's GitHub page, under the chapter's folder, namely `spring-boot-webflux`.
  prefs: []
  type: TYPE_NORMAL
- en: I am using IntelliJ as my IDE, and since we are using *Lombok library* (annotation
    `preprocessor`), make sure to enable the Lombok plugin, so as to generate appropriate
    boilerplate code for your model. Our project is kept quite simple, and does the
    function of movie management (the movie CRUD operation).
  prefs: []
  type: TYPE_NORMAL
- en: Maven setup
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Using Spring Initializr for generating a Spring WebFlux project is really easy.
    But for us to get a handle on the various aspects of a WebFlux application, we
    will build aspect by ourselves. However, we will be using Spring Boot to run our
    application.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will create a maven project, and will then add the following main dependencies
    (to make the code shorter, only important dependencies are shown in the following
    code) to our `pom.xml`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'We will include snapshot repositories for both the library and plugin dependencies.
    Finally, we will add the all-important maven plugin for our Spring Boot, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Configuration class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Even though we are going to use default configurations as much as possible,
    we will still have separate configuration classes for various components. In our
    project, we are building a basic WebFlux application, thus we have only one configuration
    class.
  prefs: []
  type: TYPE_NORMAL
- en: The SpringWebFluxConfig class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The main configuration class for a Spring WebFlux web application is achieved
    by this class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: We have an empty class with just some very important annotations as shown in
    the preceding code. `@EnableWebFlux` makes the application reactive and makes
    it WebFlux.
  prefs: []
  type: TYPE_NORMAL
- en: Repository
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will be using hardcoded movies as our data structure for this sample and
    will write methods in a reactive way, to expose methods in our repository class.
    These methods can be used to manipulate the data structure of the movies. Our
    repository class is a conventional one, but the right data structures, in the
    form of `Mono` and `Flux`, aid in bringing a reactive nature to the application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The class is just a snippet extracted from the class, and shows only one method
    (`getMovieById`). As always, our class implements an interface (`MovieRepository`),
    and this reference will be used in other parts of the application (using Spring's Dependency
    Injection capability).
  prefs: []
  type: TYPE_NORMAL
- en: Handler and router
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As detailed previously, we have two approaches, namely **functional-based**
    and **annotation-based**, for implementing a WebFlux application. Annotation-based
    is similar to Spring MVC, and because of this, we will be using functional-based
    approach in our sample application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The class is quite straightforward and uses a repository class for data structure
    query and manipulation. Each method accomplishes the functionality, and finally
    returns `Mono<ServerResponse>`. Another important aspect of WebFlux in functional-based
    programming is the routing configuration class, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: This is the class that looks at the request and routes it to the appropriate
    handler method. In your application, you can have any number of router configuration
    files.
  prefs: []
  type: TYPE_NORMAL
- en: Bootstrap application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Our sample application uses Spring Boot. Spring WebFlux runs on a Reactor Netty
    server within Spring Boot by default. Our Spring Boot class is very basic and
    is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: You can run the application on any other server, apart from Spring Boot, and
    it is quite easy to achieve. We have a separate project named `spring-boot-tomcat-webflux`
    that runs on Spring Boot, but rather than running on Reactor Netty, it runs on
    a Tomcat server.
  prefs: []
  type: TYPE_NORMAL
- en: 'No change is required in any part of the code, apart from `pom.xml`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: From the `spring-boot-starter-webflux` artifact, exclude Reactor Netty. Thereafter,
    explicitly add the Tomcat dependency, `spring-boot-starter-tomcat`. The rest of
    the `pom.xml` is kept intact. For other server runtimes, such as Undertow, Jetty,
    and so on, the approach is similar to the one detailed here.
  prefs: []
  type: TYPE_NORMAL
- en: Running the application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now, for the most important part: running the application that we built. As
    it is a Spring Boot application, execute the default command as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Once the server has started (default Rector Netty or Tomcat), open a browser
    and navigate to `localhost:8080/movies`. We have created default routing to point
    to "list all movies" endpoint and if all went well, you should see the JSON which
    shows all the hardcoded movies in our repository class.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we have created a sample Spring WebFlux movie application.
    We will add the all important security to this application in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Adding security
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To separate from what we have achieved up until now, we will have a separate
    project, `spring-boot-security-webflux` (the same as `spring-boot-webflux`). In
    it we will build all the security aspects.
  prefs: []
  type: TYPE_NORMAL
- en: Configuration classes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will be creating a new configuration class for Spring Security: `SpringSecurityWebFluxConfig`.
    Firstly, we will annotate the class with the most important annatation: `@EnableWebFluxSecurity`.
    This instructs it to enable Spring Security for WebFlux web applications. In the
    configuration class, we will look at two important beans, as follows.
  prefs: []
  type: TYPE_NORMAL
- en: The UserDetailsService bean
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will use hardcoded user details, against which we will authenticate. This
    is not how it has to be done for a production-ready application, but for simplicity
    and to explain the concepts, let''s take this shortcut:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: The bean returns the reactive user details service, containing hardcoded credentials
    for two users; one a normal user and the other an admin.
  prefs: []
  type: TYPE_NORMAL
- en: The SpringSecurityFilterChain bean
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This is the bean where we actually specify the Spring Security configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Similar to what we saw earlier, in the Spring MVC application earlier, we match
    URL patterns and specify the role that is needed to access it. We are configuring
    the login method as a form in which the user will be shown the default login form
    by Spring Security.
  prefs: []
  type: TYPE_NORMAL
- en: Running the application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Execute the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: When the server starts up, you have two ways in which you can test the application,
    as follows.
  prefs: []
  type: TYPE_NORMAL
- en: CURL
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Open your favorite Command Prompt and execute the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'You will be redirected to the `http://localhost:8080/login` page. Your entire
    application is secured and without logging in, you will not be able to access
    any content. With form login as the method, you won''t be able to test it using
    `curl`. Let''s change the login method from form (`formLogin`) to basic (`httpBasic`)
    in the Spring Security configuration (the `springWebFilterChain` bean). Now, execute
    the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'You should now see the raw JSON displaying all of the hardcoded movies. Use
    other common CURL commands, as follows, to test other endpoints:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Browser
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s put the login method back to form, and then open a browser and navigate
    to `http://localhost:8080`. You will be navigated to the default Spring Security
    login page. Enter the username as `admin` and the password as `password`, and
    click on Sign in:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/fe1f91c0-67a5-4870-8c70-74d01fe378db.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9: Default Spring Security login form'
  prefs: []
  type: TYPE_NORMAL
- en: 'After successfully logging in, you will be navigated to the list all movies
    endpoint, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7a0cd37d-e33b-4bb0-b2e5-64c2b9957c34.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10: List all movies default home page after login'
  prefs: []
  type: TYPE_NORMAL
- en: WebClient
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: On the book's GitHub page, we have a separate project (`spring-boot-security-webclient-webflux`),
    in which you can see the entire code that will be detailed in this section.
  prefs: []
  type: TYPE_NORMAL
- en: Maven setup
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Create a base maven project and add the following main dependency to your `pom.xml`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Now, add other dependencies, as well as the default Spring Boot build section.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a WebClient instance
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A `WebClient` instance can be created by using the `create()` method, or by
    using the `builder()` method. In our sample, we have used the `builder()` method,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: We will be using all of the endpoints that we have created earlier in our base
    Spring WebFlux project, and will be accessing them using the `WebClient`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Use the `create()` method to create an instance of `WebClient`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'If you have a base URL, `WebClient` can be created as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: The `builder()` method provides bunch of utility methods, such as filters, setting
    headers, setting cookies, and so on. In our example, we have set some default
    headers and have also set the base URL.
  prefs: []
  type: TYPE_NORMAL
- en: Handling errors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A `WebClient` instance allows you to handle errors (the `WebClientTestImpl`
    class) in the `listMovies()` method, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: '`SampleException` is a custom exception class that we created by extending
    the `Exception` class. We are handling 4xx and 5xx errors, and, when encountered,
    it sends the custom exception as response.'
  prefs: []
  type: TYPE_NORMAL
- en: Sending requests and retrieving responses
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `retrieve()` method is a simple method, using which the response body can
    be retrieved. If you want to have more control over returned responses, the `exchange()`
    method can be used to retrieve the response. We have used both of the methods
    in our sample application; the code snippets for the two methods in the `WebClientTestImpl`
    class are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: In the first method, we execute a GET method on the URI `http://localhost:8080/api/movie/{id}`,
    use the `retrieve()` method, and then convert into `Mono`.
  prefs: []
  type: TYPE_NORMAL
- en: In the second method, we execute a POST method on the URL `http://localhost:8080/api/movie`,
    use the `exchange()` method, and use the `flatMap()` method to create the response.
  prefs: []
  type: TYPE_NORMAL
- en: Running and testing the application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will be using the same movie model in this sample project. Since this is
    the only class that we need from our previous sample application, we will copy
    the class here. In an ideal scenario, we would have a JAR file containing all
    common classes, and it can be included in our `pom.xml` file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create the `Run` class (as seen earlier) and call the `WebClient` methods.
    The code snippet for one of the methods is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: After executing each `WebClient` call, we will sleep for three seconds. Since
    `WebClient` methods emit reactive types (`Mono` or `Flux`), you have to subscribe,
    as shown in the preceding code.
  prefs: []
  type: TYPE_NORMAL
- en: Start the `spring-boot-webflux` project, exposing the endpoints, which we will
    test by using `WebClient` in this project.
  prefs: []
  type: TYPE_NORMAL
- en: 'Make sure that your application''s default port is changed in your `application.properties`
    file by including the following entry:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Start the application by executing the Spring Boot command, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'If all goes well, you should see the output in the server console, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/22f55554-5b13-4aa5-aeeb-10c9acc37545.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11: WebClient test execution'
  prefs: []
  type: TYPE_NORMAL
- en: Unit testing (WebTestClient)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In our base `spring-boot-webflux` project, we have written test cases using
    `WebTestClient`. We have two test cases: one to get all movies, and other to save
    movie.'
  prefs: []
  type: TYPE_NORMAL
- en: Maven dependency
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Make sure that you have the following dependencies in your `pom.xml` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, in the preceding code, all of the dependencies can be scoped
    for testing purposes.
  prefs: []
  type: TYPE_NORMAL
- en: Test class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Create a normal test class, as follows. Use the `@Autowired` annotation to
    inject the `WebTestClient` instance in your test class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: The `WebTestClient` object's functionality is similar to `WebClient`, as seen
    earlier. We can check for various properties in the response to ascertain what
    we want to test. In the preceding example, for the first test, we are firing a
    GET request and checking for OK status, an application/JSON content type header,
    and, finally, a body having a list of `Movie` objects. In the second test, we
    are firing a POST request with a `Movie` object as the body, and, expecting an
    OK status and an empty body.
  prefs: []
  type: TYPE_NORMAL
- en: Spring Data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Even though this book is focused on Spring Security on reactive concepts, I
    really want you to have some idea of reactive concepts in other areas as well.
    So, there is a separate project, `spring-boot-security-mongo-webflux`, which looks
    at implementing reactive concepts by integrating the earlier project with reactive
    MongoDB, using Spring Data. Covering every aspect in regard to this is not something
    that we will do. However, with the earlier project as a base, we will cover some
    of the important aspects in this section.
  prefs: []
  type: TYPE_NORMAL
- en: Maven dependency
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In your application `pom.xml`, add the following dependencies, both dealing
    with MongoDB inclusion into the project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: I have installed MongoDB on my machine. I have started the database locally
    on the default port (`27017`).
  prefs: []
  type: TYPE_NORMAL
- en: MongoDB configuration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Add the following to your application.properties file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: We will be pointing our DB to a locally running DB on the default port utilizing
    the movie database.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up a model
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In our already existing `Movie` model, we just added one more annotation: `@Document(collection
    = "movies")`. This annotation will inform MongoDB as to the name of the collection
    in the DB where this model will be stored.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing a repository
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will create a new repository, `ReactiveMovieRepository`, with our two curated
    methods and all of the default methods provided by our extended class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: We will extend our repository from `ReactiveMongoRepository`. `ReactiveMongoRepository`
    has loads of common methods that can be used right away, without any trouble.
    The methods that we have implemented use plain queries against the MongoDB and
    return the list.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing a controller
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To make it separate from our existing functional-based programming, we have
    created a new controller that will expose some of the methods in a RESTful way,
    using the newly created `ReactiveMovieRepository`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: The class is quite straightforward; each method has appropriate mapping and
    uses corresponding repository classes to actually do the job.
  prefs: []
  type: TYPE_NORMAL
- en: Running the application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Using the `mongod` command, we will start the locally installed MongoDB and
    then using the following command, we will start the project we just created:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Head over to postman and call the URL `http://localhost:8080/movies` (GET).
    You will see an array with zero elements in it. Now, call the URL `http://localhost:8080/movies`
    (POST), with the following JSON in the body:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: You will get a 200 OK status, and should see the newly created JSON as a response.
    Now, if you run the GET request on movies endpoint, you should see the newly created
    `Movie` as a response.
  prefs: []
  type: TYPE_NORMAL
- en: Here, we implemented CRUD in our `Movie` model by using MongoDB as a persistence
    store in a reactive programming paradigm.
  prefs: []
  type: TYPE_NORMAL
- en: Authorization
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the past, we already saw that using the `@EnableWebFluxSecurity` annotation,
    we can get URL security. Spring Security also allows you to secure method execution
    in a reactive way, by using another annotation, `@EnableReactiveMethodSecurity`.
    The concept is the same what we saw in earlier examples based on Spring MVC. We
    will just cover method security in this section; the rest of the aspects are exactly
    the same and we will avoid replication here.
  prefs: []
  type: TYPE_NORMAL
- en: Method security
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To enable method security, first, annotate the Spring Security configurations
    class with `@EnableReactiveMethodSecurity`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'After that, for any method that you would like to have some security features
    for, use all of the various security-related annotations discussed in previous
    chapters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding method, we are directing Spring Security that the method execution
    for `getAllMovies()` should be allowed if the user is authenticated and has the `ADMIN`
    role granted.
  prefs: []
  type: TYPE_NORMAL
- en: Customization
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Spring Security allows for a number of customizations. The default pages produced
    by Spring Security, such as login form, logout form, and so on, can be fully customized
    in all aspects suiting your application's brand. If you would like to tweak Spring
    Security's default execution, implementing your own filter is appropriate. Since
    Spring Security depends heavily on filters to achieve its functionality, let's
    look at the customization opportunity in this.
  prefs: []
  type: TYPE_NORMAL
- en: In addition, almost all parts of Spring Security can be customized by using
    your own classes, and then plugged into the Spring Security default flow to manage
    your own customizations.
  prefs: []
  type: TYPE_NORMAL
- en: Writing custom filters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we saw earlier, in a WebFlux web application, Spring Security works based
    on `WebFilter` (similar to Servlet Filter in Spring MVC). If you would like to
    customize certain aspects in Spring Security, especially in request and response
    manipulation, implementing a custom `WebFilter` is one of the approaches that
    can be looked at.
  prefs: []
  type: TYPE_NORMAL
- en: 'Spring WebFlux offers two approaches to implement filters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Using** `WebFilter`: Works for both annotation-based and functional-based
    (`routerhandler`)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Using** `HandlerFilterFunction`: Works only with functional-based'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using WebFilter
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will be building on top of our project, `spring-boot-webflux`. To make it
    isolated from other projects, we will create a new project, `spring-boot-webflux-custom`.
    As indicated previously, using `WebFilter` applies to both annotation-based and
    functional-based WebFlux approaches. In our example, we''ll have two paths: `filtertest1`
    and `filtertest2`. We will write test cases using `WebFluxTestClient`, and will
    assert certain conditions. Being separate from the rest, we will create a new
    routing config, a handler, and an entirely new REST controller. We will not go
    into detail on some of the aspects already covered. In this section, we will just
    go through the `WebFilter` code, and also some important aspects of the test cases:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'The `SampleWebFilter` class implements `WebFilter`, and also implements the
    `filter` method. In this class, we will add a new response header, `filter-added-header`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: In both test cases, for both paths, we will check for newly added headers. When
    you run the test cases (using `mvn test`), it will confirm this finding.
  prefs: []
  type: TYPE_NORMAL
- en: Using HandlerFilterFunction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will implement a new `HandlerFilterFunction`, `SampleHandlerFilterFunction`,
    in which we will look at a path variable (`pathVariable`) and check for its value.
    If the value is equal to `value2`, we will mark the status as `BAD_REQUEST`. It''s
    important to note that since `HandlerFilterFunction` applies only to functional-based,
    even though the path variable value is equal to `value2`, the status is not stamped
    as `BAD_REQUEST`, and the response received is OK:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: '`SampleHandlerFilterFunction` implements the `HandlerFilterFunction` class,
    and also implements the `filter` method. In this class, we will explicitly set
    the response status as a bad request, if a condition is met:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding test cases, the path tested is different, and since `HandlerFilterFunction`
    applies only to functional-based, the response is OK when the path is `filtertest1`,
    and it's `BAD_REQUEST` when the path is `filtertest2`.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, for the first time in this book, we went over the details of
    reactive programming, using the Spring WebFlux framework. We started off by giving
    adequate details on the framework itself at a high level. We went over a very
    basic example, and then, introduced you to Spring Security and its functionality
    with Spring WebFlux.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we went through a hands-on coding session, with a sample application.
    In this example, we covered other reactive aspects, such as Spring Data Mongo,
    so as to give you more insight into the reactive world.
  prefs: []
  type: TYPE_NORMAL
- en: We ended the chapter with some of the customization possible in Spring WebFlux
    with Spring Security.
  prefs: []
  type: TYPE_NORMAL
- en: Having read this chapter, you should have a clear idea of the differences between
    the Spring MVC and Spring WebFlux frameworks. You should also have a good understanding
    of the workings of Spring WebFlux security using the Spring Security module. The
    examples are meant to be simple in nature and as we are undressing Spring Security
    in this book, those aspects are given more value in the explanations.
  prefs: []
  type: TYPE_NORMAL
