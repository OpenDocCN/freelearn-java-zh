- en: Integrating with Spring WebFlux
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 集成Spring WebFlux
- en: One of the new features introduced as a part of Spring Framework 5 is the introduction
    of a new reactive web application framework, Spring WebFlux. WebFlux lives alongside
    the well-established web application framework Spring MVC. The book aims to introduce
    reactive parts of Spring Security in which Spring WebFlux is one of the core components.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 作为Spring Framework 5的一部分引入的新特性之一是引入了一个新的响应式Web应用框架，Spring WebFlux。WebFlux与成熟的Web应用框架Spring
    MVC并存。本书旨在介绍Spring Security中的响应式部分，其中Spring WebFlux是核心组件之一。
- en: Making your application reactive brings in an asynchronous nature to your application.
    Traditional Java applications used threads to achieve parallel and asynchronous
    nature to the application, however, usage of threads for a web application is
    not scalable and efficient in any manner.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 使您的应用程序响应式将为您的应用程序带来异步性。传统的Java应用程序使用线程来实现应用程序的并行和异步性，然而，对于Web应用程序来说，使用线程在任何方式上都是不可扩展且效率低下的。
- en: This chapter starts by introducing you to the core differences between Spring
    MVC and Spring WebFlux. It then delves into the Spring Security module and how
    reactive aspects have been brought into it.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章首先向您介绍Spring MVC和Spring WebFlux之间的核心差异。然后深入探讨Spring Security模块以及如何将其中的响应式方面引入。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Spring MVC versus WebFlux
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Spring MVC与WebFlux的比较
- en: Reactive support in Spring 5
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Spring 5中的响应式支持
- en: Spring WebFlux
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Spring WebFlux
- en: Spring WebFlux authentication architecture
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Spring WebFlux认证架构
- en: Spring WebFlux authorization
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Spring WebFlux授权
- en: Sample project
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 示例项目
- en: Customization
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自定义
- en: Spring MVC versus WebFlux
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Spring MVC与WebFlux的比较
- en: Spring WebFlux was brought in as part of Spring 5 to bring in a new alternative
    to existing Spring MVC. Spring WebFlux brings in non-blocking event loop style
    programming to provide asynchronicity.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: Spring WebFlux作为Spring 5的一部分被引入，以提供对现有Spring MVC的一种新替代方案。Spring WebFlux引入了非阻塞的事件循环风格编程，以提供异步性。
- en: Event loop was brought in and made famous by Node.js. Node.js was able to perform
    non-blocking operations using single-threaded JavaScript by offloading operations
    to the system kernel whenever possible. The kernel, being multithreaded, is able
    to do these offloaded operations and after successful execution notifies Node.js
    through callbacks. There is a constantly running process that checks the call
    stack (where operations are stacked which need to be executed) and keeps executing
    processes in **First In, First Out** (**FIFO**) manner. If the call stack is empty,
    it looks into the *Event Queue* for operations. It picks them up and then moves
    them to the call stack to be further picked for execution.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 事件循环是由Node.js引入并使其著名的。Node.js通过在可能的情况下将操作卸载到系统内核，能够使用单线程JavaScript执行非阻塞操作。内核是多线程的，能够执行这些卸载的操作，并在成功执行后通过回调通知Node.js。有一个持续运行的过程检查调用栈（操作堆栈，其中堆叠了需要执行的操作），并按**先进先出**（**FIFO**）的方式执行进程。如果调用栈为空，它将查看*事件队列*中的操作。它将它们取出来，然后将它们移动到调用栈中，以便进一步被选中执行。
- en: 'The following diagram shows what is in both web application frameworks:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的图表展示了两个Web应用框架中都包含的内容：
- en: '![](img/c30ee398-d5be-4f01-ad27-1e250e5b0aed.png)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/c30ee398-d5be-4f01-ad27-1e250e5b0aed.png)'
- en: 'Figure 1: Spring MVC and Spring WebFlux'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 图1：Spring MVC和Spring WebFlux
- en: As shown in the preceding figure, Spring MVC is based on the Servlet API (works
    on thread pools) and Spring WebFlux is based on reactive streams (it works on
    an event loop mechanism). Both the frameworks, however, supports commonly used
    annotations such as `@Controller` and also support some well-known servers.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 如前图所示，Spring MVC基于Servlet API（在线程池上工作）和Spring WebFlux基于响应式流（它基于事件循环机制）。然而，这两个框架都支持常用的注解，如`@Controller`，并且也支持一些知名的服务器。
- en: 'Let''s see the workings of Spring MVC and Spring WebFlux side-by-side in the
    following diagram:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过以下图表来比较Spring MVC和Spring WebFlux的工作原理：
- en: '![](img/bf631caa-8c2b-4e35-ab85-e1374c4005be.png)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/bf631caa-8c2b-4e35-ab85-e1374c4005be.png)'
- en: 'Figure 2: Working of Spring MVC and Spring WebFlux'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 图2：Spring MVC和Spring WebFlux的工作原理
- en: As you can see, the fundamental difference between the working of the two frameworks
    is that Spring MVC is blocking and Spring WebFlux is non-blocking.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，这两个框架工作原理的根本区别在于Spring MVC是阻塞的，而Spring WebFlux是非阻塞的。
- en: In Spring WebFlux, Servlet APIs behave as an adapter layer, enabling it to support
    both servlet containers such as **Tomcat** and **Jetty** and non-servlet runtimes
    such as **Undertow** and **Netty**.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在Spring WebFlux中，Servlet API作为适配层，使其能够支持如**Tomcat**和**Jetty**这样的servlet容器以及**Undertow**和**Netty**这样的非servlet运行时。
- en: Spring MVC comprises synchronous APIs (Filter, Servlet, and so on) and blocking
    I/O (`InputStream`, `OutputStream`, and so on) as against Spring WebFlux's asynchronous
    APIs (`WebFilter`, `WebHandler`, and so on) and non-blocking I/O (Reactor Mono
    for *0..1* elements and Rector Flux for *0..N* elements).
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: Spring MVC包含同步API（过滤器、Servlet等）和阻塞I/O（`InputStream`、`OutputStream`等），而Spring
    WebFlux则包含异步API（`WebFilter`、`WebHandler`等）和非阻塞I/O（Reactor Mono用于*0..1*元素和Rector
    Flux用于*0..N*元素）。
- en: 'Spring WebFlux supports various asynchronous and Reactive APIs, namely Java
    9 Flow API, RxJava, Reactor, and Akka Streams. By default, it uses Spring''s very
    own reactive framework, Reactor, and it does do its job quite well:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: Spring WebFlux支持各种异步和反应式API，包括Java 9 Flow API、RxJava、Reactor和Akka Streams。默认情况下，它使用Spring自己的反应式框架Reactor，并且确实做得相当不错：
- en: '![](img/f8ce06eb-8094-44e7-b218-18d92d1711fa.png)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/f8ce06eb-8094-44e7-b218-18d92d1711fa.png)'
- en: 'Figure 3: Spring WebFlux reactive API support'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 图3：Spring WebFlux反应式API支持
- en: As mentioned earlier, Spring WebFlux was brought in as an alternative to Spring
    MVC. It doesn't mean in any way that Spring MVC is deprecated. Applications written
    in Spring MVC can continue running on the same stack without any migration to
    Spring WebFlux. If needs be, we can bring in reactive coding practices to an existing
    Spring MVC application by running a reactive client to make calls to remote services.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，Spring WebFlux被引入作为Spring MVC的替代品。这并不意味着Spring MVC已被弃用。使用Spring MVC编写的应用程序可以在同一堆栈上继续运行，无需迁移到Spring
    WebFlux。如果需要，我们可以通过运行反应式客户端来调用远程服务，将反应式编程实践引入现有的Spring MVC应用程序。
- en: Now that we have seen the features of the two web application frameworks in
    Spring, the next section will give an idea as to when to choose what framework
    while building your application.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经看到了Spring中两个Web应用程序框架的特点，下一节将给出在构建应用程序时何时选择哪个框架的想法。
- en: When to choose what?
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 何时选择什么？
- en: Reactive programming is quite good but that doesn't mean that we have to go
    reactive for every application. Along the same lines, not all the applications
    are a good fit for Spring WebFlux. Choose the framework by looking at the requirements
    and how these frameworks can solve them. If an application is working fine with
    Spring MVC as a framework, there is no need to port that to Spring WebFlux. In
    fact, as mentioned earlier, good parts of reactive can be brought into Spring
    MVC if needs be without much trouble.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 反应式编程相当不错，但这并不意味着我们必须为每个应用程序都采用反应式。同样，并非所有应用程序都适合Spring WebFlux。根据需求以及这些框架如何解决问题来选择框架。如果一个应用程序使用Spring
    MVC作为框架运行良好，就没有必要将其迁移到Spring WebFlux。实际上，正如之前提到的，如果需要，可以将反应式编程的精华引入Spring MVC，而不会遇到太多麻烦。
- en: Also, if the application already has blocking dependencies (JDBC, LDAP, and
    so on), then it's better to stick with Spring MVC as there would be complications
    bringing in reactive concepts. Even if we bring in reactive concepts, many parts
    of the application are in blocking mode, which will prevent taking full advantage
    of such a programming paradigm.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，如果应用程序已经存在阻塞依赖（如JDBC、LDAP等），那么坚持使用Spring MVC会更好，因为引入反应式概念可能会带来复杂性。即使我们引入了反应式概念，应用程序的许多部分仍然处于阻塞模式，这将阻止充分利用这种编程范式。
- en: Adopt Spring WebFlux if your application deals with streams of data (input and
    output). Also, consider this as the web application choice if scalability and
    performance is of utmost importance. By their sheer nature, asynchronous and non-blocking,
    these applications would be performant compared to synchronous and blocking. Being
    asynchronous, they can deal with latencies and are more scalable.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的应用程序处理数据流（输入和输出），则采用Spring WebFlux。如果可扩展性和性能至关重要，这也应被视为Web应用程序的选择。由于它们的本质是异步和非阻塞的，这些应用程序与同步和阻塞的应用程序相比将具有更高的性能。由于是异步的，它们可以处理延迟，并且具有更高的可扩展性。
- en: Reactive support in Spring 5
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Spring 5中的反应式支持
- en: 'Spring Framework 5 has extensive support for a reactive programming paradigm.
    Many of the modules have embraced this concept with both hands and are making
    it a first-class citizen. The following diagram summarizes the Spring 5 support
    of reactive:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Framework 5对反应式编程范式提供了广泛的支持。许多模块都全盘接受了这一概念，并将其作为一等公民。以下图表总结了Spring 5对反应式的支持：
- en: '![](img/cc2a49cf-86fc-4206-978d-46f156a7d0ca.png)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![](img/cc2a49cf-86fc-4206-978d-46f156a7d0ca.png)'
- en: 'Figure 4: Spring 5 and reactive support'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 图4：Spring 5和响应式支持
- en: Spring WebFlux module is a full-fledged web application framework built on top
    of a reactive programming paradigm (it uses Reactor and RxJava). Some of the early
    adopters of reactive programming in the Spring/Java ecosystem were **Spring Data**,
    **Spring Security**, and **Thymeleaf**. Spring Security has a number of features
    that supports reactive programming.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: Spring WebFlux模块是一个基于响应式编程范式（它使用Reactor和RxJava）构建的完整Web应用程序框架。Spring/Java生态系统中的早期响应式编程采用者包括**Spring
    Data**、**Spring Security**和**Thymeleaf**。Spring Security具有许多支持响应式编程的功能。
- en: Spring Data has reactive support for Redis, MongoDB, Couchbase, and Cassandra.
    It also supports infinite streams (records emitted one by one in the form of a
    stream) from the database with `@Tailable`. JDBC inherently is blocking in nature,
    because of which, Spring Data JPA is blocking and cannot be made reactive.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Data为Redis、MongoDB、Couchbase和Cassandra提供了响应式支持。它还支持使用`@Tailable`从数据库中获取无限流（以流的形式逐个发出的记录）。由于JDBC本质上是阻塞的，因此Spring
    Data JPA是阻塞的，无法使其响应式。
- en: Reactive in Spring MVC
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Spring MVC中的响应式编程
- en: Even though Spring MVC is inherently blocking, some aspects can be made reactive
    by using reactive programming capabilities available as part of Spring 5.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管Spring MVC本质上是阻塞的，但可以通过使用Spring 5提供的响应式编程能力使一些方面变得响应式。
- en: 'In a Spring MVC controller, you can employ reactive types, `Flux` and `Mono`,
    as shown in the following diagram. The only rule is that you can use these reactive
    types only as the controller''s return values:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在Spring MVC控制器中，你可以使用响应式类型`Flux`和`Mono`，如下所示图所示。唯一的规则是，你只能将这些响应式类型用作控制器的返回值：
- en: '![](img/a1f41618-09a4-408c-b922-567bdd742bd5.png)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a1f41618-09a4-408c-b922-567bdd742bd5.png)'
- en: 'Figure 5: Spring MVC becoming non-blocking with usage of reactive types'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 图5：使用响应式类型使Spring MVC非阻塞
- en: Spring MVC annotations such as `@Controller`, `@RequestMapping`, and so on are
    also supported in Spring WebFlux. So converting a Spring MVC web application to
    Spring WebFlux can be done over a period of time in a slow-paced manner.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: Spring MVC中的注解，如`@Controller`、`@RequestMapping`等，也支持在Spring WebFlux中。因此，将Spring
    MVC Web应用程序转换为Spring WebFlux可以以慢速的方式分阶段完成。
- en: Spring WebFlux
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Spring WebFlux
- en: 'In this section, we will go into a bit more detail on Spring WebFlux. There
    are two (programming model) ways by which Spring WebFlux can be used. They are
    as follows:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将更详细地介绍Spring WebFlux。Spring WebFlux可以通过两种（编程模型）方式使用。它们如下：
- en: '**Using annotations**: By using annotations such as `@Controller` similar to
    how it is been done in Spring MVC'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**使用注解**：通过使用类似于Spring MVC中的`@Controller`的注解'
- en: '**Using functional style**: By using routing and handling with Java Lambdas'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**使用函数式风格**：通过使用Java Lambda进行路由和处理'
- en: 'The following code shows the annotation-based style of using Spring WebFlux.
    We will be going through the entire code sample in subsequent sections in this
    chapter. This section, however, is aimed at giving an introduction before we delve
    deeper:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码展示了基于注解风格的Spring WebFlux使用方式。我们将在本章后续部分逐步分析整个代码示例。然而，本节旨在在深入探讨之前提供一个简介：
- en: '[PRE0]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The functional-style programming model of Spring WebFlux uses two fundamental
    components:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: Spring WebFlux的函数式编程模型使用两个基本组件：
- en: '`HandlerFunction`: Entrusted to handle an HTTP request. Equivalent to `@Controller`
    handler methods we have seen in our previous code snippet.'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`HandlerFunction`：负责处理HTTP请求。相当于我们在之前的代码片段中看到的`@Controller`处理方法。'
- en: '`RouterFunction`: Entrusted to route an HTTP request. Equivalent to `@RequestMapping`
    in annotation-based.'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`RouterFunction`：负责路由HTTP请求。相当于基于注解的`@RequestMapping`。'
- en: HandlerFunction
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: HandlerFunction
- en: '`HandlerFunction` accepts a `ServerRequest` object and returns `Mono<ServerResponse>`.
    Both `ServerRequest` and `ServerResponse` objects are immutable and fully reactive,
    built on top of Reactor.'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '`HandlerFunction`接受一个`ServerRequest`对象并返回`Mono<ServerResponse>`。`ServerRequest`和`ServerResponse`对象都是不可变的且完全响应式的，基于Reactor构建。'
- en: '`ServerRequest` exposes the body as `Mono` or `Flux`. Traditionally, `BodyExtractor`
    is used to achieve this. However, it also has utility methods which exposes these
    objects as shown in the following code. `ServerRequest` also gives access to all
    HTTP request elements, such as method, URI, and query string parameters:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '`ServerRequest`将体暴露为`Mono`或`Flux`。传统上，使用`BodyExtractor`来实现这一点。然而，它也有实用方法，如以下代码所示，暴露这些对象。`ServerRequest`还提供了对所有HTTP请求元素（如方法、URI和查询字符串参数）的访问：'
- en: '[PRE1]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The `ServerResponse` object gives you access to various HTTP responses. The
    `ServerResponse` object can be created by using a builder, which allows setting
    response status and response headers. It also allows you to set the response body:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '`ServerResponse` 对象提供了访问各种 HTTP 响应的能力。可以通过使用构建器创建 `ServerResponse` 对象，该构建器允许设置响应状态和响应头。它还允许您设置响应体：'
- en: '[PRE2]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '`HandlerFunction` can be created using a Lambda function as in the following
    code and return `ServerResponse` with status 200 OK and with a body based on a
    `String`:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用 Lambda 函数创建 `HandlerFunction`，如下面的代码所示，并返回状态为 200 OK 的 `ServerResponse`，其体基于一个
    `String`：
- en: '[PRE3]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'It is recommended to group all `HandlerFunction` objects into a single class
    having multiple methods, each handling a specific function, as shown in the following
    code snippet:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 建议将所有 `HandlerFunction` 对象组合成一个具有多个方法的单个类，每个方法处理一个特定的功能，如下面的代码片段所示：
- en: '[PRE4]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: RouterFunction
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: RouterFunction
- en: Incoming requests are intercepted by `RouterFunction`, and, according to the
    configured route, it is navigated to the right `HandlerFunction`. If the route
    is matched; `RouterFunction` takes in `ServerRequest` and returns back `Mono<HandlerFunction>`.
    If not, empty `Mono` is returned.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 进入的请求被 `RouterFunction` 拦截，并根据配置的路由导航到正确的 `HandlerFunction`。如果路由匹配；`RouterFunction`
    接收 `ServerRequest` 并返回 `Mono<HandlerFunction>`。如果不匹配，则返回空的 `Mono`。
- en: '`RouterFunction` is created as shown in the following code snippet:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '`RouterFunction` 的创建方式如下所示：'
- en: '[PRE5]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '`RequestPredicate` is a utility class that has predefined matching patterns
    for most of the common use cases, such as matching based on path, content type,
    HTTP method, and so on. An example code snippet for `RouterFunction` is as follows:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '`RequestPredicate` 是一个实用类，它为大多数常见用例预定义了匹配模式，例如基于路径、内容类型、HTTP 方法等。以下是一个 `RouterFunction`
    的示例代码片段：'
- en: '[PRE6]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Multiple `RouterFunction` objects can be composed by invoking the following
    method:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过调用以下方法来组合多个 `RouterFunction` 对象：
- en: '[PRE7]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'There is also a convenient method, as follows, which is a combination of the
    `RouterFunction.and()` and `RouterFunctions.route()` methods:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一个方便的方法，如下所示，它是 `RouterFunction.and()` 和 `RouterFunctions.route()` 方法的组合：
- en: '[PRE8]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The `RouterFunction` for the previous `HandlerFunction` is as follows:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 之前 `HandlerFunction` 的 `RouterFunction` 如下所示：
- en: '[PRE9]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Spring WebFlux server support
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Spring WebFlux 服务器支持
- en: 'Spring Webflux supports a number of servers, as follows:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Webflux 支持以下服务器：
- en: Netty
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Netty
- en: Jetty
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Jetty
- en: Tomcat
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Tomcat
- en: Undertow
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Undertow
- en: Servlet 3.1+ containers
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Servlet 3.1+ 容器
- en: Spring Boot 2+ uses Netty by default, when the web application framework selected
    is Spring WebFlux.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Boot 2+ 默认使用 Netty，当选择 Spring WebFlux 作为网络应用程序框架时。
- en: 'The `RouterFunction` created can be run on any of the servers listed previously.
    To do that, `RouterFunction` needs to be converted to `HttpHandler`, using the
    following method:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 创建的 `RouterFunction` 可以在之前列出的任何服务器上运行。为此，需要将 `RouterFunction` 转换为 `HttpHandler`，使用以下方法：
- en: '[PRE10]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'If you want to run the previously created `RouterFunction` in Netty, the following
    code snippet can be used:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 如果想在 Netty 中运行之前创建的 `RouterFunction`，可以使用以下代码片段：
- en: '[PRE11]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: When we look at our sample application in subsequent sections of this chapter,
    we will look at code for other Spring WebFlux supported servers.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章后续部分查看我们的示例应用程序时，我们将查看其他 Spring WebFlux 支持的服务器的代码。
- en: Reactive WebClient
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 反应式 WebClient
- en: Spring WebFlux includes a reactive client named `WebClient`, enabling us to
    perform HTTP requests in a non-blocking manner and to use reactive streams. `WebClient`
    can be used as an alternative to `RestTemplate`, which is used more traditionally.
    `WebClient` exposes reactive `ClientHttpRequest` and `ClientHttpResponse` objects.
    The bodies of these objects consist of reactive `Flux<DataBuffer>`, as opposed
    to traditional blocking stream implementation (`InputStream` and `OutputStream`).
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: Spring WebFlux 包含一个名为 `WebClient` 的反应式客户端，使我们能够以非阻塞方式执行 HTTP 请求并使用反应式流。`WebClient`
    可以作为 `RestTemplate` 的替代品，后者更传统地使用。`WebClient` 提供了反应式的 `ClientHttpRequest` 和 `ClientHttpResponse`
    对象。这些对象的内容由反应式的 `Flux<DataBuffer>` 组成，而不是传统的阻塞流实现（`InputStream` 和 `OutputStream`）。
- en: 'Create an instance of `WebClient`, perform a request, and then handle the response.
    The following is a code snippet showing the `WebClient` usage:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个 `WebClient` 实例，执行请求，然后处理响应。以下是一个展示 `WebClient` 使用的代码片段：
- en: '[PRE12]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '`WebClient` can be used from within both Spring MVC and Spring WebFlux web
    applications. `RestTemplate` usage can quite easily be swapped with `WebClient`,
    making use of the reactive advantages it provides.'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '`WebClient` 可以在 Spring MVC 和 Spring WebFlux 网络应用程序中使用。`RestTemplate` 的使用可以非常容易地与
    `WebClient` 交换，利用它提供的反应式优势。'
- en: In our sample project, we will cover the concepts and functionality of `WebClient`,
    using an example.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的示例项目中，我们将通过示例介绍 `WebClient` 的概念和功能。
- en: Reactive WebTestClient
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 反应式 WebTestClient
- en: Similar to `WebClient`, Spring WebFlux provides you with a non-blocking, reactive
    client named `WebTestClient`, to test your reactive APIs on your server. It has
    utilities that make testing these APIs easily in a test environment setup. `WebTestClient`
    can connect to any of the servers, as detailed earlier over an HTTP connection
    and execute necessary tests. However, the client has the capability of running
    the tests with and without a running server.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 与 `WebClient` 类似，Spring WebFlux 为您提供了一个非阻塞、反应式的客户端 `WebTestClient`，用于测试服务器上的反应式
    API。它具有使这些 API 在测试环境设置中易于测试的实用工具。`WebTestClient` 可以通过 HTTP 连接连接到任何服务器，如之前详细说明的那样，并执行必要的测试。然而，客户端具有在运行服务器的情况下和不运行服务器的情况下运行测试的能力。
- en: '`WebTestClient` also has a number of utilities to verify the response produced
    by executing these server side APIs. It can quite easily bind itself to the WebFlux
    web application and mock necessary request and response objects to ascertain the
    API''s functional aspects. `WebTestClient` can mutate the headers as needed, to
    simulate the desired test environment. You can get an instance of `WebTestClient`
    for your entire application (by using the `WebTestClient.bindToApplicationContext`
    method), or you can restrict it to specific controller (using the `WebTextClient.bindToController`
    method), `RouterFunction` (using the `WebTestClient.bindToRouterFunction` method),
    and so on.'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '`WebTestClient` 还提供了一些实用工具来验证执行这些服务器端 API 生成的响应。它可以非常容易地将自己绑定到 WebFlux 网络应用程序，并模拟必要的请求和响应对象，以确定
    API 的功能方面。`WebTestClient` 可以根据需要修改头信息，以模拟所需的测试环境。您可以通过使用 `WebTestClient.bindToApplicationContext`
    方法为整个应用程序获取 `WebTestClient` 实例，或者您可以使用 `WebTextClient.bindToController` 方法将其限制为特定的控制器，使用
    `WebTestClient.bindToRouterFunction` 方法限制为 `RouterFunction` 等。'
- en: We will see a detailed example of how `WebTestClient` works in a subsequent
    hands-on section (The *Sample project* section, under the *Testing (WebTestClient)*
    sub-section).
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的动手实践部分（在 *Sample project* 部分，位于 *Testing (WebTestClient)* 子部分下），我们将看到一个关于
    `WebTestClient` 如何工作的详细示例。
- en: Reactive WebSocket
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 反应式 WebSocket
- en: Spring WebFlux includes a reactive `WebSocket` client and server support based
    on the Java WebSocket API.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: Spring WebFlux 包含基于 Java WebSocket API 的反应式 `WebSocket` 客户端和服务器支持。
- en: 'On the server, create `WebSocketHandlerAdapter`, and then map each of those
    handlers to the URL. Since we don''t cover `WebSocket` in our sample application,
    let''s go into a bit more detail:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在服务器上，创建 `WebSocketHandlerAdapter`，然后将每个处理器映射到 URL。由于我们没有在我们的示例应用程序中涵盖 `WebSocket`，让我们更详细地了解一下：
- en: '[PRE13]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The `handle()` method takes in the `WebSocketSession` object and returns `Mono<Void>`
    when the handling of session is complete. `WebSocketSession` handles inbound and
    outbound messages using the `Flux<WebSocketMessage> receive()` and `Mono<Void>
    send(Publisher<WebSocketMessage>)` methods, respectively.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '`handle()` 方法接收 `WebSocketSession` 对象，并在会话处理完成后返回 `Mono<Void>`。`WebSocketSession`
    使用 `Flux<WebSocketMessage> receive()` 和 `Mono<Void> send(Publisher<WebSocketMessage>)`
    方法分别处理入站和出站消息。'
- en: 'In the web application Java configuration, declare a bean for `WebSocketHandlerAdpater`
    and create another bean to map the URL to the appropriate `WebSocketHandler`,
    as shown in the following code snippet:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在网络应用程序的 Java 配置中，声明一个 `WebSocketHandlerAdpater` 的 bean，并创建另一个 bean 将 URL 映射到适当的
    `WebSocketHandler`，如下面的代码片段所示：
- en: '[PRE14]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Spring WebFlux also provides `WebSocketClient` and has abstractions for all
    of the web servers discussed earlier, such as Netty, Jetty, and so on. Use appropriate
    server abstractions and create the client, as shown in the following code snippet:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: Spring WebFlux 还提供了 `WebSocketClient`，并为之前讨论的所有网络服务器提供了抽象，例如 Netty、Jetty 等。使用适当的网络服务器抽象，并创建客户端，如下面的代码片段所示：
- en: '[PRE15]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'In the client code, we can now subscribe to the `WebSocket`, endpoint and listen
    to messages and do the needful (basic `WebSocket` implementation). The code snippet
    for such a client on the frontend is as follows:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在客户端代码中，我们现在可以订阅 `WebSocket` 端点，并监听消息以及执行必要的操作（基本的 `WebSocket` 实现）。以下是在前端实现此类客户端的代码片段：
- en: '[PRE16]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: To keep the chapter focused and concise, we will not go over `WebSocket` security
    provided by Spring Security. In the last chapter of this book, we will quickly
    cover the `WebSocket` security, using an example.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使章节保持专注和简洁，我们不会深入探讨Spring Security提供的`WebSocket`安全。在本书的最后一章中，我们将通过一个示例快速覆盖`WebSocket`安全。
- en: Spring WebFlux authentication architecture
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Spring WebFlux认证架构
- en: With the core Spring WebFlux concepts covered, we will now get into the crux
    of this chapter; introducing you to Spring Security for Spring WebFlux based reactive
    web applications.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在掌握了核心的Spring WebFlux概念之后，我们现在将深入本章的核心内容；向您介绍适用于基于反应式Web应用的Spring WebFlux的Spring
    Security。
- en: 'As seen earlier, Spring Security in Spring MVC web applications is based on
    ServletFilter, and for Spring WebFlux, it is based on WebFilter:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，Spring MVC中的Spring Security基于ServletFilter，而对于Spring WebFlux，它基于WebFilter：
- en: '![](img/d1a354e7-4c45-4822-a724-6ffdeff0f5d6.png)'
  id: totrans-115
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d1a354e7-4c45-4822-a724-6ffdeff0f5d6.png)'
- en: 'Figure 6: Spring MVC and Spring WebFlux authentication approach'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 图6：Spring MVC和Spring WebFlux认证方法
- en: 'We saw Spring Security in detail in Spring MVC web applications in previous
    chapters. We will now look at the inner details of Spring Security authentication
    for a Spring WebFlux based web application. The following diagram shows the interaction
    of various classes when an authentication process kicks in for a WebFlux application:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在前几章中，我们详细介绍了Spring MVC中的Spring Security。现在，我们将探讨基于Spring WebFlux的Web应用的Spring
    Security认证的内部细节。以下图表显示了当WebFlux应用的认证过程启动时，各个类之间的交互：
- en: '![](img/fdb96ba6-52ca-4b7b-8b8f-1b0b76b71397.png)'
  id: totrans-118
  prefs: []
  type: TYPE_IMG
  zh: '![](img/fdb96ba6-52ca-4b7b-8b8f-1b0b76b71397.png)'
- en: 'Figure 7: Spring WebFlux authentication architecture'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 图7：Spring WebFlux认证架构
- en: The preceding diagram is quite self-explanatory, and is very similar to what
    you saw earlier for Spring MVC. The core difference is that `ServletFilter` is
    now replaced with `WebFilter`, and we have reactive-based classes for other blocking
    classes in Spring MVC. However, the core concepts of Spring Security remain intact
    with `WebFilter` dealing with many aspects in the initial authentication process;
    the core authentication is handled by `ReactiveAuthenticationManager` and related
    classes.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 上述图表相当直观，并且与您之前看到的Spring MVC中的图表非常相似。核心区别在于，现在的`ServletFilter`已被`WebFilter`所取代，并且我们在Spring
    MVC中的其他阻塞类中使用了基于反应式的类。然而，Spring Security的核心概念保持不变，`WebFilter`在初始认证过程中处理许多方面；核心认证由`ReactiveAuthenticationManager`和相关类处理。
- en: Spring WebFlux authorization
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Spring WebFlux授权
- en: 'Similar to authentication, the core concepts, in regard to authorization remains
    similar to what we have seen earlier in Spring MVC. However, the classes performing
    the operation have changed, and are, reactive and non-blocking. The following
    diagram shows the authorization-related main classes and their interactions in
    a Spring WebFlux application:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 与认证类似，关于授权的核心概念与我们在Spring MVC中看到的类似。然而，执行操作的类已经改变，它们是反应式和非阻塞的。以下图表显示了Spring
    WebFlux应用中与授权相关的主要类及其交互：
- en: '![](img/4cf1b7bb-eb58-4a8c-8658-b59deb16087c.png)'
  id: totrans-123
  prefs: []
  type: TYPE_IMG
  zh: '![](img/4cf1b7bb-eb58-4a8c-8658-b59deb16087c.png)'
- en: 'Figure 8: Authorization-related classes in a Spring WebFlux application'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 图8：Spring WebFlux应用中的授权相关类
- en: As we all know by now, Spring WebFlux security works on `WebFilter`, and `AuthorizationWebFilter` intercepts
    the request and uses `ReactiveAuthorizationManager` to check whether the `Authentication`
    object has access to a protected resource. `ReactiveAuthorizationManager` has
    two methods, namely, `check` (checks whether access is granted to an `Authentication`
    object) and `verify`(checks whether access has to be granted for an `Authentication`
    object). In the event of any exception, `ExceptionTranslationWebFilter` takes
    care of handling this by following the appropriate paths.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所知，Spring WebFlux的安全机制基于`WebFilter`，`AuthorizationWebFilter`拦截请求并使用`ReactiveAuthorizationManager`来检查`Authentication`对象是否有权访问受保护资源。`ReactiveAuthorizationManager`有两个方法，即`check`（检查是否授予`Authentication`对象访问权限）和`verify`（检查是否必须为`Authentication`对象授予访问权限）。在发生任何异常的情况下，`ExceptionTranslationWebFilter`会通过遵循适当的路径来处理这个问题。
- en: Sample project
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 示例项目
- en: Enough explanation; it's time to get our hands dirty with actual code. In this
    section, we will create a movie catalog site with integrated Spring Security.
    We will be using reactive concepts throughout and will use form-based login. We
    will start with hardcoded users and then see how we can look at a persistent user
    store to authenticate the users against. We will then into testing in more detail
    and finally look at some customizations that we can bring to Spring Security pages.
    Finally, we will touch base on authorization aspects and close the sample application.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 解释已经足够；现在是时候动手编写实际代码了。在本节中，我们将创建一个集成了Spring Security的电影目录网站。我们将使用反应式概念，并使用基于表单的登录。我们将从硬编码的用户开始，然后看看我们如何查看持久化用户存储以验证用户。然后我们将更详细地介绍测试，并最终查看我们可以对Spring
    Security页面进行的自定义。最后，我们将讨论授权方面，并关闭示例应用程序。
- en: WebFlux project setup
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: WebFlux项目设置
- en: We will create a basic WebFlux-based web application first, and will slowly
    add other features, including security, in it. The whole code is available in
    our book's GitHub page, under the chapter's folder, namely `spring-boot-webflux`.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先创建一个基于WebFlux的基本web应用程序，然后我们将逐步添加其他功能，包括安全性。整个代码可在我们书籍的GitHub页面上的章节文件夹中找到，名为`spring-boot-webflux`。
- en: I am using IntelliJ as my IDE, and since we are using *Lombok library* (annotation
    `preprocessor`), make sure to enable the Lombok plugin, so as to generate appropriate
    boilerplate code for your model. Our project is kept quite simple, and does the
    function of movie management (the movie CRUD operation).
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 我使用IntelliJ作为我的IDE，并且由于我们使用*Lombok库*（注解`preprocessor`），请确保启用Lombok插件，以便为您的模型生成适当的样板代码。我们的项目相当简单，并执行电影管理（电影CRUD操作）的功能。
- en: Maven setup
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Maven设置
- en: Using Spring Initializr for generating a Spring WebFlux project is really easy.
    But for us to get a handle on the various aspects of a WebFlux application, we
    will build aspect by ourselves. However, we will be using Spring Boot to run our
    application.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Spring Initializr生成Spring WebFlux项目非常简单。但为了让我们掌握WebFlux应用程序的各个方面，我们将自己构建方面。然而，我们将使用Spring
    Boot来运行我们的应用程序。
- en: 'We will create a maven project, and will then add the following main dependencies
    (to make the code shorter, only important dependencies are shown in the following
    code) to our `pom.xml`:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个Maven项目，然后将在我们的`pom.xml`中添加以下主要依赖项（为了使代码更简洁，以下代码中只显示了重要的依赖项）：
- en: '[PRE17]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'We will include snapshot repositories for both the library and plugin dependencies.
    Finally, we will add the all-important maven plugin for our Spring Boot, as follows:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将为库和插件依赖项都包含快照仓库。最后，我们将添加至关重要的Spring Boot Maven插件，如下所示：
- en: '[PRE18]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Configuration class
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置类
- en: Even though we are going to use default configurations as much as possible,
    we will still have separate configuration classes for various components. In our
    project, we are building a basic WebFlux application, thus we have only one configuration
    class.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们将尽可能使用默认配置，但我们仍将为各种组件分别创建配置类。在我们的项目中，我们正在构建一个基本的WebFlux应用程序，因此我们只有一个配置类。
- en: The SpringWebFluxConfig class
  id: totrans-139
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: SpringWebFluxConfig类
- en: 'The main configuration class for a Spring WebFlux web application is achieved
    by this class:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: Spring WebFlux web应用程序的主要配置类是通过这个类实现的：
- en: '[PRE19]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: We have an empty class with just some very important annotations as shown in
    the preceding code. `@EnableWebFlux` makes the application reactive and makes
    it WebFlux.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一个空类，其中只包含一些非常重要的注解，如前述代码所示。`@EnableWebFlux`使应用程序具有反应性，并使其成为WebFlux。
- en: Repository
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 仓库
- en: 'We will be using hardcoded movies as our data structure for this sample and
    will write methods in a reactive way, to expose methods in our repository class.
    These methods can be used to manipulate the data structure of the movies. Our
    repository class is a conventional one, but the right data structures, in the
    form of `Mono` and `Flux`, aid in bringing a reactive nature to the application:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将使用硬编码的电影作为我们的数据结构，并以反应式方式编写方法，以在我们的仓库类中公开方法。这些方法可以用来操作电影的数据结构。我们的仓库类是一个传统的类，但正确的数据结构，以`Mono`和`Flux`的形式，有助于使应用程序具有反应性：
- en: '[PRE20]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The class is just a snippet extracted from the class, and shows only one method
    (`getMovieById`). As always, our class implements an interface (`MovieRepository`),
    and this reference will be used in other parts of the application (using Spring's Dependency
    Injection capability).
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类只是从类中提取的一个片段，只显示了其中一个方法（`getMovieById`）。像往常一样，我们的类实现了一个接口（`MovieRepository`），这个引用将在应用程序的其他部分使用（使用Spring的依赖注入功能）。
- en: Handler and router
  id: totrans-147
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理器和路由器
- en: 'As detailed previously, we have two approaches, namely **functional-based**
    and **annotation-based**, for implementing a WebFlux application. Annotation-based
    is similar to Spring MVC, and because of this, we will be using functional-based
    approach in our sample application:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，我们有两种方法来实现WebFlux应用程序，即**基于函数式**和**基于注解**。基于注解的方法类似于Spring MVC，因此在我们的示例应用程序中我们将使用基于函数式的方法：
- en: '[PRE21]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The class is quite straightforward and uses a repository class for data structure
    query and manipulation. Each method accomplishes the functionality, and finally
    returns `Mono<ServerResponse>`. Another important aspect of WebFlux in functional-based
    programming is the routing configuration class, as follows:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类非常直接，使用存储库类进行数据结构查询和操作。每个方法完成其功能，最后返回`Mono<ServerResponse>`。WebFlux在基于函数式编程中的重要方面之一是路由配置类，如下所示：
- en: '[PRE22]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: This is the class that looks at the request and routes it to the appropriate
    handler method. In your application, you can have any number of router configuration
    files.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个查看请求并将其路由到相应处理方法的类。在你的应用程序中，你可以有任意数量的路由配置文件。
- en: Bootstrap application
  id: totrans-153
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 启动应用程序
- en: 'Our sample application uses Spring Boot. Spring WebFlux runs on a Reactor Netty
    server within Spring Boot by default. Our Spring Boot class is very basic and
    is as follows:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的示例应用程序使用Spring Boot。Spring WebFlux默认在Spring Boot内部的Reactor Netty服务器上运行。我们的Spring
    Boot类非常基础，如下所示：
- en: '[PRE23]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: You can run the application on any other server, apart from Spring Boot, and
    it is quite easy to achieve. We have a separate project named `spring-boot-tomcat-webflux`
    that runs on Spring Boot, but rather than running on Reactor Netty, it runs on
    a Tomcat server.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在任何其他服务器上运行应用程序，而不仅仅是Spring Boot，这相当容易实现。我们有一个名为`spring-boot-tomcat-webflux`的独立项目，它在Spring
    Boot上运行，但不是在Reactor Netty上运行，而是在Tomcat服务器上运行。
- en: 'No change is required in any part of the code, apart from `pom.xml`:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 除了`pom.xml`之外，代码的任何部分都不需要更改：
- en: '[PRE24]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: From the `spring-boot-starter-webflux` artifact, exclude Reactor Netty. Thereafter,
    explicitly add the Tomcat dependency, `spring-boot-starter-tomcat`. The rest of
    the `pom.xml` is kept intact. For other server runtimes, such as Undertow, Jetty,
    and so on, the approach is similar to the one detailed here.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 从`spring-boot-starter-webflux`组件中排除Reactor Netty。之后，明确添加Tomcat依赖项，`spring-boot-starter-tomcat`。`pom.xml`的其余部分保持不变。对于其他服务器运行时，如Undertow、Jetty等，方法与此处详细说明的类似。
- en: Running the application
  id: totrans-160
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行应用程序
- en: 'Now, for the most important part: running the application that we built. As
    it is a Spring Boot application, execute the default command as follows:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，对于最重要的部分：运行我们构建的应用程序。由于它是一个Spring Boot应用程序，按照以下默认命令执行：
- en: '[PRE25]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Once the server has started (default Rector Netty or Tomcat), open a browser
    and navigate to `localhost:8080/movies`. We have created default routing to point
    to "list all movies" endpoint and if all went well, you should see the JSON which
    shows all the hardcoded movies in our repository class.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦服务器启动（默认为Reactor Netty或Tomcat），打开浏览器并导航到`localhost:8080/movies`。我们已创建默认路由指向“列出所有电影”端点，如果一切顺利，你应该会看到显示我们存储库类中所有硬编码电影的JSON。
- en: In this section, we have created a sample Spring WebFlux movie application.
    We will add the all important security to this application in the next section.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们创建了一个示例Spring WebFlux电影应用程序。我们将在下一节中向这个应用程序添加所有重要的安全功能。
- en: Adding security
  id: totrans-165
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加安全功能
- en: To separate from what we have achieved up until now, we will have a separate
    project, `spring-boot-security-webflux` (the same as `spring-boot-webflux`). In
    it we will build all the security aspects.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 为了与我们现在所取得的成就分开，我们将有一个独立的项目，`spring-boot-security-webflux`（与`spring-boot-webflux`相同）。在这个项目中，我们将构建所有的安全方面。
- en: Configuration classes
  id: totrans-167
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置类
- en: We will be creating a new configuration class for Spring Security: `SpringSecurityWebFluxConfig`.
    Firstly, we will annotate the class with the most important annatation: `@EnableWebFluxSecurity`.
    This instructs it to enable Spring Security for WebFlux web applications. In the
    configuration class, we will look at two important beans, as follows.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将为 Spring Security 创建一个新的配置类：`SpringSecurityWebFluxConfig`。首先，我们将使用最重要的注解
    `@EnableWebFluxSecurity` 来注解这个类。这指示它为 WebFlux 网络应用程序启用 Spring Security。在配置类中，我们将查看两个重要的
    bean，如下所示。
- en: The UserDetailsService bean
  id: totrans-169
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: UserDetailsService bean
- en: 'We will use hardcoded user details, against which we will authenticate. This
    is not how it has to be done for a production-ready application, but for simplicity
    and to explain the concepts, let''s take this shortcut:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用硬编码的用户详情进行认证。这不是生产就绪应用程序必须这样做的方式，但为了简单和解释概念，让我们采取这个捷径：
- en: '[PRE26]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The bean returns the reactive user details service, containing hardcoded credentials
    for two users; one a normal user and the other an admin.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 该 bean 返回包含两个用户的硬编码凭证的响应式用户详情服务；一个普通用户和一个管理员。
- en: The SpringSecurityFilterChain bean
  id: totrans-173
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: SpringSecurityFilterChain bean
- en: 'This is the bean where we actually specify the Spring Security configuration:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们实际指定 Spring Security 配置的地方：
- en: '[PRE27]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Similar to what we saw earlier, in the Spring MVC application earlier, we match
    URL patterns and specify the role that is needed to access it. We are configuring
    the login method as a form in which the user will be shown the default login form
    by Spring Security.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 与我们之前看到的类似，在早期的 Spring MVC 应用程序中，我们匹配 URL 模式并指定访问它所需的角色。我们正在配置登录方法，用户将通过 Spring
    Security 显示默认登录表单。
- en: Running the application
  id: totrans-177
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行应用程序
- en: 'Execute the following command:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下命令：
- en: '[PRE28]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: When the server starts up, you have two ways in which you can test the application,
    as follows.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 当服务器启动时，你有两种方式可以测试应用程序，如下所示。
- en: CURL
  id: totrans-181
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: CURL
- en: 'Open your favorite Command Prompt and execute the following command:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 打开你喜欢的命令提示符并执行以下命令：
- en: '[PRE29]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'You will be redirected to the `http://localhost:8080/login` page. Your entire
    application is secured and without logging in, you will not be able to access
    any content. With form login as the method, you won''t be able to test it using
    `curl`. Let''s change the login method from form (`formLogin`) to basic (`httpBasic`)
    in the Spring Security configuration (the `springWebFilterChain` bean). Now, execute
    the following command:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 你将被重定向到 `http://localhost:8080/login` 页面。你的整个应用程序都是受保护的，如果没有登录，你将无法访问任何内容。使用表单登录作为方法，你将无法使用
    `curl` 进行测试。现在，让我们将 Spring Security 配置中的登录方法从表单（`formLogin`）更改为基本（`httpBasic`）（`springWebFilterChain`
    bean）。现在，执行以下命令：
- en: '[PRE30]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'You should now see the raw JSON displaying all of the hardcoded movies. Use
    other common CURL commands, as follows, to test other endpoints:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你应该能看到显示所有硬编码电影的原始 JSON。使用以下其他常见的 CURL 命令来测试其他端点：
- en: '[PRE31]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Browser
  id: totrans-188
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 浏览器
- en: 'Let''s put the login method back to form, and then open a browser and navigate
    to `http://localhost:8080`. You will be navigated to the default Spring Security
    login page. Enter the username as `admin` and the password as `password`, and
    click on Sign in:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将登录方法恢复为表单，然后打开浏览器并导航到 `http://localhost:8080`。你将被导航到默认的 Spring Security
    登录页面。输入用户名 `admin` 和密码 `password`，然后点击登录：
- en: '![](img/fe1f91c0-67a5-4870-8c70-74d01fe378db.png)'
  id: totrans-190
  prefs: []
  type: TYPE_IMG
  zh: '![](img/fe1f91c0-67a5-4870-8c70-74d01fe378db.png)'
- en: 'Figure 9: Default Spring Security login form'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9：默认 Spring Security 登录表单
- en: 'After successfully logging in, you will be navigated to the list all movies
    endpoint, as follows:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 登录成功后，你将被导航到列出所有电影的端点，如下所示：
- en: '![](img/7a0cd37d-e33b-4bb0-b2e5-64c2b9957c34.png)'
  id: totrans-193
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7a0cd37d-e33b-4bb0-b2e5-64c2b9957c34.png)'
- en: 'Figure 10: List all movies default home page after login'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10：登录后默认电影列表主页
- en: WebClient
  id: totrans-195
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: WebClient
- en: On the book's GitHub page, we have a separate project (`spring-boot-security-webclient-webflux`),
    in which you can see the entire code that will be detailed in this section.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的 GitHub 页面上，我们有一个单独的项目（`spring-boot-security-webclient-webflux`），其中你可以看到本节将详细说明的整个代码。
- en: Maven setup
  id: totrans-197
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Maven 设置
- en: 'Create a base maven project and add the following main dependency to your `pom.xml`
    file:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个基本的 Maven 项目，并将以下主要依赖项添加到你的 `pom.xml` 文件中：
- en: '[PRE32]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Now, add other dependencies, as well as the default Spring Boot build section.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，添加其他依赖项以及默认的 Spring Boot 构建部分。
- en: Creating a WebClient instance
  id: totrans-201
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建 WebClient 实例
- en: 'A `WebClient` instance can be created by using the `create()` method, or by
    using the `builder()` method. In our sample, we have used the `builder()` method,
    as follows:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过使用 `create()` 方法或使用 `builder()` 方法来创建 `WebClient` 实例。在我们的示例中，我们使用了 `builder()`
    方法，如下所示：
- en: '[PRE33]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: We will be using all of the endpoints that we have created earlier in our base
    Spring WebFlux project, and will be accessing them using the `WebClient`.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在我们的基础 Spring WebFlux 项目中使用我们之前创建的所有端点，并将使用 `WebClient` 来访问它们。
- en: 'Use the `create()` method to create an instance of `WebClient`, as follows:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `create()` 方法创建 `WebClient` 实例，如下所示：
- en: '[PRE34]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'If you have a base URL, `WebClient` can be created as follows:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有一个基本 URL，`WebClient` 可以创建如下：
- en: '[PRE35]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: The `builder()` method provides bunch of utility methods, such as filters, setting
    headers, setting cookies, and so on. In our example, we have set some default
    headers and have also set the base URL.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '`builder()` 方法提供了一组实用方法，例如过滤器、设置头部、设置 Cookie 等。在我们的示例中，我们设置了一些默认头部，并且也设置了基本
    URL。'
- en: Handling errors
  id: totrans-210
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理错误
- en: 'A `WebClient` instance allows you to handle errors (the `WebClientTestImpl`
    class) in the `listMovies()` method, as follows:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '`WebClient` 实例允许你在 `listMovies()` 方法中处理错误（`WebClientTestImpl` 类），如下所示：'
- en: '[PRE36]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '`SampleException` is a custom exception class that we created by extending
    the `Exception` class. We are handling 4xx and 5xx errors, and, when encountered,
    it sends the custom exception as response.'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '`SampleException` 是一个自定义异常类，我们通过扩展 `Exception` 类创建它。我们正在处理 4xx 和 5xx 错误，并且在遇到这些错误时，会发送自定义异常作为响应。'
- en: Sending requests and retrieving responses
  id: totrans-214
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 发送请求和检索响应
- en: 'The `retrieve()` method is a simple method, using which the response body can
    be retrieved. If you want to have more control over returned responses, the `exchange()`
    method can be used to retrieve the response. We have used both of the methods
    in our sample application; the code snippets for the two methods in the `WebClientTestImpl`
    class are as follows:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '`retrieve()` 方法是一个简单的方法，通过它可以检索响应体。如果你想对返回的响应有更多控制，可以使用 `exchange()` 方法来检索响应。我们在我们的示例应用中使用了这两种方法；`WebClientTestImpl`
    类中两种方法的代码片段如下：'
- en: '[PRE37]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: In the first method, we execute a GET method on the URI `http://localhost:8080/api/movie/{id}`,
    use the `retrieve()` method, and then convert into `Mono`.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一个方法中，我们在 URI `http://localhost:8080/api/movie/{id}` 上执行 GET 方法，使用 `retrieve()`
    方法，并将其转换为 `Mono`。
- en: In the second method, we execute a POST method on the URL `http://localhost:8080/api/movie`,
    use the `exchange()` method, and use the `flatMap()` method to create the response.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二个方法中，我们在 URL `http://localhost:8080/api/movie` 上执行 POST 方法，使用 `exchange()`
    方法，并使用 `flatMap()` 方法创建响应。
- en: Running and testing the application
  id: totrans-219
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行和测试应用程序
- en: We will be using the same movie model in this sample project. Since this is
    the only class that we need from our previous sample application, we will copy
    the class here. In an ideal scenario, we would have a JAR file containing all
    common classes, and it can be included in our `pom.xml` file.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例项目中，我们将使用相同的电影模型。由于这是我们从前一个示例应用中需要的唯一一个类，我们将在这里复制这个类。在理想情况下，我们会有一个包含所有常用类的
    JAR 文件，并且它可以包含在我们的 `pom.xml` 文件中。
- en: 'Create the `Run` class (as seen earlier) and call the `WebClient` methods.
    The code snippet for one of the methods is as follows:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 创建 `Run` 类（如前所述）并调用 `WebClient` 方法。其中一个方法的代码片段如下：
- en: '[PRE38]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: After executing each `WebClient` call, we will sleep for three seconds. Since
    `WebClient` methods emit reactive types (`Mono` or `Flux`), you have to subscribe,
    as shown in the preceding code.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 执行每个 `WebClient` 调用后，我们将暂停三秒钟。由于 `WebClient` 方法会发出反应式类型（`Mono` 或 `Flux`），你必须像前面代码中所示进行订阅。
- en: Start the `spring-boot-webflux` project, exposing the endpoints, which we will
    test by using `WebClient` in this project.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 启动 `spring-boot-webflux` 项目，公开端点，我们将使用此项目中的 `WebClient` 来测试这些端点。
- en: 'Make sure that your application''s default port is changed in your `application.properties`
    file by including the following entry:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 确保在 `application.properties` 文件中将你的应用程序的默认端口更改，包括以下条目：
- en: '[PRE39]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Start the application by executing the Spring Boot command, as follows:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 通过执行 Spring Boot 命令来启动应用程序，如下所示：
- en: '[PRE40]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'If all goes well, you should see the output in the server console, as follows:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一切顺利，你应该在服务器控制台中看到以下输出：
- en: '![](img/22f55554-5b13-4aa5-aeeb-10c9acc37545.png)'
  id: totrans-230
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/22f55554-5b13-4aa5-aeeb-10c9acc37545.png)'
- en: 'Figure 11: WebClient test execution'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11：WebClient 测试执行
- en: Unit testing (WebTestClient)
  id: totrans-232
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 单元测试（WebTestClient）
- en: 'In our base `spring-boot-webflux` project, we have written test cases using
    `WebTestClient`. We have two test cases: one to get all movies, and other to save
    movie.'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的基础`spring-boot-webflux`项目中，我们使用了`WebTestClient`编写了测试用例。我们有两个测试用例：一个用于获取所有电影，另一个用于保存电影。
- en: Maven dependency
  id: totrans-234
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Maven依赖项
- en: 'Make sure that you have the following dependencies in your `pom.xml` file:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 确保你的`pom.xml`文件中有以下依赖项：
- en: '[PRE41]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: As you can see, in the preceding code, all of the dependencies can be scoped
    for testing purposes.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，在前面的代码中，所有依赖项都可以针对测试目的进行范围限定。
- en: Test class
  id: totrans-238
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试类
- en: 'Create a normal test class, as follows. Use the `@Autowired` annotation to
    inject the `WebTestClient` instance in your test class:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个普通的测试类，如下所示。使用`@Autowired`注解将`WebTestClient`实例注入到你的测试类中：
- en: '[PRE42]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: The `WebTestClient` object's functionality is similar to `WebClient`, as seen
    earlier. We can check for various properties in the response to ascertain what
    we want to test. In the preceding example, for the first test, we are firing a
    GET request and checking for OK status, an application/JSON content type header,
    and, finally, a body having a list of `Movie` objects. In the second test, we
    are firing a POST request with a `Movie` object as the body, and, expecting an
    OK status and an empty body.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: '`WebTestClient`对象的功能与前面看到的`WebClient`类似。我们可以检查响应中的各种属性，以确定我们想要测试的内容。在前面的示例中，对于第一个测试，我们正在发送一个GET请求并检查OK状态、application/JSON内容类型头，最后是一个包含`Movie`对象列表的正文。在第二个测试中，我们正在发送一个带有`Movie`对象正文的POST请求，并期望OK状态和空正文。'
- en: Spring Data
  id: totrans-242
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Spring Data
- en: Even though this book is focused on Spring Security on reactive concepts, I
    really want you to have some idea of reactive concepts in other areas as well.
    So, there is a separate project, `spring-boot-security-mongo-webflux`, which looks
    at implementing reactive concepts by integrating the earlier project with reactive
    MongoDB, using Spring Data. Covering every aspect in regard to this is not something
    that we will do. However, with the earlier project as a base, we will cover some
    of the important aspects in this section.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这本书主要关注Spring Security和响应式概念，但我真的希望你对其他领域的响应式概念也有所了解。因此，有一个单独的项目，`spring-boot-security-mongo-webflux`，它通过将早期项目与响应式MongoDB集成，使用Spring
    Data来实现响应式概念。我们不会涵盖这个方面的每一个细节。然而，以早期项目为基础，我们将在本节中介绍一些重要方面。
- en: Maven dependency
  id: totrans-244
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Maven依赖项
- en: 'In your application `pom.xml`, add the following dependencies, both dealing
    with MongoDB inclusion into the project:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的`application `pom.xml`中，添加以下依赖项，这两个依赖项都与将MongoDB包含到项目中有关：
- en: '[PRE43]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: I have installed MongoDB on my machine. I have started the database locally
    on the default port (`27017`).
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 我已经在我的机器上安装了MongoDB。我已经在默认端口（`27017`）上本地启动了数据库。
- en: MongoDB configuration
  id: totrans-248
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: MongoDB配置
- en: 'Add the following to your application.properties file:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下内容添加到你的`application.properties`文件中：
- en: '[PRE44]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: We will be pointing our DB to a locally running DB on the default port utilizing
    the movie database.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将把我们的数据库指向默认端口上本地运行的数据库，使用电影数据库。
- en: Setting up a model
  id: totrans-252
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置模型
- en: In our already existing `Movie` model, we just added one more annotation: `@Document(collection
    = "movies")`. This annotation will inform MongoDB as to the name of the collection
    in the DB where this model will be stored.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们已存在的`Movie`模型中，我们只添加了一个额外的注解：`@Document(collection = "movies")`。这个注解将通知MongoDB，这个模型将在数据库中存储的集合名称。
- en: Implementing a repository
  id: totrans-254
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现存储库
- en: 'We will create a new repository, `ReactiveMovieRepository`, with our two curated
    methods and all of the default methods provided by our extended class:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个新的存储库，`ReactiveMovieRepository`，包含我们精心挑选的两个方法和我们扩展类提供的所有默认方法：
- en: '[PRE45]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: We will extend our repository from `ReactiveMongoRepository`. `ReactiveMongoRepository`
    has loads of common methods that can be used right away, without any trouble.
    The methods that we have implemented use plain queries against the MongoDB and
    return the list.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将我们的存储库从`ReactiveMongoRepository`扩展。`ReactiveMongoRepository`提供了许多可以直接使用而无需任何麻烦的常用方法。我们实现的方法使用对MongoDB的普通查询，并返回列表。
- en: Implementing a controller
  id: totrans-258
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现控制器
- en: 'To make it separate from our existing functional-based programming, we have
    created a new controller that will expose some of the methods in a RESTful way,
    using the newly created `ReactiveMovieRepository`:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使其与现有的基于功能的编程分离，我们创建了一个新的控制器，该控制器将以RESTful方式公开一些方法，使用新创建的`ReactiveMovieRepository`：
- en: '[PRE46]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: The class is quite straightforward; each method has appropriate mapping and
    uses corresponding repository classes to actually do the job.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类相当简单；每个方法都有适当的映射，并使用相应的存储库类来实际执行任务。
- en: Running the application
  id: totrans-262
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行应用程序
- en: 'Using the `mongod` command, we will start the locally installed MongoDB and
    then using the following command, we will start the project we just created:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `mongod` 命令，我们将启动本地安装的 MongoDB，然后使用以下命令，我们将启动我们刚刚创建的项目：
- en: '[PRE47]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Head over to postman and call the URL `http://localhost:8080/movies` (GET).
    You will see an array with zero elements in it. Now, call the URL `http://localhost:8080/movies`
    (POST), with the following JSON in the body:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 访问 Postman 并调用 URL `http://localhost:8080/movies` (GET)。你将看到一个包含零个元素的数组。现在，调用
    URL `http://localhost:8080/movies` (POST)，并在体中包含以下 JSON：
- en: '[PRE48]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: You will get a 200 OK status, and should see the newly created JSON as a response.
    Now, if you run the GET request on movies endpoint, you should see the newly created
    `Movie` as a response.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 你将获得 200 OK 状态，并应该看到作为响应的新创建的 JSON。现在，如果你在电影端点上运行 GET 请求，你应该看到新创建的 `Movie` 作为响应。
- en: Here, we implemented CRUD in our `Movie` model by using MongoDB as a persistence
    store in a reactive programming paradigm.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们通过在反应式编程范式中使用 MongoDB 作为持久化存储，在我们的 `Movie` 模型中实现了 CRUD。
- en: Authorization
  id: totrans-269
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 授权
- en: In the past, we already saw that using the `@EnableWebFluxSecurity` annotation,
    we can get URL security. Spring Security also allows you to secure method execution
    in a reactive way, by using another annotation, `@EnableReactiveMethodSecurity`.
    The concept is the same what we saw in earlier examples based on Spring MVC. We
    will just cover method security in this section; the rest of the aspects are exactly
    the same and we will avoid replication here.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 在过去，我们已经看到，使用 `@EnableWebFluxSecurity` 注解，我们可以获得 URL 安全性。Spring Security 还允许你以反应式方式安全地执行方法，通过使用另一个注解
    `@EnableReactiveMethodSecurity`。这个概念与我们在早期基于 Spring MVC 的示例中看到的是相同的。我们将在本节中仅涵盖方法安全；其余方面完全相同，我们将避免重复。
- en: Method security
  id: totrans-271
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 方法安全
- en: 'To enable method security, first, annotate the Spring Security configurations
    class with `@EnableReactiveMethodSecurity`:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 要启用方法安全，首先，使用 `@EnableReactiveMethodSecurity` 注解标注 Spring Security 配置类：
- en: '[PRE49]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'After that, for any method that you would like to have some security features
    for, use all of the various security-related annotations discussed in previous
    chapters:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，对于任何你想要添加一些安全特性的方法，使用在前几章中讨论的所有各种安全相关注解：
- en: '[PRE50]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: In the preceding method, we are directing Spring Security that the method execution
    for `getAllMovies()` should be allowed if the user is authenticated and has the `ADMIN`
    role granted.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的方法中，我们指导 Spring Security，如果用户已认证并且授予了 `ADMIN` 角色，则允许 `getAllMovies()` 方法的执行。
- en: Customization
  id: totrans-277
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自定义
- en: Spring Security allows for a number of customizations. The default pages produced
    by Spring Security, such as login form, logout form, and so on, can be fully customized
    in all aspects suiting your application's brand. If you would like to tweak Spring
    Security's default execution, implementing your own filter is appropriate. Since
    Spring Security depends heavily on filters to achieve its functionality, let's
    look at the customization opportunity in this.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Security 允许进行许多自定义。Spring Security 生成的默认页面，如登录表单、注销表单等，可以在所有方面完全自定义，以适应你应用程序的品牌。如果你想要调整
    Spring Security 的默认执行，实现你自己的过滤器是合适的。由于 Spring Security 严重依赖于过滤器来实现其功能，让我们看看这个方面的自定义机会。
- en: In addition, almost all parts of Spring Security can be customized by using
    your own classes, and then plugged into the Spring Security default flow to manage
    your own customizations.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，几乎 Spring Security 的所有部分都可以通过使用你自己的类来自定义，然后将其插入到 Spring Security 默认流程中，以管理你自己的自定义。
- en: Writing custom filters
  id: totrans-280
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写自定义过滤器
- en: As we saw earlier, in a WebFlux web application, Spring Security works based
    on `WebFilter` (similar to Servlet Filter in Spring MVC). If you would like to
    customize certain aspects in Spring Security, especially in request and response
    manipulation, implementing a custom `WebFilter` is one of the approaches that
    can be looked at.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们之前所见，在 WebFlux 网络应用程序中，Spring Security 基于过滤器 `WebFilter`（类似于 Spring MVC 中的
    Servlet Filter）工作。如果你想要自定义 Spring Security 的某些方面，特别是在请求和响应处理方面，实现一个自定义的 `WebFilter`
    是可以探讨的方法之一。
- en: 'Spring WebFlux offers two approaches to implement filters:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: Spring WebFlux 提供了两种实现过滤器的方法：
- en: '**Using** `WebFilter`: Works for both annotation-based and functional-based
    (`routerhandler`)'
  id: totrans-283
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**使用** `WebFilter`：适用于基于注解和基于功能（`routerhandler`）'
- en: '**Using** `HandlerFilterFunction`: Works only with functional-based'
  id: totrans-284
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**使用** `HandlerFilterFunction`：仅适用于基于功能的'
- en: Using WebFilter
  id: totrans-285
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用WebFilter
- en: 'We will be building on top of our project, `spring-boot-webflux`. To make it
    isolated from other projects, we will create a new project, `spring-boot-webflux-custom`.
    As indicated previously, using `WebFilter` applies to both annotation-based and
    functional-based WebFlux approaches. In our example, we''ll have two paths: `filtertest1`
    and `filtertest2`. We will write test cases using `WebFluxTestClient`, and will
    assert certain conditions. Being separate from the rest, we will create a new
    routing config, a handler, and an entirely new REST controller. We will not go
    into detail on some of the aspects already covered. In this section, we will just
    go through the `WebFilter` code, and also some important aspects of the test cases:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在我们的项目`spring-boot-webflux`的基础上进行构建。为了使其与其他项目隔离，我们将创建一个新的项目，`spring-boot-webflux-custom`。如前所述，使用`WebFilter`适用于基于注解和基于功能的WebFlux方法。在我们的示例中，我们将有两个路径：`filtertest1`和`filtertest2`。我们将使用`WebFluxTestClient`编写测试用例，并断言某些条件。作为一个独立的单元，我们将创建一个新的路由配置、一个处理器以及一个全新的REST控制器。我们不会详细讨论已经覆盖的一些方面。在本节中，我们将只通过`WebFilter`代码，以及测试用例的一些重要方面：
- en: '[PRE51]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'The `SampleWebFilter` class implements `WebFilter`, and also implements the
    `filter` method. In this class, we will add a new response header, `filter-added-header`:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: '`SampleWebFilter`类实现了`WebFilter`接口，并且也实现了`filter`方法。在这个类中，我们将添加一个新的响应头部，`filter-added-header`：'
- en: '[PRE52]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: In both test cases, for both paths, we will check for newly added headers. When
    you run the test cases (using `mvn test`), it will confirm this finding.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 在这两个测试用例中，对于所有路径，我们将检查新添加的头部信息。当你运行测试用例（使用`mvn test`）时，它将确认这一发现。
- en: Using HandlerFilterFunction
  id: totrans-291
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用HandlerFilterFunction
- en: 'We will implement a new `HandlerFilterFunction`, `SampleHandlerFilterFunction`,
    in which we will look at a path variable (`pathVariable`) and check for its value.
    If the value is equal to `value2`, we will mark the status as `BAD_REQUEST`. It''s
    important to note that since `HandlerFilterFunction` applies only to functional-based,
    even though the path variable value is equal to `value2`, the status is not stamped
    as `BAD_REQUEST`, and the response received is OK:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将实现一个新的`HandlerFilterFunction`，即`SampleHandlerFilterFunction`，我们将查看一个路径变量（`pathVariable`）并检查其值。如果值等于`value2`，我们将标记状态为`BAD_REQUEST`。需要注意的是，由于`HandlerFilterFunction`仅适用于基于功能的，即使路径变量值等于`value2`，状态也不会被标记为`BAD_REQUEST`，接收到的响应是OK：
- en: '[PRE53]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: '`SampleHandlerFilterFunction` implements the `HandlerFilterFunction` class,
    and also implements the `filter` method. In this class, we will explicitly set
    the response status as a bad request, if a condition is met:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: '`SampleHandlerFilterFunction`类实现了`HandlerFilterFunction`类，并且也实现了`filter`方法。在这个类中，如果满足某个条件，我们将明确地将响应状态设置为错误请求：'
- en: '[PRE54]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: In the preceding test cases, the path tested is different, and since `HandlerFilterFunction`
    applies only to functional-based, the response is OK when the path is `filtertest1`,
    and it's `BAD_REQUEST` when the path is `filtertest2`.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的测试用例中，测试的路径不同，由于`HandlerFilterFunction`仅适用于基于功能的，当路径是`filtertest1`时响应是OK，当路径是`filtertest2`时是`BAD_REQUEST`。
- en: Summary
  id: totrans-297
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, for the first time in this book, we went over the details of
    reactive programming, using the Spring WebFlux framework. We started off by giving
    adequate details on the framework itself at a high level. We went over a very
    basic example, and then, introduced you to Spring Security and its functionality
    with Spring WebFlux.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，本书第一次详细介绍了使用Spring WebFlux框架进行反应式编程的细节。我们从对框架本身的高层次细节进行充分介绍开始。我们讨论了一个非常基础的例子，然后，向您介绍了Spring
    Security及其与Spring WebFlux的功能。
- en: Finally, we went through a hands-on coding session, with a sample application.
    In this example, we covered other reactive aspects, such as Spring Data Mongo,
    so as to give you more insight into the reactive world.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们进行了一次实战编码环节，使用了一个示例应用程序。在这个例子中，我们涵盖了其他反应式方面，如Spring Data Mongo，以便让你对反应式世界有更深入的了解。
- en: We ended the chapter with some of the customization possible in Spring WebFlux
    with Spring Security.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在章节结束时介绍了Spring WebFlux与Spring Security的一些可能的定制。
- en: Having read this chapter, you should have a clear idea of the differences between
    the Spring MVC and Spring WebFlux frameworks. You should also have a good understanding
    of the workings of Spring WebFlux security using the Spring Security module. The
    examples are meant to be simple in nature and as we are undressing Spring Security
    in this book, those aspects are given more value in the explanations.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 阅读完本章后，你应该对 Spring MVC 和 Spring WebFlux 框架之间的区别有一个清晰的认识。你也应该对使用 Spring Security
    模块操作 Spring WebFlux 安全性的工作原理有一个良好的理解。示例旨在保持简单，由于我们在本书中逐步剖析 Spring Security，因此在解释中这些方面被赋予了更高的价值。
