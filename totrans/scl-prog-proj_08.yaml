- en: Online Shopping - User Interface
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we are going to use Scala.js to build the user interface. In
    this interface, you can select a product to add to your cart, update the number
    of products that you wish to buy, and remove them from the cart if needed.
  prefs: []
  type: TYPE_NORMAL
- en: Scala.js is a project initiated by Sebastien Doeraene back in 2013\. This project
    is mature and provides a clean way to build frontend applications. Indeed, you
    can code with a strongly-typed system to avoid stupid mistakes, but this is not
    only for strong typing; the code—written in Scala—is compiled into a highly efficient
    JavaScript. It can interoperate with all of the JavaScript frameworks. Moreover,
    the code can be shared between the front-end and the back-end developers. This
    feature simplifies communication between developers, as they are using the same
    concepts and classes.
  prefs: []
  type: TYPE_NORMAL
- en: Thanks to its interoperability, there are multiple ways to use Scala.js. You
    can use an HTML template and adapt it to interoperate with Scala.js. For example,
    you can buy the excellent SmartAdmin ([https://wrapbootstrap.com/theme/smartadmin-responsive-webapp-WB0573SK0](https://wrapbootstrap.com/theme/smartadmin-responsive-webapp-WB0573SK0))
    template (HTML5 version) as a base for the layout and all of the components/widgets,
    and then use Scala.js to implement the specific behaviors.
  prefs: []
  type: TYPE_NORMAL
- en: Another way is to start from scratch and build the HTML layout, CSS, components,
    and behaviors using the Scala.js ecosystem. This is the option that we will choose
    in this book. To generate the HTML and CSS, ScalaTags ([http://www.lihaoyi.com/scalatags/](http://www.lihaoyi.com/scalatags/))
    from Li Haoyi ([http://www.lihaoyi.com/](http://www.lihaoyi.com/)) will be used.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter will explain how to develop a dynamic web UI using Scala.js.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Defining the layout
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating the layout
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building the layout
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Main layout
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Product list panel
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Cart panel
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introducing the UI manager
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learning objectives
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The objectives of this chapter are to introduce a user interface into our project
    and interact with the server to get data from it.
  prefs: []
  type: TYPE_NORMAL
- en: 'More precisely, we will learn the following skills:'
  prefs: []
  type: TYPE_NORMAL
- en: How to develop a simple web UI
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to apply styles
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to interact with the server using a web service call
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to debug Scala code on the client side
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Note that this setup has already been completed when you start using the template.
    The following steps are only for reference:'
  prefs: []
  type: TYPE_NORMAL
- en: 'To enable Scala.js with Play, you first need to add the following code to `project`/`plugins.sbt`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `build.sbt`, you need to add the plugins by adding the following code
    in the `client` variable:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'You need to add the ScalaTags dependency by adding the following in `libraryDependencies`
    of the client configuration:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Defining the layout
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For the purpose of this book, the shopping cart is designed as shown in the
    following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6ff8c185-587f-4c23-8bb9-6d9509b41240.png)'
  prefs: []
  type: TYPE_IMG
- en: On the left-hand side, a panel lists all of the products with all of their details.
    Underneath, a button adds the product to the cart. On the right-hand panel, there
    is a list of all of the products that have been added to the cart. On the **Cart Panel**,
    the number of products can be changed by clicking on the number and entering the
    right number. Each line has a button to delete the product from the list.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the layout
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Multiple technologies are used to create the layout—more specifically, the top
    layout—using the `<html>` and `<body>` tags, and the two `div` containers for
    the products and the cart panels respectively are going to be built with a Play
    template engine, named Twirl. Using this template, the inner HTML of the product
    and cart instances of `div` are going to be filled with ScalaTags.
  prefs: []
  type: TYPE_NORMAL
- en: Let's first create the main entry point. We named it `index.html`, and it is
    implemented by creating a file called `index.scala.html` in the `view` package
    of the server.
  prefs: []
  type: TYPE_NORMAL
- en: 'The content is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: This file looks like a standard HTML file. In fact, this file is a template
    that is processed by the server.
  prefs: []
  type: TYPE_NORMAL
- en: The first line starts with an `@` character. It defines the input parameter
    that is passed by the caller, but who is calling this template? It is the `index()`
    function in the `Application` controller that calls the template, and effectively,
    the template is called by using the title of the page.
  prefs: []
  type: TYPE_NORMAL
- en: On the line starting with `@scalajs.html.scripts`, we are using a helper method
    provided by the `sbt-web-scalajs` plugin. This method retrieves all of the scripts
    generated by the `client` Scala.js project.
  prefs: []
  type: TYPE_NORMAL
- en: The two instances of `div` are going to be set from the code; we will look at
    this in more detail in the next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Building the page
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will have two main sections on the main page: the product list and the cart.'
  prefs: []
  type: TYPE_NORMAL
- en: To create the layout, we could use basic HTML tags, such as `table` and `div`,
    but this is quite laborious for our task. Instead, let's introduce a framework
    named Bootstrap ([https://getbootstrap.com/](https://getbootstrap.com/)[).](https://getbootstrap.com/)
  prefs: []
  type: TYPE_NORMAL
- en: This open source framework is widely used and very mature. It allows us to build
    a responsive website based on a grid, with a lot of components such as notifications,
    menus, badges, and tooltips. Bootstrap needs a CSS and some JavaScript libraries
    to work.
  prefs: []
  type: TYPE_NORMAL
- en: 'For now, we just need to add the Bootstrap CSS by adding the link in the HTML
    header, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Main layout
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In Bootstrap, a grid is a container composed of rows, each with 12 columns.
    A `class` attribute is used to define the type of `div`.
  prefs: []
  type: TYPE_NORMAL
- en: So, in our case, we would like to have the product list occupy two-thirds of
    the screen, with the cart getting the rest of `row`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The structure of the body in our `index.scala.html` is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Product list panel
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To structure our HTML page, we are going to create a panel called `productPanel`.
    This panel is a container for all product details.
  prefs: []
  type: TYPE_NORMAL
- en: 'A product is defined with a name, description, and button to add it to the
    cart, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a5831e93-4191-4718-b456-44238369c614.png)'
  prefs: []
  type: TYPE_IMG
- en: 'As we have multiple products, we would like to add each one in `productPanel`
    and fit the total width of `productPanel`, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1f47f425-56d8-4cf7-97d3-6e578e1ed0c4.png)'
  prefs: []
  type: TYPE_IMG
- en: 'To reach this goal, we can recreate a row inside `productPanel`, with `products`
    forming a column of the row, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: There we go. The main layout is done. Now we have to create the HTML product's
    representation as `div`, with its name, description, price, and a button to add
    it to the cart.
  prefs: []
  type: TYPE_NORMAL
- en: This looks almost the same as what we did when we modeled the product for the
    database. Wouldn't it be great if we could reuse the model created on the server
    side on the client? As we are using Scala.js, this is possible; indeed, we are
    using the same language. This is what we call an **isomorphic** **application**.
  prefs: []
  type: TYPE_NORMAL
- en: All we have to do is move the model code from the server project to the shared
    project. Using IntelliJ, just drag the `Models.scala` file from `server/app/models`
    to `shared/src/main/scala/io/fscala/shopping/shared`. By doing so, we can use
    the same model to create our product representation.
  prefs: []
  type: TYPE_NORMAL
- en: Create a new class named `ProductDiv` under `client/src/main/scala/io/fscala/shopping`.
    This class represents the HTML content of a product with a button to add itself
    to the cart.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `ProductDiv` class contains the `Product` model, and looks like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The main method is the `content` method. It creates the product description
    and the button.
  prefs: []
  type: TYPE_NORMAL
- en: The `getProductDescription` method creates an HTML `div` with a paragraph for
    each of its properties.
  prefs: []
  type: TYPE_NORMAL
- en: The `getButton()` method creates an HTML button and uses the `addToCart` function
    to handle the `onclick` event. For now, we are not going to look at the implementation
    details of the `onclick` event.
  prefs: []
  type: TYPE_NORMAL
- en: Cart panel
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The cart panel is a representation of the cart. It has a line for every product
    that is added, displaying the number of items, the name of the item type, the
    total price, and a button to remove it from the cart, as shown in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/bb709f62-78c1-4eb9-8cea-4561a58391af.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We would like to add a line each time a new product is added to the cart, as
    shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0113d396-0a16-47a6-ae9e-020e6906ef59.png)'
  prefs: []
  type: TYPE_IMG
- en: 'In this case, we do not need to modify the main layout as we are going to represent
    each line as a row with columns. The model of a line in the cart is shown in the
    following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The HTML content of the cart is shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The previous code is for a row with four columns. The code for the button to
    delete it from the cart (`getDeleteButton`) is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Note how you can add a listener to an event emitted by the component just by
    adding the method name on the `onclick` event. For now, we are not going to implement
    the action, and will leave it unimplemented (`???`), as shown in the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The `input` text field representing the quantity in the cart (`quantityInput`)
    is written as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Again, on the `onchange` event, we call the `changeQty` function, defined as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The product name (`getProductLabel`) is written as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, the total price is written as `getPriceLabel`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: As we will have the definition of a line in the cart, we can define the cart's `div`.
  prefs: []
  type: TYPE_NORMAL
- en: 'This `div` should provide an HTML representation of all of the lines and allow
    you to add a cart `line`. The implementation is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Upon its creation, `CartDiv` receives the list of lines represented by the `lines`
    value.
  prefs: []
  type: TYPE_NORMAL
- en: To get the HTML representation, the `content` function is called. In this function,
    we create an empty `div` and then append each `CartLine` into that `div`.
  prefs: []
  type: TYPE_NORMAL
- en: This is implemented using `foldLeft`. The empty `div` is created as the initial
    value, and then for each `CartLine` an anonymous function is called with `(a,
    b)` as parameters. The `a` parameter is the previous value (the empty `div` on
    the first iteration) and the `b` parameter is the next `CartLine` of the collection.
    The body of the method just appends the content of `CartDiv` to `div` and returns
    `div` for the next iteration.
  prefs: []
  type: TYPE_NORMAL
- en: We added a function to add a product to `div` (`addProduct()`). We could have
    implemented this method by creating a mutable variable that holds the list of
    `CartLine` and updates it each time we want to add `CartLine`, but this would
    not be in the spirit of functional programming.
  prefs: []
  type: TYPE_NORMAL
- en: Instead, a new `CartDiv` with `new CartLine` that we added is returned from
    the function call.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have defined the product `div` and the cart `div`, it is time to
    build the interaction between these instances of `div`.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing the UI manager
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: At some point, we will need to have a class that is responsible for the workflow
    of the user experience. For example, when a user clicks on the Add to cart button,
    the product has to be added to the cart at the server level and the user interface
    has to be updated.
  prefs: []
  type: TYPE_NORMAL
- en: The UI manager takes responsibility for managing the workflow of the user experience,
    handling all communication with the server when needed, and is used as an entry
    point to start the Scala.js code. This is the main entry point of our client application
    when the application is executed in the browser.
  prefs: []
  type: TYPE_NORMAL
- en: For communicating with the server, we are going to use jQuery. This JavaScript
    library is widely used and is a reference in the JavaScript world.
  prefs: []
  type: TYPE_NORMAL
- en: This is one of the advantages of Scala.js. We can use existing JavaScript libraries,
    such as jQuery, from Scala. To use existing JavaScript libraries, we only need
    to define an interface, which is called a **facade** in Scala.js. The facade can
    be seen as an interface to redefine the JavaScript type and the JavaScript function
    signature. It means we need a facade for all of the JavaScript libraries we want
    to use. Fortunately, there are already a number of facades that already exist
    for the most important JavaScript frameworks. A list of available facades can
    be found at the Scala website ([https://www.scala-js.org/libraries/facades.html](https://www.scala-js.org/libraries/facades.html)).
  prefs: []
  type: TYPE_NORMAL
- en: Adding jQuery to our project
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To add jQuery and its facade into our project, we need to add the Scala facade
    and the JavaScript library.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the facade, add the following dependency to the `libraryDependencies` variable
    in the `build.sbt` file :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'To add the JavaScript library, add the following dependency to the `jsDependencies` variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: This is the first library we are using in which we are adding a WebJar as a
    JavaScript library. This WebJar is a repository of JavaScript libraries packaged
    as a JAR file.
  prefs: []
  type: TYPE_NORMAL
- en: Calling our API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The first call we have to perform is the login to the server. For the purposes
    of this book, we have not designed a proper login page. Besides, the login itself
    is not really a login as it accepts any user!
  prefs: []
  type: TYPE_NORMAL
- en: We are going to log in with a random user every time we browse the index of
    the website.
  prefs: []
  type: TYPE_NORMAL
- en: By the way, what is the entry point of our client application?
  prefs: []
  type: TYPE_NORMAL
- en: Setting the main method
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'By default, Scala.js only creates a JavaScript library with all your dependencies.
    To make it an application, you have to add the client configuration of the `build.sbt` file,
    as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Once defined, Scala.js looks for an object containing the `main` method, as
    in a normal JVM application. We can create that object in the `client/src/main/scala/io/fscala/shopping/client` folder. Create
    a Scala file named `UIManager.scala`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `main` function, we would like to log in to the API and initialize the
    interface with `ProductDiv` and `CartDiv`, which we defined earlier, as shown
    in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'We define three properties on the `UIManager` object:'
  prefs: []
  type: TYPE_NORMAL
- en: The first is the `origin` property. This property uses the `dom` utility object
    from Scala.js; we will get `document.location.origin` from it. This represents
    the server location, with the protocol, hostname, and port. In development mode,
    this looks like `http://locahost:9000`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The second property is `cart`, representing `CartDiv`. This is to keep a reference
    to it on the manager for later use. In the `main` function, we perform the login
    with a hardcoded user and, once successful, we initialize the user interface.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The last property is `dummyUserName`, representing a randomly generated username.
    This will simplify the code as we are not going to implement a real login process.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note how we can use jQuery from Scala. This is the beauty of the facade—we can
    use almost the same syntax as in JavaScript but with the advantage of strong Scala
    typing.
  prefs: []
  type: TYPE_NORMAL
- en: For example, to create the settings of the `post` call, we can use a method
    on the `JQueryAjaxSettings` object instead of creating a `Map` with a string as
    a key and anything as a value. This way, it is less error-prone, and we can take
    advantage of the IDE to autocomplete all of the possible properties.
  prefs: []
  type: TYPE_NORMAL
- en: 'The signature of the `done` jQuery function is `Function` (`PlainObject` data,
    `String textStatus`, jqXHR). You can find out more about these types on the jQuery
    website:'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://api.jquery.com/Types/#Function](http://api.jquery.com/Types/#Function)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[http://api.jquery.com/Types/#PlainObject](http://api.jquery.com/Types/#PlainObject)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[http://api.jquery.com/Types/#String](http://api.jquery.com/Types/#String)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[http://api.jquery.com/Types/#jqXHR](http://api.jquery.com/Types/#jqXHR)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This function takes three parameters, but as we are just interested in the
    first one, the `data` response, we can ignore the others. This is a particularity
    of JavaScript. The implementation of the corresponding facade is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: The function uses variadic parameters, noted with the asterisk character after
    the type. This is a perfect match with JavaScript, where the parameters are not
    mandatory.
  prefs: []
  type: TYPE_NORMAL
- en: It is now time to look at the creation of the user interface based on the data
    coming from the server.
  prefs: []
  type: TYPE_NORMAL
- en: Initializing the user interface
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To initialize the user interface, we need to get all of the products from the
    database—including the cart for the user, if there are any—through the web service
    API and add it to the layout. The code for this looks like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: It will come as no surprise that we use jQuery to perform the `GET` method on
    the API. The `dataType` asks for a text response, so that we can use Circe to
    parse the response and transform it into a sequence of `Product`.
  prefs: []
  type: TYPE_NORMAL
- en: But, is `decode[Seq[Product]]` the same code that we used in [Chapter 2](f2a68dcf-78e4-452e-b2bb-8b40f22a55c9.xhtml), *Developing
    a Retirement Calculator*, the REST API, when we received JSON and converted it
    into a class?
  prefs: []
  type: TYPE_NORMAL
- en: Yes, we are using the same code with the same framework (Circe) to decode JSON
    and encode the class to JSON! The code running on the server, compiled as a JVM
    bytecode, is the same as the one running on the client, compiled as JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: Once we get the list of products, for each of them, we add `ProductDiv` in the `products`
    container. Again, jQuery is used to get an HTML element using its `id` attribute.
    At this point, knowledge of jQuery is more important than the Scala syntax.
  prefs: []
  type: TYPE_NORMAL
- en: The product panel is set up. Now it is the cart's turn.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `initCartUI()` function is responsible for creating the HTML code representing
    the cart.The cart for the user is taken from the server. We cast it to a `Cart `sequence and,
    for each of them, we get the corresponding product in order to have the name and
    price. Finally we append the line in `CartDiv`, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: In case of failure, we just print the error in the browser console.
  prefs: []
  type: TYPE_NORMAL
- en: With all this code, our user interface is now initialized. We can now implement
    the action on the user interface that we left unimplemented.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing UI actions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When the application is started, the user interface is the representation of
    the database in terms of the product and the user cart.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will implement actions such as adding a product to the cart,
    updating the quantity to buy, and removing a product from the cart.
  prefs: []
  type: TYPE_NORMAL
- en: Adding a product to the cart
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To add a product to the cart, we have to click on the Add to cart button of
    the product panel. We need to edit `ProductDiv` again and implement the `addToCart`
    method.
  prefs: []
  type: TYPE_NORMAL
- en: 'As we said in the *Introducing the UI manager* section of this chapter, we
    would like to delegate the user interface manipulation to the `UIManager` class,
    so the `addToCart` method implementation is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Indeed, we are asking `UIManager` to add the product to the cart. The `UIManager`
    builds a `div` representing the product in the cart, and if it is already in the
    cart, nothing happens.
  prefs: []
  type: TYPE_NORMAL
- en: 'The implementation is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: The `postInCart` method is called with the product code and the initial quantity
    of one to create a new entry in the `Cart` table. Once created, the `onDone()` method is
    called. This method adds the HTML elements that are needed to visualize the cart
    line in the user interface.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `postInCart` method receives `productCode`, the quantity, and the method
    to call once the web service call is a success, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: If the web service call is a failure, we just print the error in the browser
    console and nothing is added to the user interface.
  prefs: []
  type: TYPE_NORMAL
- en: Removing a product from the cart
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The action to remove a product from the cart is triggered when the X button
    related to a cart entry is clicked. This is implemented in the `removeFromCart()`
    method, located in the `CartLine` class. This is similar to the method we used
    in the previous section. The code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'We delegate the action to `UIManager`, and the implementation is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: This time, we call the `deleteFromCart` method and remove the row with the related
    ID.
  prefs: []
  type: TYPE_NORMAL
- en: 'The implementation of the web service call is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: As jQuery does not have a `delete()` method, we have to use the `ajax()` method
    and set the HTTP method.
  prefs: []
  type: TYPE_NORMAL
- en: Updating the quantity
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To update the quantity of a product in the cart, an HTML input text is used.
    As soon as the value is changed, we update the database with the new value. The
    `onchange()` event of the input text is used for this purpose.
  prefs: []
  type: TYPE_NORMAL
- en: 'It should come as no surprise that, in `CartDiv`, as we did previously, we
    delegate the call to `UIManager`, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'The implementation of `updateProduct` is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'We call the web service using the `quantity` set in `inputText`. The method
    to get the quantity is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: We get the quantity from the HTML input text element. If it exists, we parse
    it as an integer. If the field does not exist or we are having a parsing error
    (a letter is inputted), we return the quantity of `1`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The web service call to update the product quantity is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: There we are. We have finished the implementation of the user interface for
    the shopping cart.
  prefs: []
  type: TYPE_NORMAL
- en: It is time to deploy it and check whether it works.
  prefs: []
  type: TYPE_NORMAL
- en: Deploying the user interface
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To deploy from the command line in the root of your project, enter the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the deployment is a success, you can browse [https://shopping-fs.herokuapp.com/](https://shopping-fs.herokuapp.com/docs/swagger-ui/index.html?url=/v1/swagger.json). The
    interface will be displayed as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7a9cd9db-8f6c-4550-8325-981034bf2ad0.png)'
  prefs: []
  type: TYPE_IMG
- en: You can now play with the interface.
  prefs: []
  type: TYPE_NORMAL
- en: Debugging the interface
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: During development, we will not write the right code on the first draft. As
    humans, we make mistakes and do not perfectly remember all of the framework that
    we use.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we would like to give an entry point into debugging the code.
    The most obvious debugging system is to print in the console of the browser. This
    is done by directly using `println()` in Scala, and then looking at the log that
    is displayed in the console.
  prefs: []
  type: TYPE_NORMAL
- en: To have a look at the console and other debugging tools, you have to enable
    the developer tools on your browser. I am using Safari on Macintosh, but if you
    do not want to use it, I would recommend Google Chrome; the features are almost
    the same.
  prefs: []
  type: TYPE_NORMAL
- en: In Safari, enable the developer tools by clicking on the Show Develop menu in
    menu bar checkbox from the Advanced Preferences.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once done, a new Develop menu will appear. Open this menu and select Show JavaScript
    Console. A new section will appear in the Safari window with the console. If you
    click on the button to delete a cart row, a log is printed in the console, as
    shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/34173816-d2d5-4d88-a189-52a312f71fd2.png)'
  prefs: []
  type: TYPE_IMG
- en: You can interact with JavaScript by typing anything in the last line of the
    console.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, if you input `$("#productPanel")`, then the product `div` is selected,
    and you can inspect it, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d9165c82-2284-4532-8be3-379cc95374bd.png)'
  prefs: []
  type: TYPE_IMG
- en: The inspect element code of the web page
  prefs: []
  type: TYPE_NORMAL
- en: 'You can even run tests. If you input `$("#productPanel").remove()`, the `div`
    will be removed from `dom` and your page will look like the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/aa7483bd-c569-4a58-b7c5-0c09209ed5d6.png)'
  prefs: []
  type: TYPE_IMG
- en: The inspect element code for the test
  prefs: []
  type: TYPE_NORMAL
- en: Refresh the page to get back to the product list. You can even debug the Scala
    code from inside the browser.
  prefs: []
  type: TYPE_NORMAL
- en: You need to have the project in development mode to have the necessary files
    generated for debugging (the source maps files).
  prefs: []
  type: TYPE_NORMAL
- en: 'Click on the Debugger tab and look for `UIManager.scala` on the left-hand panel,
    under `Sources/client-fast-opt.js`, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/50f1f776-4826-43f6-b9b8-1fcdb7c689e7.png)'
  prefs: []
  type: TYPE_IMG
- en: The UIManager.scala source code
  prefs: []
  type: TYPE_NORMAL
- en: Once `UIManager.scala` is selected, you can see the Scala source on the middle
    panel. Click on the gutter in line **30**. A breakpoint will be set when the UI
    is initialized and product `div` instances are appended.
  prefs: []
  type: TYPE_NORMAL
- en: If you refresh the page, the engine will stop at that point and, on the right-hand
    panel, you will have all of the variables, even the local variables, such as `p`,
    representing the product to add at this point.
  prefs: []
  type: TYPE_NORMAL
- en: 'Click on the Continue script execution button, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/76838a18-ada5-4ea6-903e-e2fc81e1d165.png)'
  prefs: []
  type: TYPE_IMG
- en: The script will continue until the next element in the collection, and the `p`
    variable on the right-hand panel will be updated with the next element.
  prefs: []
  type: TYPE_NORMAL
- en: I've just scratched the surface of all of the Develop menu possibilities. You
    can have metrics that govern the time spent to load elements in the page and to
    process, inspect, and change any HTML elements in the page.
  prefs: []
  type: TYPE_NORMAL
- en: For more information, read the official documentation for Safari ([https://support.apple.com/en-in/guide/safari-developer/welcome/mac](https://support.apple.com/en-in/guide/safari-developer/welcome/mac)[)](https://support.apple.com/en-in/guide/safari-developer/welcome/mac)
    and for Google Chrome ([https://developers.google.com/web/tools/chrome-devtools/](https://developers.google.com/web/tools/chrome-devtools/)).
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned how to build a user interface from scratch by first
    creating a mockup of the interface.
  prefs: []
  type: TYPE_NORMAL
- en: Then, we implemented the main layout, representing the skeleton of the application
    with all of the files that need to be linked, such as the CSS files and scripts.
    Once the layout was ready, we modeled the different HTML parts of the user interface
    in Scala, such as the product panel and the cart panel. The last step was to create
    the navigation system and user interaction. For that purpose, we created a UI
    manager, responsible for all the interaction.
  prefs: []
  type: TYPE_NORMAL
- en: As a side note, our user interface is pretty simple, without much interaction.
    This is why we chose to write the UI manager by hand. If the interface becomes
    more complex, then it might be useful to use a framework to manage it. At the
    time of writing, React.js and Angular are two of the most popular frameworks.
    Be aware, however, that frameworks come with a learning curve, and can quickly
    become obsolete.
  prefs: []
  type: TYPE_NORMAL
- en: Another solution would be to use Akka.js and more specifically the FSM actor
    to manage your user interface. After all, this is a state machine, reacting and
    acting based on events. This will be developed in the next chapter on the automatic
    price updater.
  prefs: []
  type: TYPE_NORMAL
- en: We also looked at the debugging facilities provided by the browser. By now,
    you should be aware of the advantages of using the same principles and code when
    writing the back-end and front-end of a complete solution.
  prefs: []
  type: TYPE_NORMAL
- en: We are going to go a step further in the next chapter. We will enable our application
    to get data from external sources and asynchronously update the user interface
    using Akka/Akka.js.
  prefs: []
  type: TYPE_NORMAL
