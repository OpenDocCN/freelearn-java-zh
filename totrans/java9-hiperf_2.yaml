- en: Chapter 2. Tools for Higher Productivity and Faster Application
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第二章. 提高生产力和快速应用工具
- en: '[PRE0]'
  id: totrans-1
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '![Creating a JShell Session and Setting Context](img/02_07.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![创建JShell会话和设置上下文](img/02_07.jpg)'
- en: '[PRE1]'
  id: totrans-3
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '[PRE2]'
  id: totrans-4
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '![JShell Commands](img/02_13.jpg)'
  id: totrans-5
  prefs: []
  type: TYPE_IMG
  zh: '![JShell 命令](img/02_13.jpg)'
- en: '[PRE3]'
  id: totrans-6
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '![JShell Commands](img/02_15.jpg)'
  id: totrans-7
  prefs: []
  type: TYPE_IMG
  zh: '![JShell 命令](img/02_15.jpg)'
- en: '[PRE4]'
  id: totrans-8
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '![JShell Commands](img/02_29.jpg)'
  id: totrans-9
  prefs: []
  type: TYPE_IMG
  zh: '![JShell 命令](img/02_29.jpg)'
- en: '[PRE5]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The commands `/en`, `/res`, and `/rel` have an overlapping functionality:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 命令 `/en`、`/res` 和 `/rel` 具有重叠的功能：
- en: '`/en [options]`: This allows to view or change the evaluation context'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/en [options]`: 这允许查看或更改评估上下文'
- en: '`/res [options]`: This discards all entered snippets and restarts the session'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/res [options]`: 这将丢弃所有输入的片段并重新启动会话'
- en: '`/rel[options]`: This reloads the session the same way the command `/en` does'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/rel[options]`: 这以与命令 `/en` 相同的方式重新加载会话'
- en: See the official Oracle documentation ([http://docs.oracle.com/javase/9/tools/jshell.htm](http://docs.oracle.com/javase/9/tools/jshell.htm))
    for more details and possible options.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 有关更多详细信息和建议选项，请参阅官方Oracle文档([http://docs.oracle.com/javase/9/tools/jshell.htm](http://docs.oracle.com/javase/9/tools/jshell.htm))。
- en: The command `[/se [setting]` sets configuration information, including the external
    editor, startup settings, and feedback mode. This command is also used to create
    a custom feedback mode with customized prompt, format, and truncation values.
    If no setting is entered, then the current setting for the editor, startup settings,
    and feedback mode are displayed. The documentation referred to earlier describes
    all possible settings in all details.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 命令 `[/se [setting]` 设置配置信息，包括外部编辑器、启动设置和反馈模式。此命令还用于创建具有自定义提示、格式和截断值的自定义反馈模式。如果没有输入设置，则显示编辑器、启动设置和反馈模式的当前设置。前面提到的文档详细描述了所有可能的设置。
- en: The JShell is going to be even more helpful when integrated inside of the IDE
    so that a programmer can evaluate expressions on the fly or, even better, they
    can be evaluated automatically the same way the compiler today evaluates the syntax.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 当JShell集成到IDE中时，它将更加有用，这样程序员就可以即时评估表达式，甚至更好的是，它们可以像编译器今天评估语法一样自动评估。
- en: Ahead-of-Time (AOT)
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 预编译（AOT）
- en: The big claim of Java was write-once-run-anywhere. It was achieved by creating
    an implementation of **Java Runtime Environment** (**JRE**) for practically all
    platforms, so the bytecode generated once from the source by Java compiler (`javac`
    tool) could be executed everywhere where JRE was installed, provided the version
    of the compiler `javac` was compatible with the version of JRE.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: Java的宏伟主张是“一次编写，到处运行”。这是通过为几乎所有平台创建Java运行时环境（**JRE**）的实现来实现的，因此Java编译器（`javac`工具）从源代码生成的一次字节码可以在安装了JRE的任何地方执行，前提是编译器`javac`的版本与JRE的版本兼容。
- en: The first releases of JRE were primarily the interpreters of the bytecode and
    yielded slower performance than some other languages and their compilers, such
    as C and C++. However, over time, JRE was improved substantially and now produces
    quite decent results, on a par with many other popular systems. In big part, it
    is due to the JIT dynamic compiler that converts the bytecodes of the most frequently
    used methods to the native code. Once generated, the compiled methods (the platform-specific
    machine code) is executed as needed without any interpretation, thus decreasing
    the execution time.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: JRE的最初版本主要是字节码的解析器，其性能比C和C++等一些语言及其编译器要慢。然而，随着时间的推移，JRE得到了显著改进，现在能够产生相当不错的成果，与许多其他流行的系统相当。在很大程度上，这归功于即时编译器（JIT），它将最常用方法的字节码转换为本地代码。一旦生成，编译的方法（特定平台的机器代码）在需要时执行，无需任何解释，从而减少了执行时间。
- en: To utilize this approach, JRE needs some time for figuring out which methods
    of the application are used most often. The people working in this area of programming
    call them hot methods. This period of discovery, until the peak performance is
    reached, is often called a JVM's warm-up time. It is bigger for the larger and
    more complex Java applications and can be just a few seconds for smaller ones.
    However, even after the peak performance is reached, the application might, because
    of the particular input, start utilizing an execution path never used before and
    calling the methods that were not compiled yet, thus suddenly degrading the performance.
    It can be especially consequential when the code not compiled yet belongs to the
    complex procedures invoked in some rare critical situations, exactly when the
    best possible performance is needed.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 为了利用这种方法，JRE需要一些时间来确定应用程序中使用最频繁的方法。在这个编程领域工作的人称它们为“热点方法”。这个发现期，直到达到峰值性能，通常被称为JVM的预热时间。对于更大、更复杂的Java应用程序来说，这个时间更长，而对于较小的应用程序来说，可能只有几秒钟。然而，即使达到了峰值性能，由于特定的输入，应用程序可能会开始使用之前从未使用过的执行路径，调用尚未编译的方法，从而突然降低性能。当尚未编译的代码属于在罕见的关键情况下调用的复杂过程时，这可能会特别严重，这正是需要最佳性能的时候。
- en: 'The natural solution was to allow the programmer to decide which components
    of the application have to be precompiled into the native machine code--those
    that are more often used (thus decreasing the application''s warm-up time), and
    those that are used not often but have to be executed as quickly as possible (in
    support of the critical situations and stable performance overall). That was the
    motivation of the **Java Enhancement ProposalJEP 295: Ahead-of-Time Compilation**:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 自然解决方案是允许程序员决定哪些应用程序组件需要预先编译成本地机器代码——那些使用频率较高的（从而减少应用程序的预热时间），以及那些虽然使用频率不高但需要尽可能快地执行（以支持关键情况和整体稳定性能）的组件。这就是**Java增强提案JEP
    295：提前编译**的动机：
- en: JIT compilers are fast, but Java programs can become so large that it takes
    a long time for the JIT to warm up completely. Infrequently used Java methods
    might never be compiled at all, potentially incurring a performance penalty due
    to repeated interpreted invocations.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 即时编译器速度快，但Java程序可能会变得非常大，以至于即时编译器完全预热需要很长时间。不常用的Java方法可能根本不会被编译，这可能会因为重复的解释调用而造成性能损失。
- en: 'It is worth noticing though that already in JIT compiler, it is possible to
    decrease the warm-up time by setting the compilation threshold--how many times
    a method has to be called before it gets compiled into the native code. By default,
    the number is 1,500\. So, if we set it to less than that, the warm-up time will
    be shorter. It can be done using the option `-XX:CompileThreshold` with the `java`
    tool. For example, we can set the threshold to 500 as follows (where `Test` is
    the compiled Java class with the `main()` method in it):'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，即使在即时编译器（JIT compiler）中，通过设置编译阈值（即一个方法被调用多少次后才会编译成本地代码）也可以减少预热时间。默认情况下，这个数字是1,500。因此，如果我们将其设置为低于这个数字，预热时间将会缩短。这可以通过使用`java`工具的`-XX:CompileThreshold`选项来实现。例如，我们可以将阈值设置为500，如下所示（其中`Test`是包含`main()`方法的编译后的Java类）：
- en: '[PRE6]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The option `-XX:-TieredCompilation` was added to disable the tiered compilation
    because it is enabled by default and does not honor the compilation threshold.
    The possible drawback is that the 500 threshold might be too low and too many
    methods will be compiled, thus slowing down the performance and increasing the
    warm-up time. The best value for this option will vary from application to an
    application and may even depend on the particular data input with the same application.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 选项`-XX:-TieredCompilation`被添加来禁用分层编译，因为它默认启用且不遵守编译阈值。可能的缺点是500的阈值可能太低，导致编译的方法太多，从而降低性能并增加预热时间。这个选项的最佳值会因应用程序而异，甚至可能取决于同一应用程序的特定数据输入。
- en: Static versus Dynamic Compilation
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 静态编译与动态编译
- en: Many higher level programming languages such as C or C++ used AOT compilation
    from the very beginning. They are also called **statically compiled** languages.
    Since AOT (or static) compilers are not constrained by performance requirements
    (at least not as much as the interpreters at runtime, also called **dynamic compilers**),
    they can afford to spend the time producing complex code optimizations. On the
    other hand, the static compilers do not have the runtime (profiling) data, which
    is especially limiting in the case of dynamically typed languages, Java being
    one of them. Since the ability of dynamic typing in Java--downcasting to the subtype,
    querying an object for its type, and other type operations--is one of the pillars
    of object-oriented programming (principle of polymorphism), AOT compilation for
    Java becomes even more limited. Lambda expressions pause another challenge for
    static compilation and are currently not supported yet.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 许多高级编程语言，如 C 或 C++，从一开始就使用了 AOT 编译。它们也被称作**静态编译**语言。由于 AOT（或静态）编译器不受性能要求的限制（至少不像运行时的解释器那样受限制，也称为**动态编译器**），它们可以承担起花费时间产生复杂代码优化的成本。另一方面，静态编译器没有运行时（配置文件）数据，这在动态类型语言的情况下尤其受限，Java
    就是其中之一。由于 Java 中动态类型的能力——向下转型到子类型、查询对象以获取其类型以及其他类型操作——是面向对象编程（多态原则）的支柱，因此 Java
    的 AOT 编译变得更加有限。Lambda 表达式对静态编译又提出了另一个挑战，并且目前尚不支持。
- en: Another advantage of a dynamic compiler is that it can make assumptions and
    optimize the code accordingly. If the assumption turned out to be wrong, the compiler
    can try another assumption until the performance goal is achieved. Such a procedure
    may slow down the application and/or increase the warm-up time, but it may result
    in a much better performance in the long run. The profile-guided optimization
    can help a static compiler to move along this path too, but it will always remain
    limited in its opportunity to optimize by comparison with a dynamic one.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 动态编译器的另一个优点是它可以做出假设并相应地优化代码。如果假设被证明是错误的，编译器可以尝试另一个假设，直到达到性能目标。这样的过程可能会减慢应用程序的速度和/或增加预热时间，但长期来看可能会带来更好的性能。基于配置文件的优化可以帮助静态编译器沿着这条路径前进，但它与动态编译器相比，在优化的机会上始终有限。
- en: 'That said, we should not be surprised that the current AOT implementation in
    JDK 9 is experimental and limited, so far, to 64-bit Linux-based systems only,
    with both Parallel or G1 garbage collection and the only supported module being
    `java.base`. Further, AOT compilation should be executed on the same system or
    a system with the same configuration on which the resulting machine code will
    be executed. Yet, despite all that, the JEP 295 states:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 话虽如此，我们不应该对当前 JDK 9 中的 AOT（即时编译）实现是实验性的以及仅限于 64 位 Linux 系统感到惊讶，因为目前它只支持并行或 G1
    垃圾收集，并且唯一支持的模块是 `java.base`。此外，AOT 编译应该在执行生成的机器代码的同一系统或配置相同的系统上执行。尽管如此，JEP 295
    中声明：
- en: Performance testing shows that some applications benefit from AOT-compiled code,
    while others clearly show regressions.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 性能测试表明，一些应用程序从 AOT 编译的代码中受益，而其他应用程序则明显出现性能下降。
- en: It is worth noting that AOT compilation has been long supported in **Java Micro
    Edition** (**ME**), but more use cases for AOT in **Java Standard Edition** (**SE**)
    are yet to be identified, which was one of the reasons the experimental AOT implementation
    was released with JDK 9-- in order to facilitate the community to try and tell
    about the practical needs.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，AOT 编译在 **Java 微版**（**ME**）中已经得到了长期支持，但 **Java 标准版**（**SE**）中 AOT 的用例尚未确定，这也是实验性
    AOT 实现在 JDK 9 中发布的原因之一——为了便于社区尝试并报告实际需求。
- en: The AOT Commands and Procedures
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: AOT 命令和过程
- en: The underlying AOT compilation in JDK 9 is based on the Oracle project `Graal`--an
    open source compiler introduced with JDK 8 with a goal of improving the performance
    of the Java dynamic compiler. The AOT group had to modify it, mostly around constants
    processing and optimization. They have also added probabilistic profiling and
    a special inlining policy, thus making Grall more suitable for static compilation.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: JDK 9 中底层的 AOT 编译基于 Oracle 项目 `Graal`——这是一个与 JDK 8 一起引入的开源编译器，旨在提高 Java 动态编译器的性能。AOT
    小组不得不对其进行修改，主要围绕常量处理和优化。他们还添加了概率配置文件和特殊的内联策略，从而使 Graal 更适合静态编译。
- en: In addition to the existing compiling tool `javac`, a new `jaotc` tool is included
    in the JDK 9 installation. The resulting AOT shared libraries `.so` are generated
    using the `libelf` library--the dependency that is going to be removed in the
    future releases.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: 'To start AOT compilation, a user has to launch `jaotc` and specify classes,
    JAR files, or modules that have to be compiled. The name of the output library
    (that holds the generated machine code) can also be passed as the `jaotc` parameter.
    If not specified, the default name of the output will be `unnamed.so`. As an example,
    let''s look at how the AOT compiler can work with the class `HelloWorld`:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'First, we will generate the bytecode and produce `HelloWorld.class` using `javac`:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Then, we will use the bytecode from the file `HelloWorld.class` to generate
    machine code into the library `libHelloWorld.so`:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Now, we can execute the generated library (on the platform with the same specification
    as the one where `jaotc`was executed) using the `java` tool with an option `-XX:AOTLibrary`:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The option `-XX:AOTLibrary` allows us to list several AOT libraries separated
    by commas.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: Notice that the `java` tool requires bytecode of all the applications in addition
    to the native code of some of its components. This fact diminishes the alleged
    advantage of static compilation, which some AOT enthusiasts claim, that it protects
    code better from being decompiled. It might be so in the future when bytecode
    will not be required at runtime if the same class or method is in the AOT library
    already. However, as of today, it is not the case.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: 'To see if AOT-compiled methods were used, you can add an option `-XX:+PrintAOT`:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: It will allow you to see the line loaded `./libHelloWorld.so` AOT library in
    the output.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: If the source code of a class was changed but not pushed (through the `jaotc`
    tool) into the AOT library, JVM will notice it at runtime because the fingerprint
    of each compiled class is stored with its native code in the AOT library. JIT
    will then ignore the code in the AOT library and use the bytecode instead.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: 'The `java` tool in JDK 9 supports a few other flags and options related to
    AOT:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: '`-XX:+/-UseAOT` tells the JVM to use or to ignore AOT-compiled files (by default,
    it is set to use AOT)'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-XX:+/-UseAOTStrictLoading` turns on/off the AOT strict loading; if on, it
    directs JVM to exit if any of the AOT libraries were generated on a platform with
    a configuration different from the current runtime configuration'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The JEP 295 describes the `jaotc` tool''s command format as follows:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The `name` is a class name or JAR file. The `list` is a colon `:` separated
    list of class names, modules, JAR files, or directories that contain class files.
    The `options` is one or many flags from the following list:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: '`--output <file>`: This is the output file name (by default, `unnamed.so`)'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`--class-name <class names>`: This is the list of Java classes to compile'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`--jar <jar files>`: This is the list of JAR files to compile'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`--module <modules>`: This is the list of Java modules to compile'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`--directory <dirs>`: This is the list of directories where you can search
    for files to compile'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`--search-path <dirs>`: This is the list of directories where to search for
    specified files'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`--compile-commands <file>`: This is the name of the file with compile commands;
    here is an example:'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-63
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'AOT recognizes two compile commands currently:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: '`exclude`: This excludes the compilation of specified methods'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`compileOnly`: This compiles only specified methods'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Regular expressions are used to specify classes and methods, which are mentioned
    here:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: '`--compile-for-tiered`: This generates profiling code for tiered compilation
    (by default, profiling code is not generated)'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`--compile-with-assertions`: This generates code with Java assertions (by default,
    assertions code is not generated)'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`--compile-threads <number>`: This is the number of compilation threads to
    be used (by default, the smaller value of 16 and number of available CPUs)'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`--ignore-errors`: This ignores all exceptions thrown during class loading
    (by default, exits on compilation if class loading throws an exception)'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`--exit-on-error`: This exits on compilation errors (by default, failed compilation
    is skipped, while the compilation of other methods continues)'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`--info`: This prints information about compilation phases'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`--verbose`: This prints more details about compilation phases'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`--debug`: This prints even more details'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`--help`: This prints help information'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`--version`: This prints version information'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-J<flag>`: This passes a flag directly to the JVM runtime system'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'As we mentioned already, some applications can improve performance using AOT,
    while others may become slower. Only testing will provide a definite answer to
    the question about the usefulness of AOT for each application. In any case, one
    of the ways to improve performance is to compile and use the AOT library of the
    `java.base` module:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: At runtime, the AOT initialization code looks for shared libraries in the `$JAVA_HOME/lib`
    directory or among the libraries listed by the `-XX:AOTLibrary` option. If shared
    libraries are found, they are picked up and used. If no shared libraries can be
    found, AOT will be turned off.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this lesson, we described two new tools that can help a developer be more
    productive (JShell tool) and help improve Java application performance (`jaotc`
    tool). The examples and steps to use them will help you understand the benefits
    of their usage and get you started in case you decide to try them.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: In the next lesson, we will discuss how to monitor Java applications programmatically
    using command-line tools. We will also explore how to improve the application
    performance via multithreading and how to tune the JVM itself after learning about
    the bottlenecks through monitoring.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: Assessments
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The ________ compiler takes Java bytecode and generates a native machine code
    so that the resulting binary file can execute natively.
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Which of the following commands drops a snippet referenced by a name or on ID?
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下哪个命令用于根据名称或ID删除引用的片段？
- en: '`/d <name or id>`'
  id: totrans-88
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`/d <name or id>`'
- en: '`/drop <name or id>`'
  id: totrans-89
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`/drop <name or id>`'
- en: '`/dr <name or id>`'
  id: totrans-90
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`/dr <name or id>`'
- en: '`/dp <name or id>`'
  id: totrans-91
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`/dp <name or id>`'
- en: 'State whether True or False: Shell is Ahead-of-Time tool that is well-known
    for those who program in Scala, Ruby. It takes a user input, evaluates it, and
    returns the result after sometime.'
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 判断对错：Shell是一种预编译工具，对于Scala和Ruby程序员来说非常知名。它接收用户输入，评估它，并在一段时间后返回结果。
- en: Which of the following commands is used to list the source you have typed in
    JShell?
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下哪个命令用于列出你在JShell中输入的源代码？
- en: '`/l [<name or id>|-all|-start]`'
  id: totrans-94
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`/l [<name or id>|-all|-start]`'
- en: '`/m [<name or id>|-all|-start]L`'
  id: totrans-95
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`/m [<name or id>|-all|-start]L`'
- en: '`/t [<name or id>|-all|-start]`'
  id: totrans-96
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`/t [<name or id>|-all|-start]`'
- en: '`/v [<name or id>|-all|-start]`'
  id: totrans-97
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`/v [<name or id>|-all|-start]`'
- en: Which of the following regular expressions ignores all exceptions thrown during
    class loading?
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下哪个正则表达式在类加载过程中忽略所有抛出的异常？
- en: '`--exit-on-error`'
  id: totrans-99
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`--exit-on-error`'
- en: '`–ignores-errors`'
  id: totrans-100
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`–ignores-errors`'
- en: '`--ignore-errors`'
  id: totrans-101
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`--ignore-errors`'
- en: '`--exits-on-error`'
  id: totrans-102
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`--exits-on-error`'
