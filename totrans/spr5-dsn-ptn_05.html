<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Understanding the Bean Life Cycle and Used Patterns</h1>
                </header>
            
            <article>
                
<p>In the previous chapter, you saw how Spring creates beans in the container. You also learned how to configure the dependency injection pattern using XML, Java, and Annotation. In this chapter, we will go into more detail, beyond injecting beans and the configuration of dependencies in a Spring application. Here, you will explore the life and scope of beans in the container, and learn how the Spring container works on the defined Spring bean configuration with XML, Annotation, and Java. Spring allows us to control not only the various configurations for the DI pattern and dependency values that are to be injected into the object created from a particular bean definition, but also the life and scope of the beans created from a particular bean definition.</p>
<p>When I was writing this chapter, my two and a half year old son, Arnav, came to me and started playing a video game on my mobile. He was wearing a T-Shirt, which had an interesting quote on it, and these lines described his whole day. The lines went like this--<br/>
<em>My Perfect Day: Wake up, Play Video Games, Eat, Play Video Games, Eat, Play Video Games, and Sleep</em>.</p>
<p>Actually, these lines perfectly reflected his life cycle for each day, as he woke up, played, ate, and played again before, finally, going to sleep. With this example, I just wanted to demonstrate that everything has a life cycle. We could discuss the life cycle of a butterfly, a star, a frog, or a plant. But let's talk about something more interesting--the life cycle of a bean!</p>
<p>Every bean in the Spring container has a life cycle and its own scope. The Spring container manages the life of the beans in a Spring application. We can customize it in some phases by using Spring-aware interfaces. This chapter will talk about the life of a bean in the container, and how it is managed using design patterns in the various phases of its life. By the end of this chapter, you would have a fair idea of the bean life cycle and its various phases in the container. You will also learn about the many types of bean scope in Spring. This chapter will cover the following points:</p>
<ul>
<li>The Spring bean life cycle, and its phases, which are listed as follows:<br/>
<ul>
<li>The initialization phase</li>
<li>The Use phase</li>
<li>The destruction phase</li>
</ul>
</li>
<li>Spring callbacks</li>
<li>Understanding bean scopes
<ul>
<li>Singleton pattern</li>
<li>Prototype pattern</li>
<li>Custom scopes</li>
<li>Other bean scopes</li>
</ul>
</li>
</ul>
<p><span>Now let's take a moment to see how Spring manages the life cycle of a bean from creation to destruction in the Spring application</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The Spring bean life cycle and its phases</h1>
                </header>
            
            <article>
                
<p>In a Spring application, the term life cycle applies to any class of application--Standalone Java, Spring Boot application, or Integration/System Test. Also, life cycle applies to all three dependency injection styles--XML, Annotations, and Java configuration. You define the configuration for beans as per business goals. But Spring creates these beans and manages the life cycle of the Spring beans. Spring loads the bean configurations either in Java or XML through <kbd>ApplicationContext</kbd>. After loading these beans, the Spring container handles the creation and instantiation of these beans as per your configuration. Let's divide the Spring application life cycle into three phases as follows:</p>
<ul>
<li>The initialization phase</li>
<li>The Use phase</li>
<li>The destruction phase</li>
</ul>
<p>Please refer to the following diagram:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img height="140" width="407" class=" image-border" src="assets/3ca661ad-4883-4927-b755-08a69c8efffe.png"/></div>
<p>As you can see in the preceding diagram, each Spring bean goes through these three phases in the complete life cycle. Each phase has some set of operations to be performed for each Spring bean (depending on the configuration). Spring fits in to manage your application life cycle. It plays an important role in all three phases.</p>
<p>Now let's take a moment to see how Spring works in the first, initialization phase.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The initialization phase</h1>
                </header>
            
            <article>
                
<p>In this phase, first of all Spring loads all the configuration files of any style-XML, Annotations, and Java configuration. This phase prepares the beans for use. The application is not usable until this phase is complete. This phase, actually, creates the application services for use, and it allocates the system resources to the bean. Spring provides <kbd>ApplicationContext</kbd> to load the bean configurations; once the application context is created, the initialization phase completes. Let's see how Spring loads the configuration files in Java or XML.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Creating the application context from configuration</h1>
                </header>
            
            <article>
                
<p>Spring provides multiple implementations of <kbd>ApplicationContext</kbd> to load the various styles of configuration file. These are listed next:</p>
<ul>
<li>For Java configuration, the following is used:</li>
</ul>
<pre>        ApplicationContext context = new    <br/>        AnnotationConfigApplicationContext(AppConfig.class); </pre>
<ul>
<li>For XML configuration, the implementation is as follows:</li>
</ul>
<pre>        ApplicationContext context = new  <br/>        ClassPathXmlApplicationContext("applicationContext.xml"); </pre>
<p>In the preceding codes, Spring loads the Java configuration files by using the <kbd>AnnotationConfigApplicationContext</kbd> class, and the XML configuration files by using the <kbd>ClassPathXmlApplicationContext</kbd> class for the Spring container. Spring behaves the same for all types of configuration. It does not matter what configuration styles you use in your application. The following diagram shows what exactly happens in this phase:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img height="262" width="470" src="assets/646b0215-c1dc-4108-b1bc-edd9726445ec.png"/></div>
<p>As you can see in the preceding diagram, the initialization phase is divided into these two steps:</p>
<ul>
<li>Load bean definitions</li>
<li>Initialize bean instances</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Load bean definitions</h1>
                </header>
            
            <article>
                
<p>In this step, all the configuration files--<kbd>@Configuration</kbd> classes or XML files-are processed. For Annotation-based configuration, all the classes annotated with <kbd>@Components</kbd> are scanned to load the bean definitions. All XML files are parsed, and the bean definitions are added to a <kbd>BeanFactory</kbd>. Each bean is indexed under its <kbd>id</kbd>. Spring provides multiple <kbd>BeanFactoryPostProcessor</kbd> beans, so, it is invoked to resolve runtime dependencies such as reading values from external property files. In a Spring application, <kbd>BeanFactoryPostProcessor</kbd> can modify the definition of any bean. The following diagram describes this step:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img height="79" width="282" class=" image-border" src="assets/ecea9112-8d34-49fa-8e2a-60cbfed386f0.png"/></div>
<p>As shown in the preceding diagram, Spring first loads the bean definitions, and then calls <kbd>BeanFactoryProcessor</kbd> for some beans to modify its definitions accordingly. Let's see this with an example. We have two configuration files--<kbd>AppConfig.java</kbd> and <kbd>InfraConfig.java</kbd>, which are defined as follows:</p>
<ul>
<li>Following is the <kbd>AppConfig.java</kbd> file:</li>
</ul>
<pre>        @Configuration 
        public class AppConfig { 
          @Bean 
          public TransferService transferService(){ ... } 
          @Bean 
          public AccountRepository accountRepository(DataSource <br/>          dataSource){ ... } 
        } </pre>
<ul>
<li>Following is the <kbd>InfraConfig.java</kbd> file:</li>
</ul>
<pre>        @Configuration 
        public class InfraConfig { 
          @Bean 
          public DataSource dataSource () { ... } 
        } </pre>
<p>These Java configuration files are loaded by the <strong>ApplicationContext</strong> to the container, and indexed with its <kbd>id</kbd>, as shown in the following diagram:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img height="199" width="436" class=" image-border" src="assets/923a2b5d-4f0d-4bd2-9c25-852474ea7221.png"/></div>
<p>In the last diagram, Spring beans are indexed under its IDs into Spring's <kbd>BeanFactory</kbd>, and then, that <kbd>BeanFactory</kbd> object is passed as an argument to the <kbd>postProcess()</kbd> method of <kbd>BeanFactoryPostProcessor</kbd>. The <kbd>BeanFactoryPostProcessor</kbd> can modify the bean definition for some beans; this depends on the bean configurations provided by the developer. Let's see how <kbd>BeanFactoryPostProcessor</kbd> works, and how to override it in our application:</p>
<ol>
<li><kbd>BeanFactoryPostProcessor</kbd> works on the bean definitions or the configuration metadata of the bean before the beans are actually created.</li>
<li>Spring provides several useful implementations of <kbd>BeanFactoryPostProcessor</kbd>, such as reading properties and registering a custom scope.</li>
<li>You can write your own implementation of the <kbd>BeanFactoryPostProcessor</kbd> interface.</li>
<li>If you define a <kbd>BeanFactoryPostProcessor</kbd> in one container, it will only be applied to the bean definitions in that container.</li>
</ol>
<p>The following is the code snippet for <kbd>BeanFactoryPostProcessor</kbd>:</p>
<pre>    public interface BeanFactoryPostProcessor { 
      public void postProcessBeanFactory<br/>        (ConfigurableListableBeanFactory <br/>        beanFactory); 
    } </pre>
<p>Let's now see the following examples of the <kbd>BeanFactoryPostProcessor</kbd> extension point:</p>
<p><strong>Reading external property files (</strong><kbd>database.properties</kbd><strong>)</strong></p>
<p>Here, we'll use the <kbd>DataSource</kbd> bean to be configured with the database values such as <kbd>username</kbd>, <kbd>password</kbd>, <kbd>db url</kbd>, and <kbd>driver</kbd>, as follows:</p>
<pre>    jdbc.driver=org.hsqldb.jdbcDriver 
    jdbc.url=jdbc:hsqldb:hsql://production:9002 
    jdbc.username=doj 
    jdbc.password=doj@123 </pre>
<p>The following is the <kbd>DataSource</kbd> bean definition in the configuration file:</p>
<pre>    @Configuration 
    @PropertySource ( "classpath:/config/database.properties" ) 
    public class InfraConfig { 
     @Bean 
     public DataSource dataSource( 
     @Value("${jdbc.driver}") String driver, 
     @Value("${jdbc.url}") String url, 
     @Value("${jdbc.user}") String user, 
     @Value("${jdbc.password}") String pwd) { 
       DataSource ds = new BasicDataSource(); 
       ds.setDriverClassName( driver); 
       ds.setUrl( url); 
       ds.setUser( user); 
       ds.setPassword( pwd )); 
       return ds; 
    } 
   } </pre>
<p>So, in the preceding code, how do we resolve the <kbd>@Value</kbd> and <kbd>${..}</kbd> variables? We need a <kbd>PropertySourcesPlaceholderConfigurer</kbd> to evaluate them. This is a <kbd>BeanFactoryPostProcessor</kbd>. If you are using the XML configuration, the <kbd>&lt;context:property-placeholder/&gt;</kbd> namespace creates a <kbd>PropertySourcesPlaceholderConfigurer</kbd> for you.</p>
<p>Loading the bean definition is a one-time process at the time of loading the configuration file, but the initializing phase for bean instances is executed for each bean in the container. Let's have a look at the initialization of bean instances in the application.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Initializing bean instances</h1>
                </header>
            
            <article>
                
<p>After loading the bean definitions into the <kbd>BeanFactory</kbd>, the Spring IoC container instantiates the beans for the application; the following diagram shows the process flow:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img height="219" width="372" class=" image-border" src="assets/88a156a9-9afc-4c41-8377-8f645f4257eb.png"/></div>
<p>As you can see in the preceding diagram, the bean initialization step is executed for each bean in the container. We can summarize the bean creation process as follows:</p>
<ul>
<li>Each bean is eagerly instantiated by default. It is created in the right order with its dependencies injected unless marked as lazy.</li>
<li>Spring provides multiple <kbd>BeanPostProcessor</kbd>, so, each bean goes through a post-processing phase such as <kbd>BeanFactoryPostProcessor</kbd>, which can modify the bean definition. However, the <kbd>BeanPostProcessor</kbd> can change the instance of the bean.</li>
<li>After execution of this phase, the bean is fully initialized and ready for use. It is tracked by its <kbd>id</kbd> till the context is destroyed, except for the prototype beans.</li>
</ul>
<p>In the next section, we'll discuss how to customize the Spring container by using a <kbd>BeanPostProcessor</kbd>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Customizing beans using a BeanPostProcessor</h1>
                </header>
            
            <article>
                
<p>The <kbd>BeanPostProcessor</kbd> is an important extension point in Spring. It can modify bean instances in any way. It is used to enable a powerful feature such as the AOP proxy. You can write your own <kbd>BeanPostProcessor</kbd> in your application to create a custom <kbd>post-processor</kbd>--the class must implement the <kbd>BeanPostProcessor</kbd> interface. Spring provides several implementations of <kbd>BeanPostProcessor</kbd>. In Spring, the <kbd>BeanPostProcessor</kbd> interface has two callback methods, as follows:</p>
<pre>    public interface BeanPostProcessor { 
      Object postProcessBeforeInitialization(Object bean, String <br/>      beanName) throws BeansException; 
      Object postProcessAfterInitialization(Object bean, String <br/>      beanName) throws BeansException; 
    } </pre>
<p>You can implement these two methods of the <kbd>BeanPostProcessor</kbd> interface to provide your own custom logic for bean instantiation, dependency-resolution, and so on. You can configure multiple <kbd>BeanPostProcessor</kbd> implementations to add custom logic to the Spring container. You can also manage the order of execution of these <kbd>BeanPostProcessor</kbd> by setting the order property. <kbd>BeanPostProcessor</kbd> work on Spring bean instances after instantiation of the bean by the Spring container. The scope of the <kbd>BeanPostProcessor</kbd> is within the Spring container, which means that beans that are defined in one container are not post-processed by a <kbd>BeanPostProcessor</kbd> defined in another container.</p>
<p>Any class in a Spring application is registered as a <kbd>post-processor</kbd> with the container; it is created for each bean instance by the Spring container. And the Spring container calls the <kbd>postProcessBeforeInitialization()</kbd> method before the container initialization methods (Initializing Bean's <kbd>afterPropertiesSet()</kbd> and the bean's <kbd>init</kbd> method). It also calls the <kbd>postProcessAfterInitialization()</kbd> method after any bean initialization callbacks. The Spring AOP uses the <kbd>post-processor</kbd> to provide proxy-wrapping logic (Proxy design pattern) although we can take any action by using the <kbd>post-processor</kbd>.</p>
<p>Spring's <kbd>ApplicationContext</kbd> automatically detects those beans which implement the <kbd>BeanPostProcessor</kbd> interface, and registers these beans as <kbd>post-processors</kbd>. These beans are called at the time of any other bean creation. Let's explore the following example of <kbd>BeanPostProcessor</kbd>.</p>
<p>Let's create a custom bean <kbd>post-processor</kbd> as follows:</p>
<pre>    package com.packt.patterninspring.chapter5.bankapp.bpp; 
    import org.springframework.beans.BeansException; 
    import org.springframework.beans.factory.config.BeanPostProcessor; 
    import org.springframework.stereotype.Component; 
    @Component 
    public class MyBeanPostProcessor implements <br/>    BeanPostProcessor { 
      @Override 
      public Object postProcessBeforeInitialization<br/>      (Object bean, String beanName) throws BeansException { 
        System.out.println("In After bean Initialization <br/>        method. Bean name is "+beanName); 
        return bean; 
      } 
      public Object postProcessAfterInitialization(Object bean, String  <br/>      beanName) throws BeansException { 
        System.out.println("In Before bean Initialization method. Bean <br/>        name is "+beanName); 
        return bean; 
        } 
   }  </pre>
<p>This example illustrates basic usage, here this example shows a <kbd>post-processor</kbd> prints the string to the system console for each bean registered with the container. This <kbd>MyBeanPostProcessor</kbd> class annotated with <kbd>@Component</kbd> that means this class same as other bean class in the application context, now run the following demo class. Please refer to the following code:</p>
<pre>    public class BeanLifeCycleDemo { 
      public static void main(String[] args) { 
        ConfigurableApplicationContext applicationContext = new <br/>        AnnotationConfigApplicationContext(AppConfig.class); 
        applicationContext.close(); 
      } 
    }</pre>
<p>This is the output that we'll get on the console:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img class=" image-border" src="assets/b3eaae71-6091-4bcc-ab41-40d10793f1e8.png"/></div>
<p>As you can see in the preceding output, a string of both the callback methods is printed for each bean method in the Spring container. Spring provides many pre-implemented <kbd>BeanPostProcessor</kbd> for some specific features, as follows:</p>
<ul>
<li><kbd>RequiredAnnotationBeanPostProcessor</kbd></li>
<li><kbd>AutowiredAnnotationBeanPostProcessor</kbd></li>
<li><kbd>CommonAnnotationBeanPostProcessor</kbd></li>
<li><kbd>PersistenceAnnotationBeanPostProcessor</kbd></li>
</ul>
<p>The namespace <kbd>&lt;context:annotation-config/&gt;</kbd> in the XML configuration enables several <kbd>post-processor</kbd> in the same application context in which it is defined.</p>
<p>Let us now move on to our next section, and see how we can enable the Initializer extension point by using <kbd>BeanPostProcessor</kbd>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The Initializer extension point</h1>
                </header>
            
            <article>
                
<p>This special case of a bean <kbd>post-processor</kbd> causes <kbd>init</kbd> (<kbd>@PostConstruct</kbd>) methods to be called. Internally, Spring uses several <strong>BeanPostProcessors</strong> (<strong>BPPs</strong>) <kbd>CommonAnnotationBeanPostProcessor</kbd> to enable initialization. The following diagram illustrates the relationship between initializer and BPPs.</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img height="61" width="275" class=" image-border" src="assets/187db208-db73-4cb0-a955-49a0ec79b4da.png"/></div>
<p>Now let's see the following example for the Initializer extension point in XML:</p>
<p>Namespace <kbd>&lt;context:annotation-config/&gt;</kbd> explicitly enables many <kbd>post-processor</kbd>, let see the following configuration file in XML:</p>
<pre>    &lt;?xml version="1.0" encoding="UTF-8"?&gt; 
    &lt;beans  
      
      
      
     xsi:schemaLocation="http://www.springframework.org/schema/beans  <br/>     http://www.springframework.org/schema/beans/spring-beans.xsd 
     http://www.springframework.org/schema/context   <br/>     http://www.springframework.org/schema/context/<br/>     spring-context-4.3.xsd"&gt; 
     &lt;context:annotation-config/&gt; 
     &lt;bean id="transferService"    <br/>     class="com.packt.patterninspring.chapter5.<br/>     bankapp.service.TransferService"/&gt; 
     &lt;bean id="accountRepository"   <br/>     class="com.packt.patterninspring.chapter5.<br/>     bankapp.repository.JdbcAccountRepository" <br/>     init-method="populateCache"/&gt; 
    &lt;/beans&gt; </pre>
<p>In the preceding configuration code, you can see that I have defined some beans out of which one of the bean <kbd>accountRepository</kbd> repository has the <kbd>init</kbd> method attribute of the bean tag; this attribute has a value, <kbd>populateCache</kbd>. This is nothing but an <kbd>initializer</kbd> method of the <kbd>accountRepository</kbd> bean. It is called by the container at the time of bean initialization if the <kbd>post-processor</kbd> is explicitly enabled by the <kbd>&lt;context:annotation-config/&gt;</kbd> namespace. Let's see the <kbd>JdbcAccountRepository</kbd> class, shown as follows:</p>
<pre>    package com.packt.patterninspring.chapter5.bankapp.repository; 
    import com.packt.patterninspring.chapter5.bankapp.model.Account; 
    import com.packt.patterninspring.chapter5.bankapp.model.Amount; 
    import com.packt.patterninspring.chapter5.<br/>    bankapp.repository.AccountRepository; 
    public class JdbcAccountRepository implements AccountRepository { 
      @Override 
      public Account findByAccountId(Long accountId) { 
        return new Account(accountId, "Arnav Rajput", new  <br/>        Amount(3000.0)); 
    } 
    void populateCache(){ 
      System.out.println("Called populateCache() method"); 
    } 
   }</pre>
<p>In the Java configuration, we can use <kbd>initMethod</kbd> attribute of the <kbd>@Bean</kbd> annotation as follows:</p>
<pre>    @Bean(initMethod = "populateCache") 
    public AccountRepository accountRepository(){ 
      return new JdbcAccountRepository(); 
    }</pre>
<p>In the Annotation-based configuration, we can use the <em>JSR-250</em> annotation, <kbd>@PostConstruct</kbd> as follows:</p>
<pre>    @PostConstruct 
    void populateCache(){ 
      System.out.println("Called populateCache() method"); 
    } </pre>
<p>We have seen the first phase of a bean life cycle, where Spring loads the bean definitions by using XML-, Java-, and Annotation-based configuration, and after that, the Spring container initializes each bean in the correct order in the Spring application. The next diagram gives an overview of the first phase of the configuration life cycle:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img height="282" width="435" class=" image-border" src="assets/2a7e9ec4-ad6c-40c7-acad-1c76bec040ff.png"/></div>
<p>The last diagram shows Spring bean metadata in any style-XML, Annotation, or Java-loaded by the respective implementation of <kbd>ApplicationContext</kbd>. All XML files are parsed, and loaded with the bean definitions. In Annotation configuration, Spring scans all the components, and loads the bean definitions. In the Java configuration, Spring reads all the <kbd>@Bean</kbd> methods to load the bean definitions. After loading the bean definitions from all styles of configurations, <kbd>BeanFactoryPostProcessor</kbd> comes into the picture to modify the definition of some beans, and then the container instantiates the beans. Finally, <kbd>BeanPostProcessor</kbd> works on the beans, and it can modify and change the bean object. This is the initialization phase. Now let's see the next Use phase of a bean in its life cycle.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The Use phase of beans</h1>
                </header>
            
            <article>
                
<p>In a Spring application, all Spring beans spend 99.99% of their time in this phase. If the initialization phase is completed successfully, then the Spring beans come into this phase. Here, beans are used by clients as application services. These beans process client requests, and carry out application behaviors. In the Use phase, let's see how to invoke a bean obtained from the context <strong>in the application where it is used</strong>. Please refer to the following code:</p>
<pre>    //Get or create application context from somewhere 
    ApplicationContext applicationContext = new    <br/>    AnnotationConfigApplicationContext(AppConfig.class); 
 
    // Lookup the entry point into the application 
    TransferService transferService =    <br/>    context.getBean(TransferService.class); 
    // and use it 
    transferService.transfer("A", "B", 3000.1); </pre>
<p>Suppose the <kbd>return</kbd> service returns a raw object, then it is simply invoked directly; nothing special here. But if your bean has been wrapped in a proxy, then things become more interesting. Let's explore the following diagram to understand this more clearly:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img height="276" width="509" class=" image-border" src="assets/15ae37a0-4d43-4ca2-8e19-da8ca4ad7976.png"/></div>
<p>In the preceding diagram, you can see the <kbd>service</kbd> method call through the <kbd>Proxy</kbd> class; it is created in the <kbd>init</kbd> phase by dedicated <kbd>BeanPostProcessor</kbd>. It wraps your beans in a dynamic proxy, which adds behavior to your bean transparently. It is an implementation of the Decorator Design pattern and Proxy Design pattern.</p>
<p>Let's see how Spring creates a proxy for your bean in the Spring application.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Implementing the Decorator and Proxy patterns in Spring using Proxies</h1>
                </header>
            
            <article>
                
<p>Spring uses two types of proxy in a Spring application. The following are the kind of proxies used by Spring:</p>
<ul>
<li><strong>JDK Proxy</strong>: This is also known as a dynamic proxy. Its API is built into the JDK. For this proxy, the <kbd>Java</kbd> interface is required.</li>
<li><strong>CGLib Proxy</strong>: This is <em>NOT</em> built into JDK. However, it is included in Spring JARS, and is used when the interface is not available. It cannot be applied to final classes or methods.</li>
</ul>
<p>Let's see the features of both the proxies in the following diagram:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img height="222" width="451" class=" image-border" src="assets/ff68c3d1-47fb-49d9-bd87-440a6ed7a481.png"/></div>
<p>This is all about the Use Phase of the Spring Bean life cycle. Now let's move to the next phase of life cycle, that is, the destruction phase.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The destruction phase of the beans</h1>
                </header>
            
            <article>
                
<p>In this phase, Spring releases any system resource acquired by the application services. These are eligible for garbage collection. When you close an application context, the destruction phase completes. Let's see the following lines of code in this phase:</p>
<pre>    //Any implementation of application context 
 
    ConfigurableApplicationContext applicationContext = new   <br/>    AnnotationConfigApplicationContext(AppConfig.class); 
 
    // Destroy the application by closing application context. 
    applicationContext.close(); </pre>
<p>In the preceding code, what do you think happens when we call the <kbd>applicationContext.close()</kbd> method in this phase? The process that takes place is given as follows :</p>
<ul>
<li>Any bean implementing the <kbd>org.springframework.beans.factory.DisposableBean</kbd> interface gets a callback from the container when it is destroyed. The <kbd>DisposableBean</kbd> interface specifies a single method:</li>
</ul>
<pre>        void destroy() throws Exception; </pre>
<ul>
<li>The <kbd>bean</kbd> instances are destroyed if instructed to call their <kbd>destroy</kbd> methods. Beans must have a <kbd>destroy</kbd> method defined, that is, a <kbd>no-arg</kbd> method returning <kbd>void</kbd>.</li>
<li>The context then destroys itself, and this context is not usable again.</li>
<li>Only GC actually destroys objects and remember, it is called only when the <kbd>ApplicationContext</kbd>/JVM exit normally. It is not called for prototype beans.</li>
</ul>
<p>Let's see how to implement it with the XML Configuration:</p>
<pre>    &lt;?xml version="1.0" encoding="UTF-8"?&gt; 
    &lt;beans  
       
       
       
      xsi:schemaLocation="http://www.springframework.org/schema/beans<br/>      http://www.springframework.org/schema/beans/spring-beans.xsd 
      http://www.springframework.org/schema/context <br/>      http://www.springframework.org/schema/context/spring-context-<br/>      4.3.xsd"&gt; 
      &lt;context:annotation-config/&gt; 
      &lt;bean id="transferService" <br/>      class="com.packt.patterninspring.chapter5.<br/>      bankapp.service.TransferService"/&gt; 
      &lt;bean id="accountRepository"   <br/>      class="com.packt.patterninspring.chapter5.<br/>      bankapp.repository.JdbcAccountRepository" <br/>      destroy-method="clearCache"/&gt; 
   &lt;/beans&gt; </pre>
<p>In the configuration, the <kbd>accountRepository</kbd> bean has a <kbd>destroy</kbd> method named <kbd>clearCache</kbd>:</p>
<pre>    package com.packt.patterninspring.chapter5.bankapp.repository; 
    import com.packt.patterninspring.chapter5.bankapp.model.Account; 
    import com.packt.patterninspring.chapter5.bankapp.model.Amount; 
    import com.packt.patterninspring.chapter5.bankapp.<br/>      repository.AccountRepository; 
    public class JdbcAccountRepository implements AccountRepository { 
     @Override 
    public Account findByAccountId(Long accountId) { 
      return new Account(accountId, "Arnav Rajput", new<br/>      Amount(3000.0)); 
    } 
    void clearCache(){ 
      System.out.println("Called clearCache() method"); 
    } 
   } </pre>
<p>Let's see the same configuration with Java. In the Java configuration, we can use the <kbd>destroyMethod</kbd> attribute of the <kbd>@Bean</kbd> annotation as follows:</p>
<pre>    @Bean (destroyMethod="clearCache") 
    public AccountRepository accountRepository() { 
      return new JdbcAccountRepository(); 
    } </pre>
<p>We can do the same using Annotations. Annotations require <kbd>annotation-config</kbd> or the component scanner to be activated by using <kbd>&lt;context:component-scan ... /&gt;</kbd><kbd>, as seen in the following</kbd>:</p>
<pre>    public class JdbcAccountRepository { 
      @PreDestroy 
      void clearCache() { 
        // close files, connections... 
        // remove external resources... 
      } 
    } </pre>
<p>You have now seen the Spring bean life cycle in all its phases. In the initialization phase, Bean Post Processors for initialization and proxies. In the Use phase, Spring beans use the magic of proxy. Finally, in the destruction phase, it allows the application to terminate cleanly.</p>
<p>Now that you have seen the bean life cycle, let's learn about bean scopes, and how to create custom bean scopes in the Spring container.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Understanding bean scopes</h1>
                </header>
            
            <article>
                
<p>In Spring, each bean has one scope in the container. You can control not only the bean metadata and its life, but also the scope of that bean. You can create a custom scope of the bean, and register it with the container. You can decide the scope of the bean by configuring it with the bean definition with the XML-, Annotations-, or Java-based configuration.</p>
<p>The Spring application context <em>creates</em> all beans <em>by using</em> a singleton scope. That means, it is always the same bean each time; it doesn't matter how many times it is injected into another bean or called by other services. Because of this singleton behavior, the scope reduces the cost of instantiating. It is suitable for stateless objects in the application.</p>
<p>In a Spring application, sometimes it is required to save the state of some objects that aren't safe for reuse. For such a requirement, declaring the bean scope as a singleton is not safe, because it may cause unexpected problems when reused later. Spring provides another scope for such a requirement, which is known as the prototype scope of the Spring bean.</p>
<p>Spring defines several scopes under which a bean can be created, and these are as follows:</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The singleton bean scope</h1>
                </header>
            
            <article>
                
<p>In Spring, any bean that has a singleton scope has only one instance of the bean created for an application context, where it is defined for the entire application. This is the default behavior of the Spring container. But it is different from the singleton pattern as defined in the <strong>Gang of Four</strong> (<strong>GoF</strong>) patterns book. In Java, singleton means per object of a particular class per Classloader in the JVM. But in Spring, it implies per instance of a bean per bean definition per Spring IoC container. This is explained in the following diagram:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img class=" image-border" src="assets/4c743f7e-3f0c-4c38-890c-7bd06953c578.png"/></div>
<p>As you can see in the preceding diagram, the same instance of the object is defined by the bean definition, <kbd>accountRepository</kbd>, injected to other collaborating beans in the same IoC container. Spring stores all singleton bean instances in a cache, and all collaborating beans fetch the dependency of that object returned by the cache.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The prototype bean scope</h1>
                </header>
            
            <article>
                
<p>In Spring, any bean defined with the prototype scope has one instance of the bean created for every time the bean is injected into other collaborating beans. The following figure illustrates the Spring prototype scope:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img class=" image-border" src="assets/57c51044-2bd1-4043-97c9-ae928ac05bc7.png"/></div>
<p>As you can see in the preceding diagram, an <kbd>accountRepository</kbd> class is configured as a prototype bean, and the container creates a brand new instance for each time that bean is injected into other beans.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The session bean scope</h1>
                </header>
            
            <article>
                
<p>A new instance is created once for every user session in the web environment only.</p>
<p>Consider the following XML configuration for a bean definition:</p>
<pre>    &lt;bean id="..." class="..." scope="session"/&gt; </pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The request bean scope</h1>
                </header>
            
            <article>
                
<p>A new instance is created once for every request in the web environment only.</p>
<p>Consider the following XML configuration for a bean definition:</p>
<pre>    &lt;bean id="..." class="..." scope="request"/&gt;</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Other scopes in Spring</h1>
                </header>
            
            <article>
                
<p>Spring has other more specialized scopes, which are as follows:</p>
<ul>
<li>WebSocket scope</li>
<li>Refresh scope</li>
<li>Thread scope (defined, but not registered by default)</li>
</ul>
<p>Spring also supports the creation of your own custom scope for a bean. We'll discuss this in the following section.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Custom scopes</h1>
                </header>
            
            <article>
                
<p>We can create a custom scope of any bean, and register this scope with the application context. Let's see how to create a custom bean scope with the following example.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Creating custom scopes</h1>
                </header>
            
            <article>
                
<p>For creating your customer scope in the Spring IoC container, Spring provides the <kbd>org.springframework.beans.factory.config.Scope</kbd> interface. You have to implement this interface to create your own custom scopes. Take a look at the following <kbd>MyThreadScope</kbd> class as a custom scope in the Spring IoC container:</p>
<pre>    package com.packt.patterninspring.chapter5.bankapp.scope; 
    import java.util.HashMap; 
    import java.util.Map; 
    import org.springframework.beans.factory.ObjectFactory; 
    import org.springframework.beans.factory.config.Scope; 
 
    public class MyThreadScope implements Scope { 
      private final ThreadLocal&lt;Object&gt; myThreadScope = new<br/>      ThreadLocal&lt;Object&gt;() { 
        protected Map&lt;String, Object&gt; initialValue() { 
          System.out.println("initialize ThreadLocal"); 
          return new HashMap&lt;String, Object&gt;(); 
         } 
       }; 
    @Override 
    public Object get(String name, ObjectFactory&lt;?&gt; objectFactory) { 
      Map&lt;String, Object&gt; scope = (Map&lt;String, Object&gt;)<br/>      myThreadScope.get(); 
      System.out.println("getting object from scope."); 
      Object object = scope.get(name); 
      if(object == null) { 
        object = objectFactory.getObject(); 
        scope.put(name, object); 
      } 
      return object; 
    } 
    @Override 
    public String getConversationId() { 
      return null; 
    } 
    @Override 
    public void registerDestructionCallback(String name, Runnable<br/>    callback) { 
    
    } 
    @Override 
    public Object remove(String name) { 
      System.out.println("removing object from scope."); 
      @SuppressWarnings("unchecked") 
      Map&lt;String, Object&gt; scope = (Map&lt;String, Object&gt;)<br/>      myThreadScope.get(); 
      return scope.remove(name); 
     } 
     @Override 
     public Object resolveContextualObject(String name) { 
       return null; 
     } 
    } </pre>
<p>In the preceding code, we have overridden multiple methods of the <kbd>Scope</kbd> interface as follows:</p>
<ul>
<li><strong>Object get(String name, ObjectFactory objectFactory)</strong>: This method returns the object from the underlying scope</li>
<li><strong>Object remove(String name)</strong>: This method removes the object from the underlying scope</li>
<li><strong>void registerDestructionCallback(String name, Runnable destructionCallback)</strong>: This method registers the destruction callbacks, and is executed when the specified object with this custom scope is destroyed</li>
</ul>
<p>Now let's see how to register this custom scope with the Spring IoC container, and how to use it in the Spring application.</p>
<p>You can register this custom bean scope with the Spring IoC container declaratively by using the <kbd>CustomScopeConfigurer</kbd> class as follows :</p>
<pre>    &lt;?xml version="1.0" encoding="UTF-8"?&gt; 
    &lt;beans  
       
      xsi:schemaLocation="http://www.springframework.org/schema/beans  <br/>      http://www.springframework.org/schema/beans/spring-beans.xsd"&gt; 
      &lt;bean   class="org.springframework.beans.factory.<br/>      config.CustomScopeConfigurer"&gt; 
      &lt;property name="scopes"&gt; 
        &lt;map&gt; 
          &lt;entry key="myThreadScope"&gt; 
            &lt;bean class="com.packt.patterninspring.chapter5.<br/>            bankapp.scope.MyThreadScope"/&gt; 
          &lt;/entry&gt; 
        &lt;/map&gt; 
      &lt;/property&gt; 
     &lt;/bean&gt; 
     &lt;bean id="myBean" class="com.packt.patterninspring.chapter5.<br/>      bankapp.bean.MyBean" scope="myThreadScope"&gt;  
      &lt;property name="name" value="Dinesh"&gt;&lt;/property&gt; 
    &lt;/bean&gt; 
    &lt;/beans&gt; </pre>
<p>As you can see in the preceding configuration file, I have registered my custom bean scope named <kbd>myThreadScope</kbd> with the application context by using the <kbd>CustomScopeConfigurer</kbd> class. This custom scope that I am using is similar to the singleton or prototype scope through the scope attribute of the bean tag in the XML configuration.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>After reading this chapter, you should now have a good idea about the Spring bean life cycle in the container, and the several types of bean scope in a container. You now know that there are three phases of the Spring bean life cycle in the container. The first is the initialization phase. In this phase, Spring loads the bean definitions from XML, Java, or Annotation configurations. After loading these beans, the container constructs each bean, and applies the post-process logic on that bean.</p>
<p>The next is the Use phase, in which the Spring beans are ready to be used, and Spring shows the magic of the proxy pattern.</p>
<p>Finally, the last phase is the destruction phase. In this phase, when the application calls the <kbd>close()</kbd> method of Spring's <kbd>ApplicationContext</kbd>, the container calls the clean-up method of each bean to release resources.</p>
<p>In Spring, you can control not only the bean life cycle but also the scope of the bean in the container. The default scope of a bean in the Spring IoC container is the Singleton, but you can override the default scope by defining other scope prototypes with the bean using the scope attribute of the bean tag in XML or the <kbd>@Scope</kbd> annotation in Java. You can also create your own custom scope, and register it with the container.</p>
<p>Now we'll turn to the magic chapter of this book, that is, Spring <strong>Aspect-Oriented Programming</strong> (<strong>AOP</strong>). Much as dependency injection helps decouple components from the other components they collaborate with, AOP helps decouple your application components from tasks that span multiple components in an application. Let's move on to the next chapter, covering Spring Aspect Oriented Programming with Proxy and Decorator Design Pattern.</p>


            </article>

            
        </section>
    </body></html>