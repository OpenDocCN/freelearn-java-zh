["```java\n    user=> (println \"I am not afraid of parentheses\")\n    I am not afraid of parentheses\n    nil\n    ```", "```java\n    user=> (* (+ 1 2 3) (- 10 3))\n    42\n    ```", "```java\n    user=> (println \"Well done!\")\n    Well done!\n    Nil\n    ```", "```java\n    user=> (System/exit 0)\n    ```", "```java\n    (def base-co2 382)\n    (def base-year 2006)\n    ```", "```java\n    (defn co2-estimate\n     \"Returns a (conservative) year's estimate of carbon dioxide parts per million in the atmosphere\"\n     [year]\n     (let [year-diff (- year base-year)]\n      (+ base-co2 (* 2 year-diff))))\n    ```", "```java\n    user=> (co2-estimate 2050)\n    470\n    ```", "```java\n    user=> (doc co2-estimate)\n    -------------------------\n    user/co2-estimate\n    ([year])\n      Returns a (conservative) year's estimate of carbon dioxide parts per million in the atmosphere\n    nil\n    ```", "```java\n    (defn meditate\n      \"Return a transformed version of the string 's' based on the 'calmness-level'\"\n      [s calmness-level]\n      (println \"Clojure Meditate v2.0\"))\n    ```", "```java\n    (defn meditate\n      \"Return a transformed version of the string 's' based on the 'calmness-level'\"\n      [s calmness-level]\n      (println \"Clojure Meditate v2.0\")\n      (if (< calmness-level 4)\n        (str (clojure.string/upper-case s) \", I TELL YA!\")\n        (if (<= 4 calmness-level 9)\n            (clojure.string/capitalize s)\n            (if (= 10 calmness-level)\n              (clojure.string/reverse s)))))\n    ```", "```java\n    user=> (meditate \"what we do now echoes in eternity\" 1)\n    Clojure Meditate v2.0\n    \"WHAT WE DO NOW ECHOES IN ETERNITY, I TELL YA!\"\n    user=> (meditate \"what we do now echoes in eternity\" 6)\n    Clojure Meditate v2.0\n    \"What we do now echoes in eternity\"\n    user=> (meditate \"what we do now echoes in eternity\" 10)\n    Clojure Meditate v2.0\n    \"ytinrete ni seohce won od ew tahw\"\n    user=> (meditate \"what we do now echoes in eternity\" 50)\n    Clojure Meditate v2.0\n    nil\n    ```", "```java\n    user=> (doc cond)\n    -------------------------\n    clojure.core/cond\n    ([& clauses])\n    Macro\n      Takes a set of test/expr pairs. It evaluates each test one at a\n      time.  If a test returns logical true, cond evaluates and returns\n      the value of the corresponding expr and doesn't evaluate any of the\n      other tests or exprs. (cond) returns nil.\n    nil\n    user=> \n    (defn meditate\n      \"Return a transformed version of the string 's' based on the 'calmness-level'\"\n      [s calmness-level]\n      (println \"Clojure Meditate v2.0\")\n      (cond\n        (< calmness-level 4)  (str (clojure.string/upper-case s) \", I TELL YA!\")\n        (<= 4 calmness-level 9) (clojure.string/capitalize s)\n        (= 10 calmness-level) (clojure.string/reverse s)))\n    ```", "```java\n    user=>\n    (def memory-db (atom {}))\n    #'user/memory-db\n    (defn read-db [] @memory-db)\n    #'user/read-db\n    user=> (defn write-db [new-db] (reset! memory-db new-db))\n    #'user/write-db\n    ```", "```java\n    user=>\n    (defn create-table\n      [table-name]\n      (let [db (read-db)]\n        (write-db (assoc db table-name {:data [] :indexes {}}))))\n    #'user/create-table\n    ```", "```java\n    user=> (create-table :clients)\n    {:clients {:data [], :indexes {}}}\n    user=> (create-table :fruits)\n    {:clients {:data [], :indexes {}}, :fruits {:data [], :indexes {}}}\n    ```", "```java\n    user=>\n    (defn drop-table\n      [table-name]\n      (let [db (read-db)]\n        (write-db (dissoc db table-name))))\n    #'user/drop-table\n    ```", "```java\n    user=> (create-table :clients)\n    {:clients {:data [], :indexes {}}}\n    user=> (create-table :fruits)\n    {:clients {:data [], :indexes {}}, :fruits {:data [], :indexes {}}}\n    user=> (drop-table :clients)\n    {:fruits {:data [], :indexes {}}}\n    ```", "```java\n    user=> (insert :fruits {:name \"Pear\" :stock 3} :name)\n    {:fruits {:data [{:name \"Pear\", :stock 3}], :indexes {:name {\"Pear\" 0}}}}\n    ```", "```java\n    (defn insert\n      [table-name record id-key]\n        (let [db (read-db)\n    ```", "```java\n    (defn insert\n      [table-name record id-key]\n        (let [db (read-db)\n              new-db (update-in db [table-name :data] conj record)\n    ```", "```java\n    (defn insert\n      [table-name record id-key]\n        (let [db (read-db)\n              new-db (update-in db [table-name :data] conj record)\n              index (- (count (get-in new-db [table-name :data])) 1)]\n    ```", "```java\n    user=>\n    (defn insert\n      [table-name record id-key]\n        (let [db (read-db)\n              new-db (update-in db [table-name :data] conj record)\n              index (- (count (get-in new-db [table-name :data])) 1)]\n          (write-db\n            (update-in new-db [table-name :indexes id-key] assoc (id-key record) index))))\n    #'user/insert\n    ```", "```java\n    user=>  (insert :fruits {:name \"Apricot\" :stock 30} :name)\n    {:fruits {:data [{:name \"Pear\", :stock 3} {:name \"Apricot\", :stock 30}], :indexes {:name {\"Pear\" 0, \"Apricot\" 1}}}}\n    user=>  (insert :fruits {:name \"Grapefruit\" :stock 6} :name)\n    {:fruits {:data [{:name \"Pear\", :stock 3} {:name \"Apricot\", :stock 30} {:name \"Grapefruit\", :stock 6}], :indexes {:name {\"Pear\" 0, \"Apricot\" 1, \"Grapefruit\" 2}}}}\n    ```", "```java\n    user=> (select-* :fruits)\n    [{:name \"Pear\", :stock 3} {:name \"Apricot\", :stock 30} {:name \"Grapefruit\", :stock 6}]\n    user=>\n    (defn select-*\n      [table-name]\n      (get-in (read-db) [table-name :data]))\n    #'user/select-*\n    ```", "```java\n    user=> (select-*-where :fruits :name \"Apricot\")\n    {:name \"Apricot\", :stock 30}\n    user=>\n    (defn select-*-where\n      [table-name field field-value]\n      (let [db (read-db)\n            index (get-in db [table-name :indexes field field-value])\n            data (get-in db [table-name :data])]\n        (get data index)))\n    #'user/select-*-where\n    ```", "```java\n    user=>  (insert :fruits {:name \"Pear\" :stock 3} :name)\n    Record with :name Pear already exists. Aborting\n    user=> (select-* :fruits)\n    [{:name \"Pear\", :stock 3} {:name \"Apricot\", :stock 30} {:name \"Grapefruit\", :stock 6}]\n    user=>\n    (defn insert\n      [table-name record id-key]\n      (if-let [existing-record (select-*-where table-name id-key (id-key record))]\n        (println (str \"Record with \" id-key \": \" (id-key record) \" already exists.       Aborting\"))\n        (let [db (read-db)\n              new-db (update-in db [table-name :data] conj record)\n              index (- (count (get-in new-db [table-name :data])) 1)]\n          (write-db\n            (update-in new-db [table-name :indexes id-key] assoc (id-key record)           index)))))\n    #'user/insert\n    ```", "```java\n    user=> (create-table :fruits)\n    {:clients {:data [], :indexes {}}, :fruits {:data [], :indexes {}}}\n    user=> (insert :fruits {:name \"Pear\" :stock 3} :name)\n    Record with :name Pear already exists. Aborting\n    user=> (select-* :fruits)\n    [{:name \"Pear\", :stock 3} {:name \"Apricot\", :stock 30} {:name \"Grapefruit\", :stock 6}]\n    user=> (select-*-where :fruits :name \"Apricot\")\n    {:name \"Apricot\", :stock 30}\n    ```", "```java\n     (def walking-speed 4)\n    (def driving-speed 70)\n    ```", "```java\n     (def paris {:lat 48.856483 :lon 2.352413})\n    (def bordeaux {:lat 44.834999  :lon -0.575490})\n    ```", "```java\n     (defn distance\n      \"Returns a rough estimate of the distance between two coordinate points, in     kilometers. Works better with smaller distance\"\n      [{lat1 :lat lon1 :lon} {lat2 :lat lon2 :lon}]\n      (let [deglen 110.25\n            x (- lat2 lat1)\n            y (* (Math/cos lat2) (- lon2 lon1))]\n        (* deglen (Math/sqrt (+ (* y y) (* x x))))))\n    ```", "```java\n     (defmulti itinerary\n        \"Calculate the distance of travel between two location, and the cost and       duration based on the type of transport\"\n        :transport)\n    ```", "```java\n     (defmethod itinerary :walking\n      [{:keys [:from :to]}]\n      (let [walking-distance (distance from to)\n        duration (/ (distance from to) walking-speed)]\n        {:cost 0 :distance walking-distance :duration duration}))\n    ```", "```java\n     (def vehicle-cost-fns\n      {\n        :sporche (partial * 0.12 1.3)\n        :tayato (partial * 0.07 1.3)\n        :sleta (partial * 0.2 0.1)\n      })\n    ```", "```java\n     (defmethod itinerary :driving\n      [{:keys [:from :to :vehicle]}]\n      (let [driving-distance (distance from to)\n            cost ((vehicle vehicle-cost-fns) driving-distance)\n            duration (/ driving-distance driving-speed)]\n        {:cost cost :distance driving-distance :duration duration}))\n    ```", "```java\n    user=> (def london {:lat 51.507351, :lon -0.127758})\n    #'user/london\n    user=> (def manchester {:lat 53.480759, :lon -2.242631})\n    #'user/manchester\n    user=> (itinerary {:from london :to manchester :transport :walking})\n    {:cost 0, :distance 318.4448148814284, :duration 79.6112037203571}\n    user=> (itinerary {:from manchester :to london :transport :driving :vehicle :sleta})\n    {:cost 4.604730845743489, :distance 230.2365422871744, :duration 3.2890934612453484}\n    ```", "```java\n    (defn max-value-by-status [field status users]\n                   (->> \n                     users\n                     ;; code will go here\n                     ))\n    ```", "```java\n    (defn max-value-by-status [field status users]\n                   (->> \n                     users\n                      ;; step 1: use filter to only keep users who\n                      ;; have the status we are looking for \n                     (filter #(= (:status %) status))\n                      ;; More to come!\n                     ))\n    ```", "```java\n    (defn max-value-by-status [field status users]\n                   (->> \n                     users\n                      ;; step 1: use filter to only keep users who\n                      ;; have the status we are looking for \n                     (filter #(= (:status %) status))\n                     ;; step 2: field is a keyword, so we can use it as \n                     ;; a function when calling map.\n                     (map field)\n                     ;; Watch this space!\n                     ))\n    ```", "```java\n    (defn max-value-by-status [field status users]\n                   (->> \n                     users\n                     (filter #(= (:status %) status))\n                     (map field)\n                     (apply max 0)))\n    (defn min-value-by-status [field status users]\n                   (->> \n                     users\n                     (filter #(= (:status %) status))\n                     (map field)\n                     (apply min 0)))\n    ```", "```java\n    (defn rivalry-data [csv player-1 player-2]\n      (with-open [r (io/reader csv)]\n        ))\n    ```", "```java\n    (let [rivalry-seq (->> (csv/read-csv r)\n                           sc/mappify\n                           (sc/cast-with {:winner_sets_won sc/->int\n                                          :loser_sets_won sc/->int\n                                          :winner_games_won sc/->int\n                                          :loser_games_won sc/->int}))]\n      ;; more to come\n      )\n    ```", "```java\n    (filter #(= (hash-set (:winner_name %) (:loser_name %))\n                                           #{player-1 player-2}))\n                               (map #(select-keys % [:winner_name\n                                                     :loser_name\n                                                     :winner_sets_won\n                                                     :loser_sets_won\n                                                     :winner_games_won\n                                                     :loser_games_won\n                                                     :tourney_year_id\n                                                     :tourney_slug]))\n    ```", "```java\n    player-1-victories (filter #(= (:winner_name %) player-1) rivalry-seq)\n              player-2-victories (filter #(= (:winner_name %) player-2) rivalry-            seq)\n    ```", "```java\n          {:first-victory-player-1 (first player-1-victories)\n           :first-victory-player-2 (first player-2-victories)\n           :total-matches (count rivalry-seq)\n           :total-victories-player-1 (count player-1-victories)\n           :total-victories-player-2 (count player-2-victories)\n           :most-competitive-matches (->> rivalry-seq\n                                          (filter #(= 1 (- (:winner_sets_won %)                                         (:loser_sets_won %)))))}\n    ```", "```java\n    {:deps\n     {org.clojure/data.csv {:mvn/version \"0.1.4\"}\n      semantic-csv {:mvn/version \"0.2.1-alpha1\"}\n      org.clojure/math.numeric-tower {:mvn/version \"0.0.4\"}}}\n    ```", "```java\n    (ns packt-clj.elo\n      (:require [clojure.math.numeric-tower :as math]\n                [clojure.java.io :as io]\n                [clojure.data.csv :as csv]\n                [semantic-csv.core :as sc])\n    ```", "```java\n    (defn elo-world\n      ([csv k]\n       (with-open [r (io/reader csv)]\n         (->> (csv/read-csv r)\n              sc/mappify\n              (sc/cast-with {:winner_sets_won sc/->int\n                             :loser_sets_won sc/->int\n                             :winner_games_won sc/->int\n                             :loser_games_won sc/->int})\n              ;; TODO: just getting started\n              )))) \n    ```", "```java\n    (defn elo-world\n      ([csv k]\n       (with-open [r (io/reader csv)]\n         (->> (csv/read-csv r)\n              sc/mappify\n              (sc/cast-with {:winner_sets_won sc/->int\n                             :loser_sets_won sc/->int\n                             :winner_games_won sc/->int\n                             :loser_games_won sc/->int})\n              (reduce (fn [{:keys [players] :as acc} {:keys [:winner_name :winner_slug\n                                                             :loser_name :loser_slug] :as match}]\n                        ;; TODO: more code\n                        )\n                      {:players {}\n                       :match-count 0\n                       :predictable-match-count 0\n                       :correct-predictions 0})))))\n    ```", "```java\n    (let [winner-rating (get players winner_slug 400)\n           loser-rating (get players loser_slug 400)\n           winner-probability (match-probability winner-rating loser-rating)\n           loser-probability (- 1 winner-probability)\n           predictable-match? (not= winner-rating loser-rating)\n           prediction-correct? (> winner-rating loser-rating)\n           correct-predictions (if (and predictable-match? prediction-correct?)\n                                 (inc (:correct-predictions acc))\n                                 (:correct-predictions acc))\n           predictable-matches (if predictable-match?\n                                 (inc (:predictable-match-count acc))\n                                 (:predictable-match-count acc))]\n\n       ;; TODO: update the accumulator\n       )\n    ```", "```java\n    (-> acc\n        (assoc :predictable-match-count predictable-matches)\n        (assoc :correct-predictions correct-predictions)\n        (assoc-in [:players winner_slug] (recalculate-rating k winner-rating winner-probability 1))\n        (assoc-in [:players loser_slug] (recalculate-rating k loser-rating loser-probability 0))\n        (update :match-count inc))\n    ```", "```java\ntennis.clj\n16  (defn elo-world-simple\n17  ([csv k]\n18   (with-open [r (io/reader csv)]\n19     (->> (csv/read-csv r)\n20          sc/mappify\n21          (sc/cast-with {:winner_sets_won sc/->int\n22                         :loser_sets_won sc/->int\n23                         :winner_games_won sc/->int\n24                         :loser_games_won sc/->int})\n25          (reduce (fn [{:keys [players] :as acc} {:keys [:winner_name               :winner_slug\n26                                                         :loser_name                                                              :loser_slug] :as match}]\nThe complete code for this snippet can be found at: https://packt.live/38wSCUn\n```", "```java\n    (ns my-hiccup\n     (:require [clojure.string :as string]))\n    ```", "```java\n    (defn attributes [m]\n     (clojure.string/join \" \"\n                (map (fn [[k v]]\n                   (if (string? v)\n                    (str (name k) \"=\\\"\" v \"\\\"\")\n                    (name k)))\n                  m)))\n    ```", "```java\n    (defn keyword->opening-tag [kw]\n     (str \"<\" (name kw) \">\"))\n    (defn keyword-attributes->opening-tag [kw attrs]\n     (str \"<\" (name kw) \" \" (attributes attrs) \">\"))\n    (defn keyword->closing-tag [kw]\n     (str \"</\" (name kw) \">\"))\n    ```", "```java\n    (defn has-attributes? [tree]\n     (map? (second tree)))\n    ```", "```java\n    (defn singleton? [tree]\n     (and (vector? tree)\n        (#{:img :meta :link :input :br} (first tree))))\n    ```", "```java\n    (defn singleton-with-attrs? [tree]\n     (and (singleton? tree) (has-attributes? tree)))\n    (defn element-with-attrs? [tree]\n     (and (vector? tree) (has-attributes? tree)))\n    ```", "```java\n    (defn my-hiccup [tree]\n     (cond\n      ))\n    ```", "```java\n      (not tree) tree\n    ```", "```java\n      (string? tree) tree\n    ```", "```java\n      (singleton-with-attrs? tree)\n      (keyword-attributes->opening-tag (first tree) (second tree))\n    ```", "```java\n      (singleton? tree)\n      (keyword->opening-tag (first tree))\n    ```", "```java\n      (element-with-attrs? tree)\n      (apply str\n          (concat\n           [(keyword-attributes->opening-tag (first tree) (second tree))]\n           (map my-hiccup (next (next tree)))\n           [(keyword->closing-tag (first tree))]))\n    ```", "```java\n      (vector? tree)\n      (apply str\n          (concat\n           [(keyword->opening-tag (first tree))]\n           (map my-hiccup (next tree))\n           [(keyword->closing-tag (first tree))]))\n    ```", "```java\n    (defn my-hiccup [tree]\n     (cond\n      (not tree) tree\n      (string? tree) tree\n      (singleton-with-attrs? tree)\n      (keyword-attributes->opening-tag (first tree) (second tree))\n      (singleton? tree)\n      (keyword->opening-tag (first tree))\n      (element-with-attrs? tree)\n      (apply str\n          (concat\n           [(keyword-attributes->opening-tag (first tree) (second tree))]\n           (map my-hiccup (next (next tree)))\n           [(keyword->closing-tag (first tree))]))\n      (vector? tree)\n      (apply str\n          (concat\n           [(keyword->opening-tag (first tree))]\n           (map my-hiccup (next tree))\n           [(keyword->closing-tag (first tree))]))))\n    ```", "```java\n    (defn focus-history [tree player-slug focus-depth opponent-depth f]\n    ;;...\n    )\n    ```", "```java\n    (defn focus-history [tree player-slug focus-depth opponent-depth f]\n        (cond\n          (zero? focus-depth)\n          '()\n          (= 1 focus-depth)\n          (f (first tree))))\t\n    ```", "```java\n    :otherwise-continue\n            (cons\n              (f (first tree))\n              (cons\n                [(take-matches (dec limit) (first (second tree)) f)\n                 (take-matches (dec limit) (second (second tree)) f)]\n                '()))\n    ```", "```java\n     :otherwise\n     (cons\n       (f (first tree))\n       (cons [(if (player-in-match? (ffirst (second tree)) player-slug)\n                (focus-history (first (second tree)) player-slug (dec focus-depth) opponent-depth f)\n                (take-matches opponent-depth (first (second tree))  f))\n              (if (player-in-match? (first (second (second tree))) player-slug)\n                (focus-history (second (second tree)) player-slug (dec focus-depth) opponent-depth f)\n                (take-matches opponent-depth (second (second tree)) f))]\n             '()))\n    ```", "```java\n    (defn focus-history [tree player-slug focus-depth opponent-depth f]\n        (cond\n          (zero? focus-depth)\n          '()\n          (= 1 focus-depth)\n          (f (first tree))\n          :otherwise\n          (cons\n            (f (first tree))\n            (cons [(if (player-in-match? (ffirst (second tree)) player-slug)\n                     (focus-history (first (second tree)) player-slug (dec focus-depth)                    opponent-depth f)\n                     (take-matches opponent-depth (first (second tree))  f))\n                   (if (player-in-match? (first (second (second tree))) player-slug)\n                     (focus-history (second (second tree)) player-slug (dec focus-depth)                    opponent-depth f)\n                     (take-matches opponent-depth (second (second tree)) f))]\n                  '()))))\n    ```", "```java\n    packt-clojure.lazy-tennis> (def ratings (elo-db   \"match_scores_1991-2016_unindexed_csv.csv\" 35))\n    ```", "```java\n    #'packt-clojure.lazy-tennis/ratings\n    packt-clojure.lazy-tennis> (def federer (match-tree-by-player ratings   \"roger-federer\"))\n    #'packt-clojure.lazy-tennis/federer\n    ```", "```java\n    packt-clojure.lazy-tennis> (focus-history federer \n                                              \"roger-federer\" \n                                              4 \n                                              2 \n                                              #(select-keys % [:winner_name :loser_name                                             :winner_rating :loser_rating]))\n    ```", "```java\n    (use '[clojure.string :rename {replace str-replace, reverse str-reverse}])\n    ```", "```java\n    (def users #{\"mr_paul smith\" \"dr_john blake\" \"miss_katie hudson\"})\n    ```", "```java\n    (map #(str-replace % #\"_\" \" \") users)\n    ```", "```java\n    (\"mr paul smith\" \"miss katie hudson\" \"dr john blake\")\n    ```", "```java\n    (map #(capitalize %) users)\n    ```", "```java\n    (\"Mr_paul smith\" \"Miss_katie hudson\" \"Dr_john blake\")\n    ```", "```java\n    (def updated-users (into #{}\n                             (map #(join \" \"\n                                         (map (fn [sub-str] (capitalize sub-str))\n                                              (split (str-replace % #\"_\" \" \") #\" \")))\n                                  users)))\n    updated-users\n    ```", "```java\n    #{\"Mr Paul Smith\" \"Dr John Blake\" \"Miss Katie Hudson\"}\n    ```", "```java\n    (use '[clojure.pprint :only (print-table)])\n    ```", "```java\n    (print-table (map #(hash-map :user-name %) updated-users))\n    ```", "```java\n    (use '[clojure.set :exclude (join)])\n    ```", "```java\n    (def admins #{\"Mr Paul Smith\" \"Miss Katie Hudson\" \"Dr Mike Rose\" \"Mrs Tracy Ford\"})\n    ```", "```java\n    #'user/admins\n    ```", "```java\n    admins\n    ```", "```java\n    #{\"Mr Paul Smith\" \"Dr Mike Rose\" \"Miss Katie Hudson\" \"Mrs Tracy Ford\"}\n    ```", "```java\n    (subset? users admins)\n    ```", "```java\n    false\n    ```", "```java\n    (print-table (map #(hash-map :user-name %) updated-users))\n    ```", "```java\n    lein new app hello-leiningen\n    ```", "```java\n    (map #(Integer/parseInt %) args)\n    ```", "```java\n    apply +\n    ```", "```java\n    println\n    ```", "```java\n(ns hello-leiningen.core)\n(defn -main\n  \"Sum integers passed as arguments.\"\n  [& args]\n  (println (apply + (map #(Integer/parseInt %) args))))\n```", "```java\n    (defproject json-parser \"0.1.0-SNAPSHOT\"\n    ;;; code committed\n       :dependencies [[org.clojure/clojure \"1.10.0\"]\n                                [cheshire \"3.0.0\"]]\n    ;;; code ommited\n    )\n    ```", "```java\n    (ns json-parser.core\n        (:require [cheshire.core :as json])\n        (:gen-class))\n    (defn generate-json-from-hash [hash]\n          (json/generate-string hash))\n    ```", "```java\n    (defn generate-hash-from-json [json]\n          (json/parse-string json))\n    ```", "```java\n    (defproject json-parser \"0.1.0-SNAPSHOT\"\n     ;;; code ommited\n      :profiles {:qa  {:dependencies [[expectations \"2.1.10\"]]}\n    ;;; code ommited\n    })\n    ```", "```java\n    (defproject json-parser \"0.1.0-SNAPSHOT\"\n     ;;; code ommited\n      :profiles {:qa  {:plugins      [[lein-expectations \"0.0.8\"]]}\n    ;;; code ommited\n    })\n    ```", "```java\n    (ns json-parser.core-test\n      (:require [expectations :refer [expect]]\n                [json-parser.core :refer :all]))\n    (expect (generate-json-from-hash {:name \"John\" :occupation \"programmer\"})\n            \"{\\\"name\\\":\\\"John\\\",\\\"occupation\\\":\\\"programmer\\\"}\")\n    (expect (generate-hash-from-json \"{\\\"name\\\":\\\"Mike\\\",\\\"occupation\\\":\\\"carpenter\\\"}\")\n            {\"name\" \"Mike\", \"occupation\" \"carpenter\"})\n    ```", "```java\n    {:user {:plugins [[lein-ancient \"0.6.15\"]]\n            :dependencies [[clojure-humanize \"0.2.2\"]]}}\n    ```", "```java\n    lein new app books-app\n    ```", "```java\n    (ns books-app.core\n      (:require [books-app.utils :as utils])\n      (:import [java.util Scanner])\n      (:gen-class))\n    ```", "```java\n    (def ^:const books {:2019 {:clojure {:title \"Hands-On Reactive Programming with Clojure\" :price 20}\n                               :go      {:title \"Go Cookbook\" :price 18}}\n                        :2018 {:clojure {:title \"Clojure Microservices\" :price 15}\n                               :go {:title \"Advanced Go programming\" :price 25}}})\n    ```", "```java\n    (def ^:const orders-file \"orders.edn\")\n    ```", "```java\n    (def input (Scanner. System/in))\n    (defn- start-app []\n           \"Displaying main menu and processing user choices.\"\n           (let [run-application (ref true)]\n                (while (deref run-application)\n                       (println \"\\n|     Books app         |\")\n                       (println \"| 1-Menu 2-Orders 3-Exit |\\n\")\n                       (let [choice (.nextInt input)]\n                            (case choice\n                                  1 (show-menu)\n                                  2 (show-orders)\n                                  3 (dosync (alter run-application (fn [_]                                   false))))))))\n    ```", "```java\n    (defn- show-menu []\n           (println \"| Available books by year |\")\n           (println \"|1\\. 2019   2\\. 2018 |\")\n           (let [choice (.nextInt input)]\n                (case choice\n                      1 (show-year-menu :2019)\n                      2 (show-year-menu :2018))))\n    ```", "```java\n    (defn -main\n      \"Main function to run the app.\"\n      [& args]\n      (start-app))\n    ```", "```java\n    (ns books-app.utils\n        (:require [clojure.java.io :as io])\n        (:import [java.io PushbackReader]))\n    (defn save-to [location data]\n          (spit location data :append true))\n    ```", "```java\n    (defn save-book-order [orders-file year prog-lang number price]\n          (save-to orders-file {:year year :prog-lang prog-lang :number number :price price}))\n    ```", "```java\n    (defn calculate-book-price [books title number]\n          (->\n            (get books title)\n            :price\n            (* number)\n            float))\n    ```", "```java\n    (defn display-bought-book-message [title number total]\n          (println \"Buying\" number title \"for total:€\" total))\n    ```", "```java\n    (defn display-order [order books]\n          (str \"Bought \" (:number order) \": \" (:title (get (get books (:year order)) (:prog-lang order))) \" published in \" (name (:year order)) \" for €\" (:price order)))\n    ```", "```java\n    (defn read-one-order\n          [r]\n          (try\n            (read r)\n            (catch java.lang.RuntimeException e\n              (if (= \"EOF while reading\" (.getMessage e))\n                ::EOF\n                (throw e)))))\n    ```", "```java\n    (defn file-exists [location]\n          (.exists (io/as-file location)))\n    ```", "```java\n    (defn load-orders\n          \"Reads a sequence of orders in file at path.\"\n          [file]\n          (if (file-exists file)\n            (with-open [r (PushbackReader. (io/reader file))]\n                       (binding [*read-eval* false]\n                                (doall (take-while #(not= ::EOF %) (repeatedly                               #(read-one-order r))))))\n            []))\n    ```", "```java\n    (ns coffee-app.core)\n    (defn- show-year-menu [year]\n           (let [year-books (get books year)]\n                (println \"| Books in\" (name year) \"|\")\n                (println \"| 1\\. \" (:title (:clojure year-books)) \" 2\\. \" (:title                (:go year-books))  \"|\")\n                (let [choice (.nextInt input)]\n                     (case choice\n                           1 (buy-book year :clojure)\n                           2 (buy-book year :go)))))\n    ```", "```java\n    (defn- buy-book [year prog-lang]\n           (println \"How many books do you want to buy?\")\n           (let [choice (.nextInt input)\n                 price (utils/calculate-book-price (get books year) prog-lang                choice)]\n                (utils/save-book-order orders-file year prog-lang choice price)\n                (utils/display-bought-book-message (:title (get (get books year)               prog-lang)) choice price)))\n    ```", "```java\n    (defn- show-orders-by-year [year]\n           (println \"\\n\")\n           (doseq [order (filter #(= year (:year %)) (utils/load-orders orders-         file))]\n                  (println (utils/display-order order books))))\n    ```", "```java\n    (defn show-orders []\n          (println \"| Books by publish year |\")\n          (println \"|1\\. 2019   2\\. 2018 |\")\n          (let [choice (.nextInt input)]\n               (case choice\n                     1 (show-orders-by-year :2019)\n                     2 (show-orders-by-year :2018)))) \n    ```", "```java\n    lein new figwheel-main support-desk\n    ```", "```java\n    :dependencies [[org.clojure/clojure \"1.9.0\"]\n                   [org.clojure/clojurescript \"1.10.520\"]\n                   [funcool/cuerdas \"2.2.0\"]\n                   [jayq \"2.5.4\"]\n                   [rum \"0.11.2\"]]\n    ```", "```java\n    (ns support-desk.utils)\n    (defn get-priorities-list [list priority]\n          (filter #(<= (:priority %) priority) list))\n    ```", "```java\n    (defn get-sorted-priorities-list [list]\n          (sort-by :priority list))\n    ```", "```java\n    (defn get-sort-message [items-count]\n          (str (cond\n                 (< items-count 3) \"little\"\n                 (< items-count 6) \"medium\"\n                 :else \"many\") \" (\" items-count \")\"))\n    ```", "```java\n    Sorting done: little (0) times\n    ```", "```java\n    Sorting done: medium (3) times\n    ```", "```java\n     (defn delete-item-from-list-by-title [title list]\n          (remove #(= title (:title %)) list))\n    ```", "```java\n    (defn handle-sort-finish [state]\n          (fn [ev ui]\n              (swap! state update-in [:sort-counter] inc)))\n    ```", "```java\n    <script src=\"img/jquery-3.4.1.min.js\" integrity=\"sha256-CSXorXvZcTkaix6Yvo6HppcZGetbYMGWSFlBw8HfCJo=\" crossorigin=\"anonymous\"></script>\n    <script src=\"img/code.jquery.com/ui/1.12.1/jquery-ui.min.js\" integrity=\"sha256-VazP97ZCwtekAsvgPBSUwPFKdrwD3unUfSGVYrahUqU=\" crossorigin=\"anonymous\"></script>\n    ```", "```java\n    (ns ^:figwheel-hooks support-desk.core\n      (:require [cuerdas.core :as str]\n                [goog.dom :as gdom]\n                [jayq.core :as jayq :refer [$]]\n                [rum.core :as rum]\n                [support-desk.utils :as utils]))\n    ```", "```java\n    (def priorities-list [{:title \"IE bugs\" :priority 2} {:title \"404 page\" :priority 1} {:title \"Forgotten username\" :priority 2}\n                          {:title \"Login token\" :priority 1} {:title \"Mobile version\" :priority 3} {:title \"Load time\" :priority 5}])\n    ```", "```java\n    (defonce app-state (atom {:sort-counter 0\n                              :items        (utils/get-sorted-priorities-list (utils/get-priorities-list priorities-list 3))}))\n    ```", "```java\n    (rum/defc counter [number]\n              [:div\n               (str/format \"Sorting done: %s times\" (utils/get-sort-message number))])\n    ```", "```java\n    (defn done-button-click [item]\n          (swap! app-state update-in [:items] #(utils/delete-item-from-list-by-        title (:title item) %)))\n    ```", "```java\n    (rum/defc item [item]\n              [:li.ui-state-default {:key (:title item)}\n               (str/format \"Priority %s for: %s \" (:priority item) (:title               item))\n               [:button.delete\n                {:on-click #(done-button-click item)}\n                \"Done\"]])\n    ```", "```java\n    (rum/defc items < rum/reactive [num]\n              [:ul#sortable (vec (for [n num]\n                                      (item n)))])\n    ```", "```java\n    (rum/defc content < rum/reactive []\n              [:div {}\n               (items (:items (deref app-state)))\n               (counter (:sort-counter (rum/react app-state)))])\n    ```", "```java\n    (defn attrs [a]\n          (clj->js (sablono.util/html-to-dom-attrs a)))\n    (defn make-sortable []\n          (.sortable ($ (str \"#sortable\"))\n                     (attrs {:stop (utils/handle-sort-finish app-state)})))\n    ```", "```java\n    (defn mount [el]\n      (rum/mount (content) el))\n    (defn mount-app-element []\n      (when-let [el (get-app-element)]\n        (mount el)))\n    ```", "```java\n    (mount-app-element)\n    ```", "```java\n    (make-sortable)\n    ```", "```java\n    lein fig:build\n    ```", "```java\n    (ns coffee-app.utils-test\n        (:require [clojure.test :refer :all]\n                  [coffee-app.core :refer [price-menu]]\n                  [coffee-app.utils :refer :all]))\n    ```", "```java\n    (deftest display-order-test\n             (testing \"Multiple tests with is macro\"\n                      (is (= (display-order {:number 4 :price 3.8 :type :latte}) \"Bought 4 cups of latte for €3.8\"))\n                      (is (= (display-order {:number 7 :price 6.3 :type :espresso}) \"Bought 7 cups of espresso for €6.3\"))))\n    ```", "```java\n    (deftest display-order-test\n             (testing \"Multiple tests with are macro\"\n                      (are [order result]\n                           (= (display-order order) result)\n                           {:number 2 :price 1.5 :type :latte} \"Bought 2 cups of                          latte for €1.5\"\n                           {:number 3 :price 6.3 :type :mocca} \"Bought 3 cups of                          mocca for €6.3\"\n                           {:number 8 :price 10 :type :espresso} \"Bought 8 cups                          of espresso for €10\")))\n    ```", "```java\n    (deftest file-exists-test\n       (testing \"File does not exist\"\n                      (testing \"Multiple tests with is macro\"\n                               (is (false? (file-exists \"no-file\")))\n                               (is (false? (file-exists \"missing-file\"))))\n                      (testing \"Multiple tests with are macro\"\n                               (are [file] (false? (file-exists file))\n                                    \"eettcc\"\n                                    \"tmp-tmp\"\n                                    \"no-file-here\"))))\n    ```", "```java\n    (deftest file-exists-test\n             (testing \"File does exist\"\n                      (testing \"Multiple tests with is macro\"\n                               (is (file-exists \"/etc\"))\n                               (is (file-exists \"/lib\")))\n                      (testing \"Multiple tests with are macro\"\n                               (are [file] (true? (file-exists file))\n                                    \"/etc\"\n                                    \"/var\"\n                                    \"/tmp\"))))\n    ```", "```java\n    (defn uuid [] (str (java.util.UUID/randomUUID)))\n    (deftest saves-coffee-order\n             (testing \"Saves cofee order\"\n                      (let [test-file (str \"/tmp/\" (uuid) \".edn\")\n                            test-data {:type :latte, :number 2, :price 2.6}]\n                           (save-coffee-order test-file :latte 2 2.6)\n                           (is (= (list test-data) (load-orders test-file))))))\n    ```", "```java\n    (deftest loads-empty-vector-from-not-existing-file\n             (testing \"saving and loading\"\n                      (let [test-file (str \"/tmp/\" (uuid) \".edn\")]\n                           (is (= [] (load-orders test-file))))))\n    ```", "```java\n    (deftest can-save-and-load-some-data\n             (testing \"saving and loading\"\n                      (let [test-file (str \"/tmp/\" (uuid) \".edn\")\n                            test-data {:number 1 :type :latte}]\n                           (save-to test-file test-data)\n                           (is (= (list test-data) (load-orders test-file))))))\n    ```", "```java\n    (ns coffee-app.utils-test-expectations\n        (:require [coffee-app.utils :refer :all]\n                  [expectations :refer [expect side-effects]]))\n    (expect \"Bought 4 cups of latte for €3.8\" (display-order {:number 4 :price 3.8 :type :latte}))\n    (expect \"Bought 7 cups of espresso for €6.3\" (display-order {:number 7 :price 6.3 :type :espresso}))\n    (expect String (display-order {:number 7 :price 6.3 :type :espresso}))\n    (expect #\"Bought 7 cups\" (display-order {:number 7 :price 6.3 :type :espresso}))\n    (expect #\"cups of espresso\" (display-order {:number 7 :price 6.3 :type :espresso}))\n    (expect #\"for €6.3\" (display-order {:number 7 :price 6.3 :type :espresso}))\n    ```", "```java\n    (expect true (file-exists \"/tmp\"))\n    (expect false (file-exists \"no-file\"))\n    (expect Boolean (file-exists \"etc\"))\n    ```", "```java\n    (expect [[\"/tmp/menu.edn\" {:type :latte :number 1 :price 2.4} :append true]\n             [\"/tmp/menu.edn\" {:type :latte :number 3 :price 4.7} :append true]]\n            (side-effects [spit]\n                          (save-to \"/tmp/menu.edn\" {:type :latte :number 1 :price 2.4})\n                          (save-to \"/tmp/menu.edn\" {:type :latte :number 3 :price 4.7})))\n    ```", "```java\n    (expect [[\"/tmp/orders.edn\" :latte 1 2.4]\n             [\"/tmp/orders.edn\" :latte 2 3.9]]\n            (side-effects [save-coffee-order]\n                          (save-coffee-order \"/tmp/orders.edn\" :latte 1 2.4)\n                          (save-coffee-order \"/tmp/orders.edn\" :latte 2 3.9)))\n    ```", "```java\n    (expect [[\"/tmp/coffees.edn\" {:type :latte :number 1 :price 2.4}]\n             [\"/tmp/coffees.edn\" {:type :latte :number 2 :price 3.9}]]\n            (side-effects [save-to]\n                          (save-coffee-order \"/tmp/coffees.edn\" :latte 1 2.4)\n                          (save-coffee-order \"/tmp/coffees.edn\" :latte 2 3.9)))\n    Load orders:\n    (expect [] (load-orders \"/tmp/data.edn\"))\n    ```", "```java\n    (ns coffee-app.utils-test-midje\n        (:require [coffee-app.utils :refer :all]\n                  [midje.sweet :refer :all]))\n    (facts \"Passing an order should return display message\"\n           (fact (display-order {:number 4 :price 3.8 :type :latte}) => \"Bought 4 cups of latte for €3.8\")\n           (fact (display-order {:number 7 :price 6.3 :type :espresso}) => \"Bought 7 cups of espresso for €6.3\"))\n    (facts \"Returned message should match regular expression\"\n           (fact (display-order {:number 7 :price 6.3 :type :espresso}) => #\"Bought 7 cups\")\n           (fact (display-order {:number 7 :price 6.3 :type :espresso}) => #\"cups of espresso\")\n           (fact (display-order {:number 7 :price 6.3 :type :espresso}) => #\"for €6.3\"))\n    ```", "```java\n    (facts \"True should be returned when a file exists\"\n           (fact (file-exists \"/tmp\") => true)\n           (fact (file-exists \"/etc\") => true))\n    (facts \"False should be returned when a file does not exist\"\n           (fact (file-exists \"no-file\") => false)\n           (fact (file-exists \"missing-file\") => false))\n    ```", "```java\n    (facts \"Empty vector should be returned when there is no orders file\"\n           (fact (load-orders \"/tmp/data.edn\") => [])\n           (fact (load-orders \"/tmp/no-data.edn\") => []))\n    ```", "```java\n     (ns coffee-app.utils-test-check\n        (:require [coffee-app.utils :refer :all]\n          [clojure.test.check :as tc]\n          [clojure.test.check.generators :as gen]\n          [clojure.test.check.properties :as prop]\n          [clojure.test.check.clojure-test :refer [defspec]]))\n    ```", "```java\n    (defspec display-order-test-check 1000\n             (prop/for-all [order (gen/fmap (fn [[number type price]]\n                                                {:number number\n                                                 :type type\n                                                 :price price})\n                                            (gen/tuple (gen/large-integer* {:min                                           0})\n                                                       gen/keyword\n                                                       (gen/double* {:min 0.1 :max 999 :infinite? false :NaN? false} )))]\n                           (= (str \"Bought \" (:number order) \" cups of \" (name (:type order)) \" for €\" (:price order)) (display-order order))))\n    ```", "```java\n    (defspec file-exists-test-check 1000\n             (prop/for-all [file gen/string-alphanumeric]\n                           (false? (file-exists file))))\n    ```", "```java\n    (defspec load-orders-test-check 1000\n             (prop/for-all [file gen/string-alphanumeric]\n                           (vector? (load-orders file))))\n    ```", "```java\n    :dependencies [[org.clojure/test.check \"0.10.0\"]]\n    ```", "```java\n    (ns support-desk.core-test\n      (:require\n        [cljs.test :refer-macros [are deftest is testing use-fixtures]]\n        [clojure.test.check.generators :as gen]\n        [clojure.test.check.properties :refer-macros [for-all]]\n        [clojure.test.check.clojure-test :refer-macros [defspec]]\n        [cuerdas.core :as str]\n        [support-desk.utils :refer [delete-item-from-list-by-title get-priorities-list get-sort-message get-sorted-priorities-list handle-sort-finish]]))\n    ```", "```java\n    (ns support-desk.core-test)\n    (use-fixtures :each\n                  {:before (fn [] (do\n                                    (def priorities-list [{:title \"IE bugs\" :priority 2} {:title \"404 page\" :priority 1} {:title \"Forgotten username\" :priority 2}\n                                                          {:title \"Login token\" :priority 1} {:title \"Mobile version\" :priority 3} {:title \"Load time\" :priority 5}])\n                                    (def app-state (atom {:sort-counter 0}))))})\n    ```", "```java\n    (deftest get-sort-message-test\n             (testing \"Using is macro\"\n                      (is (= \"little (1)\" (get-sort-message 1)))\n                      (is (= \"medium (4)\" (get-sort-message 4)))\n                      (is (= \"many (8)\" (get-sort-message 8))))\n             (testing \"Using are macro\"\n                      (are [result number] (= result (get-sort-message number))\n                           \"little (1)\" 1\n                           \"little (2)\" 2\n                           \"medium (3)\" 3\n                           \"medium (4)\" 4\n                           \"medium (5)\" 5\n                           \"many (6)\" 6)))\n    ```", "```java\n    (defspec get-sort-message-test-check 10\n             (for-all [count gen/nat]\n                      (= (str/format \"%s (%s)\"\n                                     (cond\n                                       (< count 3) \"little\"\n                                       (< count 6) \"medium\"\n                                       :else \"many\")\n                                     count)\n                         (get-sort-message count))))\n    ```", "```java\n    (deftest get-priorities-list-test\n             (testing \"Testing filtering priorities based on priority number\"\n                      (is (= []\n                             (get-priorities-list priorities-list 0)))\n                      (is (= [{:title \"404 page\", :priority 1} {:title \"Login token\",                     :priority 1}]\n                             (get-priorities-list priorities-list 1)))\n                      (is (= [{:title \"IE bugs\", :priority 2}\n                              {:title \"404 page\", :priority 1}\n                              {:title \"Forgotten username\", :priority 2}\n                              {:title \"Login token\", :priority 1}]\n                             (get-priorities-list priorities-list 2)))\n                      (is (=\n                            [{:title \"IE bugs\", :priority 2}\n                             {:title \"404 page\", :priority 1}\n                             {:title \"Forgotten username\", :priority 2}\n                             {:title \"Login token\", :priority 1}\n                             {:title \"Mobile version\", :priority 3}]\n                            (get-priorities-list priorities-list 3)))))\n    ```", "```java\n    (deftest get-sorted-priorities-list-test\n             (testing \"Sorting priorities list\"\n                      (is (= [{:title \"404 page\", :priority 1}\n                              {:title \"Login token\", :priority 1}\n                              {:title \"IE bugs\", :priority 2}\n                              {:title \"Forgotten username\", :priority 2}\n                              {:title \"Mobile version\", :priority 3}\n                              {:title \"Load time\", :priority 5}]\n                             (get-sorted-priorities-list priorities-list)))))\n    ```", "```java\n    (deftest delete-item-from-list-by-title-test\n             (testing \"Passing empty list\"\n                      (is (= []\n                             (delete-item-from-list-by-title \"Login token\" [])))\n                      (is (= []\n                            (delete-item-from-list-by-title \"Login token\" nil))))\n             (testing \"Passing valid list\"\n                      (is (= (delete-item-from-list-by-title \"Login token\"                     priorities-list)))))\n    ```", "```java\n    (deftest handle-sort-finish-test\n             (testing \"Calling fn once\"\n                      (is (= {:sort-counter 1}\n                             ((handle-sort-finish app-state) \"event\"                            \"object\"))))\n             (testing \"Calling fn twice\"\n                      (is (= {:sort-counter 2}\n                            ((handle-sort-finish app-state) \"event\"                            \"object\")))))\n    ```", "```java\n    lein fig:test\n    ```", "```java\n    (with-open [reader (io/reader csv)]\n      (->> (csv/read-csv reader)\n           sc/mappify\n           (sc/cast-with {:winner_games_won sc/->int\n                          :loser_games_won sc/->int})\n           (map #(assoc % :games_diff (- (:winner_games_won %) (:loser_games_won %))))\n           (filter #(> (:games_diff %) threshold))\n           (map #(select-keys % [:winner_name :loser_name :games_diff]))\n           doall))\n    ```", "```java\n    {:deps\n     {org.clojure/data.csv {:mvn/version \"0.1.4\"}\n      semantic-csv {:mvn/version \"0.2.1-alpha1\"}\n      org.clojure/math.numeric-tower {:mvn/version \"0.0.4\"}}}\n    ```", "```java\n    (ns packt-clj.tennis-macro\n        (:require [clojure.java.io :as io]\n                  [clojure.data.csv :as csv]\n                  [semantic-csv.core :as sc]))\n    ```", "```java\n    (defmacro with-tennis-csv [csv casts fields & forms])\n    ```", "```java\n    (defmacro with-tennis-csv [csv casts fields & forms]\n      '(with-open [reader# (io/reader ~csv)]\n         (->> (csv/read-csv reader#)\n              sc/mappify\n              (sc/cast-with ~casts)\n              ;; TODO: what goes here?\n              doall)))\n    ```", "```java\n    (defmacro with-tennis-csv [csv casts fields & forms]\n      '(with-open [reader# (io/reader ~csv)]\n         (->> (csv/read-csv reader#)\n              sc/mappify\n              (sc/cast-with ~casts)\n              ~@forms\n              ;; TODO: select-keys\n              doall)))\n    ```", "```java\n    (defn maybe-select-keys [m maybe-keys]\n      (if (seq maybe-keys)\n        (select-keys m maybe-keys)\n        m))\n    ```", "```java\n     (defmacro with-tennis-csv [csv casts fields & forms]\n      '(with-open [reader# (io/reader ~csv)]\n         (->> (csv/read-csv reader#)\n              sc/mappify\n              (sc/cast-with ~casts)\n              ~@forms\n              (map #(maybe-select-keys % ~fields))\n              doall)))\n    ```", "```java\n      (let [fields# ~fields]\n        )\n    ```", "```java\n    user> (blowouts \"match_scores_1991-2016_unindexed_csv.csv\" 16)\n    ({:winner_name \"Jean-Philippe Fleurian\",\n      :loser_name \"Renzo Furlan\",\n      :games_diff 17}\n     {:winner_name \"Todd Witsken\",\n      :loser_name \"Kelly Jones\",\n      :games_diff 17}\n     {:winner_name \"Nicklas Kulti\",\n      :loser_name \"German Lopez\",\n      :games_diff 17}\n     {:winner_name \"Jim Courier\",\n      :loser_name \"Gilad Bloom\",\n      :games_diff 16}\n     {:winner_name \"Andrei Medvedev\",\n      :loser_name \"Lars Koslowski\",\n      :games_diff 17}\n    ;;; etc.\n    )\n    ```", "```java\n    user> (with-tennis-csv \"match_scores_1991-2016_unindexed_csv.csv\"\n       {}\n       [:winner_name]\n       (filter #(= \"Roger Federer\" (:loser_name %))))\n    ({:winner_name \"Lucas Arnold Ker\"}\n     {:winner_name \"Jan Siemerink\"}\n     {:winner_name \"Andre Agassi\"}\n     {:winner_name \"Arnaud Clement\"}\n     {:winner_name \"Yevgeny Kafelnikov\"}\n     {:winner_name \"Kenneth Carlsen\"}\n     {:winner_name \"Vincent Spadea\"}\n     {:winner_name \"Patrick Rafter\"}\n     {:winner_name \"Byron Black\"}\n     ;; .... etc.\n     )\n    ```", "```java\n(filter #(> (:games_diff %) threshold))\n```", "```java\n(fn [ms] (filter #(> (:games_diff %)) threshold))\n```", "```java\n    lein new figwheel packt-clj.dom-whackamole -- --rum\n    ```", "```java\n    lein figwheel\n    ```", "```java\n    (def game-length-in-seconds 20)\n    (def millis-remaining (atom (* game-length-in-seconds 1000)))\n    (def points (atom 0))\n    (def game-state (atom :waiting))\n    (def clock-interval (atom nil))\n    (def moles (atom (into []\n                (repeat 5 {:status :waiting\n                     :remaining-millis 0}))))\n    ```", "```java\n    (def app-state\n     (atom\n      {:points 0\n       :millis-remaining (* game-length-in-seconds 1000)\n       :game-state :waiting\n       :clock-interval nil\n       :moles (into []\n             (repeat 5 {:status :waiting\n                   :remaining-millis 0}))}))\n    ```", "```java\n    (defn activate-mole [mole-idx]\n     (swap! moles\n         (fn [ms]\n          (update ms mole-idx\n              #(if (= :waiting (:status %))\n               {:status :live :remaining-millis 3000}\n               %)))))\n    (defn deactivate-mole [mole-idx]\n     (swap! moles\n         (fn [ms]\n          (assoc ms mole-idx\n              {:status :waiting :remaining-millis 0}))))\n    ```", "```java\n    core.cljs\n    43 (defn mole-countdown []\n    44  (swap! moles\n    45      (fn [ms]\n    46       (into []\n    47          (map (fn [m]\n    48             (if (= (:status m) :live)\n    49              (let [new-remaining (max (- (:remaining-millis m) 100)                   0)]\n    50               (if (pos? new-remaining)\n    51                (assoc m :remaining-millis new-remaining)\n    52                {:status :waiting :remaining-millis 0}))\n    53              m))\n    54            ms)))))\n    The full code for this step is available at https://packt.live/2Rmq8aq.\n    ```", "```java\n    (defn clock-tick []\n     (if (= @millis-remaining 0)\n      (do\n       (reset! game-state :waiting)\n       (reset-moles))\n      (do\n       (update-moles)\n       (swap! millis-remaining #(- % 100)))))\n    (defn start-clock []\n     (when @clock-interval\n      (js/clearInterval @clock-interval))\n     (swap! clock-interval\n         (fn [] (js/setInterval clock-tick 100))))\n    ```", "```java\n    (defn start-game []\n     (start-clock)\n     (reset! game-state :playing)\n     (reset! points 0)\n     (reset! millis-remaining (* game-length-in-seconds 1000)))\n    ```", "```java\n    (rum/defc clock < rum/reactive []\n     [:div.clock\n      [:span \"Remaining time: \"]\n      [:span.time\n      (Math/floor (/ (rum/react millis-remaining) 1000))]])\n    (rum/defc score < rum/reactive []\n     [:div.score\n      [:span \"Score: \"]\n      [:span (rum/react points)]])\n    ```", "```java\n    (rum/defc start-game-button < rum/reactive []\n     (if (= (rum/react game-state) :waiting)\n      [:button\n       {:onClick start-game}\n       \"Click to play!\"]\n      [:div \"Game on!\"]))\n    ```", "```java\n    (rum/defc single-mole-view [mole-idx {:keys [status remaining-millis]}]\n     [:div {:class [(str \"mole \" (name status))]}\n      [:a {:onClick (partial whack! mole-idx)}\n      (str \"MOLE \" (name status) \"!\")]])\n    (rum/defc moles-view < rum/reactive []\n     (let [ms (rum/react moles)]\n      [:div {:class \"game moles\"}\n       (single-mole-view 0 (first ms))\n       (single-mole-view 1 (second ms))\n       (single-mole-view 2 (nth ms 2))\n       (single-mole-view 3 (nth ms 3))\n       (single-mole-view 4 (nth ms 4))]))\n    ```", "```java\n    (rum/defc app []\n     [:div#main\n      [:div.header\n      [:h1 \"Welcome to DOM Whack-a-mole\"]\n      [:p \"When a MOLE goes goes 'live', click on it as fast as you can.\"]\n      (start-game-button)\n      (clock)\n      (score)]\n      (moles-view)])\n    ```", "```java\n    (defn on-js-reload []\n     (rum/mount (app) (.getElementById js/document \"app\")))\n    (on-js-reload)\n    ```", "```java\n    {:deps {clojure.java-time {:mvn/version \"0.3.2\"}\n            hikari-cp {:mvn/version \"2.8.0\"}\n            org.apache.derby/derby {:mvn/version \"10.14.2.0\"}\n            org.clojure/data.csv {:mvn/version \"0.1.4\"}\n            org.clojure/java.jdbc {:mvn/version \"0.7.9\"}\n            semantic-csv {:mvn/version \"0.2.1-alpha1\"}}}\n    ```", "```java\n    packt-clj.tennis.database\n    packt-clj.tennis.elo\n    packt-clj.tennis.ingest\n    packt-clj.tennis.parse\n    packt-clj.tennis.query\n    ```", "```java\n    (ns packt-clj.tennis.database\n      (:require\n        [hikari-cp.core :as hikari]))\n    (def db {:datasource (hikari/make-datasource {:jdbc-url \"jdbc:derby:tennis;create=true\"})})\n    ```", "```java\n    (def ^:private create-player-ddl \"CREATE TABLE player (\n      id varchar(4) CONSTRAINT PLAYER_ID_PK PRIMARY KEY,\n      full_name varchar(128))\")\n    (def ^:private create-tennis-match-ddl \"CREATE TABLE tennis_match (\n      id varchar(32) CONSTRAINT MATCH_ID_PK PRIMARY KEY,\n      tournament_year int,\n      tournament varchar(32),\n      tournament_order int,\n      round_order int,\n      match_order int,\n      winner_id varchar(4) REFERENCES player(id) ON DELETE CASCADE,\n      loser_id varchar(4) REFERENCES player(id) ON DELETE CASCADE)\")\n    (def ^:private create-elo-ddl \"CREATE TABLE elo (\n      id int GENERATED ALWAYS AS IDENTITY CONSTRAINT ELO_ID_PK PRIMARY KEY,\n      player_id varchar(4) REFERENCES player(id) ON DELETE CASCADE,\n      rating DECIMAL(6,2))\")\n    ```", "```java\n    (ns packt-clj.tennis.database\n      (:require\n        [clojure.java.jdbc :as jdbc]\n        [hikari-cp.core :as hikari]))\n    (defn load []\n      (jdbc/db-do-commands db [create-player-ddl create-tennis-match-ddl create-elo-ddl]))\n    (require '[packt-clj.tennis.database :as database])\n    user=> (database/load)\n    (0 0 0)\n    ```", "```java\n    (ns packt-clj.tennis.parse\n      (:require\n        [clojure.string :as str]))\n    (def ^:private winning-player-accessors\n      {:id        :winner_player_id\n       :full_name :winner_name})\n    (def ^:private losing-player-accessors\n      {:id        :loser_player_id\n       :full_name :loser_name})\n    (def ^:private match-accessors\n      {:id               #(str (:match_id %) \"-\" (:round_order %))\n       :tournament_year  (comp first #(str/split % #\"-\") :tourney_year_id)\n       :tournament       :tourney_slug\n       :tournament_order :tourney_order\n       :round_order      :round_order\n       :match_order      :match_order\n       :winner_id        :winner_player_id\n       :loser_id         :loser_player_id})\n    ```", "```java\n    (defn apply-accessors\n      [row accessors]\n      (reduce-kv\n        (fn [acc target-key accessor]\n          (assoc acc target-key (accessor row)))\n        {}\n        accessors))\n    ```", "```java\n    (defn extract-winning-player\n      [row]\n      (apply-accessors row winning-player-accessors))\n    (defn extract-losing-player\n      [row]\n      (apply-accessors row losing-player-accessors))\n    (defn extract-match\n      [row]\n      (apply-accessors row match-accessors))\n    (defn parse-row\n      [row]\n      {:winning-player (extract-winning-player row)\n       :losing-player  (extract-losing-player row)\n       :match          (extract-match row)})\n    ```", "```java\n    (ns packt-clj.tennis.parse\n      (:require\n        [clojure.data.csv :as csv]\n        [clojure.java.io :as io]\n        [clojure.string :as str]\n        [semantic-csv.core :as sc]))\n    (defn new-player?\n      [seen candidate]\n      (not (seen (:id candidate))))\n    (defn historic\n      [file-path]\n      (->> (io/reader file-path)\n           (csv/read-csv)\n           sc/mappify\n           (reduce (fn\n                     [{:keys [player-ids-seen] :as acc} row]\n                     (let [{:keys [winning-player losing-player match]} (parse-row row)\n                           new-players (filter #(new-player? player-ids-seen %) [winning-player losing-player])]\n                       (-> acc\n                           (update-in [:data :players] into new-players)\n                           update-in [:data :matches] conj match)\n                           (update :player-ids-seen into (map :id new-players)))))\n                   {:player-ids-seen #{}\n                    :data            {:players []\n                                      :matches []}})\n           :data))\n    ```", "```java\n    (ns packt-clj.tennis.ingest\n      (:require\n        [packt-clj.tennis.parse :as parse]\n        [clojure.java.jdbc :as jdbc]))\n    (defn historic\n      [db file-path]\n      (let [{:keys [players matches]} (parse/historic file-path)]\n        (jdbc/insert-multi! db :player players)\n        (jdbc/insert-multi! db :tennis_match matches)))\n    ```", "```java\n    (require '[packt-clj.tennis.ingest :as ingest]\n             '[clojure.java.jdbc :as jdbc]\n             '[clojure.java.io :as io]\n               '[packt-clj.tennis.database :as database])\n    user=> (ingest/historic database/db (io/file \"packt-clj/resources/match_scores_1991-2016_unindexed_csv.csv\"))\n    user=> (jdbc/query database/db [\"select count(*) from player\"])\n    => ({:1 3483})\n    user=> (jdbc/query database/db [\"select count(*) from tennis_match\"])\n    => ({:1 95359})\n    ```", "```java\n    (ns packt-clj.tennis.query\n      (:require\n        [clojure.java.jdbc :as jdbc]))\n    (defn all-tennis-matches\n      [db]\n      (jdbc/query db [\"select *\n                   from tennis_match\n                       order by tournament_year, tournament_order, round_order desc, match_order\"]))\n    ```", "```java\n    (ns packt-clj.tennis.elo\n      (:require\n        [clojure.java.jdbc :as jdbc]\n        [packt-clj.tennis.query :as query]))=\n    (def k-factor 32)\n    (defn match-probability [player-1-rating player-2-rating]\n      (/ 1\n         (+ 1 (Math/pow 10 (/ (- player-2-rating player-1-rating) 1000)))))\n    (defn recalculate-rating [previous-rating expected-outcome real-outcome]\n      (+ previous-rating (* k-factor (- real-outcome expected-outcome))))\n    ```", "```java\n    (defn- expected-outcomes\n      [winner-rating loser-rating]\n      (let [winner-expected-outcome (match-probability winner-rating loser-rating)]\n        [winner-expected-outcome (- 1 winner-expected-outcome)]))\n    ```", "```java\n    (defn- calculate-new-ratings [current-player-ratings {:keys [winner_id loser_id]}]\n      (let [winner-rating (get current-player-ratings winner_id 1000)\n            loser-rating  (get current-player-ratings loser_id 1000)\n            [winner-expected-outcome loser-expected-outcome] (expected-outcomes winner-rating loser-rating)]\n        [{:player_id winner_id\n          :rating    (recalculate-rating winner-rating winner-expected-outcome 1)}\n         {:player_id loser_id\n          :rating    (recalculate-rating loser-rating loser-expected-outcome 0)}]))\n    ```", "```java\n    (defn calculate-all\n      [db]\n      (->> (query/all-tennis-matches db)\n           (reduce\n             (fn [{:keys [current-player-ratings] :as acc} match]\n               (let [[{winner-id :player_id :as new-winner-rating} {loser-id :player_id :as new-loser-rating}] (calculate-new-ratings current-player-ratings match)]\n                 (-> acc\n                     (update :elo-ratings into [new-winner-rating\n                                                new-loser-rating])\n                     (assoc-in [:current-player-ratings winner-id] (:rating new-winner-rating))\n                     (assoc-in [:current-player-ratings loser-id] (:rating new-loser-rating)))))\n             {:elo-ratings            []\n              :current-player-ratings {}})\n           :elo-ratings))\n    ```", "```java\n    (defn persist-all\n      [db]\n      (let [elo-ratings (calculate-all db)]\n        (jdbc/insert-multi! db :elo elo-ratings)))\n    user=>(require '[packt-clj.tennis.elo :as elo]\n                   '[packt-clj.tennis.query :as query])\n    nil\n    user=> (elo/persist-all database/db)\n    ```", "```java\n    (defn select-max-elo\n      [db]\n      (jdbc/query db [\"select p.full_name, e.rating\n                       from player p, elo e\n                       where p.id = e.player_id\"]\n                  {:result-set-fn (fn [rs]\n                                    (reduce (fn [{:keys [max-rating] :as acc} {:keys                                   [full_name rating]}]\n                                              (cond-> acc\n                                                      (< max-rating rating) (assoc                                                     :max-rating rating\n                                                        :player-name full_name)))\n                                            {:max-rating Integer/MIN_VALUE\n                                             :player-name nil}\n                                            rs))}))\n    ```", "```java\n    user => (query/select-max-elo database/db)\n    => {:max-rating 2974.61M, :player-name \"Novak Djokovic\"}\n    ```", "```java\n    {:deps {..\n            clj-http {:mvn/version \"3.10.0\"}\n            compojure {:mvn/version \"1.6.1\"}\n            metosin/muuntaja {:mvn/version \"0.6.4\"}\n            org.clojure/data.json {:mvn/version \"0.2.6\"}\n            ring/ring-core {:mvn/version \"1.7.1\"}\n            ring/ring-jetty-adapter {:mvn/version \"1.7.1\"}}\n    ```", "```java\n    (ns packt-clj.tennis.api\n      (:require\n        [clojure.edn :as edn]\n        [compojure.core :refer [context defroutes GET PUT]]\n        [compojure.route :as route]\n        [muuntaja.middleware :as middleware]\n        [packt-clj.tennis.database :as database]\n        [packt-clj.tennis.elo :as elo]\n        [packt-clj.fitness.ingest :as ingest]\n        [packt-clj.tennis.query :as query]\n        [ring.adapter.jetty :refer [run-jetty]]\n        [ring.middleware.params :as params]))\n    ```", "```java\n    (defroutes routes\n               (context \"/players\" []\n                 (GET \"/\" []\n                   {:body (query/all-players database/db)})\n                 (GET \"/:id\" [id]\n                   (when-first [user (query/player database/db id)]\n                     {:body user}))\n                 (GET \"/:id/tennis-matches\" [id]\n                   {:body (query/tennis-matches-by-player database/db id)}))\n               (route/not-found \"Not found\"))\n    ```", "```java\n    (defn all-players\n      [db]\n      (jdbc/query db [\"select * from player\"]))\n    (defn player\n      [db id]\n      (jdbc/query db [(str \"select * from player where id = '\" id \"'\")]))\n    (defn tennis-matches-by-player\n      [db id]\n      (jdbc/query db [(str \"select * from tennis_match\n                       where winner_id = '\" id \"' or loser_id = '\" id \"'\")]))\n    ```", "```java\n    (defn run\n      []\n      (run-jetty\n        (-> routes\n            middleware/wrap-format\n            params/wrap-params)\n        {:port  8080\n         :join? false}))\n    ```", "```java\n    (GET \"/:id/elo\" [id]\n                   (when-first [elo (query/player-elo database/db id)]\n                     {:body elo}))\n    (defn player-elo\n      [db id]\n      (jdbc/query db [(str \"select e.rating, e.id\n                            from elo e, player p\n                            where e.player_id = p.id and\n                            p.id = '\" id \"' and\n                            e.id in (select max(e2.id)\n                                     from elo e2\n                                     where e2.player_id = '\" id \"')\")]))\n    ```", "```java\n    (context \"/tennis-matches\" []\n                 (GET \"/\" []\n                   {:body (query/all-tennis-matches database/db)})\n                 (GET \"/:id\" [id]\n                   (when-first [tennis-match (query/tennis-match database/db id)]\n                     {:body tennis-match})))\n    (defn tennis-match\n      [db id]\n      (jdbc/query db [(str \"select * from tennis_match where id = '\" id \"'\")]))\n    ```", "```java\n    (require '[packt-clj.tennis.database :as database]\n             '[packt-clj.tennis.ingest :as ingest]\n             '[packt-clj.tennis.elo :as elo])\n    (database/load)\n    (ingest/historic database/db \"./resources/match_scores_1991-2016_unindexed_csv.csv\")\n    (elo/persist-all database/db) \n    ```", "```java\n    (require '[packt-clj.tennis.api :as api])\n    (def app (api/run))\n    ```", "```java\n    (defn tennis-match\n      [db tennis-match]\n      (first (jdbc/insert! db :tennis_match tennis-match)))\n    (defn persist\n     [db elo-ratings]\n     (jdbc/insert-multi! db :elo elo-ratings))\n    (PUT \"/:id\" req\n                   (let [id (-> req :params :id)\n                         {:keys [winner_id loser_id] :as tennis-match} (assoc (edn/read-string (slurp (:body req)))\n                                                                         :id id)\n                         [{winner-elo :rating}] (query/player-elo database/db                        winner_id)\n                         [{loser-elo :rating}] (query/player-elo database/db                        loser_id)\n                         new-player-ratings (elo/clj-http to submit a PUT instruction to our web service as follows:\n\n    ```", "```java\n\n    ```", "```java\n    lein new figwheel packt-clj.images -- --reagent\n    ```", "```java\n    lein figwheel\n    ```", "```java\n    (ns packt-clj.images.core\n        (:require [reagent.core :as r]))\n    ```", "```java\n    (defonce app-state (r/atom {:images []\n                                           :author-display true}))\n    ```", "```java\n    (defn fetch-images []\n     (-> (js/fetch \"https://picsum.photos/v2/list?limit=6\")\n           (. then (fn [response] (.json response)))\n          (. then (fn [json] (swap! app-state assoc-in [:images] (js->clj json :keywordize-keys true))))))\n    (defn clear-images []\n         (swap! app-state assoc-in [:images] []))\n    ```", "```java\n    (defn fetch-or-clear-button []\n      (let [handler (if (empty? (:images @app-state)) fetch-images clear-images)\n               text    (if (empty? (:images @app-state)) \"Fetch Images\" \"Clear Images\")]\n         [:button.btn {:on-click handler} text]))\n    ```", "```java\n    .btn {\n      padding: 7px 20px;\n      cursor: pointer;\n      margin-left: 10px;\n      margin-bottom: 10px;\n      border: 1px solid gray;\n    }\n    ```", "```java\n    (defn image [{:keys [download_url author]}]\n      [:div\n       [:img {:src download_url\n                   :height \"130px\"\n                   :style {:border \"solid gray 3px\"\n                               :border-radius \"10px\"}}]\n       (when (:author-display @app-state)\n          [:div {:style {:font-size \"15px\"\n                                  :color \"gray\" }}\n            (str \"Image by \") author])])\n    (defn image-grid [images]\n       (if (empty? images)\n          [:div \"Click the button to fetch images\"]\n          (into [:div] (map (fn [image-data] [:div {:style {:float \"left\"\n                                              :margin-left \"20px\"}}\n     [image image-data]])\n                                         images))))\n    ```", "```java\n    (defn author-display-button []\n      (let [text (if (:author-display @app-state)\n                     \"Hide author\"\n                     \"Show author\")]\n      [:button.btn {:on-click #(swap! app-state update-in [:author-display] not)}\n               text]))\n    ```", "```java\n    (defn app []\n      [:div\n       [fetch-or-clear-button]\n       [author-display-button]\n       [image-grid (:images @app-state)]])\n    ```", "```java\n    (r/render-component [app] (. js/document (getElementById \"app\")))\n    ```", "```java\n    lein new figwheel packt-clj.tennis -- --reagent\n    ```", "```java\n    lein figwheel\n    ```", "```java\n    (ns packt-clj.tennis.core\n        (:require [reagent.core :as r]))\n    ```", "```java\n    (defonce app-state (r/atom {:players []\n                                :current-player nil}))\n    ```", "```java\n    (defn fetch-player [id full_name]\n      (-> (js/fetch (str \"http://localhost:8080/players/\" id \"/elo\"))\n          (.then (fn [response] (.json response)))\n          (.then (fn [json] (swap! app-state assoc-in [:current-player] (assoc (js->clj json :keywordize-keys true)\n                                                                              :full_name full_name))))))\n    ```", "```java\n    (defn player-alone [{:keys [rating full_name]}]\n      [:div\n       (str full_name \" has a rating of: \" rating)])\n    ```", "```java\n    (defn player-list-button []\n      [:button.btn {:on-click #(swap! app-state assoc-in [:current-player] nil)} \"Display all players\"])\n    ```", "```java\n    (defn player [{:keys [id full_name]}]\n      [:div [:span\n             [:a\n              {:href \"#\"\n               :on-click (partial fetch-player id full_name)}\n              full_name]]])\n    ```", "```java\n    (defn player-list [players]\n      (if (empty? players)\n        [:div \"Click the button to fetch players\"]\n        (into [:div] (map player players))))\n    ```", "```java\n    (defn fetch-players []\n      (-> (js/fetch \"http://localhost:8080/players/\")\n          (.then (fn [response] (.json response)))\n          (.then (fn [json] (swap! app-state assoc-in [:players] (js->clj json         :keywordize-keys true))))))\n    ```", "```java\n    (defn clear-players []\n      (swap! app-state assoc-in [:players] []))\n    ```", "```java\n    (defn fetch-or-clear-button []\n      (let [handler (if (empty? (:players @app-state)) fetch-players clear-players)\n            text    (if (empty? (:players @app-state)) \"Fetch Players\" \"Clear Players\")]\n        [:button.btn {:on-click handler} text]))\n    ```", "```java\n    (defn app []\n      (if (:current-player @app-state)\n        [:div\n         [player-list-button]\n         [player-alone (:current-player @app-state)]]\n        [:div\n         [fetch-or-clear-button]\n         [player-list (:players @app-state)]]))\n    ```", "```java\n    (r/render-component [app] (. js/document (getElementById \"app\")))\n    ```"]