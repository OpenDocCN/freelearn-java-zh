- en: Wiring Beans using the Dependency Injection Pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, you learned about the **Gang of Four** (**GOF**) design
    patterns with examples and use cases of each. Now, we will go into more detail
    about injecting beans and the configuration of dependencies in a Spring application,
    where you will see the various ways of configuring dependencies in a Spring application.
    This includes configuration with XML, Annotation, Java, and Mix.
  prefs: []
  type: TYPE_NORMAL
- en: Everyone loves movies, right? Well, if not movies, how about plays, or dramas,
    or theatre? Ever wondered what would happen if the different team members didn't
    speak to each other? By team I don't just mean the actors, but the sets team,
    make-up personnel, audio-visual guys, sound system guys, and so on. It is needless
    to say that every member has an important contribution towards the end product,
    and an immense amount of coordination is required between these teams.
  prefs: []
  type: TYPE_NORMAL
- en: A blockbuster movie is a product of hundreds of people working together toward
    a common goal. Similarly, great software is an application where several objects
    work together to meet some business target. As a team, every object must be aware
    of the other, and communicate with each other to get their jobs done.
  prefs: []
  type: TYPE_NORMAL
- en: In a banking system, the money transfer service must be aware of the account
    service, and the account service must be aware of the accounts repository, and
    so on. All these components work together to make the banking system workable.
    In [Chapter 1](18f63847-961b-45a2-bef0-30602dcabed3.xhtml), *Getting Started with
    Framework 5.0 and Design Patterns*, you saw the same banking example created with
    the traditional approach, that is, creating objects using construction and direct
    object initiation. This traditional approach leads to complicated code, is difficult
    to reuse and unit test, and is also highly coupled to one another.
  prefs: []
  type: TYPE_NORMAL
- en: But in Spring, objects have a responsibility to do their jobs without the need
    to find and create the other dependent objects that are required in their jobs.
    The Spring container takes the responsibility to find or create the other dependent
    objects, and to collaborate with their dependencies. In the previous example of
    the banking system, the transfer service depends on the account service, but it
    doesn't have to create the account service, so the dependency is created by the
    container, and is handed over to the dependent objects in the application.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will discuss the behind-the-scenes story of the Spring-based
    application with reference to the **dependency injection** (**DI**) pattern, and
    how it works. By the end of this chapter, you will understand how the objects
    of your Spring-based application create associations between them, and how Spring
    wires these objects for a job done. You will also learn many ways to wire beans
    in Spring.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: The dependency injection pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Types of dependency injection patterns
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Resolving dependency using the Abstract Factory pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Lookup-method injection pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuring beans using the Factory pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuring dependencies
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Common best practices for configuring dependencies in an application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The dependency injection pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In any enterprise application, coordination between the working objects is very
    important for a business goal. The relationship between objects in an application
    represents the dependency of an object, so each object would get the job done
    with coordination of the dependent objects in the application. Such required dependencies
    between the objects tend to be complicated and with tight-coupled programming
    in the application. Spring provides a solution to the tight-coupling code of an
    application by using the dependency injection pattern. Dependency injection is
    a design pattern, which promotes the loosely coupled classes in the application.
    This means that the classes in the system depend on the behavior of others, and
    do not depend on instantiation of object of the classes. The dependency injection
    pattern also promotes programming to interface instead of programming to implementation.
    Object dependencies should be on an interface, and not on concrete classes, because
    a loosely coupled structure offers you greater reusability, maintainability, and
    testability.
  prefs: []
  type: TYPE_NORMAL
- en: Solving problems using the dependencies injection pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In any enterprise application, a common problem to handle is how to configure
    and wire together the different elements to achieve a business goal--for example,
    how to bind together the controllers at the web layer with the services and repository
    interfaces written by different members of the team without knowing about the
    controllers of the web layers. So, there are a number frameworks that provide
    a solution for this problem by using lightweight containers to assemble the components
    from different layers. Examples of such types of frameworks are PicoContainer
    and Spring Framework.
  prefs: []
  type: TYPE_NORMAL
- en: The containers of PicoContainer and Spring use a number of design patterns to
    solve the problem of assembling the different components of different layers.
    Here, I am going to discuss one of these design patterns--the dependency injection
    pattern. Dependency injection provides us with a decoupled and loosely coupled
    system. It ensures construction of the dependent object. In the following example,
    we'll demonstrate how the dependency injection pattern solves the common problems
    related to collaboration between the various layered components.
  prefs: []
  type: TYPE_NORMAL
- en: Without dependency injection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the following Java example, first of all, let''s see what is a dependency
    between two classes? Take a look at the following class diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/83147f64-2d22-4553-b1d9-a3fb6118fd9f.png)'
  prefs: []
  type: TYPE_IMG
- en: TransferService has dependencies with AccountRepository and TransferRepository
    for transferAmount() method with Direct Instantiation of repositories classes.
  prefs: []
  type: TYPE_NORMAL
- en: 'As seen in the preceding diagram, the **TransferService** class contains two
    member variables, **AccountRepository** and **TransferRepository.** These are
    initialized by the **TransferService** constructor. **TransferService** controls
    which implementation of the repositories is used. It also controls their construction.
    In this situation, **TransferService** is said to have a hard-coded dependency
    on the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Following is the `TransferServiceImpl.java` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, the `TransferServiceImpl` class has dependencies of
    two classes, that is `AccountRepository` and `TransferRepository`. The `TransferServiceImpl`
    class has two member variables of the dependent classes, and initializes them
    through its constructor by using the JDBC implementation of repositories such
    as `JdbcAccountRepository` and `JdbcTransferRepository`. The `TransferServiceImpl`
    class is tightly coupled with the JDBC implementation of repositories; in case
    the JDBC implementation is changed to a JPA implementation, you have to change
    your `TransferServiceImpl` class as well.
  prefs: []
  type: TYPE_NORMAL
- en: According to the SOLID (Single Responsibility Principle, Open Closed Principle,
    Liskov's Substitution Principle, Interface Segregation Principle, Dependency Inversion
    Principle) principles, a class should have a single responsibility in the application,
    but in the preceding example, the `TransferServiceImpl` class is also responsible
    for constructing the objects of `JdbcAccountRepository` and `JdbcTransferRepository`
    classes. We can't use direction instantiation of objects in the class.
  prefs: []
  type: TYPE_NORMAL
- en: 'In our first attempt to avoid the direct instantiation logic in the `TransferServiceImpl`
    class, we can use a `Factory` class that creates instances of `TransferServiceImpl`.
    According to this idea, `TransferServiceImpl` minimizes the dependency from `AccountRepository`
    and `TransferRepository`--earlier we had a tightly coupled implementation of the
    repositories, but now it refers only to the interface, as shown in the following
    diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e37d550f-2329-49ce-a6f7-d7dfd3f42b95.png)'
  prefs: []
  type: TYPE_IMG
- en: TransferService has dependencies with AccountRepository and TransferRepository
    for transferAmount() method with Factory of repositories classes.
  prefs: []
  type: TYPE_NORMAL
- en: But the `TransferServiceImpl` class is, again, tightly coupled with the implementation
    of the `RepositoryFactory` class. Moreover, this process is not suitable for cases
    where we have more number of dependencies, which increases either the `Factory`
    classes or the complexity of the `Factory` class. The repository classes can also
    have other dependencies.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code uses the `Factory` class to get the `AccountRepository`
    and `TransferRepository` classes:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Following is the `TransferServiceImpl.java` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code example, we have minimized tight coupling, and removed
    direction object instantiation from the `TransferServiceImpl` class, but this
    is not the optimal solution.
  prefs: []
  type: TYPE_NORMAL
- en: With dependency injection pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Factory idea avoids direct instantiation of an object of a class, and we
    also have to create another module that is responsible for wiring the dependencies
    between classes. This module is known as a **dependency injector**, and is based
    on the **Inversion of Control** (**IoC**) pattern. According to the IoC Framework,
    the Container it is responsible for object instantiation, and to resolve the dependencies
    among classes in the application. This module has its own life cycle of construction
    and destruction for the object defined under its scope.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following diagram, we have used the dependency injection pattern to
    resolve the dependencies of the `TransferServiceImpl` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ea8d76c4-43fb-4780-8434-8d772021c8e5.png)'
  prefs: []
  type: TYPE_IMG
- en: Using dependency injection design pattern to resolve dependencies for TransferService.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following example, we have used an interface to resolve the dependencies:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Following is the `TransferServiceImpl.java` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: In the `TransferServiceImpl` class, we passed references of the `AccountRepository`
    and `TransferRepository` interfaces to the constructor. Now the `TransferServiceImpl`
    class is loosely coupled with the implementation repository class (use any flavor,
    either JDBC or JPA implementation of repository interfaces), and the framework
    is responsible for wiring the dependencies with the involved dependent class.
    Loose coupling offers us greater reusability, maintainability, and testability.
  prefs: []
  type: TYPE_NORMAL
- en: The Spring Framework implements the dependency injection pattern to resolve
    dependencies among the classes in a Spring application. Spring DI is based on
    the IoC concept, that is, the Spring Framework has a container where it creates,
    manages, and destructs the objects; it is known as a Spring IoC container. The
    objects lying within the Spring container are known as **Spring beans**. There
    are many ways to wire beans in a Spring application. Let's take a look at the
    three most common approaches for configuring the Spring container.
  prefs: []
  type: TYPE_NORMAL
- en: In the following section, we'll look at the types of the dependency injection
    pattern; you can configure the dependencies by using either one of them.
  prefs: []
  type: TYPE_NORMAL
- en: Types of dependency injection patterns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following are the types of dependency injections that could be injected
    into your application:'
  prefs: []
  type: TYPE_NORMAL
- en: Constructor-based dependency injection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setter-based dependency injection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Constructor-based dependency injection pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Dependency injection is a design pattern to resolve the dependencies of dependent
    classes, and dependencies are nothing but object attributes. The injector has
    to be constructed for the dependent objects by using one of the ways constructor
    injection or setter injection. A constructor injection is one of the ways of fulfilling
    these object attributes at the time of creation to instantiate the object. An
    object has a public constructor that takes dependent classes as constructor arguments
    to inject the dependencies. You can declare more than one constructor into the
    dependent class. Earlier, only the PicoContainer Framework is used a constructor-based
    dependency injection to resolve dependencies. Currently, the Spring Framework
    also supports constructor injections to resolve dependencies.
  prefs: []
  type: TYPE_NORMAL
- en: '**Advantages of the constructor injection pattern**'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are the advantages if you use a constructor injection in your
    Spring application:'
  prefs: []
  type: TYPE_NORMAL
- en: Constructor-based dependency injection is more suitable for mandatory dependencies,
    and it makes a strong dependency contract
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Constructor-based dependency injection provides a more compact code structure
    than others
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It supports testing by using the dependencies passed as constructor arguments
    to the dependent class
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It favors the use of immutable objects, and does not break the information hiding
    principle
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Disadvantages of constructor injection pattern**'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is the only drawback of this constructor-based injection pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: It may cause circular dependency. (Circular dependency means that the dependent
    and the dependency class are also dependents on each other, for example, class
    A depends on Class B and Class B depends on Class A)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Example of constructor-based dependency injection** **pattern**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see the following example for constructor-based dependency injection.
    In the following code, we have a `TransferServiceImpl` class, and its constructor
    takes two arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The repositories will also be managed by the Spring container, and, as such,
    will have the `datasource` object for database configuration injected into them
    by the container, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Following is the `JdbcAccountRepository.java` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Following is the `JdbcTransferRepository.java` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: You can see in the preceding code the JDBC implementation of the repositories
    as `AccountRepository` and `TransferRepository`. These classes also have one argument
    constructor to inject the dependency with the `DataSource` class.
  prefs: []
  type: TYPE_NORMAL
- en: Let's see another way of implementing a dependency injection in the enterprise
    application, which is setter injection.
  prefs: []
  type: TYPE_NORMAL
- en: Setter-based dependency injection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The injector of the container has another way to wire the dependency of the
    dependent object. In setter injection, one of the ways to fulfil these dependencies
    is by providing a setter method in the dependent class. Object has a public setter
    methods that takes dependent classes as method arguments to inject dependencies.
    For setter-based dependency injection, the constructor of the dependent class
    is not required. There are no changes required if you change the dependencies
    of the dependent class. Spring Framework and PicoContainer Framework support setter
    injection to resolve the dependencies.
  prefs: []
  type: TYPE_NORMAL
- en: '**Advantages of setter injection**'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are the advantages if you use the setter injection pattern in
    your Spring application:'
  prefs: []
  type: TYPE_NORMAL
- en: Setter injection is more readable than the constructor injection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setter injection solves the circular dependency problem in the application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setter injection allows costly resources or services to be created as late as
    possible, and only when required
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setter injection does not require the constructor to be changed, but dependencies
    are passed through public properties that are exposed
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Disadvantage of the setter injection**'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are the drawbacks of the setter injection pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: Security is lesser in the setter injection pattern, because it can be overridden
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A setter-based dependency injection does not provide a code structure as compact
    as the constructor injection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Be careful whenever you use setter injection, because it is not a required dependency
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Example of a setter-based dependency injection**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see the following example for setter-based dependency injection. The
    following `TransferServiceImpl` class, has setter methods with one argument of
    the repository type:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Following is the `TransferServiceImpl.java` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Similarly, let''s define a setter for the repositories'' implementations as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Following is the `JdbcAccountRepository.java` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Following is the `JdbcTransferRepository.java` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: You can see in the preceding code the JDBC implementation of the repositories
    as `AccountRepository` and `TransferRepository`. These classes have a setter method
    with one argument to inject the dependency with the `DataSource` class.
  prefs: []
  type: TYPE_NORMAL
- en: '**Constructor versus setter injection and best practices**'
  prefs: []
  type: TYPE_NORMAL
- en: The Spring Framework provides support for both types of dependency injection
    patterns. Both, the constructor and setter injection pattern, assemble the elements
    in the system. The choice between the setter and constructor injections depends
    on your application requirement, and the problem at hand. Let's see the following
    table, which lists some differences between the constructor and setter injections,
    and some best practices to select which one is suitable in your application.
  prefs: []
  type: TYPE_NORMAL
- en: '| **Constructors injection** | **Setter injection** |'
  prefs: []
  type: TYPE_TB
- en: '| A class with constructor takes arguments; it is very compact sometimes, and
    clear to understand what it creates. | Here, the object is constructed, but it
    is not clear whether its attributes are initialized or not. |'
  prefs: []
  type: TYPE_TB
- en: '| This is a better choice when the dependency is mandatory. | This is suitable
    when the dependency is not mandatory. |'
  prefs: []
  type: TYPE_TB
- en: '| It allows you to hide the object attributes that are immutable, because it
    does not have setters for these object attributes. To ensure the immutable nature
    of the object, use the constructor injection pattern instead of the setter injection.
    | It doesn''t ensure the immutable nature of the object. |'
  prefs: []
  type: TYPE_TB
- en: '| It creates circular dependency in your application. | It solves the problem
    of circular dependency in your application. In this case, the setter injection
    is a better choice than constructor. |'
  prefs: []
  type: TYPE_TB
- en: '| It is not suitable for scalar value dependencies in the application. | If
    you have simple parameters such as strings and integers as dependencies, the setter
    injection is better to use, because each setter name indicates what the value
    is supposed to do. |'
  prefs: []
  type: TYPE_TB
- en: In the next section, you'll learn how to configure the injector to find the
    beans and wire them together, and how the injector manages the beans. Here, I
    will use the Spring configuration for the dependency injection pattern.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring the dependency injection pattern with Spring
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, I will explain the process required to configure dependencies
    in an application. The mainstream injectors are Google Guice, Spring, and Weld.
    In this chapter, I am using the Spring Framework, so, we will see the Spring configuration
    here. The following diagram is a high-level view of how Spring works:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a7eab42c-5110-40fe-a583-bd11022f3c74.png)'
  prefs: []
  type: TYPE_IMG
- en: How Spring works using dependency injection pattern
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding diagram, the **Configuration Instruction** is the meta configuration
    of your application. Here, we define the dependencies in **Your Application Classes
    (POJOs)**, and initialize the Spring container to resolve the dependency by combining
    the POJOs and **Configuration Instructions**, and finally, you have a fully configured
    and executable system or application.
  prefs: []
  type: TYPE_NORMAL
- en: As you have seen in the preceding diagram, the Spring container creates the
    beans in your application, and assembles them for relationships between those
    objects via the DI pattern. The Spring container creates the beans based on the
    configuration that we give to the framework, so, it's your responsibility to tell
    Spring which beans to create, and how to wire them together.
  prefs: []
  type: TYPE_NORMAL
- en: 'Spring is very flexible in configuring the dependency of Spring beans. The
    following are three ways to configure the metadata of your application:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Dependency injection pattern with Java-based configuration**—it is an explicit
    configuration in Java.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Dependency injection pattern with Annotation-based configuration**—it is
    an implicit bean discovery, and automatic wiring.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Dependency injection pattern with XML-based configuration**—it is an explicit
    configuration in XML.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Spring provides three choices to wire beans in Spring. You must select one of
    the choices, but no single choice is the best match for any application. It depends
    on your application, and you can also mix and match these choices into a single
    application. Let's now discuss the dependency injection pattern with Java-based
    configuration in detail.
  prefs: []
  type: TYPE_NORMAL
- en: Dependency injection pattern with Java-based configuration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As of Spring 3.0, it provides a Java-based Spring configuration to wire the
    Spring beans. Take a look at the following Java configuration class (`AppConfig.java`)
    to define the Spring bean and their dependencies. The Java-based configuration
    for dependency injection is a better choice, because it is more powerful and type-safe.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a Java configuration class - AppConfig.java
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s create an `AppConfig.java` configuration class for our example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The preceding `AppConfig` class is annotated with the `@Configuration` annotation,
    which indicates that it is a configuration class of the application that contains
    the details on bean definitions. This file will be loaded by the Spring application
    context to create beans for your application.
  prefs: []
  type: TYPE_NORMAL
- en: Let's now see how you can declare the `TransferService`, `AccountRepository`
    and `TransferRepository` beans in `AppConfig`.
  prefs: []
  type: TYPE_NORMAL
- en: Declaring Spring beans into configuration class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To declare a bean in a Java-based configuration, you have to write a method
    for the desired type object creation in the configuration class, and annotate
    that method with `@Bean`. Let''s see the following changes made in the `AppConfig`
    class to declare the beans:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding configuration file, I declared three methods to create instances
    for `TransferService`, `AccountRepository`, and `TransferRepository`. These methods
    are annotated with the `@Bean` annotation to indicate that they are responsible
    for instantiating, configuring, and initializing a new object to be managed by
    the Spring IoC container. Each bean in the container has a unique bean ID; by
    default, a bean has an ID same as the `@Bean` annotated method name. In the preceding
    case, the beans will be named as `transferService`, `accountRepository`, and `transferRepository`.
    You can also override that default behavior by using the name attribute of the
    `@Bean` annotation as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Now `"service"` is the bean name of that bean `TransferService`.
  prefs: []
  type: TYPE_NORMAL
- en: Let's see how you can inject dependencies for the `TransferService`, `AccountRepository`,
    and `TransferRepository` beans in `AppConfig`.
  prefs: []
  type: TYPE_NORMAL
- en: Injecting Spring beans
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the preceding code, I declared the beans `TransferService`, `AccountRepository`,
    and `TransferRepository`; these beans had no dependencies. But, actually, the
    `TransferService` bean depends on `AccountRepository` and `TransferRepository`.
    Let''s see the following changes made in the `AppConfig` class to declare the
    beans:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, the simplest way to wire up beans in a Java-based
    configuration is to refer to the referenced bean's method. The `transferService()`
    method constructs the instance of the `TransferServiceImpl` class by calling the
    arguments constructor that takes `AccountRepository` and `TransferRepository`.
    Here, it seems that the constructor of the `TransferServiceImpl` class is calling
    the `accountRepository()` and `transferRepository()` methods to create instances
    of `AccountRepository` and `TransferRepository` respectively, but it is not an
    actual call to create instances. The Spring container creates instances of `AccountRepository`
    and `TransferRepository`, because the `accountRepository()` and `transferRepository()`
    methods are annotated with the `@Bean` annotation. Any call to the bean method
    by another bean method will be intercepted by Spring to ensure the default singleton
    scope (this will be discussed further in [Chapter 5](d0375506-d940-4fe5-bc09-d1033eed2986.xhtml),
    *Understanding the Bean Life cycle and Used Patterns*) of the Spring beans by
    that method is returned rather than allowing it to be invoked again.
  prefs: []
  type: TYPE_NORMAL
- en: Best approach to configure the dependency injection pattern with Java
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the previous configuration example, I declared the `transferService()` bean
    method to construct an instance of the `TransferServiceImpl` class by using its
    arguments constructor. The bean methods, `accountRepository()` and `transferRepository()`,
    are passed as arguments of the constructor. But in an enterprise application,
    a lot of configuration files depend on the layers of the application architecture.
    Suppose the service layer and the infrastructure layer have their own configuration
    files. That means that the `accountRepository()` and `transferRepository()` methods
    may be in different configuration files, and the `transferService()` bean method
    may be in another configuration file. Passing bean methods into the constructor
    is not a good practice for configuration of the dependency injection pattern with
    Java. Let''s see a different and the best approach to configuring the dependency
    injection:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, the `transferService()` method asks for `AccountRepository`
    and `TransferRepository` as parameters. When Spring calls `transferService()`
    to create the `TransferService` bean, it autowires `AccountRepository` and `TransferRepository`
    into the configuration method. With this approach, the `transferService()` method
    can still inject `AccountRepository` and `TransferRepository` into the constructor
    of `TransferServiceImpl` without explicitly referring to the `accountRepository()`
    and `transferRepository()``@Bean` methods.
  prefs: []
  type: TYPE_NORMAL
- en: Let's now take a look at dependency injection pattern with XML-based configuration.
  prefs: []
  type: TYPE_NORMAL
- en: Dependency injection pattern with XML-based configuration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Spring provides dependency injection with XML-based configuration from the very
    beginning. It is the primary way of configuring a Spring application. According
    to me, every developer should have an understanding of how to use XML with a Spring
    application. In this section, I am going to explain the same example as discussed
    in the previous section of Java-based configuration with reference to XML-based
    configuration.
  prefs: []
  type: TYPE_NORMAL
- en: Creating an XML configuration file
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the section on Java-based configuration, we had created an `AppConfig` class
    annotated with the `@Configuration` annotation. Similarly, for XML-based configuration,
    we will now create an `applicationContext.xml` file rooted with a `<beans>` element.
    The following simplest possible example shows the basic structure of XML-based
    configuration metadata:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Following is the `applicationContext.xml` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The preceding XML file is a configuration file of the application which contains
    the details on bean definitions. This file is also loaded by the XML-flavored
    implementation of `ApplicationContext` to create beans for your application. Let's
    see how you can declare the `TransferService`, `AccountRepository` and `TransferRepository`
    beans in the preceding XML file.
  prefs: []
  type: TYPE_NORMAL
- en: Declaring Spring beans in an XML file
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As with Java, we have to declare a class as a Spring bean into Spring''s XML-based
    configuration by using an element of the Spring-beans schema as a `<bean>` element.
    The `<bean>` element is the XML analogue to JavaConfig''s `@Bean` annotation.
    We add the following configuration to the XML-based configuration file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, I have created a very simple bean definition. In this
    configuration, the `<bean>` element has an `id` attribute to identify the individual
    bean definition. The `class` attribute is expressed as the fully qualified class
    name to create this bean. The value of the `id` attribute refers to collaborating
    objects. So let's see how to configure the collaborating beans to resolve the
    dependencies in the application.
  prefs: []
  type: TYPE_NORMAL
- en: Injecting Spring beans
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Spring provides these two ways to define the DI pattern to inject the dependency
    with the dependent bean in an application:'
  prefs: []
  type: TYPE_NORMAL
- en: Using constructor injection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using setter injection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using constructor injection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For the DI pattern with the construction injection, Spring provides you two
    basic options as the `<constructor-arg>` element and c-namespace introduced in
    Spring 3.0\. c-namespace has less verbosity in the application, which is the only
    difference between them--you can choose any one. Let''s inject the collaborating
    beans with the construction injection as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding configuration, the `<bean>` element of `TransferService` has
    two `<constructor-arg>.` This tells it to pass a reference to the beans whose
    IDs are `accountRepository` and `transferRepository` to the constructor of `TransferServiceImpl`.
  prefs: []
  type: TYPE_NORMAL
- en: 'As of Spring 3.0, the c-namespace, similarly, has a more succinct way of expressing
    constructor args in XML. For using this namespace, we have to add its schema in
    the XML file, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Let's see how to set up these dependencies with the setter injection.
  prefs: []
  type: TYPE_NORMAL
- en: Using setter injection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Using the injection, Spring also provides you with two basic options as the
    `<property>` element and p-namespace introduced in Spring 3.0\. The p-namespace
    also reduced verbosity of code in the application, which is the only difference
    between them, you can choose any one. Let''s inject the collaborating beans with
    the setter injection as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding configuration, the `<bean>` element of `TransferService` has
    two `<property>` elements which tell it to pass a reference to the beans whose
    IDs are `accountRepository` and `transferRepository` to the setter methods of
    `TransferServiceImpl`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding file, if you use this Spring bean without setter methods, the
    properties `accountRepository` and `transferRepository` will be initialized as
    null without injecting the dependency.
  prefs: []
  type: TYPE_NORMAL
- en: 'As of Spring 3.0, the p-namespace, similarly, has a more succinct way of expressing
    property in XML. For using this namespace, we have to add its schema in the XML
    file as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Let's now take a look at the dependency injection pattern with Annotation-based
    configuration.
  prefs: []
  type: TYPE_NORMAL
- en: Dependency injection pattern with Annotation-based configuration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As discussed in the previous two sections, we defined the DI pattern with Java-and
    XML-based configurations, and these two options define dependencies explicitly.
    It creates the Spring beans by using either the `@Bean` annotated method in the
    `AppConfig` Java file, or the `<bean>` element tag in the XML configuration file.
    By these methods, you can also create the bean for those classes which lie outside
    the application, that is, classes that exist in third-party libraries. Now let's
    discuss another way to create Spring beans, and define the dependencies between
    them by using implicit configuration through the Stereotype annotations.
  prefs: []
  type: TYPE_NORMAL
- en: What are Stereotype annotations?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The Spring Framework provides you with some special annotations. These annotations
    are used to create Spring beans automatically in the application context. The
    main stereotype annotation is `@Component`. By using this annotation, Spring provides
    more Stereotype meta annotations such as `@Service`, used to create Spring beans
    at the Service layer, `@Repository`, which is used to create Spring beans for
    the repositories at the DAO layer, and `@Controller`, which is used to create
    Spring beans at the controller layer. This is depicted in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6fd97786-73e6-4b3d-841d-8954bd1658b4.png)'
  prefs: []
  type: TYPE_IMG
- en: 'By using these annotations, Spring creates automatic wiring in these two ways:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Component scanning:** In this, Spring automatically searches the beans to
    be created in the Spring IoC container'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Autowiring:** In this, Spring automatically searches the bean dependencies
    in the Spring IoC container'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implicitly, the DI pattern configuration reduces the verbosity of an application,
    and minimizes explicit configuration. Let's demonstrate component scanning and
    autowiring in the same example as discussed previously. Here, Spring will create
    the beans for `TransferService`, `TransferRepository`, and `AccountRepository`
    by discovering them, and automatically inject them to each other as per the defined
    dependencies.
  prefs: []
  type: TYPE_NORMAL
- en: Creating auto searchable beans using Stereotype annotations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s see the following `TransferService` interface. Its implementation is
    annotated with `@Component`. Please refer to the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding interface is not important for this approach of configuration--I
    have taken it just for loose coupling in the application. Let''s see its implementation,
    which is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: You can see in the preceding code that `TransferServiceImpl` is annotated with
    the `@Component` annotation. This annotation is used to identify this class as
    a component class, which means, it is eligible to scan and create a bean of this
    class. Now there is no need to configure this class explicitly as a bean either
    by using XML or Java configuration--Spring is now responsible for creating the
    bean of the `TransferServiceImpl` class, because it is annotated with `@Component`.
  prefs: []
  type: TYPE_NORMAL
- en: 'As mentioned earlier, Spring provides us meta annotations for the `@Component`
    annotation as `@Service`, `@Repository`, and `@Controller`. These annotations
    are based on a specific responsibility at different layers of the application.
    Here, `TransferService` is the service layer class; *as a best practice of Spring
    configuration*, we have to annotate this class with the specific annotation, `@Service`,
    rather than with the generic annotation, `@Component`, to create the bean of this
    class. The following is the code for the same class annotated with the `@Service`
    annotation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Let's see other classes in the application--these are the `implementation` classes
    of `AccountRepository`--and the `TransferRepository` interfaces are the repositories
    working at the DAO layer of the application. *As a best practice**,* these classes
    should be annotated with the `@Repository` annotation rather than using the `@Component`
    annotation as shown next.
  prefs: []
  type: TYPE_NORMAL
- en: '`JdbcAccountRepository.java` implements the `AccountRepository` interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'And `JdbcTransferRepository.java` implements the `TransferRepository` interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: In Spring, you have to enable component scanning in your application, because
    it is not enabled by default. You have to create a configuration Java file, and
    annotate it with `@Configuration` and `@ComponentScan`. This class is used to
    search out classes annotated with `@Component`, and to create beans from them.
  prefs: []
  type: TYPE_NORMAL
- en: Let's see how Spring scans the classes which are annotated with any stereotype
    annotations.
  prefs: []
  type: TYPE_NORMAL
- en: Searching beans using component scanning
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following minimum configuration is required to search beans using component
    scanning in a Spring application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'The `AppConfig` class defines a Spring wiring configuration class same as the
    Java-based Spring configuration in the previous section. There is one thing to
    be observed here--the `AppConfig` file has one more `@ComponentScan`, as earlier
    it had only the `@Configuration` annotation. The configuration file `AppConfig`
    is annotated with `@ComponentScan` to enable component scanning in Spring. The
    `@ComponentScan` annotation scans those classes that are annotated with `@Component`
    by default in the same package as the configuration class. Since the `AppConfig`
    class is in the `com.packt.patterninspring.chapter4.bankapp.config` package, Spring
    will scan only this package and its sub packages. But our component application
    classes are in the `com.packt.patterninspring.chapter1.bankapp.service` and `com.packt.patterninspring.chapter4.bankapp.repository.jdbc`
    packages, and these are not subpackages of `com.packt.patterninspring.chapter4.bankapp.config`.
    In this case, Spring allows to override the default package scanning of the `@ComponentScan`
    annotation by setting a base package for component scanning. Let''s specify a
    different base package. You only need to specify the package in the `value` attribute
    of `@ComponentScan`, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Or you can define the base packages with the `basePackages` attribute, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `@ComponentScan` annotation, the `basePackages` attribute can accept
    an array of Strings, which means that we can define multiple base packages to
    scan component classes in the application. In the previous configuration file,
    Spring will scan all classes of `com.packt.patterninspring.chapter4.bankapp package`,
    and all the subpackages underneath this package. *As a best practice,* always
    define the specific base packages where the components classes exist. For example,
    in the following code, I define the base packages for the service and repository
    components:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Now Spring scans only `com.packt.patterninspring.chapter4.bankapp.repository.jdbc`
    and `com.packt.patterninspring.chapter4.bankapp.service packages`, and its subpackages
    if they exist. instead of doing a wide range scanning like in the earlier examples.
  prefs: []
  type: TYPE_NORMAL
- en: 'Rather than specify the packages as simple String values of the `basePackages`
    attribute of `@ComponentScan`, Spring allows you to specify them via classes or
    interfaces as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: As you can see in the preceding code, the `basePackages` attribute has been
    replaced with `basePackageClasses`. Now Spring will identify the component classes
    in those packages where `basePackageClasses` will be used as the base package
    for component scanning.
  prefs: []
  type: TYPE_NORMAL
- en: 'It should find the `TransferServiceImpl`, `JdbcAccountRepository`, and `JdbcTransferRepository`
    classes, and automatically create the beans for these classes in the Spring container.
    Explicitly, there is no need to define the bean methods for these classes to create
    Spring beans. Let''s turn on component scanning via XML configuration, then you
    can use the `<context:component-scan>` element from Spring''s context namespace.
    Here is a minimal XML configuration to enable component scanning:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding XML file, the `<context:component-scan>` element is same the
    `@ComponentScan` annotation in the Java-based configuration for component scanning.
  prefs: []
  type: TYPE_NORMAL
- en: Annotating beans for autowiring
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Spring provides support for automatic bean wiring. This means that Spring automatically
    resolves the dependencies that are required by the dependent bean by finding other
    collaborating beans in the application context. Bean Autowiring is another way
    of DI pattern configuration. It reduces verbosity in the application, but the
    configuration is spread throughout the application. Spring's `@Autowired` annotation
    is used for auto bean wiring. This `@Autowired` annotation indicates that autowiring
    should be performed for this bean.
  prefs: []
  type: TYPE_NORMAL
- en: 'In our example, we have `TransferService` which has dependencies of `AccountRepository`
    and `TransferRepository`. Its constructor is annotated with `@Autowired` indicating
    that when Spring creates the `TransferService` bean, it should instantiate that
    bean by using its annotated constructor, and pass in two other beans, `AccountRepository`
    and `TransferRepository`, which are dependencies of the `TransferService` bean.
    Let''s see the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Note--As of Spring 4.3, the `@Autowired` annotation is no more required if you
    define only one construct with arguments in that class. If class has multiple
    argument constructors, then you have to use the `@Autowired` annotation on any
    one of them.
  prefs: []
  type: TYPE_NORMAL
- en: The `@Autowired` annotation is not limited to the construction; it can be used
    with the setter method, and can also be used directly in the field, that is, an
    `autowired` class property directly. Let's see the following line of code for
    setter and field injection.
  prefs: []
  type: TYPE_NORMAL
- en: Using @Autowired with setter method
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here you can annotate the setter method''s `setAccountRepository` and `setTransferRepository`
    with the `@Autowired` annotation. This annotation can be used with any method.
    There is no specific reason to use it with the setter method only. Please refer
    to the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Using @Autowired with the fields
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here you can annotate those class properties which are required for this class
    to achieve a business goal. Let''s see the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, the `@Autowired` annotation resolves the dependency
    by `type` and then by `name` if the property name is the same as the bean name
    in the Spring container. By default, the `@Autowired` dependency is a required
    dependency--it raises an exception if the dependency is not resolved, it doesn''t
    matter whether we have used it with a constructor or with the setter method. You
    can override the required behavior of the `@Autowired` annotation by using the
    `required` attribute of this annotation. You can set this attribute with the Boolean
    value `false` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we have set the required attribute with the Boolean value
    `false`. In this case, Spring will attempt to perform autowiring, but if there
    are no matching beans, it will leave the bean unwired. But as a best practice
    of code, you should avoid setting its value as false until it is absolutely necessary.
  prefs: []
  type: TYPE_NORMAL
- en: The Autowiring DI pattern and disambiguation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `@Autowiring` annotation reduces verbosity in the code, but it may create
    some problems when two of the same type of beans exist in the container. Let''s
    see what happens in that situation, with the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding snippet of code shows that the `TransferServiceImpl` class has
    a dependency with a bean of type `AccountRepository`, but the Spring container
    contains two beans of the same type, that is, the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'As seen from the preceding code, there are two implementations of the `AccountRepository`
    interface--one is `JdbcAccountRepository` and another is `JpaAccountRepository`.
    In this case, the Spring container will throw the following exception at startup
    time of the application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Resolving disambiguation in Autowiring DI pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Spring provides one more annotation, `@Qualifier`, to overcome the problem
    of disambiguation in autowiring DI. Let''s see the following snippet of code with
    the `@Qualifier` annotation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Now I have wired the dependency by name rather than by type by using the `@Qualifier`
    annotation. So, Spring will search the bean dependency with the name `"jdbcAccountRepository"`
    for the `TransferServiceImpl` class. I have given the names of the beans as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: '`@Qualifier`, also available with the method injection and field injection
    component names, should not show implementation details unless there are two implementations
    of the same interface.'
  prefs: []
  type: TYPE_NORMAL
- en: Let's now discuss some best practices to choose the DI pattern configuration
    for your Spring application.
  prefs: []
  type: TYPE_NORMAL
- en: '**Resolving dependency with Abstract Factory pattern**'
  prefs: []
  type: TYPE_NORMAL
- en: If you want to add the `if...else` conditional configuration for a bean, you
    can do so, and also add some custom logic if you are using Java configuration.
    But in the case of an XML configuration, it is not possible to add the `if...then...else`
    conditions. Spring provides the solution for conditions in an XML configuration
    by using the Abstract Factory Pattern. Use a factory to create the bean(s) you
    want, and use any complex Java code that you need in the factory's internal logic.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the Abstract Factory Pattern in Spring (FactoryBean interface)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Spring Framework provides the `FactoryBean` interface as an implementation
    of the Abstract Factory Pattern. A `FactoryBean` is a pattern to encapsulate interesting
    object construction logic in a class. The `FactoryBean` interface provides a way
    to customize the Spring IoC container's instantiation logic. You can implement
    this interface for objects that are themselves factories. Beans implementing `FactoryBean`
    are auto-detected.
  prefs: []
  type: TYPE_NORMAL
- en: 'The definition of this interface is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: As per the preceding definition of this interface, the dependency injection
    using the FactoryBean and it causes `getObject()` to be invoked transparently.
    The `isSingleton()` method returns `true` for singleton, else it returns `false`.
    The `getObjectType()` method returns the object type of the object returned by
    the `getObject()` method.
  prefs: []
  type: TYPE_NORMAL
- en: Implementation of FactoryBean interface in Spring
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`FactoryBean` is widely used within Spring as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`EmbeddedDatabaseFactoryBean`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`JndiObjectFactoryBean`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`LocalContainerEntityManagerFactoryBean`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`DateTimeFormatterFactoryBean`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ProxyFactoryBean`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`TransactionProxyFactoryBean`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`MethodInvokingFactoryBean`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sample implementation of FactoryBean interface
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Suppose you have a `TransferService` class whose definition is thus:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'And you have a `FactoryBean` whose definition is thus:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'You could wire up an `AccountRepository` instance using a hypothetical `AccountRepositoryFactoryBean`
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, the `TransferService` class depends on the `AccountRepository`
    bean, but in the XML file, we have defined `AccountRepositoryFactoryBean` as an
    `accountRepository` bean. The `AccountRepositoryFactoryBean` class implements
    the `FactoryBean` interface of Spring. The result of the `getObject` method of
    `FactoryBean` will be passed, and not the actual `FactoryBean` itself. Spring
    injects that object returned by `FactoryBean`'s `getObjectType()` method, and
    the object type returned by `FactoryBean`'s `getObjectType()`; the scope of this
    bean is decided by the `FactoryBean`'s `isSingleton()` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is the same configuration for the `FactoryBean` interface in
    a Java Configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: As other normal beans in the Spring container, the Spring `FactoryBean` also
    has all the other characteristics of any other Spring bean, including the life
    cycle hooks and services that all beans in the Spring container enjoy.
  prefs: []
  type: TYPE_NORMAL
- en: Best practices for configuring the DI pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following are the best practices for configuring the DI pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: Configuration files should be separated categorically. Application beans should
    be separate from infrastructure beans. Currently, it's a bit difficult to follow.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/0eb74c9e-0a6f-4709-8d4b-76723d2651c5.png)'
  prefs: []
  type: TYPE_IMG
- en: Always specify the component name; never rely on generated names by the container.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is a best practice to give a name along with a description of what the pattern
    does, where to apply it, and the problems it addresses.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The best practices for component scanning are as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The components are scanned at startup, and it scans the JAR dependencies as
    well.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Bad practice:** It scans all the packages of `com` and `org`. It increases
    the startup time of the application. Avoid such type of component scanning:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: '**Optimized:** It scans only the specific packages as defined by us.'
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Best practices in choosing implicit configuration:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Choose annotation-based configurations for frequently changing beans
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: It allows for very rapid development
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: It is a single place to edit the configuration
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Best practices in choosing explicit via Java configuration:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is centralized in one place
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Strong type checking enforced by the compiler
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Can be used for all classes
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Spring XML Best Practices: XML has been around for a long time, there are many
    shortcuts and useful techniques available in XML configuration as well, they are
    listed follow:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: factory-method and factory-bean attributes
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Bean Definition Inheritance
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Inner Beans
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: p and c namespaces
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Using collections as Spring beans
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: After reading this chapter, you should now have a good idea about DI design
    patterns, and the best practices for applying those patterns. Spring deals with
    the plumbing part, so, you can focus on solving the domain problem by using the
    dependency injection pattern. The DI pattern frees the object of the burden of
    resolving its dependencies. Your object is handed everything that it needs to
    work. The DI pattern simplifies your code, improves code reusability, and testability.
    It promotes programming to interfaces, and conceals the implementation details
    of dependencies. The DI pattern allows for centralized control over the object's
    life cycle. You can configure DI via two ways--explicit configuration and implicit
    configuration. Explicit configuration can be configured through XML-or Java-based
    configuration; it provides centralized configuration. But implicit configuration
    is based on annotations. Spring provides stereotype annotations for Annotation-based
    configuration. This configuration reduces the verbosity of code in the application,
    but it spreads out across the application files.
  prefs: []
  type: TYPE_NORMAL
- en: In the upcoming [Chapter 5](d0375506-d940-4fe5-bc09-d1033eed2986.xhtml), *Understanding
    the Bean Life Cycle and Used Patterns*, we will explore the life cycle of the
    Spring bean in the container.
  prefs: []
  type: TYPE_NORMAL
