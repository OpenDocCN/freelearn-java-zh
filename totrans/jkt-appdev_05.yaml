- en: '5'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Microservices Development with Jakarta EE
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Microservices is an architectural style in which code is deployed in small,
    granular modules. The microservices architecture reduces coupling and increases
    cohesion. Typically, microservices are implemented as RESTful web services, using
    JSON to pass data to one another, by invoking HTTP methods (`GET`, `POST`, `PUT`
    or `DELETE`) on each other. Since communication between microservices is done
    via HTTP methods, microservices written in different programming languages can
    interact with each other. In this chapter, we will cover how we can use Jakarta
    EE to implement microservices.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: An introduction to microservices
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Microservices and Jakarta EE
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Developing microservices using Jakarta EE
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Example source code for this chapter can be found on GitHub at [https://github.com/PacktPublishing/Jakarta-EE-Application-Development/tree/main/ch05_src](https://github.com/PacktPublishing/Jakarta-EE-Application-Development/tree/main/ch05_src).
  prefs: []
  type: TYPE_NORMAL
- en: An introduction to microservices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Architecting applications as a series of microservices offers some advantages
    over traditionally designed applications, as well as some disadvantages. When
    considering a microservices architecture for our applications, we must carefully
    weigh the advantages and disadvantages before we make our decision.
  prefs: []
  type: TYPE_NORMAL
- en: The advantages of a microservices architecture
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Developing an application as a series of microservices offers several advantages
    over traditionally designed applications, such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Smaller code bases**: Since each microservice is a small, standalone unit,
    code bases for microservices tend to be smaller and easier to manage than traditionally
    designed applications.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Microservices encourage good coding practices**: A microservices architecture
    encourages loose coupling and high cohesion.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Greater resilience**: Traditionally designed applications act as a single
    point of failure; if any component of an application is down or unavailable, the
    whole application is unavailable. Since microservices are independent modules,
    one component (i.e., one microservice) being down does not necessarily make the
    whole application unavailable.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Scalability**: Since applications developed as a series of microservices
    are composed of a number of different modules, scalability becomes easier. We
    can focus only on those services that may need scaling, without having to waste
    effort on parts of an application that do not need to be scaled.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The disadvantages of a microservices architecture
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Developing and deploying applications adhering to microservices architecture
    comes with its own set of challenges, regardless of what programming language
    or application framework is used to develop an application:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Additional operational and tooling overhead**: Each microservice implementation
    would require its own (possibly automated) deployment, monitoring systems, and
    so on.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Debugging microservices may be more involved than debugging traditional enterprise
    applications**: If an end user reports a problem with their application and the
    application utilizes multiple microservices internally, it is not always clear
    which of the microservices may be the culprit. This may be especially difficult
    if the microservices involved are developed by different teams with different
    priorities.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Distributed transactions may be a challenge**: Rolling back a transaction
    involving several microservices may be hard. A common approach to work around
    this is to isolate microservices as much as possible, treat them as single units,
    and then have local transaction management for each microservice. For example,
    if microservice A invokes microservice B and there is a problem with the latter,
    a local transaction in microservice B would roll back. Then, it would return a
    500 HTTP status code (server error) to microservice A. It could then use this
    HTTP status code as a signal to initiate a compensating transaction, restoring
    the system to its initial state.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Network latency**: Since microservices rely on HTTP method calls for communication,
    performance may suffer due to network latency.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The potential for complex interdependencies**: While independent microservices
    tend to be simple, they are dependent on each other. A microservices architecture
    can potentially create a complex dependency graph. This situation can be worrisome
    if some of our services depend on microservices developed by other teams that
    may have conflicting priorities (i.e., we find a bug in their microservice, but
    fixing the bug may not be a priority for the other team).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Susceptibility to the fallacies of distributed computing**: Applications
    developed following a microservices architecture may make some incorrect assumptions,
    such as network reliability, zero latency, and infinite bandwidth.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now that we’ve talked about microservices in general, we’ll focus our attention
    on how Jakarta EE can be leveraged to develop applications adhering to a microservices
    architecture.
  prefs: []
  type: TYPE_NORMAL
- en: Microservices and Jakarta EE
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Some may think that Jakarta EE is “too heavyweight” for microservices development.
    This is simply not the case. Because of this misconception, some may also think
    that Jakarta EE may not be suitable for a microservices architecture when, in
    reality, Jakarta EE fits microservices development well. Some time ago, Java EE
    applications were deployed to a “heavyweight” application server. Nowadays, most
    Jakarta EE application server vendors offer lightweight application servers that
    use very little memory or disk space. Some examples of these Jakarta EE-compliant
    lightweight application servers include IBM’s Open Liberty, Red Hat’s WildFly
    Swarm, Apache TomEE, and Payara Micro. Jakarta EE 10 introduced the core profile,
    which is ideal for microservices development using Jakarta EE.
  prefs: []
  type: TYPE_NORMAL
- en: Developing microservices with the Jakarta EE core profile involves writing standard
    Jakarta EE applications, while limiting yourself to the subset of Jakarta EE APIs
    supported by the core profile, namely Jakarta REST, JSON-P, JSON-B, and CDI. If
    interacting with a relational database, we may need transaction support and likely
    would like an object-relational mapping API, such as Jakarta Persistence. To interact
    with a relational database, we would need the Jakarta EE web profile, as the core
    profile does not include Jakarta Persistence or transaction support. Only microservices
    needing to directly interact with a relational database would need the web profile;
    other microservices can be developed against the core profile.
  prefs: []
  type: TYPE_NORMAL
- en: Jakarta EE developers can leverage their existing expertise when developing
    microservices. When developing microservices, the main requirement is the development
    of RESTful web services, which can be easily implemented using Jakarta REST. These
    RESTful web services would be packaged in a WAR file and deployed to a lightweight
    Jakarta EE runtime.
  prefs: []
  type: TYPE_NORMAL
- en: When using modern, embeddable Jakarta EE implementations, usually only one application
    is deployed to each instance of the application server, and, in some cases, the
    “tables are turned” so to speak, by making the Jakarta EE implementation just
    a library that the application uses as a dependency. With these modern Jakarta
    EE implementations, several instances of the Jakarta EE runtime are often deployed
    to a server, making modern Jakarta EE very suitable for microservices development.
    Many modern, lightweight Jakarta EE application servers are embeddable, allowing
    the creation of an “uber jar,” which includes both the application code and the
    application server libraries. This “uber jar” is then transferred to the server
    and run as a standalone application. In addition to “uber jars,” modern application
    servers can be added to a container image (such as Docker). Then, our application
    can be deployed as a thin WAR, typically only a few kilobytes in size; this approach
    has the advantage of very fast deployments, usually under two seconds.
  prefs: []
  type: TYPE_NORMAL
- en: By deploying to a contemporary, Jakarta EE core profile-compliant application
    server (or, as explained in the previous paragraph, creating an “uber jar”), Jakarta
    EE developers can certainly leverage their existing expertise to develop applications
    adhering to a microservices architecture.
  prefs: []
  type: TYPE_NORMAL
- en: Developing microservices using Jakarta EE
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have briefly introduced you to microservices, we are ready to show
    an example of a microservices application written using Jakarta EE. Our example
    application should be very familiar to most Jakarta EE developers. It is a simple
    **CRUD** (**Create, Read, Update, Delete**) application developed as a series
    of microservices. The application will follow the familiar MVC design pattern,
    with the “View” and “Controller” developed as microservices. The application will
    also utilize the very common **Data Access Object** (**DAO**) **pattern**, with
    our DAO developed as a microservice as well.
  prefs: []
  type: TYPE_NORMAL
- en: DAO Pattern
  prefs: []
  type: TYPE_NORMAL
- en: The **DAO** design pattern is one that allows us to separate data access code
    from the rest of our application. Allowing us to switch the implementation of
    the data access code without impacting the rest of the application code.
  prefs: []
  type: TYPE_NORMAL
- en: Our application will be developed as three modules – first, a microservices
    client, followed by a microservices implementation of a controller in the MVC
    design pattern, and then an implementation of the DAO design pattern implemented
    as a microservice.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The example code is not a full CRUD application. For simplicity, we only implemented
    the “create” part of our CRUD application.
  prefs: []
  type: TYPE_NORMAL
- en: Developing microservices client code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Before delving into developing our services, we will first develop a microservices
    client using plain HTML and JavaScript. The JavaScript code will invoke the controller
    microservice, passing a JSON representation of user-entered data. The controller
    service will then invoke the persistence service and save the data to a database.
    Each microservice will return an HTTP code indicating success or error condition.
  prefs: []
  type: TYPE_NORMAL
- en: The most relevant parts of our client code are the HTML form and the JavaScript
    code to submit it to our Controller microservice.
  prefs: []
  type: TYPE_NORMAL
- en: 'The form in our HTML page contains the following input fields:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Our web client form contains a number of input fields to collect data from
    the user. It is implemented using plain HTML, with no additional CSS or JavaScript
    libraries. Our page also has a script to send form data to the controller microservice
    using JavaScript, as illustrated in the following code block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: When the form is submitted, our script generates a JSON-formatted representation
    of the user-entered data and then sends an HTTP `POST` request to our controller
    service, using the JavaScript fetch API. In our example, our controller service
    is deployed to a Jakarta EE runtime on our local workstation, listening on port
    `8080`; therefore, our client code sends a `POST` request to http://localhost:8080/CrudController/resources/customercontroller/.
  prefs: []
  type: TYPE_NORMAL
- en: We can now point our browser to our `CrudView` application URL (http://localhost:8080/CrudView
    in our example). After entering some data, the page will look as shown in the
    following screenshot.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.1 – The HTML/JavaScript RESTful web service client](img/B21231_5_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.1 – The HTML/JavaScript RESTful web service client
  prefs: []
  type: TYPE_NORMAL
- en: When the user clicks on the **Submit** button, the client passes a JSON representation
    of user-entered data to the controller service.
  prefs: []
  type: TYPE_NORMAL
- en: The controller service
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The controller service is a standard RESTful web service implementation of
    a controller in the MVC design pattern, implemented using Jakarta REST:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The `options()` method, annotated with the `jakarta.ws.rs.OPTIONS` annotation
    is necessary, since the browser automatically calls it, before invoking the actual
    request containing the main logic of our server. In this method, we set some header
    values to allow `http://localhost:8080`, which is the host and port where our
    client code is deployed.
  prefs: []
  type: TYPE_NORMAL
- en: The main logic of our controller service is in the `addCustomer()` method. This
    method receives an instance of our `Customer` class as a parameter; Jakarta REST
    automatically populates the `Customer` parameter with the JSON-formatted data
    sent by the client.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The `Customer` class is a simple **Data Transfer Object** (**DTO**), containing
    a few properties matching the input fields in the form in the client, plus the
    corresponding getters and setters. Since the class is quite simple, we decided
    not to show it.
  prefs: []
  type: TYPE_NORMAL
- en: In the `addCustomer()` method, we create an instance of `CustomerPersistenceClient()`,
    which is a client for the persistence service, implemented using the Jakarta REST
    client API.
  prefs: []
  type: TYPE_NORMAL
- en: Then, our `addCustomer()` method invokes the persistence service by invoking
    the `create()` method on `CustomerPersistenceClient`, checks the HTTP status code
    returned by the persistence service, and then sends an appropriate response to
    the client.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s take a look at the implementation of our Jakarta REST client code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: As we can see, our client code is a fairly simple class that makes use of the
    Jakarta REST client API. We declare a constant containing the base URI of the
    service we are invoking (our persistence service). In its constructor, we create
    a new instance of `jakarta.ws.rs.client.ClientBuilder`. We then set its base URI
    and path, matching the appropriate values for our persistence service. Our client
    class has a single method, which submits an HTTP `POST` request to the persistence
    service and then returns the response sent back from it.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have successfully developed our controller service, we are ready
    to explore the final component of our application – the persistence service.
  prefs: []
  type: TYPE_NORMAL
- en: The persistence service
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Our persistence service is implemented as a simple RESTful web service using
    Jakarta REST. Its `create()` method is invoked when the service receives an HTTP
    `POST` request:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Our `create()` method is invoked when the controller service sends an HTTP `POST`
    request to the persistence service. This method simply invokes a `create()` method
    on a class implementing the DAO design pattern. Our persistence service returns
    an HTTP response, `201` (Created). If everything goes well and the DAO’s `create()`
    method throws an exception, then our service returns a `500` HTTP error (Internal
    Server Error).
  prefs: []
  type: TYPE_NORMAL
- en: 'Our DAO is implemented as a CDI-managed bean, using JPA to insert data into
    the database:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Our DAO couldn’t be much simpler; it implements a single method that invokes
    the `persist()` method on an injected instance of `EntityManager`. Note that we
    took advantage of the `@DataSourceDefinition` annotation to create a data source
    pointing to our database. This annotation is a standard Jakarta EE annotation
    that allows us to define data sources in an implementation-independent way.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: In our persistence service project, the `Customer` class is a trivial JPA entity.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have developed all three components of our application, we are ready
    to see it in action.
  prefs: []
  type: TYPE_NORMAL
- en: Once a user enters some data and clicks the submit button, we should see a “success”
    message at the top of our page (see *Figure 5**.2*).
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.2 – User-entered data](img/B21231_5_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.2 – User-entered data
  prefs: []
  type: TYPE_NORMAL
- en: If we look at the database, we should see that the user-entered data persisted
    successfully, as shown in *Figure 5**.3*.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.3 – Data inserted into the database](img/B21231_5_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.3 – Data inserted into the database
  prefs: []
  type: TYPE_NORMAL
- en: As shown by our example code, developing applications following microservices
    architecture in Jakarta EE is very simple. It doesn’t require any special knowledge.
    Microservices are developed using standard Jakarta EE APIs and deployed to a lightweight
    Jakarta EE runtime.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As seen in this chapter, Jakarta EE is quite suitable for microservices development.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we covered the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: We introduced you to microservices, listing the advantages and disadvantages
    of a microservices architecture
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We explained how to develop microservices using standard Jakarta EE technologies,
    such as Jakarta REST
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Jakarta EE developers can leverage their existing knowledge to develop microservices
    architecture – deploying modern, lightweight application servers. Traditional
    Jakarta EE applications can interact with microservices quite well, and they can
    also be refactored iteratively into a microservices architecture when it makes
    sense. Whether developing new applications following a microservices architecture,
    refactoring an existing application to microservices, or modifying existing applications
    to interact with microservices, Jakarta EE developers can leverage their existing
    skills for the task at hand.
  prefs: []
  type: TYPE_NORMAL
