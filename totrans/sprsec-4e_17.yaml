- en: '17'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Microservice Security with OAuth 2 and JSON Web Tokens
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will look at microservices-based architectures and look
    at how **OAuth 2** with **JSON Web Tokens** (**JWT**) plays a role in securing
    microservices in a Spring- based application.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is a list of topics that will be covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: The general difference between **monolithic applications** and **microservices**
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Comparing **Service-Oriented Architectures** (**SOA**) with microservices
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The conceptual architecture of **OAuth 2** and how it provides your services
    with trustworthy client access
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Types of **OAuth 2** access tokens
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Types of **OAuth 2** grant types
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Examining JWT and their general structure
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing a resource server and authentication server used to grant access
    rights to clients in order to access **OAuth** **2** resources
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing a **RESTful** client to gain access to resources through an **OAuth
    2** grant flow
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We have quite a few items to cover in this chapter, but before we dig into the
    details of how to start leveraging `Spring Security` to implement **OAuth 2**
    and **JWT**, we first want to create a baseline of the calendar application that
    does not have **Thymeleaf** or any other browser- based user interface.
  prefs: []
  type: TYPE_NORMAL
- en: After removing all **Thymeleaf** configuration and resources, the various controllers
    have been converted to **JAX-RS** **REST** controllers.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter’s code in action link is here: [https://packt.link/zEHBU](https://packt.link/zEHBU).'
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: You should start with the code from `chapter17.00-calendar`.
  prefs: []
  type: TYPE_NORMAL
- en: What are microservices?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Microservices** are an architectural approach that allows the development
    of physically separated modular applications which are autonomous, enabling agility,
    rapid development, continuous deployment, and scaling.'
  prefs: []
  type: TYPE_NORMAL
- en: An application is built as a set of services, like `JSON` or `XML`, and this
    allows the aggregation of language-agnostic services. Basically, a service can
    be written in the best language for the task the service is being created for.
  prefs: []
  type: TYPE_NORMAL
- en: Each service runs in its own process and is location neutral, thus it can be
    located anywhere on the access network.
  prefs: []
  type: TYPE_NORMAL
- en: In the next sections, we will explore Monoliths, Microservices, and Service-oriented
    architectures and discern their variances. Then, we can delve into Microservices
    Security using spring-security.
  prefs: []
  type: TYPE_NORMAL
- en: Monoliths
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The microservices approach is the opposite of the traditional monolithic software
    approach, which consists of tightly integrated modules that ship infrequently
    and have to scale as a single unit. Traditional `JBCP calendar` application in
    this book are examples of monolithic applications. Look at the following diagram
    which depicts the monolithic architecture:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 17.1 – Monolithic architecture](img/B21757_17_1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 17.1 – Monolithic architecture
  prefs: []
  type: TYPE_NORMAL
- en: Although the monolithic approach fits well for some organizations and some applications,
    microservices is becoming popular with companies that need more options for agility
    and scalability in their ecosystem.
  prefs: []
  type: TYPE_NORMAL
- en: Microservices
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A microservice architecture is a collection of small discrete services where
    each service implements a specific business capability. These services run their
    own process and communicate via an **HTTP API** usually using a **RESTful** service
    approach. These services are created to serve only one specific business function,
    such as user management, administrative roles, an e-commerce cart, a search engine,
    social media integration, and many others. Look at the following diagram which
    depicts the microservices architecture:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 17.2 – Microservices architecture](img/B21757_17_2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 17.2 – Microservices architecture
  prefs: []
  type: TYPE_NORMAL
- en: Each service can be deployed, upgraded, scaled, restarted, and removed independently
    of other services in the application and other systems in the enterprise.
  prefs: []
  type: TYPE_NORMAL
- en: Because each service is created independently of the other, they can each be
    written in different programming languages and use different data storage. Centralized
    service management is virtually non-existent, and these services use lightweight
    **HTTP**, **REST** communicating among themselves.
  prefs: []
  type: TYPE_NORMAL
- en: Service-oriented architectures
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You might be asking yourself, “Isn’t this the same as SOA?” Not exactly, you
    could say **microservices** achieve what **SOA** promised in the first place.
  prefs: []
  type: TYPE_NORMAL
- en: An **SOA** is a style of software design where services are exposed to other
    components through a language-agnostic, communication protocol over a computer
    network.
  prefs: []
  type: TYPE_NORMAL
- en: The basic principle of **SOA** is to be independent of vendors, products, and
    technologies.
  prefs: []
  type: TYPE_NORMAL
- en: The definition of a service is a discrete unit of functionality that can be
    accessed remotely and acted upon and updated independently, such as retrieving
    a credit card statement online.
  prefs: []
  type: TYPE_NORMAL
- en: Although similar, **SOA** and microservices are still different types of architectures.
  prefs: []
  type: TYPE_NORMAL
- en: A typical **SOA** is often implemented inside deployment monoliths and is more
    platform driven, while microservices can be independently deployable and, therefore,
    offer more flexibility in all dimensions.
  prefs: []
  type: TYPE_NORMAL
- en: 'The key difference, of course, is the size; the word micro says it all. Microservices
    tend to be significantly smaller than regular **SOA** services. As *Martin* *Fowler*
    said:'
  prefs: []
  type: TYPE_NORMAL
- en: We should think about SOA as a superset of microservices.
  prefs: []
  type: TYPE_NORMAL
- en: Microservice security
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Microservices can provide great flexibility but also introduce challenges that
    must be addressed.
  prefs: []
  type: TYPE_NORMAL
- en: '**Service communication**: Monolithic applications use in-memory communication
    between processes, while microservices communicate over the network. The move
    to network communication raises issues of not only speed but also security.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Tight coupling**: Microservices use many datastores rather than a few. This
    creates the opportunity for implicit service contracts between microservices and
    services that are tightly coupled.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Technical complexity**: Microservices can create additional complexity, which
    can create security gaps. If the team does not have the correct experience, then
    managing these complexities can quickly become unmanageable.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The OAuth 2 specification
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There is sometimes a misconception that **OAuth 2** is an evolution from **OAuth
    1**, but it is a completely different approach. **OAuth 1** specification requires
    signatures, so you would have to use cryptographic algorithms to create generate
    and validate those signatures that are no longer required for **OAuth 2**. The
    **OAuth 2** encryption is now handled by **TLS**, which is required.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: '**OAuth 2 RFC-6749**, *The OAuth 2.0 Authorization* *Framework* ([https://tools.ietf.org/html/rfc6749](https://tools.ietf.org/html/rfc6749)):'
  prefs: []
  type: TYPE_NORMAL
- en: The **OAuth 2.0** authorization framework enables a third-party application
    to obtain limited access to an HTTP service, either on behalf of a resource owner
    by orchestrating an approval interaction between the resource owner and the HTTP
    service, or by allowing the third-party application to obtain access on its own
    behalf.
  prefs: []
  type: TYPE_NORMAL
- en: This specification replaces and makes obsolete the **OAuth 1.0** protocol described
    in **RFC 5849**, The **OAuth 1.0** Protocol ([https://tools.ietf.org/html/rfc5849](https://tools.ietf.org/html/rfc5849)).
  prefs: []
  type: TYPE_NORMAL
- en: 'To properly understand how to utilize **OAuth 2**, we need to identify certain
    roles and the collaboration between these roles. Let’s define each of the roles
    that are participating in the **OAuth 2** authorization process:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Resource owner**: The resource owner is the entity capable of granting access
    to a protected resource that is located on a resource server'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Authorization server**: The authorization server is a centralized security
    gateway for issuing access tokens to the client after successfully authenticating
    the resource owner and obtaining authorization'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Resource server**: The resource server is the server hosting the protected
    resources and is capable of dissecting and responding to protected resource requests
    using the **OAuth 2** access token'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Microservice client**: The client is the application making resource requests
    that are protected on behalf of the resource owner, but with their authorization'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Access tokens
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'An `access_token` in code samples, represents a credential that can be used
    by a client to access an **API**. We have two types of access tokens:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Access token**: An access token usually has a limited lifetime and is used
    to enable the client to access protected resources when including this token in
    the HTTP request header for each request.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Refresh token**: A refresh token has a longer lifetime and is used to get
    a new access token once the access token has expired, but without the need to
    send credentials to the server again.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Grant types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Grant types are methods that a client can use to gain an access token that
    represents the permissions granted. There are different grant types that allow
    different types of access based on the needs of your application. Each grant type
    can support a different **OAuth 2** flow without worrying about the technical
    aspects of the implementation. We have four main grant types in **OAuth 2**:'
  prefs: []
  type: TYPE_NORMAL
- en: '`access_token` and, optionally, `id_token` and `refresh_token`. The client
    can now use this `access_token` to call the protected resource on behalf of the
    user.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`access_token` directly, without the need for `authorization_code`. This happens
    because the client application, which is usually a JavaScript application running
    within a browser and is less trusted than a client application running on the
    server, cannot be trusted with `client_secret` (which is required in the authorization
    code grant type). The implicit grant type does not send a refresh token to the
    application due to limited trust.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`access_token` and, optionally, `refresh_token`. This grant is used when there
    is a high degree of trust between the user and the client and when other authorization
    grant flows are not available. This grant type eliminates the need for the client
    to store the user credentials by exchanging the credentials with a long-lived
    `access_token` or `refresh_token`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`access_token` by using client-provided credentials (client id and client secret)
    to authenticate.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: After covering the main OAuth 2 access tokens and grant types, in the next section
    will deep dive into the JSON Web Tokens specification.
  prefs: []
  type: TYPE_NORMAL
- en: JSON Web Tokens
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**JWT** is an open standard, **RFC 7519** ([https://tools.ietf.org/html/rfc7519](https://tools.ietf.org/html/rfc7519))
    that defines a compact and self-contained format for securely transmitting information
    between parties in the form of a **JSON** object. This information can be verified
    and trusted because it is digitally signed. JWTs can be signed using a secret
    (with the **hash-based message authentication code** (**HMAC**) algorithm) or
    a public/private key pair using the **Rivest–Shamir–Adleman** (**RSA**) encryption
    algorithm.'
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: '**JWT RFC-** **7519** ([https://tools.ietf.org/html/rfc7519](https://tools.ietf.org/html/rfc7519)):'
  prefs: []
  type: TYPE_NORMAL
- en: '**JWT** is a compact, URL-safe means of representing claims to be transferred
    between two parties. The claims in a **JWT** are encoded as a **JSON** object
    that is used as the payload of a **JSON Web Signature** (**JWS**) structure or
    as the plaintext of a **JSON Web Encryption** (**JWE**) structure, enabling the
    claims to be digitally signed or integrity protected with a **Message Authentication
    Code** (**MAC**) and/or encrypted.'
  prefs: []
  type: TYPE_NORMAL
- en: '**JWT** is used to carry information related to the identity and characteristics
    (**claims**) of the client bearing the token. JWT is a container and is signed
    by the server to avoid client tampering. This token is created during the authentication
    process and is verified by the authorization server before any processing. It
    is used by a resource server to allow a client to present a token representing
    its *identity card* to the resource server and allows the resource server to verify
    the validity and integrity of the token in a stateless, secure manner.'
  prefs: []
  type: TYPE_NORMAL
- en: Token structure
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The structure of a JWT adheres to the following three-part structure including
    a header, payload, and signature:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Encoded JWT
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The following code snippet is the complete encoded `access_token` that is returned
    based on the client request:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Header
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The encoded header for our `access_token` JWT is `base64` encoded, as shown
    in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'By decoding the encoded header, we have the following payload:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Payload
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The encoded payload for our `access_token` JWT is `base64` encoded, as shown
    here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'By decoding the encoded payload, we have the following payload claims:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Signature
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The encoded payload for our `access_token` has been encoded with a private
    key by the authorization server, as seen in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is pseudo code for the creation of a JWT signature:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: JWT Authentication in Spring Security
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Moving forward, let’s examine the architectural elements employed by `Spring
    Security` to facilitate **JWT** Authentication in servlet-based applications,
    similar to the one we previously discussed.
  prefs: []
  type: TYPE_NORMAL
- en: The `JwtAuthenticationProvider` serves as an implementation of `AuthenticationProvider`,
    utilizing a `JwtDecoder` and `JwtAuthenticationConverter` to validate a **JWT**
    during authentication.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s delve into the workings of `JwtAuthenticationProvider` within the
    context of `Spring Security`. The accompanying figure elucidates the intricacies
    of the `AuthenticationManager`, as illustrated in the figures depicting the process
    of reading the **Bearer Token**.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 17.3 – JWT Authentication in Spring Security](img/B21757_17_3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 17.3 – JWT Authentication in Spring Security
  prefs: []
  type: TYPE_NORMAL
- en: 'The JWT authentication in spring-security entails the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: The Authentication Filter, as part of the process outlined in reading the `BearerTokenAuthenticationToken`
    to the `AuthenticationManager`, which is implemented by `ProviderManager`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `ProviderManager` is set up to utilize an `AuthenticationProvider` of the
    `JwtAuthenticationProvider` type.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`JwtAuthenticationProvider` undertakes the tasks of decoding, verifying, and
    validating the `Jwt` through a `JwtDecoder`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Subsequently, `JwtAuthenticationProvider` employs the `JwtAuthentication` **Converter**
    to transform the **JWT** into a Collection of granted authorities.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Upon successful authentication, the returned Authentication takes the form of
    `JwtAuthenticationToken`, featuring a principal representing the `JwtDecoder`.
    Eventually, the `JwtAuthenticationToken` returned will be placed in the `SecurityContextHolder`
    by the Authentication Filter.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After covering the **OAuth 2** and **JWT** specifications we’ll take a closer
    look at how they’re implemented within spring-security.
  prefs: []
  type: TYPE_NORMAL
- en: OAuth 2 support in Spring Security
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`Spring Security` provides `Spring Framework` programming models and configuration
    idioms.'
  prefs: []
  type: TYPE_NORMAL
- en: In the following section we will identify the main components involved in **OAuth**
    **2** flow.
  prefs: []
  type: TYPE_NORMAL
- en: Resource owner
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The resource owner can be one or multiple sources, and in the context of the
    **JBCP calendar**, it is going to have the calendar application as the resource
    owner. The **JBCP calendar** will not have any specific configuration that is
    needed to denote its ownership aside from configuring the resource server.
  prefs: []
  type: TYPE_NORMAL
- en: Resource server
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Most of the resource server support is consolidated in `spring-security-oauth2-resource-server`.
    However, the decoding and verification of `spring-security-oauth2-jose`. Therefore,
    both components are essential for a functional resource server that can handle
    **JWT-encoded** **Bearer Tokens**.
  prefs: []
  type: TYPE_NORMAL
- en: 'In Spring Boot, setting up an application as a resource server involves two
    fundamental steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Firstly, include the necessary dependencies
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Secondly, specify the location of the authorization server.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Authorization server
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To enable the authorization server capability, we will use `Spring Authorization
    Server` that offers implementations of the `Authorization` `Server` products.
  prefs: []
  type: TYPE_NORMAL
- en: To initiate the utilization of `Spring Authorization Server`, the most straightforward
    approach is to build a `Spring Authorization Server` as a dependency as follow.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: Your code should now look like `chapter17.00-authorization-server`.
  prefs: []
  type: TYPE_NORMAL
- en: OAuth 2 resource minimal configuration properties
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Note that in the project `chapter17.00-calendar`, we already have added `spring-boot-starter-oauth2-resource-server`
    dependency, in addition to spring-security. This is important for our application
    in order to behave as a resource server.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'In a Spring Boot application, you can easily designate the authorization server
    to be used by following these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: 'The `issuer-uri` property to be effective, it’s essential that one of the following
    endpoints is a supported endpoint for the authorization server: `idp.example.com/issuer/.well-known/openid-configuration`,
    `idp.example.com/.well-known/openid-configuration/issuer`, or `idp.example.com/.well-known/oauth-authorization-server/issuer`.
    This endpoint is commonly referred to as either a Provider Configuration endpoint
    or an Authorization Server Metadata endpoint.'
  prefs: []
  type: TYPE_NORMAL
- en: Expectations at startup
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When employing this property and its associated dependencies, the Resource Server
    will autonomously set up its configuration to validate Bearer Tokens encoded in
    JWT format.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is accomplished through a predictable startup sequence:'
  prefs: []
  type: TYPE_NORMAL
- en: Interrogate the Provider Configuration or Authorization Server Metadata endpoint
    for the `jwks_url` property.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Examine the `jwks_url` endpoint for the supported algorithms.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Configure the validation strategy to query the `jwks_url` for valid **public
    keys** corresponding to the identified algorithms.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Configure the validation strategy to verify the `"iss"` claim of each `idp.example.com`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: An implication of this process is that the authorization server must be operational
    and capable of receiving requests for the Resource Server to initialize successfully.
  prefs: []
  type: TYPE_NORMAL
- en: Expectations during Runtime
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: After the application has been initiated, the `Resource Server` will endeavor
    to handle any request that includes an `Authorization:` `Bearer` header.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: As long as this scheme is specified, the resource server will strive to handle
    the request in accordance with the Bearer Token specification.
  prefs: []
  type: TYPE_NORMAL
- en: 'For a properly structured **JWT**, the resource server will:'
  prefs: []
  type: TYPE_NORMAL
- en: Validate its signature using a public key obtained from the `jwks_url` endpoint
    during startup, ensuring a match with the **JWT**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Verify the **JWT**’s **exp** and **nbf** timestamps, along with the **JWT**’s
    **iss** claim.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Associate each scope with an authority, using the prefix **SCOPE_**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Spring Security will automatically update and rotate the keys used to validate
    **JWT**s as the authorization server introduces new keys.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: Your code should now look like `chapter17.01-calendar`.
  prefs: []
  type: TYPE_NORMAL
- en: By default, the resulting `Authentication#getPrincipal` is a `Spring Security
    Jwt` object, and if available, `Authentication#getName` corresponds to the sub
    property of the **JWT**.
  prefs: []
  type: TYPE_NORMAL
- en: After defining `jwk-set-uri`.
  prefs: []
  type: TYPE_NORMAL
- en: Defining the JWK Set URI for the authorization server
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If the `jwk-set-uri` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: As a result, the `issuer-uri` to ensure that the resource server validates the
    `"iss"` claim within incoming **JWT**s.
  prefs: []
  type: TYPE_NORMAL
- en: Providing Audience Information
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As demonstrated earlier, the `issuer-uri` property verifies the `"iss"` claim,
    identifying the entity that sent the **JWT**.
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, `audiences` property for validating the `"aud"` claim, determining
    the intended recipients of the **JWT**.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can specify a resource server’s audience as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The outcome will be that if the `"iss"` claim of the `"aud"` claim does not
    include `my-resource-server.example.com` in its list, the validation will not
    succeed.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring Authorization using SecurityFilterChain
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A `Authorization Server` will usually contain a `scope` or `scp` attribute,
    signifying the granted scopes or authorities.
  prefs: []
  type: TYPE_NORMAL
- en: 'In such instances, the resource server will endeavor to transform these scopes
    into a roster of authorized authorities, adding the `SCOPE_` string as a prefix
    to each scope. Consequently, to secure an endpoint or method with a scope obtained
    from a **JWT**, the associated expressions should incorporate this prefix. For
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: Your code should now look like `chapter17.02-calendar`.
  prefs: []
  type: TYPE_NORMAL
- en: At this point, we can start the `chapter17.00-authorization-server` and `chapter17.02-calendar`
    and we will be ready to send **OAuth** **2** requests.
  prefs: []
  type: TYPE_NORMAL
- en: Token requests
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When we make the initial token request, we should get a successful response
    similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'And this is a sample response:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Specifically, we have been granted an access token that can be used in subsequent
    requests. The `access_token` that will be used as our bearer.
  prefs: []
  type: TYPE_NORMAL
- en: Endpoints requests
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now we will take the `access_token` and use that token to initiate additional
    requests to the server with the following format:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'We should get the following response:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Configuring Authorization using @PreAuthorize annotation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Another way to configure authorization can be done using `@``PreAuthorize` annotation.
  prefs: []
  type: TYPE_NORMAL
- en: 'First step is to enable method security in `SecurityConfig.java`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The next step is to secure `CalendarService.getEvents()` that is invoked by
    the `/``events` endpoint.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: Your code should now look like `chapter17.03-calendar`.
  prefs: []
  type: TYPE_NORMAL
- en: At this point, we can start the `chapter17.00-authorization-server` and `chapter17.03-calendar`
    and we will be ready to send **OAuth** **2** requests.
  prefs: []
  type: TYPE_NORMAL
- en: You can try again, the same previous steps for the `/token` and `/events` endpoints
    requests.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have our `OAuth 2 server` ready to issue `access_tokens` for clients,
    we now can create a microservices client to interact with our system.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring the OAuth 2 client
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now that we have configured our resource server, you can create REST client
    to consume the **OAuth2** protected resources.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use https://start.spring.io/ to initialize you project by choosing
    the following dependencies:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, you will need to configure your application with the client configuration
    as follow:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: For this example we will use `RestTemplate` and `ClientHttpRequestInterceptor`
    to bind the `OAuth2AccessToken` for our REST Client.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Making requests to a third-party `OAuth2AuthorizedClient` class in Spring Security,
    and gaining access to protected resources by inserting a Bearer token into the
    Authorization header of an outgoing request.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The provided example sets up the application to function as an **OAuth2** Client
    with the ability to request protected resources from a third-party **API**.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'The following `OAuth2HttpRequestInterceptor` can be defined as described in
    the sample code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The last step is to make the `RestTemplate` Bean:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: We now should have the same codebase for a client application.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: Your code should now look like `chapter17.03-calendar-client`.
  prefs: []
  type: TYPE_NORMAL
- en: We need to ensure that the `chapter17.03-calendar` and `chapter17.00-authorization-server`
    applications are running and ready to take **OAuth 2**requests from clients.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can then start the `chapter17.03-calendar-client` application, which will
    expose a RESTful endpoint that will call our resource server to access the configured
    events located at `/events` on the remote resource, and will return the following
    result by running `http://localhost:8888/`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you learned the general difference between monolithic applications
    and **microservices** and compared **SOA** with **microservices**. You also learned
    the conceptual architecture of **OAuth 2** and how it provides your services with
    trustworthy client access, and learned about the types of **OAuth 2** access tokens
    and the types of **OAuth 2 client** **credentials** types.
  prefs: []
  type: TYPE_NORMAL
- en: We examined the **JWT** and their general structure, implemented a **resource
    server** and **authorization server** used to grant access rights to clients to
    access **OAuth 2**resources, and implemented a **RESTful** client to gain access
    to resources through an **OAuth 2** **grant flow**.
  prefs: []
  type: TYPE_NORMAL
- en: We’ve concluded by demonstrating a practical **OAuth 2** example implementation
    using spring-security. Moving forward, the next chapter will explore the integration
    with **Central Authentication Service** (**CAS**) to enable **Single Sign-On**
    (**SSO**) and **Single Logout** (**SLO**) functionalities for your Spring Security-enabled
    applications.
  prefs: []
  type: TYPE_NORMAL
