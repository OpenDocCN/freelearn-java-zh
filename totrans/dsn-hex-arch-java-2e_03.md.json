["```java\n@addNetworkToRouter\nFeature: Add network to a router\nI want to be able to add a network to an existent router\nScenario: Adding a network to an existent router\nGiven I provide a router ID and the network details\nWhen I found the router\nAnd The network address is valid and doesn't already exist\nAnd The CIDR is valid\nGiven, When, And, and Then terms from the feature files, we need to create a test class to automate the validation of our use case steps:\n\n```", "```java\n\n First, we have to declare the types and initialize the objects we will use to perform our tests. In the preceding code, we declared the `RouterId` and `Router` types. Then, we initialized the `RouterNetworkFileAdapter` and `Network` instances.\nAfter preparing the resources we need to test, we can start by implementing the first step of our test:\n\n```", "```java\n\n The `@Given` annotation describes the retrieval of `RouterId`. We can use this ID to fetch a router:\n\n```", "```java\n\n By using `RouterNetworkFileAdapter` and `RouterId`, we retrieve a `Router` object. Next, we can check whether the `Network` object meets the desired requirements before adding it to the router:\n\n```", "```java\n\n To ensure the network is valid, we must apply the rules from `NetworkAvailabilitySpecification`. Next, we must check the network CIDR:\n\n```", "```java\n\n As the last verification step, we must apply the rules from `CIDRSpecification`. If everything is fine, then we can add the network to the router:\n\n```", "```java\n\n By calling the `addNetworkToSwitch` method from `Router`, we have added the network to the router.\nThe following is a visual representation of the formal, casual, and BDD-based types of use cases:\n![Figure 3.1 – A use case for the topology and inventory network system](img/B19777_03_01.jpg)\n\nFigure 3.1 – A use case for the topology and inventory network system\nFully dressed, casual, and BDD-based use cases express the same thing. The main difference lies not in the *what* but rather in *how* the three techniques achieve the same objective to describe system behavior. As we may expect, the best choice is conditioned to money, time, and organization constraints.\nWe could bypass this use case creation/process and go straight on to code the use case. Although I don’t consider the formal use case structuring part a required step, I certainly consider it a recommended one. By writing down and structuring the use case’s expected behaviors, we’re engaging in a valuable additional step to help us clarify and better organize our ideas regarding the use case’s arrangement. Once the structuring effort is made, we only need to translate that into its code counterpart.\nWhat I propose in developing hexagonal applications is to design use cases as abstractions rather than implementations. I am using interfaces in these examples, but there is no problem using abstract classes. The following code shows a use case interface based on its written form:\n\n```", "```java\n\n We define use cases as interfaces for three reasons:\n\n*   To provide different ways of fulfilling the use cases’ goals\n*   To allow dependency on abstraction rather than implementation\n*   For governance of APIs\n\nThe role of use cases in the hexagonal architecture is that they allow us to implement input ports. It’s through input ports that we construct the logic that will, for example, call Domain hexagon services, other use cases, and external resources through output ports. The UML representation of the use case and its input port is as follows:\n![Figure 3.2 – A use case for the topology and inventory network system](img/B19777_03_02.jpg)\n\nFigure 3.2 – A use case for the topology and inventory network system\nNow that we know how to create use cases, both in written and code form, let’s explore the ways to implement use cases with input ports.\nImplementing use cases with input ports\nIn the hexagonal architecture, there is this idea about driving and driven operations. We’ve seen that such classification is also valid to determine which actors interact with the hexagon system. Driving actors are the ones who send requests to the application, while the driven actors represent the external components accessed by the application. We use **input ports** – also known as **primary ports** – to allow the communication flow between driving actors and the driving operations exposed by a hexagonal system. Use cases tell us what behaviors the application will support, while input ports tell us how such behaviors will be performed.\nInput ports play an integrating role because they are like pipes that allow the data to flow from driving actors when they hit the hexagonal system through one of its adapters on the Framework hexagon. In the same vein, input ports provide the pipes for communication with business rules from the Domain hexagon. Through input ports, we also orchestrate communication with external systems through output ports and adapters.\nInput ports are at the crossroads of a hexagonal system, helping translate what comes from the outside and goes in the direction of the Domain and Application hexagons. Input ports are also essential in orchestrating communication with external systems. In the following diagram, we can see how **Application Hexagon** is the integration point between **Driving Actor** and **Driven Actor** and their respective input and output ports and adapters:\n![Figure 3.3 – The various ports and the Application hexagon](img/B19777_03_03.jpg)\n\nFigure 3.3 – The various ports and the Application hexagon\nIn the previous section, we defined a use case interface describing an operation that allowed us to add a network to a router. Let’s learn how to create an input port by implementing that use case:\n\n```", "```java\n\n With this input port implementation, we have a clear view of what actions the software must perform to fulfill the use case’s goal of adding a network to the router. Before we look closer at the input port methods, let’s consider the `RouterNetworkOutputPort` interface’s declaration:\n\n```", "```java\n\n This output port states that the application intends to obtain and persist data from external sources. The hexagon system is not aware of whether the external source is a database, a flat file, or another system. Here, we only state the intention to get data from outside.\nThe `addNetworkToRouter` method, which returns a `Router` object, is the only public method that’s exposed by the input port. We make all other methods private because they are not supposed to be used outside the context of this input port. The input port starts its job by using `RouterId` to retrieve a `Router` object; then, it creates a new `Network` object on that `Router` object. Remember, the `Network` object comprises the address, name, and CIDR attributes, as expressed in the use case’s written form. The `fetchRouter` method will try to obtain a `Router` object by passing a `RouterId` ID to the output port’s `fetchRouterById` method. That’s when the input port will need to coordinate an external call that will be carried out by an output adapter that implements the output port.\nIf everything goes well, the input port will receive the desired `Router` object and will be able to create a network object and add it to the informed router. At this point, the input port is interacting with a Domain service called `createNewNetwork`. This service works under the constraints imposed by business rules from the Domain hexagon. Finally, the input port coordinates the persistence of the whole operation through the `persistRouter` method from the output port.\nThis input port does not contain anything specific to the problem domain. Its primary concern is to handle data by orchestrating internal calls with Domain services and external calls with output ports. The input port sets the operation’s execution order and provides the Domain hexagon with data in a format it understands.\nExternal calls are interactions that are performed by the hexagonal application to get data from or persist data to external systems. This is the subject of the next section, where we’ll learn how to use output ports to deal with things living outside the application.\nUsing output ports to deal with external data\n**Output ports**, also known as **secondary ports**, represent the application’s intent to deal with external data. It’s through output ports that we prepare the system to communicate with the outside world. By allowing this communication, we can associate output ports with driven actors and operations. Remember, driven actors are external systems, while driven operations are used to communicate with such systems.\nI say that we’re preparing the hexagonal application to communicate with the outside world because, at the Application hexagon level, we don’t know how that communication will occur yet. This approach is based on Uncle Bob’s wise advice to postpone, as much as possible, any decisions concerned about which technologies will be used to fulfill the application’s needs. By doing that, we’re putting more emphasis on the problem domain than on technological details. I’m not saying that the persistence or messaging mechanisms, for example, are not relevant enough to influence the application’s design. Instead, the idea is to not let external technologies dictate how the application is designed.\nIn the early stages of a software project, it’s not uncommon to see people discussing whether to use PostgreSQL or Oracle databases for persistence, Kafka or Redis for pub-sub activities, and so on. Those types of discussions exert a strong influence on how the software solves business problems. Sometimes, it’s hard to imagine such software solving the same business problems but with different technologies. On certain occasions, it’s even inconceivable to consider such a thing because the whole application architecture is centered on specific technologies.\nAs people who work with technology, we’re always eager to use the hottest development framework or a modern programming language. That is a good attitude, and I think we should continuously pursue better techniques and sophisticated ways to solve problems. But prudence is advised to properly balance our focus between the technology and problem domain aspects of a system.\nIt’s not only about repositories\nYou may be used to using terms such as repository or **data access object** (**DAO**) to describe application behaviors related to persistence in a database. In hexagonal applications, we replace repositories with output ports.\nRepositories are often associated with database operations, a fact that, by the way, is also enforced by some development frameworks that formalize this association through persistence features offered by the framework. A recurring example of this approach is similar to the following code:\n\n```", "```java\n\n The usage of the `JpaRepository` interface and the `@Query` annotation from the Spring framework reinforces the notion that the password data will come from a relational database. This situation could also be seen as a leaking abstraction condition because our `PasswordResetTokenRepository` interface would also contain all the methods inherited from the `JpaRepository` class that may not be relevant or provide behaviors that don’t suit the system’s needs.\nThe underlying idea about output ports is that we’re not inferring that persistence or any kind of external communication will occur with a database system. Instead, the output port’s scope is broader. Its concern is with communicating with any system, be it a database, a messaging system, or a local or network filesystem, for example.\nA more hexagonal approach to the password reset interface shown previously would look something like the following code:\n\n```", "```java\n\n By not extending types from a specific framework and avoiding the usage of annotations such as `@Query`, we’re turning the output port into a POJO. The usage of annotations per se is not a problem. The issue lies more in the purpose of their usage. If the aim is to use annotations to implement features that only exist in a particular framework, we are then coupling the software to that framework. Instead, if the purpose is to use annotations to implement features based on Java standard specifications, we are making a valuable effort to make the software more tolerant to change.\nThe data that’s obtained from an output port today may come directly from a relational database. Tomorrow, this same data can be obtained from the REST API of some application. Those details are not necessary from the Application hexagon’s perspective because the components in this hexagon are not concerned with how the data is obtained.\nTheir main concern is in expressing what kind of data they need to conduct their activities. The way those Application hexagon components define what data they need is based on the entity and value objects from the Domain hexagon. With this arrangement, where an output port states what type of data it needs, we can plug multiple adapters into the same output port. So, these adapters carry out the necessary tasks to obtain the data, as expressed by the output port. This flow is shown in the following diagram:\n![Figure 3.4 – The output port and its adapters](img/B19777_03_04.jpg)\n\nFigure 3.4 – The output port and its adapters\nThe output port’s main goal is to state what kind of data it needs without specifying how it will get that data. That’s the reason why we define them as interfaces and not implementations. The implementation part is reserved for output adapters, an essential hexagonal architecture component that we’ll look at in the next chapter. To conclude our analysis of output ports, let’s explore where they should be used.\nWhere to use output ports\nAt the beginning of this chapter, we learned how use cases establish the necessary actions to accomplish something useful in the application. Among these actions, there may be situations that require us to interact with external systems.\nSo, the reason to create and utilize output ports will be derived from the activities performed by use cases. In code, the reference for an output port will not appear in the use case’s interface declaration. The usage of output ports is made explicit when we implement the use case with an input port. That’s what we did when we implemented `RouterNetworkUseCase` and declared a `RouterNetworkOutputPort` attribute at the beginning of `RouterNetworkInputPort`:\n\n```", "```java\n\n You may be wondering when and how the instance for an output port is created. The previous example shows one approach, where the input port constructor receives a reference for an output port object. This object will be an implementation provided by an output adapter.\nAmong the operations defined by a use case and implemented by an input port, some operations are responsible for getting data from or persisting data to external sources. That’s where output ports come in: to provide the data required to fulfill the use case’s goal.\nIn the same way that a use case goal is used to represent a piece of software’s intent, without saying how this intent will be realized, output ports do the same thing by representing what kind of data the application needs, without needing to know how that data will be obtained. Output ports, along with input ports and use cases, are the hexagonal architecture components that support the automation effort that characterizes the Application hexagon. We’ll examine this in the next section.\nAutomating behavior with the Application hexagon\n**Automation** is one of the most valuable things software can do. The advent of computation brought radical changes to how people solve their problems. An interesting scenario is that of the credit card industry in its early years. When banks started to offer credit cards to their customers, most of the back-office activities were done manually. If you wanted to pay for something with a credit card, the person in the store would need to call their bank, who, in turn, would need to contact your card issuer to confirm you had credit. As the technology evolved, computer systems were able to automate this credit verification process.\nIf we decided to use the hexagonal architecture to build a credit card verification system, those required steps to confirm the cardholder’s credit could be expressed using a use case. With an input port, we could handle business rules and all the data necessary to achieve the use case goal, consuming, if necessary, external systems through an output port. When we put all those activities together, the fundamental role of the Application hexagon in automating those activities to fulfill the system’s intent becomes more apparent. Here’s a code example to illustrate how the credit verification process would look in the Application hexagon:\n\n1.  We start by creating a `CreditCard` entity class:\n\n    ```", "```java\n\n    The preceding code only emphasizes the credit availability aspect. So, we have the `availableCredit` attribute and the `isAvailableCreditGreaterOrEqualThan` method to check that there’s enough credit for a given transaction.\n\n     2.  Then, we declare the `CreditCheckUseCase` interface:\n\n    ```", "```java\n\n    The goal is to check whether the credit card has enough credit for the transaction amount. To do so, we expect the `cardId` and `transactionAmount` attributes. We intend to use `cardId` to get credit card data from somewhere. So, having an output port is required to get data from other places.\n\n     3.  Here, we declare `CreditCheckOutputPort`:\n\n    ```", "```java\n\n    This is a straightforward output port where we pass the `cardId` attribute and expect the `CreditCard` object to contain, among other things, how much credit is available.\n\n     4.  Suppose credit card data is stored in a MySQL database. We would need an output adapter that implements the previously defined output port:\n\n    ```", "```java\n\n    Inside the `getCreditCard` method, we would probably have some sort of mapping mechanism to convert the data that’s retrieved from the database into the domain entity object – that is, `CreditCard`.\n\n     5.  Finally, we can create the input port by implementing the `CreditCheckUseCase` interface:\n\n    ```", "```java\n\n    `CreditCheckInputPort` relies on `CreditCheckOutputPort` to get `CreditCard`, which is used in the `hasEnoughCredit` method, to check whether there is enough credit available.\n\nOne advantage of implementing the Application hexagon is that we don’t need to be specific about which technologies we should use to fulfill the automation needs of our system. Of course, it’s possible to add a fancy development framework to make our lives easier when handling certain activities–such as object life cycle management, which is provided by **Contexts and Dependency Injection** (**CDI**) mechanisms – but it’s that purist approach of not focusing on technological details that makes hexagon systems easier to integrate with different technologies.\nAs we continue exploring the possibilities offered by the hexagonal architecture, we’ll see that using a development framework is not a central point for software development. Instead, in hexagonal systems, frameworks are like ordinary utilitarian libraries that we use to strategically solve a specific problem.\nSummary\nIn this chapter, we learned how to arrange the components that are responsible for organizing and building the features provided by the software. By looking into use cases, we grasped the fundamental principles to translate the behaviors that allow a system to meet users’ goals into code. We discovered how input ports play a central role by implementing use cases and acting as middlemen, intermediating the communication flow between internal and external things. With output ports, we can express the need for data from external sources without coupling the hexagonal system with specific technologies. Finally, by using use cases and input and output ports together, we saw how the Application hexagon supports the software’s automation effort.\nBy learning how to arrange things inside the Application hexagon, we can now combine business rules, entities, Domain services, use cases, and other components from both the Application and Domain hexagons to create fully fledged features in the hexagon application, ready to be integrated with different technologies. Such integration can be accomplished with the so-called adapters in the Framework hexagon. That’s what we will look at in the next chapter.\nQuestions\nAnswer the following questions to test your knowledge of this chapter:\n\n1.  What is the purpose of use cases?\n2.  Input ports implement use cases. Why do we have to do that?\n3.  Where should output ports be used?\n4.  What is the advantage of implementing the Application hexagon?\n\nFurther reading\nTo learn more about the topics that were covered in this chapter, take a look at the following resources:\n\n*   *Writing Effective Use Cases* (Alistair Cockburn, 2000)\n*   *Clean Architecture* (Robert Cecil Martin, 2017)\n\nAnswers\nThe following are the answers to this chapter’s questions:\n\n1.  It’s to define software behaviors by establishing who the actors are and what features they expect from a system.\n2.  Because in the hexagonal architecture, use cases are interfaces that state the supported software capabilities. Input ports, in turn, describe the actions that will enable those capabilities.\n3.  Output ports appear inside input ports when it is necessary to interact with external systems.\n4.  By implementing the Application hexagon, we’re supporting the overall hexagonal application’s effort to automate operations without relying on specific technologies to do so.\n\n```"]