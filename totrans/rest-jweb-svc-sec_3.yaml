- en: Chapter 3. Security Management with RESTEasy
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Welcome to the third chapter. We hope you are enjoying and learning with us.
    In this chapter, you will get more involved with security management. You will
    also work with some more advanced security concepts.
  prefs: []
  type: TYPE_NORMAL
- en: Security management in applications built with RESTful web services can be more
    granular than what we reviewed in the previous chapter. If we think around authentication
    and authorization topics, we described the former; authorization was set aside.
    This is because we want to treat it slowly and in a very detailed level in this
    chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'The topics covered in this chapter are:'
  prefs: []
  type: TYPE_NORMAL
- en: Implementing security restrictions related to authentication and authorization
    in to an application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing fine-grained security
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using annotations to obtain more granularity over resource access control
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fine-grained and coarse-grained security
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are two levels of security we can manage: **fine-grained** and **coarse-grained**.'
  prefs: []
  type: TYPE_NORMAL
- en: When we mention the term coarse-grained in the context of security, we refer
    to security systems that are generally handled at high levels within the application.
    The examples in [Chapter 2](ch02.html "Chapter 2. The Importance of Securing Web
    Services"), *The Importance of Securing Web Services*, in which a user with any
    role can make use of the services, is a perfect example of coarse-grained because
    the coarse-grained option is used when the security restrictions give access to
    users without worrying about roles or more specific features about the authenticated
    user. This means that in order for the system to allow access to functions, we
    just verify the user identity; in other words, it authenticates the user. However,
    it is not enough to have an authenticated user of the application in real life.
    It will also be necessary that the user is authorized to use certain features.
    We can achieve this using fine-grained controls. Validating the user's assigned
    permissions to access functions means using authorization controls.
  prefs: []
  type: TYPE_NORMAL
- en: 'To demonstrate these concepts in a practical way, we will make use of the application
    we created in the previous chapter. You can access the source code on GitHub at
    the following URL, under the basic authentication section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/restful-java-web-services-security/source-code/tree/master/chapter02/basic-authentication](https://github.com/restful-java-web-services-security/source-code/tree/master/chapter02/basic-authentication)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start; suppose we want only users with the role `administrator` to be
    able to make use of the features in our application. The first thing to do is
    to change the `web.xml` file and add a constraint as follows. Note how the changes
    appear in bold:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Now, let's try to make the request using the user we just created (`username`).
    You will be surprised when you get a `403 Forbidden` error.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that if you try to make the request with invalid credentials, you will
    get the error `HTTP/1.1 401 Unauthorized`. The error is pretty clear; the access
    is unauthorized. This means that we have sent invalid credentials, and hence the
    user can''t be authenticated. The error we just got is `HTTP/1.1 403 Forbidden`,
    which indicates that the user was successfully logged in but was not authorized
    to use the functionality that they require. This is demonstrated in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Fine-grained and coarse-grained security](img/0109OS_03_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, let''s create a new user with the role `administrator` using the `JBOSS_HOME/standalone/bin/adduser.sh`
    file. Enter the requested information as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Fine-grained and coarse-grained security](img/0109OS_03_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'When we change the credentials in SoapUI, the result of the request is successful,
    as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Fine-grained and coarse-grained security](img/0109OS_03_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, we used an additional control in which we restricted only authenticated
    users with the `administrator` role assigned to them; they are capable of using
    the web service functions. It is very common to use these kinds of controls when
    managing security on real-world applications. As we have implemented a more detailed
    level of control, the platform offers us the opportunity to implement more granular
    controls, such as the ones we will see right now.
  prefs: []
  type: TYPE_NORMAL
- en: Securing HTTP methods
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One of the benefits of JAAS is that we have control even at the level of HTTP
    methods. Thus, we can implement security controls to allow only users with a certain
    role to use certain methods with regards to our convenience; for example, one
    role to save information, another to delete it, others to read it, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: To implement these kinds of controls, it is necessary that we understand the
    HTTP methods' functionality in the application. In our example, we already know
    that in order to save information, the application always uses the `HTTP POST`
    method. Also, when we want to read information, the application uses the `HTTP
    GET` method. Therefore, we will modify our example so that only users with the
    `administrator` role are able to use the `savePerson` (`HTTP POST`) method. Meanwhile,
    only those with the `reader` role will be able to read information using the `findById`
    (`HTTP GET`) method.
  prefs: []
  type: TYPE_NORMAL
- en: 'With this as our objective, we will modify our `web.xml` file as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Before we continue, we must create a new user (`readeruser`) with the role `reader`
    using the `JBOSS_HOME/standalone/bin/adduser.sh` script.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's test the roles and their permissions using SoapUI.
  prefs: []
  type: TYPE_NORMAL
- en: HTTP method – POST
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We are going to test the `POST` method using a role that doesn't have the required
    permissions. You will see the permission error message.
  prefs: []
  type: TYPE_NORMAL
- en: 'Role: Reader'
  prefs: []
  type: TYPE_NORMAL
- en: 'This method is not allowed when using this role. This is demonstrated in the
    following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![HTTP method – POST](img/0109OS_03_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Role: Administrator'
  prefs: []
  type: TYPE_NORMAL
- en: 'With this role, you can execute the method successfully. This is demonstrated
    in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![HTTP method – POST](img/0109OS_03_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: HTTP method – GET
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now, we are going to use a user with the required permissions to use the GET
    method. The execution should be successful with this role.
  prefs: []
  type: TYPE_NORMAL
- en: 'Role: Reader'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, the execution is successful with this role. This is demonstrated in the
    following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![HTTP method – GET](img/0109OS_03_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Role: Administrator'
  prefs: []
  type: TYPE_NORMAL
- en: 'The admin role does not have access to this method. This is demonstrated in
    the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![HTTP method – GET](img/0109OS_03_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The same consideration of roles can be used for URL patterns. In our example,
    we apply the restriction on the `/services/*` pattern. However, you can apply
    it at a deeper level, for example `/services/person/*`. We mean that if we had
    another service that is exposed under the URL `/services/other-service/`, we can
    set it so that a role has access to services under the path `/services/person/*`
    and different levels of access under the path `/services/other-service/*`. This
    example is quite simple and is proposed as a basic example to the reader.
  prefs: []
  type: TYPE_NORMAL
- en: After applying all the changes, we set security over all methods listed in the
    `web.xml` file. However, we must ask ourselves a question; what happens with the
    methods that haven't been included?
  prefs: []
  type: TYPE_NORMAL
- en: 'The OWASP (Open Web Application Security Project), a nonprofit organization
    dedicated to finding and fixing security holes in software, has written a paper
    on this, and it is called the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Bypassing Web Authentication and Authorization with HTTP Verb Tampering: How
    to inadvertently allow attackers full access to your web application.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to check out the complete document, you can do so by accessing
    the following link:'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://dl.packetstormsecurity.net/papers/web/Bypassing_VBAAC_with_HTTP_Verb_Tampering.pdf](http://dl.packetstormsecurity.net/papers/web/Bypassing_VBAAC_with_HTTP_Verb_Tampering.pdf)'
  prefs: []
  type: TYPE_NORMAL
- en: What the OWASP describes in the aforementioned document is simple. It shows
    that JEE exposes potential security gaps in the `web.xml` configuration file if
    we don't take certain precautions as all methods that are not listed in the file
    can be used without any restrictions. This means that a user that hasn't been
    authenticated in the application can invoke any other HTTP method.
  prefs: []
  type: TYPE_NORMAL
- en: 'The OWASP states the following in the earlier article:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Unfortunately, almost all the implementations of this mechanism work in an
    unexpected and insecure war. Rather than denying methods not specified in the
    rule, they allow any method not listed. Ironically, by listing specific methods
    in their rule, developers are actually allowing more access than they intended.*'
  prefs: []
  type: TYPE_NORMAL
- en: In order to understand this in a better way, let's focus on an analogy.
  prefs: []
  type: TYPE_NORMAL
- en: Suppose you have a web application to write books that handles two roles—one
    for authors who are able to write the pages of the books and another for reviewers
    who can only read the books and add notes with comments. Now, suppose a user ends
    up getting the URL of your application by mistake. This user does not have any
    credentials to deliver, and the obvious thing is that the user should not even
    be able to access the application. However, the problem that is demonstrated by
    the OWASP is that instead of doing what seems obvious, it actually enables application
    access to unauthenticated users with enough permission to perform any operation
    on the books, such as removing them.
  prefs: []
  type: TYPE_NORMAL
- en: Let's take an example in order to see this inconvenience, and after that, we
    will implement OWASP's suggestions to solve it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create a new method within the class `PersonService`; we''ll use one
    of the methods that has not been listed in the `web.xml` file this time. One of
    the most used methods is `HTTP DELETE`; its functionality is to remove one of
    the entries stored in memory using its ID. This will pass the ID of the record
    as a parameter in the URL, so the URL of the request will look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`http://localhost:8080/resteasy-examples/services/person/[ID]`'
  prefs: []
  type: TYPE_NORMAL
- en: 'The method implementation should look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'In order to test the method, we must first create a couple of registers through
    SoapUI, also using the `HTTP POST` method and a string such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, select the `DELETE` method in SoapUI, remove the information on the credentials
    we use for authentication, and perform a request using one of the item IDs, as
    shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![HTTP method – GET](img/0109OS_03_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, the item was removed and the server returns the message `HTTP/1.1
    410 Gone`. This indicates that the resource is no longer available. As you have
    noted, when we don't specify that this method should be protected by default,
    it is marked as available. In our case, any user without the need to authenticate
    can remove our application resources.
  prefs: []
  type: TYPE_NORMAL
- en: 'To overcome this drawback, the OWASP recommends adding another security constraint
    in the `web.xml` file. This new security constraint should not have any HTTP method
    listed within itself, which means denying access to all HTTP methods, as shown
    in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Also, we will have to add a new role in order to determine an authenticated
    user in the application, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Now, we run the request from SoapUI, and we can see the error message `HTTP/1.1
    401 Unauthorized`. This indicates that you cannot execute the request because
    the user has not been authenticated, which in turn means that unauthenticated
    users cannot use the `DELETE` or any other method.
  prefs: []
  type: TYPE_NORMAL
- en: Fine-grained security implementation through annotations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `web.xml` file, the file that allows all security settings, is not the
    only way in which you can achieve fine-grained security implementation; the platform
    also offers the possibility of using annotations for security checks. To do this,
    there are three options that can be chosen depending on your needs, listed as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`@RolesAllowed`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@DenyAll`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@PermitAll`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The @RolesAllowed annotation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `@RolesAllowed` annotation can be applied at the method or class level.
    With this annotation, you can define a set of roles that are allowed to use the
    annotated resource. As a parameter annotation, let''s write all allowed roles.
    For this example, we will modify our `web.xml` file as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'In the class `PersonService`, let''s use the annotation on every method with
    the roles we want to be able to execute the method, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: It is now time to test it through SoapUI.
  prefs: []
  type: TYPE_NORMAL
- en: The savePerson method
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now, we will test the `savePerson` method of the `PersonService` class with
    the admin role, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The savePerson method](img/0109OS_03_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The execution was successful, as you can see in the preceding screenshot. The
    reason is because we included both roles in the `@RolesAllowed` annotation. Also,
    we will test the execution using the `reader` role for it to be successful, as
    shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The savePerson method](img/0109OS_03_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, we grant permissions to specific roles when we use the annotation
    `@RolesAllowed`. For this method, we used `administrator` and `reader`.
  prefs: []
  type: TYPE_NORMAL
- en: The findById method
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'We will now test the method `findById` with the `administrator` role, as shown
    in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The findById method](img/0109OS_03_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The screenshot shows that the execution was successful because the `@RolesAllowed`
    annotation includes admin. As we didn''t include the `reader` role, the next execution
    should not be authorized. Let''s test it right now, as shown in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The findById method](img/0109OS_03_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Once again, we used the annotation `@RolesAllowed` to grant permissions at a
    method level, but this time we specified just one role, `administrator`.
  prefs: []
  type: TYPE_NORMAL
- en: 'All the source code for this chapter can be found at the following URL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/restful-java-web-services-security/source-code/tree/master/chapter03](https://github.com/restful-java-web-services-security/source-code/tree/master/chapter03)'
  prefs: []
  type: TYPE_NORMAL
- en: The @DenyAll annotation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `@DenyAll` annotation allows us to define operations that cannot be invoked
    regardless of whether the user is authenticated or the roles are related to the
    user. The specification defines this annotation as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Specifies that no security roles are allowed to invoke the specified method(s)
    - i.e. that the methods are to be excluded from execution in the J2EE container.*'
  prefs: []
  type: TYPE_NORMAL
- en: The @PermitAll annotation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When we use the `@PermitAll` annotation, we tell the container that the annotated
    resource (a method or all methods of the class) can be invoked by any user who
    has logged in to the application. This means that it is only necessary that the
    user be authenticated; it's not required to have any specific role assigned.
  prefs: []
  type: TYPE_NORMAL
- en: From these three annotations, the most used is undoubtedly the first one (`@RolesAllowed`);
    the others aren't often used since `@PermitAll` can be easily replaced in the
    `web.xml` file, and `@DenyAll` can be used only in few scenarios.
  prefs: []
  type: TYPE_NORMAL
- en: Programmatical implementation of fine-grained security
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: RESTEasy, besides providing options for security management that we have seen,
    programmatically provides an additional mechanism for access control.
  prefs: []
  type: TYPE_NORMAL
- en: 'Within the operations of web services, you can add an additional parameter
    to the method. This allows access to the security context, without altering the
    way clients invoke the method or the action that the method executes. The parameter
    must be included in the following way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Suppose that in our example, in the method `savePerson`, we want access to this
    functionality. The only change we need to make is shown in the following code
    snippets.
  prefs: []
  type: TYPE_NORMAL
- en: 'Earlier, the method used just one parameter, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, the method has another parameter, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The interface `javax.ws.rs.core.SecurityContext` offers the following three
    interesting features:'
  prefs: []
  type: TYPE_NORMAL
- en: '`isUserInRole()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`getUserPrincipal()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`isSecure()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The functionality of the method `isUserInRole ()` is similar to the annotation
    `@RolesAllowed`; its goal is to perform a check in order to determine if a logged
    user belongs to a specified role, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The `getUserPrincipal()` method obtains the primary user in the application,
    in other words, the logged user. You can obtain information such as the username
    that represents it through this user; this is always useful in scenarios in which
    you want to generate audit trails.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the method `isSecure()` determines whether the invocation is being
    made through a secure means of communication, such as whether you are using HTTPS.
  prefs: []
  type: TYPE_NORMAL
- en: As you know, HTTP and HTTPS are protocols to exchange information; the former
    is usually used when you share information that is not sensitive, and the latter
    is often used when the information is sensitive and we need a secure channel.
  prefs: []
  type: TYPE_NORMAL
- en: Let's imagine the web portal of ABC Bank, particularly the home page where it
    shows information about services and stuff related to the bank's business that
    can be managed with HTTP. We can't manage the web pages that work with information
    about accounts or money transfers with the HTTP protocol; this is because the
    information is not protected. Through the HTTPS protocol, we can encrypt the information;
    when the information is intercepted by a traffic analyzer such as Wireshark, it
    can't be interpreted.
  prefs: []
  type: TYPE_NORMAL
- en: This functionality can be tested by applying the changes to the project to enable
    HTTPS, as we show you in [Chapter 2](ch02.html "Chapter 2. The Importance of Securing
    Web Services"), *The Importance of Securing Web Services*.
  prefs: []
  type: TYPE_NORMAL
- en: When you invoke this method using HTTP, the result will be false, but it will
    be true when you invoke the same method using HTTPS.
  prefs: []
  type: TYPE_NORMAL
- en: These three methods we just analyzed are very useful when we want to implement
    fine-grained security checks. For example, when we want to implement an audit,
    we can determine if one action was executed using a transmission secure protocol
    such as HTTPS; also, we can discover information about the user that is executing
    the action.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The needs that we have when implementing application security can be quite varied.
    In this chapter, we saw how JAX-RS offers mechanisms to handle security, starting
    from a fairly basic model (coarse-grained) to a more elaborate one (fine-grained)
    in which you can perform more exhaustive controls, including programmatic controls
    and controls through configuration files.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, it is always recommended to keep these checks in configuration files
    such as `web.xml`. Since you have the controls centralized in one place, it facilitates
    maintenance. This does not occur when security is handled at the level of source
    code, because when there are many classes that are part of the project, the tasks
    get complicated when some form of modification to the current functionality is
    required.
  prefs: []
  type: TYPE_NORMAL
- en: Now, you should prepare for the next chapter, in which we will talk about OAuth.
    It's a very exciting topic because this protocol is widely accepted and used across
    Internet applications. The rockstar companies of the World Wide Web, such as Google,
    Twitter, and Facebook, among others, use it with great success.
  prefs: []
  type: TYPE_NORMAL
