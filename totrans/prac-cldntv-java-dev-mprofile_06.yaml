- en: '*Chapter 4*: Developing Cloud-Native Applications'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: MicroProfile 4.1 builds on some **Jakarta EE** (formerly **Java Enterprise Edition**)
    **application programming interfaces** (**APIs**)—specifically, **Jakarta RESTful
    Web Services** (**JAX-RS**), **Jakarta Contexts and Dependency Injection** (**CDI**),
    **JavaScript Object Notation Processing** (**JSON-P**), and **JSON Binding** (**JSON-B**).
    Using only these technologies, it is possible to develop a perfectly capable cloud-native
    application. The MicroProfile community added a type-safe mechanism for invoking
    RESTful services known as the **MicroProfile Rest Client**. These technologies
    are essential for building Java-based microservices that can interoperate in the
    cloud. Learning to use these technologies will enable you to build robust and
    secure Java microservices.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will explore all of the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: Developing a RESTful service with JAX-RS
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Managing the payload with JSON-P and JSON-B
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Consuming RESTful services with the MicroProfile Rest Client
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Managing life cycle and **dependency injection** (**DI**) with CDI
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This chapter covers a wide spectrum of technologies and the functionality within
    each technology. When you have finished this chapter, you should have a broad
    and deep understanding of how to build reliable, robust RESTful applications that
    can communicate with each other using JSON.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In order to build and run the samples mentioned in this chapter, you will need
    a Mac or PC (Windows or Linux) with the following software:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
- en: '**Java Development Kit** (**JDK**) version 8 or higher ([http://ibm.biz/GetSemeru](http://ibm.biz/GetSemeru))'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Apache Maven ([https://maven.apache.org/](https://maven.apache.org/))
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A Git client ([https://git-scm.com/](https://git-scm.com/))
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All of the source code used in this chapter is available on GitHub at [https://github.com/PacktPublishing/Practical-Cloud-Native-Java-Development-with-MicroProfile/tree/main/Chapter04](https://github.com/PacktPublishing/Practical-Cloud-Native-Java-Development-with-MicroProfile/tree/main/Chapter04).
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Once you have cloned the GitHub repository, you can start the Open Liberty
    server that these code samples will execute in by entering the `Chapter04` directory
    and running the following command from the command line:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: You can then stop the server in the same command window by pressing *Ctrl +
    C*.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: Now we've got the prerequisites taken care of, let's start by building a basic
    RESTful service.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: Developing a RESTful service with JAX-RS
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will develop a few RESTful services using JAX-RS. We'll
    start with a simple example, and then we'll add more complex and powerful techniques
    such as exception handling, advanced conversion of **HyperText Transfer Protocol**
    (**HTTP**) data into Java objects (and vice versa), cross-cutting concerns, asynchronous
    methods, and DI.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: JAX-RS is built around the idea of a **request-response** pipeline. On the server
    side, an HTTP request enters the pipeline, then the JAX-RS server invokes any
    pre-matching **filters** on the request. It then attempts to match the request
    with a JAX-RS **resource method**.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: JAX-RS 是围绕 **请求-响应** 管道这一理念构建的。在服务器端，一个 HTTP 请求进入管道，然后 JAX-RS 服务器在请求上调用任何预匹配的
    **过滤器**。然后它尝试将请求与 JAX-RS **资源方法** 匹配。
- en: 'When the JAX-RS container receives an incoming request, it will perform the
    following process:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 当 JAX-RS 容器收到一个传入请求时，它将执行以下过程：
- en: Invoke any registered pre-matching filters.
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用任何已注册的预匹配过滤器。
- en: Attempt to match the request to a `resource` method. If no match can be made,
    the container will respond with an appropriate `not found` HTTP response.
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 尝试将请求与 `resource` 方法匹配。如果无法匹配，容器将响应适当的 `not found` HTTP 响应。
- en: Invoke any registered post-matching filters.
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用任何已注册的匹配后过滤器。
- en: Perform conversion of HTTP data (such as the HTTP entity payload or parameters,
    headers, and so on) into Java objects consumable by the resource method if necessary.
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果需要，执行 HTTP 数据（如 HTTP 实体有效负载或参数、头等）到资源方法可消费的 Java 对象的转换。
- en: Invoke the `resource` method.
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用 `resource` 方法。
- en: Perform exception handling, if necessary.
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果需要，执行异常处理。
- en: Invoke any registered response filters.
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用任何已注册的响应过滤器。
- en: Perform conversion of Java object(s) to HTTP response data, if necessary.
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果需要，执行 Java 对象到 HTTP 响应数据的转换。
- en: Return the HTTP response to the client.
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 HTTP 响应返回给客户端。
- en: 'This pipeline flow is illustrated in the following diagram:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表展示了该管道流程：
- en: '![Figure 4.1 – JAX-RS server pipeline flow'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 4.1 – JAX-RS 服务器管道流程](img/Figure_4.1_-_B17377.jpg)'
- en: '](img/Figure_4.1_-_B17377.jpg)'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_4.1_-_B17377.jpg)'
- en: Figure 4.1 – JAX-RS server pipeline flow
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.1 – JAX-RS 服务器管道流程
- en: 'In JAX-RS, there are three types of components, outlined as follows:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在 JAX-RS 中，有三种类型的组件，如下概述：
- en: '**Resources**: The resources are what ultimately make the RESTful service what
    it is as they contain the business logic.'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**资源**：资源是使 RESTful 服务成为其自身的最终因素，因为它们包含业务逻辑。'
- en: '`MessageBodyReader`, `MessageBodyWriter`, `ParamConverter`, `ExceptionMapper`,
    `ReaderInterceptor`, and `WriterInterceptor` are all providers.'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MessageBodyReader`、`MessageBodyWriter`、`ParamConverter`、`ExceptionMapper`、`ReaderInterceptor`
    和 `WriterInterceptor` 都是提供者。'
- en: '`Application` subclass is used to provide configuration for the JAX-RS application.'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `Application` 子类来为 JAX-RS 应用程序提供配置。
- en: Now we understand the basic flow, let's create a simple JAX-RS application.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了基本流程，让我们创建一个简单的 JAX-RS 应用程序。
- en: Hello World!
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Hello World！
- en: 'A JAX-RS application must contain at least one resource class. Providers are
    optional. An `Application` subclass is only necessary if you don''t have a `web.xml`
    file that specifies an application path. So, a very simple application might look
    like this:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 JAX-RS 应用程序必须至少包含一个资源类。提供者可选。只有在没有指定应用程序路径的 `web.xml` 文件时，才需要 `Application`
    子类。因此，一个非常简单的应用程序可能看起来像这样：
- en: '[PRE1]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: If we build this code into a web application called `myApp.war` and deploy it
    into a JAX-RS container such as Open Liberty, we could quickly test it using an
    HTTP client by browsing to `http://localhost:9080/myApp/rest/hello` and we would
    see the text **Hello World!**.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将此代码构建成一个名为 `myApp.war` 的 Web 应用程序，并将其部署到 Open Liberty 等JAX-RS 容器中，我们可以通过浏览到
    `http://localhost:9080/myApp/rest/hello` 来快速使用 HTTP 客户端测试它，我们会看到文本 **Hello World**！。
- en: This works because the `@GET` annotation on the `helloWorld()` method tells
    the JAX-RS container that this method should be invoked when a client issues a
    `GET` request to the `/hello` path of the `/rest` application path under the `.war`
    extension. By default, most HTTP clients (browsers, `curl`, and so on) use `GET`
    unless specified otherwise. This brings up a good point about tooling. When developing
    RESTful applications, it is extremely valuable to have a client tool that can
    issue different types of HTTP requests. Command-line tools such as `curl` are
    very useful, and there are several browser extension-based tools that would also
    work.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 这之所以有效，是因为 `helloWorld()` 方法上的 `@GET` 注解告诉 JAX-RS 容器，当客户端向 `/rest` 应用程序路径下的
    `.war` 扩展名的 `/hello` 路径发出 `GET` 请求时，应该调用此方法。默认情况下，大多数 HTTP 客户端（浏览器、`curl` 等）使用
    `GET`，除非指定其他方式。这提出了关于工具的一个很好的观点。在开发 RESTful 应用程序时，拥有一个可以发出不同类型 HTTP 请求的客户端工具非常有价值。命令行工具如
    `curl` 非常有用，还有基于浏览器扩展的工具也可以使用。
- en: A more real-world example
  id: totrans-45
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 一个更贴近现实世界的例子
- en: 'Now we have built a simple JAX-RS application, let''s build a more complex
    application—a thesaurus service where clients can search and update synonyms.
    We''ll start with an **exception mapper**, as follows:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经构建了一个简单的 JAX-RS 应用程序，让我们构建一个更复杂的应用程序——一个同义词服务，客户端可以搜索和更新同义词。我们将从一个 **异常映射器**
    开始，如下所示：
- en: '[PRE2]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Most applications will have `NoSuchWordException` exception, which could be
    used to indicate that a searched word does not exist. It is clear in the application
    that somebody specified a word that does not exist, but it is not clear to an
    HTTP client. The `NoSuchWordExceptionMapper` provider class makes that possible.
    It enables the resource class methods to throw a `NoSuchWordException` exception,
    and the JAX-RS container will map the exception to an HTTP response (in this case,
    a `404 Not Found` error).
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数应用程序都会遇到 `NoSuchWordException` 异常，该异常可以用来指示搜索的单词不存在。在应用程序中，有人指定了一个不存在的单词是明确的，但对于
    HTTP 客户端来说则不是。`NoSuchWordExceptionMapper` 提供器类使得这一点成为可能。它使得资源类方法能够抛出 `NoSuchWordException`
    异常，JAX-RS 容器会将该异常映射到一个 HTTP 响应（在这种情况下，是一个 `404 Not Found` 错误）。
- en: 'Next is the resource class (the full source code is available at [https://github.com/PacktPublishing/Practical-Cloud-Native-Java-Development-with-MicroProfile/blob/main/Chapter04/src/main/java/com/packt/microprofile/book/ch4/thesaurus/ThesaurusResource.java](https://github.com/PacktPublishing/Practical-Cloud-Native-Java-Development-with-MicroProfile/blob/main/Chapter04/src/main/java/com/packt/microprofile/book/ch4/thesaurus/ThesaurusResource.java)),
    as illustrated in the following code snippet:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是资源类（完整的源代码可在 [https://github.com/PacktPublishing/Practical-Cloud-Native-Java-Development-with-MicroProfile/blob/main/Chapter04/src/main/java/com/packt/microprofile/book/ch4/thesaurus/ThesaurusResource.java](https://github.com/PacktPublishing/Practical-Cloud-Native-Java-Development-with-MicroProfile/blob/main/Chapter04/src/main/java/com/packt/microprofile/book/ch4/thesaurus/ThesaurusResource.java)
    找到）的示例，如下代码片段所示：
- en: '[PRE3]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'There are a few new annotations on the resource class: `@Produces` and `@Consumes`.
    These annotations can be placed on resource classes or methods—as with most annotations
    of this type in JAX-RS, annotations on the method take priority over annotations
    on the class. These annotations help control the matching of requests and the
    entity providers (`MessageBodyReaders` and `MessageBodyWriters`) to be used in
    deserializing the HTTP entity from the request or serializing the HTTP entity
    in the response.'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 资源类上有几个新的注解：`@Produces` 和 `@Consumes`。这些注解可以放置在资源类或方法上——与 JAX-RS 中此类注解的大多数注解一样，方法上的注解优先于类上的注解。这些注解有助于控制请求的匹配以及用于从请求反序列化
    HTTP 实体或响应中序列化 HTTP 实体的实体提供者（`MessageBodyReaders` 和 `MessageBodyWriters`）。
- en: HTTP requests and responses may contain a header that indicates the `Content-Type`.
    HTTP requests may also contain a header that specifies the media type(s) that
    it expects to receive in the response—`Accept`. In the absence of these headers,
    all media types are allowed (denoted by, `*/*`).
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP 请求和响应可能包含一个表示 `Content-Type` 的头信息。HTTP 请求也可能包含一个头信息，指定它期望在响应中接收的媒体类型（或多个媒体类型）——`Accept`。如果没有这些头信息，则允许所有媒体类型（用
    `*/*` 表示）。
- en: 'In the previous example, the resource class specifies `MediaType.TEXT_PLAIN`
    or `text/plain`. Other media types include `text/html`, `application/json`, `application/xml`,
    `image/jpeg`, and much more. Specifying `text/plain` would prevent the resource
    methods from being invoked if a request contained a header such as `Content-Type:
    application/pdf` or `Accept: image/png`—instead of invoking the resource method,
    the JAX-RS container would return a `415 Unsupported Media Type` error.'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '在前面的例子中，资源类指定了 `MediaType.TEXT_PLAIN` 或 `text/plain`。其他媒体类型包括 `text/html`、`application/json`、`application/xml`、`image/jpeg`
    以及更多。指定 `text/plain` 将会阻止资源方法在请求包含如 `Content-Type: application/pdf` 或 `Accept:
    image/png` 等头信息时被调用——在这种情况下，JAX-RS 容器会返回一个 `415 Unsupported Media Type` 错误。'
- en: Best practice
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 最佳实践
- en: Always use `@Produces` and `@Consumes` to limit media types. This will place
    limits on the types of requests your service will respond to. It will ensure that
    your application (if properly tested) can handle requests of the specified media
    types.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 总是使用 `@Produces` 和 `@Consumes` 来限制媒体类型。这将限制你的服务将响应的类型。这将确保你的应用程序（如果经过适当测试）可以处理指定媒体类型的请求。
- en: 'This example also introduces new method-level HTTP verb annotations: `@POST`,
    `@PUT`, `@DELETE`, and `@PATCH`. As with `@GET`, these annotations specify which
    method should be invoked based on the HTTP request''s `@HEAD` and `@OPTIONS`,
    which are less commonly used.'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: Special note
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: 'If the resource class contains a method annotated with `@GET` but not `@HEAD`,
    the JAX-RS container would invoke the `@GET` method for matching HTTP `HEAD` requests,
    but it would remove the entity. Likewise, if a resource class contains any HTTP
    verb annotation other than `@OPTIONS`, the JAX-RS container would return a response
    indicating all of the valid verbs that could be matched for that request. Using
    the preceding example, an `OPTIONS` request would result in a response with a
    header such as `Allow: DELETE, HEAD, GET, OPTIONS, PATCH, POST, PUT`.'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: This example also introduces the idea of HTTP parameters—specifically, `@PathParam("word")
    String word;`.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: This annotation can be placed on fields or method parameters. The value of `@PathParm`
    is `word`, which corresponds to the template variable in the resource class's
    `@Path` value (`"/thesaurus/{word}"`). This means that for an HTTP request such
    as `http://localhost:9080/myApp/rest/thesaurus/funny`, the value injected into
    the `word` field would be `funny`.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: 'There are other HTTP parameter types that can be used in JAX-RS, including
    `@QueryParam`, `@FormParam`, `@CookieParam`, `@HeaderParam`, and `@MatrixParam`,
    which all correspond to different parts of an HTTP request. JAX-RS also allows
    multiple HTTP parameter annotations to be aggregated on a single Java class and
    then referenced in the resource class or method as a `@BeanParam` parameter type.
    Here is an example of this:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The `ParamBean` bean is just a `@*Param` annotations. Then, this POJO is injected
    into a resource, like this:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '`@BeanParam` beans can be very useful for aggregating common sets of RESTful
    parameters to avoid writing repetitive code. Let''s test this example from the
    command line using `curl`, as follows:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'One thing to be wary of is that not all parameters will be non-null, so you
    will need to check for null values, or you can use the `@DefaultValue` annotation.
    This applies to method parameters as well. An example is provided here:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Notice that the value in the `@DefaultValue` annotation is always a string,
    but as long as it can be converted from a string to the parameter type (`Integer`,
    in this case), it will work. In the next section, we will learn how to convert
    data sent from a client into the Java objects in our application code.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: Entity providers and ParamConverter
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: So far, our resource methods have mainly been dealing with strings or other
    primitives. The JAX-RS container is responsible for serializing and deserializing
    those objects, but what if we want to send and receive more complex objects? In
    those cases, we may need to implement some `ParamConverter`.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: Entity providers
  id: totrans-72
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Entity providers include `MessageBodyReader` and `MessageBodyWriter`, and they
    are responsible for deserializing HTTP entity data to a Java object and serializing
    a Java object to an HTTP entity, respectively.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 实体提供者包括`MessageBodyReader`和`MessageBodyWriter`，它们分别负责将HTTP实体数据反序列化为Java对象，以及将Java对象序列化为HTTP实体。
- en: 'Let''s say that we have a `Person` object such as this:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有一个`Person`对象，如下所示：
- en: '[PRE8]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'And let''s say that we have a `service` object such as this:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 再假设我们有一个`service`对象，如下所示：
- en: '[PRE9]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: One thing to notice here is that the `getPerson(…)` method throws a new `WebApplicationException`
    exception, passing it as a `404` response. This is another way to map an exception
    to a response without needing an `ExceptionMapper` instance.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 这里需要注意的一点是，`getPerson(…)`方法抛出了一个新的`WebApplicationException`异常，并将其作为`404`响应传递。这是将异常映射到响应而不需要`ExceptionMapper`实例的另一种方式。
- en: Best practice
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 最佳实践
- en: Use `ExceptionMappers` when multiple resource methods may throw the same exception.
    Throw a `WebApplicationException` exception with a passed-in `Response` object
    only in cases where you don't have an appropriate business exception to throw
    or you only throw the exception from one resource method.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 当多个资源方法可能抛出相同的异常时，请使用`ExceptionMappers`。只有在没有合适的业务异常可以抛出，或者你只从单个资源方法中抛出异常的情况下，才使用带有传入的`Response`对象的`WebApplicationException`异常。
- en: 'Another thing to notice is the use of `APPLICATION_JSON` as the media type
    that this resource produces and consumes. The `application/json` media type is
    the most common content type used in microservices. `Person` object from the previous
    sample code:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 另一点需要注意是，这个资源使用`APPLICATION_JSON`作为它产生的和消费的媒体类型。`application/json`媒体类型是微服务中最常用的内容类型。以下是从上一个示例代码中获取的`Person`对象：
- en: '[PRE10]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'In order for a client to create a new `Person` object via the `POST` method,
    we need a `MessageBodyReader` instance. There are some built-in readers that would
    handle this nicely, but for now, we''ll write and register our own, like this
    (the full source code is available at [https://github.com/PacktPublishing/Practical-Cloud-Native-Java-Development-with-MicroProfile/blob/main/Chapter04/src/main/java/com/packt/microprofile/book/ch4/entityandparamproviders/MyJsonReader.java](https://github.com/PacktPublishing/Practical-Cloud-Native-Java-Development-with-MicroProfile/blob/main/Chapter04/src/main/java/com/packt/microprofile/book/ch4/entityandparamproviders/MyJsonReader.java)):'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使客户端能够通过`POST`方法创建一个新的`Person`对象，我们需要一个`MessageBodyReader`实例。有一些内置的读取器可以很好地处理这个问题，但到目前为止，我们将编写并注册自己的，如下所示（完整的源代码可在[https://github.com/PacktPublishing/Practical-Cloud-Native-Java-Development-with-MicroProfile/blob/main/Chapter04/src/main/java/com/packt/microprofile/book/ch4/entityandparamproviders/MyJsonReader.java](https://github.com/PacktPublishing/Practical-Cloud-Native-Java-Development-with-MicroProfile/blob/main/Chapter04/src/main/java/com/packt/microprofile/book/ch4/entityandparamproviders/MyJsonReader.java)）：
- en: '[PRE11]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Furthermore, in order to write a `Person` object as JSON in a response entity,
    we must register a JSON `MessageBodyWriter` instance, like this (the full source
    code is available at [https://github.com/PacktPublishing/Practical-Cloud-Native-Java-Development-with-MicroProfile/blob/main/Chapter04/src/main/java/com/packt/microprofile/book/ch4/entityandparamproviders/MyJsonWriter.java](https://github.com/PacktPublishing/Practical-Cloud-Native-Java-Development-with-MicroProfile/blob/main/Chapter04/src/main/java/com/packt/microprofile/book/ch4/entityandparamproviders/MyJsonWriter.java)):'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，为了将`Person`对象作为JSON写入响应实体，我们必须注册一个JSON的`MessageBodyWriter`实例，如下所示（完整的源代码可在[https://github.com/PacktPublishing/Practical-Cloud-Native-Java-Development-with-MicroProfile/blob/main/Chapter04/src/main/java/com/packt/microprofile/book/ch4/entityandparamproviders/MyJsonWriter.java](https://github.com/PacktPublishing/Practical-Cloud-Native-Java-Development-with-MicroProfile/blob/main/Chapter04/src/main/java/com/packt/microprofile/book/ch4/entityandparamproviders/MyJsonWriter.java)）：
- en: '[PRE12]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: These providers could easily be combined into one `MyJsonEntityProvider` class
    that implements both interfaces. Both implementations use `InputStream` to read
    an entity from a client request and `OutputStream` for writing the response entity.
    Both providers have a Boolean check to verify that this is the proper entity provider
    to invoke—in addition to the generic type specified (`Person`) and the `@Consumes`/`@Produces`
    values, returning `true` or `false` for the `isReadable` or `isWriteable` methods
    will tell the JAX-RS container whether this provider should be used to serialize/deserialize
    the data.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 这些提供者可以很容易地合并成一个实现两个接口的 `MyJsonEntityProvider` 类。这两个实现都使用 `InputStream` 从客户端请求中读取实体，并使用
    `OutputStream` 来写入响应实体。这两个提供者都有一个布尔检查，以验证这是否是应该调用的正确实体提供者——除了指定的泛型类型（`Person`）和
    `@Consumes`/`@Produces` 值之外，返回 `true` 或 `false` 对于 `isReadable` 或 `isWriteable`
    方法将告诉 JAX-RS 容器是否应该使用此提供者来序列化/反序列化数据。
- en: Another criterion for selecting among multiple providers would be the `@Priority`
    annotation—the JAX-RS container will select the provider with the highest priority
    (which is the lowest value—thus, `@Priority(1)` would be selected before `@Priority(2)`).
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 选择多个提供者的另一个标准将是 `@Priority` 注解——JAX-RS 容器将选择具有最高优先级的提供者（优先级值最低——因此，`@Priority(1)`
    将在 `@Priority(2)` 之前被选中）。
- en: Ultimately, the value returned from the reader's `readFrom` method will be injected
    into the resource method's `@Context` (more on this in the *Context injection*
    section) or `@*Param`. A resource method may contain zero or one entity parameters—any
    more will result in a deployment failure.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，从读取者的 `readFrom` 方法返回的值将被注入到资源方法的 `@Context`（更多内容请参阅 *上下文注入* 部分）或 `@*Param`。资源方法可能包含零个或一个实体参数——任何更多都将导致部署失败。
- en: On the response side, the content written to the writer's `writeTo` entity stream
    will be written to the HTTP response sent back to the client.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在响应方面，写入到写入者的 `writeTo` 实体流中的内容将被写入发送回客户端的 HTTP 响应。
- en: If the amount of code complexity for writing and reading JSON seems a little
    daunting at this point, don't fret! We'll cover a simpler approach in the next
    section.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 如果此时编写和读取 JSON 的代码复杂度看起来有点令人畏惧，不要担心！我们将在下一节中介绍一个更简单的方法。
- en: So, entity providers are responsible for serializing and deserializing HTTP
    entities to objects, but what about parameters such as query parameters, path
    parameters, and so on? These are deserialized with `ParamConverter`
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，实体提供者负责将 HTTP 实体序列化和反序列化为对象，但参数如查询参数、路径参数等怎么办？这些参数使用 `ParamConverter` 进行反序列化。
- en: ParamConverter
  id: totrans-93
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: ParamConverter
- en: 'Building on our `PersonService` example, let''s add a `PATCH` method allowing
    clients to change a person''s favorite color, as follows:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的 `PersonService` 示例的基础上，让我们添加一个 `PATCH` 方法，允许客户端更改一个人的最喜欢的颜色，如下所示：
- en: '[PRE13]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'We can invoke this method from the command line like this:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以从命令行像这样调用此方法：
- en: '[PRE14]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'We are able to update John''s favorite color because the JAX-RS container was
    able to identify that `Color` is an enumerated type, and so it will invoke its
    `valueOf(String)` method to get the `Color` object that it injects when invoking
    the `updateFavoriteColor` method. But what happens when we specify the `color`
    in lowercase? Let''s have a look at the following output to find out:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 我们能够更新约翰最喜欢的颜色，因为 JAX-RS 容器能够识别出 `Color` 是一个枚举类型，因此它会调用其 `valueOf(String)` 方法来获取在调用
    `updateFavoriteColor` 方法时注入的 `Color` 对象。但是当我们指定小写的 `color` 时会发生什么？让我们看一下以下输出以了解情况：
- en: '[PRE15]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Uh oh! The JAX-RS container could not match the request to a resource method
    (resulting in a `404 Not Found` response) because it could not convert `blue`
    to `Color.BLUE`. In order for our service to be more resilient or to handle more
    complex objects as parameters, we must use `ParamConverterProvider` and `ParamConverter`
    like this:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 哎呀！JAX-RS 容器无法将请求与资源方法匹配（导致返回 `404 Not Found` 响应），因为它无法将 `blue` 转换为 `Color.BLUE`。为了使我们的服务更具弹性或处理更复杂的参数，我们必须像这样使用
    `ParamConverterProvider` 和 `ParamConverter`：
- en: '[PRE16]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '`ParamConverterProvider` is responsible for returning an instance of a class
    that implements `ParamConverter`, such as this:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '`ParamConverterProvider` 负责返回一个实现 `ParamConverter` 接口的类的实例，例如如下所示：'
- en: '[PRE17]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The first class, `ColorParamConverterProvider`, is the registered provider class.
    When a resource method has a parameter that needs to be converted from `String`
    to an object, the JAX-RS container will invoke the `getContainer` method of any
    registered `ParamConverterProvider` class until one returns a non-null `ParamConverter`
    instance.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 第一类，`ColorParamConverterProvider`是已注册的提供者类。当一个资源方法有一个需要从`String`转换为对象的参数时，JAX-RS容器将调用任何已注册的`ParamConverterProvider`类的`getContainer`方法，直到其中一个返回非空的`ParamConverter`实例。
- en: The `ColorParamConverter` class simply capitalizes the string value to ensure
    that the enum's `valueOf` method will return the `Color.BLUE` color, regardless
    of whether the client request's query parameter was `BLUE`, `Blue`, `blue`, `bLuE`,
    and so on.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '`ColorParamConverter`类简单地将字符串值转换为大写，以确保枚举的`valueOf`方法将返回`Color.BLUE`颜色，无论客户端请求的查询参数是`BLUE`、`Blue`、`blue`、`bLuE`等。'
- en: '`ParamConverter` work for `@QueryParam` parameters as demonstrated, but also
    work for `@CookieParam`, `@FormParam`, `@HeaderParam`, `@MatrixParam`, and `@PathParam`
    parameters, and they can be used to convert a string to any object, and vice versa.
    The conversion from object to `String` is important on the client side. We''ll
    discuss that in the *Consuming RESTful services with the MicroProfile Rest Client*
    section.'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 如示例所示，`ParamConverter`适用于`@QueryParam`参数，但也适用于`@CookieParam`、`@FormParam`、`@HeaderParam`、`@MatrixParam`和`@PathParam`参数，并且可以将字符串转换为任何对象，反之亦然。在客户端，从对象到`String`的转换非常重要。我们将在*使用MicroProfile
    Rest Client消费RESTful服务*这一节中讨论这个问题。
- en: Intercepting requests and responses
  id: totrans-107
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 请求和响应的拦截
- en: There may be times when you need to check the input stream of a request before
    or after processing it in the `MessageBodyReader` entity provider. Likewise, there
    may be times where you want to perform additional processing to the output stream
    before or after processing it in the `MessageBodyWriter` entity provider. `ReaderInterceptors`
    and `WriterInterceptors` are intended for such tasks.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，您可能需要在`MessageBodyReader`实体提供者处理请求之前或之后检查输入流。同样，也可能会出现您想在`MessageBodyWriter`实体提供者处理输出流之前或之后执行额外处理的情况。`ReaderInterceptors`和`WriterInterceptors`就是为了这类任务而设计的。
- en: ReaderInterceptors and WriterInterceptors
  id: totrans-109
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: ReaderInterceptors和WriterInterceptors
- en: 'In our `MessageBodyReader` entity provider, we make a lot of calls to trim
    strings, which can be expensive in terms of performance. One way we might be able
    to reduce such calls would be to remove whitespace from the entity stream in a
    `ReaderInterceptor` provider so that then the `MessageBodyReader` provider could
    always assume that the stream contains no whitespace characters. Here''s an example
    of this:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的`MessageBodyReader`实体提供者中，我们进行了大量的字符串修剪调用，这在性能方面可能是昂贵的。我们可能减少此类调用的一种方法是在`ReaderInterceptor`提供者中从实体流中删除空白字符，这样`MessageBodyReader`提供者就可以始终假设流中不包含空白字符。以下是一个示例：
- en: '[PRE18]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'When a client sends a multiline request entity with spaces, line feeds, or
    other white space, you can see that this will convert them with the system output,
    as follows:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 当客户端发送包含空格、换行符或其他空白字符的多行请求实体时，您可以看到这将与系统输出一起转换，如下所示：
- en: '[PRE19]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: A common use case for `WriterInterceptors` is to reduce the response entity
    size by using GZIP compression—see a full example of this at [https://github.com/PacktPublishing/Practical-Cloud-Native-Java-Development-with-MicroProfile/blob/main/Chapter04/src/main/java/com/packt/microprofile/book/ch4/interceptorsandfilters/GzipWriterInterceptor.java](https://github.com/PacktPublishing/Practical-Cloud-Native-Java-Development-with-MicroProfile/blob/main/Chapter04/src/main/java/com/packt/microprofile/book/ch4/interceptorsandfilters/GzipWriterInterceptor.java).
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '`WriterInterceptors`的一个常见用途是使用GZIP压缩来减少响应实体的大小——请参阅[https://github.com/PacktPublishing/Practical-Cloud-Native-Java-Development-with-MicroProfile/blob/main/Chapter04/src/main/java/com/packt/microprofile/book/ch4/interceptorsandfilters/GzipWriterInterceptor.java](https://github.com/PacktPublishing/Practical-Cloud-Native-Java-Development-with-MicroProfile/blob/main/Chapter04/src/main/java/com/packt/microprofile/book/ch4/interceptorsandfilters/GzipWriterInterceptor.java)的完整示例。'
- en: Special note about entity streams
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 关于实体流的特殊说明
- en: While you can read the entity stream from multiple places (entity providers,
    reader or writer interceptors, filters—we'll cover these shortly), you can run
    into problems when you do. For example, your initial request entity stream may
    not support re-reading, so if you attempt to read it twice, you may end up with
    an `IOException` exception. In that case, you may need to reset the stream (if
    the stream supports resetting—each JAX-RS container may be a little different)
    or copy and replace the stream entirely as we did in our `ReaderInterceptor` example.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然你可以从多个地方读取实体流（实体提供者、读取器或写入拦截器、过滤器——我们将在稍后介绍这些），但在这样做时可能会遇到问题。例如，你的初始请求实体流可能不支持重新读取，所以如果你尝试读取两次，你可能会遇到
    `IOException` 异常。在这种情况下，你可能需要重置流（如果流支持重置——每个 JAX-RS 容器可能略有不同）或完全复制并替换流，就像我们在 `ReaderInterceptor`
    示例中所做的那样。
- en: Filters
  id: totrans-117
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 过滤器
- en: Where `ReaderInterceptors` and `WriterInterceptors` intercept the reading and
    writing of entity streams, **filters** intercept the overall request and response.
    Filters enable some powerful cross-cutting abilities in RESTful applications.
    So, what can we use filters for? We could probably fill the rest of this book
    with useful examples, from managing authentication, authorizing requests, redirecting
    requests, managing headers, aborting invalid requests before wasting server resources
    on them, audit logging requests/responses, detecting suspicious activity, providing
    application statistics, tracing requests/responses, throttling requests from specific
    clients, and more.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `ReaderInterceptors` 和 `WriterInterceptors` 截获实体流的读取和写入时，**过滤器**截获整体请求和响应。过滤器在
    RESTful 应用程序中启用了一些强大的横切能力。那么，我们可以用过滤器做什么呢？我们可能可以用这本书的其余部分来填充有用的示例，从管理身份验证、授权请求、重定向请求、管理头信息、在浪费服务器资源之前终止无效请求、审计日志请求/响应、检测可疑活动、提供应用程序统计信息、跟踪请求/响应、限制特定客户端的请求，等等。
- en: 'Let''s start with an example that checks incoming requests for an API key and
    returns a useful response if none exists, if it is unrecognized, or if that API
    key has exceeded the maximum number of requests for the day (the full source code
    is available at [https://github.com/PacktPublishing/Practical-Cloud-Native-Java-Development-with-MicroProfile/blob/main/Chapter04/src/main/java/com/packt/microprofile/book/ch4/interceptorsandfilters/ApiKeyCheckFilter.java](https://github.com/PacktPublishing/Practical-Cloud-Native-Java-Development-with-MicroProfile/blob/main/Chapter04/src/main/java/com/packt/microprofile/book/ch4/interceptorsandfilters/ApiKeyCheckFilter.java)).
    Have a look at the following code snippet:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从以下示例开始，该示例检查传入的 API 密钥请求，如果没有找到 API 密钥、API 密钥不可识别或该 API 密钥已超过当天最大请求数量（完整源代码可在[https://github.com/PacktPublishing/Practical-Cloud-Native-Java-Development-with-MicroProfile/blob/main/Chapter04/src/main/java/com/packt/microprofile/book/ch4/interceptorsandfilters/ApiKeyCheckFilter.java](https://github.com/PacktPublishing/Practical-Cloud-Native-Java-Development-with-MicroProfile/blob/main/Chapter04/src/main/java/com/packt/microprofile/book/ch4/interceptorsandfilters/ApiKeyCheckFilter.java)找到）。请查看以下代码片段：
- en: '[PRE20]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: This example checks that the client sent an API key as an HTTP header, that
    the API key is valid (by its existence in the map), and that the user's key has
    not exceeded their quota of requests. If any of these conditions occur, the filter
    will abort the request and return a response with useful data for the client.
    If the filter method exits normally, then the request will proceed, and the JAX-RS
    container will attempt to match the request to a resource class and method.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例检查客户端是否通过 HTTP 头发送了 API 密钥，API 密钥是否有效（通过其在映射中的存在），以及用户的密钥是否未超过其请求配额。如果发生任何这些条件，过滤器将终止请求并返回对客户端有用的响应。如果过滤器方法正常退出，则请求将继续，JAX-RS
    容器将尝试将请求与资源类和方法匹配。
- en: Once the request has been matched to a resource method, the JAX-RS container
    will invoke post-match request filters. These filters are useful for performing
    `ContainerRequestFilter`) as pre-match filters, but without the `@PreMatching`
    annotation. Post-match filters also enable more methods from the `RequestContext`
    object so that it knows which resource will be invoked. This is handy for situations
    where your filter may want to behave differently based on the resource class/method
    it will invoke.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦请求与资源方法匹配，JAX-RS 容器将调用匹配后请求过滤器。这些过滤器在作为预匹配过滤器执行 `ContainerRequestFilter` 时很有用，但没有
    `@PreMatching` 注解。匹配后过滤器还启用了 `RequestContext` 对象的更多方法，以便它知道将调用哪个资源。这在你的过滤器可能根据它将调用的资源类/方法而表现不同的场合很有用。
- en: Response filters are similar to request filters but are invoked after the resource
    method has been completed. Response filters can then further refine or transform
    the response. They could add or modify response headers or cookies. They could
    also replace the response entity entirely, though a `MessageBodyWriter` provider
    and/or `WriterInterceptor` provider might be more appropriate for that.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: Dynamic providers
  id: totrans-124
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: So far, all of the providers we have discussed will apply to all requests—or
    at least all matched requests—the only exception being entity providers, which
    will apply to all requests of the request's specified media type(s). But what
    if we want some providers to only be executed in certain circumstances, such as
    when a specific resource method is invoked or if the request contains specific
    content, or if the client's user is part of a special group? JAX-RS provides a
    few different mechanisms for more dynamic providers. First, we'll look at name
    binding.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: '**Name binding** allows users to place a custom annotation on one or more provider
    classes and one or more resource classes or methods. The JAX-RS container will
    then recognize that annotation and only invoke the provider if the target resource
    method or class is also annotated. For example, suppose we want to log certain
    requests; we might create an annotation like this:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The `@NameBinding` annotation is what tells the JAX-RS container to pay attention
    to this annotation. We can now create a filter that logs the request method, the
    **Uniform Resource Identifier** (**URI**), and the request and response entity
    (the full source code is available at [https://github.com/PacktPublishing/Practical-Cloud-Native-Java-Development-with-MicroProfile/blob/main/Chapter04/src/main/java/com/packt/microprofile/book/ch4/dynamicbinding/LoggingFilter.java](https://github.com/PacktPublishing/Practical-Cloud-Native-Java-Development-with-MicroProfile/blob/main/Chapter04/src/main/java/com/packt/microprofile/book/ch4/dynamicbinding/LoggingFilter.java)).
    Have a look at the following code snippet:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: This `filter` class is both a request and response filter. While it is very
    convenient to combine request and response filters (or perhaps even other provider
    types), it is important to note that the life-cycle behavior may change from one
    JAX-RS container to another. In general, it is considered a best practice not
    to store data in instance variables. If you want to store a piece of data from
    the request's filter method to be used in the response's filter method, a more
    portable approach would be to store that data in `requestContext` as a property,
    as we did for the request **identifier** (**ID**) in the preceding example.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we would just add the `@Logged` annotation to the classes (all methods
    in the class) or methods that should be logged, so in the following example, only
    the `POST` method would be logged (the full source code is available at [https://github.com/PacktPublishing/Practical-Cloud-Native-Java-Development-with-MicroProfile/blob/main/Chapter04/src/main/java/com/packt/microprofile/book/ch4/dynamicbinding/DynamicResource.java](https://github.com/PacktPublishing/Practical-Cloud-Native-Java-Development-with-MicroProfile/blob/main/Chapter04/src/main/java/com/packt/microprofile/book/ch4/dynamicbinding/DynamicResource.java)):'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Another approach to dynamically apply providers is to use `configure`, which
    provides a `ResourceInfo` object that is used to determine specifics of the matched
    resource, and a `FeatureContext` object that is used to configure the providers
    and properties or view the application configuration for each request. The following
    example will add the `LoggingFilter` class to all resource methods that start
    with `get`:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Since the `ResourceInfo` object will return the matched class and method, it
    is also possible to check the annotations of the matched resource. This makes
    it easy for dynamic features to register a provider for all requests of a specific
    HTTP verb (`if (resourceInfo.getResourceMethod().getAnnotation(GET.class) != null)
    { //…` ) or methods with annotations that don't already have the `@NameBinding`
    annotation.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: Name binding annotations and dynamic filters are powerful ways to control request
    and response processing.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: Async
  id: totrans-137
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Enough with providers! Let's get back to the core of RESTful services—the resources.
    In many cases, the synchronous nature of the JAX-RS request/response flow is inefficient.
    For example, suppose your resources tend to pass a request to a data store that
    looks up or modifies data in a database. If your data store logic has a fixed
    set of threads performing the database operations, then when the service is under
    load, incoming requests may be queued. With the synchronous flow we've been working
    with so far, this means that the flow of execution would block inside the resource
    method waiting for the data-store logic to complete before completing the flow.
    This can be inefficient as one thread essentially waits for another to complete.
    That initial thread could be more efficient if it were to perform some other task
    while the data-store operations take place. Using **asynchronous** APIs in JAX-RS
    can obtain that increased efficiency.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: AsyncResponse
  id: totrans-139
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Asynchronous methods in JAX-RS are created by adding an `AsyncResponse` parameter
    to the resource method, annotated with `@Suspended`. The `AsyncResponse` object
    may then be used to *resume* the request once the data has been fetched from the
    data store. Let''s take a look at an example. Suppose we have a service that tracks
    people, like the one we used in the *Entity providers* section. We''ll change
    the resource class around a little so that the data store access uses a separate
    `Executor` class to retrieve the data (the full source code is available at [https://github.com/PacktPublishing/Practical-Cloud-Native-Java-Development-with-MicroProfile/blob/main/Chapter04/src/main/java/com/packt/microprofile/book/ch4/async/AsyncPersonService.java](https://github.com/PacktPublishing/Practical-Cloud-Native-Java-Development-with-MicroProfile/blob/main/Chapter04/src/main/java/com/packt/microprofile/book/ch4/async/AsyncPersonService.java)).
    Have a look at the following code snippet:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: In this version of the code, the `getPersonSync` method will submit a request
    to the executor service to retrieve the `Person` object with the specified ID,
    then it will block until the executor service has completed the operation. In
    this case (for code simplicity), it is just pulling data out of a hash map, but
    if it were pulling data out of a remote database, the time spent blocking in the
    `someData.get()` call could be more substantial.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: 'So, let''s try to improve the efficiency so that we don''t have to block. We
    can rewrite the `getPersonSync()` method to look like this:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Now, the executor service is invoking the `getPerson(id)` method, but then passing
    the result to `ar.resume(…)`, which will pick up the request/response flow where
    it left off and return a response. The request thread that invoked the `getPersonAsync(…)`
    method immediately returns and can be used to service another request.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: 'The `AsyncResponse` object can also be used to handle an exception. Let''s
    say that we want to throw a `NoSuchPersonException` exception if the ID specified
    does not match any `Person` instance in the database. We might change the code
    to look like this:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: When we resume a response with an exception, the JAX-RS container will attempt
    to map the exception to a suitable response, just as it does in the synchronous
    case.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: Server-sent events
  id: totrans-149
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Another form of server-side async is **server-sent events** (**SSEs**). SSEs
    are a part of the **HyperText Markup Language 5** (**HTML 5**) specification and
    provide a way for a client to register and receive events asynchronously from
    a server.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: 'JAX-RS has two ways of sending SSEs—streaming directly to each client and **broadcasting**
    to all clients. Let''s take a look at how you might implement the first way, as
    follows (the full source code is available at [https://github.com/PacktPublishing/Practical-Cloud-Native-Java-Development-with-MicroProfile/blob/main/Chapter04/src/main/java/com/packt/microprofile/book/ch4/async/SseService.java](https://github.com/PacktPublishing/Practical-Cloud-Native-Java-Development-with-MicroProfile/blob/main/Chapter04/src/main/java/com/packt/microprofile/book/ch4/async/SseService.java)):'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: This is a contrived example, but it shows the method immediately returns after
    starting a new thread that sends a few text events to the client separated by
    a half-second delay.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: This example shows us that in order for a JAX-RS resource to send SSEs, it must
    produce the SSE media type (`MediaType.SERVER_SENT_EVENTS`, or `text/event-stream`)
    and the method must receive `Sse` and `SseEventSink` parameters, both annotated
    with `@Context`. The `Sse` type is a utility class that can create events and
    broadcasters. The `SseEventSink` type represents the connection between the server
    and the client, so calling the `send(…)` method sends a new event to that specific
    client, and calling the `close()` method (which is done implicitly by the try-with-resources
    logic) will gracefully close the connection with the client.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: The events we are sending have a `text/plain` media type—the media type is used
    to determine which `MessageBodyWriter` provider should be used to serialize that
    object passed to the data method. The `name(…)` and `id(...)` methods can provide
    additional context to each event sent. Only the `data(…)` method is required,
    though it is always a best practice to specify the media type.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: 'If we were to invoke this service using `curl`, we would see something like
    this:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Another approach to sending events is to use a `SseEventSinks`, and it will
    send events to all registered clients. Let''s look at an example of code that
    we might add to our `SseService` class, as follows:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: As with the direct-stream approach, this approach also requires that the method
    produce a media type of `SERVER_SENT_EVENTS` and that the method has the `SseEventSink`
    and `Sse` parameter types.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: First, we need to set `SseBroadcaster` as a static field. We do this because
    the default life cycle for JAX-RS resources is per request. We will discuss alternate
    life cycles in the *Managing life cycle and DI with CDI* section—that will simplify
    this code and improve performance too.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: 'Once we have the broadcaster set, we then register the event sink with it.
    Once registered, the client associated with that event sink will receive all events
    sent from this broadcaster. In this example, we broadcast an event any time a
    new client is registered and every 5 seconds. Let''s see what this looks like
    on the command line when using `curl` when we are the first client, and when a
    second client registers (from a separate command window), as follows:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: One thing to notice about this output is the `UnnamedEvent` text—this is because
    SSEs must have a name, so if no name is provided when it is built, the JAX-RS
    container creates a name for it. Other JAX-RS containers may use a different name
    if none is specified.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: Context injection
  id: totrans-165
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We''ve already discussed injection when using the `@Context` annotation for
    SSE objects, but this annotation can be used for a lot more. **Context injection**
    can occur in both resources and providers. There are lots of useful things you
    can inject, as outlined here:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: '`ResourceContext`: Used for initializing sub-resource locators'
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ResourceInfo`: Used for determining the matched resource class and method'
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`HttpHeaders`: Used for reading HTTP headers in the client request'
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SecurityContext`: Used for determining the current user, their security role,
    and so on'
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`UriInfo`: Used for reading the URI of the client request'
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Application`: Used for obtaining the application representing this RESTful
    service'
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Providers`: Used for accessing other JAX-RS providers'
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Sse` and `SseEventSink`: Discussed in the previous section'
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Best practice
  id: totrans-175
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: In most cases, it is recommended that context injection occurs in fields rather
    than as parameters. The reason for this is that the Jakarta REST project is intending
    to deprecate the `@Context` annotation in favor of CDI's `@Inject` annotation,
    which does not target method parameters.
  id: totrans-176
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Javadoc** ([https://jakarta.ee/specifications/restful-ws/2.1/apidocs/overview-summary.html](https://jakarta.ee/specifications/restful-ws/2.1/apidocs/overview-summary.html))
    is the best resource for understanding the capabilities of each of these injectable
    types. Here are a few basic examples:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'This example uses the role of the client''s user principal to determine what
    entity response to return. The following example uses the `ResourceInfo` class
    to determine whether a `MessageBodyWriter` provider should be used or not:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The injection of context objects into resources and providers enables us to
    develop powerful and flexible applications. Now, let's turn our attention to formatting
    the data our application will need to send and receive.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: Managing the payload with JSON-P and JSON-B
  id: totrans-182
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While RESTful services in general and JAX-RS applications specifically can serve
    entities of any media type (plain text, **Extensible Markup Language** (**XML**),
    **Portable Document Format** (**PDF**), binary, and so on), JSON is the *standard
    du jour* for cloud-native applications. JSON is popular because it is both human-readable
    and easily parsed— libraries for JSON parsing and binding exist in virtually all
    modern languages.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: In the *Entity providers* section, we got a taste of serializing and deserializing
    a Java object (`Person`) into JSON. In that section, we performed this by hand
    using string manipulation. While a manual approach can work, we're now going to
    discuss two APIs that enable simpler and more powerful control over JSON in Java.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: JSON-P is a programmatic API for manipulating JSON, while JSON-B is a declarative
    (annotation-based) API for quickly and easily mapping an object to JSON or vice
    versa.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: JSON-P
  id: totrans-186
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`JsonObject`, `JsonArray`, and so on, which are part of the object model API.'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s say we have some objects such as these:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'And let''s say we want to convert that into JSON content that looks like this:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: We'll start out by converting an instance of `Starship` into a JSON string.
    We can do this by using the `Json` class to create object builders and array builders.
    These builders can create objects by adding properties or objects. So, to create
    the JSON for a starship, we would need an object builder for the starship and
    for each weapon, and then an array builder for all of the weapons. An example
    of this is available at [https://github.com/PacktPublishing/Practical-Cloud-Native-Java-Development-with-MicroProfile/blob/main/Chapter04/src/main/java/com/packt/microprofile/book/ch4/jsonp/JsonpConverter.java](https://github.com/PacktPublishing/Practical-Cloud-Native-Java-Development-with-MicroProfile/blob/main/Chapter04/src/main/java/com/packt/microprofile/book/ch4/jsonp/JsonpConverter.java).
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: Each object needs its own `JsonObjectBuilder` instance, and each array or collection
    needs its own `JsonArrayBuilder` instance. Then, you simply add items to them.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: 'Deserializing a JSON string into an object works in the opposite way. First,
    you must extract `JsonObject` instance from `JsonReader`, like so:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Then, you must create a `Starship` instance and populate it from the properties
    in the `JsonObject`, like this:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: This approach uses the object model, which requires loading the entire JSON
    stream into memory before it can be converted into an object. For small JSON files,
    this is not an issue, and it allows the model to be stored in memory and re-accessed.
    It also allows the model to be changed over time before writing the JSON back
    to a stream.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: 'The streaming approach requires far less memory and is capable of reading extremely
    large JSON streams without running out of memory. It accomplishes this by firing
    events as it reads the JSON and then discards that portion of the JSON. This is
    very efficient and performs better than the object model, but it requires more
    complex coding, and since the object model is not in memory, you cannot go back
    later to ask it: *Now, what was the value again?*'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: 'Using the same Java object and JSON stream as before, here is what the serialization
    code looks like (the full source code is available at [https://github.com/PacktPublishing/Practical-Cloud-Native-Java-Development-with-MicroProfile/blob/main/Chapter04/src/main/java/com/packt/microprofile/book/ch4/jsonp/JsonpStreamingConverter.java](https://github.com/PacktPublishing/Practical-Cloud-Native-Java-Development-with-MicroProfile/blob/main/Chapter04/src/main/java/com/packt/microprofile/book/ch4/jsonp/JsonpStreamingConverter.java)):'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Similar to `JsonObjectBuilder` and `JsonArrayBuilder`, `JsonGenerator` can pass
    in map-like values to build the JSON object. Unlike the object model builder APIs,
    `JsonGenerator` cannot make changes—once the JSON is written, you cannot change
    the values. Both of the builders have `remove` methods, and the `JsonArrayBuilder`
    API has setter methods, allowing you to change previously configured values. The
    reason for having these two approaches is to allow you to make a decision between
    flexibility and efficiency.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: 'For parsing JSON into an object, a stream-based approach is even more complex,
    as we can see here:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The parser works similar to a Java iterator, returning events to indicate things
    such as object start (`{`), object end (`}`), array start (`[`), array end (`]`),
    key names (for example, `name` and `speedRating`), and key values (for example,
    `Coreillian Freighter` and `24`). It is important that each event is interpreted
    within its context. For example, an array might contain several objects, so it
    is necessary to keep track of which object is currently being parsed to avoid
    mixing up data. The `parseWeapons` method provides an example of this by separately
    parsing each item in the array, as illustrated in the following code snippet:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: JSON-P provides a very powerful API set for reading and writing JSON programmatically.
    The code can tend to be a tad verbose, though. That's something that JSON-B can
    help with.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: JSON-B
  id: totrans-208
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: While JSON-P is very powerful and flexible, **JSON-B** is very simple and efficient
    at serializing and deserializing objects to JSON. JSON-B has some programmatic
    APIs but overall, it takes a declarative approach to writing/reading JSON. This
    means that the conversion of an object to JSON will be based on the object type's
    getter methods—and likewise, the conversion of JSON to object will be based on
    the object type's setter methods.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: 'If we use the example objects of `Starships` and `Weapons` from JSON-P, the
    conversion of object to JSON and vice versa is very simple, as is illustrated
    here:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'It is possible to convert directly to a string but using `OutputStream` or
    `Writer` is preferable, especially when dealing with large JSON objects. The primary
    objects here are `Jsonb` and the `toJson(…)` method. You can see the output here:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'This looks very similar to what we created using JSON-P, but it''s all on one
    line and difficult to distinguish where one object ends and the next begins. For
    most JSON consumers that should not be a problem, but if we want to make it more
    human-readable, we can add some configuration by replacing the `JsonbBuilder.create()`
    method call with the following code:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'This will produce the following output:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: There are several other configuration options that you could use to handle the
    serialization of a Java object.  For example, you could also add your own `JsonParser`
    from JSON-P to convert the object to JSON your own way.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: 'Converting JSON back into an object is just as simple, as we can see here:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: And as with the `toJson(…)` method, you can use a string or a stream.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: 'So, what happens if you have an object, but you want the JSON fields to have
    a different name than the Java property name? Or, maybe you don''t want certain
    fields to be exposed as JSON at all? That''s where annotations such as `@JsonbProperty("someOtherName")`
    and `@JsonbTransient` come in handy, and depending on where you place the annotation,
    it will have a different effect. If the annotation is on the getter, then it will
    only apply to serialization (conversion from Java to JSON). If the annotation
    is on the setter, then it will only apply deserialization. If the annotation is
    on the field itself, then it will apply to both. Let''s consider the following
    code snippet:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'We would create an instance of `Person` and print it out to JSON, like so:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'The output would look like this:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'The `lastName` field has been converted to `familyName`, the `middleName` field
    has not been printed at all, and the `favoriteColor` field has been Britishized
    to `favouriteColour`. But if we tried to create a new `Person` instance from this
    JSON, we would get an incomplete `Person` instance. Let''s take a look, as follows:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'This would yield the following output:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: The `middleName` field was missing from the JSON, so it is no surprise that
    it is null. Since the `@JsonbProperty("favouriteColour")` annotation is only on
    the getter, JSON-B will not convert the Britishized JSON field to the Americanized
    Java field. And since the `@JsonbProperty("yearsOld")` annotation is applied to
    the `setAge(…)` method, it will not be set since the JSON is still using the `age`
    field name.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
- en: The behavior differences depending on where an annotation is placed are important
    to note when using JSON-B.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's tie this back to JAX-RS. The JAX-RS specification says that a product
    that supports JSON-P must supply `MessageBodyReaders` and `MessageBodyWriters`
    for entity types of `JsonStructure`, `JsonObject`, `JsonArray`, `JsonString`,
    and `JsonNumber`. Furthermore, a product that supports JSON-B must supply `MessageBodyReaders`
    and `Writers` for any object type when the media type is `application/json`, `text/json`,
    `*/json`, `or` `*/*+json`. Any product that implements the entire MicroProfile
    set of specifications will have JAX-RS, JSON-P, and JSON-B. This means that for
    the most part, you can count on your JAX-RS container to handle the conversion
    of JSON to objects and back to JSON.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: Now we've learned the easy way to work with JSON, let's learn how we can send
    requests and consume results using the client APIs.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: Consuming RESTful services with the MicroProfile Rest Client
  id: totrans-236
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Thus far, we've covered how we can design elaborate RESTful services and how
    we can easily transform JSON into Java objects and vice versa. Next up, we need
    to consume those services using the client APIs. In a microservice architecture,
    RESTful clients are critical for invoking remote services.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
- en: JAX-RS Client APIs
  id: totrans-238
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'One way to consume RESTful services is with the **JAX-RS Client APIs**. Similar
    to JSON-P (as opposed to JSON-B), these APIs tend to be more programmatic with
    more control over individual options, such as headers, path construction, and
    so on. Let''s take a look at some code using the thesaurus example from earlier
    in this chapter, as follows:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: The client instance is built using `ClientBuilder`. In this example, it simply
    builds a `Client` instance, but you could use `ClientBuilder` to set configuration
    properties or register client-side providers. `Client` instances should be explicitly
    closed when you are done using them—they currently do not implement the `AutoCloseable`
    interface, but a future version of the JAX-RS specification will add that, allowing
    `Client` instances to be closed in a try-with-resources block.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
- en: '`WebTarget` represents the destination of the client request. It has methods
    for appending path elements, resolving path template variables, adding query or
    matrix parameters, or specifying the expected response media type. In the previous
    example, we append the `word` variable to the `uri` variable with this line of
    code:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Alternatively, we could change the `uri` variable to `http://localhost:9080/rest/thesaurus/{word}`,
    then we could use the following line of code:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Depending on the situation, either might be more usable.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
- en: An `Invocation.Builder` object is created by calling the `request(…)` method
    on the `WebTarget`—an optional media type parameter is used to determine what
    media type is expected for the response; it will set the `Accept` header. The
    `Invocation.Builder` object has methods such as `get(…)`, `post(…)`, `put(…)`,
    `delete(…)`, and other methods that represent the HTTP verb to use for the request.
    You can use the `method(…)` method to specify HTTP verbs that are not built into
    the API. It also has methods for setting cookies or headers.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
- en: The `Invocation.Builder` object also has `async()` and `rx()` methods that will
    return an asynchronous invoker and reactive invoker, respectively. These invokers
    enable users to retrieve the response asynchronously, which will generally improve
    performance.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
- en: The `Response` object represents the HTTP response from the remote server. From
    the `Response` object, you can check the status code of the response (`200`, `204`,
    `400`, `404`, `500`, and so on) and response headers, read the response entity,
    and more. Note that the `Response` object is `AutoCloseable`—it is always a good
    practice to close both `Response` and `Clientobjects`.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
- en: MicroProfile Rest Client
  id: totrans-250
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If the JAX-RS Client is similar to JSON-P, then the `@Path`, `@GET`, `@PUT`,
    `@POST`, `@DELETE`, and so on, annotations. The MicroProfile Rest Client implementation
    provides an instance of the interface, which you can then invoke in order to invoke
    the remote service.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at an example, as follows (the full source code is available
    at [https://github.com/PacktPublishing/Practical-Cloud-Native-Java-Development-with-MicroProfile/blob/main/Chapter04/src/main/java/com/packt/microprofile/book/ch4/client/ThesaurusClient.java](https://github.com/PacktPublishing/Practical-Cloud-Native-Java-Development-with-MicroProfile/blob/main/Chapter04/src/main/java/com/packt/microprofile/book/ch4/client/ThesaurusClient.java)):'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'The methods here match the five resource methods in the `ThesaurusResource`
    class, with the exception that the `@PathParam` parameter is a method parameter.
    These methods all return a `String` object, but they could also return a `Response`
    object if it was important to view things in the response such as headers or status
    code, and so on. Usually, these things can be abstracted so that you can return
    the actual data type. This interface approach allows us to invoke the service
    by simply calling these methods. But first, we need to build an instance of this
    client. If we are in an environment that uses CDI (see the next section) and MicroProfile
    Config (see [*Chapter 5*](B17377_05_Final_SB_epub.xhtml#_idTextAnchor091), *Enhancing
    Cloud-Native Applications*), then the framework can automatically build and inject
    the client instance. Otherwise (or if you just want to build the instance programmatically),
    you can use the `RestClientBuilder` API, like so:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'This sets `baseUri`, the URI path up to the point where the `@Path` annotation
    is added. Similar to the JAX-RS `ClientBuilder` API, we could also use the `RestClientBuilder`
    API to specify properties for the client instance or register providers. Once
    we''ve built the client instance, we can invoke it like so:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Client-side providers
  id: totrans-258
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'That''s a nice way to invoke the service—a lot less code and it reads easier
    too! You might be thinking: *That method throws an exception—how does the implementation
    know when it should throw it?* Excellent question! The answer is `ResponseExceptionMapper`.
    It is basically the converse of JAX-RS `ExceptionMapper`—instead of mapping an
    exception to a response, they map a response to an exception. By default, MicroProfile
    Rest Client implementations will throw a `WebApplicationException` on any response
    with a status code of `400` or higher— those codes are client errors or server
    errors. To map more specific responses to exceptions, you would need to register
    one or more `ResponseExceptionMapper`, such as the following:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: This response exception mapper implements two methods. The first, `handles(…)`,
    is used to inform the client implementation of whether it should use this mapper
    for the current response. If it returns `true`, then the client implementation
    will invoke the `toThrowable(…)` method to obtain the exception it should throw.
    If the `handles(…)` method returns `false`, then the client implementation will
    check any other registered response exception mappers before assuming that the
    response was successful and simply returning a valid value to the client caller
    rather than throwing an exception.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
- en: Special note
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
- en: The `toThrowable(…)` method should *return* the exception, not throw it. The
    client implementation will actually throw the exception; it just needs to know
    which exception to throw.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
- en: 'As with server-side providers, client-side providers need to be registered.
    There are two ways to register client providers. First, you can register them
    from the `RestClientBuilder` API before building the client, as illustrated in
    the following code snippet:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'A second way to register a client provider is to use one or more `@RegisterProvider`
    annotations on the client interface, like this:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: You can register as many of the same types of providers on the client side as
    you would on the server, including `MessageBodyReader` and `Writer`, `Reader`,
    and `WriterInterceptors`. You may not register `ExceptionMappers` or server-side
    filters (`ContainerRequestFilter` or `ContainerResponseFilter`). You may, however,
    register client-side filters (`ClientRequestFilter` or `ClientResponseFilter`)—they
    work in much the same way as server-side filters.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
- en: The `ClientRequestFilter` filter's `ClientRequestContext` has an `abortWith(Response)`
    method similar to the `ContainerRequestFilter` filter. This method can be useful
    in test code for mocking different server responses.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
- en: All of these client-side providers will work with either client, the JAX-RS
    Client and the MicroProfile Rest Client, except for `ResponseExceptionMapper`—these
    will only work with the MicroProfile Rest Client.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
- en: Async
  id: totrans-272
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Both JAX-RS Client and the MicroProfile Rest Client are capable of invoking
    services asynchronously. This is perhaps even more powerful on the client than
    on the server, as a client will often run in resource-constrained environments
    and may be called upon to perform multiple requests in order to achieve its goal.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
- en: 'The JAX-RS Client invokes services asynchronously by creating an `AsyncInvoker`
    instance that will produce `java.util.concurrent.Future` objects that reference
    the response objects or allow the user to specify an `InvocationCallback` that
    is notified when the response is available (or if there was an exception during
    the request/response). Here is an example of the `Future` approach:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'This code looks very similar to the synchronous code from earlier in this section
    and makes for a very simple way to perform asynchronous client requests. Next,
    let''s see how we would use `InvocationCallbacks`, as follows (the full source
    code for this and the `Future` approach is available at [https://github.com/PacktPublishing/Practical-Cloud-Native-Java-Development-with-MicroProfile/blob/main/Chapter04/src/main/java/com/packt/microprofile/book/ch4/client/JAXRSClient.java](https://github.com/PacktPublishing/Practical-Cloud-Native-Java-Development-with-MicroProfile/blob/main/Chapter04/src/main/java/com/packt/microprofile/book/ch4/client/JAXRSClient.java)):'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: This example shows how you might look up multiple words. It sends multiple requests
    in parallel to the server, and the `completed` method of `InvocationCallback`
    is invoked when the response is available.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
- en: 'Asynchronous requests in the MicroProfile Rest Client are slightly different.
    The client interface methods must return `CompletionStage` that wraps the intended
    return type. So, we would modify our client interface to look like this (the full
    source code is available at [https://github.com/PacktPublishing/Practical-Cloud-Native-Java-Development-with-MicroProfile/blob/main/Chapter04/src/main/java/com/packt/microprofile/book/ch4/client/ThesaurusAsyncClient.java](https://github.com/PacktPublishing/Practical-Cloud-Native-Java-Development-with-MicroProfile/blob/main/Chapter04/src/main/java/com/packt/microprofile/book/ch4/client/ThesaurusAsyncClient.java)):'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Notice that none of these methods declare that they throw any exceptions. That
    is because any exception processing occurs after the processing of the returned
    `CompletionStage`. This is how we might invoke this client:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: Like the JAX-RS Client callback example, this example looks up the synonyms
    for multiple words simultaneously. By using `CompletionStage`, we can easily handle
    exceptions or perform additional processing inline.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
- en: Remember another form of asynchronous operations is SSEs. The JAX-RS Client
    APIs allow you to receive events in the form of `InboundSseEvent` objects. The
    MicroProfile Rest Client goes a step further and allows you to receive events
    using `Publisher` objects. The events can be `InboundSseEvent` objects that allow
    you to read extra metadata on each event or as a specific Java type, so long as
    you have `MessageBodyReader` to convert the event into that type.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
- en: 'If we want to consume the SSE events from the service we wrote at the end of
    the *Building a RESTful Service with Jakarta REST* section, we might write a client
    interface that looks something like this:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'The client interface is simple enough, right? So, this is how you might use
    it (the full source code is available at [https://github.com/PacktPublishing/Practical-Cloud-Native-Java-Development-with-MicroProfile/blob/main/Chapter04/src/main/java/com/packt/microprofile/book/ch4/async/MPSseConsumerResource.java](https://github.com/PacktPublishing/Practical-Cloud-Native-Java-Development-with-MicroProfile/blob/main/Chapter04/src/main/java/com/packt/microprofile/book/ch4/async/MPSseConsumerResource.java)):'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: Once the `Publisher` is returned from the client interface, a caller can subscribe
    to it and control the flow of the SSEs via the `request(int)` method of `Subscription`.
    The `onNext` callback method is invoked for each new event (so long as it has
    been requested). The `onError` callback is invoked when an error occurs (for example,
    not being able to find a `MessageBodyReader` that can deserialize the event).
    The `onComplete` callback is invoked when the connection with the server has been
    closed.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
- en: Propagating HTTP headers from server to client
  id: totrans-290
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Quite often, you may need to construct a RESTful service that needs to consume
    other RESTful services. This might be part of a gateway or delegation pattern,
    or it may be that your service needs to aggregate other services such as the following
    service, where a vacation service may need to make reservations for airlines,
    hotels, entertainment venues, and so on:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.2 – Aggregating service'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_4.2_-_B17377.jpg)'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.2 – Aggregating service
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
- en: In these situations, it is often useful to propagate headers from the original
    request to the delegated requests. For example, suppose you want to reuse the
    authentication credentials sent on the original request when making the subsequent
    requests; the MicroProfile Rest Client has some built-in mechanisms that make
    this easy to do.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
- en: 'First, you must annotate your client interface with `@RegisterClientHeaders`
    and then specify a comma-separated list of headers that the container should automatically
    propagate in a MicroProfile Config property, like so:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Next, you can specify headers declaratively in the client interface, like this:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: In this code, the `AgentID` header with the hardcoded value `Bob's Travel Co.`
    would be sent on every request from this client since the `@ClientHeaderParam`
    annotation is applied to the interface. When the `makeReservation` method is invoked,
    the MicroProfile Rest Client implementation will invoke the `newId` method to
    obtain the value of the `RequestID` header—the value of the header is the return
    value of a method because the annotation value is surrounded by curly braces.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
- en: Both of these approaches allow headers to be sent without needing to modify
    the signature of the client interface method.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
- en: Managing life cycle and DI with CDI
  id: totrans-302
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: By default, JAX-RS resources are created for each request. While this might
    be useful in some cases, it would be far more efficient if they were singletons.
    That way, we wouldn't be creating new object instances (an expensive operation)
    for each request, and we wouldn't be generating excess garbage after the request
    is completed.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
- en: While we could create an `Application` subclass that returns the resources via
    the `getSingletons()` method, that would prevent the container from automatically
    discovering and registering resources and providers. Another reason to avoid that
    approach is that the `getSingletons()` method is deprecated in a future version
    of JAX-RS and will eventually be removed.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
- en: Instead, we can use **Context and Dependency Injection** (**CDI**). CDI uses
    annotations to allow developers to declaratively manage object life cycles and
    perform injections of fields, constructors, and setter methods.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
- en: Scopes
  id: totrans-306
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: CDI has several built-in `@ApplicationScoped`, `@RequestScoped`, and `@Dependent`.
    As you can probably guess, an object annotated with `@ApplicationScoped` will
    *live* for the lifetime of the application, while an object annotated with `@RequestScoped`
    will only live for the lifetime of a single request.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
- en: The `@Dependent` annotation is a little special. Basically, objects annotated
    with it will inherit the scope of the object it is injected into. In the case
    of JAX-RS resource classes that are not really injected into anything, it inherits
    the scope of the JAX-RS container. For resource objects, that is **per request**,
    but for provider objects, that is **per application**.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
- en: This means that we can annotate our JAX-RS resource classes with `@ApplicationScoped`
    and then we can get rid of those pesky static fields and just use normal instance
    fields.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
- en: Injection
  id: totrans-310
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: DI is another powerful piece of CDI. Using annotations, you can specify your
    dependencies and let the container handle all of the wiring. In the most basic
    cases where you want to inject a class or an instance of an interface where there
    is only one managed bean implementation of that interface, you can use `@Inject`,
    and CDI does the rest.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at an example. Suppose we have a class like this that we
    want to inject (the full source code for all CDI examples can be found at [https://github.com/PacktPublishing/Practical-Cloud-Native-Java-Development-with-MicroProfile/tree/main/Chapter04/src/main/java/com/packt/microprofile/book/ch4/cdi](https://github.com/PacktPublishing/Practical-Cloud-Native-Java-Development-with-MicroProfile/tree/main/Chapter04/src/main/java/com/packt/microprofile/book/ch4/cdi)):'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'We have a request-scoped bean that, when instantiated, will have a unique instance
    ID. Now, let''s say that we want to inject it into a JAX-RS resource class that
    is managed by CDI, but we want the resource class to be application-scoped for
    better performance. It might look like this:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'This object, `MyCdiResource`, will only be instantiated once for the lifetime
    of the application, with no extra object creation or excess garbage. But the `MyDependency`
    object that is injected is `GET` method that returns the dependency instance ID,
    as the dependency''s instance ID increments on each request, as illustrated here:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'There may be times where you want to create your own bean that is injected.
    CDI provides a mechanism where you would use the `@Produces` annotation (same
    name but different package as the JAX-RS `@Produces` annotation for specifying
    media types). To use this, you would apply this annotation to a method on a CDI-managed
    bean; the object returned by that method will be injected appropriately. Let''s
    see how this would look in a code example, as follows:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: And in this case, since the `MyCdiResource` class is annotated with `@ApplicationScoped`,
    the `MyProducedDependency` object is only built and injected once for the lifetime
    of the application. If we were to change `MyCdiResource` to be `@RequestScoped`,
    then the random number would change for each request. The `producer` method is
    invoked when needed by the *consuming* bean.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
- en: So, what happens if you have more than one possible bean to inject? Your application
    may fail to start with a `DeploymentException` exception, indicating ambiguous
    dependencies. To resolve this, you can either use the `@Named` annotation or *qualifier*
    annotations.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
- en: 'The `@Named` annotation may look something like this:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: The `@Named` annotation with the same value, `max`, is applied to both the implementation
    class *and* the injection point.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
- en: 'Qualifiers are a little more complex but add more flexibility. It first involves
    the creation of a new annotation, like this:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'Then, we just add that annotation on both the class and injection target, like
    so:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'Qualifiers can be used more extensively in other CDI artifacts such as interceptors
    and portable extensions. One such extension is built into the MicroProfile Rest
    Client implementation, which allows client instances to be built and injected
    into your CDI beans. It uses the `@RestClient` qualifier. For this to work, you
    would need to add the `@RegisterRestClient` annotation to the client interface.
    With this annotation, you can also specify the `baseUri` path. Alternatively,
    you could use MicroProfile Config to specify the `baseUri` path and other configuration
    options for the client instance. Here''s what it might look like:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  id: totrans-330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'Then, we could inject the client instance and use it like so:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: While it might seem silly to create a RESTful service that then uses a client
    to access a different RESTful service in the same application, the principle is
    very common for microservice architecture. This service could be a gateway for
    the real thesaurus service, or perhaps the complete thesaurus is split across
    several **virtual machines** (**VMs**). The ability to provide or consume RESTful
    services where those services' life cycles and dependencies are managed declaratively
    can be very powerful indeed.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-334
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we've learned how to create and consume basic and complex RESTful
    services using industry-standard APIs such as JAX-RS, CDI, JSON-P, JSON-B, and
    the MicroProfile Rest Client. We've learned that some of these APIs provide very
    concise and type-safe approaches, while others provide additional flexibility
    at the cost of increased code complexity. Having completed this chapter, we can
    now create fully functioning micro-services utilizing REST and JSON. We can also
    improve the efficiency of these services by using asynchronous clients and appropriate
    life-cycle scopes.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will explore how we can improve the configurability
    and robustness of these services with other MicroProfile APIs.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
