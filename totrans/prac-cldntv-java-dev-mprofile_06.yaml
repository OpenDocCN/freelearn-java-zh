- en: '*Chapter 4*: Developing Cloud-Native Applications'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: MicroProfile 4.1 builds on some **Jakarta EE** (formerly **Java Enterprise Edition**)
    **application programming interfaces** (**APIs**)—specifically, **Jakarta RESTful
    Web Services** (**JAX-RS**), **Jakarta Contexts and Dependency Injection** (**CDI**),
    **JavaScript Object Notation Processing** (**JSON-P**), and **JSON Binding** (**JSON-B**).
    Using only these technologies, it is possible to develop a perfectly capable cloud-native
    application. The MicroProfile community added a type-safe mechanism for invoking
    RESTful services known as the **MicroProfile Rest Client**. These technologies
    are essential for building Java-based microservices that can interoperate in the
    cloud. Learning to use these technologies will enable you to build robust and
    secure Java microservices.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will explore all of the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Developing a RESTful service with JAX-RS
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Managing the payload with JSON-P and JSON-B
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Consuming RESTful services with the MicroProfile Rest Client
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Managing life cycle and **dependency injection** (**DI**) with CDI
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This chapter covers a wide spectrum of technologies and the functionality within
    each technology. When you have finished this chapter, you should have a broad
    and deep understanding of how to build reliable, robust RESTful applications that
    can communicate with each other using JSON.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In order to build and run the samples mentioned in this chapter, you will need
    a Mac or PC (Windows or Linux) with the following software:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Java Development Kit** (**JDK**) version 8 or higher ([http://ibm.biz/GetSemeru](http://ibm.biz/GetSemeru))'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Apache Maven ([https://maven.apache.org/](https://maven.apache.org/))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A Git client ([https://git-scm.com/](https://git-scm.com/))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All of the source code used in this chapter is available on GitHub at [https://github.com/PacktPublishing/Practical-Cloud-Native-Java-Development-with-MicroProfile/tree/main/Chapter04](https://github.com/PacktPublishing/Practical-Cloud-Native-Java-Development-with-MicroProfile/tree/main/Chapter04).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Once you have cloned the GitHub repository, you can start the Open Liberty
    server that these code samples will execute in by entering the `Chapter04` directory
    and running the following command from the command line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: You can then stop the server in the same command window by pressing *Ctrl +
    C*.
  prefs: []
  type: TYPE_NORMAL
- en: Now we've got the prerequisites taken care of, let's start by building a basic
    RESTful service.
  prefs: []
  type: TYPE_NORMAL
- en: Developing a RESTful service with JAX-RS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will develop a few RESTful services using JAX-RS. We'll
    start with a simple example, and then we'll add more complex and powerful techniques
    such as exception handling, advanced conversion of **HyperText Transfer Protocol**
    (**HTTP**) data into Java objects (and vice versa), cross-cutting concerns, asynchronous
    methods, and DI.
  prefs: []
  type: TYPE_NORMAL
- en: JAX-RS is built around the idea of a **request-response** pipeline. On the server
    side, an HTTP request enters the pipeline, then the JAX-RS server invokes any
    pre-matching **filters** on the request. It then attempts to match the request
    with a JAX-RS **resource method**.
  prefs: []
  type: TYPE_NORMAL
- en: 'When the JAX-RS container receives an incoming request, it will perform the
    following process:'
  prefs: []
  type: TYPE_NORMAL
- en: Invoke any registered pre-matching filters.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Attempt to match the request to a `resource` method. If no match can be made,
    the container will respond with an appropriate `not found` HTTP response.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Invoke any registered post-matching filters.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Perform conversion of HTTP data (such as the HTTP entity payload or parameters,
    headers, and so on) into Java objects consumable by the resource method if necessary.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Invoke the `resource` method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Perform exception handling, if necessary.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Invoke any registered response filters.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Perform conversion of Java object(s) to HTTP response data, if necessary.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Return the HTTP response to the client.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'This pipeline flow is illustrated in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.1 – JAX-RS server pipeline flow'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_4.1_-_B17377.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.1 – JAX-RS server pipeline flow
  prefs: []
  type: TYPE_NORMAL
- en: 'In JAX-RS, there are three types of components, outlined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Resources**: The resources are what ultimately make the RESTful service what
    it is as they contain the business logic.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`MessageBodyReader`, `MessageBodyWriter`, `ParamConverter`, `ExceptionMapper`,
    `ReaderInterceptor`, and `WriterInterceptor` are all providers.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Application` subclass is used to provide configuration for the JAX-RS application.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now we understand the basic flow, let's create a simple JAX-RS application.
  prefs: []
  type: TYPE_NORMAL
- en: Hello World!
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A JAX-RS application must contain at least one resource class. Providers are
    optional. An `Application` subclass is only necessary if you don''t have a `web.xml`
    file that specifies an application path. So, a very simple application might look
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: If we build this code into a web application called `myApp.war` and deploy it
    into a JAX-RS container such as Open Liberty, we could quickly test it using an
    HTTP client by browsing to `http://localhost:9080/myApp/rest/hello` and we would
    see the text **Hello World!**.
  prefs: []
  type: TYPE_NORMAL
- en: This works because the `@GET` annotation on the `helloWorld()` method tells
    the JAX-RS container that this method should be invoked when a client issues a
    `GET` request to the `/hello` path of the `/rest` application path under the `.war`
    extension. By default, most HTTP clients (browsers, `curl`, and so on) use `GET`
    unless specified otherwise. This brings up a good point about tooling. When developing
    RESTful applications, it is extremely valuable to have a client tool that can
    issue different types of HTTP requests. Command-line tools such as `curl` are
    very useful, and there are several browser extension-based tools that would also
    work.
  prefs: []
  type: TYPE_NORMAL
- en: A more real-world example
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now we have built a simple JAX-RS application, let''s build a more complex
    application—a thesaurus service where clients can search and update synonyms.
    We''ll start with an **exception mapper**, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Most applications will have `NoSuchWordException` exception, which could be
    used to indicate that a searched word does not exist. It is clear in the application
    that somebody specified a word that does not exist, but it is not clear to an
    HTTP client. The `NoSuchWordExceptionMapper` provider class makes that possible.
    It enables the resource class methods to throw a `NoSuchWordException` exception,
    and the JAX-RS container will map the exception to an HTTP response (in this case,
    a `404 Not Found` error).
  prefs: []
  type: TYPE_NORMAL
- en: 'Next is the resource class (the full source code is available at [https://github.com/PacktPublishing/Practical-Cloud-Native-Java-Development-with-MicroProfile/blob/main/Chapter04/src/main/java/com/packt/microprofile/book/ch4/thesaurus/ThesaurusResource.java](https://github.com/PacktPublishing/Practical-Cloud-Native-Java-Development-with-MicroProfile/blob/main/Chapter04/src/main/java/com/packt/microprofile/book/ch4/thesaurus/ThesaurusResource.java)),
    as illustrated in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'There are a few new annotations on the resource class: `@Produces` and `@Consumes`.
    These annotations can be placed on resource classes or methods—as with most annotations
    of this type in JAX-RS, annotations on the method take priority over annotations
    on the class. These annotations help control the matching of requests and the
    entity providers (`MessageBodyReaders` and `MessageBodyWriters`) to be used in
    deserializing the HTTP entity from the request or serializing the HTTP entity
    in the response.'
  prefs: []
  type: TYPE_NORMAL
- en: HTTP requests and responses may contain a header that indicates the `Content-Type`.
    HTTP requests may also contain a header that specifies the media type(s) that
    it expects to receive in the response—`Accept`. In the absence of these headers,
    all media types are allowed (denoted by, `*/*`).
  prefs: []
  type: TYPE_NORMAL
- en: 'In the previous example, the resource class specifies `MediaType.TEXT_PLAIN`
    or `text/plain`. Other media types include `text/html`, `application/json`, `application/xml`,
    `image/jpeg`, and much more. Specifying `text/plain` would prevent the resource
    methods from being invoked if a request contained a header such as `Content-Type:
    application/pdf` or `Accept: image/png`—instead of invoking the resource method,
    the JAX-RS container would return a `415 Unsupported Media Type` error.'
  prefs: []
  type: TYPE_NORMAL
- en: Best practice
  prefs: []
  type: TYPE_NORMAL
- en: Always use `@Produces` and `@Consumes` to limit media types. This will place
    limits on the types of requests your service will respond to. It will ensure that
    your application (if properly tested) can handle requests of the specified media
    types.
  prefs: []
  type: TYPE_NORMAL
- en: 'This example also introduces new method-level HTTP verb annotations: `@POST`,
    `@PUT`, `@DELETE`, and `@PATCH`. As with `@GET`, these annotations specify which
    method should be invoked based on the HTTP request''s `@HEAD` and `@OPTIONS`,
    which are less commonly used.'
  prefs: []
  type: TYPE_NORMAL
- en: Special note
  prefs: []
  type: TYPE_NORMAL
- en: 'If the resource class contains a method annotated with `@GET` but not `@HEAD`,
    the JAX-RS container would invoke the `@GET` method for matching HTTP `HEAD` requests,
    but it would remove the entity. Likewise, if a resource class contains any HTTP
    verb annotation other than `@OPTIONS`, the JAX-RS container would return a response
    indicating all of the valid verbs that could be matched for that request. Using
    the preceding example, an `OPTIONS` request would result in a response with a
    header such as `Allow: DELETE, HEAD, GET, OPTIONS, PATCH, POST, PUT`.'
  prefs: []
  type: TYPE_NORMAL
- en: This example also introduces the idea of HTTP parameters—specifically, `@PathParam("word")
    String word;`.
  prefs: []
  type: TYPE_NORMAL
- en: This annotation can be placed on fields or method parameters. The value of `@PathParm`
    is `word`, which corresponds to the template variable in the resource class's
    `@Path` value (`"/thesaurus/{word}"`). This means that for an HTTP request such
    as `http://localhost:9080/myApp/rest/thesaurus/funny`, the value injected into
    the `word` field would be `funny`.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are other HTTP parameter types that can be used in JAX-RS, including
    `@QueryParam`, `@FormParam`, `@CookieParam`, `@HeaderParam`, and `@MatrixParam`,
    which all correspond to different parts of an HTTP request. JAX-RS also allows
    multiple HTTP parameter annotations to be aggregated on a single Java class and
    then referenced in the resource class or method as a `@BeanParam` parameter type.
    Here is an example of this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The `ParamBean` bean is just a `@*Param` annotations. Then, this POJO is injected
    into a resource, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '`@BeanParam` beans can be very useful for aggregating common sets of RESTful
    parameters to avoid writing repetitive code. Let''s test this example from the
    command line using `curl`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'One thing to be wary of is that not all parameters will be non-null, so you
    will need to check for null values, or you can use the `@DefaultValue` annotation.
    This applies to method parameters as well. An example is provided here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Notice that the value in the `@DefaultValue` annotation is always a string,
    but as long as it can be converted from a string to the parameter type (`Integer`,
    in this case), it will work. In the next section, we will learn how to convert
    data sent from a client into the Java objects in our application code.
  prefs: []
  type: TYPE_NORMAL
- en: Entity providers and ParamConverter
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: So far, our resource methods have mainly been dealing with strings or other
    primitives. The JAX-RS container is responsible for serializing and deserializing
    those objects, but what if we want to send and receive more complex objects? In
    those cases, we may need to implement some `ParamConverter`.
  prefs: []
  type: TYPE_NORMAL
- en: Entity providers
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Entity providers include `MessageBodyReader` and `MessageBodyWriter`, and they
    are responsible for deserializing HTTP entity data to a Java object and serializing
    a Java object to an HTTP entity, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s say that we have a `Person` object such as this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'And let''s say that we have a `service` object such as this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: One thing to notice here is that the `getPerson(…)` method throws a new `WebApplicationException`
    exception, passing it as a `404` response. This is another way to map an exception
    to a response without needing an `ExceptionMapper` instance.
  prefs: []
  type: TYPE_NORMAL
- en: Best practice
  prefs: []
  type: TYPE_NORMAL
- en: Use `ExceptionMappers` when multiple resource methods may throw the same exception.
    Throw a `WebApplicationException` exception with a passed-in `Response` object
    only in cases where you don't have an appropriate business exception to throw
    or you only throw the exception from one resource method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another thing to notice is the use of `APPLICATION_JSON` as the media type
    that this resource produces and consumes. The `application/json` media type is
    the most common content type used in microservices. `Person` object from the previous
    sample code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'In order for a client to create a new `Person` object via the `POST` method,
    we need a `MessageBodyReader` instance. There are some built-in readers that would
    handle this nicely, but for now, we''ll write and register our own, like this
    (the full source code is available at [https://github.com/PacktPublishing/Practical-Cloud-Native-Java-Development-with-MicroProfile/blob/main/Chapter04/src/main/java/com/packt/microprofile/book/ch4/entityandparamproviders/MyJsonReader.java](https://github.com/PacktPublishing/Practical-Cloud-Native-Java-Development-with-MicroProfile/blob/main/Chapter04/src/main/java/com/packt/microprofile/book/ch4/entityandparamproviders/MyJsonReader.java)):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Furthermore, in order to write a `Person` object as JSON in a response entity,
    we must register a JSON `MessageBodyWriter` instance, like this (the full source
    code is available at [https://github.com/PacktPublishing/Practical-Cloud-Native-Java-Development-with-MicroProfile/blob/main/Chapter04/src/main/java/com/packt/microprofile/book/ch4/entityandparamproviders/MyJsonWriter.java](https://github.com/PacktPublishing/Practical-Cloud-Native-Java-Development-with-MicroProfile/blob/main/Chapter04/src/main/java/com/packt/microprofile/book/ch4/entityandparamproviders/MyJsonWriter.java)):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: These providers could easily be combined into one `MyJsonEntityProvider` class
    that implements both interfaces. Both implementations use `InputStream` to read
    an entity from a client request and `OutputStream` for writing the response entity.
    Both providers have a Boolean check to verify that this is the proper entity provider
    to invoke—in addition to the generic type specified (`Person`) and the `@Consumes`/`@Produces`
    values, returning `true` or `false` for the `isReadable` or `isWriteable` methods
    will tell the JAX-RS container whether this provider should be used to serialize/deserialize
    the data.
  prefs: []
  type: TYPE_NORMAL
- en: Another criterion for selecting among multiple providers would be the `@Priority`
    annotation—the JAX-RS container will select the provider with the highest priority
    (which is the lowest value—thus, `@Priority(1)` would be selected before `@Priority(2)`).
  prefs: []
  type: TYPE_NORMAL
- en: Ultimately, the value returned from the reader's `readFrom` method will be injected
    into the resource method's `@Context` (more on this in the *Context injection*
    section) or `@*Param`. A resource method may contain zero or one entity parameters—any
    more will result in a deployment failure.
  prefs: []
  type: TYPE_NORMAL
- en: On the response side, the content written to the writer's `writeTo` entity stream
    will be written to the HTTP response sent back to the client.
  prefs: []
  type: TYPE_NORMAL
- en: If the amount of code complexity for writing and reading JSON seems a little
    daunting at this point, don't fret! We'll cover a simpler approach in the next
    section.
  prefs: []
  type: TYPE_NORMAL
- en: So, entity providers are responsible for serializing and deserializing HTTP
    entities to objects, but what about parameters such as query parameters, path
    parameters, and so on? These are deserialized with `ParamConverter`
  prefs: []
  type: TYPE_NORMAL
- en: ParamConverter
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Building on our `PersonService` example, let''s add a `PATCH` method allowing
    clients to change a person''s favorite color, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'We can invoke this method from the command line like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'We are able to update John''s favorite color because the JAX-RS container was
    able to identify that `Color` is an enumerated type, and so it will invoke its
    `valueOf(String)` method to get the `Color` object that it injects when invoking
    the `updateFavoriteColor` method. But what happens when we specify the `color`
    in lowercase? Let''s have a look at the following output to find out:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Uh oh! The JAX-RS container could not match the request to a resource method
    (resulting in a `404 Not Found` response) because it could not convert `blue`
    to `Color.BLUE`. In order for our service to be more resilient or to handle more
    complex objects as parameters, we must use `ParamConverterProvider` and `ParamConverter`
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '`ParamConverterProvider` is responsible for returning an instance of a class
    that implements `ParamConverter`, such as this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The first class, `ColorParamConverterProvider`, is the registered provider class.
    When a resource method has a parameter that needs to be converted from `String`
    to an object, the JAX-RS container will invoke the `getContainer` method of any
    registered `ParamConverterProvider` class until one returns a non-null `ParamConverter`
    instance.
  prefs: []
  type: TYPE_NORMAL
- en: The `ColorParamConverter` class simply capitalizes the string value to ensure
    that the enum's `valueOf` method will return the `Color.BLUE` color, regardless
    of whether the client request's query parameter was `BLUE`, `Blue`, `blue`, `bLuE`,
    and so on.
  prefs: []
  type: TYPE_NORMAL
- en: '`ParamConverter` work for `@QueryParam` parameters as demonstrated, but also
    work for `@CookieParam`, `@FormParam`, `@HeaderParam`, `@MatrixParam`, and `@PathParam`
    parameters, and they can be used to convert a string to any object, and vice versa.
    The conversion from object to `String` is important on the client side. We''ll
    discuss that in the *Consuming RESTful services with the MicroProfile Rest Client*
    section.'
  prefs: []
  type: TYPE_NORMAL
- en: Intercepting requests and responses
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There may be times when you need to check the input stream of a request before
    or after processing it in the `MessageBodyReader` entity provider. Likewise, there
    may be times where you want to perform additional processing to the output stream
    before or after processing it in the `MessageBodyWriter` entity provider. `ReaderInterceptors`
    and `WriterInterceptors` are intended for such tasks.
  prefs: []
  type: TYPE_NORMAL
- en: ReaderInterceptors and WriterInterceptors
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In our `MessageBodyReader` entity provider, we make a lot of calls to trim
    strings, which can be expensive in terms of performance. One way we might be able
    to reduce such calls would be to remove whitespace from the entity stream in a
    `ReaderInterceptor` provider so that then the `MessageBodyReader` provider could
    always assume that the stream contains no whitespace characters. Here''s an example
    of this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'When a client sends a multiline request entity with spaces, line feeds, or
    other white space, you can see that this will convert them with the system output,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: A common use case for `WriterInterceptors` is to reduce the response entity
    size by using GZIP compression—see a full example of this at [https://github.com/PacktPublishing/Practical-Cloud-Native-Java-Development-with-MicroProfile/blob/main/Chapter04/src/main/java/com/packt/microprofile/book/ch4/interceptorsandfilters/GzipWriterInterceptor.java](https://github.com/PacktPublishing/Practical-Cloud-Native-Java-Development-with-MicroProfile/blob/main/Chapter04/src/main/java/com/packt/microprofile/book/ch4/interceptorsandfilters/GzipWriterInterceptor.java).
  prefs: []
  type: TYPE_NORMAL
- en: Special note about entity streams
  prefs: []
  type: TYPE_NORMAL
- en: While you can read the entity stream from multiple places (entity providers,
    reader or writer interceptors, filters—we'll cover these shortly), you can run
    into problems when you do. For example, your initial request entity stream may
    not support re-reading, so if you attempt to read it twice, you may end up with
    an `IOException` exception. In that case, you may need to reset the stream (if
    the stream supports resetting—each JAX-RS container may be a little different)
    or copy and replace the stream entirely as we did in our `ReaderInterceptor` example.
  prefs: []
  type: TYPE_NORMAL
- en: Filters
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Where `ReaderInterceptors` and `WriterInterceptors` intercept the reading and
    writing of entity streams, **filters** intercept the overall request and response.
    Filters enable some powerful cross-cutting abilities in RESTful applications.
    So, what can we use filters for? We could probably fill the rest of this book
    with useful examples, from managing authentication, authorizing requests, redirecting
    requests, managing headers, aborting invalid requests before wasting server resources
    on them, audit logging requests/responses, detecting suspicious activity, providing
    application statistics, tracing requests/responses, throttling requests from specific
    clients, and more.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start with an example that checks incoming requests for an API key and
    returns a useful response if none exists, if it is unrecognized, or if that API
    key has exceeded the maximum number of requests for the day (the full source code
    is available at [https://github.com/PacktPublishing/Practical-Cloud-Native-Java-Development-with-MicroProfile/blob/main/Chapter04/src/main/java/com/packt/microprofile/book/ch4/interceptorsandfilters/ApiKeyCheckFilter.java](https://github.com/PacktPublishing/Practical-Cloud-Native-Java-Development-with-MicroProfile/blob/main/Chapter04/src/main/java/com/packt/microprofile/book/ch4/interceptorsandfilters/ApiKeyCheckFilter.java)).
    Have a look at the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: This example checks that the client sent an API key as an HTTP header, that
    the API key is valid (by its existence in the map), and that the user's key has
    not exceeded their quota of requests. If any of these conditions occur, the filter
    will abort the request and return a response with useful data for the client.
    If the filter method exits normally, then the request will proceed, and the JAX-RS
    container will attempt to match the request to a resource class and method.
  prefs: []
  type: TYPE_NORMAL
- en: Once the request has been matched to a resource method, the JAX-RS container
    will invoke post-match request filters. These filters are useful for performing
    `ContainerRequestFilter`) as pre-match filters, but without the `@PreMatching`
    annotation. Post-match filters also enable more methods from the `RequestContext`
    object so that it knows which resource will be invoked. This is handy for situations
    where your filter may want to behave differently based on the resource class/method
    it will invoke.
  prefs: []
  type: TYPE_NORMAL
- en: Response filters are similar to request filters but are invoked after the resource
    method has been completed. Response filters can then further refine or transform
    the response. They could add or modify response headers or cookies. They could
    also replace the response entity entirely, though a `MessageBodyWriter` provider
    and/or `WriterInterceptor` provider might be more appropriate for that.
  prefs: []
  type: TYPE_NORMAL
- en: Dynamic providers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: So far, all of the providers we have discussed will apply to all requests—or
    at least all matched requests—the only exception being entity providers, which
    will apply to all requests of the request's specified media type(s). But what
    if we want some providers to only be executed in certain circumstances, such as
    when a specific resource method is invoked or if the request contains specific
    content, or if the client's user is part of a special group? JAX-RS provides a
    few different mechanisms for more dynamic providers. First, we'll look at name
    binding.
  prefs: []
  type: TYPE_NORMAL
- en: '**Name binding** allows users to place a custom annotation on one or more provider
    classes and one or more resource classes or methods. The JAX-RS container will
    then recognize that annotation and only invoke the provider if the target resource
    method or class is also annotated. For example, suppose we want to log certain
    requests; we might create an annotation like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The `@NameBinding` annotation is what tells the JAX-RS container to pay attention
    to this annotation. We can now create a filter that logs the request method, the
    **Uniform Resource Identifier** (**URI**), and the request and response entity
    (the full source code is available at [https://github.com/PacktPublishing/Practical-Cloud-Native-Java-Development-with-MicroProfile/blob/main/Chapter04/src/main/java/com/packt/microprofile/book/ch4/dynamicbinding/LoggingFilter.java](https://github.com/PacktPublishing/Practical-Cloud-Native-Java-Development-with-MicroProfile/blob/main/Chapter04/src/main/java/com/packt/microprofile/book/ch4/dynamicbinding/LoggingFilter.java)).
    Have a look at the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: This `filter` class is both a request and response filter. While it is very
    convenient to combine request and response filters (or perhaps even other provider
    types), it is important to note that the life-cycle behavior may change from one
    JAX-RS container to another. In general, it is considered a best practice not
    to store data in instance variables. If you want to store a piece of data from
    the request's filter method to be used in the response's filter method, a more
    portable approach would be to store that data in `requestContext` as a property,
    as we did for the request **identifier** (**ID**) in the preceding example.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we would just add the `@Logged` annotation to the classes (all methods
    in the class) or methods that should be logged, so in the following example, only
    the `POST` method would be logged (the full source code is available at [https://github.com/PacktPublishing/Practical-Cloud-Native-Java-Development-with-MicroProfile/blob/main/Chapter04/src/main/java/com/packt/microprofile/book/ch4/dynamicbinding/DynamicResource.java](https://github.com/PacktPublishing/Practical-Cloud-Native-Java-Development-with-MicroProfile/blob/main/Chapter04/src/main/java/com/packt/microprofile/book/ch4/dynamicbinding/DynamicResource.java)):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Another approach to dynamically apply providers is to use `configure`, which
    provides a `ResourceInfo` object that is used to determine specifics of the matched
    resource, and a `FeatureContext` object that is used to configure the providers
    and properties or view the application configuration for each request. The following
    example will add the `LoggingFilter` class to all resource methods that start
    with `get`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Since the `ResourceInfo` object will return the matched class and method, it
    is also possible to check the annotations of the matched resource. This makes
    it easy for dynamic features to register a provider for all requests of a specific
    HTTP verb (`if (resourceInfo.getResourceMethod().getAnnotation(GET.class) != null)
    { //…` ) or methods with annotations that don't already have the `@NameBinding`
    annotation.
  prefs: []
  type: TYPE_NORMAL
- en: Name binding annotations and dynamic filters are powerful ways to control request
    and response processing.
  prefs: []
  type: TYPE_NORMAL
- en: Async
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Enough with providers! Let's get back to the core of RESTful services—the resources.
    In many cases, the synchronous nature of the JAX-RS request/response flow is inefficient.
    For example, suppose your resources tend to pass a request to a data store that
    looks up or modifies data in a database. If your data store logic has a fixed
    set of threads performing the database operations, then when the service is under
    load, incoming requests may be queued. With the synchronous flow we've been working
    with so far, this means that the flow of execution would block inside the resource
    method waiting for the data-store logic to complete before completing the flow.
    This can be inefficient as one thread essentially waits for another to complete.
    That initial thread could be more efficient if it were to perform some other task
    while the data-store operations take place. Using **asynchronous** APIs in JAX-RS
    can obtain that increased efficiency.
  prefs: []
  type: TYPE_NORMAL
- en: AsyncResponse
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Asynchronous methods in JAX-RS are created by adding an `AsyncResponse` parameter
    to the resource method, annotated with `@Suspended`. The `AsyncResponse` object
    may then be used to *resume* the request once the data has been fetched from the
    data store. Let''s take a look at an example. Suppose we have a service that tracks
    people, like the one we used in the *Entity providers* section. We''ll change
    the resource class around a little so that the data store access uses a separate
    `Executor` class to retrieve the data (the full source code is available at [https://github.com/PacktPublishing/Practical-Cloud-Native-Java-Development-with-MicroProfile/blob/main/Chapter04/src/main/java/com/packt/microprofile/book/ch4/async/AsyncPersonService.java](https://github.com/PacktPublishing/Practical-Cloud-Native-Java-Development-with-MicroProfile/blob/main/Chapter04/src/main/java/com/packt/microprofile/book/ch4/async/AsyncPersonService.java)).
    Have a look at the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: In this version of the code, the `getPersonSync` method will submit a request
    to the executor service to retrieve the `Person` object with the specified ID,
    then it will block until the executor service has completed the operation. In
    this case (for code simplicity), it is just pulling data out of a hash map, but
    if it were pulling data out of a remote database, the time spent blocking in the
    `someData.get()` call could be more substantial.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, let''s try to improve the efficiency so that we don''t have to block. We
    can rewrite the `getPersonSync()` method to look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Now, the executor service is invoking the `getPerson(id)` method, but then passing
    the result to `ar.resume(…)`, which will pick up the request/response flow where
    it left off and return a response. The request thread that invoked the `getPersonAsync(…)`
    method immediately returns and can be used to service another request.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `AsyncResponse` object can also be used to handle an exception. Let''s
    say that we want to throw a `NoSuchPersonException` exception if the ID specified
    does not match any `Person` instance in the database. We might change the code
    to look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: When we resume a response with an exception, the JAX-RS container will attempt
    to map the exception to a suitable response, just as it does in the synchronous
    case.
  prefs: []
  type: TYPE_NORMAL
- en: Server-sent events
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Another form of server-side async is **server-sent events** (**SSEs**). SSEs
    are a part of the **HyperText Markup Language 5** (**HTML 5**) specification and
    provide a way for a client to register and receive events asynchronously from
    a server.
  prefs: []
  type: TYPE_NORMAL
- en: 'JAX-RS has two ways of sending SSEs—streaming directly to each client and **broadcasting**
    to all clients. Let''s take a look at how you might implement the first way, as
    follows (the full source code is available at [https://github.com/PacktPublishing/Practical-Cloud-Native-Java-Development-with-MicroProfile/blob/main/Chapter04/src/main/java/com/packt/microprofile/book/ch4/async/SseService.java](https://github.com/PacktPublishing/Practical-Cloud-Native-Java-Development-with-MicroProfile/blob/main/Chapter04/src/main/java/com/packt/microprofile/book/ch4/async/SseService.java)):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: This is a contrived example, but it shows the method immediately returns after
    starting a new thread that sends a few text events to the client separated by
    a half-second delay.
  prefs: []
  type: TYPE_NORMAL
- en: This example shows us that in order for a JAX-RS resource to send SSEs, it must
    produce the SSE media type (`MediaType.SERVER_SENT_EVENTS`, or `text/event-stream`)
    and the method must receive `Sse` and `SseEventSink` parameters, both annotated
    with `@Context`. The `Sse` type is a utility class that can create events and
    broadcasters. The `SseEventSink` type represents the connection between the server
    and the client, so calling the `send(…)` method sends a new event to that specific
    client, and calling the `close()` method (which is done implicitly by the try-with-resources
    logic) will gracefully close the connection with the client.
  prefs: []
  type: TYPE_NORMAL
- en: The events we are sending have a `text/plain` media type—the media type is used
    to determine which `MessageBodyWriter` provider should be used to serialize that
    object passed to the data method. The `name(…)` and `id(...)` methods can provide
    additional context to each event sent. Only the `data(…)` method is required,
    though it is always a best practice to specify the media type.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we were to invoke this service using `curl`, we would see something like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Another approach to sending events is to use a `SseEventSinks`, and it will
    send events to all registered clients. Let''s look at an example of code that
    we might add to our `SseService` class, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: As with the direct-stream approach, this approach also requires that the method
    produce a media type of `SERVER_SENT_EVENTS` and that the method has the `SseEventSink`
    and `Sse` parameter types.
  prefs: []
  type: TYPE_NORMAL
- en: First, we need to set `SseBroadcaster` as a static field. We do this because
    the default life cycle for JAX-RS resources is per request. We will discuss alternate
    life cycles in the *Managing life cycle and DI with CDI* section—that will simplify
    this code and improve performance too.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once we have the broadcaster set, we then register the event sink with it.
    Once registered, the client associated with that event sink will receive all events
    sent from this broadcaster. In this example, we broadcast an event any time a
    new client is registered and every 5 seconds. Let''s see what this looks like
    on the command line when using `curl` when we are the first client, and when a
    second client registers (from a separate command window), as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: One thing to notice about this output is the `UnnamedEvent` text—this is because
    SSEs must have a name, so if no name is provided when it is built, the JAX-RS
    container creates a name for it. Other JAX-RS containers may use a different name
    if none is specified.
  prefs: []
  type: TYPE_NORMAL
- en: Context injection
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We''ve already discussed injection when using the `@Context` annotation for
    SSE objects, but this annotation can be used for a lot more. **Context injection**
    can occur in both resources and providers. There are lots of useful things you
    can inject, as outlined here:'
  prefs: []
  type: TYPE_NORMAL
- en: '`ResourceContext`: Used for initializing sub-resource locators'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ResourceInfo`: Used for determining the matched resource class and method'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`HttpHeaders`: Used for reading HTTP headers in the client request'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SecurityContext`: Used for determining the current user, their security role,
    and so on'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`UriInfo`: Used for reading the URI of the client request'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Application`: Used for obtaining the application representing this RESTful
    service'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Providers`: Used for accessing other JAX-RS providers'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Sse` and `SseEventSink`: Discussed in the previous section'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Best practice
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: In most cases, it is recommended that context injection occurs in fields rather
    than as parameters. The reason for this is that the Jakarta REST project is intending
    to deprecate the `@Context` annotation in favor of CDI's `@Inject` annotation,
    which does not target method parameters.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Javadoc** ([https://jakarta.ee/specifications/restful-ws/2.1/apidocs/overview-summary.html](https://jakarta.ee/specifications/restful-ws/2.1/apidocs/overview-summary.html))
    is the best resource for understanding the capabilities of each of these injectable
    types. Here are a few basic examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'This example uses the role of the client''s user principal to determine what
    entity response to return. The following example uses the `ResourceInfo` class
    to determine whether a `MessageBodyWriter` provider should be used or not:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: The injection of context objects into resources and providers enables us to
    develop powerful and flexible applications. Now, let's turn our attention to formatting
    the data our application will need to send and receive.
  prefs: []
  type: TYPE_NORMAL
- en: Managing the payload with JSON-P and JSON-B
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While RESTful services in general and JAX-RS applications specifically can serve
    entities of any media type (plain text, **Extensible Markup Language** (**XML**),
    **Portable Document Format** (**PDF**), binary, and so on), JSON is the *standard
    du jour* for cloud-native applications. JSON is popular because it is both human-readable
    and easily parsed— libraries for JSON parsing and binding exist in virtually all
    modern languages.
  prefs: []
  type: TYPE_NORMAL
- en: In the *Entity providers* section, we got a taste of serializing and deserializing
    a Java object (`Person`) into JSON. In that section, we performed this by hand
    using string manipulation. While a manual approach can work, we're now going to
    discuss two APIs that enable simpler and more powerful control over JSON in Java.
  prefs: []
  type: TYPE_NORMAL
- en: JSON-P is a programmatic API for manipulating JSON, while JSON-B is a declarative
    (annotation-based) API for quickly and easily mapping an object to JSON or vice
    versa.
  prefs: []
  type: TYPE_NORMAL
- en: JSON-P
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`JsonObject`, `JsonArray`, and so on, which are part of the object model API.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s say we have some objects such as these:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'And let''s say we want to convert that into JSON content that looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: We'll start out by converting an instance of `Starship` into a JSON string.
    We can do this by using the `Json` class to create object builders and array builders.
    These builders can create objects by adding properties or objects. So, to create
    the JSON for a starship, we would need an object builder for the starship and
    for each weapon, and then an array builder for all of the weapons. An example
    of this is available at [https://github.com/PacktPublishing/Practical-Cloud-Native-Java-Development-with-MicroProfile/blob/main/Chapter04/src/main/java/com/packt/microprofile/book/ch4/jsonp/JsonpConverter.java](https://github.com/PacktPublishing/Practical-Cloud-Native-Java-Development-with-MicroProfile/blob/main/Chapter04/src/main/java/com/packt/microprofile/book/ch4/jsonp/JsonpConverter.java).
  prefs: []
  type: TYPE_NORMAL
- en: Each object needs its own `JsonObjectBuilder` instance, and each array or collection
    needs its own `JsonArrayBuilder` instance. Then, you simply add items to them.
  prefs: []
  type: TYPE_NORMAL
- en: 'Deserializing a JSON string into an object works in the opposite way. First,
    you must extract `JsonObject` instance from `JsonReader`, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, you must create a `Starship` instance and populate it from the properties
    in the `JsonObject`, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: This approach uses the object model, which requires loading the entire JSON
    stream into memory before it can be converted into an object. For small JSON files,
    this is not an issue, and it allows the model to be stored in memory and re-accessed.
    It also allows the model to be changed over time before writing the JSON back
    to a stream.
  prefs: []
  type: TYPE_NORMAL
- en: 'The streaming approach requires far less memory and is capable of reading extremely
    large JSON streams without running out of memory. It accomplishes this by firing
    events as it reads the JSON and then discards that portion of the JSON. This is
    very efficient and performs better than the object model, but it requires more
    complex coding, and since the object model is not in memory, you cannot go back
    later to ask it: *Now, what was the value again?*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Using the same Java object and JSON stream as before, here is what the serialization
    code looks like (the full source code is available at [https://github.com/PacktPublishing/Practical-Cloud-Native-Java-Development-with-MicroProfile/blob/main/Chapter04/src/main/java/com/packt/microprofile/book/ch4/jsonp/JsonpStreamingConverter.java](https://github.com/PacktPublishing/Practical-Cloud-Native-Java-Development-with-MicroProfile/blob/main/Chapter04/src/main/java/com/packt/microprofile/book/ch4/jsonp/JsonpStreamingConverter.java)):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Similar to `JsonObjectBuilder` and `JsonArrayBuilder`, `JsonGenerator` can pass
    in map-like values to build the JSON object. Unlike the object model builder APIs,
    `JsonGenerator` cannot make changes—once the JSON is written, you cannot change
    the values. Both of the builders have `remove` methods, and the `JsonArrayBuilder`
    API has setter methods, allowing you to change previously configured values. The
    reason for having these two approaches is to allow you to make a decision between
    flexibility and efficiency.
  prefs: []
  type: TYPE_NORMAL
- en: 'For parsing JSON into an object, a stream-based approach is even more complex,
    as we can see here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'The parser works similar to a Java iterator, returning events to indicate things
    such as object start (`{`), object end (`}`), array start (`[`), array end (`]`),
    key names (for example, `name` and `speedRating`), and key values (for example,
    `Coreillian Freighter` and `24`). It is important that each event is interpreted
    within its context. For example, an array might contain several objects, so it
    is necessary to keep track of which object is currently being parsed to avoid
    mixing up data. The `parseWeapons` method provides an example of this by separately
    parsing each item in the array, as illustrated in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: JSON-P provides a very powerful API set for reading and writing JSON programmatically.
    The code can tend to be a tad verbose, though. That's something that JSON-B can
    help with.
  prefs: []
  type: TYPE_NORMAL
- en: JSON-B
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: While JSON-P is very powerful and flexible, **JSON-B** is very simple and efficient
    at serializing and deserializing objects to JSON. JSON-B has some programmatic
    APIs but overall, it takes a declarative approach to writing/reading JSON. This
    means that the conversion of an object to JSON will be based on the object type's
    getter methods—and likewise, the conversion of JSON to object will be based on
    the object type's setter methods.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we use the example objects of `Starships` and `Weapons` from JSON-P, the
    conversion of object to JSON and vice versa is very simple, as is illustrated
    here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'It is possible to convert directly to a string but using `OutputStream` or
    `Writer` is preferable, especially when dealing with large JSON objects. The primary
    objects here are `Jsonb` and the `toJson(…)` method. You can see the output here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'This looks very similar to what we created using JSON-P, but it''s all on one
    line and difficult to distinguish where one object ends and the next begins. For
    most JSON consumers that should not be a problem, but if we want to make it more
    human-readable, we can add some configuration by replacing the `JsonbBuilder.create()`
    method call with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'This will produce the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: There are several other configuration options that you could use to handle the
    serialization of a Java object.  For example, you could also add your own `JsonParser`
    from JSON-P to convert the object to JSON your own way.
  prefs: []
  type: TYPE_NORMAL
- en: 'Converting JSON back into an object is just as simple, as we can see here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: And as with the `toJson(…)` method, you can use a string or a stream.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, what happens if you have an object, but you want the JSON fields to have
    a different name than the Java property name? Or, maybe you don''t want certain
    fields to be exposed as JSON at all? That''s where annotations such as `@JsonbProperty("someOtherName")`
    and `@JsonbTransient` come in handy, and depending on where you place the annotation,
    it will have a different effect. If the annotation is on the getter, then it will
    only apply to serialization (conversion from Java to JSON). If the annotation
    is on the setter, then it will only apply deserialization. If the annotation is
    on the field itself, then it will apply to both. Let''s consider the following
    code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'We would create an instance of `Person` and print it out to JSON, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'The output would look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'The `lastName` field has been converted to `familyName`, the `middleName` field
    has not been printed at all, and the `favoriteColor` field has been Britishized
    to `favouriteColour`. But if we tried to create a new `Person` instance from this
    JSON, we would get an incomplete `Person` instance. Let''s take a look, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'This would yield the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: The `middleName` field was missing from the JSON, so it is no surprise that
    it is null. Since the `@JsonbProperty("favouriteColour")` annotation is only on
    the getter, JSON-B will not convert the Britishized JSON field to the Americanized
    Java field. And since the `@JsonbProperty("yearsOld")` annotation is applied to
    the `setAge(…)` method, it will not be set since the JSON is still using the `age`
    field name.
  prefs: []
  type: TYPE_NORMAL
- en: The behavior differences depending on where an annotation is placed are important
    to note when using JSON-B.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's tie this back to JAX-RS. The JAX-RS specification says that a product
    that supports JSON-P must supply `MessageBodyReaders` and `MessageBodyWriters`
    for entity types of `JsonStructure`, `JsonObject`, `JsonArray`, `JsonString`,
    and `JsonNumber`. Furthermore, a product that supports JSON-B must supply `MessageBodyReaders`
    and `Writers` for any object type when the media type is `application/json`, `text/json`,
    `*/json`, `or` `*/*+json`. Any product that implements the entire MicroProfile
    set of specifications will have JAX-RS, JSON-P, and JSON-B. This means that for
    the most part, you can count on your JAX-RS container to handle the conversion
    of JSON to objects and back to JSON.
  prefs: []
  type: TYPE_NORMAL
- en: Now we've learned the easy way to work with JSON, let's learn how we can send
    requests and consume results using the client APIs.
  prefs: []
  type: TYPE_NORMAL
- en: Consuming RESTful services with the MicroProfile Rest Client
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Thus far, we've covered how we can design elaborate RESTful services and how
    we can easily transform JSON into Java objects and vice versa. Next up, we need
    to consume those services using the client APIs. In a microservice architecture,
    RESTful clients are critical for invoking remote services.
  prefs: []
  type: TYPE_NORMAL
- en: JAX-RS Client APIs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'One way to consume RESTful services is with the **JAX-RS Client APIs**. Similar
    to JSON-P (as opposed to JSON-B), these APIs tend to be more programmatic with
    more control over individual options, such as headers, path construction, and
    so on. Let''s take a look at some code using the thesaurus example from earlier
    in this chapter, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: The client instance is built using `ClientBuilder`. In this example, it simply
    builds a `Client` instance, but you could use `ClientBuilder` to set configuration
    properties or register client-side providers. `Client` instances should be explicitly
    closed when you are done using them—they currently do not implement the `AutoCloseable`
    interface, but a future version of the JAX-RS specification will add that, allowing
    `Client` instances to be closed in a try-with-resources block.
  prefs: []
  type: TYPE_NORMAL
- en: '`WebTarget` represents the destination of the client request. It has methods
    for appending path elements, resolving path template variables, adding query or
    matrix parameters, or specifying the expected response media type. In the previous
    example, we append the `word` variable to the `uri` variable with this line of
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, we could change the `uri` variable to `http://localhost:9080/rest/thesaurus/{word}`,
    then we could use the following line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: Depending on the situation, either might be more usable.
  prefs: []
  type: TYPE_NORMAL
- en: An `Invocation.Builder` object is created by calling the `request(…)` method
    on the `WebTarget`—an optional media type parameter is used to determine what
    media type is expected for the response; it will set the `Accept` header. The
    `Invocation.Builder` object has methods such as `get(…)`, `post(…)`, `put(…)`,
    `delete(…)`, and other methods that represent the HTTP verb to use for the request.
    You can use the `method(…)` method to specify HTTP verbs that are not built into
    the API. It also has methods for setting cookies or headers.
  prefs: []
  type: TYPE_NORMAL
- en: The `Invocation.Builder` object also has `async()` and `rx()` methods that will
    return an asynchronous invoker and reactive invoker, respectively. These invokers
    enable users to retrieve the response asynchronously, which will generally improve
    performance.
  prefs: []
  type: TYPE_NORMAL
- en: The `Response` object represents the HTTP response from the remote server. From
    the `Response` object, you can check the status code of the response (`200`, `204`,
    `400`, `404`, `500`, and so on) and response headers, read the response entity,
    and more. Note that the `Response` object is `AutoCloseable`—it is always a good
    practice to close both `Response` and `Clientobjects`.
  prefs: []
  type: TYPE_NORMAL
- en: MicroProfile Rest Client
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If the JAX-RS Client is similar to JSON-P, then the `@Path`, `@GET`, `@PUT`,
    `@POST`, `@DELETE`, and so on, annotations. The MicroProfile Rest Client implementation
    provides an instance of the interface, which you can then invoke in order to invoke
    the remote service.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at an example, as follows (the full source code is available
    at [https://github.com/PacktPublishing/Practical-Cloud-Native-Java-Development-with-MicroProfile/blob/main/Chapter04/src/main/java/com/packt/microprofile/book/ch4/client/ThesaurusClient.java](https://github.com/PacktPublishing/Practical-Cloud-Native-Java-Development-with-MicroProfile/blob/main/Chapter04/src/main/java/com/packt/microprofile/book/ch4/client/ThesaurusClient.java)):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'The methods here match the five resource methods in the `ThesaurusResource`
    class, with the exception that the `@PathParam` parameter is a method parameter.
    These methods all return a `String` object, but they could also return a `Response`
    object if it was important to view things in the response such as headers or status
    code, and so on. Usually, these things can be abstracted so that you can return
    the actual data type. This interface approach allows us to invoke the service
    by simply calling these methods. But first, we need to build an instance of this
    client. If we are in an environment that uses CDI (see the next section) and MicroProfile
    Config (see [*Chapter 5*](B17377_05_Final_SB_epub.xhtml#_idTextAnchor091), *Enhancing
    Cloud-Native Applications*), then the framework can automatically build and inject
    the client instance. Otherwise (or if you just want to build the instance programmatically),
    you can use the `RestClientBuilder` API, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'This sets `baseUri`, the URI path up to the point where the `@Path` annotation
    is added. Similar to the JAX-RS `ClientBuilder` API, we could also use the `RestClientBuilder`
    API to specify properties for the client instance or register providers. Once
    we''ve built the client instance, we can invoke it like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: Client-side providers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'That''s a nice way to invoke the service—a lot less code and it reads easier
    too! You might be thinking: *That method throws an exception—how does the implementation
    know when it should throw it?* Excellent question! The answer is `ResponseExceptionMapper`.
    It is basically the converse of JAX-RS `ExceptionMapper`—instead of mapping an
    exception to a response, they map a response to an exception. By default, MicroProfile
    Rest Client implementations will throw a `WebApplicationException` on any response
    with a status code of `400` or higher— those codes are client errors or server
    errors. To map more specific responses to exceptions, you would need to register
    one or more `ResponseExceptionMapper`, such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: This response exception mapper implements two methods. The first, `handles(…)`,
    is used to inform the client implementation of whether it should use this mapper
    for the current response. If it returns `true`, then the client implementation
    will invoke the `toThrowable(…)` method to obtain the exception it should throw.
    If the `handles(…)` method returns `false`, then the client implementation will
    check any other registered response exception mappers before assuming that the
    response was successful and simply returning a valid value to the client caller
    rather than throwing an exception.
  prefs: []
  type: TYPE_NORMAL
- en: Special note
  prefs: []
  type: TYPE_NORMAL
- en: The `toThrowable(…)` method should *return* the exception, not throw it. The
    client implementation will actually throw the exception; it just needs to know
    which exception to throw.
  prefs: []
  type: TYPE_NORMAL
- en: 'As with server-side providers, client-side providers need to be registered.
    There are two ways to register client providers. First, you can register them
    from the `RestClientBuilder` API before building the client, as illustrated in
    the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'A second way to register a client provider is to use one or more `@RegisterProvider`
    annotations on the client interface, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: You can register as many of the same types of providers on the client side as
    you would on the server, including `MessageBodyReader` and `Writer`, `Reader`,
    and `WriterInterceptors`. You may not register `ExceptionMappers` or server-side
    filters (`ContainerRequestFilter` or `ContainerResponseFilter`). You may, however,
    register client-side filters (`ClientRequestFilter` or `ClientResponseFilter`)—they
    work in much the same way as server-side filters.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: The `ClientRequestFilter` filter's `ClientRequestContext` has an `abortWith(Response)`
    method similar to the `ContainerRequestFilter` filter. This method can be useful
    in test code for mocking different server responses.
  prefs: []
  type: TYPE_NORMAL
- en: All of these client-side providers will work with either client, the JAX-RS
    Client and the MicroProfile Rest Client, except for `ResponseExceptionMapper`—these
    will only work with the MicroProfile Rest Client.
  prefs: []
  type: TYPE_NORMAL
- en: Async
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Both JAX-RS Client and the MicroProfile Rest Client are capable of invoking
    services asynchronously. This is perhaps even more powerful on the client than
    on the server, as a client will often run in resource-constrained environments
    and may be called upon to perform multiple requests in order to achieve its goal.
  prefs: []
  type: TYPE_NORMAL
- en: 'The JAX-RS Client invokes services asynchronously by creating an `AsyncInvoker`
    instance that will produce `java.util.concurrent.Future` objects that reference
    the response objects or allow the user to specify an `InvocationCallback` that
    is notified when the response is available (or if there was an exception during
    the request/response). Here is an example of the `Future` approach:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'This code looks very similar to the synchronous code from earlier in this section
    and makes for a very simple way to perform asynchronous client requests. Next,
    let''s see how we would use `InvocationCallbacks`, as follows (the full source
    code for this and the `Future` approach is available at [https://github.com/PacktPublishing/Practical-Cloud-Native-Java-Development-with-MicroProfile/blob/main/Chapter04/src/main/java/com/packt/microprofile/book/ch4/client/JAXRSClient.java](https://github.com/PacktPublishing/Practical-Cloud-Native-Java-Development-with-MicroProfile/blob/main/Chapter04/src/main/java/com/packt/microprofile/book/ch4/client/JAXRSClient.java)):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: This example shows how you might look up multiple words. It sends multiple requests
    in parallel to the server, and the `completed` method of `InvocationCallback`
    is invoked when the response is available.
  prefs: []
  type: TYPE_NORMAL
- en: 'Asynchronous requests in the MicroProfile Rest Client are slightly different.
    The client interface methods must return `CompletionStage` that wraps the intended
    return type. So, we would modify our client interface to look like this (the full
    source code is available at [https://github.com/PacktPublishing/Practical-Cloud-Native-Java-Development-with-MicroProfile/blob/main/Chapter04/src/main/java/com/packt/microprofile/book/ch4/client/ThesaurusAsyncClient.java](https://github.com/PacktPublishing/Practical-Cloud-Native-Java-Development-with-MicroProfile/blob/main/Chapter04/src/main/java/com/packt/microprofile/book/ch4/client/ThesaurusAsyncClient.java)):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice that none of these methods declare that they throw any exceptions. That
    is because any exception processing occurs after the processing of the returned
    `CompletionStage`. This is how we might invoke this client:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: Like the JAX-RS Client callback example, this example looks up the synonyms
    for multiple words simultaneously. By using `CompletionStage`, we can easily handle
    exceptions or perform additional processing inline.
  prefs: []
  type: TYPE_NORMAL
- en: Remember another form of asynchronous operations is SSEs. The JAX-RS Client
    APIs allow you to receive events in the form of `InboundSseEvent` objects. The
    MicroProfile Rest Client goes a step further and allows you to receive events
    using `Publisher` objects. The events can be `InboundSseEvent` objects that allow
    you to read extra metadata on each event or as a specific Java type, so long as
    you have `MessageBodyReader` to convert the event into that type.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we want to consume the SSE events from the service we wrote at the end of
    the *Building a RESTful Service with Jakarta REST* section, we might write a client
    interface that looks something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'The client interface is simple enough, right? So, this is how you might use
    it (the full source code is available at [https://github.com/PacktPublishing/Practical-Cloud-Native-Java-Development-with-MicroProfile/blob/main/Chapter04/src/main/java/com/packt/microprofile/book/ch4/async/MPSseConsumerResource.java](https://github.com/PacktPublishing/Practical-Cloud-Native-Java-Development-with-MicroProfile/blob/main/Chapter04/src/main/java/com/packt/microprofile/book/ch4/async/MPSseConsumerResource.java)):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: Once the `Publisher` is returned from the client interface, a caller can subscribe
    to it and control the flow of the SSEs via the `request(int)` method of `Subscription`.
    The `onNext` callback method is invoked for each new event (so long as it has
    been requested). The `onError` callback is invoked when an error occurs (for example,
    not being able to find a `MessageBodyReader` that can deserialize the event).
    The `onComplete` callback is invoked when the connection with the server has been
    closed.
  prefs: []
  type: TYPE_NORMAL
- en: Propagating HTTP headers from server to client
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Quite often, you may need to construct a RESTful service that needs to consume
    other RESTful services. This might be part of a gateway or delegation pattern,
    or it may be that your service needs to aggregate other services such as the following
    service, where a vacation service may need to make reservations for airlines,
    hotels, entertainment venues, and so on:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.2 – Aggregating service'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_4.2_-_B17377.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.2 – Aggregating service
  prefs: []
  type: TYPE_NORMAL
- en: In these situations, it is often useful to propagate headers from the original
    request to the delegated requests. For example, suppose you want to reuse the
    authentication credentials sent on the original request when making the subsequent
    requests; the MicroProfile Rest Client has some built-in mechanisms that make
    this easy to do.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, you must annotate your client interface with `@RegisterClientHeaders`
    and then specify a comma-separated list of headers that the container should automatically
    propagate in a MicroProfile Config property, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, you can specify headers declaratively in the client interface, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: In this code, the `AgentID` header with the hardcoded value `Bob's Travel Co.`
    would be sent on every request from this client since the `@ClientHeaderParam`
    annotation is applied to the interface. When the `makeReservation` method is invoked,
    the MicroProfile Rest Client implementation will invoke the `newId` method to
    obtain the value of the `RequestID` header—the value of the header is the return
    value of a method because the annotation value is surrounded by curly braces.
  prefs: []
  type: TYPE_NORMAL
- en: Both of these approaches allow headers to be sent without needing to modify
    the signature of the client interface method.
  prefs: []
  type: TYPE_NORMAL
- en: Managing life cycle and DI with CDI
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: By default, JAX-RS resources are created for each request. While this might
    be useful in some cases, it would be far more efficient if they were singletons.
    That way, we wouldn't be creating new object instances (an expensive operation)
    for each request, and we wouldn't be generating excess garbage after the request
    is completed.
  prefs: []
  type: TYPE_NORMAL
- en: While we could create an `Application` subclass that returns the resources via
    the `getSingletons()` method, that would prevent the container from automatically
    discovering and registering resources and providers. Another reason to avoid that
    approach is that the `getSingletons()` method is deprecated in a future version
    of JAX-RS and will eventually be removed.
  prefs: []
  type: TYPE_NORMAL
- en: Instead, we can use **Context and Dependency Injection** (**CDI**). CDI uses
    annotations to allow developers to declaratively manage object life cycles and
    perform injections of fields, constructors, and setter methods.
  prefs: []
  type: TYPE_NORMAL
- en: Scopes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: CDI has several built-in `@ApplicationScoped`, `@RequestScoped`, and `@Dependent`.
    As you can probably guess, an object annotated with `@ApplicationScoped` will
    *live* for the lifetime of the application, while an object annotated with `@RequestScoped`
    will only live for the lifetime of a single request.
  prefs: []
  type: TYPE_NORMAL
- en: The `@Dependent` annotation is a little special. Basically, objects annotated
    with it will inherit the scope of the object it is injected into. In the case
    of JAX-RS resource classes that are not really injected into anything, it inherits
    the scope of the JAX-RS container. For resource objects, that is **per request**,
    but for provider objects, that is **per application**.
  prefs: []
  type: TYPE_NORMAL
- en: This means that we can annotate our JAX-RS resource classes with `@ApplicationScoped`
    and then we can get rid of those pesky static fields and just use normal instance
    fields.
  prefs: []
  type: TYPE_NORMAL
- en: Injection
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: DI is another powerful piece of CDI. Using annotations, you can specify your
    dependencies and let the container handle all of the wiring. In the most basic
    cases where you want to inject a class or an instance of an interface where there
    is only one managed bean implementation of that interface, you can use `@Inject`,
    and CDI does the rest.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at an example. Suppose we have a class like this that we
    want to inject (the full source code for all CDI examples can be found at [https://github.com/PacktPublishing/Practical-Cloud-Native-Java-Development-with-MicroProfile/tree/main/Chapter04/src/main/java/com/packt/microprofile/book/ch4/cdi](https://github.com/PacktPublishing/Practical-Cloud-Native-Java-Development-with-MicroProfile/tree/main/Chapter04/src/main/java/com/packt/microprofile/book/ch4/cdi)):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'We have a request-scoped bean that, when instantiated, will have a unique instance
    ID. Now, let''s say that we want to inject it into a JAX-RS resource class that
    is managed by CDI, but we want the resource class to be application-scoped for
    better performance. It might look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'This object, `MyCdiResource`, will only be instantiated once for the lifetime
    of the application, with no extra object creation or excess garbage. But the `MyDependency`
    object that is injected is `GET` method that returns the dependency instance ID,
    as the dependency''s instance ID increments on each request, as illustrated here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'There may be times where you want to create your own bean that is injected.
    CDI provides a mechanism where you would use the `@Produces` annotation (same
    name but different package as the JAX-RS `@Produces` annotation for specifying
    media types). To use this, you would apply this annotation to a method on a CDI-managed
    bean; the object returned by that method will be injected appropriately. Let''s
    see how this would look in a code example, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: And in this case, since the `MyCdiResource` class is annotated with `@ApplicationScoped`,
    the `MyProducedDependency` object is only built and injected once for the lifetime
    of the application. If we were to change `MyCdiResource` to be `@RequestScoped`,
    then the random number would change for each request. The `producer` method is
    invoked when needed by the *consuming* bean.
  prefs: []
  type: TYPE_NORMAL
- en: So, what happens if you have more than one possible bean to inject? Your application
    may fail to start with a `DeploymentException` exception, indicating ambiguous
    dependencies. To resolve this, you can either use the `@Named` annotation or *qualifier*
    annotations.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `@Named` annotation may look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: The `@Named` annotation with the same value, `max`, is applied to both the implementation
    class *and* the injection point.
  prefs: []
  type: TYPE_NORMAL
- en: 'Qualifiers are a little more complex but add more flexibility. It first involves
    the creation of a new annotation, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we just add that annotation on both the class and injection target, like
    so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'Qualifiers can be used more extensively in other CDI artifacts such as interceptors
    and portable extensions. One such extension is built into the MicroProfile Rest
    Client implementation, which allows client instances to be built and injected
    into your CDI beans. It uses the `@RestClient` qualifier. For this to work, you
    would need to add the `@RegisterRestClient` annotation to the client interface.
    With this annotation, you can also specify the `baseUri` path. Alternatively,
    you could use MicroProfile Config to specify the `baseUri` path and other configuration
    options for the client instance. Here''s what it might look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we could inject the client instance and use it like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: While it might seem silly to create a RESTful service that then uses a client
    to access a different RESTful service in the same application, the principle is
    very common for microservice architecture. This service could be a gateway for
    the real thesaurus service, or perhaps the complete thesaurus is split across
    several **virtual machines** (**VMs**). The ability to provide or consume RESTful
    services where those services' life cycles and dependencies are managed declaratively
    can be very powerful indeed.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we've learned how to create and consume basic and complex RESTful
    services using industry-standard APIs such as JAX-RS, CDI, JSON-P, JSON-B, and
    the MicroProfile Rest Client. We've learned that some of these APIs provide very
    concise and type-safe approaches, while others provide additional flexibility
    at the cost of increased code complexity. Having completed this chapter, we can
    now create fully functioning micro-services utilizing REST and JSON. We can also
    improve the efficiency of these services by using asynchronous clients and appropriate
    life-cycle scopes.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will explore how we can improve the configurability
    and robustness of these services with other MicroProfile APIs.
  prefs: []
  type: TYPE_NORMAL
