- en: '*Chapter 4*: Developing Cloud-Native Applications'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第 4 章*：开发云原生应用程序'
- en: MicroProfile 4.1 builds on some **Jakarta EE** (formerly **Java Enterprise Edition**)
    **application programming interfaces** (**APIs**)—specifically, **Jakarta RESTful
    Web Services** (**JAX-RS**), **Jakarta Contexts and Dependency Injection** (**CDI**),
    **JavaScript Object Notation Processing** (**JSON-P**), and **JSON Binding** (**JSON-B**).
    Using only these technologies, it is possible to develop a perfectly capable cloud-native
    application. The MicroProfile community added a type-safe mechanism for invoking
    RESTful services known as the **MicroProfile Rest Client**. These technologies
    are essential for building Java-based microservices that can interoperate in the
    cloud. Learning to use these technologies will enable you to build robust and
    secure Java microservices.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: MicroProfile 4.1 基于某些 **Jakarta EE**（以前称为 **Java Enterprise Edition**）**应用程序编程接口**（**API**）——具体来说，是
    **Jakarta RESTful Web Services**（**JAX-RS**）、**Jakarta Contexts and Dependency
    Injection**（**CDI**）、**JavaScript Object Notation Processing**（**JSON-P**）和 **JSON
    Binding**（**JSON-B**）。仅使用这些技术，就可以开发一个完全能够胜任的云原生应用程序。MicroProfile 社区增加了一个用于调用 RESTful
    服务的类型安全机制，称为 **MicroProfile Rest Client**。这些技术对于构建可以在云中互操作的基于 Java 的微服务至关重要。学习使用这些技术将使您能够构建健壮且安全的
    Java 微服务。
- en: 'In this chapter, we will explore all of the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨以下所有主题：
- en: Developing a RESTful service with JAX-RS
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 JAX-RS 开发 RESTful 服务
- en: Managing the payload with JSON-P and JSON-B
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 JSON-P 和 JSON-B 管理有效载荷
- en: Consuming RESTful services with the MicroProfile Rest Client
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 MicroProfile Rest Client 消费 RESTful 服务
- en: Managing life cycle and **dependency injection** (**DI**) with CDI
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 CDI 管理生命周期和 **依赖注入**（**DI**）
- en: This chapter covers a wide spectrum of technologies and the functionality within
    each technology. When you have finished this chapter, you should have a broad
    and deep understanding of how to build reliable, robust RESTful applications that
    can communicate with each other using JSON.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖了广泛的技术以及每个技术中的功能。当您完成本章后，您应该对如何构建可靠、健壮的 RESTful 应用程序，并使用 JSON 互相通信有广泛而深入的理解。
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'In order to build and run the samples mentioned in this chapter, you will need
    a Mac or PC (Windows or Linux) with the following software:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 为了构建和运行本章中提到的示例，您需要一个装有以下软件的 Mac 或 PC（Windows 或 Linux）：
- en: '**Java Development Kit** (**JDK**) version 8 or higher ([http://ibm.biz/GetSemeru](http://ibm.biz/GetSemeru))'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Java 开发工具包**（**JDK**）版本 8 或更高 ([http://ibm.biz/GetSemeru](http://ibm.biz/GetSemeru))'
- en: Apache Maven ([https://maven.apache.org/](https://maven.apache.org/))
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Apache Maven ([https://maven.apache.org/](https://maven.apache.org/))
- en: A Git client ([https://git-scm.com/](https://git-scm.com/))
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Git 客户端 ([https://git-scm.com/](https://git-scm.com/))
- en: All of the source code used in this chapter is available on GitHub at [https://github.com/PacktPublishing/Practical-Cloud-Native-Java-Development-with-MicroProfile/tree/main/Chapter04](https://github.com/PacktPublishing/Practical-Cloud-Native-Java-Development-with-MicroProfile/tree/main/Chapter04).
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本章中使用的所有源代码均可在 GitHub 上找到，网址为 [https://github.com/PacktPublishing/Practical-Cloud-Native-Java-Development-with-MicroProfile/tree/main/Chapter04](https://github.com/PacktPublishing/Practical-Cloud-Native-Java-Development-with-MicroProfile/tree/main/Chapter04)。
- en: 'Once you have cloned the GitHub repository, you can start the Open Liberty
    server that these code samples will execute in by entering the `Chapter04` directory
    and running the following command from the command line:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您已经克隆了 GitHub 仓库，您可以通过进入 `Chapter04` 目录并在命令行中运行以下命令来启动 Open Liberty 服务器，这些代码示例将在其中执行：
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: You can then stop the server in the same command window by pressing *Ctrl +
    C*.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过在相同的命令窗口中按 *Ctrl + C* 来停止服务器。
- en: Now we've got the prerequisites taken care of, let's start by building a basic
    RESTful service.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经处理好了先决条件，让我们先构建一个基本的 RESTful 服务。
- en: Developing a RESTful service with JAX-RS
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 JAX-RS 开发 RESTful 服务
- en: In this section, we will develop a few RESTful services using JAX-RS. We'll
    start with a simple example, and then we'll add more complex and powerful techniques
    such as exception handling, advanced conversion of **HyperText Transfer Protocol**
    (**HTTP**) data into Java objects (and vice versa), cross-cutting concerns, asynchronous
    methods, and DI.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将使用 JAX-RS 开发几个 RESTful 服务。我们将从一个简单的例子开始，然后添加更复杂和强大的技术，如异常处理、将 **超文本传输协议**（**HTTP**）数据高级转换为
    Java 对象（反之亦然）、横切关注点、异步方法和 DI。
- en: JAX-RS is built around the idea of a **request-response** pipeline. On the server
    side, an HTTP request enters the pipeline, then the JAX-RS server invokes any
    pre-matching **filters** on the request. It then attempts to match the request
    with a JAX-RS **resource method**.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: JAX-RS 是围绕 **请求-响应** 管道这一理念构建的。在服务器端，一个 HTTP 请求进入管道，然后 JAX-RS 服务器在请求上调用任何预匹配的
    **过滤器**。然后它尝试将请求与 JAX-RS **资源方法** 匹配。
- en: 'When the JAX-RS container receives an incoming request, it will perform the
    following process:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 当 JAX-RS 容器收到一个传入请求时，它将执行以下过程：
- en: Invoke any registered pre-matching filters.
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用任何已注册的预匹配过滤器。
- en: Attempt to match the request to a `resource` method. If no match can be made,
    the container will respond with an appropriate `not found` HTTP response.
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 尝试将请求与 `resource` 方法匹配。如果无法匹配，容器将响应适当的 `not found` HTTP 响应。
- en: Invoke any registered post-matching filters.
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用任何已注册的匹配后过滤器。
- en: Perform conversion of HTTP data (such as the HTTP entity payload or parameters,
    headers, and so on) into Java objects consumable by the resource method if necessary.
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果需要，执行 HTTP 数据（如 HTTP 实体有效负载或参数、头等）到资源方法可消费的 Java 对象的转换。
- en: Invoke the `resource` method.
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用 `resource` 方法。
- en: Perform exception handling, if necessary.
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果需要，执行异常处理。
- en: Invoke any registered response filters.
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用任何已注册的响应过滤器。
- en: Perform conversion of Java object(s) to HTTP response data, if necessary.
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果需要，执行 Java 对象到 HTTP 响应数据的转换。
- en: Return the HTTP response to the client.
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 HTTP 响应返回给客户端。
- en: 'This pipeline flow is illustrated in the following diagram:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表展示了该管道流程：
- en: '![Figure 4.1 – JAX-RS server pipeline flow'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 4.1 – JAX-RS 服务器管道流程](img/Figure_4.1_-_B17377.jpg)'
- en: '](img/Figure_4.1_-_B17377.jpg)'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_4.1_-_B17377.jpg)'
- en: Figure 4.1 – JAX-RS server pipeline flow
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.1 – JAX-RS 服务器管道流程
- en: 'In JAX-RS, there are three types of components, outlined as follows:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在 JAX-RS 中，有三种类型的组件，如下概述：
- en: '**Resources**: The resources are what ultimately make the RESTful service what
    it is as they contain the business logic.'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**资源**：资源是使 RESTful 服务成为其自身的最终因素，因为它们包含业务逻辑。'
- en: '`MessageBodyReader`, `MessageBodyWriter`, `ParamConverter`, `ExceptionMapper`,
    `ReaderInterceptor`, and `WriterInterceptor` are all providers.'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MessageBodyReader`、`MessageBodyWriter`、`ParamConverter`、`ExceptionMapper`、`ReaderInterceptor`
    和 `WriterInterceptor` 都是提供者。'
- en: '`Application` subclass is used to provide configuration for the JAX-RS application.'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `Application` 子类来为 JAX-RS 应用程序提供配置。
- en: Now we understand the basic flow, let's create a simple JAX-RS application.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了基本流程，让我们创建一个简单的 JAX-RS 应用程序。
- en: Hello World!
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Hello World！
- en: 'A JAX-RS application must contain at least one resource class. Providers are
    optional. An `Application` subclass is only necessary if you don''t have a `web.xml`
    file that specifies an application path. So, a very simple application might look
    like this:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 JAX-RS 应用程序必须至少包含一个资源类。提供者可选。只有在没有指定应用程序路径的 `web.xml` 文件时，才需要 `Application`
    子类。因此，一个非常简单的应用程序可能看起来像这样：
- en: '[PRE1]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: If we build this code into a web application called `myApp.war` and deploy it
    into a JAX-RS container such as Open Liberty, we could quickly test it using an
    HTTP client by browsing to `http://localhost:9080/myApp/rest/hello` and we would
    see the text **Hello World!**.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将此代码构建成一个名为 `myApp.war` 的 Web 应用程序，并将其部署到 Open Liberty 等JAX-RS 容器中，我们可以通过浏览到
    `http://localhost:9080/myApp/rest/hello` 来快速使用 HTTP 客户端测试它，我们会看到文本 **Hello World**！。
- en: This works because the `@GET` annotation on the `helloWorld()` method tells
    the JAX-RS container that this method should be invoked when a client issues a
    `GET` request to the `/hello` path of the `/rest` application path under the `.war`
    extension. By default, most HTTP clients (browsers, `curl`, and so on) use `GET`
    unless specified otherwise. This brings up a good point about tooling. When developing
    RESTful applications, it is extremely valuable to have a client tool that can
    issue different types of HTTP requests. Command-line tools such as `curl` are
    very useful, and there are several browser extension-based tools that would also
    work.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 这之所以有效，是因为 `helloWorld()` 方法上的 `@GET` 注解告诉 JAX-RS 容器，当客户端向 `/rest` 应用程序路径下的
    `.war` 扩展名的 `/hello` 路径发出 `GET` 请求时，应该调用此方法。默认情况下，大多数 HTTP 客户端（浏览器、`curl` 等）使用
    `GET`，除非指定其他方式。这提出了关于工具的一个很好的观点。在开发 RESTful 应用程序时，拥有一个可以发出不同类型 HTTP 请求的客户端工具非常有价值。命令行工具如
    `curl` 非常有用，还有基于浏览器扩展的工具也可以使用。
- en: A more real-world example
  id: totrans-45
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 一个更贴近现实世界的例子
- en: 'Now we have built a simple JAX-RS application, let''s build a more complex
    application—a thesaurus service where clients can search and update synonyms.
    We''ll start with an **exception mapper**, as follows:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经构建了一个简单的 JAX-RS 应用程序，让我们构建一个更复杂的应用程序——一个同义词服务，客户端可以搜索和更新同义词。我们将从一个 **异常映射器**
    开始，如下所示：
- en: '[PRE2]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Most applications will have `NoSuchWordException` exception, which could be
    used to indicate that a searched word does not exist. It is clear in the application
    that somebody specified a word that does not exist, but it is not clear to an
    HTTP client. The `NoSuchWordExceptionMapper` provider class makes that possible.
    It enables the resource class methods to throw a `NoSuchWordException` exception,
    and the JAX-RS container will map the exception to an HTTP response (in this case,
    a `404 Not Found` error).
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数应用程序都会遇到 `NoSuchWordException` 异常，该异常可以用来指示搜索的单词不存在。在应用程序中，有人指定了一个不存在的单词是明确的，但对于
    HTTP 客户端来说则不是。`NoSuchWordExceptionMapper` 提供器类使得这一点成为可能。它使得资源类方法能够抛出 `NoSuchWordException`
    异常，JAX-RS 容器会将该异常映射到一个 HTTP 响应（在这种情况下，是一个 `404 Not Found` 错误）。
- en: 'Next is the resource class (the full source code is available at [https://github.com/PacktPublishing/Practical-Cloud-Native-Java-Development-with-MicroProfile/blob/main/Chapter04/src/main/java/com/packt/microprofile/book/ch4/thesaurus/ThesaurusResource.java](https://github.com/PacktPublishing/Practical-Cloud-Native-Java-Development-with-MicroProfile/blob/main/Chapter04/src/main/java/com/packt/microprofile/book/ch4/thesaurus/ThesaurusResource.java)),
    as illustrated in the following code snippet:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是资源类（完整的源代码可在 [https://github.com/PacktPublishing/Practical-Cloud-Native-Java-Development-with-MicroProfile/blob/main/Chapter04/src/main/java/com/packt/microprofile/book/ch4/thesaurus/ThesaurusResource.java](https://github.com/PacktPublishing/Practical-Cloud-Native-Java-Development-with-MicroProfile/blob/main/Chapter04/src/main/java/com/packt/microprofile/book/ch4/thesaurus/ThesaurusResource.java)
    找到）的示例，如下代码片段所示：
- en: '[PRE3]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'There are a few new annotations on the resource class: `@Produces` and `@Consumes`.
    These annotations can be placed on resource classes or methods—as with most annotations
    of this type in JAX-RS, annotations on the method take priority over annotations
    on the class. These annotations help control the matching of requests and the
    entity providers (`MessageBodyReaders` and `MessageBodyWriters`) to be used in
    deserializing the HTTP entity from the request or serializing the HTTP entity
    in the response.'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 资源类上有几个新的注解：`@Produces` 和 `@Consumes`。这些注解可以放置在资源类或方法上——与 JAX-RS 中此类注解的大多数注解一样，方法上的注解优先于类上的注解。这些注解有助于控制请求的匹配以及用于从请求反序列化
    HTTP 实体或响应中序列化 HTTP 实体的实体提供者（`MessageBodyReaders` 和 `MessageBodyWriters`）。
- en: HTTP requests and responses may contain a header that indicates the `Content-Type`.
    HTTP requests may also contain a header that specifies the media type(s) that
    it expects to receive in the response—`Accept`. In the absence of these headers,
    all media types are allowed (denoted by, `*/*`).
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP 请求和响应可能包含一个表示 `Content-Type` 的头信息。HTTP 请求也可能包含一个头信息，指定它期望在响应中接收的媒体类型（或多个媒体类型）——`Accept`。如果没有这些头信息，则允许所有媒体类型（用
    `*/*` 表示）。
- en: 'In the previous example, the resource class specifies `MediaType.TEXT_PLAIN`
    or `text/plain`. Other media types include `text/html`, `application/json`, `application/xml`,
    `image/jpeg`, and much more. Specifying `text/plain` would prevent the resource
    methods from being invoked if a request contained a header such as `Content-Type:
    application/pdf` or `Accept: image/png`—instead of invoking the resource method,
    the JAX-RS container would return a `415 Unsupported Media Type` error.'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '在前面的例子中，资源类指定了 `MediaType.TEXT_PLAIN` 或 `text/plain`。其他媒体类型包括 `text/html`、`application/json`、`application/xml`、`image/jpeg`
    以及更多。指定 `text/plain` 将会阻止资源方法在请求包含如 `Content-Type: application/pdf` 或 `Accept:
    image/png` 等头信息时被调用——在这种情况下，JAX-RS 容器会返回一个 `415 Unsupported Media Type` 错误。'
- en: Best practice
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 最佳实践
- en: Always use `@Produces` and `@Consumes` to limit media types. This will place
    limits on the types of requests your service will respond to. It will ensure that
    your application (if properly tested) can handle requests of the specified media
    types.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 总是使用 `@Produces` 和 `@Consumes` 来限制媒体类型。这将限制你的服务将响应的类型。这将确保你的应用程序（如果经过适当测试）可以处理指定媒体类型的请求。
- en: 'This example also introduces new method-level HTTP verb annotations: `@POST`,
    `@PUT`, `@DELETE`, and `@PATCH`. As with `@GET`, these annotations specify which
    method should be invoked based on the HTTP request''s `@HEAD` and `@OPTIONS`,
    which are less commonly used.'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例还介绍了新的方法级 HTTP 动词注解：`@POST`、`@PUT`、`@DELETE` 和 `@PATCH`。与 `@GET` 一样，这些注解指定应根据
    HTTP 请求的 `@HEAD` 和 `@OPTIONS`（较少使用）调用哪个方法。
- en: Special note
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 特别注意
- en: 'If the resource class contains a method annotated with `@GET` but not `@HEAD`,
    the JAX-RS container would invoke the `@GET` method for matching HTTP `HEAD` requests,
    but it would remove the entity. Likewise, if a resource class contains any HTTP
    verb annotation other than `@OPTIONS`, the JAX-RS container would return a response
    indicating all of the valid verbs that could be matched for that request. Using
    the preceding example, an `OPTIONS` request would result in a response with a
    header such as `Allow: DELETE, HEAD, GET, OPTIONS, PATCH, POST, PUT`.'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '如果资源类包含一个带有 `@GET` 注解但没有 `@HEAD` 注解的方法，JAX-RS 容器将调用 `@GET` 方法来匹配 HTTP `HEAD`
    请求，但会移除实体。同样，如果资源类包含除 `@OPTIONS` 之外的其他 HTTP 动词注解，JAX-RS 容器将返回一个响应，指示可以匹配该请求的所有有效动词。使用前面的示例，`OPTIONS`
    请求将导致一个包含类似 `Allow: DELETE, HEAD, GET, OPTIONS, PATCH, POST, PUT` 的响应头。'
- en: This example also introduces the idea of HTTP parameters—specifically, `@PathParam("word")
    String word;`.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例还介绍了 HTTP 参数的概念——特别是 `@PathParam("word") String word;`。
- en: This annotation can be placed on fields or method parameters. The value of `@PathParm`
    is `word`, which corresponds to the template variable in the resource class's
    `@Path` value (`"/thesaurus/{word}"`). This means that for an HTTP request such
    as `http://localhost:9080/myApp/rest/thesaurus/funny`, the value injected into
    the `word` field would be `funny`.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 这个注解可以放置在字段或方法参数上。`@PathParm` 的值是 `word`，它对应资源类 `@Path` 值中的模板变量（`"/thesaurus/{word}"`）。这意味着对于像
    `http://localhost:9080/myApp/rest/thesaurus/funny` 这样的 HTTP 请求，注入到 `word` 字段的值将是
    `funny`。
- en: 'There are other HTTP parameter types that can be used in JAX-RS, including
    `@QueryParam`, `@FormParam`, `@CookieParam`, `@HeaderParam`, and `@MatrixParam`,
    which all correspond to different parts of an HTTP request. JAX-RS also allows
    multiple HTTP parameter annotations to be aggregated on a single Java class and
    then referenced in the resource class or method as a `@BeanParam` parameter type.
    Here is an example of this:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在 JAX-RS 中可以使用其他 HTTP 参数类型，包括 `@QueryParam`、`@FormParam`、`@CookieParam`、`@HeaderParam`
    和 `@MatrixParam`，它们都对应 HTTP 请求的不同部分。JAX-RS 还允许在单个 Java 类上聚合多个 HTTP 参数注解，然后在资源类或方法中作为
    `@BeanParam` 参数类型引用。以下是一个示例：
- en: '[PRE4]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The `ParamBean` bean is just a `@*Param` annotations. Then, this POJO is injected
    into a resource, like this:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '`ParamBean` 实体只是一个 `@*Param` 注解。然后，这个 POJO 被注入到一个资源中，如下所示：'
- en: '[PRE5]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '`@BeanParam` beans can be very useful for aggregating common sets of RESTful
    parameters to avoid writing repetitive code. Let''s test this example from the
    command line using `curl`, as follows:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '`@BeanParam` 可以非常有助于聚合常见的 RESTful 参数集合，以避免编写重复的代码。让我们使用 `curl` 从命令行测试此示例，如下所示：'
- en: '[PRE6]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'One thing to be wary of is that not all parameters will be non-null, so you
    will need to check for null values, or you can use the `@DefaultValue` annotation.
    This applies to method parameters as well. An example is provided here:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个需要注意的事情是，并非所有参数都不会为空，因此您需要检查空值，或者可以使用 `@DefaultValue` 注解。这也适用于方法参数。这里提供了一个示例：
- en: '[PRE7]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Notice that the value in the `@DefaultValue` annotation is always a string,
    but as long as it can be converted from a string to the parameter type (`Integer`,
    in this case), it will work. In the next section, we will learn how to convert
    data sent from a client into the Java objects in our application code.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`@DefaultValue` 注解中的值始终是字符串，但只要它可以从字符串转换为参数类型（在这种情况下是 `Integer`），它就会工作。在下一节中，我们将学习如何将客户端发送的数据转换为我们的应用程序代码中的
    Java 对象。
- en: Entity providers and ParamConverter
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实体提供者和参数转换器
- en: So far, our resource methods have mainly been dealing with strings or other
    primitives. The JAX-RS container is responsible for serializing and deserializing
    those objects, but what if we want to send and receive more complex objects? In
    those cases, we may need to implement some `ParamConverter`.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们的资源方法主要处理字符串或其他原始数据。JAX-RS 容器负责序列化和反序列化这些对象，但如果我们想发送和接收更复杂的对象怎么办？在这些情况下，我们可能需要实现一些
    `ParamConverter`。
- en: Entity providers
  id: totrans-72
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 实体提供者
- en: Entity providers include `MessageBodyReader` and `MessageBodyWriter`, and they
    are responsible for deserializing HTTP entity data to a Java object and serializing
    a Java object to an HTTP entity, respectively.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 实体提供者包括`MessageBodyReader`和`MessageBodyWriter`，它们分别负责将HTTP实体数据反序列化为Java对象，以及将Java对象序列化为HTTP实体。
- en: 'Let''s say that we have a `Person` object such as this:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有一个`Person`对象，如下所示：
- en: '[PRE8]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'And let''s say that we have a `service` object such as this:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 再假设我们有一个`service`对象，如下所示：
- en: '[PRE9]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: One thing to notice here is that the `getPerson(…)` method throws a new `WebApplicationException`
    exception, passing it as a `404` response. This is another way to map an exception
    to a response without needing an `ExceptionMapper` instance.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 这里需要注意的一点是，`getPerson(…)`方法抛出了一个新的`WebApplicationException`异常，并将其作为`404`响应传递。这是将异常映射到响应而不需要`ExceptionMapper`实例的另一种方式。
- en: Best practice
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 最佳实践
- en: Use `ExceptionMappers` when multiple resource methods may throw the same exception.
    Throw a `WebApplicationException` exception with a passed-in `Response` object
    only in cases where you don't have an appropriate business exception to throw
    or you only throw the exception from one resource method.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 当多个资源方法可能抛出相同的异常时，请使用`ExceptionMappers`。只有在没有合适的业务异常可以抛出，或者你只从单个资源方法中抛出异常的情况下，才使用带有传入的`Response`对象的`WebApplicationException`异常。
- en: 'Another thing to notice is the use of `APPLICATION_JSON` as the media type
    that this resource produces and consumes. The `application/json` media type is
    the most common content type used in microservices. `Person` object from the previous
    sample code:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 另一点需要注意是，这个资源使用`APPLICATION_JSON`作为它产生的和消费的媒体类型。`application/json`媒体类型是微服务中最常用的内容类型。以下是从上一个示例代码中获取的`Person`对象：
- en: '[PRE10]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'In order for a client to create a new `Person` object via the `POST` method,
    we need a `MessageBodyReader` instance. There are some built-in readers that would
    handle this nicely, but for now, we''ll write and register our own, like this
    (the full source code is available at [https://github.com/PacktPublishing/Practical-Cloud-Native-Java-Development-with-MicroProfile/blob/main/Chapter04/src/main/java/com/packt/microprofile/book/ch4/entityandparamproviders/MyJsonReader.java](https://github.com/PacktPublishing/Practical-Cloud-Native-Java-Development-with-MicroProfile/blob/main/Chapter04/src/main/java/com/packt/microprofile/book/ch4/entityandparamproviders/MyJsonReader.java)):'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使客户端能够通过`POST`方法创建一个新的`Person`对象，我们需要一个`MessageBodyReader`实例。有一些内置的读取器可以很好地处理这个问题，但到目前为止，我们将编写并注册自己的，如下所示（完整的源代码可在[https://github.com/PacktPublishing/Practical-Cloud-Native-Java-Development-with-MicroProfile/blob/main/Chapter04/src/main/java/com/packt/microprofile/book/ch4/entityandparamproviders/MyJsonReader.java](https://github.com/PacktPublishing/Practical-Cloud-Native-Java-Development-with-MicroProfile/blob/main/Chapter04/src/main/java/com/packt/microprofile/book/ch4/entityandparamproviders/MyJsonReader.java)）：
- en: '[PRE11]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Furthermore, in order to write a `Person` object as JSON in a response entity,
    we must register a JSON `MessageBodyWriter` instance, like this (the full source
    code is available at [https://github.com/PacktPublishing/Practical-Cloud-Native-Java-Development-with-MicroProfile/blob/main/Chapter04/src/main/java/com/packt/microprofile/book/ch4/entityandparamproviders/MyJsonWriter.java](https://github.com/PacktPublishing/Practical-Cloud-Native-Java-Development-with-MicroProfile/blob/main/Chapter04/src/main/java/com/packt/microprofile/book/ch4/entityandparamproviders/MyJsonWriter.java)):'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，为了将`Person`对象作为JSON写入响应实体，我们必须注册一个JSON的`MessageBodyWriter`实例，如下所示（完整的源代码可在[https://github.com/PacktPublishing/Practical-Cloud-Native-Java-Development-with-MicroProfile/blob/main/Chapter04/src/main/java/com/packt/microprofile/book/ch4/entityandparamproviders/MyJsonWriter.java](https://github.com/PacktPublishing/Practical-Cloud-Native-Java-Development-with-MicroProfile/blob/main/Chapter04/src/main/java/com/packt/microprofile/book/ch4/entityandparamproviders/MyJsonWriter.java)）：
- en: '[PRE12]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: These providers could easily be combined into one `MyJsonEntityProvider` class
    that implements both interfaces. Both implementations use `InputStream` to read
    an entity from a client request and `OutputStream` for writing the response entity.
    Both providers have a Boolean check to verify that this is the proper entity provider
    to invoke—in addition to the generic type specified (`Person`) and the `@Consumes`/`@Produces`
    values, returning `true` or `false` for the `isReadable` or `isWriteable` methods
    will tell the JAX-RS container whether this provider should be used to serialize/deserialize
    the data.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 这些提供者可以很容易地合并成一个实现两个接口的 `MyJsonEntityProvider` 类。这两个实现都使用 `InputStream` 从客户端请求中读取实体，并使用
    `OutputStream` 来写入响应实体。这两个提供者都有一个布尔检查，以验证这是否是应该调用的正确实体提供者——除了指定的泛型类型（`Person`）和
    `@Consumes`/`@Produces` 值之外，返回 `true` 或 `false` 对于 `isReadable` 或 `isWriteable`
    方法将告诉 JAX-RS 容器是否应该使用此提供者来序列化/反序列化数据。
- en: Another criterion for selecting among multiple providers would be the `@Priority`
    annotation—the JAX-RS container will select the provider with the highest priority
    (which is the lowest value—thus, `@Priority(1)` would be selected before `@Priority(2)`).
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 选择多个提供者的另一个标准将是 `@Priority` 注解——JAX-RS 容器将选择具有最高优先级的提供者（优先级值最低——因此，`@Priority(1)`
    将在 `@Priority(2)` 之前被选中）。
- en: Ultimately, the value returned from the reader's `readFrom` method will be injected
    into the resource method's `@Context` (more on this in the *Context injection*
    section) or `@*Param`. A resource method may contain zero or one entity parameters—any
    more will result in a deployment failure.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，从读取者的 `readFrom` 方法返回的值将被注入到资源方法的 `@Context`（更多内容请参阅 *上下文注入* 部分）或 `@*Param`。资源方法可能包含零个或一个实体参数——任何更多都将导致部署失败。
- en: On the response side, the content written to the writer's `writeTo` entity stream
    will be written to the HTTP response sent back to the client.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在响应方面，写入到写入者的 `writeTo` 实体流中的内容将被写入发送回客户端的 HTTP 响应。
- en: If the amount of code complexity for writing and reading JSON seems a little
    daunting at this point, don't fret! We'll cover a simpler approach in the next
    section.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 如果此时编写和读取 JSON 的代码复杂度看起来有点令人畏惧，不要担心！我们将在下一节中介绍一个更简单的方法。
- en: So, entity providers are responsible for serializing and deserializing HTTP
    entities to objects, but what about parameters such as query parameters, path
    parameters, and so on? These are deserialized with `ParamConverter`
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，实体提供者负责将 HTTP 实体序列化和反序列化为对象，但参数如查询参数、路径参数等怎么办？这些参数使用 `ParamConverter` 进行反序列化。
- en: ParamConverter
  id: totrans-93
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: ParamConverter
- en: 'Building on our `PersonService` example, let''s add a `PATCH` method allowing
    clients to change a person''s favorite color, as follows:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的 `PersonService` 示例的基础上，让我们添加一个 `PATCH` 方法，允许客户端更改一个人的最喜欢的颜色，如下所示：
- en: '[PRE13]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'We can invoke this method from the command line like this:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以从命令行像这样调用此方法：
- en: '[PRE14]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'We are able to update John''s favorite color because the JAX-RS container was
    able to identify that `Color` is an enumerated type, and so it will invoke its
    `valueOf(String)` method to get the `Color` object that it injects when invoking
    the `updateFavoriteColor` method. But what happens when we specify the `color`
    in lowercase? Let''s have a look at the following output to find out:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 我们能够更新约翰最喜欢的颜色，因为 JAX-RS 容器能够识别出 `Color` 是一个枚举类型，因此它会调用其 `valueOf(String)` 方法来获取在调用
    `updateFavoriteColor` 方法时注入的 `Color` 对象。但是当我们指定小写的 `color` 时会发生什么？让我们看一下以下输出以了解情况：
- en: '[PRE15]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Uh oh! The JAX-RS container could not match the request to a resource method
    (resulting in a `404 Not Found` response) because it could not convert `blue`
    to `Color.BLUE`. In order for our service to be more resilient or to handle more
    complex objects as parameters, we must use `ParamConverterProvider` and `ParamConverter`
    like this:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 哎呀！JAX-RS 容器无法将请求与资源方法匹配（导致返回 `404 Not Found` 响应），因为它无法将 `blue` 转换为 `Color.BLUE`。为了使我们的服务更具弹性或处理更复杂的参数，我们必须像这样使用
    `ParamConverterProvider` 和 `ParamConverter`：
- en: '[PRE16]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '`ParamConverterProvider` is responsible for returning an instance of a class
    that implements `ParamConverter`, such as this:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '`ParamConverterProvider` 负责返回一个实现 `ParamConverter` 接口的类的实例，例如如下所示：'
- en: '[PRE17]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The first class, `ColorParamConverterProvider`, is the registered provider class.
    When a resource method has a parameter that needs to be converted from `String`
    to an object, the JAX-RS container will invoke the `getContainer` method of any
    registered `ParamConverterProvider` class until one returns a non-null `ParamConverter`
    instance.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 第一类，`ColorParamConverterProvider`是已注册的提供者类。当一个资源方法有一个需要从`String`转换为对象的参数时，JAX-RS容器将调用任何已注册的`ParamConverterProvider`类的`getContainer`方法，直到其中一个返回非空的`ParamConverter`实例。
- en: The `ColorParamConverter` class simply capitalizes the string value to ensure
    that the enum's `valueOf` method will return the `Color.BLUE` color, regardless
    of whether the client request's query parameter was `BLUE`, `Blue`, `blue`, `bLuE`,
    and so on.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '`ColorParamConverter`类简单地将字符串值转换为大写，以确保枚举的`valueOf`方法将返回`Color.BLUE`颜色，无论客户端请求的查询参数是`BLUE`、`Blue`、`blue`、`bLuE`等。'
- en: '`ParamConverter` work for `@QueryParam` parameters as demonstrated, but also
    work for `@CookieParam`, `@FormParam`, `@HeaderParam`, `@MatrixParam`, and `@PathParam`
    parameters, and they can be used to convert a string to any object, and vice versa.
    The conversion from object to `String` is important on the client side. We''ll
    discuss that in the *Consuming RESTful services with the MicroProfile Rest Client*
    section.'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 如示例所示，`ParamConverter`适用于`@QueryParam`参数，但也适用于`@CookieParam`、`@FormParam`、`@HeaderParam`、`@MatrixParam`和`@PathParam`参数，并且可以将字符串转换为任何对象，反之亦然。在客户端，从对象到`String`的转换非常重要。我们将在*使用MicroProfile
    Rest Client消费RESTful服务*这一节中讨论这个问题。
- en: Intercepting requests and responses
  id: totrans-107
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 请求和响应的拦截
- en: There may be times when you need to check the input stream of a request before
    or after processing it in the `MessageBodyReader` entity provider. Likewise, there
    may be times where you want to perform additional processing to the output stream
    before or after processing it in the `MessageBodyWriter` entity provider. `ReaderInterceptors`
    and `WriterInterceptors` are intended for such tasks.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，您可能需要在`MessageBodyReader`实体提供者处理请求之前或之后检查输入流。同样，也可能会出现您想在`MessageBodyWriter`实体提供者处理输出流之前或之后执行额外处理的情况。`ReaderInterceptors`和`WriterInterceptors`就是为了这类任务而设计的。
- en: ReaderInterceptors and WriterInterceptors
  id: totrans-109
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: ReaderInterceptors和WriterInterceptors
- en: 'In our `MessageBodyReader` entity provider, we make a lot of calls to trim
    strings, which can be expensive in terms of performance. One way we might be able
    to reduce such calls would be to remove whitespace from the entity stream in a
    `ReaderInterceptor` provider so that then the `MessageBodyReader` provider could
    always assume that the stream contains no whitespace characters. Here''s an example
    of this:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的`MessageBodyReader`实体提供者中，我们进行了大量的字符串修剪调用，这在性能方面可能是昂贵的。我们可能减少此类调用的一种方法是在`ReaderInterceptor`提供者中从实体流中删除空白字符，这样`MessageBodyReader`提供者就可以始终假设流中不包含空白字符。以下是一个示例：
- en: '[PRE18]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'When a client sends a multiline request entity with spaces, line feeds, or
    other white space, you can see that this will convert them with the system output,
    as follows:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 当客户端发送包含空格、换行符或其他空白字符的多行请求实体时，您可以看到这将与系统输出一起转换，如下所示：
- en: '[PRE19]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: A common use case for `WriterInterceptors` is to reduce the response entity
    size by using GZIP compression—see a full example of this at [https://github.com/PacktPublishing/Practical-Cloud-Native-Java-Development-with-MicroProfile/blob/main/Chapter04/src/main/java/com/packt/microprofile/book/ch4/interceptorsandfilters/GzipWriterInterceptor.java](https://github.com/PacktPublishing/Practical-Cloud-Native-Java-Development-with-MicroProfile/blob/main/Chapter04/src/main/java/com/packt/microprofile/book/ch4/interceptorsandfilters/GzipWriterInterceptor.java).
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '`WriterInterceptors`的一个常见用途是使用GZIP压缩来减少响应实体的大小——请参阅[https://github.com/PacktPublishing/Practical-Cloud-Native-Java-Development-with-MicroProfile/blob/main/Chapter04/src/main/java/com/packt/microprofile/book/ch4/interceptorsandfilters/GzipWriterInterceptor.java](https://github.com/PacktPublishing/Practical-Cloud-Native-Java-Development-with-MicroProfile/blob/main/Chapter04/src/main/java/com/packt/microprofile/book/ch4/interceptorsandfilters/GzipWriterInterceptor.java)的完整示例。'
- en: Special note about entity streams
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 关于实体流的特殊说明
- en: While you can read the entity stream from multiple places (entity providers,
    reader or writer interceptors, filters—we'll cover these shortly), you can run
    into problems when you do. For example, your initial request entity stream may
    not support re-reading, so if you attempt to read it twice, you may end up with
    an `IOException` exception. In that case, you may need to reset the stream (if
    the stream supports resetting—each JAX-RS container may be a little different)
    or copy and replace the stream entirely as we did in our `ReaderInterceptor` example.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然你可以从多个地方读取实体流（实体提供者、读取器或写入拦截器、过滤器——我们将在稍后介绍这些），但在这样做时可能会遇到问题。例如，你的初始请求实体流可能不支持重新读取，所以如果你尝试读取两次，你可能会遇到
    `IOException` 异常。在这种情况下，你可能需要重置流（如果流支持重置——每个 JAX-RS 容器可能略有不同）或完全复制并替换流，就像我们在 `ReaderInterceptor`
    示例中所做的那样。
- en: Filters
  id: totrans-117
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 过滤器
- en: Where `ReaderInterceptors` and `WriterInterceptors` intercept the reading and
    writing of entity streams, **filters** intercept the overall request and response.
    Filters enable some powerful cross-cutting abilities in RESTful applications.
    So, what can we use filters for? We could probably fill the rest of this book
    with useful examples, from managing authentication, authorizing requests, redirecting
    requests, managing headers, aborting invalid requests before wasting server resources
    on them, audit logging requests/responses, detecting suspicious activity, providing
    application statistics, tracing requests/responses, throttling requests from specific
    clients, and more.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `ReaderInterceptors` 和 `WriterInterceptors` 截获实体流的读取和写入时，**过滤器**截获整体请求和响应。过滤器在
    RESTful 应用程序中启用了一些强大的横切能力。那么，我们可以用过滤器做什么呢？我们可能可以用这本书的其余部分来填充有用的示例，从管理身份验证、授权请求、重定向请求、管理头信息、在浪费服务器资源之前终止无效请求、审计日志请求/响应、检测可疑活动、提供应用程序统计信息、跟踪请求/响应、限制特定客户端的请求，等等。
- en: 'Let''s start with an example that checks incoming requests for an API key and
    returns a useful response if none exists, if it is unrecognized, or if that API
    key has exceeded the maximum number of requests for the day (the full source code
    is available at [https://github.com/PacktPublishing/Practical-Cloud-Native-Java-Development-with-MicroProfile/blob/main/Chapter04/src/main/java/com/packt/microprofile/book/ch4/interceptorsandfilters/ApiKeyCheckFilter.java](https://github.com/PacktPublishing/Practical-Cloud-Native-Java-Development-with-MicroProfile/blob/main/Chapter04/src/main/java/com/packt/microprofile/book/ch4/interceptorsandfilters/ApiKeyCheckFilter.java)).
    Have a look at the following code snippet:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从以下示例开始，该示例检查传入的 API 密钥请求，如果没有找到 API 密钥、API 密钥不可识别或该 API 密钥已超过当天最大请求数量（完整源代码可在[https://github.com/PacktPublishing/Practical-Cloud-Native-Java-Development-with-MicroProfile/blob/main/Chapter04/src/main/java/com/packt/microprofile/book/ch4/interceptorsandfilters/ApiKeyCheckFilter.java](https://github.com/PacktPublishing/Practical-Cloud-Native-Java-Development-with-MicroProfile/blob/main/Chapter04/src/main/java/com/packt/microprofile/book/ch4/interceptorsandfilters/ApiKeyCheckFilter.java)找到）。请查看以下代码片段：
- en: '[PRE20]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: This example checks that the client sent an API key as an HTTP header, that
    the API key is valid (by its existence in the map), and that the user's key has
    not exceeded their quota of requests. If any of these conditions occur, the filter
    will abort the request and return a response with useful data for the client.
    If the filter method exits normally, then the request will proceed, and the JAX-RS
    container will attempt to match the request to a resource class and method.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例检查客户端是否通过 HTTP 头发送了 API 密钥，API 密钥是否有效（通过其在映射中的存在），以及用户的密钥是否未超过其请求配额。如果发生任何这些条件，过滤器将终止请求并返回对客户端有用的响应。如果过滤器方法正常退出，则请求将继续，JAX-RS
    容器将尝试将请求与资源类和方法匹配。
- en: Once the request has been matched to a resource method, the JAX-RS container
    will invoke post-match request filters. These filters are useful for performing
    `ContainerRequestFilter`) as pre-match filters, but without the `@PreMatching`
    annotation. Post-match filters also enable more methods from the `RequestContext`
    object so that it knows which resource will be invoked. This is handy for situations
    where your filter may want to behave differently based on the resource class/method
    it will invoke.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦请求与资源方法匹配，JAX-RS 容器将调用匹配后请求过滤器。这些过滤器在作为预匹配过滤器执行 `ContainerRequestFilter` 时很有用，但没有
    `@PreMatching` 注解。匹配后过滤器还启用了 `RequestContext` 对象的更多方法，以便它知道将调用哪个资源。这在你的过滤器可能根据它将调用的资源类/方法而表现不同的场合很有用。
- en: Response filters are similar to request filters but are invoked after the resource
    method has been completed. Response filters can then further refine or transform
    the response. They could add or modify response headers or cookies. They could
    also replace the response entity entirely, though a `MessageBodyWriter` provider
    and/or `WriterInterceptor` provider might be more appropriate for that.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 响应过滤器与请求过滤器类似，但在资源方法完成后被调用。然后，响应过滤器可以进一步细化或转换响应。它们可以添加或修改响应头或cookie。它们也可以完全替换响应实体，尽管`MessageBodyWriter`提供者和/或`WriterInterceptor`提供者可能更适合这种情况。
- en: Dynamic providers
  id: totrans-124
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 动态提供者
- en: So far, all of the providers we have discussed will apply to all requests—or
    at least all matched requests—the only exception being entity providers, which
    will apply to all requests of the request's specified media type(s). But what
    if we want some providers to only be executed in certain circumstances, such as
    when a specific resource method is invoked or if the request contains specific
    content, or if the client's user is part of a special group? JAX-RS provides a
    few different mechanisms for more dynamic providers. First, we'll look at name
    binding.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们讨论的所有提供者都将应用于所有请求——或者至少是所有匹配的请求——唯一的例外是实体提供者，它将应用于请求指定的所有媒体类型（s）的请求。但如果我们希望某些提供者只在特定情况下执行，例如在调用特定资源方法或请求包含特定内容，或者客户端的用户是特殊群体的一部分时，怎么办呢？JAX-RS提供了一些不同的机制来实现更动态的提供者。首先，我们将看看名称绑定。
- en: '**Name binding** allows users to place a custom annotation on one or more provider
    classes and one or more resource classes or methods. The JAX-RS container will
    then recognize that annotation and only invoke the provider if the target resource
    method or class is also annotated. For example, suppose we want to log certain
    requests; we might create an annotation like this:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '**名称绑定**允许用户在一个或多个提供者类以及一个或多个资源类或方法上放置自定义注解。JAX-RS容器将识别这个注解，并且只有在目标资源方法或类也被注解的情况下才会调用提供者。例如，如果我们想记录某些请求，我们可能会创建一个这样的注解：'
- en: '[PRE21]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The `@NameBinding` annotation is what tells the JAX-RS container to pay attention
    to this annotation. We can now create a filter that logs the request method, the
    **Uniform Resource Identifier** (**URI**), and the request and response entity
    (the full source code is available at [https://github.com/PacktPublishing/Practical-Cloud-Native-Java-Development-with-MicroProfile/blob/main/Chapter04/src/main/java/com/packt/microprofile/book/ch4/dynamicbinding/LoggingFilter.java](https://github.com/PacktPublishing/Practical-Cloud-Native-Java-Development-with-MicroProfile/blob/main/Chapter04/src/main/java/com/packt/microprofile/book/ch4/dynamicbinding/LoggingFilter.java)).
    Have a look at the following code snippet:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '`@NameBinding`注解是告诉JAX-RS容器注意这个注解的。我们现在可以创建一个记录请求方法、**统一资源标识符**（**URI**）以及请求和响应实体的过滤器（完整的源代码可在[https://github.com/PacktPublishing/Practical-Cloud-Native-Java-Development-with-MicroProfile/blob/main/Chapter04/src/main/java/com/packt/microprofile/book/ch4/dynamicbinding/LoggingFilter.java](https://github.com/PacktPublishing/Practical-Cloud-Native-Java-Development-with-MicroProfile/blob/main/Chapter04/src/main/java/com/packt/microprofile/book/ch4/dynamicbinding/LoggingFilter.java)找到）。看看下面的代码片段：'
- en: '[PRE22]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: This `filter` class is both a request and response filter. While it is very
    convenient to combine request and response filters (or perhaps even other provider
    types), it is important to note that the life-cycle behavior may change from one
    JAX-RS container to another. In general, it is considered a best practice not
    to store data in instance variables. If you want to store a piece of data from
    the request's filter method to be used in the response's filter method, a more
    portable approach would be to store that data in `requestContext` as a property,
    as we did for the request **identifier** (**ID**) in the preceding example.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`filter`类既是请求过滤器也是响应过滤器。虽然将请求和响应过滤器（或者甚至其他提供者类型）组合在一起非常方便，但重要的是要注意，生命周期行为可能从一个JAX-RS容器变化到另一个容器。一般来说，被认为是一种最佳实践，不要在实例变量中存储数据。如果您想从请求的过滤器方法存储一些数据以在响应的过滤器方法中使用，一个更便携的方法是将该数据存储在`requestContext`中作为一个属性，就像我们在前面的例子中为请求**标识符**（**ID**）所做的那样。
- en: 'Now, we would just add the `@Logged` annotation to the classes (all methods
    in the class) or methods that should be logged, so in the following example, only
    the `POST` method would be logged (the full source code is available at [https://github.com/PacktPublishing/Practical-Cloud-Native-Java-Development-with-MicroProfile/blob/main/Chapter04/src/main/java/com/packt/microprofile/book/ch4/dynamicbinding/DynamicResource.java](https://github.com/PacktPublishing/Practical-Cloud-Native-Java-Development-with-MicroProfile/blob/main/Chapter04/src/main/java/com/packt/microprofile/book/ch4/dynamicbinding/DynamicResource.java)):'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们只需将`@Logged`注解添加到需要记录的类（类中的所有方法）或方法上，所以在这个例子中，只有`POST`方法会被记录（完整的源代码可在[https://github.com/PacktPublishing/Practical-Cloud-Native-Java-Development-with-MicroProfile/blob/main/Chapter04/src/main/java/com/packt/microprofile/book/ch4/dynamicbinding/DynamicResource.java](https://github.com/PacktPublishing/Practical-Cloud-Native-Java-Development-with-MicroProfile/blob/main/Chapter04/src/main/java/com/packt/microprofile/book/ch4/dynamicbinding/DynamicResource.java)找到）：
- en: '[PRE23]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Another approach to dynamically apply providers is to use `configure`, which
    provides a `ResourceInfo` object that is used to determine specifics of the matched
    resource, and a `FeatureContext` object that is used to configure the providers
    and properties or view the application configuration for each request. The following
    example will add the `LoggingFilter` class to all resource methods that start
    with `get`:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种动态应用提供者的方法是使用`configure`，它提供了一个`ResourceInfo`对象，用于确定匹配资源的具体信息，以及一个`FeatureContext`对象，用于配置提供者和属性或查看每个请求的应用程序配置。以下示例将`LoggingFilter`类添加到所有以`get`开头的方法资源中：
- en: '[PRE24]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Since the `ResourceInfo` object will return the matched class and method, it
    is also possible to check the annotations of the matched resource. This makes
    it easy for dynamic features to register a provider for all requests of a specific
    HTTP verb (`if (resourceInfo.getResourceMethod().getAnnotation(GET.class) != null)
    { //…` ) or methods with annotations that don't already have the `@NameBinding`
    annotation.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`ResourceInfo`对象将返回匹配的类和方法，因此也可以检查匹配资源的注解。这使得动态功能可以为特定HTTP动词的所有请求（`if (resourceInfo.getResourceMethod().getAnnotation(GET.class)
    != null) { //…`）或没有`@NameBinding`注解的方法注册提供者变得容易。
- en: Name binding annotations and dynamic filters are powerful ways to control request
    and response processing.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 名称绑定注解和动态过滤器是控制请求和响应处理的有效方法。
- en: Async
  id: totrans-137
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 异步
- en: Enough with providers! Let's get back to the core of RESTful services—the resources.
    In many cases, the synchronous nature of the JAX-RS request/response flow is inefficient.
    For example, suppose your resources tend to pass a request to a data store that
    looks up or modifies data in a database. If your data store logic has a fixed
    set of threads performing the database operations, then when the service is under
    load, incoming requests may be queued. With the synchronous flow we've been working
    with so far, this means that the flow of execution would block inside the resource
    method waiting for the data-store logic to complete before completing the flow.
    This can be inefficient as one thread essentially waits for another to complete.
    That initial thread could be more efficient if it were to perform some other task
    while the data-store operations take place. Using **asynchronous** APIs in JAX-RS
    can obtain that increased efficiency.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 足够了，关于提供者！让我们回到RESTful服务的核心——资源。在许多情况下，JAX-RS请求/响应流的同步特性效率低下。例如，假设你的资源倾向于将请求传递给一个数据存储，该数据存储在数据库中查找或修改数据。如果你的数据存储逻辑有一组固定的线程执行数据库操作，那么当服务负载较高时，传入的请求可能会排队。使用我们迄今为止一直在使用的同步流程，这意味着执行流程会在资源方法内部阻塞，等待数据存储逻辑完成，然后才能完成流程。这可能会效率低下，因为一个线程实际上在等待另一个线程完成。如果这个初始线程在数据存储操作进行时执行其他任务，可能会更有效率。使用JAX-RS中的**异步**API可以获得更高的效率。
- en: AsyncResponse
  id: totrans-139
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 异步响应
- en: 'Asynchronous methods in JAX-RS are created by adding an `AsyncResponse` parameter
    to the resource method, annotated with `@Suspended`. The `AsyncResponse` object
    may then be used to *resume* the request once the data has been fetched from the
    data store. Let''s take a look at an example. Suppose we have a service that tracks
    people, like the one we used in the *Entity providers* section. We''ll change
    the resource class around a little so that the data store access uses a separate
    `Executor` class to retrieve the data (the full source code is available at [https://github.com/PacktPublishing/Practical-Cloud-Native-Java-Development-with-MicroProfile/blob/main/Chapter04/src/main/java/com/packt/microprofile/book/ch4/async/AsyncPersonService.java](https://github.com/PacktPublishing/Practical-Cloud-Native-Java-Development-with-MicroProfile/blob/main/Chapter04/src/main/java/com/packt/microprofile/book/ch4/async/AsyncPersonService.java)).
    Have a look at the following code snippet:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在JAX-RS中创建异步方法是通过在资源方法中添加一个`AsyncResponse`参数并使用`@Suspended`注解来实现的。一旦从数据存储中获取了数据，`AsyncResponse`对象就可以用来*恢复*请求。让我们看一个例子。假设我们有一个跟踪人员的服务，就像我们在*实体提供者*部分使用的那样。我们将稍微修改资源类，以便数据存储访问使用一个单独的`Executor`类来检索数据（完整的源代码可在[https://github.com/PacktPublishing/Practical-Cloud-Native-Java-Development-with-MicroProfile/blob/main/Chapter04/src/main/java/com/packt/microprofile/book/ch4/async/AsyncPersonService.java](https://github.com/PacktPublishing/Practical-Cloud-Native-Java-Development-with-MicroProfile/blob/main/Chapter04/src/main/java/com/packt/microprofile/book/ch4/async/AsyncPersonService.java)找到））。看看下面的代码片段：
- en: '[PRE25]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: In this version of the code, the `getPersonSync` method will submit a request
    to the executor service to retrieve the `Person` object with the specified ID,
    then it will block until the executor service has completed the operation. In
    this case (for code simplicity), it is just pulling data out of a hash map, but
    if it were pulling data out of a remote database, the time spent blocking in the
    `someData.get()` call could be more substantial.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个版本的代码中，`getPersonSync`方法将向执行器服务提交一个请求以检索具有指定ID的`Person`对象，然后它将阻塞，直到执行器服务完成操作。在这种情况下（为了代码的简洁性），它只是从哈希表中拉取数据，但如果它要从远程数据库中拉取数据，那么在`someData.get()`调用中阻塞的时间可能会更长。
- en: 'So, let''s try to improve the efficiency so that we don''t have to block. We
    can rewrite the `getPersonSync()` method to look like this:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们尝试提高效率，这样我们就不必阻塞。我们可以将`getPersonSync()`方法重写如下：
- en: '[PRE26]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Now, the executor service is invoking the `getPerson(id)` method, but then passing
    the result to `ar.resume(…)`, which will pick up the request/response flow where
    it left off and return a response. The request thread that invoked the `getPersonAsync(…)`
    method immediately returns and can be used to service another request.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，执行器服务正在调用`getPerson(id)`方法，然后将结果传递给`ar.resume(…)`，这将从上次停止的地方恢复请求/响应流程并返回一个响应。调用`getPersonAsync(…)`方法的请求线程立即返回，可以用来处理另一个请求。
- en: 'The `AsyncResponse` object can also be used to handle an exception. Let''s
    say that we want to throw a `NoSuchPersonException` exception if the ID specified
    does not match any `Person` instance in the database. We might change the code
    to look like this:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '`AsyncResponse`对象也可以用来处理异常。假设我们希望在指定的ID与数据库中的任何`Person`实例不匹配时抛出`NoSuchPersonException`异常。我们可能将代码修改如下：'
- en: '[PRE27]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: When we resume a response with an exception, the JAX-RS container will attempt
    to map the exception to a suitable response, just as it does in the synchronous
    case.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们用一个异常恢复响应时，JAX-RS容器将尝试将异常映射到一个合适的响应，就像在同步情况下所做的那样。
- en: Server-sent events
  id: totrans-149
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 服务器端发送事件
- en: Another form of server-side async is **server-sent events** (**SSEs**). SSEs
    are a part of the **HyperText Markup Language 5** (**HTML 5**) specification and
    provide a way for a client to register and receive events asynchronously from
    a server.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器端异步的另一种形式是**服务器端发送事件**（**SSEs**）。SSEs是**超文本标记语言 5**（**HTML 5**）规范的一部分，为客户端提供了一种从服务器异步注册和接收事件的方式。
- en: 'JAX-RS has two ways of sending SSEs—streaming directly to each client and **broadcasting**
    to all clients. Let''s take a look at how you might implement the first way, as
    follows (the full source code is available at [https://github.com/PacktPublishing/Practical-Cloud-Native-Java-Development-with-MicroProfile/blob/main/Chapter04/src/main/java/com/packt/microprofile/book/ch4/async/SseService.java](https://github.com/PacktPublishing/Practical-Cloud-Native-Java-Development-with-MicroProfile/blob/main/Chapter04/src/main/java/com/packt/microprofile/book/ch4/async/SseService.java)):'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: JAX-RS 有两种发送 SSEs 的方式——直接向每个客户端流式传输和 **广播** 到所有客户端。让我们看看如何实现第一种方式，如下所示（完整源代码可在
    [https://github.com/PacktPublishing/Practical-Cloud-Native-Java-Development-with-MicroProfile/blob/main/Chapter04/src/main/java/com/packt/microprofile/book/ch4/async/SseService.java](https://github.com/PacktPublishing/Practical-Cloud-Native-Java-Development-with-MicroProfile/blob/main/Chapter04/src/main/java/com/packt/microprofile/book/ch4/async/SseService.java)
    找到）：
- en: '[PRE28]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: This is a contrived example, but it shows the method immediately returns after
    starting a new thread that sends a few text events to the client separated by
    a half-second delay.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个虚构的例子，但它显示了方法在启动一个新线程后立即返回，该线程以半秒的延迟向客户端发送一些文本事件。
- en: This example shows us that in order for a JAX-RS resource to send SSEs, it must
    produce the SSE media type (`MediaType.SERVER_SENT_EVENTS`, or `text/event-stream`)
    and the method must receive `Sse` and `SseEventSink` parameters, both annotated
    with `@Context`. The `Sse` type is a utility class that can create events and
    broadcasters. The `SseEventSink` type represents the connection between the server
    and the client, so calling the `send(…)` method sends a new event to that specific
    client, and calling the `close()` method (which is done implicitly by the try-with-resources
    logic) will gracefully close the connection with the client.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子向我们展示了，为了使 JAX-RS 资源能够发送服务器端事件（SSEs），它必须生成 SSE 媒体类型（`MediaType.SERVER_SENT_EVENTS`
    或 `text/event-stream`），并且该方法必须接收 `Sse` 和 `SseEventSink` 参数，这两个参数都带有 `@Context`
    注解。`Sse` 类型是一个实用类，可以创建事件和广播器。`SseEventSink` 类型代表服务器和客户端之间的连接，因此调用 `send(…)` 方法会将新事件发送给特定的客户端，而调用
    `close()` 方法（这是通过 try-with-resources 逻辑隐式执行的）将优雅地关闭与客户端的连接。
- en: The events we are sending have a `text/plain` media type—the media type is used
    to determine which `MessageBodyWriter` provider should be used to serialize that
    object passed to the data method. The `name(…)` and `id(...)` methods can provide
    additional context to each event sent. Only the `data(…)` method is required,
    though it is always a best practice to specify the media type.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 我们发送的事件具有 `text/plain` 媒体类型——媒体类型用于确定应该使用哪个 `MessageBodyWriter` 提供程序来序列化传递给数据方法的那个对象。`name(…)`
    和 `id(...)` 方法可以为每个发送的事件提供额外的上下文。尽管 `data(…)` 方法是必需的，但始终指定媒体类型是一个最佳实践。
- en: 'If we were to invoke this service using `curl`, we would see something like
    this:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用 `curl` 调用此服务，我们会看到如下内容：
- en: '[PRE29]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Another approach to sending events is to use a `SseEventSinks`, and it will
    send events to all registered clients. Let''s look at an example of code that
    we might add to our `SseService` class, as follows:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 发送事件的另一种方法是使用 `SseEventSinks`，它将事件发送给所有已注册的客户端。让我们看看我们可能添加到 `SseService` 类中的代码示例，如下所示：
- en: '[PRE30]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: As with the direct-stream approach, this approach also requires that the method
    produce a media type of `SERVER_SENT_EVENTS` and that the method has the `SseEventSink`
    and `Sse` parameter types.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 与直接流方法一样，这种方法也要求方法生成 `SERVER_SENT_EVENTS` 媒体类型，并且方法具有 `SseEventSink` 和 `Sse`
    参数类型。
- en: First, we need to set `SseBroadcaster` as a static field. We do this because
    the default life cycle for JAX-RS resources is per request. We will discuss alternate
    life cycles in the *Managing life cycle and DI with CDI* section—that will simplify
    this code and improve performance too.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要将 `SseBroadcaster` 设置为静态字段。我们这样做是因为 JAX-RS 资源默认的生命周期是每个请求。我们将在 *使用 CDI
    管理生命周期和 DI* 部分讨论替代生命周期——这将简化此代码并提高性能。
- en: 'Once we have the broadcaster set, we then register the event sink with it.
    Once registered, the client associated with that event sink will receive all events
    sent from this broadcaster. In this example, we broadcast an event any time a
    new client is registered and every 5 seconds. Let''s see what this looks like
    on the command line when using `curl` when we are the first client, and when a
    second client registers (from a separate command window), as follows:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们设置了广播器，我们就会将其与事件接收器注册。一旦注册，与该事件接收器关联的客户端将接收到从该广播器发送的所有事件。在这个例子中，每当有新的客户端注册以及每5秒钟，我们都会广播一个事件。让我们看看当我们是第一个客户端时，使用
    `curl` 在命令行上看起来是什么样子，以及当第二个客户端注册（从一个单独的命令窗口）时的情况，如下所示：
- en: '[PRE31]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: One thing to notice about this output is the `UnnamedEvent` text—this is because
    SSEs must have a name, so if no name is provided when it is built, the JAX-RS
    container creates a name for it. Other JAX-RS containers may use a different name
    if none is specified.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 关于这个输出的一个需要注意的事项是 `未命名的Event` 文本——这是因为 SSE 必须有一个名称，所以如果在构建时没有提供名称，JAX-RS 容器会为其创建一个名称。如果没有指定，其他
    JAX-RS 容器可能会使用不同的名称。
- en: Context injection
  id: totrans-165
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 上下文注入
- en: 'We''ve already discussed injection when using the `@Context` annotation for
    SSE objects, but this annotation can be used for a lot more. **Context injection**
    can occur in both resources and providers. There are lots of useful things you
    can inject, as outlined here:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经讨论了在使用 `@Context` 注解 SSE 对象时的注入，但这个注解可以用在很多地方。**上下文注入**可以在资源和提供者中发生。你可以注入很多有用的事物，如下所述：
- en: '`ResourceContext`: Used for initializing sub-resource locators'
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ResourceContext`: 用于初始化子资源定位器'
- en: '`ResourceInfo`: Used for determining the matched resource class and method'
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ResourceInfo`: 用于确定匹配的资源类和方法'
- en: '`HttpHeaders`: Used for reading HTTP headers in the client request'
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`HttpHeaders`: 用于读取客户端请求中的 HTTP 头'
- en: '`SecurityContext`: Used for determining the current user, their security role,
    and so on'
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SecurityContext`: 用于确定当前用户、他们的安全角色等'
- en: '`UriInfo`: Used for reading the URI of the client request'
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`UriInfo`: 用于读取客户端请求的 URI'
- en: '`Application`: Used for obtaining the application representing this RESTful
    service'
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`应用程序`: 用于获取表示此 RESTful 服务的应用程序'
- en: '`Providers`: Used for accessing other JAX-RS providers'
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`提供者`: 用于访问其他 JAX-RS 提供者'
- en: '`Sse` and `SseEventSink`: Discussed in the previous section'
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Sse` 和 `SseEventSink`: 在上一节中讨论'
- en: Best practice
  id: totrans-175
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 最佳实践
- en: In most cases, it is recommended that context injection occurs in fields rather
    than as parameters. The reason for this is that the Jakarta REST project is intending
    to deprecate the `@Context` annotation in favor of CDI's `@Inject` annotation,
    which does not target method parameters.
  id: totrans-176
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在大多数情况下，建议上下文注入发生在字段而不是参数中。原因是 Jakarta REST 项目打算废弃 `@Context` 注解，转而使用 CDI 的
    `@Inject` 注解，该注解不针对方法参数。
- en: '**Javadoc** ([https://jakarta.ee/specifications/restful-ws/2.1/apidocs/overview-summary.html](https://jakarta.ee/specifications/restful-ws/2.1/apidocs/overview-summary.html))
    is the best resource for understanding the capabilities of each of these injectable
    types. Here are a few basic examples:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '**Javadoc** ([https://jakarta.ee/specifications/restful-ws/2.1/apidocs/overview-summary.html](https://jakarta.ee/specifications/restful-ws/2.1/apidocs/overview-summary.html))
    是理解这些可注入类型功能的最佳资源。以下是一些基本示例：'
- en: '[PRE32]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'This example uses the role of the client''s user principal to determine what
    entity response to return. The following example uses the `ResourceInfo` class
    to determine whether a `MessageBodyWriter` provider should be used or not:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例使用客户端用户主体的角色来确定要返回的实体响应。以下示例使用 `ResourceInfo` 类来确定是否应该使用 `MessageBodyWriter`
    提供者：
- en: '[PRE33]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The injection of context objects into resources and providers enables us to
    develop powerful and flexible applications. Now, let's turn our attention to formatting
    the data our application will need to send and receive.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '将上下文对象注入资源和提供者使我们能够开发强大且灵活的应用程序。现在，让我们将注意力转向格式化应用程序需要发送和接收的数据。 '
- en: Managing the payload with JSON-P and JSON-B
  id: totrans-182
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 JSON-P 和 JSON-B 管理有效载荷
- en: While RESTful services in general and JAX-RS applications specifically can serve
    entities of any media type (plain text, **Extensible Markup Language** (**XML**),
    **Portable Document Format** (**PDF**), binary, and so on), JSON is the *standard
    du jour* for cloud-native applications. JSON is popular because it is both human-readable
    and easily parsed— libraries for JSON parsing and binding exist in virtually all
    modern languages.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然一般来说 RESTful 服务和具体来说 JAX-RS 应用可以提供任何媒体类型的实体（纯文本、**可扩展标记语言**（**XML**）、**可移植文档格式**（**PDF**）、二进制等），但
    JSON 是云原生应用的**当红炸子鸡**。JSON 流行是因为它既易于阅读又易于解析——几乎在所有现代语言中都有 JSON 解析和绑定的库。
- en: In the *Entity providers* section, we got a taste of serializing and deserializing
    a Java object (`Person`) into JSON. In that section, we performed this by hand
    using string manipulation. While a manual approach can work, we're now going to
    discuss two APIs that enable simpler and more powerful control over JSON in Java.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *实体提供者* 部分，我们体验了将 Java 对象（`Person`）序列化和反序列化为 JSON 的过程。在那个部分，我们通过字符串操作手动执行了这一操作。虽然手动方法可以工作，但现在我们将讨论两个
    API，它们可以简化并增强 Java 中对 JSON 的控制。
- en: JSON-P is a programmatic API for manipulating JSON, while JSON-B is a declarative
    (annotation-based) API for quickly and easily mapping an object to JSON or vice
    versa.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: JSON-P 是一个用于操作 JSON 的程序性 API，而 JSON-B 是一个声明性（基于注解）的 API，用于快速轻松地将对象映射到 JSON 或相反。
- en: JSON-P
  id: totrans-186
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: JSON-P
- en: '`JsonObject`, `JsonArray`, and so on, which are part of the object model API.'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '`JsonObject`、`JsonArray` 等，这些都是对象模型 API 的一部分。'
- en: 'Let''s say we have some objects such as these:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有一些这样的对象：
- en: '[PRE34]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'And let''s say we want to convert that into JSON content that looks like this:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想要将其转换为类似以下的 JSON 内容：
- en: '[PRE35]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: We'll start out by converting an instance of `Starship` into a JSON string.
    We can do this by using the `Json` class to create object builders and array builders.
    These builders can create objects by adding properties or objects. So, to create
    the JSON for a starship, we would need an object builder for the starship and
    for each weapon, and then an array builder for all of the weapons. An example
    of this is available at [https://github.com/PacktPublishing/Practical-Cloud-Native-Java-Development-with-MicroProfile/blob/main/Chapter04/src/main/java/com/packt/microprofile/book/ch4/jsonp/JsonpConverter.java](https://github.com/PacktPublishing/Practical-Cloud-Native-Java-Development-with-MicroProfile/blob/main/Chapter04/src/main/java/com/packt/microprofile/book/ch4/jsonp/JsonpConverter.java).
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从将 `Starship` 实例转换为 JSON 字符串开始。我们可以通过使用 `Json` 类来创建对象构建器和数组构建器来完成此操作。这些构建器可以通过添加属性或对象来创建对象。因此，为了创建飞船的
    JSON，我们需要一个飞船的对象构建器，以及每个武器的对象构建器，然后是一个用于所有武器的数组构建器。一个这样的例子可以在[https://github.com/PacktPublishing/Practical-Cloud-Native-Java-Development-with-MicroProfile/blob/main/Chapter04/src/main/java/com/packt/microprofile/book/ch4/jsonp/JsonpConverter.java](https://github.com/PacktPublishing/Practical-Cloud-Native-Java-Development-with-MicroProfile/blob/main/Chapter04/src/main/java/com/packt/microprofile/book/ch4/jsonp/JsonpConverter.java)找到。
- en: Each object needs its own `JsonObjectBuilder` instance, and each array or collection
    needs its own `JsonArrayBuilder` instance. Then, you simply add items to them.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 每个对象都需要自己的 `JsonObjectBuilder` 实例，每个数组或集合都需要自己的 `JsonArrayBuilder` 实例。然后，你只需向它们添加项目即可。
- en: 'Deserializing a JSON string into an object works in the opposite way. First,
    you must extract `JsonObject` instance from `JsonReader`, like so:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 将 JSON 字符串反序列化为对象的方式相反。首先，你必须从 `JsonReader` 中提取 `JsonObject` 实例，如下所示：
- en: '[PRE36]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Then, you must create a `Starship` instance and populate it from the properties
    in the `JsonObject`, like this:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你必须创建一个 `Starship` 实例，并从 `JsonObject` 的属性中填充它，如下所示：
- en: '[PRE37]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: This approach uses the object model, which requires loading the entire JSON
    stream into memory before it can be converted into an object. For small JSON files,
    this is not an issue, and it allows the model to be stored in memory and re-accessed.
    It also allows the model to be changed over time before writing the JSON back
    to a stream.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法使用对象模型，它需要在将其转换为对象之前将整个 JSON 流加载到内存中。对于小 JSON 文件，这不会成为问题，并且允许模型存储在内存中并重新访问。它还允许在将
    JSON 写回流之前更改模型。
- en: 'The streaming approach requires far less memory and is capable of reading extremely
    large JSON streams without running out of memory. It accomplishes this by firing
    events as it reads the JSON and then discards that portion of the JSON. This is
    very efficient and performs better than the object model, but it requires more
    complex coding, and since the object model is not in memory, you cannot go back
    later to ask it: *Now, what was the value again?*'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 流式方法需要的内存远少于对象模型，并且能够读取非常大的 JSON 流而不会耗尽内存。它是通过在读取 JSON 时触发事件，然后丢弃该部分的 JSON 来实现这一点的。这种方法非常高效，性能优于对象模型，但需要更复杂的编码，并且由于对象模型不在内存中，你无法稍后回过头来询问：“现在，那个值是什么来着？”
- en: 'Using the same Java object and JSON stream as before, here is what the serialization
    code looks like (the full source code is available at [https://github.com/PacktPublishing/Practical-Cloud-Native-Java-Development-with-MicroProfile/blob/main/Chapter04/src/main/java/com/packt/microprofile/book/ch4/jsonp/JsonpStreamingConverter.java](https://github.com/PacktPublishing/Practical-Cloud-Native-Java-Development-with-MicroProfile/blob/main/Chapter04/src/main/java/com/packt/microprofile/book/ch4/jsonp/JsonpStreamingConverter.java)):'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 使用与之前相同的 Java 对象和 JSON 流，以下是序列化代码的示例（完整源代码可在[https://github.com/PacktPublishing/Practical-Cloud-Native-Java-Development-with-MicroProfile/blob/main/Chapter04/src/main/java/com/packt/microprofile/book/ch4/jsonp/JsonpStreamingConverter.java](https://github.com/PacktPublishing/Practical-Cloud-Native-Java-Development-with-MicroProfile/blob/main/Chapter04/src/main/java/com/packt/microprofile/book/ch4/jsonp/JsonpStreamingConverter.java)找到）：
- en: '[PRE38]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Similar to `JsonObjectBuilder` and `JsonArrayBuilder`, `JsonGenerator` can pass
    in map-like values to build the JSON object. Unlike the object model builder APIs,
    `JsonGenerator` cannot make changes—once the JSON is written, you cannot change
    the values. Both of the builders have `remove` methods, and the `JsonArrayBuilder`
    API has setter methods, allowing you to change previously configured values. The
    reason for having these two approaches is to allow you to make a decision between
    flexibility and efficiency.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 与 `JsonObjectBuilder` 和 `JsonArrayBuilder` 类似，`JsonGenerator` 可以传入类似映射的值来构建
    JSON 对象。与对象模型构建器 API 不同，`JsonGenerator` 无法进行更改——一旦 JSON 被写入，就无法更改值。这两个构建器都有 `remove`
    方法，而 `JsonArrayBuilder` API 有设置方法，允许您更改之前配置的值。存在这两种方法的原因是让您在灵活性和效率之间做出选择。
- en: 'For parsing JSON into an object, a stream-based approach is even more complex,
    as we can see here:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 将 JSON 解析到对象中，基于流的方案甚至更复杂，如下所示：
- en: '[PRE39]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The parser works similar to a Java iterator, returning events to indicate things
    such as object start (`{`), object end (`}`), array start (`[`), array end (`]`),
    key names (for example, `name` and `speedRating`), and key values (for example,
    `Coreillian Freighter` and `24`). It is important that each event is interpreted
    within its context. For example, an array might contain several objects, so it
    is necessary to keep track of which object is currently being parsed to avoid
    mixing up data. The `parseWeapons` method provides an example of this by separately
    parsing each item in the array, as illustrated in the following code snippet:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 解析器的工作方式类似于 Java 迭代器，返回事件以指示诸如对象开始（`{`）、对象结束（`}`）、数组开始（`[`）、数组结束（`]`）、键名（例如，`name`
    和 `speedRating`）以及键值（例如，`Coreillian Freighter` 和 `24`）等信息。每个事件在其上下文中被解释是很重要的。例如，一个数组可能包含多个对象，因此需要跟踪当前正在解析的对象，以避免数据混淆。`parseWeapons`
    方法通过分别解析数组中的每个项目来提供示例，如下面的代码片段所示：
- en: '[PRE40]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: JSON-P provides a very powerful API set for reading and writing JSON programmatically.
    The code can tend to be a tad verbose, though. That's something that JSON-B can
    help with.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: JSON-P 提供了一套非常强大的 API，用于程序化地读取和写入 JSON。不过，代码可能会有些冗长。这正是 JSON-B 可以帮助解决的问题。
- en: JSON-B
  id: totrans-208
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: JSON-B
- en: While JSON-P is very powerful and flexible, **JSON-B** is very simple and efficient
    at serializing and deserializing objects to JSON. JSON-B has some programmatic
    APIs but overall, it takes a declarative approach to writing/reading JSON. This
    means that the conversion of an object to JSON will be based on the object type's
    getter methods—and likewise, the conversion of JSON to object will be based on
    the object type's setter methods.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 JSON-P 非常强大且灵活，但 **JSON-B** 在序列化和反序列化对象到 JSON 方面非常简单且高效。JSON-B 有一些程序化 API，但总体而言，它采用声明式方法来编写/读取
    JSON。这意味着对象到 JSON 的转换将基于对象类型的 getter 方法——同样，JSON 到对象的转换将基于对象类型的 setter 方法。
- en: 'If we use the example objects of `Starships` and `Weapons` from JSON-P, the
    conversion of object to JSON and vice versa is very simple, as is illustrated
    here:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用来自JSON-P的`Starships`和`Weapons`的示例对象，对象到JSON以及相反的转换非常简单，如下所示：
- en: '[PRE41]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'It is possible to convert directly to a string but using `OutputStream` or
    `Writer` is preferable, especially when dealing with large JSON objects. The primary
    objects here are `Jsonb` and the `toJson(…)` method. You can see the output here:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 直接转换为字符串是可能的，但使用`OutputStream`或`Writer`更可取，尤其是在处理大型JSON对象时。这里的主要对象是`Jsonb`和`toJson(…)`方法。你可以在这里看到输出：
- en: '[PRE42]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'This looks very similar to what we created using JSON-P, but it''s all on one
    line and difficult to distinguish where one object ends and the next begins. For
    most JSON consumers that should not be a problem, but if we want to make it more
    human-readable, we can add some configuration by replacing the `JsonbBuilder.create()`
    method call with the following code:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 这看起来与我们使用JSON-P创建的非常相似，但它都在一行中，难以区分一个对象在哪里结束，下一个对象在哪里开始。对于大多数JSON消费者来说，这应该不是问题，但如果我们想让它更易于阅读，我们可以通过用以下代码替换`JsonbBuilder.create()`方法调用来添加一些配置：
- en: '[PRE43]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'This will produce the following output:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 这将产生以下输出：
- en: '[PRE44]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: There are several other configuration options that you could use to handle the
    serialization of a Java object.  For example, you could also add your own `JsonParser`
    from JSON-P to convert the object to JSON your own way.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用几种其他配置选项来处理Java对象的序列化。例如，你也可以添加自己的`JsonParser`从JSON-P，以你自己的方式将对象转换为JSON。
- en: 'Converting JSON back into an object is just as simple, as we can see here:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 将JSON转换回对象同样简单，如下所示：
- en: '[PRE45]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: And as with the `toJson(…)` method, you can use a string or a stream.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 与`toJson(…)`方法一样，你可以使用字符串或流。
- en: 'So, what happens if you have an object, but you want the JSON fields to have
    a different name than the Java property name? Or, maybe you don''t want certain
    fields to be exposed as JSON at all? That''s where annotations such as `@JsonbProperty("someOtherName")`
    and `@JsonbTransient` come in handy, and depending on where you place the annotation,
    it will have a different effect. If the annotation is on the getter, then it will
    only apply to serialization (conversion from Java to JSON). If the annotation
    is on the setter, then it will only apply deserialization. If the annotation is
    on the field itself, then it will apply to both. Let''s consider the following
    code snippet:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，如果你有一个对象，但你想JSON字段的名字与Java属性名不同呢？或者，也许你根本不想将某些字段暴露为JSON？这时，`@JsonbProperty("someOtherName")`和`@JsonbTransient`这样的注解就派上用场了，而且根据你放置注解的位置，它会产生不同的效果。如果注解在getter上，那么它只会应用于序列化（从Java到JSON的转换）。如果注解在setter上，那么它只会应用于反序列化。如果注解在字段本身上，那么它将应用于两者。让我们考虑以下代码片段：
- en: '[PRE46]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'We would create an instance of `Person` and print it out to JSON, like so:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个`Person`实例并将其打印为JSON，如下所示：
- en: '[PRE47]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'The output would look like this:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 输出将看起来像这样：
- en: '[PRE48]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'The `lastName` field has been converted to `familyName`, the `middleName` field
    has not been printed at all, and the `favoriteColor` field has been Britishized
    to `favouriteColour`. But if we tried to create a new `Person` instance from this
    JSON, we would get an incomplete `Person` instance. Let''s take a look, as follows:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: '`lastName`字段已转换为`familyName`，`middleName`字段根本未打印，而`favoriteColor`字段已被英国化为`favouriteColour`。但如果我们尝试从这个JSON创建一个新的`Person`实例，我们会得到一个不完整的`Person`实例。让我们看一下，如下所示：'
- en: '[PRE49]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'This would yield the following output:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 这将产生以下输出：
- en: '[PRE50]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: The `middleName` field was missing from the JSON, so it is no surprise that
    it is null. Since the `@JsonbProperty("favouriteColour")` annotation is only on
    the getter, JSON-B will not convert the Britishized JSON field to the Americanized
    Java field. And since the `@JsonbProperty("yearsOld")` annotation is applied to
    the `setAge(…)` method, it will not be set since the JSON is still using the `age`
    field name.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: '`middleName`字段在JSON中缺失，所以它为null并不奇怪。由于`@JsonbProperty("favouriteColour")`注解只存在于getter上，JSON-B不会将英国化的JSON字段转换为美国化的Java字段。而且，由于`@JsonbProperty("yearsOld")`注解应用于`setAge(…)`方法，它将不会被设置，因为JSON仍在使用`age`字段名。'
- en: The behavior differences depending on where an annotation is placed are important
    to note when using JSON-B.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 使用JSON-B时，注意注解放置的位置导致的差异行为是很重要的。
- en: Now, let's tie this back to JAX-RS. The JAX-RS specification says that a product
    that supports JSON-P must supply `MessageBodyReaders` and `MessageBodyWriters`
    for entity types of `JsonStructure`, `JsonObject`, `JsonArray`, `JsonString`,
    and `JsonNumber`. Furthermore, a product that supports JSON-B must supply `MessageBodyReaders`
    and `Writers` for any object type when the media type is `application/json`, `text/json`,
    `*/json`, `or` `*/*+json`. Any product that implements the entire MicroProfile
    set of specifications will have JAX-RS, JSON-P, and JSON-B. This means that for
    the most part, you can count on your JAX-RS container to handle the conversion
    of JSON to objects and back to JSON.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们将这一点与 JAX-RS 相关联。JAX-RS 规范说明，支持 JSON-P 的产品必须为 `JsonStructure`、`JsonObject`、`JsonArray`、`JsonString`
    和 `JsonNumber` 实体类型提供 `MessageBodyReaders` 和 `MessageBodyWriters`。此外，支持 JSON-B
    的产品必须在媒体类型为 `application/json`、`text/json`、`*/json` 或 `*/*+json` 时为任何对象类型提供 `MessageBodyReaders`
    和 `Writers`。任何实现整个 MicroProfile 规范集的产品都将包含 JAX-RS、JSON-P 和 JSON-B。这意味着在大多数情况下，你可以依赖你的
    JAX-RS 容器来处理 JSON 到对象以及对象到 JSON 的转换。
- en: Now we've learned the easy way to work with JSON, let's learn how we can send
    requests and consume results using the client APIs.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经学会了轻松处理 JSON 的方法，让我们学习如何使用客户端 API 发送请求并消费结果。
- en: Consuming RESTful services with the MicroProfile Rest Client
  id: totrans-236
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 MicroProfile Rest Client 消费 RESTful 服务
- en: Thus far, we've covered how we can design elaborate RESTful services and how
    we can easily transform JSON into Java objects and vice versa. Next up, we need
    to consume those services using the client APIs. In a microservice architecture,
    RESTful clients are critical for invoking remote services.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经介绍了如何设计复杂的 RESTful 服务，以及如何轻松地将 JSON 转换为 Java 对象，反之亦然。接下来，我们需要使用客户端
    API 来消费这些服务。在微服务架构中，RESTful 客户端对于调用远程服务至关重要。
- en: JAX-RS Client APIs
  id: totrans-238
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: JAX-RS 客户端 API
- en: 'One way to consume RESTful services is with the **JAX-RS Client APIs**. Similar
    to JSON-P (as opposed to JSON-B), these APIs tend to be more programmatic with
    more control over individual options, such as headers, path construction, and
    so on. Let''s take a look at some code using the thesaurus example from earlier
    in this chapter, as follows:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 消费 RESTful 服务的一种方式是使用 **JAX-RS 客户端 API**。与 JSON-P（与 JSON-B 相反），这些 API 通常更程序化，对单个选项（如头部、路径构建等）有更多的控制。让我们看看一些使用本章前面提到的同义词例子的代码，如下所示：
- en: '[PRE51]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: The client instance is built using `ClientBuilder`. In this example, it simply
    builds a `Client` instance, but you could use `ClientBuilder` to set configuration
    properties or register client-side providers. `Client` instances should be explicitly
    closed when you are done using them—they currently do not implement the `AutoCloseable`
    interface, but a future version of the JAX-RS specification will add that, allowing
    `Client` instances to be closed in a try-with-resources block.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端实例是通过 `ClientBuilder` 构建的。在这个例子中，它只是构建了一个 `Client` 实例，但你也可以使用 `ClientBuilder`
    来设置配置属性或注册客户端提供者。`Client` 实例在使用完毕后应显式关闭——它们目前没有实现 `AutoCloseable` 接口，但 JAX-RS
    规范的未来版本将添加该接口，允许在 try-with-resources 块中关闭 `Client` 实例。
- en: '`WebTarget` represents the destination of the client request. It has methods
    for appending path elements, resolving path template variables, adding query or
    matrix parameters, or specifying the expected response media type. In the previous
    example, we append the `word` variable to the `uri` variable with this line of
    code:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: '`WebTarget` 表示客户端请求的目的地。它有用于附加路径元素、解析路径模板变量、添加查询或矩阵参数或指定预期响应媒体类型的方法。在先前的例子中，我们使用以下行代码将
    `word` 变量附加到 `uri` 变量：'
- en: '[PRE52]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Alternatively, we could change the `uri` variable to `http://localhost:9080/rest/thesaurus/{word}`,
    then we could use the following line of code:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，我们可以将 `uri` 变量更改为 `http://localhost:9080/rest/thesaurus/{word}`，然后我们可以使用以下行代码：
- en: '[PRE53]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Depending on the situation, either might be more usable.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 根据具体情况，两者可能都更易使用。
- en: An `Invocation.Builder` object is created by calling the `request(…)` method
    on the `WebTarget`—an optional media type parameter is used to determine what
    media type is expected for the response; it will set the `Accept` header. The
    `Invocation.Builder` object has methods such as `get(…)`, `post(…)`, `put(…)`,
    `delete(…)`, and other methods that represent the HTTP verb to use for the request.
    You can use the `method(…)` method to specify HTTP verbs that are not built into
    the API. It also has methods for setting cookies or headers.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在 `WebTarget` 上调用 `request(…)` 方法创建一个 `Invocation.Builder` 对象——一个可选的媒体类型参数用于确定期望的响应媒体类型；它将设置
    `Accept` 头。`Invocation.Builder` 对象具有 `get(…)`、`post(…)`、`put(…)`、`delete(…)` 以及其他表示请求中使用的
    HTTP 动词的方法。您可以使用 `method(…)` 方法指定 API 中未内置的 HTTP 动词。它还具有设置 cookie 或头的其他方法。
- en: The `Invocation.Builder` object also has `async()` and `rx()` methods that will
    return an asynchronous invoker and reactive invoker, respectively. These invokers
    enable users to retrieve the response asynchronously, which will generally improve
    performance.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: '`Invocation.Builder` 对象还具有 `async()` 和 `rx()` 方法，分别返回异步调用器和响应式调用器。这些调用器使用户能够异步检索响应，这通常可以提高性能。'
- en: The `Response` object represents the HTTP response from the remote server. From
    the `Response` object, you can check the status code of the response (`200`, `204`,
    `400`, `404`, `500`, and so on) and response headers, read the response entity,
    and more. Note that the `Response` object is `AutoCloseable`—it is always a good
    practice to close both `Response` and `Clientobjects`.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: '`Response` 对象代表来自远程服务器的 HTTP 响应。从 `Response` 对象中，您可以检查响应的状态码（如 `200`、`204`、`400`、`404`、`500`
    等）和响应头，读取响应实体，等等。请注意，`Response` 对象是 `AutoCloseable` 的——始终关闭 `Response` 和 `Client`
    对象是一个好习惯。'
- en: MicroProfile Rest Client
  id: totrans-250
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: MicroProfile Rest Client
- en: If the JAX-RS Client is similar to JSON-P, then the `@Path`, `@GET`, `@PUT`,
    `@POST`, `@DELETE`, and so on, annotations. The MicroProfile Rest Client implementation
    provides an instance of the interface, which you can then invoke in order to invoke
    the remote service.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 JAX-RS 客户端类似于 JSON-P，那么 `@Path`、`@GET`、`@PUT`、`@POST`、`@DELETE` 等注解。MicroProfile
    Rest Client 实现提供了一个接口实例，然后您可以通过调用该接口来调用远程服务。
- en: 'Let''s take a look at an example, as follows (the full source code is available
    at [https://github.com/PacktPublishing/Practical-Cloud-Native-Java-Development-with-MicroProfile/blob/main/Chapter04/src/main/java/com/packt/microprofile/book/ch4/client/ThesaurusClient.java](https://github.com/PacktPublishing/Practical-Cloud-Native-Java-Development-with-MicroProfile/blob/main/Chapter04/src/main/java/com/packt/microprofile/book/ch4/client/ThesaurusClient.java)):'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一个例子，如下（完整的源代码可在[https://github.com/PacktPublishing/Practical-Cloud-Native-Java-Development-with-MicroProfile/blob/main/Chapter04/src/main/java/com/packt/microprofile/book/ch4/client/ThesaurusClient.java](https://github.com/PacktPublishing/Practical-Cloud-Native-Java-Development-with-MicroProfile/blob/main/Chapter04/src/main/java/com/packt/microprofile/book/ch4/client/ThesaurusClient.java)找到）：
- en: '[PRE54]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'The methods here match the five resource methods in the `ThesaurusResource`
    class, with the exception that the `@PathParam` parameter is a method parameter.
    These methods all return a `String` object, but they could also return a `Response`
    object if it was important to view things in the response such as headers or status
    code, and so on. Usually, these things can be abstracted so that you can return
    the actual data type. This interface approach allows us to invoke the service
    by simply calling these methods. But first, we need to build an instance of this
    client. If we are in an environment that uses CDI (see the next section) and MicroProfile
    Config (see [*Chapter 5*](B17377_05_Final_SB_epub.xhtml#_idTextAnchor091), *Enhancing
    Cloud-Native Applications*), then the framework can automatically build and inject
    the client instance. Otherwise (or if you just want to build the instance programmatically),
    you can use the `RestClientBuilder` API, like so:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的方法与 `ThesaurusResource` 类中的五个资源方法相匹配，但 `@PathParam` 参数是一个方法参数。这些方法都返回一个 `String`
    对象，但它们也可以返回 `Response` 对象，如果查看响应中的内容（如头或状态码等）很重要的话。通常，这些内容可以被抽象出来，以便返回实际的数据类型。这种接口方法允许我们通过简单地调用这些方法来调用服务。但首先，我们需要构建这个客户端的一个实例。如果我们处于使用
    CDI（见下一节）和 MicroProfile Config（见[*第 5 章*](B17377_05_Final_SB_epub.xhtml#_idTextAnchor091)，*增强云原生应用程序*）的环境，那么框架可以自动构建和注入客户端实例。否则（或者如果您只想程序化地构建实例），您可以使用
    `RestClientBuilder` API，如下所示：
- en: '[PRE55]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'This sets `baseUri`, the URI path up to the point where the `@Path` annotation
    is added. Similar to the JAX-RS `ClientBuilder` API, we could also use the `RestClientBuilder`
    API to specify properties for the client instance or register providers. Once
    we''ve built the client instance, we can invoke it like so:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 这设置了`baseUri`，即添加`@Path`注解之前的URI路径。类似于JAX-RS `ClientBuilder` API，我们也可以使用`RestClientBuilder`
    API来指定客户端实例的属性或注册提供者。一旦我们构建了客户端实例，我们就可以这样调用它：
- en: '[PRE56]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Client-side providers
  id: totrans-258
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 客户端提供者
- en: 'That''s a nice way to invoke the service—a lot less code and it reads easier
    too! You might be thinking: *That method throws an exception—how does the implementation
    know when it should throw it?* Excellent question! The answer is `ResponseExceptionMapper`.
    It is basically the converse of JAX-RS `ExceptionMapper`—instead of mapping an
    exception to a response, they map a response to an exception. By default, MicroProfile
    Rest Client implementations will throw a `WebApplicationException` on any response
    with a status code of `400` or higher— those codes are client errors or server
    errors. To map more specific responses to exceptions, you would need to register
    one or more `ResponseExceptionMapper`, such as the following:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一种调用服务的好方法——代码更少，阅读起来也更简单！你可能正在想：*那个方法会抛出异常——实现如何知道何时抛出它呢？* 这是一个很好的问题！答案是`ResponseExceptionMapper`。它基本上是JAX-RS
    `ExceptionMapper`的逆过程——不是将异常映射到响应，而是将响应映射到异常。默认情况下，MicroProfile Rest Client实现将在任何状态码为`400`或更高的响应上抛出`WebApplicationException`——这些代码是客户端错误或服务器错误。要将更具体的响应映射到异常，你需要注册一个或多个`ResponseExceptionMapper`，如下所示：
- en: '[PRE57]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: This response exception mapper implements two methods. The first, `handles(…)`,
    is used to inform the client implementation of whether it should use this mapper
    for the current response. If it returns `true`, then the client implementation
    will invoke the `toThrowable(…)` method to obtain the exception it should throw.
    If the `handles(…)` method returns `false`, then the client implementation will
    check any other registered response exception mappers before assuming that the
    response was successful and simply returning a valid value to the client caller
    rather than throwing an exception.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 此响应异常映射器实现了两种方法。第一种，`handles(…)`, 用于通知客户端实现是否应该使用此映射器处理当前响应。如果它返回`true`，则客户端实现将调用`toThrowable(…)`方法来获取它应该抛出的异常。如果`handles(…)`方法返回`false`，则客户端实现将在假定响应成功并简单地返回一个有效值给客户端调用者而不是抛出异常之前检查任何其他已注册的响应异常映射器。
- en: Special note
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 特别注意
- en: The `toThrowable(…)` method should *return* the exception, not throw it. The
    client implementation will actually throw the exception; it just needs to know
    which exception to throw.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: '`toThrowable(…)`方法应该*返回*异常，而不是抛出它。客户端实现实际上会抛出异常；它只需要知道应该抛出哪个异常。'
- en: 'As with server-side providers, client-side providers need to be registered.
    There are two ways to register client providers. First, you can register them
    from the `RestClientBuilder` API before building the client, as illustrated in
    the following code snippet:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 与服务器端提供者一样，客户端提供者需要被注册。有两种方式可以注册客户端提供者。首先，你可以在构建客户端之前从`RestClientBuilder` API注册它们，如下面的代码片段所示：
- en: '[PRE58]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'A second way to register a client provider is to use one or more `@RegisterProvider`
    annotations on the client interface, like this:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 注册客户端提供者的第二种方式是在客户端接口上使用一个或多个`@RegisterProvider`注解，如下所示：
- en: '[PRE59]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: You can register as many of the same types of providers on the client side as
    you would on the server, including `MessageBodyReader` and `Writer`, `Reader`,
    and `WriterInterceptors`. You may not register `ExceptionMappers` or server-side
    filters (`ContainerRequestFilter` or `ContainerResponseFilter`). You may, however,
    register client-side filters (`ClientRequestFilter` or `ClientResponseFilter`)—they
    work in much the same way as server-side filters.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在客户端注册与服务器端相同类型的提供者，包括`MessageBodyReader`和`Writer`、`Reader`和`WriterInterceptors`。你无法注册`ExceptionMappers`或服务器端过滤器（`ContainerRequestFilter`或`ContainerResponseFilter`）。然而，你可以注册客户端过滤器（`ClientRequestFilter`或`ClientResponseFilter`）——它们与服务器端过滤器的工作方式非常相似。
- en: Tip
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士
- en: The `ClientRequestFilter` filter's `ClientRequestContext` has an `abortWith(Response)`
    method similar to the `ContainerRequestFilter` filter. This method can be useful
    in test code for mocking different server responses.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: '`ClientRequestFilter`过滤器的`ClientRequestContext`有一个类似于`ContainerRequestFilter`过滤器的`abortWith(Response)`方法。这个方法在测试代码中模拟不同的服务器响应时非常有用。'
- en: All of these client-side providers will work with either client, the JAX-RS
    Client and the MicroProfile Rest Client, except for `ResponseExceptionMapper`—these
    will only work with the MicroProfile Rest Client.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些客户端提供程序都将与 JAX-RS 客户端和 MicroProfile Rest 客户端一起工作，除了`ResponseExceptionMapper`——这些只与
    MicroProfile Rest 客户端一起工作。
- en: Async
  id: totrans-272
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 异步
- en: Both JAX-RS Client and the MicroProfile Rest Client are capable of invoking
    services asynchronously. This is perhaps even more powerful on the client than
    on the server, as a client will often run in resource-constrained environments
    and may be called upon to perform multiple requests in order to achieve its goal.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: JAX-RS 客户端和 MicroProfile Rest 客户端都能够异步调用服务。这可能对客户端来说甚至更强大，因为客户端通常在资源受限的环境中运行，并且可能需要执行多个请求以实现其目标。
- en: 'The JAX-RS Client invokes services asynchronously by creating an `AsyncInvoker`
    instance that will produce `java.util.concurrent.Future` objects that reference
    the response objects or allow the user to specify an `InvocationCallback` that
    is notified when the response is available (or if there was an exception during
    the request/response). Here is an example of the `Future` approach:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: JAX-RS 客户端通过创建一个将产生引用响应对象的`java.util.concurrent.Future`对象的`AsyncInvoker`实例来异步调用服务。这允许用户指定一个当响应可用（或在请求/响应过程中发生异常时）被通知的`InvocationCallback`。以下是一个`Future`方法的示例：
- en: '[PRE60]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'This code looks very similar to the synchronous code from earlier in this section
    and makes for a very simple way to perform asynchronous client requests. Next,
    let''s see how we would use `InvocationCallbacks`, as follows (the full source
    code for this and the `Future` approach is available at [https://github.com/PacktPublishing/Practical-Cloud-Native-Java-Development-with-MicroProfile/blob/main/Chapter04/src/main/java/com/packt/microprofile/book/ch4/client/JAXRSClient.java](https://github.com/PacktPublishing/Practical-Cloud-Native-Java-Development-with-MicroProfile/blob/main/Chapter04/src/main/java/com/packt/microprofile/book/ch4/client/JAXRSClient.java)):'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码看起来与本章早些时候的同步代码非常相似，提供了一种执行异步客户端请求的简单方法。接下来，让我们看看如何使用`InvocationCallbacks`，如下所示（此方法和`Future`方法的完整源代码可在[https://github.com/PacktPublishing/Practical-Cloud-Native-Java-Development-with-MicroProfile/blob/main/Chapter04/src/main/java/com/packt/microprofile/book/ch4/client/JAXRSClient.java](https://github.com/PacktPublishing/Practical-Cloud-Native-Java-Development-with-MicroProfile/blob/main/Chapter04/src/main/java/com/packt/microprofile/book/ch4/client/JAXRSClient.java)找到）：
- en: '[PRE61]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: This example shows how you might look up multiple words. It sends multiple requests
    in parallel to the server, and the `completed` method of `InvocationCallback`
    is invoked when the response is available.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子展示了如何查找多个单词。它向服务器并行发送多个请求，当响应可用时，会调用`InvocationCallback`的`completed`方法。
- en: 'Asynchronous requests in the MicroProfile Rest Client are slightly different.
    The client interface methods must return `CompletionStage` that wraps the intended
    return type. So, we would modify our client interface to look like this (the full
    source code is available at [https://github.com/PacktPublishing/Practical-Cloud-Native-Java-Development-with-MicroProfile/blob/main/Chapter04/src/main/java/com/packt/microprofile/book/ch4/client/ThesaurusAsyncClient.java](https://github.com/PacktPublishing/Practical-Cloud-Native-Java-Development-with-MicroProfile/blob/main/Chapter04/src/main/java/com/packt/microprofile/book/ch4/client/ThesaurusAsyncClient.java)):'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: MicroProfile Rest 客户端的异步请求略有不同。客户端接口方法必须返回包装了预期返回类型的`CompletionStage`。因此，我们将修改我们的客户端接口，如下所示（完整源代码可在[https://github.com/PacktPublishing/Practical-Cloud-Native-Java-Development-with-MicroProfile/blob/main/Chapter04/src/main/java/com/packt/microprofile/book/ch4/client/ThesaurusAsyncClient.java](https://github.com/PacktPublishing/Practical-Cloud-Native-Java-Development-with-MicroProfile/blob/main/Chapter04/src/main/java/com/packt/microprofile/book/ch4/client/ThesaurusAsyncClient.java)找到）：
- en: '[PRE62]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Notice that none of these methods declare that they throw any exceptions. That
    is because any exception processing occurs after the processing of the returned
    `CompletionStage`. This is how we might invoke this client:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这些方法中没有任何一个声明会抛出任何异常。这是因为任何异常处理都是在返回的`CompletionStage`处理之后发生的。这就是我们可能调用此客户端的方式：
- en: '[PRE63]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: Like the JAX-RS Client callback example, this example looks up the synonyms
    for multiple words simultaneously. By using `CompletionStage`, we can easily handle
    exceptions or perform additional processing inline.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 与 JAX-RS 客户端回调示例类似，此示例同时查找多个单词的同义词。通过使用`CompletionStage`，我们可以轻松处理异常或执行额外的内联处理。
- en: Remember another form of asynchronous operations is SSEs. The JAX-RS Client
    APIs allow you to receive events in the form of `InboundSseEvent` objects. The
    MicroProfile Rest Client goes a step further and allows you to receive events
    using `Publisher` objects. The events can be `InboundSseEvent` objects that allow
    you to read extra metadata on each event or as a specific Java type, so long as
    you have `MessageBodyReader` to convert the event into that type.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 记住另一种异步操作的形式是 SSEs。JAX-RS 客户端 API 允许你以 `InboundSseEvent` 对象的形式接收事件。MicroProfile
    Rest Client 进一步允许你使用 `Publisher` 对象接收事件。事件可以是允许你在每个事件上读取额外元数据的 `InboundSseEvent`
    对象，或者是一个特定的 Java 类型，只要你有 `MessageBodyReader` 将事件转换为该类型。
- en: 'If we want to consume the SSE events from the service we wrote at the end of
    the *Building a RESTful Service with Jakarta REST* section, we might write a client
    interface that looks something like this:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想消费在“使用 Jakarta REST 构建RESTful服务”部分末尾编写的服务的 SSE 事件，我们可能会编写一个看起来像这样的客户端接口：
- en: '[PRE64]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'The client interface is simple enough, right? So, this is how you might use
    it (the full source code is available at [https://github.com/PacktPublishing/Practical-Cloud-Native-Java-Development-with-MicroProfile/blob/main/Chapter04/src/main/java/com/packt/microprofile/book/ch4/async/MPSseConsumerResource.java](https://github.com/PacktPublishing/Practical-Cloud-Native-Java-Development-with-MicroProfile/blob/main/Chapter04/src/main/java/com/packt/microprofile/book/ch4/async/MPSseConsumerResource.java)):'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端接口很简单，对吧？所以，这就是你可能使用它的方法（完整的源代码可在 [https://github.com/PacktPublishing/Practical-Cloud-Native-Java-Development-with-MicroProfile/blob/main/Chapter04/src/main/java/com/packt/microprofile/book/ch4/async/MPSseConsumerResource.java](https://github.com/PacktPublishing/Practical-Cloud-Native-Java-Development-with-MicroProfile/blob/main/Chapter04/src/main/java/com/packt/microprofile/book/ch4/async/MPSseConsumerResource.java)
    找到）：
- en: '[PRE65]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: Once the `Publisher` is returned from the client interface, a caller can subscribe
    to it and control the flow of the SSEs via the `request(int)` method of `Subscription`.
    The `onNext` callback method is invoked for each new event (so long as it has
    been requested). The `onError` callback is invoked when an error occurs (for example,
    not being able to find a `MessageBodyReader` that can deserialize the event).
    The `onComplete` callback is invoked when the connection with the server has been
    closed.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦从客户端接口返回 `Publisher`，调用者可以订阅它，并通过 `Subscription` 的 `request(int)` 方法控制 SSEs
    的流动。对于每个新事件（只要它已被请求），都会调用 `onNext` 回调方法。当发生错误时（例如，找不到可以反序列化事件的 `MessageBodyReader`），会调用
    `onError` 回调。当与服务器的连接关闭时，会调用 `onComplete` 回调。
- en: Propagating HTTP headers from server to client
  id: totrans-290
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从服务器到客户端传播 HTTP 头部
- en: 'Quite often, you may need to construct a RESTful service that needs to consume
    other RESTful services. This might be part of a gateway or delegation pattern,
    or it may be that your service needs to aggregate other services such as the following
    service, where a vacation service may need to make reservations for airlines,
    hotels, entertainment venues, and so on:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 很常见的情况是，你可能需要构建一个需要消费其他 RESTful 服务的 RESTful 服务。这可能是网关或委托模式的一部分，或者可能是你的服务需要聚合其他服务，例如以下服务，其中休假服务可能需要为航空公司、酒店、娱乐场所等预订：
- en: '![Figure 4.2 – Aggregating service'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 4.2 – 服务聚合'
- en: '](img/Figure_4.2_-_B17377.jpg)'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_4.2_-_B17377.jpg)'
- en: Figure 4.2 – Aggregating service
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.2 – 服务聚合
- en: In these situations, it is often useful to propagate headers from the original
    request to the delegated requests. For example, suppose you want to reuse the
    authentication credentials sent on the original request when making the subsequent
    requests; the MicroProfile Rest Client has some built-in mechanisms that make
    this easy to do.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些情况下，从原始请求传播头部到委托请求通常很有用。例如，假设你想要在后续请求中重用原始请求上发送的认证凭据；MicroProfile Rest Client
    有一些内置机制使得这变得容易实现。
- en: 'First, you must annotate your client interface with `@RegisterClientHeaders`
    and then specify a comma-separated list of headers that the container should automatically
    propagate in a MicroProfile Config property, like so:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你必须使用 `@RegisterClientHeaders` 注解你的客户端接口，然后指定一个以逗号分隔的头部列表，该列表应该由容器自动传播到一个
    MicroProfile Config 属性中，如下所示：
- en: '[PRE66]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Next, you can specify headers declaratively in the client interface, like this:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你可以在客户端接口中声明性地指定头部，如下所示：
- en: '[PRE67]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: In this code, the `AgentID` header with the hardcoded value `Bob's Travel Co.`
    would be sent on every request from this client since the `@ClientHeaderParam`
    annotation is applied to the interface. When the `makeReservation` method is invoked,
    the MicroProfile Rest Client implementation will invoke the `newId` method to
    obtain the value of the `RequestID` header—the value of the header is the return
    value of a method because the annotation value is surrounded by curly braces.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 在此代码中，带有硬编码值 `Bob's Travel Co.` 的 `AgentID` 标头将随着每个请求从该客户端发送，因为接口上应用了 `@ClientHeaderParam`
    注解。当调用 `makeReservation` 方法时，MicroProfile Rest Client 实现将调用 `newId` 方法以获取 `RequestID`
    标头的值——标头的值是方法的返回值，因为注解值被大括号包围。
- en: Both of these approaches allow headers to be sent without needing to modify
    the signature of the client interface method.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 这两种方法都允许发送标头而无需修改客户端接口方法的签名。
- en: Managing life cycle and DI with CDI
  id: totrans-302
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 CDI 管理生命周期和 DI
- en: By default, JAX-RS resources are created for each request. While this might
    be useful in some cases, it would be far more efficient if they were singletons.
    That way, we wouldn't be creating new object instances (an expensive operation)
    for each request, and we wouldn't be generating excess garbage after the request
    is completed.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，JAX-RS 资源为每个请求创建。虽然这在某些情况下可能很有用，但如果它们是单例的，效率会更高。这样，我们就不会为每个请求创建新的对象实例（这是一个昂贵的操作），也不会在请求完成后产生多余的垃圾。
- en: While we could create an `Application` subclass that returns the resources via
    the `getSingletons()` method, that would prevent the container from automatically
    discovering and registering resources and providers. Another reason to avoid that
    approach is that the `getSingletons()` method is deprecated in a future version
    of JAX-RS and will eventually be removed.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们可以创建一个返回资源的 `Application` 子类，通过 `getSingletons()` 方法，但这将阻止容器自动发现和注册资源及提供者。避免这种方法的另一个原因是
    `getSingletons()` 方法在 JAX-RS 的未来版本中已被弃用，并最终将被移除。
- en: Instead, we can use **Context and Dependency Injection** (**CDI**). CDI uses
    annotations to allow developers to declaratively manage object life cycles and
    perform injections of fields, constructors, and setter methods.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，我们可以使用 **上下文和依赖注入**（**CDI**）。CDI 使用注解允许开发者声明式地管理对象生命周期并执行字段、构造函数和设置方法的注入。
- en: Scopes
  id: totrans-306
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 范围
- en: CDI has several built-in `@ApplicationScoped`, `@RequestScoped`, and `@Dependent`.
    As you can probably guess, an object annotated with `@ApplicationScoped` will
    *live* for the lifetime of the application, while an object annotated with `@RequestScoped`
    will only live for the lifetime of a single request.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: CDI 包含几个内置的注解 `@ApplicationScoped`、`@RequestScoped` 和 `@Dependent`。正如你可能猜到的，被
    `@ApplicationScoped` 注解的对象将 *存活* 在应用程序的生命周期内，而被 `@RequestScoped` 注解的对象则只会在单个请求的生命周期内存活。
- en: The `@Dependent` annotation is a little special. Basically, objects annotated
    with it will inherit the scope of the object it is injected into. In the case
    of JAX-RS resource classes that are not really injected into anything, it inherits
    the scope of the JAX-RS container. For resource objects, that is **per request**,
    but for provider objects, that is **per application**.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: '`@Dependent` 注解有点特殊。基本上，被这个注解注解的对象将继承它被注入的对象的作用域。对于实际上没有注入任何东西的 JAX-RS 资源类，它继承
    JAX-RS 容器的作用域。对于资源对象，这是 **每个请求**，但对于提供者对象，这是 **每个应用程序**。'
- en: This means that we can annotate our JAX-RS resource classes with `@ApplicationScoped`
    and then we can get rid of those pesky static fields and just use normal instance
    fields.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着我们可以用 `@ApplicationScoped` 注解我们的 JAX-RS 资源类，然后我们可以摆脱那些讨厌的静态字段，只使用正常的实例字段。
- en: Injection
  id: totrans-310
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 注入
- en: DI is another powerful piece of CDI. Using annotations, you can specify your
    dependencies and let the container handle all of the wiring. In the most basic
    cases where you want to inject a class or an instance of an interface where there
    is only one managed bean implementation of that interface, you can use `@Inject`,
    and CDI does the rest.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: DI 是 CDI 的另一个强大功能。使用注解，你可以指定你的依赖关系，并让容器处理所有的连接。在最基本的案例中，如果你想注入一个类或接口的一个实例，其中只有一个管理
    Bean 实现该接口，你可以使用 `@Inject`，CDI 会完成其余的工作。
- en: 'Let''s take a look at an example. Suppose we have a class like this that we
    want to inject (the full source code for all CDI examples can be found at [https://github.com/PacktPublishing/Practical-Cloud-Native-Java-Development-with-MicroProfile/tree/main/Chapter04/src/main/java/com/packt/microprofile/book/ch4/cdi](https://github.com/PacktPublishing/Practical-Cloud-Native-Java-Development-with-MicroProfile/tree/main/Chapter04/src/main/java/com/packt/microprofile/book/ch4/cdi)):'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一个例子。假设我们有一个类，如下所示，我们想要注入（所有 CDI 示例的完整源代码可以在 [https://github.com/PacktPublishing/Practical-Cloud-Native-Java-Development-with-MicroProfile/tree/main/Chapter04/src/main/java/com/packt/microprofile/book/ch4/cdi](https://github.com/PacktPublishing/Practical-Cloud-Native-Java-Development-with-MicroProfile/tree/main/Chapter04/src/main/java/com/packt/microprofile/book/ch4/cdi)
    找到）：
- en: '[PRE68]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'We have a request-scoped bean that, when instantiated, will have a unique instance
    ID. Now, let''s say that we want to inject it into a JAX-RS resource class that
    is managed by CDI, but we want the resource class to be application-scoped for
    better performance. It might look like this:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一个请求作用域的 Bean，当实例化时，将有一个唯一的实例 ID。现在，假设我们想要将其注入到一个由 CDI 管理的 JAX-RS 资源类中，但我们希望资源类是应用程序作用域的，以获得更好的性能。它可能看起来像这样：
- en: '[PRE69]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'This object, `MyCdiResource`, will only be instantiated once for the lifetime
    of the application, with no extra object creation or excess garbage. But the `MyDependency`
    object that is injected is `GET` method that returns the dependency instance ID,
    as the dependency''s instance ID increments on each request, as illustrated here:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 这个对象，`MyCdiResource`，在整个应用程序的生命周期中只会实例化一次，没有额外的对象创建或多余的垃圾。但是注入的 `MyDependency`
    对象是一个返回依赖实例 ID 的 `GET` 方法，因为依赖的实例 ID 在每次请求时都会增加，如图所示：
- en: '[PRE70]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'There may be times where you want to create your own bean that is injected.
    CDI provides a mechanism where you would use the `@Produces` annotation (same
    name but different package as the JAX-RS `@Produces` annotation for specifying
    media types). To use this, you would apply this annotation to a method on a CDI-managed
    bean; the object returned by that method will be injected appropriately. Let''s
    see how this would look in a code example, as follows:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，你可能想要创建自己的注入 Bean。CDI 提供了一种机制，你可以使用 `@Produces` 注解（与 JAX-RS 的 `@Produces`
    注解同名但不同包，用于指定媒体类型）。要使用这个注解，你需要在 CDI 管理的 Bean 上的一个方法上应用这个注解；该方法返回的对象将被适当地注入。让我们看看在代码示例中这会是什么样子，如下所示：
- en: '[PRE71]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: And in this case, since the `MyCdiResource` class is annotated with `@ApplicationScoped`,
    the `MyProducedDependency` object is only built and injected once for the lifetime
    of the application. If we were to change `MyCdiResource` to be `@RequestScoped`,
    then the random number would change for each request. The `producer` method is
    invoked when needed by the *consuming* bean.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，由于 `MyCdiResource` 类被注解为 `@ApplicationScoped`，`MyProducedDependency`
    对象在整个应用程序的生命周期中只构建和注入一次。如果我们把 `MyCdiResource` 改为 `@RequestScoped`，那么随机数会随着每个请求而改变。`producer`
    方法在需要时由 *消费* Bean 调用。
- en: So, what happens if you have more than one possible bean to inject? Your application
    may fail to start with a `DeploymentException` exception, indicating ambiguous
    dependencies. To resolve this, you can either use the `@Named` annotation or *qualifier*
    annotations.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，如果你有多个可能的 Bean 可以注入，会发生什么？你的应用程序可能会因为 `DeploymentException` 异常而无法启动，这表明存在模糊的依赖关系。为了解决这个问题，你可以使用
    `@Named` 注解或 *限定符* 注解。
- en: 'The `@Named` annotation may look something like this:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: '`@Named` 注解可能看起来像这样：'
- en: '[PRE72]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: The `@Named` annotation with the same value, `max`, is applied to both the implementation
    class *and* the injection point.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 值相同的 `@Named` 注解应用于实现类 *和* 注入点。
- en: 'Qualifiers are a little more complex but add more flexibility. It first involves
    the creation of a new annotation, like this:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 限定符稍微复杂一些，但提供了更多的灵活性。它首先涉及到创建一个新的注解，如下所示：
- en: '[PRE73]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'Then, we just add that annotation on both the class and injection target, like
    so:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们只需在类和注入目标上添加这个注解，如下所示：
- en: '[PRE74]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'Qualifiers can be used more extensively in other CDI artifacts such as interceptors
    and portable extensions. One such extension is built into the MicroProfile Rest
    Client implementation, which allows client instances to be built and injected
    into your CDI beans. It uses the `@RestClient` qualifier. For this to work, you
    would need to add the `@RegisterRestClient` annotation to the client interface.
    With this annotation, you can also specify the `baseUri` path. Alternatively,
    you could use MicroProfile Config to specify the `baseUri` path and other configuration
    options for the client instance. Here''s what it might look like:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 在其他 CDI 艺术品（如拦截器和可移植扩展）中可以更广泛地使用限定符。其中一个扩展内置在 MicroProfile Rest Client 实现中，它允许构建客户端实例并将其注入到您的
    CDI 容器中。它使用 `@RestClient` 限定符。为了使其工作，您需要将 `@RegisterRestClient` 注解添加到客户端接口上。使用此注解，您还可以指定
    `baseUri` 路径。或者，您可以使用 MicroProfile Config 来指定客户端实例的 `baseUri` 路径和其他配置选项。下面是一个示例：
- en: '[PRE75]'
  id: totrans-330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'Then, we could inject the client instance and use it like so:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以注入客户端实例并像这样使用它：
- en: '[PRE76]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: While it might seem silly to create a RESTful service that then uses a client
    to access a different RESTful service in the same application, the principle is
    very common for microservice architecture. This service could be a gateway for
    the real thesaurus service, or perhaps the complete thesaurus is split across
    several **virtual machines** (**VMs**). The ability to provide or consume RESTful
    services where those services' life cycles and dependencies are managed declaratively
    can be very powerful indeed.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然创建一个 RESTful 服务然后使用客户端访问同一应用程序中的另一个 RESTful 服务可能看起来很愚蠢，但这个原则对于微服务架构来说非常常见。这个服务可能是真实同义词服务的网关，或者完整的同义词可能分布在几个
    **虚拟机**（**VMs**）上。提供或消费那些服务生命周期和依赖关系声明式管理的 RESTful 服务的能力确实非常强大。
- en: Summary
  id: totrans-334
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we've learned how to create and consume basic and complex RESTful
    services using industry-standard APIs such as JAX-RS, CDI, JSON-P, JSON-B, and
    the MicroProfile Rest Client. We've learned that some of these APIs provide very
    concise and type-safe approaches, while others provide additional flexibility
    at the cost of increased code complexity. Having completed this chapter, we can
    now create fully functioning micro-services utilizing REST and JSON. We can also
    improve the efficiency of these services by using asynchronous clients and appropriate
    life-cycle scopes.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了如何使用行业标准 API（如 JAX-RS、CDI、JSON-P、JSON-B 和 MicroProfile Rest Client）创建和消费基本和复杂的
    RESTful 服务。我们了解到，其中一些 API 提供了非常简洁和类型安全的途径，而其他 API 则以增加代码复杂性的代价提供了额外的灵活性。完成本章后，我们现在可以创建利用
    REST 和 JSON 的完整功能的微服务。我们还可以通过使用异步客户端和适当的生命周期范围来提高这些服务的效率。
- en: In the next chapter, we will explore how we can improve the configurability
    and robustness of these services with other MicroProfile APIs.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨如何通过其他 MicroProfile API 来提高这些服务的可配置性和鲁棒性。
