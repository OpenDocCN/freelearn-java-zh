- en: Chapter 10.  Reactors
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第10章。反应器
- en: '|   | *"Simplicity is prerequisite for reliability."* |   |'
  id: totrans-1
  prefs: []
  type: TYPE_TB
  zh: '|   | *"简单是可靠性的前提。" |   |'
- en: '|   | --*Edsger W. Dijkstra* |'
  id: totrans-2
  prefs: []
  type: TYPE_TB
  zh: '|   | --*埃德加·W·迪杰斯特拉* |'
- en: Location-transparency, serializable event-handling, and non-blocking semantics
    of sends, make the actor model a powerful foundation for building distributed
    systems. However, the actor model has several important limitations, which only
    become apparent when building larger systems. First, actors cannot simultaneously
    contain multiple message entry points. All messages must arrive through the same
    `receive` block. Consequently, two different protocols cannot reuse the same message
    type, and must be aware of each other. The main example where we saw this was
    the `Identify` message, which required users to incorporate a unique token into
    the message. Second, actors cannot await specific combinations of messages. For
    example, it is cumbersome to simultaneously send a request message to two target
    actors, and proceed after both replies arrive. Third, the `receive` statement
    is not a first-class citizen. Event streams, which we saw in the Rx framework,
    are first-class citizens, and this improves program composition, modularity, and
    separation of concerns.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 位置透明性、可序列化的事件处理以及发送的非阻塞语义，使得actor模型成为构建分布式系统的强大基础。然而，actor模型有几个重要的限制，这些限制只有在构建更大的系统时才会变得明显。首先，actor不能同时包含多个消息入口点。所有消息都必须通过同一个`receive`块到达。因此，两个不同的协议不能重用相同的消息类型，并且必须相互了解。我们看到的这个主要例子是`Identify`消息，它要求用户将一个唯一的令牌纳入消息中。其次，actor不能等待特定的消息组合。例如，同时向两个目标actor发送请求消息并在两个回复到达后继续操作是很繁琐的。第三，`receive`语句不是一等公民。我们在Rx框架中看到的事件流是一等公民，这提高了程序组合、模块化和关注点分离。
- en: In this chapter, we study the reactor programming model for distributed computing,
    which retains the advantages of the actor model, but overcomes the above limitations.
    This framework allows creating complex concurrent and distributed applications
    more easily, by providing correct, robust, and composable abstractions for distributed
    programming. Similar to the actor model, the reactor model allows writing location-transparent
    programs. Clear separation between units of concurrency is achieved through special
    entities called reactors. This separation makes it easier to reason about concurrent
    programs, as was the case with actors. However, computations and message exchange
    patterns can be more easily subdivided into modular components in the reactor
    model. The improved composition at the core of the reactor model is the result
    of a careful integration of the traditional actor model and functional reactive
    programming concepts.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们研究分布式计算的reactor编程模型，该模型保留了actor模型的优势，但克服了上述限制。这个框架通过为分布式编程提供正确、健壮和可组合的抽象，使得创建复杂并发和分布式应用变得更加容易。与actor模型类似，reactor模型允许编写位置透明的程序。通过称为reactor的特殊实体实现了并发单元之间的清晰分离。这种分离使得推理并发程序变得更加容易，正如actor模型中的情况一样。然而，在reactor模型中，计算和消息交换模式可以更容易地细分为模块化组件。reactor模型核心的改进组合是传统actor模型和函数式响应式编程概念的谨慎整合的结果。
- en: 'We use the Reactors framework throughout this chapter to learn about the reactor
    programming model. We will cover the following topics:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在本章中使用Reactors框架来了解reactor编程模型。我们将涵盖以下主题：
- en: Utilizing and composing event-streams to structure logic within a reactor
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 利用和组合事件流来在reactor中构建逻辑
- en: Defining reactors and starting reactor instances
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义reactor和启动reactor实例
- en: Customizing reactor instances and using custom schedulers
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自定义reactor实例和使用自定义调度器
- en: Using reactor system services to access non-standard events, and defining custom
    services
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用reactor系统服务访问非标准事件，并定义自定义服务
- en: The basics of protocol composition, along with several concrete protocol examples
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 协议组合的基本原理，以及几个具体的协议示例
- en: We start by recounting what we learned about concurrent and distributed programming,
    and explaining why the reactor model is important.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先回顾我们关于并发和分布式编程的知识，并解释为什么reactor模型很重要。
- en: The need for reactors
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 对reactor的需求
- en: 'As you may have concluded by reading this book, writing concurrent and distributed
    programs is not easy. Ensuring program correctness, scalability, and fault-tolerance
    is harder than in a sequential program. Here, we recall some of the reasons for
    this:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 通过阅读本书，你可能已经得出结论，编写并发和分布式程序并不容易。确保程序的正确性、可扩展性和容错性比在顺序程序中更难。在这里，我们回顾一下造成这种情况的一些原因：
- en: First of all, most concurrent and distributed computations are, by their nature,
    non-deterministic. This non-determinism is not a consequence of poor programming
    abstractions, but is inherent in systems that need to react to external events.
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，大多数并发和分布式计算在本质上是非确定性的。这种非确定性并非由于编程抽象不良的结果，而是需要对外部事件做出反应的系统固有的。
- en: Data races are a basic characteristic of most shared-memory multicore systems.
    Combined with inherent non-determinism, these lead to subtle bugs that are hard
    to detect or reproduce.
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据竞争是大多数共享内存多核系统的一个基本特征。结合固有的非确定性，这些会导致难以检测或重现的微妙错误。
- en: When it comes to distributed computing, things get even more complicated. Random
    faults, network outages, or interruptions, present in distributed programming,
    compromise correctness and robustness of distributed systems.
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当涉及到分布式计算时，事情变得更加复杂。随机故障、网络中断或中断，这些在分布式编程中普遍存在，会损害分布式系统的正确性和鲁棒性。
- en: Furthermore, shared-memory programs do not work in distributed environments,
    and existing shared-memory programs are not easily ported to a distributed setup.
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 此外，共享内存程序在分布式环境中无法工作，现有的共享内存程序也不容易移植到分布式设置中。
- en: There is one more reason why concurrent and distributed programming is hard.
    When building large systems, we would like to compose simpler program components
    into larger entities. However, it is often hard to correctly compose concurrent
    and distributed programs. Correctness of specific components is no guarantee for
    global program correctness when those components are used together. Deadlocks
    inherent to locks are one such example, and potential race conditions in actors
    are another.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个使并发和分布式编程变得困难的原因是，当构建大型系统时，我们希望将简单的程序组件组合成更大的实体。然而，正确组合并发和分布式程序往往很困难。当这些组件一起使用时，特定组件的正确性并不能保证全局程序的正确性。锁固有的死锁就是一个例子，actor中潜在的竞争条件是另一个。
- en: Frameworks that we have seen in this book strive to address the aforementioned
    problems in concurrent and distributed programming. Different concurrency models
    try to address these issues from different angles. The intent of the reactor model,
    described in this chapter, is to borrow some of the best characteristics of existing
    frameworks, such as location-transparency, serializability and data-race freedom,
    and especially address the issue of composability.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 本书中所提到的框架努力解决上述并发和分布式编程中的问题。不同的并发模型试图从不同的角度解决这些问题。本章所描述的反应器模型的目的是借鉴现有框架的一些最佳特性，例如位置透明性、可串行性和数据竞争自由，特别是解决可组合性问题。
- en: 'To achieve these goals, the reactor model employs several minimalist abstractions,
    which can compose into complex protocols, algorithms, and program components.
    In particular, the model is based on the following:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这些目标，反应器模型采用了几种最小化抽象，这些抽象可以组合成复杂的协议、算法和程序组件。特别是，该模型基于以下内容：
- en: Location-transparent **reactors**, lightweight entities that execute concurrently
    with each other, but are internally always single-threaded, and can be ported
    from a single machine to a distributed setting. Every reactor is created with
    one main event stream. A reactor is a generalization of an actor from the traditional
    actor model.
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 位置透明的**反应器**，轻量级实体，可以与其他反应器并发执行，但内部始终是单线程的，并且可以从单机环境移植到分布式环境。每个反应器都创建了一个主要事件流。反应器是传统actor模型中actor的泛化。
- en: Asynchronous first-class **event streams** that can be reasoned about in a declarative,
    functional manner, and are the basis for composing components. An event stream
    is the reading end of a channel. Only the reactor that owns the channel can read
    from the corresponding event stream. Event streams cannot be shared between different
    reactors. To borrow the analogy from the actor model, an event stream is a counterpart
    of the `receive` statement.
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以以声明式、函数式方式推理的异步一等**事件流**，是组件组合的基础。事件流是通道的读取端。只有拥有该通道的反应器才能从对应的事件流中读取。事件流不能在不同反应器之间共享。借用actor模型的类比，事件流是`receive`语句的对等物。
- en: '**Channels** that can be shared between reactors, and are used to send events
    asynchronously. A channel is the writing end of the corresponding event stream,
    and any number of reactors can write to a channel. A channel is a close equivalent
    of the actor reference that we saw in the actor model.'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**通道**可以在反应器之间共享，并用于异步发送事件。通道是对应事件流的写入端，任何数量的反应器都可以向通道写入。通道与我们在actor模型中看到的actor引用非常相似。'
- en: These three unique abstractions are the core prerequisite for building powerful
    distributed computing abstractions. Most other utilities in the Reactors framework,
    which we study in this chapter, are built in terms of reactors, channels, and
    event streams.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 这三个独特的抽象是构建强大的分布式计算抽象的核心先决条件。在本章中，我们研究的Reactors框架中的大多数其他实用工具都是基于反应器、通道和事件流构建的。
- en: Getting started with Reactors
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Reactors入门
- en: This section contains instructions on how to get Reactors working in your project.
    The Reactors framework has multiple languages frontend, and works on multiple
    platforms. At the time of writing this book, Reactors can be used with Scala and
    Java as a JVM library, or alternatively on NodeJS or inside the browser if you
    are using the `Scala.js` frontend of Reactors.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 本节包含如何在项目中设置Reactors的说明。Reactors框架具有多种语言前端，并在多个平台上运行。在撰写本书时，Reactors可以用作Scala和Java的JVM库，或者如果您使用Reactors的`Scala.js`前端，还可以在NodeJS或浏览器中使用。
- en: 'If you are developing with SBT, the easiest way is to include Reactors into
    your project as a library dependency. To get started with `Reactors.IO`, you should
    grab the latest snapshot version distributed on **Maven**. If you are using SBT,
    add the following to your project definition:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您使用SBT进行开发，最简单的方法是将Reactors作为库依赖项包含到您的项目中。要开始使用`Reactors.IO`，您应该获取在**Maven**上分发的最新快照版本。如果您使用SBT，请将以下内容添加到您的项目定义中：
- en: '[PRE0]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: At the time of writing this, the latest version is `0.8` for Scala `2.11`. After
    a version of Reactors is released for Scala `2.12`, you might have to replace
    the `0.8` version in the preceding code.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本文时，Scala `2.11`的最新版本是`0.8`。在为Scala `2.12`发布Reactors版本之后，您可能需要替换前面代码中的`0.8`版本。
- en: The "Hello World" program
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '"Hello World"程序'
- en: In this section, we go through a simple, working Hello World program. We will
    not go into too much, yet we will provide deeper information in the subsequent
    sections. For now, we will just define a reactor that waits for one incoming event,
    prints a message to the standard output once this event arrives, and then terminate.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将通过一个简单、有效的Hello World程序进行操作。我们不会深入太多，但将在后续章节中提供更深入的信息。现在，我们只需定义一个等待一个传入事件、在事件到达时向标准输出打印一条消息，然后终止的反应器。
- en: 'We start by importing the contents of the `io.reactors` package:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先导入`io.reactors`包的内容：
- en: '[PRE1]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'This allows us to use the facilities provided by the Reactors framework. In
    the following snippet, we declare a simple reactor-based program:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 这允许我们使用Reactors框架提供的设施。在下面的代码片段中，我们声明了一个基于反应器的简单程序：
- en: '[PRE2]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The program above declares an anonymous reactor called `welcomeReactor`, which
    waits for a name to arrive on its main event stream, prints that name, and then
    seals its main channel, therefore terminating itself. The main program then creates
    a new reactor system, uses the reactor template to start a new running instance
    of the previously defined `welcomeReactor`, and sends an event `"Alan"` to it.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的程序声明了一个名为`welcomeReactor`的匿名反应器，它等待其主事件流上到达一个名称，打印该名称，然后密封其主通道，从而终止自身。主程序随后创建一个新的反应器系统，使用反应器模板启动之前定义的`welcomeReactor`的新运行实例，并向它发送一个事件`"Alan"`。
- en: 'By analyzing the previous program, we conclude the following:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 通过分析前面的程序，我们得出以下结论：
- en: A reactor is defined using the `Reactor[T]` constructor, where `T` is the type
    of the events that can be sent to the reactor on its main channel.
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`Reactor[T]`构造函数定义reactor，其中`T`是可以向reactor的主通道发送的事件类型。
- en: A reactor reacts to incoming events as specified in the callback function passed
    to the `onEvent` method. We can call `onEvent`, for example, on the main event
    stream of the reactor, which is obtained with the expression `main.events`.
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Reactor根据传递给`onEvent`方法的回调函数中指定的方式对传入的事件做出反应。例如，我们可以在reactor的主事件流上调用`onEvent`，该主事件流通过表达式`main.events`获得。
- en: Calling `main.seal()` terminates the reactor.
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调用`main.seal()`终止reactor。
- en: A reactor with a specific definition is started with the `spawn` method, which
    returns the reactor's main channel.
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用特定定义的reactor可以通过`spawn`方法启动，该方法返回reactor的主通道。
- en: Events are sent to the reactor by calling the `!` operator on one of its channels.
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过在reactor的一个通道上调用`!`运算符来向reactor发送事件。
- en: The subsequent sections will explain each of these features in greater depth.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 后续章节将更深入地解释这些功能中的每一个。
- en: Event streams
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 事件流
- en: 'In this section, we study the basic data-type that drives most computations
    in the Reactors framework: an event stream. Event streams represent special program
    values that can occasionally produce events. Event streams are represented by
    the `Event[T]` type.'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们研究驱动Reactor框架中大多数计算的基本数据类型：事件流。事件流表示偶尔可以产生事件的特殊程序值。事件流由`Event[T]`类型表示。
- en: Semantically, an event stream is very similar to the `Observable` type, which
    we saw in [Chapter 6](ch06.html "Chapter 6. Concurrent Programming with Reactive
    Extensions"), *Concurrent Programming with Reactive Extensions*. As we will see,
    the main difference between `Observable` and `Events` is that an `Observable`
    object can generally be used from different threads, and even emit events across
    different threads when the `observeOn` method is used. An `Events` object, by
    contrast, can only be used inside the reactor that owns that event stream.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 从语义上讲，事件流与我们在[第6章](ch06.html "第6章。使用Reactive Extensions进行并发编程")中看到的`Observable`类型非常相似，即*使用Reactive
    Extensions进行并发编程*。我们将看到，`Observable`和`Events`之间的主要区别在于，`Observable`对象通常可以从不同的线程中使用，并且在使用`observeOn`方法时甚至可以在不同的线程之间发出事件。相比之下，`Events`对象只能在其拥有该事件流的reactor内部使用。
- en: Tip
  id: totrans-47
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Never share an event stream between two reactors. An event stream can only be
    used by the reactor that owns the corresponding channel.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 永远不要在两个reactor之间共享事件流。事件流只能由拥有相应通道的reactor使用。
- en: 'In the following, we show an example event stream called `myEvents`, which
    produces events of type `String`:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下内容中，我们展示了名为`myEvents`的事件流示例，它产生类型为`String`的事件：
- en: '[PRE3]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: For now, we assume that the method `createEventStreamOfStrings` is already defined,
    and that it returns an event stream of type `Events[String]`.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我们假设方法`createEventStreamOfStrings`已经定义，并且它返回一个类型为`Events[String]`的事件流。
- en: 'To be useful, an event stream must allow the users to somehow manipulate the
    events it produces. For this purpose, every event stream has a method called `onEvent`,
    which takes a user callback function and invokes it every time an event arrives:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 要变得有用，事件流必须允许用户以某种方式操作它产生的事件。为此，每个事件流都有一个名为`onEvent`的方法，该方法接受一个用户回调函数，并在每次事件到达时调用它：
- en: '[PRE4]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The `onEvent` method is similar to what most callback-based frameworks expose:
    a way to provide an executable snippet of code that is invoked later, once an
    event becomes available. However, just like the `Observable` object in Reactive
    Extensions, the receiver of the `onEvent` method, that is, the event stream, is
    a first-class value. This subtle difference allows passing the event stream as
    an argument to other methods, and consequently allows writing more general abstractions.
    For example, we can implement a reusable `trace` method as follows:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '`onEvent`方法类似于大多数基于回调的框架所暴露的：提供一段可执行代码片段的方式，该代码片段在事件可用时被调用。然而，就像Reactive Extensions中的`Observable`对象一样，`onEvent`方法的接收者，即事件流，是一个一等值。这种微妙的不同之处使得可以将事件流作为参数传递给其他方法，从而允许编写更通用的抽象。例如，我们可以实现一个可重用的`trace`方法，如下所示：'
- en: '[PRE5]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The `onEvent` method returns a special `Subscription` object. Events are propagated
    to the user-specified callback until the user decides to call the `unsubscribe`
    method of that `Subscription` object. These `Subscription` objects have similar
    semantics as those seen in the **Reactive Extensions** framework.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '`onEvent` 方法返回一个特殊的 `Subscription` 对象。事件会传递到用户指定的回调函数，直到用户决定调用该 `Subscription`
    对象的 `unsubscribe` 方法。这些 `Subscription` 对象的语义与在 **Reactive Extensions** 框架中看到的类似。'
- en: Before we continue, we note that event streams are entirely a single-threaded
    entity. The same event stream will never concurrently produce two events at the
    same time, so the `onEvent` method will never be invoked by two different threads
    at the same time on the same event stream. As we will see, this property simplifies
    the programming model and makes event-based programs easier to reason about.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续之前，我们注意到事件流完全是单线程的实体。同一个事件流永远不会同时产生两个事件，因此同一个事件流上的 `onEvent` 方法永远不会同时被两个不同的线程调用。正如我们将看到的，这个特性简化了编程模型，使得基于事件的程序更容易推理。
- en: 'To understand this better, let''s study a concrete event stream called an emitter,
    represented by the `Events.Emitter[T]` type. In the following, we instantiate
    an emitter:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地理解这一点，让我们研究一个具体的名为发射器的事件流，它由 `Events.Emitter[T]` 类型表示。在下面的代码中，我们实例化了一个发射器：
- en: '[PRE6]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: An emitter is simultaneously an event stream and an event source. We can imperatively
    tell the emitter to produce an event by calling its `react` method. When we do
    that, the emitter invokes the callbacks previously registered with the `onEvent`
    method.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 发射器同时是事件流和事件源。我们可以通过调用其 `react` 方法来强制发射器产生一个事件。当我们这样做时，发射器会调用之前通过 `onEvent`
    方法注册的回调函数。
- en: '[PRE7]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: By running the above snippet, we convince ourselves that the `react` call really
    forces the emitter to produce an event. Furthermore, the call `emitter.react(8)`
    will always execute after `emitter.react(7)`, and the callback will be first invoked
    with `7`, and then with `8`, but not concurrently. Event propagation will occur
    on the same thread on which `react` was called.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 通过运行上面的代码片段，我们确信 `react` 调用确实强制发射器产生一个事件。此外，调用 `emitter.react(8)` 总是在 `emitter.react(7)`
    之后执行，回调函数将首先使用 `7` 调用，然后使用 `8` 调用，但不会并发。事件传播将在调用 `react` 的同一个线程上发生。
- en: Lifecycle of an event stream
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 事件流的生命周期
- en: We now take a closer look at the events that an event stream can produce. An
    event stream of type `Events[T]` usually emits events of type `T`. However, type `T`
    is not the only type of events that an event stream can produce. Some event streams
    are finite. After they emit all their events, they emit a special event that denotes
    that there will be no further events. Sometimes, event streams run into exceptional
    situations, and emit exceptions instead of normal events.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们更详细地看看事件流可以产生的事件。类型为 `Events[T]` 的事件流通常发出类型为 `T` 的事件。然而，类型 `T` 并不是事件流可以产生的唯一类型。一些事件流是有限的。在发出所有事件后，它们会发出一个特殊的事件，表示将不会有更多的事件。有时，事件流会遇到异常情况，并发出异常而不是普通事件。
- en: 'The `onEvent` method that we saw earlier can only react to normal events. To
    listen to other event kinds, event streams have the more general `onReaction`
    method. The `onReaction` method takes an `Observer` object as an argument. An
    `Observer` object has three different methods used to react to different event
    types. In the following code snippet, we instantiate an emitter and listen to
    all its events:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前看到的 `onEvent` 方法只能响应普通事件。要监听其他类型的事件，事件流有更通用的 `onReaction` 方法。`onReaction`
    方法接受一个 `Observer` 对象作为参数。`Observer` 对象有三个不同的方法，用于响应不同类型的事件。在下面的代码片段中，我们实例化了一个发射器并监听其所有事件：
- en: '[PRE8]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The type  `Observer[T]` has three methods:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 类型 `Observer[T]` 有三个方法：
- en: The `react` method, which is invoked when a normal event gets emitted. The second,
    optional hint argument may contain an additional value, but is usually set to
    `null`.
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当一个普通事件被触发时，会调用 `react` 方法。第二个可选的提示参数可能包含额外的值，但通常设置为 `null`。
- en: The `except` method, which is invoked when the event stream produces an exception.
    An event stream can produce multiple exceptions. An exception, however, does not
    terminate the stream, and many exceptions can be emitted by the same event stream.
    This is one big difference with respect to the type `Observable` from Reactive
    Extensions.
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当事件流产生异常时，会调用 `except` 方法。事件流可以产生多个异常。然而，异常并不会终止流，同一个事件流可以发出多个异常。这与 Reactive
    Extensions 中的类型 `Observable` 有一个很大的不同点。
- en: The `unreact` method, which is invoked when the event stream stops producing
    events. After this method is invoked on the observer, no further events or exceptions
    will be produced by the event stream.
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当事件流停止产生事件时调用的 `unreact` 方法。在此方法在观察者上调用后，事件流将不再产生更多事件或异常。
- en: 'Let''s assert that this contract is correct for `Events.Emitter`. We already
    learned that we can produce events with emitters by calling the `react` method.
    We can similarly call `except` to produce exceptions, or the `unreact` method
    to signal that there will be no more events. For example:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们断言这个合约对于 `Events.Emitter` 是正确的。我们已经了解到，我们可以通过调用 `react` 方法来使用发射器产生事件。我们可以类似地调用
    `except` 来产生异常，或者调用 `unreact` 方法来表示将不再有事件。例如：
- en: '[PRE9]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: If you run the preceding code snippet, you will see that, after calling the `unreact`
    method, subsequent calls to the `react` or `except` methods have no effect, and
    the `unreact` call effectively terminates the emitter. Not all event streams are
    as imperative as emitters, however. Most other event streams are created by functionally
    composing different event streams.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你运行前面的代码片段，你将看到，在调用 `unreact` 方法后，对 `react` 或 `except` 方法的后续调用都没有效果，`unreact`
    调用实际上终止了发射器。然而，并非所有事件流都像发射器那样命令式。大多数其他事件流是通过功能组合不同的事件流创建的。
- en: Functional composition of event streams
  id: totrans-74
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 事件流的功能组合
- en: 'Using event stream methods such as `onEvent` and `onReaction` can easily result
    in a callback hell: a program composed of a large number of unstructured `onXYZ`
    calls, which is hard to understand and maintain. Having first-class event streams
    is a step in the right direction, but it is not sufficient.'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 使用事件流方法，如 `onEvent` 和 `onReaction`，很容易导致回调地狱：由大量无结构的 `onXYZ` 调用组成的程序，难以理解和维护。拥有第一类事件流是正确的方向，但这还不够。
- en: 'Event streams support functional composition, seen in the earlier chapters.
    This pattern allows declaratively forming complex values by composing simpler
    ones. Consider the following example, in which we compute the sum of squares of
    incoming events:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 事件流支持功能组合，这在前面章节中已经看到。这种模式允许通过组合更简单的值来声明性地形成复杂值。考虑以下示例，其中我们计算传入事件的平方和：
- en: '[PRE10]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The example is fairly straightforward, but what if we want to make `squareSum`
    an event stream so that another part of the program can react to its changes?
    We would have to create another emitter and have our `onEvent` callback invoke
    the `react` method on that new emitter, passing it the value of `squareSum`. This
    could work, but it is not elegant, as shown in the following snippet:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子相当直接，但如果我们想让 `squareSum` 成为一个事件流，以便程序的另一部分能够对其变化做出反应呢？我们就需要创建另一个发射器，并让我们的
    `onEvent` 回调在该新发射器上调用 `react` 方法，传递 `squareSum` 的值。这可能可行，但并不优雅，如下面的代码片段所示：
- en: '[PRE11]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: We now rewrite the previous snippet using event stream combinators. Concretely,
    we use the `map` and `scanPast` combinators. The `map` combinator transforms events
    in one event stream into events for a derived event stream. We use the `map` combinatory
    to produce a square of each integer event. The `scanPast` combinator combines
    the last and the current event to produce a new event for the derived event stream.
    We use `scanPast` to add the previous value of the sum to the current one. For
    example, if an input event stream produces numbers `0`, `1`, and `2`, the event
    stream produced by `scanPast(0)(_ + _)` would produce numbers `0`, `1`, and `3`.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在使用事件流组合子重写前面的代码片段。具体来说，我们使用 `map` 和 `scanPast` 组合子。`map` 组合子将一个事件流中的事件转换成派生事件流的事件。我们使用
    `map` 组合子来生成每个整数事件的平方。`scanPast` 组合子将最后一个事件和当前事件结合起来，为派生事件流生成一个新事件。我们使用 `scanPast`
    来将总和的先前值加到当前值上。例如，如果输入事件流产生数字 `0`、`1` 和 `2`，则由 `scanPast(0)(_ + _)` 产生的事件流将产生数字
    `0`、`1` 和 `3`。
- en: 'Here is how we can rewrite the previous example:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是如何重写前面的示例：
- en: '[PRE12]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The type `Events[T]` comes with a large number of predefined combinators. You
    can find other combinators in the online API documentation. A set of event streams
    composed using functional combinators forms a dataflow graph. Emitters are usually
    source nodes in this graph, event streams created by various combinators are inner
    nodes, and callback methods, such as `onEvent`, are sink nodes. Combinators such
    as `union` take several input event streams. Such event streams correspond to
    graph nodes with multiple input edges. Here is one example:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 类型`Events[T]`附带大量预定义的组合子。您可以在在线API文档中找到其他组合子。使用功能组合子组成的事件流集合形成一个数据流图。发射器通常是此图中的源节点，由各种组合子创建的事件流是内部节点，而回调方法，如`onEvent`，是汇节点。例如，`union`这样的组合子接受多个输入事件流。这些事件流对应于具有多个输入边的图节点。以下是一个例子：
- en: '[PRE13]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Dataflow graphs induced by event streams are similar in nature to dataflow graphs
    induced by Scala futures and `Observable` objects from Reactive Extensions, so
    we will not study them further in this chapter. The most important thing to remember
    about event streams in the reactor model is that they are single-threaded entities.
    As we will see in the next section, each event stream can only belong to a single
    reactor.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 由事件流引起的数据流图在本质上与由Scala的`futures`和Reactive Extensions中的`Observable`对象引起的数据流图相似，因此我们不会在本章中进一步研究它们。关于反应器模型中事件流最重要的记住的事情是，它们是单线程实体。正如我们将在下一节中看到的，每个事件流只能属于单个反应器。
- en: Reactors
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 反应器
- en: As we learned previously, event streams always propagate events on a single
    thread. This is useful from the standpoint of program comprehension, but we still
    need a way to express concurrency in our programs. In this section, we will see
    how to achieve concurrency by using entities called reactors.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前所学的，事件流总是在单线程上传播事件。这对于程序理解是有用的，但我们仍然需要在我们的程序中表达并发。在本节中，我们将看到如何通过使用称为反应器的实体来实现并发。
- en: A reactor is the basic unit of concurrency. While actors receive messages, we
    will adopt the terminology in which reactors receive events, in order to disambiguate.
    However, while an actor a in particular state has only a single point where it
    can receive a message, namely, the `receive` statement, a reactor can receive
    an event from many different sources at any time. Despite this flexibility, one
    reactor will always process, at most, one event at any time. We say that events
    received by a reactor are **serialized**, similar to how messages received by
    an actor are serialized.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 反应器是并发的基本单元。当演员接收消息时，我们将采用反应器接收事件的术语，以便消除歧义。然而，尽管一个处于特定状态的演员只有一个可以接收消息的点，即`receive`语句，但反应器可以在任何时候从许多不同的来源接收事件。尽管这种灵活性，但一个反应器在任何时候最多只能处理一个事件。我们说反应器接收的事件是**序列化的**，类似于演员接收的消息是如何序列化的。
- en: 'To be able to create new reactors, we need a `ReactorSystem` object, which
    tracks reactors in a single machine:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 为了能够创建新的反应器，我们需要一个`ReactorSystem`对象，它跟踪单个机器中的反应器：
- en: '[PRE14]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Before we can start a reactor instance, we need to define its template. One
    way to do this is to call `Reactor.apply[T]` method, which returns a `Proto` object
    for the reactor. The `Proto` object is a reactor prototype, which can be used
    to start the reactor. The following reactor prints all the events it receives
    to the standard output:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们可以启动反应器实例之前，我们需要定义其模板。一种方法是调用`Reactor.apply[T]`方法，它返回一个用于反应器的`Proto`对象。`Proto`对象是一个反应器原型，可以用来启动反应器。以下反应器将接收到的所有事件打印到标准输出：
- en: '[PRE15]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Let's examine this code more closely. The `Reactor.apply` method is called with
    the type argument `String`. This means that the reactor encoded in the resulting
    `Proto` object by default receives events whose type is `String`. This is the
    first difference with respect to the standard actor model, in which actors can
    receive messages of any type. Events received by reactors are well typed.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更仔细地检查这段代码。`Reactor.apply`方法使用类型参数`String`被调用。这意味着由结果`Proto`对象编码的反应器默认接收类型为`String`的事件。这与标准演员模型中的演员可以接收任何类型的消息的第一个区别。反应器接收的事件是严格类型化的。
- en: In the reactor model, every reactor can access a special event stream called
    `main.events`, which emits events that the reactor receives from other reactors.
    Since we are declaring an anonymous reactor with the `Reactor.apply` method, we
    need to add a prefix `self` to access members of the reactor. We previously learned
    that we can call `onEvent` to register callbacks to event streams, and we used
    it in this example to print the events using `println`.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在反应器模型中，每个反应器都可以访问一个特殊的事件流，称为 `main.events`，它发出反应器从其他反应器接收的事件。由于我们使用 `Reactor.apply`
    方法声明了一个匿名反应器，因此我们需要添加一个前缀 `self` 来访问反应器的成员。我们之前了解到，我们可以调用 `onEvent` 来注册事件流的回调，并且我们在本例中使用了它来使用
    `println` 打印事件。
- en: 'After defining a reactor template, the next step is to spawn a new reactor.
    We do this by calling the `spawn` method on the reactor system:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在定义反应器模板之后，下一步是启动一个新的反应器。我们通过在反应器系统上调用 `spawn` 方法来完成此操作：
- en: '[PRE16]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The `spawn` method takes a `Proto` object as a parameter. The `Proto` object
    can generally encode the reactor's constructor arguments, scheduler, name, and
    other options. In our example, we created a `Proto` object for an anonymous reactor
    with the `Reactor.apply` method, so we do not have access to any constructor arguments.
    We will later see alternative ways of declaring reactors and configuring prototypes.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '`spawn` 方法接受一个 `Proto` 对象作为参数。`Proto` 对象可以通常编码反应器的构造函数参数、调度器、名称和其他选项。在我们的例子中，我们使用
    `Reactor.apply` 方法创建了一个匿名反应器的 `Proto` 对象，因此我们无法访问任何构造函数参数。我们将在以后看到声明反应器和配置原型的其他方法。'
- en: 'The `spawn` method does two things. First, it registers and starts a new reactor
    instance. Second, it returns a `Channel` object, which is used to send events
    to the newly created reactor. We show the relationship between a reactor, its
    event stream, and the channel in the following figure:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '`spawn` 方法执行两个操作。首先，它注册并启动一个新的反应器实例。其次，它返回一个 `Channel` 对象，该对象用于向新创建的反应器发送事件。我们在以下图中展示了反应器、其事件流和通道之间的关系：'
- en: '![Reactors](img/image_10_001.jpg)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![反应器](img/image_10_001.jpg)'
- en: The only way for the outside world to access the inside of a reactor is to send
    events to its channel. These events are eventually delivered to the corresponding
    event stream, which the reactor can listen to. The channel and event stream can
    only pass events whose type corresponds to the type of the reactor.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 外部世界访问反应器内部唯一的方式是向其通道发送事件。这些事件最终被传递到相应的事件流，反应器可以监听这些事件流。通道和事件流只能传递与反应器类型相对应的事件类型。
- en: 'Let''s send an event to our reactor. We do this by calling the bang operator
    `!` on the channel:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们向我们的反应器发送一个事件。我们通过在通道上调用感叹号操作符 `!` 来完成此操作：
- en: '[PRE17]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Running the last statement should print the string `"Hola!"` to the standard
    output.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 执行最后一条语句应该在标准输出中打印字符串 `"Hola!"`。
- en: Defining and configuring reactors
  id: totrans-104
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义和配置反应器
- en: In earlier sections, we saw how to define a reactor using the `Reactor.apply`
    method. In this section, we take a look at an alternative way of defining a reactor--by
    extending the `Reactor` base class. Recall that the `Reactor.apply` method defines
    an anonymous reactor template. Extending the `Reactor` class declares a named
    reactor template.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们看到了如何使用 `Reactor.apply` 方法定义一个反应器。在本节中，我们将探讨定义反应器的另一种方法——通过扩展 `Reactor`
    基类。回想一下，`Reactor.apply` 方法定义了一个匿名反应器模板。扩展 `Reactor` 类声明了一个命名反应器模板。
- en: 'In the following, we declare the `HelloReactor` class, which must be top-level:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下内容中，我们声明了 `HelloReactor` 类，它必须是顶级类：
- en: '[PRE18]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'To run this reactor, we first create a prototype to configure it. The method
    `Proto.apply` takes the type of the reactor and returns a prototype for that reactor
    type. We then call the `spawn` method with that `Proto` object to start the reactor:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行此反应器，我们首先创建一个原型来配置它。`Proto.apply` 方法接受反应器的类型，并返回该反应器类型的原型。然后我们使用该 `Proto`
    对象调用 `spawn` 方法来启动反应器：
- en: '[PRE19]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'We can also use the prototype to, for example, set the scheduler that the reactor
    instance should use. If we want the reactor instance to run on its own dedicated
    thread to give it more priority, we can do the following:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用原型来设置反应器实例应使用的调度器。如果我们想让反应器实例在自己的专用线程上运行以赋予它更高的优先级，我们可以执行以下操作：
- en: '[PRE20]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Note that if you are running Reactors on `Scala.js`, you will need to use a
    `Scala.js` specific scheduler. The reason for this is because the JavaScript runtime,
    which `Scala.js` compiles to, is not multi-threaded. Asynchronous executions are
    placed on a single queue, and executed one after another. On `Scala.js`, you will
    need to use the `JsScheduler.Key.default` scheduler.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: 'There are several other configuration options for `Proto` objects, and you
    can find out more about them in the online API documentation. We can summarize
    this section as follows. Starting a reactor is generally a three-step process:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: A named reactor template is created by extending the `Reactor` class.
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A reactor configuration object is created with the `Proto.apply` method.
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A reactor instance is started with the `spawn` method of the reactor system.
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For convenience, we can fuse the first two steps by using the `Reactor.apply`
    method, which creates an anonymous reactor template and directly returns a prototype
    object of type `Proto[I]`, for some reactor type `I`. Typically, this is what
    we do in the tests, or when trying things out in the Scala REPL.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: Using channels
  id: totrans-118
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that we understand how to create and configure reactors in different ways,
    we can take a closer look at channels, which are the reactor's means of communicating
    with its environment. As noted before, every reactor is created with a default
    channel called `main`, which is often sufficient. But sometimes a reactor needs
    to be able to receive more than just one type of an event, and needs additional
    channels for this purpose.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s declare a reactor that stores key-value pairs. The reactor must react
    to requests for storing key-value pairs, and for retrieving a value under a specific
    key. Since the reactor''s input channel will have to serve two purposes, we need
    the following data type:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The `Op` datatype has two type parameters called `K` and `V`, which denote the
    types of keys and values being stored. The `Put` case class is used to store a
    value into the reactor, so it contains the new key and value. The `Get` case class
    is used to retrieve the value that was previously stored with some key, so it
    encodes the key and the channel of type `V`. When the reactor receives the `Get`
    event, it must look up the value associated with the key, and send the value along
    the channel.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: 'With the `Op[K, V]` data type, we can define `MapReactor`, shown in the following
    snippet:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Let''s start `MapReactor` and test it. We will use the `MapReactor` to store
    some DNS aliases. We will map each alias `String` key to a URL, where the URLs
    are represented with the `List[String]` type. We first initialize as follows:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'We then send a couple of `Put` messages to store some alias values:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Next, we create a client reactor that we control by sending it `String` events.
    This means that the reactor''s type will be `Reactor[String]`. However, the client
    reactor will also have to contact the `MapReactor` and ask it for one of the URLs.
    Since the `MapReactor` can only send it back `List[String]` events that do not
    correspond to the client''s default channel type, the client''s default channel
    is not be able to receive the reply. Therefore, the client will have to provide
    the `MapReactor` with a different channel. The following expression is used to
    create a new channel:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The expression `system.channels` returns a channel builder object, which provides
    methods such as `named` or `daemon`, used to customize the channel (see the online
    API docs for more details). In this example, we will create **daemon channel**,
    to indicate that the channel does not need to be closed (more on that a bit later).
    To create a new channel, we call the `open` method on the channel builder with
    the appropriate type parameter.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: 'The resulting `Connector` object contains two members: the `channel` field,
    which is the newly created channel, and the `events` field, which is the event
    stream corresponding to that channel. The event stream propagates all events that
    were sent and delivered on the channel, and can only be used by the reactor that
    created it. The channel, on the other hand, can be shared with other reactors.'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  id: totrans-133
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Use the `open` operation on the `system.channels` object to create new connectors.
    Each connector holds a pair of a channel and its event stream.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s define a client reactor that waits for a `"start"` message, and then
    checks a DNS entry. This reactor will use the `onMatch` handler instead of `onEvent`,
    to listen only to certain `String` events and ignore others:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: In the preceding code snippet, when the reactor receives the `"start"` event
    from the main program, it opens a new `reply` channel that accepts `List[String]`
    events. It then sends a `Get` event to the `MapReactor` with the `"dns-main"`
    key and the `reply` channel. Finally, the reactor listens to events sent back
    along the `reply` channel, and prints the URL to the standard output. In the `"end"`
    case of the main pattern match, the reactor calls the `seal` method on the main
    channel to indicate that it will not receive any further events on that channel.
    Once all non-daemon channels become sealed, the reactor terminates.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  id: totrans-138
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A reactor terminates either when all its non-daemon channels are sealed, or
    when its constructor or some event handler throws an exception.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start the client reactor and see what happens:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: At this point, we should witness the URL on the standard output. Finally, we
    can send the `"end"` message to the client reactor to stop it.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: In the next section, we will see how to customize reactors with custom scheduling
    policies.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: Schedulers
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Each reactor template can be used to start multiple reactor instances, and each
    reactor instance can be started with a different reactor scheduler. Different
    schedulers have different characteristics in terms of execution priority, frequency,
    latency, and throughput. In this section, we take a look at how to use a non-default
    scheduler, and how to define custom schedulers when necessary.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: We start by defining a reactor that logs incoming events, reports every time
    it gets scheduled, and ends after being scheduled three times. We will use the
    `sysEvents` stream of the reactor, which will be explained in the next section.
    For now, all you need to know is that the system event stream produces events
    when the reactor gets some execution time (that is, gets scheduled), and pauses
    its execution (that is, gets pre-empted).
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Logger` reactor is shown in the following snippet:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Before starting an instance of the `Logger` reactor, we need to create a reactor
    system, as we learned in the earlier sections:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Every reactor system is bundled with a default scheduler and some additional
    predefined schedulers. When a reactor is started, it uses the default scheduler,
    unless specified otherwise. In the following, we override the default scheduler
    with the one using Scala''s global execution context, that is, Scala''s own default
    thread pool:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Running the snippet above should start the `Logger` reactor and print the `"scheduled"`
    string once, because starting a reactor schedules it even before any events arrive.
    If we now send an event to the main channel, we will see the `"scheduled"` string
    printed again, followed by the event itself. We do this as follows:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Sending the event again decrements the reactor''s counter. The main channel
    gets sealed, leaving the reactor in a state without non-daemon channels, and the
    reactor terminates:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Reactor systems also allow registering custom scheduler instances. In the following,
    we create and register a custom `Timer` scheduler, which schedules the `Logger`
    reactor for execution once every 1,000 milliseconds:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: By running the code above, we can see that the reactor gets scheduled even if
    no events were sent to it. The `Timer` scheduler ensures that the reactor gets
    scheduled exactly once every N seconds, and then processes some of its pending
    events.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: Reactor lifecycle
  id: totrans-161
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Every reactor goes through a certain set of stages during its lifetime, which
    are jointly called a **reactor lifecycle**. When the reactor enters a specific
    stage, it emits a lifecycle event. These lifecycle events are dispatched on a
    special daemon event stream called `sysEvents`. Every reactor is created with
    this special event stream.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: 'The reactor lifecycle can be summarized as follows:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: After calling the `spawn` method, the reactor is scheduled for execution. Its
    constructor is started asynchronously, and immediately after that, a `ReactorStarted`
    event is dispatched.
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Then, whenever the reactor gets execution time, the `ReactorScheduled` event
    gets dispatched. After that, events get dispatched on normal event streams.
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When the scheduling system decides to pre-empt the reactor, the `ReactorPreempted`
    event is dispatched. This scheduling cycle can be repeated any number of times.
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Eventually, the reactor terminates, either by normal execution or exceptionally.
    If a user code exception terminates execution, a `ReactorDied` event is dispatched.
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In either normal or exceptional execution, a `ReactorTerminated` event gets
    emitted.
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This reactor lifecycle is shown in the following diagram:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: '![Reactor lifecycle](img/image_10_002.jpg)'
  id: totrans-170
  prefs: []
  type: TYPE_IMG
- en: 'To test this, we define the following reactor:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Upon creating the lifecycle reactor, the reactor gets the `ReactorStarted` event,
    and then the `ReactorStarted` and `ReactorScheduled` events. The reactor then
    gets suspended, and remains that way until the scheduler gives it more execution
    time.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: The scheduler executes the reactor again when it detects that there are pending
    messages for that reactor. If we send an event to the reactor now, we will see
    the same cycle of `ReactorScheduled` and `ReactorPreempted` events from the standard
    output. However, the `ReactorPreempted` handler this time throws an exception.
    The exception gets caught, and a `ReactorDied` event is emitted, followed by the
    mandatory `ReactorTerminated` event.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: At this point, the reactor is fully removed from the reactor system.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: Reactor system services
  id: totrans-178
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the earlier sections, we learned that reactors delimit concurrent executions,
    and that event streams allow routing events within each reactor. This is already
    a powerful set of abstractions, and we can use reactors and event streams to write
    all kinds of distributed programs. However, such a model is restricted to reactor
    computations only. We cannot, for example, start blocking I/O operations, read
    from a temperature sensor implemented in hardware, wait until a GPU computation
    completes, or react to temporal events. In some cases, we need to interact with
    the native capabilities of the OS, or tap into a rich ecosystem of existing libraries.
    For this purpose, every reactor system has a set of **services**: protocols that
    relate event streams to the outside world.'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we will take a closer look at various services that are available
    by default, and also show how to implement custom services and plug them into
    reactor systems.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: The logging service
  id: totrans-181
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We start with the simplest possible service called `Log`. This service is used
    to print logging messages to the standard output. In the following, we create
    an anonymous reactor that uses the `Log` service. We start by importing the `Log`
    service:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Next, we create a reactor system, and start a reactor instance. The reactor
    invokes the `service` method on the reactor system, which returns the service
    singleton with the specified type. The reactor then calls the `apply` method on
    the `log` object to print a message, and seals itself.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: 'This is shown in the following snippet:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Running the above snippet prints the timestamped message to the standard output.
    This example is very simple, but we use it to describe some important properties
    of services:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: Reactor system's method `service[S]` returns a service of type `S`.
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The service obtained this way is a lazily initialized singleton instance. There
    exists at most one instance of the service per reactor system, and it is created
    only after being requested by some reactor.
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Some standard services are eagerly initialized when the reactor system gets
    created. Such services are usually available as a standalone method on the `ReactorSystem`
    class. For example, `system.log` is an alternative way to obtain the `Log` service.
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The clock service
  id: totrans-191
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Having seen a trivial service example, let's take a look at a more involved
    service that connects reactors with the outside world of events, namely, the `Clock`
    service. The `Clock` service is capable of producing time-driven events, for example,
    timeouts, countdowns, or periodic counting. This service is standard, so it is
    available by calling either `system.clock` or `system.service[Clock]`.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following, we create an anonymous reactor that uses the `Clock` service
    to create a timeout event after one second. The `timeout` method of the clock
    service returns an event stream of the `Unit` type that always produces at most
    one event. We install a callback to the `timeout` event stream, which seals the
    main channel of this reactor. This is shown in the following snippet:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'The `Clock` service uses a separate timer thread under-the-hood, which sends
    events to the reactor when the timer thread decides it is time to do so. The events
    are sent on a special channel created by the `timeout` method, so they are seen
    only on the corresponding event stream combinator. This is summarized in the following
    figure:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: '![The clock service](img/image_10_003.jpg)'
  id: totrans-196
  prefs: []
  type: TYPE_IMG
- en: When the main channel gets sealed, the reactor terminates. This is because the
    `timeout` event stream creates a daemon channel under-the-hood, which does not
    prevent our anonymous reactor from terminating after non-daemon channels are gone.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Clock` service shows a general pattern: when a native entity or an external
    event needs to communicate with a reactor, it creates a new channel, and then
    asynchronously sends events to it.'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: The channels service
  id: totrans-199
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Some services provide event streams that work with reactor system internals.
    The `Channels` service is one such example--it provides an event-driven view over
    all channels that exist in the current reactor system. This allows polling the
    channels that are currently available, or waiting until a channel with a specific
    name becomes available. Awaiting a channel is particularly useful, as it allows
    easier handling of asynchrony between reactors, which is inherent to distributed
    systems.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: As a side-note, we actually saw and used the `Channels` service earlier, when
    we opened a second channel in a reactor. The expression `system.channels.open`
    actually calls the `open` method on the standard channel service. The channels
    service thus not only allows querying channels that exist in the reactor system,
    but also creating new channels within existing reactors.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: 'To show basic usage of the `Channels` service, we construct two reactors. The
    first reactor will create a channel named `"hidden"` after some delay, and the
    second reactor will wait for that channel. When the channel appears, the second
    reactor will send an event to that channel. The first reactor prints the string
    `"event received"` after it receives the message, sealing its main channel. This
    is shown in the following snippet:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: In the preceding program, we use the `Clock` service seen earlier to introduce
    a delay in the first reactor. In the second reactor, we use the `Channels` service
    to wait for the channel named `"hidden"` of the reactor named `"first"`. Both
    reactors start at approximately the same time.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: 'After one second, the first reactor uses the `Channels` service to open a new
    daemon channel named `"hidden"`. The first reactor then installs a callback: when
    the first event arrives on the hidden channel, it prints a message to the standard
    output, and the main channel is sealed, to ensure that the reactor terminates.
    The second reactor gets an event from the `Channels` service, since a channel
    with the desired name now exists. This reactor sends a value `7` to the hidden
    channel, and terminates.'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: To conclude, waiting for channels to appear is important when establishing temporal
    order in an asynchronous system. In general, the creation of the hidden channel
    in the first reactor could have been delayed by an arbitrary amount by the reactor
    system, and the `Channels` service allows the computation to proceed only after
    specific channels in other reactors get created.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: Custom services
  id: totrans-207
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Having seen a few existing services, we now show how to create a custom service.
    To do this, we must implement the `Protocol.Service` trait, which has a single
    member method called `shutdown`:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: The `shutdown` method is called when the corresponding reactor system gets shut
    down, and is used to free any resources that the service potentially has. Any
    custom service must additionally have a single parameter constructor that takes
    a `ReactorSystem` object, which allows the service to interact with and use the
    reactor system during its existence.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: As noted earlier, a service is a mechanism that gives access to events that
    a reactor normally cannot obtain from other reactors. Let's implement a service
    that notifies a reactor when the enclosing reactor system gets shut down. For
    this, we will need to keep a map of the channels that subscribed to the shutdown
    event and a lock to protect access to that state. Finally, we will expose a method
    `state`, which creates an event stream that emits an event when the reactor system
    is shut down.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: The `state` method will return a special kind of event stream called a `Signal`.
    The `Signal` type extends the `Events` type, and a signal object emits events
    whenever its value changes. Additionally, a `Signal` caches the value of the previously
    emitted event, which can be accessed with the signal's `apply` method. Any event
    stream can be converted into a signal by calling the `toSignal` method.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: The `state` method, called by a specific reactor, must create a new daemon channel
    called `shut`. This channel is added to the `subscribers` set of the shutdown
    service. The event stream associated with this channel is converted into a signal
    with the initial value `false`, and returned to the caller.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: 'The implementation of the `Shutdown` service is shown in the following snippet:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'We can now use the `Shutdown` service in user programs. This is shown in the
    following snippet:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Later, when we shut down the system, we expect that the code in the callback
    runs and completes the promise:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Note that, when implementing a custom service, we are no longer in the same
    ballpark as when writing normal reactor code. A service may be invoked by multiple
    reactors concurrently, and this is why we had to synchronize access to the subscribers
    map in the `Shutdown` implementation. In general, when implementing a custom service,
    we have to take care to:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: Never block or acquire a lock in the service constructor
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ensure that access to shared state of the service is properly synchronized
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In conclusion, you should use custom services when you have a native event-driven
    API that must deliver events to reactors in your program, or wish to expose access
    to internals of the reactor system, the OS or the underlying hardware. Often the
    implementation of a reactor system service will employ some lower-level concurrency
    primitives, but will expose a high-level API that relies on event streams and
    channels.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: Protocols
  id: totrans-224
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Reactors, event streams, and channels form the cornerstone of the reactor programming
    model. These basic primitives allow composing powerful communication abstractions.
    In this section, we go through some of the basic communication protocols that
    the Reactors framework implements in terms of its basic primitives. What these
    protocols have in common is that they are not artificial extensions of the basic
    model. Rather, they are composed from basic abstractions and other simpler protocols.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: We start with one of the simplest protocols, namely the **server-client** protocol.
    First, we show how to implement a simple server-client protocol ourselves. After
    that, we show how to use the standard server-client implementation provided by
    the Reactors framework. In the later sections on protocols, we will not dive into
    the implementation, but instead immediately show how to use the protocol predefined
    in the framework.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: This approach will serve several purposes. First, you should get an idea of
    how to implement a communication pattern using event streams and channels. Second,
    you will see that there is more than one way to implement a protocol and expose
    it to clients. Finally, you will see how protocols are structured and exposed
    in the Reactors framework.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: Custom server-client protocol
  id: totrans-228
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this subsection, we implement the server-client protocol ourselves. Before
    we start, we have to create a default reactor system:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Let''s now consider the server-client protocol more closely. This protocol
    proceeds as follows: first, the client sends a request value to the server. Then,
    the server uses the request to compute a response value and send it to the client.
    But to do that, the server needs a response channel, which serves as the destination
    to send the response value to. This means that the client must not only send the
    request value to the server, but also send a channel used for the reply. The request
    sent by the client is thus a tuple with a value and the reply channel. The server
    channel used by the server must accept such tuples. We capture these relationships
    with the following two types:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Here, `T` is the type of the request value, and `S` is the type of the response
    value. The `Req` type represents the request: a tuple of the request value `T`
    and the reply channel for responses of type `S`. The `Server` type is then just
    a channel that accepts request objects.'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we ask ourselves--how do we create a `Server` channel? There are several
    requirements that a factory method for the `Server` channel should satisfy. First,
    the server method should be generic in the request and the response type. Second,
    it should be generic in how the request type is mapped to the response type. Third,
    when a request is sent to the server, the mapped response should be sent back
    to the server. Putting these requirements together, we arrive at the following
    implementation of the `server` method, which instantiates a new server:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'The `server` method starts by creating a connector for `Req[T, S]` type. It
    then adds a callback to the event stream of the newly created connector. The callback
    decomposes the request tuple into the request value `x` of type `T` and the `reply`
    channel, then maps the input value using the specified mapping function `f`, and
    finally sends the mapped value of type `S` back along the `reply` channel. The
    `server` method returns the channel associated with this connector. We can use
    this method to start a server that maps request strings to uppercase strings,
    as follows:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Next, we will implement the client protocol. We will define a new method called
    `?` on the `Channel` type, which sends the request to the server. This method
    cannot immediately return the server''s response, because the response arrives
    asynchronously. Instead, method `?` must return an event stream with the server''s
    reply. So, the `?` method must create a reply channel, send the `Req` object to
    the server, and then return the event stream associated with the reply channel.
    This is shown in the following snippet:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: In the code above, we defined an extension method `?` for objects of the `Server`
    type by declaring an implicit class `ServerOps`. The `Arrayable` context bound
    on type `S` is required in the Reactors framework to enable the creation of arrays.
    The Reactors framework requires the `Arrayable` type class whenever we want to
    open a channel of a generic type, which is in this case the type `S`.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
- en: 'We now show the interaction between the server and the client by instantiating
    the two protocols within the same reactor. The server just returns an uppercase
    version of the input string, while the client sends the request with the content
    `"hello"`, and prints the response to the standard output. This is shown in the
    following snippet:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Our implementation works, but it is not very useful to start the server-client
    protocol inside a single reactor. Normally, the server and the client are separated
    by the network, or are at least different reactors running inside the same reactor
    system.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
- en: It turns out that, with our toy implementation of the server-client protocol,
    it is not straightforward to instantiate the protocol in two different reactors.
    The main reason for this is that once the server channel is instantiated within
    one reactor, we have no way of *seeing* it in another reactor. The server channel
    is hidden inside the lexical scope of the server reactor. We will see how to easily
    overcome this problem with the standard server-client implementation that the
    Reactors framework provides.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
- en: Standard server-client protocol
  id: totrans-245
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We have just seen an example implementation of the server-client protocol, which
    relies only on the basic primitives provided by the Reactors framework. However,
    the implementation that was presented is very simplistic, and it ignores several
    important concerns. For example, how do we stop the server protocol? Also, we
    instantiated the server-client protocol in a single reactor, but is it possible
    to instantiate server-client in two different reactors?
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
- en: 'In this section, we take a closer look at how the server-client protocol is
    exposed in the Reactors framework, and explain how some of the above concerns
    are addressed. Most predefined protocols can be instantiated in several ways:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
- en: By installing the protocol on the existing connector inside an existing reactor,
    which has an appropriate type for that protocol. The main benefit of this is that
    you can install the protocol on, for example, the main channel of a reactor. This
    also makes the protocol accessible to other reactors that are aware of that respective
    channel.
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By creating a new connector for the protocol, and then installing the protocol
    to that connector. The main benefit of this is that you can fully customize the
    protocol's connector (for example, name it), but you will need to find some way
    of sharing the protocol's channel with other reactors, for example, by using it
    on the `Channels` service, or by sending the channel to specific reactors.
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By creating a new `Proto` object for a reactor that exclusively runs a specific
    protocol. The main benefit of this is being able to fully configure the reactor
    that you wish to start (for example, specify a scheduler, reactor name, or transport).
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By immediately spawning a reactor that runs a specific protocol. This is the
    most concise option.
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These approaches are mostly equivalent, but they represent different trade-offs
    between convenience and customization. Let's take a look at the predefined server-client
    protocol to study these approaches in turn.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
- en: Using an existing connector
  id: totrans-253
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'When using an existing connector, we need to ensure that the connector''s type
    matches the type needed by the protocol. In the case of a server, the connector''s
    event type must be `Server.Req`. In the following, we define a server prototype
    that multiplies the request integer by `2` to compute a response. To install the
    server-client protocol, we call the `serve` method on the connector:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'The client can then query the `server` channel using the `?` operator. For
    convenience, we use the `spawnLocal` method, which simultaneously defines an anonymous
    reactor template and uses it to spawn a new client reactor. This is shown in the
    following snippet:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Creating a new connector
  id: totrans-258
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let's say that the main channel is already used for something else. For example,
    the main channel could be accepting termination requests. Consequently, the main
    channel cannot be shared with the server protocol, as protocols usually need exclusive
    ownership of the respective channel. In such cases, we want to create a new connector
    for the protocol.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
- en: This approach is very similar to using an existing connector. The only difference
    is that we must first create the connector itself, giving us an opportunity to
    customize it. In particular, we will make the server a `daemon` channel, and we
    will assign it a specific name `"server"`, so that other reactors can find it.
    We will name the reactor itself `"Multiplier"`. To create a server connector,
    we use the convenience method called `server` on the channel builder object, to
    get a new connector of the appropriate type.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
- en: 'We can then call the `serve` method on the connector to start the protocol.
    This is shown in the following snippet:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'The client must now query the name service to find the server channel, and
    from there on it proceeds as before, as shown in the following:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Creating a protocol-specific reactor prototype
  id: totrans-265
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'When we are sure that the reactor will exist only, or mainly, for the purposes
    of the server protocol, we can directly create a reactor server. To do this, we
    use the `server` method on the `Reactor` companion object. The `server` method
    returns the `Proto` object for the server, which can then be further customized
    before spawning the reactor. The `server` method takes a user function that is
    invoked each time a request arrives. This user function takes the state of the
    server and the request event, and returns the response event. This is shown in
    the following code snippet:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: The `state` object for the server contains a `Subscription` object, which allows
    the users to stop the server if, for example, an unexpected event arrives.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
- en: Spawning a protocol-specific reactor directly
  id: totrans-269
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Finally, we can immediately start a server reactor, without any customization.
    This is done by passing a server function to the `server` method on the `ReactorSystem`,
    as follows:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: In the subsequent sections, we will take a look at some other predefined protocols,
    which have similar API as the server-client protocol.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
- en: Router protocol
  id: totrans-273
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this section, we take a look at a simple router protocol. Here, events coming
    to a specific channel are routed between a set of target channels, according to
    some user-specified policy. In practice, there are a number of applications of
    this protocol, ranging from data replication and sharding, to load-balancing and
    multicasting. The protocol is illustrated in the following figure:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
- en: '![Router protocol](img/image_10_004.jpg)'
  id: totrans-275
  prefs: []
  type: TYPE_IMG
- en: To show the router protocol in action, we will instantiate a master reactor
    that will route the incoming requests between two workers. In a real system, requests
    typically represent workloads, and workers execute computations based on those
    requests. For simplicity, requests will be just strings, and the workers will
    just print those strings to the standard output.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
- en: As was the case with the server-client protocol, there are several ways to instantiate
    the router protocol. First, the protocol can be started within an existing reactor,
    in which case it is just one of the protocols running inside that reactor. Alternatively,
    the protocol can be started as a standalone reactor, in which case that reactor
    is dedicated to the router protocol. In our example, we create an instance of
    the router protocol in an existing reactor.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
- en: 'We first start two workers, called `worker1` and `worker2`. These two reactors
    will print incoming events to the standard output. We use a shorthand method `spawnLocal`,
    to concisely start the reactors without creating the `Proto` object:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: Next, we declare a reactor whose main channel takes `Unit` events, since we
    will not be using the main channel for anything special. Inside that reactor,
    we first call the `router` method on the `channels` service to open a connector
    with the appropriate type for the router. By just calling the `router` method,
    the router protocol does not yet start. We need to call the `route` method on
    the newly created connector to actually start routing.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
- en: The `route` method expects a `Router.Policy` object as an argument. The policy
    object contains a function that returns a channel for an event that we want to
    route. This function of type `T => Channel[T]` represents the routing logic for
    the router protocol.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
- en: 'In our example, we will use the simple round-robin policy. This policy can
    be instantiated with the `Router.roundRobin` factory method, which expects a list
    of channels for the round-robin policy, so we will pass a list with `worker1`
    and `worker2` channels. We show this in the following snippet:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'After starting the router protocol and sending the events `"one"` and `"two"`
    to the router channel, the two strings are delivered to the two different workers.
    The `roundRobin` policy does not specify which of the target channels is chosen
    first, so the output can either contain `"1: one"` and `"2: two"`, or `"1: two"`
    and `"2: one"`.'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
- en: The round-robin routing policy does not have any knowledge about the two target
    channels, so it just picks one after another in succession, and then the first
    one again when it reaches the end of the target list. Effectively, this policy
    constitutes a very simple form of load-balancing.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
- en: There are other predefined policies that can be used with the router protocol.
    For example, the `Router.random` policy uses a random number generator to route
    events to different channels, which is more robust in scenarios when a high-load
    event gets sent periodically. Another policy is `Router.hash`, which computes
    the hash code of the event, and uses it to find the target channel. If either
    of these are not satisfactory, `deficitRoundRobin` strategy tracks the expected
    cost of each event, and biases its routing decisions to balance the total cost
    sent to each target. Users can also create custom routing policies for other use-cases.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
- en: Two-way protocol
  id: totrans-287
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this section, we show a two-way communication protocol. In two-way communication,
    two parties obtain a connection handle of type `TwoWay`, which allows them to
    simultaneously send and receive an unlimited number of events until they decide
    to close this connection. One party initiates the connection, so we call that
    party the client, and the other party the server. The `TwoWay` type has two type
    parameters `I` and `O`, which describe the types of input and output events, respectively,
    from the client''s point of view. This is illustrated in the following figure:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
- en: '![Two-way protocol](img/image_10_005.jpg)'
  id: totrans-289
  prefs: []
  type: TYPE_IMG
- en: 'Note that these types are reversed depending on whether you are looking at
    the connection from the server-side or from the client-side. The type of the client-side
    two-way connection is:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Whereas the type of the server sees the two-way connection as:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: Accordingly, the `TwoWay` object contains an output channel `output`, and an
    input event stream `input`. To close the connection, the `TwoWay` object contains
    a subscription object called `subscription`, which is used to close the connection
    and free the associated resources.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
- en: Let's create an instance of the two-way protocol. This protocol works in two
    phases. First, a client asks a two-way connection server to establish a two-way
    connection. After that, the client and the server use the two-way channel to communicate.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
- en: In what follows, we declare a reactor, and instantiate a two-way connection
    server within that reactor. For each established two-way connection, the two-way
    server will receive strings, and send back the length of those strings.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: The two lines above declare a reactor `Proto` object, which instantiates a two-way
    server called `lengthServer`. We first called the `twoWayServer` method on the
    `Channels` service, and specified the input and the output type (from the point
    of view of the client). Then, we called the `serverTwoWay` method to start the
    protocol. In our case, we set the input type `I` to `Int`, meaning that the client
    will receive integers from the server, and the output type `O` to `String`, meaning
    that the client will be sending strings to the server.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
- en: The resulting object `lengthServer` represents the state of the connection.
    It contains an event stream called `connections`, which emits an event every time
    a client requests a connection. If we do nothing with this event stream, the server
    will remain silent - it will start new connections, but ignore events coming from
    the clients. How exactly the client and server communicate over the two-way connection
    (and when to terminate this connection) is up to the user to specify. To customize
    the two-way communication protocol with our own logic, we need to react to the
    `TwoWay` events emitted by the `connections` event stream, and install callbacks
    to the `TwoWay` objects.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
- en: 'In our case, for each incoming two-way connection, we want to react to `input`
    strings by computing the length of the string, and then sending that length back
    along the `output` channel. We can do this as follows:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'We now have a working instance of the two-way connection server. The current
    state of the reactor can be illustrated with the following figure, where our new
    channel appears alongside standard reactor channels:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
- en: '![Two-way protocol](img/image_10_006.jpg)'
  id: totrans-303
  prefs: []
  type: TYPE_IMG
- en: Next, let's start the client-side part of the protocol. The client must use
    the two-way server channel to request a connection. The `lengthServer` object
    that we saw earlier has a field called `channel` that must be used for this purpose.
    The client must know about this channel to start the connection. Note that only
    the `channel` must be shared, not the complete `lengthServer` object. To make
    things simple, we will instantiate the client-side part of the protocol inside
    the same reactor as the server-side part.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
- en: To connect to the server, the client must invoke the `connectTwoWay` extension
    method on the `channel`. This method is only available when the package `io.reactors.protocol`
    is imported, and works on two-way server channels. The `connect` method returns
    an event stream that emits a `TwoWay` object once the connection gets established.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following, we connect to the server. Once the server responds, we use
    the `TwoWay[Int, String]` object to send a string event, and then print the length
    event that we get back:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'After the connection is established, the state of the reactor and its connectors
    is as shown in the following diagram:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
- en: '![Two-way protocol](img/image_10_007.jpg)'
  id: totrans-309
  prefs: []
  type: TYPE_IMG
- en: Note that, in this case, the two-way channel has both endpoints in the same
    reactor. This is because we called `twoWayServe` and `connect` in the same reactor,
    for the purposes of demonstration. In real scenarios, we would typically invoke
    these two operations on separate reactors.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-311
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned about the reactor model, and its implementation
    in the Reactors framework. We saw how to define and instantiate reactors, compose
    event streams, customize reactor names and assign schedulers, use reactor system
    services, and define custom ones. Importantly, we saw how to use a few basic low-level
    protocols such as the server-client, router, and the two-way connection protocol.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
- en: To learn more about reactors, you can find a lot of information on the website
    of the Reactors framework, at [http://reactors.io](http://reactors.io/). The Reactors
    framework is relatively new, but it is under constant development. As the framework
    matures and gains more features, you will find more and more information on the
    website. To learn more about the reactor programming model itself, the paper *Reactors,
    Channels, and Event Streams for Composable Distributed Programming* is worth taking
    a look at.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
- en: Exercises
  id: totrans-314
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the following exercises, you are expected to define several reactor protocols.
    In some cases, the task is to first investigate a specific algorithm online on
    your own, and then implement it using the Reactors framework. The exercises are
    ordered by their difficulty, and range from simple tasks to more complex ones.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
- en: Define a method called `twice`, which takes a target channel, and returns a
    channel that forwards every event twice to the target.
  id: totrans-316
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE65]'
  id: totrans-317
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE65]'
- en: Define a method called `throttle`, which throttles the rate at which events
    are forwarded to the target channel.
  id: totrans-318
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE66]'
  id: totrans-319
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE66]'
- en: '**Hint**: you will have to use the `Clock` service and the functional event
    stream composition.'
  id: totrans-320
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The `Shutdown` service shown in this chapter can run out of memory if there
    are a lot of reactors subscribing to it. This is because the current implementation
    never removes entries from the service's `subscribers` map. Modify the custom
    `Shutdown` service so that the clients of the `state` signals can unsubscribe
    from listening to shutdown events. Additionally, ensure that when a reactor terminates,
    it unsubscribes from the `Shutdown` service if it was subscribed to it. Use the
    `sysEvents` event stream for this purpose.
  id: totrans-321
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Assume that normal `Channel` objects can occasionally lose some events or reorder
    them, but never duplicate or corrupt events. Implement a reliable channel protocol,
    which ensures that every event sent through a channel is delivered to its destination
    in the order it was sent. Define two methods `reliableServer` and `openReliable`,
    which are used to start the reliable connection server and open the reliable connection
    on the client, respectively. The methods must have the following signatures, where
    it is up to you to determine the types:'
  id: totrans-322
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE67]'
  id: totrans-323
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Implement the *best-effort broadcast protocol*, which delivers events to multiple
    targets. The broadcast method must implement the following interface, where events
    sent to the resulting channel must be forwarded to all the targets:'
  id: totrans-324
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE68]'
  id: totrans-325
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE68]'
- en: Investigate and learn about how the CRDT counter algorithm works. Then, use
    the best-effort broadcast protocol from an earlier exercise to implement the CRDT
    counter algorithm. Define a method called `crdt` to allow users to create the
    CRDT counter.
  id: totrans-326
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Implement a `failureDetector` method, which takes a heartbeat server of `Unit`
    request and response types, and returns a `Signal` object that denotes whether
    the server is suspected to have failed:'
  id: totrans-327
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE69]'
  id: totrans-328
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE69]'
- en: The protocol started by this method must regularly send heartbeat signals to
    the server, and expect replies within a certain time period. The server is suspected
    to have failed when its response does not arrive before that time period elapses.
    Implement a unit test to validate that the resulting signal correctly detects
    server failure.
  id: totrans-329
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Implement the *reliable broadcast algorithm*, which has the same interface as
    the best-effort broadcast from an earlier exercise, but guarantees delivery to
    either all or none of the targets even if the sender dies halfway during the send
    operation. Implement unit tests to validate the correctness of your implementation.
  id: totrans-330
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
