- en: '*Chapter 2*: How Does MicroProfile Fit into Cloud-Native Application Development?'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter provides you with an overview of **MicroProfile** and describes
    the specifications of MicroProfile in terms of fulfilling the requirements of
    cloud-native applications. In this chapter, we first look at the history of MicroProfile
    concerning why it was created and for what purpose, and then we will explore the
    content of MicroProfile. This will give you a high-level understanding of each
    MicroProfile specification so that you will understand how MicroProfile fits into
    cloud-native application development and why you should adopt MicroProfile technologies.
    Finally, we will look at the MicroProfile code generator, **MicroProfile Starter**,
    focusing on how to create cloud-native applications. This is useful because it
    will help you get started with MicroProfile from scratch.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will cover the following topics in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: MicroProfile overview
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: MicroProfile specifications
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: MicroProfile Starter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: MicroProfile overview
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s start by reflecting on the history of MicroProfile, why it was set up,
    and how it progressed and established its working group. In this section, we look
    at two different sub-topics: the *history of MicroProfile* and the *characteristics
    of MicroProfile*. We''ll begin by looking at the history. It is important to understand
    the release cycle and what is included in various MicroProfile releases so that
    we can choose which version to use, and that we have a sense of how fast MicroProfile
    releases new versions.'
  prefs: []
  type: TYPE_NORMAL
- en: History of MicroProfile
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Seeing the slowly advancing pace of Java EE, a few major industry players, including
    IBM, Red Hat, Payara, Tomitribe, and others, got together in 2016 to discuss how
    to make server-side Java frameworks move faster and to address the new challenges
    associated with the new microservice space. As a result of this collaboration,
    MicroProfile was born in the fall of 2016\. It was designed to help Java developers
    develop cloud-native applications without needing to learn new languages.
  prefs: []
  type: TYPE_NORMAL
- en: 'MicroProfile 1.0 was announced in September 2016 at JavaOne. This first release
    of MicroProfile 1.0 consisted of CDI, JSON-P, and JAX-RS. In December 2016, MicroProfile
    joined the Eclipse Foundation under the Apache License v2.0 (Alv2.0). MicroProfile
    1.1 was released in August 2017 and included the first new MicroProfile specification,
    MicroProfile Config 1.0\. From 2017 to 2019, MicroProfile did three releases per
    year: in February, June, and October.'
  prefs: []
  type: TYPE_NORMAL
- en: In 2020, following the release of MicroProfile 3.3, MicroProfile was requested
    by Eclipse Foundation to set up its working group before any further major or
    minor releases could be performed. It took nearly 1 year for the community to
    decide whether to set up its own working group or merge with the Jakarta EE working
    group. Eventually, IBM, Red Hat, and Tomitribe decided to pursue a separate working
    group. With the working group requirement of a minimum of 5 corporate members,
    it took the community some time to acquire 2 more corporate members. In October,
    **Atlanta Java User Group** (**AJUG**) and Jelastic joined forces with IBM, Red
    Hat, and Tomitribe to form the MicroProfile working group. Finally, in October
    2020, the working group charter was approved. Soon afterward, Payara, Oracle,
    Fujitsu, Garden State JUG, and iJUG joined the MicroProfile working group.
  prefs: []
  type: TYPE_NORMAL
- en: 'After the MicroProfile working group was established in October 2020, the MicroProfile
    community immediately prepared the MicroProfile 4.0 release using the newly established
    release process. On 23 December, MicroProfile 4.0 was released. The latest MicroProfile
    version 4.1 got released recently in July 2021\. Here is the timeline for MicroProfile
    releases:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.1 – MicroProfile release timeline'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17377_02_01.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.1 – MicroProfile release timeline
  prefs: []
  type: TYPE_NORMAL
- en: As you can see from *Figure* *2.1*, MicroProfile has a fast release cadence.
    As well as this, MicroProfile has other identifying characteristics. In the next
    section, we will look at them.
  prefs: []
  type: TYPE_NORMAL
- en: Characteristics of MicroProfile
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'MicroProfile grew very quickly thanks to its unique characteristics of openness
    and diversity. These are detailed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Openness and transparency: MicroProfile is open to the public in terms of meetings,
    projects, contributions, and suchlike. There is no hierarchy, and everyone has
    the same right to voice their opinions. No one has a veto right.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Diversity: The community is diverse. Its contributors are made up of many major
    players, including IBM, Red Hat, Tomitribe, Payara, Java User Groups, and other
    individuals and groups. Everyone is welcome to join MicroProfile and voice their
    opinion. The way to join the conversation is via the MicroProfile Google group,
    accessible via **Join the Discussion** on [microprofile.io](http://microprofile.io).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Many runtime implementations: MicroProfile evolves APIs, specifications, and
    **Technology Compatibility Kits** (**TCKs**). It only creates APIs, but it does
    not include implementations. However, there is no lack of implementations. There
    are around a dozen implementations, as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: a) Open Liberty ([https://openliberty.io/](https://openliberty.io/))
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: b) WebSphere Liberty ([https://www.ibm.com/uk-en/cloud/websphere-liberty](https://www.ibm.com/uk-en/cloud/websphere-liberty))
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: c) Quarkus ([https://quarkus.io/](https://quarkus.io/))
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: d) Wildfly ([https://www.wildfly.org/](https://www.wildfly.org/))
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: e) Payara ([https://www.payara.fish/](https://www.payara.fish/))
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: f) TomEE ([https://tomee.apache.org/](https://tomee.apache.org/))
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: g) Helidon ([https://helidon.io](https://helidon.io))
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: h) Launcher ([https://github.com/fujitsu/launcher](https://github.com/fujitsu/launcher))
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: i) KumuluzEE ([https://ee.kumuluz.com/](https://ee.kumuluz.com/))
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: j) Piranha Cloud ([https://piranha.cloud/](https://piranha.cloud/))
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: k) Apache Geronimo ([https://geronimo.apache.org/](https://geronimo.apache.org/))
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Lightweight, iterative processes: MicroProfile establishes a pattern that moves
    fast and adopts an iterative process. It adapts to changes, allows breaking changes
    between releases, and adopts a semantic versioning policy, which means a major
    version release containing breaking changes. However, MicroProfile tries to minimize
    the number of breaking changes. When there are breaking changes, the changes must
    be clearly documented in the release notes of the corresponding specifications.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Due to the aforementioned characteristics of MicroProfile, its adoption rate
    increased rapidly. As a result, more and more companies started investing in MicroProfile
    technologies. MicroProfile is now seen as the standard for developing cloud-native
    applications. We will take a closer look at each individual MicroProfile specification
    in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: MicroProfile specifications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: At this point, you might be wondering what MicroProfile consists of. As you
    may know, MicroProfile evolves **Application Programming Interfaces** (**APIs**)
    in terms of developing cloud-native applications. MicroProfile has several specifications
    that offer various capabilities for cloud-native applications. As a cloud-native
    application developer, it's important to understand these.
  prefs: []
  type: TYPE_NORMAL
- en: 'The MicroProfile 4.0 release includes four specifications from Jakarta EE 8
    and eight MicroProfile specifications, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Jakarta EE specifications**:'
  prefs: []
  type: TYPE_NORMAL
- en: Jakarta Contexts and Dependency Injection (CDI) 2.0
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Jakarta RESTful Web Services (JAX-RS) 2.1
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Jakarta JSON Binding 1.0
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Jakarta JSON Processing 1.1
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**MicroProfile specifications**:'
  prefs: []
  type: TYPE_NORMAL
- en: MicroProfile Config 2.0
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: MicroProfile Fault Tolerance 3.0
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: MicroProfile Health 3.0
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: MicroProfile JWT Propagation 1.2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: MicroProfile Metrics 3.0
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: MicroProfile OpenAPI 2.0
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: MicroProfile OpenTracing 2.0
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: MicroProfile Rest Client 2.0
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: MicroProfile specifications are grouped under different release categories.
    MicroProfile has the concept of **platform** **release** and **standalone** **release**.
    In this section, we will cover both concepts in detail.
  prefs: []
  type: TYPE_NORMAL
- en: Platform release
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The platform release consists of 12 specifications, 4 of them being from Jakarta
    EE. These specifications can be divided into three subgroups (three layers) based
    on their usage:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Building cloud-native applications**: CDI, JAX-RS, Rest Client, JSON-B, and
    JSON-P'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Enhancing cloud-native applications**: Open API, Fault Tolerance, JWT Propagation,
    and Config'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Observing and monitoring cloud-native applications**: Open Tracing, Health,
    and Metrics'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's explore each of these groups in turn.
  prefs: []
  type: TYPE_NORMAL
- en: Technologies for developing cloud-native applications
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Cloud-native applications** can be developed using **CDI**, **JAX-RS**, **JSON-B**,
    or **JSON-P**. MicroProfile Rest Client is used for connecting cloud-native applications.
    Coming up next is a quick overview of these technologies. [*Chapter 4*](B17377_04_Final_SB_epub.xhtml#_idTextAnchor068),
    *Developing Cloud-Native Applications*, will explain them in more detail.'
  prefs: []
  type: TYPE_NORMAL
- en: CDI – Contexts and Dependency Injection
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '`@ApplicationScoped`, `@RequestScoped`, and `@Dependent`. The `@ApplicationScoped`
    annotation means only one instance exists per cloud-native application. The dependency
    injection is specified via the `@Inject` annotation, which is defined in the Jakarta
    injection specification.'
  prefs: []
  type: TYPE_NORMAL
- en: JAX-RS – Jakarta RESTful Web Services
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '`@Path`, `@GET`, `@PUT`, `@POST`, `DELETE`, `@Produces`, and `@Consumes`. Let''s
    look at these instances individually:'
  prefs: []
  type: TYPE_NORMAL
- en: '`@Path` specifies the relative path for a resource or a method.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@GET`, `@PUT`, `@POST`, and `@DELETE` specify the HTTP request type.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@Produces` specifies the response media type, such as `MediaType.APPLICATION_JSON`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@Consumes` specifies the accepted media type.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following is an example of a JAX-RS service. It declares a `GET` operation
    with the endpoint, such as `http://localhost:9080/system/properties`. When this
    URL is invoked, the system properties will be returned. Since `@Produces` specifies
    the `MediaType.APPLICATION_JSON` format, the payload format will be in a format
    called **JavaScript Object Notation** (**JSON**):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s take a look at the four commented lines in this code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: The `@ApplicationScoped` annotation, defined in the CDI, states that the life
    cycle of the `PropertyController` resource is singular, with only one instance
    existing per application.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `@Path` annotation specifies the relative path to the `PropertyController`
    resource to be `/properties`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `@GET` annotation indicates the JAX-RS operation type.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `@Produces(MediaType.APPLICATION_JSON)` annotation mandates the payload
    to be in JSON format.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: By now, you should have a basic understanding of JAX-RS. In the next section,
    we will take a look at how to connect RESTful services using MicroProfile Rest
    Client.
  prefs: []
  type: TYPE_NORMAL
- en: MicroProfile Rest Client
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '`@RegisterRestClient` to declare a type-safe interface, as shown in the following
    code snippet.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example defines the type-safe interface for the JAX-RS operation,
    `PropertyController.getProperties()`, as shown in the previous section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s take a look at the four commented lines in this code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: The `@RegisterRestClient` annotation registers the `PropertiesClient` interface
    as a RESTful client.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `@GET` annotation indicates that the `getProperties()` method is a `GET`
    operation.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `@Produces(MediaType.APPLICATION_JSON)` annotation specifies the payload
    format as a JSON format.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `@Path` annotation declares the relative path to the `getProperties()` operation.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The type-safe clients support both CDI and programmatic lookup. The following
    code snippet demonstrates how to use CDI to inject the `PropertiesClient` RESTful
    client and then invoke its `getProperties()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s take a look at the two commented lines in this code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: The `@Inject` (defined by `@RestClient` (a CDI qualifier defined by `PropertiesClient`
    into the `propertiesClient` variable.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Call the backend operation, `getProperties()`, which is `PropertyController.getProperties()`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Alternatively, you can use the `RestClientBuilder` programmatic API to get hold
    of the client, which will be discussed in [*Chapter 4*](B17377_04_Final_SB_epub.xhtml#_idTextAnchor068),
    *Developing Cloud-Native Applications*.
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding example, the response from the JAX-RS service is in JSON format,
    the most popular response format. We will look at JSON in the next section in
    terms of how to convert to, and from, an object to a JSON object.
  prefs: []
  type: TYPE_NORMAL
- en: JSON-B and JSON-P
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'JSON is the prominent format for transmitting data in cloud-native applications.
    JSON supports two data structures: **objects** and **arrays**. The objects are
    sets of key-value pairs, enclosed by curly brackets, while arrays collect these
    objects into a set.'
  prefs: []
  type: TYPE_NORMAL
- en: Both **JSON-B** ([https://github.com/eclipse-ee4j/jsonb-api](https://github.com/eclipse-ee4j/jsonb-api))
    and **JSON-P** ([https://github.com/eclipse-ee4j/jsonp](https://github.com/eclipse-ee4j/jsonp))
    are Jakarta EE API specifications that convert POJOs to and from JSON data. The
    first version of JSON-P was released a few years before JSON-B. JSON-P provides
    both streaming and data models for JSON processing.
  prefs: []
  type: TYPE_NORMAL
- en: JSON-B provides a mechanism for converting Java objects to/from JSON messages.
    It provides several methods to serialize/desterilize a Java object to/from JSON.
    JSON-B provides a higher-level API than JSON-P. JSON-B works well with JAX-RS
    and JAX-RS 2.1 mandates the use of JSON-B to automatically convert the returned
    object to JSON data in the HTTP response.
  prefs: []
  type: TYPE_NORMAL
- en: Technologies for enhancing cloud-native applications
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: After building cloud-native applications, the job is not done yet, unfortunately.
    You will need to think about how to improve the application. The next task is
    to improve its reliability and maintainability. Do you want to freely change its
    config value without recompiling your applications, for example, the port number?
    Do you want your application to be resilient, functioning all the time no matter
    what? Do you want your application to be secure, which means unauthorized requests
    are not permitted? Do you need help to work out what your applications are doing
    when you have got tens or hundreds of applications?
  prefs: []
  type: TYPE_NORMAL
- en: 'If the answer to any of the aforementioned questions is *yes*, you will need
    to add some essential **Quality of Services**(**QoS**) , which includes the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Configuration
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Resilience
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Security
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Documentation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**MicroProfile Config** provides a way to configure applications without the
    need for redeployment. **MicroProfile Fault Tolerance** makes the application
    more resilient. **MicroProfile JWT Authentication** secures applications in a
    portable and simple way, while **MicroProfile Open API** is used to document applications.
    Next, we will provide a quick overview of these technologies, and we will go deeper
    into each of them in [*Chapter 5*](B17377_05_Final_SB_epub.xhtml#_idTextAnchor091),
    *Enhancing Cloud-Native Applications*.'
  prefs: []
  type: TYPE_NORMAL
- en: MicroProfile Config
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '**MicroProfile Config** ([https://github.com/eclipse/microprofile-config](https://github.com/eclipse/microprofile-config))
    defines an easy and flexible system to retrieve application configurations. The
    configurations are defined in config sources, which can be supplied by applications.
    There are two ways to retrieve configuration: **CDI** or **programmatic lookup**.
    Let''s look at each of these in turn:'
  prefs: []
  type: TYPE_NORMAL
- en: '`"customer.name"`, the following code snippet can be used to retrieve its value:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`customer.name` can also be looked up programmatically via the following APIs:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The property defined in the `microprofile-config.properites` file on the classpath,
    environment variable, and system properties is available to the cloud-native applications
    automatically. This means that MicroProfile Config can also access the values
    of fields from Kubernetes `ConfigMaps` or `Secrets` that are mapped to the Pod
    as environment variables. The following code snippet demonstrates the `customer.name`
    property defined in `microprofile-config.properties`, in the format of a Java
    property file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: MicroProfile Config enables the externalization of the configuration. The configuration
    stored in the environment can be accessed by the cloud-native applications via
    the Config APIs. This specification fulfills the third factor, **Configuration**,
    in **Twelve-Factor App**, as mentioned in [*Chapter 1*](B17377_01_Final_SB_epub.xhtml#_idTextAnchor021),
    *Cloud-Native Application*. You have learned how to configure your application.
    Next, we will briefly discuss how to make your application resilient using MicroProfile
    Fault Tolerance.
  prefs: []
  type: TYPE_NORMAL
- en: MicroProfile Fault Tolerance
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '**MicroProfile Fault Tolerance** ([https://github.com/eclipse/microprofile-fault-tolerance/](https://github.com/eclipse/microprofile-fault-tolerance/))
    defines a set of annotations for making cloud-native applications resilient. These
    annotations are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`@Retry`: Recovers from a brief network glitch. This allows you to define how
    many times the retry can be performed, what exceptions can trigger the retry,
    the time duration for the retries, and so on.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@Timeout`: Defines the maximum allowed response time. This is used for time-critical
    operations. It defines the maximum time duration for the corresponding operation
    to respond.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@CircuitBreaker`: Fails fast and avoids the repeatable indefinite wait or
    timeout. You can specify the rolling window for a circuit to be checked, the failure
    ratio for the circuit to open, the exceptions that the circuit breaker considers
    or ignores, and so on.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@Bulkhead`: Isolates failures and avoids bringing the whole system down. There
    are two types of bulkhead. When this annotation is used together with the `@Asynchronous`
    annotation, this means **thread isolation**, which means the method with this
    annotation will be executed on a child thread. Otherwise, it means **semaphore
    isolation**, which means the method will be executed on the parent thread.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@Fallback`: Provides an alternative solution for a failed execution. You should
    always use this annotation to ensure a resilient cloud-native application to respond
    to all kinds of situations. This annotation provides an alternative operation
    if the original method returns an exception.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The aforementioned annotations can be used together, which improves the resilience
    of your cloud-native applications. Once your application is configurable and resilient,
    the next step is to think about how to prevent sensitive information from being
    obtained by irrelevant parties. This is where MicroProfile JWT Propagation comes
    into play.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: MicroProfile JWT Propagation
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '`@RolesAllowed`, to secure JAX-RS endpoints.'
  prefs: []
  type: TYPE_NORMAL
- en: 'MicroProfile JWT Propagation establishes a way to pass in the user info to
    the backend so that the backend can determine whether the invocation is allowed.
    MicroProfile JWT Propagation is built on top of a JWT with a couple of additional
    claims: `JsonWebToken`, which extends the `java.security.Principal` interface.
    This API makes a set of claims available via getter accessors.'
  prefs: []
  type: TYPE_NORMAL
- en: 'JAX-RS applications can access `JsonWebToken` from the `SecurityContext` annotation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, it can also be injected:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: MicroProfile JWT Authentication also ensures single sign-on and the runtime
    will automatically reject the requests with insufficient **access rights** or
    a lack of the appropriate claims. Once your application is configurable, resilient,
    and secure, you then need to think about how to document your application. You
    can document your application using MicroProfile OpenAPI.
  prefs: []
  type: TYPE_NORMAL
- en: MicroProfile OpenAPI
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '`http://myHost:myPort/openapi`, as a `GET` operation. Some MicroProfile Open
    API implementations such as Open Liberty ([https://openliberty.io/](https://openliberty.io/))
    also provide the Swagger UI integration and exposes the endpoint, `http://myHost:myPort/openapi/ui`,
    which allows the endpoints to be tested out.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: MicroProfile OpenAPI produces a set of Java interfaces and annotations that
    allow Java developers to produce OpenAPI v3 documents from their JAX-RS. MicroProfile
    OpenAPI was heavily influenced by OpenAPI v3, but they are not the same.
  prefs: []
  type: TYPE_NORMAL
- en: As a cloud-native developer, your job is nearly done. You could deploy your
    application to the cloud. If everything goes well, you will have an easy job.
    However, if something goes wrong, you might have a difficult time figuring out
    where the problem lies. In order to help with service, you will need to learn
    about the technologies for observing and monitoring your applications. Read along
    to find out what you can do to help with serviceability.
  prefs: []
  type: TYPE_NORMAL
- en: Technologies for observing and monitoring cloud-native applications
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Upon completing the development of cloud-native applications, the next stage
    is **day 2 operation**, where monitoring, maintenance, and troubleshooting come
    into play. **MicroProfile Health**, **MicroProfile Metrics**, and **MicroProfile
    Open Tracing** provide support in these areas. Next is a quick overview of these
    technologies to give you a basic understanding of how these technologies work
    together to help with day 2 operation. [*Chapter 6*](B17377_06_Final_SB_epub.xhtml#_idTextAnchor123),
    *Observing and Monitoring Cloud-Native Applications*, will cover this in more
    detail.
  prefs: []
  type: TYPE_NORMAL
- en: MicroProfile Health
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '`@Readiness` and `@Liveness` annotations, accordingly. The `@Readiness` annotation
    is applied to a `HealthCheck` implementation to define a readiness check procedure,
    while `@Liveness` is applied to a liveness check procedure. The response of the
    `HealthCheck` procedure can be either *UP* or *DOWN*.'
  prefs: []
  type: TYPE_NORMAL
- en: The response of the readiness check determines whether the cloud-native application
    is ready to serve requests. If the response is *UP*, the cloud infrastructure,
    such as **Kubernetes**, will route requests to the Pod it lives in. If the response
    is *DOWN*, Kubernetes will not route requests to the Pod. The response of the
    liveness check means whether the cloud-native application is still alive. With
    a response of *DOWN*, Kubernetes will destroy the Pod that the cloud-native application
    lives in and start a new one.
  prefs: []
  type: TYPE_NORMAL
- en: MicroProfile Health defines the `http://myHost:myPort/health/ready` and `http://myHost:myPort/health/live`
    endpoints to be exposed by its implementations to represent the status of readiness
    and liveness of the entire runtime accordingly, which can be used for Kubernetes
    readiness and liveness checks.
  prefs: []
  type: TYPE_NORMAL
- en: MicroProfile Metrics
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '`http://myHost:myPort/metrics/base`, `http://` `myHost:myPort/metrics/vendor`,
    and `http://myHost:myPort/metrics/application`. The endpoint of `http://myHost:myPort/metrics`
    lists the aggregation of all three scopes of the metrics. The data exposed via
    REST over HTTP can be in JSON format or **OpenMetrics** text format, which can
    be consumed by the monitoring tools such as **Prometheus** so that the metrics
    can be represented as a graph in a dashboard.'
  prefs: []
  type: TYPE_NORMAL
- en: MicroProfile OpenTracing
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '`SpanContext` information into any outgoing JAX-RS request and then start a
    span for any outgoing JAX-RS request and finish the `Span` when the request completes.
    MicroProfile OpenTracing adopts `io.opentracing.Tracer` available to each application.'
  prefs: []
  type: TYPE_NORMAL
- en: MicroProfile OpenTracing exposes the trace spans that tracing tools such as
    **Jaeger** or **Zipkin** can use to gather the data and graph them in a dashboard.
  prefs: []
  type: TYPE_NORMAL
- en: You have learned the essential specifications from MicroProfile. However, there
    are some extra specifications following standalone releases. Let's look at these
    to see whether you could use some of them in your applications.
  prefs: []
  type: TYPE_NORMAL
- en: Standalone releases
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'From 2018, a few more MicroProfile specifications were released: **MicroProfile
    Reactive Streams Operators**, **MicroProfile Messaging**, **MicroProfile Context
    Propagation**, and **MicroProfile GraphQL**.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The MicroProfile community would like to get more feedback before merging these
    specifications into the umbrella release. As a consequence, they remain as standalone
    specifications. [*Chapter 10*](B17377_10_Final_SB_epub.xhtml#_idTextAnchor187),
    *Reactive Cloud-Native Applications*, and [*Chapter 11*](B17377_11_Final_SB_epub.xhtml#_idTextAnchor202),
    *MicroProfile GraphQL*, will discuss these specifications in more detail. For
    now, let''s have an overview of each:'
  prefs: []
  type: TYPE_NORMAL
- en: '`map`, `filter`, and `flatMap`. It also provides APIs to be used by MicroProfile
    Messaging.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@Incoming` for consuming messages and `@Outgoing` for publishing messages.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CompletionStage`, `CompletableFuture`, and `Function`, to work better in cloud-native
    applications with some associated contexts. MicroProfile Context Propagation enables
    asynchronous programming to be context-aware because the new threads can inherit
    some contexts from parent threads, such as `Security Context`, `CDI Context`,
    `Application Context`, `Transaction Context`, and other applications defined in
    `ThreadContext`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@Query` and `@Mutuation`, for building GraphQL queries and mutations, accordingly.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: So far, we have learned about all the MicroProfile specifications in short order.
    If you don't understand some of them, don't worry as we will cover them in more
    depth in the following chapters.
  prefs: []
  type: TYPE_NORMAL
- en: You might now be wondering how to create a cloud-native application using MicroProfile,
    and whether there are any tools to help with creating a cloud-native application.
    We will cover this in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: MicroProfile Starter
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**MicroProfile Starter** ([https://start.microprofile.io/](https://start.microprofile.io/))
    is a code generator for developing cloud-native applications using MicroProfile.
    This tool can be accessed via the web, command line, or IDE plugins. In this section,
    we will learn about the MicroProfile Starter tool for creating cloud-native applications.'
  prefs: []
  type: TYPE_NORMAL
- en: Accessing MicroProfile Starter via the web
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following screenshot shows the **User Interface** of MicroProfile Starter,
    which can be used to create cloud-native applications and then download the ZIP:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.2 – MicroProfile Starter UI'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17377_02_02_new.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.2 – MicroProfile Starter UI
  prefs: []
  type: TYPE_NORMAL
- en: 'In the preceding UI, we can specify the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**groupId**: The generated application''s Maven group ID.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**artifactId**: The generated application''s Maven artifact ID.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**MicroProfile Version**: The version of the MicroProfile release.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**MicroProfile Runtime**: The selected runtime that supports the chosen MicroProfile
    release version. In *Figure 2.2*, MicroProfile version 3.3 is selected, and then
    three runtimes that implement MicroProfile version 3.3 are displayed: **Open Liberty**,
    **Wildfly**, and **Payara Micro**.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Java SE Version**: Once we have chosen our favorite runtime, we can then
    choose the Java SE version. If a runtime supports multiple Java SE, we can then
    select which Java SE version you want. For example, Open Liberty supports both
    Java SE 8 and Java SE 11\. Once we have selected Open Liberty, we can then choose
    either Java SE 8 or Java SE 11.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Examples for specifications**: The MicroProfile specifications that the generated
    applications are going to use. Clicking on the checkbox will select the corresponding
    MicroProfile specifications and the code sample will include the chosen MicroProfile
    specifications. If TypeSafe Rest Client or JWT Auth is selected, two cloud-native
    applications will be generated to demonstrate the client-server architecture.
    If you want to create a MicroProfile application from scratch, you don''t need
    to choose any of the checkboxes. In this case, you will have the structure set
    up and you can write your business code straightaway.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Accessing MicroProfile Starter via the command line
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: MicroProfile Starter has command-line support, which is useful if you want to
    automatically generate cloud-native applications on the command line or as part
    of the automation process.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can find all information via the following command, where the output displays
    all of the supported features with the corresponding commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: In the output from the aforementioned command, you can find further commands
    to use for creating a specific cloud-native application for a chosen runtime,
    MicroProfile version, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: Accessing MicroProfile Starter via an IDE plugin
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: MicroProfile Starter can also be accessed via IDE plugins, namely, the **Visual
    Studio Code MicroProfile extension pack** or **Intellij IDEA MicroProfile plugin**,
    which we will look at now.
  prefs: []
  type: TYPE_NORMAL
- en: Visual Studio Code plugin
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The **Visual Studio Code Extension Pack for MicroProfile** ([https://marketplace.visualstudio.com/items?itemName=MicroProfile-Community.vscode-microprofile-pack](https://marketplace.visualstudio.com/items?itemName=MicroProfile-Community.vscode-microprofile-pack))
    can be downloaded and installed onto Visual Studio Code ([https://code.visualstudio.com](https://code.visualstudio.com)).
  prefs: []
  type: TYPE_NORMAL
- en: This extension pack also includes **Language Server Support for MicroProfile**,
    **Open Liberty Tools**, **Quarkus**, and **Payara Tools**.
  prefs: []
  type: TYPE_NORMAL
- en: IntelliJ IDEA plugin
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**IntelliJ IDEA** ([https://www.jetbrains.com/idea/](https://www.jetbrains.com/idea/))
    offers a MicroProfile Starter plugin ([https://plugins.jetbrains.com/plugin/13386-microprofile-starter](https://plugins.jetbrains.com/plugin/13386-microprofile-starter))
    for you to access MicroProfile Starter directly from the Intellij IDE. You can
    simply install the plugin and start using MicroProfile Starter. When using the
    plugin, you can input the same fields as shown in *Figure 2.2*, and then an application
    will be created.'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have learned all of the MicroProfile specifications and
    discussed how they can help with creating cloud-native applications. We then added
    various QoS, such as configuration, resilience, security, and monitoring. With
    this, you will have a basic idea of how to design your cloud-native application
    with best practices to make it secure, configurable, resilient, intelligent, and
    monitorable. In the chapters to follow, we will learn these technologies in more
    depth.
  prefs: []
  type: TYPE_NORMAL
- en: Furthermore, after going through the MicroProfile specifications, we then introduced
    MicroProfile Starter, a tool to develop cloud-native applications. This tool can
    be accessed via the web, command line, Visual Studio plugin, or IntelliJ IDEA
    plugin. You will be able to use these tools to create your cloud-native applications
    from scratch.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will introduce a real-world, cloud-native application
    that utilizes MicroProfile technologies to solve some common problems, and we
    will also learn how MicroProfile helps with the challenges posed by real-world
    use cases.
  prefs: []
  type: TYPE_NORMAL
