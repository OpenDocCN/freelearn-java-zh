- en: '*Chapter 2*: How Does MicroProfile Fit into Cloud-Native Application Development?'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第二章*：MicroProfile 如何融入云原生应用开发？'
- en: This chapter provides you with an overview of **MicroProfile** and describes
    the specifications of MicroProfile in terms of fulfilling the requirements of
    cloud-native applications. In this chapter, we first look at the history of MicroProfile
    concerning why it was created and for what purpose, and then we will explore the
    content of MicroProfile. This will give you a high-level understanding of each
    MicroProfile specification so that you will understand how MicroProfile fits into
    cloud-native application development and why you should adopt MicroProfile technologies.
    Finally, we will look at the MicroProfile code generator, **MicroProfile Starter**,
    focusing on how to create cloud-native applications. This is useful because it
    will help you get started with MicroProfile from scratch.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章为您提供了 MicroProfile 的概述，并从满足云原生应用需求的角度描述了 MicroProfile 的规范。在本章中，我们首先回顾 MicroProfile
    的历史，探讨其创建的原因和目的，然后我们将探讨 MicroProfile 的内容。这将使您对每个 MicroProfile 规范有一个高层次的理解，以便您了解
    MicroProfile 如何融入云原生应用开发，以及为什么您应该采用 MicroProfile 技术。最后，我们将关注 MicroProfile 代码生成器，即
    **MicroProfile Starter**，重点介绍如何创建云原生应用。这很有用，因为它将帮助您从头开始使用 MicroProfile。
- en: 'We will cover the following topics in this chapter:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: MicroProfile overview
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: MicroProfile 概述
- en: MicroProfile specifications
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: MicroProfile 规范
- en: MicroProfile Starter
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: MicroProfile Starter
- en: MicroProfile overview
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: MicroProfile 概述
- en: 'Let''s start by reflecting on the history of MicroProfile, why it was set up,
    and how it progressed and established its working group. In this section, we look
    at two different sub-topics: the *history of MicroProfile* and the *characteristics
    of MicroProfile*. We''ll begin by looking at the history. It is important to understand
    the release cycle and what is included in various MicroProfile releases so that
    we can choose which version to use, and that we have a sense of how fast MicroProfile
    releases new versions.'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先回顾 MicroProfile 的历史，探讨其成立的原因和进展，以及如何建立其工作组。在本节中，我们将探讨两个不同的子主题：*MicroProfile
    的历史*和*MicroProfile 的特点*。我们将从历史开始。了解发布周期和各个 MicroProfile 版本包含的内容非常重要，这样我们才能选择使用哪个版本，并了解
    MicroProfile 发布新版本的频率。
- en: History of MicroProfile
  id: totrans-8
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: MicroProfile 历史
- en: Seeing the slowly advancing pace of Java EE, a few major industry players, including
    IBM, Red Hat, Payara, Tomitribe, and others, got together in 2016 to discuss how
    to make server-side Java frameworks move faster and to address the new challenges
    associated with the new microservice space. As a result of this collaboration,
    MicroProfile was born in the fall of 2016\. It was designed to help Java developers
    develop cloud-native applications without needing to learn new languages.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 看到 Java EE 发展的缓慢步伐，包括 IBM、Red Hat、Payara、Tomitribe 等在内的几家主要行业参与者于 2016 年聚在一起，讨论如何使服务器端
    Java 框架发展更快，并解决与新兴微服务空间相关的新挑战。作为这次合作的结果，MicroProfile 于 2016 年秋季诞生。它旨在帮助 Java 开发者开发云原生应用，而无需学习新语言。
- en: 'MicroProfile 1.0 was announced in September 2016 at JavaOne. This first release
    of MicroProfile 1.0 consisted of CDI, JSON-P, and JAX-RS. In December 2016, MicroProfile
    joined the Eclipse Foundation under the Apache License v2.0 (Alv2.0). MicroProfile
    1.1 was released in August 2017 and included the first new MicroProfile specification,
    MicroProfile Config 1.0\. From 2017 to 2019, MicroProfile did three releases per
    year: in February, June, and October.'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: MicroProfile 1.0 于 2016 年 9 月在 JavaOne 上宣布发布。MicroProfile 1.0 的首个版本包括 CDI、JSON-P
    和 JAX-RS。2016 年 12 月，MicroProfile 在 Apache License v2.0 (Alv2.0) 许可下加入了 Eclipse
    基金会。MicroProfile 1.1 于 2017 年 8 月发布，并包括了第一个新的 MicroProfile 规范，即 MicroProfile Config
    1.0。从 2017 年到 2019 年，MicroProfile 每年发布三次：2 月、6 月和 10 月。
- en: In 2020, following the release of MicroProfile 3.3, MicroProfile was requested
    by Eclipse Foundation to set up its working group before any further major or
    minor releases could be performed. It took nearly 1 year for the community to
    decide whether to set up its own working group or merge with the Jakarta EE working
    group. Eventually, IBM, Red Hat, and Tomitribe decided to pursue a separate working
    group. With the working group requirement of a minimum of 5 corporate members,
    it took the community some time to acquire 2 more corporate members. In October,
    **Atlanta Java User Group** (**AJUG**) and Jelastic joined forces with IBM, Red
    Hat, and Tomitribe to form the MicroProfile working group. Finally, in October
    2020, the working group charter was approved. Soon afterward, Payara, Oracle,
    Fujitsu, Garden State JUG, and iJUG joined the MicroProfile working group.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 2020 年，在 MicroProfile 3.3 版本发布之后，Eclipse 基金会要求 MicroProfile 在进行任何进一步的重大或小版本发布之前，先设立其工作组。社区为此花费了近一年的时间来决定是设立自己的工作组还是与
    Jakarta EE 工作组合并。最终，IBM、Red Hat 和 Tomitribe 决定成立一个独立的工作组。由于工作组要求至少有 5 家企业成员，社区花了些时间才获得另外
    2 家企业成员的支持。10 月份，**亚特兰大 Java 用户组**（**AJUG**）和 Jelastic 与 IBM、Red Hat 和 Tomitribe
    联合，成立了 MicroProfile 工作组。最终，在 2020 年 10 月，工作组章程获得批准。不久之后，Payara、Oracle、富士通、Garden
    State JUG 和 iJUG 也加入了 MicroProfile 工作组。
- en: 'After the MicroProfile working group was established in October 2020, the MicroProfile
    community immediately prepared the MicroProfile 4.0 release using the newly established
    release process. On 23 December, MicroProfile 4.0 was released. The latest MicroProfile
    version 4.1 got released recently in July 2021\. Here is the timeline for MicroProfile
    releases:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 2020 年 10 月 MicroProfile 工作组成立后，MicroProfile 社区立即开始准备使用新建立的发布流程发布 MicroProfile
    4.0 版本。12 月 23 日，MicroProfile 4.0 版本发布。最新的 MicroProfile 版本 4.1 于 2021 年 7 月最近发布。以下是
    MicroProfile 发布的时间线：
- en: '![Figure 2.1 – MicroProfile release timeline'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 2.1 – MicroProfile 发布时间线'
- en: '](img/B17377_02_01.jpg)'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17377_02_01.jpg)'
- en: Figure 2.1 – MicroProfile release timeline
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.1 – MicroProfile 发布时间线
- en: As you can see from *Figure* *2.1*, MicroProfile has a fast release cadence.
    As well as this, MicroProfile has other identifying characteristics. In the next
    section, we will look at them.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 如您从 *图* *2.1* 中所见，MicroProfile 具有快速的发布节奏。此外，MicroProfile 还有其他识别特征。在下一节中，我们将探讨它们。
- en: Characteristics of MicroProfile
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: MicroProfile 的特点
- en: 'MicroProfile grew very quickly thanks to its unique characteristics of openness
    and diversity. These are detailed as follows:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: MicroProfile 由于其开放性和多样性等独特特性而迅速发展。具体如下：
- en: 'Openness and transparency: MicroProfile is open to the public in terms of meetings,
    projects, contributions, and suchlike. There is no hierarchy, and everyone has
    the same right to voice their opinions. No one has a veto right.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开放性和透明度：MicroProfile 在会议、项目、贡献等方面对公众开放。没有等级制度，每个人都有权表达自己的观点。没有人有否决权。
- en: 'Diversity: The community is diverse. Its contributors are made up of many major
    players, including IBM, Red Hat, Tomitribe, Payara, Java User Groups, and other
    individuals and groups. Everyone is welcome to join MicroProfile and voice their
    opinion. The way to join the conversation is via the MicroProfile Google group,
    accessible via **Join the Discussion** on [microprofile.io](http://microprofile.io).'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 多样性：社区是多元化的。其贡献者包括 IBM、Red Hat、Tomitribe、Payara、Java 用户组以及其他个人和团体。每个人都欢迎加入 MicroProfile
    并表达自己的观点。加入对话的方式是通过 MicroProfile Google 群组，可通过 [microprofile.io](http://microprofile.io)
    上的 **加入讨论** 访问。
- en: 'Many runtime implementations: MicroProfile evolves APIs, specifications, and
    **Technology Compatibility Kits** (**TCKs**). It only creates APIs, but it does
    not include implementations. However, there is no lack of implementations. There
    are around a dozen implementations, as follows:'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 许多运行时实现：MicroProfile 发展 API、规范和**技术兼容性工具包**（**TCK**）。它只创建 API，但不包括实现。然而，并不缺少实现。大约有十几种实现，如下所示：
- en: a) Open Liberty ([https://openliberty.io/](https://openliberty.io/))
  id: totrans-22
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: a) Open Liberty ([https://openliberty.io/](https://openliberty.io/))
- en: b) WebSphere Liberty ([https://www.ibm.com/uk-en/cloud/websphere-liberty](https://www.ibm.com/uk-en/cloud/websphere-liberty))
  id: totrans-23
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: b) WebSphere Liberty ([https://www.ibm.com/uk-en/cloud/websphere-liberty](https://www.ibm.com/uk-en/cloud/websphere-liberty))
- en: c) Quarkus ([https://quarkus.io/](https://quarkus.io/))
  id: totrans-24
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: c) Quarkus ([https://quarkus.io/](https://quarkus.io/))
- en: d) Wildfly ([https://www.wildfly.org/](https://www.wildfly.org/))
  id: totrans-25
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: d) Wildfly ([https://www.wildfly.org/](https://www.wildfly.org/))
- en: e) Payara ([https://www.payara.fish/](https://www.payara.fish/))
  id: totrans-26
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: e) Payara ([https://www.payara.fish/](https://www.payara.fish/))
- en: f) TomEE ([https://tomee.apache.org/](https://tomee.apache.org/))
  id: totrans-27
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: f) TomEE ([https://tomee.apache.org/](https://tomee.apache.org/))
- en: g) Helidon ([https://helidon.io](https://helidon.io))
  id: totrans-28
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: g) Helidon ([https://helidon.io](https://helidon.io))
- en: h) Launcher ([https://github.com/fujitsu/launcher](https://github.com/fujitsu/launcher))
  id: totrans-29
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: h) Launcher ([https://github.com/fujitsu/launcher](https://github.com/fujitsu/launcher))
- en: i) KumuluzEE ([https://ee.kumuluz.com/](https://ee.kumuluz.com/))
  id: totrans-30
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: i) KumuluzEE ([https://ee.kumuluz.com/](https://ee.kumuluz.com/))
- en: j) Piranha Cloud ([https://piranha.cloud/](https://piranha.cloud/))
  id: totrans-31
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: j) Piranha Cloud ([https://piranha.cloud/](https://piranha.cloud/))
- en: k) Apache Geronimo ([https://geronimo.apache.org/](https://geronimo.apache.org/))
  id: totrans-32
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: k) Apache Geronimo ([https://geronimo.apache.org/](https://geronimo.apache.org/))
- en: 'Lightweight, iterative processes: MicroProfile establishes a pattern that moves
    fast and adopts an iterative process. It adapts to changes, allows breaking changes
    between releases, and adopts a semantic versioning policy, which means a major
    version release containing breaking changes. However, MicroProfile tries to minimize
    the number of breaking changes. When there are breaking changes, the changes must
    be clearly documented in the release notes of the corresponding specifications.'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 轻量级、迭代的过程：MicroProfile建立了一种快速移动并采用迭代过程的模式。它适应变化，允许在版本之间进行破坏性更改，并采用语义版本控制策略，这意味着包含破坏性更改的主要版本发布。然而，MicroProfile试图最小化破坏性更改的数量。当有破坏性更改时，这些更改必须在相应规范的发布说明中进行明确记录。
- en: Due to the aforementioned characteristics of MicroProfile, its adoption rate
    increased rapidly. As a result, more and more companies started investing in MicroProfile
    technologies. MicroProfile is now seen as the standard for developing cloud-native
    applications. We will take a closer look at each individual MicroProfile specification
    in the next section.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 由于MicroProfile的上述特性，其采用率迅速增长。因此，越来越多的公司开始投资MicroProfile技术。现在，MicroProfile被视为开发云原生应用的标准。在下一节中，我们将更详细地查看每个单独的MicroProfile规范。
- en: MicroProfile specifications
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: MicroProfile规范
- en: At this point, you might be wondering what MicroProfile consists of. As you
    may know, MicroProfile evolves **Application Programming Interfaces** (**APIs**)
    in terms of developing cloud-native applications. MicroProfile has several specifications
    that offer various capabilities for cloud-native applications. As a cloud-native
    application developer, it's important to understand these.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，你可能想知道MicroProfile包含哪些内容。正如你可能知道的，MicroProfile在开发云原生应用方面不断演进**应用程序编程接口**（**APIs**）。MicroProfile有几个规范，为云原生应用提供了各种功能。作为一名云原生应用开发者，了解这些是非常重要的。
- en: 'The MicroProfile 4.0 release includes four specifications from Jakarta EE 8
    and eight MicroProfile specifications, as follows:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: MicroProfile 4.0版本包括来自Jakarta EE 8的四个规范和八个MicroProfile规范，如下所示：
- en: '**Jakarta EE specifications**:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '**Jakarta EE规范**：'
- en: Jakarta Contexts and Dependency Injection (CDI) 2.0
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Jakarta上下文和依赖注入（CDI）2.0
- en: Jakarta RESTful Web Services (JAX-RS) 2.1
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Jakarta RESTful Web服务（JAX-RS）2.1
- en: Jakarta JSON Binding 1.0
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Jakarta JSON绑定 1.0
- en: Jakarta JSON Processing 1.1
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Jakarta JSON处理 1.1
- en: '**MicroProfile specifications**:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '**MicroProfile规范**：'
- en: MicroProfile Config 2.0
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: MicroProfile配置 2.0
- en: MicroProfile Fault Tolerance 3.0
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: MicroProfile容错 3.0
- en: MicroProfile Health 3.0
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: MicroProfile健康 3.0
- en: MicroProfile JWT Propagation 1.2
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: MicroProfile JWT传播 1.2
- en: MicroProfile Metrics 3.0
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: MicroProfile度量 3.0
- en: MicroProfile OpenAPI 2.0
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: MicroProfile OpenAPI 2.0
- en: MicroProfile OpenTracing 2.0
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: MicroProfile OpenTracing 2.0
- en: MicroProfile Rest Client 2.0
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: MicroProfile Rest客户端 2.0
- en: MicroProfile specifications are grouped under different release categories.
    MicroProfile has the concept of **platform** **release** and **standalone** **release**.
    In this section, we will cover both concepts in detail.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: MicroProfile规范根据不同的发布类别进行分组。MicroProfile有**平台**发布和**独立**发布的概念。在本节中，我们将详细介绍这两个概念。
- en: Platform release
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 平台发布
- en: 'The platform release consists of 12 specifications, 4 of them being from Jakarta
    EE. These specifications can be divided into three subgroups (three layers) based
    on their usage:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 平台发布包括12个规范，其中4个来自Jakarta EE。根据它们的用途，这些规范可以分为三个子组（三个层次）：
- en: '**Building cloud-native applications**: CDI, JAX-RS, Rest Client, JSON-B, and
    JSON-P'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**构建云原生应用**：CDI、JAX-RS、Rest客户端、JSON-B和JSON-P'
- en: '**Enhancing cloud-native applications**: Open API, Fault Tolerance, JWT Propagation,
    and Config'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**增强云原生应用**：Open API、容错、JWT传播和配置'
- en: '**Observing and monitoring cloud-native applications**: Open Tracing, Health,
    and Metrics'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**观察和监控云原生应用**：Open Tracing、健康和度量'
- en: Let's explore each of these groups in turn.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们依次探索这些组。
- en: Technologies for developing cloud-native applications
  id: totrans-59
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 开发云原生应用的技术
- en: '**Cloud-native applications** can be developed using **CDI**, **JAX-RS**, **JSON-B**,
    or **JSON-P**. MicroProfile Rest Client is used for connecting cloud-native applications.
    Coming up next is a quick overview of these technologies. [*Chapter 4*](B17377_04_Final_SB_epub.xhtml#_idTextAnchor068),
    *Developing Cloud-Native Applications*, will explain them in more detail.'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '**云原生应用程序**可以使用 **CDI**、**JAX-RS**、**JSON-B** 或 **JSON-P** 来开发。MicroProfile
    Rest Client 用于连接云原生应用程序。接下来是一个关于这些技术的快速概述。[*第 4 章*](B17377_04_Final_SB_epub.xhtml#_idTextAnchor068)，*开发云原生应用程序*，将更详细地解释它们。'
- en: CDI – Contexts and Dependency Injection
  id: totrans-61
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: CDI – Contexts and Dependency Injection
- en: '`@ApplicationScoped`, `@RequestScoped`, and `@Dependent`. The `@ApplicationScoped`
    annotation means only one instance exists per cloud-native application. The dependency
    injection is specified via the `@Inject` annotation, which is defined in the Jakarta
    injection specification.'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '`@ApplicationScoped`、`@RequestScoped` 和 `@Dependent`。`@ApplicationScoped` 注解意味着每个云原生应用程序只有一个实例。依赖注入通过
    `@Inject` 注解指定，该注解由 Jakarta 注入规范定义。'
- en: JAX-RS – Jakarta RESTful Web Services
  id: totrans-63
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: JAX-RS – Jakarta RESTful Web Services
- en: '`@Path`, `@GET`, `@PUT`, `@POST`, `DELETE`, `@Produces`, and `@Consumes`. Let''s
    look at these instances individually:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '`@Path`、`@GET`、`@PUT`、`@POST`、`DELETE`、`@Produces` 和 `@Consumes`。让我们逐个查看这些实例：'
- en: '`@Path` specifies the relative path for a resource or a method.'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@Path` 指定资源或方法的相对路径。'
- en: '`@GET`, `@PUT`, `@POST`, and `@DELETE` specify the HTTP request type.'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@GET`、`@PUT`、`@POST` 和 `@DELETE` 指定 HTTP 请求类型。'
- en: '`@Produces` specifies the response media type, such as `MediaType.APPLICATION_JSON`.'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@Produces` 指定响应媒体类型，例如 `MediaType.APPLICATION_JSON`。'
- en: '`@Consumes` specifies the accepted media type.'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@Consumes` 指定接受的媒体类型。'
- en: 'The following is an example of a JAX-RS service. It declares a `GET` operation
    with the endpoint, such as `http://localhost:9080/system/properties`. When this
    URL is invoked, the system properties will be returned. Since `@Produces` specifies
    the `MediaType.APPLICATION_JSON` format, the payload format will be in a format
    called **JavaScript Object Notation** (**JSON**):'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以下是一个 JAX-RS 服务的示例。它声明了一个带有端点的 `GET` 操作，例如 `http://localhost:9080/system/properties`。当调用此
    URL 时，将返回系统属性。由于 `@Produces` 指定了 `MediaType.APPLICATION_JSON` 格式，因此有效载荷格式将采用称为
    **JavaScript 对象表示法**（**JSON**）的格式：
- en: '[PRE0]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Let''s take a look at the four commented lines in this code snippet:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看这段代码中的四条注释行：
- en: The `@ApplicationScoped` annotation, defined in the CDI, states that the life
    cycle of the `PropertyController` resource is singular, with only one instance
    existing per application.
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`@ApplicationScoped` 注解，由 CDI 定义，表示 `PropertyController` 资源的生命周期是单一的，每个应用程序只有一个实例。'
- en: The `@Path` annotation specifies the relative path to the `PropertyController`
    resource to be `/properties`.
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`@Path` 注解指定了到 `PropertyController` 资源的相对路径，即为 `/properties`。'
- en: The `@GET` annotation indicates the JAX-RS operation type.
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`@GET` 注解表示 JAX-RS 操作类型。'
- en: The `@Produces(MediaType.APPLICATION_JSON)` annotation mandates the payload
    to be in JSON format.
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`@Produces(MediaType.APPLICATION_JSON)` 注解强制要求有效载荷以 JSON 格式。'
- en: By now, you should have a basic understanding of JAX-RS. In the next section,
    we will take a look at how to connect RESTful services using MicroProfile Rest
    Client.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 到现在为止，你应该对 JAX-RS 有了一个基本的了解。在下一节中，我们将探讨如何使用 MicroProfile Rest Client 连接 RESTful
    服务。
- en: MicroProfile Rest Client
  id: totrans-77
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: MicroProfile Rest Client
- en: '`@RegisterRestClient` to declare a type-safe interface, as shown in the following
    code snippet.'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '`@RegisterRestClient` 用于声明类型安全接口，如下面的代码片段所示。'
- en: 'The following example defines the type-safe interface for the JAX-RS operation,
    `PropertyController.getProperties()`, as shown in the previous section:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例定义了 JAX-RS 操作 `PropertyController.getProperties()` 的类型安全接口，如前节所示：
- en: '[PRE1]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Let''s take a look at the four commented lines in this code snippet:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看这段代码中的四条注释行：
- en: The `@RegisterRestClient` annotation registers the `PropertiesClient` interface
    as a RESTful client.
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`@RegisterRestClient` 注解将 `PropertiesClient` 接口注册为 RESTful 客户端。'
- en: The `@GET` annotation indicates that the `getProperties()` method is a `GET`
    operation.
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`@GET` 注解表示 `getProperties()` 方法是一个 `GET` 操作。'
- en: The `@Produces(MediaType.APPLICATION_JSON)` annotation specifies the payload
    format as a JSON format.
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`@Produces(MediaType.APPLICATION_JSON)` 注解指定了有效载荷格式为 JSON 格式。'
- en: The `@Path` annotation declares the relative path to the `getProperties()` operation.
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`@Path` 注解声明了 `getProperties()` 操作的相对路径。'
- en: 'The type-safe clients support both CDI and programmatic lookup. The following
    code snippet demonstrates how to use CDI to inject the `PropertiesClient` RESTful
    client and then invoke its `getProperties()` method:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 类型安全的客户端同时支持CDI和程序性查找。以下代码片段演示了如何使用CDI注入`PropertiesClient` RESTful客户端，然后调用其`getProperties()`方法：
- en: '[PRE2]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Let''s take a look at the two commented lines in this code snippet:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看这个代码片段中的两条注释行：
- en: The `@Inject` (defined by `@RestClient` (a CDI qualifier defined by `PropertiesClient`
    into the `propertiesClient` variable.
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`@Inject`（由`@RestClient`（由`PropertiesClient`定义的CDI限定符）注入到`propertiesClient`变量中。'
- en: Call the backend operation, `getProperties()`, which is `PropertyController.getProperties()`.
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用后端操作，`getProperties()`，即`PropertyController.getProperties()`。
- en: Alternatively, you can use the `RestClientBuilder` programmatic API to get hold
    of the client, which will be discussed in [*Chapter 4*](B17377_04_Final_SB_epub.xhtml#_idTextAnchor068),
    *Developing Cloud-Native Applications*.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，您可以使用`RestClientBuilder`程序性API来获取客户端，这将在[*第4章*](B17377_04_Final_SB_epub.xhtml#_idTextAnchor068)
    *开发云原生应用程序*中讨论。
- en: In the preceding example, the response from the JAX-RS service is in JSON format,
    the most popular response format. We will look at JSON in the next section in
    terms of how to convert to, and from, an object to a JSON object.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，JAX-RS服务的响应是JSON格式，这是最受欢迎的响应格式。我们将在下一节中讨论JSON，如何将其转换为对象，以及从对象转换为JSON对象。
- en: JSON-B and JSON-P
  id: totrans-93
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: JSON-B和JSON-P
- en: 'JSON is the prominent format for transmitting data in cloud-native applications.
    JSON supports two data structures: **objects** and **arrays**. The objects are
    sets of key-value pairs, enclosed by curly brackets, while arrays collect these
    objects into a set.'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: JSON是云原生应用程序中传输数据的主要格式。JSON支持两种数据结构：**对象**和**数组**。对象是一系列键值对，由大括号括起来，而数组将这些对象收集到一个集合中。
- en: Both **JSON-B** ([https://github.com/eclipse-ee4j/jsonb-api](https://github.com/eclipse-ee4j/jsonb-api))
    and **JSON-P** ([https://github.com/eclipse-ee4j/jsonp](https://github.com/eclipse-ee4j/jsonp))
    are Jakarta EE API specifications that convert POJOs to and from JSON data. The
    first version of JSON-P was released a few years before JSON-B. JSON-P provides
    both streaming and data models for JSON processing.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 两者**JSON-B**([https://github.com/eclipse-ee4j/jsonb-api](https://github.com/eclipse-ee4j/jsonb-api))和**JSON-P**([https://github.com/eclipse-ee4j/jsonp](https://github.com/eclipse-ee4j/jsonp))都是Jakarta
    EE API规范，用于将POJOs转换为JSON数据以及从JSON数据转换回POJOs。JSON-P的第一个版本比JSON-B早几年发布。JSON-P为JSON处理提供了流式和数据模型。
- en: JSON-B provides a mechanism for converting Java objects to/from JSON messages.
    It provides several methods to serialize/desterilize a Java object to/from JSON.
    JSON-B provides a higher-level API than JSON-P. JSON-B works well with JAX-RS
    and JAX-RS 2.1 mandates the use of JSON-B to automatically convert the returned
    object to JSON data in the HTTP response.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: JSON-B提供了一种将Java对象转换为JSON消息或从JSON消息转换回Java对象的机制。它提供了多种方法来序列化/反序列化Java对象到/从JSON。JSON-B提供的API比JSON-P更高级。JSON-B与JAX-RS和JAX-RS
    2.1兼容，并强制使用JSON-B来自动将返回的对象转换为HTTP响应中的JSON数据。
- en: Technologies for enhancing cloud-native applications
  id: totrans-97
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 增强云原生应用程序的技术
- en: After building cloud-native applications, the job is not done yet, unfortunately.
    You will need to think about how to improve the application. The next task is
    to improve its reliability and maintainability. Do you want to freely change its
    config value without recompiling your applications, for example, the port number?
    Do you want your application to be resilient, functioning all the time no matter
    what? Do you want your application to be secure, which means unauthorized requests
    are not permitted? Do you need help to work out what your applications are doing
    when you have got tens or hundreds of applications?
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 建立云原生应用程序后，不幸的是，工作还没有完成。您需要考虑如何改进应用程序。下一个任务是提高其可靠性和可维护性。例如，您是否希望自由更改配置值而无需重新编译应用程序，比如端口号？您是否希望应用程序具有弹性，无论发生什么情况都能持续运行？您是否希望应用程序具有安全性，这意味着不允许未经授权的请求？当您有数十或数百个应用程序时，您需要帮助确定应用程序正在做什么？
- en: 'If the answer to any of the aforementioned questions is *yes*, you will need
    to add some essential **Quality of Services**(**QoS**) , which includes the following:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 如果上述任何问题的答案是*是*，您将需要添加一些基本的**服务质量**(**QoS**)，包括以下内容：
- en: Configuration
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置
- en: Resilience
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 弹性
- en: Security
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安全性
- en: Documentation
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文档
- en: '**MicroProfile Config** provides a way to configure applications without the
    need for redeployment. **MicroProfile Fault Tolerance** makes the application
    more resilient. **MicroProfile JWT Authentication** secures applications in a
    portable and simple way, while **MicroProfile Open API** is used to document applications.
    Next, we will provide a quick overview of these technologies, and we will go deeper
    into each of them in [*Chapter 5*](B17377_05_Final_SB_epub.xhtml#_idTextAnchor091),
    *Enhancing Cloud-Native Applications*.'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '**MicroProfile 配置** 提供了一种无需重新部署即可配置应用程序的方法。**MicroProfile 故障恢复** 使应用程序更具弹性。**MicroProfile
    JWT 认证** 以便携和简单的方式保护应用程序，而 **MicroProfile Open API** 用于记录应用程序。接下来，我们将快速概述这些技术，并在
    [*第五章*](B17377_05_Final_SB_epub.xhtml#_idTextAnchor091)，*增强云原生应用程序* 中深入探讨每个技术。'
- en: MicroProfile Config
  id: totrans-105
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: MicroProfile 配置
- en: '**MicroProfile Config** ([https://github.com/eclipse/microprofile-config](https://github.com/eclipse/microprofile-config))
    defines an easy and flexible system to retrieve application configurations. The
    configurations are defined in config sources, which can be supplied by applications.
    There are two ways to retrieve configuration: **CDI** or **programmatic lookup**.
    Let''s look at each of these in turn:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '**MicroProfile 配置** ([https://github.com/eclipse/microprofile-config](https://github.com/eclipse/microprofile-config))
    定义了一个简单灵活的系统来检索应用程序配置。配置定义在配置源中，这些配置源可以由应用程序提供。检索配置有两种方式：**CDI** 或 **程序性查找**。让我们依次查看这些方法：'
- en: '`"customer.name"`, the following code snippet can be used to retrieve its value:'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`"customer.name"`，以下代码片段可以用来检索其值：'
- en: '[PRE3]'
  id: totrans-108
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '`customer.name` can also be looked up programmatically via the following APIs:'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`customer.name` 也可以通过以下 API 进行程序性查找：'
- en: '[PRE4]'
  id: totrans-110
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The property defined in the `microprofile-config.properites` file on the classpath,
    environment variable, and system properties is available to the cloud-native applications
    automatically. This means that MicroProfile Config can also access the values
    of fields from Kubernetes `ConfigMaps` or `Secrets` that are mapped to the Pod
    as environment variables. The following code snippet demonstrates the `customer.name`
    property defined in `microprofile-config.properties`, in the format of a Java
    property file:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在类路径上的 `microprofile-config.properties` 文件中定义的属性，环境变量和系统属性对云原生应用程序自动可用。这意味着
    MicroProfile 配置还可以访问映射到 Pod 的 Kubernetes `ConfigMaps` 或 `Secrets` 的环境变量的值。以下代码片段演示了在
    Java 属性文件格式中定义的 `customer.name` 属性：
- en: '[PRE5]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: MicroProfile Config enables the externalization of the configuration. The configuration
    stored in the environment can be accessed by the cloud-native applications via
    the Config APIs. This specification fulfills the third factor, **Configuration**,
    in **Twelve-Factor App**, as mentioned in [*Chapter 1*](B17377_01_Final_SB_epub.xhtml#_idTextAnchor021),
    *Cloud-Native Application*. You have learned how to configure your application.
    Next, we will briefly discuss how to make your application resilient using MicroProfile
    Fault Tolerance.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: MicroProfile 配置允许外部化配置。存储在环境中的配置可以通过 Config API 被云原生应用程序访问。本规范实现了在 [*第一章*](B17377_01_Final_SB_epub.xhtml#_idTextAnchor021)，*云原生应用程序*
    中提到的 **Twelve-Factor App** 的第三个因素，**配置**。您已经学习了如何配置您的应用程序。接下来，我们将简要讨论如何使用 MicroProfile
    故障恢复使您的应用程序更具弹性。
- en: MicroProfile Fault Tolerance
  id: totrans-114
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: MicroProfile 故障恢复
- en: '**MicroProfile Fault Tolerance** ([https://github.com/eclipse/microprofile-fault-tolerance/](https://github.com/eclipse/microprofile-fault-tolerance/))
    defines a set of annotations for making cloud-native applications resilient. These
    annotations are as follows:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '**MicroProfile 故障恢复** ([https://github.com/eclipse/microprofile-fault-tolerance/](https://github.com/eclipse/microprofile-fault-tolerance/))
    定义了一组用于使云原生应用程序具有弹性的注解。这些注解如下：'
- en: '`@Retry`: Recovers from a brief network glitch. This allows you to define how
    many times the retry can be performed, what exceptions can trigger the retry,
    the time duration for the retries, and so on.'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@Retry`：从短暂的网络故障中恢复。这允许您定义重试的次数、可以触发重试的异常、重试的时间长度等。'
- en: '`@Timeout`: Defines the maximum allowed response time. This is used for time-critical
    operations. It defines the maximum time duration for the corresponding operation
    to respond.'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@Timeout`：定义了最大允许的响应时间。这用于时间敏感的操作。它定义了相应操作响应的最大时间长度。'
- en: '`@CircuitBreaker`: Fails fast and avoids the repeatable indefinite wait or
    timeout. You can specify the rolling window for a circuit to be checked, the failure
    ratio for the circuit to open, the exceptions that the circuit breaker considers
    or ignores, and so on.'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@CircuitBreaker`：快速失败并避免可重复的无限等待或超时。您可以指定要检查电路的滚动窗口、电路打开的失败率、电路断路器考虑或忽略的异常等。'
- en: '`@Bulkhead`: Isolates failures and avoids bringing the whole system down. There
    are two types of bulkhead. When this annotation is used together with the `@Asynchronous`
    annotation, this means **thread isolation**, which means the method with this
    annotation will be executed on a child thread. Otherwise, it means **semaphore
    isolation**, which means the method will be executed on the parent thread.'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@Bulkhead`：隔离故障并避免整个系统崩溃。有两种类型的隔离舱。当此注解与 `@Asynchronous` 注解一起使用时，这意味着**线程隔离**，这意味着带有此注解的方法将在子线程上执行。否则，它意味着**信号量隔离**，这意味着方法将在父线程上执行。'
- en: '`@Fallback`: Provides an alternative solution for a failed execution. You should
    always use this annotation to ensure a resilient cloud-native application to respond
    to all kinds of situations. This annotation provides an alternative operation
    if the original method returns an exception.'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@Fallback`：为失败的执行提供替代解决方案。您应该始终使用此注解来确保健壮的云原生应用程序能够应对各种情况。此注解在原始方法返回异常时提供替代操作。'
- en: The aforementioned annotations can be used together, which improves the resilience
    of your cloud-native applications. Once your application is configurable and resilient,
    the next step is to think about how to prevent sensitive information from being
    obtained by irrelevant parties. This is where MicroProfile JWT Propagation comes
    into play.
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 上述注解可以一起使用，这提高了您云原生应用程序的健壮性。一旦您的应用程序可配置且健壮，下一步就是考虑如何防止敏感信息被无关方获取。这正是 MicroProfile
    JWT 传播发挥作用的地方。
- en: MicroProfile JWT Propagation
  id: totrans-122
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: MicroProfile JWT 传播
- en: '`@RolesAllowed`, to secure JAX-RS endpoints.'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '`@RolesAllowed`，用于保护 JAX-RS 端点。'
- en: 'MicroProfile JWT Propagation establishes a way to pass in the user info to
    the backend so that the backend can determine whether the invocation is allowed.
    MicroProfile JWT Propagation is built on top of a JWT with a couple of additional
    claims: `JsonWebToken`, which extends the `java.security.Principal` interface.
    This API makes a set of claims available via getter accessors.'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: MicroProfile JWT 传播建立了一种将用户信息传递到后端的方法，以便后端可以确定调用是否允许。MicroProfile JWT 传播建立在
    JWT 之上，并添加了一些额外的声明：`JsonWebToken`，它扩展了 `java.security.Principal` 接口。此 API 通过 getter
    访问器提供一系列声明。
- en: 'JAX-RS applications can access `JsonWebToken` from the `SecurityContext` annotation:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: JAX-RS 应用程序可以通过 `SecurityContext` 注解访问 `JsonWebToken`：
- en: '[PRE6]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Alternatively, it can also be injected:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，它也可以被注入：
- en: '[PRE7]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: MicroProfile JWT Authentication also ensures single sign-on and the runtime
    will automatically reject the requests with insufficient **access rights** or
    a lack of the appropriate claims. Once your application is configurable, resilient,
    and secure, you then need to think about how to document your application. You
    can document your application using MicroProfile OpenAPI.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: MicroProfile JWT 认证还确保了单点登录，并且运行时将自动拒绝权限不足或缺少适当声明的请求。一旦您的应用程序可配置、健壮且安全，您就需要考虑如何记录您的应用程序。您可以使用
    MicroProfile OpenAPI 来记录您的应用程序。
- en: MicroProfile OpenAPI
  id: totrans-130
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: MicroProfile OpenAPI
- en: '`http://myHost:myPort/openapi`, as a `GET` operation. Some MicroProfile Open
    API implementations such as Open Liberty ([https://openliberty.io/](https://openliberty.io/))
    also provide the Swagger UI integration and exposes the endpoint, `http://myHost:myPort/openapi/ui`,
    which allows the endpoints to be tested out.'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '`http://myHost:myPort/openapi`，作为一个 `GET` 操作。一些 MicroProfile Open API 实现，如
    Open Liberty ([https://openliberty.io/](https://openliberty.io/))，也提供了 Swagger
    UI 集成并公开了端点，`http://myHost:myPort/openapi/ui`，允许测试端点。'
- en: Note
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: MicroProfile OpenAPI produces a set of Java interfaces and annotations that
    allow Java developers to produce OpenAPI v3 documents from their JAX-RS. MicroProfile
    OpenAPI was heavily influenced by OpenAPI v3, but they are not the same.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: MicroProfile OpenAPI 生成一组 Java 接口和注解，允许 Java 开发者从他们的 JAX-RS 生成 OpenAPI v3 文档。MicroProfile
    OpenAPI 受 OpenAPI v3 的影响很大，但它们并不相同。
- en: As a cloud-native developer, your job is nearly done. You could deploy your
    application to the cloud. If everything goes well, you will have an easy job.
    However, if something goes wrong, you might have a difficult time figuring out
    where the problem lies. In order to help with service, you will need to learn
    about the technologies for observing and monitoring your applications. Read along
    to find out what you can do to help with serviceability.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 作为云原生开发者，你的工作几乎已经完成。你可以将你的应用程序部署到云端。如果一切顺利，你将有一个轻松的工作。然而，如果出了问题，你可能很难找出问题所在。为了帮助服务，你需要了解观察和监控应用程序的技术。继续阅读，了解你可以做些什么来帮助服务性。
- en: Technologies for observing and monitoring cloud-native applications
  id: totrans-135
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 观察和监控云原生应用程序的技术
- en: Upon completing the development of cloud-native applications, the next stage
    is **day 2 operation**, where monitoring, maintenance, and troubleshooting come
    into play. **MicroProfile Health**, **MicroProfile Metrics**, and **MicroProfile
    Open Tracing** provide support in these areas. Next is a quick overview of these
    technologies to give you a basic understanding of how these technologies work
    together to help with day 2 operation. [*Chapter 6*](B17377_06_Final_SB_epub.xhtml#_idTextAnchor123),
    *Observing and Monitoring Cloud-Native Applications*, will cover this in more
    detail.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在完成云原生应用程序的开发后，下一个阶段是**第二天操作**，在这一阶段，监控、维护和故障排除变得重要。**MicroProfile Health**、**MicroProfile
    Metrics**和**MicroProfile Open Tracing**在这些领域提供支持。接下来是对这些技术的快速概述，以帮助你了解这些技术如何协同工作以帮助第二天操作。[*第6章*](B17377_06_Final_SB_epub.xhtml#_idTextAnchor123)，*观察和监控云原生应用程序*，将更详细地介绍这一点。
- en: MicroProfile Health
  id: totrans-137
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: MicroProfile Health
- en: '`@Readiness` and `@Liveness` annotations, accordingly. The `@Readiness` annotation
    is applied to a `HealthCheck` implementation to define a readiness check procedure,
    while `@Liveness` is applied to a liveness check procedure. The response of the
    `HealthCheck` procedure can be either *UP* or *DOWN*.'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '`@Readiness`和`@Liveness`注解，相应地。`@Readiness`注解应用于`HealthCheck`实现，以定义就绪检查程序，而`@Liveness`应用于存活检查程序。`HealthCheck`程序的响应可以是*UP*或*DOWN*。'
- en: The response of the readiness check determines whether the cloud-native application
    is ready to serve requests. If the response is *UP*, the cloud infrastructure,
    such as **Kubernetes**, will route requests to the Pod it lives in. If the response
    is *DOWN*, Kubernetes will not route requests to the Pod. The response of the
    liveness check means whether the cloud-native application is still alive. With
    a response of *DOWN*, Kubernetes will destroy the Pod that the cloud-native application
    lives in and start a new one.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 就绪检查的响应决定了云原生应用程序是否准备好服务请求。如果响应是*UP*，云基础设施，如**Kubernetes**，将路由请求到它所在的Pod。如果响应是*DOWN*，Kubernetes将不会将请求路由到Pod。存活检查的响应意味着云原生应用程序是否仍然存活。如果响应是*DOWN*，Kubernetes将销毁云原生应用程序所在的Pod，并启动一个新的Pod。
- en: MicroProfile Health defines the `http://myHost:myPort/health/ready` and `http://myHost:myPort/health/live`
    endpoints to be exposed by its implementations to represent the status of readiness
    and liveness of the entire runtime accordingly, which can be used for Kubernetes
    readiness and liveness checks.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: MicroProfile Health定义了其实现需要暴露的`http://myHost:myPort/health/ready`和`http://myHost:myPort/health/live`端点，以表示整个运行时的就绪和存活状态，这可以用于Kubernetes的就绪和存活检查。
- en: MicroProfile Metrics
  id: totrans-141
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: MicroProfile度量指标
- en: '`http://myHost:myPort/metrics/base`, `http://` `myHost:myPort/metrics/vendor`,
    and `http://myHost:myPort/metrics/application`. The endpoint of `http://myHost:myPort/metrics`
    lists the aggregation of all three scopes of the metrics. The data exposed via
    REST over HTTP can be in JSON format or **OpenMetrics** text format, which can
    be consumed by the monitoring tools such as **Prometheus** so that the metrics
    can be represented as a graph in a dashboard.'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '`http://myHost:myPort/metrics/base`，`http://myHost:myPort/metrics/vendor`和`http://myHost:myPort/metrics/application`。`http://myHost:myPort/metrics`端点列出了度量指标所有三个作用域的聚合。通过HTTP
    REST暴露的数据可以是JSON格式或**OpenMetrics**文本格式，可以被监控工具如**Prometheus**消费，以便将度量指标以图表的形式显示在仪表板上。'
- en: MicroProfile OpenTracing
  id: totrans-143
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: MicroProfile OpenTracing
- en: '`SpanContext` information into any outgoing JAX-RS request and then start a
    span for any outgoing JAX-RS request and finish the `Span` when the request completes.
    MicroProfile OpenTracing adopts `io.opentracing.Tracer` available to each application.'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 将`SpanContext`信息放入任何出去的JAX-RS请求中，然后为任何出去的JAX-RS请求启动一个跨度，并在请求完成时完成`Span`。MicroProfile
    OpenTracing采用每个应用程序可用的`io.opentracing.Tracer`。
- en: MicroProfile OpenTracing exposes the trace spans that tracing tools such as
    **Jaeger** or **Zipkin** can use to gather the data and graph them in a dashboard.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: MicroProfile OpenTracing公开了跟踪工具（如**Jaeger**或**Zipkin**）可以用来收集数据并在仪表板上图形化的跟踪跨度。
- en: You have learned the essential specifications from MicroProfile. However, there
    are some extra specifications following standalone releases. Let's look at these
    to see whether you could use some of them in your applications.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经学到了MicroProfile的基本规范。然而，还有一些额外的规范在独立版本之后发布。让我们看看这些规范，看看你是否可以在你的应用中使用它们。
- en: Standalone releases
  id: totrans-147
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 独立版本
- en: 'From 2018, a few more MicroProfile specifications were released: **MicroProfile
    Reactive Streams Operators**, **MicroProfile Messaging**, **MicroProfile Context
    Propagation**, and **MicroProfile GraphQL**.'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 从2018年开始，又发布了几个MicroProfile规范：**MicroProfile Reactive Streams Operators**、**MicroProfile
    Messaging**、**MicroProfile Context Propagation**和**MicroProfile GraphQL**。
- en: 'The MicroProfile community would like to get more feedback before merging these
    specifications into the umbrella release. As a consequence, they remain as standalone
    specifications. [*Chapter 10*](B17377_10_Final_SB_epub.xhtml#_idTextAnchor187),
    *Reactive Cloud-Native Applications*, and [*Chapter 11*](B17377_11_Final_SB_epub.xhtml#_idTextAnchor202),
    *MicroProfile GraphQL*, will discuss these specifications in more detail. For
    now, let''s have an overview of each:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: MicroProfile社区希望在将这些规范合并到综合版本之前收集更多反馈。因此，它们仍然作为独立规范存在。[第10章*](B17377_10_Final_SB_epub.xhtml#_idTextAnchor187)，*反应式云原生应用*，和[第11章*](B17377_11_Final_SB_epub.xhtml#_idTextAnchor202)，*MicroProfile
    GraphQL*将更详细地讨论这些规范。现在，让我们概述每个规范：
- en: '`map`, `filter`, and `flatMap`. It also provides APIs to be used by MicroProfile
    Messaging.'
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`map`、`filter`和`flatMap`。它还提供了MicroProfile Messaging可用的API。'
- en: '`@Incoming` for consuming messages and `@Outgoing` for publishing messages.'
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@Incoming`用于消费消息，`@Outgoing`用于发布消息。'
- en: '`CompletionStage`, `CompletableFuture`, and `Function`, to work better in cloud-native
    applications with some associated contexts. MicroProfile Context Propagation enables
    asynchronous programming to be context-aware because the new threads can inherit
    some contexts from parent threads, such as `Security Context`, `CDI Context`,
    `Application Context`, `Transaction Context`, and other applications defined in
    `ThreadContext`.'
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CompletionStage`、`CompletableFuture`和`Function`，以便在具有一些相关上下文的云原生应用中更好地工作。MicroProfile
    Context Propagation使异步编程能够感知上下文，因为新线程可以从父线程继承一些上下文，例如`Security Context`、`CDI Context`、`Application
    Context`、`Transaction Context`以及定义在`ThreadContext`中的其他应用。'
- en: '`@Query` and `@Mutuation`, for building GraphQL queries and mutations, accordingly.'
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@Query`和`@Mutuation`，用于构建GraphQL查询和突变。'
- en: So far, we have learned about all the MicroProfile specifications in short order.
    If you don't understand some of them, don't worry as we will cover them in more
    depth in the following chapters.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经迅速了解了所有MicroProfile规范。如果你对其中的一些规范不理解，不要担心，我们将在接下来的章节中更深入地介绍它们。
- en: You might now be wondering how to create a cloud-native application using MicroProfile,
    and whether there are any tools to help with creating a cloud-native application.
    We will cover this in the next section.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在可能想知道如何使用MicroProfile创建云原生应用，以及是否有任何工具可以帮助创建云原生应用。我们将在下一节中介绍。
- en: MicroProfile Starter
  id: totrans-156
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: MicroProfile Starter
- en: '**MicroProfile Starter** ([https://start.microprofile.io/](https://start.microprofile.io/))
    is a code generator for developing cloud-native applications using MicroProfile.
    This tool can be accessed via the web, command line, or IDE plugins. In this section,
    we will learn about the MicroProfile Starter tool for creating cloud-native applications.'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '**MicroProfile Starter** ([https://start.microprofile.io/](https://start.microprofile.io/))是使用MicroProfile开发云原生应用的代码生成器。这个工具可以通过网络、命令行或IDE插件访问。在本节中，我们将学习MicroProfile
    Starter工具，用于创建云原生应用。'
- en: Accessing MicroProfile Starter via the web
  id: totrans-158
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通过网络访问MicroProfile Starter
- en: 'The following screenshot shows the **User Interface** of MicroProfile Starter,
    which can be used to create cloud-native applications and then download the ZIP:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了MicroProfile Starter的**用户界面**，可以用来创建云原生应用，然后下载ZIP文件：
- en: '![Figure 2.2 – MicroProfile Starter UI'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '![图2.2 – MicroProfile Starter UI'
- en: '](img/B17377_02_02_new.jpg)'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17377_02_02_new.jpg)'
- en: Figure 2.2 – MicroProfile Starter UI
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.2 – MicroProfile Starter UI
- en: 'In the preceding UI, we can specify the following:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的UI中，我们可以指定以下内容：
- en: '**groupId**: The generated application''s Maven group ID.'
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**groupId**：生成的应用的Maven组ID。'
- en: '**artifactId**: The generated application''s Maven artifact ID.'
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**artifactId**：生成的应用的 Maven 项目的ID。'
- en: '**MicroProfile Version**: The version of the MicroProfile release.'
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**MicroProfile版本**：MicroProfile发布版本的版本号。'
- en: '**MicroProfile Runtime**: The selected runtime that supports the chosen MicroProfile
    release version. In *Figure 2.2*, MicroProfile version 3.3 is selected, and then
    three runtimes that implement MicroProfile version 3.3 are displayed: **Open Liberty**,
    **Wildfly**, and **Payara Micro**.'
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**MicroProfile运行时**：支持所选MicroProfile发布版本的所选运行时。在*图2.2*中，选择了MicroProfile版本3.3，然后显示了实现MicroProfile版本3.3的三个运行时：**Open
    Liberty**、**Wildfly**和**Payara Micro**。'
- en: '**Java SE Version**: Once we have chosen our favorite runtime, we can then
    choose the Java SE version. If a runtime supports multiple Java SE, we can then
    select which Java SE version you want. For example, Open Liberty supports both
    Java SE 8 and Java SE 11\. Once we have selected Open Liberty, we can then choose
    either Java SE 8 or Java SE 11.'
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Java SE版本**：一旦我们选择了我们喜欢的运行时，我们就可以选择Java SE版本。如果运行时支持多个Java SE版本，我们就可以选择我们想要的Java
    SE版本。例如，Open Liberty支持Java SE 8和Java SE 11。一旦我们选择了Open Liberty，我们就可以选择Java SE
    8或Java SE 11。'
- en: '**Examples for specifications**: The MicroProfile specifications that the generated
    applications are going to use. Clicking on the checkbox will select the corresponding
    MicroProfile specifications and the code sample will include the chosen MicroProfile
    specifications. If TypeSafe Rest Client or JWT Auth is selected, two cloud-native
    applications will be generated to demonstrate the client-server architecture.
    If you want to create a MicroProfile application from scratch, you don''t need
    to choose any of the checkboxes. In this case, you will have the structure set
    up and you can write your business code straightaway.'
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**规范示例**：生成的应用将要使用的MicroProfile规范。点击复选框将选择相应的MicroProfile规范，代码示例将包括所选的MicroProfile规范。如果选择了TypeSafe
    Rest Client或JWT Auth，将生成两个云原生应用来演示客户端-服务器架构。如果您想从头创建MicroProfile应用，则不需要选择任何复选框。在这种情况下，您将设置好结构，然后可以直接编写业务代码。'
- en: Accessing MicroProfile Starter via the command line
  id: totrans-170
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通过命令行访问MicroProfile Starter
- en: MicroProfile Starter has command-line support, which is useful if you want to
    automatically generate cloud-native applications on the command line or as part
    of the automation process.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: MicroProfile Starter支持命令行，如果您想在命令行或作为自动化过程的一部分自动生成云原生应用，这将非常有用。
- en: 'You can find all information via the following command, where the output displays
    all of the supported features with the corresponding commands:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过以下命令找到所有信息，其中输出显示了所有支持的功能及其对应的命令：
- en: '[PRE8]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: In the output from the aforementioned command, you can find further commands
    to use for creating a specific cloud-native application for a chosen runtime,
    MicroProfile version, and so on.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述命令的输出中，您可以找到用于为所选运行时、MicroProfile版本等创建特定云原生应用的进一步命令。
- en: Accessing MicroProfile Starter via an IDE plugin
  id: totrans-175
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通过IDE插件访问MicroProfile Starter
- en: MicroProfile Starter can also be accessed via IDE plugins, namely, the **Visual
    Studio Code MicroProfile extension pack** or **Intellij IDEA MicroProfile plugin**,
    which we will look at now.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: MicroProfile Starter还可以通过IDE插件访问，即**Visual Studio Code MicroProfile扩展包**或**IntelliJ
    IDEA MicroProfile插件**，我们现在将探讨这些插件。
- en: Visual Studio Code plugin
  id: totrans-177
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Visual Studio Code 插件
- en: The **Visual Studio Code Extension Pack for MicroProfile** ([https://marketplace.visualstudio.com/items?itemName=MicroProfile-Community.vscode-microprofile-pack](https://marketplace.visualstudio.com/items?itemName=MicroProfile-Community.vscode-microprofile-pack))
    can be downloaded and installed onto Visual Studio Code ([https://code.visualstudio.com](https://code.visualstudio.com)).
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '**Visual Studio Code MicroProfile扩展包**（[https://marketplace.visualstudio.com/items?itemName=MicroProfile-Community.vscode-microprofile-pack](https://marketplace.visualstudio.com/items?itemName=MicroProfile-Community.vscode-microprofile-pack)）可以下载并安装到Visual
    Studio Code（[https://code.visualstudio.com](https://code.visualstudio.com)）。'
- en: This extension pack also includes **Language Server Support for MicroProfile**,
    **Open Liberty Tools**, **Quarkus**, and **Payara Tools**.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 此扩展包还包括**MicroProfile语言服务器支持**、**Open Liberty工具**、**Quarkus**和**Payara工具**。
- en: IntelliJ IDEA plugin
  id: totrans-180
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: IntelliJ IDEA 插件
- en: '**IntelliJ IDEA** ([https://www.jetbrains.com/idea/](https://www.jetbrains.com/idea/))
    offers a MicroProfile Starter plugin ([https://plugins.jetbrains.com/plugin/13386-microprofile-starter](https://plugins.jetbrains.com/plugin/13386-microprofile-starter))
    for you to access MicroProfile Starter directly from the Intellij IDE. You can
    simply install the plugin and start using MicroProfile Starter. When using the
    plugin, you can input the same fields as shown in *Figure 2.2*, and then an application
    will be created.'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '**IntelliJ IDEA** ([https://www.jetbrains.com/idea/](https://www.jetbrains.com/idea/))
    提供了一个 MicroProfile Starter 插件 ([https://plugins.jetbrains.com/plugin/13386-microprofile-starter](https://plugins.jetbrains.com/plugin/13386-microprofile-starter))，让您可以直接从
    IntelliJ IDE 访问 MicroProfile Starter。您只需简单地安装插件，就可以开始使用 MicroProfile Starter。在使用插件时，您可以输入与
    *图 2.2* 中所示相同的字段，然后就会创建一个应用程序。'
- en: Summary
  id: totrans-182
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we have learned all of the MicroProfile specifications and
    discussed how they can help with creating cloud-native applications. We then added
    various QoS, such as configuration, resilience, security, and monitoring. With
    this, you will have a basic idea of how to design your cloud-native application
    with best practices to make it secure, configurable, resilient, intelligent, and
    monitorable. In the chapters to follow, we will learn these technologies in more
    depth.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了所有的 MicroProfile 规范，并讨论了它们如何帮助创建云原生应用程序。然后我们添加了各种 QoS，例如配置、弹性、安全和监控。有了这些，您将有一个基本的想法，了解如何使用最佳实践来设计您的云原生应用程序，使其安全、可配置、弹性、智能和可监控。在接下来的章节中，我们将更深入地学习这些技术。
- en: Furthermore, after going through the MicroProfile specifications, we then introduced
    MicroProfile Starter, a tool to develop cloud-native applications. This tool can
    be accessed via the web, command line, Visual Studio plugin, or IntelliJ IDEA
    plugin. You will be able to use these tools to create your cloud-native applications
    from scratch.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，在了解了 MicroProfile 规范之后，我们介绍了 MicroProfile Starter，这是一个用于开发云原生应用程序的工具。该工具可以通过网页、命令行、Visual
    Studio 插件或 IntelliJ IDEA 插件访问。您将能够使用这些工具从头开始创建您的云原生应用程序。
- en: In the next chapter, we will introduce a real-world, cloud-native application
    that utilizes MicroProfile technologies to solve some common problems, and we
    will also learn how MicroProfile helps with the challenges posed by real-world
    use cases.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将介绍一个利用 MicroProfile 技术解决一些常见问题的真实世界、云原生应用程序，并学习 MicroProfile 如何帮助解决真实世界用例带来的挑战。
