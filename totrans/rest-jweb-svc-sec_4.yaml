- en: Chapter 4. RESTEasy Skeleton Key
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第4章 RESTEasy Skeleton Key
- en: Welcome to the fourth chapter! We hope you are enjoying the book, and even more
    important, learning and understanding what we are transmitting and teaching you.
    It is time to move forward and immerse yourself in a new chapter.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 欢迎来到第四章！我们希望你在享受这本书，更重要的是，在学习和理解我们所传达和教授的内容。现在是时候前进并沉浸在新的一章中。
- en: Once you read this chapter, you will have the knowledge to design, implement,
    and aggregate additional security levels to your RESTEasy applications, all of
    this using OAuth and RESTEasy Skeleton Key and some other specific requirements
    of these technologies, such as setting up an OAuth server. You will learn through
    practical and descriptive examples of applications, just as we did in previous
    chapters; we won't get stuck in theory only, and we'll implement applications
    and explain specific methods and classes to implement OAuth.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦阅读了本章，你将具备设计、实现和聚合额外的安全级别到你的RESTEasy应用程序中的知识，这一切都使用OAuth和RESTEasy Skeleton
    Key以及这些技术的某些特定要求，例如设置OAuth服务器。你将通过实际和描述性的应用程序示例来学习，就像我们在前面的章节中所做的那样；我们不会只停留在理论上，而是会实现应用程序并解释实现OAuth的具体方法和类。
- en: 'In this chapter, you will learn about the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将了解以下主题：
- en: OAuth and RESTEasy
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: OAuth和RESTEasy
- en: SSO configuration for security management
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安全管理的SSO配置
- en: Access tokens
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 访问令牌
- en: Custom filters
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自定义过滤器
- en: Web services clients for test
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试用的Web服务客户端
- en: As you have probably experienced, if you have an account on one or several social
    networks, a lot of these social networks allow you to share information between
    them or post something in all of them. This is a sign that applications need to
    share information and also use resources that are in other applications. In this
    example, it can be your account or your contact list. This involves sensitive
    information, so it needs to be protected. Also, limited permissions over resources
    means that a third-party application can only read your contacts list. This opens
    the door to a very important, attractive, and useful feature among applications,
    which is the capacity to use resources on behalf of the user. Of course, you may
    ask how the latter authorizes the use? Well, this chapter will show you. So, let's
    go!
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 如你可能已经体验过的，如果你在一个或几个社交网络上拥有账户，许多这些社交网络允许你在它们之间共享信息或在所有它们上发布内容。这是一个迹象表明应用程序需要共享信息，并且也使用其他应用程序中的资源。在这个例子中，它可以是你的账户或你的联系名单。这涉及到敏感信息，因此需要保护。此外，对资源的有限权限意味着第三方应用程序只能读取你的联系名单。这为应用程序中一个非常重要、吸引人和有用的功能打开了大门，即代表用户使用资源的容量。当然，你可能想知道后者如何授权使用？好吧，本章将向你展示。那么，让我们开始吧！
- en: OAuth protocol
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: OAuth协议
- en: This is an open protocol that allows you to grant safe authorization to your
    private resources from one site (service provider) to another (consumer) without
    sharing your identity.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个开放协议，允许你从一个站点（服务提供者）安全地授权你的私有资源到另一个站点（消费者），而不必分享你的身份。
- en: A practical example is when you grant authorization to a website or an application
    to use the contact list in your phone or social network.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 一个实际的例子是当你授权一个网站或应用程序使用你手机或社交网络中的联系名单。
- en: OAuth and RESTEasy Skeleton Key
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: OAuth和RESTEasy Skeleton Key
- en: In this section, we will review some concepts related to OAuth as an authentication
    framework, RESTEasy Skeleton Key, and how they work together. You will check out
    some features of these technologies and get your hands dirty with some code as
    a practical example.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将回顾与OAuth作为认证框架、RESTEasy Skeleton Key以及它们如何协同工作相关的一些概念。你将检查这些技术的某些功能，并通过一些实际示例的代码来亲自动手。
- en: What is RESTEasy Skeleton Key?
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 什么是RESTEasy Skeleton Key？
- en: RESTEasy Skeleton Key provides a unified way for browser and JAX-RS clients
    to be secured. This allows executing and forwarding requests in a network of applications
    and services in a secure and scalable way, without interacting with a central
    authentication server every time a request appears.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: RESTEasy Skeleton Key为浏览器和JAX-RS客户端提供了一种统一的方式来确保安全。这允许在应用程序和服务网络中安全且可扩展地执行和转发请求，而无需在每次出现请求时与中央认证服务器交互。
- en: OAuth 2.0 authentication framework
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: OAuth 2.0认证框架
- en: This enables third-party applications or services access to an HTTP resource
    on behalf of the resource owner. It also prevents the third-party application
    or service from getting in contact with the owner's credentials. This is possible
    through issuing access tokens via browsers and using a direct grant.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 这使得第三方应用程序或服务能够代表资源所有者访问HTTP资源。它还防止第三方应用程序或服务与所有者的凭证取得联系。这是通过通过浏览器颁发访问令牌和使用直接授权来实现的。
- en: With the two concepts explained in a nutshell, it is time to describe how they
    are related. RESTEasy Skeleton Key is an OAuth 2.0 implementation that uses the
    JBoss AS 7 security infrastructure in order to secure web applications and RESTful
    services.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 简要解释了这两个概念之后，现在是时候描述它们是如何相互关联的了。RESTEasy骨架密钥是一个OAuth 2.0实现，它使用JBoss AS 7安全基础设施来保护Web应用程序和RESTful服务。
- en: This means that you can transform a web application into an OAuth 2.0 access
    token provider, and you can also transform the JBoss AS 7 security domain into
    a central authentication and authorization server, where applications and services
    can interact with each other.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着你可以将Web应用程序转换为OAuth 2.0访问令牌提供者，你还可以将JBoss AS 7安全域转换为中央认证和授权服务器，在那里应用程序和服务可以相互交互。
- en: 'The following diagram describes this process in a better way:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的图表以更好的方式描述了此过程：
- en: '![OAuth 2.0 authentication framework](img/0109OS_04_01.jpg)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![OAuth 2.0认证框架](img/0109OS_04_01.jpg)'
- en: Main features
  id: totrans-23
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 主要功能
- en: 'We want to help you understand these technologies and clarify what they are
    used for; this is why we will name some of their main features. With OAuth 2.0
    and RESTEasy Skeleton Key, you can perform the following functions:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望帮助你理解这些技术并阐明它们的使用目的；这就是为什么我们将命名它们的一些主要功能。通过OAuth 2.0和RESTEasy骨架密钥，你可以执行以下功能：
- en: Transform a servlet-form-auth-based web application into an OAuth 2.0 provider.
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将基于servlet表单认证的Web应用程序转换为OAuth 2.0提供者。
- en: Provide distributed **Single Sign-On** (**SSO**) throughout a central authentication
    server in order to log in once and access any browser-based application configured
    in the domain in a secure way.
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在中央认证服务器上提供分布式**单点登录（SSO**），以便一次登录即可安全地访问域中配置的任何基于浏览器的应用程序。
- en: Use just one link and log out from all the distributed applications that were
    configured with SSO.
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 只用一个链接即可从所有配置了单点登录（SSO）的分布式应用程序中注销。
- en: Make a web application interact with a remote RESTful service using access tokens.
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用访问令牌使Web应用程序与远程RESTful服务交互。
- en: Sign access tokens with OAuth 2.0 and use the tokens later to access any service
    configured in the domain. The token has Identity and Role Mapping, and there is
    no need to overload the central authentication server with every request that
    appears because tokens are digitally signed.
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用OAuth 2.0对签名访问令牌，并在以后使用这些令牌访问域中配置的任何服务。令牌具有身份和角色映射，并且由于令牌是数字签名的，因此无需在每次请求时都过载中央认证服务器。
- en: You can find more information about these topics at [http://docs.jboss.org/resteasy/docs/3.0-beta-2/userguide/html/oauth2.html](http://docs.jboss.org/resteasy/docs/3.0-beta-2/userguide/html/oauth2.html).
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在[http://docs.jboss.org/resteasy/docs/3.0-beta-2/userguide/html/oauth2.html](http://docs.jboss.org/resteasy/docs/3.0-beta-2/userguide/html/oauth2.html)找到更多关于这些主题的信息。
- en: We will discuss the most important parts, but it might be useful for you.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将讨论最重要的部分，但这可能对你有所帮助。
- en: OAuth2 implementation
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: OAuth2实现
- en: We have just reviewed some of the main concepts that we will deal with in this
    chapter, but this is not enough. We must implement a descriptive example so that
    we can completely understand these topics.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚回顾了本章将要处理的一些主要概念，但这还远远不够。我们必须实现一个描述性示例，以便我们能够完全理解这些主题。
- en: Updating RESTEasy modules in JBoss
  id: totrans-34
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在JBoss中更新RESTEasy模块
- en: In order not to mess with your JBoss configuration or anything else, we will
    use another brand new instance of JBoss. We have to update some modules that are
    related to RESTEasy. We can do this very easily. Let's visit the link [http://resteasy.jboss.org/](http://resteasy.jboss.org/);
    at your right, you will find a panel with the title **Useful Links**, which has
    a download link. Click on it to visit another page that has a bunch of download
    links. In this example, we use the 3.0.7.Final Version. Download this version
    in order to go forward.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 为了不干扰您的 JBoss 配置或其他任何东西，我们将使用另一个全新的 JBoss 实例。我们必须更新一些与 RESTEasy 相关的模块。我们可以非常容易地做到这一点。让我们访问链接
    [http://resteasy.jboss.org/](http://resteasy.jboss.org/)；在您的右侧，您将找到一个标题为 **Useful
    Links** 的面板，其中有一个下载链接。点击它以访问另一个页面，该页面包含许多下载链接。在这个示例中，我们使用 3.0.7.Final 版本。下载此版本以继续前进。
- en: 'Once you have downloaded and unzipped it, you will find another `.zip` file
    named `resteasy-jboss-modules-3.0.7.Final`; this file contains some JARs that
    will update your JBoss modules. So, unzip it, copy all folders into `JBOSS_HOME/modules/`,
    and replace all coincidences. There is one last step: we have to update the JAR
    files'' version and modify the module XML in JBoss in order to set `org.apache.httpcomponents`
    to use `httpclient-4.2.1.jar`, `httpcore-4.2.1.jar` and `httpmime-4.2.1.jar` because
    the current latest Version is 4.3.4, which works fine too. So, copy these JARs
    and update the version in the `module.xml` file in `JBOSS_HOME/modules/org/apache`
    folder. Now, we have updated our modules for RESTEasy.'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 下载并解压后，您将找到一个名为 `resteasy-jboss-modules-3.0.7.Final` 的另一个 `.zip` 文件；此文件包含一些
    JAR 文件，这些文件将更新您的 JBoss 模块。因此，解压它，将所有文件夹复制到 `JBOSS_HOME/modules/` 中，并替换所有冲突项。最后一步：我们必须更新
    JAR 文件的版本并修改 JBoss 中的模块 XML，以便将 `org.apache.httpcomponents` 设置为使用 `httpclient-4.2.1.jar`、`httpcore-4.2.1.jar`
    和 `httpmime-4.2.1.jar`，因为当前最新版本是 4.3.4，这也同样可以正常工作。因此，复制这些 JAR 文件并在 `JBOSS_HOME/modules/org/apache`
    文件夹中的 `module.xml` 文件中更新版本。现在，我们已经更新了我们的模块以支持 RESTEasy。
- en: Setting up the configuration in JBoss
  id: totrans-37
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在 JBoss 中设置配置
- en: For the next step in getting our JBoss ready for our example, we must go to
    [https://github.com/restful-java-web-services-security/source-code/tree/master/chapter04](https://github.com/restful-java-web-services-security/source-code/tree/master/chapter04)
    and download the `chapter04` examples zip file. Unzip and you will find a folder
    named `configuration`. This folder contains the files necessary for setting up
    our JBoss configuration. So, copy the files and replace the configuration folder
    in your JBoss located at `JBOSS_HOME/standalone/configuration`.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使我们的 JBoss 为我们的示例做好准备的下一步，我们必须前往 [https://github.com/restful-java-web-services-security/source-code/tree/master/chapter04](https://github.com/restful-java-web-services-security/source-code/tree/master/chapter04)
    并下载 `chapter04` 示例 zip 文件。解压后，您将找到一个名为 `configuration` 的文件夹。这个文件夹包含设置我们的 JBoss
    配置所需的文件。因此，复制这些文件并替换位于 `JBOSS_HOME/standalone/configuration` 的 JBoss 中的配置文件夹。
- en: Implementing an OAuth client
  id: totrans-39
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 实现OAuth客户端
- en: 'In order to develop this example, we investigate a very useful example and
    apply it to a new project. This example is composed of several projects; each
    project will produce a WAR file. The purpose of this example is to demonstrate
    how OAuth works and explain the way you can implement this technology at a technical
    level. So, we will simulate several things in order to create the environment
    where we can apply this implementation. The complete code can be downloaded from
    the following link:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 为了开发这个示例，我们研究了一个非常有用的示例并将其应用于一个新的项目。这个示例由几个项目组成；每个项目将生成一个 WAR 文件。这个示例的目的是演示
    OAuth 的工作原理，并解释您如何在技术层面上实现这项技术。因此，我们将模拟几个事物来创建一个可以应用此实现的环境。完整的代码可以从以下链接下载：
- en: '[https://github.com/restful-java-web-services-security/source-code/tree/master/chapter04/oauth2-as7-example](https://github.com/restful-java-web-services-security/source-code/tree/master/chapter04/oauth2-as7-example)'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/restful-java-web-services-security/source-code/tree/master/chapter04/oauth2-as7-example](https://github.com/restful-java-web-services-security/source-code/tree/master/chapter04/oauth2-as7-example)'
- en: The oauth-client project
  id: totrans-42
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: oauth-client 项目
- en: First we are going to create the `oauth-client` webapp project. You can use
    the Maven command we have used before in previous chapters or you can use Eclipse
    IDE in order to perform this.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将创建 `oauth-client` webapp 项目。您可以使用我们在前几章中使用的 Maven 命令，或者您可以使用 Eclipse IDE
    来执行此操作。
- en: 'After that, let''s add some dependencies in order to implement our client.
    These dependencies are for all the projects. Go to the `pom.xml` file and make
    sure to add the following dependencies inside the `<dependencies>` tag:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，让我们添加一些依赖项以实现我们的客户端。这些依赖项适用于所有项目。转到`pom.xml`文件，并确保在`<dependencies>`标签内添加以下依赖项：
- en: '[PRE0]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Let's start by creating the package `com.packtpub.resteasy.example.oauth`. Then,
    create the class `public class Loader implements ServletContextListener`, which
    implements `ServletContextListener`, because we will load a key store and initialize
    a context.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从创建包`com.packtpub.resteasy.example.oauth`开始。然后，创建类`public class Loader implements
    ServletContextListener`，它实现了`ServletContextListener`接口，因为我们将会加载一个密钥存储库并初始化上下文。
- en: Let's add a field into our class `private ServletOAuthClient oauthClient`, which
    will represent our OAuth client object.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在我们的类`private ServletOAuthClient oauthClient`中添加一个字段，它将代表我们的OAuth客户端对象。
- en: 'Then, let''s create the method shown in the following piece of code:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，让我们创建以下代码片段所示的方法：
- en: '[PRE1]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This method receives two parameters, the filename and the password, and creates
    the object `KeyStore`. It also creates a `FileInputStream` object from the filename
    received so that it can use it to load the `KeyStore` object, and it uses the
    password received in the form of a char array.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法接收两个参数，文件名和密码，并创建`KeyStore`对象。它还从接收到的文件名创建一个`FileInputStream`对象，以便它可以使用它来加载`KeyStore`对象，并且它使用接收到的密码作为字符数组。
- en: 'After this, as our class implements the `ServletContextListener` interface,
    we have to override some methods. The first method to override is `contextInitialized`.
    Let''s do it as follows:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，由于我们的类实现了`ServletContextListener`接口，我们必须覆盖一些方法。第一个要覆盖的方法是`contextInitialized`。让我们这样做：
- en: '[PRE2]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Through this method, we will accomplish several things. As you can see, we set
    two internal variables; one is set with the path to our `client-truststore.ts`
    file and the other is set to the password. Make sure to paste the file in the
    path we specified in the variable (`JBOSS_HOME/standalone/configuration`).
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这个方法，我们将完成几件事情。正如你所看到的，我们设置了两个内部变量；一个是设置到我们的`client-truststore.ts`文件路径，另一个是设置密码。确保将文件粘贴到我们在变量中指定的路径（`JBOSS_HOME/standalone/configuration`）。
- en: After this, we load the `KeyStore` object using the path and password we specified
    in the variables, obtaining another `KeyStore` object through this.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们使用在变量中指定的路径和密码加载`KeyStore`对象，通过这种方式获取另一个`KeyStore`对象。
- en: 'Now, it''s time to instantiate and set the properties of our OAuth client object.
    In the previous code, we set the following properties: `trustStore`, `clientId`,
    `password`, `authUrl`, and `codeUrl`.'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，是时候实例化和设置我们的OAuth客户端对象的属性了。在之前的代码中，我们设置了以下属性：`trustStore`、`clientId`、`password`、`authUrl`和`codeUrl`。
- en: Finally, we create the client to obtain an access token from the code. In order
    to accomplish this, we use the `start()` method. Also, we set the attribute servlet
    OAuth client with the OAuth client object we just created.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们创建客户端以从代码中获取访问令牌。为了完成这个任务，我们使用`start()`方法。同时，我们使用我们刚刚创建的OAuth客户端对象设置属性servlet
    OAuth客户端。
- en: 'In order to finish our OAuth client, we need to override a second method named
    `public void contextDestroyed(ServletContextEvent sce)`, as shown in the following
    code:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完成我们的OAuth客户端，我们需要覆盖一个名为`public void contextDestroyed(ServletContextEvent
    sce)`的第二个方法，如下面的代码所示：
- en: '[PRE3]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This method will be executed when the servlet context is about to shut down,
    our application is redeploying, and so on. The method closes the client instance
    and all its associated resources.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 当servlet上下文即将关闭、我们的应用程序正在重新部署等情况发生时，此方法将执行。该方法关闭客户端实例及其所有相关资源。
- en: 'We implemented our OAuth client for our example. We need another resource.
    This time, we will create a class that works as a database client for our compact
    discs store. So, let''s name it `CompactDiscsDatabaseClient`, and we will get
    the two following methods:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为我们的示例实现了OAuth客户端。我们需要另一个资源。这次，我们将创建一个类，作为我们的光盘存储库的数据库客户端。所以，让我们称它为`CompactDiscsDatabaseClient`，并且我们将获取以下两个方法：
- en: '`public static void redirect(HttpServletRequest request, HttpServletResponse
    response)`'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`public static void redirect(HttpServletRequest request, HttpServletResponse
    response)`'
- en: '`public static List<String> getCompactDiscs(HttpServletRequest request)`'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`public static List<String> getCompactDiscs(HttpServletRequest request)`'
- en: 'So, let''s begin implementing the first method. This method is explained as
    follows:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们开始实现第一个方法。这个方法解释如下：
- en: '[PRE4]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In the preceding method, we obtain the `ServletOAuthClient` object from the
    `ServletContext` obtained from the request; the servlet OAuth client is in the
    servlet context as an attribute named `ServletOAuthClient`. Remember that in the
    first class we created, we set this attribute in the servlet context.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的方法中，我们从请求中获取的`ServletContext`对象中获取`ServletOAuthClient`对象；servlet OAuth客户端作为名为`ServletOAuthClient`的属性存在于servlet上下文中。记住，在我们创建的第一个类中，我们在servlet上下文中设置了此属性。
- en: Finally, we start the process of getting an access token by redirecting the
    browser to the authentication server through `redirectRelative (String relativePath,
    HttpServletRequest request, HttpServletResponse response)`.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们通过通过`redirectRelative (String relativePath, HttpServletRequest request,
    HttpServletResponse response)`方法将浏览器重定向到认证服务器来启动获取访问令牌的过程。
- en: 'Now, let''s move on with the next method that loads the discs. The following
    code represents the method:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们继续使用下一个方法来加载光盘。以下代码表示该方法：
- en: '[PRE5]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Let's check what we have up here. In the preceding `getCompactDiscs ()` method,
    we create a `ServletOAuthClient` object that is in charge of starting the process
    of obtaining an access token by redirecting the browser to the authentication
    server. Once again, we obtain the attribute from the `ServletContext` object from
    the request. Then, we create a `ResteasyClient` object using a new instance of
    `ResteasyClientBuilder()`; this class is an abstraction to create clients and
    allows SSL configuration.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们检查一下这里的情况。在前面的`getCompactDiscs()`方法中，我们创建了一个`ServletOAuthClient`对象，该对象负责通过将浏览器重定向到认证服务器来启动获取访问令牌的过程。再次，我们从请求的`ServletContext`对象中获取属性。然后，我们使用一个新的`ResteasyClientBuilder()`实例创建一个`ResteasyClient`对象；这个类是创建客户端和允许SSL配置的抽象。
- en: We then set the client-side trust store with the `trustStore()` method. This
    invocation will return a `KeyStore` object and set the client-side trust store.
    After this, we invoke the `hostnameVerification()` method, which sets an SSL policy
    used to verify hostnames. Finally, using the `build()` method, we build a new
    client instance with the entire configuration previously specified in this client
    builder. This will return an instance of `ResteasyClient`.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我们随后使用`trustStore()`方法设置客户端信任存储库。这个调用将返回一个`KeyStore`对象并设置客户端信任存储库。之后，我们调用`hostnameVerification()`方法，该方法设置用于验证主机名的SSL策略。最后，通过使用`build()`方法，我们构建一个新的客户端实例，该实例包含在此客户端构建器中先前指定的整个配置。这将返回一个`ResteasyClient`实例。
- en: Let's move on to create an internal variable which will hold the URL of the
    resource that we will set as our target resource. Also, we will create another
    internal variable to hold the bearer token as a string. This string will comprise
    the word `Bearer` followed by the bearer token from the servlet OAuth client and
    request.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续创建一个内部变量，该变量将保存我们将设置为我们的目标资源的资源URL。同时，我们还将创建另一个内部变量来保存作为字符串的bearer令牌。这个字符串将由单词`Bearer`后跟servlet
    OAuth客户端和请求中的bearer令牌组成。
- en: Now, in order to create the response, we will use the servlet OAuth client we
    just created. Let's use the variable `urlDiscs` as a parameter and create a new
    web resource target through the `target()` method. After this, using the `request()`
    method, we set up a request to the targeted web resource we just set.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，为了创建响应，我们将使用我们刚刚创建的servlet OAuth客户端。让我们使用变量`urlDiscs`作为参数，并通过`target()`方法创建一个新的网络资源目标。之后，使用`request()`方法，我们设置对刚刚设置的目标网络资源的请求。
- en: 'Finally, we add a header by invoking the `header()` method, which will receive
    two parameters: the first parameter represents the header''s name and the second
    parameter is the header''s value. After this, we invoke the `HTTP GET` method
    for the current request.'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们通过调用`header()`方法添加一个头，该方法将接收两个参数：第一个参数代表头的名称，第二个参数是头的值。之后，我们调用当前请求的`HTTP
    GET`方法。
- en: Just to clarify, the `HttpHeaders.AUTHORIZATION` constant represents the header
    field in the specific case when a user wants to authenticate themselves with a
    server. It does so by adding an authorization request-header field along with
    the request. On the other hand, the authorization field value is composed of credentials
    that contain the authentication information of the user for the realm of the resource
    being requested.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 为了澄清，`HttpHeaders.AUTHORIZATION`常量代表当用户想要通过添加一个授权请求头字段与服务器进行身份验证时的特定情况。它是通过在请求中添加一个授权请求头字段来完成的。另一方面，授权字段值由包含请求资源的领域内用户身份验证信息的凭据组成。
- en: Once the response object is created, we use the `readEntity()` method to read
    the message entity input stream as an instance of the specified Java type. With
    this, we fill the list with our compact discs example list so that we can present
    it in the web page. This means that we accessed the resource.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦创建响应对象，我们使用 `readEntity()` 方法读取消息实体输入流作为指定 Java 类型的实例。这样，我们就可以用我们的光盘示例列表填充列表，以便在网页中展示。这意味着我们已经访问了资源。
- en: 'If you want to explore more about what we just used in the block of code we
    described, here are some links as references. You can check them out, expand your
    knowledge, and get more details on `RestEasyClient` and `RestEasyClientBuilder`:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想了解更多关于我们在描述的代码块中使用的代码，这里有一些链接作为参考。您可以查看它们，扩展您的知识，并获取更多关于 `RestEasyClient`
    和 `RestEasyClientBuilder` 的详细信息。
- en: '[http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html](http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html)'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html](http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html)'
- en: '[http://docs.jboss.org/resteasy/docs/3.0.2.Final/javadocs/org/jboss/resteasy/client/jaxrs/ResteasyClient.html](http://docs.jboss.org/resteasy/docs/3.0.2.Final/javadocs/org/jboss/resteasy/client/jaxrs/ResteasyClient.html)'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[http://docs.jboss.org/resteasy/docs/3.0.2.Final/javadocs/org/jboss/resteasy/client/jaxrs/ResteasyClient.html](http://docs.jboss.org/resteasy/docs/3.0.2.Final/javadocs/org/jboss/resteasy/client/jaxrs/ResteasyClient.html)'
- en: '[http://docs.jboss.org/resteasy/docs/3.0.1.Final/javadocs/org/jboss/resteasy/client/jaxrs/ResteasyClientBuilder.html#truststore](http://docs.jboss.org/resteasy/docs/3.0.1.Final/javadocs/org/jboss/resteasy/client/jaxrs/ResteasyClientBuilder.html#truststore)'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[http://docs.jboss.org/resteasy/docs/3.0.1.Final/javadocs/org/jboss/resteasy/client/jaxrs/ResteasyClientBuilder.html#truststore](http://docs.jboss.org/resteasy/docs/3.0.1.Final/javadocs/org/jboss/resteasy/client/jaxrs/ResteasyClientBuilder.html#truststore)'
- en: The discstore project
  id: totrans-80
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 光盘存储项目
- en: The next project we are going to create is the `discstore` project; the steps
    to create the project are the same as the previous one, and you can use the Maven
    command or Eclipse IDE.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要创建的下一个项目是 `discstore` 项目；创建项目的步骤与上一个项目相同，您可以使用 Maven 命令或 Eclipse IDE。
- en: 'In this project, we will create a class that will create the list of compact
    discs. This class is pretty simple, and it uses some annotations that have already
    been discussed in previous chapters. The name of this class will be `CompactDiscService`,
    and it will have only one method with several annotations. Let''s start with the
    code, and we will add a short description about it after the code block:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在此项目中，我们将创建一个类，该类将创建光盘列表。这个类相当简单，它使用了一些在前几章中已经讨论过的注解。这个类的名称将是 `CompactDiscService`，它将只有一个带有多个注解的方法。让我们从代码开始，我们将在代码块之后添加一个简短的描述：
- en: '[PRE6]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: As you can see, the method `getCompactDiscs()` is in charge of creating a list
    of strings, which each item will represent as a compact disc as this is an example
    in which we will add three items.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，`getCompactDiscs()` 方法负责创建一个字符串列表，其中每个项目都将代表一张光盘，这是我们将添加三个项目的示例。
- en: The `@Produces` annotations are used to specify the MIME media types, and if
    applied at the method level, the annotations override any `@Produces` annotation
    applied at the class level. The `@GET` annotation, as you already know, will represent
    the HTTP method `GET`. Meanwhile, the `@Path` annotation will help us to set the
    class as a resource, and its name will be `discs`.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '`@Produces` 注解用于指定 MIME 媒体类型，如果应用于方法级别，则这些注解将覆盖在类级别上应用的任何 `@Produces` 注解。如您所知，`@GET`
    注解将代表 HTTP 方法 `GET`。同时，`@Path` 注解将帮助我们设置类为资源，其名称将为 `discs`。'
- en: All the backend has been implemented; we now need to develop some other resources
    in order to let our example function. Remember we specified some web pages in
    the classes up there? Well, that is what we will implement now.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 所有后端功能都已实现；我们现在需要开发一些其他资源，以便我们的示例能够运行。记住我们在上面的类中指定了一些网页吗？嗯，这正是我们现在要实现的。
- en: The oauth-server project
  id: totrans-87
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: oauth-server 项目
- en: As before, in order to create this project, you can use Maven commands or Eclipse
    IDE.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，为了创建此项目，您可以使用 Maven 命令或 Eclipse IDE。
- en: 'In order to turn this application, we must create the `jboss-web.xml` file
    with the following content:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使此应用程序运行，我们必须创建包含以下内容的 `jboss-web.xml` 文件：
- en: '[PRE7]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'One last thing: we have to create a JSON file with the purpose of having our
    certificates and security configuration in this server. We are going to name it
    `resteasy-oauth`. And as you can see, there is not a big deal with this file;
    it is a set of properties and values. Through this file, we specify the KeyStores
    and passwords, the truststore path, and so on. This file will be located in the
    `WEBINF` folder of this project.'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一件事情：我们需要创建一个JSON文件，目的是将我们的证书和安全配置保存在这个服务器上。我们将它命名为`resteasy-oauth`。正如你所见，这个文件并没有什么大不了的；它只是一组属性和值。通过这个文件，我们指定了KeyStores和密码、信任存储库路径等等。这个文件将位于本项目的`WEBINF`文件夹中。
- en: '[PRE8]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: webapp/WEB-INF/ jboss-deployment-structure.xml
  id: totrans-93
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: webapp/WEB-INF/ jboss-deployment-structure.xml
- en: 'We must configure this file in all the projects because we updated some modules
    from the instance of JBoss AS. In this file, we must specify the dependencies
    our application has with some modules of JBoss. Then, we need to clearly set them
    using the `<module>` tag inside the `<dependencies>` tag, as follows:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须在所有项目中配置这个文件，因为我们从JBoss AS实例更新了一些模块。在这个文件中，我们必须指定我们的应用程序与JBoss某些模块的依赖关系。然后，我们需要使用`<dependencies>`标签内的`<module>`标签明确设置它们，如下所示：
- en: '[PRE9]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Running the application
  id: totrans-96
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 运行应用程序
- en: We have explained the main parts of each project, so in order to run and test
    the application, you can download the examples folder of this chapter from [https://github.com/restful-java-web-services-security/source-code/tree/master/chapter04](https://github.com/restful-java-web-services-security/source-code/tree/master/chapter04).
    After you download the ZIP file, unzip it and you will find there is a folder
    named `OAuthExample`. Inside this folder, there are our three projects. You can
    copy them and paste them in your workspace and import the projects using Eclipse.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经解释了每个项目的关键部分，因此为了运行和测试应用程序，你可以从[https://github.com/restful-java-web-services-security/source-code/tree/master/chapter04](https://github.com/restful-java-web-services-security/source-code/tree/master/chapter04)下载本章的示例文件夹。下载ZIP文件后，解压它，你将发现有一个名为`OAuthExample`的文件夹。在这个文件夹中，有我们的三个项目。你可以将它们复制并粘贴到你的工作空间中，并使用Eclipse导入这些项目。
- en: We have provided you the keystores, and certification and truststore files inside
    the `configuration` folder you just pasted while setting up the JBoss `configuration`.
    In order to make sure the application runs correctly, you may update these files,
    by following the instructions in the `.txt` file named `keystoreCommands` located
    inside the `configuration` folder.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经提供了你所需的密钥存储库、证书和信任存储库文件，这些文件位于你设置JBoss `configuration`时粘贴的`configuration`文件夹内。为了确保应用程序正确运行，你可能需要根据`configuration`文件夹内名为`keystoreCommands`的`.txt`文件中的说明更新这些文件。
- en: 'In order to launch our application, we have to deploy it. So, open a terminal.
    Let''s go to `JBOSS_HOME/bin` and start JBoss in standalone mode; this means executing
    `standalone.bat` if you are in Windows or `./standalone.sh` if you are in Linux.
    Then, open a terminal and go inside the folder of our application in the workspace.
    We have to execute the following commands: `mvn clean install` followed by `mvn`
    `jboss-as:deploy` on each one of the three projects that we have created: `discstore`,
    `oauth-client`, and `oauth-server`.'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 为了启动我们的应用程序，我们必须部署它。所以，打开一个终端。让我们进入`JBOSS_HOME/bin`并以独立模式启动JBoss；这意味着如果你在Windows上，执行`standalone.bat`，如果你在Linux上，执行`./standalone.sh`。然后，打开一个终端并进入工作空间中我们的应用程序文件夹。我们必须执行以下命令：`mvn
    clean install`，然后对创建的三个项目（`discstore`、`oauth-client`和`oauth-server`）中的每一个执行`mvn
    jboss-as:deploy`。
- en: 'We have created a special class in the `discstore` project. This class contains
    a `void main` method, and we test our application through this class. We have
    named it `OAuthClientTest`. The code of this class is as follows:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在`discstore`项目中创建了一个特殊类。这个类包含一个`void main`方法，我们通过这个类来测试我们的应用程序。我们将其命名为`OAuthClientTest`。这个类的代码如下：
- en: '[PRE10]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: We are going to explain the preceding code, first, we have two variables, `truststorePath`
    and `truststorePassword`. The first one is referencing the path of our `client-truststore.ts`
    file located in the configuration folder of our JBoss. You should change the value
    of this variable in order to make this test work, so place the path of your configuration
    folder. After this, with a method we already explained, `loadKeyStore ()`, we
    load the KeyStore using the previous variables and we assign this value to a `KeyStore`
    object named `truststore`. From `truststore`, we create the `RestEasyClient` object
    named `client`.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先解释前面的代码，我们有两个变量，`truststorePath` 和 `truststorePassword`。第一个变量引用的是我们位于 JBoss
    配置文件夹中的 `client-truststore.ts` 文件路径。你应该更改这个变量的值以便使这个测试工作，所以请放置你配置文件夹的路径。之后，使用我们已解释过的方法
    `loadKeyStore ()`，我们使用前面的变量来加载 KeyStore，并将这个值赋给一个名为 `truststore` 的 `KeyStore`
    对象。从 `truststore` 中，我们创建了一个名为 `client` 的 `RestEasyClient` 对象。
- en: Now, we will obtain an access token programmatically, so we can request an access
    token from the auth-server simply by using HTTPS invocation. Then we have to use
    basic authentication to identify our user; as a result, we will get back a signed
    access token for that user.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将以编程方式获取访问令牌，这样我们就可以通过使用 HTTPS 调用来从 auth-server 获取访问令牌。然后我们必须使用基本认证来识别我们的用户；结果，我们将为该用户获取一个签名访问令牌。
- en: So, we perform a simple `POST` to the context root of the auth-server with `j_oauth_token_grant`
    at the end of the target URL, because when we use that URL and a `POST` with basic
    authentication, we will obtain an access token for a specific user.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们向 auth-server 的上下文根执行一个简单的 `POST` 请求，并在目标 URL 的末尾加上 `j_oauth_token_grant`，因为当我们使用该
    URL 并执行带有基本认证的 `POST` 请求时，我们将为特定用户获取一个访问令牌。
- en: 'After that, we obtained the access token, which is a simple string. In order
    to invoke on a service protected by bearer token authentication, we have to build
    a string made up of the authorization header of your `HTTPS` request plus the
    string `Bearer` and finally the access token string. This will get back the response
    object, so we can read it and print it as we did in the test. In the console,
    you will see the list of compact discs as shown in the following screenshot:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们获得了访问令牌，它是一个简单的字符串。为了调用受令牌认证保护的服务，我们必须构建一个由你的 `HTTPS` 请求的授权头、字符串 `Bearer`
    以及最终的访问令牌字符串组成的字符串。这将返回响应对象，因此我们可以读取它并像在测试中那样打印它。在控制台中，你会看到如下截图所示的 CD 列表：
- en: '![Running the application](img/0109OS_04_02.jpg)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
  zh: '![运行应用程序](img/0109OS_04_02.jpg)'
- en: SSO configuration for security management
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安全管理的 SSO 配置
- en: SSO is a mechanism for authentication. It allows a user to access several systems
    or applications entering credentials just once. We think you experience this more
    often these days because we are living in a social network era, and most of these
    services let us use each other's credentials to access several services.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: SSO 是一种认证机制。它允许用户通过一次输入凭证即可访问多个系统或应用程序。我们认为你今天可能更经常体验到这一点，因为我们生活在一个社交网络时代，这些服务中的大多数都允许我们使用彼此的凭证来访问多个服务。
- en: After discussing some concepts of SSO, let's try and implement this mechanism.
    In order to achieve this, we will use JBoss 7 Application Server and our earlier
    project `secure-demo`.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在讨论了一些 SSO 的概念之后，让我们尝试实现这个机制。为了实现这一点，我们将使用 JBoss 7 应用程序服务器和我们的早期项目 `secure-demo`。
- en: As a brief introduction to this implementation, we want to tell you that we
    will work with two files; one file belongs to JBoss and the other belongs to our
    application.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 作为对这个实现的简要介绍，我们想告诉你，我们将与两个文件一起工作；一个文件属于 JBoss，另一个属于我们的应用程序。
- en: 'The file that belongs to JBoss is `standalone.xml`. We will add some lines
    to this file. In the following lines of code, let''s add the SSO element in the
    `virtual-server` definition:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 属于 JBoss 的文件是 `standalone.xml`。我们将向这个文件添加一些行。在下面的代码行中，让我们在 `virtual-server`
    定义中添加 SSO 元素：
- en: '[PRE11]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The `reauthenticate` attribute allows us to establish whether each request needs
    to be reauthenticated to `securityReal`. The default value is `false`.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '`reauthenticate` 属性允许我们确定每个请求是否需要重新认证到 `securityReal`。默认值是 `false`。'
- en: 'The next file we must edit is in our application, and its name is `jboss-web.xml`.
    Also, we need to add some lines of code to this file. These lines of code will
    declare the valve that will manage the SSO. In other words, every request will
    go through this valve, as shown in the following code:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Just in case you forgot it or deleted it, we set a security domain in the previous
    chapters. The following block of code must exist in the `standalone.xml` file:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Since we are using the `secure-demo` example, this is all we must modify in
    order to configure SSO.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: In order to test this mechanism, we need another application. We must replicate
    the configuration we just did in our `secure-demo` example.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: When we enter the credentials in one of them, we no longer need to enter the
    credentials in the others, since we have applied SSO. We will authenticate in
    both applications.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: OAuth token via Basic Auth
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now, let's explore and implement a short example of using tokens. In order to
    build this example, we will create a class. This class, as in the previous example,
    will simulate a database client. It will have the same method, `getCompactDiscs()`,
    but we will modify the internal function in this example. Also, it won't receive
    any parameter this time.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: 'Alright, let''s do it! First, create two static string fields in the class.
    The first field will hold the URL for authentication in the auth-server. The other
    field will have the URL showing the compact discs list; you can reuse the same
    web page from the previous example. Then, you should have your variables as shown:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'After this, let''s create our method to obtain the compact discs list. The
    following piece of code shows you exactly how the method is executed:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: It is time to check what we have just done. As a first step, we created a `ResteasyClient`
    object. If you noticed, we used something to disable trust management and hostname
    verification. The result of this invocation is that it turns off server-certificate
    verification allowing MITM (man-in-the-middle) attacks. So, use this feature with
    caution.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: After this, we create a `form` object and pass in some parameters. These parameters
    are passed in through the `param()` method, representing the parameter name and
    parameter value, respectively. This means we specify the type of grant being requested
    by the application, which will be `client_credentials`.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: Then, as we did before in the previous example, let's create a RESTEasy web
    target that will target our URL showing the compact discs list. Remember that
    this URL was set in a static field we created earlier. This web target will be
    the `resourceTarget` object that we will access.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: When we use the `register()` method and pass in a `BasicAuthentication` object,
    we register an instance of a custom JAX-RS component to be instantiated and used
    in the scope of this configurable context.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: Moving forward, we create the `AccessTokenResponse` class by executing a request
    to our web target. Then, in the same line, we execute a post in order to send
    the entity and the response type we want to obtain for the current request synchronously.
    The `Entity.form()` method creates the `application/x-www-form-urlencoded` entity
    from the `form` object we created before. Now, this will return an `AccessTokenResponse`
    object; we use this object to build the bearer token by adding the word `Bearer`
    at the beginning of the token.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: Finally, let's create the response object by executing a request to the URL
    that is set in the `urlDiscs` variable. We should use the `ResteasyClient` object
    to target this resource, and then execute the request and set the headers field
    with `HttpHeaders.AUTHORIZATION` using the `bearer` token set in the variable
    `bearerToken`. In this way, we gain access to the target resource; in this case,
    we can see the information.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: As we keep using the same application business, we can reuse the web pages of
    the previous example. Make sure to incorporate in to your example, in the same
    path as in the previous example, the web pages `index.html` and `discsList.jsp`.
    We will also use the configuration set in the `jboss-deployment-structure.xml`
    file since we are using the same module dependencies.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: 'Our `web.xml` file should look simpler than the previous example, so it might
    be something like the following:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Running the application
  id: totrans-136
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You can download the complete code and configuration from [https://github.com/restful-java-web-services-security/source-code/tree/master/chapter04](https://github.com/restful-java-web-services-security/source-code/tree/master/chapter04).
    Unzip the file, and inside you will find a folder named `token-grant`. You have
    to deploy this project using the same commands. As a requirement, you have to
    deploy the projects `oauth-server`, `oauth-client`, and `discstore`.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: 'It is time to run our application. Let''s execute the steps we did in the previous
    example, the OAuth example. After this, we have to open our favorite browser and
    type the URL `https://localhost:8443/token-grant/`. This will lead us to the following
    web page:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: '![Running the application](img/0109OS_04_03.jpg)'
  id: totrans-139
  prefs: []
  type: TYPE_IMG
- en: 'Well, as you notice, we reused the same web page, just for the purpose of these
    examples. There is, however, a little difference; when calling a different web
    page, you can look in the core we just explained. This will execute a token, where
    we will perform a request to the data we want to access through this token. As
    a result, we will read the list of our compact discs in the web page, as shown
    in the following screenshot:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: '![Running the application](img/0109OS_04_04.jpg)'
  id: totrans-141
  prefs: []
  type: TYPE_IMG
- en: The final result is the capability to present the discs list in the web page.
    However, don't forget what happened; we just obtained an access token response
    using the request, the basic authentication with our credentials, and a form.
    With the access token response, we can create the response and present the data
    with the respective authorization.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: Custom filters
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As a brief introduction, JAX-RS 2.0 has two different concepts for interceptions:
    filters and interceptors.'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: 'Interceptors are components that intercept EJB method invocations. They can
    be used to audit and log as and when EJBs are accessed. This is a topic that won''t
    be included in this book, but if you feel curious and want to find out some more
    about it, we give you the following links as references so you can look it up:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: '[http://docs.oracle.com/javaee/6/tutorial/doc/gkigq.html](http://docs.oracle.com/javaee/6/tutorial/doc/gkigq.html)'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[http://www.javacodegeeks.com/2013/07/java-ee-ejb-interceptors-tutorial-and-example.html](http://www.javacodegeeks.com/2013/07/java-ee-ejb-interceptors-tutorial-and-example.html)'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Filters are mainly used to alter or process incoming and outgoing request or
    response headers. They can be executed before and after request and response processing.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: 'Also, JAX-RS 2.0 offers us two categories of filters: server-side filters and
    client-side filters. The following diagram shows us a better classification of
    this concept:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: '![Custom filters](img/0109OS_04_05.jpg)'
  id: totrans-150
  prefs: []
  type: TYPE_IMG
- en: Server-side filters
  id: totrans-151
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When we are on the server side, we have another classification for these filters;
    container request filters are executed before the JAX-RS resource method is invoked.
    Also, we have the container response filters; you''ve probably guessed, they are
    executed after the JAX-RS resource method is invoked. However, this doesn''t end
    here; there is another classification of container request filters: pre-matching
    and post-matching.'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: You can specify a pre-matching container request filter through the `@PreMatching`
    annotation, and this means that the filter will be executed before the JAX-RS
    resource method is matched with the incoming HTTP request.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: Container request filters can abort the request by executing the `abortWith
    (Response)` method. A filter might want to abort if it implements a custom authentication
    protocol.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: Once the resource class method has been executed, JAX-RS will run all container
    response filters. These filters let you modify the outgoing response before it
    is marshalled and is sent to the client.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: Client-side filters
  id: totrans-156
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As we already told you, there are filters on the client side too, and similar
    to the server-side filters, they also have two types of filters: client request
    filters and client response filters. Client request filters are executed before
    your HTTP request is sent over the wire to the server. On the other hand, client
    response filters run after a response is received from the server, but before
    the response body is assembled.'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: Client request filters are also capable of aborting the request and providing
    a response without going over the wire to the server. Client response filters
    are capable of altering the response object before it is handed back to the application
    code.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: Example usage of filters
  id: totrans-159
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: After looking at some of the necessary theory around this topic, it is time
    to get your feet wet. Now, we will implement an example in order to support our
    new theoretical knowledge. So, let's start!
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: 'We will implement an interceptor that will verify the access permissions for
    a user, based on the username and password sent in the request. You can download
    the complete code of this example from the following link:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/restful-java-web-services-security/source-code/tree/master/chapter04](https://github.com/restful-java-web-services-security/source-code/tree/master/chapter04)'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: 'We have the topic of our compact discs store. So, the following class will
    represent our service, and it will have the functions to find the compact discs
    by name and update the compact disc information. The annotations used here have
    already been studied in the previous chapter, so you will probably find the following
    code understandable:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: As you can see, we have created only two methods, one to retrieve compact discs
    by name and the other to update the compact discs' price. The annotations let
    us know that the method `getCompactDiscByName()` can be accessed and executed
    by all; meanwhile, the method `updatePriceByDiscName()` can be accessed and executed
    by users with the role `ADMIN`.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: 'If you noticed in the preceding code, we used the class `CompactDiscDatabase`,
    which simulates a database. We applied the same technique in the previous examples.
    As it worked very well, let''s do it again. This class doesn''t have any special
    code. You can get an idea about this from the following code:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: There is nothing complex here; we just created a map and put one entry there.
    This entry is a compact disc object, as you can tell. We have two static methods
    that will simulate queries—a SELECT statement and an UPDATE statement.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s check our `CompactDisc` class, as shown in the following code:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: In this class, we just set the fields that represent a common compact disc attribute.
    The annotation `@XmlElement` is used to map a property to an XML element derived
    from a property name.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: Now, it is time to implement the filter. We will show you the code after this
    short introduction, explain what we have done, and explain some technical concepts
    used in the implementation. Ready? Here we go!
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: 'Since the code of this class is a little bit long, we will split it and include
    a short description after each block of code, as follows:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Let's check out this code. The first step, in order to implement a filter, is
    the annotation `@Provider`. When we place this annotation at class level, we set
    the class as a filter. Our class name is `SecurityFilter`, and as you can see,
    it implements the interface `ContainerRequestFilter`. If you remember, this filter
    will execute on the server side and before the resource method is invoked.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: At the start of our class's body, we set some constants that we will use later.
    The `AUTHORIZATION_PROPERTY` constant represents just the name of a property,
    as does the `RESOURCE_METHOD_INVOKER` constant. The `AUTHENTICATION_SCHEME` constant
    represents just a string. Both `ACCESS_DENIED` and `ACCESS_FORBIDDEN` constants
    represent two different server response objects in order to notify the user of
    the result of their request when it is denied or the user doesn't have enough
    permission.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: As we implemented the interface `ContainerRequestFilter`, we must override the
    `filter()` method. It is inside this method that we will put our logic for the
    purpose of filtering the request based on the user that executed the request.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start. As a first step, we obtain the method of the request using the
    constant `RESOURCE_METHOD_INVOKER`. After this, we will have a `ResourceMethodInvoker`
    object, and then the `Method` object, as shown in the following code:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Next, we will perform some simple validations over `method`. We will check
    whether the method is annotated with `@PermitAll`. If it isn''t, then the method
    continues, and we check whether it is annotated with `@DenyAll`. If the method
    is annotated with `DenyAll`, then we abort the request, including the constant
    `ACCESS_FORBIDDEN`, as shown in the following code:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Now, we have to obtain the username and password. We must first obtain the
    headers of the request and put it in a map. Then, we obtain the authorization
    string list using `constant AUTHORIZATION_PROPERTY` as a key. This list will let
    us know whether the user has enough permission or not. So, we check if the list
    is empty or null; if it enters the `if()` block, we abort the request, including
    the constant `ACCESS_DENIED`, as shown in the following code:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'This list has the encoded username and password as a string in the first element.
    So, we execute a replacement and eliminate the string contained in the constant
    `AUTHENTICATION_SCHEME`. Then, we decode it using the `Base64.decodeBase64` decoder,
    and through `StringTokenizer`, we obtain the username and password separated.
    Let''s look at the following code:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Now is the time to evaluate and check whether the user has enough permission.
    First, let''s check whether `method` has the `@RolesAllowed` annotation; if it
    does, we obtain the set of roles allowed using the object `method`. Finally, we
    check whether the constant `ADMIN` is included in this list. If it is not, the
    request is aborted and `ACCESS_DENIED` is once again included, as shown in the
    following code:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Summary
  id: totrans-188
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we studied and implemented one of the most useful and necessary
    techniques with the purpose of sharing and protecting our information. Nowadays,
    applications have dramatically increased their interaction with each other because
    they want to meet and satisfy the requirements of clients, users, and so on, compromising
    neither the security nor the integrity of the data while doing this.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we studied several technologies to secure, limit, and authorize
    the use of our resources to a third-party application, starting with brief but
    descriptive concepts about OAuth 2.0 authentication, Single Sign-On, filters,
    and tokens.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: Through a practical example and real code, you witnessed how you can grant permission
    over specific resources to a third-party application in order to share the information
    and maintain control over it. Also, we checked and worked with specific code to
    implement one of the most used technologies in recent times, especially in the
    world of social networks, Single Sign-On. Now, you can put in to practice these
    concepts and technologies in order to build applications to interact with each
    other, selecting which resource you want to be shared, which applications you
    want to use as Single Sign-On, and filtering the use of certain resources based
    on the user and role.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
