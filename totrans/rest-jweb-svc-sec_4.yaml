- en: Chapter 4. RESTEasy Skeleton Key
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Welcome to the fourth chapter! We hope you are enjoying the book, and even more
    important, learning and understanding what we are transmitting and teaching you.
    It is time to move forward and immerse yourself in a new chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Once you read this chapter, you will have the knowledge to design, implement,
    and aggregate additional security levels to your RESTEasy applications, all of
    this using OAuth and RESTEasy Skeleton Key and some other specific requirements
    of these technologies, such as setting up an OAuth server. You will learn through
    practical and descriptive examples of applications, just as we did in previous
    chapters; we won't get stuck in theory only, and we'll implement applications
    and explain specific methods and classes to implement OAuth.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, you will learn about the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: OAuth and RESTEasy
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: SSO configuration for security management
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Access tokens
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Custom filters
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Web services clients for test
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As you have probably experienced, if you have an account on one or several social
    networks, a lot of these social networks allow you to share information between
    them or post something in all of them. This is a sign that applications need to
    share information and also use resources that are in other applications. In this
    example, it can be your account or your contact list. This involves sensitive
    information, so it needs to be protected. Also, limited permissions over resources
    means that a third-party application can only read your contacts list. This opens
    the door to a very important, attractive, and useful feature among applications,
    which is the capacity to use resources on behalf of the user. Of course, you may
    ask how the latter authorizes the use? Well, this chapter will show you. So, let's
    go!
  prefs: []
  type: TYPE_NORMAL
- en: OAuth protocol
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This is an open protocol that allows you to grant safe authorization to your
    private resources from one site (service provider) to another (consumer) without
    sharing your identity.
  prefs: []
  type: TYPE_NORMAL
- en: A practical example is when you grant authorization to a website or an application
    to use the contact list in your phone or social network.
  prefs: []
  type: TYPE_NORMAL
- en: OAuth and RESTEasy Skeleton Key
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will review some concepts related to OAuth as an authentication
    framework, RESTEasy Skeleton Key, and how they work together. You will check out
    some features of these technologies and get your hands dirty with some code as
    a practical example.
  prefs: []
  type: TYPE_NORMAL
- en: What is RESTEasy Skeleton Key?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: RESTEasy Skeleton Key provides a unified way for browser and JAX-RS clients
    to be secured. This allows executing and forwarding requests in a network of applications
    and services in a secure and scalable way, without interacting with a central
    authentication server every time a request appears.
  prefs: []
  type: TYPE_NORMAL
- en: OAuth 2.0 authentication framework
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This enables third-party applications or services access to an HTTP resource
    on behalf of the resource owner. It also prevents the third-party application
    or service from getting in contact with the owner's credentials. This is possible
    through issuing access tokens via browsers and using a direct grant.
  prefs: []
  type: TYPE_NORMAL
- en: With the two concepts explained in a nutshell, it is time to describe how they
    are related. RESTEasy Skeleton Key is an OAuth 2.0 implementation that uses the
    JBoss AS 7 security infrastructure in order to secure web applications and RESTful
    services.
  prefs: []
  type: TYPE_NORMAL
- en: This means that you can transform a web application into an OAuth 2.0 access
    token provider, and you can also transform the JBoss AS 7 security domain into
    a central authentication and authorization server, where applications and services
    can interact with each other.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram describes this process in a better way:'
  prefs: []
  type: TYPE_NORMAL
- en: '![OAuth 2.0 authentication framework](img/0109OS_04_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Main features
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We want to help you understand these technologies and clarify what they are
    used for; this is why we will name some of their main features. With OAuth 2.0
    and RESTEasy Skeleton Key, you can perform the following functions:'
  prefs: []
  type: TYPE_NORMAL
- en: Transform a servlet-form-auth-based web application into an OAuth 2.0 provider.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Provide distributed **Single Sign-On** (**SSO**) throughout a central authentication
    server in order to log in once and access any browser-based application configured
    in the domain in a secure way.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use just one link and log out from all the distributed applications that were
    configured with SSO.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Make a web application interact with a remote RESTful service using access tokens.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sign access tokens with OAuth 2.0 and use the tokens later to access any service
    configured in the domain. The token has Identity and Role Mapping, and there is
    no need to overload the central authentication server with every request that
    appears because tokens are digitally signed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can find more information about these topics at [http://docs.jboss.org/resteasy/docs/3.0-beta-2/userguide/html/oauth2.html](http://docs.jboss.org/resteasy/docs/3.0-beta-2/userguide/html/oauth2.html).
  prefs: []
  type: TYPE_NORMAL
- en: We will discuss the most important parts, but it might be useful for you.
  prefs: []
  type: TYPE_NORMAL
- en: OAuth2 implementation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We have just reviewed some of the main concepts that we will deal with in this
    chapter, but this is not enough. We must implement a descriptive example so that
    we can completely understand these topics.
  prefs: []
  type: TYPE_NORMAL
- en: Updating RESTEasy modules in JBoss
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In order not to mess with your JBoss configuration or anything else, we will
    use another brand new instance of JBoss. We have to update some modules that are
    related to RESTEasy. We can do this very easily. Let's visit the link [http://resteasy.jboss.org/](http://resteasy.jboss.org/);
    at your right, you will find a panel with the title **Useful Links**, which has
    a download link. Click on it to visit another page that has a bunch of download
    links. In this example, we use the 3.0.7.Final Version. Download this version
    in order to go forward.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you have downloaded and unzipped it, you will find another `.zip` file
    named `resteasy-jboss-modules-3.0.7.Final`; this file contains some JARs that
    will update your JBoss modules. So, unzip it, copy all folders into `JBOSS_HOME/modules/`,
    and replace all coincidences. There is one last step: we have to update the JAR
    files'' version and modify the module XML in JBoss in order to set `org.apache.httpcomponents`
    to use `httpclient-4.2.1.jar`, `httpcore-4.2.1.jar` and `httpmime-4.2.1.jar` because
    the current latest Version is 4.3.4, which works fine too. So, copy these JARs
    and update the version in the `module.xml` file in `JBOSS_HOME/modules/org/apache`
    folder. Now, we have updated our modules for RESTEasy.'
  prefs: []
  type: TYPE_NORMAL
- en: Setting up the configuration in JBoss
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For the next step in getting our JBoss ready for our example, we must go to
    [https://github.com/restful-java-web-services-security/source-code/tree/master/chapter04](https://github.com/restful-java-web-services-security/source-code/tree/master/chapter04)
    and download the `chapter04` examples zip file. Unzip and you will find a folder
    named `configuration`. This folder contains the files necessary for setting up
    our JBoss configuration. So, copy the files and replace the configuration folder
    in your JBoss located at `JBOSS_HOME/standalone/configuration`.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing an OAuth client
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In order to develop this example, we investigate a very useful example and
    apply it to a new project. This example is composed of several projects; each
    project will produce a WAR file. The purpose of this example is to demonstrate
    how OAuth works and explain the way you can implement this technology at a technical
    level. So, we will simulate several things in order to create the environment
    where we can apply this implementation. The complete code can be downloaded from
    the following link:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/restful-java-web-services-security/source-code/tree/master/chapter04/oauth2-as7-example](https://github.com/restful-java-web-services-security/source-code/tree/master/chapter04/oauth2-as7-example)'
  prefs: []
  type: TYPE_NORMAL
- en: The oauth-client project
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: First we are going to create the `oauth-client` webapp project. You can use
    the Maven command we have used before in previous chapters or you can use Eclipse
    IDE in order to perform this.
  prefs: []
  type: TYPE_NORMAL
- en: 'After that, let''s add some dependencies in order to implement our client.
    These dependencies are for all the projects. Go to the `pom.xml` file and make
    sure to add the following dependencies inside the `<dependencies>` tag:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Let's start by creating the package `com.packtpub.resteasy.example.oauth`. Then,
    create the class `public class Loader implements ServletContextListener`, which
    implements `ServletContextListener`, because we will load a key store and initialize
    a context.
  prefs: []
  type: TYPE_NORMAL
- en: Let's add a field into our class `private ServletOAuthClient oauthClient`, which
    will represent our OAuth client object.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, let''s create the method shown in the following piece of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: This method receives two parameters, the filename and the password, and creates
    the object `KeyStore`. It also creates a `FileInputStream` object from the filename
    received so that it can use it to load the `KeyStore` object, and it uses the
    password received in the form of a char array.
  prefs: []
  type: TYPE_NORMAL
- en: 'After this, as our class implements the `ServletContextListener` interface,
    we have to override some methods. The first method to override is `contextInitialized`.
    Let''s do it as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Through this method, we will accomplish several things. As you can see, we set
    two internal variables; one is set with the path to our `client-truststore.ts`
    file and the other is set to the password. Make sure to paste the file in the
    path we specified in the variable (`JBOSS_HOME/standalone/configuration`).
  prefs: []
  type: TYPE_NORMAL
- en: After this, we load the `KeyStore` object using the path and password we specified
    in the variables, obtaining another `KeyStore` object through this.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, it''s time to instantiate and set the properties of our OAuth client object.
    In the previous code, we set the following properties: `trustStore`, `clientId`,
    `password`, `authUrl`, and `codeUrl`.'
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we create the client to obtain an access token from the code. In order
    to accomplish this, we use the `start()` method. Also, we set the attribute servlet
    OAuth client with the OAuth client object we just created.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to finish our OAuth client, we need to override a second method named
    `public void contextDestroyed(ServletContextEvent sce)`, as shown in the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: This method will be executed when the servlet context is about to shut down,
    our application is redeploying, and so on. The method closes the client instance
    and all its associated resources.
  prefs: []
  type: TYPE_NORMAL
- en: 'We implemented our OAuth client for our example. We need another resource.
    This time, we will create a class that works as a database client for our compact
    discs store. So, let''s name it `CompactDiscsDatabaseClient`, and we will get
    the two following methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '`public static void redirect(HttpServletRequest request, HttpServletResponse
    response)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`public static List<String> getCompactDiscs(HttpServletRequest request)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'So, let''s begin implementing the first method. This method is explained as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding method, we obtain the `ServletOAuthClient` object from the
    `ServletContext` obtained from the request; the servlet OAuth client is in the
    servlet context as an attribute named `ServletOAuthClient`. Remember that in the
    first class we created, we set this attribute in the servlet context.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we start the process of getting an access token by redirecting the
    browser to the authentication server through `redirectRelative (String relativePath,
    HttpServletRequest request, HttpServletResponse response)`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s move on with the next method that loads the discs. The following
    code represents the method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Let's check what we have up here. In the preceding `getCompactDiscs ()` method,
    we create a `ServletOAuthClient` object that is in charge of starting the process
    of obtaining an access token by redirecting the browser to the authentication
    server. Once again, we obtain the attribute from the `ServletContext` object from
    the request. Then, we create a `ResteasyClient` object using a new instance of
    `ResteasyClientBuilder()`; this class is an abstraction to create clients and
    allows SSL configuration.
  prefs: []
  type: TYPE_NORMAL
- en: We then set the client-side trust store with the `trustStore()` method. This
    invocation will return a `KeyStore` object and set the client-side trust store.
    After this, we invoke the `hostnameVerification()` method, which sets an SSL policy
    used to verify hostnames. Finally, using the `build()` method, we build a new
    client instance with the entire configuration previously specified in this client
    builder. This will return an instance of `ResteasyClient`.
  prefs: []
  type: TYPE_NORMAL
- en: Let's move on to create an internal variable which will hold the URL of the
    resource that we will set as our target resource. Also, we will create another
    internal variable to hold the bearer token as a string. This string will comprise
    the word `Bearer` followed by the bearer token from the servlet OAuth client and
    request.
  prefs: []
  type: TYPE_NORMAL
- en: Now, in order to create the response, we will use the servlet OAuth client we
    just created. Let's use the variable `urlDiscs` as a parameter and create a new
    web resource target through the `target()` method. After this, using the `request()`
    method, we set up a request to the targeted web resource we just set.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we add a header by invoking the `header()` method, which will receive
    two parameters: the first parameter represents the header''s name and the second
    parameter is the header''s value. After this, we invoke the `HTTP GET` method
    for the current request.'
  prefs: []
  type: TYPE_NORMAL
- en: Just to clarify, the `HttpHeaders.AUTHORIZATION` constant represents the header
    field in the specific case when a user wants to authenticate themselves with a
    server. It does so by adding an authorization request-header field along with
    the request. On the other hand, the authorization field value is composed of credentials
    that contain the authentication information of the user for the realm of the resource
    being requested.
  prefs: []
  type: TYPE_NORMAL
- en: Once the response object is created, we use the `readEntity()` method to read
    the message entity input stream as an instance of the specified Java type. With
    this, we fill the list with our compact discs example list so that we can present
    it in the web page. This means that we accessed the resource.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to explore more about what we just used in the block of code we
    described, here are some links as references. You can check them out, expand your
    knowledge, and get more details on `RestEasyClient` and `RestEasyClientBuilder`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html](http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[http://docs.jboss.org/resteasy/docs/3.0.2.Final/javadocs/org/jboss/resteasy/client/jaxrs/ResteasyClient.html](http://docs.jboss.org/resteasy/docs/3.0.2.Final/javadocs/org/jboss/resteasy/client/jaxrs/ResteasyClient.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[http://docs.jboss.org/resteasy/docs/3.0.1.Final/javadocs/org/jboss/resteasy/client/jaxrs/ResteasyClientBuilder.html#truststore](http://docs.jboss.org/resteasy/docs/3.0.1.Final/javadocs/org/jboss/resteasy/client/jaxrs/ResteasyClientBuilder.html#truststore)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The discstore project
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The next project we are going to create is the `discstore` project; the steps
    to create the project are the same as the previous one, and you can use the Maven
    command or Eclipse IDE.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this project, we will create a class that will create the list of compact
    discs. This class is pretty simple, and it uses some annotations that have already
    been discussed in previous chapters. The name of this class will be `CompactDiscService`,
    and it will have only one method with several annotations. Let''s start with the
    code, and we will add a short description about it after the code block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the method `getCompactDiscs()` is in charge of creating a list
    of strings, which each item will represent as a compact disc as this is an example
    in which we will add three items.
  prefs: []
  type: TYPE_NORMAL
- en: The `@Produces` annotations are used to specify the MIME media types, and if
    applied at the method level, the annotations override any `@Produces` annotation
    applied at the class level. The `@GET` annotation, as you already know, will represent
    the HTTP method `GET`. Meanwhile, the `@Path` annotation will help us to set the
    class as a resource, and its name will be `discs`.
  prefs: []
  type: TYPE_NORMAL
- en: All the backend has been implemented; we now need to develop some other resources
    in order to let our example function. Remember we specified some web pages in
    the classes up there? Well, that is what we will implement now.
  prefs: []
  type: TYPE_NORMAL
- en: The oauth-server project
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: As before, in order to create this project, you can use Maven commands or Eclipse
    IDE.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to turn this application, we must create the `jboss-web.xml` file
    with the following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'One last thing: we have to create a JSON file with the purpose of having our
    certificates and security configuration in this server. We are going to name it
    `resteasy-oauth`. And as you can see, there is not a big deal with this file;
    it is a set of properties and values. Through this file, we specify the KeyStores
    and passwords, the truststore path, and so on. This file will be located in the
    `WEBINF` folder of this project.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: webapp/WEB-INF/ jboss-deployment-structure.xml
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'We must configure this file in all the projects because we updated some modules
    from the instance of JBoss AS. In this file, we must specify the dependencies
    our application has with some modules of JBoss. Then, we need to clearly set them
    using the `<module>` tag inside the `<dependencies>` tag, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Running the application
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: We have explained the main parts of each project, so in order to run and test
    the application, you can download the examples folder of this chapter from [https://github.com/restful-java-web-services-security/source-code/tree/master/chapter04](https://github.com/restful-java-web-services-security/source-code/tree/master/chapter04).
    After you download the ZIP file, unzip it and you will find there is a folder
    named `OAuthExample`. Inside this folder, there are our three projects. You can
    copy them and paste them in your workspace and import the projects using Eclipse.
  prefs: []
  type: TYPE_NORMAL
- en: We have provided you the keystores, and certification and truststore files inside
    the `configuration` folder you just pasted while setting up the JBoss `configuration`.
    In order to make sure the application runs correctly, you may update these files,
    by following the instructions in the `.txt` file named `keystoreCommands` located
    inside the `configuration` folder.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to launch our application, we have to deploy it. So, open a terminal.
    Let''s go to `JBOSS_HOME/bin` and start JBoss in standalone mode; this means executing
    `standalone.bat` if you are in Windows or `./standalone.sh` if you are in Linux.
    Then, open a terminal and go inside the folder of our application in the workspace.
    We have to execute the following commands: `mvn clean install` followed by `mvn`
    `jboss-as:deploy` on each one of the three projects that we have created: `discstore`,
    `oauth-client`, and `oauth-server`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We have created a special class in the `discstore` project. This class contains
    a `void main` method, and we test our application through this class. We have
    named it `OAuthClientTest`. The code of this class is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: We are going to explain the preceding code, first, we have two variables, `truststorePath`
    and `truststorePassword`. The first one is referencing the path of our `client-truststore.ts`
    file located in the configuration folder of our JBoss. You should change the value
    of this variable in order to make this test work, so place the path of your configuration
    folder. After this, with a method we already explained, `loadKeyStore ()`, we
    load the KeyStore using the previous variables and we assign this value to a `KeyStore`
    object named `truststore`. From `truststore`, we create the `RestEasyClient` object
    named `client`.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we will obtain an access token programmatically, so we can request an access
    token from the auth-server simply by using HTTPS invocation. Then we have to use
    basic authentication to identify our user; as a result, we will get back a signed
    access token for that user.
  prefs: []
  type: TYPE_NORMAL
- en: So, we perform a simple `POST` to the context root of the auth-server with `j_oauth_token_grant`
    at the end of the target URL, because when we use that URL and a `POST` with basic
    authentication, we will obtain an access token for a specific user.
  prefs: []
  type: TYPE_NORMAL
- en: 'After that, we obtained the access token, which is a simple string. In order
    to invoke on a service protected by bearer token authentication, we have to build
    a string made up of the authorization header of your `HTTPS` request plus the
    string `Bearer` and finally the access token string. This will get back the response
    object, so we can read it and print it as we did in the test. In the console,
    you will see the list of compact discs as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Running the application](img/0109OS_04_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: SSO configuration for security management
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: SSO is a mechanism for authentication. It allows a user to access several systems
    or applications entering credentials just once. We think you experience this more
    often these days because we are living in a social network era, and most of these
    services let us use each other's credentials to access several services.
  prefs: []
  type: TYPE_NORMAL
- en: After discussing some concepts of SSO, let's try and implement this mechanism.
    In order to achieve this, we will use JBoss 7 Application Server and our earlier
    project `secure-demo`.
  prefs: []
  type: TYPE_NORMAL
- en: As a brief introduction to this implementation, we want to tell you that we
    will work with two files; one file belongs to JBoss and the other belongs to our
    application.
  prefs: []
  type: TYPE_NORMAL
- en: 'The file that belongs to JBoss is `standalone.xml`. We will add some lines
    to this file. In the following lines of code, let''s add the SSO element in the
    `virtual-server` definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The `reauthenticate` attribute allows us to establish whether each request needs
    to be reauthenticated to `securityReal`. The default value is `false`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next file we must edit is in our application, and its name is `jboss-web.xml`.
    Also, we need to add some lines of code to this file. These lines of code will
    declare the valve that will manage the SSO. In other words, every request will
    go through this valve, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Just in case you forgot it or deleted it, we set a security domain in the previous
    chapters. The following block of code must exist in the `standalone.xml` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Since we are using the `secure-demo` example, this is all we must modify in
    order to configure SSO.
  prefs: []
  type: TYPE_NORMAL
- en: In order to test this mechanism, we need another application. We must replicate
    the configuration we just did in our `secure-demo` example.
  prefs: []
  type: TYPE_NORMAL
- en: When we enter the credentials in one of them, we no longer need to enter the
    credentials in the others, since we have applied SSO. We will authenticate in
    both applications.
  prefs: []
  type: TYPE_NORMAL
- en: OAuth token via Basic Auth
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now, let's explore and implement a short example of using tokens. In order to
    build this example, we will create a class. This class, as in the previous example,
    will simulate a database client. It will have the same method, `getCompactDiscs()`,
    but we will modify the internal function in this example. Also, it won't receive
    any parameter this time.
  prefs: []
  type: TYPE_NORMAL
- en: 'Alright, let''s do it! First, create two static string fields in the class.
    The first field will hold the URL for authentication in the auth-server. The other
    field will have the URL showing the compact discs list; you can reuse the same
    web page from the previous example. Then, you should have your variables as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'After this, let''s create our method to obtain the compact discs list. The
    following piece of code shows you exactly how the method is executed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: It is time to check what we have just done. As a first step, we created a `ResteasyClient`
    object. If you noticed, we used something to disable trust management and hostname
    verification. The result of this invocation is that it turns off server-certificate
    verification allowing MITM (man-in-the-middle) attacks. So, use this feature with
    caution.
  prefs: []
  type: TYPE_NORMAL
- en: After this, we create a `form` object and pass in some parameters. These parameters
    are passed in through the `param()` method, representing the parameter name and
    parameter value, respectively. This means we specify the type of grant being requested
    by the application, which will be `client_credentials`.
  prefs: []
  type: TYPE_NORMAL
- en: Then, as we did before in the previous example, let's create a RESTEasy web
    target that will target our URL showing the compact discs list. Remember that
    this URL was set in a static field we created earlier. This web target will be
    the `resourceTarget` object that we will access.
  prefs: []
  type: TYPE_NORMAL
- en: When we use the `register()` method and pass in a `BasicAuthentication` object,
    we register an instance of a custom JAX-RS component to be instantiated and used
    in the scope of this configurable context.
  prefs: []
  type: TYPE_NORMAL
- en: Moving forward, we create the `AccessTokenResponse` class by executing a request
    to our web target. Then, in the same line, we execute a post in order to send
    the entity and the response type we want to obtain for the current request synchronously.
    The `Entity.form()` method creates the `application/x-www-form-urlencoded` entity
    from the `form` object we created before. Now, this will return an `AccessTokenResponse`
    object; we use this object to build the bearer token by adding the word `Bearer`
    at the beginning of the token.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, let's create the response object by executing a request to the URL
    that is set in the `urlDiscs` variable. We should use the `ResteasyClient` object
    to target this resource, and then execute the request and set the headers field
    with `HttpHeaders.AUTHORIZATION` using the `bearer` token set in the variable
    `bearerToken`. In this way, we gain access to the target resource; in this case,
    we can see the information.
  prefs: []
  type: TYPE_NORMAL
- en: As we keep using the same application business, we can reuse the web pages of
    the previous example. Make sure to incorporate in to your example, in the same
    path as in the previous example, the web pages `index.html` and `discsList.jsp`.
    We will also use the configuration set in the `jboss-deployment-structure.xml`
    file since we are using the same module dependencies.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our `web.xml` file should look simpler than the previous example, so it might
    be something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Running the application
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You can download the complete code and configuration from [https://github.com/restful-java-web-services-security/source-code/tree/master/chapter04](https://github.com/restful-java-web-services-security/source-code/tree/master/chapter04).
    Unzip the file, and inside you will find a folder named `token-grant`. You have
    to deploy this project using the same commands. As a requirement, you have to
    deploy the projects `oauth-server`, `oauth-client`, and `discstore`.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is time to run our application. Let''s execute the steps we did in the previous
    example, the OAuth example. After this, we have to open our favorite browser and
    type the URL `https://localhost:8443/token-grant/`. This will lead us to the following
    web page:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Running the application](img/0109OS_04_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Well, as you notice, we reused the same web page, just for the purpose of these
    examples. There is, however, a little difference; when calling a different web
    page, you can look in the core we just explained. This will execute a token, where
    we will perform a request to the data we want to access through this token. As
    a result, we will read the list of our compact discs in the web page, as shown
    in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Running the application](img/0109OS_04_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The final result is the capability to present the discs list in the web page.
    However, don't forget what happened; we just obtained an access token response
    using the request, the basic authentication with our credentials, and a form.
    With the access token response, we can create the response and present the data
    with the respective authorization.
  prefs: []
  type: TYPE_NORMAL
- en: Custom filters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As a brief introduction, JAX-RS 2.0 has two different concepts for interceptions:
    filters and interceptors.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Interceptors are components that intercept EJB method invocations. They can
    be used to audit and log as and when EJBs are accessed. This is a topic that won''t
    be included in this book, but if you feel curious and want to find out some more
    about it, we give you the following links as references so you can look it up:'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://docs.oracle.com/javaee/6/tutorial/doc/gkigq.html](http://docs.oracle.com/javaee/6/tutorial/doc/gkigq.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[http://www.javacodegeeks.com/2013/07/java-ee-ejb-interceptors-tutorial-and-example.html](http://www.javacodegeeks.com/2013/07/java-ee-ejb-interceptors-tutorial-and-example.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Filters are mainly used to alter or process incoming and outgoing request or
    response headers. They can be executed before and after request and response processing.
  prefs: []
  type: TYPE_NORMAL
- en: 'Also, JAX-RS 2.0 offers us two categories of filters: server-side filters and
    client-side filters. The following diagram shows us a better classification of
    this concept:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Custom filters](img/0109OS_04_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Server-side filters
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When we are on the server side, we have another classification for these filters;
    container request filters are executed before the JAX-RS resource method is invoked.
    Also, we have the container response filters; you''ve probably guessed, they are
    executed after the JAX-RS resource method is invoked. However, this doesn''t end
    here; there is another classification of container request filters: pre-matching
    and post-matching.'
  prefs: []
  type: TYPE_NORMAL
- en: You can specify a pre-matching container request filter through the `@PreMatching`
    annotation, and this means that the filter will be executed before the JAX-RS
    resource method is matched with the incoming HTTP request.
  prefs: []
  type: TYPE_NORMAL
- en: Container request filters can abort the request by executing the `abortWith
    (Response)` method. A filter might want to abort if it implements a custom authentication
    protocol.
  prefs: []
  type: TYPE_NORMAL
- en: Once the resource class method has been executed, JAX-RS will run all container
    response filters. These filters let you modify the outgoing response before it
    is marshalled and is sent to the client.
  prefs: []
  type: TYPE_NORMAL
- en: Client-side filters
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As we already told you, there are filters on the client side too, and similar
    to the server-side filters, they also have two types of filters: client request
    filters and client response filters. Client request filters are executed before
    your HTTP request is sent over the wire to the server. On the other hand, client
    response filters run after a response is received from the server, but before
    the response body is assembled.'
  prefs: []
  type: TYPE_NORMAL
- en: Client request filters are also capable of aborting the request and providing
    a response without going over the wire to the server. Client response filters
    are capable of altering the response object before it is handed back to the application
    code.
  prefs: []
  type: TYPE_NORMAL
- en: Example usage of filters
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: After looking at some of the necessary theory around this topic, it is time
    to get your feet wet. Now, we will implement an example in order to support our
    new theoretical knowledge. So, let's start!
  prefs: []
  type: TYPE_NORMAL
- en: 'We will implement an interceptor that will verify the access permissions for
    a user, based on the username and password sent in the request. You can download
    the complete code of this example from the following link:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/restful-java-web-services-security/source-code/tree/master/chapter04](https://github.com/restful-java-web-services-security/source-code/tree/master/chapter04)'
  prefs: []
  type: TYPE_NORMAL
- en: 'We have the topic of our compact discs store. So, the following class will
    represent our service, and it will have the functions to find the compact discs
    by name and update the compact disc information. The annotations used here have
    already been studied in the previous chapter, so you will probably find the following
    code understandable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we have created only two methods, one to retrieve compact discs
    by name and the other to update the compact discs' price. The annotations let
    us know that the method `getCompactDiscByName()` can be accessed and executed
    by all; meanwhile, the method `updatePriceByDiscName()` can be accessed and executed
    by users with the role `ADMIN`.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you noticed in the preceding code, we used the class `CompactDiscDatabase`,
    which simulates a database. We applied the same technique in the previous examples.
    As it worked very well, let''s do it again. This class doesn''t have any special
    code. You can get an idea about this from the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: There is nothing complex here; we just created a map and put one entry there.
    This entry is a compact disc object, as you can tell. We have two static methods
    that will simulate queries—a SELECT statement and an UPDATE statement.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s check our `CompactDisc` class, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: In this class, we just set the fields that represent a common compact disc attribute.
    The annotation `@XmlElement` is used to map a property to an XML element derived
    from a property name.
  prefs: []
  type: TYPE_NORMAL
- en: Now, it is time to implement the filter. We will show you the code after this
    short introduction, explain what we have done, and explain some technical concepts
    used in the implementation. Ready? Here we go!
  prefs: []
  type: TYPE_NORMAL
- en: 'Since the code of this class is a little bit long, we will split it and include
    a short description after each block of code, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Let's check out this code. The first step, in order to implement a filter, is
    the annotation `@Provider`. When we place this annotation at class level, we set
    the class as a filter. Our class name is `SecurityFilter`, and as you can see,
    it implements the interface `ContainerRequestFilter`. If you remember, this filter
    will execute on the server side and before the resource method is invoked.
  prefs: []
  type: TYPE_NORMAL
- en: At the start of our class's body, we set some constants that we will use later.
    The `AUTHORIZATION_PROPERTY` constant represents just the name of a property,
    as does the `RESOURCE_METHOD_INVOKER` constant. The `AUTHENTICATION_SCHEME` constant
    represents just a string. Both `ACCESS_DENIED` and `ACCESS_FORBIDDEN` constants
    represent two different server response objects in order to notify the user of
    the result of their request when it is denied or the user doesn't have enough
    permission.
  prefs: []
  type: TYPE_NORMAL
- en: As we implemented the interface `ContainerRequestFilter`, we must override the
    `filter()` method. It is inside this method that we will put our logic for the
    purpose of filtering the request based on the user that executed the request.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start. As a first step, we obtain the method of the request using the
    constant `RESOURCE_METHOD_INVOKER`. After this, we will have a `ResourceMethodInvoker`
    object, and then the `Method` object, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we will perform some simple validations over `method`. We will check
    whether the method is annotated with `@PermitAll`. If it isn''t, then the method
    continues, and we check whether it is annotated with `@DenyAll`. If the method
    is annotated with `DenyAll`, then we abort the request, including the constant
    `ACCESS_FORBIDDEN`, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we have to obtain the username and password. We must first obtain the
    headers of the request and put it in a map. Then, we obtain the authorization
    string list using `constant AUTHORIZATION_PROPERTY` as a key. This list will let
    us know whether the user has enough permission or not. So, we check if the list
    is empty or null; if it enters the `if()` block, we abort the request, including
    the constant `ACCESS_DENIED`, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'This list has the encoded username and password as a string in the first element.
    So, we execute a replacement and eliminate the string contained in the constant
    `AUTHENTICATION_SCHEME`. Then, we decode it using the `Base64.decodeBase64` decoder,
    and through `StringTokenizer`, we obtain the username and password separated.
    Let''s look at the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Now is the time to evaluate and check whether the user has enough permission.
    First, let''s check whether `method` has the `@RolesAllowed` annotation; if it
    does, we obtain the set of roles allowed using the object `method`. Finally, we
    check whether the constant `ADMIN` is included in this list. If it is not, the
    request is aborted and `ACCESS_DENIED` is once again included, as shown in the
    following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we studied and implemented one of the most useful and necessary
    techniques with the purpose of sharing and protecting our information. Nowadays,
    applications have dramatically increased their interaction with each other because
    they want to meet and satisfy the requirements of clients, users, and so on, compromising
    neither the security nor the integrity of the data while doing this.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we studied several technologies to secure, limit, and authorize
    the use of our resources to a third-party application, starting with brief but
    descriptive concepts about OAuth 2.0 authentication, Single Sign-On, filters,
    and tokens.
  prefs: []
  type: TYPE_NORMAL
- en: Through a practical example and real code, you witnessed how you can grant permission
    over specific resources to a third-party application in order to share the information
    and maintain control over it. Also, we checked and worked with specific code to
    implement one of the most used technologies in recent times, especially in the
    world of social networks, Single Sign-On. Now, you can put in to practice these
    concepts and technologies in order to build applications to interact with each
    other, selecting which resource you want to be shared, which applications you
    want to use as Single Sign-On, and filtering the use of certain resources based
    on the user and role.
  prefs: []
  type: TYPE_NORMAL
