<html><head></head><body>
<div id="_idContainer075">
<h1 class="chapter-number" id="_idParaDest-181"><a id="_idTextAnchor228"/><span class="koboSpan" id="kobo.1.1">11</span></h1>
<h1 id="_idParaDest-182"><a id="_idTextAnchor229"/><span class="koboSpan" id="kobo.2.1">Leveraging CDI Beans to Manage Ports and Use Cases</span></h1>
<p><span class="koboSpan" id="kobo.3.1">Quarkus provides its own dependency injection solution called </span><strong class="bold"><span class="koboSpan" id="kobo.4.1">Quarkus DI</span></strong><span class="koboSpan" id="kobo.5.1">. </span><span class="koboSpan" id="kobo.5.2">It stems </span><a id="_idIndexMarker726"/><span class="koboSpan" id="kobo.6.1">from the </span><strong class="bold"><span class="koboSpan" id="kobo.7.1">Contexts and Dependency Injection</span></strong><span class="koboSpan" id="kobo.8.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.9.1">CDI</span></strong><span class="koboSpan" id="kobo.10.1">) for </span><strong class="bold"><span class="koboSpan" id="kobo.11.1">Java 2.0</span></strong><span class="koboSpan" id="kobo.12.1"> specification. </span><span class="koboSpan" id="kobo.12.2">We employ CDI to delegate the responsibility of providing object instances </span><a id="_idIndexMarker727"/><span class="koboSpan" id="kobo.13.1">to an external dependency and managing their life cycle across an application. </span><span class="koboSpan" id="kobo.13.2">Several dependency injection solutions on the market take such responsibility. </span><span class="koboSpan" id="kobo.13.3">Quarkus DI is one </span><span class="No-Break"><span class="koboSpan" id="kobo.14.1">of them.</span></span></p>
<p><span class="koboSpan" id="kobo.15.1">The value of using a dependency injection mechanism is that we no longer need to worry about how and when to provide an object instance. </span><span class="koboSpan" id="kobo.15.2">A dependency injection solution enables us to automatically create and provide objects as dependencies in classes that depend on those objects, generally using </span><span class="No-Break"><span class="koboSpan" id="kobo.16.1">annotation attributes.</span></span></p>
<p><span class="koboSpan" id="kobo.17.1">In the context of hexagonal architecture, the Framework and Application hexagons are good candidates to leverage the benefits a CDI solution can provide. </span><span class="koboSpan" id="kobo.17.2">Instead of using constructors that inject dependencies using concrete classes, we can use the CDI discovery mechanisms to automatically look up interface implementations and provide them to </span><span class="No-Break"><span class="koboSpan" id="kobo.18.1">the application.</span></span></p>
<p><span class="koboSpan" id="kobo.19.1">In this chapter, we’ll learn how to enhance the provisioning of ports and use cases by turning them into beans. </span><span class="koboSpan" id="kobo.19.2">We’ll explore bean scopes and their life cycles and understand how and when to use the available bean scopes. </span><span class="koboSpan" id="kobo.19.3">Once we know about the CDI fundamentals, we’ll learn how to apply them to a </span><span class="No-Break"><span class="koboSpan" id="kobo.20.1">hexagonal system.</span></span></p>
<p><span class="koboSpan" id="kobo.21.1">The following topics will be covered in </span><span class="No-Break"><span class="koboSpan" id="kobo.22.1">this chapter:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.23.1">Learning about </span><span class="No-Break"><span class="koboSpan" id="kobo.24.1">Quarkus DI</span></span></li>
<li><span class="koboSpan" id="kobo.25.1">Transforming ports, use cases, and adapters into </span><span class="No-Break"><span class="koboSpan" id="kobo.26.1">CDI beans</span></span></li>
<li><span class="koboSpan" id="kobo.27.1">Testing use cases with Quarkus </span><span class="No-Break"><span class="koboSpan" id="kobo.28.1">and Cucumber</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.29.1">By the end of this chapter, you’ll know how to integrate Quarkus DI into a hexagonal application by transforming use cases and ports into managed beans that can be injected across the hexagonal system. </span><span class="koboSpan" id="kobo.29.2">You’ll also know how to test use cases by using Quarkus in conjunction </span><span class="No-Break"><span class="koboSpan" id="kobo.30.1">with Cucumber.</span></span></p>
<h1 id="_idParaDest-183"><a id="_idTextAnchor230"/><span class="koboSpan" id="kobo.31.1">Technical requirements</span></h1>
<p><span class="koboSpan" id="kobo.32.1">To compile </span><a id="_idIndexMarker728"/><span class="koboSpan" id="kobo.33.1">and run the code examples presented in this chapter, you will </span><a id="_idIndexMarker729"/><span class="koboSpan" id="kobo.34.1">need the latest </span><strong class="bold"><span class="koboSpan" id="kobo.35.1">Java SE Development Kit</span></strong><span class="koboSpan" id="kobo.36.1"> and </span><strong class="bold"><span class="koboSpan" id="kobo.37.1">Maven 3.8</span></strong><span class="koboSpan" id="kobo.38.1"> installed on your computer. </span><span class="koboSpan" id="kobo.38.2">They are available for Linux, Mac, and Windows </span><span class="No-Break"><span class="koboSpan" id="kobo.39.1">operating systems.</span></span></p>
<p><span class="koboSpan" id="kobo.40.1">You can find the code files for this chapter on GitHub </span><span class="No-Break"><span class="koboSpan" id="kobo.41.1">at </span></span><a href="https://github.com/PacktPublishing/-Designing-Hexagonal-Architecture-with-Java---Second-Edition/tree/main/Chapter11"><span class="No-Break"><span class="koboSpan" id="kobo.42.1">https://github.com/PacktPublishing/-Designing-Hexagonal-Architecture-with-Java---Second-Edition/tree/main/Chapter11</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.43.1">.</span></span></p>
<h1 id="_idParaDest-184"><a id="_idTextAnchor231"/><span class="koboSpan" id="kobo.44.1">Learning about Quarkus DI</span></h1>
<p><strong class="bold"><span class="koboSpan" id="kobo.45.1">Quarkus DI</span></strong><span class="koboSpan" id="kobo.46.1"> is the </span><a id="_idIndexMarker730"/><span class="koboSpan" id="kobo.47.1">dependency injection solution provided by the Quarkus framework. </span><span class="koboSpan" id="kobo.47.2">This solution, also called </span><strong class="bold"><span class="koboSpan" id="kobo.48.1">ArC</span></strong><span class="koboSpan" id="kobo.49.1">, is based </span><a id="_idIndexMarker731"/><span class="koboSpan" id="kobo.50.1">on the CDI for the </span><strong class="bold"><span class="koboSpan" id="kobo.51.1">Java 2.0 specification</span></strong><span class="koboSpan" id="kobo.52.1">. </span><span class="koboSpan" id="kobo.52.2">Quarkus DI does not completely implement </span><a id="_idIndexMarker732"/><span class="koboSpan" id="kobo.53.1">such a specification. </span><span class="koboSpan" id="kobo.53.2">Instead, it provides some customized and changed implementations that are more inclined toward the Quarkus project’s goals. </span><span class="koboSpan" id="kobo.53.3">However, these changes are more visible when you go deeper into what the Quarkus DI provides. </span><span class="koboSpan" id="kobo.53.4">For those working only with the basics and most recurrent features described in the CDI for Java 2.0 specification, the Quarkus DI experience is similar to other </span><span class="No-Break"><span class="koboSpan" id="kobo.54.1">CDI implementations.</span></span></p>
<p><span class="koboSpan" id="kobo.55.1">The advantage we get by using Quarkus DI or any dependency injection solution is that we can focus more on the business aspects of the software we’re developing, rather than on the plumbing activities related to the provisioning and life cycle control of the objects that the application needs to provide its features. </span><span class="koboSpan" id="kobo.55.2">To enable such an advantage, Quarkus DI deals with </span><span class="No-Break"><span class="koboSpan" id="kobo.56.1">so-called beans.</span></span></p>
<h2 id="_idParaDest-185"><a id="_idTextAnchor232"/><span class="koboSpan" id="kobo.57.1">Working with beans</span></h2>
<p><strong class="bold"><span class="koboSpan" id="kobo.58.1">Beans</span></strong><span class="koboSpan" id="kobo.59.1"> are </span><a id="_idIndexMarker733"/><span class="koboSpan" id="kobo.60.1">special kinds of objects we can use to inject</span><a id="_idIndexMarker734"/><span class="koboSpan" id="kobo.61.1"> dependencies or that act as dependencies themselves to be injected into other beans. </span><span class="koboSpan" id="kobo.61.2">This injection activity takes place in a container-managed environment. </span><span class="koboSpan" id="kobo.61.3">This </span><a id="_idIndexMarker735"/><span class="koboSpan" id="kobo.62.1">environment is nothing more than the runtime environment in which the </span><span class="No-Break"><span class="koboSpan" id="kobo.63.1">application runs.</span></span></p>
<p><span class="koboSpan" id="kobo.64.1">Beans have a context that influences when and how their instance objects are created. </span><span class="koboSpan" id="kobo.64.2">The following are the main contexts that are supported by </span><span class="No-Break"><span class="koboSpan" id="kobo.65.1">Quarkus DI:</span></span></p>
<ul>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.66.1">ApplicationScoped</span></strong><span class="koboSpan" id="kobo.67.1">: A </span><a id="_idIndexMarker736"/><span class="koboSpan" id="kobo.68.1">bean marked with such a context is available to the entire application. </span><span class="koboSpan" id="kobo.68.2">Only one bean instance is created and shared across all system areas that inject this bean. </span><span class="koboSpan" id="kobo.68.3">Another important aspect is that </span><strong class="source-inline"><span class="koboSpan" id="kobo.69.1">ApplicationScoped</span></strong><span class="koboSpan" id="kobo.70.1"> beans are lazily loaded. </span><span class="koboSpan" id="kobo.70.2">This means that the bean instance is created only when a bean’s method is called for the first time. </span><span class="koboSpan" id="kobo.70.3">Take a look at </span><span class="No-Break"><span class="koboSpan" id="kobo.71.1">this example:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.72.1">
@ApplicationScoped
class MyBean {
    public String name = "Test Bean";
    public String getName(){
        return name;
    }
}
class Consumer {
    @Inject
    MyBean myBean;
    public String getName() {
        return myBean.getName();
    }
}</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.73.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.74.1">MyBean</span></strong><span class="koboSpan" id="kobo.75.1"> class is available not only to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.76.1">Consumer</span></strong><span class="koboSpan" id="kobo.77.1"> class but also to other classes that inject the bean. </span><span class="koboSpan" id="kobo.77.2">The bean instance will be created only once when </span><strong class="source-inline"><span class="koboSpan" id="kobo.78.1">myBean.getName()</span></strong><span class="koboSpan" id="kobo.79.1"> is called for the </span><span class="No-Break"><span class="koboSpan" id="kobo.80.1">first time.</span></span></p></li> <li><strong class="source-inline"><span class="koboSpan" id="kobo.81.1">Singleton</span></strong><span class="koboSpan" id="kobo.82.1">: Similar to </span><strong class="source-inline"><span class="koboSpan" id="kobo.83.1">ApplicationScoped</span></strong><span class="koboSpan" id="kobo.84.1"> beans, for </span><strong class="source-inline"><span class="koboSpan" id="kobo.85.1">Singleton</span></strong><span class="koboSpan" id="kobo.86.1"> beans, only one bean object is created and shared </span><a id="_idIndexMarker737"/><span class="koboSpan" id="kobo.87.1">across the system. </span><span class="koboSpan" id="kobo.87.2">The only difference, though, is that </span><strong class="source-inline"><span class="koboSpan" id="kobo.88.1">Singleton</span></strong><span class="koboSpan" id="kobo.89.1"> beans are eagerly loaded. </span><span class="koboSpan" id="kobo.89.2">This means that once the system is started, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.90.1">Singleton</span></strong><span class="koboSpan" id="kobo.91.1"> bean instance is started as well. </span><span class="koboSpan" id="kobo.91.2">Here is the code that </span><span class="No-Break"><span class="koboSpan" id="kobo.92.1">exemplifies this:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.93.1">
@Singleton
class EagerBean { ... </span><span class="koboSpan" id="kobo.93.2">}
class Consumer {
    @Inject
    EagerBean eagerBean;
}</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.94.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.95.1">EagerBean</span></strong><span class="koboSpan" id="kobo.96.1"> object will be created during the </span><span class="No-Break"><span class="koboSpan" id="kobo.97.1">system’s initialization.</span></span></p></li> <li><strong class="source-inline"><span class="koboSpan" id="kobo.98.1">RequestScoped</span></strong><span class="koboSpan" id="kobo.99.1">: We</span><a id="_idIndexMarker738"/><span class="koboSpan" id="kobo.100.1"> usually mark a bean as </span><strong class="source-inline"><span class="koboSpan" id="kobo.101.1">RequestScope</span></strong><span class="koboSpan" id="kobo.102.1"> when we want to make that bean available only for as long as the request associated with that bean lives. </span><span class="koboSpan" id="kobo.102.2">The following is an example of how we can </span><span class="No-Break"><span class="koboSpan" id="kobo.103.1">use </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.104.1">RequestScope</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.105.1">:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.106.1">
@RequestScoped
class RequestData {
    public String getResponse(){
        return "string response";
    }
}
@Path("/")
class Consumer {
    @Inject
    RequestData requestData;
    @GET
    @Path("/request")
    public String loadRequest(){
        return requestData.getResponse();
    }
}</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.107.1">Every time a request arrives at </span><strong class="source-inline"><span class="koboSpan" id="kobo.108.1">/request</span></strong><span class="koboSpan" id="kobo.109.1">, a new </span><strong class="source-inline"><span class="koboSpan" id="kobo.110.1">RequestData</span></strong><span class="koboSpan" id="kobo.111.1"> bean object will be created and destroyed once the request </span><span class="No-Break"><span class="koboSpan" id="kobo.112.1">has finished.</span></span></p></li> <li><strong class="source-inline"><span class="koboSpan" id="kobo.113.1">Dependent</span></strong><span class="koboSpan" id="kobo.114.1">: Beans </span><a id="_idIndexMarker739"/><span class="koboSpan" id="kobo.115.1">marked as </span><strong class="source-inline"><span class="koboSpan" id="kobo.116.1">Dependent</span></strong><span class="koboSpan" id="kobo.117.1"> have their scope restricted to places where they are used. </span><span class="koboSpan" id="kobo.117.2">So, </span><strong class="source-inline"><span class="koboSpan" id="kobo.118.1">Dependent</span></strong><span class="koboSpan" id="kobo.119.1"> beans are not shared across other beans in the system. </span><span class="koboSpan" id="kobo.119.2">Also, their life cycle is the same as the one defined in the bean injecting them. </span><span class="koboSpan" id="kobo.119.3">For example, if you inject a </span><strong class="source-inline"><span class="koboSpan" id="kobo.120.1">Dependent</span></strong><span class="koboSpan" id="kobo.121.1">-annotated bean into a </span><strong class="source-inline"><span class="koboSpan" id="kobo.122.1">RequestScoped</span></strong><span class="koboSpan" id="kobo.123.1"> bean, the former bean uses the </span><span class="No-Break"><span class="koboSpan" id="kobo.124.1">latter’s scope:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.125.1">
@Dependent
class DependentBean { ... </span><span class="koboSpan" id="kobo.125.2">}
@ApplicationScoped
class ConsumerApplication {
    @Inject
    DependentBean dependentBean;
}
@RequestScoped
class ConsumerRequest {
    @Inject
    DependentBean dependentBean;
}</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.126.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.127.1">DependentBean</span></strong><span class="koboSpan" id="kobo.128.1"> class </span><a id="_idIndexMarker740"/><span class="koboSpan" id="kobo.129.1">will become </span><strong class="source-inline"><span class="koboSpan" id="kobo.130.1">ApplicationScoped</span></strong><span class="koboSpan" id="kobo.131.1"> when injected into </span><strong class="source-inline"><span class="koboSpan" id="kobo.132.1">ConsumerApplication</span></strong><span class="koboSpan" id="kobo.133.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.134.1">RequestScoped</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.135.1">into </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.136.1">ConsumerRequest</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.137.1">.</span></span></p></li> <li><strong class="source-inline"><span class="koboSpan" id="kobo.138.1">SessionScoped</span></strong><span class="koboSpan" id="kobo.139.1">: We use </span><a id="_idIndexMarker741"/><span class="koboSpan" id="kobo.140.1">this scope to share the bean context between all the requests of the same HTTP session. </span><span class="koboSpan" id="kobo.140.2">We need the </span><strong class="source-inline"><span class="koboSpan" id="kobo.141.1">quarkus-undertow</span></strong><span class="koboSpan" id="kobo.142.1"> extension to enable </span><strong class="source-inline"><span class="koboSpan" id="kobo.143.1">SessionScoped</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.144.1">on Quarkus:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.145.1">
@SessionScoped
class SessionBean implements Serializable {
    public String getSessionData(){
        return "sessionData";
    }
}
@Path("/")
class Consumer {
    @Inject
    SessionBean sessionBean;
    @GET
    @Path("/sessionData")
    public String test(){
        return sessionBean.getSessionData();
    }
}</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.146.1">In the preceding</span><a id="_idIndexMarker742"/><span class="koboSpan" id="kobo.147.1"> example, a </span><strong class="source-inline"><span class="koboSpan" id="kobo.148.1">SessionBean</span></strong><span class="koboSpan" id="kobo.149.1"> instance </span><a id="_idIndexMarker743"/><span class="koboSpan" id="kobo.150.1">will be created after the first request is sent to </span><strong class="source-inline"><span class="koboSpan" id="kobo.151.1">/sessionData</span></strong><span class="koboSpan" id="kobo.152.1">. </span><span class="koboSpan" id="kobo.152.2">This same instance will be available for other requests coming from the </span><span class="No-Break"><span class="koboSpan" id="kobo.153.1">same session.</span></span></p></li> </ul>
<p><span class="koboSpan" id="kobo.154.1">To summarize, Quarkus offers the following bean scopes: </span><strong class="source-inline"><span class="koboSpan" id="kobo.155.1">ApplicationScoped</span></strong><span class="koboSpan" id="kobo.156.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.157.1">RequestScoped</span></strong><span class="koboSpan" id="kobo.158.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.159.1">Singleton</span></strong><span class="koboSpan" id="kobo.160.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.161.1">Dependent</span></strong><span class="koboSpan" id="kobo.162.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.163.1">SessionScoped</span></strong><span class="koboSpan" id="kobo.164.1">. </span><span class="koboSpan" id="kobo.164.2">For stateless applications, most of the time, you may only need </span><strong class="source-inline"><span class="koboSpan" id="kobo.165.1">ApplicationScoped</span></strong><span class="koboSpan" id="kobo.166.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.167.1">RequestScoped</span></strong><span class="koboSpan" id="kobo.168.1">. </span><span class="koboSpan" id="kobo.168.2">By understanding how these scopes work, we can select them according to our </span><span class="No-Break"><span class="koboSpan" id="kobo.169.1">system needs.</span></span></p>
<p><span class="koboSpan" id="kobo.170.1">Now that we know about the advantages of Quarkus DI and the basics of how it works, let’s learn how to employ dependency injection techniques with the ports and use cases from the </span><span class="No-Break"><span class="koboSpan" id="kobo.171.1">hexago</span><a id="_idTextAnchor233"/><span class="koboSpan" id="kobo.172.1">nal architecture.</span></span></p>
<h1 id="_idParaDest-186"><a id="_idTextAnchor234"/><span class="koboSpan" id="kobo.173.1">Transforming ports, use cases, and adapters into CDI beans</span></h1>
<p><span class="koboSpan" id="kobo.174.1">When designing the Application hexagon for the topology and inventory system, we defined the use cases as interfaces and input ports as their implementations. </span><span class="koboSpan" id="kobo.174.2">We also defined </span><a id="_idIndexMarker744"/><span class="koboSpan" id="kobo.175.1">output ports as interfaces and output adapters as their </span><a id="_idIndexMarker745"/><span class="koboSpan" id="kobo.176.1">implementations in the Framework </span><a id="_idIndexMarker746"/><span class="koboSpan" id="kobo.177.1">hexagon. </span><span class="koboSpan" id="kobo.177.2">In this section, we’ll refactor components from both the Application and Framework hexagons to enable the usage of dependency injection with </span><span class="No-Break"><span class="koboSpan" id="kobo.178.1">Quarkus DI.</span></span></p>
<p><span class="koboSpan" id="kobo.179.1">The first step to working with Quarkus DI is to add the following Maven dependency to the project’s </span><span class="No-Break"><span class="koboSpan" id="kobo.180.1">root </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.181.1">pom.xml</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.182.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.183.1">
&lt;dependency&gt;
  &lt;groupId&gt;io.quarkus&lt;/groupId&gt;
  &lt;artifactId&gt;quarkus-resteasy&lt;/artifactId&gt;
&lt;/dependency&gt;</span></pre> <p><span class="koboSpan" id="kobo.184.1">In addition to the RESTEasy libraries, this </span><strong class="source-inline"><span class="koboSpan" id="kobo.185.1">quarkus-resteasy</span></strong><span class="koboSpan" id="kobo.186.1"> library also provides the required libraries to work with </span><span class="No-Break"><span class="koboSpan" id="kobo.187.1">Quarkus DI.</span></span></p>
<p><span class="koboSpan" id="kobo.188.1">Let’s start our refactoring efforts with the classes and interfaces related to </span><span class="No-Break"><span class="koboSpan" id="kobo.189.1">router management.</span></span></p>
<h2 id="_idParaDest-187"><a id="_idTextAnchor235"/><span class="koboSpan" id="kobo.190.1">Implementing CDI for router management objects</span></h2>
<p><span class="koboSpan" id="kobo.191.1">When</span><a id="_idIndexMarker747"/><span class="koboSpan" id="kobo.192.1"> developing the topology and inventory system, we defined a set of ports, use cases, and adapters to manage </span><a id="_idIndexMarker748"/><span class="koboSpan" id="kobo.193.1">router-related operations. </span><span class="koboSpan" id="kobo.193.2">We’ll walk through the required changes to enable dependency injection in </span><span class="No-Break"><span class="koboSpan" id="kobo.194.1">such operations:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.195.1">We start by transforming the </span><strong class="source-inline"><span class="koboSpan" id="kobo.196.1">RouterManagementH2Adapter</span></strong><span class="koboSpan" id="kobo.197.1"> output adapter</span><a id="_idIndexMarker749"/><span class="koboSpan" id="kobo.198.1"> into a </span><span class="No-Break"><span class="koboSpan" id="kobo.199.1">managed bean:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.200.1">
import jakarta.enterprise.context.ApplicationScoped;
@ApplicationScoped
public class RouterManagementH2Adapter implements
  RouterManagementOutputPort {
    @PersistenceContext
    private EntityManager em;
   /** Code omitted **/
        private void setUpH2Database() {
        EntityManagerFactory entityManagerFactory =
        Persistence.createEntityManagerFactory(
          "inventory");
        EntityManager em =
        entityManagerFactory.createEntityManager();
        this.em = em;
    }
}</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.201.1">We turn</span><a id="_idIndexMarker750"/><span class="koboSpan" id="kobo.202.1"> this class into a managed bean by putting the </span><strong class="source-inline"><span class="koboSpan" id="kobo.203.1">@ApplicationScoped</span></strong><span class="koboSpan" id="kobo.204.1"> annotation on top of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.205.1">RouterManagementH2Adapter</span></strong><span class="koboSpan" id="kobo.206.1"> class. </span><span class="koboSpan" id="kobo.206.2">Note the </span><strong class="source-inline"><span class="koboSpan" id="kobo.207.1">EntityManager</span></strong><span class="koboSpan" id="kobo.208.1"> attribute – we can use dependency injection on that attribute as well. </span><span class="koboSpan" id="kobo.208.2">We’ll do that in </span><a href="B19777_13.xhtml#_idTextAnchor263"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.209.1">Chapter 13</span></em></span></a><span class="koboSpan" id="kobo.210.1">, </span><em class="italic"><span class="koboSpan" id="kobo.211.1">Persisting Data with Output Adapters and Hibernate Reactive</span></em><span class="koboSpan" id="kobo.212.1">, but we won’t touch on it </span><span class="No-Break"><span class="koboSpan" id="kobo.213.1">for now.</span></span></p></li> <li><span class="koboSpan" id="kobo.214.1">Before changing the </span><strong class="source-inline"><span class="koboSpan" id="kobo.215.1">RouterManagementUseCase</span></strong><span class="koboSpan" id="kobo.216.1"> interface and its implementation, </span><strong class="source-inline"><span class="koboSpan" id="kobo.217.1">RouterManagementInputPort</span></strong><span class="koboSpan" id="kobo.218.1">, let’s analyze some aspects </span><a id="_idIndexMarker751"/><span class="koboSpan" id="kobo.219.1">of the </span><span class="No-Break"><span class="koboSpan" id="kobo.220.1">current implementation:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.221.1">
public interface RouterManagementUseCase {
    void setOutputPort(
    RouterManagementOutputPort
      routerManagementOutputPort);
    /** Code omitted **/
}</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.222.1">We defined the </span><strong class="source-inline"><span class="koboSpan" id="kobo.223.1">setOutputPort</span></strong><span class="koboSpan" id="kobo.224.1"> method to receive and set an instance type of </span><strong class="source-inline"><span class="koboSpan" id="kobo.225.1">RouterManagementOutputPort</span></strong><span class="koboSpan" id="kobo.226.1">, which is fulfilled by a </span><strong class="source-inline"><span class="koboSpan" id="kobo.227.1">RouterManagementH2Adapter</span></strong><span class="koboSpan" id="kobo.228.1"> output adapter. </span><span class="koboSpan" id="kobo.228.2">As we’ll no longer need to explicitly </span><a id="_idIndexMarker752"/><span class="koboSpan" id="kobo.229.1">provide this output adapter object (because Quarkus DI will inject it), we can remove the </span><strong class="source-inline"><span class="koboSpan" id="kobo.230.1">setOutputPort</span></strong><span class="koboSpan" id="kobo.231.1"> method from the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.232.1">RouterManagementUseCase</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.233.1"> interface.</span></span></p><p class="list-inset"><span class="koboSpan" id="kobo.234.1">The following code demonstrates how </span><strong class="source-inline"><span class="koboSpan" id="kobo.235.1">RouterManagementInputPort</span></strong><span class="koboSpan" id="kobo.236.1"> is implemented without </span><span class="No-Break"><span class="koboSpan" id="kobo.237.1">Quarkus DI:</span></span></p><pre class="source-code"><span class="koboSpan" id="kobo.238.1">@NoArgsConstructor
public class RouterManagementInputPort implements
  RouterManagementUseCase {
    private RouterManagementOutputPort
    routerManagement</span><a id="_idTextAnchor236"/><span class="koboSpan" id="kobo.239.1">OutputPort;
    @Override
    public void setOutputPort(
    RouterManagementOutputPort
      routerManagementOutputPort) {
        this.routerManagementOutputPort =
        routerManagementOutputPort;
    }
    /** Code omitted **/
}</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.240.1">To provide an object of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.241.1">RouterManagementOutputPort</span></strong><span class="koboSpan" id="kobo.242.1"> type, we need to </span><a id="_idIndexMarker753"/><span class="koboSpan" id="kobo.243.1">use the </span><a id="_idIndexMarker754"/><span class="koboSpan" id="kobo.244.1">previously mentioned </span><strong class="source-inline"><span class="koboSpan" id="kobo.245.1">setOutputPort</span></strong><span class="koboSpan" id="kobo.246.1"> method. </span><span class="koboSpan" id="kobo.246.2">After implementing Quarkus DI, this will no longer be necessary, as we’ll see in the </span><span class="No-Break"><span class="koboSpan" id="kobo.247.1">next step.</span></span></p></li> <li><span class="koboSpan" id="kobo.248.1">This is what </span><strong class="source-inline"><span class="koboSpan" id="kobo.249.1">RouterManagementOutputPort</span></strong><span class="koboSpan" id="kobo.250.1"> should look like after implementing </span><span class="No-Break"><span class="koboSpan" id="kobo.251.1">Quarkus DI:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.252.1">
import jakarta.enterprise.context.ApplicationScoped;
import jakarta.inject.Inject;
@ApplicationScoped
public class RouterManagementInputPort implements
  RouterManagementUseCase {
    @Inject
    RouterManagementOutputPort
      routerManagementOutputPort;
    /** Code omitted **/
}</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.253.1">First, we add </span><strong class="source-inline"><span class="koboSpan" id="kobo.254.1">ApplicationScoped</span></strong><span class="koboSpan" id="kobo.255.1"> on top of </span><strong class="source-inline"><span class="koboSpan" id="kobo.256.1">RouterManagementInputPort</span></strong><span class="koboSpan" id="kobo.257.1"> to enable it to be injected into other system parts. </span><span class="koboSpan" id="kobo.257.2">Then, by using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.258.1">@Inject</span></strong><span class="koboSpan" id="kobo.259.1"> annotation, we inject </span><strong class="source-inline"><span class="koboSpan" id="kobo.260.1">RouterManagementOutputPort</span></strong><span class="koboSpan" id="kobo.261.1">. </span><span class="koboSpan" id="kobo.261.2">We don’t need to refer to the output adapter’s implementation. </span><span class="koboSpan" id="kobo.261.3">Quarkus DI will find a proper implementation for this output </span><a id="_idIndexMarker755"/><span class="koboSpan" id="kobo.262.1">port interface, which happens to be the </span><strong class="source-inline"><span class="koboSpan" id="kobo.263.1">RouterManagementH2Adapter</span></strong><span class="koboSpan" id="kobo.264.1"> output adapter that we turned into a managed </span><span class="No-Break"><span class="koboSpan" id="kobo.265.1">bean earlier.</span></span></p></li> <li><span class="koboSpan" id="kobo.266.1">Finally, we</span><a id="_idIndexMarker756"/><span class="koboSpan" id="kobo.267.1"> must update the </span><strong class="source-inline"><span class="koboSpan" id="kobo.268.1">RouterManagementGenericAdapter</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.269.1">input adapter:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.270.1">
@ApplicationScoped
public class RouterManagementGenericAdapter {
    @Inject
    private RouterManagementUseCase
      routerManagementUseCase;
    /** Code omitted **/
}</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.271.1">Instead of initializing </span><strong class="source-inline"><span class="koboSpan" id="kobo.272.1">RouterManagementUseCase</span></strong><span class="koboSpan" id="kobo.273.1"> using a constructor, we must provide the dependency through the </span><strong class="source-inline"><span class="koboSpan" id="kobo.274.1">@Inject</span></strong><span class="koboSpan" id="kobo.275.1"> annotation. </span><span class="koboSpan" id="kobo.275.2">At runtime, Quarkus DI will create and assign a </span><strong class="source-inline"><span class="koboSpan" id="kobo.276.1">RouterManagementInputPort</span></strong><span class="koboSpan" id="kobo.277.1"> object to that use </span><span class="No-Break"><span class="koboSpan" id="kobo.278.1">case reference.</span></span></p></li> </ol>
<p><span class="koboSpan" id="kobo.279.1">That’s it for the changes we must make to the classes and interfaces related to router management. </span><span class="koboSpan" id="kobo.279.2">Now, let’s learn what we need to change regarding the classes and interfaces for </span><span class="No-Break"><span class="koboSpan" id="kobo.280.1">switch management.</span></span></p>
<h2 id="_idParaDest-188"><a id="_idTextAnchor237"/><span class="koboSpan" id="kobo.281.1">Implementing CDI for switch management objects</span></h2>
<p><span class="koboSpan" id="kobo.282.1">In this </span><a id="_idIndexMarker757"/><span class="koboSpan" id="kobo.283.1">section, we’ll follow a </span><a id="_idIndexMarker758"/><span class="koboSpan" id="kobo.284.1">similar path to the one we followed when we refactored the ports, use cases, and adapters related to </span><span class="No-Break"><span class="koboSpan" id="kobo.285.1">router management:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.286.1">We start by transforming the </span><strong class="source-inline"><span class="koboSpan" id="kobo.287.1">SwitchManagementH2Adapter</span></strong><span class="koboSpan" id="kobo.288.1"> output adapter into a </span><span class="No-Break"><span class="koboSpan" id="kobo.289.1">managed bean:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.290.1">
import jakarta.enterprise.context.ApplicationScoped;
@ApplicationScoped
public class SwitchManagementH2Adapter implements
  SwitchManagementOutputPort {
    @PersistenceContext
    private EntityManager em;
    /** Code omitted **/
}</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.291.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.292.1">SwitchManagementH2Adapter</span></strong><span class="koboSpan" id="kobo.293.1"> adapter also makes use of </span><strong class="source-inline"><span class="koboSpan" id="kobo.294.1">EntityManager</span></strong><span class="koboSpan" id="kobo.295.1">. </span><span class="koboSpan" id="kobo.295.2">We won’t modify how the </span><strong class="source-inline"><span class="koboSpan" id="kobo.296.1">EntityManager</span></strong><span class="koboSpan" id="kobo.297.1"> object is provided, but in </span><a href="B19777_13.xhtml#_idTextAnchor263"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.298.1">Chapter 13</span></em></span></a><span class="koboSpan" id="kobo.299.1">, </span><em class="italic"><span class="koboSpan" id="kobo.300.1">Persisting Data with Output Adapters and Hibernate Reactive</span></em><span class="koboSpan" id="kobo.301.1">, we will change it to use </span><span class="No-Break"><span class="koboSpan" id="kobo.302.1">dependency injection.</span></span></p></li> <li><span class="koboSpan" id="kobo.303.1">We changed the definition of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.304.1">SwitchManagementUseCase</span></strong><span class="koboSpan" id="kobo.305.1"> interface in </span><a href="B19777_09.xhtml#_idTextAnchor192"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.306.1">Chapter 9</span></em></span></a><span class="koboSpan" id="kobo.307.1">, </span><em class="italic"><span class="koboSpan" id="kobo.308.1">Applying Dependency Inversion with Java Modules</span></em><span class="koboSpan" id="kobo.309.1">, and defined the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.310.1">setOutputPort</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.311.1"> method:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.312.1">
public interface SwitchManagementUseCase {
    void setOutputPort(
    SwitchManagementOutputPort
      switchManagementOutputPort)
/** Code omitted **/
}</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.313.1">As Quarkus DI will provide a proper </span><strong class="source-inline"><span class="koboSpan" id="kobo.314.1">SwitchManagementOutputPort</span></strong><span class="koboSpan" id="kobo.315.1"> instance, we’ll no longer need this </span><strong class="source-inline"><span class="koboSpan" id="kobo.316.1">setOutputPort</span></strong><span class="koboSpan" id="kobo.317.1"> method, so we can </span><span class="No-Break"><span class="koboSpan" id="kobo.318.1">remove it.</span></span></p></li> <li><span class="koboSpan" id="kobo.319.1">The</span><a id="_idIndexMarker759"/><span class="koboSpan" id="kobo.320.1"> following code </span><a id="_idIndexMarker760"/><span class="koboSpan" id="kobo.321.1">shows how </span><strong class="source-inline"><span class="koboSpan" id="kobo.322.1">SwitchManagementInputPort</span></strong><span class="koboSpan" id="kobo.323.1"> is implemented without </span><span class="No-Break"><span class="koboSpan" id="kobo.324.1">dependency injection:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.325.1">
@NoArgsConstructor
public class SwitchManagementInputPort implements
  SwitchManagementUseCase {
    private SwitchManagementOutputPort
    switchManagementOutputPort;
    @Override
    public void setOutputPort(
    SwitchManagementOutputPort
      switchManagementOutputPort) {
        this.switchManagementOutputPort =
        switchManagementOutputPort;
    }
    /** Code omitted **/
}</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.326.1">We call the </span><strong class="source-inline"><span class="koboSpan" id="kobo.327.1">setOutputPort</span></strong><span class="koboSpan" id="kobo.328.1"> method to initialize a </span><strong class="source-inline"><span class="koboSpan" id="kobo.329.1">SwitchManagementOutputPort</span></strong><span class="koboSpan" id="kobo.330.1"> object. </span><span class="koboSpan" id="kobo.330.2">When using dependency injection techniques, there is no need to explicitly instantiate or </span><span class="No-Break"><span class="koboSpan" id="kobo.331.1">initialize objects.</span></span></p></li> <li><span class="koboSpan" id="kobo.332.1">The </span><a id="_idIndexMarker761"/><span class="koboSpan" id="kobo.333.1">following is what </span><strong class="source-inline"><span class="koboSpan" id="kobo.334.1">SwitchManagementInputPort</span></strong><span class="koboSpan" id="kobo.335.1"> should look like after implementing</span><a id="_idIndexMarker762"/> <span class="No-Break"><span class="koboSpan" id="kobo.336.1">dependency injection:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.337.1">
import jakarta.enterprise.context.ApplicationScoped;
import jakarta.inject.Inject;
@ApplicationScoped
public class SwitchManagementInputPort implements
  SwitchManagementUseCase {
    @Inject
    private SwitchManagementOutputPort
    switchManagementOutputPort;
    /** Code omitted **/
}</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.338.1">We use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.339.1">@ApplicationScoped</span></strong><span class="koboSpan" id="kobo.340.1"> annotation to convert </span><strong class="source-inline"><span class="koboSpan" id="kobo.341.1">SwitchManagementInputPort</span></strong><span class="koboSpan" id="kobo.342.1"> into a managed bean and the </span><strong class="source-inline"><span class="koboSpan" id="kobo.343.1">@Inject</span></strong><span class="koboSpan" id="kobo.344.1"> annotation to make Quarkus DI discover a managed bean object that implements the </span><strong class="source-inline"><span class="koboSpan" id="kobo.345.1">SwitchManagementOutputPort</span></strong><span class="koboSpan" id="kobo.346.1"> interface, which happens to be the </span><strong class="source-inline"><span class="koboSpan" id="kobo.347.1">SwitchManagementH2Adapter</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.348.1">output adapter.</span></span></p></li> <li><span class="koboSpan" id="kobo.349.1">We still need to adjust the </span><strong class="source-inline"><span class="koboSpan" id="kobo.350.1">SwitchManagementGenericAdapter</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.351.1">input adapter:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.352.1">
public class SwitchManagementGenericAdapter {
    @Inject
    private SwitchManagementUseCase
      switchManagementUseCase;
    @Inject
    private RouterManagementUseCase
      routerManagementUseCase;
    /** Code omitted **/
}</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.353.1">Here, we </span><a id="_idIndexMarker763"/><span class="koboSpan" id="kobo.354.1">are injecting </span><a id="_idIndexMarker764"/><span class="koboSpan" id="kobo.355.1">dependencies for both the </span><strong class="source-inline"><span class="koboSpan" id="kobo.356.1">SwitchManagementUseCase</span></strong><span class="koboSpan" id="kobo.357.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.358.1">RouterManagementUseCase</span></strong><span class="koboSpan" id="kobo.359.1"> objects. </span><span class="koboSpan" id="kobo.359.2">Before using annotations, these dependencies were provided in </span><span class="No-Break"><span class="koboSpan" id="kobo.360.1">this way:</span></span></p><pre class="source-code"><span class="koboSpan" id="kobo.361.1">public SwitchManagementGenericAdapter (
RouterManagementUseCase routerManagementUseCase,
  SwitchManagementUseCase switchManagementUseCase){
    this.routerManagementUseCase =
      routerManagementUseCase;
    this.switchManagementUseCase =
      switchManagementUseCase;
}</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.362.1">The improvement we get is that we no longer need to rely on the constructor to initialize the </span><strong class="source-inline"><span class="koboSpan" id="kobo.363.1">SwitchManagementGenericAdapter</span></strong><span class="koboSpan" id="kobo.364.1"> dependencies. </span><span class="koboSpan" id="kobo.364.2">Quarkus DI will automatically provide the required instances </span><span class="No-Break"><span class="koboSpan" id="kobo.365.1">for us.</span></span></p></li> </ol>
<p><span class="koboSpan" id="kobo.366.1">The next section is about the operations related to network management. </span><span class="koboSpan" id="kobo.366.2">Let’s learn how we should </span><span class="No-Break"><span class="koboSpan" id="kobo.367.1">change them.</span></span></p>
<h2 id="_idParaDest-189"><a id="_idTextAnchor238"/><span class="koboSpan" id="kobo.368.1">Implementing CDI for network management classes and interfaces</span></h2>
<p><span class="koboSpan" id="kobo.369.1">We </span><a id="_idIndexMarker765"/><span class="koboSpan" id="kobo.370.1">have fewer things to change for the network part because we did not create a specific output port</span><a id="_idIndexMarker766"/><span class="koboSpan" id="kobo.371.1"> and adapter for the network-related operations. </span><span class="koboSpan" id="kobo.371.2">So, the implementation changes will only take place on the use cases, input ports, and </span><span class="No-Break"><span class="koboSpan" id="kobo.372.1">input adapters:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.373.1">Let’s start by looking at the </span><strong class="source-inline"><span class="koboSpan" id="kobo.374.1">NetworkManagementUseCase</span></strong><span class="koboSpan" id="kobo.375.1"> use </span><span class="No-Break"><span class="koboSpan" id="kobo.376.1">case interface:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.377.1">
public interface NetworkManagementUseCase {
    void setOutputPort(
    RouterManagementOutputPort
      routerNetworkOutputPort);
    /** Code omitted **/
}</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.378.1">As we did in the other use cases, we also defined the </span><strong class="source-inline"><span class="koboSpan" id="kobo.379.1">setOutputPort</span></strong><span class="koboSpan" id="kobo.380.1"> method to allow the initialization of </span><strong class="source-inline"><span class="koboSpan" id="kobo.381.1">RouterManagementOutputPort</span></strong><span class="koboSpan" id="kobo.382.1">. </span><span class="koboSpan" id="kobo.382.2">After implementing Quarkus DI, this method will no longer </span><span class="No-Break"><span class="koboSpan" id="kobo.383.1">be needed.</span></span></p></li> <li><span class="koboSpan" id="kobo.384.1">This is how </span><strong class="source-inline"><span class="koboSpan" id="kobo.385.1">NetworkManagementInputPort</span></strong><span class="koboSpan" id="kobo.386.1"> is implemented without </span><span class="No-Break"><span class="koboSpan" id="kobo.387.1">Quarkus DI:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.388.1">
import jakarta.enterprise.context.ApplicationScoped;
import jakarta.inject.Inject;
public class NetworkManagementInputPort implements
  NetworkManagementUseCase {
    private RouterManagementOutputPort
    routerManagementOutputPort;
    @Override
    public void setOutputPort(
    RouterManagementOutputPort
      routerManagementOutputPort) {
        this.routerManagementOutputPort =
       routerManagementOutputPort;
    }
    /** Code omitted **/
}</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.389.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.390.1">NetworkManagementInputPort</span></strong><span class="koboSpan" id="kobo.391.1"> input </span><a id="_idIndexMarker767"/><span class="koboSpan" id="kobo.392.1">port only relies on </span><strong class="source-inline"><span class="koboSpan" id="kobo.393.1">RouterManagementOutputPort</span></strong><span class="koboSpan" id="kobo.394.1">, which, without dependency injection, is initialized by the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.395.1">setOutputPort</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.396.1"> method.</span></span></p></li> <li><span class="koboSpan" id="kobo.397.1">This is</span><a id="_idIndexMarker768"/><span class="koboSpan" id="kobo.398.1"> what </span><strong class="source-inline"><span class="koboSpan" id="kobo.399.1">NetworkManagementInputPort</span></strong><span class="koboSpan" id="kobo.400.1"> looks like after implementing </span><span class="No-Break"><span class="koboSpan" id="kobo.401.1">Quarkus DI:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.402.1">
@ApplicationScoped
public class NetworkManagementInputPort implements
  NetworkManagementUseCase {
    @Inject
    private RouterManagementOutputPort
    routerManagementOutputPort;
    /** Code omitted **/
}</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.403.1">As you can see, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.404.1">setOutputPort</span></strong><span class="koboSpan" id="kobo.405.1"> method has been removed. </span><span class="koboSpan" id="kobo.405.2">Quarkus DI is now </span><a id="_idIndexMarker769"/><span class="koboSpan" id="kobo.406.1">providing an implementation for </span><strong class="source-inline"><span class="koboSpan" id="kobo.407.1">RouterManagementOutputPort</span></strong><span class="koboSpan" id="kobo.408.1"> through the </span><strong class="source-inline"><span class="koboSpan" id="kobo.409.1">@Inject</span></strong><span class="koboSpan" id="kobo.410.1"> annotation. </span><span class="koboSpan" id="kobo.410.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.411.1">@ApplicationScoped</span></strong><span class="koboSpan" id="kobo.412.1"> annotation converts </span><strong class="source-inline"><span class="koboSpan" id="kobo.413.1">NetworkManagementInputPort</span></strong><span class="koboSpan" id="kobo.414.1"> into a </span><span class="No-Break"><span class="koboSpan" id="kobo.415.1">managed bean.</span></span></p></li> <li><span class="koboSpan" id="kobo.416.1">Finally, we</span><a id="_idIndexMarker770"/><span class="koboSpan" id="kobo.417.1"> have to change the </span><strong class="source-inline"><span class="koboSpan" id="kobo.418.1">NetworkManagementGenericAdapter</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.419.1">input adapter:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.420.1">
import jakarta.enterprise.context.ApplicationScoped;
import jakarta.inject.Inject;
@ApplicationScoped
public class NetworkManagementGenericAdapter {
    @Inject
    private SwitchManagementUseCase
      switchManagementUseCase;
    @Inject
    private NetworkManagementUseCase
      networkManagementUseCase;
   /** Code omitted **/
}</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.421.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.422.1">NetworkManagementGenericAdapter</span></strong><span class="koboSpan" id="kobo.423.1"> input adapter relies on the </span><strong class="source-inline"><span class="koboSpan" id="kobo.424.1">SwitchManagementUseCase</span></strong><span class="koboSpan" id="kobo.425.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.426.1">NetworkManagementUseCase</span></strong><span class="koboSpan" id="kobo.427.1"> use cases to trigger network-related operations on the system. </span><span class="koboSpan" id="kobo.427.2">As we did in the previous</span><a id="_idIndexMarker771"/><span class="koboSpan" id="kobo.428.1"> implementations, here, we are using </span><strong class="source-inline"><span class="koboSpan" id="kobo.429.1">@Inject</span></strong><span class="koboSpan" id="kobo.430.1"> to provide the dependencies </span><span class="No-Break"><span class="koboSpan" id="kobo.431.1">at runtime.</span></span></p><p class="list-inset"><span class="koboSpan" id="kobo.432.1">The following code shows how these dependencies were provided before </span><span class="No-Break"><span class="koboSpan" id="kobo.433.1">Quarkus DI:</span></span></p><pre class="source-code"><span class="koboSpan" id="kobo.434.1">public NetworkManagementGenericAdapter(
SwitchManagementUseCase switchManagementUseCase, Net
  workManagementUseCase networkManagementUseCase) {
    this.switchManagementUseCase =
      switchManagementUseCase;
    this.networkManagementUseCase =
      networkManagementUseCase;
}</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.435.1">After implementing the injection mechanism, we can safely remove this </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.436.1">NetworkManagementGenericAdapter</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.437.1"> constructor.</span></span></p></li> </ol>
<p><span class="koboSpan" id="kobo.438.1">We have</span><a id="_idIndexMarker772"/><span class="koboSpan" id="kobo.439.1"> finished making all the necessary changes to convert the input ports, use cases, and adapters into components that can be used for dependency injection. </span><span class="koboSpan" id="kobo.439.2">These changes showed us how to integrate the Quarkus CDI mechanisms into our </span><span class="No-Break"><span class="koboSpan" id="kobo.440.1">hexagonal application.</span></span></p>
<p><span class="koboSpan" id="kobo.441.1">Now, let’s learn how to adapt the hexagonal system to mock and use managed beans </span><span class="No-Break"><span class="koboSpan" id="kobo.442.1">during tests.</span></span></p>
<h1 id="_idParaDest-190"><a id="_idTextAnchor239"/><span class="koboSpan" id="kobo.443.1">Testing use cases with Quarkus and Cucumber</span></h1>
<p><span class="koboSpan" id="kobo.444.1">While implementing the Application hexagon in </span><a href="B19777_07.xhtml#_idTextAnchor152"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.445.1">Chapter 7</span></em></span></a><span class="koboSpan" id="kobo.446.1">, </span><em class="italic"><span class="koboSpan" id="kobo.447.1">Building the Application Hexagon</span></em><span class="koboSpan" id="kobo.448.1">, we used </span><a id="_idIndexMarker773"/><span class="koboSpan" id="kobo.449.1">Cucumber to aid us in shaping and testing </span><a id="_idIndexMarker774"/><span class="koboSpan" id="kobo.450.1">our use cases. </span><span class="koboSpan" id="kobo.450.2">By leveraging the behavior-driven design techniques provided by Cucumber, we could express use cases in a declarative way. </span><span class="koboSpan" id="kobo.450.3">Now, we need to integrate Cucumber so that it works </span><span class="No-Break"><span class="koboSpan" id="kobo.451.1">with Quarkus:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.452.1">The first step is to add the Quarkus testing dependencies to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.453.1">pom.xml</span></strong><span class="koboSpan" id="kobo.454.1"> file from the </span><span class="No-Break"><span class="koboSpan" id="kobo.455.1">Application hexagon:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.456.1">
&lt;dependency&gt;
  &lt;groupId&gt;io.quarkiverse.cucumber&lt;/groupId&gt;
  &lt;artifactId&gt;quarkus-cucumber&lt;/artifactId&gt;
  &lt;version&gt;1.0    .0&lt;/version&gt;
  &lt;scope&gt;test&lt;/scope&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
  &lt;groupId&gt;io.quarkus&lt;/groupId&gt;
  &lt;artifactId&gt;quarkus-junit5&lt;/artifactId&gt;
  &lt;scope&gt;test&lt;/scope&gt;
&lt;/dependency&gt;</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.457.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.458.1">quarkus-cucumber</span></strong><span class="koboSpan" id="kobo.459.1"> dependency provides the integration we need to run tests with Quarkus. </span><span class="koboSpan" id="kobo.459.2">We also need the </span><strong class="source-inline"><span class="koboSpan" id="kobo.460.1">quarkus-junit5</span></strong><span class="koboSpan" id="kobo.461.1"> dependency, which enables us to use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.462.1">@</span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.463.1">QuarkusTest</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.464.1"> annotation.</span></span></p></li> <li><span class="koboSpan" id="kobo.465.1">Next, we must add the necessary </span><span class="No-Break"><span class="koboSpan" id="kobo.466.1">Cucumber dependencies:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.467.1">
&lt;dependency&gt;
  &lt;groupId&gt;io.cucumber&lt;/groupId&gt;
  &lt;artifactId&gt;cucumber-java&lt;/artifactId&gt;
  &lt;version&gt;${cucumber.version}&lt;/version&gt;
  &lt;scope&gt;test&lt;/scope&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
  &lt;groupId&gt;io.cucumber&lt;/groupId&gt;
  &lt;artifactId&gt;cucumber-junit&lt;/artifactId&gt;
  &lt;version&gt;${cucumber.version}&lt;/version&gt;
  &lt;scope&gt;test&lt;/scope&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
  &lt;groupId&gt;io.cucumber&lt;/groupId&gt;
  &lt;artifactId&gt;cucumber-picocontainer&lt;/artifactId&gt;
  &lt;version&gt;${cucumber.version}&lt;/version&gt;
  &lt;scope&gt;test&lt;/scope&gt;
&lt;/dependency&gt;</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.468.1">With </span><a id="_idIndexMarker775"/><span class="koboSpan" id="kobo.469.1">the </span><strong class="source-inline"><span class="koboSpan" id="kobo.470.1">cucumber-java</span></strong><span class="koboSpan" id="kobo.471.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.472.1">cucumber-junit</span></strong><span class="koboSpan" id="kobo.473.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.474.1">cucumber-picocontainer</span></strong><span class="koboSpan" id="kobo.475.1"> dependencies, we can enable the Cucumber </span><a id="_idIndexMarker776"/><span class="koboSpan" id="kobo.476.1">engine on </span><span class="No-Break"><span class="koboSpan" id="kobo.477.1">the system.</span></span></p></li> </ol>
<p><span class="koboSpan" id="kobo.478.1">Let’s see how Cucumber is configured </span><span class="No-Break"><span class="koboSpan" id="kobo.479.1">without Quarkus:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.480.1">
package dev.davivieira.topologyinventory.application;
import io.cucumber.junit.Cucumber;
import io.cucumber.junit.CucumberOptions;
import org.junit.runner.RunWith;
@RunWith(Cucumber.class)
@CucumberOptions(
        plugin = {"pretty", "html:target/cucumber-result"}
)
public class ApplicationTest {
}</span></pre> <p><span class="koboSpan" id="kobo.481.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.482.1">@RunWith(Cucumber.class)</span></strong><span class="koboSpan" id="kobo.483.1"> annotation </span><a id="_idIndexMarker777"/><span class="koboSpan" id="kobo.484.1">is used to </span><a id="_idIndexMarker778"/><span class="koboSpan" id="kobo.485.1">activate the Cucumber engine. </span><span class="koboSpan" id="kobo.485.2">When using Quarkus, this is how </span><strong class="source-inline"><span class="koboSpan" id="kobo.486.1">ApplicationTest</span></strong><span class="koboSpan" id="kobo.487.1"> should </span><span class="No-Break"><span class="koboSpan" id="kobo.488.1">be implemented:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.489.1">
package dev.davivieira.topologyinventory.application;
import io.quarkiverse.cucumber.CucumberQuarkusTest;
import io.quarkus.test.junit.QuarkusTest;
@QuarkusTest
public class ApplicationTest extends CucumberQuarkusTest {
}</span></pre> <p><span class="koboSpan" id="kobo.490.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.491.1">@QuarkusTest</span></strong><span class="koboSpan" id="kobo.492.1"> annotations activate the Quarkus testing engine. </span><span class="koboSpan" id="kobo.492.2">By extending the </span><strong class="source-inline"><span class="koboSpan" id="kobo.493.1">CucumberQuarkusTest</span></strong><span class="koboSpan" id="kobo.494.1"> class, we also enable the Cucumber </span><span class="No-Break"><span class="koboSpan" id="kobo.495.1">testing engine.</span></span></p>
<p><span class="koboSpan" id="kobo.496.1">There are no tests on the </span><strong class="source-inline"><span class="koboSpan" id="kobo.497.1">ApplicationTest</span></strong><span class="koboSpan" id="kobo.498.1"> class because this is just a bootstrap class. </span><span class="koboSpan" id="kobo.498.2">Remember that Cucumber tests were implemented in separate classes. </span><span class="koboSpan" id="kobo.498.3">Before changing these classes, we need to mock the managed beans that are required to provide instances for </span><strong class="source-inline"><span class="koboSpan" id="kobo.499.1">RouterManagementOutputPort</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.500.1">and </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.501.1">SwitchManagementOutputPort</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.502.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.503.1">Let’s create a mocked </span><a id="_idIndexMarker779"/><span class="koboSpan" id="kobo.504.1">bean object </span><span class="No-Break"><span class="koboSpan" id="kobo.505.1">for </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.506.1">RouterManagementOutputPort</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.507.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.508.1">
package dev.davivieira.topologyinventory.application.mocks;
import dev.davivieira.topologyinventory.applica
  tion.ports.output.RouterManagementOutputPort;
import dev.davivieira.topologyinventory.domain.en
  tity.Router;
import dev.davivieira.topologyinventory.domain.vo.Id;
import io.quarkus.test.Mock;
@Mock
public class RouterManagementOutputPortMock implements
  RouterManagementOutputPort {
    @Override
    public Router retrieveRouter(Id id) {
        return null;
    }
    @Override
    public Router removeRouter(Id id) {
        return null;
    }
    @Override
    public Router persistRouter(Router router) {
        return null;
    }
}</span></pre> <p><span class="koboSpan" id="kobo.509.1">This is a dummy mocked bean that we created to prevent Quarkus from throwing </span><strong class="source-inline"><span class="koboSpan" id="kobo.510.1">UnsatisfiedResolutionException</span></strong><span class="koboSpan" id="kobo.511.1">. </span><span class="koboSpan" id="kobo.511.2">By using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.512.1">@Mock</span></strong><span class="koboSpan" id="kobo.513.1"> annotation, Quarkus will instantiate </span><a id="_idIndexMarker780"/><span class="koboSpan" id="kobo.514.1">the </span><strong class="source-inline"><span class="koboSpan" id="kobo.515.1">RouterManagementOutputPortMock</span></strong><span class="koboSpan" id="kobo.516.1"> class and </span><a id="_idIndexMarker781"/><span class="koboSpan" id="kobo.517.1">serve it as a bean to be injected during </span><span class="No-Break"><span class="koboSpan" id="kobo.518.1">the tests.</span></span></p>
<p><span class="koboSpan" id="kobo.519.1">In the same way, we will </span><span class="No-Break"><span class="koboSpan" id="kobo.520.1">mock </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.521.1">SwitchManagementOutputPort</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.522.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.523.1">
package dev.davivieira.topologyinventory.application.mocks;
import dev.davivieira.topologyinventory.applica
  tion.ports.output.SwitchManagementOutputPort;
import dev.davivieira.topologyinventory.domain.en
  tity.Switch;
import dev.davivieira.topologyinventory.domain.vo.Id;
import io.quarkus.test.Mock;
@Mock
public class SwitchManagementOutputPortMock implements
  SwitchManagementOutputPort {
    @Override
    public Switch retrieveSwitch(Id id) {
        return null;
    }
}</span></pre> <p><span class="koboSpan" id="kobo.524.1">For </span><strong class="source-inline"><span class="koboSpan" id="kobo.525.1">SwitchManagementOutputPort</span></strong><span class="koboSpan" id="kobo.526.1">, we created </span><strong class="source-inline"><span class="koboSpan" id="kobo.527.1">SwitchManagementOutputPortMock</span></strong><span class="koboSpan" id="kobo.528.1"> to provide a dummy managed bean so that Quarkus can use it for injection during the tests. </span><span class="koboSpan" id="kobo.528.2">Without mocks, we’d need real instances from the </span><strong class="source-inline"><span class="koboSpan" id="kobo.529.1">RouterManagementH2Adapter</span></strong><span class="koboSpan" id="kobo.530.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.531.1">SwitchManagementH2Adapter</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.532.1">output adapters.</span></span></p>
<p><span class="koboSpan" id="kobo.533.1">Although we don’t refer directly to output interfaces and output port adapters during tests, Quarkus still tries to perform bean discovery on them. </span><span class="koboSpan" id="kobo.533.2">That’s why we need to provide </span><span class="No-Break"><span class="koboSpan" id="kobo.534.1">the mocks.</span></span></p>
<p><span class="koboSpan" id="kobo.535.1">Now, we can refactor the tests to use the dependency injection provided by Quarkus DI. </span><span class="koboSpan" id="kobo.535.2">Let’s learn how to do that on the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.536.1">RouterAdd</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.537.1"> test:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.538.1">
public class RouterAdd extends ApplicationTestData {
    @Inject
    RouterManagementUseCase routerManagementUseCase;
   /** Code omitted **/
}</span></pre> <p><span class="koboSpan" id="kobo.539.1">Before using Quarkus DI, this is how </span><a id="_idIndexMarker782"/><span class="koboSpan" id="kobo.540.1">we got the implementation </span><span class="No-Break"><span class="koboSpan" id="kobo.541.1">for </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.542.1">RouterManagementUseCase</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.543.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.544.1">
this.routerManagementUseCase = new RouterManagementInput
  Port();</span></pre> <p><span class="koboSpan" id="kobo.545.1">The preceding </span><a id="_idIndexMarker783"/><span class="koboSpan" id="kobo.546.1">code can be removed once the </span><strong class="source-inline"><span class="koboSpan" id="kobo.547.1">@Inject</span></strong><span class="koboSpan" id="kobo.548.1"> annotation has </span><span class="No-Break"><span class="koboSpan" id="kobo.549.1">been implemented.</span></span></p>
<p><span class="koboSpan" id="kobo.550.1">We can follow the same approach of adding the </span><strong class="source-inline"><span class="koboSpan" id="kobo.551.1">@Inject</span></strong><span class="koboSpan" id="kobo.552.1"> annotation and removing the constructor call to instantiate input port objects when refactoring other </span><span class="No-Break"><span class="koboSpan" id="kobo.553.1">test classes.</span></span></p>
<p><span class="koboSpan" id="kobo.554.1">The output you’ll get after running Quarkus tests integrated with Cucumber will be similar to </span><span class="No-Break"><span class="koboSpan" id="kobo.555.1">the following:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.556.1">
[INFO] -------------------------------------------------------
[INFO]  T E S T S
[INFO] -------------------------------------------------------
[INFO] Running dev.davivieira.topologyinventory.application.ApplicationTest
2021-09-08 22:44:15,596 INFO  [io.quarkus] (main) Quarkus 2.2.1.Final on JVM started in 1.976s. </span><span class="koboSpan" id="kobo.556.2">Listening on: http://localhost:8081
2021-09-08 22:44:15,618 INFO  [io.quarkus] (main) Profile test activated.
</span><span class="koboSpan" id="kobo.556.3">2021-09-08 22:44:15,618 INFO  [io.quarkus] (main) Installed features: [cdi, cucumber, smallrye-context-propagation]
@RouterCreate
Scenario: Creating a new core router
#dev/davivieira/topologyinventory/application/routers/RouterCreate.feature:4
.  Given I provide all required data to create a core router
#dev.davivieira.topologyinventory.application.RouterCreate.create_core_router()
.  Then A new core router is created
#dev.davivieira.topologyinventory.application.RouterCreate.a_new_core_router_is_created()</span></pre> <p><span class="koboSpan" id="kobo.557.1">Note that in </span><a id="_idIndexMarker784"/><span class="koboSpan" id="kobo.558.1">the installed feature’s output entry, Quarkus mentions </span><strong class="source-inline"><span class="koboSpan" id="kobo.559.1">CDI</span></strong><span class="koboSpan" id="kobo.560.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.561.1">Cucumber</span></strong><span class="koboSpan" id="kobo.562.1"> as extensions that are </span><span class="No-Break"><span class="koboSpan" id="kobo.563.1">being used.</span></span></p>
<p><span class="koboSpan" id="kobo.564.1">In this </span><a id="_idIndexMarker785"/><span class="koboSpan" id="kobo.565.1">section, we learned how to configure Quarkus to work together with Cucumber properly. </span><span class="koboSpan" id="kobo.565.2">This configuration was required to configure Quarkus mocks and refactor test classes to inject input port objects instead of creating them with </span><span class="No-Break"><span class="koboSpan" id="kobo.566.1">constructor calls.</span></span></p>
<h1 id="_idParaDest-191"><a id="_idTextAnchor240"/><span class="koboSpan" id="kobo.567.1">Summary</span></h1>
<p><span class="koboSpan" id="kobo.568.1">In this chapter, we had the opportunity to learn how Quarkus provides dependency injection through Quarkus DI. </span><span class="koboSpan" id="kobo.568.2">We started by reviewing some of the concepts defined by the CDI for </span><strong class="bold"><span class="koboSpan" id="kobo.569.1">Java 2.0</span></strong><span class="koboSpan" id="kobo.570.1"> specification, the specification that Quarkus DI is derived from. </span><span class="koboSpan" id="kobo.570.2">Then, we proceeded to implement these concepts in our hexagonal application. </span><span class="koboSpan" id="kobo.570.3">We defined the managed beans and injected them while refactoring use cases, ports, and adapters. </span><span class="koboSpan" id="kobo.570.4">Finally, we learned how to integrate Quarkus with Cucumber to get the best of both worlds while testing our </span><span class="No-Break"><span class="koboSpan" id="kobo.571.1">hexagonal application.</span></span></p>
<p><span class="koboSpan" id="kobo.572.1">By implementing Quarkus dependency injection mechanisms into a hexagonal system, we are also turning it into a more robust and </span><span class="No-Break"><span class="koboSpan" id="kobo.573.1">modern system.</span></span></p>
<p><span class="koboSpan" id="kobo.574.1">In the next chapter, we’ll turn our attention to adapters. </span><span class="koboSpan" id="kobo.574.2">Quarkus provides powerful capabilities for creating reactive REST endpoints and we’ll learn how to integrate them with hexagonal </span><span class="No-Break"><span class="koboSpan" id="kobo.575.1">system adapters.</span></span></p>
<h1 id="_idParaDest-192"><a id="_idTextAnchor241"/><span class="koboSpan" id="kobo.576.1">Questions</span></h1>
<ol>
<li><span class="koboSpan" id="kobo.577.1">Quarkus DI is based on which </span><span class="No-Break"><span class="koboSpan" id="kobo.578.1">Java specification?</span></span></li>
<li><span class="koboSpan" id="kobo.579.1">What is the difference between the </span><strong class="source-inline"><span class="koboSpan" id="kobo.580.1">ApplicationScoped</span></strong><span class="koboSpan" id="kobo.581.1"> and </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.582.1">Singleton</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.583.1"> scopes?</span></span></li>
<li><span class="koboSpan" id="kobo.584.1">What is the annotation we should use to provide dependencies through Quarkus DI instead of using </span><span class="No-Break"><span class="koboSpan" id="kobo.585.1">calling constructors?</span></span></li>
<li><span class="koboSpan" id="kobo.586.1">To enable Quarkus te</span><a id="_idTextAnchor242"/><span class="koboSpan" id="kobo.587.1">sting capabilities, which annotation should </span><span class="No-Break"><span class="koboSpan" id="kobo.588.1">we use?</span></span></li>
</ol>
<h1 id="_idParaDest-193"><a id="_idTextAnchor243"/><span class="koboSpan" id="kobo.589.1">Answers</span></h1>
<ol>
<li value="1"><span class="koboSpan" id="kobo.590.1">It’s based on the CDI for </span><strong class="bold"><span class="koboSpan" id="kobo.591.1">Java </span></strong><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.592.1">2.0</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.593.1"> specification.</span></span></li>
<li><span class="koboSpan" id="kobo.594.1">When using </span><strong class="source-inline"><span class="koboSpan" id="kobo.595.1">ApplicationScope</span></strong><span class="koboSpan" id="kobo.596.1">, the objects are lazily loaded. </span><span class="koboSpan" id="kobo.596.2">With </span><strong class="source-inline"><span class="koboSpan" id="kobo.597.1">Singleton</span></strong><span class="koboSpan" id="kobo.598.1">, the objects are </span><span class="No-Break"><span class="koboSpan" id="kobo.599.1">eagerly loaded.</span></span></li>
<li><span class="koboSpan" id="kobo.600.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.601.1">@</span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.602.1">Inject</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.603.1"> annotation.</span></span></li>
<li><span class="koboSpan" id="kobo.604.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.605.1">@</span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.606.1">QuarkusTest</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.607.1"> annotation.</span></span></li>
</ol>
</div>
</body></html>