<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Concurrent and Multithreaded Programming</h1>
                </header>
            
            <article>
                
<p>Concurrent programming has always been a difficult task. It might sound easy, but it is a source of many hard-to-solve problems. In this chapter, we will show you different ways of incorporating concurrency and some best practices, such as immutability, which will help in creating better, concurrent applications. We will also discuss the implementation of some commonly used patterns, such as divide-conquer and publish-subscribe, using the constructs provided by Java. We will cover the following recipes:</p>
<ul>
<li>Using the basic element of concurrency - thread</li>
<li>Different synchronization approaches</li>
<li>Immutability as a means to achieve concurrency</li>
<li>Using concurrent collections</li>
<li>Using the executor service to execute async tasks</li>
<li>Using fork/join to implement divide-and-conquer</li>
<li>Using flow to implement the publish-subscribe pattern</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Introduction</h1>
                </header>
            
            <article>
                
<p>Concurrency--the ability to execute several procedures in parallel--becomes increasingly important as big data analysis moves into the mainstream of modern applications. Having CPUs or several cores in one CPU helps increase the throughput, but the growth rate of data volume will always outpace hardware advances. Besides, even in a multiple CPU system, one still has to structure the code and think about resource sharing to take advantage of the available computational power.  </p>
<p><span>In the previous chapters, we demonstrated how l</span><span>ambdas with functional interfaces and parallel streams made concurrent processing a part of the toolkit of every Java programmer. One can easily take advantage of this functionality with minimal guidance, if at all.</span></p>
<p><span>In this chapter, we will describe some other--old (that existed before Java 9) and new--Java features and APIs that allow more control over concurrency. </span><span>The high-level concurrency Java API has been around since Java 5. The JDK Enhancement Proposal (JEP) 266, <em>More Concurrency Updates,</em> introduced <em>an interoperable publish-subscribe framework, enhancements to the CompletableFuture API, and various other improvements</em> to Java 9 in the <kbd>java.util.concurrent</kbd> package. </span>But before we dive into the details of the latest additions, let's review the basics of concurrent programming in Java and see how to use them. </p>
<p>Java has two units of execution: process and thread. A process usually represents the whole JVM, although an application can create another process using <kbd>ProcessBuilder</kbd>. But since the multiprocess case is outside the scope of this book, we will focus on the second unit of execution, that is, a thread, which is similar to a process but less isolated from other threads and requires fewer resources for execution. </p>
<p>A process can have many threads running and at least one thread called the main thread. Threads can share resources, including memory and open files, which allows better efficiency, but comes with a price of higher risk of unintended mutual interference and even blocking of the execution. This is where programming skills and an understanding of the concurrency technique are required. And this is what we are going to discuss in this chapter.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Using the basic element of concurrency - thread</h1>
                </header>
            
            <article>
                
<p>In this chapter, we will look at the <kbd>java.lang.Thread</kbd> class and see what it can do for concurrency and program performance in general.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p>A Java application starts as the main thread (not counting system threads that support the process). It can then create other threads and let them run in parallel (sharing the same core via time slicing of having a dedicated CPU for each thread). This can be done using the <kbd>java.lang.Thread</kbd> class that implements the <kbd>Runnable</kbd> functional interface with only one <kbd>run()</kbd> method. </p>
<p>There are two ways of creating a new thread: creating a subclass of <kbd>Thread</kbd> or implementing the <kbd>Runnable</kbd> interface and passing the object of the implementing class to the <kbd>Thread</kbd> constructor. We can invoke the new thread by calling the <kbd>start()</kbd> method of the <kbd>Thread</kbd> class (which, in turn, calls the <kbd>run()</kbd> method that we implemented).</p>
<p>Then, we can either let the new thread run until its completion or pause it and let it continue again. We can also access its properties or intermediate results, if needed. </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p>First, we create a class called <kbd>AThread</kbd> that extends <kbd>Thread</kbd> and override its <kbd>run()</kbd> method: </p>
<pre><span>class </span>AThread <span>extends </span>Thread {<br/>  <span>int </span><span>i1</span><span>,</span><span>i2</span><span>;<br/></span><span>  </span><span>AThread</span>(<span>int </span>i1<span>, int </span>i2){<br/>    <span>this</span>.<span>i1 </span>= i1<span>;<br/></span><span>    this</span>.<span>i2 </span>= i2<span>;<br/></span><span>  </span>}<br/>  <span>public void </span><span>run</span>() {<br/>    IntStream.<span>range</span>(<span>i1</span><span>, </span><span>i2</span>)<br/>             .peek(Chapter07Concurrency::<span>doSomething</span>)<br/>             .forEach(System.<span>out</span>::println)<span>;<br/></span><span>  </span>}<br/>}</pre>
<p><span>In this example, we wanted the thread to generate a stream of integers in a certain range. Then, we peeked into each emitted integer (the method <kbd>peek()</kbd> cannot change the stream element) and called the static method <kbd>doSomething()</kbd> of the main class in order to make the thread busy for some time. Refer to the following code:</span></p>
<pre><span>private static int </span><span>doSomething</span>(<span>int i</span>){<br/>  IntStream.<span>range</span>(i<span>, </span><span>99999</span>).asDoubleStream().map(Math::<span>sqrt</span>).average()<span>;<br/></span><span>  return i</span><span>;<br/></span>}</pre>
<p>As you can see, this method generates another stream of integers in the range of <kbd>i</kbd> and <kbd>99999</kbd>, then converts the stream into a stream of doubles, calculates the square root of each of the stream elements, and finally calculates an average average of the stream. We discard the result and return the passed-in parameter (as a convenience that allows us to keep the fluent style in the stream pipe of the thread, which ends up printing out each element). Using this new class, we can now demonstrate the concurrent execution of the three threads:  </p>
<p> </p>
<pre>Thread thr1 = <span>new </span>AThread(<span>1</span><span>, </span><span>4</span>)<span>;<br/></span>thr1.start()<span>;<br/></span><span><br/></span>Thread thr2 = <span>new </span>AThread(<span>11</span><span>, </span><span>14</span>)<span>;<br/></span>thr2.start()<span>;<br/></span><span><br/></span>IntStream.<span>range</span>(<span>21</span><span>, </span><span>24</span>)<br/>         .peek(Chapter07Concurrency::<span>doSomething</span>)<br/>         .forEach(System.<span>out</span>::println)<span>;<br/></span></pre>
<p>The first thread generates the integers <kbd>1</kbd>, <kbd>2</kbd>, and <kbd>3</kbd>, the second generates the integers <kbd>11</kbd>, <kbd>12</kbd>, and <kbd>13</kbd>, and the third thread (main one) generates <kbd>21</kbd>, <kbd>22</kbd>, and <kbd>23</kbd>.</p>
<p>As mentioned before, we can rewrite the same program by creating and using a class that could implement the <kbd>Runnable</kbd> interface: </p>
<p> </p>
<pre><span>class </span>ARunnable <span>implements </span>Runnable {<br/>  <span>int </span><span>i1</span><span>,</span><span>i2</span><span>;<br/></span><span>  </span><span>ARunnable</span>(<span>int </span>i1<span>, int </span>i2){<br/>    <span>this</span>.<span>i1 </span>= i1<span>;<br/></span><span>    this</span>.<span>i2 </span>= i2<span>;<br/></span><span>  </span>}<br/>  <span>public void </span><span>run</span>() {<br/>    IntStream.<span>range</span>(<span>i1</span><span>, </span><span>i2</span>)<br/>             .peek(Chapter07Concurrency::<span>doSomething</span>)<br/>             .forEach(System.<span>out</span>::println)<span>;<br/></span><span>  </span>}<br/>}</pre>
<p>So, you can run the same three threads like this:</p>
<pre>Thread thr1 = <span>new </span>Thread(<span>new </span>ARunnable(<span>1</span><span>, </span><span>4</span>))<span>;<br/></span>thr1.start()<span>;<br/></span><span><br/></span>Thread thr2 = <span>new </span>Thread(<span>new </span>ARunnable(<span>11</span><span>, </span><span>14</span>))<span>;<br/></span>thr2.start()<span>;<br/></span><span><br/></span>IntStream.<span>range</span>(<span>21</span><span>, </span><span>24</span>)<br/>         .peek(Chapter07Concurrency::<span>doSomething</span>)<br/>         .forEach(System.<span>out</span>::println)<span>;<br/></span></pre>
<p>We can also take advantage of <kbd>Runnable</kbd> being a functional interface and avoid creating an intermediate class by passing in a lambda expression instead:</p>
<pre>Thread thr1 = <span>new </span>Thread(() -&gt; IntStream.<span>range</span>(<span>1</span><span>, </span><span>4</span>)<br/>                  .peek(Chapter07Concurrency::<span>doSomething</span>)<br/>                  .forEach(System.<span>out</span>::println))<span>;<br/></span>thr1.start()<span>;<br/></span><span><br/></span>Thread thr2 = <span>new </span>Thread(() -&gt; IntStream.<span>range</span>(<span>11</span><span>, </span><span>14</span>)<br/>                  .peek(Chapter07Concurrency::<span>doSomething</span>)<br/>                  .forEach(System.<span>out</span>::println))<span>;<br/></span>thr2.start()<span>;<br/></span><span><br/></span>IntStream.<span>range</span>(<span>21</span><span>, </span><span>24</span>)<br/>         .peek(Chapter07Concurrency::<span>doSomething</span>)<br/>         .forEach(System.<span>out</span>::println)<span>;<br/></span></pre>
<p>Which implementation is better depends on your goal and style. Implementing <kbd>Runnable</kbd> has an advantage (and in some cases, the only possible option) that it allows the implementation to extend from another class. It is particularly helpful when you would like to add thread-like behavior to an existing class. You can even invoke method <kbd>run()</kbd> directly, without passing the object to the <kbd>Thread</kbd> constructor. </p>
<p>Using a lambda expression wins over <kbd>Runnable</kbd> implementation when only method <kbd>run()</kbd> implementation is needed, no matter how big it is. If it is too big, you can have it isolated in a separate method:</p>
<pre>public static void main(String arg[]) {<br/>  Thread thr1 = <span>new </span>Thread(() -&gt; <span>runImpl</span>(<span>1</span><span>, </span><span>4</span>))<span>;<br/></span><span>  </span>thr1.start()<span>;<br/></span><span><br/></span><span>  </span>Thread thr2 = <span>new </span>Thread(() -&gt; <span>runImpl</span>(<span>11</span><span>, </span><span>14</span>))<span>;<br/></span><span>  </span>thr2.start()<span>;<br/></span><span><br/></span><span>  </span><span>runImpl</span>(<span>21</span><span>, </span><span>24</span>)<span>;</span><span><br/></span>}<br/><br/>private static void runImpl(int i1, int i2){<br/>  IntStream.range(i1, i2)<br/>           .peek(Chapter07Concurrency::doSomething)<br/>           .forEach(System.out::println);<br/>}</pre>
<p>One would be hard pressed to come up with a shorter implementation of the same functionality.</p>
<p>If we run any of the preceding versions, we will get something like this:</p>
<div class="CDPAlignCenter CDPAlign"><img height="116" width="403" src="assets/a7d8b2a4-7c0d-453a-bfb6-e27ee4448308.png"/></div>
<p>As you can see, the three threads print out their numbers in parallel, but the sequence depends on the particular JVM implementation and underlying operating system. So, you will probably get different output. Besides, it also changes from run to run. </p>
<p><span>The <kbd>Thread</kbd> class has several constructors that allow you to set the thread name and the group it belongs to. Grouping of threads helps manage them in case there are many threads running in parallel. The class also has several methods that provide information about the thread's status and properties and allow you to control its behavior. Add these two lines to the preceding example: </span></p>
<pre>System.<span>out</span>.println(<span>"Id=" </span>+ thr1.getId() + <span>", " </span>+ thr1.getName() + <span>",<br/>                   priority=" </span>+ thr1.getPriority() + <span>",<br/>                   state=" </span>+ thr1.getState())<span>;<br/>System.out.println("Id=" + thr2.getId() + ", " + thr2.getName() + ",<br/>                   priority=" + thr2.getPriority() + ",<br/>                   state=" + thr2.getState());</span></pre>
<p><span> You'll get something like this:</span></p>
<div class="CDPAlignCenter CDPAlign"><img height="42" width="436" src="assets/6bc78a6a-ddb4-4594-a619-de660561eb1c.png"/></div>
<p><span>Next, say, you add names to the threads:</span></p>
<pre>Thread thr1 = <span>new </span>Thread(() -&gt; <span>runImpl</span>(<span>1</span><span>, </span><span>4</span>)<span>, </span><span>"First Thread"</span>)<span>;<br/></span>thr1.start()<span>;<br/></span><span><br/></span>Thread thr2 =<span> new </span>Thread(() -&gt; <span>runImpl</span>(<span>11</span><span>, </span><span>14</span>)<span>, </span><span>"Second Thread"</span>)<span>;<br/></span>thr2.start()<span>;<br/></span></pre>
<p>In this case, the output will show the following:</p>
<div class="CDPAlignCenter CDPAlign"><img height="40" width="431" src="assets/f5d7fac4-bd4b-4ff9-bac0-95c654d2c7d4.png"/></div>
<p>The thread's <kbd>id</kbd> is generated automatically and cannot be changed, but it can be reused after the thread is terminated. The thread name, on the other hand, can be shared by several threads. Priority can be set programmatically with a value between <kbd>Thread.MIN_PRIORITY</kbd> and <kbd>Thread.MAX_PRIORITY</kbd>. The smaller the value, the more time the thread is allowed to run (which means it has higher priority). If not set, priority value defaults to <kbd>Thread.NORM_PRIORITY</kbd>. The state of a thread can have one of the following values:</p>
<ul>
<li><kbd>NEW</kbd>: When a thread has not yet started</li>
<li><kbd>RUNNABLE</kbd>: When a thread is being executed</li>
<li><kbd>BLOCKED</kbd>: When a thread is blocked and is waiting for a monitor lock</li>
<li><kbd>WAITING</kbd>: When a thread is waiting indefinitely for another thread to perform a particular action</li>
<li><kbd>TIMED_WAITING</kbd>: When a thread is waiting for another thread to perform an action for up to a specified waiting time</li>
<li><kbd>TERMINATED</kbd>: When a thread has exited</li>
</ul>
<p>We will talk about the <kbd>BLOCKED</kbd> and <kbd>WAITING</kbd> states in one of our recipes later.</p>
<p>The <kbd>sleep()</kbd> method can be used to suspend the thread execution for a specified (in milliseconds) period of time. The complementary method <kbd>interrupt()</kbd> sends <kbd>InterruptedException</kbd> to the thread that can be used to wake up the <em>sleeping</em> thread. Let's work this out in the code and create a new class:</p>
<pre><span>private static class </span>BRunnable <span>implements </span>Runnable {<br/>  <span>int </span><span>i1</span><span>, result</span><span>;<br/></span><span>  </span><span>BRunnable</span>(<span>int </span>i1){ <span>this</span>.<span>i1 </span>= i1<span>; </span>}<br/>  <span>public int </span><span>getCurrentResult</span>(){ <span>return this</span>.result<span>; </span>}<br/>  <span>public void </span><span>run</span>() {<br/>    <span>for</span>(<span>int </span>i = i<span>1</span><span>; </span>i &lt; i1 + 6<span>; </span>i++){<br/>      //Do something useful here<br/><span>      this</span>.result<span> </span>= i<span>;<br/></span><span>      try</span>{ Thread.<span>sleep</span>(<span>1000</span>)<span>;<br/></span><span>      </span>} <span>catch</span>(InterruptedException ex){}<br/>    }<br/>  }<br/>}</pre>
<p>The preceding code produces intermediate results, which are stored in the property <kbd>result</kbd>. Each time a new result is produced, the thread sleeps for one second. In this specific example, written for demonstration purposes only, the code does not do anything particularly useful.  It just iterates over a set of values and considers each of them a result. In a real-world code, you would do some calculations here based on the current state of the system or something and assign the calculated value to the property <kbd>result</kbd>. Now let's use this class:</p>
<pre>BRunnable r1 = <span>new </span>BRunnable(<span>1</span>)<span>;<br/></span>Thread thr1 = <span>new </span>Thread(r1)<span>;<br/></span>thr1.start()<span>;<br/></span><span><br/></span>IntStream.<span>range</span>(<span>21</span><span>, </span><span>29</span>)<br/>         .peek(i -&gt; <span>thr1</span>.interrupt())<br/>         .filter(i -&gt;  {<br/>           <span>int </span>res = <span>r1</span>.getCurrentResult()<span>;<br/></span><span>           </span>System.<span>out</span>.print(res + <span>" =&gt; "</span>)<span>;<br/></span><span>           return </span>res % <span>2 </span>== <span>0</span><span>;<br/></span><span>         </span>})<br/>         .forEach(System.<span>out</span>::println)<span>;<br/></span></pre>
<p><span>The preceding program generates a stream of integers: 21, 22, ..., 28. After each integer is generated, the main thread interrupts the <kbd>thr1</kbd> thread and lets it generate the next result, which is then accessed via the <kbd>getCurrentResult()</kbd> method and analyzed. If the current result is an even number, the filter allows the generated number flow to be printed out. If not, it is skipped. Here is a possible result:</span></p>
<div class="CDPAlignCenter CDPAlign"><img height="73" width="423" src="assets/47552ae2-9a12-4c4a-88b4-e35729ad770c.png"/></div>
<p><span>It will be different if the program is run on different computers, but you get the idea: this way, one thread can control the output of another thread.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">There's more...</h1>
                </header>
            
            <article>
                
<p><span>There are two other important methods that allow threads to cooperate. First is the <kbd>join()</kbd> method that allows the current thread to wait until another thread is terminated. Overloaded versions of <kbd>join()</kbd> accept the parameters that define how long the thread has to wait before it could do something else. </span></p>
<p>The <kbd>setDaemon()</kbd> method terminates the thread automatically after all the non-daemon threads are terminated. Usually, it is used for background and supporting processes.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">See also</h1>
                </header>
            
            <article>
                
<p>Refer to the following recipes in this chapter:</p>
<ul>
<li>Different synchronization approaches</li>
<li>Immutability as a means to achieve concurrency</li>
<li>Using concurrent collections</li>
<li>Using the executor service to execute async tasks</li>
<li>Using fork/join to implement divide-and-conquer</li>
<li>Using flow to implement the publish-subscribe pattern</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Different synchronization approaches</h1>
                </header>
            
            <article>
                
<p>In this recipe, you will learn about the two most popular and basic methods of managing concurrent access to common resources in Java: a <kbd>synchronized</kbd> method and a <kbd>synchronized</kbd> block. </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p>Two or more threads modifying the same value while other threads reading it is the most general description of a problem of concurrent access. Subtler problems include <em>thread interference</em> and <em>memory consistency errors</em>, both producing unexpected results in seemingly benign fragments of code.  We are going to demonstrate such cases and ways to avoid them.</p>
<p>At first glance, it seems quite straightforward: just allow only one thread at a time to modify/access the resource and that's it. But if the access takes a long time, then it creates a bottleneck that might eliminate the advantage of having many threads working in parallel. Or, if one thread blocks access to one resource while waiting for access to another resource and the second thread blocks access to the second resource while waiting for access to the first one, then it creates a problem called a deadlock. These are two very simple examples of the possible challenges a programmer has to tackle while dealing with multiple threads.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p>First, we'll check out a problem caused by concurrency. Let's create a <kbd>Calculator</kbd> class that has the <kbd>calculate()</kbd>: method: </p>
<pre><span>class </span>Calculator{<br/>  <span>private double </span><span>prop</span><span>;<br/></span><span>  public double </span><span>calculate</span>(<span>int </span>i){<br/>    <span>this</span>.<span>prop </span>= <span>2.0 </span>* i<span>;<br/></span><span>    </span>DoubleStream.<span>generate</span>(<span>new </span>Random()::nextDouble)<br/>                .limit(<span>10</span>)<span>;<br/></span><span>    return </span>Math.<span>sqrt</span>(<span>this</span>.<span>prop</span>)<span>;<br/></span><span>  </span>}<br/>}</pre>
<p>This method assigns an input value to a property and then calculates its square root. We also inserted code that generates a stream of 10 values. We did this in order to keep the method busy for some time. Otherwise, everything is done so quickly that there will be little chance for any concurrency to occur. Also, we wanted the return value to be obviously the same all the time, so we did not complicate it by having calculations and made the method busy by an unrelated activity. Now we are going to use it in the following code:</p>
<pre>Calculator c = <span>new </span>Calculator()<span>;</span><span><br/></span>Thread thr1 = <span>new </span>Thread(() -&gt; System.<span>out</span>.println(IntStream.<span>range</span>(<span>1</span><span>, </span><span>4</span>)<br/>          .peek(x -&gt;DoubleStream.<span>generate</span>(<span>new </span>Random()::nextDouble)<br/>          .limit(<span>10</span>)).mapToDouble(<span>c</span>::calculate).sum()))<span>;<br/></span>thr1.start()<span>;</span><span><br/></span>Thread thr2 = <span>new </span>Thread(() -&gt; System.<span>out</span>.println(IntStream.<span>range</span>(<span>1</span><span>, </span><span>4</span>)<br/>          .mapToDouble(<span>c</span>::calculate).sum()))<span>;<br/></span>thr2.start()<span>;<br/></span></pre>
<p>Even for a novice, it will be obvious that two threads accessing the same object will have a good chance of stepping on each other's toes. As you can see, the <kbd>Random</kbd> interface implementation prints out the sum of the same three numbers, that is, 1, 2, and 3, after each one of them is processed by the <kbd>calculate()</kbd> method of the object of <kbd>Calculator</kbd>. Inside <kbd>calculate()</kbd>, each number is multiplied by two and then pushed through the square root extraction process. The operation is so simple that we can even calculate it by hand in advance. The result is going to be <kbd>5.863703305156273</kbd>. And again, to the first thread, we have added the <kbd>peek()</kbd> operator with 10 double-generating code to make it run a bit slower to give concurrency a better chance to happen. If you run these examples on your computer and do not see the effect of concurrency, try to increase the number of doubles by replacing <kbd>10</kbd> with <kbd>100</kbd>, for example.</p>
<p>Now run the code. Here is one of the possible results:</p>
<div class="CDPAlignCenter CDPAlign"><img height="36" width="494" src="assets/1f97f474-3cce-45e2-ad94-0bf99e8a72b5.png"/></div>
<p>One thread got the correct result, while the other did not. Apparently, in the period between setting the value of the <kbd>prop</kbd> property and then using it to return the result of the <kbd>calculate()</kbd> method, the other thread managed to assign its (smaller) value to <kbd>prop</kbd>. This is the case of thread interference. </p>
<p>There are two ways to protect code from such a problem: using a <kbd>synchronized</kbd> method or a <kbd>synchronized</kbd> block; these help include lines of code that are always executed as an atomic operation without any interference from another thread.</p>
<p>Making a <kbd>synchronized</kbd> method is easy and straightforward:</p>
<pre><span>class </span>Calculator{<br/>  <span>private double </span><span>prop</span><span>;<br/></span><span><strong>  synchronized</strong> public double </span><span>calculate</span>(<span>int </span>i){<br/>    <span>this</span>.<span>prop </span>= <span>2.0 </span>* i<span>;<br/></span><span>    </span>DoubleStream.<span>generate</span>(<span>new </span>Random()::nextDouble).limit(<span>10</span>)<span>;<br/></span><span>    return </span>Math.<span>sqrt</span>(<span>this</span>.<span>prop</span>)<span>;<br/></span><span>  </span>}<br/>}</pre>
<p><span>We just add the <kbd>synchronized</kbd> keyword in front of the method definition. Now, no matter how big a stream of doubles is generated, the result of our program is always going to be as follows:</span></p>
<div class="CDPAlignCenter CDPAlign"><img height="37" width="402" src="assets/abd436e8-31d5-4436-aea3-a1a1d0fff1b7.png"/></div>
<p>This is because another thread cannot enter the <kbd>synchronized</kbd> method until the current thread (the one that has entered the method already) has exited it. This approach may cause performance degradation if the method takes a long time to execute, so many threads might be blocked, waiting for their turn to use the method. In such cases, a <kbd>synchronized</kbd> block can be used to wrap several lines of code in an atomic operation: </p>
<pre><span>private static class </span>Calculator{<br/>  <span>private double </span><span>prop</span><span>;<br/></span><span>  public double </span><span>calculate</span>(<span>int </span>i){<br/>    <span>synchronized (this) {<br/></span><span>      </span><span>this</span>.<span>prop </span>= <span>2.0 </span>* i<span>;<br/></span><span>      </span>DoubleStream.<span>generate</span>(<span>new </span>Random()::nextDouble).limit(<span>10</span>)<span>;<br/></span><span>      return </span>Math.<span>sqrt</span>(<span>this</span>.<span>prop</span>)<span>;<br/></span><span>    </span>}<br/>  <span>}<br/></span></pre>
<p><span>Alternatively, you can do this:</span></p>
<pre><span>private static class </span>Calculator{<br/>  <span>private double </span><span>prop</span><span>;<br/></span><span>  public double </span><span>calculate</span>(<span>int </span>i){<br/>    DoubleStream.generate(new Random()::nextDouble).limit(10);<br/>    <span><strong>synchronized (this)</strong> {<br/></span><span>      </span><span>this</span>.<span>prop </span>= <span>2.0 </span>* i<span>;</span><span><br/></span><span>      return </span>Math.<span>sqrt</span>(<span>this</span>.<span>prop</span>)<span>;<br/></span><span>    </span>}<br/>  <span>}<br/></span></pre>
<p>We can do this because by studying the code, we have discovered that we can rearrange it such that the synchronized portion will be much smaller, thus having fewer chances to become a bottleneck.</p>
<p>A <kbd>synchronized</kbd> block acquires a lock on an object, any object for that matter. It could be, for example, a dedicated one:</p>
<pre><span>private static class </span>Calculator{<br/>  <span>private double </span><span>prop</span><span>;<br/></span><span>  private </span>Object <span>calculateLock </span>= <span>new </span>Object()<span>;<br/></span><span>  public double </span><span>calculate</span>(<span>int </span>i){<br/>    DoubleStream.generate(new Random()::nextDouble).limit(10);<br/>    <span>synchronized </span>(<span>calculateLock</span>) {<br/>      <span>this</span>.<span>prop </span>= <span>2.0 </span>* i<span>;<br/></span><span>     </span><span> return </span>Math.<span>sqrt</span>(<span>this</span>.<span>prop</span>)<span>;<br/></span><span>    </span>}<br/>  }<br/>}</pre>
<p>The advantage of a dedicated lock is that you can be sure that such a lock will be used for accessing a particular block only. Otherwise, the current object (<kbd>this</kbd>) might be used to control access to another block; in a huge class, you might not notice this while writing your code. A lock can also be acquired from a class, which is even more susceptible to sharing for unrelated purposes.</p>
<p>We did all these examples just for demonstrating synchronization approaches. If they were to be real code, we would just let each thread create its own <kbd>Calculator</kbd> object:</p>
<pre>Thread thr1 = <span>new </span>Thread(() -&gt; System.<span>out</span>.println(IntStream.<span>range</span>(<span>1</span><span>, </span><span>4</span>)<br/>  .peek(x -&gt;DoubleStream.<span>generate</span>(<span>new </span>Random()::nextDouble)<br/>  .limit(<span>10</span>))<br/>  .mapToDouble(x -&gt; {<br/>     Calculator c = <span>new </span>Calculator()<span>;<br/></span><span>     return </span>c.calculate(x)<span>;<br/></span><span>  </span>}).sum()))<span>;<br/></span>thr1.start()<span>;<br/></span><span><br/></span>Thread thr2 = <span>new </span>Thread(() -&gt; System.<span>out</span>.println(IntStream.<span>range</span>(<span>1</span><span>, </span><span>4</span>)<br/>    .mapToDouble(x -&gt; {<br/>       Calculator c = <span>new </span>Calculator()<span>;<br/></span><span>       return </span>c.calculate(x)<span>;<br/></span><span>    </span>}).sum()))<span>;<br/></span>thr2.start()<span>;<br/></span></pre>
<p>This would be in line with the general idea of making lambda expressions independent of the context in which they are created. This is because in a multithreaded environment, one never knows how the context would look during their execution. The cost of creating a new object every time is negligible unless a large amount of data has to be processed, and testing ensures that the object creation overhead is noticeable. Making the <kbd>calculate()</kbd> method (and the property) static (which is tempting as it avoids object creation and preserves the fluent style) would not eliminate the concurrency problem because one shared (at the class level this time) value of the property would still remain in place. </p>
<p>Memory consistency errors can have many forms and causes in a multithreaded environment. They are well discussed in the Javadoc of the <kbd>java.util.concurrent</kbd> package. Here we will mention only the most common case caused by lack of visibility. When one thread changes a property value, the other might not see the change immediately, and you cannot use <kbd>synchronized</kbd> keyword for a primitive type. In such a situation, consider using the <kbd>volatile</kbd> keyword for such a property; it guarantees its read/write visibility between different threads. </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">There's more...</h1>
                </header>
            
            <article>
                
<p>Different types of locks for different needs and with different behavior are assembled in the <kbd>java.util.concurrent.locks</kbd> package.  </p>
<p>The <kbd>java.util.concurrent.atomic</kbd> package provides support for lock-free, thread-safe programming on single variables.</p>
<p>The following classes provide synchronization support too:</p>
<ul>
<li><kbd>Semaphore</kbd>: This restricts the number of threads that can access some resource</li>
<li><kbd>CountDownLatch</kbd>: This allows one or more threads to wait until a set of operations being performed in other threads are completed</li>
<li><kbd>CyclicBarrier</kbd>: This allows a set of threads to wait for each other to reach a common barrier point</li>
<li><kbd>Phaser</kbd>: This provides a more flexible form of barrier that may be used to control phased computation among multiple threads</li>
<li><kbd>Exchanger</kbd>: This allows two threads to exchange objects at a rendezvous point and is useful in several pipeline designs</li>
</ul>
<p>Each object in Java is inherited from the base object's <kbd>wait()</kbd>, <kbd>notify()</kbd>, and <kbd>notifyAll()</kbd> methods; these can also be used to control threads' behavior and their access to and release from locks.</p>
<p>The <kbd>Collections</kbd> class has methods that make various collections synchronized. However, this means that only the modifications of the collection could become thread-safe, not the changes to the collection members. Also, while traversing the collection via its iterator, it has to be protected too because an iterator is not thread-safe. Here is a Javadoc example of the correct usage of a synchronized map:</p>
<pre> Map m = Collections.synchronizedMap(new HashMap());<br/> ...<br/> Set s = m.keySet(); // Needn't be in synchronized block<br/> ...<br/> synchronized (m) { // Synchronizing on m, not s!<br/>   Iterator i = s.iterator(); //Must be synchronized block<br/>   while (i.hasNext())<br/>   foo(i.next());<br/> }</pre>
<p>To add more to your plate as a programmer, you have to realize that the following code is not thread-safe:</p>
<pre>List&lt;String&gt; l = <br/>       Collections.<span>synchronizedList</span>(<span>new </span>ArrayList&lt;&gt;())<span>;<br/></span>l.add(<span>"first"</span>)<span>;<br/></span><span>//... code that adds more elements to the list<br/></span><span>int </span>i = l.size()<span>;<br/></span><span>//... some other code<br/></span>l.add(i<span>, </span><span>"last"</span>)<span>;<br/></span></pre>
<p>This is because although <kbd>List l</kbd> is synchronized, in multithreaded processing, it is quite possible that some other code would add more elements to the list (then the intended last does not reflect the reality) or remove an element (then the code fails with <kbd>IndexOutOfBoundException</kbd>). </p>
<p>The ones described here are a few of the most often encountered concurrency problems. <span>These problems are not easy to solve. That is why it is not surprising that more and more developers now take a more radical approach. They avoid managing the state. Instead, they prefer writing non-blocking code for asynchronous and parallel processing data in a set of stateless operations. We saw similar code in the chapter about stream pipelines. It seems that Java and many modern languages and computer systems are evolving in this direction.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"> See also</h1>
                </header>
            
            <article>
                
<p>Refer to the following recipes in this chapter:</p>
<ul>
<li>Immutability as a means to achieve concurrency</li>
<li>Using concurrent collections</li>
<li>Using the executor service to execute async tasks</li>
<li>Using fork/join to implement divide-and-conquer</li>
<li>Using flow to implement the publish-subscribe pattern</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Immutability as a means to achieve concurrency</h1>
                </header>
            
            <article>
                
<p>In this recipe, you will learn how to use immutability against problems caused by concurrency. </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p>A concurrency problem most often occurs when different threads modify and read data from the same shared resource. Decreasing the number of modifying operations diminishes the risk of concurrency issues. This is where immutability--the condition of read-only values--enters the stage. </p>
<p><span>Object immutability means an absence of means to change its state after the object has been created. It does not guarantee thread safety but helps to increase it significantly and provide sufficient protection from concurrency problems in many practical applications. </span></p>
<p>Creating a new object instead of reusing an existing one (by changing its state via setters and getters) is often perceived as an expensive approach. But with the power of modern computers, there has to be a huge number of object creations done for performance to be affected in any significant way. And even if that is the case, programmers often prefer some performance degradation as the price for getting more reliable results.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p>Here is a very basic class that produces mutable objects:</p>
<pre><span>class </span>MutableClass{<br/>  <span>private int </span><span>prop</span><span>;<br/></span><span>  public </span><span>MutableClass</span>(<span>int </span>prop){<br/>    <span>this</span>.<span>prop </span>= prop<span>;<br/></span><span>  </span>}<br/>  <span>public int </span><span>getProp</span>(){<br/>    <span>return this</span>.<span>prop</span><span>;<br/></span><span>  </span>}<br/>  <span>public void </span><span>setProp</span>(<span>int </span>prop){<br/>    <span>this</span>.<span>prop </span>= prop<span>;<br/></span><span>  </span>}<br/>}</pre>
<p>To make it immutable, we need to remove the setter and add the <kbd>final</kbd> keyword to its only property and the class itself:</p>
<pre><span>final class Imm</span>utableClass{<br/>  final <span>private int </span><span>prop</span><span>;<br/></span><span>  public Imm</span><span>utableClass</span>(<span>int </span>prop){<br/>    <span>this</span>.<span>prop </span>= prop<span>;<br/></span><span>  </span>}<br/>  <span>public int </span><span>getProp</span>(){<br/>    <span>return this</span>.<span>prop</span><span>;<br/></span><span>  </span>}<br/>}</pre>
<p>Adding the <kbd>final</kbd> keyword to a class prevents it from being extended, so its methods cannot be overridden. Adding <kbd>final</kbd> to a private property is not as obvious. The motivation is somewhat complex and has to do with the way the compiler reorders the fields during object construction. If the field is declared <kbd>final</kbd>, it is treated by the compiler as synchronized. That is why adding <kbd>final</kbd> to a private property is necessary to make the object completely immutable.</p>
<p>The challenge mounts up if the class is composed of other classes, especially mutable ones. When this happens, the injected class might bring in code that would affect the containing class. Also, the inner (mutable) class, which is retrieved by references via the getter, could then be modified and propagate the change inside the containing class. The way to close such holes is to generate new objects during the composition of the object retrieval. Here is an example of this:</p>
<pre><span>final class </span>ImmutableClass{<br/>  <span>private final double </span><span>prop</span><span>;<br/></span><span>  private final </span>MutableClass <span>mutableClass</span><span>;<br/></span><span>  public </span><span>ImmutableClass</span>(<span>double </span>prop<span>, </span>MutableClass mc){<br/>    <span>this</span>.<span>prop </span>= prop<span>;<br/></span><span>    this</span>.<span>mutableClass </span>= <span>new </span>MutableClass(mc.getProp())<span>;<br/></span><span>  </span>}<br/>  <span>public double </span><span>getProp</span>(){<br/>    <span>return this</span>.<span>prop</span><span>;<br/></span><span>  </span>}<br/>  <span>public </span>MutableClass <span>getMutableClass</span>(){<br/>    <span>return new </span>MutableClass(<span>mutableClass</span>.getProp())<span>;<br/></span><span>  </span>}<br/>}</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">There's more...</h1>
                </header>
            
            <article>
                
<p><span>In our examples, we used very simple code. If more complexity is added to any of the methods, especially with parameters (and especially when some of the parameters are objects), it is possible you'll get concurrency issues again:</span></p>
<pre><span>int</span> <span>getSomething</span>(AnotherMutableClass amc, String whatever){<br/>  //... code is here that generates a value "whatever" <br/>  amc.setProperty(whatever);<br/>  //...some other code that generates another value "val"<br/><span>  amc.setAnotherProperty(val);<br/>  return amc.getIntValue();<br/></span>}</pre>
<p><span>Even if this method belongs to <kbd>ImmutableClass</kbd> and does not affect the state of the <kbd>ImmutableClass</kbd> object, it is still a subject of the thread's race and has to be analyzed and protected as needed.</span></p>
<p>The <kbd>Collections</kbd> class has methods that make various collections unmodifiable. It means that the modification of the collection itself becomes read only, not the collection members.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">See also</h1>
                </header>
            
            <article>
                
<p>Refer to the following recipes in this chapter:</p>
<ul>
<li>Using concurrent collections</li>
<li>Using the executor service to execute async tasks</li>
<li>Using fork/join to implement divide-and-conquer</li>
<li>Using flow to implement the publish-subscribe pattern</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Using concurrent collections</h1>
                </header>
            
            <article>
                
<p>In this recipe, you will learn about the thread-safe collections of the <kbd>java.util.concurrent</kbd> package. </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p><span>A collection can be synchronized if you apply one of the <kbd>Collections.synchronizeXYZ()</kbd> methods to it; here, we have used XYZ as a placeholder that represents either <kbd>Set</kbd>, <kbd>List</kbd>, <kbd>Map</kbd>, or one of the several collection types (see the API of the <kbd>Collections</kbd></span> class<span>). We have already mentioned that the synchronization applies to the collection itself, not to its iterator or the collection members. </span></p>
<p>Such synchronized collections are also called <strong>wrappers</strong> because all of the functionality is still provided by the collections passed as parameters to the<span> </span><kbd>Collections.synchronizeXYZ()</kbd><span> methods, so the wrappers provide only thread-safe access to them. The same effect could be achieved by acquiring a lock on the original collection. Obviously, such a synchronization incurs a performance overhead in a multithreading environment causing each thread to wait for its turn to access the collection.</span></p>
<p>A well-tuned application for performance implementation of thread-safe collections is provided by the <kbd>java.util.concurrent</kbd> package. </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p>Each of the concurrent collections of the <kbd>java.util.concurrent</kbd> package implements (or extends, if it is an interface) one of the four interfaces of the <kbd>java.util</kbd> package: <kbd>List</kbd>, <kbd>Set</kbd>, <kbd>Map</kbd>, or <kbd>Queue</kbd>:</p>
<ol>
<li>The <kbd>List</kbd> interface has only one implementation: the <kbd>CopyOnWriteArrayList</kbd> class. According to the Javadoc of this class, <em>all mutative operations (add, set, and so on) are implemented by making a fresh copy of the underlying array.... The "snapshot" style iterator method uses a reference to the state of the array at the point that the iterator was created. This array never changes during the lifetime of the iterator, so interference is impossible and the iterator is guaranteed not to throw ConcurrentModificationException. The iterator will not reflect additions, removals, or changes to the list since the iterator was created. Element-changing operations on iterators themselves (remove, set, and add) are not supported. These methods throw UnsupportedOperationException.</em> To demonstrate the behavior of the <kbd>CopyOnWriteArrayList</kbd><span> class, let's compare it with <kbd>java.util.ArrayList</kbd> (which is not a thread-safe implementation of <kbd>List</kbd>). Here is the method that adds an element to the list while iterating on the same list:</span></li>
</ol>
<pre><span>        void </span><span>demoListAdd</span>(List&lt;String&gt; list) {<br/>    <span> </span><span>     </span>System.<span>out</span>.println(<span>"list: " </span>+ list)<span>;<br/></span><span>          try </span>{<br/>      <span> </span><span>     </span><span>for </span>(String e : list) {<br/>        <span> </span><span>     </span>System.<span>out</span>.println(e)<span>;<br/></span><span>              if </span>(!list.contains(<span>"Four"</span>)) {<br/>          <span> </span><span> </span><span> </span><span> </span><span> </span><span> </span>System.<span>out</span>.println(<span>"Calling list.add(Four)..."</span>)<span>;<br/></span><span>                </span>list.add(<span>"Four"</span>)<span>;<br/></span><span>              </span>}<br/>      <span> </span><span> </span><span> </span><span> </span><span> </span><span> </span>}<br/>    <span> </span><span> </span><span> </span><span> </span><span> </span><span> </span>} <span>catch </span>(Exception ex) {<br/>        <span> </span><span> </span><span> </span><span> </span>System.<span>out</span>.println(ex.getClass().getName())<span>;<br/></span><span>          </span>}<br/>    <span> </span><span> </span><span> </span><span> </span><span> </span><span> </span>System.<span>out</span>.println(<span>"list: " </span>+ list)<span>;<br/></span><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span>}</pre>
<p style="padding-left: 60px"><span>Consider the following code:</span></p>
<pre><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span>System.<span>out</span>.println(<span>"***** ArrayList add():"</span>)<span>;<br/></span><span>        demoListAdd</span>(<span>new </span>ArrayList&lt;&gt;(Arrays<br/>                          .<span>asList</span>(<span>"One"</span><span>, </span><span>"Two"</span><span>, </span><span>"Three"</span>)))<span>;<br/></span><span><br/></span><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span>System.<span>out</span>.println()<span>;<br/></span><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span>System.<span>out</span>.println(<span>"***** CopyOnWriteArrayList add():"</span>)<span>;<br/></span><span>        demoListAdd</span>(<span>new </span>CopyOnWriteArrayList&lt;&gt;(Arrays.<span>asList</span>(<span>"One"</span><span>, <br/></span><span>                                         "Two"</span><span>, </span><span>"Three"</span>)))<span>;<br/></span></pre>
<p style="padding-left: 60px">If we execute this code, the result would be as follows:</p>
<div class="CDPAlignCenter CDPAlign"><img height="182" width="439" src="assets/9d3be92f-49be-46b4-82f2-572566dfa397.png"/></div>
<p style="padding-left: 60px">As you can see, <kbd>ArrayList</kbd> throws <kbd>ConcurrentModificationException</kbd> when the list is modified while being iterated (we used the same thread for simplicity and because it leads to the same effect, as in the case of another thread modifying the list). The specification, though, does not guarantee that the exception will be thrown or the list modification applied (as in in our case), so a programmer should not base the application logic on such behavior. The <kbd>CopyOnWriteArrayList</kbd> class, on the other hand, tolerates the same intervention; however, notice that it does not add a new element to the current list because the iterator was created from a snapshot of the fresh copy of the underlying array.</p>
<p style="padding-left: 60px">Now let's try to remove a list element concurrently while traversing the list, using this method:</p>
<pre><span>        void </span><span>demoListRemove</span>(List&lt;String&gt; list) {<br/> <span> </span><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span> System.<span>out</span>.println(<span>"list: " </span>+ list)<span>;<br/></span><span>          try </span>{<br/>   <span> </span><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span> <span>for </span>(String e : list) {<br/>     <span> </span><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span> System.<span>out</span>.println(e)<span>;<br/></span><span>              if </span>(list.contains(<span>"Two"</span>)) {<br/>        <span> </span><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span>System.<span>out</span>.println(<span>"Calling list.remove(Two)..."</span>)<span>;<br/></span><span>                </span>list.remove(<span>"Two"</span>)<span>;<br/></span><span>              </span>}<br/>    <span> </span><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span>}<br/>  <span> </span><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span>} <span>catch </span>(Exception ex) {<br/>     <span> </span><span> </span><span> </span><span> </span><span> </span><span> </span> System.<span>out</span>.println(ex.getClass().getName())<span>;<br/></span><span>          </span>}<br/><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span>  System.<span>out</span>.println(<span>"list: " </span>+ list)<span>;<br/></span><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span>}</pre>
<p style="padding-left: 60px">Consider the following code:</p>
<pre><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span>System.<span>out</span>.println(<span>"***** ArrayList remove():"</span>)<span>;<br/></span><span>        demoListRemove</span>(<span>new </span>ArrayList&lt;&gt;(Arrays.<span>asList</span>(<span>"One"</span><span>, <br/></span><span>                                         "Two"</span><span>, </span><span>"Three"</span>)))<span>;<br/></span><span><br/></span><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span>System.<span>out</span>.println()<span>;<br/></span><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span>System.<span>out</span>.println(<span>"***** CopyOnWriteArrayList remove():"</span>)<span>;<br/></span><span>        demoListRemove</span>(<span>new </span>CopyOnWriteArrayList&lt;&gt;(Arrays<br/>                         <span> </span><span> </span><span> </span><span> </span><span> </span><span> </span> .<span>asList</span>(<span>"One"</span><span>, </span><span>"Two"</span><span>, </span><span>"Three"</span>)))<span>;<br/></span></pre>
<p style="padding-left: 60px">If we execute this, we will get the following:</p>
<div class="CDPAlignCenter CDPAlign"><img height="169" width="408" src="assets/a6bf9320-f196-4fa3-b905-1b1d9e2c1608.png"/></div>
<p style="padding-left: 60px">The behavior is similar to the previous example. The <kbd>CopyOnWriteArrayList</kbd> class tolerates <span>the concurrent access to the list but does not modify the current list's copy.  </span></p>
<p style="padding-left: 60px"><span>We knew <kbd>ArrayList</kbd> would not be thread-safe for a long time, so we used a different technique to remove an element from the list while traversing it. Here is how this was done before the Java 8 release:</span></p>
<pre><span>        void </span><span>demoListIterRemove</span>(List&lt;String&gt; list) {<br/>  <span> </span><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span>System.<span>out</span>.println(<span>"list: " </span>+ list)<span>;<br/></span><span>          try </span>{<br/>   <span> </span><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span> Iterator iter = list.iterator()<span>;<br/></span><span>            while </span>(iter.hasNext()) {<br/>   <span> </span><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span>   String e = (String) iter.next()<span>;<br/></span><span>              </span>System.<span>out</span>.println(e)<span>;<br/></span><span>              if </span>(<span>"Two"</span>.equals(e)) {<br/>     <span> </span><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span>   System.<span>out</span>.println(<span>"Calling iter.remove()..."</span>)<span>;<br/></span><span>                </span>iter.remove()<span>;<br/></span><span>              </span>}<br/>   <span> </span><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span> }<br/> <span> </span><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span> } <span>catch </span>(Exception ex) {<br/>     <span> </span><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span> System.<span>out</span>.println(ex.getClass().getName())<span>;<br/></span><span>          </span>}<br/> <span> </span><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span> System.<span>out</span>.println(<span>"list: " </span>+ list)<span>;<br/></span><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span>}</pre>
<p style="padding-left: 60px"><span> Let's try this and run the code:</span></p>
<pre><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span>System.<span>out</span>.println(<span>"***** ArrayList iter.remove():"</span>)<span>;<br/></span><span>        demoListIterRemove</span>(<span>new </span>ArrayList&lt;&gt;(Arrays<br/>              <span> </span><span> </span>           .<span>asList</span>(<span>"One"</span><span>, </span><span>"Two"</span><span>, </span><span>"Three"</span>)))<span>;<br/></span><span><br/></span><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span>System.<span>out</span>.println()<span>;<br/></span><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span>System.<span>out</span>.println(<span>"*****" <br/>                           + " CopyOnWriteArrayList iter.remove():"</span>)<span>;<br/></span><span>        demoListIterRemove</span>(<span>new </span>CopyOnWriteArrayList&lt;&gt;(Arrays<br/>                           .<span>asList</span>(<span>"One"</span><span>, </span><span>"Two"</span><span>, </span><span>"Three"</span>)))<span>;<br/></span></pre>
<p style="padding-left: 60px">The result will be as follows:</p>
<div class="CDPAlignCenter CDPAlign"><img height="167" width="454" src="assets/7617419e-7428-4f5d-a99c-784f45e87586.png"/></div>
<p style="padding-left: 60px">This is exactly what Javadoc warned about: "<em>Element-changing operations on iterators themselves (remove, set, and add) are not supported. These methods throw UnsupportedOperationException."</em> We should remember this when upgrading an application to make it work in a multithreaded environment: just changing from <kbd>ArrayList()</kbd> to <kbd>CopyOnWriteArrayList</kbd><span> would not be enough if we use an iterator to remove a list element. </span></p>
<p style="padding-left: 60px">Since Java 8, we have a better way to remove an element from a collection using a lambda, which we can and should use from now on (leaving plumbing details to the library):</p>
<pre><span>        void </span><span>demoRemoveIf</span>(Collection&lt;String&gt; collection) {<br/>    <span> </span><span> </span><span> </span><span> </span><span> </span><span> </span>System.<span>out</span>.println(<span>"collection: " </span>+ collection)<span>;<br/></span><span>          </span>System.<span>out</span>.println(<span>"Calling list.removeIf(e -&gt;" <br/>                              + " Two.equals(e))..."</span>)<span>;<br/></span><span>          </span>collection.removeIf(e -&gt; <span>"Two"</span>.equals(e))<span>;<br/></span><span>          </span>System.<span>out</span>.println(<span>"collection: " </span>+ collection)<span>;<br/></span><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span>}</pre>
<p style="padding-left: 60px">So let's do this:</p>
<pre><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span>System.<span>out</span>.println(<span>"***** ArrayList list.removeIf():"</span>)<span>;<br/></span><span>        demoRemoveIf</span>(<span>new </span>ArrayList&lt;&gt;(Arrays<br/>                          .<span>asList</span>(<span>"One"</span><span>, </span><span>"Two"</span><span>, </span><span>"Three"</span>)))<span>;<br/></span><span><br/></span><span> </span><span> </span><span> </span><span> </span><span>  </span><span> </span><span> </span>System.<span>out</span>.println()<span>;<br/></span><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span>System.<span>out</span>.println(<span>"*****" <br/>                   + " CopyOnWriteArrayList list.removeIf():"</span>)<span>;<br/></span><span>        demoRemoveIf</span>(<span>new </span>CopyOnWriteArrayList&lt;&gt;(Arrays<br/>                          .<span>asList</span>(<span>"One"</span><span>, </span><span>"Two"</span><span>, </span><span>"Three"</span>)))<span>;<br/></span></pre>
<p style="padding-left: 60px">The result of the preceding code is as follows:</p>
<div class="CDPAlignCenter CDPAlign"><img height="131" width="468" src="assets/6896d051-ab90-460b-a691-cb94a0459c97.png"/></div>
<p style="padding-left: 60px"> It is short and has no problem with any of the collections and in line with the general trend of having a stateless parallel computation that uses streams with lambdas and functional interfaces.</p>
<p style="padding-left: 60px">Also, after we upgrade an application to use the <kbd>CopyOnWriteArrayList</kbd><span> class, </span>we can take advantage of a simpler way of adding a new element to the list (without first checking whether it is already there): </p>
<pre>        CopyOnWriteArrayList&lt;String&gt; list = <span> new </span>CopyOnWriteArrayList&lt;&gt;<br/>                              (Arrays.<span>asList</span>(<span>"Five"</span><span>, </span><span>"Six"</span><span>, </span><span>"Seven"</span>))<span>;<br/></span>        list.addIfAbsent(<span>"One"</span>)<span>;</span><span><br/></span></pre>
<p style="padding-left: 60px"><span>With</span><span> </span><kbd>CopyOnWriteArrayList</kbd><span>, this can be done as an atomic operation, so one does not need to synchronize this block of code: if-not-present-then-add.</span></p>
<ol start="2">
<li>Now let's review the concurrent collections of the <kbd>java.util.concurrent</kbd><span> package implementing the </span><kbd>Set</kbd> <span>i</span>nterface. There are three such implementations:<span> </span><kbd>ConcurrentHashMap.KeySetView</kbd><span>, <kbd>CopyOnWriteArraySet</kbd> , and <kbd>ConcurrentSkipListSet</kbd>.</span></li>
</ol>
<p style="padding-left: 60px"><span>The first one is just a view of the keys of <kbd>ConcurrentHashMap</kbd>. It is backed up by <kbd>ConcurrentHashMap</kbd> (can be retrieved by the <kbd>getMap()</kbd></span> method<span>). We will review the behavior of  <kbd>ConcurrentHashMap</kbd> later.</span></p>
<p style="padding-left: 60px">The second implementation of <kbd>Set</kbd> in the <kbd>java.util.concurrent</kbd> <span>package</span> is the <kbd>CopyOnWriteArraySet</kbd><span> class. Its behavior is similar to the <kbd>CopyOnWriteArrayList</kbd> class. In fact, it uses the <kbd>CopyOnWriteArrayList</kbd> class's implementation under the hood. The only difference is that it does not allow duplicate elements in the collection.</span></p>
<p style="padding-left: 60px"><span>The third (and the last) implementation of</span> <kbd>Set</kbd> <span>in the </span><kbd>java.util.concurrent</kbd><span> package is</span> <kbd>ConcurrentSkipListSet</kbd>; it implements a subinterface of <kbd>Set</kbd> called <kbd>NavigableSet</kbd>. According to the Javadoc of the <kbd>ConcurrentSkipListSet</kbd> class, insertion, removal, and access operations are safely executed concurrently by multiple threads<em>.</em> There are some limitations described in Javadoc too:</p>
<ul>
<li style="list-style-type: none">
<ul>
<li>It does not permit the use of <kbd>null</kbd> elements.</li>
<li>The size of the set is calculated dynamically by traversing the collection, so it may report inaccurate results if this collection is modified during the operation.</li>
<li>The operations <kbd>addAll()</kbd>, <kbd>removeIf()</kbd>, or <kbd>forEach()</kbd> are not guaranteed to be performed atomically. The <kbd>forEach()</kbd> operation, if concurrent with an <kbd>addAll()</kbd> operation for example, <em>might observe only some of the added elements</em> (as stated in the Javadoc).</li>
</ul>
</li>
</ul>
<p style="padding-left: 60px">The implementation of class  <kbd>ConcurrentSkipListSet</kbd> is based on the <kbd>ConcurrentSkipListMap</kbd> class, which we will discuss shortly. <span>To demonstrate the behavior of</span> the <kbd>ConcurrentSkipListSet</kbd> class, let's compare it with <span>the <kbd>java.util.TreeSet</kbd> class (non-concurrent implementation of </span><span><kbd>NavigableSet</kbd>). We start with removing an element:</span></p>
<pre><span>        void </span><span>demoNavigableSetRemove</span>(NavigableSet&lt;Integer&gt; set) {<br/>    <span> </span><span> </span><span> </span><span> </span><span> </span><span> </span>System.<span>out</span>.println(<span>"set: " </span>+ set)<span>;<br/></span><span>          try </span>{<br/>        <span> </span><span> </span><span> </span><span> </span><span>for </span>(<span>int </span>i : set) {<br/>            <span> </span><span> </span>System.<span>out</span>.println(i)<span>;<br/></span><span>              </span>System.<span>out</span>.println(<span>"Calling set.remove(2)..."</span>)<span>;<br/></span><span>              </span>set.remove(<span>2</span>)<span>;<br/></span><span>            </span>}<br/>  <span> </span><span> </span><span> </span><span> </span><span> </span><span> </span>  } <span>catch </span>(Exception ex) {<br/>        <span> </span><span> </span><span> </span><span> </span>System.<span>out</span>.println(ex.getClass().getName())<span>;<br/></span><span>          </span>}<br/>    <span> </span><span> </span><span> </span><span>   </span>System.<span>out</span>.println(<span>"set: " </span>+ set)<span>;<br/></span><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span>}</pre>
<p style="padding-left: 60px">Of course, this code is not very efficient; we've removed the same element many times without checking its presence. We have done this just for demo purposes. Besides, since Java 8, the same method <kbd>removeIf()</kbd> works for <kbd>Set</kbd> just fine. But we would like to bring up the behavior of the new <span>class <kbd>ConcurrentSkipListSet</kbd></span><span>,</span> so let's execute this code:</p>
<pre>        System.<span>out</span>.println(<span>"***** TreeSet set.remove(2):"</span>)<span>;<br/></span><span>        demoNavigableSetRemove</span>(<span>new </span>TreeSet&lt;&gt;(Arrays<br/>                                    .<span>asList</span>(<span>0</span><span>, </span><span>1</span><span>, </span><span>2</span><span>, </span><span>3</span>)))<span>;<br/></span><span><br/></span>        System.<span>out</span>.println()<span>;<br/></span>        System.<span>out</span>.println(<span>"*****"<br/>                           + " ConcurrentSkipListSet set.remove(2):"</span>)<span>;<br/></span><span>        demoNavigableSetRemove</span>(<span>new </span>ConcurrentSkipListSet&lt;&gt;(Arrays<br/>                                     .<span>asList</span>(<span>0</span><span>, </span><span>1</span><span>, </span><span>2</span><span>, </span><span>3</span>)))<span>;<br/></span></pre>
<p style="padding-left: 60px">The output will be as follows:</p>
<div class="CDPAlignCenter CDPAlign"><img height="200" width="425" src="assets/ce19ea45-db92-4768-807c-1da31f1a4669.png"/></div>
<p style="padding-left: 60px">As expected, the <span><kbd>ConcurrentSkipListSet</kbd></span><span> class handles the concurrency and even removes an element from the current set, which is helpful. It also removes an element via an iterator without an exception. Consider the following code:</span></p>
<pre><span>        void </span><span>demoNavigableSetIterRemove</span>(NavigableSet&lt;Integer&gt; set){<br/>          System.<span>out</span>.println(<span>"set: " </span>+ set)<span>;<br/></span><span>          try </span>{<br/>            Iterator iter = set.iterator()<span>;<br/></span><span>            while </span>(iter.hasNext()) {<br/>              Integer e = (Integer) iter.next()<span>;<br/></span><span>              </span>System.<span>out</span>.println(e)<span>;<br/></span><span>              if </span>(e == <span>2</span>) {<br/>                System.<span>out</span>.println(<span>"Calling iter.remove()..."</span>)<span>;<br/></span><span>                </span>iter.remove()<span>;<br/></span><span>              </span>}<br/>            }<br/>          } <span>catch </span>(Exception ex) {<br/>            System.<span>out</span>.println(ex.getClass().getName())<span>;<br/></span><span>          </span>}<br/>          System.<span>out</span>.println(<span>"set: " </span>+ set)<span>;<br/></span>        }</pre>
<p style="padding-left: 60px">Run this for <kbd>TreeSet</kbd> and  <span><kbd>ConcurrentSkipListSet</kbd></span>:<span> </span></p>
<pre>        System.<span>out</span>.println(<span>"***** TreeSet iter.remove():"</span>)<span>;<br/></span><span>        demoNavigableSetIterRemove</span>(<span>new </span>TreeSet&lt;&gt;(Arrays<br/>                                     .<span>asList</span>(<span>0</span><span>, </span><span>1</span><span>, </span><span>2</span><span>, </span><span>3</span>)))<span>;<br/></span><span><br/></span>        System.<span>out</span>.println()<span>;<br/></span>        System.<span>out</span>.println(<span>"*****"<br/>                           + " ConcurrentSkipListSet iter.remove():"</span>)<span>;<br/></span><span>        demoNavigableSetIterRemove</span>(<span>new </span>ConcurrentSkipListSet&lt;&gt;(<br/>                                  Arrays.<span>asList</span>(<span>0</span><span>, </span><span>1</span><span>, </span><span>2</span><span>, </span><span>3</span>)))<span>;</span></pre>
<p style="padding-left: 60px">We'll not get any exception:</p>
<div class="CDPAlignCenter CDPAlign"><img height="229" width="465" src="assets/1f1522f2-e50d-4343-9240-286bf57739fa.png"/></div>
<p style="padding-left: 60px">This is because, according to the Javadoc, the iterator of <kbd>ConcurrentSkipListSet</kbd> is weakly consistent, which means the following (according to Javadoc):</p>
<ul>
<li style="list-style-type: none">
<ul>
<li>They may proceed concurrently with other operations</li>
<li>They will never throw <kbd>ConcurrentModificationException</kbd></li>
<li>They are guaranteed to traverse elements as they existed upon construction exactly once, and may (but are not guaranteed to) reflect any modifications subsequent to construction (from Javadoc).</li>
</ul>
</li>
</ul>
<p style="padding-left: 60px">This not guaranteed part is somewhat disappointing, but it is better than getting an exception, like with <kbd>CopyOnWriteArrayList</kbd><span>.</span></p>
<p style="padding-left: 60px">Adding to a <kbd>Set</kbd> class is not as problematic as to a <kbd>List</kbd> class because <kbd>Set</kbd> does not allow duplicates and handles the necessary checks internally:</p>
<pre><span>        void </span><span>demoNavigableSetAdd</span>(NavigableSet&lt;Integer&gt; set) {<br/>          System.<span>out</span>.println(<span>"set: " </span>+ set)<span>;<br/></span><span>          try </span>{<br/>            <span>int </span>m = set.stream().max(Comparator.<span>naturalOrder</span>())<br/>                                .get() + <span>1</span><span>;<br/></span><span>            for </span>(<span>int </span>i : set) {<br/>              System.<span>out</span>.println(i)<span>;<br/></span><span>              </span>System.<span>out</span>.println(<span>"Calling set.add(" </span>+ m + <span>")"</span>)<span>;<br/></span><span>              </span>set.add(m++)<span>;<br/></span><span>              if </span>(m &gt; <span>6</span>) {<br/>                <span>break;<br/></span><span>              </span>}<br/>            }<br/>          } <span>catch </span>(Exception ex) {<br/>            System.<span>out</span>.println(ex.getClass().getName())<span>;<br/></span><span>          </span>}<br/>          System.<span>out</span>.println(<span>"set: " </span>+ set)<span>;<br/></span>        }</pre>
<p style="padding-left: 60px">Consider the following code:</p>
<pre>        System.<span>out</span>.println(<span>"***** TreeSet set.add():"</span>)<span>;<br/></span><span>        demoNavigableSetAdd</span>(<span>new </span>TreeSet&lt;&gt;(Arrays<br/>                                     .<span>asList</span>(<span>0</span><span>, </span><span>1</span><span>, </span><span>2</span><span>, </span><span>3</span>)))<span>;<br/></span><span><br/></span>        System.<span>out</span>.println()<span>;<br/></span>        System.<span>out</span>.println(<span>"*****" <br/>                            + " ConcurrentSkipListSet set.add():"</span>)<span>;<br/></span><span>        demoNavigableSetAdd</span>(<span>new </span>ConcurrentSkipListSet&lt;&gt;(Arrays<br/>                                        .<span>asList</span>(<span>0</span><span>,</span><span>1</span><span>,</span><span>2</span><span>,</span><span>3</span>)))<span>;<br/></span></pre>
<p style="padding-left: 60px">If we run this, we'll get the following result:</p>
<div class="CDPAlignCenter CDPAlign"><img height="216" width="460" src="assets/f66129c3-7a84-4265-ac8b-72b758f97cee.png"/></div>
<p style="padding-left: 60px">As before, we observe that the concurrent <kbd>Set</kbd> version handles concurrency better.</p>
<ol start="3">
<li>Now we turn to the <kbd>Map</kbd> interface that has two implementations in the java.util.concurrent package: <kbd>ConcurrentHashMap</kbd> and <kbd>ConcurrentSkipListMap</kbd><span>.</span></li>
</ol>
<p style="padding-left: 60px"><span>The</span> <kbd>ConcurrentHashMap</kbd> <span>class </span><em>supports full concurrency of retrievals and high concurrency for updates</em> <span>(from Javadoc).</span> It is a thread-safe version of <kbd>java.util.HashMap</kbd> and is analogous to <kbd>java.util.Hashtable</kbd> in this respect. In fact, the <kbd>ConcurrentHashMap</kbd> <span>class </span>meets the requirements of the same functional specification as <kbd><span>java.util.H</span>ashtable</kbd>, although its implementation is <em>somewhat different in synchronization details </em><span>(from Javadoc)</span>. </p>
<p style="padding-left: 60px">Unlike <kbd><span>java.util.H</span>ashMap</kbd> and <kbd><span>java.util.H</span>ashtable</kbd>, <kbd>ConcurrentHashMap</kbd> supports, according its JavaDoc, <em>a set of sequential and parallel bulk operations that, unlike most Stream methods, are designed to be safely, and often sensibly, applied even with maps that are being concurrently updated by other threads</em><span>:</span></p>
<ul>
<li style="list-style-type: none">
<ul>
<li><kbd>forEach()</kbd>: This performs a given action on each element</li>
<li><kbd>search()</kbd>: This returns the first available non-null result of applying a given function to each element</li>
<li><kbd>reduce()</kbd>: This accumulates each element (there are five overloaded versions)</li>
</ul>
</li>
</ul>
<p style="padding-left: 60px">These bulk operations accept a <kbd>parallelismThreshold</kbd> argument that allows deferring parallelization until the map size reaches the specified threshold. Naturally, when the threshold is set to <kbd>Long.MAX_VALUE</kbd>, there will be no parallelism whatsoever.</p>
<p style="padding-left: 60px">There are many other methods in the class API, so refer to its Javadoc for an overview.</p>
<p style="padding-left: 60px">Unlike<span> </span><kbd><span>java.util.H</span>ashMap</kbd><span> (and similar to </span><kbd><span>java.util.H</span>ashtable</kbd><span>),</span> neither <kbd>ConcurrentHashMap</kbd> nor <kbd>ConcurrentSkipListMap</kbd> allow null to be used as a key or value.</p>
<p style="padding-left: 60px"><span>The second implementation of <kbd>Map</kbd>--the <kbd>ConcurrentSkipListSet</kbd> class--is based, as we mentioned before, on the <kbd>ConcurrentSkipListMap</kbd> class, so all the limitations of the <kbd>ConcurrentSkipListSet</kbd> class we just described apply to the <kbd>ConcurrentSkipListMap</kbd> class too. The <kbd>ConcurrentSkipListSet</kbd> class </span>is practically a thread-safe version of <kbd>java.util.TreeMap</kbd>. <kbd>SkipList</kbd> is a sorted data structure that allows fast search concurrently. All the elements are sorted based on their natural sorting order of keys. The <kbd>NavigableSet</kbd> functionality we demonstrated for the <kbd>ConcurrentSkipListSet</kbd> class is present in the <kbd>ConcurrentSkipListMap</kbd> class too. For <span>many other methods in the class API, refer to its Javadoc.</span></p>
<p style="padding-left: 60px"><span>Now let's demonstrate the difference in the behavior in response to concurrency between the <kbd>java.util.HashMap</kbd>, <kbd>ConcurrentHashMap</kbd>, and <kbd>ConcurrentSkipListMap</kbd> classes. First, we will write the method that generates a test <kbd>Map</kbd> object:</span></p>
<pre><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span>Map <span>createhMap</span>() {<br/>    <span> </span><span> </span><span> </span><span> </span><span> </span><span> </span>Map&lt;Integer<span>, </span>String&gt; map = <span>new </span>HashMap&lt;&gt;()<span>;<br/></span><span>          </span>map.put(<span>0</span><span>, </span><span>"Zero"</span>)<span>;<br/></span><span>          </span>map.put(<span>1</span><span>, </span><span>"One"</span>)<span>;<br/></span><span>          </span>map.put(<span>2</span><span>, </span><span>"Two"</span>)<span>;<br/></span><span>          </span>map.put(<span>3</span><span>, </span><span>"Three"</span>)<span>;<br/></span><span>          return </span>map<span>;<br/></span><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span>}</pre>
<p style="padding-left: 60px">Here is the code that adds an element to a <kbd>Map</kbd> object concurrently:</p>
<pre><span>        void </span><span>demoMapPut</span>(Map&lt;Integer<span>, </span>String&gt; map) {<br/>          System.<span>out</span>.println(<span>"map: " </span>+ map)<span>;<br/></span><span>          try </span>{<br/>            Set&lt;Integer&gt; keys = map.keySet()<span>;<br/></span><span>            for </span>(<span>int </span>i : keys) {<br/>              System.<span>out</span>.println(i)<span>;<br/></span><span>              </span>System.<span>out</span>.println(<span>"Calling map.put(8, Eight)..."</span>)<span>;<br/></span><span>              </span>map.put(<span>8</span><span>, </span><span>"Eight"</span>)<span>;<br/></span><span><br/></span><span>              </span>System.<span>out</span>.println(<span>"map: " </span>+ map)<span>;<br/></span><span>              </span>System.<span>out</span>.println(<span>"Calling map.put(8, Eight)..."</span>)<span>;<br/></span><span>              </span>map.put(<span>8</span><span>, </span><span>"Eight"</span>)<span>;<br/></span><span><br/></span><span>              </span>System.<span>out</span>.println(<span>"map: " </span>+ map)<span>;<br/></span><span>              </span>System.<span>out</span>.println(<span>"Calling" <br/>                                 + " map.putIfAbsent(9, Nine)..."</span>)<span>;<br/></span><span>              </span>map.putIfAbsent(<span>9</span><span>, </span><span>"Nine"</span>)<span>;<br/></span><span><br/></span><span>              </span>System.<span>out</span>.println(<span>"map: " </span>+ map)<span>;<br/></span><span>              </span>System.<span>out</span>.println(<span>"Calling" <br/>                                 + " map.putIfAbsent(9, Nine)..."</span>)<span>;<br/></span><span>              </span>map.putIfAbsent(<span>9</span><span>, </span><span>"Nine"</span>)<span>;<br/></span><span><br/></span><span>              </span>System.<span>out</span>.println(<span>"keys.size(): " </span>+ keys.size())<span>;<br/></span><span>              </span>System.<span>out</span>.println(<span>"map: " </span>+ map)<span>;<br/></span><span>            </span>}<br/>          } <span>catch </span>(Exception ex) {<br/>            System.<span>out</span>.println(ex.getClass().getName())<span>;<br/></span><span>          </span>}<br/>        }</pre>
<p style="padding-left: 60px">Run this for all three implementations of <kbd>Map</kbd>:</p>
<pre>        System.<span>out</span>.println(<span>"***** HashMap map.put():"</span>)<span>;<br/></span><span>        demoMapPut</span>(<span>createhMap</span>())<span>;<br/></span><span><br/></span>        System.<span>out</span>.println()<span>;<br/></span>        System.<span>out</span>.println(<span>"***** ConcurrentHashMap map.put():"</span>)<span>;<br/></span><span>        demoMapPut</span>(<span>new </span>ConcurrentHashMap(<span>createhMap</span>()))<span>;<br/></span><span><br/></span>        System.<span>out</span>.println()<span>;<br/></span>        System.<span>out</span>.println(<span>"*****"<br/>                          + " ConcurrentSkipListMap map.put():"</span>)<span>;<br/></span><span>        demoMapPut</span>(<span>new </span>ConcurrentSkipListMap(<span>createhMap</span>()))<span>;<br/></span></pre>
<p style="padding-left: 60px">If we do this, we get an output for <kbd>HashMap</kbd> for the first key only:</p>
<div class="CDPAlignCenter CDPAlign"><img height="172" width="453" src="assets/d1868213-4bf8-4a75-bf12-b337f0f42c05.png"/></div>
<p style="padding-left: 60px">We also get an output for <kbd>ConcurrentHashMap</kbd><span> and </span><kbd>ConcurrentSkipListMap</kbd><span> for all the keys, including the newly added ones. Here is the last section of the <kbd>ConcurrentHashMap</kbd> output:</span></p>
<div class="CDPAlignCenter CDPAlign"><img height="145" width="411" src="assets/3add6164-1a06-46e4-8a2c-f158894894bc.png"/></div>
<p style="padding-left: 60px">As mentioned already, the appearance of <kbd>ConcurrentModificationException</kbd> is not guaranteed. Now we see that the moment it is thrown (if at all) is the moment when the code discovers that the modification has taken place. In the case of our example, it happened on the next iteration. Another point worth noticing is that the current set of keys changes even as we sort of isolate the set in a separate variable:</p>
<pre>      Set&lt;Integer&gt; keys = map.keySet()<span>;</span></pre>
<p style="padding-left: 60px">This reminds us not to dismiss the changes propagated through the objects via their references.</p>
<p style="padding-left: 60px">To save the book space and your time, we will not show the code for concurrent removal and just summarize the results. As expected, <kbd>HashMap</kbd> throws exception <kbd><span>ConcurrentModificationException</span></kbd> when an element is removed in any of the following ways. Here's the first way:</p>
<pre>        String result = map.remove(<span>2</span>)<span>;<br/></span></pre>
<p style="padding-left: 60px">Here is the second way:</p>
<pre>        boolean success = map.remove(2, "Two");</pre>
<p style="padding-left: 60px">It allows concurrent removal via <kbd>Iterator</kbd> in two ways. Here's the first way:</p>
<pre>         iter.remove();</pre>
<p style="padding-left: 60px">And here is the second way:</p>
<pre>         boolean result = map.keySet().remove(2);</pre>
<p style="padding-left: 60px">Here's the third way:</p>
<pre>        boolean result = map.keySet().removeIf(e -&gt; e == 2);</pre>
<p style="padding-left: 60px">By contrast, the two concurrent <kbd>Map</kbd> implementations allow any of the above ways of removal concurrently.</p>
<p style="padding-left: 60px">Similar behavior is also exhibited by all the concurrent implementations of the <kbd>Queue</kbd> interface: <kbd>LinkedTransferQueue</kbd><span>, <kbd>LinkedBlockingQueue</kbd></span><span>, <kbd>LinkedBlockingDequeue</kbd></span>, <kbd>ArrayBlockingQueue</kbd>, <kbd>PriorityBlockingQueue</kbd>, <kbd>DelayQueue</kbd>, <kbd>SynchronousQueue</kbd>, <kbd>ConcurrentLinkedQueue</kbd>, and <kbd>ConcurrentLinkedDequeue</kbd>, all in the <kbd>java.util.concurrent</kbd> package. But to demonstrate all of them would require a separate volume, so we leave it up to you to browse the Javadoc and provide an example of <kbd>ArrayBlockingQueue</kbd> only. The queue will be represented by the <kbd>QueueElement</kbd> class:</p>
<pre><span>         class </span>QueueElement {<br/>           <span>private </span>String <span>value</span><span>;<br/></span><span>           public </span><span>QueueElement</span>(String value){<br/>             <span>this</span>.<span>value </span>= value<span>;<br/></span><span>           </span>}<br/>           <span>public </span>String <span>getValue</span>() {<br/>             <span>return </span><span>value</span><span>;<br/></span><span>           </span>}<br/>         }</pre>
<p style="padding-left: 60px">The queue producer will be as follows:</p>
<pre><span>        class </span>QueueProducer <span>implements </span>Runnable {<br/>          <span>int </span><span>intervalMs</span><span>, </span><span>consumersCount</span><span>;<br/></span><span>          private </span>BlockingQueue&lt;QueueElement&gt; <span>queue</span><span>;</span><span><br/></span><span>          public </span><span>QueueProducer</span>(<span>int </span>intervalMs<span>, int </span>consumersCount<span>, <br/></span>                               BlockingQueue&lt;QueueElement&gt; queue) {<br/>            <span>this</span>.<span>consumersCount </span>= consumersCount<span>;<br/></span><span>            this</span>.<span>intervalMs </span>= intervalMs<span>;<br/></span><span>            this</span>.<span>queue </span>= queue<span>;<br/></span><span>          </span>}<br/>          <span>public void </span><span>run</span>() {<br/>            List&lt;String&gt; list = <br/>               List.<span>of</span>(<span>"One"</span><span>,</span><span>"Two"</span><span>,"</span><span>Three"</span><span>,</span><span>"Four"</span><span>,</span><span>"Five"</span>)<span>;<br/></span><span>            try </span>{<br/>              <span>for </span>(String e : list) {<br/>                Thread.<span>sleep</span>(intervalMs)<span>;<br/></span><span>                </span><span>queue</span>.put(<span>new </span>QueueElement(e))<span>;<br/></span><span>                </span>System.<span>out</span>.println(e + <span>" produced" </span>)<span>;<br/></span><span>              </span>}<br/>              <span>for</span>(<span>int </span>i = <span>0</span><span>; </span>i &lt; <span>consumersCount</span><span>; </span>i++){<br/>                <span>queue</span>.put(<span>new </span>QueueElement(<span>"Stop"</span>))<span>;<br/></span><span>              </span>}<br/>            } <span>catch </span>(InterruptedException e) {<br/>              e.printStackTrace()<span>;<br/></span><span>            </span>}<br/>           }<br/>         }</pre>
<p style="padding-left: 60px">The following will be the queue consumer:</p>
<pre><span>        class </span>QueueConsumer <span>implements </span>Runnable{<br/>          <span>private </span>String <span>name</span><span>;<br/></span><span>          private int </span><span>intervalMs</span><span>;<br/></span><span>          private </span>BlockingQueue&lt;QueueElement&gt; <span>queue</span><span>;</span><span><br/></span><span>          public </span><span>QueueConsumer</span>(String name<span>, int </span>intervalMs<span>, <br/></span>                               BlockingQueue&lt;QueueElement&gt; queue){<br/>             <span>this</span>.<span>intervalMs </span>= intervalMs<span>;<br/></span><span>             this</span>.<span>queue </span>= queue<span>;<br/></span><span>             this</span>.<span>name </span>= name<span>;<br/></span><span>          </span>}<br/>          <span>public void </span><span>run</span>() {<br/>            <span>try </span>{<br/>              <span>while</span>(<span>true</span>){<br/>                String value = <span>queue</span>.take().getValue()<span>;<br/></span><span>                if</span>(<span>"Stop"</span>.equals(value)){<br/>                  <span>break;<br/></span><span>                </span>}<br/>                System.<span>out</span>.println(value + <span>" consumed by " </span>+ <span>name</span>)<span>;<br/></span><span>                </span>Thread.<span>sleep</span>(<span>intervalMs</span>)<span>;<br/></span><span>              </span>}<br/>            } <span>catch</span>(InterruptedException e) {<br/>              e.printStackTrace()<span>;<br/></span><span>            </span>}<br/>          }<br/>        }</pre>
<p style="padding-left: 60px">Run the following code:</p>
<pre>        BlockingQueue&lt;QueueElement&gt; queue = <br/><span>                      new </span>ArrayBlockingQueue&lt;&gt;(<span>5</span>)<span>;<br/></span>        QueueProducer producer = <span>new </span>QueueProducer(queue)<span>;<br/></span>        QueueConsumer consumer = <span>new </span>QueueConsumer(queue)<span>;<br/></span><span>        new </span>Thread(producer).start()<span>;<br/></span><span>        new </span>Thread(consumer).start()<span>;<br/></span></pre>
<p style="padding-left: 60px">Its results may look like this:</p>
<div class="CDPAlignCenter CDPAlign"><img height="122" width="396" src="assets/774a9db0-6d17-4aa2-b1fd-174c3f946db3.png"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>Before we select which collections to use, read the Javadoc and see whether the limitations of the collection are acceptable for your application.</p>
<p>For example, as per the Javadoc, the <span><kbd>CopyOnWriteArrayList</kbd> class <em>is ordinarily too costly, but may be more efficient than alternatives when traversal operations vastly outnumber mutations, and is useful when you cannot or don't want to synchronize traversals, yet need to preclude interference among concurrent threads.</em> Use it when you do not need to add new elements at different positions and do not require sorting. Otherwise, use <kbd>ConcurrentSkipListSet</kbd>.</span></p>
<p><span>The <kbd>ConcurrentSkipListSet</kbd></span><span> and <kbd>ConcurrentSkipListMap</kbd> classes, as per the Javadoc, <em>provide expected average log(n) time cost for the contains, add, and remove operations and their variants.</em> <em>Ascending ordered views and their iterators are faster than descending ones.</em> Use them when you need to iterate quickly through the elements in a certain order and prefer sorting by default.</span></p>
<p><span>U</span>se <kbd>ConcurrentHashMap</kbd> when the concurrency requirements are very demanding and you need to allow locking on the write operation but do not need to lock the element.</p>
<p><span><kbd>ConcurrentLinkedQueque</kbd> and </span><kbd><span>ConcurrentLinkedDeque</span></kbd> are an appropriate choice when many threads share access to a common collection. <kbd>ConcurrentLinkedQueque</kbd> employs an efficient non-blocking algorithm.</p>
<p><kbd>PriorityBlockingQueue</kbd> is a better choice when natural order is acceptable and you need fast adding of elements to the tail and fast removing of elements from the head of the queue. Blocking means that the queue waits to become non-empty when retrieving an element and waits for space to become available in the queue when storing an element. </p>
<p><kbd>ArrayBlockingQueue</kbd>, <kbd>LinkedBlockingQueue</kbd>, and <kbd>LinkedBlockingDeque</kbd> have a fixed size (bounded). The other queues are unbounded. </p>
<p>Use these and similar characteristics and recommendations as the guidelines but execute comprehensive testing and performance measuring before and after implementing your functionality.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">See also</h1>
                </header>
            
            <article>
                
<p>Refer to the following recipes in this chapter:</p>
<ul>
<li>Using the executor service to execute async tasks</li>
<li>Using fork/join to implement divide-and-conquer</li>
<li>Using flow to implement the publish-subscribe pattern</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Using the executor service to execute async tasks</h1>
                </header>
            
            <article>
                
<p>In this recipe, you will learn how to use <kbd>ExecutorService</kbd> to implement controllable thread execution.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p>In an earlier recipe, we demonstrated how to create and execute threads using the <kbd>Thread</kbd> class directly. It is an acceptable mechanism for a small number of threads that run and produce results predictably quickly. For big-scale applications with longer running threads with complex logic (which might keep them alive for an unpredictably long time) and/or a number of threads growing unpredictably too, a simple create-and-run-until-exit approach might result in an <kbd>OutOfMemory</kbd> error or require a complex customized system of threads' status maintenance and management. For such cases, <kbd>ExecutorService</kbd> and related classes of the <kbd>java.util.concurrent</kbd> package provide an out-of-the-box solution that relieves a programmer of the need to write and maintain a lot of infrastructural code.  </p>
<p>At the foundation of the Executor Framework lies an <kbd>Executor</kbd> interface that has only one <kbd>void execute(Runnable command)</kbd> method that executes the given command at some time in the future.</p>
<p>Its subinterface <kbd>ExecutorService</kbd> adds methods that allow you to manage the executor:  </p>
<ul>
<li>The <kbd>invokeAny()</kbd>, <kbd>invokeAll()</kbd>, and <kbd>awaitTermination()</kbd> methods and <kbd>submit()</kbd> allow you to define how the threads will be executed and if they are expected to return some values or not</li>
<li>The <kbd>shutdown()</kbd> and <kbd>shutdownNow()</kbd> methods allow you to shut down the executor</li>
<li>The <kbd>isShutdown()</kbd> and <kbd>isTerminated()</kbd> methods provide the status of the executor</li>
</ul>
<p>The objects of <kbd>ExecutorService</kbd> can be created with the static factory methods of the <kbd>java.util.concurrent.Executors</kbd> class: </p>
<ul>
<li><kbd>newSingleThreadExecutor()</kbd> - This creates an <kbd>Executor</kbd> method that uses a single worker thread operating off an unbounded queue. It has an overloaded version with <kbd>ThreadFactory</kbd> as a parameter.</li>
<li><kbd>newCachedThreadPool()</kbd> - This creates a thread pool that creates new threads as needed, but reuses previously constructed threads when they are available.<span> It has an overloaded version with</span> <kbd>ThreadFactory</kbd> <span>as a parameter.</span></li>
<li><kbd>newFixedThreadPool(int nThreads)</kbd> - This creates a thread pool that reuses a fixed number of threads operating off a shared unbounded queue.<span> It has an overloaded version with</span> <kbd>ThreadFactory</kbd> <span>as a parameter</span>.</li>
</ul>
<p>The <kbd>ThreadFactory</kbd> implementation allows you to override the process of creating new threads, enabling applications to use special thread subclasses, priorities, and so on. A demonstration of its usage is outside the scope of this book.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<ol>
<li>One important aspect of the behavior of the <kbd>Executor</kbd> interface you need to remember is that once created, it keeps running (waiting for new tasks to execute) until the Java process is stopped. So, if you would like to free memory, the<span> </span><kbd>Executor</kbd> interface has to be stopped explicitly. If not shut down, forgotten executors will create a memory leak. Here is one possible way to make sure no executor is left behind:</li>
</ol>
<pre>        int shutdownDelaySec = 1;<br/>        ExecutorService execService = <br/>                       Executors.<span>newSingleThreadExecutor</span>()<span>;<br/></span>        Runnable runnable =  () -&gt; System.<span>out</span>.println(<span>"Worker One did<br/>                                                       the job."</span>);<span><br/></span>        execService.execute(runnable)<span>;<br/></span>        runnable =   () -&gt; System.<span>out</span>.println(<span>"Worker Two did the <br/>                                               job."</span>)<span>;<br/></span>        Future future = execService.submit(runnable)<span>;<br/></span><span>        try </span>{<br/>          execService.shutdown()<span>;<br/></span><span>          </span>execService.awaitTermination(shutdownDelaySec<span>, <br/>                                       </span>TimeUnit.<span>SECONDS</span>)<span>;<br/></span>        } <span>catch </span>(Exception ex) {<br/>          System.<span>out</span>.println(<span>"Caught around" <br/>                  + " execService.awaitTermination(): " <br/></span>                  + ex.getClass().getName())<span>;<br/></span>        } <span>finally </span>{<br/>          <span>if </span>(!execService.isTerminated()) {<br/>            <span>if </span>(future != <span>null </span>&amp;&amp; !future.isDone() <br/>                               &amp;&amp; !future.isCancelled()){<br/>              System.<span>out</span>.println(<span>"Cancelling the task..."</span>)<span>;<br/></span><span>              </span>future.cancel(<span>true</span>)<span>;<br/></span><span>            </span>}<br/>          }<br/>          List&lt;Runnable&gt; l = execService.shutdownNow()<span>;<br/></span><span>          </span>System.<span>out</span>.println(l.size() <br/>                 + <span>" tasks were waiting to be executed." <br/>                 + " Service stopped."</span>)<span>;<br/></span>        }</pre>
<p style="padding-left: 60px">You can pass a worker (an implementation of either the <kbd>Runnable</kbd><span> or</span><span> </span><kbd>Callable</kbd><span> functional interface)</span> for execution to <kbd>ExecutorService</kbd> in a variety of ways, which we will see shortly. In this example, we executed two threads: one using the <kbd>execute()</kbd> method and another using the <kbd>submit()</kbd> method. Both methods accept <kbd>Runnable</kbd> or <kbd>Callable</kbd>, but we used only <kbd>Runnable</kbd> in this example. The <span><kbd>submit()</kbd> method </span>returns <kbd>Future</kbd>, which represents the result of an asynchronous computation.</p>
<p style="padding-left: 60px"><span>The </span><kbd>shutdown()</kbd> method initiates an orderly shutdown of the previously submitted tasks and prevents any new task from being accepted. This method does not wait for the task to complete the execution. The <kbd>awaitTermination()</kbd> method does that. But after <kbd>shutdownDelaySec</kbd>, it stops blocking and the code flow gets into <kbd>finally</kbd> block, where the <kbd>isTerminated()</kbd> method returns <kbd>true</kbd> if all the tasks are completed following the shutdown. In this example, we have two tasks executed in two different statements, but note that other methods of <kbd>ExecutorService</kbd> accept a collection of tasks.</p>
<p style="padding-left: 60px">In such a case, when the service is shutting down, we iterate over the collection of <kbd>Future</kbd> objects. We call each task and cancel it if it is not completed yet, possibly doing something else that had to be done before canceling the task. How much time to wait (value of <kbd>shutdownDelaySec</kbd>) has to be tested for each application and the possible running tasks.</p>
<p style="padding-left: 60px">Finally, the <kbd>shutdownNow()</kbd> method says this: <em>attempts to stop all actively executing tasks, halts the processing of waiting tasks, and returns a list of the tasks that were awaiting execution</em> (according to the Javadoc).</p>
<ol start="2">
<li>Now we can collect and assess the results. In a real application, we typically do not want to shut down a service often. We just check the status of the tasks and collect results of those that return true from the <kbd>isDone()</kbd> method. In the above code example, we just show how to make sure that when we do stop the service, we do it in a controlled manner, without leaving behind any runaway process. If <span>we run that code example, we will get the following:</span></li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img height="57" width="461" src="assets/c6dd14bc-8a2a-4216-933b-efdb49cacd86.png"/></div>
<ol start="3">
<li>Generalize the preceding code and create a method that shuts down a service and the task that has returned <kbd>Future</kbd>:</li>
</ol>
<pre><span>        void </span><span>shutdownAndCancelTask</span>(ExecutorService execService<span>, <br/>                  int </span>shutdownDelaySec<span>, </span>String name<span>, </span>Future future) {<br/>          <span>try </span>{<br/>            execService.shutdown()<span>;<br/></span><span>            </span>System.<span>out</span>.println(<span>"Waiting for " </span>+ shutdownDelaySec <br/>                         + <span>" sec before shutting down service..."</span>)<span>;<br/></span><span>            </span>execService.awaitTermination(shutdownDelaySec<span>,<br/></span>                                         TimeUnit.<span>SECONDS</span>)<span>;<br/></span><span>          </span>} <span>catch </span>(Exception ex) {<br/>    <span> </span><span> </span><span> </span><span> </span><span>   </span> System.<span>out</span>.println(<span>"Caught around" <br/>                        + " execService.awaitTermination():" <br/></span>                        + ex.getClass().getName())<span>;<br/></span><span>         </span>} <span>finally </span>{<br/>  <span> </span><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span>  <span>if </span>(!execService.isTerminated()) {<br/>      <span> </span><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span>System.<span>out</span>.println(<span>"Terminating remaining tasks..."</span>)<span>;<br/></span><span>             if </span>(future != <span>null </span>&amp;&amp; !future.isDone() <br/>                                &amp;&amp; !future.isCancelled()) {<br/>         <span> </span><span> </span><span> </span><span> </span><span> </span><span> </span>System.<span>out</span>.println(<span>"Cancelling task " <br/></span>                                  + name + <span>"..."</span>)<span>;<br/></span><span>               </span>future.cancel(<span>true</span>)<span>;<br/></span><span>             </span>}<br/>    <span> </span><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span>}<br/>    <span> </span><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span>System.<span>out</span>.println(<span>"Calling execService.shutdownNow(" <br/></span>                              + name + <span>")..."</span>)<span>;<br/></span><span>           </span>List&lt;Runnable&gt; l = execService.shutdownNow()<span>;<br/></span><span>           </span>System.<span>out</span>.println(l.size() + <span>" tasks were waiting" <br/>                         + " to be executed. Service stopped."</span>)<span>;<br/></span><span>         </span>}<br/><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span>}</pre>
<ol start="4">
<li>Enhance the example by making the <kbd>Runnable</kbd> (using lambda expression) sleep for some time (simulating useful work to be done):</li>
</ol>
<pre><span>        void </span><span>executeAndSubmit</span>(ExecutorService execService<span>, <br/>                    int </span>shutdownDelaySec<span>, int </span>threadSleepsSec) {<br/><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span>  System.<span>out</span>.println(<span>"shutdownDelaySec = " <br/></span>         <span> </span><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span>+ shutdownDelaySec + <span>", threadSleepsSec = " <br/></span>                            + threadSleepsSec)<span>;<br/></span><span>          </span>Runnable runnable = () -&gt; {<br/>      <span> </span><span> </span><span> </span><span> </span><span> </span><span> </span><span>try </span>{<br/>          <span> </span><span> </span><span> </span><span> </span>Thread.<span>sleep</span>(<span>threadSleepsSec </span>* <span>1000</span>)<span>;<br/></span><span>              </span>System.<span>out</span>.println(<span>"Worker One did the job."</span>)<span>;<br/></span><span>            </span>} <span>catch </span>(Exception ex) {<br/>         <span> </span><span> </span><span> </span><span> </span><span> </span>System.<span>out</span>.println(<span>"Caught around One Thread.sleep(): " <br/></span>                               <span> </span> + ex.getClass().getName())<span>;<br/></span><span>            </span>}<br/>  <span> </span><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span>}<span>;<br/></span><span>          </span>execService.execute(runnable)<span>;<br/></span><span>          </span>runnable = () -&gt; {<br/>   <span> </span><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span> <span>try </span>{<br/>      <span> </span><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span>Thread.<span>sleep</span>(<span>threadSleepsSec </span>* <span>1000</span>)<span>;<br/></span><span>              </span>System.<span>out</span>.println(<span>"Worker Two did the job."</span>)<span>;<br/></span><span>            </span>} <span>catch </span>(Exception ex) {<br/>      <span> </span><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span>System.<span>out</span>.println(<span>"Caught around Two Thread.sleep(): " <br/></span>                              <span> </span>  + ex.getClass().getName())<span>;<br/></span><span>            </span>}<br/> <span> </span><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span> <span> </span>}<span>;<br/></span><span>          </span>Future future = execService.submit(runnable)<span>;<br/></span><span>          </span><span>shutdownAndCancelTask</span>(execService<span>, </span>shutdownDelaySec<span>, <br/></span><span>                                "Two"</span><span>, </span>future)<span>;<br/></span><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span>}</pre>
<p style="padding-left: 60px"><span>Notice the two parameters: <kbd>shutdownDelaySec</kbd> (that defines how long the service will wait without allowing new tasks to be submitted before moving on and shutting itself down, eventually) and <kbd>threadSleepSec</kbd> (that defines how long the worker is sleeping, indicating that the simulating process is doing its job).</span></p>
<ol start="5">
<li>Run the new code for different implementations of <kbd>ExecutorService</kbd> and values of <kbd>shutdownDelaySec</kbd> and <kbd>threadSleepSec</kbd>:</li>
</ol>
<pre>        System.<span>out</span>.println(<span>"Executors.newSingleThreadExecutor():"</span>)<span>;<br/></span>        ExecutorService execService = <br/>                       Executors.<span>newSingleThreadExecutor</span>()<span>;</span><span><br/></span><span>        executeAndSubmit</span>(execService<span>, </span><span>3</span><span>, </span><span>1</span>)<span>;<br/></span><span><br/></span>        System.<span>out</span>.println()<span>;<br/></span>        System.<span>out</span>.println(<span>"Executors.newCachedThreadPool():"</span>)<span>;<br/></span>        execService = Executors.<span>newCachedThreadPool</span>()<span>;<br/></span><span>        executeAndSubmit</span>(execService<span>, </span><span>3</span><span>, </span><span>1</span>)<span>;<br/></span><span><br/></span>        System.<span>out</span>.println()<span>;<br/></span><span>        int </span>poolSize = <span>3</span><span>;<br/></span>        System.<span>out</span>.println(<span>"Executors.newFixedThreadPool(" <br/></span>                                            + poolSize + <span>"):"</span>)<span>;<br/></span>        execService = Executors.<span>newFixedThreadPool</span>(poolSize)<span>;<br/></span><span>        executeAndSubmit</span>(execService<span>, </span><span>3</span><span>, </span><span>1</span>)<span>;</span><span><br/></span></pre>
<p style="padding-left: 60px">This is how the output may look like (it might be slightly different on your computer, depending on the exact timing of the events controlled by the operating system):</p>
<div class="CDPAlignCenter CDPAlign"><img height="103" width="468" src="assets/72c92273-0613-457e-ac41-ee268941a01e.png"/></div>
<ol start="6">
<li>Analyze the results. In the first example, we find no surprise because of the following line:</li>
</ol>
<pre>        execService.awaitTermination(shutdownDelaySec<span>, <br/></span>                                     TimeUnit.<span>SECONDS</span>)<span>;<br/></span></pre>
<p style="padding-left: 60px">It is blocking for three seconds, whereas each worker works for one second only. So it is enough time for each worker to complete its work even for a single-thread executor.</p>
<p style="padding-left: 60px">Let's make the service wait for one second only:</p>
<div class="CDPAlignCenter CDPAlign"><img height="104" width="420" src="assets/fe87a199-b14e-47ba-9aeb-912d3429af43.png"/> </div>
<p style="padding-left: 60px">When you do this, you will notice that none of the tasks will be completed. In this case, worker <kbd>One</kbd> was interrupted (see the last line of the output), while task <kbd>Two</kbd> was canceled.</p>
<p style="padding-left: 60px">Let's make the service wait for three seconds: </p>
<div class="CDPAlignCenter CDPAlign"> <img height="115" width="427" src="assets/a1106c9b-f169-4c22-858b-ec93a86baad1.png"/></div>
<p style="padding-left: 60px">Now we see that worker <kbd>One</kbd> was able to complete its task, while worker <kbd>Two</kbd> was interrupted.</p>
<p style="padding-left: 60px">The <kbd>ExecutorService</kbd> interface produced by <kbd>newCachedThreadPool()</kbd> or <kbd>newFixedThreadPool()</kbd> performs similarly on a one-core computer. The only significant difference is that if the <kbd>shutdownDelaySec</kbd> value is equal to the <kbd>threadSleepSec</kbd> value, then they both allow you to complete the threads:</p>
<div class="CDPAlignCenter CDPAlign"><img height="93" width="416" src="assets/4d7286f3-51a5-494d-a668-8e30fc334dac.png"/></div>
<p style="padding-left: 60px">This was the result of using <kbd>newCachedThreadPool()</kbd><span>. The output of the example using </span><kbd>newFixedThreadPool()</kbd><span> looks exactly the same on a one-core computer.</span></p>
<ol start="7">
<li><span>Use the <kbd>Future</kbd></span> object as a returned value when you need more control over the task, not just submit one and wait. There is another method called <kbd>submit()</kbd> in the <kbd>ExecutorService</kbd> interface that allows you to not only return a <kbd>Future</kbd> object, but also include the result that is passed to the method as a second parameter in the return object. Let's check out an example of this:</li>
</ol>
<pre>        Future&lt;Integer&gt; future = execService.submit(() -&gt; <br/>               System.<span>out</span>.println(<span>"Worker 42 did the job."</span>)<span>, </span><span>42</span>)<span>;<br/></span><span>        int </span>result = future.get()<span>;<br/></span></pre>
<p style="padding-left: 60px">The value of <kbd>result</kbd> is <kbd>42</kbd>. This method can be helpful when you have submitted many workers (<kbd>nWorkers</kbd>) and need to know which one is completed:</p>
<pre>        Set&lt;Integer&gt; set = <span>new </span>HashSet&lt;&gt;()<span>;<br/></span><span>        while </span>(set.size() &lt; nWorkers){<br/>          <span>for </span>(Future&lt;Integer&gt; future : futures) {<br/>            <span>if </span>(future.isDone()){<br/>              <span>try </span>{<br/>                String id = future.get(<span>1</span><span>, </span>TimeUnit.<span>SECONDS</span>)<span>;<br/></span><span>                if</span>(!set.contains(id)){<br/>                  System.<span>out</span>.println(<span>"Task " </span>+ id + <span>" is done."</span>)<span>;<br/></span><span>                  </span>set.add(id)<span>;<br/></span><span>                </span>}<br/>              } <span>catch </span>(Exception ex) {<br/>                System.<span>out</span>.println(<span>"Caught around future.get(): "<br/></span>                                   + ex.getClass().getName())<span>;<br/></span><span>              </span>}<br/>            }<br/>          }<br/>        }</pre>
<p style="padding-left: 60px">Well, the catch is that <kbd>future.get()</kbd> is a blocking method. This is why we use a version of the <kbd>get()</kbd> method that allows us to set the <kbd>delaySec</kbd> timeout. Otherwise, <kbd>get()</kbd> blocks the iteration. </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>Let's move a step closer to real-life code and create a class that implements <kbd>Callable</kbd> and allows you to return a result from a worker as an object of the <kbd>Result</kbd> class:    </p>
<pre><span>class </span>Result {<br/>  <span>private int </span><span>sleepSec</span><span>, </span><span>result</span><span>;<br/></span><span>  private </span>String <span>workerName</span><span>;</span><span><br/></span><span>  public </span><span>Result</span>(String workerName<span>, int </span>sleptSec<span>, int </span>result) {<br/>    <span>this</span>.<span>workerName </span>= workerName<span>;<br/></span><span>    this</span>.<span>sleepSec </span>= sleptSec<span>;<br/></span><span>    this</span>.<span>result </span>= result<span>;<br/></span><span>  </span>}<br/>  <span>public </span>String <span>getWorkerName</span>() {<span> return this</span>.<span>workerName</span><span>; </span>}<br/>  <span>public int </span><span>getSleepSec</span>() { <span>return this</span>.<span>sleepSec</span><span>; </span>}<br/>  <span>public int </span><span>getResult</span>() { <span>return this</span>.<span>result</span><span>; </span>}<br/>}</pre>
<p>An actual numeric result is returned by the <kbd>getResult()</kbd> method. Here we also included the name of the worker and how long the thread is expected to sleep (to work) just for convenience and to better illustrate the output. </p>
<p>The worker itself is going to be an instance of the <kbd>CallableWorkerImpl</kbd> class:</p>
<pre><span>class </span>CallableWorkerImpl <span>implements </span>CallableWorker&lt;Result&gt;{<br/>  <span>private int </span><span>sleepSec</span><span>;<br/></span><span>  private </span>String <span>name</span><span>;</span><span><br/></span><span>  public </span><span>CallableWorkerImpl</span>(String name<span>, int </span>sleepSec) {<br/>    <span>this</span>.<span>name </span>= name<span>;<br/></span><span>    this</span>.<span>sleepSec </span>= sleepSec<span>;<br/></span><span>  </span>}<br/>  <span>public </span>String <span>getName</span>() { <span>return this</span>.<span>name</span><span>; </span>}<br/>  <span>public int </span><span>getSleepSec</span>() { <span>return this</span>.<span>sleepSec</span><span>; </span>}<br/>  <span>public </span>Result <span>call</span>() {<br/>    <span>try </span>{<br/>      Thread.<span>sleep</span>(<span>sleepSec </span>* <span>1000</span>)<span>;<br/></span><span>    </span>} <span>catch </span>(Exception ex) {<br/>      System.<span>out</span>.println(<span>"Caught in CallableWorker: " <br/></span>                         + ex.getClass().getName())<span>;<br/></span><span>    </span>}<br/>    <span>return new </span>Result(<span>name</span><span>, </span><span>sleepSec</span><span>, </span><span>42</span>)<span>;<br/></span><span>  </span>}<br/>}</pre>
<p>Here, the number <kbd>42</kbd> is an actual numeric result, which a worker supposedly calculated (while sleeping). The class  <kbd>CallableWorkerImpl</kbd> implemented interface <kbd>CallableWorker</kbd> : </p>
<pre><span>interface </span>CallableWorker&lt;<span>Result</span>&gt; <span>extends </span>Callable&lt;<span>Result</span>&gt; {<br/>  <span>default </span>String <span>getName</span>() { <span>return </span><span>"Anonymous"</span><span>; </span>}<br/>  <span>default int </span><span>getSleepSec</span>() { <span>return </span><span>1</span><span>; </span>}<br/>}</pre>
<p>We had to make the methods default and return some data (they will be overridden by the class implementation anyway) to preserve its <kbd>functional interface</kbd> status. Otherwise, we would not be able to use it in lambda expressions.</p>
<p>We will also create a factory that will generate a list of workers:</p>
<pre>List&lt;CallableWorker&lt;Result&gt;&gt; <span>createListOfCallables</span>(<span>int </span>nSec){<br/>  <span>return </span>List.<span>of</span>(<span>new </span>CallableWorkerImpl(<span>"One"</span><span>, </span>nSec)<span>,<br/></span><span>                 new </span>CallableWorkerImpl(<span>"Two"</span><span>, </span><span>2 </span>* nSec)<span>,<br/></span><span>                 new </span>CallableWorkerImpl(<span>"Three"</span><span>, </span><span>3 </span>* nSec))<span>;<br/></span>}</pre>
<p>Now we can use all these new classes and methods to demonstrate the <kbd>invokeAll()</kbd> method: </p>
<pre><span>void </span><span>invokeAllCallables</span>(ExecutorService execService<span>, <br/>        int </span>shutdownDelaySec<span>,</span> List&lt;CallableWorker&lt;Result&gt;&gt; callables) {<br/>  List&lt;Future&lt;Result&gt;&gt; futures = <span>new </span>ArrayList&lt;&gt;()<span>;<br/></span><span>  try </span>{<br/>    futures = execService.invokeAll(callables<span>, </span>shutdownDelaySec<span>, <br/></span>                                    TimeUnit.<span>SECONDS</span>)<span>;</span><span><br/></span><span>  </span>} <span>catch </span>(Exception ex) {<br/>    System.<span>out</span>.println(<span>"Caught around execService.invokeAll(): " <br/></span>                       + ex.getClass().getName())<span>;<br/></span><span>  </span>}<br/>  <span>try </span>{<br/>    execService.shutdown()<span>;<br/></span><span>    </span>System.<span>out</span>.println(<span>"Waiting for " </span>+ shutdownDelaySec <br/>                       + <span>" sec before terminating all tasks..."</span>)<span>;<br/></span><span>    </span>execService.awaitTermination(shutdownDelaySec<span>,<br/></span>                                 TimeUnit.<span>SECONDS</span>)<span>;<br/></span><span>  </span>} <span>catch </span>(Exception ex) {<br/>    System.<span>out</span>.println(<span>"Caught around awaitTermination(): " <br/></span>                       + ex.getClass().getName())<span>;<br/></span><span>  </span>} <span>finally </span>{<br/>    <span>if </span>(!execService.isTerminated()) {<br/>      System.<span>out</span>.println(<span>"Terminating remaining tasks..."</span>)<span>;<br/></span><span>      for </span>(Future&lt;Result&gt; future : futures) {<br/>        <span>if </span>(!future.isDone() &amp;&amp; !future.isCancelled()) {<br/>          <span>try </span>{<br/>            System.<span>out</span>.println(<span>"Cancelling task "<br/>                       </span>+ future.get(shutdownDelaySec<span>, <br/></span>                               TimeUnit.<span>SECONDS</span>).getWorkerName())<span>;<br/></span><span>            </span>future.cancel(<span>true</span>)<span>;<br/></span><span>          </span>} <span>catch </span>(Exception ex) {<br/>            System.<span>out</span>.println(<span>"Caught at cancelling task: " <br/></span>                               + ex.getClass().getName())<span>;<br/></span><span>          </span>}<br/>        }<br/>      }<br/>    }<br/>    System.<span>out</span>.println(<span>"Calling execService.shutdownNow()..."</span>)<span>;<br/></span><span>    </span>execService.shutdownNow()<span>;<br/></span><span>  </span>}<br/>  <span>printResults</span>(futures<span>, </span>shutdownDelaySec)<span>;<br/></span>}</pre>
<p>The <kbd>printResults()</kbd> method outputs the results received from the workers: </p>
<pre><span>void </span><span>printResults</span>(List&lt;Future&lt;Result&gt;&gt; futures<span>, int </span>timeoutSec) {<br/>  System.<span>out</span>.println(<span>"Results from futures:"</span>)<span>;<br/></span><span>  if </span>(futures == <span>null </span>|| futures.size() == <span>0</span>) {<br/>    System.<span>out</span>.println(<span>"No results. Futures" <br/></span>                       + (futures == <span>null </span>? <span>" = null" </span>: <span>".size()=0"</span>))<span>;<br/></span><span>  </span>} <span>else </span>{<br/>    <span>for </span>(Future&lt;Result&gt; future : futures) {<br/>      <span>try </span>{<br/>        <span>if </span>(future.isCancelled()) {<br/>          System.<span>out</span>.println(<span>"Worker is cancelled."</span>)<span>;<br/></span><span>        </span>} <span>else </span>{<br/>          Result result = future.get(timeoutSec<span>, </span>TimeUnit.<span>SECONDS</span>)<span>;<br/></span><span>          </span>System.<span>out</span>.println(<span>"Worker "</span>+ result.getWorkerName() + <br/>                             <span>" slept " </span>+ result.getSleepSec() + <br/>                             <span>" sec. Result = " </span>+ result.getResult())<span>;<br/></span><span>        </span>}<br/>      } <span>catch </span>(Exception ex) {<br/>        System.<span>out</span>.println(<span>"Caught while getting result: " <br/></span>                           + ex.getClass().getName())<span>;<br/></span><span>      </span>}<br/>    }<br/>  }<br/>}</pre>
<p>To get the results, again we use a version of the <kbd>get()</kbd> method with timeout settings. Run the following code:</p>
<pre>List&lt;CallableWorker&lt;Result&gt;&gt; callables = <span>createListOfCallables</span>(1)<span>;</span><span><br/></span>System.<span>out</span>.println(<span>"Executors.newSingleThreadExecutor():"</span>)<span>;<br/></span>ExecutorService execService = Executors.<span>newSingleThreadExecutor</span>()<span>;<br/></span><span>invokeAllCallables</span>(execService<span>, </span><span>1</span><span>, </span>callables)<span>;<br/></span></pre>
<p>Its output will be as follows:</p>
<div class="CDPAlignCenter CDPAlign"><img height="88" width="391" src="assets/be8e4318-8490-4fd0-8660-970c74b8dd60.png"/></div>
<p>It's probably worth reminding that the three workers were created with sleep time 1, 2, and 3 seconds correspondingly, while the waiting time before the service shuts down is one second. This is why all the workers were canceled.</p>
<p>Now if we set the waiting time to six seconds, the output of the single-thread executor will be as follows:</p>
<div class="CDPAlignCenter CDPAlign"><img height="108" width="440" src="assets/f39a119a-87b0-47ec-a95f-fac460d3e347.png"/></div>
<p>Naturally, if we increase the waiting time again, all the workers would be able to complete their tasks. </p>
<p><span>The</span> <kbd>ExecutorService</kbd> interface <span>produced by </span><kbd>newCachedThreadPool()</kbd> <span>or </span><kbd>newFixedThreadPool()</kbd> <span>performs much better even on a one-core computer:</span></p>
<div class="CDPAlignCenter CDPAlign"><img height="101" width="467" src="assets/ed6d36e5-fbdc-439c-8d77-ba7cbc5d60ce.png"/></div>
<p>As you can see, all the threads were able to complete even with three seconds of waiting time. </p>
<p>As an alternative, instead of setting a timeout during the service shutdown, you can possibly set it on the overloaded version of the <kbd>invokeAll()</kbd> method: </p>
<pre>List&lt;Future&lt;T&gt;&gt; invokeAll(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks,<br/>                          long timeout, TimeUnit unit)</pre>
<p>There is one particular aspect of the <kbd>invokeAll()</kbd> method's behavior that often gets overlooked and causes surprises for first-time users: it returns only after all the tasks are complete (either normally or by throwing an exception). Read the Javadoc and experiment until you <span>recognize</span> that this behavior is acceptable for your application.</p>
<p>By contrast, the <kbd>invokeAny()</kbd> method blocks only until at least one task is <em>completed successfully (without throwing an exception), if any do. Upon normal or exceptional return, tasks that have not completed are canceled</em> (according to Javadoc). Here is an example of the code that does this:</p>
<pre><span>void </span><span>invokeAnyCallables</span>(ExecutorService execService<span>, <br/>        int </span>shutdownDelaySec<span>, </span>List&lt;CallableWorker&lt;Result&gt;&gt; callables) {<br/>  Result result = <span>null;<br/></span><span>  try </span>{<br/>    result = execService.invokeAny(callables<span>,</span> shutdownDelaySec<span>,                                    </span>TimeUnit.<span>SECONDS</span>)<span>;</span><span><br/></span><span>  </span>} <span>catch </span>(Exception ex) {<br/>    System.<span>out</span>.println(<span>"Caught around execService.invokeAny(): " <br/></span>                       + ex.getClass().getName())<span>;<br/></span><span>  </span>}<br/>  <span>shutdownAndCancelTasks</span>(execService<span>,</span> shutdownDelaySec<span>,<br/>                         new </span>ArrayList&lt;&gt;())<span>;<br/></span><span>  if </span>(result == <span>null</span>) {<br/>    System.<span>out</span>.println(<span>"No result from execService.invokeAny()"</span>)<span>;<br/></span><span>  </span>} <span>else </span>{<br/>    System.<span>out</span>.println(<span>"Worker " </span>+ result.getWorkerName() + <br/>                       <span>" slept " </span>+ result.getSleepSec() + <br/>                       <span>" sec. Result = " </span>+ result.getResult())<span>;<br/></span><span>  </span>}<br/>}</pre>
<p><span>You can experiment with it, setting different values for the waiting time (<kbd>shutdownDelaySec</kbd>) and sleep time for threads until you are comfortable with how this method behaves. As you can see, we have reused the <kbd>shutdownAndCancelTasks()</kbd> method by passing an empty list of <kbd>Future</kbd> objects since we do not have them in this case.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">There's more...</h1>
                </header>
            
            <article>
                
<p>There are two more static factory methods in the <kbd>Executors</kbd> class that create instances of <kbd>ExecutorService</kbd>:</p>
<ul>
<li><kbd>newWorkStealingPool()</kbd>: This creates a work-stealing thread pool using the number of available processors as its target parallelism level. It has an overloaded version with a parallelism level as a parameter.</li>
<li><kbd><span>unconfigurableExecutorService(ExecutorService executor)</span></kbd><span>: This returns an object that delegates all the defined</span> <kbd>ExecutorService</kbd> <span>methods to the given executor, except for those methods that might otherwise be accessible using casts.</span></li>
</ul>
<p>Also, a subinterface of the <kbd>ExecutorService</kbd> <span>interface,</span> called <kbd>ScheduledExecutorService</kbd>, enhances the API with the capability to schedule a thread execution in future and/or their periodic execution. </p>
<p>The objects of <kbd>ScheduledExecutorService</kbd> can be created using the static factory methods of the <kbd>java.util.concurrent.Executors</kbd> class too:</p>
<ul>
<li><kbd>newSingleThreadScheduledExecutor()</kbd>: This creates a single-threaded executor that can schedule commands to run after a given delay or to execute them periodically. It<span> has an overloaded version with <kbd>ThreadFactory</kbd> as a parameter</span>.</li>
<li><kbd>newScheduledThreadPool(int corePoolSize)</kbd>: This creates a thread pool that can schedule commands to run after a given delay or to execute them periodically. It<span> has an overloaded version with</span> <kbd>ThreadFactory</kbd> <span>as a parameter</span><span>.</span></li>
<li><kbd>unconfigurableScheduledExecutorService( ScheduledExecutorService executor )</kbd>: This returns an object that delegates all the defined <kbd>ScheduledExecutorService</kbd> methods to the given executor, but not any other methods that might otherwise be accessible using casts.</li>
</ul>
<p>The <kbd>Executors</kbd> class also has several overloaded methods that accept, execute, and return <kbd>Callable</kbd> (which, by contrast with <kbd>Runnable</kbd>, contains the result).</p>
<p>The <kbd>java.util.concurrent</kbd> package also includes classes that implement <kbd>ExecutorService</kbd>: </p>
<ul>
<li><strong>The ThreadPoolExecutor class</strong>: This executes each submitted task using one of the several pooled threads, normally configured using the <kbd>Executors</kbd> factory methods.</li>
<li><strong>The ScheduledThreadPoolExecutor</strong><span><strong> class</strong>: This extends the <kbd>ThreadPoolExecutor</kbd> class and implements the <kbd>ScheduledExecutorService</kbd> interface.</span></li>
<li><strong>The ForkJoinPool class</strong><span>: This manages the execution of workers (<kbd>ForkJoinTask</kbd> processes) using a work-stealing algorithm. We will discuss it in the next recipe.</span></li>
</ul>
<p>Instances of these classes can be created via class constructors that accept more parameters, including the queue that holds the results, for providing more refined thread pool management.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">See also</h1>
                </header>
            
            <article>
                
<p>Refer to the following recipes in this chapter:</p>
<ul>
<li>Using fork/join to implement divide-and-conquer</li>
<li>Using flow to implement the publish-subscribe pattern</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Using fork/join to implement divide-and-conquer</h1>
                </header>
            
            <article>
                
<p>In this recipe, you will learn how to use the fork/join framework for the <span>divide-and-conquer</span> computation pattern.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p>As mentioned in the previous recipe, the <kbd>ForkJoinPool</kbd><span> class </span>is an implementation of the <kbd>ExecutorService</kbd> interface that <span>manages the execution of workers--</span><kbd>ForkJoinTask</kbd> <span>processes--using the </span>work-stealing <span>algorithm. It</span> takes advantage of multiple processors, if available, and works best on tasks that can be broken down into smaller tasks recursively, which is also called a <em>divide-and-conquer</em> strategy.</p>
<p><span>Each thread in the pool has a dedicated double-ended queue (deque) that stores tasks, and the thread picks up the next task (from the head of the queue) as soon as the current task is completed. When another thread finishes executing all the tasks in its queue, it can take a task (steal it) from the tail of a non-empty queue of another thread.</span></p>
<p>As with any <kbd>ExecutorService</kbd> implementation, the fork/join framework distributes tasks to worker threads in a thread pool. This framework is distinct because it uses a work-stealing algorithm. Worker threads that run out of <span>tasks</span> can steal tasks from other threads that are still busy.</p>
<p><span>Such a design balances the load and allows an efficient use of the resources. </span></p>
<p>For demonstration purposes, we are going to use the API created in <a href="488da544-ff73-4ef7-9d57-00b67479defd.xhtml">Chapter 3</a>, <em>Modular Programming</em>: the <kbd>TrafficUnit</kbd>, <kbd>SpeedModel</kbd>, and <kbd>Vehicle</kbd> interfaces and the <kbd>TrafficUnitWrapper</kbd>, <kbd>FactoryTraffic</kbd>, <kbd>FactoryVehicle</kbd>, and <kbd>FactorySpeedModel</kbd> classes. We will also rely on the streams and stream pipelines described in <a href="488da544-ff73-4ef7-9d57-00b67479defd.xhtml">Chapter 3</a>, <em>Modular Programming</em>. </p>
<p>Just to refresh your memory, here is the <kbd>TrafficUnitWrapper</kbd> class: </p>
<p> </p>
<pre><span>class </span>TrafficUnitWrapper {<br/>  <span>private double </span><span>speed</span><span>;<br/></span><span>  private </span>Vehicle <span>vehicle</span><span>;<br/></span><span>  private </span>TrafficUnit <span>trafficUnit</span><span>;<br/></span><span>  public </span><span>TrafficUnitWrapper</span>(TrafficUnit trafficUnit){<br/>    <span>this</span>.<span>trafficUnit </span>= trafficUnit<span>;<br/></span><span>    this</span>.<span>vehicle </span>= FactoryVehicle.<span>build</span>(trafficUnit)<span>;<br/></span><span>  </span>}<br/>  <span>public </span>TrafficUnitWrapper <span>setSpeedModel</span>(SpeedModel speedModel) {<br/>    <span>this</span>.<span>vehicle</span>.setSpeedModel(speedModel)<span>;<br/></span><span>    return this;<br/></span><span>  </span>}<br/>  TrafficUnit <span>getTrafficUnit</span>(){ <span>return this</span>.<span>trafficUnit</span><span>;</span>}<br/>  <span>public double </span><span>getSpeed</span>() { <span>return </span><span>speed</span><span>; </span>}<br/><br/>  <span>public </span>TrafficUnitWrapper <span>calcSpeed</span>(<span>double </span>timeSec) {<br/>    <span>double </span>speed = <span>this</span>.<span>vehicle</span>.getSpeedMph(timeSec)<span>;<br/></span><span>    this</span>.<span>speed </span>= Math.<span>round</span>(speed * <span>this</span>.<span>trafficUnit.</span>getTraction())<span>;<br/></span><span>    return this;<br/></span><span>  </span>}<br/>}</pre>
<p>We will also slightly modify the existing API interface and make it a bit more compact by introducing a new <kbd>DateLocation</kbd> class:</p>
<p> </p>
<pre><span>class </span>DateLocation {<br/>  <span>private int </span><span>hour</span><span>;<br/></span><span>  private </span>Month <span>month</span><span>;<br/></span><span>  private </span>DayOfWeek <span>dayOfWeek</span><span>;<br/></span><span>  private </span>String <span>country</span><span>, </span><span>city</span><span>, </span><span>trafficLight</span><span>;<br/></span><span><br/></span><span>  public </span><span>DateLocation</span>(Month month<span>, </span>DayOfWeek dayOfWeek<span>, <br/>                      int </span>hour<span>, </span>String country<span>, </span>String city<span>, <br/></span>                      String trafficLight) {<br/>    <span>this</span>.<span>hour </span>= hour<span>;<br/></span><span>    this</span>.<span>month </span>= month<span>;<br/></span><span>    this</span>.<span>dayOfWeek </span>= dayOfWeek<span>;<br/></span><span>    this</span>.<span>country </span>= country<span>;<br/></span><span>    this</span>.<span>city </span>= city<span>;<br/></span><span>    this</span>.<span>trafficLight </span>= trafficLight<span>;<br/></span><span>  </span>}<br/>  <span>public int </span><span>getHour</span>() { <span>return </span><span>hour</span><span>; </span>}<br/>  <span>public </span>Month <span>getMonth</span>() { <span>return </span><span>month</span><span>; </span>}<br/>  <span>public </span>DayOfWeek <span>getDayOfWeek</span>() { <span>return </span><span>dayOfWeek</span><span>; </span>}<br/>  <span>public </span>String <span>getCountry</span>() { <span>return </span><span>country</span><span>; </span>}<br/>  <span>public </span>String <span>getCity</span>() { <span>return </span><span>city</span><span>; </span>}<br/>  <span>public </span>String <span>getTrafficLight</span>() { <span>return </span><span>trafficLight</span><span>;</span>}<br/>}</pre>
<p>It will also allow you to hide the details and help you see the important aspects of this recipe.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p>All computations are encapsulated inside a subclass of one of the two subclasses (<span><kbd>RecursiveAction</kbd> or <kbd>RecursiveTask&lt;T&gt;</kbd>) </span>of the abstract <kbd>ForkJoinTask</kbd><span> class. You can extend either <kbd>RecursiveAction</kbd> (and implement the <kbd>void compute()</kbd></span> method<span>) or <kbd>RecursiveTask&lt;T&gt;</kbd> (and implement the <kbd>T compute()</kbd></span> method<span>). As you may have probably noticed, you can choose to extend the <kbd>RecursiveAction</kbd> class for tasks that do not return any value, and extend <kbd>RecursiveTask&lt;T&gt;</kbd> when you need your tasks to return a value. In our demo, we are going to use the latter because it is slightly more complex.</span></p>
<p>Let's say we would like to calculate the average speed of traffic in a certain location on a certain date and time and driving conditions (all these parameters are defined by the property <kbd>DateLocation</kbd> object). Other parameters will be as follows: </p>
<ul>
<li><kbd>timeSec</kbd>: The number of seconds during which the vehicles have a chance to accelerate after stopping at the traffic light</li>
<li><kbd>trafficUnitsNumber</kbd>: The number of vehicles to include in the average speed calculation</li>
</ul>
<p>Naturally, the more vehicles included in the calculations, the better the prediction. But as this number increases, the number of calculations increases too. This gives rise to the need to break down the number of vehicles into smaller groups and compute the average speed of each group in parallel with the others. Yet, there is a certain minimal number of calculations that is not worth splitting between two threads. Here's what Javadoc has to say about it: <em>As a very rough rule of thumb, a task should perform more than 100 and less than 10000 basic computational steps, and should avoid indefinite looping. If tasks are too big, then parallelism cannot improve throughput. If too small, then memory and internal task maintenance overhead may overwhelm processing.</em> Yet, as always, the final answer about the best minimal number of calculations without splitting will come from testing. This is why we recommend to pass it as a parameter. We will call this parameter <kbd>threshold</kbd>. Notice that it also serves as a criterium for exiting from the recursion.</p>
<p>We will call our class (task) <kbd>AverageSpeed</kbd> and extend <kbd>RecursiveTask&lt;Double&gt;</kbd> because we would like to have as a result of the average speed value of the <kbd>double</kbd> type:</p>
<pre><span>class </span>AverageSpeed <span>extends </span>RecursiveTask&lt;Double&gt; {<br/>  <span>private double </span><span>timeSec</span><span>;<br/></span><span>  private </span>DateLocation <span>dateLocation</span><span>;<br/></span><span>  private int </span><span>threshold</span><span>, </span><span>trafficUnitsNumber</span><span>;</span><span><br/></span><span>  public </span><span>AverageSpeed</span>(DateLocation dateLocation<span>, <br/>                      double </span>timeSec<span>, int </span>trafficUnitsNumber<span>, <br/>                      int </span>threshold) {<br/>    <span>this</span>.<span>timeSec </span>= timeSec<span>;<br/></span><span>    this</span>.<span>threshold </span>= threshold<span>;<br/></span><span>    this</span>.<span>dateLocation </span>= dateLocation<span>;<br/></span><span>    this</span>.<span>trafficUnitsNumber </span>= trafficUnitsNumber<span>;<br/></span><span>  </span>}<br/>  <span>protected </span>Double <span>compute</span>() {<br/>    <span>if </span>(<span>trafficUnitsNumber </span>&lt; <span>threshold</span>) {<br/>      //... write the code here that calculates<br/>      //... average speed trafficUnitsNumber vehicles<br/>      <span>return averageSpeed</span><span>;<br/></span><span>    </span>} <span>else</span>{<br/>      <span>int </span>tun = <span>trafficUnitsNumber </span>/ <span>2</span><span>;<br/></span><span>      //write the code that creates two tasks, each<br/></span><span>      //for calculating average speed of tun vehicles <br/>      //then calculates an average of the two results<br/>      double avrgSpeed1 = ...;<br/>      double avrgSpeed2 = ...;<br/>      return (double) Math.round((avrgSpeed1 + avrgSpeed2) / 2);</span><span><br/></span><span>    </span>}<br/>  }<br/>}</pre>
<p>Before we finish writing the code for the <kbd>compute()</kbd> method, let's write the code that will execute this task. There are several ways to do this. We can use <kbd>fork()</kbd> and <kbd>join()</kbd>, for example:</p>
<pre><span>void </span><span>demo1_ForkJoin_fork_join</span>() {<br/><span>  </span>AverageSpeed averageSpeed = <span>createTask</span>()<span>;</span><span><br/></span><span>  </span>averageSpeed.fork()<span>;  </span><span><br/></span><span>  </span><span>double </span>result = averageSpeed.join()<span>;</span><span><br/></span><span>  </span>System.<span>out</span>.println(<span>"result = " </span>+ result)<span>;<br/></span>}</pre>
<p>This technique provided the name for the framework. The <kbd>fork()</kbd> method, according to Javadoc, a<em>rranges to asynchronously execute this task in the pool the current task is running in, if applicable, or using the ForkJoinPool.commonPool() if not in ForkJoinPool().</em> In our case, we did not use any pool yet, so <kbd>fork()</kbd> is going to use <kbd>ForkJoinPool.commonPool()</kbd> by default. It places the task in the queue of a thread in the pool. The <kbd>join()</kbd> method returns the result of the computation when it is done.</p>
<p>The <kbd>createTask()</kbd> method contains the following: </p>
<pre>AverageSpeed <span>createTask</span>() {<br/>  DateLocation dateLocation = <span>new </span>DateLocation(Month.<span>APRIL</span><span>, <br/></span>        DayOfWeek.<span>FRIDAY</span><span>, </span><span>17</span><span>, </span><span>"USA"</span><span>, </span><span>"Denver"</span><span>, </span><span>"Main103S"</span>)<span>;<br/>  double timeSec = 10d;<br/>  int trafficUnitsNumber = 1001;<br/>  int threshold = 100;<br/></span><span>  return</span> <span>new </span>AverageSpeed(dateLocation<span>, timeSec, <br/></span><span>                          trafficUnitsNumber, threshold</span>)<span>;<br/></span><span>}</span></pre>
<p>Notice the values of the <kbd>trafficUnitsNumber</kbd> and <kbd>threshold</kbd> parameters. This will be important for analyzing the results.</p>
<p>Another way to accomplish this is to use either the <kbd>execute()</kbd> or <kbd>submit()</kbd> method--each providing the same functionality--for the execution of the task. The result of the execution can be retrieved by the <kbd>join()</kbd> method (the same as in the previous example): </p>
<pre><span>void </span><span>demo2_ForkJoin_execute_join</span>() {<span><br/></span><span>  </span>AverageSpeed averageSpeed = <span>createTask</span>()<span>;</span><span><br/></span><span>  </span>ForkJoinPool commonPool = ForkJoinPool.<span>commonPool</span>()<span>;<br/></span><span>  </span>commonPool.execute(averageSpeed)<span>;<br/></span><span>  double </span>result = averageSpeed.join()<span>;</span><span><br/></span><span>  </span>System.<span>out</span>.println(<span>"result = " </span>+ result)<span>;<br/></span>}</pre>
<p>The last method we are going to review is <kbd>invoke()</kbd>, which is equivalent to calling the <kbd>fork()</kbd> method followed by the <kbd>join()</kbd> method:</p>
<pre><span>void </span><span>demo3_ForkJoin_invoke</span>() {<span><br/></span><span>  </span>AverageSpeed averageSpeed = <span>createTask</span>()<span>;</span><span><br/></span><span>  </span>ForkJoinPool commonPool = ForkJoinPool.<span>commonPool</span>()<span>;<br/></span><span>  double </span>result = commonPool.invoke(averageSpeed)<span>;</span><span><br/></span><span>  </span>System.<span>out</span>.println(<span>"result = " </span>+ result)<span>;<br/></span>}</pre>
<p>Naturally, this is the most popular way to start the divide-and-conquer process.</p>
<p>Now let's get back to the <kbd>compute()</kbd> method and see how it can be implemented. First, let's implement the <kbd>if</kbd> block (that calculates the average speed of less than <kbd>threshold</kbd> vehicles). We will use the technique and code we described in <a href="488da544-ff73-4ef7-9d57-00b67479defd.xhtml">Chapter 3</a>, <em>Modular Programming</em>:</p>
<pre><span>double </span>speed = FactoryTraffic.<span>getTrafficUnitStream</span>(<span>dateLocation</span><span>, <br/></span><span>                                  trafficUnitsNumber</span>)<br/>        .map(TrafficUnitWrapper::<span>new</span>)<br/>        .map(tuw -&gt; tuw.setSpeedModel(FactorySpeedModel.<br/><span>                         generateSpeedModel</span>(tuw.getTrafficUnit())))<br/>        .map(tuw -&gt; tuw.calcSpeed(<span>timeSec</span>))<br/>        .mapToDouble(TrafficUnitWrapper::getSpeed)<br/>        .average()<br/>        .getAsDouble()<span>;<br/></span>System.<span>out</span>.println(<span>"speed(" </span>+ <span>trafficUnitsNumber </span>+ <span>") = " </span>+ speed)<span>;<br/></span><span>return </span>(<span>double</span>) Math.<span>round</span>(speed)<span>;<br/></span></pre>
<p>We get the <kbd>trafficUnitsNumber</kbd> of the vehicles from <kbd>FactoryTraffic</kbd>, and we create an object of <kbd>TrafficUnitWrapper</kbd> for each emitted element and call the <kbd>setSpeedModel()</kbd> method on it (by passing in the newly generated <kbd>SpeedModel</kbd> object, based on the emitted <kbd>TrafficUnit</kbd> object). Then we calculate the speed, get an average of all the speeds in the stream, and get the result as <kbd>double</kbd> from the <kbd>Optional</kbd> object (the return type of the <kbd>average()</kbd> operation). We then print out the result and round to get a more presentable format.</p>
<p>It is also possible to achieve the same result using a traditional <kbd>for</kbd> loop. But, as mentioned before, it seems that Java follows the general trend of more fluent and stream-like style, geared towards processing a large amount of data. So, we recommend you get used to it.</p>
<p>In <a href="823213ae-b820-450c-abb8-8a98a70caf70.xhtml">Chapter 15</a>, <em>Testing</em>, you will see another version of the same functionality that allows better unit testing of each step in isolation, which again supports the view that unit testing, along with writing code, helps you make your code more testable and decreases the need for rewriting it later.</p>
<p>Now, let's review the options of the <kbd>else</kbd> block implementation. The first few lines are always going to be the same:</p>
<pre><span>int </span>tun = <span>trafficUnitsNumber </span>/ <span>2</span><span>;<br/></span>System.<span>out</span>.println(<span>"tun = " </span>+ tun)<span>;<br/></span>AverageSpeed as1 = <span>new </span>AverageSpeed(<span>dateLocation</span><span>, </span><span>timeSec</span><span>, </span>tun<span>,<br/></span><span>                                    threshold</span>)<span>;<br/></span>AverageSpeed as2 = <span>new </span>AverageSpeed(<span>dateLocation</span><span>, </span><span>timeSec</span><span>, </span>tun<span>,<br/></span><span>                                    threshold</span>)<span>;<br/></span></pre>
<p>We divide the <kbd>trafficUnitsNumber</kbd> number by two (we do not worry about possible loss of one unit in the case of an average across a big set) and create two tasks.</p>
<p>The following--the actual task execution code--can be written in several different ways. Here is the first possible solution, which is familiar to us already, that comes to mind:</p>
<pre>as1.fork()<span>;                </span><span>//add to the queue<br/></span><span>double </span>res1 = as1.join()<span>;  </span><span>//wait until completed</span><span><br/></span>as2.fork()<span>;<br/></span><span>double </span>res2 = as2.join()<span>;</span><span><br/></span><span>return </span>(<span>double</span>) Math.<span>round</span>((res1 + res2) / <span>2</span>)<span>;<br/></span></pre>
<p> Run the following code:</p>
<pre><span>demo1_ForkJoin_fork_join</span>()<span>;<br/></span><span>demo2_ForkJoin_execute_join</span>()<span>;<br/></span><span>demo3_ForkJoin_invoke</span>()<span>;<br/></span></pre>
<p> If we do this, we will see the same output (but with different speed values) three times:</p>
<div class="CDPAlignCenter CDPAlign"><img height="355" width="388" src="assets/c694c38c-ce64-4682-baa3-7b2b12c613d6.png"/></div>
<p>You see how the original task of calculating average speed over 1,001 units (vehicles) was first divided by two several times until the number of one group (62) fell under the threshold of 100. Then, an average speed of the last two groups was calculated and combined (joined) with the results of other groups. </p>
<p>Another way to implement an <kbd>else</kbd> <span>block of the <kbd>compute()</kbd> method could be as follows:</span></p>
<pre>as1.fork()<span>;                   </span><span>//add to the queue<br/></span><span>double </span>res1 = as2.compute()<span>;  </span><span>//get the result recursively<br/></span><span>double </span>res2 = as1.join()<span>;     </span><span>//wait until the queued task ends<br/></span><span>return </span>(<span>double</span>) Math.<span>round</span>((res1 + res2) / <span>2</span>)<span>;<br/></span></pre>
<p>Here's how the result will look: </p>
<div class="CDPAlignCenter CDPAlign"><img height="359" width="401" src="assets/4df2d4d0-0ef5-47a3-9838-ae440af6c6e9.png"/> </div>
<p>You can see how, in this case, the <kbd>compute()</kbd> method (of the second task) was called recursively many times until it reached the threshold by the number of elements, then its results were joined with the results of the call to the <kbd>fork()</kbd> and <kbd>join()</kbd> methods of the first task.</p>
<p>As mentioned before, all this complexity can be replaced by a call to the <kbd>invoke()</kbd> method:</p>
<pre><span>double </span>res1 = as1.invoke()<span>;<br/></span><span>double </span>res2 = as2.invoke()<span>;<br/></span><span>return </span>(<span>double</span>) Math.<span>round</span>((res1 + res2) / <span>2</span>)<span>;<br/></span></pre>
<p>It produces a result similar to the one produced by calling <kbd>fork()</kbd> and <kbd>join()</kbd> on each of the tasks:</p>
<div class="CDPAlignCenter CDPAlign"><img height="389" width="430" src="assets/f9ffedad-2fd0-431f-9624-e4de7fec800b.png"/></div>
<p>Yet, there is an even better way to implement an <kbd>else</kbd> block of the <kbd>compute()</kbd> method:</p>
<pre><span>return </span>ForkJoinTask.<span>invokeAll</span>(List.<span>of</span>(as1<span>, </span>as2))<br/>        .stream()<br/>        .mapToDouble(ForkJoinTask::join)<br/>        .map(Math::<span>round</span>)<br/>        .average()<br/>        .getAsDouble()<span>;<br/></span></pre>
<p>If this looks complex to you, just notice that it is just a stream-like way to iterate over the results of <kbd>invokeAll()</kbd>:</p>
<pre>&lt;T extends ForkJoinTask&gt; Collection&lt;T&gt; invokeAll(Collection&lt;T&gt; tasks)</pre>
<p>It is also to iterate over the results of calling <kbd>join()</kbd> on each of the returned tasks (and combining the results into average). The advantage is that we yield to the framework to decide how to optimize the load distribution. The result is as follows:</p>
<div class="CDPAlignCenter CDPAlign"><img height="393" width="438" src="assets/e65ae659-3593-4eb7-a719-f536471c7d09.png"/></div>
<p>You can see it differs from any of the preceding results and can change depending on the availability and load of the CPUs on your computer. </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Using flow to implement the publish-subscribe pattern</h1>
                </header>
            
            <article>
                
<p>In this recipe, you will learn about the new publish-subscribe capability introduced in Java 9.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p>Among many other features, Java 9 introduced these four interfaces in the <kbd>java.util.concurrent.Flow</kbd> class:</p>
<pre>Flow.Publisher&lt;T&gt; - producer of items (messages) of type T<br/>Flow.Subscriber&lt;T&gt; - receiver of messages of type T<br/>Flow.Subscription - links producer and receiver<br/>Flow.Processor&lt;T,R&gt; - acts as both producer and receiver</pre>
<p>With this, Java stepped into the world of reactive programming--programming with the <span>asynchronous</span> processing of data streams.</p>
<p>We discussed streams in <a href="488da544-ff73-4ef7-9d57-00b67479defd.xhtml">Chapter 3</a>, <em>Modular Programming</em> and pointed out that they <span>are not data structures, as they do not keep data in memory. T</span>he stream pipeline does nothing until an element is emitted. Such a model allows minimal resource allocation and uses resources only as needed. The application behaves <em>in response</em> to the appearance of the data it reacts to, thus the name.</p>
<p><span>In a publish-subscribe pattern, the main two actors are a <kbd>Publisher</kbd> and a <kbd>Subscriber</kbd>. <kbd>Publisher</kbd> streams data (publishes), and <kbd>Subscriber</kbd> listens to data (subscribes).</span></p>
<p>The <span><kbd>Flow.Publisher&lt;T&gt;</kbd></span> interface <span>is a functional interface. It only has one abstract method:</span></p>
<pre><span>void subscribe(Flow.Subscriber&lt;? super T&gt; subscriber)<br/></span></pre>
<p>According to the Javadoc, this method <em>adds the given Flow.Subscriber&lt;T&gt; if possible. If already subscribed, or the attempt to subscribe fails, the onError() method of theFlow.Subscriber&lt;T&gt; is invoked with an IllegalStateException. Otherwise, the onSubscribe() method of theFlow.Subscriber&lt;T&gt; is invoked with a new Flow.Subscription. Subscribers may enable receiving items by invoking the request() method of thisFlow.Subscription and may unsubscribe by invoking its cancel() method.</em></p>
<p>The <kbd>Flow.Subscriber&lt;T&gt;</kbd> interface has four methods; some of them were mentioned just now:</p>
<ul>
<li><kbd>void onSubscribe(Flow.Subscription subscription)</kbd> is invoked prior to invoking any other <kbd>Subscriber</kbd> methods for the given <kbd>Subscription</kbd></li>
<li><kbd>void onError(Throwable throwable)</kbd> is invoked upon an unrecoverable error encountered by a <kbd>Publisher</kbd> or <kbd>Subscription</kbd>, after which no other <kbd>Subscriber</kbd> methods are invoked by the <kbd>Subscription</kbd></li>
<li><kbd>void onNext(T item)</kbd> is invoked with the <kbd>Subscription</kbd>'s next item</li>
<li><kbd>void onComplete()</kbd>: This method is invoked when it is known that no additional <kbd>Subscriber</kbd> method invocations will occur for a <kbd>Subscription</kbd></li>
</ul>
<p>The <kbd>Flow.Subscription</kbd> interface has two methods:</p>
<ul>
<li><kbd>void cancel()</kbd>: This method causes the <kbd>Subscriber</kbd> to (eventually) stop receiving messages </li>
<li><kbd>void request(long n)</kbd>: This method adds the given n number of items to the current unfulfilled demand for this subscription</li>
</ul>
<p>The <kbd>Flow.Processor&lt;T,R&gt;</kbd> interface is outside the scope of this book.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p>To save some time and space, instead of creating our own implementation of the <kbd>Flow.Publisher&lt;T&gt;</kbd> interface, we can use the <kbd>SubmissionPublisher&lt;T&gt;</kbd> class from the <kbd>java.util.concurrent</kbd> package. But, we will create our own implementation of the <kbd>Flow.Subscriber&lt;T&gt;</kbd> interface:</p>
<p> </p>
<pre><span>class </span>DemoSubscriber&lt;T&gt; <span>implements </span>Flow.Subscriber&lt;T&gt; {<br/>  <span>private </span>String name<span>;<br/></span><span>  private </span>Flow.Subscription subscription<span>;</span><span><br/></span><span>  public </span>DemoSubscriber(String name){ <span>this</span>.name = name<span>; </span>}<br/>  <span>public void </span>onSubscribe(Flow.Subscription subscription) {<br/>    <span>this</span>.subscription = subscription<span>;<br/></span><span>    this</span>.<span>subscription</span>.request(<span>0</span>)<span>;<br/></span><span>  </span>}<br/>  <span>public void </span><span>onNext</span>(<span>T </span>item) {<br/>    System.out.println(name + <span>" received: " </span>+ item)<span>;<br/></span><span>    this</span>.<span>subscription</span>.request(<span>1</span>)<span>;<br/></span><span>  </span>}<br/>  <span>public void </span>onError(Throwable ex){ ex.printStackTrace()<span>;</span>}<br/>  <span>public void </span>onComplete() { System.out.println(<span>"Completed"</span>)<span>; </span>}<br/>}</pre>
<p>We will also implement the <kbd>Flow.Subscription</kbd> interface: </p>
<pre><span>class </span>DemoSubscription&lt;<span>T</span>&gt; <span>implements </span>Flow.Subscription {<br/>  <span>private final </span>Flow.Subscriber&lt;<span>T</span>&gt; <span>subscriber</span><span>;<br/></span><span>  private final </span>ExecutorService executor<span>;<br/></span><span>  private </span>Future&lt;?&gt; <span>future</span><span>;<br/></span><span>  private </span><span>T </span><span>item</span><span>;<br/></span><span>  public </span><span>DemoSubscription</span>(Flow.Subscriber subscriber<span>,<br/></span><span>                          </span>ExecutorService executor) {<br/>    <span>this</span>.<span>subscriber </span>= subscriber<span>;<br/></span><span>    this</span>.<span>executor </span>= executor<span>;<br/></span><span>  </span>}<br/>  <span>public void </span><span>request</span>(<span>long </span>n) {<br/>    <span>future </span>= <span>executor</span>.submit(() -&gt; {<br/>      <span>this</span>.subscriber.onNext(item )<span>;<br/></span><span>    </span>})<span>;<br/></span><span>  </span>}<br/>  <span>public synchronized void </span><span>cancel</span>() {<br/>    <span>if </span>(<span>future </span>!= <span>null </span>&amp;&amp; !<span>future</span>.isCancelled()) {<br/>      <span>this</span>.<span>future</span>.cancel(<span>true</span>)<span>;<br/></span><span>    </span>}<br/>  }<br/>}</pre>
<p>As you can see, we just followed Javadoc recommendations and expect the <kbd>onSubscribe()</kbd> method of a subscriber to be called when the subscriber is added to a publisher.</p>
<p>Another detail to notice is that the <kbd>SubmissionPublisher&lt;T&gt;</kbd><span> class has the <kbd>submit(T item)</kbd></span> <span>method</span> that, according to Javadoc, <em>publishes the given item to each current subscriber by asynchronously invoking its onNext() method, blocking uninterruptibly while resources for any subscriber are unavailable</em>. This way, the <kbd><span>SubmissionPublisher&lt;T&gt;</span></kbd> class submits items to the current subscribers until it is closed. This allows item generators to act as reactive-streams publishers.</p>
<p><span>To demonstrate this, let's create several subscribers and subscriptions using the <kbd>demoSubscribe()</kbd></span> method:</p>
<pre><span>void </span>demoSubscribe(SubmissionPublisher&lt;Integer&gt; publisher<span>, <br/></span>        ExecutorService execService<span>, </span>String subscriberName){<br/>  DemoSubscriber&lt;Integer&gt; subscriber = <br/><span>                     new </span>DemoSubscriber&lt;&gt;(subscriberName)<span>;<br/></span><span>  </span>DemoSubscription subscription = <br/><span>            new </span>DemoSubscription(subscriber<span>, </span>execService)<span>;<br/></span><span>  </span>subscriber.onSubscribe(subscription)<span>;<br/></span><span>  </span>publisher.subscribe(subscriber)<span>;<br/></span>}</pre>
<p><span>Then use them in the following code:</span></p>
<pre>ExecutorService execService =  ForkJoinPool.commonPool()<span>;</span><span><br/></span><span>try </span>(SubmissionPublisher&lt;Integer&gt; publisher = <br/><span>                            new </span>SubmissionPublisher&lt;&gt;()){<span><br/></span><span>  </span>demoSubscribe(publisher<span>, </span>execService<span>, </span><span>"One"</span>)<span>;<br/></span><span>  </span>demoSubscribe(publisher<span>, </span>execService<span>, </span><span>"Two"</span>)<span>;<br/></span><span>  </span>demoSubscribe(publisher<span>, </span>execService<span>, </span><span>"Three"</span>)<span>;<br/></span><span>  </span>IntStream.range(<span>1</span><span>, </span><span>5</span>).forEach(publisher::submit)<span>;<br/></span>} <span>finally </span>{<br/>  //...make sure that execService is shut down<br/>}</pre>
<p><span> The preceding code creates three subscribers, connected to the same publisher with a dedicated subscription. The last line generates a stream of numbers 1, 2, 3, and 4 and submits each of them to the publisher. We expect that every subscriber will get each of the generated numbers as the parameter of the <kbd>onNext()</kbd> method.</span></p>
<p>In the <kbd>finally</kbd> block, we included the code you are already familiar with from the previous recipe:</p>
<pre><span>try </span>{<br/>  execService.shutdown()<span>;<br/></span><span>  int </span>shutdownDelaySec = <span>1</span><span>;<br/></span><span>  </span>System.out.println(<span>"Waiting for " </span>+ shutdownDelaySec <br/>                     + <span>" sec before shutting down service..."</span>)<span>;<br/></span><span>  </span>execService.awaitTermination(shutdownDelaySec<span>,</span> TimeUnit.SECONDS)<span>;<br/></span>} <span>catch </span>(Exception ex) {<br/>  System.out.println(<span>"Caught around execService.awaitTermination(): " <br/></span>                     + ex.getClass().getName())<span>;<br/></span>} <span>finally </span>{<br/>  System.out.println(<span>"Calling execService.shutdownNow()..."</span>)<span>;<br/></span><span>  </span>List&lt;Runnable&gt; l = execService.shutdownNow()<span>;<br/></span><span>  </span>System.out.println(l.size() <br/>              +<span>" tasks were waiting to be executed. Service stopped."</span>)<span>;<br/></span>}</pre>
<p>If we run the preceding code, the output may look like the following:</p>
<div class="CDPAlignCenter CDPAlign"><img height="298" width="489" src="assets/df995979-dce0-4fad-b7ea-95cbbf1ecab3.png"/></div>
<p>As you can see, because of asynchronous processing, the control gets to the <kbd>finally</kbd> block very quickly and waits for 1 sec before shutting down the service. This period of waiting is enough for the items to be generated and passed to the subscribers. We also confirmed that every generated item was sent to each of the subscribers. The three <kbd>null</kbd> values were generated every time the <kbd>onSubscribe()</kbd> method of each of the subscribers is called.</p>
<p><span>It is reasonable to expect that in future Java releases, there will be more support added for reactive (asynchronous and non-blocking) functionality.</span></p>


            </article>

            
        </section>
    </body></html>