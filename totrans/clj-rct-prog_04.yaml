- en: Chapter 4. Introduction to core.async
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 4 章。核心异步简介
- en: Long gone are the days when programs were required to do only one thing at a
    time. Being able to perform several tasks concurrently is at the core of the vast
    majority of modern business applications. This is where asynchronous programming
    comes in.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 那些程序一次只能做一件事的日子已经一去不复返了。能够同时执行多个任务是大多数现代商业应用的核心。这就是异步编程的用武之地。
- en: Asynchronous programming—and, more generally, concurrency—is about doing more
    with your hardware resources than you previously could. It means fetching data
    from the network or a database connection without having to wait for the result.
    Or, perhaps, reading an Excel spreadsheet into memory while the user can still
    operate the graphical interface. In general, it improves a system's responsiveness.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 异步编程——更普遍地说，并发——是关于利用你的硬件资源比以前做得更多。这意味着在等待结果的同时从网络或数据库连接中获取数据。或者，也许在用户仍然可以操作图形界面时，将
    Excel 电子表格读入内存。总的来说，它提高了系统的响应性。
- en: 'In this chapter, we will look at how different platforms handle this style
    of programming. More specifically, we will:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨不同平台如何处理这种编程风格。更具体地说，我们将：
- en: Be introduced to core.async's background and API
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解核心异步的背景和 API
- en: Solidify our understanding of core.async by re-implementing the stock market
    application in terms of its abstractions
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过以核心异步的抽象实现股票市场应用程序来巩固我们对核心异步的理解
- en: Understand how core.async deals with error handling and backpressure
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解核心异步如何处理错误处理和背压
- en: Take a brief tour on transducers
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 简短地浏览一下转换器
- en: Asynchronous programming and concurrency
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 异步编程和并发
- en: Different platforms have different programming models. For instance, JavaScript
    applications are single-threaded and have an event loop. When making a network
    call, it is common to register a callback that will be invoked at a later stage,
    when that network call completes either successfully or with an error.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 不同的平台有不同的编程模型。例如，JavaScript 应用程序是单线程的，并且有一个事件循环。在发起网络调用时，通常会在稍后阶段注册一个回调，当网络调用成功或出错时会被调用。
- en: In contrast, when we're on the JVM, we can take full advantage of multithreading
    to achieve concurrency. It is simple to spawn new threads via one of the many
    concurrency primitives provided by Clojure, such as futures.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 与此相反，当我们处于 JVM 上时，我们可以充分利用多线程来实现并发。通过 Clojure 提供的许多并发原语之一（如 futures）来创建新线程非常简单。
- en: 'However, asynchronous programming becomes cumbersome. Clojure futures don''t
    provide a native way for us to be notified of their completion at a later stage.
    In addition, retrieving values from a not-yet-completed future is a blocking operation.
    This can be seen clearly in the following snippet:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，异步编程变得繁琐。Clojure futures 没有提供一种原生的方式让我们在稍后阶段通知它们的完成。此外，从尚未完成的 future 中检索值是一个阻塞操作。这可以在以下代码片段中清楚地看到：
- en: '[PRE0]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The second call to print dereferences the future, causing the main thread to
    block since it hasn't finished yet. This is why you only see the last print after
    the thread in which the future is running has finished. Callbacks can, of course,
    be simulated by spawning a separate thread to monitor the first one, but this
    solution is clunky at best.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 第二次调用打印时，会取消引用 future，由于它尚未完成，这导致主线程阻塞。这就是为什么只有在 future 运行的线程完成后，你才会看到最后的打印。当然，可以通过为第一个线程创建一个单独的线程来模拟回调，但这个解决方案最多是笨拙的。
- en: An exception to the lack of callbacks is GUI programming in Clojure. Much like
    JavaScript, Clojure Swing applications also possess an event loop and can respond
    to user input and invoke listeners (callbacks) to handle them.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Clojure 中，GUI 编程是缺乏回调的例外。与 JavaScript 类似，Clojure Swing 应用程序也拥有事件循环，可以响应用户输入并调用监听器（回调）来处理它们。
- en: 'Another option is rewriting the previous example with a custom callback that
    is passed into the future:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个选项是用一个传递给 future 的自定义回调重写前面的示例：
- en: '[PRE1]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This time the order of the outputs should make more sense. However, if we return
    the future from this function, we have no way to give it another callback. We
    have lost the ability to perform an action when the future ends and are back to
    having to dereference it, thus blocking the main thread again—exactly what we
    wanted to avoid.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 这次输出的顺序应该更有意义。然而，如果我们从这个函数返回 future，我们就无法给它另一个回调。我们失去了在 future 结束时执行操作的能力，又回到了必须取消引用它，从而再次阻塞主线程——这正是我们想要避免的。
- en: Tip
  id: totrans-18
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Java 8 introduces a new class, `CompletableFuture`, that allows registering
    a callback to be invoked once the future completes. If that's an option for you,
    you can use interop to make Clojure leverage the new class.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: Java 8引入了一个新的类，`CompletableFuture`，它允许注册一个在完成时被调用的回调。如果你有这个选项，你可以使用互操作来让Clojure利用这个新类。
- en: 'As you might have realized, CES is closely related to asynchronous programming:
    the stock market application we built in the previous chapter is an example of
    such a program. The main—or UI—thread is never blocked by the Observables fetching
    data from the network. Additionally, we were also able to register callbacks when
    subscribing to them.'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所意识到的那样，CES（Continuous Event Stream）与异步编程密切相关：我们在上一章中构建的股票市场应用就是一个这样的程序示例。主线程（或UI线程）永远不会因为从网络获取数据而阻塞。此外，我们还在订阅时注册了回调。
- en: In many asynchronous applications, however, callbacks are not the best way to
    go. Heavy use of callbacks can lead to what is known as callback hell. Clojure
    provides a more powerful and elegant solution.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在许多异步应用程序中，回调并不是最佳选择。过度使用回调可能导致所谓的回调地狱。Clojure提供了一个更强大、更优雅的解决方案。
- en: In the next few sections, we will explore `core.async`, a Clojure library for
    asynchronous programming, and how it relates to Reactive Programming.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的几节中，我们将探讨`core.async`，这是一个用于异步编程的Clojure库，以及它与响应式编程的关系。
- en: core.async
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: core.async
- en: 'If you''ve ever done any amount of JavaScript programming, you have probably
    experienced callback hell. If you haven''t, the following code should give you
    a good idea:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你曾经进行过任何数量的JavaScript编程，你可能已经经历过回调地狱。如果你没有，以下代码应该能给你一个很好的概念：
- en: '[PRE2]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This style of programming can easily get out of hand—instead of writing more
    natural, sequential steps to achieving a task, that logic is instead scattered
    across multiple callbacks, increasing the developer's cognitive load.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 这种编程风格很容易失控——不是编写更自然、顺序的步骤来实现任务，而是将逻辑分散到多个回调中，增加了开发者的认知负担。
- en: In response to this issue, the JavaScript community released several promises
    libraries that are meant to solve the issue. We can think of promises as empty
    boxes we can pass into and return from our functions. At some point in the future,
    another process might put a value inside this box.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 作为对这个问题的回应，JavaScript社区发布了几个承诺库，旨在解决这个问题。我们可以将承诺视为我们可以传递到和从我们的函数中返回的空盒子。在未来的某个时刻，另一个进程可能会在这个盒子里放入一个值。
- en: 'As an example, the preceding snippet can be written with promises like the
    following:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，前面的片段可以用以下承诺来编写：
- en: '[PRE3]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '[PRE4]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'As we tend to think in sequences of steps, however, we would like to write
    the following:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，由于我们倾向于按步骤序列思考，我们希望编写以下内容：
- en: '[PRE5]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Even though the code looks synchronous, the behavior should be no different
    from the previous examples. This is exactly what `core.async` lets us do in both
    Clojure and ClojureScript.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管代码看起来是同步的，但行为应该与前面的示例没有不同。这正是`core.async`让我们在Clojure和ClojureScript中都能做到的。
- en: Communicating sequential processes
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通信顺序过程
- en: The `core.async` library is built on an old idea. The foundation upon which
    it lies was first described by Tony Hoare—of Quicksort fame—in his 1978 paper
    *Communicating Sequential Processes* (*CSP*; see [http://www.cs.ucf.edu/courses/cop4020/sum2009/CSP-hoare.pdf](http://www.cs.ucf.edu/courses/cop4020/sum2009/CSP-hoare.pdf)).
    CSP has since been extended and implemented in several languages, the latest of
    which being Google's **Go** programming language.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '`core.async`库建立在旧想法之上。它所依赖的基础最初由Tony Hoare——著名的快速排序算法的发明者——在他的1978年论文《通信顺序过程》（*Communicating
    Sequential Processes*，简称CSP）中描述。（见[http://www.cs.ucf.edu/courses/cop4020/sum2009/CSP-hoare.pdf](http://www.cs.ucf.edu/courses/cop4020/sum2009/CSP-hoare.pdf)）。CSP自那时以来已在几种语言中得到扩展和实现，其中最新的是Google的**Go**编程语言。'
- en: It is beyond the scope of this book to go into the details of this seminal paper,
    so what follows is a simplified description of the main ideas.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 本书的范围不包括深入探讨这篇开创性论文的细节，因此以下是对主要思想的简化描述。
- en: 'In CSP, work is modeled using two main abstractions: channels and processes.
    CSP is also message-driven and, as such, it completely decouples the producer
    from the consumer of the message. It is useful to think of channels as blocking
    queues.'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在CSP（Communicating Sequential Processes）中，工作是通过两种主要抽象来建模的：通道和进程。CSP也是消息驱动的，因此它完全解耦了消息的生产者和消费者。将通道视为阻塞队列是有用的。
- en: 'A simplistic approach demonstrating these basic abstractions is as follows:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个展示这些基本抽象的简单方法：
- en: '[PRE6]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Running this code in the REPL should show us output similar to the following:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在REPL中运行此代码应该会显示类似于以下内容的输出：
- en: '[PRE7]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: In order not to block our program, we start both the consumer and the producer
    in their own threads using a future. Since the consumer was started first, we
    most likely will see its output immediately. However, as soon as it attempts to
    take a value from the channel—or queue—it will block. It will wait for a value
    to become available and will only proceed after the producer is done taking its
    nap—clearly a very important task.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 为了不阻塞我们的程序，我们使用一个未来在每个自己的线程中启动消费者和生成者。由于消费者首先启动，我们很可能会立即看到其输出。然而，一旦它尝试从通道或队列中获取值，它就会阻塞。它将等待值变得可用，并且只有在生成者完成其小憩后才会继续——显然这是一个非常重要的任务。
- en: 'Now, let''s compare it with a solution using core.async. First, create a new
    leiningen project and add a dependency on it:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们将其与使用 core.async 的解决方案进行比较。首先，创建一个新的 leiningen 项目并添加对其的依赖：
- en: '[PRE8]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Now, type this in the REPL or in your core namespace:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在REPL或你的核心命名空间中输入以下内容：
- en: '[PRE9]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'This time we are using a helper function, `prn-with-thread-id`, which appends
    the current thread ID to the output string. I will explain why shortly, but apart
    from that, the output will have been equivalent to the previous one:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 这次我们使用了一个辅助函数，`prn-with-thread-id`，它将当前线程ID附加到输出字符串中。我很快就会解释原因，但除此之外，输出将与之前的一个相同：
- en: '[PRE10]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Structurally, both solutions look fairly similar, but since we are using quite
    a few new functions here, let''s break it down:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 从结构上看，这两个解决方案看起来相当相似，但由于我们在这里使用了相当多的新函数，让我们将其分解：
- en: '`chan` is a function that creates a `core.async` channel. As mentioned previously,
    it can be thought of as a concurrent blocking queue and is the main abstraction
    in the library. By default `chan` creates an unbounded channel, but `core.async`
    provides many more useful channel constructors, a few of which we''ll be using
    later.'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`chan` 是一个创建 `core.async` 通道的函数。如前所述，它可以被视为一个并发阻塞队列，并且是库中的主要抽象。默认情况下 `chan`
    创建一个无界通道，但 `core.async` 提供了许多更多有用的通道构造函数，其中一些我们将在稍后使用。'
- en: '`timeout` is another such channel constructor. It gives us a *channel* that
    will *wait* for a given amount of time before returning nil to the taking process,
    closing itself immediately afterward. This is the `core.async` equivalent of **Thread/sleep**.'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`timeout` 是另一个这样的通道构造函数。它给我们一个会在返回nil给获取进程之前等待给定时间的通道，并在之后立即关闭自己。这是 `core.async`
    中 **Thread/sleep** 的等效函数。'
- en: The functions `>!` and `<!` are used to put and take values from a channel,
    respectively. The caveat is that they have to be used inside a `go` block, as
    we will explain later.
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数 `>!` 和 `<!` 分别用于向通道中放入和从通道中取出值。需要注意的是，它们必须在使用 `go` 块的内部使用，正如我们稍后将要解释的。
- en: '`go` is a macro that takes a body of expressions—which form a `go` block—and
    creates lightweight processes. This is where the magic happens. Inside a `go`
    block, any calls to `>!` and `<!` that would ordinarily block waiting for values
    to be available in channels are instead parked. Parking is a special type of blocking
    used internally in the state machine of `core.async`. The blog post by Huey Petersen
    covers this state machine in depth (see [http://hueypetersen.com/posts/2013/08/02/the-state-machines-of-core-async/](http://hueypetersen.com/posts/2013/08/02/the-state-machines-of-core-async/)).'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`go` 是一个宏，它接受一个表达式体——形成一个 `go` 块——并创建轻量级进程。这就是魔法发生的地方。在 `go` 块内部，任何调用 `>!`
    和 `<!` 以等待通道中可用值的操作都会被挂起。挂起是 `core.async` 状态机内部使用的特殊类型的阻塞。Huey Petersen 的博客文章深入探讨了这一状态机（见
    [http://hueypetersen.com/posts/2013/08/02/the-state-machines-of-core-async/](http://hueypetersen.com/posts/2013/08/02/the-state-machines-of-core-async/)）。'
- en: Go blocks are the very reason for which I chose to print the thread IDs in our
    example. If we look closely, we'll realize that the last two statements were executed
    in the same thread—this isn't true 100 percent of the time as concurrency is inherently
    non-deterministic. This is a fundamental difference between `core.async` and solutions
    using threads/futures.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: Go 块正是我选择在我们的示例中打印线程ID的原因。如果我们仔细观察，我们会意识到最后两个语句是在同一个线程中执行的——这并不总是100%正确，因为并发本质上是非确定性的。这是
    `core.async` 与使用线程/未来的解决方案之间的基本区别。
- en: Threads can be expensive. On the JVM, their default stack size is 512 kilobytes—configurable
    via the `-Xss` JVM startup option. When developing a highly concurrent system,
    creating thousands of threads can quickly drain the resources of the machine the
    application is running on.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 线程可能很昂贵。在JVM上，它们的默认堆栈大小是512千字节——可以通过`-Xss` JVM启动选项进行配置。在开发高度并发的系统时，创建数千个线程可以迅速耗尽应用程序运行的机器的资源。
- en: '`core.async` acknowledges this limitation and gives us lightweight processes.
    Internally, they do share a thread pool, but instead of wastefully creating a
    thread per go block, threads are recycled and reused when a put/take operation
    is waiting for a value to become available.'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '`core.async`承认了这个限制，并为我们提供了轻量级进程。内部，它们确实共享一个线程池，但与为每个go块无谓地创建一个线程不同，当put/take操作等待一个值变得可用时，线程会被回收和重用。'
- en: Tip
  id: totrans-57
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: At the time of writing, the thread pool used by `core.async` defaults to the
    number of available processors x 2, + 42\. So, a machine with eight processors
    will have a pool with 58 threads.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本文时，`core.async`使用的线程池默认为可用处理器的数量乘以2，加42。因此，具有八个处理器的机器将有一个包含58个线程的池。
- en: Therefore, it is common for `core.async` applications to have dozens of thousands
    of lightweight processes. They are extremely cheap to create.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，对于`core.async`应用程序来说，拥有数万个轻量级进程是很常见的。它们创建起来非常便宜。
- en: 'Since this is a book on Reactive Programming, the question that might be in
    your head now is: can we build reactive applications using `core.async`? The short
    answer is yes, we can! To prove it, we will revisit our stock market application
    and rewrite it using `core.async`.'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这是一本关于响应式编程的书，你现在可能心中会有的问题是：我们能否使用`core.async`构建响应式应用程序？简短的答案是：是的，我们可以！为了证明这一点，我们将重新审视我们的股票市场应用程序，并使用`core.async`重写它。
- en: Rewriting the stock market application with core.async
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用core.async重写股票市场应用
- en: By using an example we are familiar with, we are able to focus on the differences
    between all approaches discussed so far, without getting side tracked with new,
    specific domain rules.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用我们熟悉的例子，我们能够专注于迄今为止讨论的所有方法之间的差异，而不会因为新的、具体的领域规则而分心。
- en: Before we dive into the implementation, let's quickly do an overview of how
    our solution should work.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入实施之前，让我们快速概述一下我们的解决方案应该如何工作。
- en: Just like in our previous implementations, we have a service from which we can
    query share prices. Where our approach differs, however, is a direct consequence
    of how `core.async` channels work.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们之前的实现一样，我们有一个可以查询股票价格的服务。然而，我们的方法的不同之处是一个直接的后果，即`core.async`通道的工作方式。
- en: 'On a given schedule, we would like to write the current price to a `core.async`
    channel. This might look like so:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在给定的计划中，我们希望将当前价格写入`core.async`通道。这可能看起来是这样的：
- en: '![Rewriting the stock market application with core.async](img/00014.jpeg)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![使用core.async重写股票市场应用](img/00014.jpeg)'
- en: 'This process will continuously put prices in the `out` channel. We need to
    do two things with each price: display it and display the calculated sliding window.
    Since we like our functions decoupled, we will use two `go` blocks, one for each
    task:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 此过程将持续将价格放入`out`通道。对于每个价格，我们需要做两件事：显示它并显示计算出的滑动窗口。由于我们喜欢我们的函数解耦，我们将使用两个`go`块，一个用于每个任务：
- en: '![Rewriting the stock market application with core.async](img/00015.jpeg)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
  zh: '![使用core.async重写股票市场应用](img/00015.jpeg)'
- en: Hold on. There seems to be something off with our approach. Once we take a price
    from the output channel, it is not available any longer to be taken by other go
    blocks, so, instead of calculating the sliding window starting with 10, our function
    ends up getting the second value, 20\. With this approach, we will end up with
    a sliding window that calculates a sliding window with roughly every other item,
    depending on how consistent the interleaving between the go blocks is.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 等一下。我们的方法似乎有些不对劲。一旦我们从输出通道中取出一个价格，它就不再可用，无法被其他go块获取，因此，我们的函数最终得到的是第二个值，20。使用这种方法，我们将得到一个大约每隔一个项目计算滑动窗口的滑动窗口，这取决于go块之间的交织程度是否一致。
- en: Clearly, this is not what we want, but it helps us think about the problem a
    little more. The semantics of `core.async` prevent us from reading a value from
    a channel more than once. Most of the time, this behavior is just fine—especially
    if you think of them as queues. So how can we provide the same value to both functions?
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，这并不是我们想要的，但它有助于我们更深入地思考问题。`core.async`的语义阻止我们从通道中读取值超过一次。大多数时候，这种行为都是可以接受的——尤其是如果你把它们看作队列的话。那么我们如何为两个函数提供相同的值呢？
- en: 'To solve this problem, we will take advantage of another channel constructor
    provided by `core.async` called `broadcast`. As the name implies, `broadcast`
    returns a channel, which, when written to, writes its value into the channels
    passed to it as arguments. Effectively, this changes our high-level picture to
    something like the following:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，我们将利用`core.async`提供的另一个通道构造函数，称为`broadcast`。正如其名所示，`broadcast`返回一个通道，当写入时，将其值写入作为参数传递给它的通道。实际上，这改变了我们的高级图示，如下所示：
- en: '![Rewriting the stock market application with core.async](img/00016.jpeg)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![用core.async重写股票市场应用程序](img/00016.jpeg)'
- en: 'In summary, we will have a go loop writing prices to this broadcast channel,
    which will then forward its values to the two channels from which we will be operating:
    prices and the sliding window.'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，我们将尝试将价格写入这个广播通道，然后它将把其值转发到我们将从中操作的两个通道：价格和滑动窗口。
- en: With the general idea in place, we are ready to dive into the code.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在确立了总体思路之后，我们就可以深入代码了。
- en: Implementing the application code
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现应用程序代码
- en: 'We already have a project depending on `core.async` that we created in the
    previous section, so we''ll be working off that. Let''s start by adding an extra
    dependency on seesaw to your `project.clj` file:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在上一节中创建了一个依赖于`core.async`的项目，所以我们将基于那个项目进行工作。让我们首先在`project.clj`文件中添加对seesaw的额外依赖项：
- en: '[PRE11]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Next, create a file called `stock_market.clj` in the `src` directory and add
    this namespace declaration:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在`src`目录中创建一个名为`stock_market.clj`的文件，并添加以下命名空间声明：
- en: '[PRE12]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This might be a good point to restart your REPL if you haven't done so. Don't
    worry about any functions we haven't seen yet. We'll get a feel for them in this
    section.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您还没有这样做，现在可能是重启您的REPL的好时机。不用担心我们还没有看到的任何函数。在本节中，我们将了解它们。
- en: 'The GUI code remains largely unchanged, so no explanation should be necessary
    for the next snippet:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: GUI代码基本保持不变，所以对于下一个代码片段不需要解释：
- en: '[PRE13]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The only difference is that now we have a `sliding-buffer` function that returns
    a window of data. This is in contrast with our original application, where the
    `rolling-avg` function was responsible for both creating the window and calculating
    the average. This new design is more general as it makes this function easier
    to reuse. The sliding logic is the same, however.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 唯一的不同之处在于，我们现在有一个返回数据窗口的`sliding-buffer`函数。这与我们的原始应用形成对比，在原始应用中，`rolling-avg`函数负责创建窗口并计算平均值。这种新的设计更通用，因为它使得这个函数更容易重用。滑动逻辑仍然是相同的。
- en: 'Next, we have our main application logic using `core.async`:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们有使用`core.async`的主应用程序逻辑：
- en: '[PRE14]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Let's walk through the code.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们一步步地看代码。
- en: 'The first function, `broadcast-at-interval`, is responsible for creating the
    broadcasting channel. It receives a variable number of arguments: a number of
    milliseconds describing the interval, the function representing the task to be
    executed, and a sequence of one of more output channels. These channels are used
    to create the broadcasting channel to which the go loop will be writing prices.'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个函数`broadcast-at-interval`负责创建广播通道。它接收一个变量数量的参数：描述间隔的毫秒数，表示要执行的任务的函数，以及一个输出通道的序列。这些通道用于创建广播通道，go循环将向其中写入价格。
- en: 'Next, we have our main function. The `let` block is where the interesting bits
    are. As we discussed in our high-level diagrams, we need two output channels:
    one for prices and one for the sliding window. They are both created in the following:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，是我们的主函数。`let`块是其中有趣的部分。正如我们在高级图中讨论的那样，我们需要两个输出通道：一个用于价格，一个用于滑动窗口。它们都在以下内容中创建：
- en: '[PRE15]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '`prices-ch` should be self-explanatory; however, `sliding-buffer-ch` is using
    a function we haven''t encountered before: `map>`. This is yet another useful
    channel constructor in `core.async`. It takes two arguments: a function and a
    target channel. It returns a channel that applies this function to each value
    before writing it to the target channel. An example will help illustrate how it
    works:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '`prices-ch` 应该是显而易见的；然而，`sliding-buffer-ch` 使用了一个我们之前未曾遇到过的函数：`map>`。这又是 `core.async`
    中另一个有用的通道构造器。它接受两个参数：一个函数和一个目标通道。它返回一个通道，在将值写入目标通道之前，将此函数应用于每个值。一个例子将有助于说明它是如何工作的：'
- en: '[PRE16]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: That is, we write a price to the channel and get a sliding window on the other
    end. Finally, we create the two go blocks containing the side effects. They loop
    indefinitely, getting values from both channels and updating the user interface.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 也就是说，我们将一个价格写入通道，并在另一端得到一个滑动窗口。最后，我们创建了包含副作用的两块 go 块。它们无限循环，从两个通道中获取值并更新用户界面。
- en: 'You can see it in action by running the program from the terminal:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过在终端运行程序来看到它的实际效果：
- en: '[PRE17]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Error handling
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 错误处理
- en: Back in [Chapter 2](part0021_split_000.html#page "Chapter 2. A Look at Reactive
    Extensions"), *A Look at Reactive Extensions*, we learned how Reactive Extensions
    treats errors and exceptions. It provides a rich set of combinators to deal with
    exceptional cases and are straightforward to use.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 回到 [第 2 章](part0021_split_000.html#page "第 2 章。查看反应式扩展")，我们学习了反应式扩展如何处理错误和异常。它提供了一套丰富的组合器来处理异常情况，并且使用起来非常简单。
- en: Despite being a pleasure to work with, `core.async` doesn't ship with much support
    for exception handling. In fact, if we write our code with only the happy path
    in mind we don't even know an error occurred!
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管与 `core.async` 一起工作是一种乐趣，但它并没有提供很多异常处理的支持。事实上，如果我们只考虑愉快的路径来编写代码，我们甚至不知道发生了错误！
- en: 'Let''s have a look at an example:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个例子：
- en: '[PRE18]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '[PRE19]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Let''s watch what happens when we put this together:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看当我们把它们放在一起会发生什么：
- en: '[PRE20]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Nothing happens. Zero, zip, zilch, nada.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 没有发生任何事情。零，零，什么都没有，什么也没有。
- en: 'This is precisely the problem with error handling in `core.async`: by default,
    our exceptions are swallowed by the go block as it runs on a separate thread.
    We are left in this state where we don''t really know what happened.'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 这正是 `core.async` 中错误处理的问题：默认情况下，我们的异常被 go 块吞没，因为它在单独的线程上运行。我们处于这种状态，实际上并不知道发生了什么。
- en: Not all is lost, however. David Nolen outlined on his blog a pattern for dealing
    with such asynchronous exceptions. It only requires a few extra lines of code.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，并非所有都失去了。David Nolen 在他的博客上概述了一种处理此类异步异常的模式。它只需要几行额外的代码。
- en: 'We start by defining a helper function and macro—this would probably live in
    a utility namespace we require anywhere we use `core.async`:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先定义一个辅助函数和宏——这可能会存在于我们使用 `core.async` 的任何地方的实用命名空间中：
- en: '[PRE21]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The `throw-err` function receives a value and, if it's a subclass of `Throwable`,
    it is thrown. Otherwise, it is simply returned.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '`throw-err` 函数接收一个值，如果它是一个 `Throwable` 的子类，它就会被抛出。否则，它只是简单地返回。'
- en: The macro `<?` is essentially a drop-in replacement for `<!`. In fact, it uses
    `<!` to get the value out of the channel but passes it to `throw-err` first.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 宏 `<?` 实质上是 `<!` 的直接替代品。事实上，它使用 `<!` 从通道中获取值，但首先将其传递给 `throw-err`。
- en: 'With these utilities in place, we need to make a couple of changes, first to
    our `process` function:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在有了这些实用工具之后，我们需要对我们的 `process` 函数做一些更改：
- en: '[PRE22]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The only change is that we wrapped `get-data` in a `try`/`catch` block. Look
    closely at the `catch` block: it simply returns the exception.'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 唯一的改变是我们将 `get-data` 包裹在一个 `try`/`catch` 块中。仔细看看 `catch` 块：它只是返回异常。
- en: This is important as we need to ensure the exception gets put into the channel.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 这很重要，因为我们需要确保异常被放入通道中。
- en: 'Next, we update our consumer code:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们更新我们的消费者代码：
- en: '[PRE23]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: This time we use `<?` in place of `<!`. This makes sense as it will rethrow
    any exceptions found in the channel. As a result we can now use a simple `try`/`catch`
    to regain control over our exceptions.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 这次我们用 `<?` 代替 `<!`。这很有意义，因为它会重新抛出通道中发现的任何异常。因此，我们现在可以使用简单的 `try`/`catch` 来重新控制我们的异常。
- en: Backpressure
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 [第 2 章](part0021_split_000.html#page "第 2 章。查看反应式扩展") 中，我们学习了反应式扩展如何处理错误和异常。它提供了一套丰富的组合器来处理异常情况，并且使用起来非常简单。
- en: The main mechanism by which `core.async` allows for coordinating backpressure
    is buffering. `core.async` doesn't allow unbounded buffers as this can be a source
    of bugs and a resource hog.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '`core.async` 允许协调背压的主要机制是缓冲。`core.async` 不允许无界缓冲，因为这可能是错误和资源消耗的来源。'
- en: Instead, we are required to think hard about our application's unique needs
    and choose an appropriate buffering strategy.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，我们必须深入思考我们应用程序的独特需求，并选择一个合适的缓冲策略。
- en: Fixed buffer
  id: totrans-120
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 固定缓冲区
- en: 'This is the simplest form of buffering. It is fixed to a chosen number `n`,
    allowing producers to put items in the channel without having to wait for consumers:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 这是最简单的缓冲形式。它固定为选择的数字`n`，允许生产者在不需要等待消费者的情况下将项目放入通道：
- en: '[PRE24]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: In the preceding example, we created a buffer of size `5` and started a `go`
    loop to consume values from it. The `go` loop uses a `timeout` channel to delay
    its start.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们创建了一个大小为`5`的缓冲区，并启动了一个`go`循环来消费其中的值。`go`循环使用一个`timeout`通道来延迟其启动。
- en: Then, we start another go block that puts numbers from 0 to 4 into the result
    channel and prints to the console once it's done.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们开始另一个go块，将数字从0到4放入结果通道，并在完成后打印到控制台。
- en: By then, the first timeout will have expired and we will see the values printed
    to the REPL.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 到那时，第一个超时将已过期，我们将看到值打印到REPL。
- en: 'Now let''s watch what happens if the buffer isn''t large enough:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来看看如果缓冲区不够大会发生什么：
- en: '[PRE25]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: This time our buffer size is `2` but everything else is the same. As you can
    see the `go` loop finishes much later as it attempted to put another value in
    the result channel and was blocked/parked since its buffer was full.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 这次我们的缓冲区大小是`2`，但其他一切都是相同的。正如你所看到的，`go`循环完成得晚得多，因为它试图将另一个值放入结果通道，但由于其缓冲区已满而被阻塞/暂停。
- en: As with most things, this might be OK but if we are not willing to block a fast
    producer just because we can't consume its items fast enough, we must look for
    another option.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 与大多数事情一样，这可能没问题，但如果我们不打算阻塞一个快速的生产者，仅仅因为我们不能快速消费其项目，我们必须寻找另一个选项。
- en: Dropping buffer
  id: totrans-130
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 丢弃缓冲区
- en: 'A dropping buffer also has a fixed size. However, instead of blocking producers
    when it is full, it simply ignores any new items as shown here:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 丢弃缓冲区也有一个固定的大小。然而，当它满时，它不会阻塞生产者，而是简单地忽略任何新的项目，如下所示：
- en: '[PRE26]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: As before, we still have a buffer of size two, but this time the producer ends
    quickly without ever getting blocked. The `dropping-buffer` simply ignored all
    items over its limit.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，我们仍然有一个大小为二的缓冲区，但这次生产者迅速结束，从未被阻塞。`dropping-buffer`简单地忽略了所有超出其限制的项目。
- en: Sliding buffer
  id: totrans-134
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 滑动缓冲区
- en: 'A drawback of dropping buffers is that we might not be processing the latest
    items at a given time. For the times where processing the latest information is
    a must, we can use a sliding buffer:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 丢弃缓冲区的缺点是，我们可能不会在给定时间处理最新的项目。对于必须处理最新信息的情况，我们可以使用滑动缓冲区：
- en: '[PRE27]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: As before, we only get two values but they are the latest ones produced by the
    `go` loop.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，我们只得到两个值，但它们是`go`循环产生的最新值。
- en: When the limit of the sliding buffer is overrun, `core.async` drops the oldest
    items to make room for the newest ones. I end up using this buffering strategy
    most of the time.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 当滑动缓冲区的限制被超过时，`core.async`会丢弃最旧的项目以腾出空间给最新的项目。我大多数时候都使用这种缓冲策略。
- en: Transducers
  id: totrans-139
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 转换器
- en: Before we finish up with our `core.async` portion of the book, it would be unwise
    of me not to mention what is coming up in Clojure 1.7 as well as how this affects
    `core.async`.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们完成本书的`core.async`部分之前，不提及Clojure 1.7中即将出现的内容以及这对`core.async`的影响是不明智的。
- en: At the time of this writing, Clojure's latest release is `1.7.0-alpha5`—and
    even though it is an alpha release, a lot of people—myself included—are already
    using it in production.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本文时，Clojure的最新版本是`1.7.0-alpha5`——尽管它是一个alpha版本，但包括我在内的大量人已经在生产中使用它。
- en: As such, a final version could be just around the corner and perhaps by the
    time you read this, 1.7 final will be out already.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，最终版本可能就在眼前，也许在你阅读这篇文章的时候，1.7最终版可能已经发布。
- en: One of the big changes in this upcoming release is the introduction of `transducers`.
    We will not cover the nuts and bolts of it here but rather focus on what it means
    at a high-level with examples using both Clojure sequences and `core.async` channels.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在即将发布的版本中，最大的变化是引入了`transducers`。我们不会在这里介绍它的细节，而是将重点放在使用Clojure序列和`core.async`通道的示例中的高层次含义上。
- en: If you would like to know more I recommend Carin Meier's *Green Eggs and Transducers*
    blog post ([http://gigasquidsoftware.com/blog/2014/09/06/green-eggs-and-transducers/](http://gigasquidsoftware.com/blog/2014/09/06/green-eggs-and-transducers/)).
    It's a great place to start.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想了解更多，我推荐Carin Meier的*绿色鸡蛋和转换器*博客文章([http://gigasquidsoftware.com/blog/2014/09/06/green-eggs-and-transducers/](http://gigasquidsoftware.com/blog/2014/09/06/green-eggs-and-transducers/))。这是一个很好的起点。
- en: Additionally, the official Clojure documentation site on the subject is another
    useful resource ([http://clojure.org/transducers](http://clojure.org/transducers)).
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，关于该主题的官方 Clojure 文档网站也是一个有用的资源 ([http://clojure.org/transducers](http://clojure.org/transducers))。
- en: 'Let''s get started by creating a new leiningen project:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从创建一个新的 leiningen 项目开始：
- en: '[PRE28]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Now, open your `project.clj` file and make sure you have the right dependencies:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，打开你的 `project.clj` 文件，确保你有正确的依赖项：
- en: '[PRE29]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Next, fire up a REPL session in the project root and require `core.async`,
    which we will be using shortly:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在项目根目录中启动一个 REPL 会话并引入 `core.async`，我们很快就会用到它：
- en: '[PRE30]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'We will start with a familiar example:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从一个熟悉的例子开始：
- en: '[PRE31]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '[PRE32]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Starting in Clojure 1.7, the previous example can be written like so:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 从 Clojure 1.7 版本开始，之前的例子可以写成这样：
- en: '[PRE33]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The Clojure documentation describes transducers as composable algorithmic transformations.
    Let's see why that is.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: Clojure 文档将转换器描述为可组合的算法转换。让我们看看为什么是这样。
- en: 'In the new version, a whole range of the core sequence combinators, such as
    `map` and `filter`, have gained an extra arity: if you don''t pass it a collection,
    it instead returns a transducer.'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在新版本中，一系列核心序列组合器，如 `map` 和 `filter`，增加了一个额外的参数：如果你不传递一个集合，它将返回一个转换器。
- en: In the previous example, `(map inc)` returns a transducer that knows how to
    apply the function `inc` to elements of a sequence. Similarly, `(filter even?)`
    returns a transducer that will eventually filter elements of a sequence. Neither
    of them do anything yet, they simply return functions.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的例子中，`(map inc)` 返回一个知道如何将函数 `inc` 应用到序列元素上的转换器。同样，`(filter even?)` 返回一个最终将过滤序列元素的转换器。它们目前都不做任何事情，它们只是返回函数。
- en: 'This is interesting because transducers are composable. We build larger and
    more complex transducers by using simple function composition:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 这很有趣，因为转换器是可组合的。我们通过使用简单的函数组合来构建更大、更复杂的转换器：
- en: '[PRE34]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Once we have our transducer ready, we can apply it to a collection in a few
    different ways. For this example, we chose `sequence` as it will return a lazy
    sequence of the applications of the given transducer to the input sequence:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们有了转换器，我们可以以几种不同的方式将其应用于集合。在这个例子中，我们选择了 `sequence`，因为它将返回一个给定的转换器对输入序列应用后的惰性序列：
- en: '[PRE35]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: As previously highlighted, this code does not create intermediate sequences;
    transducers extract the very core of the algorithmic transformation at hand and
    abstracts it away from having to deal with sequences directly.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，此代码不会创建中间序列；转换器提取当前算法转换的核心，并将其从直接处理序列中抽象出来。
- en: Transducers and core.async
  id: totrans-165
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 转换器和 core.async
- en: We might now be asking ourselves "What do transducers have to do with `core.async`?"
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可能正在问自己：“转换器与 `core.async` 有什么关系？”
- en: It turns out that once we're able to extract the core of these transformations
    and put them together using simple function composition, there is nothing stopping
    us from using transducers with data structures other than sequences!
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 结果表明，一旦我们能够提取这些转换的核心并使用简单的函数组合将它们组合起来，就没有什么可以阻止我们使用转换器与除了序列之外的数据结构！
- en: 'Let''s revisit our first example using standard `core.async` functions:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾一下我们第一个例子，使用标准的 `core.async` 函数：
- en: '[PRE36]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'This code should look familiar by now: it''s the `core.async` equivalent of
    the sequence-only version shown earlier. As before, we have unnecessary allocations
    here as well, except that this time we''re allocating channels.'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码现在应该看起来很熟悉了：它是之前展示的仅序列版本的 `core.async` 等价物。和之前一样，我们这里也有不必要的分配，只是这次我们分配的是通道。
- en: 'With the new support for transducers, `core.async` can take advantage of the
    same transformation defined earlier:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 新增对转换器的支持后，`core.async` 可以利用之前定义的相同转换：
- en: '[PRE37]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: The code remains largely unchanged except we now use the same `xform` transformation
    defined earlier when creating a new channel. It's important to note that we did
    not have to use `core.async` combinators—in fact a lot of these combinators have
    been deprecated and will be removed in future versions of `core.async`.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 代码基本保持不变，除了我们现在在创建新通道时使用之前定义的相同 `xform` 转换。需要注意的是，我们不必使用 `core.async` 组合器——实际上，很多这些组合器已经被弃用，并将在未来版本的
    `core.async` 中被移除。
- en: The functions `map` and `filter` used to define `xform` are the same ones we
    used previously, that is, they are core Clojure functions.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 用于定义 `xform` 的函数 `map` 和 `filter` 与我们之前使用的相同，即它们是核心 Clojure 函数。
- en: 'This is the next big advantage of using transducers: by removing the underlying
    data structure from the equation via transducers, libraries such as `core.async`
    can reuse Clojure''s core combinators to prevent unnecessary allocation and code
    duplication.'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 这是使用transducers的下一个重大优势：通过transducers从等式中移除底层数据结构，库如`core.async`可以重用Clojure的核心组合器，以防止不必要的分配和代码重复。
- en: 'It''s not too far fetched to imagine other frameworks like RxClojure could
    take advantage of transducers as well. All of them would be able to use the same
    core function across substantially different data structures and contexts: sequences,
    channels, and Obervables.'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 想象其他框架，如RxClojure，也能利用transducers，这并不太过分。所有这些框架都能够跨不同数据结构和上下文（序列、通道和Obervables）使用相同的核心函数。
- en: Tip
  id: totrans-177
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: The concept of extracting the essence of computations disregarding their underlying
    data structures is an exciting topic and has been seen before in the Haskell community,
    although they deal with lists specifically.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 提取计算本质的概念，不考虑其底层数据结构，是一个令人兴奋的话题，在Haskell社区中也曾出现过，尽管他们具体处理的是列表。
- en: Two papers worth mentioning on the subject are *Stream Fusion* [11] by Duncan
    Coutts, Roman Leshchinskiy and Don Stewart and *Transforming programs to eliminate
    trees* [12] by Philip Wadler. There are some overlaps so the reader might find
    these interesting.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 关于这个主题，有两篇值得提及的论文是Duncan Coutts、Roman Leshchinskiy和Don Stewart的*Stream Fusion*
    [11]以及Philip Wadler的*Transforming programs to eliminate trees* [12]。它们有一些重叠，所以读者可能会觉得这些很有趣。
- en: Summary
  id: totrans-180
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: By now, I hope to have proved that you can write reactive applications using
    `core.async`. It's an extremely powerful and flexible concurrency model with a
    rich API. If you can design your solution in terms of queues, most likely `core.async`
    is the tool you want to reach for.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 到现在为止，我希望我已经证明了你可以使用`core.async`编写响应式应用。这是一个极其强大且灵活的并发模型，拥有丰富的API。如果你能以队列的形式设计你的解决方案，那么`core.async`很可能是你想要使用的工具。
- en: This version of the stock market application is shorter and simpler than the
    version using only the standard Java API we developed earlier in this book—for
    instance, we didn't have to worry about thread pools. On the other hand, it feels
    like it is a little more complex than the version implemented using Reactive Extensions
    in [Chapter 3](part0028_split_000.html#page "Chapter 3. Asynchronous Programming
    and Networking"), *Asynchronous Programming and Networking*.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 与本书早期仅使用标准Java API开发的版本相比，这个股票市场应用的版本更短、更简单——例如，我们不必担心线程池。另一方面，它感觉比在[第3章](part0028_split_000.html#page
    "第3章。异步编程和网络")中实现的版本复杂一些，即使用Reactive Extensions实现的版本。
- en: This is because `core.async` operates at a lower level of abstraction when compared
    to other frameworks. This becomes especially obvious in our application as we
    had to worry about creating broadcasting channels, go loops, and so on—all of
    which can be considered incidental complexity, not directly related to the problem
    at hand.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为与其它框架相比，`core.async`在更低的抽象级别上运行。在我们的应用中这一点尤其明显，因为我们不得不担心创建广播通道、go循环等等——所有这些都可视为附带复杂性，与当前问题无直接关系。
- en: '`core.async` does, however, provide an excellent foundation for building our
    own CES abstractions. This is what we will be exploring next.'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '`core.async`确实为我们构建自己的CES抽象提供了一个优秀的基础。这正是我们将要探讨的内容。'
