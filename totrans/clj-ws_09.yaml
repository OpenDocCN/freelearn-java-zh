- en: 9\. Host Platform Interoperability with Java and JavaScript
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Overview
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will look at interoperability between Clojure and both Java
    and JavaScript. Clojure runs on top of platforms provided by Java and JavaScript.
    Clojure was designed to use libraries provided by Java or JavaScript. We will
    learn how to access Java and JavaScript objects and methods in Clojure. We will
    also learn how to convert data between Clojure and Java or JavaScript and back.
    After learning how to access Java and JavaScript from Clojure, we will investigate
    how to perform Input-Output (I/O) operations like reading and writing to files
    using Java classes. We will then learn how to deal with errors and exceptions
    in our code.
  prefs: []
  type: TYPE_NORMAL
- en: By the end of this chapter, you will be able to work with the appropriate syntax
    and semantics to access Java and JavaScript objects and methods from Clojure,
    and deal with Java exceptions and JavaScript errors.
  prefs: []
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we learned how to create a Leiningen project. A project
    gives a structure for organizing our code. We structure our project around namespaces.
    We created new namespaces and we imported external Clojure libraries in order
    to use them in our code.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you are familiar with using namespaces and creating Clojure projects,
    it is time to become more comfortable with working on projects that use Java and
    JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: As we learned in *Chapter 1*, *Hello REPL!*, Clojure compiles to Java bytecode
    and operates on the **Java Virtual Machine** (**JVM**). The JVM is a host platform.
    Any programming language that compiles to Java bytecode can run on the JVM. Because
    Clojure compiles to Java bytecode and runs on the JVM, we call it a hosted language.
    Java dates from the 1990s and is now one of the most popular backend languages.
    We can leverage existing Java libraries instead of writing a lot of code on our
    own. This helps us deliver new features faster.
  prefs: []
  type: TYPE_NORMAL
- en: As we will see, importing Java classes in Clojure is a bit different than using
    Clojure libraries. In this chapter, we will learn how to import and call Java
    classes in Clojure by writing an application that performs I/O operationsâ€”reading
    and writing from a file.
  prefs: []
  type: TYPE_NORMAL
- en: In the second part of this chapter, we will look into ClojureScript and JavaScript
    interoperability. JavaScript is a scripting language that runs in browsers. It
    is the most popular frontend language at the moment. ClojureScript compiles to
    JavaScript. In ClojureScript, we can use JavaScript libraries. This gives us access
    to a huge amount of code written by other developers. A great boost to our productivity.
  prefs: []
  type: TYPE_NORMAL
- en: Using Java in Clojure
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Any code written by a developer needs to be converted to code that is understood
    by a machine. An interpreter uses code from a developer and compiles it into machine
    code. Each operating system is different, hence the need for platform-specific
    compilers and interpreters. One of the reasons why Java is so successful is that
    it provides the JVM, which takes human-understandable code and converts it into
    machine code. Developers are not usually interested in the JVM. They can focus
    on writing code in Java without interacting with the underlying operating system.
    This job is done by the JVM.
  prefs: []
  type: TYPE_NORMAL
- en: Clojure is a hosted language. It means that it uses the JVM instead of creating
    a new runtime environment. Clojure cleverly reuses facilities provided by the
    JVM. This is a very powerful approach. Things such as garbage collection, threading,
    concurrency, IO operations (all of which will be explained in the following paragraphs)
    are JVM battle-tested technologies that Clojure relies on.
  prefs: []
  type: TYPE_NORMAL
- en: Java garbage collection is the process by which Java programs perform automatic
    memory management. Java programs compile to bytecode that can be run on a JVM.
    When Java programs run on a JVM, objects are created on the heap, which is a portion
    of memory dedicated to the program. Eventually, some objects will no longer be
    needed. The garbage collector finds these unused objects and deletes them to free
    up memory. We could have a vector with usernames in our program. The usernames
    are strings. Each string will occupy some space in memory. When we display a list
    of users on a page, we need this list. When we click on a user and display her
    profile, we do not need information about other users. We could remove this information
    from memory so the memory is available for other data.
  prefs: []
  type: TYPE_NORMAL
- en: In concurrent computing several computations and operations are executed during
    overlapping time periods. This is in contrast with sequential programming, where
    one operation must finish before other operations can start. In sequential computing,
    an operation to capitalize a vector of usernames must finish before the second
    operation that finds only admin users can start. In concurrent computing, execution
    of both operations overlaps. We do not need to wait for one to finish before the
    second can start.
  prefs: []
  type: TYPE_NORMAL
- en: A thread is a lightweight process on the JVM. When a computing program uses
    two or more threads, it runs concurrently. Each part of a program is a separate
    thread. In our usernames example, one thread will filter usernames for admins
    while the other thread will capitalize names.
  prefs: []
  type: TYPE_NORMAL
- en: IO operations are processes that deal with reading from a source, such as a
    keyboard, and writing to a destination, such as a monitor. Java provides support
    for a number of sources and destinations. We can read from a text file and write
    to a printer. Java IO will be covered in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: As Clojure developers, we have access to an ecosystem of JVM libraries. Because
    Java is one of the most popular languages, by targeting JVM, we join a big community.
    This gives us the benefit of using many well-tested and optimized libraries.
  prefs: []
  type: TYPE_NORMAL
- en: In order to use existing Java code, we need to import it to our project. Clojure
    gives us tools to import and operate with Java.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the next sections, we will explore tasks such as:'
  prefs: []
  type: TYPE_NORMAL
- en: Importing Java classes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating new instances of Java classes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will start with importing Java classes. Clojure provides an `import` function
    to do this job. This function can import a single class or a number of classes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 9.01: Importing a Single Java Class in Clojure'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As we learned in the previous chapter, Clojure code is organized into namespaces.
    Java organizes its code into packages that contain classes. In this exercise,
    we will learn how to import packages and Java classes.
  prefs: []
  type: TYPE_NORMAL
- en: We will explore Java interoperability using a REPL.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open a Terminal and add the following command to start the REPL:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In order to use a Java class, we need to import it. First, we will import a
    single class. We will start with `BigDecimal` class, which allows us to store
    very large decimal numbers.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Call the `import` function with the `BigDecimal` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This will let us know that the class has been imported:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In Java, we construct an instance of a class using the `new` keyword:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Similarly, in Clojure, we can construct an object from the `BigDecimal` class.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Call the `new` function on the `BigDecimal` class to create an instance of
    it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Executing the preceding statement in the REPL returns a `BigDecimal` value:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Often, we want to use a value many times. Storing the value in a variable is
    a good choice:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Calling an instance of the variable in the REPL will give us the value stored
    in `BigDecimal`:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 9.1: Printing the value stored in BigDecimal'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/B14502_09_01.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 9.1: Printing the value stored in BigDecimal'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Clojure provides a special shorthand symbol for constructing class instances
    using a dot, `.`. We place a dot after a class name. In these cases, Clojure assumes
    that we want to construct an instance of a class.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The preceding example with `BigDecimal` could have been written using dot notation.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Construct a `BigDecimal` instance using dot notation:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Notice the dot after the `BigDecimal` class name:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 9.2: Printing the BigDecimal value'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/B14502_09_02.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 9.2: Printing the BigDecimal value'
  prefs: []
  type: TYPE_NORMAL
- en: We have seen how to import a class and create an instance of it. Very often,
    you would want to import more than one class. In the next exercise, we will investigate
    how to import more than one Java class.
  prefs: []
  type: TYPE_NORMAL
- en: Working with Time in Java
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The Java standard library provides the `java.time` and `java.util` packages,
    which contain classes that are useful for working with time. Two useful classes
    are:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Locale`: A class representing a specific geographical region such as `US`
    (United States), `FR` (France).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`LocalTime`: A class representing time in the current locale. The local time
    for Eastern Europe is two hours ahead of Universal time (London).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this chapter, we will see examples of manipulating time in Java and Clojure.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 9.02: Importing Multiple Java Classes in Clojure'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Importing more than one class can be divided into two actions:'
  prefs: []
  type: TYPE_NORMAL
- en: Importing classes from the same package
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Importing classes from different packages
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In order to import more than one class from the same Java package, we will
    use a vector import:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Call the `import` function with two classes in a vector:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Once they are imported, we can use both classes like we have.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Create an instance of the `BigInteger` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We will see a new `BigInteger` instance created in the REPL:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create an instance of the `BigDecimal` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We will see a new `BigInteger` instance created in the REPL:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: If we want to import classes from different packages, we specify their full
    names, including the package names.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Import the `LocalTime` class from the `time` package and the `Locale` class
    from the `util` package:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Once they are imported, we can construct these classes as we did before.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Create an instance of the `Locale` class using dot notation:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `LocalTime` class provides static methods to obtain the current time. A
    static method is a class method. We call it on a class and not on an instance
    of the class that we create. In Java, we call the class name followed by the method
    name when we want to use a static method. The static `now` method returns the
    current time:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Here, the static `now` method is called on the `LocalTime` class. The `now`
    method is a static method in the `LocalTime` class. The `now` method returns the
    current time. The time is in the format `hour:minutes:seconds.miliseconds`. Since
    we can run the code at any time, the output will differ in each execution of the
    code:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 9.3: Printing the local time'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/B14502_09_03.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 9.3: Printing the local time'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: We can also access static methods from the `LocalTime` class in Clojure. This
    is done by stating the class followed by a slash and a method name.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Call the static `now` method from the `LocalTime` class using slash notation:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The output is similar to the following:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'A Java class can have static fieldsâ€”fields that belong to a class and not an
    instance of a class. In Java, we access class fields using a dot. The `LocalTime`
    class has class fields corresponding to the times of the day: the `NOON` field
    indicates the middle of the day, 12:00, and the `MIDNIGHT` field indicates the
    middle of the night, 00:00.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'In order to get the `NOON` field for `LocalTime`, we would write the following:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This would give us the following
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 9.4: Printing the NOON value'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/B14502_09_04.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 9.4: Printing the NOON value'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: When we run the code, we are accessing the `NOON` field. In the output, we see
    that noon is at `12:00`. In Clojure, we use the form with a slash, as we have
    just seen when we accessed the static `now` method.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Access the static `MIDNIGHT` field from the `LocalTime` class using slash notation:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: When we run the code, we are accessing the `MIDNIGHT` field. In the output,
    we see that midnight is at `00:00`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: As we have just seen, accessing static fields and methods with a slash uses
    the same syntax as the dot.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: If we want to access instance methods, we use the dot operator with a function
    name. In the following example, we will use the `negate` method on `BigDecimal`,
    which negates the value of `BigDecimal`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Call the `negate` function on the `BigDecimal` instance:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This was an example of calling a function without any arguments. In the following
    example, we will see how to call an instance method that accepts arguments. The
    `BigDecimal` class provides an exponentiation method, `pow`, that raises the base
    to the specified power. In order to calculate the product of the exponentiation
    of a `BigDecimal` instance, we pass to the power method an integer.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: In Java, we use the `pow` method, as shown in the next step.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'First, we will create a `BigDecimal` instance:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, we will call the `pow` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If we printed the call to `pow` method, we would get the following output:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In Clojure, we can also use the `pow` method.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Call the `pow` method on a `BigDecimal` instance:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This gives us the following:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In this exercise, we imported a number of classes from Java packages. We also
    saw how to call static and instance methods. This allows us to import and use
    any Java classes that we might need.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the next exercise, we will learn about macros, which help us use Java classes
    in Clojure. Syntax in Clojure is very concise. Code written in Clojure is shorter
    than code written in Java. One common pattern in Java is calling multiple methods
    on class instances. The methods are chained together, each operating on the result
    of the previous method call. Clojure provides macros that simplify this method
    chaining. We will learn more about macros in *Chapter 11*, *Macros*. For the purpose
    of this chapter and learning about Java interoperability, we can think about macros
    as functions on steroids. One macro that we have used a lot so far is `let`. With
    `let`, we can create a local variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: In this example, `let` allows us to define a variable, `num`, with a value of
    `2`. The plus function adds `3` to our variable. Both `let` and `+` are the first
    elements in their lists. WeÂ can see that the use of the `let` macro and the plus
    function is similar.
  prefs: []
  type: TYPE_NORMAL
- en: Clojure macros help us simplify code. We will learn about macros in depth in
    *Chapter 11*, *Macros*. In the meantime, we will see what macros we can use to
    simplify Java interoperability.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 9.03: Macros That Help Us Use Java in Clojure'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this exercise, we will find out the difference in seconds between our time
    zone and the target zone in London (UTC). In order to do this, we will use two
    Java classes from the `time` package. We will chain method calls to get the result.
  prefs: []
  type: TYPE_NORMAL
- en: The `ZonedDateTime` class contains information about the date and time in specific
    time zones. If we live in India, this class allows us to get the current date
    and time in India as opposed to the current time in London (UTC).
  prefs: []
  type: TYPE_NORMAL
- en: 'Import the `ZonedDateTime` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Get an instance of `ZonedDateTime`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In this example, the time zone is in Central Europe in Warsaw.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Use `getOffset` from `ZonedDateTime`. This will tell us the time difference
    between our time zone and the UTC zone:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Please note that the preceding statement can be written as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The statements are equivalent. It is a matter of preference regarding which
    one to use. Most Clojure code uses the `.getOffset` function call, though it is
    good to know the other form in case you ever see it. The time difference between
    Central Europe and London (UTC) is two hours (+2).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now that we know the time difference between the zones, we can get this value
    in seconds:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the output, we see that the time difference between Central Europe and London
    is 7,200 seconds. Depending on where you live, the output might differ. What is
    important here is that the method chaining looks verbose. We have two dot operators
    and some parentheses. This already looks confusing, and with more method chaining,
    it will be even more confusing. Luckily, Clojure provides a convenience `..` (dot-dot)
    macro for method chaining.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: This example can be rewritten using the dot-dot macro.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Get the time difference in seconds from `ZonedDateTime` using the dot-dot macro:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The output is the same. The method calls are much easier to read. Whenever you
    need to chain methods on Java objects, the dot-dot macro will simplify the code.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: This was an example of calling methods on different objects. Clojure provides
    a `doto` macro for situations where we want to call methods on the same instance
    of a Java class.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: It is common in Java to write a code where it is necessary to make a lot of
    modifications to strings of characters. Consider a situation where we have an
    auto finder on a website. Whenever we type a new character, we need to create
    a new string. With constant typing, this would mean creating many string objects.
    Such objects would occupy lots of memory space. With `StringBuffer`, we create
    one instance and we can add characters to this instance. This saves a lot of memory
    compared to having string objects.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'In Java, we could use `StringBuffer` in the following way:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In Clojure, a sentence can be constructed by calling the append method on the
    `StringBuffer` class as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The output we get is a sentence:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: There is a repetition of the word `string`. The `doto` macro eliminates this
    duplication. The `doto` macro will implicitly call functions on instances that
    we specify. The preceding code can be rewritten using `doto`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Construct a sentence using `StringBuffer` and the `doto` macro:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The output is the following sentence:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In this example, we eliminated code duplication. With the `doto` macro, we called
    methods on an instance of `StringBuffer`. Once we were done, we converted the
    instance to a string.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: In this exercise, we looked at two helpful macros for situations when we need
    to work with Java classes. Often, we call many methods. The `doto` and `dot-dot`
    macros allow us to simplify code that has multiple method calls.
  prefs: []
  type: TYPE_NORMAL
- en: In the next topic, we will use our new knowledge of calling Java classes in
    Clojure. We will look into Java IO operations. Then, we will create a coffee-ordering
    application that performs file manipulations.
  prefs: []
  type: TYPE_NORMAL
- en: Working with Java I/O
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: I/O deals with reading data from a source and writing data to a destination.
    These are some of the most common activities that programs do. Source and destination
    are very broad concepts. You could read from a file or a keyboard and display
    data on a monitor. You could read from a database and write to an API serving
    data. Java provides classes for many sources and destinations for reading and
    writing data.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this topic, we will look at the most common I/O cases:'
  prefs: []
  type: TYPE_NORMAL
- en: Reading and writing to a file
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reading from a keyboard and writing to a monitor
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We have already worked with I/O without realizing it. Whenever we start the
    REPL and type on the keyboard, we perform write operations. Similarly, all function
    calls in the REPL print to the monitor, performing output operations.
  prefs: []
  type: TYPE_NORMAL
- en: I/O is a huge and difficult topic. Even the people that created Java did not
    get it right in the beginning, as we can see from the number of classes and packages
    for I/O. We have the `java.io` package and the `java.nio` (new IO) package. The
    `java.io` package contains classes for working with input and output in Java.
    This package has methods for reading from sources such as the keyboard and displaying
    to destinations such as a printer or a screen. While the `java.io` package contains
    many useful classes, it is considered complicated. In order to write I/O code,
    we have to use many classes. The newer package, `java.nio` (new I/O), introduces
    new I/O classes that simplify working with input and output in Java.
  prefs: []
  type: TYPE_NORMAL
- en: Java has many I/O classes because there are many scenarios for using input and
    output. We will see the `PushbackReader` class in action. This class allows us
    to read ahead a few characters to see what is coming, before we determine how
    to interpret the current character. This is useful when we want to read and interpret
    data by taking into account what other data is in the file.
  prefs: []
  type: TYPE_NORMAL
- en: Luckily for us, Clojure is a very pragmatic language and provides tools to work
    with I/O. Clojure has a `with-open` macro that helps us to work with files. Opening
    a file, or, to be more precise, any stream of data, uses computer resources such
    as CPU and RAM. After finishing reading from a file, we want to free these resources
    so they are available for other tasks. The `with-open` macro closes the opened
    stream, thus freeing up the resources. Closing resources is done automatically,
    and we do not need to think about closing resources ourselves. This prevents our
    application from slowing down or even crashing if we have many opened resources
    that are not used.
  prefs: []
  type: TYPE_NORMAL
- en: Immutability in Clojure
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In *Chapter 2*, *Data Types and Immutability*, we learned about immutability.
    Clojure defaults to immutability. We do not alter data structures but create new
    structures based on existing data. For example, information about employees that
    is stored in a map is updated by creating a new map of employees with the necessary
    changes. The original map of employees is intact and available if we need it.
    As we have learned, this approach prevents many bugs in Clojure when we want to
    access one data structure from many places.
  prefs: []
  type: TYPE_NORMAL
- en: There are times, however, when we want to mutate data. We want to run an application
    by default and stop it when the user selects the exit option. Ref is one of Clojure's
    concurrency primitives. We will learn more about concurrency in Clojure in *Chapter
    12*, *Concurrency*. Now, all we need to know is that with `ref` we can change
    the value of data. We will use ref to control the state of an application that
    we will shortly create.
  prefs: []
  type: TYPE_NORMAL
- en: In the next two exercises, we will create a coffee-ordering app. During the
    development process, we will have the opportunity to work with I/O operations
    such as file reading and writing. We will start by creating a new Leiningen project
    for the frontend part of the application. We will display the coffee menu and
    handle user choices.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 9.04: Coffee-Ordering Application â€“ Displaying a Menu'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this chapter, we have seen how to use Java classes in Clojure. The aim of
    this exercise is to extend our knowledge of Clojure and Java. We will create a
    coffee-ordering app.
  prefs: []
  type: TYPE_NORMAL
- en: 'The app will have the following features:'
  prefs: []
  type: TYPE_NORMAL
- en: Display the coffee menu
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Be able to order coffee (type and quantity)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Display order confirmation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Once we finish the application, we will be able to place orders and display
    them:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.5: The coffee application'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B14502_09_05.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 9.5: The coffee application'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the Terminal and create a new Leiningen project:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This will create a Leiningen project that's similar to the one we investigated
    in the previous chapter.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: In this application, we will get user input from a keyboard. To help us, we
    will use a Java class called `Scanner` from the `java.util` package.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Import namespaces to the `core.clj` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We have imported the `Scanner` class. This class allows us to get input from
    a keyboard. In order to use methods from `Scanner`, we need to create an instance
    of this class.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: We also imported the `coffee-app.utils` namespace, where we will have utility
    functions.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'We will store the menu in a hash. A hash is a Clojure collection that we learned
    about in *Chapter 1*, *Hello REPL* ! In the hash, we use a coffee type such as
    `:latte` as the key. The value of the key is the price:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the price menu, the price for `mocha` is `0.4`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Create an instance of the `Scanner` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We will call methods on this class instance when we want to get input from
    a user. The `Scanner` class needs to know the source of the input. In our case,
    we use the default in source from the `System` class â€“ keyboard. When a user runs
    the application, they should see a menu with options. The options are displaying
    and ordering coffees, listing orders, and exiting the application:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 9.6: Options of the coffee application'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/B14502_09_06.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 9.6: Options of the coffee application'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Add the code for displaying the menu and handling user choices:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the `start-app` function, we set the application to run by default:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Concurrency primitives are special. In order to get the values stored in them,
    we use the `deref` function.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Inside the `while` block, the application runs until the user chooses the exit
    option. In this case, we will update the value of `ref`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: After updating, `ref` is false. The `while` block will stop when the value of
    ref is `false` and our application will exit.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'When our application runs, the user can choose options from the menu:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This will display the following menu:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 9.7: Choosing the options'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/B14502_09_07.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 9.7: Choosing the options'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: We are able to display the initial menu. We can work on handling user choices
    from the menu.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'In order to get the user response, we call the `nextInt` method from the `Scanner`
    instance:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, once we get the user input, we check which option from the menu should
    be executed:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We now know the logic in the main application menu when we start the app. It
    is time to dig deeper and see the code for the `show-menu` function.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Display the menu:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the `show-menu` function, we let the user know about the two available coffees,
    latte and mocha:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This will display the coffee menu:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 9.8: Displaying the coffee menu'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/B14502_09_08.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 9.8: Displaying the coffee menu'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: We need to respond to the user's coffee choice now.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'We use a `Scanner` instance to get the user input:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, we proceed to buying the coffee that the user chose:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `show-menu` function is not long. Its purpose is to display the available
    coffees and get the user input. Once the user has chosen, we call the `buy-coffee`
    function to handle buying the selected coffee.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Ask the user how many coffees they want:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `buy-coffee` function asks how many coffees user wants to buy. Again, we
    use an instance of the Scanner class â€“ `input` â€“ to get the user's choice. Next,
    the function calls two utility functions to process buying. The functions are
    responsible for calculating the coffee price and displaying a feedback message
    to the user.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: All the functions will be placed in the `utils.clj` file. Instead of having
    all the functions in one big file, it is a good practice to split functions into
    various namespaces. A common namespace name is `utils`. We can keep any useful
    functions that operate on data there.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Create the `utils` namespace:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Because the methods that we place in this namespace perform I/O operations,
    we could have called this namespace `coffee-app.io`. In our case, both names for
    namespaces, `utils` and `io`, are valid. In much bigger applications, it is common
    to split the `utils` namespace into different namespaces.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Calculate the coffee price:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Our first utility function calculates the coffee price. It uses the get function
    to check the `coffees` hash for the passed coffee type. The hash was defined in
    the core namespace. The value obtained from the hash is then multiplied by the
    number of coffee cups that the user ordered. Finally, we convert the number to
    a float. This allows us to convert numbers such as `1.2000000000000002` to `1.2`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The last utility function used when we handle buying coffee is the `display-bought-coffee-message`
    function.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Display a message to the user after buying coffee:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `display-bought-coffee-message` function takes an order map and constructs
    a string message for a user based on the data from a map. The user is informed
    that they have bought a certain number of coffee cups for a specified price.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'With this function, we can control the information passed back to the user
    after completing the order:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The second option from the main menu allows us to see placed orders:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 9.9: Option 2 to see placed orders'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/B14502_09_09.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 9.9: Option 2 to see placed orders'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The function responsible for displaying orders is `show-orders` from the `coffee-app.core`
    namespace.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Display placed orders:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This function displays the coffee orders placed. In this exercise, we inform
    the user that orders will be displayed here. In the following exercise, we will
    implement saving and displaying orders:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'When we run the application and buy two cups of latte, we will see the followingÂ output:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 9.10: Output displaying placed orders'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/B14502_09_10.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 9.10: Output displaying placed orders'
  prefs: []
  type: TYPE_NORMAL
- en: In this exercise, we learned how to work with I/O and Java in Clojure. We created
    a coffee-ordering application that allowed us to see the coffee menu and order
    coffees.
  prefs: []
  type: TYPE_NORMAL
- en: In the next exercise, we will extend this application and implement saving coffee
    orders and retrieving orders.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 9.05: Coffee-Ordering Application â€“ Saving and Loading Orders'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The aim of this exercise is to extend our I/O knowledge. We will learn how to
    save and read from files. We will extend the coffee-ordering application to save
    data to a file and read data from a file.
  prefs: []
  type: TYPE_NORMAL
- en: 'The application will have the following features:'
  prefs: []
  type: TYPE_NORMAL
- en: Saving orders
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Retrieving orders
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Displaying saved orders
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Once we finish the application, we will be able to display orders:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.11: Output for placed orders'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B14502_09_11.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 9.11: Output for placed orders'
  prefs: []
  type: TYPE_NORMAL
- en: 'The main features of this application are saving and loading orders. We will
    create utility functions for this purpose:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to work with file I/O, we need to import I/O namespaces:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We will use the `PushbackReader` Java class to read a file. We will also use
    utilities from the Clojure I/O library.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The first function that we will implement will save data to a file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `spit` function is a Clojure I/O function that writes to a specified file
    location. With the `:append` keyword set to true, data that we want to store will
    be appended to existing data. Otherwise, every time we save data, new data will
    override the existing file content. After saving a file, we want to retrieve data
    from it.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'In order to retrieve data from a file, we need to make sure that the file exists:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `file-exists?` function calls an I/O function, `as-file`, that returns
    `java.io.File`. Then, we call the `exists` function to check whether we have a
    file in the requested location. The return value of the `file-exists` function
    is a Boolean value. If a file exists, we get `true`:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 9.12: Function output as true for file_exists?'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/B14502_09_12.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 9.12: Function output as true for file_exists?'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'If the file does not exist, we get `false`:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 9.13: Function output as false for file_exists?'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/B14502_09_13.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 9.13: Function output as false for file_exists?'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Once we know that a file exists, we can load the saved orders.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'We will need to load orders from a file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `load-orders` function takes a filename as a parameter. We call the `file-exists?`
    function to check whether we have a file in the requested location. The return
    value of the `file-exists?` function is used in an `if` block in the `load-orders`
    function. If we do not have a file, we return an empty vector. If we have a file,
    we will read its content.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: We use the `with-open` macro to read from a file. The macro will automatically
    handle closing a file once we finish reading. This will free up computer resources
    for us. We use the `PushbackReader` class to read from a file. This class allows
    us to read ahead a few characters to see what is coming before you can determine
    how to interpret the current character. Our plan is to read orders until we reach
    the end of the file, marked by the `::EOF` keyword. We repeatedly read one order.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: We have changed the binding for `read-eval` to `false`. It is not secure to
    read from a file that we do not know. By default, `read-eval` is set to `true`.
    This means that any data that we read can be evaluated. User data or files sent
    over a network should never be trusted. The data that we work with can contain
    malicious code. When we manipulate data in Clojure, the data should always be
    read without evaluating the content of the data.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'We will use the `read` function from the `clojure.java.io` namespace to read
    each line in the orders file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Once we reach the end of the file, a Java error is thrown and we catch this
    error. Upon catching the error, we return the `::EOF` keyword, which instructs
    our while loop to stop reading from the file. We will learn more about exceptions
    in Java later on in this chapter. We have our utility functions to save and load
    data to a file. We are ready to use these functions.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Save the coffee order. The `save-to` function is used to save a coffee order:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `save-coffee-order` function takes the names of files in which to save data,
    the coffee type, the number of cups of coffee, and the price of the order as parameters.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Using this data, we construct a map that we pass to the `save-to` function.
    TheÂ `save-to` function will save data to the file that we specify.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: After implementing the ability to save coffee orders, we can use this function
    when we handle buying coffee.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Handle buying coffee. The `buy-coffee` function will be responsible for calculating
    the coffee price, saving the coffee order, and displaying the feedback message
    to the user:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the `buy-coffee` function, we ask how many coffees the user wants to buy.
    We use an instance of the Scanner class â€“ `input` â€“ to get the user's choice.
    Next, the function calls three utility functions to process buying.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: After we calculate the order price, we save the order and finally display information
    to the user about the order placed. After placing an order, we are ready to load
    orders in order to display them in the menu.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'We will show orders using the `show-orders` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the `show-orders` function, we get orders from the orders file. We iterate
    over a sequence of orders using `doseq`. With `doseq`, for each order, we will
    call the `display-order` function.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Data for displaying an order is constructed from an order passed as a parameter
    to the `display-order` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `display-order` function creates a string from an order map. We access information
    about the number of cups bought, the type of coffee bought, and the price of the
    order.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'After ordering two coffees, we will have the following output:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 9.14: Output for the display-order function'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/B14502_09_14.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 9.14: Output for the display-order function'
  prefs: []
  type: TYPE_NORMAL
- en: In this exercise, we extended our coffee-ordering application. We added functionality
    to save orders to a file and load data from the file. While implementing these
    features, we learned more about Java I/O. These features improved our coffee-ordering
    application.
  prefs: []
  type: TYPE_NORMAL
- en: Working with Java Data Types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A data type refers to how data is classified. Any variable or object in Java
    has a specific type. In this book, we have seen types such as strings ("`Paris`"),
    Booleans (`true`, `false`), numbers (`1`, `2`) and collections (`[:one :two :three]`).
  prefs: []
  type: TYPE_NORMAL
- en: Clojure reuses some of the most common Java data types, such as strings and
    numbers. This is a good approach because Java types have been tested by many developers
    in their code since Java was created in the 90s. This gives us confidence when
    using Java data types. There are some types that are not directly present in Clojure.
    In such cases, we use Java interoperability in Clojure to access Java data types.
  prefs: []
  type: TYPE_NORMAL
- en: When writing applications in Clojure, we can use the data types that we have
    learned about in this book. We can also use data types if we know them from Java.
    In the previous exercises, we learned how to use access methods in Java classes.
    We know how to work with classes now.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the next exercise, we will learn how to work with Java collections in Clojure.
    Java provides collections such as `ArrayList` and `HashMap`:'
  prefs: []
  type: TYPE_NORMAL
- en: '`ArrayList` is like a Clojure vector. Elements in an `ArrayList` are stored
    in sequential order.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`HashMap` is like a Clojure hash. Elements in a `HashMap` are stored as key/value
    pairs.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Exercise 9.06: Java Data Types'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The aim of this exercise is to learn how to work with Java data types in Clojure.
    Often, when we work in Clojure we rely on external libraries. There are many Java
    libraries. Knowing how to use Java data types will help us to use Java libraries
    efficiently. In this exercise, we will work on a part of a geography application.
    The application stores information such as countries, capitals, and rivers as
    Java collections. We will write code to convert between Java and Clojure collections:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Start the REPL using the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'It will start as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 9.15: Output for the REPL'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/B14502_09_15.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 9.15: Output for the REPL'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'We will create a vector containing some capitals:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Check the `capitals` vector:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We can check the class of our `capitals` vector:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We see that `capitals` is a `PersistentVector` from Clojure.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Using Clojure''s vector, we can create an `ArrayList` in Java:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We created an `ArrayList` from a vector. We can check it as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We can check the class for our `destinations` array:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The destinations variable has the `ArrayList` class from Java. We just converted
    from Clojure to Java. We converted the `capitals` vector to the `destinations`
    `ArrayList`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'We can also convert the other way. We can convert from Java to Clojure as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `vec` function from the Clojure core library allows us to convert from `ArrayList`
    to a vector.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'We can check the class of our newly converted data:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: When we convert from `ArrayList` to a vector, we get the `PersistentVector`
    class in Clojure.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'We were able to convert back and forth from Java to Clojure using an ArrayList
    and a vector. Clojure has another collection type that stores data. A hash stores
    data in a key/value pair:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We defined a hash containing countries and rivers (fluss in German) in those
    countries:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We can check the `fluss` variable''s class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `fluss` variable is a `PersistentArrayMap` from Clojure.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Using Clojure''s hash, we can create a HashMap using Java:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We create a HashMap from Java using a hash from Clojure.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `rivers` variable contains countries and the rivers in those countries.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'We can check the class of the `rivers` variable as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We can see that `rivers` is a HashMap from Java.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Using HashMap from Java, we can create a hash in Clojure:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the preceding code we used the `into` function from Clojure's core library.
    The `into` function takes the destination collection and the source collection
    as the two arguments.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Our destination collection is a hash from Clojure. Remember that we define a
    hash in Clojure using curly brackets, `{}`. We put the content of the `rivers`
    HashMap from Java into a hash `{}` from Clojure.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'We can check the class of our newly converted hash:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The class of our converted data is a `PersistentArrayMap` from Clojure.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: In this exercise, we extended our knowledge of Java's interoperability with
    Clojure. We learned how to convert data from Java to Clojure and back again. In
    the following activity, you will use your knowledge of Java interoperability to
    create an application that performs I/O operations.
  prefs: []
  type: TYPE_NORMAL
- en: 'Activity 9.01: Book-Ordering Application'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this activity, we will apply our new knowledge about I/O and Java to create
    a book-ordering application. A media company has decided to create an app that
    allows users to order books. A user can select a year and titles from a list in
    the application. Once a book order has been placed, we should be able to see the
    orders grouped by year.
  prefs: []
  type: TYPE_NORMAL
- en: Once you complete the activity, you should have output similar to the following.
  prefs: []
  type: TYPE_NORMAL
- en: 'Initial menu:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.16: Menu display'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B14502_09_16.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 9.16: Menu display'
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing years:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.17: Available books by year'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B14502_09_17.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 9.17: Available books by year'
  prefs: []
  type: TYPE_NORMAL
- en: 'Books in one year:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.18: Books purchased in 2019'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B14502_09_18.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 9.18: Books purchased in 2019'
  prefs: []
  type: TYPE_NORMAL
- en: 'Asking how many books the user wants to buy:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.19: Asking for the number of books to be bought'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B14502_09_19.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 9.19: Asking for the number of books to be bought'
  prefs: []
  type: TYPE_NORMAL
- en: 'Order confirmation message:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.20: Order confirmation message'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B14502_09_20.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 9.20: Order confirmation message'
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing purchased books:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.21: List of purchased books'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B14502_09_21.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 9.21: List of purchased books'
  prefs: []
  type: TYPE_NORMAL
- en: 'These steps will help you complete the activity:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Import the necessary namespace.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a map to hold books by year.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a variable for a file that stores orders.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create an initial menu with options to order a book and list orders.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a menu to display books by year.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create the application's `main` method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a function to save data to a file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a function to save an order.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a function to calculate the `book price`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a function to display an order confirmation message.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a function to display the bought order.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a function to read a single order.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a function to check whether a file exists.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a function to load orders from a file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a submenu to order a book.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a function to buy a book by year.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a function to show orders by year.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a submenu to list orders.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The solution for this activity can be found on page 712.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Using JavaScript in ClojureScript
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: ClojureScript allows us to use JavaScript constructs. We can call JavaScript
    methods and functions like any other in ClojureScript. When we called Java from
    Clojure we used operators such as `.` dot or `\` slash. Using JavaScript in ClojureScript
    will also require us to learn a new syntax.
  prefs: []
  type: TYPE_NORMAL
- en: 'While Java operates on classes a lot, in JavaScript we operate on objects.
    Two JavaScript constructs that we want to use on objects are:'
  prefs: []
  type: TYPE_NORMAL
- en: Methods
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fields
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In order to access a method from a JavaScript object, we place `.` (a dot) followed
    by a method name. Accessing a field of an object is very similar. We use `.-`
    (a dot and a hyphen) before the field name. You might wonder why accessing a function
    uses slightly different syntax than accessing a field. In JavaScript, an object
    can have a method and a field with the same name. In ClojureScript, we need a
    way to distinguish between a function call and a field access.
  prefs: []
  type: TYPE_NORMAL
- en: 'In JavaScript, the code looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: 'In ClojureScript, the code looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s take a minute to appreciate the design of ClojureScript. We learned
    at the beginning of the book about ClojureScript functions and how to call them.
    Essentially, it is the same syntax as in Clojure. Unless we have a sequence, the
    first position in a list is treated as a function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: 'Calling `range` will return a sequence of numbers from 1 to 10:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.22: Output for calling range'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B14502_09_22.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 9.22: Output for calling range'
  prefs: []
  type: TYPE_NORMAL
- en: Here, `range` is in the first position and the ClojureScript compiler rightly
    treats `range` as a function. We have just seen how to call JavaScript methods
    and fields. With the addition of a dot or a hyphen, nothing changes in the syntax.
    This uniformity of placing method calls in the first position in ClojureScript
    reduces the mental burden on developers. We do not need to learn a lot of special
    syntax for JavaScript interoperability.
  prefs: []
  type: TYPE_NORMAL
- en: We will see this uniformity when we compare using the `range` function and checking
    the length of a string.
  prefs: []
  type: TYPE_NORMAL
- en: 'We call the `range` function in this way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: 'It will work as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.23: Calling the range function'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B14502_09_23.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 9.23: Calling the range function'
  prefs: []
  type: TYPE_NORMAL
- en: 'Checking the length of a string is done in the following way:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.24: Checking the length of a string'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B14502_09_24.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 9.24: Checking the length of a string'
  prefs: []
  type: TYPE_NORMAL
- en: The `range` function and accessing the length field of a JavaScript string are
    both placed in the first position in a statement.
  prefs: []
  type: TYPE_NORMAL
- en: What is even more amazing is that ClojureScript improves on JavaScript. In JavaScript,
    there is no concept of a namespace. When we define a function or a variable, it
    belongs to a global namespace. This poses a problem when two or more libraries
    use the same name for a variable or a method. This causes a conflict and gives
    us errors. Library designers use JavaScript objects as modules/namespaces and
    place functions in their objects. This is, however, only a workaround and not
    a language design. In ClojureScript, namespaces are first-class citizens designed
    in the language.
  prefs: []
  type: TYPE_NORMAL
- en: We should pay attention to one namespace. ClojureScript uses the `js` namespace
    to refer to the global scope of a program. Core JavaScript objects such as `Number`,
    `String`, and `Date` are accessed in ClojureScript using the `js` namespace. In
    this namespace, we will also find browser-defined objects such as `window`.
  prefs: []
  type: TYPE_NORMAL
- en: In order to construct a JavaScript object, we use the object's name followed
    by a dot. This is the same syntax we used to construct an instance of a Java class
    in Clojure.
  prefs: []
  type: TYPE_NORMAL
- en: 'In JavaScript, the code looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE107]'
  prefs: []
  type: TYPE_PRE
- en: 'In ClojureScript, the code looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE108]'
  prefs: []
  type: TYPE_PRE
- en: Notice that we use the `js` namespace. As was mentioned in this section, core
    JavaScript objects such as Number are accessed through this namespace.
  prefs: []
  type: TYPE_NORMAL
- en: 'ClojureScript takes advantage of JavaScript data types. ClojureScript does
    not invent new data types but reuses existing JavaScript data types. The following
    table presents ClojureScript data types and their JavaScript origin:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.25: ClojureScript data types with their origins'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B14502_09_25.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 9.25: ClojureScript data types with their origins'
  prefs: []
  type: TYPE_NORMAL
- en: As we can see, data types often used in ClojureScript are based on JavaScript
    data types.
  prefs: []
  type: TYPE_NORMAL
- en: We have seen how to access JavaScript in ClojureScript. In the next exercise,
    we will learn how to work with JavaScript data types in ClojureScript.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 9.07: Working with JavaScript Data Types'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The aim of this exercise is to learn how to work with JavaScript data types
    in ClojureScript. We will learn how to convert ClojureScript data to JavaScript
    objects. Later, we will learn the reverse process of how to convert JavaScript
    objects to ClojureScript data:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We will create a new project for our code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE109]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This command creates a basic ClojureScript project called `js-interop`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: We will start the REPL with the following command.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE110]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 9.26: Output of the REPL'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/B14502_09_26.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 9.26: Output of the REPL'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'ClojureScript provides the `js-obj` function for creating a JavaScript object
    from ClojureScript data:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE111]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE112]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Calling the `js-obj` function created a new JavaScript object. Notice the `#js`
    in the REPL. This symbol in the REPL informs us that the following expression
    is a JavaScript object.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Frequently, we use nested structures where one object contains another object:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE113]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 9.27: Nested structures'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/B14502_09_27.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 9.27: Nested structures'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The `rivers-map-js` object is a nested structure. It contains a country key,
    the value of which is another object with some river details.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'We can access fields in the `rivers-map-js` object:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE114]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE115]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'After accessing country, we got nested data about rivers. We will try to access
    this nested data:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE116]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE117]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: When we try to get information about a river, we get `nil`. It turns out that
    we cannot access data using JavaScript interoperability. The reason is because
    the `js-obj` function is shallow. It does not transform nested data structures
    to JavaScript objects. If we want to transfer nested ClojureScript data to JavaScript
    objects we need to use some other method.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'In order to transform all nested data, we need to use the `clj->js` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE118]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE119]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'With the `clj->js` function, we are able to convert nested ClojureScript data:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE120]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE121]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Notice the two `#js` symbols. Each symbol informs us that we have a JavaScript
    object. The first object contains the name of a country. Inside this country object,
    we have another JavaScript object with the name of a river.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'When we have nested JavaScript objects, we can access data from them using
    JavaScript interoperability:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE122]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE123]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We were able to access nested JavaScript objects using JavaScript interoperability.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'So far, we have converted from ClojureScript to JavaScript. It is possible
    to convert the other way, from JavaScript to ClojureScript:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE124]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE125]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Using the `#js` symbol, we converted a JavaScript object to ClojureScript data.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Convert nested JavaScript objects to ClojureScript data:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE126]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE127]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Using the `js->clj` function, we again converted from JavaScript objects to
    ClojureScript data. Notice that we used the `#js` symbol twice. Every time we
    have a JavaScript object, we have to mark it using the `#js` symbol. This instructs
    ClojureScript to treat the following data as a JavaScript object.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: In this exercise, we learned how to convert ClojureScript data to JavaScript
    objects. Then we saw how to reverse the process and convert from JavaScript objects
    to ClojureScript data.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: We are ready to start building ClojureScript applications. In *Chapter 8*, *Namespaces,
    Libraries, and Leiningen*, we learned about structuring projects and using Leiningen
    to create Clojure projects. We can use Leiningen to create ClojureScript projects
    as well. Using Leiningen templates to create ClojureScript applications will create
    the necessary configuration for working in ClojureScript. One of the most common
    ClojureScript templates is the Figwheel template. We will learn about this template
    in the next topic.
  prefs: []
  type: TYPE_NORMAL
- en: Figwheel Template
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Figwheel is a tool that compiles ClojureScript code. One of the selling points
    of Figwheel is hot-code reloading. When we make changes to ClojureScript files,
    the code will be recompiled and a page in a browser will be updated. This helps
    to speed up the development process by giving quick feedback to programmers.
  prefs: []
  type: TYPE_NORMAL
- en: Figwheel not only reloads our code, but is intelligent with code reloading.
    Figwheel gives us compiler errors when we make changes in our code that result
    in faulty code.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we try to use a function that is not declared, Figwheel will inform us:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.28: Message from Figwheel'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B14502_09_28.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 9.28: Message from Figwheel'
  prefs: []
  type: TYPE_NORMAL
- en: Figwheel informed us that on line 42 in the `core.cljs` file we tried to call
    a `handle-sort-finish` function without declaring it.
  prefs: []
  type: TYPE_NORMAL
- en: With this concise and high-quality feedback from Figwheel, we can develop ClojureScript
    applications faster than if we had to dig through errors in stack traces. OrÂ worse,
    our application runs but gives unexpected results.
  prefs: []
  type: TYPE_NORMAL
- en: Figwheel supports an interactive programming style. Changes made in our code
    base are recompiled and displayed in a web browser. We learned in *Chapter 1*,
    *Hello REPL!*, that Clojure uses immutable data structures by default. You can
    reload function definitions all day long. They are side-effect free and not tied
    to the local state of a running system. This means that running the same function
    many times does not change the state of an application. Recompiling and reloading
    is thus safe.
  prefs: []
  type: TYPE_NORMAL
- en: Figwheel encourages using React to develop applications. React is a web tool
    that allows us to manipulate elements on a page. React allows you to write functions
    that express what the state of such elements should be given the current application
    state.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will learn about Rum. Rum is a library used to create
    HTML elements on a page using application state.
  prefs: []
  type: TYPE_NORMAL
- en: Reactive Web Programming Using Rum
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Many websites allow users to interact with web pages. Users can click, drag,
    and sort elements. These pages are dynamic â€“ they respond to user actions. A programming
    page that reacts to user interactions is called reactive programming.
  prefs: []
  type: TYPE_NORMAL
- en: HTML provides a structure of elements on a page. The **Document Object Model**
    (**DOM**) is a representation of HTML in JavaScript. JavaScript allows us to operate
    on DOM elements that are finally displayed as HTML elements on a web page.
  prefs: []
  type: TYPE_NORMAL
- en: One way to make a page react to user actions is to render (display) that whole
    page again. Rendering a whole page consumes computer resources. If only a small
    part of the page needs re-rendering, we waste precious resources re-rendering
    the entire page. Fortunately for us, there is a solution that allows us to re-render
    only the parts of a page that have changed.
  prefs: []
  type: TYPE_NORMAL
- en: React.js is a JavaScript library that supports reactive programming. The basic
    block of React.js is a component. In React.js, we define what components should
    look like and how they should behave. With React.js, we can create components
    based on the current application state. Changes in state result in re-rendering
    components that require a change. React internally checks which parts of the application
    state have changed and which components rely on these parts of state. As a result,
    React re-renders only those components that used parts of the application state
    that have changed.
  prefs: []
  type: TYPE_NORMAL
- en: Rum is a Clojure library for creating HTML elements on a web page. Rum is based
    on React.js. We often have some state in a ClojureScript application. A state
    could be a list of users. We can manipulate a list of users by adding or removing
    users, and based on our actions a web page should update. In Rum, it is possible
    to define page elements such as a user entry that will react to changes to the
    list of users. Adding a new user will result in a page displaying an updated list
    of users.
  prefs: []
  type: TYPE_NORMAL
- en: In the next exercise, we will create a Figwheel project that uses Rum and explore
    what benefits Figwheel and Rum provide for developers.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 9.08: Investigating Figwheel and Rum'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The aim of this exercise is to learn about Figwheel and Rum. Figwheel will
    create a ClojureScript project structure for us. Rum will allow us to build HTML
    components that respond to user actions:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create the Figwheel and Rum project:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE128]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We use Leiningen to call the `fighwheel-main` template. This template will create
    a new ClojureScript project with a main namespace called `hello-clojuresript.core`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'We want to use Rum, so we pass the `--rum` command-line parameter to add Rum
    support to the project:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 9.29: Creating a Figwheel and Rum project'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/B14502_09_29.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 9.29: Creating a Figwheel and Rum project'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Leiningen downloads the template and creates a ClojureScript project for us.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'We will move to the project to the command line:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE129]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This will change the directory to `hello-clojurescript.core`:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 9.30: Changing directory'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/B14502_09_30.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 9.30: Changing directory'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: We are ready to run our application. In order to run our ClojureScript application,
    we need to build it.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figwheel provides an automatic build configuration that allows us to run a
    newly-created ClojureScript application:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE130]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Calling this command will build a ClojureScript application. First, Figwheel
    will download any necessary dependencies:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 9.31: Building a ClojureScript application'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/B14502_09_31.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 9.31: Building a ClojureScript application'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Here, Figwheel downloads three dependencies:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Rum
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Figwheel-main` library'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: ClojureScript
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Second, Figwheel will check our configuration:'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 9.32: Figwheel checking configuration'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/B14502_09_32.jpg)'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 9.32: Figwheel checking configuration'
  prefs: []
  type: TYPE_NORMAL
- en: Because we have not changed the default configuration, there are no problems
    with our project's configuration. We will see what the default configuration looks
    like shortly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Third, Figwheel will compile our code and output a main file that is run:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.33: Compiling code'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B14502_09_33.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 9.33: Compiling code'
  prefs: []
  type: TYPE_NORMAL
- en: 'After Figwheel builds our application, it will launch a server that will serve
    our application:![Figure 9.34: Starting the server'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B14502_09_34.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE131]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Any changes that we make in source files will result in recompilation of the
    code and our application being updated in the web browser.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: We will investigate the core source file now.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figwheel will import two namespaces for us in the `core.cjs` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE132]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The first namespace is the Google `dom` namespace, which allows us to manipulate
    DOM elements. The second namespace is `rum`, which was imported because we set
    our application to use Rum. Remember that we passed the `--rum` command-line parameter
    when we created the application.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: In the namespace, we have defined the `^:figwheel-hooks` keyword. This is autogenerated
    by Figwheel and instructs Figwheel that it needs to auto-compile this file.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The Google DOM namespace allows us to manipulate DOM elements on the page:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE133]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `getElement` function will search a page for an element with an ID of `app`.
    By default, Figwheel will create an index page with a `div`. This `div` will have
    an ID of `app`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figwheel creates a default index file in the `resources/public` folder:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE134]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The main things that interest us in the index file are importing styles from
    the `css/style.css` file, creating the `div` with app `id` where we will mount
    our application, and adding our compiled code as a script from the `dev-main.js`
    file.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Reactive applications need to manage state to react to user interactions. The
    state is defined as an atom:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE135]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: n the state, we store a hash with a `:text` key that has a value of `"Hello
    world!"` and a `:counter` key with a value of zero. The state is defined using
    `defonce`. This is because we do not want to redefine the state when Figwheel
    reloads the code. This way, we preserve application state during page reload.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Rum components are defined using the `defc` macro:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE136]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `hello-world` component constructs an HTML `div` element. Inside the `div`,
    we have an `h1` HTML element and an `h3` HTML element.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The `h1` element will display text stored in the application state. Because
    the application state is an atom, if we want to access values, we need to dereference
    it. Dereferencing is an action that returns a value stored in an atom.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The `h3` element informs us that we can edit the `core.cljs` file and see the
    changes on the web page.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Defined components need to be mounted on the page.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'In order to see the components on the page, we need to mount them:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE137]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `rum/mount` function will mount the `hello-world` component to the DOM element.
    This element is returned by the `get-app-element` function that we investigated
    earlier.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Once the component is mounted to the DOM element, it will be displayed on the
    page:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 9.36: Initial page after mounting the component to the DOM element'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/B14502_09_36.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 9.36: Initial page after mounting the component to the DOM element'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Our `hello-world` component displays two headers. First is an `h1` header with
    saying `Hello world!`. Then is an `h3` header with information about editing the
    `core.cljs` file.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Rum allows us to define reactive components. A reactive component is a component
    that reacts to changes in the application state. When a change happens, the component
    is re-rendered on the page with a new value taken from the application state:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE138]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We marked the component to be reactive by using Rum's `< rum/reactive` syntax.
    The `<` symbol tells Rum that a component is a special type. In our case, it is
    a reactive component. Rum will react to changes to `app-state`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The `hello-world` component will call a band component and pass the band name
    together with `:counter`, which is defined in the application state.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Whenever the `app-state` is updated, Rum will react to the change and re-render
    the band component.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'In the `hello-world` component, we will display a band:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE139]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `band` component takes two band names and the number of likes as the parameters.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The component will display the band name and the number of likes:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 9.37: Displaying the band name in the hello-world component'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B14502_09_37.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 9.37: Displaying the band name in the hello-world component'
  prefs: []
  type: TYPE_NORMAL
- en: Inside the component, we use the `:on-click` DOM attribute.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `on-click` attribute allows us to attach a function that is called when
    a user clicks on an element on a web page:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE140]'
  prefs: []
  type: TYPE_PRE
- en: 'The function updates a `:counter` key inside the `app-state` hash. The update
    is done by incrementing the value of the counter using Clojure''s `inc` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.38: Incrementing likes for the band name'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B14502_09_38.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 9.38: Incrementing likes for the band name'
  prefs: []
  type: TYPE_NORMAL
- en: Clicking three times on the page element will update the counter. Updating the
    counter will trigger the re-rendering of the component with a new value.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this exercise, we updated the `hello-world` component. After code changes,
    the component was displayed in the browser. We did not have to recompile the code.
    The code was recompiled by Figwheel. When we run Figwheel, it starts to watch
    our files for changes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE141]'
  prefs: []
  type: TYPE_PRE
- en: Thanks to Figwheel, we were able to focus on coding without worrying about recompiling
    our code. This is done automatically by Figwheel.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we learned about Figwheel. It creates a template for ClojureScript
    projects. The main feature of Figwheel is hot-code reloading. Changes in our source
    files are automatically recompiled and re-displayed in the browser.
  prefs: []
  type: TYPE_NORMAL
- en: We also learned about Rum. Rum is a library that helps to create reactive components.
    The components react to changes in application state and are redisplayed on the
    web pages.
  prefs: []
  type: TYPE_NORMAL
- en: In the next topic, we will delve deeper into JavaScript interoperability.
  prefs: []
  type: TYPE_NORMAL
- en: Drag and Drop
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One of the most common use cases in web pages is using drag and drop. It is
    so common that we rarely even notice it nowadays. The jQuery UI library provides
    functions to code drag and drop functionality. With this library, we can mark
    HTML elements as draggable and droppable.
  prefs: []
  type: TYPE_NORMAL
- en: 'The library has a number of options that allow us to alter how dragging and
    dropping behaves. We can:'
  prefs: []
  type: TYPE_NORMAL
- en: Constrain the movement of draggable elements to certain areas on a web page
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Specify if the element returns to the original position after dragging
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Specify if the element auto-aligns to other elements
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Give visual aids while dragging, such as transparency or animation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Accept only one droppable element in a page area
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Allow or deny reverting after dropping
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Give visual feedback once an element has been dropped
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using jQuery's draggable and droppable functionality, we can create a truly
    interactive page.
  prefs: []
  type: TYPE_NORMAL
- en: We have seen the syntax for JavaScript interoperability. It is now time to put
    our knowledge into practice. In the next exercise, we will create a drag and drop
    application using JavaScript interoperability. The application will be based on
    the Figwheel template and use Rum for reactive behavior.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 9.09: JavaScript Interoperability with Drag and Drop'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The aim of this exercise is to get comfortable with JavaScript interoperability
    in ClojureScript. We will create a frontend application that allows users to drag
    and drop elements. When coding dragging and dropping behavior, we will use objects
    and functions from JavaScript. JavaScript's jQuery UI library has drag and drop
    methods. We will use methods from this library.
  prefs: []
  type: TYPE_NORMAL
- en: 'The application will be based on a Figwheel template that helps build ClojureScript
    applications. One of its main features is hot-code reloading. Any changes in source
    files are recompiled and updated in a browser. This helps to speed up the development
    process by giving quick feedback to programmers:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new ClojureScript application based on the `figwheel` template:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE142]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The REPL will display information saying that a new project based on the `figwheel`
    template has been created:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 9.39: REPL output'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/B14502_09_39.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 9.39: REPL output'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: In the project, we will use the `jayq` external library. `jayq` is a ClojureScript
    wrapper for jQuery.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Add external ClojureScript dependencies in `project.clj`. In `project.clj`,
    add the `jayq` library in the `:dependencies` section:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE143]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `dependencies` section in `project.clj` should look like the following:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 9.40: Output for dependencies'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/B14502_09_40.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 9.40: Output for dependencies'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now that we have dependencies configured in `project.clj`, we can import them
    in the `hello-drag-and-drop.core` namespace:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE144]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The libraries will help us create drag and drop elements on a page. Drag and
    drop implementation will be based on a component from jQuery UI. We need to import
    these JavaScript libraries in the `index.html` file.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Open the `resources/public/index.html` file and, inside the `<head>` tag, add
    imports for jQuery and jQuery UI:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE145]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'After importing the necessary libraries, we will launch Figwheel. In Terminal,
    type the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE146]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This will launch Figwheel for us:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 9.41: Launching Figwheel'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/B14502_09_41.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 9.41: Launching Figwheel'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figwheel will compile ClojureScript code and launch a server for us. The server
    will automatically open a web browser displaying the content from the `index.html`
    file:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 9.42: Content from index.html'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/B14502_09_42.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 9.42: Content from index.html'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: One of the selling points of Figwheel is code reloading. When we make changes
    to ClojureScript files, the code will be recompiled and a page in the browser
    will be updated.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: In our app, we will implement drag and drop functionality. We will move draggable
    cards into droppable tiles. We start by defining a tile component.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Inside `hello-clojurescript.core`, add a definition for a tile:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE147]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Here, a tile is a `rum` component that is basically an HTML block. We define
    a component using the `defc` method from `rum`. A tile accepts two arguments:
    text and a number. Inside it, a hash that allows us to set properties on an element
    number parameter is used to set an ID for the tile div. Text will be displayed
    inside the div element. We also set a "`tile`" class for styling.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Inside `resources/public/css/styles.css`, add a CSS definition. CSS stands
    for Cascading Style Sheets. Style sheets allow us to style HTML elements on a
    web page. Cascading means that if an HTML element has some styles, any HTML elements
    inside this element will inherit the same styling:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE148]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Here, we define the style for a tile component with a solid green border. The
    border''s width should be 1 pixel, the height should be 100 pixels, the width
    should be 200 pixels, and the component is displayed inline, meaning that it is
    on the same line as other elements. When we render the tiles, they will look as
    follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 9.43: Defining the tile component'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/B14502_09_43.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 9.43: Defining the tile component'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: We have two tiles on the same line. Each tile has a green border.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'This styling will help us to see each tile clearly. We have a solid green line
    to distinguish between the tiles. We are going to create a component that holds
    tiles:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE149]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We create a component that is a `div` holding two `tile` components. We mark
    them as first and second. Notice that we did not write a `div` tag directly. When
    we omit the `div` tag and provide a class or an ID, Rum will implicitly create
    a `div` element. Here, we used a shorthand notation for a class and gave the component
    class `tiles`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'We want to inform a user that an element was dropped. We will store information
    about dropping elements in an `atom`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE150]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: When the application starts, we set the value to `false`. We do not want Figwheel
    to redefine the atom when it reloads the page, so we define it once.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The component will display information if an element was dropped:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE151]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We use the `reactive` directive from Rum. This directive instructs Rum that
    the component will `react` to changes in `application state`. In our case, any
    changes to the `is-element-dropped?` atom will cause the component to be rerendered
    with a new value. We have three components already, but they are not visible in
    the web browser yet. We need to write code that will mount our components on the
    page. We will have a top-level component that will contain all the HTML for our
    application.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'We will put all our components into one `main` component. This `main` component
    will contain cards that we drag and tiles where we drop elements:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE152]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'After defining our `main` component, we are ready to tell Rum how to mount
    this component:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE153]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We tell Rum that we want to mount a component called `content`. The mount point
    is an element with an ID of `app`. When we check the web browser, we can see the
    changes applied:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 9.44: Changes in the tile component'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/B14502_09_44.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 9.44: Changes in the tile component'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: We did not have to compile the code ourselves. All this was done by Figwheel.
    After creating droppable elements, it is time to create elements that we can drag.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'We will create a new `rum` component â€“ a `card`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE154]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The card component will accept one argument, a number. This argument is used
    twice inside the properties hash. We will set an ID for this component using the
    number. We will also set a data property with the number.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Once we have the card component, we can create a component that will hold a
    number of cards:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE155]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In this example, we create two cards. Finally, we need to place our cards somewhere.
    A good place is our `main` component. It should look like this now:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE156]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The main content consists of cards and tiles. Even if we went to the web browser,
    we would not see any cards yet. We have to add some styling:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE157]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'After adding styling for a card, the web browser will show us new content:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 9.45: Styled cards'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/B14502_09_45.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 9.45: Styled cards'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Besides two big green tiles, we have two small red cards. The draggable and
    droppable elements are now placed. We are ready to implement the dragging and
    dropping behavior.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'We will add dragging to cards. We will use the `draggable` function from jQuery
    UI. Add code for dragging cards to `hello-clojurescript.core`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE158]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We find HTML elements with the `card` class and use the `$` function from the
    `jayq` library that we imported at the beginning of the section. The `$` function
    will create a jQuery object. We call the `draggable` method on this object, passing
    attributes. Attributes are constructed using a new function, `attrs`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE159]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `attrs` function takes attributes as arguments. We use `sablono`'s `html-to-dom-attrs`
    function to convert all HTML attributes to their DOM equivalents. We convert from
    HTML attributes to DOM attributes because jQuery manipulates the DOM, not HTML.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'We need to import the `sablono` library to the `hello-drag-and-drop.core` namespace:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE160]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `clj->js` function will recursively transform ClojureScript values to JavaScript.
    Sets/vectors/lists become arrays, keywords and symbols become strings, and maps
    become objects. We can code in ClojureScript, and when we need to use JavaScript
    construct `clj->js` will convert the necessary constructs from ClojureScript to
    JavaScript.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The last step is to call `make-draggable` in the `on-reload` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE161]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Figwheel will compile and reload code in the web browser. We can drag the red
    cards now:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 9.46: Dragging the red cards'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/B14502_09_46.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 9.46: Dragging the red cards'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The last piece in our application is implementing the dropping behavior for
    tiles. AÂ `tile` should accept a dragged card.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'For the dropping behavior, we will use the `droppable` function from the jQuery
    UI library:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE162]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Similar to the `make-draggable` function, we use the `$` function to construct
    jQuery objects using the `tile` CSS class. Next, we call the `droppable` function
    from the jQuery UI library passing attributes as arguments.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'We set two attributes. The first one is `:hoverClass`, which takes a value
    of `hovered-tile`. This attribute allows us to add styling when an element is
    hoveredÂ over with the mouse. In `styles.css`, add the following declaration:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE163]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: When we hover over a tile during dragging, its background color will change
    to a shade of blue.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'For the second attribute, `:drop`, we assign the `handle-drop` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE164]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Inside the `handle-drop` function, we specify the behavior when an element is
    dropped. There are a few things happening in the function. We access the `draggable`
    field on the `ui` element using JavaScript interoperability with `.-` (dot and
    hyphen). This field is passed to the `data` function from the `jayq` library to
    access the `data-number` HTML attribute. We print the ID of the dragged element.
    We reset the atom informing that an element has been dropped. We disable the dragged
    element. This will add the `ui-draggable-disabled` CSS class to the element. We
    disable the element into which we dropped, preventing dropping more elements.
    Finally, we set the position of the dropped element to the top left of the droppable
    container
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The `handle-drop` function is a good example of using JavaScript interoperability.
    WeÂ call functions on JavaScript objects and access fields from these objects.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The droppable widget allows us to add a function that is called when an element
    is being dragged:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE165]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In our implementation, we set the `is-element-dropped?` atom to `false`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'We need to add styling to the element that we dropped. In `styles.css`, add
    the following declaration:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE166]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This will set the background color of dropped elements to yellow.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Finally, we will call the `make-droppable` function on `on-js-reload`. It should
    look as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE167]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'When we drop an element in the web browser, we will see the following result:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 9.47: Dropping an element'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/B14502_09_47.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 9.47: Dropping an element'
  prefs: []
  type: TYPE_NORMAL
- en: In this exercise, we have created a drag and drop application. We used JavaScript
    interoperability to access functions, objects, and fields from JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: We did not have any problems when coding this application. There are situations
    when our application does not operate as expected. In the next section, we will
    look atÂ exception and error handling in Clojure.
  prefs: []
  type: TYPE_NORMAL
- en: Exceptions and Errors in Clojure
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In an ideal world, every program runs without any problems. In the real world,
    mistakes happen and programs do not run as planned. Errors and exceptions in Java
    and Clojure are a mechanism for informing developers when such unexpected situations
    occur.
  prefs: []
  type: TYPE_NORMAL
- en: An error indicates a serious problem that an application should not try to catch
    or handle. An exception indicates conditions that an application might want to
    catch. To put it another way, errors are situations from which an application
    cannot recover. Such conditions could be running out of disk space or memory.
    If an application runs out of disk space to save data, there is no possibility
    that this application can serve its purpose. Unless we provide more disk space,
    the application cannot run successfully. Exceptions are conditions from which
    an application can recover. Such a condition could be trying to access a list
    from a database before a connection to the database has been established, or trying
    to use arithmetic operations on strings instead of numbers.
  prefs: []
  type: TYPE_NORMAL
- en: 'Both errors and exceptions are subclasses of the `Throwable` class. This class
    indicates a Java object that can be thrown. Throwing means raising an alert such
    as an error or an exception. Java provides four constructs to deal with errors
    and exceptions:'
  prefs: []
  type: TYPE_NORMAL
- en: '`throw`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`try`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`catch`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`finally`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`throw` allows a developer to raise an exception. We could have a web application
    that accepts user input such as their age. In this application, we could have
    a feature where we check for the user''s age before showing age-restricted content.
    When we perform an arithmetic operation on input, we expect a number from a user.
    If a user puts a string instead, the application cannot carry out such calculations.
    Throwing an error in such a situation will alert the application of an input that
    is not correct. Once we raise an exception or throw an error, we can deal with
    them using the remaining three JavaÂ constructs.'
  prefs: []
  type: TYPE_NORMAL
- en: '`try` is a Java reserved word that allows a developer to write a block of code
    that can potentially result in a `Throwable` object appearing. This code is scoped
    within a `try` block and guarded against errors. Going back to our application,
    an age check will be placed inside a `try` block. When we encounter an error or
    exception, we can handle it. The third construct will help us with that.'
  prefs: []
  type: TYPE_NORMAL
- en: '`catch` is a reserved word in Java that allows a developer to handle and deal
    with exceptions and errors. The block of code under catch is executed when the
    specified exception or error is encountered. In our example, when we try to manipulate
    an age string such as a number, an exception is thrown and the `catch` block is
    executed. In this block, we could return a message to the user that they need
    to input numbers.'
  prefs: []
  type: TYPE_NORMAL
- en: '`finally` is the last reserved word for dealing with exceptions and errors
    in Java. The block of code under `finally` is always executed. There are situations
    when we want to execute code regardless of whether we have encountered an exception
    or not. An example is I/O operations. Opening a file could raise an error if a
    file is not present. If a file is present, an error is not thrown. Opening a file
    uses computer resources such as RAM that we want to free up after we finishing
    reading the file. Closing a file after reading the `finally` block is a common
    practice. It is so common that Clojure provides the `with-open` macro that we
    saw in action in the I/O section of this chapter.'
  prefs: []
  type: TYPE_NORMAL
- en: The most common example of a `try-catch-finally` block is reading or writing
    to a file. Inside the `try` block, we have an operation to read or write to a
    file. The `catch` block would guard against IO exceptions such as file not present.
    In the `finally` block, we would have code to close the file. Closing the file
    releases computer resources for other tasks.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following table presents the most common exceptions and errors in Java:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.48: Common exceptions and errors in Java'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B14502_09_48.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 9.48: Common exceptions and errors in Java'
  prefs: []
  type: TYPE_NORMAL
- en: In the next exercise, we will learn how to use `throw`, `try`, `catch`, and
    `finally` in Clojure.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 9.10: Handling Errors and Exceptions in Clojure'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The aim of this exercise is to learn how exceptions and errors in Clojure are
    handled. It is common that in Clojure we work with data from Java. In this exercise,
    we will create a function that takes a Java `ArrayList` instance and an index.
    The `ArrayList` class is like a vector in Clojure, which we saw in *Chapter 2*,
    *Data Types and Immutability*. The `ArrayList` class stores data. We can access
    elements from the `ArrayList` class using the index, the same as we do with vectors
    in Clojure. Accessing elements from `ArrayList` can cause exceptions. While designing
    our function, we will handle the exceptions raised:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open Terminal and start the REPL:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE168]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: After opening the REPL, we will define an `ArrayList` instance.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'We will create an `ArrayList` containing three numbers:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE169]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We have an array that contains three numbers, zero to two:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE170]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE171]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We will create a function that allows us to access elements from an array.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The `array-list-getter` function will allow us to access elements from an array:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE172]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `array-list-getter` function takes two arguments: an array and an index.
    We access an element from the array using the passed index.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'When we access the element that is present in the array, we get it back:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE173]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE174]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We wanted to get the element at index 1, and we got it back.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'When we try to access an element that is not present, Clojure complains:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE175]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE176]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Our array has only three elements. When we try to access the element at index
    `5`, Clojure raises `IndexOutOfBoundsException`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'We can catch errors thrown by our code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE177]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The new definition of `array-list-getter` catches the `IndexOutOfBoundsException`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE178]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE179]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the `catch` block, we specify what error or exception we want to catch and
    how to handle it. Here, we return information that the array does not have an
    element in the passed index.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'If our code does not throw an exception, the `catch` block is not executed:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE180]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE181]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We have an element at index `1`. The `array-list-getter` function returns this
    number for us. No exception is thrown.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Code in the `finally` block is always executed just before the `try` block
    finishes. This happens even if no exception has been thrown:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE182]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Executing this correct code returns the expected result and prints a message
    that this code always gets executed:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE183]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE184]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We see that when code does not throw any errors or exceptions, only the `finally`
    block is executed and not the `catch` block.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'When our code will throw an error situation, the `catch` and `finally` blocks
    areÂ executed:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE185]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This time, we try to access an element that is not present. This code will raise
    an exception and execute the `finally` block. Instead of getting a number, we
    see two messages in the REPL. One is from the `catch` block and the other from
    the `finally` block.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: In this exercise, we have learned about errors and exceptions. Clojure reuses
    these constructs from Java. Code that can throw errors or exceptions is protected
    by a `try` block. When exceptions are thrown, code in the `catch` block is executed.
    For situations when some code needs to be run regardless of exceptions raised,
    the `finally` block is used.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Like in Java, errors happen in JavaScript as well. In the final section of this
    chapter, we will learn about errors in JavaScript and how to deal with them in
    ClojureScript.
  prefs: []
  type: TYPE_NORMAL
- en: Errors in JavaScript
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous section, we learned about errors and exceptions in Java and
    how to handle them in Clojure. Unexpected situations that lead to problems in
    JavaScript applications also happen. This results in a need to handle errors.
    JavaScript does not distinguish between errors and exceptions, so any situations
    in which code causes the application not to run as expected are errors.
  prefs: []
  type: TYPE_NORMAL
- en: 'Like in Java, in JavaScript, we have tools to deal with errors. JavaScript
    provides four constructs:'
  prefs: []
  type: TYPE_NORMAL
- en: '`throw`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`try`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`catch`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`finally`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They are the same as we saw in the previous section. JavaScript reuses error
    handling concepts known from other languages, such as Java. Because JavaScript
    is not Java, the way we deal with errors in ClojureScript is not 100% the same
    as in Clojure. It's very close, but code pasted from Clojure to ClojureScript
    will not work straight away. In the next exercise, we will see how to deal with
    JavaScript errors in ClojureScript and examine the small syntax differences with
    error handling in Clojure.
  prefs: []
  type: TYPE_NORMAL
- en: ClojureScript Leiningen Templates
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We have used Leiningen to create projects for us. When we create a new project,
    we use a project template. Template developers can publish project templates on
    the internet and other developers (like us) can create projects using such templates.
  prefs: []
  type: TYPE_NORMAL
- en: So far, we have used Figwheel to create ClojureScript projects. As we have learned,
    Figwheel provides a lot of default configuration for us. A new Figwheel project
    comes with features such as hot-code reloading, a REPL, and tests.
  prefs: []
  type: TYPE_NORMAL
- en: There are situations where we do not need all these nice things from Figwheel.
    We want a simple ClojureScript setup. For such cases, we can use a `mies` project
    template. The `mies` template creates a basic project structure for ClojureScript.
  prefs: []
  type: TYPE_NORMAL
- en: To reiterate, for most situations when we want to develop a website application,
    we would use Figwheel. On rare occasions when we want a minimal ClojureScript
    project setup, we will use `mies`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 9.11: Handling Errors in ClojureScript'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The aim of this exercise is to learn how ClojureScript handles JavaScript errors.
    In this exercise, we will write a function that abbreviates programming language
    names. When a programming language is not supported, we will throw an error to
    inform the user that this language is not supported:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create the project:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE186]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This command will create a new project for us.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'We will run the ClojureScript REPL from the command line:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE187]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This launches the REPL.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 9.49: Output for the REPL'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/B14502_09_49.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 9.49: Output for the REPL'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: With REPL launched, we can investigate error handling in ClojureScript.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'In our code, we will support the following languages:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE188]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We will implement a function that abbreviates a programming language name:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE189]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The function will try to get a short version of a language from a language hash
    defined earlier.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: If the language is not found, we will throw an error. The syntax of `throw`
    in ClojureScript is very similar to syntax that we have seen in Clojure. Here,
    instead of Java classes, we have an `Error` object that we access from the `js`
    namespace.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'When a function is called with a valid argument, it returns the abbreviated
    name of a programming language:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE190]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE191]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We see that a short name for JavaScript is `JS`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'When we call a function with an invalid argument, it will throw an error:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE192]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This will return an error as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE193]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We see that Ruby is not a supported language and calling the `language-abbreviator`
    function with Ruby as the argument throws an error. We know how to throw errors
    in ClojureScript. We will see how to catch them now.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'We will create a function that returns the language of the week:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE194]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The function uses Clojure's `rand-nth` function to randomly pick an element
    from a sequence. Using this language, we try to get an abbreviated version of
    a language. If the language is not supported and an error is thrown, we catch
    the error and inform the user that the language is not supported.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Calling the `get-language-of-the-week` function with unsupported languages
    will result in errors:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE195]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE196]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `Go` language was picked as the language of the week. Sadly, we do not have
    an abbreviated name for `Go`. The `language-abbreviator` function threw an error
    that was caught by the `catch` block in the `get-language-of-the-week` function.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'We will call the `get-language-of-the-week` function with supported languages:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE197]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE198]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: When we call the `get-language-of-the-week` function with supported languages,
    we get an abbreviated name for the picked language.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'We will extend our language of the week function to include the `finally` block:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE199]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: With the `finally` block, we can execute any code we want to run regardless
    of errors thrown in our code.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'We will choose a language of the week from the supported languages:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE200]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE201]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: ClojureScript was chosen as the language of the week. The `get-language-of-the-week`
    function returned the abbreviated name of the chosen language and a message from
    the `finally` block.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'We will choose the language of the week from the languages that are not supported:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE202]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE203]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Kotlin was chosen as the language of the week. The `get-language-of-the-week`
    function returned two messages: the message from the `catch` block that Kotlin
    is not a supported language and the message from the `finally` block.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: We have just seen how `try-catch-finally` blocks are used in ClojureScript.
    Using these constructs will help us write code that can deal with many unexpected
    situations.
  prefs: []
  type: TYPE_NORMAL
- en: We now know how to handle exceptions in Clojure and ClojureScript. We have seen
    how to use interoperability between JavaScript and ClojureScript. It is time to
    put our knowledge to use. We will write a ClojureScript application that uses
    JavaScript interoperability.
  prefs: []
  type: TYPE_NORMAL
- en: 'Activity 9.02: Creating a Support Desk'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The aim of this activity is to write a web application that uses external JavaScript
    libraries. We will create a support desk application that manages issues raised
    in the support desk. The application allows us to sort issues and resolve them
    when they are done. By sorting the issues, we can raise the priority of individual
    issues.
  prefs: []
  type: TYPE_NORMAL
- en: 'The application will have the following features:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Display how many times the list has been sorted:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'less than three: few times'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'less than six: medium times'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'more than six: many times'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Filter the list of issues by priority, such as only displaying issues above
    priority 3.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sort the list of issues.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Resolve an issue.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following steps will help you complete the activity:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add the `jayq` and `cuerdas` libraries as dependencies in `project.clj`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create the `utils` function to filter the issues list by priority.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create the `utils` function to get the sorted issues list.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create the `utils` function to get the sorted messages by issue count.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create the `utils` function to delete issues from a list.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create the `utils` function that's called when sorting is finished.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add jQuery and jQuery UI to `index.html`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Import `jayq` ,`cuerdas` and `utils` to the core namespace.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Define the priorities list.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Define app state.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Define the counter Rum component.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create the issue on `click` function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Define the issue item Rum component.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Define the reactive issue items component.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Define the reactive page content component.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Make item components sortable.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Mount the page component.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Call the mount function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Call the sortable function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run the application.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The initial issues list will look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.50: Initial issue list'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B14502_09_50.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 9.50: Initial issue list'
  prefs: []
  type: TYPE_NORMAL
- en: 'The issues list after sorting will look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.51: Issue list after sorting'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B14502_09_51.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 9.51: Issue list after sorting'
  prefs: []
  type: TYPE_NORMAL
- en: 'The issues list after resolving three issues will look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.52: Issue list after resolving issues'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B14502_09_52.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 9.52: Issue list after resolving issues'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The solution for this activity can be found on page 718.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have learned about the interoperability of Clojure and Java.
    We saw how to import Java classes in Clojure. We constructed instances of Java
    classes and called methods on these instances. We have also learned about macros
    that help us use Java in Clojure.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we learned about input/output (I/O) operations in Java. We accessed files
    from a disk, both reading and writing content. We saw how to get input from a
    user using a keyboard and how to display information back to the user.
  prefs: []
  type: TYPE_NORMAL
- en: After that, we learned about interoperability in ClojureScript. We created a
    drag and drop application using objects and methods from JavaScript libraries.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we learned about exceptions and errors in Clojure and ClojureScript.
    We saw how errors are thrown and how to guard against errors using `try-catch`
    blocks. We investigated the `finally` block and when to use it.
  prefs: []
  type: TYPE_NORMAL
- en: We finished the chapter by working on a help desk application that allows users
    to sort a list of items in order of priority.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will investigate testing in Clojure and ClojureScript.
    We will see why testing is important, what libraries both languages provide for
    testing, and how to use testing libraries in Clojure and ClojureScript.
  prefs: []
  type: TYPE_NORMAL
