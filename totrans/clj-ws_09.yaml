- en: 9\. Host Platform Interoperability with Java and JavaScript
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 9. 使用Java和JavaScript实现宿主平台互操作性
- en: Overview
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 概述
- en: In this chapter, we will look at interoperability between Clojure and both Java
    and JavaScript. Clojure runs on top of platforms provided by Java and JavaScript.
    Clojure was designed to use libraries provided by Java or JavaScript. We will
    learn how to access Java and JavaScript objects and methods in Clojure. We will
    also learn how to convert data between Clojure and Java or JavaScript and back.
    After learning how to access Java and JavaScript from Clojure, we will investigate
    how to perform Input-Output (I/O) operations like reading and writing to files
    using Java classes. We will then learn how to deal with errors and exceptions
    in our code.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨Clojure与Java和JavaScript之间的互操作性。Clojure运行在Java和JavaScript提供的平台之上。Clojure被设计为使用Java或JavaScript提供的库。我们将学习如何在Clojure中访问Java和JavaScript对象和方法。我们还将学习如何在Clojure和Java或JavaScript之间转换数据。在学会如何从Clojure访问Java和JavaScript之后，我们将研究如何使用Java类执行输入输出（I/O）操作，如读取和写入文件。然后我们将学习如何处理代码中的错误和异常。
- en: By the end of this chapter, you will be able to work with the appropriate syntax
    and semantics to access Java and JavaScript objects and methods from Clojure,
    and deal with Java exceptions and JavaScript errors.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将能够使用适当的语法和语义从Clojure访问Java和JavaScript对象和方法，并处理Java异常和JavaScript错误。
- en: Introduction
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: In the previous chapter, we learned how to create a Leiningen project. A project
    gives a structure for organizing our code. We structure our project around namespaces.
    We created new namespaces and we imported external Clojure libraries in order
    to use them in our code.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们学习了如何创建Leiningen项目。项目为我们代码的组织提供了一个结构。我们围绕命名空间来构建我们的项目。我们创建了新的命名空间，并导入外部Clojure库以便在代码中使用它们。
- en: Now that you are familiar with using namespaces and creating Clojure projects,
    it is time to become more comfortable with working on projects that use Java and
    JavaScript.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经熟悉了使用命名空间和创建Clojure项目，是时候更加熟悉使用Java和JavaScript的项目工作了。
- en: As we learned in *Chapter 1*, *Hello REPL!*, Clojure compiles to Java bytecode
    and operates on the **Java Virtual Machine** (**JVM**). The JVM is a host platform.
    Any programming language that compiles to Java bytecode can run on the JVM. Because
    Clojure compiles to Java bytecode and runs on the JVM, we call it a hosted language.
    Java dates from the 1990s and is now one of the most popular backend languages.
    We can leverage existing Java libraries instead of writing a lot of code on our
    own. This helps us deliver new features faster.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们在*第一章*，“Hello REPL!”中学到的，Clojure编译成Java字节码并在**Java虚拟机**（**JVM**）上运行。JVM是一个宿主平台。任何编译成Java字节码的编程语言都可以在JVM上运行。因为Clojure编译成Java字节码并在JVM上运行，所以我们称它为宿主语言。Java始于20世纪90年代，现在是最受欢迎的后端语言之一。我们可以利用现有的Java库，而不是自己编写大量代码。这有助于我们更快地交付新功能。
- en: As we will see, importing Java classes in Clojure is a bit different than using
    Clojure libraries. In this chapter, we will learn how to import and call Java
    classes in Clojure by writing an application that performs I/O operations—reading
    and writing from a file.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们将要看到的，在Clojure中导入Java类与使用Clojure库有所不同。在本章中，我们将通过编写一个执行I/O操作（从文件中读取和写入）的应用程序来学习如何在Clojure中导入和调用Java类。
- en: In the second part of this chapter, we will look into ClojureScript and JavaScript
    interoperability. JavaScript is a scripting language that runs in browsers. It
    is the most popular frontend language at the moment. ClojureScript compiles to
    JavaScript. In ClojureScript, we can use JavaScript libraries. This gives us access
    to a huge amount of code written by other developers. A great boost to our productivity.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的第二部分，我们将探讨ClojureScript和JavaScript的互操作性。JavaScript是一种在浏览器中运行的脚本语言。它是目前最受欢迎的前端语言。ClojureScript编译成JavaScript。在ClojureScript中，我们可以使用JavaScript库。这使我们能够访问其他开发者编写的大量代码，极大地提高了我们的生产力。
- en: Using Java in Clojure
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Clojure中使用Java
- en: Any code written by a developer needs to be converted to code that is understood
    by a machine. An interpreter uses code from a developer and compiles it into machine
    code. Each operating system is different, hence the need for platform-specific
    compilers and interpreters. One of the reasons why Java is so successful is that
    it provides the JVM, which takes human-understandable code and converts it into
    machine code. Developers are not usually interested in the JVM. They can focus
    on writing code in Java without interacting with the underlying operating system.
    This job is done by the JVM.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 开发者编写的任何代码都需要转换为机器能理解的代码。解释器使用开发者的代码并将其编译成机器码。每个操作系统都是不同的，因此需要特定平台的编译器和解释器。Java之所以如此成功，其中一个原因就是它提供了JVM，它将人类可理解的代码转换为机器码。开发者通常对JVM不感兴趣。他们可以专注于用Java编写代码，而不必与底层操作系统交互。这项工作由JVM完成。
- en: Clojure is a hosted language. It means that it uses the JVM instead of creating
    a new runtime environment. Clojure cleverly reuses facilities provided by the
    JVM. This is a very powerful approach. Things such as garbage collection, threading,
    concurrency, IO operations (all of which will be explained in the following paragraphs)
    are JVM battle-tested technologies that Clojure relies on.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: Clojure是一种托管语言。这意味着它使用JVM而不是创建一个新的运行时环境。Clojure巧妙地重用了JVM提供的设施。这是一个非常强大的方法。垃圾回收、线程、并发、IO操作（所有这些将在以下段落中解释）都是JVM经过实战检验的技术，Clojure依赖这些技术。
- en: Java garbage collection is the process by which Java programs perform automatic
    memory management. Java programs compile to bytecode that can be run on a JVM.
    When Java programs run on a JVM, objects are created on the heap, which is a portion
    of memory dedicated to the program. Eventually, some objects will no longer be
    needed. The garbage collector finds these unused objects and deletes them to free
    up memory. We could have a vector with usernames in our program. The usernames
    are strings. Each string will occupy some space in memory. When we display a list
    of users on a page, we need this list. When we click on a user and display her
    profile, we do not need information about other users. We could remove this information
    from memory so the memory is available for other data.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: Java垃圾回收是Java程序执行自动内存管理的过程。Java程序编译成可以在JVM上运行的字节码。当Java程序在JVM上运行时，对象会在堆上创建，堆是程序专用的内存部分。最终，一些对象将不再需要。垃圾收集器找到这些未使用的对象并将它们删除以释放内存。在我们的程序中，我们可能有一个包含用户名的向量。用户名是字符串。每个字符串都会在内存中占用一些空间。当我们在一个页面上显示用户列表时，我们需要这个列表。当我们点击一个用户并显示她的个人资料时，我们不需要其他用户的信息。我们可以从内存中删除这些信息，以便内存可用于其他数据。
- en: In concurrent computing several computations and operations are executed during
    overlapping time periods. This is in contrast with sequential programming, where
    one operation must finish before other operations can start. In sequential computing,
    an operation to capitalize a vector of usernames must finish before the second
    operation that finds only admin users can start. In concurrent computing, execution
    of both operations overlaps. We do not need to wait for one to finish before the
    second can start.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在并发计算中，多个计算和操作在重叠的时间段内执行。这与顺序编程形成对比，在顺序编程中，一个操作必须完成，其他操作才能开始。在顺序计算中，将用户名向量首字母大写的操作必须完成，第二个仅查找管理员用户的操作才能开始。在并发计算中，两个操作的执行是重叠的。我们不需要等待一个完成，然后才能开始第二个。
- en: A thread is a lightweight process on the JVM. When a computing program uses
    two or more threads, it runs concurrently. Each part of a program is a separate
    thread. In our usernames example, one thread will filter usernames for admins
    while the other thread will capitalize names.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 线程是在JVM上的轻量级进程。当计算程序使用两个或更多线程时，它们会并发运行。程序的一部分是一个独立的线程。在我们的用户名示例中，一个线程将过滤管理员的用户名，而另一个线程将首字母大写名字。
- en: IO operations are processes that deal with reading from a source, such as a
    keyboard, and writing to a destination, such as a monitor. Java provides support
    for a number of sources and destinations. We can read from a text file and write
    to a printer. Java IO will be covered in this chapter.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: IO操作是处理从源读取（例如键盘）和写入目标（例如显示器）的过程。Java提供了对多个源和目标的支持。我们可以从文本文件中读取并写入打印机。Java IO将在本章中介绍。
- en: As Clojure developers, we have access to an ecosystem of JVM libraries. Because
    Java is one of the most popular languages, by targeting JVM, we join a big community.
    This gives us the benefit of using many well-tested and optimized libraries.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 作为 Clojure 开发者，我们有权访问 JVM 库生态系统。由于 Java 是最受欢迎的语言之一，通过针对 JVM，我们加入了一个庞大的社区。这使我们能够使用许多经过良好测试和优化的库。
- en: In order to use existing Java code, we need to import it to our project. Clojure
    gives us tools to import and operate with Java.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使用现有的 Java 代码，我们需要将其导入到我们的项目中。Clojure 为我们提供了导入和操作 Java 的工具。
- en: 'In the next sections, we will explore tasks such as:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的几节中，我们将探讨以下任务：
- en: Importing Java classes
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 导入 Java 类
- en: Creating new instances of Java classes
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建 Java 类的新实例
- en: We will start with importing Java classes. Clojure provides an `import` function
    to do this job. This function can import a single class or a number of classes.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将开始导入 Java 类。Clojure 提供了一个 `import` 函数来完成这项工作。这个函数可以导入单个类或多个类。
- en: 'Exercise 9.01: Importing a Single Java Class in Clojure'
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 9.01：在 Clojure 中导入单个 Java 类
- en: As we learned in the previous chapter, Clojure code is organized into namespaces.
    Java organizes its code into packages that contain classes. In this exercise,
    we will learn how to import packages and Java classes.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们在上一章所学，Clojure 代码组织到命名空间中。Java 将其代码组织到包含类的包中。在这个练习中，我们将学习如何导入包和 Java 类。
- en: We will explore Java interoperability using a REPL.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用 REPL 探索 Java 互操作性。
- en: 'Open a Terminal and add the following command to start the REPL:'
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开终端并添加以下命令以启动 REPL：
- en: '[PRE0]'
  id: totrans-27
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In order to use a Java class, we need to import it. First, we will import a
    single class. We will start with `BigDecimal` class, which allows us to store
    very large decimal numbers.
  id: totrans-28
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 为了使用 Java 类，我们需要导入它。首先，我们将导入一个单个类。我们将从 `BigDecimal` 类开始，它允许我们存储非常大的十进制数。
- en: 'Call the `import` function with the `BigDecimal` class:'
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `BigDecimal` 类调用 `import` 函数：
- en: '[PRE1]'
  id: totrans-30
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'This will let us know that the class has been imported:'
  id: totrans-31
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这将让我们知道类已经被导入：
- en: '[PRE2]'
  id: totrans-32
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'In Java, we construct an instance of a class using the `new` keyword:'
  id: totrans-33
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在 Java 中，我们使用 `new` 关键字构造类的实例：
- en: '[PRE3]'
  id: totrans-34
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Similarly, in Clojure, we can construct an object from the `BigDecimal` class.
  id: totrans-35
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 类似地，在 Clojure 中，我们可以从 `BigDecimal` 类构造一个对象。
- en: 'Call the `new` function on the `BigDecimal` class to create an instance of
    it:'
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `BigDecimal` 类上调用 `new` 函数以创建其实例：
- en: '[PRE4]'
  id: totrans-37
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Executing the preceding statement in the REPL returns a `BigDecimal` value:'
  id: totrans-38
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在 REPL 中执行前面的语句返回一个 `BigDecimal` 值：
- en: '[PRE5]'
  id: totrans-39
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Often, we want to use a value many times. Storing the value in a variable is
    a good choice:'
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通常，我们希望多次使用一个值。将值存储在变量中是一个不错的选择：
- en: '[PRE6]'
  id: totrans-41
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Calling an instance of the variable in the REPL will give us the value stored
    in `BigDecimal`:'
  id: totrans-42
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在 REPL 中调用变量的实例将给出 `BigDecimal` 中存储的值：
- en: '![Figure 9.1: Printing the value stored in BigDecimal'
  id: totrans-43
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图 9.1：打印 BigDecimal 存储的值]'
- en: '](img/B14502_09_01.jpg)'
  id: totrans-44
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![img/B14502_09_01.jpg]'
- en: 'Figure 9.1: Printing the value stored in BigDecimal'
  id: totrans-45
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 9.1：打印 BigDecimal 存储的值
- en: Clojure provides a special shorthand symbol for constructing class instances
    using a dot, `.`. We place a dot after a class name. In these cases, Clojure assumes
    that we want to construct an instance of a class.
  id: totrans-46
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Clojure 提供了一个特殊的简写符号，用于使用点 `.` 构造类实例。我们在类名后放置一个点。在这些情况下，Clojure 假设我们想要构造类的实例。
- en: The preceding example with `BigDecimal` could have been written using dot notation.
  id: totrans-47
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 前面的 `BigDecimal` 示例可以使用点符号编写。
- en: 'Construct a `BigDecimal` instance using dot notation:'
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用点符号构造 `BigDecimal` 实例：
- en: '[PRE7]'
  id: totrans-49
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Notice the dot after the `BigDecimal` class name:'
  id: totrans-50
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意 `BigDecimal` 类名后面的点：
- en: '![Figure 9.2: Printing the BigDecimal value'
  id: totrans-51
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图 9.2：打印 BigDecimal 值]'
- en: '](img/B14502_09_02.jpg)'
  id: totrans-52
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![img/B14502_09_02.jpg]'
- en: 'Figure 9.2: Printing the BigDecimal value'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.2：打印 BigDecimal 值
- en: We have seen how to import a class and create an instance of it. Very often,
    you would want to import more than one class. In the next exercise, we will investigate
    how to import more than one Java class.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了如何导入一个类并创建其实例。非常常见的情况是，你想要导入多个类。在下一个练习中，我们将研究如何导入多个 Java 类。
- en: Working with Time in Java
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Java 中的时间处理
- en: 'The Java standard library provides the `java.time` and `java.util` packages,
    which contain classes that are useful for working with time. Two useful classes
    are:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: Java 标准库提供了 `java.time` 和 `java.util` 包，其中包含用于处理时间的类。两个有用的类是：
- en: '`Locale`: A class representing a specific geographical region such as `US`
    (United States), `FR` (France).'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Locale`：表示特定地理区域的类，例如 `US`（美国）、`FR`（法国）。'
- en: '`LocalTime`: A class representing time in the current locale. The local time
    for Eastern Europe is two hours ahead of Universal time (London).'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LocalTime`：表示当前区域设置的类。东欧的本地时间比世界时（伦敦）快两小时。'
- en: In this chapter, we will see examples of manipulating time in Java and Clojure.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将看到在 Java 和 Clojure 中操作时间的示例。
- en: 'Exercise 9.02: Importing Multiple Java Classes in Clojure'
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 9.02：在 Clojure 中导入多个 Java 类
- en: 'Importing more than one class can be divided into two actions:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 导入多个类可以分为两个动作：
- en: Importing classes from the same package
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从同一包中导入类
- en: Importing classes from different packages
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从不同包中导入类
- en: 'In order to import more than one class from the same Java package, we will
    use a vector import:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 为了从同一 Java 包中导入多个类，我们将使用向量导入：
- en: 'Call the `import` function with two classes in a vector:'
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用向量调用 `import` 函数，包含两个类：
- en: '[PRE8]'
  id: totrans-66
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Once they are imported, we can use both classes like we have.
  id: totrans-67
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 一旦它们被导入，我们就可以像以前一样使用这两个类。
- en: 'Create an instance of the `BigInteger` class:'
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建 `BigInteger` 类的实例：
- en: '[PRE9]'
  id: totrans-69
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'We will see a new `BigInteger` instance created in the REPL:'
  id: totrans-70
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们将在 REPL 中看到一个新创建的 `BigInteger` 实例：
- en: '[PRE10]'
  id: totrans-71
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Create an instance of the `BigDecimal` class:'
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建 `BigDecimal` 类的实例：
- en: '[PRE11]'
  id: totrans-73
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'We will see a new `BigInteger` instance created in the REPL:'
  id: totrans-74
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们将在 REPL 中看到一个新创建的 `BigInteger` 实例：
- en: '[PRE12]'
  id: totrans-75
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: If we want to import classes from different packages, we specify their full
    names, including the package names.
  id: totrans-76
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果我们想要从不同的包中导入类，我们指定它们的完整名称，包括包名。
- en: 'Import the `LocalTime` class from the `time` package and the `Locale` class
    from the `util` package:'
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 `time` 包导入 `LocalTime` 类和从 `util` 包导入 `Locale` 类：
- en: '[PRE13]'
  id: totrans-78
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Once they are imported, we can construct these classes as we did before.
  id: totrans-79
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 一旦它们被导入，我们就可以像以前一样构造这些类。
- en: 'Create an instance of the `Locale` class using dot notation:'
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用点表示法创建 `Locale` 类的实例：
- en: '[PRE14]'
  id: totrans-81
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The output is as follows:'
  id: totrans-82
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE15]'
  id: totrans-83
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The `LocalTime` class provides static methods to obtain the current time. A
    static method is a class method. We call it on a class and not on an instance
    of the class that we create. In Java, we call the class name followed by the method
    name when we want to use a static method. The static `now` method returns the
    current time:'
  id: totrans-84
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`LocalTime` 类提供了获取当前时间的静态方法。静态方法是一个类方法。我们调用它时，是在类上而不是在我们创建的类的实例上。在 Java 中，当我们想要使用静态方法时，我们调用类名后跟方法名。静态的
    `now` 方法返回当前时间：'
- en: '[PRE16]'
  id: totrans-85
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Here, the static `now` method is called on the `LocalTime` class. The `now`
    method is a static method in the `LocalTime` class. The `now` method returns the
    current time. The time is in the format `hour:minutes:seconds.miliseconds`. Since
    we can run the code at any time, the output will differ in each execution of the
    code:'
  id: totrans-86
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这里，静态的 `now` 方法是在 `LocalTime` 类上调用的。`now` 方法是 `LocalTime` 类中的静态方法。`now` 方法返回当前时间。时间格式为
    `hour:minutes:seconds.miliseconds`。由于我们可以在任何时间运行代码，所以每次执行代码的输出都会不同：
- en: '![Figure 9.3: Printing the local time'
  id: totrans-87
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图 9.3：打印本地时间'
- en: '](img/B14502_09_03.jpg)'
  id: totrans-88
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图片 B14502_09_03.jpg](img/B14502_09_03.jpg)'
- en: 'Figure 9.3: Printing the local time'
  id: totrans-89
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 9.3：打印本地时间
- en: We can also access static methods from the `LocalTime` class in Clojure. This
    is done by stating the class followed by a slash and a method name.
  id: totrans-90
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们还可以在 Clojure 中访问 `LocalTime` 类的静态方法。这是通过声明类后跟一个斜杠和方法名来完成的。
- en: 'Call the static `now` method from the `LocalTime` class using slash notation:'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用斜杠表示法从 `LocalTime` 类调用静态的 `now` 方法：
- en: '[PRE17]'
  id: totrans-92
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The output is similar to the following:'
  id: totrans-93
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出类似于以下内容：
- en: '[PRE18]'
  id: totrans-94
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'A Java class can have static fields—fields that belong to a class and not an
    instance of a class. In Java, we access class fields using a dot. The `LocalTime`
    class has class fields corresponding to the times of the day: the `NOON` field
    indicates the middle of the day, 12:00, and the `MIDNIGHT` field indicates the
    middle of the night, 00:00.'
  id: totrans-95
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 一个 Java 类可以拥有静态字段——属于类而不是类的实例的字段。在 Java 中，我们使用点来访问类字段。`LocalTime` 类有与一天中的时间相对应的类字段：`NOON`
    字段表示中午，12:00，而 `MIDNIGHT` 字段表示午夜，00:00。
- en: 'In order to get the `NOON` field for `LocalTime`, we would write the following:'
  id: totrans-96
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 为了获取 `LocalTime` 的 `NOON` 字段，我们将编写以下内容：
- en: '[PRE19]'
  id: totrans-97
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: This would give us the following
  id: totrans-98
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这将给我们以下结果
- en: '![Figure 9.4: Printing the NOON value'
  id: totrans-99
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图 9.4：打印 NOON 值'
- en: '](img/B14502_09_04.jpg)'
  id: totrans-100
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图片 B14502_09_04.jpg](img/B14502_09_04.jpg)'
- en: 'Figure 9.4: Printing the NOON value'
  id: totrans-101
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 9.4：打印 NOON 值
- en: When we run the code, we are accessing the `NOON` field. In the output, we see
    that noon is at `12:00`. In Clojure, we use the form with a slash, as we have
    just seen when we accessed the static `now` method.
  id: totrans-102
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当我们运行代码时，我们正在访问 `NOON` 字段。在输出中，我们看到中午是 `12:00`。在 Clojure 中，我们使用斜杠形式，就像我们访问静态
    `now` 方法时看到的那样。
- en: 'Access the static `MIDNIGHT` field from the `LocalTime` class using slash notation:'
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用斜杠符号从 `LocalTime` 类访问静态 `MIDNIGHT` 字段：
- en: '[PRE20]'
  id: totrans-104
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The output is as follows:'
  id: totrans-105
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE21]'
  id: totrans-106
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: When we run the code, we are accessing the `MIDNIGHT` field. In the output,
    we see that midnight is at `00:00`.
  id: totrans-107
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当我们运行代码时，我们正在访问 `MIDNIGHT` 字段。在输出中，我们看到午夜是 `00:00`。
- en: As we have just seen, accessing static fields and methods with a slash uses
    the same syntax as the dot.
  id: totrans-108
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 正如我们所看到的，使用斜杠访问静态字段和方法与点操作符使用相同的语法。
- en: If we want to access instance methods, we use the dot operator with a function
    name. In the following example, we will use the `negate` method on `BigDecimal`,
    which negates the value of `BigDecimal`.
  id: totrans-109
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果我们想访问实例方法，我们使用点操作符和函数名。在以下示例中，我们将使用 `BigDecimal` 上的 `negate` 方法，该方法取反 `BigDecimal`
    的值。
- en: 'Call the `negate` function on the `BigDecimal` instance:'
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `BigDecimal` 实例上调用 `negate` 函数：
- en: '[PRE22]'
  id: totrans-111
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The output is as follows:'
  id: totrans-112
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE23]'
  id: totrans-113
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: This was an example of calling a function without any arguments. In the following
    example, we will see how to call an instance method that accepts arguments. The
    `BigDecimal` class provides an exponentiation method, `pow`, that raises the base
    to the specified power. In order to calculate the product of the exponentiation
    of a `BigDecimal` instance, we pass to the power method an integer.
  id: totrans-114
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这是一个调用不带任何参数的函数的例子。在以下示例中，我们将看到如何调用接受参数的实例方法。`BigDecimal` 类提供了一个指数方法 `pow`，该方法将基数提升到指定的幂。为了计算
    `BigDecimal` 实例的指数乘积，我们将整数传递给幂方法。
- en: In Java, we use the `pow` method, as shown in the next step.
  id: totrans-115
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在 Java 中，我们使用 `pow` 方法，如下一步所示。
- en: 'First, we will create a `BigDecimal` instance:'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们将创建一个 `BigDecimal` 实例：
- en: '[PRE24]'
  id: totrans-117
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Then, we will call the `pow` method:'
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们将调用 `pow` 方法：
- en: '[PRE25]'
  id: totrans-119
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'If we printed the call to `pow` method, we would get the following output:'
  id: totrans-120
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果我们打印 `pow` 方法的调用，我们会得到以下输出：
- en: '[PRE26]'
  id: totrans-121
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: In Clojure, we can also use the `pow` method.
  id: totrans-122
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在 Clojure 中，我们也可以使用 `pow` 方法。
- en: 'Call the `pow` method on a `BigDecimal` instance:'
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `BigDecimal` 实例上调用 `pow` 方法：
- en: '[PRE27]'
  id: totrans-124
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'This gives us the following:'
  id: totrans-125
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这给我们以下结果：
- en: '[PRE28]'
  id: totrans-126
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: In this exercise, we imported a number of classes from Java packages. We also
    saw how to call static and instance methods. This allows us to import and use
    any Java classes that we might need.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们从 Java 包中导入了多个类。我们还看到了如何调用静态和实例方法。这使我们能够导入和使用我们可能需要的任何 Java 类。
- en: 'In the next exercise, we will learn about macros, which help us use Java classes
    in Clojure. Syntax in Clojure is very concise. Code written in Clojure is shorter
    than code written in Java. One common pattern in Java is calling multiple methods
    on class instances. The methods are chained together, each operating on the result
    of the previous method call. Clojure provides macros that simplify this method
    chaining. We will learn more about macros in *Chapter 11*, *Macros*. For the purpose
    of this chapter and learning about Java interoperability, we can think about macros
    as functions on steroids. One macro that we have used a lot so far is `let`. With
    `let`, we can create a local variable:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个练习中，我们将了解宏，这些宏帮助我们使用 Clojure 中的 Java 类。Clojure 的语法非常简洁。用 Clojure 编写的代码比用
    Java 编写的代码短。Java 中的一种常见模式是在类实例上调用多个方法。这些方法被链接在一起，每个方法都作用于前一个方法调用的结果。Clojure 提供了简化这种方法链的宏。我们将在第
    11 章 *宏* 中了解更多关于宏的内容。为了本章和了解 Java 互操作性的目的，我们可以将宏视为类固醇上的函数。我们迄今为止使用得很多的宏之一是 `let`。使用
    `let`，我们可以创建一个局部变量：
- en: '[PRE29]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: In this example, `let` allows us to define a variable, `num`, with a value of
    `2`. The plus function adds `3` to our variable. Both `let` and `+` are the first
    elements in their lists. We can see that the use of the `let` macro and the plus
    function is similar.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`let` 允许我们定义一个值为 `2` 的变量 `num`。加法函数将 `3` 添加到我们的变量中。`let` 和 `+` 都是它们列表中的第一个元素。我们可以看到，`let`
    宏和加法函数的使用方式相似。
- en: Clojure macros help us simplify code. We will learn about macros in depth in
    *Chapter 11*, *Macros*. In the meantime, we will see what macros we can use to
    simplify Java interoperability.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: Clojure 宏帮助我们简化代码。我们将在第 11 章 *宏* 中深入了解宏。在此期间，我们将看看我们可以使用哪些宏来简化 Java 互操作性。
- en: 'Exercise 9.03: Macros That Help Us Use Java in Clojure'
  id: totrans-132
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 9.03：帮助我们使用 Clojure 中的 Java 的宏
- en: In this exercise, we will find out the difference in seconds between our time
    zone and the target zone in London (UTC). In order to do this, we will use two
    Java classes from the `time` package. We will chain method calls to get the result.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将找出我们的时区与目标时区伦敦（UTC）之间的秒级差异。为了做到这一点，我们将使用 `time` 包中的两个 Java 类。我们将链式调用方法以获取结果。
- en: The `ZonedDateTime` class contains information about the date and time in specific
    time zones. If we live in India, this class allows us to get the current date
    and time in India as opposed to the current time in London (UTC).
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '`ZonedDateTime` 类包含特定时区中的日期和时间信息。如果我们生活在印度，这个类允许我们获取印度的当前日期和时间，而不是伦敦（UTC）的当前时间。'
- en: 'Import the `ZonedDateTime` class:'
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入 `ZonedDateTime` 类：
- en: '[PRE30]'
  id: totrans-136
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Get an instance of `ZonedDateTime`:'
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取 `ZonedDateTime` 的实例：
- en: '[PRE31]'
  id: totrans-138
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The output is as follows:'
  id: totrans-139
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE32]'
  id: totrans-140
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: In this example, the time zone is in Central Europe in Warsaw.
  id: totrans-141
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这个例子中，时区位于华沙的中央欧洲。
- en: 'Use `getOffset` from `ZonedDateTime`. This will tell us the time difference
    between our time zone and the UTC zone:'
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `ZonedDateTime` 的 `getOffset` 方法。这将告诉我们我们的时区与 UTC 时区之间的时间差：
- en: '[PRE33]'
  id: totrans-143
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The output is as follows:'
  id: totrans-144
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE34]'
  id: totrans-145
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Please note that the preceding statement can be written as follows:'
  id: totrans-146
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 请注意，前面的陈述可以写成以下形式：
- en: '[PRE35]'
  id: totrans-147
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: The statements are equivalent. It is a matter of preference regarding which
    one to use. Most Clojure code uses the `.getOffset` function call, though it is
    good to know the other form in case you ever see it. The time difference between
    Central Europe and London (UTC) is two hours (+2).
  id: totrans-148
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这些语句是等效的。这是一个关于使用哪个的问题。大多数 Clojure 代码使用 `.getOffset` 函数调用，尽管了解其他形式也是好的。中央欧洲和伦敦（UTC）之间的时间差是两小时（+2）。
- en: 'Now that we know the time difference between the zones, we can get this value
    in seconds:'
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们知道了时区之间的时间差，我们可以以秒为单位获取这个值：
- en: '[PRE36]'
  id: totrans-150
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The output is as follows:'
  id: totrans-151
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE37]'
  id: totrans-152
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: In the output, we see that the time difference between Central Europe and London
    is 7,200 seconds. Depending on where you live, the output might differ. What is
    important here is that the method chaining looks verbose. We have two dot operators
    and some parentheses. This already looks confusing, and with more method chaining,
    it will be even more confusing. Luckily, Clojure provides a convenience `..` (dot-dot)
    macro for method chaining.
  id: totrans-153
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在输出中，我们看到中央欧洲和伦敦之间的时间差是 7,200 秒。根据你所在的位置，输出可能会有所不同。重要的是，方法链看起来很冗长。我们有两个点操作符和一些括号。这已经看起来很混乱了，随着更多方法链的使用，它将变得更加混乱。幸运的是，Clojure
    提供了一个方便的 `..`（点号点号）宏用于方法链。
- en: This example can be rewritten using the dot-dot macro.
  id: totrans-154
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这个例子可以使用点号宏重写。
- en: 'Get the time difference in seconds from `ZonedDateTime` using the dot-dot macro:'
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用点号宏从 `ZonedDateTime` 获取秒级的时间差：
- en: '[PRE38]'
  id: totrans-156
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The output is as follows:'
  id: totrans-157
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE39]'
  id: totrans-158
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: The output is the same. The method calls are much easier to read. Whenever you
    need to chain methods on Java objects, the dot-dot macro will simplify the code.
  id: totrans-159
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出是相同的。方法调用更易于阅读。每当您需要在 Java 对象上链式调用方法时，点号宏可以简化代码。
- en: This was an example of calling methods on different objects. Clojure provides
    a `doto` macro for situations where we want to call methods on the same instance
    of a Java class.
  id: totrans-160
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这是一个在不同对象上调用方法的例子。Clojure 提供了一个 `doto` 宏，用于我们想在 Java 类的同一实例上调用方法的情况。
- en: It is common in Java to write a code where it is necessary to make a lot of
    modifications to strings of characters. Consider a situation where we have an
    auto finder on a website. Whenever we type a new character, we need to create
    a new string. With constant typing, this would mean creating many string objects.
    Such objects would occupy lots of memory space. With `StringBuffer`, we create
    one instance and we can add characters to this instance. This saves a lot of memory
    compared to having string objects.
  id: totrans-161
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在 Java 中，编写需要大量修改字符字符串的代码是很常见的。考虑一个我们在网站上有一个自动查找器的情况。每次我们输入一个新字符时，我们需要创建一个新的字符串。随着持续的输入，这意味着会创建许多字符串对象。这些对象会占用大量的内存空间。使用
    `StringBuffer`，我们创建一个实例，并可以向这个实例添加字符。这比拥有字符串对象节省了大量的内存。
- en: 'In Java, we could use `StringBuffer` in the following way:'
  id: totrans-162
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在 Java 中，我们可以像以下这样使用 `StringBuffer`：
- en: '[PRE40]'
  id: totrans-163
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'In Clojure, a sentence can be constructed by calling the append method on the
    `StringBuffer` class as follows:'
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Clojure 中，可以通过在 `StringBuffer` 类上调用 append 方法来构建一个句子，如下所示：
- en: '[PRE41]'
  id: totrans-165
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'The output we get is a sentence:'
  id: totrans-166
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们得到的输出是一个句子：
- en: '[PRE42]'
  id: totrans-167
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: There is a repetition of the word `string`. The `doto` macro eliminates this
    duplication. The `doto` macro will implicitly call functions on instances that
    we specify. The preceding code can be rewritten using `doto`.
  id: totrans-168
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 词语“string”有重复。`doto` 宏消除了这种重复。`doto` 宏会隐式调用我们指定的实例上的函数。前面的代码可以使用 `doto` 重新编写。
- en: 'Construct a sentence using `StringBuffer` and the `doto` macro:'
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `StringBuffer` 和 `doto` 宏构造一个句子：
- en: '[PRE43]'
  id: totrans-170
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'The output is the following sentence:'
  id: totrans-171
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出如下句子：
- en: '[PRE44]'
  id: totrans-172
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: In this example, we eliminated code duplication. With the `doto` macro, we called
    methods on an instance of `StringBuffer`. Once we were done, we converted the
    instance to a string.
  id: totrans-173
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这个例子中，我们消除了代码重复。使用 `doto` 宏，我们在 `StringBuffer` 的实例上调用方法。一旦完成，我们将实例转换为字符串。
- en: In this exercise, we looked at two helpful macros for situations when we need
    to work with Java classes. Often, we call many methods. The `doto` and `dot-dot`
    macros allow us to simplify code that has multiple method calls.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们查看了一些在需要与 Java 类一起工作时很有用的宏。我们经常调用很多方法。`doto` 和 `dot-dot` 宏允许我们简化具有多个方法调用的代码。
- en: In the next topic, we will use our new knowledge of calling Java classes in
    Clojure. We will look into Java IO operations. Then, we will create a coffee-ordering
    application that performs file manipulations.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个主题中，我们将使用我们在 Clojure 中调用 Java 类的新知识。我们将研究 Java IO 操作。然后，我们将创建一个咖啡订购应用程序，该应用程序执行文件操作。
- en: Working with Java I/O
  id: totrans-176
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Java I/O
- en: I/O deals with reading data from a source and writing data to a destination.
    These are some of the most common activities that programs do. Source and destination
    are very broad concepts. You could read from a file or a keyboard and display
    data on a monitor. You could read from a database and write to an API serving
    data. Java provides classes for many sources and destinations for reading and
    writing data.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: I/O 处理从源读取数据并将数据写入目的地。这些是程序执行的一些最常见的活动。源和目的地是非常广泛的概念。你可以从文件或键盘读取数据，并在监视器上显示数据。你也可以从数据库读取数据，并将数据写入提供数据的
    API。Java 为许多读取和写入数据的源和目的地提供了类。
- en: 'In this topic, we will look at the most common I/O cases:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个主题中，我们将查看最常见的 I/O 情况：
- en: Reading and writing to a file
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从文件读取和写入
- en: Reading from a keyboard and writing to a monitor
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从键盘读取并写入监视器
- en: We have already worked with I/O without realizing it. Whenever we start the
    REPL and type on the keyboard, we perform write operations. Similarly, all function
    calls in the REPL print to the monitor, performing output operations.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在不知不觉中处理了 I/O。每次我们启动 REPL 并在键盘上输入时，我们都会执行写入操作。同样，REPL 中的所有函数调用都会打印到监视器上，执行输出操作。
- en: I/O is a huge and difficult topic. Even the people that created Java did not
    get it right in the beginning, as we can see from the number of classes and packages
    for I/O. We have the `java.io` package and the `java.nio` (new IO) package. The
    `java.io` package contains classes for working with input and output in Java.
    This package has methods for reading from sources such as the keyboard and displaying
    to destinations such as a printer or a screen. While the `java.io` package contains
    many useful classes, it is considered complicated. In order to write I/O code,
    we have to use many classes. The newer package, `java.nio` (new I/O), introduces
    new I/O classes that simplify working with input and output in Java.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: I/O 是一个庞大且复杂的话题。即使是创建 Java 的人最初也没有完全搞对，正如我们可以从 I/O 的类和包的数量中看到的那样。我们有 `java.io`
    包和 `java.nio`（新 IO）包。`java.io` 包包含用于在 Java 中处理输入和输出的类。这个包包含从键盘读取和向打印机或屏幕等目的地显示的方法。虽然
    `java.io` 包包含许多有用的类，但它被认为是复杂的。为了编写 I/O 代码，我们必须使用许多类。较新的包 `java.nio`（新 I/O）引入了简化
    Java 中输入和输出工作的新 I/O 类。
- en: Java has many I/O classes because there are many scenarios for using input and
    output. We will see the `PushbackReader` class in action. This class allows us
    to read ahead a few characters to see what is coming, before we determine how
    to interpret the current character. This is useful when we want to read and interpret
    data by taking into account what other data is in the file.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: Java 有许多 I/O 类，因为使用输入和输出的场景有很多。我们将看到 `PushbackReader` 类的实际应用。这个类允许我们在确定如何解释当前字符之前，先读取几个字符来查看接下来是什么。这在我们需要考虑文件中的其他数据来读取和解释数据时非常有用。
- en: Luckily for us, Clojure is a very pragmatic language and provides tools to work
    with I/O. Clojure has a `with-open` macro that helps us to work with files. Opening
    a file, or, to be more precise, any stream of data, uses computer resources such
    as CPU and RAM. After finishing reading from a file, we want to free these resources
    so they are available for other tasks. The `with-open` macro closes the opened
    stream, thus freeing up the resources. Closing resources is done automatically,
    and we do not need to think about closing resources ourselves. This prevents our
    application from slowing down or even crashing if we have many opened resources
    that are not used.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，Clojure是一种非常实用的语言，并提供了处理I/O的工具。Clojure有一个`with-open`宏，它帮助我们处理文件。打开文件，或者更准确地说，任何数据流，都会使用计算机资源，如CPU和RAM。在完成从文件中读取后，我们希望释放这些资源，以便它们可用于其他任务。`with-open`宏关闭打开的流，从而释放资源。关闭资源是自动完成的，我们不需要自己考虑关闭资源。这可以防止我们的应用程序因为有许多未使用的打开资源而变慢或崩溃。
- en: Immutability in Clojure
  id: totrans-185
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Clojure中的不可变性
- en: In *Chapter 2*, *Data Types and Immutability*, we learned about immutability.
    Clojure defaults to immutability. We do not alter data structures but create new
    structures based on existing data. For example, information about employees that
    is stored in a map is updated by creating a new map of employees with the necessary
    changes. The original map of employees is intact and available if we need it.
    As we have learned, this approach prevents many bugs in Clojure when we want to
    access one data structure from many places.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在*第二章*，*数据类型和不可变性*中，我们学习了不可变性。Clojure默认使用不可变性。我们不修改数据结构，而是基于现有数据创建新的结构。例如，存储在映射中的员工信息通过创建一个新的带有必要更改的员工映射来更新。如果需要，原始的员工映射保持完整并可用。正如我们所学的，这种方法可以防止我们在Clojure中从多个地方访问一个数据结构时出现许多错误。
- en: There are times, however, when we want to mutate data. We want to run an application
    by default and stop it when the user selects the exit option. Ref is one of Clojure's
    concurrency primitives. We will learn more about concurrency in Clojure in *Chapter
    12*, *Concurrency*. Now, all we need to know is that with `ref` we can change
    the value of data. We will use ref to control the state of an application that
    we will shortly create.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，有时我们想要修改数据。我们希望默认运行应用程序，并在用户选择退出选项时停止它。Ref是Clojure的并发原语之一。我们将在*第12章*，*并发*中了解更多关于Clojure的并发知识。现在，我们只需要知道，使用`ref`我们可以更改数据的值。我们将使用ref来控制我们即将创建的应用程序的状态。
- en: In the next two exercises, we will create a coffee-ordering app. During the
    development process, we will have the opportunity to work with I/O operations
    such as file reading and writing. We will start by creating a new Leiningen project
    for the frontend part of the application. We will display the coffee menu and
    handle user choices.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的两个练习中，我们将创建一个咖啡订购应用程序。在开发过程中，我们将有机会处理文件读写等I/O操作。我们将首先为应用程序的前端部分创建一个新的Leiningen项目。我们将显示咖啡菜单并处理用户选择。
- en: 'Exercise 9.04: Coffee-Ordering Application – Displaying a Menu'
  id: totrans-189
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习9.04：咖啡订购应用程序 – 显示菜单
- en: In this chapter, we have seen how to use Java classes in Clojure. The aim of
    this exercise is to extend our knowledge of Clojure and Java. We will create a
    coffee-ordering app.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们看到了如何在Clojure中使用Java类。这个练习的目的是扩展我们对Clojure和Java的知识。我们将创建一个咖啡订购应用程序。
- en: 'The app will have the following features:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 该应用程序将具有以下功能：
- en: Display the coffee menu
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 显示咖啡菜单
- en: Be able to order coffee (type and quantity)
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 能够订购咖啡（类型和数量）
- en: Display order confirmation
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 显示订单确认
- en: 'Once we finish the application, we will be able to place orders and display
    them:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们完成应用程序，我们就能下订单并显示它们：
- en: '![Figure 9.5: The coffee application'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.5：咖啡应用程序'
- en: '](img/B14502_09_05.jpg)'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B14502_09_05.jpg)'
- en: 'Figure 9.5: The coffee application'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.5：咖啡应用程序
- en: 'Open the Terminal and create a new Leiningen project:'
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开终端并创建一个新的Leiningen项目：
- en: '[PRE45]'
  id: totrans-200
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: This will create a Leiningen project that's similar to the one we investigated
    in the previous chapter.
  id: totrans-201
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这将创建一个与上一章中我们研究的项目相似的Leiningen项目。
- en: In this application, we will get user input from a keyboard. To help us, we
    will use a Java class called `Scanner` from the `java.util` package.
  id: totrans-202
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这个应用程序中，我们将从键盘获取用户输入。为了帮助我们，我们将使用来自`java.util`包的名为`Scanner`的Java类。
- en: 'Import namespaces to the `core.clj` file:'
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将命名空间导入到`core.clj`文件中：
- en: '[PRE46]'
  id: totrans-204
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: We have imported the `Scanner` class. This class allows us to get input from
    a keyboard. In order to use methods from `Scanner`, we need to create an instance
    of this class.
  id: totrans-205
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们已经导入了`Scanner`类。这个类允许我们从键盘获取输入。为了使用`Scanner`类的方法，我们需要创建这个类的实例。
- en: We also imported the `coffee-app.utils` namespace, where we will have utility
    functions.
  id: totrans-206
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们还导入了`coffee-app.utils`命名空间，其中我们将有实用函数。
- en: 'We will store the menu in a hash. A hash is a Clojure collection that we learned
    about in *Chapter 1*, *Hello REPL* ! In the hash, we use a coffee type such as
    `:latte` as the key. The value of the key is the price:'
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将菜单存储在哈希表中。哈希表是我们在*第一章*，*Hello REPL*中学习到的Clojure集合。在哈希表中，我们使用咖啡类型，例如`:latte`作为键。键的值是价格：
- en: '[PRE47]'
  id: totrans-208
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: In the price menu, the price for `mocha` is `0.4`.
  id: totrans-209
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在价格菜单中，摩卡的价格是`0.4`。
- en: 'Create an instance of the `Scanner` class:'
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建`Scanner`类的实例：
- en: '[PRE48]'
  id: totrans-211
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'We will call methods on this class instance when we want to get input from
    a user. The `Scanner` class needs to know the source of the input. In our case,
    we use the default in source from the `System` class – keyboard. When a user runs
    the application, they should see a menu with options. The options are displaying
    and ordering coffees, listing orders, and exiting the application:'
  id: totrans-212
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当我们想要从用户那里获取输入时，我们将调用这个类实例的方法。`Scanner`类需要知道输入的来源。在我们的情况下，我们使用`System`类的默认输入源——键盘。当用户运行应用程序时，他们应该看到一个带有选项的菜单。这些选项是显示和订购咖啡、列出订单和退出应用程序：
- en: '![Figure 9.6: Options of the coffee application'
  id: totrans-213
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图9.6：咖啡应用程序的选项'
- en: '](img/B14502_09_06.jpg)'
  id: totrans-214
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图片](img/B14502_09_06.jpg)'
- en: 'Figure 9.6: Options of the coffee application'
  id: totrans-215
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图9.6：咖啡应用程序的选项
- en: 'Add the code for displaying the menu and handling user choices:'
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加显示菜单和处理用户选择的代码：
- en: '[PRE49]'
  id: totrans-217
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'In the `start-app` function, we set the application to run by default:'
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`start-app`函数中，我们将应用程序设置为默认运行：
- en: '[PRE50]'
  id: totrans-219
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Concurrency primitives are special. In order to get the values stored in them,
    we use the `deref` function.
  id: totrans-220
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 并发原语是特殊的。为了获取它们存储的值，我们使用`deref`函数。
- en: 'Inside the `while` block, the application runs until the user chooses the exit
    option. In this case, we will update the value of `ref`:'
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`while`块内部，应用程序将一直运行，直到用户选择退出选项。在这种情况下，我们将更新`ref`的值：
- en: '[PRE51]'
  id: totrans-222
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: After updating, `ref` is false. The `while` block will stop when the value of
    ref is `false` and our application will exit.
  id: totrans-223
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 更新后，`ref`变为`false`。当`ref`的值为`false`时，`while`块将停止，我们的应用程序将退出。
- en: 'When our application runs, the user can choose options from the menu:'
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当我们的应用程序运行时，用户可以从菜单中选择选项：
- en: '[PRE52]'
  id: totrans-225
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'This will display the following menu:'
  id: totrans-226
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这将显示以下菜单：
- en: '![Figure 9.7: Choosing the options'
  id: totrans-227
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图9.7：选择选项'
- en: '](img/B14502_09_07.jpg)'
  id: totrans-228
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图片](img/B14502_09_07.jpg)'
- en: 'Figure 9.7: Choosing the options'
  id: totrans-229
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图9.7：选择选项
- en: We are able to display the initial menu. We can work on handling user choices
    from the menu.
  id: totrans-230
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们能够显示初始菜单。我们可以处理用户从菜单中的选择。
- en: 'In order to get the user response, we call the `nextInt` method from the `Scanner`
    instance:'
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了获取用户响应，我们调用`Scanner`实例的`nextInt`方法：
- en: '[PRE53]'
  id: totrans-232
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Finally, once we get the user input, we check which option from the menu should
    be executed:'
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，一旦我们获取了用户输入，我们检查菜单中的哪个选项应该被执行：
- en: '[PRE54]'
  id: totrans-234
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: We now know the logic in the main application menu when we start the app. It
    is time to dig deeper and see the code for the `show-menu` function.
  id: totrans-235
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们现在知道了当启动应用程序时主应用程序菜单中的逻辑。现在是时候深入了解并查看`show-menu`函数的代码。
- en: 'Display the menu:'
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 显示菜单：
- en: '[PRE55]'
  id: totrans-237
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'In the `show-menu` function, we let the user know about the two available coffees,
    latte and mocha:'
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`show-menu`函数中，我们让用户了解两种可用的咖啡，拿铁和摩卡：
- en: '[PRE56]'
  id: totrans-239
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'This will display the coffee menu:'
  id: totrans-240
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这将显示咖啡菜单：
- en: '![Figure 9.8: Displaying the coffee menu'
  id: totrans-241
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图9.8：显示咖啡菜单'
- en: '](img/B14502_09_08.jpg)'
  id: totrans-242
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图片](img/B14502_09_08.jpg)'
- en: 'Figure 9.8: Displaying the coffee menu'
  id: totrans-243
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图9.8：显示咖啡菜单
- en: We need to respond to the user's coffee choice now.
  id: totrans-244
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们现在需要响应用户的咖啡选择。
- en: 'We use a `Scanner` instance to get the user input:'
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们使用`Scanner`实例来获取用户输入：
- en: '[PRE57]'
  id: totrans-246
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Finally, we proceed to buying the coffee that the user chose:'
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们继续购买用户选择的咖啡：
- en: '[PRE58]'
  id: totrans-248
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE58]'
- en: The `show-menu` function is not long. Its purpose is to display the available
    coffees and get the user input. Once the user has chosen, we call the `buy-coffee`
    function to handle buying the selected coffee.
  id: totrans-249
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`show-menu`函数不是很长。它的目的是显示可用的咖啡并获取用户输入。一旦用户选择，我们就调用`buy-coffee`函数来处理购买所选咖啡。'
- en: 'Ask the user how many coffees they want:'
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 询问用户他们想要多少杯咖啡：
- en: '[PRE59]'
  id: totrans-251
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE59]'
- en: The `buy-coffee` function asks how many coffees user wants to buy. Again, we
    use an instance of the Scanner class – `input` – to get the user's choice. Next,
    the function calls two utility functions to process buying. The functions are
    responsible for calculating the coffee price and displaying a feedback message
    to the user.
  id: totrans-252
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`buy-coffee` 函数询问用户想要购买多少杯咖啡。同样，我们使用Scanner类的实例 – `input` – 来获取用户的选择。接下来，该函数调用两个实用函数来处理购买。这些函数负责计算咖啡价格并向用户显示反馈消息。'
- en: All the functions will be placed in the `utils.clj` file. Instead of having
    all the functions in one big file, it is a good practice to split functions into
    various namespaces. A common namespace name is `utils`. We can keep any useful
    functions that operate on data there.
  id: totrans-253
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 所有函数都将放置在 `utils.clj` 文件中。而不是将所有函数放在一个大的文件中，将函数拆分到不同的命名空间中是一种良好的实践。一个常见的命名空间名称是
    `utils`。我们可以将任何有用的操作数据的函数保存在那里。
- en: 'Create the `utils` namespace:'
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建 `utils` 命名空间：
- en: '[PRE60]'
  id: totrans-255
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE60]'
- en: Because the methods that we place in this namespace perform I/O operations,
    we could have called this namespace `coffee-app.io`. In our case, both names for
    namespaces, `utils` and `io`, are valid. In much bigger applications, it is common
    to split the `utils` namespace into different namespaces.
  id: totrans-256
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 因为我们将放置在这个命名空间中的方法执行I/O操作，所以我们本可以将其命名为 `coffee-app.io`。在我们的情况下，命名空间名称 `utils`
    和 `io` 都是有效的。在更大的应用程序中，将 `utils` 命名空间拆分为不同的命名空间是常见的做法。
- en: 'Calculate the coffee price:'
  id: totrans-257
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 计算咖啡价格：
- en: '[PRE61]'
  id: totrans-258
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE61]'
- en: Our first utility function calculates the coffee price. It uses the get function
    to check the `coffees` hash for the passed coffee type. The hash was defined in
    the core namespace. The value obtained from the hash is then multiplied by the
    number of coffee cups that the user ordered. Finally, we convert the number to
    a float. This allows us to convert numbers such as `1.2000000000000002` to `1.2`.
  id: totrans-259
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们的第一个实用函数计算咖啡价格。它使用get函数检查传递的咖啡类型的 `coffees` 哈希。该哈希在核心命名空间中定义。然后，从哈希中获取的值乘以用户订购的咖啡杯数。最后，我们将数字转换为浮点数。这允许我们将
    `1.2000000000000002` 这样的数字转换为 `1.2`。
- en: The last utility function used when we handle buying coffee is the `display-bought-coffee-message`
    function.
  id: totrans-260
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在处理购买咖啡时最后使用的实用函数是 `display-bought-coffee-message` 函数。
- en: 'Display a message to the user after buying coffee:'
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在购买咖啡后向用户显示一条消息：
- en: '[PRE62]'
  id: totrans-262
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE62]'
- en: The `display-bought-coffee-message` function takes an order map and constructs
    a string message for a user based on the data from a map. The user is informed
    that they have bought a certain number of coffee cups for a specified price.
  id: totrans-263
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`display-bought-coffee-message` 函数接受一个订单映射，并根据映射中的数据为用户构建一个字符串消息。用户被告知他们以指定价格购买了一定数量的咖啡杯。'
- en: 'With this function, we can control the information passed back to the user
    after completing the order:'
  id: totrans-264
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 使用此函数，我们可以控制在完成订单后传递给用户的信息：
- en: '[PRE63]'
  id: totrans-265
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'The second option from the main menu allows us to see placed orders:'
  id: totrans-266
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 主菜单中的第二个选项允许我们查看已放置的订单：
- en: '![Figure 9.9: Option 2 to see placed orders'
  id: totrans-267
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图9.9：查看放置的订单的选项2'
- en: '](img/B14502_09_09.jpg)'
  id: totrans-268
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B14502_09_09.jpg)'
- en: 'Figure 9.9: Option 2 to see placed orders'
  id: totrans-269
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图9.9：查看放置的订单的选项2
- en: The function responsible for displaying orders is `show-orders` from the `coffee-app.core`
    namespace.
  id: totrans-270
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 负责显示订单的函数是来自 `coffee-app.core` 命名空间的 `show-orders` 函数。
- en: 'Display placed orders:'
  id: totrans-271
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 显示放置的订单：
- en: '[PRE64]'
  id: totrans-272
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'This function displays the coffee orders placed. In this exercise, we inform
    the user that orders will be displayed here. In the following exercise, we will
    implement saving and displaying orders:'
  id: totrans-273
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此函数显示已放置的咖啡订单。在本练习中，我们通知用户订单将在此处显示。在接下来的练习中，我们将实现保存和显示订单：
- en: '[PRE65]'
  id: totrans-274
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'When we run the application and buy two cups of latte, we will see the following output:'
  id: totrans-275
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当我们运行应用程序并购买两杯拿铁时，我们将看到以下输出：
- en: '![Figure 9.10: Output displaying placed orders'
  id: totrans-276
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图9.10：显示放置的订单输出'
- en: '](img/B14502_09_10.jpg)'
  id: totrans-277
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B14502_09_10.jpg)'
- en: 'Figure 9.10: Output displaying placed orders'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.10：显示放置的订单输出
- en: In this exercise, we learned how to work with I/O and Java in Clojure. We created
    a coffee-ordering application that allowed us to see the coffee menu and order
    coffees.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们学习了如何在Clojure中处理I/O和Java。我们创建了一个允许我们查看咖啡菜单并订购咖啡的咖啡订购应用程序。
- en: In the next exercise, we will extend this application and implement saving coffee
    orders and retrieving orders.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个练习中，我们将扩展此应用程序并实现保存咖啡订单和检索订单。
- en: 'Exercise 9.05: Coffee-Ordering Application – Saving and Loading Orders'
  id: totrans-281
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习9.05：咖啡订购应用程序 – 保存和加载订单
- en: The aim of this exercise is to extend our I/O knowledge. We will learn how to
    save and read from files. We will extend the coffee-ordering application to save
    data to a file and read data from a file.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 本练习的目的是扩展我们的I/O知识。我们将学习如何保存和读取文件。我们将扩展咖啡订购应用程序，以便将数据保存到文件并从文件中读取数据。
- en: 'The application will have the following features:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序将具有以下功能：
- en: Saving orders
  id: totrans-284
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 保存订单
- en: Retrieving orders
  id: totrans-285
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检索订单
- en: Displaying saved orders
  id: totrans-286
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 显示已保存的订单
- en: 'Once we finish the application, we will be able to display orders:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们完成应用程序，我们就能显示订单：
- en: '![Figure 9.11: Output for placed orders'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.11：已放置订单的输出'
- en: '](img/B14502_09_11.jpg)'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/B14502_09_11.jpg](img/B14502_09_11.jpg)'
- en: 'Figure 9.11: Output for placed orders'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.11：已放置订单的输出
- en: 'The main features of this application are saving and loading orders. We will
    create utility functions for this purpose:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 此应用程序的主要功能是保存和加载订单。我们将为此创建实用函数：
- en: 'In order to work with file I/O, we need to import I/O namespaces:'
  id: totrans-292
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了与文件I/O一起工作，我们需要导入I/O命名空间：
- en: '[PRE66]'
  id: totrans-293
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE66]'
- en: We will use the `PushbackReader` Java class to read a file. We will also use
    utilities from the Clojure I/O library.
  id: totrans-294
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们将使用`PushbackReader`Java类来读取文件。我们还将使用Clojure I/O库中的实用工具。
- en: 'The first function that we will implement will save data to a file:'
  id: totrans-295
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将实现的第一项功能是将数据保存到文件：
- en: '[PRE67]'
  id: totrans-296
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE67]'
- en: The `spit` function is a Clojure I/O function that writes to a specified file
    location. With the `:append` keyword set to true, data that we want to store will
    be appended to existing data. Otherwise, every time we save data, new data will
    override the existing file content. After saving a file, we want to retrieve data
    from it.
  id: totrans-297
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`spit`函数是一个Clojure I/O函数，它将数据写入指定的文件位置。当`:append`关键字设置为true时，我们想要存储的数据将被追加到现有数据。否则，每次我们保存数据时，新数据将覆盖现有文件内容。保存文件后，我们希望从文件中检索数据。'
- en: 'In order to retrieve data from a file, we need to make sure that the file exists:'
  id: totrans-298
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了从文件中检索数据，我们需要确保文件存在：
- en: '[PRE68]'
  id: totrans-299
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'The `file-exists?` function calls an I/O function, `as-file`, that returns
    `java.io.File`. Then, we call the `exists` function to check whether we have a
    file in the requested location. The return value of the `file-exists` function
    is a Boolean value. If a file exists, we get `true`:'
  id: totrans-300
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`file-exists?`函数调用一个I/O函数`as-file`，该函数返回`java.io.File`。然后，我们调用`exists`函数来检查我们是否在请求的位置有一个文件。`file-exists`函数的返回值是一个布尔值。如果文件存在，我们得到`true`：'
- en: '![Figure 9.12: Function output as true for file_exists?'
  id: totrans-301
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图9.12：file_exists?函数输出为true'
- en: '](img/B14502_09_12.jpg)'
  id: totrans-302
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![img/B14502_09_12.jpg](img/B14502_09_12.jpg)'
- en: 'Figure 9.12: Function output as true for file_exists?'
  id: totrans-303
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图9.12：file_exists?函数输出为true
- en: 'If the file does not exist, we get `false`:'
  id: totrans-304
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果文件不存在，我们得到`false`：
- en: '![Figure 9.13: Function output as false for file_exists?'
  id: totrans-305
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图9.13：file_exists?函数输出为false'
- en: '](img/B14502_09_13.jpg)'
  id: totrans-306
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![img/B14502_09_13.jpg](img/B14502_09_13.jpg)'
- en: 'Figure 9.13: Function output as false for file_exists?'
  id: totrans-307
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图9.13：file_exists?函数输出为false
- en: Once we know that a file exists, we can load the saved orders.
  id: totrans-308
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 一旦我们知道文件存在，我们就可以加载已保存的订单。
- en: 'We will need to load orders from a file:'
  id: totrans-309
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将需要从文件中加载订单：
- en: '[PRE69]'
  id: totrans-310
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE69]'
- en: The `load-orders` function takes a filename as a parameter. We call the `file-exists?`
    function to check whether we have a file in the requested location. The return
    value of the `file-exists?` function is used in an `if` block in the `load-orders`
    function. If we do not have a file, we return an empty vector. If we have a file,
    we will read its content.
  id: totrans-311
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`load-orders`函数接受一个文件名作为参数。我们调用`file-exists?`函数来检查我们是否在请求的位置有一个文件。`file-exists?`函数的返回值在`load-orders`函数中的`if`块中使用。如果没有文件，我们返回一个空向量。如果有文件，我们将读取其内容。'
- en: We use the `with-open` macro to read from a file. The macro will automatically
    handle closing a file once we finish reading. This will free up computer resources
    for us. We use the `PushbackReader` class to read from a file. This class allows
    us to read ahead a few characters to see what is coming before you can determine
    how to interpret the current character. Our plan is to read orders until we reach
    the end of the file, marked by the `::EOF` keyword. We repeatedly read one order.
  id: totrans-312
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们使用`with-open`宏从文件中读取。宏将在我们完成读取后自动处理关闭文件。这将为我们释放计算机资源。我们使用`PushbackReader`类从文件中读取。此类允许我们在确定如何解释当前字符之前，先读取几个字符来查看接下来会发生什么。我们的计划是读取订单，直到我们到达文件末尾，由`::EOF`关键字标记。我们反复读取一个订单。
- en: We have changed the binding for `read-eval` to `false`. It is not secure to
    read from a file that we do not know. By default, `read-eval` is set to `true`.
    This means that any data that we read can be evaluated. User data or files sent
    over a network should never be trusted. The data that we work with can contain
    malicious code. When we manipulate data in Clojure, the data should always be
    read without evaluating the content of the data.
  id: totrans-313
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们已将`read-eval`的绑定更改为`false`。从我们不知道的文件中读取是不安全的。默认情况下，`read-eval`设置为`true`。这意味着我们读取的任何数据都可以被评估。用户数据或通过网络发送的文件永远不应该被信任。我们处理的数据可能包含恶意代码。当我们用Clojure操作数据时，数据应该始终以不评估数据内容的方式读取。
- en: 'We will use the `read` function from the `clojure.java.io` namespace to read
    each line in the orders file:'
  id: totrans-314
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将使用`clojure.java.io`命名空间中的`read`函数来读取订单文件中的每一行：
- en: '[PRE70]'
  id: totrans-315
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE70]'
- en: Once we reach the end of the file, a Java error is thrown and we catch this
    error. Upon catching the error, we return the `::EOF` keyword, which instructs
    our while loop to stop reading from the file. We will learn more about exceptions
    in Java later on in this chapter. We have our utility functions to save and load
    data to a file. We are ready to use these functions.
  id: totrans-316
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 一旦我们到达文件末尾，就会抛出一个Java错误，我们会捕获这个错误。在捕获错误后，我们返回`::EOF`关键字，这指示我们的while循环停止从文件中读取。我们将在本章后面学习更多关于Java异常的内容。我们有自己的实用函数来保存和加载数据到文件。我们已经准备好使用这些函数。
- en: 'Save the coffee order. The `save-to` function is used to save a coffee order:'
  id: totrans-317
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存咖啡订单。使用`save-to`函数保存咖啡订单：
- en: '[PRE71]'
  id: totrans-318
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE71]'
- en: The `save-coffee-order` function takes the names of files in which to save data,
    the coffee type, the number of cups of coffee, and the price of the order as parameters.
  id: totrans-319
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`save-coffee-order`函数接受要保存数据的文件名、咖啡类型、咖啡杯数和订单价格作为参数。'
- en: Using this data, we construct a map that we pass to the `save-to` function.
    The `save-to` function will save data to the file that we specify.
  id: totrans-320
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 使用这些数据，我们构建一个映射，并将其传递给`save-to`函数。`save-to`函数将数据保存到我们指定的文件中。
- en: After implementing the ability to save coffee orders, we can use this function
    when we handle buying coffee.
  id: totrans-321
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在实现保存咖啡订单的能力后，我们可以使用这个函数来处理购买咖啡。
- en: 'Handle buying coffee. The `buy-coffee` function will be responsible for calculating
    the coffee price, saving the coffee order, and displaying the feedback message
    to the user:'
  id: totrans-322
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 处理购买咖啡。`buy-coffee`函数将负责计算咖啡价格，保存咖啡订单，并向用户显示反馈信息：
- en: '[PRE72]'
  id: totrans-323
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE72]'
- en: In the `buy-coffee` function, we ask how many coffees the user wants to buy.
    We use an instance of the Scanner class – `input` – to get the user's choice.
    Next, the function calls three utility functions to process buying.
  id: totrans-324
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在`buy-coffee`函数中，我们询问用户想要购买多少杯咖啡。我们使用Scanner类的实例`input`来获取用户的选择。接下来，函数调用三个实用函数来处理购买。
- en: After we calculate the order price, we save the order and finally display information
    to the user about the order placed. After placing an order, we are ready to load
    orders in order to display them in the menu.
  id: totrans-325
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在我们计算订单价格后，我们保存订单，并最终向用户显示有关已下订单的信息。在下单后，我们准备好加载订单以便在菜单中显示。
- en: 'We will show orders using the `show-orders` function:'
  id: totrans-326
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将使用`show-orders`函数来显示订单：
- en: '[PRE73]'
  id: totrans-327
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE73]'
- en: In the `show-orders` function, we get orders from the orders file. We iterate
    over a sequence of orders using `doseq`. With `doseq`, for each order, we will
    call the `display-order` function.
  id: totrans-328
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在`show-orders`函数中，我们从订单文件中获取订单。我们使用`doseq`遍历一系列订单。使用`doseq`，对于每个订单，我们将调用`display-order`函数。
- en: 'Data for displaying an order is constructed from an order passed as a parameter
    to the `display-order` function:'
  id: totrans-329
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 显示订单的数据是从传递给`display-order`函数的订单参数中构建的：
- en: '[PRE74]'
  id: totrans-330
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE74]'
- en: The `display-order` function creates a string from an order map. We access information
    about the number of cups bought, the type of coffee bought, and the price of the
    order.
  id: totrans-331
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`display-order`函数从一个订单映射中创建一个字符串。我们访问购买咖啡杯数、购买咖啡类型和订单价格的信息。'
- en: 'After ordering two coffees, we will have the following output:'
  id: totrans-332
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 购买两杯咖啡后，我们将得到以下输出：
- en: '![Figure 9.14: Output for the display-order function'
  id: totrans-333
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![Figure 9.14: Output for the display-order function]'
- en: '](img/B14502_09_14.jpg)'
  id: totrans-334
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![img/B14502_09_14.jpg]'
- en: 'Figure 9.14: Output for the display-order function'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.14：`display-order`函数的输出
- en: In this exercise, we extended our coffee-ordering application. We added functionality
    to save orders to a file and load data from the file. While implementing these
    features, we learned more about Java I/O. These features improved our coffee-ordering
    application.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们扩展了我们的咖啡订购应用程序。我们添加了将订单保存到文件和从文件加载数据的功能。在实现这些功能的过程中，我们学习了更多关于Java I/O的知识。这些功能提高了我们的咖啡订购应用程序。
- en: Working with Java Data Types
  id: totrans-337
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 处理Java数据类型
- en: A data type refers to how data is classified. Any variable or object in Java
    has a specific type. In this book, we have seen types such as strings ("`Paris`"),
    Booleans (`true`, `false`), numbers (`1`, `2`) and collections (`[:one :two :three]`).
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 数据类型指的是数据是如何分类的。Java中的任何变量或对象都有一个特定的类型。在这本书中，我们看到了如字符串("`巴黎`")、布尔值(`true`、`false`)、数字(`1`、`2`)和集合(`[:one
    :two :three]`)这样的类型。
- en: Clojure reuses some of the most common Java data types, such as strings and
    numbers. This is a good approach because Java types have been tested by many developers
    in their code since Java was created in the 90s. This gives us confidence when
    using Java data types. There are some types that are not directly present in Clojure.
    In such cases, we use Java interoperability in Clojure to access Java data types.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: Clojure重用了Java中最常见的几种数据类型，例如字符串和数字。这是一个很好的方法，因为自从90年代Java被创建以来，许多开发者在他们的代码中测试了Java类型。这让我们在使用Java数据类型时有了信心。有一些类型在Clojure中并不直接存在。在这种情况下，我们使用Clojure中的Java互操作性来访问Java数据类型。
- en: When writing applications in Clojure, we can use the data types that we have
    learned about in this book. We can also use data types if we know them from Java.
    In the previous exercises, we learned how to use access methods in Java classes.
    We know how to work with classes now.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 当在Clojure中编写应用程序时，我们可以使用本书中介绍的数据类型。如果我们知道Java中的数据类型，我们也可以使用它们。在前面的练习中，我们学习了如何使用Java类中的访问方法。现在我们知道如何处理类了。
- en: 'In the next exercise, we will learn how to work with Java collections in Clojure.
    Java provides collections such as `ArrayList` and `HashMap`:'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个练习中，我们将学习如何在Clojure中处理Java集合。Java提供了如`ArrayList`和`HashMap`这样的集合：
- en: '`ArrayList` is like a Clojure vector. Elements in an `ArrayList` are stored
    in sequential order.'
  id: totrans-342
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ArrayList`就像Clojure的向量。`ArrayList`中的元素按顺序存储。'
- en: '`HashMap` is like a Clojure hash. Elements in a `HashMap` are stored as key/value
    pairs.'
  id: totrans-343
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`HashMap`就像Clojure的哈希表。`HashMap`中的元素以键/值对的形式存储。'
- en: 'Exercise 9.06: Java Data Types'
  id: totrans-344
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习9.06：Java数据类型
- en: 'The aim of this exercise is to learn how to work with Java data types in Clojure.
    Often, when we work in Clojure we rely on external libraries. There are many Java
    libraries. Knowing how to use Java data types will help us to use Java libraries
    efficiently. In this exercise, we will work on a part of a geography application.
    The application stores information such as countries, capitals, and rivers as
    Java collections. We will write code to convert between Java and Clojure collections:'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 本练习的目的是学习如何在Clojure中处理Java数据类型。通常，当我们使用Clojure工作时，我们依赖于外部库。有许多Java库。了解如何使用Java数据类型将帮助我们有效地使用Java库。在这个练习中，我们将处理一个地理应用程序的一部分。该应用程序将国家、首都和河流等信息作为Java集合存储。我们将编写代码在Java和Clojure集合之间进行转换：
- en: 'Start the REPL using the following command:'
  id: totrans-346
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令启动REPL：
- en: '[PRE75]'
  id: totrans-347
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'It will start as follows:'
  id: totrans-348
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 它将如下开始：
- en: '![Figure 9.15: Output for the REPL'
  id: totrans-349
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图9.15：REPL的输出'
- en: '](img/B14502_09_15.jpg)'
  id: totrans-350
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图片](img/B14502_09_15.jpg)'
- en: 'Figure 9.15: Output for the REPL'
  id: totrans-351
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图9.15：REPL的输出
- en: 'We will create a vector containing some capitals:'
  id: totrans-352
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将创建一个包含一些首都的向量：
- en: '[PRE76]'
  id: totrans-353
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'Check the `capitals` vector:'
  id: totrans-354
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查`capitals`向量：
- en: '[PRE77]'
  id: totrans-355
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'The output is as follows:'
  id: totrans-356
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE78]'
  id: totrans-357
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'We can check the class of our `capitals` vector:'
  id: totrans-358
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以检查我们的`capitals`向量的类：
- en: '[PRE79]'
  id: totrans-359
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'The output is as follows:'
  id: totrans-360
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE80]'
  id: totrans-361
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE80]'
- en: We see that `capitals` is a `PersistentVector` from Clojure.
  id: totrans-362
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们可以看到`capitals`是一个Clojure的`PersistentVector`。
- en: 'Using Clojure''s vector, we can create an `ArrayList` in Java:'
  id: totrans-363
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用Clojure的向量，我们可以在Java中创建一个`ArrayList`：
- en: '[PRE81]'
  id: totrans-364
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'We created an `ArrayList` from a vector. We can check it as follows:'
  id: totrans-365
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们从一个向量创建了一个`ArrayList`。我们可以这样检查它：
- en: '[PRE82]'
  id: totrans-366
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'The output is as follows:'
  id: totrans-367
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE83]'
  id: totrans-368
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'We can check the class for our `destinations` array:'
  id: totrans-369
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以检查我们的`destinations`数组的类：
- en: '[PRE84]'
  id: totrans-370
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'The output is as follows:'
  id: totrans-371
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE85]'
  id: totrans-372
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE85]'
- en: The destinations variable has the `ArrayList` class from Java. We just converted
    from Clojure to Java. We converted the `capitals` vector to the `destinations`
    `ArrayList`.
  id: totrans-373
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 变量`destinations`具有Java的`ArrayList`类。我们刚刚从Clojure转换为Java。我们将`capitals`向量转换为`destinations`
    `ArrayList`。
- en: 'We can also convert the other way. We can convert from Java to Clojure as follows:'
  id: totrans-374
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们也可以进行逆向转换。我们可以这样从Java转换为Clojure：
- en: '[PRE86]'
  id: totrans-375
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE86]'
- en: The `vec` function from the Clojure core library allows us to convert from `ArrayList`
    to a vector.
  id: totrans-376
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Clojure 核心库中的 `vec` 函数允许我们将 `ArrayList` 转换为向量。
- en: 'We can check the class of our newly converted data:'
  id: totrans-377
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以检查我们新转换的数据的类：
- en: '[PRE87]'
  id: totrans-378
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'The output is as follows:'
  id: totrans-379
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE88]'
  id: totrans-380
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE88]'
- en: When we convert from `ArrayList` to a vector, we get the `PersistentVector`
    class in Clojure.
  id: totrans-381
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当我们将 `ArrayList` 转换为向量时，我们得到 Clojure 中的 `PersistentVector` 类。
- en: 'We were able to convert back and forth from Java to Clojure using an ArrayList
    and a vector. Clojure has another collection type that stores data. A hash stores
    data in a key/value pair:'
  id: totrans-382
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们能够使用 ArrayList 和向量在 Java 和 Clojure 之间来回转换。Clojure 有另一种存储数据的集合类型。哈希以键/值对的形式存储数据：
- en: '[PRE89]'
  id: totrans-383
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'We defined a hash containing countries and rivers (fluss in German) in those
    countries:'
  id: totrans-384
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们定义了一个包含国家和这些国家中的河流（在德语中为 fluss）的哈希。
- en: '[PRE90]'
  id: totrans-385
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'The output is as follows:'
  id: totrans-386
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE91]'
  id: totrans-387
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'We can check the `fluss` variable''s class:'
  id: totrans-388
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以检查 `fluss` 变量的类：
- en: '[PRE92]'
  id: totrans-389
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'The output is as follows:'
  id: totrans-390
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE93]'
  id: totrans-391
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE93]'
- en: The `fluss` variable is a `PersistentArrayMap` from Clojure.
  id: totrans-392
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`fluss` 变量是 Clojure 的 `PersistentArrayMap`。'
- en: 'Using Clojure''s hash, we can create a HashMap using Java:'
  id: totrans-393
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 Clojure 的哈希，我们可以使用 Java 创建一个 HashMap：
- en: '[PRE94]'
  id: totrans-394
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE94]'
- en: We create a HashMap from Java using a hash from Clojure.
  id: totrans-395
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们使用 Clojure 的哈希从 Java 创建一个 HashMap。
- en: '[PRE95]'
  id: totrans-396
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 'The output is as follows:'
  id: totrans-397
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE96]'
  id: totrans-398
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE96]'
- en: The `rivers` variable contains countries and the rivers in those countries.
  id: totrans-399
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`rivers` 变量包含国家和这些国家中的河流。'
- en: 'We can check the class of the `rivers` variable as follows:'
  id: totrans-400
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以如下检查 `rivers` 变量的类：
- en: '[PRE97]'
  id: totrans-401
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE97]'
- en: 'The output is as follows:'
  id: totrans-402
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE98]'
  id: totrans-403
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE98]'
- en: We can see that `rivers` is a HashMap from Java.
  id: totrans-404
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们可以看到 `rivers` 是一个 Java 的 HashMap。
- en: 'Using HashMap from Java, we can create a hash in Clojure:'
  id: totrans-405
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 Java 的 HashMap，我们可以创建一个 Clojure 中的哈希：
- en: '[PRE99]'
  id: totrans-406
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE99]'
- en: 'The output is as follows:'
  id: totrans-407
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE100]'
  id: totrans-408
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE100]'
- en: In the preceding code we used the `into` function from Clojure's core library.
    The `into` function takes the destination collection and the source collection
    as the two arguments.
  id: totrans-409
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们使用了 Clojure 核心库中的 `into` 函数。`into` 函数接受目标集合和源集合作为两个参数。
- en: Our destination collection is a hash from Clojure. Remember that we define a
    hash in Clojure using curly brackets, `{}`. We put the content of the `rivers`
    HashMap from Java into a hash `{}` from Clojure.
  id: totrans-410
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们的目标集合是 Clojure 中的一个哈希。记住，我们在 Clojure 中使用花括号 `{}` 定义哈希。我们将 Java 中的 `rivers`
    HashMap 的内容放入 Clojure 的哈希 `{}` 中。
- en: 'We can check the class of our newly converted hash:'
  id: totrans-411
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以检查我们新转换的哈希的类：
- en: '[PRE101]'
  id: totrans-412
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE101]'
- en: 'The output is as follows:'
  id: totrans-413
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE102]'
  id: totrans-414
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE102]'
- en: The class of our converted data is a `PersistentArrayMap` from Clojure.
  id: totrans-415
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们转换后的数据类是 Clojure 的 `PersistentArrayMap`。
- en: In this exercise, we extended our knowledge of Java's interoperability with
    Clojure. We learned how to convert data from Java to Clojure and back again. In
    the following activity, you will use your knowledge of Java interoperability to
    create an application that performs I/O operations.
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们扩展了我们对 Java 与 Clojure 互操作性的知识。我们学习了如何将数据从 Java 转换为 Clojure，然后再转换回来。在接下来的活动中，你将使用你对
    Java 互操作性的知识来创建一个执行 I/O 操作的应用程序。
- en: 'Activity 9.01: Book-Ordering Application'
  id: totrans-417
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 活动九.01：图书订购应用程序
- en: In this activity, we will apply our new knowledge about I/O and Java to create
    a book-ordering application. A media company has decided to create an app that
    allows users to order books. A user can select a year and titles from a list in
    the application. Once a book order has been placed, we should be able to see the
    orders grouped by year.
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个活动中，我们将应用我们对 I/O 和 Java 的新知识来创建一个图书订购应用程序。一家媒体公司决定创建一个允许用户订购图书的应用程序。用户可以从应用程序中的列表中选择年份和标题。一旦用户下单，我们应该能够按年份分组查看订单。
- en: Once you complete the activity, you should have output similar to the following.
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦完成活动，你应该会有以下类似的输出。
- en: 'Initial menu:'
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 初始菜单：
- en: '![Figure 9.16: Menu display'
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 9.16：菜单显示'
- en: '](img/B14502_09_16.jpg)'
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片 B14502_09_16.jpg](img/B14502_09_16.jpg)'
- en: 'Figure 9.16: Menu display'
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.16：菜单显示
- en: 'Listing years:'
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 列出年份：
- en: '![Figure 9.17: Available books by year'
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 9.17：按年份提供的书籍'
- en: '](img/B14502_09_17.jpg)'
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片 B14502_09_17.jpg](img/B14502_09_17.jpg)'
- en: 'Figure 9.17: Available books by year'
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.17：按年份提供的书籍
- en: 'Books in one year:'
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 一年中的书籍：
- en: '![Figure 9.18: Books purchased in 2019'
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 9.18：2019 年购买的书籍'
- en: '](img/B14502_09_18.jpg)'
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片 B14502_09_18.jpg](img/B14502_09_18.jpg)'
- en: 'Figure 9.18: Books purchased in 2019'
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.18：2019 年购买的书籍
- en: 'Asking how many books the user wants to buy:'
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 询问用户想购买多少本书：
- en: '![Figure 9.19: Asking for the number of books to be bought'
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 9.19：询问购买书籍的数量'
- en: '](img/B14502_09_19.jpg)'
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片 B14502_09_19.jpg](img/B14502_09_19.jpg)'
- en: 'Figure 9.19: Asking for the number of books to be bought'
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.19：询问购买书籍的数量
- en: 'Order confirmation message:'
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 订单确认信息：
- en: '![Figure 9.20: Order confirmation message'
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.20：订单确认信息'
- en: '](img/B14502_09_20.jpg)'
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B14502_09_20.jpg)'
- en: 'Figure 9.20: Order confirmation message'
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.20：订单确认信息
- en: 'Listing purchased books:'
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: 列出购买的书籍：
- en: '![Figure 9.21: List of purchased books'
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.21：购买书籍列表'
- en: '](img/B14502_09_21.jpg)'
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B14502_09_21.jpg)'
- en: 'Figure 9.21: List of purchased books'
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.21：购买书籍列表
- en: 'These steps will help you complete the activity:'
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: 这些步骤将帮助你完成活动：
- en: Create a new project.
  id: totrans-445
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的项目。
- en: Import the necessary namespace.
  id: totrans-446
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入必要的命名空间。
- en: Create a map to hold books by year.
  id: totrans-447
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个按年份存储书籍的映射。
- en: Create a variable for a file that stores orders.
  id: totrans-448
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为存储订单的文件创建一个变量。
- en: Create an initial menu with options to order a book and list orders.
  id: totrans-449
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个初始菜单，包含订购书籍和列出订单的选项。
- en: Create a menu to display books by year.
  id: totrans-450
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个按年份显示书籍的菜单。
- en: Create the application's `main` method.
  id: totrans-451
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建应用程序的`main`方法。
- en: Create a function to save data to a file.
  id: totrans-452
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个将数据保存到文件的函数。
- en: Create a function to save an order.
  id: totrans-453
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个保存订单的函数。
- en: Create a function to calculate the `book price`.
  id: totrans-454
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个计算`书籍价格`的函数。
- en: Create a function to display an order confirmation message.
  id: totrans-455
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个显示订单确认信息的函数。
- en: Create a function to display the bought order.
  id: totrans-456
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个显示已购买订单的函数。
- en: Create a function to read a single order.
  id: totrans-457
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个读取单个订单的函数。
- en: Create a function to check whether a file exists.
  id: totrans-458
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个检查文件是否存在的函数。
- en: Create a function to load orders from a file.
  id: totrans-459
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个从文件中加载订单的函数。
- en: Create a submenu to order a book.
  id: totrans-460
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个用于订购书籍的下拉菜单。
- en: Create a function to buy a book by year.
  id: totrans-461
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个按年份购买书籍的函数。
- en: Create a function to show orders by year.
  id: totrans-462
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个按年份显示订单的函数。
- en: Create a submenu to list orders.
  id: totrans-463
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个用于列出订单的下拉菜单。
- en: Note
  id: totrans-464
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 备注
- en: The solution for this activity can be found on page 712.
  id: totrans-465
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此活动的解决方案可以在第712页找到。
- en: Using JavaScript in ClojureScript
  id: totrans-466
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在ClojureScript中使用JavaScript
- en: ClojureScript allows us to use JavaScript constructs. We can call JavaScript
    methods and functions like any other in ClojureScript. When we called Java from
    Clojure we used operators such as `.` dot or `\` slash. Using JavaScript in ClojureScript
    will also require us to learn a new syntax.
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: ClojureScript允许我们使用JavaScript构造。我们可以在ClojureScript中像调用其他方法一样调用JavaScript方法和函数。当我们从Clojure调用Java时，我们使用了`.`点或`\`斜杠这样的运算符。在ClojureScript中使用JavaScript也将需要我们学习新的语法。
- en: 'While Java operates on classes a lot, in JavaScript we operate on objects.
    Two JavaScript constructs that we want to use on objects are:'
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然Java大量操作类，但在JavaScript中我们操作对象。我们想在对象上使用的两个JavaScript构造是：
- en: Methods
  id: totrans-469
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 方法
- en: Fields
  id: totrans-470
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字段
- en: In order to access a method from a JavaScript object, we place `.` (a dot) followed
    by a method name. Accessing a field of an object is very similar. We use `.-`
    (a dot and a hyphen) before the field name. You might wonder why accessing a function
    uses slightly different syntax than accessing a field. In JavaScript, an object
    can have a method and a field with the same name. In ClojureScript, we need a
    way to distinguish between a function call and a field access.
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: 为了从JavaScript对象中访问一个方法，我们在方法名前放置一个点（`.`）。访问对象的字段与访问字段非常相似。我们在字段名前使用`.-`（一个点和短横线）。你可能想知道为什么访问函数的语法与访问字段略有不同。在JavaScript中，一个对象可以有一个与字段同名的函数和字段。在ClojureScript中，我们需要一种方法来区分函数调用和字段访问。
- en: 'In JavaScript, the code looks as follows:'
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: 在JavaScript中，代码如下：
- en: '[PRE103]'
  id: totrans-473
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: 'In ClojureScript, the code looks as follows:'
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: 在ClojureScript中，代码如下：
- en: '[PRE104]'
  id: totrans-475
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: 'Let''s take a minute to appreciate the design of ClojureScript. We learned
    at the beginning of the book about ClojureScript functions and how to call them.
    Essentially, it is the same syntax as in Clojure. Unless we have a sequence, the
    first position in a list is treated as a function:'
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们花一分钟来欣赏ClojureScript的设计。我们在书的开始部分学习了ClojureScript函数及其调用方法。本质上，它与Clojure的语法相同。除非我们有一个序列，否则列表中的第一个位置被视为一个函数：
- en: '[PRE105]'
  id: totrans-477
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: 'Calling `range` will return a sequence of numbers from 1 to 10:'
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: 调用`range`将返回从1到10的数字序列：
- en: '![Figure 9.22: Output for calling range'
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.22：调用range的输出'
- en: '](img/B14502_09_22.jpg)'
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B14502_09_22.jpg)'
- en: 'Figure 9.22: Output for calling range'
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.22：调用range的输出
- en: Here, `range` is in the first position and the ClojureScript compiler rightly
    treats `range` as a function. We have just seen how to call JavaScript methods
    and fields. With the addition of a dot or a hyphen, nothing changes in the syntax.
    This uniformity of placing method calls in the first position in ClojureScript
    reduces the mental burden on developers. We do not need to learn a lot of special
    syntax for JavaScript interoperability.
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`range` 处于第一个位置，ClojureScript 编译器正确地将 `range` 视为一个函数。我们刚刚看到了如何调用 JavaScript
    方法和字段。通过添加一个点或连字符，语法没有任何变化。这种在 ClojureScript 中将方法调用放在第一个位置的统一性减轻了开发者的心理负担。我们不需要学习很多特殊的语法来实现
    JavaScript 互操作性。
- en: We will see this uniformity when we compare using the `range` function and checking
    the length of a string.
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们比较使用 `range` 函数和检查字符串长度时，我们将看到这种一致性。
- en: 'We call the `range` function in this way:'
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: 我们这样调用 `range` 函数：
- en: '[PRE106]'
  id: totrans-485
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: 'It will work as follows:'
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: 它将按以下方式工作：
- en: '![Figure 9.23: Calling the range function'
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 9.23：调用 range 函数'
- en: '](img/B14502_09_23.jpg)'
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B14502_09_23.jpg)'
- en: 'Figure 9.23: Calling the range function'
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.23：调用 range 函数
- en: 'Checking the length of a string is done in the following way:'
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: 检查字符串长度的方式如下：
- en: '![Figure 9.24: Checking the length of a string'
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 9.24：检查字符串长度'
- en: '](img/B14502_09_24.jpg)'
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B14502_09_24.jpg)'
- en: 'Figure 9.24: Checking the length of a string'
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.24：检查字符串长度
- en: The `range` function and accessing the length field of a JavaScript string are
    both placed in the first position in a statement.
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
  zh: '`range` 函数和访问 JavaScript 字符串的长度字段都放在语句的第一个位置。'
- en: What is even more amazing is that ClojureScript improves on JavaScript. In JavaScript,
    there is no concept of a namespace. When we define a function or a variable, it
    belongs to a global namespace. This poses a problem when two or more libraries
    use the same name for a variable or a method. This causes a conflict and gives
    us errors. Library designers use JavaScript objects as modules/namespaces and
    place functions in their objects. This is, however, only a workaround and not
    a language design. In ClojureScript, namespaces are first-class citizens designed
    in the language.
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
  zh: 更令人惊讶的是，ClojureScript 在 JavaScript 之上进行了改进。在 JavaScript 中，没有命名空间的概念。当我们定义一个函数或变量时，它属于全局命名空间。当两个或多个库使用相同的变量或方法名称时，这会引发冲突并导致错误。库设计者使用
    JavaScript 对象作为模块/命名空间，并将函数放在它们的对象中。然而，这只是一个权宜之计，而不是语言设计。在 ClojureScript 中，命名空间是语言中一等公民。
- en: We should pay attention to one namespace. ClojureScript uses the `js` namespace
    to refer to the global scope of a program. Core JavaScript objects such as `Number`,
    `String`, and `Date` are accessed in ClojureScript using the `js` namespace. In
    this namespace, we will also find browser-defined objects such as `window`.
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该注意一个命名空间。ClojureScript 使用 `js` 命名空间来引用程序的全局作用域。在 ClojureScript 中，像 `Number`、`String`
    和 `Date` 这样的核心 JavaScript 对象都通过 `js` 命名空间访问。在这个命名空间中，我们还会找到浏览器定义的对象，如 `window`。
- en: In order to construct a JavaScript object, we use the object's name followed
    by a dot. This is the same syntax we used to construct an instance of a Java class
    in Clojure.
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
  zh: 为了构造一个 JavaScript 对象，我们使用对象的名称后跟一个点。这是我们之前在 Clojure 中构造 Java 类实例时使用的相同语法。
- en: 'In JavaScript, the code looks as follows:'
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
  zh: 在 JavaScript 中，代码看起来如下：
- en: '[PRE107]'
  id: totrans-499
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: 'In ClojureScript, the code looks as follows:'
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ClojureScript 中，代码看起来如下：
- en: '[PRE108]'
  id: totrans-501
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: Notice that we use the `js` namespace. As was mentioned in this section, core
    JavaScript objects such as Number are accessed through this namespace.
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我们使用了 `js` 命名空间。正如本节所述，核心 JavaScript 对象如 Number 是通过这个命名空间访问的。
- en: 'ClojureScript takes advantage of JavaScript data types. ClojureScript does
    not invent new data types but reuses existing JavaScript data types. The following
    table presents ClojureScript data types and their JavaScript origin:'
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
  zh: ClojureScript 利用 JavaScript 数据类型。ClojureScript 并不发明新的数据类型，而是重用现有的 JavaScript
    数据类型。以下表格展示了 ClojureScript 数据类型及其 JavaScript 来源：
- en: '![Figure 9.25: ClojureScript data types with their origins'
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 9.25：ClojureScript 数据类型及其来源'
- en: '](img/B14502_09_25.jpg)'
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B14502_09_25.jpg)'
- en: 'Figure 9.25: ClojureScript data types with their origins'
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.25：ClojureScript 数据类型及其来源
- en: As we can see, data types often used in ClojureScript are based on JavaScript
    data types.
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，在 ClojureScript 中常用到的数据类型都是基于 JavaScript 数据类型的。
- en: We have seen how to access JavaScript in ClojureScript. In the next exercise,
    we will learn how to work with JavaScript data types in ClojureScript.
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了如何在 ClojureScript 中访问 JavaScript。在下一个练习中，我们将学习如何在 ClojureScript 中处理 JavaScript
    数据类型。
- en: 'Exercise 9.07: Working with JavaScript Data Types'
  id: totrans-509
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 9.07：使用 JavaScript 数据类型
- en: 'The aim of this exercise is to learn how to work with JavaScript data types
    in ClojureScript. We will learn how to convert ClojureScript data to JavaScript
    objects. Later, we will learn the reverse process of how to convert JavaScript
    objects to ClojureScript data:'
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
- en: 'We will create a new project for our code:'
  id: totrans-511
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE109]'
  id: totrans-512
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE109]'
- en: This command creates a basic ClojureScript project called `js-interop`.
  id: totrans-513
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: We will start the REPL with the following command.
  id: totrans-514
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE110]'
  id: totrans-515
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE110]'
- en: 'The output is as follows:'
  id: totrans-516
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 9.26: Output of the REPL'
  id: totrans-517
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/B14502_09_26.jpg)'
  id: totrans-518
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 9.26: Output of the REPL'
  id: totrans-519
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'ClojureScript provides the `js-obj` function for creating a JavaScript object
    from ClojureScript data:'
  id: totrans-520
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE111]'
  id: totrans-521
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE111]'
- en: 'The output is as follows:'
  id: totrans-522
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE112]'
  id: totrans-523
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE112]'
- en: Calling the `js-obj` function created a new JavaScript object. Notice the `#js`
    in the REPL. This symbol in the REPL informs us that the following expression
    is a JavaScript object.
  id: totrans-524
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Frequently, we use nested structures where one object contains another object:'
  id: totrans-525
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE113]'
  id: totrans-526
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE113]'
- en: 'The output is as follows:'
  id: totrans-527
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 9.27: Nested structures'
  id: totrans-528
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/B14502_09_27.jpg)'
  id: totrans-529
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 9.27: Nested structures'
  id: totrans-530
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The `rivers-map-js` object is a nested structure. It contains a country key,
    the value of which is another object with some river details.
  id: totrans-531
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'We can access fields in the `rivers-map-js` object:'
  id: totrans-532
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE114]'
  id: totrans-533
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE114]'
- en: 'The output is as follows:'
  id: totrans-534
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE115]'
  id: totrans-535
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE115]'
- en: 'After accessing country, we got nested data about rivers. We will try to access
    this nested data:'
  id: totrans-536
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE116]'
  id: totrans-537
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE116]'
- en: 'The output is as follows:'
  id: totrans-538
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE117]'
  id: totrans-539
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE117]'
- en: When we try to get information about a river, we get `nil`. It turns out that
    we cannot access data using JavaScript interoperability. The reason is because
    the `js-obj` function is shallow. It does not transform nested data structures
    to JavaScript objects. If we want to transfer nested ClojureScript data to JavaScript
    objects we need to use some other method.
  id: totrans-540
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'In order to transform all nested data, we need to use the `clj->js` function:'
  id: totrans-541
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE118]'
  id: totrans-542
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE118]'
- en: 'The output is as follows:'
  id: totrans-543
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE119]'
  id: totrans-544
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE119]'
- en: 'With the `clj->js` function, we are able to convert nested ClojureScript data:'
  id: totrans-545
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE120]'
  id: totrans-546
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE120]'
- en: 'The output is as follows:'
  id: totrans-547
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE121]'
  id: totrans-548
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE121]'
- en: Notice the two `#js` symbols. Each symbol informs us that we have a JavaScript
    object. The first object contains the name of a country. Inside this country object,
    we have another JavaScript object with the name of a river.
  id: totrans-549
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'When we have nested JavaScript objects, we can access data from them using
    JavaScript interoperability:'
  id: totrans-550
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE122]'
  id: totrans-551
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE122]'
- en: 'The output is as follows:'
  id: totrans-552
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE123]'
  id: totrans-553
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE123]'
- en: We were able to access nested JavaScript objects using JavaScript interoperability.
  id: totrans-554
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'So far, we have converted from ClojureScript to JavaScript. It is possible
    to convert the other way, from JavaScript to ClojureScript:'
  id: totrans-555
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE124]'
  id: totrans-556
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE124]'
- en: 'The output is as follows:'
  id: totrans-557
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE125]'
  id: totrans-558
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE125]'
- en: Using the `#js` symbol, we converted a JavaScript object to ClojureScript data.
  id: totrans-559
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Convert nested JavaScript objects to ClojureScript data:'
  id: totrans-560
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE126]'
  id: totrans-561
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE126]'
- en: 'The output is as follows:'
  id: totrans-562
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE127]'
  id: totrans-563
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE127]'
- en: Using the `js->clj` function, we again converted from JavaScript objects to
    ClojureScript data. Notice that we used the `#js` symbol twice. Every time we
    have a JavaScript object, we have to mark it using the `#js` symbol. This instructs
    ClojureScript to treat the following data as a JavaScript object.
  id: totrans-564
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 使用`js->clj`函数，我们再次将JavaScript对象转换为ClojureScript数据。请注意，我们使用了`#js`符号两次。每次我们有一个JavaScript对象时，我们必须使用`#js`符号来标记它。这指示ClojureScript将以下数据视为JavaScript对象。
- en: In this exercise, we learned how to convert ClojureScript data to JavaScript
    objects. Then we saw how to reverse the process and convert from JavaScript objects
    to ClojureScript data.
  id: totrans-565
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这个练习中，我们学习了如何将ClojureScript数据转换为JavaScript对象。然后我们看到了如何逆向操作，将JavaScript对象转换为ClojureScript数据。
- en: We are ready to start building ClojureScript applications. In *Chapter 8*, *Namespaces,
    Libraries, and Leiningen*, we learned about structuring projects and using Leiningen
    to create Clojure projects. We can use Leiningen to create ClojureScript projects
    as well. Using Leiningen templates to create ClojureScript applications will create
    the necessary configuration for working in ClojureScript. One of the most common
    ClojureScript templates is the Figwheel template. We will learn about this template
    in the next topic.
  id: totrans-566
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经准备好开始构建ClojureScript应用程序。在*第8章*，*命名空间、库和Leiningen*中，我们学习了如何构建项目和如何使用Leiningen创建Clojure项目。我们也可以使用Leiningen创建ClojureScript项目。使用Leiningen模板创建ClojureScript应用程序将创建在ClojureScript中工作的必要配置。最常用的ClojureScript模板之一是Figwheel模板。我们将在下一主题中学习这个模板。
- en: Figwheel Template
  id: totrans-567
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Figwheel模板
- en: Figwheel is a tool that compiles ClojureScript code. One of the selling points
    of Figwheel is hot-code reloading. When we make changes to ClojureScript files,
    the code will be recompiled and a page in a browser will be updated. This helps
    to speed up the development process by giving quick feedback to programmers.
  id: totrans-568
  prefs: []
  type: TYPE_NORMAL
  zh: Figwheel是一个编译ClojureScript代码的工具。Figwheel的一个卖点是热代码重新加载。当我们对ClojureScript文件进行更改时，代码将被重新编译，浏览器中的一个页面将被更新。这有助于通过给程序员提供快速反馈来加快开发过程。
- en: Figwheel not only reloads our code, but is intelligent with code reloading.
    Figwheel gives us compiler errors when we make changes in our code that result
    in faulty code.
  id: totrans-569
  prefs: []
  type: TYPE_NORMAL
  zh: Figwheel不仅重新加载我们的代码，而且在代码重新加载方面非常智能。当我们对代码进行更改导致代码错误时，Figwheel会给我们编译错误。
- en: 'If we try to use a function that is not declared, Figwheel will inform us:'
  id: totrans-570
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们尝试使用未声明的函数，Figwheel会通知我们：
- en: '![Figure 9.28: Message from Figwheel'
  id: totrans-571
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.28：Figwheel的消息'
- en: '](img/B14502_09_28.jpg)'
  id: totrans-572
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B14502_09_28.jpg)'
- en: 'Figure 9.28: Message from Figwheel'
  id: totrans-573
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.28：Figwheel的消息
- en: Figwheel informed us that on line 42 in the `core.cljs` file we tried to call
    a `handle-sort-finish` function without declaring it.
  id: totrans-574
  prefs: []
  type: TYPE_NORMAL
  zh: Figwheel通知我们，在`core.cljs`文件的第42行，我们尝试调用一个未声明的`handle-sort-finish`函数。
- en: With this concise and high-quality feedback from Figwheel, we can develop ClojureScript
    applications faster than if we had to dig through errors in stack traces. Or worse,
    our application runs but gives unexpected results.
  id: totrans-575
  prefs: []
  type: TYPE_NORMAL
  zh: 通过Figwheel提供的这种简洁且高质量的反馈，我们可以比在堆栈跟踪中挖掘错误时更快地开发ClojureScript应用程序。或者更糟，我们的应用程序运行但给出意外的结果。
- en: Figwheel supports an interactive programming style. Changes made in our code
    base are recompiled and displayed in a web browser. We learned in *Chapter 1*,
    *Hello REPL!*, that Clojure uses immutable data structures by default. You can
    reload function definitions all day long. They are side-effect free and not tied
    to the local state of a running system. This means that running the same function
    many times does not change the state of an application. Recompiling and reloading
    is thus safe.
  id: totrans-576
  prefs: []
  type: TYPE_NORMAL
  zh: Figwheel支持交互式编程风格。我们在代码库中做出的更改将被重新编译并在网页浏览器中显示。我们在*第1章*，*Hello REPL!*中学习了Clojure默认使用不可变数据结构。你可以整天重新加载函数定义。它们是无副作用的，并且与运行系统的本地状态无关。这意味着运行相同的函数多次不会改变应用程序的状态。因此，重新编译和重新加载是安全的。
- en: Figwheel encourages using React to develop applications. React is a web tool
    that allows us to manipulate elements on a page. React allows you to write functions
    that express what the state of such elements should be given the current application
    state.
  id: totrans-577
  prefs: []
  type: TYPE_NORMAL
  zh: Figwheel鼓励使用React来开发应用程序。React是一个允许我们在页面上操作元素的Web工具。React允许你编写函数，这些函数表达的是给定当前应用程序状态，这些元素的当前状态应该是什么。
- en: In the next section, we will learn about Rum. Rum is a library used to create
    HTML elements on a page using application state.
  id: totrans-578
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节，我们将学习关于Rum的内容。Rum是一个库，用于在页面上使用应用程序状态创建HTML元素。
- en: Reactive Web Programming Using Rum
  id: totrans-579
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Rum进行响应式Web编程
- en: Many websites allow users to interact with web pages. Users can click, drag,
    and sort elements. These pages are dynamic – they respond to user actions. A programming
    page that reacts to user interactions is called reactive programming.
  id: totrans-580
  prefs: []
  type: TYPE_NORMAL
  zh: 许多网站允许用户与网页交互。用户可以点击、拖动和排序元素。这些页面是动态的——它们会对用户操作做出响应。一个对用户交互做出反应的编程页面称为响应式编程。
- en: HTML provides a structure of elements on a page. The **Document Object Model**
    (**DOM**) is a representation of HTML in JavaScript. JavaScript allows us to operate
    on DOM elements that are finally displayed as HTML elements on a web page.
  id: totrans-581
  prefs: []
  type: TYPE_NORMAL
  zh: HTML 提供了页面元素的结构。**文档对象模型**（**DOM**）是 JavaScript 中的 HTML 表示。JavaScript 允许我们在最终显示为网页
    HTML 元素的 DOM 元素上操作。
- en: One way to make a page react to user actions is to render (display) that whole
    page again. Rendering a whole page consumes computer resources. If only a small
    part of the page needs re-rendering, we waste precious resources re-rendering
    the entire page. Fortunately for us, there is a solution that allows us to re-render
    only the parts of a page that have changed.
  id: totrans-582
  prefs: []
  type: TYPE_NORMAL
  zh: 使页面能够对用户操作做出反应的一种方法是通过重新渲染（显示）整个页面。渲染整个页面会消耗计算机资源。如果只有页面的一小部分需要重新渲染，我们就会浪费宝贵的资源重新渲染整个页面。幸运的是，我们有一个解决方案，它允许我们只重新渲染页面已更改的部分。
- en: React.js is a JavaScript library that supports reactive programming. The basic
    block of React.js is a component. In React.js, we define what components should
    look like and how they should behave. With React.js, we can create components
    based on the current application state. Changes in state result in re-rendering
    components that require a change. React internally checks which parts of the application
    state have changed and which components rely on these parts of state. As a result,
    React re-renders only those components that used parts of the application state
    that have changed.
  id: totrans-583
  prefs: []
  type: TYPE_NORMAL
  zh: React.js 是一个支持响应式编程的 JavaScript 库。React.js 的基本块是组件。在 React.js 中，我们定义组件的外观和行为。使用
    React.js，我们可以根据当前应用程序的状态创建组件。状态的变化会导致需要更改的组件重新渲染。React 内部检查应用程序状态哪些部分已更改，哪些组件依赖于这些状态部分。因此，React
    只重新渲染那些使用了应用程序状态中已更改部分的部分。
- en: Rum is a Clojure library for creating HTML elements on a web page. Rum is based
    on React.js. We often have some state in a ClojureScript application. A state
    could be a list of users. We can manipulate a list of users by adding or removing
    users, and based on our actions a web page should update. In Rum, it is possible
    to define page elements such as a user entry that will react to changes to the
    list of users. Adding a new user will result in a page displaying an updated list
    of users.
  id: totrans-584
  prefs: []
  type: TYPE_NORMAL
  zh: Rum 是一个用于在网页上创建 HTML 元素的 Clojure 库。Rum 基于 React.js。我们通常在 ClojureScript 应用程序中有些状态。状态可能是一组用户。我们可以通过添加或删除用户来操作用户列表，并且基于我们的操作，网页应该更新。在
    Rum 中，可以定义页面元素，如用户条目，它将根据用户列表的变化做出反应。添加新用户将导致页面显示更新后的用户列表。
- en: In the next exercise, we will create a Figwheel project that uses Rum and explore
    what benefits Figwheel and Rum provide for developers.
  id: totrans-585
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个练习中，我们将创建一个使用 Rum 的 Figwheel 项目，并探索 Figwheel 和 Rum 为开发者提供的优势。
- en: 'Exercise 9.08: Investigating Figwheel and Rum'
  id: totrans-586
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 9.08：调查 Figwheel 和 Rum
- en: 'The aim of this exercise is to learn about Figwheel and Rum. Figwheel will
    create a ClojureScript project structure for us. Rum will allow us to build HTML
    components that respond to user actions:'
  id: totrans-587
  prefs: []
  type: TYPE_NORMAL
  zh: 本练习的目的是了解 Figwheel 和 Rum。Figwheel 将为我们创建 ClojureScript 项目结构。Rum 将允许我们构建对用户操作做出响应的
    HTML 组件：
- en: 'Create the Figwheel and Rum project:'
  id: totrans-588
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建 Figwheel 和 Rum 项目：
- en: '[PRE128]'
  id: totrans-589
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE128]'
- en: We use Leiningen to call the `fighwheel-main` template. This template will create
    a new ClojureScript project with a main namespace called `hello-clojuresript.core`.
  id: totrans-590
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们使用 Leiningen 调用 `fighwheel-main` 模板。此模板将创建一个名为 `hello-clojuresript.core` 的主命名空间的新
    ClojureScript 项目。
- en: 'We want to use Rum, so we pass the `--rum` command-line parameter to add Rum
    support to the project:'
  id: totrans-591
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们想使用 Rum，因此我们传递 `--rum` 命令行参数以将 Rum 支持添加到项目中：
- en: '![Figure 9.29: Creating a Figwheel and Rum project'
  id: totrans-592
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图 9.29：创建 Figwheel 和 Rum 项目'
- en: '](img/B14502_09_29.jpg)'
  id: totrans-593
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B14502_09_29.jpg)'
- en: 'Figure 9.29: Creating a Figwheel and Rum project'
  id: totrans-594
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 9.29：创建 Figwheel 和 Rum 项目
- en: Leiningen downloads the template and creates a ClojureScript project for us.
  id: totrans-595
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Leiningen 下载模板并为我们创建 ClojureScript 项目。
- en: 'We will move to the project to the command line:'
  id: totrans-596
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将移动到命令行中的项目：
- en: '[PRE129]'
  id: totrans-597
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE129]'
- en: 'This will change the directory to `hello-clojurescript.core`:'
  id: totrans-598
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这将更改目录到 `hello-clojurescript.core`：
- en: '![Figure 9.30: Changing directory'
  id: totrans-599
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图 9.30：更改目录'
- en: '](img/B14502_09_30.jpg)'
  id: totrans-600
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B14502_09_30.jpg)'
- en: 'Figure 9.30: Changing directory'
  id: totrans-601
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图9.30：更改目录
- en: We are ready to run our application. In order to run our ClojureScript application,
    we need to build it.
  id: totrans-602
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们已准备好运行我们的应用程序。为了运行我们的ClojureScript应用程序，我们需要构建它。
- en: 'Figwheel provides an automatic build configuration that allows us to run a
    newly-created ClojureScript application:'
  id: totrans-603
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Figwheel提供了一个自动构建配置，允许我们运行新创建的ClojureScript应用程序：
- en: '[PRE130]'
  id: totrans-604
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE130]'
- en: 'Calling this command will build a ClojureScript application. First, Figwheel
    will download any necessary dependencies:'
  id: totrans-605
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 调用此命令将构建一个ClojureScript应用程序。首先，Figwheel将下载任何必要的依赖项：
- en: '![Figure 9.31: Building a ClojureScript application'
  id: totrans-606
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图9.31：构建ClojureScript应用程序'
- en: '](img/B14502_09_31.jpg)'
  id: totrans-607
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B14502_09_31.jpg)'
- en: 'Figure 9.31: Building a ClojureScript application'
  id: totrans-608
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图9.31：构建ClojureScript应用程序
- en: 'Here, Figwheel downloads three dependencies:'
  id: totrans-609
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这里，Figwheel下载了三个依赖项：
- en: Rum
  id: totrans-610
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: Rum
- en: '`Figwheel-main` library'
  id: totrans-611
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Figwheel-main`库'
- en: ClojureScript
  id: totrans-612
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: ClojureScript
- en: 'Second, Figwheel will check our configuration:'
  id: totrans-613
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 其次，Figwheel将检查我们的配置：
- en: '![Figure 9.32: Figwheel checking configuration'
  id: totrans-614
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图9.32：Figwheel检查配置'
- en: '](img/B14502_09_32.jpg)'
  id: totrans-615
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B14502_09_32.jpg)'
- en: 'Figure 9.32: Figwheel checking configuration'
  id: totrans-616
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.32：Figwheel检查配置
- en: Because we have not changed the default configuration, there are no problems
    with our project's configuration. We will see what the default configuration looks
    like shortly.
  id: totrans-617
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们没有更改默认配置，我们的项目配置没有问题。我们很快就会看到默认配置的样子。
- en: 'Third, Figwheel will compile our code and output a main file that is run:'
  id: totrans-618
  prefs: []
  type: TYPE_NORMAL
  zh: 第三，Figwheel将编译我们的代码，并输出一个要运行的主文件：
- en: '![Figure 9.33: Compiling code'
  id: totrans-619
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.33：编译代码'
- en: '](img/B14502_09_33.jpg)'
  id: totrans-620
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B14502_09_33.jpg)'
- en: 'Figure 9.33: Compiling code'
  id: totrans-621
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.33：编译代码
- en: 'After Figwheel builds our application, it will launch a server that will serve
    our application:![Figure 9.34: Starting the server'
  id: totrans-622
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Figwheel构建我们的应用程序后，它将启动一个服务器，该服务器将提供我们的应用程序：![图9.34：启动服务器
- en: '](img/B14502_09_34.jpg)'
  id: totrans-623
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B14502_09_34.jpg)'
- en: '[PRE131]'
  id: totrans-624
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE131]'
- en: Any changes that we make in source files will result in recompilation of the
    code and our application being updated in the web browser.
  id: totrans-625
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们在源文件中做出的任何更改都将导致代码重新编译，并且我们的应用程序将在网页浏览器中更新。
- en: We will investigate the core source file now.
  id: totrans-626
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们现在将研究核心源文件。
- en: 'Figwheel will import two namespaces for us in the `core.cjs` file:'
  id: totrans-627
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Figwheel将在`core.cjs`文件中为我们导入两个命名空间：
- en: '[PRE132]'
  id: totrans-628
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE132]'
- en: The first namespace is the Google `dom` namespace, which allows us to manipulate
    DOM elements. The second namespace is `rum`, which was imported because we set
    our application to use Rum. Remember that we passed the `--rum` command-line parameter
    when we created the application.
  id: totrans-629
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 第一个命名空间是Google的`dom`命名空间，它允许我们操作DOM元素。第二个命名空间是`rum`，因为我们设置了我们的应用程序使用Rum。记住，当我们创建应用程序时，我们传递了`--rum`命令行参数。
- en: In the namespace, we have defined the `^:figwheel-hooks` keyword. This is autogenerated
    by Figwheel and instructs Figwheel that it needs to auto-compile this file.
  id: totrans-630
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在命名空间中，我们定义了`^:figwheel-hooks`关键字。这是由Figwheel自动生成的，并指示Figwheel需要自动编译此文件。
- en: 'The Google DOM namespace allows us to manipulate DOM elements on the page:'
  id: totrans-631
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Google DOM命名空间允许我们在页面上操作DOM元素：
- en: '[PRE133]'
  id: totrans-632
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE133]'
- en: The `getElement` function will search a page for an element with an ID of `app`.
    By default, Figwheel will create an index page with a `div`. This `div` will have
    an ID of `app`.
  id: totrans-633
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`getElement`函数将在页面中搜索具有`app` ID的元素。默认情况下，Figwheel将创建一个带有`div`的索引页面。这个`div`将具有`app`
    ID。'
- en: 'Figwheel creates a default index file in the `resources/public` folder:'
  id: totrans-634
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Figwheel在`resources/public`文件夹中创建一个默认的索引文件：
- en: '[PRE134]'
  id: totrans-635
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE134]'
- en: The main things that interest us in the index file are importing styles from
    the `css/style.css` file, creating the `div` with app `id` where we will mount
    our application, and adding our compiled code as a script from the `dev-main.js`
    file.
  id: totrans-636
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在索引文件中，我们关注的主要事情是从`css/style.css`文件导入样式，创建一个带有应用程序`id`的`div`，我们将在这里挂载我们的应用程序，并将编译后的代码作为从`dev-main.js`文件的脚本添加。
- en: 'Reactive applications need to manage state to react to user interactions. The
    state is defined as an atom:'
  id: totrans-637
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 响应式应用程序需要管理状态以响应用户交互。状态被定义为原子：
- en: '[PRE135]'
  id: totrans-638
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE135]'
- en: n the state, we store a hash with a `:text` key that has a value of `"Hello
    world!"` and a `:counter` key with a value of zero. The state is defined using
    `defonce`. This is because we do not want to redefine the state when Figwheel
    reloads the code. This way, we preserve application state during page reload.
  id: totrans-639
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在当前状态下，我们存储一个带有`:text`键，其值为`"Hello world!"`和带有`:counter`键，其值为零的哈希。状态是通过`defonce`定义的。这是因为我们不希望在Figwheel重新加载代码时重新定义状态。这样，我们可以在页面重新加载期间保留应用程序状态。
- en: 'Rum components are defined using the `defc` macro:'
  id: totrans-640
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`defc`宏定义Rum组件：
- en: '[PRE136]'
  id: totrans-641
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE136]'
- en: The `hello-world` component constructs an HTML `div` element. Inside the `div`,
    we have an `h1` HTML element and an `h3` HTML element.
  id: totrans-642
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`hello-world`组件构建一个HTML `div`元素。在`div`内部，我们有一个`h1` HTML元素和一个`h3` HTML元素。'
- en: The `h1` element will display text stored in the application state. Because
    the application state is an atom, if we want to access values, we need to dereference
    it. Dereferencing is an action that returns a value stored in an atom.
  id: totrans-643
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`h1`元素将显示存储在应用程序状态中的文本。因为应用程序状态是一个原子，如果我们想访问值，我们需要对其进行解引用。解引用是一个返回原子中存储的值的操作。'
- en: The `h3` element informs us that we can edit the `core.cljs` file and see the
    changes on the web page.
  id: totrans-644
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`h3`元素告诉我们我们可以编辑`core.cljs`文件，并在网页上看到更改。'
- en: Defined components need to be mounted on the page.
  id: totrans-645
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 定义好的组件需要挂载到页面上。
- en: 'In order to see the components on the page, we need to mount them:'
  id: totrans-646
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了在页面上看到组件，我们需要将它们挂载：
- en: '[PRE137]'
  id: totrans-647
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE137]'
- en: The `rum/mount` function will mount the `hello-world` component to the DOM element.
    This element is returned by the `get-app-element` function that we investigated
    earlier.
  id: totrans-648
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`rum/mount`函数将`hello-world`组件挂载到DOM元素上。该元素是我们之前调查的`get-app-element`函数返回的。'
- en: 'Once the component is mounted to the DOM element, it will be displayed on the
    page:'
  id: totrans-649
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 一旦组件挂载到DOM元素上，它就会在页面上显示：
- en: '![Figure 9.36: Initial page after mounting the component to the DOM element'
  id: totrans-650
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图9.36：将组件挂载到DOM元素后的初始页面'
- en: '](img/B14502_09_36.jpg)'
  id: totrans-651
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图片 B14502_09_36.jpg]'
- en: 'Figure 9.36: Initial page after mounting the component to the DOM element'
  id: totrans-652
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图9.36：将组件挂载到DOM元素后的初始页面
- en: Our `hello-world` component displays two headers. First is an `h1` header with
    saying `Hello world!`. Then is an `h3` header with information about editing the
    `core.cljs` file.
  id: totrans-653
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们的`hello-world`组件显示两个标题。首先是带有“Hello world!”的`h1`标题，然后是带有关于编辑`core.cljs`文件信息的`h3`标题。
- en: 'Rum allows us to define reactive components. A reactive component is a component
    that reacts to changes in the application state. When a change happens, the component
    is re-rendered on the page with a new value taken from the application state:'
  id: totrans-654
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Rum允许我们定义响应式组件。响应式组件是一种对应用程序状态变化做出反应的组件。当发生变化时，组件将在页面上以从应用程序状态中取出的新值重新渲染：
- en: '[PRE138]'
  id: totrans-655
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE138]'
- en: We marked the component to be reactive by using Rum's `< rum/reactive` syntax.
    The `<` symbol tells Rum that a component is a special type. In our case, it is
    a reactive component. Rum will react to changes to `app-state`.
  id: totrans-656
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们使用Rum的`< rum/reactive`语法标记组件为响应式。`<`符号告诉Rum组件是一个特殊类型。在我们的例子中，它是一个响应式组件。Rum将对`app-state`的变化做出反应。
- en: The `hello-world` component will call a band component and pass the band name
    together with `:counter`, which is defined in the application state.
  id: totrans-657
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`hello-world`组件将调用乐队组件，并将乐队名称与定义在应用程序状态中的`:counter`一起传递。'
- en: Whenever the `app-state` is updated, Rum will react to the change and re-render
    the band component.
  id: totrans-658
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 每当`app-state`更新时，Rum都会对变化做出反应并重新渲染乐队组件。
- en: 'In the `hello-world` component, we will display a band:'
  id: totrans-659
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`hello-world`组件中，我们将显示一个乐队：
- en: '[PRE139]'
  id: totrans-660
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE139]'
- en: The `band` component takes two band names and the number of likes as the parameters.
  id: totrans-661
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`band`组件接受两个乐队名称和点赞数作为参数。'
- en: 'The component will display the band name and the number of likes:'
  id: totrans-662
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 组件将显示乐队名称和点赞数：
- en: '![Figure 9.37: Displaying the band name in the hello-world component'
  id: totrans-663
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.37：在hello-world组件中显示乐队名称'
- en: '](img/B14502_09_37.jpg)'
  id: totrans-664
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片 B14502_09_37.jpg]'
- en: 'Figure 9.37: Displaying the band name in the hello-world component'
  id: totrans-665
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.37：在hello-world组件中显示乐队名称
- en: Inside the component, we use the `:on-click` DOM attribute.
  id: totrans-666
  prefs: []
  type: TYPE_NORMAL
  zh: 在组件内部，我们使用`:on-click` DOM 属性。
- en: 'The `on-click` attribute allows us to attach a function that is called when
    a user clicks on an element on a web page:'
  id: totrans-667
  prefs: []
  type: TYPE_NORMAL
  zh: '`on-click`属性允许我们在用户点击网页上的元素时附加一个函数：'
- en: '[PRE140]'
  id: totrans-668
  prefs: []
  type: TYPE_PRE
  zh: '[PRE140]'
- en: 'The function updates a `:counter` key inside the `app-state` hash. The update
    is done by incrementing the value of the counter using Clojure''s `inc` function:'
  id: totrans-669
  prefs: []
  type: TYPE_NORMAL
  zh: 函数通过使用Clojure的`inc`函数增加计数器的值来更新`app-state`哈希中的`:counter`键：
- en: '![Figure 9.38: Incrementing likes for the band name'
  id: totrans-670
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.38：乐队名称的点赞数增加'
- en: '](img/B14502_09_38.jpg)'
  id: totrans-671
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片 B14502_09_38.jpg]'
- en: 'Figure 9.38: Incrementing likes for the band name'
  id: totrans-672
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.38：乐队名称的点赞数增加
- en: Clicking three times on the page element will update the counter. Updating the
    counter will trigger the re-rendering of the component with a new value.
  id: totrans-673
  prefs: []
  type: TYPE_NORMAL
  zh: 在页面元素上点击三次将更新计数器。更新计数器将触发组件以新值重新渲染。
- en: 'In this exercise, we updated the `hello-world` component. After code changes,
    the component was displayed in the browser. We did not have to recompile the code.
    The code was recompiled by Figwheel. When we run Figwheel, it starts to watch
    our files for changes:'
  id: totrans-674
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们更新了`hello-world`组件。在代码更改后，组件在浏览器中显示。我们不必重新编译代码。代码是由Figwheel重新编译的。当我们运行Figwheel时，它开始监视我们的文件以查找更改：
- en: '[PRE141]'
  id: totrans-675
  prefs: []
  type: TYPE_PRE
  zh: '[PRE141]'
- en: Thanks to Figwheel, we were able to focus on coding without worrying about recompiling
    our code. This is done automatically by Figwheel.
  id: totrans-676
  prefs: []
  type: TYPE_NORMAL
  zh: 多亏了Figwheel，我们能够专注于编码，而不必担心重新编译我们的代码。这是由Figwheel自动完成的。
- en: In this section, we learned about Figwheel. It creates a template for ClojureScript
    projects. The main feature of Figwheel is hot-code reloading. Changes in our source
    files are automatically recompiled and re-displayed in the browser.
  id: totrans-677
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们学习了关于Figwheel的内容。它为ClojureScript项目创建了一个模板。Figwheel的主要功能是热代码重新加载。我们源文件中的更改会自动重新编译并在浏览器中重新显示。
- en: We also learned about Rum. Rum is a library that helps to create reactive components.
    The components react to changes in application state and are redisplayed on the
    web pages.
  id: totrans-678
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还学习了关于Rum的内容。Rum是一个库，有助于创建响应式组件。这些组件会响应应用程序状态的变化，并在网页上重新显示。
- en: In the next topic, we will delve deeper into JavaScript interoperability.
  id: totrans-679
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个主题中，我们将更深入地探讨JavaScript互操作性。
- en: Drag and Drop
  id: totrans-680
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 拖放
- en: One of the most common use cases in web pages is using drag and drop. It is
    so common that we rarely even notice it nowadays. The jQuery UI library provides
    functions to code drag and drop functionality. With this library, we can mark
    HTML elements as draggable and droppable.
  id: totrans-681
  prefs: []
  type: TYPE_NORMAL
  zh: 在网页中，最常见的使用场景之一就是使用拖放。它如此普遍，以至于我们如今很少注意到它。jQuery UI库提供了用于编码拖放功能的函数。使用这个库，我们可以将HTML元素标记为可拖动和可放置。
- en: 'The library has a number of options that allow us to alter how dragging and
    dropping behaves. We can:'
  id: totrans-682
  prefs: []
  type: TYPE_NORMAL
  zh: 该库提供了一些选项，允许我们改变拖放行为。我们可以：
- en: Constrain the movement of draggable elements to certain areas on a web page
  id: totrans-683
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将可拖动元素的移动限制在网页上的特定区域
- en: Specify if the element returns to the original position after dragging
  id: totrans-684
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 指定元素在拖动后是否返回原始位置
- en: Specify if the element auto-aligns to other elements
  id: totrans-685
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 指定元素是否自动对齐到其他元素
- en: Give visual aids while dragging, such as transparency or animation
  id: totrans-686
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 拖动时提供视觉辅助，例如透明度或动画
- en: Accept only one droppable element in a page area
  id: totrans-687
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在页面区域中仅接受一个可放置元素
- en: Allow or deny reverting after dropping
  id: totrans-688
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 允许或禁止拖放后回滚
- en: Give visual feedback once an element has been dropped
  id: totrans-689
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 元素被放置后提供视觉反馈
- en: Using jQuery's draggable and droppable functionality, we can create a truly
    interactive page.
  id: totrans-690
  prefs: []
  type: TYPE_NORMAL
  zh: 使用jQuery的可拖动和可放置功能，我们可以创建一个真正交互式的页面。
- en: We have seen the syntax for JavaScript interoperability. It is now time to put
    our knowledge into practice. In the next exercise, we will create a drag and drop
    application using JavaScript interoperability. The application will be based on
    the Figwheel template and use Rum for reactive behavior.
  id: totrans-691
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了JavaScript互操作性的语法。现在是时候将我们的知识付诸实践了。在下一个练习中，我们将使用JavaScript互操作性创建一个拖放应用。该应用将基于Figwheel模板，并使用Rum实现响应式行为。
- en: 'Exercise 9.09: JavaScript Interoperability with Drag and Drop'
  id: totrans-692
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习9.09：使用拖放与JavaScript互操作
- en: The aim of this exercise is to get comfortable with JavaScript interoperability
    in ClojureScript. We will create a frontend application that allows users to drag
    and drop elements. When coding dragging and dropping behavior, we will use objects
    and functions from JavaScript. JavaScript's jQuery UI library has drag and drop
    methods. We will use methods from this library.
  id: totrans-693
  prefs: []
  type: TYPE_NORMAL
  zh: 本练习的目的是让用户熟悉ClojureScript中的JavaScript互操作性。我们将创建一个前端应用，允许用户拖放元素。在编码拖放行为时，我们将使用JavaScript中的对象和函数。JavaScript的jQuery
    UI库提供了拖放方法。我们将使用这个库的方法。
- en: 'The application will be based on a Figwheel template that helps build ClojureScript
    applications. One of its main features is hot-code reloading. Any changes in source
    files are recompiled and updated in a browser. This helps to speed up the development
    process by giving quick feedback to programmers:'
  id: totrans-694
  prefs: []
  type: TYPE_NORMAL
  zh: 该应用将基于一个Figwheel模板，该模板有助于构建ClojureScript应用。其主要功能之一是热代码重新加载。任何对源文件的更改都会在浏览器中重新编译和更新。这有助于通过为程序员提供快速反馈来加快开发过程：
- en: 'Create a new ClojureScript application based on the `figwheel` template:'
  id: totrans-695
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 基于figwheel模板创建一个新的ClojureScript应用：
- en: '[PRE142]'
  id: totrans-696
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE142]'
- en: 'The REPL will display information saying that a new project based on the `figwheel`
    template has been created:'
  id: totrans-697
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: REPL将显示信息，说明已创建了一个基于`figwheel`模板的新项目：
- en: '![Figure 9.39: REPL output'
  id: totrans-698
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/B14502_09_39.jpg)'
  id: totrans-699
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 9.39: REPL output'
  id: totrans-700
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: In the project, we will use the `jayq` external library. `jayq` is a ClojureScript
    wrapper for jQuery.
  id: totrans-701
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Add external ClojureScript dependencies in `project.clj`. In `project.clj`,
    add the `jayq` library in the `:dependencies` section:'
  id: totrans-702
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE143]'
  id: totrans-703
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE143]'
- en: 'The `dependencies` section in `project.clj` should look like the following:'
  id: totrans-704
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 9.40: Output for dependencies'
  id: totrans-705
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/B14502_09_40.jpg)'
  id: totrans-706
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 9.40: Output for dependencies'
  id: totrans-707
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now that we have dependencies configured in `project.clj`, we can import them
    in the `hello-drag-and-drop.core` namespace:'
  id: totrans-708
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE144]'
  id: totrans-709
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE144]'
- en: The libraries will help us create drag and drop elements on a page. Drag and
    drop implementation will be based on a component from jQuery UI. We need to import
    these JavaScript libraries in the `index.html` file.
  id: totrans-710
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Open the `resources/public/index.html` file and, inside the `<head>` tag, add
    imports for jQuery and jQuery UI:'
  id: totrans-711
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE145]'
  id: totrans-712
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE145]'
- en: 'After importing the necessary libraries, we will launch Figwheel. In Terminal,
    type the following:'
  id: totrans-713
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE146]'
  id: totrans-714
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE146]'
- en: 'This will launch Figwheel for us:'
  id: totrans-715
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 9.41: Launching Figwheel'
  id: totrans-716
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/B14502_09_41.jpg)'
  id: totrans-717
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 9.41: Launching Figwheel'
  id: totrans-718
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figwheel will compile ClojureScript code and launch a server for us. The server
    will automatically open a web browser displaying the content from the `index.html`
    file:'
  id: totrans-719
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 9.42: Content from index.html'
  id: totrans-720
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/B14502_09_42.jpg)'
  id: totrans-721
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 9.42: Content from index.html'
  id: totrans-722
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: One of the selling points of Figwheel is code reloading. When we make changes
    to ClojureScript files, the code will be recompiled and a page in the browser
    will be updated.
  id: totrans-723
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: In our app, we will implement drag and drop functionality. We will move draggable
    cards into droppable tiles. We start by defining a tile component.
  id: totrans-724
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Inside `hello-clojurescript.core`, add a definition for a tile:'
  id: totrans-725
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE147]'
  id: totrans-726
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE147]'
- en: 'Here, a tile is a `rum` component that is basically an HTML block. We define
    a component using the `defc` method from `rum`. A tile accepts two arguments:
    text and a number. Inside it, a hash that allows us to set properties on an element
    number parameter is used to set an ID for the tile div. Text will be displayed
    inside the div element. We also set a "`tile`" class for styling.'
  id: totrans-727
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Inside `resources/public/css/styles.css`, add a CSS definition. CSS stands
    for Cascading Style Sheets. Style sheets allow us to style HTML elements on a
    web page. Cascading means that if an HTML element has some styles, any HTML elements
    inside this element will inherit the same styling:'
  id: totrans-728
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE148]'
  id: totrans-729
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE148]'
- en: 'Here, we define the style for a tile component with a solid green border. The
    border''s width should be 1 pixel, the height should be 100 pixels, the width
    should be 200 pixels, and the component is displayed inline, meaning that it is
    on the same line as other elements. When we render the tiles, they will look as
    follows:'
  id: totrans-730
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 9.43: Defining the tile component'
  id: totrans-731
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/B14502_09_43.jpg)'
  id: totrans-732
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 9.43: Defining the tile component'
  id: totrans-733
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: We have two tiles on the same line. Each tile has a green border.
  id: totrans-734
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'This styling will help us to see each tile clearly. We have a solid green line
    to distinguish between the tiles. We are going to create a component that holds
    tiles:'
  id: totrans-735
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这种样式将帮助我们清楚地看到每个瓦片。我们有一个实心的绿色线来区分瓦片。我们将创建一个包含瓦片的组件：
- en: '[PRE149]'
  id: totrans-736
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE149]'
- en: We create a component that is a `div` holding two `tile` components. We mark
    them as first and second. Notice that we did not write a `div` tag directly. When
    we omit the `div` tag and provide a class or an ID, Rum will implicitly create
    a `div` element. Here, we used a shorthand notation for a class and gave the component
    class `tiles`.
  id: totrans-737
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们创建了一个包含两个 `tile` 组件的 `div` 组件。我们将它们标记为第一和第二。请注意，我们没有直接写 `div` 标签。当我们省略 `div`
    标签并提供一个类或 ID 时，Rum 会隐式创建一个 `div` 元素。在这里，我们使用了类的简写符号，并给组件类命名为 `tiles`。
- en: 'We want to inform a user that an element was dropped. We will store information
    about dropping elements in an `atom`:'
  id: totrans-738
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们想通知用户一个元素已经被放下。我们将在一个 `atom` 中存储关于放下元素的信息：
- en: '[PRE150]'
  id: totrans-739
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE150]'
- en: When the application starts, we set the value to `false`. We do not want Figwheel
    to redefine the atom when it reloads the page, so we define it once.
  id: totrans-740
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当应用程序启动时，我们将值设置为 `false`。我们不希望 Figwheel 在重新加载页面时重新定义原子，所以我们只定义一次。
- en: 'The component will display information if an element was dropped:'
  id: totrans-741
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当一个元素被放下时，组件将显示信息：
- en: '[PRE151]'
  id: totrans-742
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE151]'
- en: We use the `reactive` directive from Rum. This directive instructs Rum that
    the component will `react` to changes in `application state`. In our case, any
    changes to the `is-element-dropped?` atom will cause the component to be rerendered
    with a new value. We have three components already, but they are not visible in
    the web browser yet. We need to write code that will mount our components on the
    page. We will have a top-level component that will contain all the HTML for our
    application.
  id: totrans-743
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们使用来自 Rum 的 `reactive` 指令。这个指令指示 Rum，该组件将 `react` 到 `application state` 的变化。在我们的例子中，对
    `is-element-dropped?` 原子的任何更改都会导致组件以新的值重新渲染。我们已经有三个组件了，但它们在网页浏览器中还未可见。我们需要编写代码将我们的组件挂载到页面上。我们将有一个顶层组件，它将包含我们应用程序的所有
    HTML。
- en: 'We will put all our components into one `main` component. This `main` component
    will contain cards that we drag and tiles where we drop elements:'
  id: totrans-744
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将把所有我们的组件放入一个 `main` 组件中。这个 `main` 组件将包含我们可以拖拽的卡片和我们可以放下元素的瓦片：
- en: '[PRE152]'
  id: totrans-745
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE152]'
- en: 'After defining our `main` component, we are ready to tell Rum how to mount
    this component:'
  id: totrans-746
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在定义了我们的 `main` 组件之后，我们就准备好告诉 Rum 如何挂载这个组件：
- en: '[PRE153]'
  id: totrans-747
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE153]'
- en: 'We tell Rum that we want to mount a component called `content`. The mount point
    is an element with an ID of `app`. When we check the web browser, we can see the
    changes applied:'
  id: totrans-748
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们告诉 Rum，我们想要挂载一个名为 `content` 的组件。挂载点是具有 ID `app` 的元素。当我们检查网页浏览器时，我们可以看到应用的变化：
- en: '![Figure 9.44: Changes in the tile component'
  id: totrans-749
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图 9.44：瓦片组件的变化'
- en: '](img/B14502_09_44.jpg)'
  id: totrans-750
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图片 B14502_09_44.jpg]'
- en: 'Figure 9.44: Changes in the tile component'
  id: totrans-751
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图 9.44：瓦片组件的变化'
- en: We did not have to compile the code ourselves. All this was done by Figwheel.
    After creating droppable elements, it is time to create elements that we can drag.
  id: totrans-752
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们不必自己编译代码。所有这些都是由 Figwheel 完成的。在创建可拖拽元素之后，是时候创建我们可以拖拽的元素了。
- en: 'We will create a new `rum` component – a `card`:'
  id: totrans-753
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将创建一个新的 `rum` 组件——一个 `card`：
- en: '[PRE154]'
  id: totrans-754
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE154]'
- en: The card component will accept one argument, a number. This argument is used
    twice inside the properties hash. We will set an ID for this component using the
    number. We will also set a data property with the number.
  id: totrans-755
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 卡片组件将接受一个参数，一个数字。这个参数在属性哈希中使用了两次。我们将使用这个数字为该组件设置一个 ID。我们还将设置一个带有数字的数据属性。
- en: 'Once we have the card component, we can create a component that will hold a
    number of cards:'
  id: totrans-756
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦我们有了卡片组件，我们可以创建一个可以包含多个卡片的组件：
- en: '[PRE155]'
  id: totrans-757
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE155]'
- en: 'In this example, we create two cards. Finally, we need to place our cards somewhere.
    A good place is our `main` component. It should look like this now:'
  id: totrans-758
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这个例子中，我们创建了两个卡片。最后，我们需要将我们的卡片放置在某个地方。一个好的地方是我们的 `main` 组件。现在它应该看起来像这样：
- en: '[PRE156]'
  id: totrans-759
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE156]'
- en: 'The main content consists of cards and tiles. Even if we went to the web browser,
    we would not see any cards yet. We have to add some styling:'
  id: totrans-760
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 主要内容由卡片和瓦片组成。即使我们访问了网页浏览器，我们也看不到任何卡片。我们必须添加一些样式：
- en: '[PRE157]'
  id: totrans-761
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE157]'
- en: 'After adding styling for a card, the web browser will show us new content:'
  id: totrans-762
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在为卡片添加样式后，网页浏览器将显示新的内容：
- en: '![Figure 9.45: Styled cards'
  id: totrans-763
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图 9.45：样式化卡片'
- en: '](img/B14502_09_45.jpg)'
  id: totrans-764
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图片 B14502_09_45.jpg]'
- en: 'Figure 9.45: Styled cards'
  id: totrans-765
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 9.45：样式化卡片
- en: Besides two big green tiles, we have two small red cards. The draggable and
    droppable elements are now placed. We are ready to implement the dragging and
    dropping behavior.
  id: totrans-766
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 除了两个大绿色瓦片外，我们还有两个小红色卡片。可拖拽和可放下元素现在已放置。我们现在可以实施拖拽和放下行为。
- en: 'We will add dragging to cards. We will use the `draggable` function from jQuery
    UI. Add code for dragging cards to `hello-clojurescript.core`:'
  id: totrans-767
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将为卡片添加拖动功能。我们将使用jQuery UI中的`draggable`函数。将拖动卡片的代码添加到`hello-clojurescript.core`：
- en: '[PRE158]'
  id: totrans-768
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE158]'
- en: 'We find HTML elements with the `card` class and use the `$` function from the
    `jayq` library that we imported at the beginning of the section. The `$` function
    will create a jQuery object. We call the `draggable` method on this object, passing
    attributes. Attributes are constructed using a new function, `attrs`:'
  id: totrans-769
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们找到具有`card`类的HTML元素，并使用我们在本节开头导入的`jayq`库中的`$`函数。`$`函数将创建一个jQuery对象。我们在该对象上调用`draggable`方法，并传递属性。属性是通过一个新的函数`attrs`构建的：
- en: '[PRE159]'
  id: totrans-770
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE159]'
- en: The `attrs` function takes attributes as arguments. We use `sablono`'s `html-to-dom-attrs`
    function to convert all HTML attributes to their DOM equivalents. We convert from
    HTML attributes to DOM attributes because jQuery manipulates the DOM, not HTML.
  id: totrans-771
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`attrs`函数接受属性作为参数。我们使用`sablono`的`html-to-dom-attrs`函数将所有HTML属性转换为它们的DOM等效属性。我们从HTML属性转换为DOM属性，因为jQuery操作的是DOM，而不是HTML。'
- en: 'We need to import the `sablono` library to the `hello-drag-and-drop.core` namespace:'
  id: totrans-772
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要将`sablono`库导入到`hello-drag-and-drop.core`命名空间中：
- en: '[PRE160]'
  id: totrans-773
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE160]'
- en: The `clj->js` function will recursively transform ClojureScript values to JavaScript.
    Sets/vectors/lists become arrays, keywords and symbols become strings, and maps
    become objects. We can code in ClojureScript, and when we need to use JavaScript
    construct `clj->js` will convert the necessary constructs from ClojureScript to
    JavaScript.
  id: totrans-774
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`clj->js`函数将递归地将ClojureScript值转换为JavaScript。集合/向量/列表变为数组，关键字和符号变为字符串，映射变为对象。我们可以在ClojureScript中编码，当我们需要使用JavaScript构造时，`clj->js`将必要的结构从ClojureScript转换为JavaScript。'
- en: 'The last step is to call `make-draggable` in the `on-reload` function:'
  id: totrans-775
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后一步是在`on-reload`函数中调用`make-draggable`：
- en: '[PRE161]'
  id: totrans-776
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE161]'
- en: 'Figwheel will compile and reload code in the web browser. We can drag the red
    cards now:'
  id: totrans-777
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Figwheel将在网页浏览器中编译和重新加载代码。现在我们可以拖动红色卡片了：
- en: '![Figure 9.46: Dragging the red cards'
  id: totrans-778
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图9.46：拖动红色卡片'
- en: '](img/B14502_09_46.jpg)'
  id: totrans-779
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图片 B14502_09_46.jpg](img/B14502_09_46.jpg)'
- en: 'Figure 9.46: Dragging the red cards'
  id: totrans-780
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图9.46：拖动红色卡片
- en: The last piece in our application is implementing the dropping behavior for
    tiles. A `tile` should accept a dragged card.
  id: totrans-781
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们应用程序的最后一部分是实现瓷砖的放置行为。一个`tile`应该接受一个被拖动的卡片。
- en: 'For the dropping behavior, we will use the `droppable` function from the jQuery
    UI library:'
  id: totrans-782
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于放置行为，我们将使用jQuery UI库中的`droppable`函数：
- en: '[PRE162]'
  id: totrans-783
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE162]'
- en: Similar to the `make-draggable` function, we use the `$` function to construct
    jQuery objects using the `tile` CSS class. Next, we call the `droppable` function
    from the jQuery UI library passing attributes as arguments.
  id: totrans-784
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 与`make-draggable`函数类似，我们使用`$`函数使用`tile`CSS类构建jQuery对象。接下来，我们调用jQuery UI库中的`droppable`函数，并将属性作为参数传递。
- en: 'We set two attributes. The first one is `:hoverClass`, which takes a value
    of `hovered-tile`. This attribute allows us to add styling when an element is
    hovered over with the mouse. In `styles.css`, add the following declaration:'
  id: totrans-785
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们设置了两个属性。第一个是`:hoverClass`，它的值是`hovered-tile`。这个属性允许我们在鼠标悬停时添加样式。在`styles.css`中添加以下声明：
- en: '[PRE163]'
  id: totrans-786
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE163]'
- en: When we hover over a tile during dragging, its background color will change
    to a shade of blue.
  id: totrans-787
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当我们在拖动过程中悬停在瓷砖上时，其背景颜色将变为蓝色。
- en: 'For the second attribute, `:drop`, we assign the `handle-drop` function:'
  id: totrans-788
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于第二个属性`:drop`，我们分配`handle-drop`函数：
- en: '[PRE164]'
  id: totrans-789
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE164]'
- en: Inside the `handle-drop` function, we specify the behavior when an element is
    dropped. There are a few things happening in the function. We access the `draggable`
    field on the `ui` element using JavaScript interoperability with `.-` (dot and
    hyphen). This field is passed to the `data` function from the `jayq` library to
    access the `data-number` HTML attribute. We print the ID of the dragged element.
    We reset the atom informing that an element has been dropped. We disable the dragged
    element. This will add the `ui-draggable-disabled` CSS class to the element. We
    disable the element into which we dropped, preventing dropping more elements.
    Finally, we set the position of the dropped element to the top left of the droppable
    container
  id: totrans-790
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在`handle-drop`函数内部，我们指定元素被放置时的行为。在函数中有几个操作。我们使用JavaScript互操作性中的`.-`（点号和连字符）访问`ui`元素上的`draggable`字段。这个字段被传递给`jayq`库中的`data`函数以访问`data-number`HTML属性。我们打印被拖动元素的ID。我们重置原子，通知元素已被放置。我们禁用被拖动的元素。这将向元素添加`ui-draggable-disabled`CSS类。我们禁用我们放置元素的元素，防止放置更多元素。最后，我们将放置元素的定位设置为可放置容器的左上角
- en: The `handle-drop` function is a good example of using JavaScript interoperability.
    We call functions on JavaScript objects and access fields from these objects.
  id: totrans-791
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`handle-drop`函数是使用JavaScript互操作性的一个很好的例子。我们在JavaScript对象上调用函数，并访问这些对象中的字段。'
- en: 'The droppable widget allows us to add a function that is called when an element
    is being dragged:'
  id: totrans-792
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 可拖动小部件允许我们添加一个当元素正在拖动时被调用的函数：
- en: '[PRE165]'
  id: totrans-793
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE165]'
- en: In our implementation, we set the `is-element-dropped?` atom to `false`.
  id: totrans-794
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在我们的实现中，我们将`is-element-dropped?`原子设置为`false`。
- en: 'We need to add styling to the element that we dropped. In `styles.css`, add
    the following declaration:'
  id: totrans-795
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要为我们掉落的元素添加样式。在`styles.css`中添加以下声明：
- en: '[PRE166]'
  id: totrans-796
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE166]'
- en: This will set the background color of dropped elements to yellow.
  id: totrans-797
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这将设置掉落元素的背景颜色为黄色。
- en: 'Finally, we will call the `make-droppable` function on `on-js-reload`. It should
    look as follows:'
  id: totrans-798
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们将在`on-js-reload`上调用`make-droppable`函数。它应该看起来如下：
- en: '[PRE167]'
  id: totrans-799
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE167]'
- en: 'When we drop an element in the web browser, we will see the following result:'
  id: totrans-800
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当我们在网页浏览器中掉落一个元素时，我们将看到以下结果：
- en: '![Figure 9.47: Dropping an element'
  id: totrans-801
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图9.47：掉落元素'
- en: '](img/B14502_09_47.jpg)'
  id: totrans-802
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图片](img/B14502_09_47.jpg)'
- en: 'Figure 9.47: Dropping an element'
  id: totrans-803
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.47：掉落元素
- en: In this exercise, we have created a drag and drop application. We used JavaScript
    interoperability to access functions, objects, and fields from JavaScript.
  id: totrans-804
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们创建了一个拖放应用程序。我们使用了JavaScript互操作性来访问函数、对象和字段。
- en: We did not have any problems when coding this application. There are situations
    when our application does not operate as expected. In the next section, we will
    look at exception and error handling in Clojure.
  id: totrans-805
  prefs: []
  type: TYPE_NORMAL
  zh: 在编码这个应用程序时我们没有遇到任何问题。有时我们的应用程序不会按预期运行。在下一节中，我们将探讨Clojure中的异常和错误处理。
- en: Exceptions and Errors in Clojure
  id: totrans-806
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Clojure中的异常和错误
- en: In an ideal world, every program runs without any problems. In the real world,
    mistakes happen and programs do not run as planned. Errors and exceptions in Java
    and Clojure are a mechanism for informing developers when such unexpected situations
    occur.
  id: totrans-807
  prefs: []
  type: TYPE_NORMAL
  zh: 在理想的世界里，每个程序都能在没有问题的情况下运行。在现实世界中，错误会发生，程序不会按计划运行。Java和Clojure中的错误和异常是一种机制，用于在发生此类意外情况时通知开发者。
- en: An error indicates a serious problem that an application should not try to catch
    or handle. An exception indicates conditions that an application might want to
    catch. To put it another way, errors are situations from which an application
    cannot recover. Such conditions could be running out of disk space or memory.
    If an application runs out of disk space to save data, there is no possibility
    that this application can serve its purpose. Unless we provide more disk space,
    the application cannot run successfully. Exceptions are conditions from which
    an application can recover. Such a condition could be trying to access a list
    from a database before a connection to the database has been established, or trying
    to use arithmetic operations on strings instead of numbers.
  id: totrans-808
  prefs: []
  type: TYPE_NORMAL
  zh: 错误表示一个应用程序不应该尝试捕获或处理的严重问题。异常表示应用程序可能想要捕获的条件。换句话说，错误是应用程序无法从中恢复的情况。这些条件可能是磁盘空间或内存不足。如果一个应用程序在保存数据时耗尽磁盘空间，那么这个应用程序无法实现其目的。除非我们提供更多的磁盘空间，否则应用程序无法成功运行。异常是应用程序可以从中恢复的条件。这样的条件可能是尝试在建立数据库连接之前从数据库中访问列表，或者尝试在字符串上使用算术运算而不是数字。
- en: 'Both errors and exceptions are subclasses of the `Throwable` class. This class
    indicates a Java object that can be thrown. Throwing means raising an alert such
    as an error or an exception. Java provides four constructs to deal with errors
    and exceptions:'
  id: totrans-809
  prefs: []
  type: TYPE_NORMAL
  zh: 错误和异常都是`Throwable`类的子类。这个类表示一个可以被抛出的Java对象。抛出意味着引发一个警告，如错误或异常。Java提供了四种结构来处理错误和异常：
- en: '`throw`'
  id: totrans-810
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`throw`'
- en: '`try`'
  id: totrans-811
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`try`'
- en: '`catch`'
  id: totrans-812
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`catch`'
- en: '`finally`'
  id: totrans-813
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`finally`'
- en: '`throw` allows a developer to raise an exception. We could have a web application
    that accepts user input such as their age. In this application, we could have
    a feature where we check for the user''s age before showing age-restricted content.
    When we perform an arithmetic operation on input, we expect a number from a user.
    If a user puts a string instead, the application cannot carry out such calculations.
    Throwing an error in such a situation will alert the application of an input that
    is not correct. Once we raise an exception or throw an error, we can deal with
    them using the remaining three Java constructs.'
  id: totrans-814
  prefs: []
  type: TYPE_NORMAL
- en: '`try` is a Java reserved word that allows a developer to write a block of code
    that can potentially result in a `Throwable` object appearing. This code is scoped
    within a `try` block and guarded against errors. Going back to our application,
    an age check will be placed inside a `try` block. When we encounter an error or
    exception, we can handle it. The third construct will help us with that.'
  id: totrans-815
  prefs: []
  type: TYPE_NORMAL
- en: '`catch` is a reserved word in Java that allows a developer to handle and deal
    with exceptions and errors. The block of code under catch is executed when the
    specified exception or error is encountered. In our example, when we try to manipulate
    an age string such as a number, an exception is thrown and the `catch` block is
    executed. In this block, we could return a message to the user that they need
    to input numbers.'
  id: totrans-816
  prefs: []
  type: TYPE_NORMAL
- en: '`finally` is the last reserved word for dealing with exceptions and errors
    in Java. The block of code under `finally` is always executed. There are situations
    when we want to execute code regardless of whether we have encountered an exception
    or not. An example is I/O operations. Opening a file could raise an error if a
    file is not present. If a file is present, an error is not thrown. Opening a file
    uses computer resources such as RAM that we want to free up after we finishing
    reading the file. Closing a file after reading the `finally` block is a common
    practice. It is so common that Clojure provides the `with-open` macro that we
    saw in action in the I/O section of this chapter.'
  id: totrans-817
  prefs: []
  type: TYPE_NORMAL
- en: The most common example of a `try-catch-finally` block is reading or writing
    to a file. Inside the `try` block, we have an operation to read or write to a
    file. The `catch` block would guard against IO exceptions such as file not present.
    In the `finally` block, we would have code to close the file. Closing the file
    releases computer resources for other tasks.
  id: totrans-818
  prefs: []
  type: TYPE_NORMAL
- en: 'The following table presents the most common exceptions and errors in Java:'
  id: totrans-819
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.48: Common exceptions and errors in Java'
  id: totrans-820
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B14502_09_48.jpg)'
  id: totrans-821
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 9.48: Common exceptions and errors in Java'
  id: totrans-822
  prefs: []
  type: TYPE_NORMAL
- en: In the next exercise, we will learn how to use `throw`, `try`, `catch`, and
    `finally` in Clojure.
  id: totrans-823
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 9.10: Handling Errors and Exceptions in Clojure'
  id: totrans-824
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The aim of this exercise is to learn how exceptions and errors in Clojure are
    handled. It is common that in Clojure we work with data from Java. In this exercise,
    we will create a function that takes a Java `ArrayList` instance and an index.
    The `ArrayList` class is like a vector in Clojure, which we saw in *Chapter 2*,
    *Data Types and Immutability*. The `ArrayList` class stores data. We can access
    elements from the `ArrayList` class using the index, the same as we do with vectors
    in Clojure. Accessing elements from `ArrayList` can cause exceptions. While designing
    our function, we will handle the exceptions raised:'
  id: totrans-825
  prefs: []
  type: TYPE_NORMAL
- en: 'Open Terminal and start the REPL:'
  id: totrans-826
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE168]'
  id: totrans-827
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE168]'
- en: After opening the REPL, we will define an `ArrayList` instance.
  id: totrans-828
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'We will create an `ArrayList` containing three numbers:'
  id: totrans-829
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE169]'
  id: totrans-830
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE169]'
- en: 'We have an array that contains three numbers, zero to two:'
  id: totrans-831
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE170]'
  id: totrans-832
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE170]'
- en: 'The output is as follows:'
  id: totrans-833
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE171]'
  id: totrans-834
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE171]'
- en: We will create a function that allows us to access elements from an array.
  id: totrans-835
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The `array-list-getter` function will allow us to access elements from an array:'
  id: totrans-836
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE172]'
  id: totrans-837
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE172]'
- en: 'The `array-list-getter` function takes two arguments: an array and an index.
    We access an element from the array using the passed index.'
  id: totrans-838
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'When we access the element that is present in the array, we get it back:'
  id: totrans-839
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE173]'
  id: totrans-840
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE173]'
- en: 'The output is as follows:'
  id: totrans-841
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE174]'
  id: totrans-842
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE174]'
- en: We wanted to get the element at index 1, and we got it back.
  id: totrans-843
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'When we try to access an element that is not present, Clojure complains:'
  id: totrans-844
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE175]'
  id: totrans-845
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE175]'
- en: 'The output is as follows:'
  id: totrans-846
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE176]'
  id: totrans-847
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE176]'
- en: Our array has only three elements. When we try to access the element at index
    `5`, Clojure raises `IndexOutOfBoundsException`.
  id: totrans-848
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'We can catch errors thrown by our code:'
  id: totrans-849
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE177]'
  id: totrans-850
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE177]'
- en: 'The new definition of `array-list-getter` catches the `IndexOutOfBoundsException`:'
  id: totrans-851
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE178]'
  id: totrans-852
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE178]'
- en: 'The output is as follows:'
  id: totrans-853
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE179]'
  id: totrans-854
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE179]'
- en: In the `catch` block, we specify what error or exception we want to catch and
    how to handle it. Here, we return information that the array does not have an
    element in the passed index.
  id: totrans-855
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'If our code does not throw an exception, the `catch` block is not executed:'
  id: totrans-856
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE180]'
  id: totrans-857
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE180]'
- en: 'The output is as follows:'
  id: totrans-858
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE181]'
  id: totrans-859
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE181]'
- en: We have an element at index `1`. The `array-list-getter` function returns this
    number for us. No exception is thrown.
  id: totrans-860
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Code in the `finally` block is always executed just before the `try` block
    finishes. This happens even if no exception has been thrown:'
  id: totrans-861
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE182]'
  id: totrans-862
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE182]'
- en: 'Executing this correct code returns the expected result and prints a message
    that this code always gets executed:'
  id: totrans-863
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE183]'
  id: totrans-864
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE183]'
- en: 'The output is as follows:'
  id: totrans-865
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE184]'
  id: totrans-866
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE184]'
- en: We see that when code does not throw any errors or exceptions, only the `finally`
    block is executed and not the `catch` block.
  id: totrans-867
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'When our code will throw an error situation, the `catch` and `finally` blocks
    are executed:'
  id: totrans-868
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE185]'
  id: totrans-869
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE185]'
- en: This time, we try to access an element that is not present. This code will raise
    an exception and execute the `finally` block. Instead of getting a number, we
    see two messages in the REPL. One is from the `catch` block and the other from
    the `finally` block.
  id: totrans-870
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: In this exercise, we have learned about errors and exceptions. Clojure reuses
    these constructs from Java. Code that can throw errors or exceptions is protected
    by a `try` block. When exceptions are thrown, code in the `catch` block is executed.
    For situations when some code needs to be run regardless of exceptions raised,
    the `finally` block is used.
  id: totrans-871
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Like in Java, errors happen in JavaScript as well. In the final section of this
    chapter, we will learn about errors in JavaScript and how to deal with them in
    ClojureScript.
  id: totrans-872
  prefs: []
  type: TYPE_NORMAL
- en: Errors in JavaScript
  id: totrans-873
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous section, we learned about errors and exceptions in Java and
    how to handle them in Clojure. Unexpected situations that lead to problems in
    JavaScript applications also happen. This results in a need to handle errors.
    JavaScript does not distinguish between errors and exceptions, so any situations
    in which code causes the application not to run as expected are errors.
  id: totrans-874
  prefs: []
  type: TYPE_NORMAL
- en: 'Like in Java, in JavaScript, we have tools to deal with errors. JavaScript
    provides four constructs:'
  id: totrans-875
  prefs: []
  type: TYPE_NORMAL
- en: '`throw`'
  id: totrans-876
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`try`'
  id: totrans-877
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`catch`'
  id: totrans-878
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`finally`'
  id: totrans-879
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They are the same as we saw in the previous section. JavaScript reuses error
    handling concepts known from other languages, such as Java. Because JavaScript
    is not Java, the way we deal with errors in ClojureScript is not 100% the same
    as in Clojure. It's very close, but code pasted from Clojure to ClojureScript
    will not work straight away. In the next exercise, we will see how to deal with
    JavaScript errors in ClojureScript and examine the small syntax differences with
    error handling in Clojure.
  id: totrans-880
  prefs: []
  type: TYPE_NORMAL
- en: ClojureScript Leiningen Templates
  id: totrans-881
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We have used Leiningen to create projects for us. When we create a new project,
    we use a project template. Template developers can publish project templates on
    the internet and other developers (like us) can create projects using such templates.
  id: totrans-882
  prefs: []
  type: TYPE_NORMAL
- en: So far, we have used Figwheel to create ClojureScript projects. As we have learned,
    Figwheel provides a lot of default configuration for us. A new Figwheel project
    comes with features such as hot-code reloading, a REPL, and tests.
  id: totrans-883
  prefs: []
  type: TYPE_NORMAL
- en: There are situations where we do not need all these nice things from Figwheel.
    We want a simple ClojureScript setup. For such cases, we can use a `mies` project
    template. The `mies` template creates a basic project structure for ClojureScript.
  id: totrans-884
  prefs: []
  type: TYPE_NORMAL
- en: To reiterate, for most situations when we want to develop a website application,
    we would use Figwheel. On rare occasions when we want a minimal ClojureScript
    project setup, we will use `mies`.
  id: totrans-885
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 9.11: Handling Errors in ClojureScript'
  id: totrans-886
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The aim of this exercise is to learn how ClojureScript handles JavaScript errors.
    In this exercise, we will write a function that abbreviates programming language
    names. When a programming language is not supported, we will throw an error to
    inform the user that this language is not supported:'
  id: totrans-887
  prefs: []
  type: TYPE_NORMAL
- en: 'Create the project:'
  id: totrans-888
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE186]'
  id: totrans-889
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE186]'
- en: This command will create a new project for us.
  id: totrans-890
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'We will run the ClojureScript REPL from the command line:'
  id: totrans-891
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE187]'
  id: totrans-892
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE187]'
- en: This launches the REPL.
  id: totrans-893
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 9.49: Output for the REPL'
  id: totrans-894
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/B14502_09_49.jpg)'
  id: totrans-895
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 9.49: Output for the REPL'
  id: totrans-896
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: With REPL launched, we can investigate error handling in ClojureScript.
  id: totrans-897
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'In our code, we will support the following languages:'
  id: totrans-898
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE188]'
  id: totrans-899
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE188]'
- en: 'We will implement a function that abbreviates a programming language name:'
  id: totrans-900
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE189]'
  id: totrans-901
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE189]'
- en: The function will try to get a short version of a language from a language hash
    defined earlier.
  id: totrans-902
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: If the language is not found, we will throw an error. The syntax of `throw`
    in ClojureScript is very similar to syntax that we have seen in Clojure. Here,
    instead of Java classes, we have an `Error` object that we access from the `js`
    namespace.
  id: totrans-903
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'When a function is called with a valid argument, it returns the abbreviated
    name of a programming language:'
  id: totrans-904
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE190]'
  id: totrans-905
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE190]'
- en: 'The output is as follows:'
  id: totrans-906
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE191]'
  id: totrans-907
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE191]'
- en: We see that a short name for JavaScript is `JS`.
  id: totrans-908
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'When we call a function with an invalid argument, it will throw an error:'
  id: totrans-909
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE192]'
  id: totrans-910
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE192]'
- en: 'This will return an error as follows:'
  id: totrans-911
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE193]'
  id: totrans-912
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE193]'
- en: We see that Ruby is not a supported language and calling the `language-abbreviator`
    function with Ruby as the argument throws an error. We know how to throw errors
    in ClojureScript. We will see how to catch them now.
  id: totrans-913
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'We will create a function that returns the language of the week:'
  id: totrans-914
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE194]'
  id: totrans-915
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE194]'
- en: The function uses Clojure's `rand-nth` function to randomly pick an element
    from a sequence. Using this language, we try to get an abbreviated version of
    a language. If the language is not supported and an error is thrown, we catch
    the error and inform the user that the language is not supported.
  id: totrans-916
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Calling the `get-language-of-the-week` function with unsupported languages
    will result in errors:'
  id: totrans-917
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE195]'
  id: totrans-918
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE195]'
- en: 'The output is as follows:'
  id: totrans-919
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE196]'
  id: totrans-920
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE196]'
- en: The `Go` language was picked as the language of the week. Sadly, we do not have
    an abbreviated name for `Go`. The `language-abbreviator` function threw an error
    that was caught by the `catch` block in the `get-language-of-the-week` function.
  id: totrans-921
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'We will call the `get-language-of-the-week` function with supported languages:'
  id: totrans-922
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE197]'
  id: totrans-923
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE197]'
- en: 'The output is as follows:'
  id: totrans-924
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE198]'
  id: totrans-925
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE198]'
- en: When we call the `get-language-of-the-week` function with supported languages,
    we get an abbreviated name for the picked language.
  id: totrans-926
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'We will extend our language of the week function to include the `finally` block:'
  id: totrans-927
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE199]'
  id: totrans-928
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE199]'
- en: With the `finally` block, we can execute any code we want to run regardless
    of errors thrown in our code.
  id: totrans-929
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'We will choose a language of the week from the supported languages:'
  id: totrans-930
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE200]'
  id: totrans-931
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE200]'
- en: 'The output is as follows:'
  id: totrans-932
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE201]'
  id: totrans-933
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE201]'
- en: ClojureScript was chosen as the language of the week. The `get-language-of-the-week`
    function returned the abbreviated name of the chosen language and a message from
    the `finally` block.
  id: totrans-934
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'We will choose the language of the week from the languages that are not supported:'
  id: totrans-935
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE202]'
  id: totrans-936
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE202]'
- en: 'The output is as follows:'
  id: totrans-937
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE203]'
  id: totrans-938
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE203]'
- en: 'Kotlin was chosen as the language of the week. The `get-language-of-the-week`
    function returned two messages: the message from the `catch` block that Kotlin
    is not a supported language and the message from the `finally` block.'
  id: totrans-939
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: We have just seen how `try-catch-finally` blocks are used in ClojureScript.
    Using these constructs will help us write code that can deal with many unexpected
    situations.
  id: totrans-940
  prefs: []
  type: TYPE_NORMAL
- en: We now know how to handle exceptions in Clojure and ClojureScript. We have seen
    how to use interoperability between JavaScript and ClojureScript. It is time to
    put our knowledge to use. We will write a ClojureScript application that uses
    JavaScript interoperability.
  id: totrans-941
  prefs: []
  type: TYPE_NORMAL
- en: 'Activity 9.02: Creating a Support Desk'
  id: totrans-942
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The aim of this activity is to write a web application that uses external JavaScript
    libraries. We will create a support desk application that manages issues raised
    in the support desk. The application allows us to sort issues and resolve them
    when they are done. By sorting the issues, we can raise the priority of individual
    issues.
  id: totrans-943
  prefs: []
  type: TYPE_NORMAL
- en: 'The application will have the following features:'
  id: totrans-944
  prefs: []
  type: TYPE_NORMAL
- en: 'Display how many times the list has been sorted:'
  id: totrans-945
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'less than three: few times'
  id: totrans-946
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'less than six: medium times'
  id: totrans-947
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'more than six: many times'
  id: totrans-948
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Filter the list of issues by priority, such as only displaying issues above
    priority 3.
  id: totrans-949
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sort the list of issues.
  id: totrans-950
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Resolve an issue.
  id: totrans-951
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following steps will help you complete the activity:'
  id: totrans-952
  prefs: []
  type: TYPE_NORMAL
- en: Create a new project.
  id: totrans-953
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add the `jayq` and `cuerdas` libraries as dependencies in `project.clj`.
  id: totrans-954
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create the `utils` function to filter the issues list by priority.
  id: totrans-955
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create the `utils` function to get the sorted issues list.
  id: totrans-956
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create the `utils` function to get the sorted messages by issue count.
  id: totrans-957
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create the `utils` function to delete issues from a list.
  id: totrans-958
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create the `utils` function that's called when sorting is finished.
  id: totrans-959
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add jQuery and jQuery UI to `index.html`.
  id: totrans-960
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Import `jayq` ,`cuerdas` and `utils` to the core namespace.
  id: totrans-961
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Define the priorities list.
  id: totrans-962
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Define app state.
  id: totrans-963
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Define the counter Rum component.
  id: totrans-964
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create the issue on `click` function.
  id: totrans-965
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Define the issue item Rum component.
  id: totrans-966
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Define the reactive issue items component.
  id: totrans-967
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Define the reactive page content component.
  id: totrans-968
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Make item components sortable.
  id: totrans-969
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Mount the page component.
  id: totrans-970
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Call the mount function.
  id: totrans-971
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Call the sortable function.
  id: totrans-972
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run the application.
  id: totrans-973
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The initial issues list will look as follows:'
  id: totrans-974
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.50: Initial issue list'
  id: totrans-975
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B14502_09_50.jpg)'
  id: totrans-976
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 9.50: Initial issue list'
  id: totrans-977
  prefs: []
  type: TYPE_NORMAL
- en: 'The issues list after sorting will look as follows:'
  id: totrans-978
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.51: Issue list after sorting'
  id: totrans-979
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B14502_09_51.jpg)'
  id: totrans-980
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 9.51: Issue list after sorting'
  id: totrans-981
  prefs: []
  type: TYPE_NORMAL
- en: 'The issues list after resolving three issues will look as follows:'
  id: totrans-982
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.52: Issue list after resolving issues'
  id: totrans-983
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B14502_09_52.jpg)'
  id: totrans-984
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 9.52: Issue list after resolving issues'
  id: totrans-985
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-986
  prefs: []
  type: TYPE_NORMAL
- en: The solution for this activity can be found on page 718.
  id: totrans-987
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-988
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have learned about the interoperability of Clojure and Java.
    We saw how to import Java classes in Clojure. We constructed instances of Java
    classes and called methods on these instances. We have also learned about macros
    that help us use Java in Clojure.
  id: totrans-989
  prefs: []
  type: TYPE_NORMAL
- en: Next, we learned about input/output (I/O) operations in Java. We accessed files
    from a disk, both reading and writing content. We saw how to get input from a
    user using a keyboard and how to display information back to the user.
  id: totrans-990
  prefs: []
  type: TYPE_NORMAL
- en: After that, we learned about interoperability in ClojureScript. We created a
    drag and drop application using objects and methods from JavaScript libraries.
  id: totrans-991
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we learned about exceptions and errors in Clojure and ClojureScript.
    We saw how errors are thrown and how to guard against errors using `try-catch`
    blocks. We investigated the `finally` block and when to use it.
  id: totrans-992
  prefs: []
  type: TYPE_NORMAL
- en: We finished the chapter by working on a help desk application that allows users
    to sort a list of items in order of priority.
  id: totrans-993
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will investigate testing in Clojure and ClojureScript.
    We will see why testing is important, what libraries both languages provide for
    testing, and how to use testing libraries in Clojure and ClojureScript.
  id: totrans-994
  prefs: []
  type: TYPE_NORMAL
