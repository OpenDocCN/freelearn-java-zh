- en: Chapter 9. Saving Your Data
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 9 章：保存你的数据
- en: 'There are many types of Bukkit plugins. Some of them require you to save data.
    By saving data, I am referring to saving information to the system''s hard drive.
    This is needed if the information must stay intact, even after the server restarts.
    At this point, none of the plugins that we created have this requirement. Examples
    of plugins that will save data are as follows:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: Bukkit 插件有很多种类型。其中一些需要你保存数据。通过保存数据，我指的是将信息保存到系统的硬盘上。如果信息必须在服务器重启后保持完整，则需要这样做。到目前为止，我们创建的插件中还没有这个要求。以下是一些将保存数据的插件示例：
- en: Economy plugins must save information about how much money each player has
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 经济插件必须保存每个玩家有多少钱的信息
- en: Land protection plugins must save information about which plots of land are
    claimed and who their owner is
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 土地保护插件必须保存有关哪些地块已被声明及其所有者的信息
- en: Questing plugins must store all the information for each quest, such as who
    has completed it
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任务插件必须存储每个任务的所有信息，例如谁完成了它
- en: 'There are countless uses for saving data when a server is shut down. In this
    chapter, we will create a teleportation plugin that saves various warp locations
    to a file. Again, we will save these locations to a file so that we do not need
    to create them again after the server shuts down. You are already familiar with
    the YAML file format. Therefore, we will utilize the YAML configuration to save
    and load data. In this chapter, we will cover the following topics:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在服务器关闭时，保存数据有无数用途。在本章中，我们将创建一个传送插件，将各种传送位置保存到文件中。同样，我们将这些位置保存到文件中，这样在服务器关闭后我们就不需要再次创建它们。你已经熟悉
    YAML 文件格式。因此，我们将利用 YAML 配置来保存和加载数据。在本章中，我们将涵盖以下主题：
- en: The type of data that you can save
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以保存的数据类型
- en: The data in a plugin that is worth saving and the frequency of saving it
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 值得保存的插件数据和保存频率
- en: Expanding a prewritten teleportation plugin
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 扩展预先编写的传送插件
- en: Creating and using a `ConfigurationSerializable` object
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建和使用 `ConfigurationSerializable` 对象
- en: Saving data in a YAML configuration
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 YAML 配置中保存数据
- en: Loading the saved data from the YAML configuration
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从 YAML 配置文件中加载已保存的数据
- en: Types of data that can be saved
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可以保存的数据类型
- en: You may recall, as discussed in the previous chapter, that only certain data
    types can be stored in a YAML file. These include primitive types, such as `int`
    and `boolean`, strings, lists, and types that implement `ConfigurationSerializable`,
    such as `ItemStack`.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能还记得，在上一章中讨论过，只有某些数据类型可以存储在 YAML 文件中。这些包括原始类型，如 `int` 和 `boolean`，字符串、列表以及实现
    `ConfigurationSerializable` 的类型，如 `ItemStack`。
- en: For this reason, we can only save these specific types of data.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们只能保存这些特定类型的数据。
- en: You may find yourself wanting to save other types of data such as a `Player`
    object, or in the case of the teleportation plugin, a `Location` object. These
    may not be stored directly, but they can usually be broken down in order to save
    the important values that are needed to load it later. As an example, you cannot
    save a `Player` object, but you can save the players' **UUID** (**Universal Unique
    Identifier**), which can be converted into a string. Each `Player` has one UUID.
    Hence, it is the only information that we need to be able to refer to that specific
    player later.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能希望保存其他类型的数据，例如 `Player` 对象，或者在传送插件的情况下，一个 `Location` 对象。这些可能不能直接存储，但通常可以分解以保存在以后加载时所需的重要值。例如，你不能保存
    `Player` 对象，但你可以保存玩家的 **UUID**（**通用唯一标识符**），它可以被转换成字符串。每个 `Player` 都有一个 UUID。因此，这是我们后来能够引用该特定玩家的唯一信息。
- en: Tip
  id: totrans-16
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Storing a Players name is not an adequate solution, since the name provided
    in the Minecraft account can be changed.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 仅存储玩家名称不是一个充分的解决方案，因为提供的 Minecraft 账户名称可以更改。
- en: A `Location` object also cannot be stored directly, but it can be broken down
    to its world, `x`, `y`, and `z` coordinates, `yaw`, and `pitch`. The `x, y, z,
    yaw`, and `pitch` values are simply numbers that can be stored. As for the world,
    it also has a UUID that will never change. Therefore, a location is broken down
    into one string (`world uuid`), three doubles (`x`, `y`, `z`), and two floats
    (`yaw` and `pitch`).
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '`Location` 对象也不能直接存储，但它可以被分解为其世界、`x`、`y` 和 `z` 坐标、`yaw` 和 `pitch`。`x`、`y`、`z`、`yaw`
    和 `pitch` 的值仅仅是可以存储的数字。至于世界，它也有一个永远不会改变的 UUID。因此，一个位置被分解为一个字符串（`world uuid`）、三个双精度浮点数（`x`、`y`、`z`）和两个浮点数（`yaw`
    和 `pitch`）。'
- en: As you create your own plugins, you may have classes that you wish to store
    in a file, such as a `BankAccount` object. As mentioned earlier, we can do this
    with any class that implements `ConfigurationSerializable`. `ConfigurationSerializable`
    means that the object can be translated to a form that can be stored within a
    configuration. This configuration can then be written to a file. In the teleportation
    plugin, we will create a `location` object that does exactly this.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 当你创建自己的插件时，你可能希望将某些类存储在文件中，例如一个 `BankAccount` 对象。如前所述，我们可以使用任何实现了 `ConfigurationSerializable`
    的类来做到这一点。`ConfigurationSerializable` 意味着对象可以被转换成可以存储在配置中的形式。然后，这个配置可以被写入文件。在传送插件中，我们将创建一个
    `location` 对象，它正好可以做到这一点。
- en: Which data to save and when
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 保存哪些数据以及何时保存
- en: We know what can be saved to a file, but what should we save? Writing data to
    a file uses disk space. Therefore, we want to save only what we need to. It is
    better to think, "Which information do I want to keep after the server shuts down?"
    For example, a banking plugin will want to keep the balance of each account. As
    another example, a **PvP** arena plugin will not care about having information
    about an arena match. It is quite likely that the match will simply be canceled
    as the server is shutting down. When considering the teleportation plugin, we
    will want to still have the locations of each warp after the server is shut down.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 我们知道可以保存到文件中的内容，但我们应该保存什么？将数据写入文件会占用磁盘空间。因此，我们只想保存我们需要的内容。最好是思考，“服务器关闭后，我想保留哪些信息？”例如，一个银行插件将希望保留每个账户的余额。作为另一个例子，一个
    **PvP** 场地插件可能不会关心有关场地比赛的信息。在服务器关闭时，比赛很可能简单地被取消。在考虑传送插件时，我们希望服务器关闭后仍然保留每个传送门的位置。
- en: 'Our next concern is when to save this information. Writing data to files has
    the potential to **lag** a server if it is a large amount of data. If you are
    unfamiliar with the term "lag", it is a phrase that is used to indicate that the
    server is running slowly. You know when this happens because the game becomes
    very choppy and players and mobs seem to move around sporadically. This is an
    unpleasant experience for everyone. Hence, you want to save your data only when
    you have to. There are three typical options for how often you want to save your
    data:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 我们接下来的关注点是何时保存这些信息。如果数据量很大，将数据写入文件可能会使服务器 **延迟**。如果你不熟悉“延迟”这个术语，它是一个用来表示服务器运行缓慢的短语。你知道这种情况发生时，因为游戏变得非常卡顿，玩家和怪物似乎四处移动。这对每个人来说都是一种不愉快的体验。因此，你只想在你必须的时候保存数据。保存数据频率有三个典型的选项：
- en: Every time the data is modified
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每次数据被修改时
- en: Periodically, such as every hour
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定期，例如每小时一次
- en: When the server/plugin is shut down
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当服务器/插件关闭时
- en: These options are ordered by how safe they are. For instance, if your data is
    saved only when the server is shut down, then you run the risk of losing unsaved
    data in case the server crashes. If data is saved every hour, then in the worst
    case, you will lose only one hour's worth of data. For this reason, the first
    option should always be used when possible. The second and third options should
    be considered only if the plugin handles a large amount of data and/or the data
    is modified very often, such as several times every minute. The data of the teleportation
    plugin will only be modified when someone creates/deletes a warp or sets their
    home warp location. Therefore, we will invoke the `save` method every time the
    data is modified.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 这些选项按照它们的安全性排序。例如，如果你的数据仅在服务器关闭时保存，那么如果服务器崩溃，你将面临丢失未保存数据的风险。如果数据每小时保存一次，那么在最坏的情况下，你将丢失一小时的资料。因此，在可能的情况下，应始终使用第一个选项。第二个和第三个选项只有在插件处理大量数据且/或数据修改非常频繁时（例如每分钟修改几次）才应考虑。传送插件的数据只有在有人创建/删除传送门或设置他们的家传送门位置时才会被修改。因此，每次数据被修改时，我们将调用
    `save` 方法。
- en: A sample teleportation plugin
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一个示例传送插件
- en: 'For this project, you will be given an incomplete teleportation plugin. You
    already know how to program most of this project. Therefore, we will discuss only
    the following three topics:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个项目，你将得到一个不完整的传送插件。你已经知道如何编写这个项目的大部分代码。因此，我们只讨论以下三个主题：
- en: Creating a class that implements `ConfigurationSerializable`
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个实现 `ConfigurationSerializable` 的类
- en: The `save` method
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`save` 方法'
- en: The `load` method
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`load` 方法'
- en: The rest of the plugin is provided and can be downloaded from [www.packtpub.com](http://www.packtpub.com),
    as mentioned in the preface. The code that you will be working on is Version 0.1
    of the plugin Warper. Go through the plugin and read the comments to try to understand
    everything that it does. Both `Maps` and `try/catch` blocks are used in this project.
    If you do not know what either of those are, that is okay. They will be explained
    when it is time to use them yourself. Note that the `SerializableLocation` class
    is the location class, which implements `ConfigurationSerializable`; we will discuss
    this next.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 插件的其余部分已提供，可以从[www.packtpub.com](http://www.packtpub.com)下载，如前言中所述。你将工作的代码是插件Warper的0.1版本。通过插件并阅读注释，尝试理解它所做的一切。在这个项目中使用了`Maps`和`try/catch`块。如果你不知道它们是什么，那没关系。它们将在你需要使用它们的时候进行解释。请注意，`SerializableLocation`类是位置类，实现了`ConfigurationSerializable`；我们将在下面讨论这一点。
- en: Writing a ConfigurationSerializable class
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写ConfigurationSerializable类
- en: '**Serialization** is the process of translating data or objects into a form
    that can be written to a file. In the plugin Warper, we will need to save the
    Bukkit locations. Locations cannot be serialized themselves. Therefore, we will
    make our own class that holds the Bukkit `Location` object data and is able to
    convert it to and from a map. If you are new to maps, they are a very useful type
    of collection that we will use throughout this project. Maps have keys and values.
    Each key points to a specific value. The `Warper` plugin is a good example of
    how maps can be used. When teleporting, a player will choose a specific location
    to warp to by name. If all the warp locations were in a list, we would have to
    iterate through the list until the warp location with the correct name was found.
    With a map, we can pass the key (the name of the warp) to the map, and it will
    return the value (the warp location).'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '**序列化**是将数据或对象转换为可以写入文件的形式的过程。在Warper插件中，我们需要保存Bukkit位置信息。位置信息本身不能进行序列化。因此，我们将创建自己的类来保存Bukkit
    `Location`对象的数据，并且能够将其转换为地图形式，以及从地图形式转换回来。如果你对地图还不熟悉，它们是一种非常有用的集合类型，我们将在整个项目中使用。地图有键和值。每个键指向一个特定的值。`Warper`插件是地图如何使用的良好示例。当进行传送时，玩家将通过名称选择一个特定的位置进行传送。如果所有传送位置都在一个列表中，我们就必须遍历列表，直到找到具有正确名称的传送位置。使用地图，我们可以将键（传送的名称）传递给地图，它将返回值（传送位置）。'
- en: 'Create a new class called `SerializableLocation`, which contains a private
    variable that holds the Bukkit `Location object`. The first constructor will require
    a `Location` object. We will also include a `getLocation` method. The following
    code is how the beginning of the new class looks:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个名为`SerializableLocation`的新类，其中包含一个私有变量，用于保存Bukkit `Location对象`。第一个构造函数将需要一个`Location`对象。我们还将包括一个`getLocation`方法。以下是新类开头的外观代码：
- en: '[PRE0]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Once you add `implements ConfigurationSerializable`, your IDE should warn you
    about implementing all the abstract methods. The method that you must override
    is `serialize`. This will return a map representation of your object. We already
    mentioned each piece of data that we will need. Now, we just have to assign each
    piece of data a name and put it in a map. To add data to a map, you can call the
    `put` method. This method requires two parameters, namely a key and a value of
    the key. A key is simply a name for the piece of data that allows us to reference
    it later. The value is the serializable data. To find out more about maps, you
    can read the **Javadoc** at [https://docs.oracle.com/javase/8/docs/api/java/util/Map.html](https://docs.oracle.com/javase/8/docs/api/java/util/Map.html).
    For the `serialize` method, we will need to get all the data that we mentioned
    earlier and put it in a map, as follows:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你添加了`implements ConfigurationSerializable`，你的IDE应该会警告你关于实现所有抽象方法。你必须重写的方法是`serialize`。这个方法将返回你对象的地图表示形式。我们之前已经提到了我们需要的数据。现在，我们只需要给每份数据分配一个名称并将其放入地图中。要向地图添加数据，你可以调用`put`方法。这个方法需要两个参数，即键和键的值。键是数据的名称，它允许我们稍后引用它。值是可序列化的数据。要了解更多关于地图的信息，你可以阅读[https://docs.oracle.com/javase/8/docs/api/java/util/Map.html](https://docs.oracle.com/javase/8/docs/api/java/util/Map.html)上的**Javadoc**。对于`serialize`方法，我们需要获取我们之前提到的所有数据并将其放入地图中，如下所示：
- en: '[PRE1]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'This handles the saving portion, but we still have to handle the loading. The
    simplest way to do this is by adding a constructor that takes the map as a parameter,
    as follows:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 这处理了保存部分，但我们仍然需要处理加载部分。最简单的方法是添加一个接受地图作为参数的构造函数，如下所示：
- en: '[PRE2]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Loading is essentially the opposite of saving. We pull each value from the map
    and then use it to create the Bukkit `Location` object. As a safeguard, we will
    first verify that the world is actually loaded. If the world is not loaded, the
    location will not exist. We do not want the plugin to crash because of this. There
    is also no reason why you need to try loading the location of a nonexistent world,
    because no one will be able to teleport to it anyway.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 加载基本上是保存的反面。我们从映射中提取每个值，然后使用它来创建Bukkit的`Location`对象。作为一个安全措施，我们首先会验证世界是否实际上已经加载。如果世界没有加载，位置将不存在。我们不希望插件因为这一点而崩溃。也没有必要尝试加载一个不存在世界的位置，因为无论如何没有人能够传送到那里。
- en: Each object that you get from the map will have to be cast to its original type,
    which was done in the previous code. The `float` values are an exceptional case.
    Each of the `float` values will be read as a `double` value. The `double value`
    is similar to `float`, but it is more precise. Therefore, loading the `float`
    values as the `double` values and then converting them will not cause data loss.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 从映射中获取的每个对象都必须转换为它的原始类型，这在之前的代码中已经完成。`float`值是一个特例。每个`float`值都将被读取为`double`值。`double`值类似于`float`，但更精确。因此，将`float`值作为`double`值加载，然后转换它们不会导致数据丢失。
- en: 'Both of these methods will be used by Bukkit. As a programmer, you will only
    have to store this object in the YAML configuration. This can be done by simply
    using the following line of code:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 这两种方法都将由Bukkit使用。作为一个程序员，您只需将此对象存储在YAML配置中即可。这可以通过简单地使用以下代码行来完成：
- en: '[PRE3]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Then, you can retrieve the data later by using the following code:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，您可以使用以下代码检索数据：
- en: '[PRE4]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Bukkit uses the `serialize` method and the constructor to handle the rest.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: Bukkit使用`serialize`方法和构造函数来处理其余部分。
- en: 'The class name and path are used to reference this class. To see an example
    of this, take a look at the `ItemStack` object in the `config.yml` file for the
    `MobEnhancer` plugin. An example of this class has also been provided:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 类名和路径用于引用这个类。为了查看一个例子，请查看`MobEnhancer`插件的`config.yml`文件中的`ItemStack`对象。这个类的例子也已经提供：
- en: '[PRE5]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Tip
  id: totrans-50
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: The path will of course have your own namespace, not `com.codisimus`.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 路径当然会有您自己的命名空间，而不是`com.codisimus`。
- en: 'This works fine, but it may cause confusion, especially with long pathnames.
    However, there is a way to ask Bukkit to reference this class by using an alias.
    Perform the following two steps to complete this:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 这工作得很好，但可能会引起混淆，尤其是当路径名很长时。然而，有一种方法可以要求Bukkit通过别名引用这个类。执行以下两个步骤来完成：
- en: 'Add the `@SerializableAs` annotation just above the class, as follows:'
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在类上方直接添加`@SerializableAs`注解，如下所示：
- en: '[PRE6]'
  id: totrans-54
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Register your class within the `ConfigurationSerialization class`:'
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`ConfigurationSerialization类`中注册您的班级：
- en: '[PRE7]'
  id: totrans-56
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This can be done in the `onEnable` method. Just ensure that it is executed before
    you attempt loading the data.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以在`onEnable`方法中完成。只需确保它在尝试加载数据之前执行。
- en: Tip
  id: totrans-58
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: The serializable name must be unique. Therefore, it is better to include your
    plugin name rather than simply `Location`. That way, you can have a serializable
    location for another plugin without them conflicting.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 可序列化的名称必须是唯一的。因此，最好包含您的插件名称，而不仅仅是`Location`。这样，您可以为另一个插件提供一个可序列化的位置，而不会发生冲突。
- en: Saving data to a YAML configuration
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将数据保存到YAML配置文件
- en: 'Now, we are ready to complete the `save` method. We want to save data to a
    YAML file, much like how we did in `config.yml`. However, we do not want to save
    it to `config.yml`, because that serves a different purpose. The first thing that
    we will need to do is create a new YAML configuration, as follows:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们准备完成`save`方法。我们希望将数据保存到YAML文件中，就像我们在`config.yml`中做的那样。然而，我们不想将其保存到`config.yml`中，因为它有不同的用途。我们首先需要做的是创建一个新的YAML配置，如下所示：
- en: '[PRE8]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Next, we will store all the information that we wish to save. This is done
    by setting objects to specific paths, as follows:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将存储我们希望保存的所有信息。这是通过将对象设置到特定的路径来完成的，如下所示：
- en: '[PRE9]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The acceptable types for `value` were mentioned earlier in this chapter. In
    the teleportation plugin, we have maps, which contain the `SerializableLocation`
    method. Maps can be added to a YAML configuration as long as they are a map of
    strings to an object that is `ConfigurationSerializable`. **Hashmaps** are added
    to a configuration in a different manner. You must create a configuration section
    using the map.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章前面提到了`value`的可接受类型。在传送插件中，我们有地图，其中包含`SerializableLocation`方法。只要它们是字符串到`ConfigurationSerializable`对象的映射，就可以将地图添加到YAML配置中。**哈希表**在配置中的添加方式不同。你必须使用地图创建一个配置部分。
- en: 'The following code shows how we will add the teleportation data to the configuration:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码显示了我们将如何将传送数据添加到配置中：
- en: '[PRE10]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Once all the data is stored, all that is left to do is write the configuration
    to the `save` file. This is done by invoking the `save` method on `config` and
    passing the file that we wish to use. Calling the `getDataFolder` method of the
    plugin will give us the directory in which we should store all the plugin data.
    This is also where `config.yml` is located. We can use this directory to reference
    the file in which we will save the data, as follows:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦所有数据都存储完毕，剩下的就是将配置写入`save`文件。这是通过在`config`上调用`save`方法并传递我们希望使用的文件来完成的。调用插件上的`getDataFolder`方法将给我们一个目录，我们应该在其中存储所有插件数据。这也是`config.yml`所在的位置。我们可以使用这个目录来引用我们将要保存数据的文件，如下所示：
- en: '[PRE11]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'We will put all of these lines of code inside a `try` block to catch an exception
    that may occur. If you don''t already know about exceptions, they are thrown when
    there is some sort of error or when something unexpected occurs. A `try/catch`
    block can be used to prevent the error from causing your plugin to crash. In this
    case, an exception is thrown if the specified file cannot be written for some
    reason. This reason may be that the user has insufficient privileges or the file
    location cannot be found. Therefore, the `save` method with the `try` block is
    as follows:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将所有这些代码行放入一个`try`块中，以捕获可能发生的异常。如果你还不了解异常，它们是在出现某种错误或发生意外情况时抛出的。可以使用`try/catch`块来防止错误导致你的插件崩溃。在这种情况下，如果由于某种原因指定的文件无法写入，则会抛出异常。这种原因可能是用户权限不足或找不到文件位置。因此，带有`try`块的`save`方法如下：
- en: '[PRE12]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The following is a sample `warps.yml` file that will be created using the Warper
    plugin:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个使用Warper插件创建的示例`warps.yml`文件：
- en: '[PRE13]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Loading data from a YAML configuration
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从YAML配置加载数据
- en: 'Now that the `save` method is complete, we are ready to write the `load` method.
    You are already familiar with loading data using the Bukkit configuration API.
    What we''ll do now is similar to retrieving values from `config.yml`, as discussed
    in the previous chapter. However, we must first manually load the configuration
    using the following code, which will be different. We should only do this if the
    file actually exists. The file will not exist the first time the plugin is used.
    Therefore, we do not want an error to occur in that situation:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 现在完成`save`方法后，我们准备编写`load`方法。你已经熟悉使用Bukkit配置API加载数据。我们现在要做的是类似于在上一章中讨论的从`config.yml`检索值。然而，我们必须首先手动使用以下代码加载配置，这将有所不同。我们只有在文件实际存在的情况下才这样做。因此，我们不希望在第一次使用插件时出现错误：
- en: '[PRE14]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Now that we have the YAML configuration loaded, we can get values from it.
    The data has been placed into two unique configuration sections. We will loop
    through each key of both the sections in order to load all the locations. To get
    a specific object from a section, all that we need to do is call the `get` method
    and cast it to the correct object. You can see how this is done in the completed
    `load` method:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经加载了YAML配置，我们可以从中获取值。数据已放置在两个独特的配置部分中。我们将遍历这两个部分中的每个键，以加载所有位置。要从部分获取特定对象，我们只需要调用`get`方法并将其转换为正确的对象。你可以在完成的`load`方法中看到这是如何完成的：
- en: '[PRE15]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Now that the plugin is complete, you can test it on your server. Set a home
    location as well as some warp locations and then view the save file. Stop and
    then start the server again to verify that the plugin does indeed load the correct
    data.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 现在插件已经完成，你可以在服务器上对其进行测试。设置一个家位置以及一些传送位置，然后查看保存的文件。停止并重新启动服务器以验证插件确实加载了正确的数据。
- en: Summary
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: The plugin that we created in this chapter invokes the `save` method whenever
    the data is modified. In the next chapter, you will learn how to periodically
    save data. If you wish to save data when the server is shut down, simply call
    the `save` method from the `onDisable` method of the plugin's `main` class. You
    can use your programming skills to expand this plugin. You can add permission
    nodes, which is done by simply adding them to `plugin.yml`. You can also add a
    `config.yml` file to modify messages or perhaps the amount of time that needs
    to be set for the upcoming warp delay. If you wish to incorporate a listener,
    you can listen for a `PlayerRespawnEvent`. Then, you can set a player's respawn
    location to their home. There are countless more ways to customize this plugin
    to your liking. Many teleportation plugins use a warp delay to prevent players
    from teleporting away from a fight. In the next chapter, we will expand this project
    by adding a warp delay using the Bukkit scheduler.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中我们创建的插件在数据被修改时都会调用`save`方法。在下一章中，你将学习如何定期保存数据。如果你希望在服务器关闭时保存数据，只需从插件的`main`类的`onDisable`方法中调用`save`方法。你可以利用你的编程技能来扩展这个插件。你可以添加权限节点，只需将它们添加到`plugin.yml`文件中即可。你还可以添加一个`config.yml`文件来修改消息或可能需要设置的即将到来的扭曲延迟的时间。如果你想要集成监听器，你可以监听`PlayerRespawnEvent`事件。然后，你可以设置玩家的重生位置为他们的家。有无数种方法可以自定义这个插件以满足你的需求。许多传送插件使用扭曲延迟来防止玩家在战斗中传送离开。在下一章中，我们将通过添加使用Bukkit调度器的扭曲延迟来扩展这个项目。
