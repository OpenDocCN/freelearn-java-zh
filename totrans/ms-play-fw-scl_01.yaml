- en: Chapter 1. Getting Started with Play
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The World Wide Web has grown by leaps and bounds since its first appearance
    in August 1991\. It has come a long way from line mode browsers and static websites
    to graphical browsers and highly interactive websites, such as search engines,
    online department stores, social networking, gaming, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: Complex websites or applications are backed by one or more databases and several
    lines of code. In most cases, such web applications use a framework to simplify
    the development process. A framework provides a skeleton structure that handles
    most of the repetitive or common features. Ruby on Rails, Django, Grails, and
    Play are a few examples of this.
  prefs: []
  type: TYPE_NORMAL
- en: Play Framework was developed by Guillaume Bort while he was working at Zenexity
    (now Zengularity). Its first full release was in October 2009 for version 1.0\.
    In 2011, Sadek Drobi joined Guillaume Bort to develop Play 2.0, which was adopted
    by Typesafe Stack 2.0\. Play 2.0 was released on March 13, 2012.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will be covering the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: The reasons for choosing Play
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a sample Play application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a TaskTracker application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Venturing into the world of Play
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Play's installation is hassle free. If you have Java JDK 6 or a later version,
    all you need to do to get Play working is an installation of **Typesafe Activator**
    or **Simple Build Tool** (**SBT**).
  prefs: []
  type: TYPE_NORMAL
- en: Play is fully RESTful! **Representational State Transfer** (**REST**) is an
    architectural style, which relies on a stateless, client-server, and cache-enabled
    communication protocol. It's a lightweight alternative to mechanisms such as **Remote
    Procedure Calls** (**RPC**) and web services (which include SOAP, WSDL, and so
    on). Here stateless means that the client state data is not stored on the server
    and every request should include all the data required for the server to process
    it successfully. The server does not rely on previous data to process the current
    request. The clients store their session state and the servers can service many
    more clients in a stateless fashion. The Play build system uses **Simple Build
    Tool** (**SBT**), which is a build tool used for Scala and Java. It also has a
    plugin to allow native compilation of C and C++. SBT uses incremental recompilation
    to reduce the compilation time and can be run in triggered execution mode, which
    means that if specified by the user, required tasks will be run whenever the user
    saves changes in any of the source files. This feature in particular has been
    leveraged by the Play Framework so that developers need not redeploy after every
    change in development stage. This means that if a Play app is running from source
    on your local machine and you edit its code, you can view the updated app just
    by reloading the app in the browser.
  prefs: []
  type: TYPE_NORMAL
- en: It provides a default test framework along with helpers and application stubs
    to simplify both unit and functional testing of the application. **Specs2** is
    the default testing framework used in Play.
  prefs: []
  type: TYPE_NORMAL
- en: Play comes with a Scala-based template engine, due to which it is possible to
    use Scala objects (`String`, `List`, `Map`, `Int`, user-defined objects, and so
    on) in the templates. This was not possible prior to 2.0 because earlier versions
    of Play relied on Groovy for the template engine.
  prefs: []
  type: TYPE_NORMAL
- en: It uses JBoss Netty as the default web server but any Play 2 application can
    be packaged as a WAR file and deployed on Servlet 2.5, 3.0, and 3.1 containers,
    if required. There is a plugin called **play2-war-plugin** (it can be found at
    [https://github.com/play2war/play2-war-plugin/](https://github.com/play2war/play2-war-plugin/)),
    which can be used to generate the WAR file for any given Play2 app.
  prefs: []
  type: TYPE_NORMAL
- en: 'Play endorses the **Model-View-Controller** (**MVC**) pattern. According to
    the MVC pattern, the components of an application can be divided into three categories:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Model**: This represents application data or activity'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**View**: This is the part of the application which is visible to the end user'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Controller**: This is responsible for processing input from the end user'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The pattern also defines how these components are supposed to interact with
    one another. Let''s consider an online store as our application. In this case,
    the products, brands, users, cart, and so on can be represented by a model each.
    The pages in the application where users can view the products are defined in
    the views (HTML pages). When a user adds a product to the cart, the transaction
    is handled by a controller. The view is unaware of the model and the model is
    unaware of the view. The controller sends commands to the model and view. The
    following figure shows how the models, views, and controllers interact:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Venturing into the world of Play](img/3803OS_01_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Play also comes prepackaged with an easy to use Hibernate layer, and offers
    OpenID, Ehcache, and web service integration straight out of the box by adding
    a dependency on the individual modules.
  prefs: []
  type: TYPE_NORMAL
- en: In the following sections of this chapter, we'll make a simple app using Play.
    This is mainly for developers who are using Play earlier.
  prefs: []
  type: TYPE_NORMAL
- en: A sample Play app
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are two ways of creating a new Play application: Activator, and without
    using Activator. It is simpler to create a Play project using Activator since
    the most minimalist app would require at least six files.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Typesafe Activator** is a tool that can be used to create applications using
    the Typesafe stack. It relies on using predefined templates to create new projects.
    The instructions for setting up Activator can be found at [http://typesafe.com/get-started](http://typesafe.com/get-started).'
  prefs: []
  type: TYPE_NORMAL
- en: Building a Play application using Activator
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let''s build a new Play application using Activator and a simple template:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, run the project using the `run` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: This starts the application, which is accessible at `http://localhost:9000`,
    by default.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `run` command starts the project in development mode. In this mode, the
    source code of the application is watched for changes, and if there are any changes
    the code is recompiled. We can then make changes to the models, views, or controllers
    and see them reflected in the application by reloading the browser.
  prefs: []
  type: TYPE_NORMAL
- en: 'Take a look at the project structure. It will be similar to the one shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Building a Play application using Activator](img/3803OS_01_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: If we can't use Activator, we will probably have to create all these files.
    Now, let's dig into the files individually and see which is for what purpose.
  prefs: []
  type: TYPE_NORMAL
- en: The build definition
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Let's start with the crucial part of the project—its build definition, and in
    our case, the `build.sbt` file. The `.sbt` extension comes from the build tool
    used for Play applications. We will go through the key concepts of this for anyone
    who isn't familiar with SBT. The build definition is essentially a list of keys
    and their corresponding values, more or less like assignment statements with the
    `:=` symbol acting as the assignment operator.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: SBT version lower than 0.13.7 expects a new line as the delimiter between two
    different statements in the build definition.
  prefs: []
  type: TYPE_NORMAL
- en: 'The contents of the build file are:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding build definition, the values for the project''s `name`, `version`,
    and `root` are specified. Another way of specifying values is by updating the
    existing ones. We can append to the existing values using the `+=` symbol for
    individual items and `++=` for sequences. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '`resolvers` is the list of URLs from where the dependencies can be picked up
    and `scalacOptions` is the list of parameters passed to the Scala compiler.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Alternatively, an SBT project can also use a `.scala` build file. The structure
    for our application would then be:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The build definition](img/3803OS_01_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The `.scala` build definition for `SimpleApp` will be:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The `.scala` build definition comes in handy when we need to define custom tasks/settings
    for our application/plugin, since it uses Scala code. The `.sbt` definition is
    generally smaller and simpler than its corresponding `.scala` definition and is
    hence, more preferred.
  prefs: []
  type: TYPE_NORMAL
- en: Without the Play settings, which are imported by enabling the PlayScala plugin,
    SBT is clueless that our project is a Play application and is defined according
    to the semantics of a Play application.
  prefs: []
  type: TYPE_NORMAL
- en: So, is that statement sufficient for SBT to run a Play app correctly?
  prefs: []
  type: TYPE_NORMAL
- en: No, there is something else as well! SBT allows us to extend build definitions
    using plugins. Play-based projects make use of the Play SBT plugin and it is from
    this plugin that SBT gets the required settings. In order for SBT to download
    all the plugins that our project will be using, they should be added explicitly.
    This is done by adding them in `plugins.sbt` in the `projectRoot/project` directory.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at the `plugins.sbt` file. The file content will be:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The parameter passed to `addSbtPlugin` is the Ivy module ID for the plugin.
    The resolver is helpful when the plugin is not hosted on Maven or Typesafe repositories.
  prefs: []
  type: TYPE_NORMAL
- en: The `build.properties` file is used to specify the SBT version to avoid incompatibility
    issues between the same build definitions compiled by using two or more different
    versions of SBT.
  prefs: []
  type: TYPE_NORMAL
- en: This covers all the build-related files of a Play application.
  prefs: []
  type: TYPE_NORMAL
- en: The source code
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Now, let us look at the source code for our project. Most of the source is in
    the `app` folder. Generally, the model's code is within `app/models` or `app/com/projectName/models`
    and the controller's source code is in `app/co` `ntrollers` or `app/com/projectName/controllers`,
    where `com.projectName` is the package. The code for the views should be in `app/views`
    or within a subfolder in `app/views`.
  prefs: []
  type: TYPE_NORMAL
- en: The `views/main.scala.html` file is the page we will be able to see when we
    run our application. If this file is missing, you can add it. If you are wondering
    why the file is named `main.scala.html` and not `main.html`, this is because it's
    a Twirl template; it facilitates using Scala code along with HTML to define views.
    We will delve deeper into this in [Chapter 4](ch04.html "Chapter 4. Exploring
    Views"), *Exploring Views*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, update the content of `main.scala.html` to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'We can provide the title and content from our Scala code to display this view.
    A view can be bound to a specific request through the controllers. So, let''s
    update the code for our controller `SampleAppController`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Downloading the example code**'
  prefs: []
  type: TYPE_NORMAL
- en: You can download the example code files for all Packt books you have purchased
    from your account at [http://www.packtpub.com](http://www.packtpub.com). If you
    purchased this book elsewhere, you can visit [http://www.packtpub.com/support](http://www.packtpub.com/support)
    and register to have the files e-mailed directly to you.
  prefs: []
  type: TYPE_NORMAL
- en: '`Action` and `Ok` are methods made available by the `play.mvc.api` package.
    [Chapter 2](ch02.html "Chapter 2. Defining Actions"), *Defining Actions* covers
    them in detail.'
  prefs: []
  type: TYPE_NORMAL
- en: 'On saving the changes and running the application, we will see the page hosted
    at `http://localhost:9000`, as shown in the screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The source code](img/3803OS_01_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Request handling process
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Let's see how the request was handled!
  prefs: []
  type: TYPE_NORMAL
- en: All requests that will be supported by the application must be defined in the
    `conf/routes` file. Each route definition has three parts. The first part is the
    request method. It can be any one of `GET`, `POST`, `PUT`, and `DELETE`. The second
    part is the path and the third is the method, which returns a response. When a
    request is defined in the `conf/routes` file, the method to which it is mapped
    in the `conf/routes` file is called.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, an entry in the routes file would be:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: This means that for a GET request on the `/` path, we have mapped the response
    to be the one returned from the `SampleController.index()` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'A sample request would be:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Go ahead and add a few more pages to the application to get more comfortable,
    maybe a FAQ, Contact Us, or About.
  prefs: []
  type: TYPE_NORMAL
- en: 'The request-response cycle for a Play app, explained in the preceding code
    is represented here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Request handling process](img/3803OS_01_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The `public` directory is essentially used to serve resources, such as stylesheets,
    JavaScript, and images that are independent of Play. To make these files accessible,
    the path to `public` is also added in routes by default:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: We will see routes in detail in [Chapter 3](ch03.html "Chapter 3. Building Routes"),
    *Building Routes*.
  prefs: []
  type: TYPE_NORMAL
- en: The file `conf/application.conf` is used to set application-level configuration
    properties.
  prefs: []
  type: TYPE_NORMAL
- en: The `target` directory is used by SBT for the files generated during compile,
    build, or other processes.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a TaskTracker application
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let us create a simple **TaskTracker** application, which allows us to add pending
    tasks and delete them. We will continue by modifying `SampleApp`, built in the
    previous section. In this app, we will not be using a DB to store the tasks. It
    is possible to persist models in Play using **Anorm** or other modules; this is
    discussed in more detail in [Chapter 5](ch05.html "Chapter 5. Working with Data"),
    *Working with Data*.
  prefs: []
  type: TYPE_NORMAL
- en: 'We need a view that has an input box to enter the task. Add another template
    file, `index.scala.html`, to the views, using the template generated in the preceding
    section as boilerplate:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: In order to use a template, we can call its generated method from our Scala
    code or refer to it in other templates by using its name. Using a main template
    can come in handy when we want to apply a change to all the templates. For example,
    if we want to add a style sheet for an application, just adding this in our main
    template will ensure that it's added for all the dependent views.
  prefs: []
  type: TYPE_NORMAL
- en: 'To view this template''s content on loading, update the `index` method to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Notice that we have also replaced all occurrences of `SampleAppController` to
    `TaskController`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the application and view it in the browser; the page will look similar
    to this figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating a TaskTracker application](img/3803OS_01_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, in order to work on the functionality, let''s add a model called `Task`,
    which we''ll use to represent the task in our app. Since we want to delete the
    functionality too, we will need to identify each task using a unique ID, which
    means that our model should have two properties: an ID and a name. The `Task`
    model will be:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: In this model, we are using a `taskList` private variable to keep track of the
    tasks for the session.
  prefs: []
  type: TYPE_NORMAL
- en: In the `add` method, whenever a new task is added, we append it to this list.
    Instead of keeping another variable to keep count of the IDs, I choose to increment
    the ID of the last element in the list.
  prefs: []
  type: TYPE_NORMAL
- en: In the `delete` method, we simply filter out the task with the given ID and
    the `all` method returns the list for this session.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we need to call these methods in our controller and then bind them to
    a request route. Now, update the controller in this way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, `routes` refers to the helper that can be used to access
    the routes defined for the application in `conf/routes`. Try running the app now!
  prefs: []
  type: TYPE_NORMAL
- en: It'll throw a compilation error, which says that values tasks is not a member
    of `controllers.ReverseTaskController`. This occurs because we haven't yet updated
    the routes.
  prefs: []
  type: TYPE_NORMAL
- en: Adding a new task
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now, let''s bind actions to get tasks and add a new task:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'We''ll complete our application''s view so that it can facilitate the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`accept and render a List[Task]`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: We have now added a form in the view, which takes a text input with the `taskName`
    name and submits this data to a `TaskController.newTask` method.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Notice that we have now added a `tasks` argument for this template and are displaying
    it in the view. Scala elements and predefined templates are prepended with the
    `@` twirl symbol in the views.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, when running the app, we will be able to add tasks as well as view existing
    ones, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Adding a new task](img/3803OS_01_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Deleting a task
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The only thing remaining in our app is the ability to delete a task. Update
    the index template so that each `<li>` element has a button, whose click results
    in a delete request to the server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we would need to update the routes file to map the delete action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'We also need to define `deleteTask` in our view. To do this, we can simply
    add a script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Ideally, we shouldn't be defining JavaScript methods in the window's global
    namespace. It has been done in this example, so as to keep it simple and it's
    not advised for any real-time application.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, when we run the app, we can add tasks as well as remove them, as shown
    here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Deleting a task](img/3803OS_01_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'I am leaving the task of beautifying the app up to you. Add a style sheet in
    the public directory and declare it in the main template. For example, if the
    `taskTracker.css` file is located at `public/stylesheets`, the link to it in the
    `main.scala.html` file would be:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This chapter gives a basic introduction to the Play Framework. In this chapter,
    we have learned how to build simple applications using the Play Framework. We
    have gone through its project structure to understand how the framework plugs
    in required settings through the build file. We have also discussed the various
    bits and pieces of such applications: models, routes, views, controllers, and
    so on.'
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will cover actions in detail.
  prefs: []
  type: TYPE_NORMAL
