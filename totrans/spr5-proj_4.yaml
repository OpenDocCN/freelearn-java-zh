- en: Building a Central Authentication Server
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Implementing security constraints is a core requirement of any application.
    Spring provides support to various aspects of applications, including security.
    One of the modules of the Spring framework, called Spring Security, was specially
    designed to meet security needs. It is a robust and highly adaptive framework,
    providing authentication and authorization out of the box.
  prefs: []
  type: TYPE_NORMAL
- en: Spring Security is the standard for securing any Spring-based application. We
    can see the real strength of Spring Security when integrating it with other systems.
    Its capabilities can be extended with ease, in order to meet custom requirements.
    This chapter will be devoted purely to Spring Security.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the last chapter, we looked at the power of the Spring framework, with various
    modules and third-party libraries binding together in Spring Boot: a module built
    on top of the Spring framework, mainly designed for bootstrapping and developing
    a Spring-based application with auto configuration. We will continue to use it
    in this chapter, in order to build central authentication and authorization system.'
  prefs: []
  type: TYPE_NORMAL
- en: Spring Security is a highly customizable framework, and we can integrate it
    with other systems that provide the data for access control. In this chapter,
    we will look closely at **Lightweight Directory Access Protocol** (**LDAP**) and
    **OAuth** integration with Spring Security.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will cover the following interesting topics in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: A basic understanding of LDAP and data structures
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuration of the LDAP server (Apache DS)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Authentication in Spring Security with LDAP
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: LDAP authorization with Spring Security
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: OAuth fundamentals and various grant types
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Spring Security integration with OAuth
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dual authentication with LDAP and OAuth in Spring Security
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: OAuth implementation with a custom authorization server in Spring Security
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'All the code used in this chapter can be downloaded from the following GitHub
    link: [https://github.com/PacktPublishing/Spring-5.0-Projects/tree/master/chapter04](https://github.com/PacktPublishing/Spring-5.0-Projects/tree/master/chapter04).
    The code can be executed on any operating system, although it has only been tested
    on Windows.'
  prefs: []
  type: TYPE_NORMAL
- en: LDAP
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When email was introduced and started to be used in corporations, one challenge
    was to look up the email address of someone that had never communicated with you.
    It required some sort of central repository for searching the email addresses
    of other people within the organization.
  prefs: []
  type: TYPE_NORMAL
- en: Necessity is the mother of invention. The need for a central data depot brought
    companies like Microsoft, Lotus, Netscape, and IBM together, and they defined
    a standard called **LDAP**. It is a protocol for accessing data stored in a directory
    structure over the network.
  prefs: []
  type: TYPE_NORMAL
- en: The LDAP server, which holds and indexes the data in a hierarchical manner,
    can be accessed by LDAP-aware clients. The data can be filtered to select a particular
    person or group stored in a different entity. For example, imagine searching for
    all employees located in Chicago that are from the admin department and have been
    working for more than three years, and receiving their full name, designation,
    and email address. This is quite possible with LDAP.
  prefs: []
  type: TYPE_NORMAL
- en: Apart from contact information, LDAP can also be used to store access control
    data, which can then be used to perform authentication and authorization. We will
    start by covering the basics of LDAP and how to construct a data structure with
    it.
  prefs: []
  type: TYPE_NORMAL
- en: What is LDAP?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: LDAP is an industry standard for accessing and managing hierarchical information
    stored in a directory structure over the network. LDAP has been in use for quite
    a long time. Nowadays, it is mainly used to build an authentication system; however,
    that is by no means its only purpose. LDAP can also be used to store any kind
    of information that needs to be accessed centrally (for example, emails or contact
    information in an organization).
  prefs: []
  type: TYPE_NORMAL
- en: 'The main motive for storing user (or any other) information, like usernames,
    emails, passwords, and so on, in one place, is to provide administration and maintenance
    support with ease. For example, rather than handling the user list for each subgroup
    separately in an organization, LDAP can be used to manage them as a central repository,
    accessible from anywhere in the network. There are certain use cases where LDAP
    is the perfect fit, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Allowing a user to log in with the same credentials in multiple applications,
    like logging in on an intranet and on your local machine.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Providing role-based access to a group of users; for example, accessing a specific
    page on the intranet site, or accessing a document in a document management system.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Collecting user contact details and making them available globally, so that
    any user in the organization can access them.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: LDAP is a way to access the structured information stored in directories. For
    this, it follows the client-server model, where data is stored on the LDAP server
    and the client can raise a request to access required information (through the
    LDAP API).
  prefs: []
  type: TYPE_NORMAL
- en: The information stored in an LDAP service is not intended to be altered upon
    each access, which makes that LDAP is a write once and read many times form of
    service. For example, LDAP would not be appropriate for maintaining the transaction
    records of an online shopping application, considering the fact that those records
    change with every operation. However, LDAP can be used to maintain data that changes
    less frequently, like user accounts, user addresses, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: The data stored on the LDAP server is not in a relational form; rather, it is
    hierarchical. However, LDAP uses the database to store the information internally,
    but presents it in a hierarchical manner.
  prefs: []
  type: TYPE_NORMAL
- en: 'Along with defining how to access the data in the directory service, LDAP also
    defines how the data is presented. To understand this data information model,
    it is essential to understand certain terms used in LDAP. This will not only help
    you to get a better idea of how it works, but will also illustrate how to create
    and search for the data in LDAP:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Directory information tree **(**DIT**): As we discussed, the LDAP server
    stores the information in a hierarchical (or a tree) form. This tree is called
    a directory information tree.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Entry**: As trees have nodes, the nodes in the DIT are called entries. The
    information that is stored within the entry is in the form of a key-value pair.
    Each entry has one parent entry (except for the root entry) and zero or more child
    entries. A child entry is a sibling of its parent’s other child entry.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Root/base/suffix**: The top entry in DIT is called the root, base, or suffix.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Distinguished name **(**DN**): Each entry in DIT should be recognized by
    a unique identifier. This unique identifier is called a distinguished name. Generally,
    it is a string consisting of one or more comma-separated key-value pairs, which
    together uniquely distinguish the node (entry) in the tree. For example, the string
    `dc=nilangpatel`*,* `cd=com` could be the DN for the root entity.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Relative distinguished name** (**RDN**): A string that uniquely distinguishes
    the entity relative to its parent is called a relative distinguished name. The
    DN uniquely identifies the entity globally, while the RDN uniquely identifies
    the entity among its siblings.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Object class**: Each entity is comprised of one or more `objectClasses`.
    Each object class has a name and zero or more attributes. The `objectclass` is
    considered a container for attributes, and it will control what types of attributes
    can be added to the entity.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Attribute**: The attribute is part of the `objectclass`. It has a name and
    a value. It also has an abbreviation or alias.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following is a list of a few attributes (along with their object classes)
    that we are going to use in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Attribute name | Alias name | Description | Object class |'
  prefs: []
  type: TYPE_TB
- en: '| `dc` | `domainComponent` | Any part of a domain name; for example, `domain.com`,
    domain, or com | `dcObject` |'
  prefs: []
  type: TYPE_TB
- en: '| `o` | `organizationName` | Organization name | `organization` |'
  prefs: []
  type: TYPE_TB
- en: '| `ou` | `organisationalUnitName`  | Department or any subgroup | `organizationUnit`
    |'
  prefs: []
  type: TYPE_TB
- en: '| `cn` | `common name` | Name of the entity | `person`, `organizationalPerson`,
    `organizationalRole`, `groupOfNames`, `applicationProcess`, `applicationEntity`,
    `posixAccount`, `device` |'
  prefs: []
  type: TYPE_TB
- en: '| `sn` | `surname` | Surname or family name | `person` |'
  prefs: []
  type: TYPE_TB
- en: '| `uid` | `userid` | Username or other unique value | `account`, `inetOrgPerson`,
    `posixAccount` |'
  prefs: []
  type: TYPE_TB
- en: '| `userPassword`  |  `-` | User password for some form of access control |
    `organization`, `organizationalUnit`, `person`, `dmd`, `simpleSecurityObject`,
    `domain`, `posixAccount` |'
  prefs: []
  type: TYPE_TB
- en: '**LDAP Data Interchange Format **(**LDIF**): This is an ASCII file format to
    describe the hierarchical tree structure of LDAP data in the form of a text file.
    LDAP data can be imported or exported in an LDIF file format.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuring Apache DS as an LDAP server
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will use **Apache Directory Server** (**Apache DS**), an extendable, modern,
    and embeddable LDAP server, to showcase LDAP authentication. It is written purely
    in Java. Apache DS comes as a standalone LDAP server. While working with it, you
    will need some sort of LDAP Browser to visualize and manipulate the data.
  prefs: []
  type: TYPE_NORMAL
- en: However, Apache provides another tool, called **Apache Directory Studio,** which
    is an Eclipse-based application. It ships with Apache DS and LDAP Browser, in
    a single bundle. It was designed particularly for Apache DS; however, you can
    use it with any LDAP server (like **OpenLDAP**).
  prefs: []
  type: TYPE_NORMAL
- en: When you use Apache Directory Studio, you are no longer required to get another
    LDAP server, because it comes with Apache DS (an LDAP server).
  prefs: []
  type: TYPE_NORMAL
- en: Download Apache Directory Studio ([https://directory.apache.org/studio/](https://directory.apache.org/studio/)),
    extract it on your local machine, and double-click on the `ApacheDirectoryStudio`
    executable file to open it.
  prefs: []
  type: TYPE_NORMAL
- en: First, we need to add the Apache DS server. For that, go to the LDAP Server
    tab (generally placed at the bottom of the window), right-click there, select
    New | New Server, and choose the latest version of Apache DS server. Once the
    server has been added, right-click on it and select *Run* to start the server.
  prefs: []
  type: TYPE_NORMAL
- en: 'After the server is up and running, we need to create a connection. Right-click
    on the *Connections* tab and select New Connection, with the following information:'
  prefs: []
  type: TYPE_NORMAL
- en: Connection name**:** Any appropriate name.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Hostname: The localhost.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Port**:** The default port for any LDAP server is `389`. However, the default
    port for Apache DS is `10389`. Needless to say, that port can be changed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Keep the rest of the options as is, and click on the Next button to fill in
    the following details:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Authentication Method:** Simple authentication'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Bind DN or user: **`uid=admin`, `ou=system`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Bind password:** `Secret`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This is the default admin credential, and can be verified by clicking on the Check
    Authentication button. Click on Finish, and you will see the details in the LDAP
    Browser windows, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e77d5953-205b-452f-8cb8-30cadfe77ffd.png)'
  prefs: []
  type: TYPE_IMG
- en: Next, we will start to create a data structure to store user details. As you
    have seen, LDAP can be used to store any kind of information, but we will use
    LDAP for authentication. LDAP stores the data in the form of a tree (DIT), so
    we will create a DIT structure.
  prefs: []
  type: TYPE_NORMAL
- en: Example DIT structures
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Moving on, let''s first look at a few data structures that are commonly used
    in LDAP, and then select one of them:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/82f72d0f-e7ab-4c5f-a48a-2240ca32af5a.png)'
  prefs: []
  type: TYPE_IMG
- en: This structure starts with an organization with a name, packt (**o=packt**),
    followed by an organizational unit (subgroup) for each of the departments, and
    finally, the users. At some places, the sub-organization has a user group, followed
    by users.
  prefs: []
  type: TYPE_NORMAL
- en: 'The tree can also be arranged based on internet domain names, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/54101e71-9a26-4e90-8bc2-8cdf364380b0.png)'
  prefs: []
  type: TYPE_IMG
- en: This structure has `example.com` as a domain. You can give the same attribute
    multiple times with different name, as previously shown. The **dc** stands for **domain
    component**. It is followed by subgroups for **users** and **printers** (devices),
    and at the end, the **users** and devices (**printers**) are listed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another option could be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/fa6a4809-43f0-4b9d-ab26-5f8619a589f7.png)'
  prefs: []
  type: TYPE_IMG
- en: This option has an organization (**o=packtPublisher**) as the root, and two
    child **users** and **roles** as the **ou** (organizational unit, or subgroup).
    The **users** entry will have user entries, and the **roles** entry will have
    role entries. We will choose this option to construct a DIT in LDAP in this chapter.
    LDAP allows for associating the users to roles with attribute members. You will
    see more details about this in the *Creating roles in an LDAP server* section,
    later in this book.
  prefs: []
  type: TYPE_NORMAL
- en: Apache DS partitions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Apache DS has a concept called **partitions**. Every partition contains an entity
    tree (DIT) that is totally disconnected from the entity trees in other partitions.
    This means that changes that happen with entry trees in one partition will never
    affect entry trees in other partition. Each partition is identified by a unique
    ID. It also has a naming context referred to as the **partition suffix**, which
    can be thought of as the root (or base) for the DIT in that partition; all entries
    are stored beneath that.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create a partition in Apache DS, double-click on the server instance in
    the LDAP server tab, and it will open the server configuration. Open the Partitions
    tab of the server configuration, click on the Add button, and give the values
    for the Partition General Details section, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/93d2ee51-0e6a-44fd-8634-33e8bb916c39.png)'
  prefs: []
  type: TYPE_IMG
- en: 'ID: `packtPublisher`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Suffix: `o=packtPublisher`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Keep all of the other values as the defaults, and save the configuration. Restart
    the server to take the partition into effect. The new partition will be available
    in the LDAP Browser, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c05bf0b7-40a1-4e18-ba9c-2e40d5706561.png)'
  prefs: []
  type: TYPE_IMG
- en: We will create an entity tree (DIT) under this partition. The partition suffix
    (`o=packtPublisher`) will be considered the base (or root) of the DIT. Next, we
    will create entries underneath it.
  prefs: []
  type: TYPE_NORMAL
- en: The LDAP structure
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Proceeding further, we will look at the DN and RDN concept in DIT. We are targeting
    our DIT as per the third option that you saw in the *Example DIT structures* section. Let's
    recall that the RDN uniquely distinguishes the entry among its siblings. That
    means it is a key that makes the entry unique underneath the parent entry. We
    can use any attribute to declare the RDN. Additionally, at each level, the attribute
    used as an RDN can differ.
  prefs: []
  type: TYPE_NORMAL
- en: In our case, the RDN of the base is `o=packtPublisher` (which is the partition
    suffix). We have used the attribute `o`, which is the organization name. Just
    beneath it, there are two children, for which the `ou` attribute has been used
    as the RDN. The attribute `ou` stands for an organizational unit. These two children
    represent users and roles, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: We are going to store the user information (the username and password, along
    with other information) under the `users` entity. So, the children of the `users`
    entity are the actual user entity for which the attribute `uid` is used as the
    RDN. The attribute `uid` stands for the **user ID**. Generally, in any organization,
    either the username or email ID is used for logging in; so, we can take either
    of them as the value of the `uid` attribute. In this case, we will give the username
    as `uid`.
  prefs: []
  type: TYPE_NORMAL
- en: We've gone over how the RDN works. Now, let's look at how the DN works. As we
    described, the DN uniquely identifies any entry in a given DIT. In other words,
    the DN makes the entry unique across the whole tree (DIT). The DN is a comma-separated
    string of the RDNs of the given entity, along with all of its parents, up till
    the root entity. So, the DN is automatically calculated, based on a given RDN
    at each level.
  prefs: []
  type: TYPE_NORMAL
- en: In the previous case, the DN of each entity (with `uid=npatel`) would be `uid=npatel`*,*
    `ou=users`*,* and `o=packtPublisher`. Similarly, the DN of the `users` entity
    is `ou=users` and `o=packtPublisher`. This is how the DN is calculated by appending
    the RDN at each level.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create this structure in Apace DS now. Execute the following steps to
    expand the DIT structure in Apache Directory Studio:'
  prefs: []
  type: TYPE_NORMAL
- en: Right-click on the partition `o=packtPublisher`, and select New | New Entry.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Choose an option, *Create entry from scratch*, and click on Next.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We are going to add an entity type organization unit, so choose the `organizationalUnit`
    object class and click on Next.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We will use `ou` (organizational unit) as an RDN and `users` as its value. The
    DN is automatically calculated when you give the value of the RDN. You can use
    more than one attribute (or the same attribute multiple times, with a different
    value) for the RDN. The DN will then be calculated by appending each name with
    a comma.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on Next, followed by the Finish button, and the entry `ou=users` will
    be added under `o=packtPublisher`. The updated structure will be visible in the LDAP
    Browser window.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Once the `users` entry is added, we can insert the individual user entries
    underneath it. The steps are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Right-click on the `users` entity (`ou=users`), and select New | New Entry.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Choose the option Create entry from scratch and click on Next.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We are going to add a user, so choose the `inetOrgPerson` object class, which
    represents a person within an organization. Click on the Next button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We are going to add a user, so we will use the attribute `uid` (user ID) as
    the RDN. Just give the value as `npatel`. You can give any value that uniquely
    identifies the user. At this moment, the DN is calculated as `uid=npatel`,`ou=users`,
    `o=packtPublisher`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on Next, and you will see a few required attributes, like `cn` and `sn`.
    The `cn` stands for **common name**, and `sn` means **surname**. The first name
    and last name can be given for `cn` and `sn`, respectively.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We want to authenticate a user, so there must be a password field (attribute)
    for a user entity. Just right-click on this screen and select New Attribute.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Give the attribute type as `userPassword`, and click on Next | Finish; a new
    window will pop up, in which you can give the password.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Give the appropriate value for the password, confirm the password, and set the Hash
    method as SHA; click on the OK button. Click on the Finish button from the parent
    window.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add two to three such users, using the previous steps. We will look at how to
    add roles and create actual roles in the *LDAP authorization with Spring Security*
    section.
  prefs: []
  type: TYPE_NORMAL
- en: The default configuration of Apache DS contains a data partition with the suffix
    `dc=example`, `dc=com`. This partition can also be used, but to understand the
    concept in detail, we have created a separate partition.
  prefs: []
  type: TYPE_NORMAL
- en: Congratulations! The basic step of configuring the LDAP is done. The LDAP server
    is ready for use. Next, we will look at how to authenticate the user against the
    LDAP server with Spring Security.
  prefs: []
  type: TYPE_NORMAL
- en: Spring Security integration with LDAP
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [Chapter 3](e32452e8-07bb-4815-96d6-b0db0a6009ba.xhtml), *Blogpress - A Simple
    Blog Management System*, we provided information about Spring Boot and looked
    at how to create an application with it. In this chapter, we will use Spring Boot
    to build an app to showcase authentication and authorization in Spring Security.
    In the *LDAP* section, we covered the installation and setup of the LDAP server,
    along with its data structure. In this section, you will see how Spring Security
    works with LDAP.
  prefs: []
  type: TYPE_NORMAL
- en: Spring Security is a highly comprehensive and extensible framework; it provides
    authentication and authorization support for a J2EE-based web and REST application.
    We will look at how to integrate Spring Security with LDAP to perform authentication.
    By definition, **authentication** is a mechanism of validating or deciding whether
    an individual or entity is what it claims to be.
  prefs: []
  type: TYPE_NORMAL
- en: To demonstrate authentication, we will first build a web application with Spring
    Boot, and then we'll integrate it with LDAP.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a web application with Spring Boot
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We have created the data structure and have added the users, along with their
    credentials, in the LDAP server. Next, we will build a web application and integrate
    Spring Security, which will talk to the LDAP server for authentication. In the
    previous chapter, we built an application with Spring MVC and Thymeleaf. We will
    reuse the same architecture and create a web application with the following artifacts:'
  prefs: []
  type: TYPE_NORMAL
- en: Spring Boot, for creating a web application and auto configuration for other
    modules
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Thymeleaf, for the presentation layer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Spring Security, to perform authentication with LDAP.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Like in the previous chapter, we will use an Eclipse-based IDE called **Spring
    Tool Suite (STS)** in this chapter. Create a Spring Boot application with the
    name `SpringAuth`, and other suitable parameters, like the group, artifact, version,
    description, and Java package. Make sure that the following starters are added
    to `pom.xml`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Among the preceding entries, the `spring-security-ldap` is not a starter, but
    rather, a plain dependency. It provides the relevant dependencies required in
    the integration of Spring Security with LDAP.
  prefs: []
  type: TYPE_NORMAL
- en: We will configure the LDAP server as a data source to fetch user details and
    perform authentication in Spring Security. At this moment, Spring Security should
    know the details of how to connect with the LDAP server. These details are comprised
    of the URL, the base RDN, and the admin credentials. We will define these details
    in the `application.properties` file, as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The details are straightforward. The username and password represent the LDAP
    admin credentials. Since we are dealing with LDAP, the admin username is in the
    form of a DN (`uid=admin`*,* `ou=system`) instead of a direct value (like admin).
    We can relate these details with the information that we use to interact with
    a database (like the URL, port, username, and password). We will read these details
    and supply them to Spring Security to make a connection with LDAP. To achieve
    this, we will write a configuration class, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'This class simply reads the LDAP connection properties with the `@Value` annotation,
    stored in the instance of the `LdapAuthStructure` class, and defines it as Spring
    Bean, so that it is available to other classes. The `LdapAuthStructure` is a custom
    class that holds LDAP configuration properties. We will use the following two
    additional properties for LDAP integration with Spring:'
  prefs: []
  type: TYPE_NORMAL
- en: '`userDnPattern`: The value is `uid={0},ou=users`. This is nothing but a DN
    pattern (relative to the entity `ou=users`). The `{0}` will be substituted with
    the actual value (`uid`, user ID) by Spring at runtime.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`userSearchBase`:It represents the user base (`ou=users`). Basically, it represents
    an entity under which the users can be searched.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`groupSearchBase`: It represents the group base (`ou=roles`). We will use this
    property to perform authorization in upcoming sections.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Next, we will use these properties and initialize Spring Security with the
    security configuration class, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The `WebSecurityConfig` is a custom class that extends the `WebSecurityConfigurerAdapter`
    class. This class is a single point of configuration to declare security-related
    details. The `configure(WebSecurity web)` method is used for ignoring the requests
    for static resources (JS and CSS) from the security context. Without this, not
    a single static resource will be loaded in the browser, because they will be filtered
    by Spring Security.
  prefs: []
  type: TYPE_NORMAL
- en: For our application, we did not use any images; if we did, the image path (generally
    `/img/**`) would also need to be ignored.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next method, `configure(HttpSecurity http)`, is used to set rules on various
    pages (URLs). Our motive is to showcase authentication with LDAP; hence, to make
    things simple, there are three pages with corresponding URLs, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The home page (with the URL `/`). It is a landing page, meaning that this page
    will be opened when a user types `http://localhost:8080/springauth` (considering
    `8080` as the server port and `springauth` as the context).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The login page (with the URL `/login`). It will show a login form, with which
    the user can be authenticated.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A private page (with the URL `/privatePage`). This is a protected page and is
    only available to the logged in user. A user will be redirected to this page upon
    successful login.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The home page and login page are set to view for all, while the private page
    is set as a successful URL after logging in. This is a simple form login. The
    next method, `configure(AuthenticationManagerBuilder authManagerBuilder)`, actually
    does the magic. This is the place where the LDAP is being configured as an authentication
    mechanism.
  prefs: []
  type: TYPE_NORMAL
- en: In this class, the object of `LdapAuthStructure` is being auto-wired, which
    is supplied from the `LdapDataConfig` class, where we declared it with the `@Bean`
    annotation. Let's recall that the `LdapAuthStructure` class holds the LDAP connection
    data, which we are using in the `configure(AuthenticationManagerBuilder authManagerBuilder)` method.
    The call `ldapAuthentication()` on the `AuthenticationManagerBuilder` class will
    set the type of authentication as LDAP.
  prefs: []
  type: TYPE_NORMAL
- en: Further, it will set other connection data, like `userDnPattern` and `userSearchBase`.
    The value of `url` is supplied as a combination of the LDAP URL and the LDAP base
    (for example, `localhost:10389/o=packtPublisher`). In the end, the admin credential
    is supplied with the `managerDn()` and `managerPassword()` call. We also need
    to supply a password encoder. It must be the same password encoder that we used
    in the LDAP server, so we have used `LdapShaPasswordEncoder`. Finally, we are
    just mentioning the password field that we set in the LDAP server.
  prefs: []
  type: TYPE_NORMAL
- en: The LDAP authentication configuration is done. When we log in with the (same)
    credentials that we created in the Apache DS server, it will be successful. We
    have set the `uid`as `userDnPatterns`, so give `uid` as the username when logging
    in.
  prefs: []
  type: TYPE_NORMAL
- en: Congratulations! The LDAP integration with Spring Security has been successfully
    executed. The user will be authenticated against LDAP through Spring Security.
    If you only need to perform authentication with LDAP, the configuration that we
    have done so far will suffice. Next, we will look at how to interact with the
    LDAP server through the Spring Data repository, which we will use while working
    with both LDAP and OAuth later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Managing LDAP users with Spring Data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One part of our integration is over. The LDAP admin can configure users from
    the LDAP server; then, they can be authenticated from web applications created
    with Spring Security. However, we still have to deal with separate systems (Apache
    DS) to maintain the user information.
  prefs: []
  type: TYPE_NORMAL
- en: How cool would it be if an admin could directly maintain the users from a Spring
    web application? This is a great idea, because it will not only make the admin
    job easy, but a user will be able to update their profile information (like the
    password, first name, last name, and so on) directly in the Spring-based web application. This
    is quite possible with Spring Boot. We are talking about performing CRUD operations
    on the LDAP server from a web application.
  prefs: []
  type: TYPE_NORMAL
- en: In our application, the LDAP is used as a data store, where we are maintaining
    user data. Whenever we need to deal with any kind of data provider in a Spring-based
    application, we need to use **Spring Data**, a module of the Spring family that
    was specially designed to interact with the data store. Spring Data facilitates
    an abstract layer to interact with the underlying data provider, while providing
    an implementation for each of the data providers, like JPA, REST, Elasticsearch
    (which we used in the previous chapter), Mongo DB, and so on. Spring Data LDAP
    interacts with the LDAP server, and we will use it in our application.
  prefs: []
  type: TYPE_NORMAL
- en: 'Spring supplies a set of libraries for each of these data providers, which
    can be availed of by specifying the corresponding starter in the Spring Boot application.
    The Spring Data LDAP module can be integrated with the following starter entry
    in `pom.xml`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Soon after we have defined this starter, all of the required JARs will be available
    in the classpath. Next, we will create the model (entity) class.
  prefs: []
  type: TYPE_NORMAL
- en: Spring Data models
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Spring Data module provides an implementation of DAO, with the aim of making
    data access consistent for various data providers. This brings the great flexibility
    of switching the underlying persistence technologies without much effort. Eventually,
    this will make the system loosely coupled.
  prefs: []
  type: TYPE_NORMAL
- en: 'Spring Data allows for exchanging the data with the persistence layer in an
    object-oriented manner, meaning that we can perform CRUD operations with entity
    class objects. Needless to say, the Spring Data LDAP module also facilitates the
    feature of dealing with the LDAP server in the form of the model class object.
    So, the first thing is to define the model (entity) class that represents the
    user data that we defined in the LDAP server, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The `LdapAuthUser` class represents the LDAP user that we created in Apache
    DS. The `@Entity` annotation is used to map the Java class with an entity in the
    LDAP server. The `base` represents the base of the `users` entity (`ou=users`),
    while `objectClasses` is used to define the object class hierarchy used for creating
    the user entity.
  prefs: []
  type: TYPE_NORMAL
- en: The `@Attribute` annotation is used to map the instance variable with the attribute
    of the LDAP entity. The annotation `@DnAttribute` is used to populate the values
    automatically, from the distinguished names of the entries found. Special attention
    for `id` instance variable. It will be of the type `javax.naming.Name`.
  prefs: []
  type: TYPE_NORMAL
- en: There is no direct attribute, like `id`, in the LDAP entity, but Spring Data
    needs some sort of unique identifier (like `PK`, in a relational database) for
    each instance of the model class. So, internally, it assigns a DN relative to
    a `base` (in the `@Entity` annotation) defined for the model class. For example,
    if the `uid` of a user is `npatel`, then the `id` would be `uid=npatel`, `ou=users`.
  prefs: []
  type: TYPE_NORMAL
- en: Another unique point is that this model class implements the `Persistable<Name>`
    interface. Especially for the LDAP, at the time of adding a new entity, Spring
    Data does not have any way of knowing whether the entity is new or existing. So,
    every time Spring Data tries to search for an existing entity, it will throw an
    error if the entity does not exist. To avoid this, while adding a new record,
    we will explicitly set the `isNew` attribute to `true`, so that Spring Data will
    get its value with the overridden method `isNew()`.
  prefs: []
  type: TYPE_NORMAL
- en: The model class is now ready to use. Next, we will perform CRUD operations for
    LDAP users with Spring Data.
  prefs: []
  type: TYPE_NORMAL
- en: The Spring Data repository for LDAP
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As you have seen, Spring Data provides an abstract (interface) layer while working
    with the persistence layer, in order to support various data stores, including
    relational databases, non-relational databases, map-reduce frameworks, cloud services,
    and so on. The abstraction starts with the `CrudRepository` interface, which provides
    basic CRUD operations, irrespective of the underlying data stores. This interface
    covers all basic CRUD operations.
  prefs: []
  type: TYPE_NORMAL
- en: Spring Data defines various interfaces, which are specific to each data provider
    on top of the `CrudRepository`. For LDAP support, Spring Data supplies the `LdapRepository`
    interface, which basically extends the `CrudRepository` interface, the one that
    we will extend for our custom repository. This interface has all of the required
    methods to perform CRUD operations. This way, by extending the specific repository
    interface, all basic CRUD operations for standard data access will be readily
    available.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s add Spring Data capability to LDAP in our application. The custom repository
    interface will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The `@Repository` annotation is used to describe that this is the repository
    interface. The custom interface `LdapAuthRepository` extends the `LdapRepository`
    with the model entity `LdapAuthUser`, which we created in the previous section.
    Upon declaring this interface, Spring Data provides the CRUD implementation that
    we can use in the service class, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'In this service class, the object of the `LdapAuthRepository` class is injected
    with the `@Autowired` annotation. It is used to call the CRUD methods, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**CREATE**: The `existsById()` command is used to check whether a user with
    the same ID already exists. The ID is of the type `javax.naming.Name`. The `LdapNameBuilder`
    class is used to build the ID. If a user does not exist, the `save` method is
    called on the `ldapAuthRepository` object, in order to create a fresh object.
    We can call this service method to add the record from the Spring MVC controller.
    We need to create the object of `LdapAuthUser`, set the data, and call the service
    method from the controller method, as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: To create a new user, the object of the model class (`LdapAuthUser`) needs to
    be created first, along with its attribute.
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
- en: Since we are creating a new user, it is required to set `isNew` to `true`, to
    make sure that the Spring Data module considers it a new record. Without doing
    this, the system will throw an error.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: We also need to set the value of `id`. The `LdapNameBuilder` is used to create
    the object of the type `javax.naming.Name` (`id`). It is also required to add
    values like `uid=kpatel` (`username`) and `ou=users` in `id`.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**READ**:To read the LDAP user with `username`, the `findOne()` method is used.
    We need to pass the LDAP query inside of this method. The `LdapQueryBuilder` class
    is used to create the LDAP query, which matches the `username` against the `uid`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**UPDATE**: The update operation is straightforward. The `save` method of `ldapAuthRepository` will
    actually update the LDAP user.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**DELETE**: When deleting a user, first, it is required to check whether the
    user exists. Again, `fineOne` can be used to retrieve the existing user. The `delete`
    operation can only be executed if a user exists.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Additionally, we can use the following methods to perform authentication programmatically,
    in the service class, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The `authenticateLdapUserWithLdapQuery` and `authenticateLdapUserWithContext`
    are the custom methods defined in the `LdapAuthRepositoryCustomImpl` class, where
    we can define the custom method to interact with LDAP. We will discuss this topic
    further in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Upon successful authentication, these methods will return `true`; otherwise,
    they will be `false`. We need to pass the password in a plain text format for
    both of these methods. This is how the Spring Data repository is used to perform
    CRUD operations on LDAP users. Alternatively, we can use `LdapTemplate` to perform
    CRUD operations, as well as other complex business functions.
  prefs: []
  type: TYPE_NORMAL
- en: Performing CRUD operations with LdapTemplate
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Spring Data repository is a convenient way to interact with the underlying
    data provider, as it is easy to use and requires less code, because the implementation
    is provided by the Spring Data module out of the box. However, this simplicity
    comes with certain limitations. For example, with the repository programming model,
    we only have basic CRUD operations available to use. For more complex business
    needs, we need to extend this and provide our own repository implementation. This
    is where the Template model comes into the picture.
  prefs: []
  type: TYPE_NORMAL
- en: The template model in the Spring Data module is less handy than repository abstraction,
    but it is more powerful in terms of furnishing more fine-grained control for complex
    operations that we execute on the data store. We will look at the same CRUD operations
    with the Spring Data template model. Of course, the motive is to learn how to
    prepare the Spring Data template so that it can be used for complex business functions.
  prefs: []
  type: TYPE_NORMAL
- en: Initializing LdapTemplate
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Spring Data provides templates for each of the underlying data providers, like
    `JdbcTemplate`, `JpaTemplate`, `MongoTemplate`, `ElasticSearchTemplate`, `CassandraTemplate`,
    and so on. The `LdapTemplate` is the one that is used to communicate with the
    LDAP server. We will first initialize `LdapTemplate`. Add the following methods
    to the `LdapDataConfig` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The `getLdapContextSrc()` method first creates an object of `LdapContextSource`
    and initializes it with the LDAP connection parameters that were read from `application.properties`.
    The `@Bean` annotation will export this object as a Spring bean. The second method, `getLdapTemplate()`,
    uses the object of `LdapContextSoruce` and initializes the object of the `LdapTemplate`
    class; then, it is exposed as a Spring bean with `id=ldapTemplate`, with the `@Bean`
    annotation.
  prefs: []
  type: TYPE_NORMAL
- en: Using LdapTemplate to perform CRUD operations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now, we have initialized the `LdapTemplate` object. Next, we will use it to
    perform various CRUD operations. We will use `LdapTemplate` in the Spring Data
    repository structure. For this, we need to extend the Spring Data repository model
    and provide a custom implementation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create an interface: `LdapAuthRepositoryCustom`. This is a place where we can
    define customized methods that are not directly available with the repository
    abstraction. Update the definition of the `LdapAuthRepository` interface, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'This is a glue point of the custom implementation with the Spring Data repository
    framework. Finally, define the `LdapAuthRepositoryCustomImpl` class that implements
    the `LdapAuthRepositoryCustom` interface. This is the class where the implementation
    of custom methods are defined, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The `LdapAuthRepositoryCustomImpl` implements the `LdapAuthRepositoryCustom`
    interface, which is used to declare custom repository methods. This class has
    an instance variable of the type `LdapTemplate`, which is injected with the `@Autowired`
    annotation (created in the `LdapDataConfig` class). Next, we will look at some
    of the methods defined in this class, as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '**CREATE operation:** The following code block describes how the CREATE operation
    is used to add a new LDAP user, with `ldapTemplate`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The first method is straightforward. It uses `ldapTemplate` to create an LDAP
    user with the model object. We have set `isNew` to `true`, to make sure that there
    will not be any issues while creating the LDAP user. The second method, `createByBindOperation`,
    uses a low-level API to create the LDAP user. The object of `DirContextAdapter`
    is first initialized with various model attributes, like `objectClass`, `cn`,
    `sn`, `uid`, `userPassword`, and `dn`. The `LdapNameBuilder` class is used to
    create the DN of the LDAP user. Finally, the `bind` method of `ldapTemplate` is
    used to create the user. We can use either of these methods to create a user.
  prefs: []
  type: TYPE_NORMAL
- en: '**READ operation: **The following code block depicts how the READ operation
    is used to fetch the LDAP user, with `ldapTemplate`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: These are a few methods that read the user from the LDAP server. The `LdapQueryBuilder`
    is used to construct a query that can be used to perform a search of various attributes,
    such as `uid`, and `surname`. It can also be used to find users with matching
    attributes, with the `like` query.
  prefs: []
  type: TYPE_NORMAL
- en: '**UPDATE operation:**The following code block shows how the UPDATE operation
    updates the LDAP user, with `ldapTemplate`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The `update` method is straightforward. The `update()` method is used to update
    the LDAP user with the model object.
  prefs: []
  type: TYPE_NORMAL
- en: '**DELETE operation:** The following code block describes how the DELETE operation
    is used to delete the LDAP user, with `ldapTemplate`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The first method is straightforward. It simply calls the `delete` method on
    the `ldapTemplate` object to delete the LDAP user. The second method first creates
    the user DN, and then calls the `unbind` method on `ldapTemplate`, to delete the
    user.
  prefs: []
  type: TYPE_NORMAL
- en: The `delete` method on `ldapTemplate` simply calls the `unbind` method with
    a null check on the given entity. So, both of the methods, `delete()` and `unbind()`,
    are ultimately doing the same thing.
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition to the basic CRUD operations, we can perform some other operations
    with `ldapTemplate`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The first method calls the `authenticate` method on the `ldapTemplate` by passing
    the `LdapQuery` and `password`. The `LdapQueryBuilder` is used to create the LDAP
    query for the given username. The second method calls `getContextSource().getContet()`
    on the `ldapTemplate` object by passing the user DN and password. The context
    is required to be closed at the end. The user DN is obtained for a given `userName`
    with the `getDnForUser()` method, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The `search` method of `ldapTemplate` is called by passing `LdapQuery` and an
    implementation of `ContextMapper`, and finally, it returns a user DN (for example, `uid=npatel`,
    `ou=users`, `o=packtPublisher`) for the given username.
  prefs: []
  type: TYPE_NORMAL
- en: LDAP authorization with Spring Security
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You saw LDAP authentication with Spring Security in the previous section. Next,
    we will look at how to perform authorization. Let's recall that **authorization**
    is a verification process of whether an entity should have access to something.
    In short, authorization concerns the rules that will identify who is allowed to
    do what. After successful authentication, a user can perform various actions,
    based on the authority they have.
  prefs: []
  type: TYPE_NORMAL
- en: Let's recall that authentication deals with login credentials to verify valid
    users. Authorization is more of a check of whether a user has the authority to
    perform various actions, like adding, updating, viewing, or deleting a resource. An
    authorization happens after the user has been successfully authenticated. In this
    section, we will look at how to authorize an LDAP user.
  prefs: []
  type: TYPE_NORMAL
- en: So far, you have seen that the user's details are maintained at the LDAP server,
    which is used by Spring Security to perform authentication. Similarly, we will
    set up authorization details in the LDAP server and fetch them in Spring Security
    to achieve authorization.
  prefs: []
  type: TYPE_NORMAL
- en: Creating roles in the LDAP server
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As you saw in the previous section, we have created the `users` entity (`ou=users`)
    under the root entity (`o=packtPublisher`), and have kept all users under that
    entity in the LDAP server. Similarly, to store authorization information, we will
    create a new entity directly under the root entity in Apache DS, with the following
    steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Right-click on the partition `o=packtPublisher` and select New | New Entryfrom
    the LDAP Browser window.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Choose the option Create entry from scratch and click on the Next button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We are going to add an entity type organization unit, so choose the organizationalUnit
    object class and click on the Nextbutton.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We will use `ou` (organizational unit) as the RDN and roles as its value. The
    DN is automatically calculated when we give the value of the RDN. You can use
    more than one attribute (or the same attribute multiple times, with different
    values) for the RDN. The DN will then be calculated by appending each of them
    with a comma.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the Next button, followed by the Finish button, and the entry `ou=roles` will
    be added under `o=packtPublisher`. The updated structure will be visible in the LDAP
    Browser window.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Next, we will add the actual role entries under the `ou=roles` entry. The steps
    are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Right-click on the roles entity (`ou=roles`) and select* New | New Entry*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Choose the option Create entry from scratch and click on Next*.*
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To add a role, choose `groupOfNames` as the object class that represents a role.
    Click on the Next button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We are going to add a role, so we will use the attribute `cn` (common name)
    as the RDN. Just give the value as `ADMIN`. At this moment, the DN is calculated
    as `cn=ADMIN`, `ou=roles`, `o=packtPublisher`. Click on the Next button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Since this entity has `groupOfNames` as the object class, the system will ask
    for the member assignment in the next window.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the Browse button and choose the user that you want to assign this
    role, under the `o=packtPublisher` entry. Click on the OK button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The following are the steps for assigning multiple members in the given role:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select any of the role entries from the LDAP Browser window. Right-click in
    the middle section (where the details of the selected role are visible a tabular
    format) and choose New Attribute.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Give the value of Attribute type as `member`, click on Next*,* and click on
    the Finish button; you will see the same window for selecting the user to assign
    to this role.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Execute these steps and create the following two roles under the roles entry:'
  prefs: []
  type: TYPE_NORMAL
- en: '`ADMIN`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`USER`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The role structure has been created in Apache DS. We will now import these details
    to perform authorization.
  prefs: []
  type: TYPE_NORMAL
- en: Importing role information to perform authorization
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the *Example DIT structures* section of this chapter, we created a role entity
    (`ou=roles`) under the root entity (`o=packtPublisher`). The role entity contains
    various roles as its child entities. We will look at how to use these roles to
    perform authorization with Spring Security. We have already configured Spring
    Security to perform authentication with LDAP. We will now add two sample pages,
    and configure it so that one page is only accessible by a user with the `ADMIN`
    role, and the other is accessible by a user with either the `USER` or `ADMIN`
    role.
  prefs: []
  type: TYPE_NORMAL
- en: 'To achieve this, the changes need to be done in the `configure` method of the `WebSecurityConfig`
    class that we created for Spring Security configuration. The updated method should
    look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: We have added an admin page (with the URL `/adminPage/`) and a user page (with
    the URL `/usePage/`), and have configured them so that they can be accessed by
    a user with the `ADMIN` and `USER` role, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, we need to create respective Thymeleaf templates under the `src/main/resources/templates`
    folder and entries for both of these pages in the Spring MVC controller class,
    and update the menu structure (defined in the header template) to accommodate
    these pages. The full details are mentioned in the source code, which is available
    in GitHub ([https://github.com/PacktPublishing/Spring-5.0-Projects](https://github.com/PacktPublishing/Spring-5.0-Projects)).
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we will update the `configure` method that represents the LDAP configuration
    with Spring Security. This method takes an object of the type `AuthenticationManagerBuilder`.
    After making the required changes, this method will look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The following are the changes that we made for authorization:'
  prefs: []
  type: TYPE_NORMAL
- en: Added the `groupSearchBase` method call and passed the value as `ou=roles`,
    which represents the base for group search. The group search base value (`ou=roles`)
    is stored in an `ldapAuthStructure` object that we created to hold LDAP connection
    properties.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Added a `groupSearchFilter` method call and passed the value as `member={0}`.
    It is used to define the pattern to search the members. The `{0}` will be substituted
    by the actual user DN at runtime.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The additional method `rolePrefix("")` is placed to set the role prefix. In
    absence of this method call, the role name will be prepended with `ROLE_` by Spring
    Security. As an example, for the role `ADMIN` defined in the LDAP server, the
    actual role return by Spring Security would be `ROLE_ADMIN`. To avoid this, we
    call this method and simply pass an empty string, so that we get the exact role
    name that we defined in the LDAP server.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The configuration part of the authorization is over. You can create some sample
    users in Apache DS, assign them roles, and check whether they are able to access
    the pages that we have created. A user that does not have any role cannot access
    any of the pages (admin or user).
  prefs: []
  type: TYPE_NORMAL
- en: This was all about the integration of LDAP using Spring Security. In the next
    section, we will look at OAuth integration.
  prefs: []
  type: TYPE_NORMAL
- en: OAuth
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A typical web application requires credentials, in the form of a username/password,
    to perform authentication. The HTML form is used to ask for credentials in the
    browser, and then send them to the server. The server then authenticates the information,
    creates and maintains a session at the server side, and sends the session ID back
    to the browser.
  prefs: []
  type: TYPE_NORMAL
- en: The session ID will be sent in each request, and the server will map the session
    with the session ID and pull certain information from the database to perform
    authorization. The browser generally stores the session ID in cookies. As long
    as the session is active, a user can access the restricted resources, based on
    the authorities assigned.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is a quite simple and easy mechanism for client-server interaction, and
    hence, it is still used by many web applications and services today. However,
    there are certain limitations to this model, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Generally, the cookies are stateful, so the server needs to keep track of the
    session and check with the database (or in the memory) for every request. This
    may lead to overhead on the server. Additionally, the authorization process is
    closely associated with the application server, which results in a tightly coupled
    system.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For REST clients, like a native mobile app, cookies may not work properly.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the application functionality is spread across multiple domains, additional
    configuration may be required to maintain the cookie value.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The cookie-based model has the limitation of granting third-party client access.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**OAuth** overcomes these restrictions. By definition, it is an authorization
    framework (or protocol, more precisely), allowing for the application to access
    resources within the same or different applications. In other words, OAuth 2.0
    allows limited access to protected resources to a third-party application, on
    behalf of a resource owner. It supports authorization flows for mobile, web, and
    desktop applications. The current version of this protocol is OAuth 2.0\. We will
    integrate OAuth 2.0 with Spring Security.'
  prefs: []
  type: TYPE_NORMAL
- en: Even though OAuth has certain characteristics that are not available with a
    normal client-server mechanism with the session, the former cannot replace the
    latter. For example, a banking application must be implemented with a client-server
    mechanism. The comparison given here is to showcase how OAuth can be used to provide
    access to third-party applications.
  prefs: []
  type: TYPE_NORMAL
- en: OAuth roles
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before moving further, it is important that you understand certain terminologies
    used in OAuth. This will provide a profound understanding of its underlying concepts.
    They are referred to as OAuth roles, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Resource owner:** A person or entity that can grant access to protected resources.
    The OAuth protocol is not limited to a person. An application to application interaction
    can happen with OAuth. If the resource owner is a person (or user), it is called
    an end user.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Authorization server: **As its name suggests, it is an entity that provides
    authorization, in the form of a token. After the resource owner is authenticated
    successfully, the authorization server will issue an access token to a client.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Resource server: **This is the server that holds the protected resources.
    When a request for a protected resource comes to the resource server, it will
    verify the access token with the authorization server and respond accordingly.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Client: **An entity that initiates the request to access the protected resource
    in support of a resource owner is called a **client**. It can be in any form,
    like a mobile application asking for credentials or a web-based application that
    provides an alternate login functionality with social media (like Facebook or
    Google).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The relationships between these roles is illustrated in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4449129b-3238-4c98-a1ce-eea5fec9ee78.png)'
  prefs: []
  type: TYPE_IMG
- en: The end user, who is the Resource owner, interacts with an application, which
    acts as a Client here. The Client will talk to the Authorization server. The Resource
    owner provides credentials, and it will be authenticated at the Authorization
    server first. Upon successful identification, the Authorization server issues
    an access token, which is used by the Client to access the secure resources on
    the Resource server, in support of the Resource owner. The Authorization server is
    also known as an **identity provider**.
  prefs: []
  type: TYPE_NORMAL
- en: Let's look at the process of authorization in OAuth with a real-life scenario.
    Suppose that John has a car with a smart key. Nowadays, a vehicle with a smart
    key is common, wherein the vehicle cannot be operated (not even unlocked or started)
    without a smart key in your pocket. John has asked his friend Charles to pick
    him up from the airport. He already has already given him a smart key. Charles
    uses the smart key and starts the car.
  prefs: []
  type: TYPE_NORMAL
- en: In this analogy, the smart key gives Charles the authorization to operate John's
    car, as authorization involves the resources a user has access to, and what it
    can do with those resources. John, in this case, is the end user (Resource owner),
    whereas Charles is a Client. The smart key is an access token, whereas the car's
    security system can be considered an Authorization server (or identity provider)
    who authorizes Charles (Client) with a smart key (access token). The whole car
    is the Resource server (Charles can use other features of the car, like the AC,
    music system, and so on, as he is authorized to use the car with the access token
    (smart key)).
  prefs: []
  type: TYPE_NORMAL
- en: Grant types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The crux of the OAuth protocol is to provide access tokens for authorization.
    The way of retrieving the access token is called a **grant**. There are various
    ways (grants) to access and use the access token. OAuth 2.0 provides different
    grants for different scenarios, like the level of trust for the application, the
    type of the application, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'OAuth 2.0 supports the following types of grants. Selecting the one that best
    fits an application depends on the type of that application:'
  prefs: []
  type: TYPE_NORMAL
- en: Authorization code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implicit
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Resource Owner Password Credentials
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Client Credentials
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s look at each of these grant types in detail: how they work, and into
    which situations they fit best.'
  prefs: []
  type: TYPE_NORMAL
- en: Authorization code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Being the most commonly and widely used, the authorization code grant is the
    best fit for server-side applications. The **Client** would be a web application.
    To make sure that the **Client** interacts with the **Authorization Server** properly,
    it is required to configure certain connection parameters, like the *Client ID* and
    *Client Secret, *with the **Client**. Since the **Client** is a web application,
    these parameters can be maintained secretly.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this grant type, a **Client** must be able to collaborate with a **User
    Agent (Browser)**, because the authorization code is routed through the browser.
    The process of obtaining an access token for an authorization code grant can be
    described with the following diagram. Since the **Resource Owner** is authenticated
    at the **Authorization Server**, its credentials will not be shared with the **Client**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ee105b78-23eb-48c0-a39d-4b34868c9461.png)'
  prefs: []
  type: TYPE_IMG
- en: 'In this grant type, the access token is obtained through the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: The **Client** is configured to establish a connection to the authorization
    server. It will open the link in the **User Agent (Browser)**. This link contains
    other information, which will be used by the authorization server to identify
    and respond back to the **Client**. Generally, the link opens in a separate window,
    and it contains a login form to authenticate a user as the first step towards
    authorization.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A user (**Resource Owner**) then enters the credentials, in the form of a username
    and password.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The browser (**User Agent**) then sends these credentials to the **Authorization
    Server**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The **Authorization Server** verifies the credentials and sends the response
    back to the **Client** with the authorization code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Upon receiving the authorization code, the **Client** will exchange it with
    the **Authorization Server** to get an access token, and optionally, a refresh
    token.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After getting an access token, the **Client** can talk to the **Resource Server**
    to get protected resources.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The authorization code flow can be used with web and mobile app clients. Generally,
    web app clients use *Client ID* and *Client Secret,* while mobile app clients
    use the **Proof Key for Code Exchange (PKCE)** mechanism and utilize code challenges
    and code verifiers.
  prefs: []
  type: TYPE_NORMAL
- en: Implicit
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The implicit grant type was designed specifically for single-page JavaScript
    applications running in the browser. It is most similar to the authorization code
    flow. The only difference is in the process of exchanging the authorization code.
    In the implicit grant type, a client will not receive an authorization code from
    the **Authorization Server**, in contrast with the authorization code grant type,
    due to security reasons.
  prefs: []
  type: TYPE_NORMAL
- en: Alternatively, once a **User Agent** successfully sends the credentials, the
    **Authorization Server** issues an access token directly to the **Client**. Since
    the implicit flow is targeted at single-page JavaScript applications, the refresh
    token is also not allowed. The whole process is described in the following diagram.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since the **Authorization Server** directly issues an access token, the round-trip
    of the request-response between the **Client** and **Authorization Server** is
    reduced, as compare to the authorization code flow:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9910f850-7806-4a80-9137-05a4462f6891.png)'
  prefs: []
  type: TYPE_IMG
- en: 'This process happens in the following sequence:'
  prefs: []
  type: TYPE_NORMAL
- en: The Client will open the link in a separate window in the User Agent (browser),
    which contains a login form to authenticate a user as a first step towards authorization.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A user (Resource Owner) then enters the credentials, in the form of a username
    and password.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The browser (User Agent) then sends these credentials to the Authorization Server.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The Authorization Server verifies the credentials and sends the access token
    directly to the Client.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After getting the access token, the Client can talk to the Resource Server to
    get protected resources.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Resource Owner Password Credentials
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The Resource Owner Password Credentials grant type should be used for a highly
    trusted client, because it handles the user credentials directly. In other words,
    this grant type should only be used when there is plenty of certainty and faith
    between the **Resource owner** and the **Client**. Mostly, the client will be
    a first-party application. The credentials will be used by the **Client** directly,
    to interact with the **Authorization Server** and get an access token. The flow
    can be described with the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/54da154e-3463-4a25-94b1-ca3c42307b4c.png)'
  prefs: []
  type: TYPE_IMG
- en: 'This flow can be described as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The **Client** is highly trusted, so it will directly ask the **Resource Owner**
    to provide credentials. The **Client** could be a highly indulged application.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The credentials will be sent by the **Client** to the **Authorization Server**.
    The **Client** will also send its own identity to the **Authorization Server**.
    In response, the **Authorization Server** will send back the access token, and
    optionally, a refresh token.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The access token is used by the client to access the protected resources of
    the **Resource Server**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Client Credentials
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The Client Credentials grant type is similar to the Resource Owner Password
    Credentials flow. In the Client Credentials grant, the **Client** interacts with
    the **Authorization Server**, provides the identification by sending the Client
    ID and Client Secrets, and gets the access token. Once the access token is received,
    the **Client** will interact with the **Resource Server**. In this case, a refresh
    token should not be used. The process flow is illustrated by the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c04d5470-6da0-402c-b287-ad9c20a87106.png)'
  prefs: []
  type: TYPE_IMG
- en: The Client ID and Client Secrets are configured with the **Client**. The **Client**
    will interact with the **Authorization Server** to get an access token.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After getting the access token, the **Client** can interact with the **Resource
    Server** to access protected resources.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Which grant type should be used?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Having seen the details about each grant type, it is important to understand
    the right grant type for a given application. There are various factors that play
    a vital role in grant type selection, like end user identification, the type of
    client (server-side, web-based, native, client-side), and the level of assurance
    between the client and resource owner.
  prefs: []
  type: TYPE_NORMAL
- en: If we are planning to build an app and allow for the access of resources to
    other third-party apps, then the authorization code flow is the right choice.
    It is a highly recommended grant type for a publicly hosted application. On the
    other hand, if a client is JavaScript-based and runs in a browser, we should go
    with the implicit grant type for a third-party client, and the resource owner
    password credentials grant for a first-party client.
  prefs: []
  type: TYPE_NORMAL
- en: If a client is a native (mobile) application, we can select the resource owner
    password credentials grant type. If the resource owner does not need the identity
    of the end user and the client itself behaves like a resource owner, we should
    use the client credentials grant type. Typically, a client credentialsgrant is
    used where the machine (and not a user) needs the authorization to access protected
    resources, and user permission is not required.
  prefs: []
  type: TYPE_NORMAL
- en: Spring Security integration with OAuth
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Having seen the basic fundamentals of what OAuth 2.0 is and how it works, we
    will now look at the integration of OAuth in Spring Security. We will continue
    to work with the same application that we created for LDAP, and will make the
    necessary changes for OAuth integration.
  prefs: []
  type: TYPE_NORMAL
- en: For the OAuth demonstration, we will use readily available authorization providers.
    Spring Security supports Google, Facebook, Okta, and GitHub providers out of the
    box. Choosing one of them would only require certain configurations, and things
    would start to work. We will select Google as an authorization server (provider)
    to build OAuth for our application. The grant type that we will use in this integration
    is authorization code.
  prefs: []
  type: TYPE_NORMAL
- en: Every authorization provider supports some sort of mechanism that enables the
    clients to establish a connection with the service. This process is known as **application
    registration**.
  prefs: []
  type: TYPE_NORMAL
- en: Application registration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s register (or create) an application at Google, which provides connection
    access to use the authorization service. This is an essential step before start
    to implement OAuth. Google provides an **API console** to register an application.
    A valid Google account is required to access the API console. Go to [https://console.developers.google.com/apis/credentials ](https://console.developers.google.com/apis/credentials)and
    follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Click on the Create credentials button in the Credentials tab, and click on
    the OAuth client ID option. Select the application type as Web Application.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Give an appropriate name (like `SpringOAuthDemo`).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We need to set the authorized redirect URI in the Google console, which represents
    a path upon which users are redirected after they are successfully authorized
    by Google. The default implementation, provided by Spring Security for Google,
    has configured the redirect URI as `/login/oauth2/code/google`. Apparently, the
    valid redirect URI, in our case, would be [http://localhost:8080/springuath/login/oauth2/code/google](http://localhost:8080/springuath/login/oauth2/code/google) (considering
    `8080` as the port and `springauth`as the context name). Give this URI in Authorized
    redirectURIs in the Google console, and click on the Create button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Upon successful registration of the application, Google will create client
    credentials in the form of the client ID and client secret, as shown in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6f5dc88c-7ffc-433d-b918-008d54e3e628.png)'
  prefs: []
  type: TYPE_IMG
- en: The client ID is a kind of public key used by the Google service API to identify
    the application that we have registered. It is also used to construct authorization
    URLs of the Google login form. The client secret, as its name suggests, is a kind
    of private key. When the application (that we registered) requests the details
    of a user account, at the moment the user credentials are sent, the client secret
    will be used to validate the identity of the application. Because of this, the
    client secret must be kept private between the application and the client.
  prefs: []
  type: TYPE_NORMAL
- en: Changes in the Spring Boot application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: After completing the preceding requirements, we will start to make the necessary
    changes in the Spring Boot application that we created for LDAP authentication.
    The aim is to build a central authentication and authorization server that will
    work with both technologies (LDAP and OAuth).
  prefs: []
  type: TYPE_NORMAL
- en: 'When the user enters a plain username and password, the authentication and
    authorization will be done with LDAP. We will configure our application with Google,
    for OAuth. The very first step for OAuth integration is to declare the relevant
    starters. Spring Boot provides support for OAuth in the form of starters. Add
    the following starter entries in a `pom.xml` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Upon defining this starter, Spring Boot will add the following dependencies,
    which are essentials for OAuth integration, automatically:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we will add properties for the client ID and client secret, along with
    the provider and client name, in the `application.propeties` file. These properties
    are prefixed with `spring.security.oauth.client.registration`, along with the
    provider name and property name. Set these properties with the `Client ID` and
    `Client Secret` that we created in the Google developer console in the previous
    section, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: The default OAuth configuration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Spring Security allows for configuring multiple OAuth clients. In addition
    to Google, Spring Security also supports default configurations for Facebook,
    GitHub, and Okta, out of the box. That means that all required classes and configurations
    are readily available, and we just need to define the client credentials (`Client
    ID` and `Client Secret`). Next, we will update the `configure(HttpSecurity http)`
    method of the `WebSecurityConfig` class, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: The oauth2Login() method will initiate an OAuth call. At this moment, while
    executing the application, the preceding method will make an OAuth call to Google.
    A user will be asked for a valid Google login credential. Upon successful authentication,
    it will show the home page.
  prefs: []
  type: TYPE_NORMAL
- en: If we set the properties for at least one client, Spring Security will automatically
    enable the `Oauth2ClientAutoConfiguration` class, which will make all of the necessary
    arrangements to enable OAuth login, without even defining the preceding `WebSecurityConfig`
    class.
  prefs: []
  type: TYPE_NORMAL
- en: If more than one client is configured in the `application.properties` file,
    the system will show a list of those clients, with a default login (username and
    password) form. It will be the autogenerated login page. We can perform a login
    with any of those configured clients.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is quite obvious to show the name of the user at the top, to indicate which
    user is currently logged in. We can get the name of the user that has been authenticated
    at Google with the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: This method is defined with `ModelAttribute`, meaning it can be directly used
    in the presentation layer with the `${currentUserName}` expression. We are getting
    an instance of `Authentication`, and checking if it is of the type `OAuth2AuthenticationToken`.
    The `getPrincipal()` method will return the user details, along with the attributes.
    The `name` attribute returns the name of the user that logged in with Google.
  prefs: []
  type: TYPE_NORMAL
- en: The other part will be executed when we perform authentication with LDAP, which
    gets the `userName` from the `Authentication` object, and then calls the custom
    service method (`ldapAuthService.getUser()`) to fetch the LDAP user object. It
    is then used to get the name of the user (the first name and surname).
  prefs: []
  type: TYPE_NORMAL
- en: OAuth with a custom login page
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This is how OAuth can be integrated with Spring Security. In the preceding
    configuration, Spring Boot provides an autogenerated login page, which may suffice
    for testing purposes. In real scenarios, we may need a customized login page.
    To build a custom login page, we need to make certain configuration changes in
    the `configure(HttpSecurity http)` method, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: This looks similar to what we configured for LDAP. The only change is that we
    are using `oauth2Login()` instead of `formLogin()`. The call for `super.configure(http)`has
    been removed at the end, as it is no longer required. If we place it there, Spring
    Boot will show an autogenerated login page, so make sure to remove it at the end.
  prefs: []
  type: TYPE_NORMAL
- en: 'This change will show the custom login page, but the list of OAuth providers
    will not be visible automatically. We need to prepare the list manually, and show
    them in the login page. To achieve this, we will need to update the controller
    method, `showLoginPage()`, as follows. This method basically shows the login page:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: This is the login method that we already created at the beginning of the chapter,
    in order to show the login form. The changes are made specifically for OAuth.
    First, the instance of `ClientRegistrationRepository` is injected, which represents
    the repository and stores the OAuth client's primary details. It is an interface
    type, and Spring Boot provides the instance of the `InMemoryClientRegistrationRepository` class
    as a default implementation. The `InMemoryClientRegistrationRepository` maintains
    a map for `ClientRegistration`, a class that represents the OAuth providers.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the preceding code, we are getting the map of `ClientRegistration` from
    `clientRegistrationRepository`, iterating it, and preparing the list of OAuth
    providers with a name and authorization URL that is prefixed with `oauth2/authorization`.
    We set it as a model attribute, so that it will be available to the presentation
    layer. After applying these changes, the login page will look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8b464a88-ab49-4f0f-9a25-08e2fa631a07.png)'
  prefs: []
  type: TYPE_IMG
- en: Dual authentication with OAuth and LDAP
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The application will now show a custom login page, along with the list of OAuth
    clients that we configured. Still, when we enter the credentials manually in the
    login form, nothing will happen, because the Spring Security is configured for
    OAuth. The user, when entering credentials in a login form, should be authenticated
    with LDAP. To achieve this, we need to perform certain configurations specifically
    within LDAP.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, the goal is to perform manual authentication with LDAP. Spring Security
    provides a way to define a custom authentication provider, by implementing the `AuthenticationProvider`
    interface. First, we will write a class that implements this interface and performs
    LDAP authentication, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'The class `CustomLdapAuthProvider` is defined with the `@Component` annotation,
    meaning that Spring will configure it as a bean, so that it can be available to
    other components with the `@Autowired` annotation. The `AuthenticationProvider`
    interface declares the following two methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Authentication authenticate(Authentication authentication)`: This is the place
    where we can provide custom authentication.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`boolean supports(Class<?> authentication)`: This method indicates whether
    this custom authentication provider supports the indicated authenticated object.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the `authenticate` method, we are first getting the `username` and `password`
    from an instance of `Authentication`. Then, we are doing manual authentication
    by calling the custom service method `authenticateLdapUserWithContext`, which
    we already created for LDAP authentication. If this method returns `true`, it
    means that the credentials are valid.
  prefs: []
  type: TYPE_NORMAL
- en: 'Along with verifying the credentials, we also need to fetch the authorities
    (roles) that a user has. To get them, we have defined a method in the custom repository
    `impl` class (`LdapAuthRepositoryCustomImpl`), as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: The `getUserAuthorities` method takes the `userName` and returns the list of
    authorities. Let's recall that for roles, we have created a separate entity (`ou=roles`)
    in Apache DS. All of its children represent actual roles (with the attribute `cn`
    as the role name). Any LDAP user that is a member of a particular authority (role)
    is added with the `member` attribute. The aim is to fetch all the authorities
    of which the current user is a member.
  prefs: []
  type: TYPE_NORMAL
- en: The search method on `ldapTemplate` takes `LdapQuery` and the `ContextMapper`
    object and returns the list of authorities. The `LdapQuery` is built with a group
    filter of `objectclass` and value of member attribute. The value of `objectclass`
    is the same as the name of the `objectclass` that we gave to the entity (`ou=roles`)
    in LDAP. The value of the member attribute will be a valid user DN; for example,
    `uid=npatel`, `ou=users`, `o=packtPublisher`. The `ContextMapper` is a mechanism
    to retrieve only the required values from the `search` method. More specifically,
    `ContextMapper` can be used to retrieve custom results (wrap the selected value
    in custom POJO).
  prefs: []
  type: TYPE_NORMAL
- en: 'This can be done by providing the implementation for a `ContextMapper` interface.
    We have created a class for this implementation, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'The `ContextMapper` interface is a raw type, so we have defined the type as `LdapGranntedAuthority`,
    which is nothing but a custom POJO. In the `mapFromContext` method, the object
    of `DirContextAdapter` is used to fetch the name of the role with the attribute
    `cn`. This role name is then set in the instance of `LdapGranntedAuthority`, and
    finally, returns it. The `LdapGranntedAuthority` class looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: This POJO implements the `GrantedAuthority` interface to set the name of the
    authority (role). Now, let's go back to the authenticate method of the `CustomLdapAuthProvider`
    class. After getting the authorities, we are creating the object of the `UsernamePasswordAuthenticationToken`
    class with the username, password, and list of authorities. The `UsernamePasswordAuthenticationToken`
    class basically provides an implementation of the `Authentication` interface.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, with the help of this custom authentication provider, we will do manual
    authentication. Before that, we have to change the action of the login form, since
    the default (`/login`) will no longer work automatically. Change the path from
    `/login` to `/ldapLogin` in the login form. We also need to create a corresponding
    controller method to handle the login flow manually, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: The instance of `CustomLdapAuthProvider` is injected with the `@Autowired` annotation.
    This method is defined with the `@PostMapping` annotation, to handle the login
    form with the POST method. We are creating the instance of `UsernamePasswordAuthenticationToken`
    with the username and password that were submitted with the login form, and we
    pass it to the `authenticate` method of `CustomLdapAuthProvider`, which basically
    does authentication with LDAP and fetches the user authorities. Once the authentication
    is done, we will store the authentication object in the Spring Security context.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we have saved the security context in an HTTP session, so that Spring
    Security will create and maintain the user authentication information in the session.
    After performing all of these processes, we are checking whether the authentication
    is successful by calling the `isAuthenticated` method on the authentication object.
    Based on the authentication status (success or failure), we are redirecting the
    flow to either a private page (upon successful authentication) or a login page
    (upon failed authentication). This was all about using dual authentication with
    LDAP and OAuth. Next, we will illustrate OAuth implementation on a custom authorization
    server.
  prefs: []
  type: TYPE_NORMAL
- en: OAuth authorization with a custom authorization server
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now, you have seen OAuth integration with Spring using third-party providers
    (Google). In this section, we will build a custom authorization server (provider)
    and do OAuth authorization. We will also build our own resource server, and we'll
    access the resources once the authorization is done.
  prefs: []
  type: TYPE_NORMAL
- en: In the previous section, the authorization code grant type was used with Google.
    We will implement an implicit grant type in this section. Let's recall that the
    implicit grant type was specially designed for JavaScript applications. Since
    it runs in a browser, the authorization server directly sends the access token.
    There is no support for refresh tokens, for security purposes.
  prefs: []
  type: TYPE_NORMAL
- en: We will first develop a custom authorization server (provider) that will provide
    the access token. We can consider it in place of Google in the previous section,
    where we developed a client for authorization. For our custom authorization, we
    will set up a client with credentials (an ID and secret), which will be used to
    provide authorization (in the form of providing an access token).
  prefs: []
  type: TYPE_NORMAL
- en: We will create separate Spring Boot applications for the authorization and resource
    server, and we will need to run them simultaneously, in order to test the functionality.
    To avoid the port clashing (the default is 8080 for both applications), we need
    to explicitly set the port while running them. To do so, you need to give a different
    port with the property `server.port` in the `application.properties` file.
  prefs: []
  type: TYPE_NORMAL
- en: Authorization server configuration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will develop a separate Spring Boot application and apply the necessary
    configurations to use it as an authorization server. This is our custom authorization
    server. Create a Spring Boot application with the name `SpringCustomAuthorization`and
    add the following component, which is basically an essential entry point to building
    a custom authorization server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: With the `@EnableAuthorizationServer` annotation, this class claims to present
    a configuration for the authorization server. In order to understand the concept
    in more detail, we will associate each step for configuring the custom authorization
    server with what we already did in the Google OAuth integration. The very first
    step in this configuration is to define a client, which basically talks to an
    authorization server to get an access token.
  prefs: []
  type: TYPE_NORMAL
- en: The `configure(ClientDetailsServiceConfigurer clients)` method is used to define
    a client with various metadata, like the client ID, grant type, scopes, secret,
    and redirection URI. The `resourceId` is used to make the pair with the resource
    server. We will configure the same `resourceId` while creating a resource server
    later in this chapter. The type of client that we have used here is in-memory,
    which is appropriate for developmental purposes.
  prefs: []
  type: TYPE_NORMAL
- en: Another type is JDBC, wherein the client details can be stored in the database.
    We can configure multiple clients in this method, and each can be separated with
    the `.and()` method call. The client is created within an authorization server.
    We can relate this to the client that we created in the Google developer console.
  prefs: []
  type: TYPE_NORMAL
- en: The `tokenStore()` method is used to construct an access token. Spring provides
    various mechanisms, like `InMemoryTokenStore`, `JdbcTokenStore`, `JwkTokenStore`,
    and `JwtTokenStore`, to create a token. Out of these, we have used `JwtTokenStore`.
    The `accessTokenConverter()` method is used to encode/decode the token with a
    signing key.
  prefs: []
  type: TYPE_NORMAL
- en: We need to use the same signing key while configuring the token store at the
    resource server. The `tokenServices()` method is used to configure the token service
    with the token store, along with a few settings. Since the grant type is implicit,
    the refresh token is not allowed, so we are setting `setSupportRefreshToken()`
    to `false`. We can also set how long the token is valid, through the `setAccessTokenValiditySeconds()`
    method. Since this is an implicit flow and will be used by a JavaScript application,
    the token should be short-lived, for security reasons.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, the `configure(AuthorizationServerEndpointsConfigurer endpoints)` method
    is a glue point to group the things that we have configured so far together. Generally,
    user authentication is performed prior to authorization, and the object of `AuthenticationManager`
    is used to perform the authentication. After defining the authorization configuration,
    let''s make it secure by applying security configurations, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: With the `@EnableWebSecurity` annotation, Spring Security will be applied to
    the authorization server. It is a normal Spring Security configuration that you
    have already seen in previous sections. The `/oauth/authorize` is a default authorization
    endpoint. The resource server will initiate an authorization call on this path,
    so we have configured it in the `configure` method.
  prefs: []
  type: TYPE_NORMAL
- en: We have created an in-memory user with credentials and authority. We can associate
    it with the user account hold in Google, which is being asked when we initiate
    authorization with Google. In our case, we will provide this credential when the
    authorization process is initiated at the custom authorization server.
  prefs: []
  type: TYPE_NORMAL
- en: Our authorization server is now ready. It cannot be accessed directly; instead,
    the resource server initiates the request with certain parameters. Next, we will
    build the resource server.
  prefs: []
  type: TYPE_NORMAL
- en: Resource server configuration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As its name suggests, a **resource server** holds resources (in the form of
    data, services, files, and so on), which can be accessed by the resource owner
    by providing valid authorization. The process of providing authorization happens
    in the form of a **token sharing mechanism**.
  prefs: []
  type: TYPE_NORMAL
- en: The authorization server creates a token after authentication, which is used
    by a resource server to serve the restricted resources. For all incoming requests
    for protected resources, the resource server will check the validity of the access
    token with the authorization server. This is the flow of the system, in brief.
    Now, we will create a resource server with a separate Spring Boot application.
  prefs: []
  type: TYPE_NORMAL
- en: 'Spring allows for creating a resource server by declaring certain essential
    configurations, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: The `@EnableResourceServer` annotation will instruct Spring Security to treat
    the component as the resource server and to authenticate incoming requests with
    an access token. In this configuration, we are using the same `resourceId` that
    we used in the authorization server. Also, the process of creating and converting
    the token, along with the signing key, is the same as what we implemented in the
    authorization server.
  prefs: []
  type: TYPE_NORMAL
- en: For a token of the type `Jwt`, we can also use the public-private key as a signing
    key for generating an access token. In a normal case, the signing key declared at
    the authorization and resource server must be the same.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `configure(HttpSecurity http)` method of this class is a place where we
    can configure the path of protected resources. In our case, we are configuring
    `/api/**`, meaning that any path that starts with `/api/` is considered secure.
    Without a valid token, the user cannot access that path. We also defined the appropriate
    denied handler to show an appropriate message, in the case of invalid tokens or
    insufficient privileges. Next, we will configure Spring Security for the resource
    server, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'This is a straightforward security configuration, where we have declared certain
    paths to be accessible by all. Next, we will create a Spring MVC controller, which
    will show the page from which we can initiate authorization, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'The first two methods show the home page and private page, respectively. We
    will show a link on the home page that will initiate the authorization process.
    This link will call the `authorizeUser()` method (with the link `/customAuth`).
    This method fetches the client metadata that is defined in the `application.properties`
    file, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: In the `authorizeUser()` method, we are redirecting the flow to the authorization
    URI, along with the `client-id`, `client-secret`, `grant-type`, and `response-type`
    parameters. The `oauth/authorize` is a default authorization endpoint.
  prefs: []
  type: TYPE_NORMAL
- en: Let's recall that, while doing a client setup in the authorization server, we
    configured the `redirectUri` as [http://localhost:8082/privatePage](http://localhost:8082/privatePage),
    meaning that after authorization, the flow will go back to this URL, which ultimately
    shows a private page, along with the access token.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once we get the token, we can start to consume the protected resources. We
    have defined the path `/api/**` as protected resources in the resource server
    configuration. So, let''s create a REST controller, as follows, which will provide
    the resources. For demo purpose, we will return some sample data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: The REST controller is configured with path `/api`, meaning that all of its
    methods can be accessible with the valid authorization token. Now, it is time
    to run the application and test the flow. We will first run the resource server
    application ([http://localhost:8082](http://localhost:8082), assuming it is running
    on port `8082`). It will show a link, which will redirect the flow to the authorization
    server.
  prefs: []
  type: TYPE_NORMAL
- en: Soon after the flow reaches the authorization server, it prompts a login page.
    This is because an authorization server required a valid authentication before
    even starting authorization. This makes sense, because the authorization server
    will authorize the given user account, and for this, a user must be logged in.
    We will use the in-memory credentials that we created for the authorization server.
  prefs: []
  type: TYPE_NORMAL
- en: 'Soon after logging in, the authorization server shows an intermediate page
    and asks a user to either allows or denies. Based on that, a user can access the
    restricted resource on the resource server, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/56135b7d-db6e-4b8f-a40d-26515f933566.png)'
  prefs: []
  type: TYPE_IMG
- en: This is similar to when we created a client in the Google developer console
    and did authorization with it. At that time, first, we gave Google the credentials,
    and after authentication, it asked for the approval of access for the client.
    When we authorize the client, it will redirect to the private page of the resource
    server with an access token.
  prefs: []
  type: TYPE_NORMAL
- en: At this moment, the access token is returned with `#` character in the response.
    To access any protected resources, we need to append the access token with `?`,
    so that it will be supplied as a request parameter. Without this, the resource
    server will not allow for accessing any protected resources.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we can access protected resources with the access token. The rest controller
    (with the path `/api`) will serve the resources. For example, the URL [http://localhost:8082/api/usergreeting?access_token=<token_string>](http://localhost:8082/api/usergreeting?access_token=%3Ctoken_string%3E)
    will give the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/39988647-0eeb-4943-8c43-532f04a1dbaa.png)'
  prefs: []
  type: TYPE_IMG
- en: It will show a `token expired` error if the request is made after the token
    validity is over. It will also throw an `invalid token` error if the original
    token is altered. Without supplying the token, it will show an error like, `Full
    authentication is required to access this resource`.
  prefs: []
  type: TYPE_NORMAL
- en: Method-level resource permissions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now, an authorized user can access all of the resources that we have configured.
    How good would it be if the resources could be accessed based on user roles? It
    would provide for more fine-grained control over the resources. This is possible
    by applying method-level configurations in Spring Security. For this, first, we
    need to define a class that represents method-level Spring Security configurations,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: The `@EnableGlobalMethodSecurity` annotation is required to define authorization
    constraints at the method level. The base class, `GlobalMethodSecurityConfiguration`,
    provides a default implementation of method-level security configuration.
  prefs: []
  type: TYPE_NORMAL
- en: We have overridden the `createExpressionHandle` method to supply `OAuth2MethodSecurityExpressionHandler`
    instead of `DefaultMethodSecurityExpressionHandler`, which is provided out of
    the box. Spring Security uses an AOP proxy mechanism to apply method-level security
    configurations.
  prefs: []
  type: TYPE_NORMAL
- en: The `prePostEnabled` and `securedEnabled` options enable respective annotations
    at the method level, to define authorization rules. For example, `prePostEnabled`
    will allow for defining the Spring Security pre/post annotations `@PreAuthorize`
    and `@PostAuthorize`. These annotations allow for expression-based access control,
    meaning that we can use Spring **EL (Expression Language)** to describe the rule.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `@PreAuthorize` will evaluate the expression before entering the method,
    while the `@PostAuthorize` will verify the expression after method execution has
    completed, and could alter the result. The `securedEnabled` option of `@EnableGlobalMethodSecurity`
    is used to define the `@Secured` annotation. With the `@Secuired` annotation,
    we can specify a list of roles on a method. Let''s look at a few examples of this
    annotation, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'The `getUserAccnt` method will be accessible by the user that has a role as
    `ROLE_USER`. The `getCompanyPolicy` method will be invoked by a user who has at
    least one role among `ROLE_USER` and `ROLE_ADMIN`. The `@Secuired` annotation
    does not allow for defining an expression with Spring EL. On the other hand, the `@PreAuthorize`
    and `@PostAuthorize` annotations allow for Spring EL to define the expression,
    meaning that we can define the more complex condition. Let''s look at some examples
    of `@PreAuthorize`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'The first method (`adminResource`) is accessible for the user with a `USER`
    role, and the client should have a `read` scope. Let''s recall that for the client
    that we configured in the authorization server, we set three scopes: read, write,
    and trust. The `#oauth2` variable is provided out of the box, and is used to check
    the various scopes that a client has. We can utilize other methods on the `#oauth2`
    variable, like `clientHasRole()`, `clientHasAnyRole()`, `hasAnyScope()`, `isOAuth()`, `isUser()`, `isClient()`,
    and so on. They are defined in the class `OAuth2SecurityExpressionMethods`. In
    short, the variable `#oauth2` represents the object of this class.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The second method (`userResource`) is a bit more complex, and can be accessed
    under the following conditions:'
  prefs: []
  type: TYPE_NORMAL
- en: A user has a `USER` role and a client has a `read` scope
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A request is not of the OAuth type (it may be raised by a machine client) and
    a user has a `USER` role
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The third method (`listAllSampleUsers`) is similar to the second method, and
    can be accessed in the following situations:'
  prefs: []
  type: TYPE_NORMAL
- en: A user has an `ADMIN` role
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A client has a `trust` scope
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A request is not of the OAuth type (it may be raised by a machine client) and
    a user has an `ADMIN` role
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This is how the implicit grant type can be implemented with the custom authorization
    server. There are certain things that require attention while using the implicit
    grant type. Since it was designed for JavaScript applications, both the authorization
    and resource server should be securely accessible (with HTTPS). The second thing
    is, in an implicit grant type, the access token is directly returned by the authorization
    server to the browser, instead of at a trusted backend; it is highly recommended
    to configure short-lived access tokens, to mitigate the risk of the access token
    being leaked.
  prefs: []
  type: TYPE_NORMAL
- en: Another challenge in the implicit flow is that it does not allow refresh tokens.
    That means that after the short-lived token has expired, a user should be prompt
    to initiate the flow again; or, a better method might be to set a mechanism, like
    `iframe`, to get the new token without interruption.
  prefs: []
  type: TYPE_NORMAL
- en: As an exercise, you could create a few more users with different roles in the
    authorization server, and configure the resource methods with those roles, checking
    how they are accessible.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Security is an essential part of any system. How effective it is depends on
    various aspects, like simplicity, feature richness, ease of integration with other
    systems, flexibility, robustness, and so on. This whole chapter was based on Spring
    Security. It is a fully-fledged framework that's used to secure J2EE-based applications.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we explored Spring Security more closely, especially how it
    can be integrated with LDAP and OAuth. We started with the basics of LDAP, including
    its data structure and setup; we created the structure in Apache DS, which is
    an LDAP server. Then, we explored the required configurations with Spring Security,
    to integrate it with LDAP.
  prefs: []
  type: TYPE_NORMAL
- en: Along with authentication with LDAP, we explored how to manage users in LDAP
    from a Spring application. We used the Spring Data framework to achieve this.
    Next, we created a structure for the role (authority) in LDAP. In the same sequence,
    we fetched the role details and implemented authorization in Spring Security with
    LDAP.
  prefs: []
  type: TYPE_NORMAL
- en: Later in the chapter, we started to cover another mechanism, called OAuth. It
    is an open standard for token-based authorization. We began with the basics of
    OAuth roles, then explored details about various grant types; you also learned
    which grant should be used when. Going further, we started on Spring Security
    integration with OAuth. We used Google to implement the authorization code flow
    with Spring Security.
  prefs: []
  type: TYPE_NORMAL
- en: With the default OAuth implementation, Spring Security shows the autogenerated
    login page. We showed how to implement a custom login page in OAuth. Up to that
    point, you had only seen the two different mechanisms, LDAP and OAuth, independently.
    We integrated both of them together, creating dual authentication.
  prefs: []
  type: TYPE_NORMAL
- en: We then implemented OAuth with the authorization code flow. Next, we showed
    how to implement the implicit flow with custom authorization and the resource
    server. We performed a set of configurations for both the authorization and resource
    server, and we successfully implemented an implicit flow. Towards the end, we
    applied method-level authorization in Spring Security.
  prefs: []
  type: TYPE_NORMAL
- en: In next chapter, we will explore another tool, called JHipster. It is an open
    source application generator framework that's mainly used to develop web applications
    and microservices with responsive web fronts (Angular or React) and the Spring
    framework as a backend.
  prefs: []
  type: TYPE_NORMAL
