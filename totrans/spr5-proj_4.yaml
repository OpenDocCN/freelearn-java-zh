- en: Building a Central Authentication Server
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建中央认证服务器
- en: Implementing security constraints is a core requirement of any application.
    Spring provides support to various aspects of applications, including security.
    One of the modules of the Spring framework, called Spring Security, was specially
    designed to meet security needs. It is a robust and highly adaptive framework,
    providing authentication and authorization out of the box.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 实现安全约束是任何应用程序的核心要求。Spring为应用程序的各个方面提供支持，包括安全。Spring框架的一个模块，称为Spring Security，专门设计来满足安全需求。它是一个强大且高度自适应的框架，提供开箱即用的认证和授权。
- en: Spring Security is the standard for securing any Spring-based application. We
    can see the real strength of Spring Security when integrating it with other systems.
    Its capabilities can be extended with ease, in order to meet custom requirements.
    This chapter will be devoted purely to Spring Security.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Security是任何基于Spring的应用程序的标准安全解决方案。当我们将其与其他系统集成时，我们可以看到Spring Security的真实实力。其功能可以轻松扩展，以满足定制需求。本章将专门介绍Spring
    Security。
- en: 'In the last chapter, we looked at the power of the Spring framework, with various
    modules and third-party libraries binding together in Spring Boot: a module built
    on top of the Spring framework, mainly designed for bootstrapping and developing
    a Spring-based application with auto configuration. We will continue to use it
    in this chapter, in order to build central authentication and authorization system.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们探讨了Spring框架的力量，其中各种模块和第三方库在Spring Boot中绑定在一起：一个建立在Spring框架之上的模块，主要设计用于引导和开发具有自动配置的基于Spring的应用程序。我们将在本章继续使用它，以构建中央认证和授权系统。
- en: Spring Security is a highly customizable framework, and we can integrate it
    with other systems that provide the data for access control. In this chapter,
    we will look closely at **Lightweight Directory Access Protocol** (**LDAP**) and
    **OAuth** integration with Spring Security.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Security是一个高度可定制的框架，我们可以将其与其他提供访问控制数据的系统集成。在本章中，我们将仔细研究**轻量级目录访问协议**（**LDAP**）和**OAuth**与Spring
    Security的集成。
- en: 'We will cover the following interesting topics in this chapter:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下有趣的主题：
- en: A basic understanding of LDAP and data structures
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对LDAP和数据结构的基本理解
- en: Configuration of the LDAP server (Apache DS)
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: LDAP服务器（Apache DS）的配置
- en: Authentication in Spring Security with LDAP
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用LDAP在Spring Security中进行认证
- en: LDAP authorization with Spring Security
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Spring Security进行LDAP授权
- en: OAuth fundamentals and various grant types
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: OAuth基础和不同的授权类型
- en: Spring Security integration with OAuth
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Spring Security与OAuth的集成
- en: Dual authentication with LDAP and OAuth in Spring Security
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Spring Security中使用LDAP和OAuth进行双重认证
- en: OAuth implementation with a custom authorization server in Spring Security
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Spring Security中使用自定义授权服务器实现OAuth
- en: Technical requirements
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'All the code used in this chapter can be downloaded from the following GitHub
    link: [https://github.com/PacktPublishing/Spring-5.0-Projects/tree/master/chapter04](https://github.com/PacktPublishing/Spring-5.0-Projects/tree/master/chapter04).
    The code can be executed on any operating system, although it has only been tested
    on Windows.'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中使用的所有代码都可以从以下GitHub链接下载：[https://github.com/PacktPublishing/Spring-5.0-Projects/tree/master/chapter04](https://github.com/PacktPublishing/Spring-5.0-Projects/tree/master/chapter04)。代码可以在任何操作系统上执行，尽管它只在Windows上进行了测试。
- en: LDAP
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: LDAP
- en: When email was introduced and started to be used in corporations, one challenge
    was to look up the email address of someone that had never communicated with you.
    It required some sort of central repository for searching the email addresses
    of other people within the organization.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 当电子邮件被引入并在企业中开始使用时，一个挑战是查找从未与你交流过的人的电子邮件地址。这需要某种类型的中央存储库来搜索组织内部其他人的电子邮件地址。
- en: Necessity is the mother of invention. The need for a central data depot brought
    companies like Microsoft, Lotus, Netscape, and IBM together, and they defined
    a standard called **LDAP**. It is a protocol for accessing data stored in a directory
    structure over the network.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 需要是发明之母。对中央数据仓库的需求将微软、莲花、网景和IBM等公司聚集在一起，他们定义了一个称为**LDAP**的标准。它是一种通过网络目录结构访问存储数据的协议。
- en: The LDAP server, which holds and indexes the data in a hierarchical manner,
    can be accessed by LDAP-aware clients. The data can be filtered to select a particular
    person or group stored in a different entity. For example, imagine searching for
    all employees located in Chicago that are from the admin department and have been
    working for more than three years, and receiving their full name, designation,
    and email address. This is quite possible with LDAP.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: LDAP服务器以分层方式存储和索引数据，可以被LDAP感知客户端访问。数据可以被过滤以选择存储在不同实体中的特定个人或组。例如，想象一下搜索所有位于芝加哥的来自行政部门且工作超过三年的员工，并接收他们的全名、职位和电子邮件地址。使用LDAP完全可以做到这一点。
- en: Apart from contact information, LDAP can also be used to store access control
    data, which can then be used to perform authentication and authorization. We will
    start by covering the basics of LDAP and how to construct a data structure with
    it.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 除了联系信息外，LDAP还可以用来存储访问控制数据，然后可以使用这些数据来进行身份验证和授权。我们将从介绍LDAP的基础知识以及如何使用它构建数据结构开始。
- en: What is LDAP?
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是LDAP？
- en: LDAP is an industry standard for accessing and managing hierarchical information
    stored in a directory structure over the network. LDAP has been in use for quite
    a long time. Nowadays, it is mainly used to build an authentication system; however,
    that is by no means its only purpose. LDAP can also be used to store any kind
    of information that needs to be accessed centrally (for example, emails or contact
    information in an organization).
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: LDAP是访问和管理存储在网络目录结构中的分层信息的行业标准。LDAP已经使用了很长时间。如今，它主要用于构建身份验证系统；然而，这绝对不是它的唯一目的。LDAP还可以用来存储需要集中访问的任何类型的信息（例如，组织中的电子邮件或联系信息）。
- en: 'The main motive for storing user (or any other) information, like usernames,
    emails, passwords, and so on, in one place, is to provide administration and maintenance
    support with ease. For example, rather than handling the user list for each subgroup
    separately in an organization, LDAP can be used to manage them as a central repository,
    accessible from anywhere in the network. There are certain use cases where LDAP
    is the perfect fit, as follows:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 将用户（或任何其他）信息，如用户名、电子邮件、密码等存储在一个地方的主要动机是为了方便提供管理和维护支持。例如，而不是在组织中单独处理每个子组的用户列表，LDAP可以用来将它们作为一个中央存储库来管理，可以从网络中的任何位置访问。以下是一些LDAP是完美匹配的用例：
- en: Allowing a user to log in with the same credentials in multiple applications,
    like logging in on an intranet and on your local machine.
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 允许用户使用相同的凭据在多个应用程序中登录，例如在内部网和本地机器上登录。
- en: Providing role-based access to a group of users; for example, accessing a specific
    page on the intranet site, or accessing a document in a document management system.
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为一组用户提供基于角色的访问权限；例如，访问内部网站上的特定页面，或访问文档管理系统中的文档。
- en: Collecting user contact details and making them available globally, so that
    any user in the organization can access them.
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 收集用户联系信息并使其在全球范围内可用，以便组织中的任何用户都可以访问它们。
- en: LDAP is a way to access the structured information stored in directories. For
    this, it follows the client-server model, where data is stored on the LDAP server
    and the client can raise a request to access required information (through the
    LDAP API).
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: LDAP是一种访问存储在目录中的结构化信息的方式。为此，它遵循客户端-服务器模型，其中数据存储在LDAP服务器上，客户端可以提出请求以访问所需信息（通过LDAP
    API）。
- en: The information stored in an LDAP service is not intended to be altered upon
    each access, which makes that LDAP is a write once and read many times form of
    service. For example, LDAP would not be appropriate for maintaining the transaction
    records of an online shopping application, considering the fact that those records
    change with every operation. However, LDAP can be used to maintain data that changes
    less frequently, like user accounts, user addresses, and so on.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 存储在LDAP服务中的信息不打算在每次访问时都进行更改，这使得LDAP成为一种写入一次、读取多次的服务形式。例如，考虑到这些记录随着每次操作而改变，LDAP不适合维护在线购物应用的交易记录。然而，LDAP可以用来维护变化频率较低的数据，如用户账户、用户地址等。
- en: The data stored on the LDAP server is not in a relational form; rather, it is
    hierarchical. However, LDAP uses the database to store the information internally,
    but presents it in a hierarchical manner.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 存储在LDAP服务器上的数据不是以关系形式存在的；而是分层的。然而，LDAP使用数据库来内部存储信息，但以分层的方式呈现。
- en: 'Along with defining how to access the data in the directory service, LDAP also
    defines how the data is presented. To understand this data information model,
    it is essential to understand certain terms used in LDAP. This will not only help
    you to get a better idea of how it works, but will also illustrate how to create
    and search for the data in LDAP:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 除了定义如何访问目录服务中的数据外，LDAP还定义了数据的呈现方式。要理解此数据信息模型，了解LDAP中使用的某些术语至关重要。这不仅将帮助您更好地了解其工作原理，还将说明如何在LDAP中创建和搜索数据：
- en: '**Directory information tree **(**DIT**): As we discussed, the LDAP server
    stores the information in a hierarchical (or a tree) form. This tree is called
    a directory information tree.'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**目录信息树**（**DIT**）：正如我们讨论的那样，LDAP服务器以分层（或树状）形式存储信息。这个树称为目录信息树。'
- en: '**Entry**: As trees have nodes, the nodes in the DIT are called entries. The
    information that is stored within the entry is in the form of a key-value pair.
    Each entry has one parent entry (except for the root entry) and zero or more child
    entries. A child entry is a sibling of its parent’s other child entry.'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**条目**：由于树有节点，DIT中的节点称为条目。存储在条目中的信息以键值对的形式存在。每个条目有一个父条目（除了根条目）和零个或多个子条目。子条目是其父条目的其他子条目的兄弟条目。'
- en: '**Root/base/suffix**: The top entry in DIT is called the root, base, or suffix.'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**根/基本/后缀**：DIT的顶级条目称为根、基本或后缀。'
- en: '**Distinguished name **(**DN**): Each entry in DIT should be recognized by
    a unique identifier. This unique identifier is called a distinguished name. Generally,
    it is a string consisting of one or more comma-separated key-value pairs, which
    together uniquely distinguish the node (entry) in the tree. For example, the string
    `dc=nilangpatel`*,* `cd=com` could be the DN for the root entity.'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**区分名称**（**DN**）：DIT中的每个条目都应该由一个唯一的标识符识别。这个唯一的标识符称为区分名称。通常，它是由一个或多个逗号分隔的键值对组成的字符串，这些键值对共同唯一地识别树中的节点（条目）。例如，字符串`dc=nilangpatel`*，*
    `cd=com` 可以是根实体的DN。'
- en: '**Relative distinguished name** (**RDN**): A string that uniquely distinguishes
    the entity relative to its parent is called a relative distinguished name. The
    DN uniquely identifies the entity globally, while the RDN uniquely identifies
    the entity among its siblings.'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**相对区分名称**（**RDN**）：相对于其父实体的唯一标识字符串称为相对区分名称。DN在全球范围内唯一标识实体，而RDN在兄弟姐妹中唯一标识实体。'
- en: '**Object class**: Each entity is comprised of one or more `objectClasses`.
    Each object class has a name and zero or more attributes. The `objectclass` is
    considered a container for attributes, and it will control what types of attributes
    can be added to the entity.'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**对象类**：每个实体由一个或多个`objectClasses`组成。每个对象类都有一个名称和零个或多个属性。`objectclass`被视为属性的容器，它将控制可以添加到实体中的属性类型。'
- en: '**Attribute**: The attribute is part of the `objectclass`. It has a name and
    a value. It also has an abbreviation or alias.'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**属性**：属性是`objectclass`的一部分。它有一个名称和值。它还有一个缩写或别名。'
- en: 'The following is a list of a few attributes (along with their object classes)
    that we are going to use in this chapter:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是我们将在本章中使用的一些属性（及其对象类）的列表：
- en: '| Attribute name | Alias name | Description | Object class |'
  id: totrans-39
  prefs: []
  type: TYPE_TB
  zh: '| 属性名称 | 别名名称 | 描述 | 对象类 |'
- en: '| `dc` | `domainComponent` | Any part of a domain name; for example, `domain.com`,
    domain, or com | `dcObject` |'
  id: totrans-40
  prefs: []
  type: TYPE_TB
  zh: '| `dc` | `domainComponent` | 域名的一部分；例如，`domain.com`、domain或com | `dcObject`
    |'
- en: '| `o` | `organizationName` | Organization name | `organization` |'
  id: totrans-41
  prefs: []
  type: TYPE_TB
  zh: '| `o` | `organizationName` | 组织名称 | `organization` |'
- en: '| `ou` | `organisationalUnitName`  | Department or any subgroup | `organizationUnit`
    |'
  id: totrans-42
  prefs: []
  type: TYPE_TB
  zh: '| `ou` | `organisationalUnitName`  | 部门或任何子组 | `organizationUnit` |'
- en: '| `cn` | `common name` | Name of the entity | `person`, `organizationalPerson`,
    `organizationalRole`, `groupOfNames`, `applicationProcess`, `applicationEntity`,
    `posixAccount`, `device` |'
  id: totrans-43
  prefs: []
  type: TYPE_TB
  zh: '| `cn` | `common name` | 实体的名称 | `person`, `organizationalPerson`, `organizationalRole`, `groupOfNames`, `applicationProcess`,
    `applicationEntity`, `posixAccount`, `device` |'
- en: '| `sn` | `surname` | Surname or family name | `person` |'
  id: totrans-44
  prefs: []
  type: TYPE_TB
  zh: '| `sn` | `surname` | 姓氏或家族名称 | `person` |'
- en: '| `uid` | `userid` | Username or other unique value | `account`, `inetOrgPerson`,
    `posixAccount` |'
  id: totrans-45
  prefs: []
  type: TYPE_TB
  zh: '| `uid` | `userid` | 用户名或其他唯一值 | `account`, `inetOrgPerson`, `posixAccount`
    |'
- en: '| `userPassword`  |  `-` | User password for some form of access control |
    `organization`, `organizationalUnit`, `person`, `dmd`, `simpleSecurityObject`,
    `domain`, `posixAccount` |'
  id: totrans-46
  prefs: []
  type: TYPE_TB
  zh: '| `userPassword`  |  `-` | 用于某种形式的访问控制的用户密码 | `organization`, `organizationalUnit`,
    `person`, `dmd`, `simpleSecurityObject`, `domain`, `posixAccount` |'
- en: '**LDAP Data Interchange Format **(**LDIF**): This is an ASCII file format to
    describe the hierarchical tree structure of LDAP data in the form of a text file.
    LDAP data can be imported or exported in an LDIF file format.'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**LDAP 数据交换格式** (**LDIF**)：这是一个 ASCII 文件格式，用于以文本文件的形式描述 LDAP 数据的层次树结构。LDAP
    数据可以以 LDIF 文件格式导入或导出。'
- en: Configuring Apache DS as an LDAP server
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置 Apache DS 作为 LDAP 服务器
- en: We will use **Apache Directory Server** (**Apache DS**), an extendable, modern,
    and embeddable LDAP server, to showcase LDAP authentication. It is written purely
    in Java. Apache DS comes as a standalone LDAP server. While working with it, you
    will need some sort of LDAP Browser to visualize and manipulate the data.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用 **Apache 目录服务器** (**Apache DS**)，一个可扩展的、现代的、可嵌入的 LDAP 服务器，来展示 LDAP 认证。它完全用
    Java 编写。Apache DS 是一个独立的 LDAP 服务器。在使用它时，你需要某种 LDAP 浏览器来可视化并操作数据。
- en: However, Apache provides another tool, called **Apache Directory Studio,** which
    is an Eclipse-based application. It ships with Apache DS and LDAP Browser, in
    a single bundle. It was designed particularly for Apache DS; however, you can
    use it with any LDAP server (like **OpenLDAP**).
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，Apache 提供了另一个工具，称为 **Apache 目录工作室**，这是一个基于 Eclipse 的应用程序。它捆绑了 Apache DS 和
    LDAP 浏览器，作为一个单一包提供。它特别为 Apache DS 设计；然而，你可以用它与任何 LDAP 服务器（如 **OpenLDAP**）一起使用。
- en: When you use Apache Directory Studio, you are no longer required to get another
    LDAP server, because it comes with Apache DS (an LDAP server).
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 当你使用 Apache 目录工作室时，你不再需要获取另一个 LDAP 服务器，因为它自带 Apache DS（一个 LDAP 服务器）。
- en: Download Apache Directory Studio ([https://directory.apache.org/studio/](https://directory.apache.org/studio/)),
    extract it on your local machine, and double-click on the `ApacheDirectoryStudio`
    executable file to open it.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 下载 Apache 目录工作室 ([https://directory.apache.org/studio/](https://directory.apache.org/studio/))，在本地机器上解压，然后双击 `ApacheDirectoryStudio` 可执行文件以打开它。
- en: First, we need to add the Apache DS server. For that, go to the LDAP Server
    tab (generally placed at the bottom of the window), right-click there, select
    New | New Server, and choose the latest version of Apache DS server. Once the
    server has been added, right-click on it and select *Run* to start the server.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要添加 Apache DS 服务器。为此，转到 LDAP 服务器选项卡（通常位于窗口底部），右键点击那里，选择新建 | 新服务器，并选择 Apache
    DS 服务器的最新版本。一旦服务器被添加，右键点击它并选择 *运行* 以启动服务器。
- en: 'After the server is up and running, we need to create a connection. Right-click
    on the *Connections* tab and select New Connection, with the following information:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器启动并运行后，我们需要创建一个连接。右键点击 *连接* 选项卡，选择新建连接，并输入以下信息：
- en: Connection name**:** Any appropriate name.
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 连接名称**：** 任何合适的名称。
- en: 'Hostname: The localhost.'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 主机名：localhost。
- en: Port**:** The default port for any LDAP server is `389`. However, the default
    port for Apache DS is `10389`. Needless to say, that port can be changed.
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 端口**：** 任何 LDAP 服务器的默认端口是 `389`。然而，Apache DS 的默认端口是 `10389`。不言而喻，该端口可以更改。
- en: 'Keep the rest of the options as is, and click on the Next button to fill in
    the following details:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 保持其余选项不变，点击 *下一步* 按钮填写以下详细信息：
- en: '**Authentication Method:** Simple authentication'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**认证方法：** 简单认证'
- en: '**Bind DN or user: **`uid=admin`, `ou=system`'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**绑定DN或用户：** `uid=admin`, `ou=system`'
- en: '**Bind password:** `Secret`'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**绑定密码：** `Secret`'
- en: 'This is the default admin credential, and can be verified by clicking on the Check
    Authentication button. Click on Finish, and you will see the details in the LDAP
    Browser windows, as shown in the following screenshot:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 这是默认的管理员凭证，可以通过点击 *检查认证* 按钮进行验证。点击完成，你将在 LDAP 浏览器窗口中看到详细信息，如下所示截图：
- en: '![](img/e77d5953-205b-452f-8cb8-30cadfe77ffd.png)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/e77d5953-205b-452f-8cb8-30cadfe77ffd.png)'
- en: Next, we will start to create a data structure to store user details. As you
    have seen, LDAP can be used to store any kind of information, but we will use
    LDAP for authentication. LDAP stores the data in the form of a tree (DIT), so
    we will create a DIT structure.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将开始创建一个数据结构来存储用户详细信息。正如你所见，LDAP 可以用来存储任何类型的信息，但我们将使用 LDAP 进行认证。LDAP 以树（DIT）的形式存储数据，因此我们将创建一个
    DIT 结构。
- en: Example DIT structures
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 示例 DIT 结构
- en: 'Moving on, let''s first look at a few data structures that are commonly used
    in LDAP, and then select one of them:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们先看看在 LDAP 中常用的一些数据结构，然后从中选择一个：
- en: '![](img/82f72d0f-e7ab-4c5f-a48a-2240ca32af5a.png)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/82f72d0f-e7ab-4c5f-a48a-2240ca32af5a.png)'
- en: This structure starts with an organization with a name, packt (**o=packt**),
    followed by an organizational unit (subgroup) for each of the departments, and
    finally, the users. At some places, the sub-organization has a user group, followed
    by users.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 此结构以一个名为 packt（**o=packt**）的组织开始，然后是每个部门的组织单元（子组），最后是用户。在某些地方，子组织有一个用户组，然后是用户。
- en: 'The tree can also be arranged based on internet domain names, as follows:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 树也可以根据互联网域名进行排列，如下所示：
- en: '![](img/54101e71-9a26-4e90-8bc2-8cdf364380b0.png)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/54101e71-9a26-4e90-8bc2-8cdf364380b0.png)'
- en: This structure has `example.com` as a domain. You can give the same attribute
    multiple times with different name, as previously shown. The **dc** stands for **domain
    component**. It is followed by subgroups for **users** and **printers** (devices),
    and at the end, the **users** and devices (**printers**) are listed.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 此结构以 `example.com` 作为域名。你可以使用不同的名称多次提供相同的属性，如之前所示。**dc** 代表 **domain component**。它后面跟着
    **users** 和 **printers**（设备）的子组，最后列出 **users** 和设备（**printers**）。
- en: 'Another option could be as follows:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个选项可能如下所示：
- en: '![](img/fa6a4809-43f0-4b9d-ab26-5f8619a589f7.png)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/fa6a4809-43f0-4b9d-ab26-5f8619a589f7.png)'
- en: This option has an organization (**o=packtPublisher**) as the root, and two
    child **users** and **roles** as the **ou** (organizational unit, or subgroup).
    The **users** entry will have user entries, and the **roles** entry will have
    role entries. We will choose this option to construct a DIT in LDAP in this chapter.
    LDAP allows for associating the users to roles with attribute members. You will
    see more details about this in the *Creating roles in an LDAP server* section,
    later in this book.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 此选项以组织（**o=packtPublisher**）为根，有两个子节点 **users** 和 **roles** 作为 **ou**（组织单元或子组）。**users**
    条目将包含用户条目，而 **roles** 条目将包含角色条目。在本章中，我们将选择此选项在 LDAP 中构建 DIT。LDAP 允许通过属性成员将用户与角色关联。你将在本书后面的
    **在 LDAP 服务器中创建角色** 部分看到更多关于此的信息。
- en: Apache DS partitions
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Apache DS 分区
- en: Apache DS has a concept called **partitions**. Every partition contains an entity
    tree (DIT) that is totally disconnected from the entity trees in other partitions.
    This means that changes that happen with entry trees in one partition will never
    affect entry trees in other partition. Each partition is identified by a unique
    ID. It also has a naming context referred to as the **partition suffix**, which
    can be thought of as the root (or base) for the DIT in that partition; all entries
    are stored beneath that.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: Apache DS 有一个称为 **分区** 的概念。每个分区包含一个实体树（DIT），它与其他分区的实体树完全断开连接。这意味着一个分区中实体树发生的更改永远不会影响其他分区的实体树。每个分区都有一个唯一的
    ID。它还有一个称为 **分区后缀** 的命名上下文，可以将其视为该分区中 DIT 的根（或基础）；所有条目都存储在其下。
- en: 'To create a partition in Apache DS, double-click on the server instance in
    the LDAP server tab, and it will open the server configuration. Open the Partitions
    tab of the server configuration, click on the Add button, and give the values
    for the Partition General Details section, as follows:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 要在 Apache DS 中创建分区，请双击 LDAP 服务器选项卡中的服务器实例，它将打开服务器配置。打开服务器配置的分区选项卡，单击 **添加**
    按钮，并为 **分区常规详情** 部分提供以下值：
- en: '![](img/93d2ee51-0e6a-44fd-8634-33e8bb916c39.png)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/93d2ee51-0e6a-44fd-8634-33e8bb916c39.png)'
- en: 'ID: `packtPublisher`'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ID：`packtPublisher`
- en: 'Suffix: `o=packtPublisher`'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 后缀：`o=packtPublisher`
- en: 'Keep all of the other values as the defaults, and save the configuration. Restart
    the server to take the partition into effect. The new partition will be available
    in the LDAP Browser, as shown in the following screenshot:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 将所有其他值保留为默认值，并保存配置。重启服务器以使分区生效。新的分区将在 LDAP 浏览器中可用，如下截图所示：
- en: '![](img/c05bf0b7-40a1-4e18-ba9c-2e40d5706561.png)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/c05bf0b7-40a1-4e18-ba9c-2e40d5706561.png)'
- en: We will create an entity tree (DIT) under this partition. The partition suffix
    (`o=packtPublisher`) will be considered the base (or root) of the DIT. Next, we
    will create entries underneath it.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在该分区下创建一个实体树（DIT）。分区后缀（`o=packtPublisher`）将被视为 DIT 的基础（或根）。接下来，我们将在其下创建条目。
- en: The LDAP structure
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: LDAP 结构
- en: Proceeding further, we will look at the DN and RDN concept in DIT. We are targeting
    our DIT as per the third option that you saw in the *Example DIT structures* section. Let's
    recall that the RDN uniquely distinguishes the entry among its siblings. That
    means it is a key that makes the entry unique underneath the parent entry. We
    can use any attribute to declare the RDN. Additionally, at each level, the attribute
    used as an RDN can differ.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 进一步操作，我们将查看DIT中的DN和RDN概念。我们针对您在“示例DIT结构”部分看到的第三个选项来定位我们的DIT。让我们回忆一下，RDN在兄弟姐妹中唯一地区分条目。这意味着它是使条目在父条目下独特的关键。我们可以使用任何属性来声明RDN。此外，在每个级别，用作RDN的属性可以不同。
- en: In our case, the RDN of the base is `o=packtPublisher` (which is the partition
    suffix). We have used the attribute `o`, which is the organization name. Just
    beneath it, there are two children, for which the `ou` attribute has been used
    as the RDN. The attribute `ou` stands for an organizational unit. These two children
    represent users and roles, respectively.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的例子中，基的RDN是`o=packtPublisher`（这是分区后缀）。我们使用了属性`o`，它是组织名称。在其下方，有两个子项，其中使用了`ou`属性作为RDN。属性`ou`代表组织单元。这两个子项分别代表用户和角色。
- en: We are going to store the user information (the username and password, along
    with other information) under the `users` entity. So, the children of the `users`
    entity are the actual user entity for which the attribute `uid` is used as the
    RDN. The attribute `uid` stands for the **user ID**. Generally, in any organization,
    either the username or email ID is used for logging in; so, we can take either
    of them as the value of the `uid` attribute. In this case, we will give the username
    as `uid`.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在`users`实体下存储用户信息（用户名和密码，以及其他信息）。因此，`users`实体的子项是实际的用户实体，其中使用`uid`属性作为RDN。属性`uid`代表**用户ID**。通常，在任何组织中，要么使用用户名，要么使用电子邮件ID进行登录；因此，我们可以将它们中的任何一个作为`uid`属性的值。在这种情况下，我们将用户名作为`uid`。
- en: We've gone over how the RDN works. Now, let's look at how the DN works. As we
    described, the DN uniquely identifies any entry in a given DIT. In other words,
    the DN makes the entry unique across the whole tree (DIT). The DN is a comma-separated
    string of the RDNs of the given entity, along with all of its parents, up till
    the root entity. So, the DN is automatically calculated, based on a given RDN
    at each level.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经介绍了RDN的工作原理。现在，让我们看看DN是如何工作的。正如我们描述的那样，DN唯一地标识了给定DIT中的任何条目。换句话说，DN在整个树（DIT）中使条目独特。DN是由给定实体的RDN组成的逗号分隔字符串，包括所有其父实体，直到根实体。因此，DN是根据每个级别的给定RDN自动计算的。
- en: In the previous case, the DN of each entity (with `uid=npatel`) would be `uid=npatel`*,*
    `ou=users`*,* and `o=packtPublisher`. Similarly, the DN of the `users` entity
    is `ou=users` and `o=packtPublisher`. This is how the DN is calculated by appending
    the RDN at each level.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个例子中，每个实体（带有`uid=npatel`）的DN将是`uid=npatel`*，* `ou=users`*，*和`o=packtPublisher`。同样，`users`实体的DN是`ou=users`和`o=packtPublisher`。这就是通过在每个级别附加RDN来计算DN的方式。
- en: 'Let''s create this structure in Apace DS now. Execute the following steps to
    expand the DIT structure in Apache Directory Studio:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在Apace DS中创建这个结构。按照以下步骤在Apache Directory Studio中展开DIT结构：
- en: Right-click on the partition `o=packtPublisher`, and select New | New Entry.
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 右键单击分区`o=packtPublisher`，然后选择“新建”|“新建条目”。
- en: Choose an option, *Create entry from scratch*, and click on Next.
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择一个选项，“从头创建条目”，然后点击“下一步”。
- en: We are going to add an entity type organization unit, so choose the `organizationalUnit`
    object class and click on Next.
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将添加一个实体类型组织单元，因此请选择`organizationalUnit`对象类，然后点击“下一步”。
- en: We will use `ou` (organizational unit) as an RDN and `users` as its value. The
    DN is automatically calculated when you give the value of the RDN. You can use
    more than one attribute (or the same attribute multiple times, with a different
    value) for the RDN. The DN will then be calculated by appending each name with
    a comma.
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将使用`ou`（组织单元）作为RDN，并使用`users`作为其值。当您给出RDN的值时，DN会自动计算。您可以为RDN使用多个属性（或多次使用相同的属性，具有不同的值）。然后，DN将通过在每个名称后附加逗号来计算。
- en: Click on Next, followed by the Finish button, and the entry `ou=users` will
    be added under `o=packtPublisher`. The updated structure will be visible in the LDAP
    Browser window.
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击“下一步”，然后点击“完成”按钮，条目`ou=users`将被添加到`o=packtPublisher`下。更新后的结构将在LDAP浏览器窗口中可见。
- en: 'Once the `users` entry is added, we can insert the individual user entries
    underneath it. The steps are as follows:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦添加了`users`条目，我们可以在其下方插入单个用户条目。步骤如下：
- en: Right-click on the `users` entity (`ou=users`), and select New | New Entry.
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 右键单击`users`实体（`ou=users`），然后选择“新建 | 新条目”。
- en: Choose the option Create entry from scratch and click on Next.
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择“从头创建条目”选项，然后点击下一步。
- en: We are going to add a user, so choose the `inetOrgPerson` object class, which
    represents a person within an organization. Click on the Next button.
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将添加一个用户，因此请选择代表组织内人员的`inetOrgPerson`对象类。点击下一步按钮。
- en: We are going to add a user, so we will use the attribute `uid` (user ID) as
    the RDN. Just give the value as `npatel`. You can give any value that uniquely
    identifies the user. At this moment, the DN is calculated as `uid=npatel`,`ou=users`,
    `o=packtPublisher`.
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将添加一个用户，因此我们将使用属性`uid`（用户ID）作为RDN。只需将值设置为`npatel`。您可以提供任何唯一标识用户的值。此时，DN计算为`uid=npatel`,`ou=users`,
    `o=packtPublisher`。
- en: Click on Next, and you will see a few required attributes, like `cn` and `sn`.
    The `cn` stands for **common name**, and `sn` means **surname**. The first name
    and last name can be given for `cn` and `sn`, respectively.
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击下一步，您将看到一些必需的属性，如`cn`和`sn`。`cn`代表**通用名称**，而`sn`表示**姓氏**。可以为`cn`和`sn`分别提供名字和姓氏。
- en: We want to authenticate a user, so there must be a password field (attribute)
    for a user entity. Just right-click on this screen and select New Attribute.
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们想要认证一个用户，因此用户实体必须有一个密码字段（属性）。只需在此屏幕上右键单击并选择“新建属性”。
- en: Give the attribute type as `userPassword`, and click on Next | Finish; a new
    window will pop up, in which you can give the password.
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将属性类型指定为`userPassword`，然后点击“下一步 | 完成”；将弹出一个新窗口，在其中可以输入密码。
- en: Give the appropriate value for the password, confirm the password, and set the Hash
    method as SHA; click on the OK button. Click on the Finish button from the parent
    window.
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为密码输入适当的值，确认密码，并将哈希方法设置为SHA；点击“确定”按钮。从父窗口中点击“完成”按钮。
- en: Add two to three such users, using the previous steps. We will look at how to
    add roles and create actual roles in the *LDAP authorization with Spring Security*
    section.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 使用前面的步骤添加两到三个这样的用户。我们将在“*使用Spring Security的LDAP授权*”部分查看如何添加角色并创建实际角色。
- en: The default configuration of Apache DS contains a data partition with the suffix
    `dc=example`, `dc=com`. This partition can also be used, but to understand the
    concept in detail, we have created a separate partition.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: Apache DS的默认配置包含一个后缀为`dc=example`, `dc=com`的数据分区。此分区也可以使用，但为了详细了解概念，我们已创建了一个单独的分区。
- en: Congratulations! The basic step of configuring the LDAP is done. The LDAP server
    is ready for use. Next, we will look at how to authenticate the user against the
    LDAP server with Spring Security.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜！配置LDAP的基本步骤已完成。LDAP服务器已准备好使用。接下来，我们将探讨如何使用Spring Security对LDAP服务器进行用户认证。
- en: Spring Security integration with LDAP
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Spring Security与LDAP集成
- en: In [Chapter 3](e32452e8-07bb-4815-96d6-b0db0a6009ba.xhtml), *Blogpress - A Simple
    Blog Management System*, we provided information about Spring Boot and looked
    at how to create an application with it. In this chapter, we will use Spring Boot
    to build an app to showcase authentication and authorization in Spring Security.
    In the *LDAP* section, we covered the installation and setup of the LDAP server,
    along with its data structure. In this section, you will see how Spring Security
    works with LDAP.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第3章](e32452e8-07bb-4815-96d6-b0db0a6009ba.xhtml)，“*Blogpress - 一个简单的博客管理系统*”中，我们提供了关于Spring
    Boot的信息，并探讨了如何使用它创建应用程序。在本章中，我们将使用Spring Boot构建一个应用程序，以展示Spring Security中的认证和授权。在*LDAP*部分，我们介绍了LDAP服务器的安装和设置，以及其数据结构。在本节中，您将了解Spring
    Security如何与LDAP协同工作。
- en: Spring Security is a highly comprehensive and extensible framework; it provides
    authentication and authorization support for a J2EE-based web and REST application.
    We will look at how to integrate Spring Security with LDAP to perform authentication.
    By definition, **authentication** is a mechanism of validating or deciding whether
    an individual or entity is what it claims to be.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Security是一个高度综合和可扩展的框架；它为基于J2EE的Web和REST应用程序提供认证和授权支持。我们将探讨如何将Spring
    Security与LDAP集成以执行认证。根据定义，**认证**是验证或决定个人或实体是否为其声称的身份的机制。
- en: To demonstrate authentication, we will first build a web application with Spring
    Boot, and then we'll integrate it with LDAP.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示认证，我们首先将使用Spring Boot构建一个Web应用程序，然后将其与LDAP集成。
- en: Creating a web application with Spring Boot
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Spring Boot创建Web应用程序
- en: 'We have created the data structure and have added the users, along with their
    credentials, in the LDAP server. Next, we will build a web application and integrate
    Spring Security, which will talk to the LDAP server for authentication. In the
    previous chapter, we built an application with Spring MVC and Thymeleaf. We will
    reuse the same architecture and create a web application with the following artifacts:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经创建了数据结构，并在LDAP服务器中添加了用户及其凭据。接下来，我们将构建一个Web应用程序并集成Spring Security，该应用程序将与LDAP服务器进行身份验证。在前一章中，我们使用Spring
    MVC和Thymeleaf构建了一个应用程序。我们将重用相同的架构并创建以下工件的应用程序：
- en: Spring Boot, for creating a web application and auto configuration for other
    modules
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Spring Boot，用于创建Web应用程序并对其他模块进行自动配置
- en: Thymeleaf, for the presentation layer
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Thymeleaf，用于表示层
- en: Spring Security, to perform authentication with LDAP.
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Spring Security，用于与LDAP执行身份验证。
- en: 'Like in the previous chapter, we will use an Eclipse-based IDE called **Spring
    Tool Suite (STS)** in this chapter. Create a Spring Boot application with the
    name `SpringAuth`, and other suitable parameters, like the group, artifact, version,
    description, and Java package. Make sure that the following starters are added
    to `pom.xml`:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 如前一章所述，在本章中，我们将使用基于Eclipse的IDE，称为**Spring Tool Suite (STS**)。创建一个名为`SpringAuth`的Spring
    Boot应用程序，并添加其他合适的参数，如组、工件、版本、描述和Java包。确保将以下启动器添加到`pom.xml`中：
- en: '[PRE0]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Among the preceding entries, the `spring-security-ldap` is not a starter, but
    rather, a plain dependency. It provides the relevant dependencies required in
    the integration of Spring Security with LDAP.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的条目中，`spring-security-ldap`不是一个启动器，而是一个普通依赖项。它提供了在Spring Security与LDAP集成中所需的相应依赖项。
- en: We will configure the LDAP server as a data source to fetch user details and
    perform authentication in Spring Security. At this moment, Spring Security should
    know the details of how to connect with the LDAP server. These details are comprised
    of the URL, the base RDN, and the admin credentials. We will define these details
    in the `application.properties` file, as follows.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将配置LDAP服务器作为数据源以获取用户详情并在Spring Security中执行身份验证。此时，Spring Security应该知道如何连接到LDAP服务器。这些细节包括URL、基础RDN和管理员凭据。我们将在`application.properties`文件中定义这些细节，如下所示。
- en: '[PRE1]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The details are straightforward. The username and password represent the LDAP
    admin credentials. Since we are dealing with LDAP, the admin username is in the
    form of a DN (`uid=admin`*,* `ou=system`) instead of a direct value (like admin).
    We can relate these details with the information that we use to interact with
    a database (like the URL, port, username, and password). We will read these details
    and supply them to Spring Security to make a connection with LDAP. To achieve
    this, we will write a configuration class, as follows:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 这些细节很简单。用户名和密码代表LDAP管理员凭据。由于我们处理的是LDAP，管理员用户名采用DN形式（如`uid=admin`*`ou=system`*），而不是直接值（如admin）。我们可以将这些细节与我们用于与数据库交互的信息（如URL、端口、用户名和密码）联系起来。我们将读取这些细节并将它们提供给Spring
    Security以与LDAP建立连接。为此，我们将编写一个配置类，如下所示：
- en: '[PRE2]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'This class simply reads the LDAP connection properties with the `@Value` annotation,
    stored in the instance of the `LdapAuthStructure` class, and defines it as Spring
    Bean, so that it is available to other classes. The `LdapAuthStructure` is a custom
    class that holds LDAP configuration properties. We will use the following two
    additional properties for LDAP integration with Spring:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 此类简单地使用`@Value`注解读取LDAP连接属性，存储在`LdapAuthStructure`类的实例中，并将其定义为Spring Bean，以便它可供其他类使用。`LdapAuthStructure`是一个自定义类，用于存储LDAP配置属性。我们将使用以下两个附加属性进行Spring与LDAP的集成：
- en: '`userDnPattern`: The value is `uid={0},ou=users`. This is nothing but a DN
    pattern (relative to the entity `ou=users`). The `{0}` will be substituted with
    the actual value (`uid`, user ID) by Spring at runtime.'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`userDnPattern`：其值是`uid={0},ou=users`。这实际上是一个DN模式（相对于`ou=users`实体）。`{0}`将在Spring运行时被实际值（如`uid`、用户ID）替换。'
- en: '`userSearchBase`:It represents the user base (`ou=users`). Basically, it represents
    an entity under which the users can be searched.'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`userSearchBase`：它表示用户基础（`ou=users`）。基本上，它表示一个用户可以搜索的实体。'
- en: '`groupSearchBase`: It represents the group base (`ou=roles`). We will use this
    property to perform authorization in upcoming sections.'
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`groupSearchBase`：它表示组基础（`ou=roles`）。我们将使用此属性在后续部分执行授权。'
- en: 'Next, we will use these properties and initialize Spring Security with the
    security configuration class, as follows:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将使用这些属性并使用安全配置类初始化 Spring Security，如下所示：
- en: '[PRE3]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The `WebSecurityConfig` is a custom class that extends the `WebSecurityConfigurerAdapter`
    class. This class is a single point of configuration to declare security-related
    details. The `configure(WebSecurity web)` method is used for ignoring the requests
    for static resources (JS and CSS) from the security context. Without this, not
    a single static resource will be loaded in the browser, because they will be filtered
    by Spring Security.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '`WebSecurityConfig` 是一个扩展 `WebSecurityConfigurerAdapter` 类的自定义类。这个类是声明安全相关细节的单一点。`configure(WebSecurity
    web)` 方法用于忽略来自安全上下文的静态资源（JS 和 CSS）请求。如果没有这个方法，浏览器中不会加载任何静态资源，因为它们将被 Spring Security
    过滤。'
- en: For our application, we did not use any images; if we did, the image path (generally
    `/img/**`) would also need to be ignored.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的应用程序，我们没有使用任何图像；如果我们使用了，图像路径（通常为 `/img/**`）也需要被忽略。
- en: 'The next method, `configure(HttpSecurity http)`, is used to set rules on various
    pages (URLs). Our motive is to showcase authentication with LDAP; hence, to make
    things simple, there are three pages with corresponding URLs, as follows:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个方法 `configure(HttpSecurity http)` 用于设置各种页面（URL）的规则。我们的目的是展示使用 LDAP 的认证；因此，为了简化，有三个页面和相应的
    URL，如下所示：
- en: The home page (with the URL `/`). It is a landing page, meaning that this page
    will be opened when a user types `http://localhost:8080/springauth` (considering
    `8080` as the server port and `springauth` as the context).
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 主页面（URL 为 `/`）。这是一个着陆页面，意味着当用户输入 `http://localhost:8080/springauth`（假设 `8080`
    为服务器端口，`springauth` 为上下文）时，此页面将被打开。
- en: The login page (with the URL `/login`). It will show a login form, with which
    the user can be authenticated.
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 登录页面（URL 为 `/login`）。它将显示一个登录表单，用户可以通过该表单进行认证。
- en: A private page (with the URL `/privatePage`). This is a protected page and is
    only available to the logged in user. A user will be redirected to this page upon
    successful login.
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个私有页面（URL 为 `/privatePage`）。这是一个受保护的页面，并且仅对登录用户可用。用户登录成功后将被重定向到该页面。
- en: The home page and login page are set to view for all, while the private page
    is set as a successful URL after logging in. This is a simple form login. The
    next method, `configure(AuthenticationManagerBuilder authManagerBuilder)`, actually
    does the magic. This is the place where the LDAP is being configured as an authentication
    mechanism.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 主页面和登录页面对所有用户开放，而私有页面在登录成功后设置为成功 URL。这是一个简单的表单登录。下一个方法 `configure(AuthenticationManagerBuilder
    authManagerBuilder)` 实际上执行了魔法。这是配置 LDAP 作为认证机制的地方。
- en: In this class, the object of `LdapAuthStructure` is being auto-wired, which
    is supplied from the `LdapDataConfig` class, where we declared it with the `@Bean`
    annotation. Let's recall that the `LdapAuthStructure` class holds the LDAP connection
    data, which we are using in the `configure(AuthenticationManagerBuilder authManagerBuilder)` method.
    The call `ldapAuthentication()` on the `AuthenticationManagerBuilder` class will
    set the type of authentication as LDAP.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个类中，`LdapAuthStructure` 对象正在自动装配，它由 `LdapDataConfig` 类提供，我们在其中使用 `@Bean` 注解声明了它。让我们回顾一下，`LdapAuthStructure`
    类持有 LDAP 连接数据，我们在 `configure(AuthenticationManagerBuilder authManagerBuilder)`
    方法中使用这些数据。在 `AuthenticationManagerBuilder` 类上的 `ldapAuthentication()` 调用将设置认证类型为
    LDAP。
- en: Further, it will set other connection data, like `userDnPattern` and `userSearchBase`.
    The value of `url` is supplied as a combination of the LDAP URL and the LDAP base
    (for example, `localhost:10389/o=packtPublisher`). In the end, the admin credential
    is supplied with the `managerDn()` and `managerPassword()` call. We also need
    to supply a password encoder. It must be the same password encoder that we used
    in the LDAP server, so we have used `LdapShaPasswordEncoder`. Finally, we are
    just mentioning the password field that we set in the LDAP server.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，它还会设置其他连接数据，如 `userDnPattern` 和 `userSearchBase`。`url` 的值是 LDAP URL 和 LDAP
    基础（例如，`localhost:10389/o=packtPublisher`）的组合。最后，管理员凭据通过 `managerDn()` 和 `managerPassword()`
    调用提供。我们还需要提供一个密码编码器。它必须与我们在 LDAP 服务器上使用的相同的密码编码器，因此我们使用了 `LdapShaPasswordEncoder`。最后，我们只是提到了我们在
    LDAP 服务器上设置的密码字段。
- en: The LDAP authentication configuration is done. When we log in with the (same)
    credentials that we created in the Apache DS server, it will be successful. We
    have set the `uid`as `userDnPatterns`, so give `uid` as the username when logging
    in.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: LDAP认证配置已完成。当我们使用在Apache DS服务器中创建的（相同）凭据登录时，登录将会成功。我们已将`uid`设置为`userDnPatterns`，因此在登录时请使用`uid`作为用户名。
- en: Congratulations! The LDAP integration with Spring Security has been successfully
    executed. The user will be authenticated against LDAP through Spring Security.
    If you only need to perform authentication with LDAP, the configuration that we
    have done so far will suffice. Next, we will look at how to interact with the
    LDAP server through the Spring Data repository, which we will use while working
    with both LDAP and OAuth later in this chapter.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜！Spring Security与LDAP的集成已成功执行。用户将通过Spring Security对LDAP进行身份验证。如果您只需要使用LDAP进行身份验证，我们迄今为止所做的配置就足够了。接下来，我们将探讨如何通过Spring
    Data仓库与LDAP服务器交互，这是我们将在本章后面与LDAP和OAuth一起工作时使用的。
- en: Managing LDAP users with Spring Data
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Spring Data管理LDAP用户
- en: One part of our integration is over. The LDAP admin can configure users from
    the LDAP server; then, they can be authenticated from web applications created
    with Spring Security. However, we still have to deal with separate systems (Apache
    DS) to maintain the user information.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 我们集成的一部分已经完成。LDAP管理员可以从LDAP服务器配置用户；然后，他们可以通过使用Spring Security创建的Web应用程序进行身份验证。然而，我们仍然需要处理单独的系统（Apache
    DS）来维护用户信息。
- en: How cool would it be if an admin could directly maintain the users from a Spring
    web application? This is a great idea, because it will not only make the admin
    job easy, but a user will be able to update their profile information (like the
    password, first name, last name, and so on) directly in the Spring-based web application. This
    is quite possible with Spring Boot. We are talking about performing CRUD operations
    on the LDAP server from a web application.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 如果管理员可以直接从Spring Web应用程序中维护用户，那会多么酷啊？这是一个很好的想法，因为它不仅会使管理员的工作变得简单，而且用户可以直接在基于Spring的Web应用程序中更新他们的个人资料信息（如密码、名字、姓氏等）。这完全可以通过Spring
    Boot实现。我们正在讨论从Web应用程序中执行对LDAP服务器的CRUD操作。
- en: In our application, the LDAP is used as a data store, where we are maintaining
    user data. Whenever we need to deal with any kind of data provider in a Spring-based
    application, we need to use **Spring Data**, a module of the Spring family that
    was specially designed to interact with the data store. Spring Data facilitates
    an abstract layer to interact with the underlying data provider, while providing
    an implementation for each of the data providers, like JPA, REST, Elasticsearch
    (which we used in the previous chapter), Mongo DB, and so on. Spring Data LDAP
    interacts with the LDAP server, and we will use it in our application.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的应用程序中，LDAP被用作数据存储，我们在其中维护用户数据。每次我们需要在基于Spring的应用程序中处理任何类型的数据提供者时，我们都需要使用**Spring
    Data**，这是Spring家族的一个模块，专门设计用来与数据存储交互。Spring Data提供了一个抽象层来与底层数据提供者交互，同时为每个数据提供者提供了实现，如JPA、REST、Elasticsearch（我们在上一章中使用过）、Mongo
    DB等。Spring Data LDAP与LDAP服务器交互，我们将在应用程序中使用它。
- en: 'Spring supplies a set of libraries for each of these data providers, which
    can be availed of by specifying the corresponding starter in the Spring Boot application.
    The Spring Data LDAP module can be integrated with the following starter entry
    in `pom.xml`:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: Spring为每个这些数据提供者提供了一套库，可以通过在Spring Boot应用程序中指定相应的启动器来使用。Spring Data LDAP模块可以通过以下`pom.xml`中的启动器条目进行集成：
- en: '[PRE4]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Soon after we have defined this starter, all of the required JARs will be available
    in the classpath. Next, we will create the model (entity) class.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们定义了这个启动器之后，所有必需的JAR文件都将出现在类路径中。接下来，我们将创建模型（实体）类。
- en: Spring Data models
  id: totrans-148
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Spring Data模型
- en: The Spring Data module provides an implementation of DAO, with the aim of making
    data access consistent for various data providers. This brings the great flexibility
    of switching the underlying persistence technologies without much effort. Eventually,
    this will make the system loosely coupled.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Data模块提供了一个DAO的实现，目的是使对各种数据提供者的数据访问保持一致。这带来了在无需太多努力的情况下切换底层持久化技术的巨大灵活性。最终，这将使系统松散耦合。
- en: 'Spring Data allows for exchanging the data with the persistence layer in an
    object-oriented manner, meaning that we can perform CRUD operations with entity
    class objects. Needless to say, the Spring Data LDAP module also facilitates the
    feature of dealing with the LDAP server in the form of the model class object.
    So, the first thing is to define the model (entity) class that represents the
    user data that we defined in the LDAP server, as follows:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Data 允许以面向对象的方式与持久化层交换数据，这意味着我们可以使用实体类对象执行 CRUD 操作。不用说，Spring Data LDAP
    模块还简化了以模型类对象的形式处理 LDAP 服务器的功能。因此，首先需要定义一个模型（实体）类，该类代表我们在 LDAP 服务器中定义的用户数据，如下所示：
- en: '[PRE5]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The `LdapAuthUser` class represents the LDAP user that we created in Apache
    DS. The `@Entity` annotation is used to map the Java class with an entity in the
    LDAP server. The `base` represents the base of the `users` entity (`ou=users`),
    while `objectClasses` is used to define the object class hierarchy used for creating
    the user entity.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '`LdapAuthUser` 类代表我们在 Apache DS 中创建的 LDAP 用户。使用 `@Entity` 注解将 Java 类映射到 LDAP
    服务器中的实体。`base` 代表 `users` 实体的基础（`ou=users`），而 `objectClasses` 用于定义用于创建用户实体的对象类层次结构。'
- en: The `@Attribute` annotation is used to map the instance variable with the attribute
    of the LDAP entity. The annotation `@DnAttribute` is used to populate the values
    automatically, from the distinguished names of the entries found. Special attention
    for `id` instance variable. It will be of the type `javax.naming.Name`.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `@Attribute` 注解将实例变量映射到 LDAP 实体的属性。使用 `@DnAttribute` 注解自动填充从找到的条目的区分名称中的值。特别关注
    `id` 实例变量。它将是 `javax.naming.Name` 类型。
- en: There is no direct attribute, like `id`, in the LDAP entity, but Spring Data
    needs some sort of unique identifier (like `PK`, in a relational database) for
    each instance of the model class. So, internally, it assigns a DN relative to
    a `base` (in the `@Entity` annotation) defined for the model class. For example,
    if the `uid` of a user is `npatel`, then the `id` would be `uid=npatel`, `ou=users`.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在 LDAP 实体中没有直接属性，例如 `id`，但 Spring Data 需要为模型类的每个实例分配某种唯一标识符（例如，在关系型数据库中的 `PK`）。因此，在内部，它为模型类定义的
    `base`（在 `@Entity` 注解中）分配一个相对的 DN。例如，如果用户的 `uid` 是 `npatel`，则 `id` 将是 `uid=npatel`，`ou=users`。
- en: Another unique point is that this model class implements the `Persistable<Name>`
    interface. Especially for the LDAP, at the time of adding a new entity, Spring
    Data does not have any way of knowing whether the entity is new or existing. So,
    every time Spring Data tries to search for an existing entity, it will throw an
    error if the entity does not exist. To avoid this, while adding a new record,
    we will explicitly set the `isNew` attribute to `true`, so that Spring Data will
    get its value with the overridden method `isNew()`.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个独特之处在于，此模型类实现了 `Persistable<Name>` 接口。特别是对于 LDAP，在添加新实体时，Spring Data 没有任何方法知道实体是新的还是现有的。因此，每次
    Spring Data 尝试搜索现有实体时，如果实体不存在，它将抛出一个错误。为了避免这种情况，在添加新记录时，我们将显式设置 `isNew` 属性为 `true`，这样
    Spring Data 就可以通过重写方法 `isNew()` 获取其值。
- en: The model class is now ready to use. Next, we will perform CRUD operations for
    LDAP users with Spring Data.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 模型类现在已准备好使用。接下来，我们将使用 Spring Data 对 LDAP 用户执行 CRUD 操作。
- en: The Spring Data repository for LDAP
  id: totrans-157
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Spring Data LDAP 存储库
- en: As you have seen, Spring Data provides an abstract (interface) layer while working
    with the persistence layer, in order to support various data stores, including
    relational databases, non-relational databases, map-reduce frameworks, cloud services,
    and so on. The abstraction starts with the `CrudRepository` interface, which provides
    basic CRUD operations, irrespective of the underlying data stores. This interface
    covers all basic CRUD operations.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，Spring Data 在与持久化层一起工作时提供了一个抽象（接口）层，以支持各种数据存储，包括关系型数据库、非关系型数据库、MapReduce
    框架、云服务等。抽象从 `CrudRepository` 接口开始，该接口提供了基本的 CRUD 操作，无论底层数据存储如何。此接口涵盖了所有基本的 CRUD
    操作。
- en: Spring Data defines various interfaces, which are specific to each data provider
    on top of the `CrudRepository`. For LDAP support, Spring Data supplies the `LdapRepository`
    interface, which basically extends the `CrudRepository` interface, the one that
    we will extend for our custom repository. This interface has all of the required
    methods to perform CRUD operations. This way, by extending the specific repository
    interface, all basic CRUD operations for standard data access will be readily
    available.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Data定义了各种接口，这些接口在`CrudRepository`之上针对每个数据提供者都是特定的。对于LDAP支持，Spring Data提供了`LdapRepository`接口，该接口基本上扩展了`CrudRepository`接口，这是我们将在自定义仓库中扩展的接口。该接口具有执行CRUD操作所需的所有方法。通过扩展特定的仓库接口，所有标准数据访问的基本CRUD操作都将
    readily 可用。
- en: 'Let''s add Spring Data capability to LDAP in our application. The custom repository
    interface will be as follows:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在应用程序中添加Spring Data对LDAP的支持。自定义仓库接口将如下所示：
- en: '[PRE6]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The `@Repository` annotation is used to describe that this is the repository
    interface. The custom interface `LdapAuthRepository` extends the `LdapRepository`
    with the model entity `LdapAuthUser`, which we created in the previous section.
    Upon declaring this interface, Spring Data provides the CRUD implementation that
    we can use in the service class, as follows:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`@Repository`注解来描述这是一个仓库接口。自定义接口`LdapAuthRepository`扩展了`LdapRepository`，其中包含我们在上一节中创建的模型实体`LdapAuthUser`。在声明此接口后，Spring
    Data提供了我们可以在服务类中使用的CRUD实现，如下所示：
- en: '[PRE7]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'In this service class, the object of the `LdapAuthRepository` class is injected
    with the `@Autowired` annotation. It is used to call the CRUD methods, as follows:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在此服务类中，使用`@Autowired`注解注入了`LdapAuthRepository`类的对象。它用于调用CRUD方法，如下所示：
- en: '**CREATE**: The `existsById()` command is used to check whether a user with
    the same ID already exists. The ID is of the type `javax.naming.Name`. The `LdapNameBuilder`
    class is used to build the ID. If a user does not exist, the `save` method is
    called on the `ldapAuthRepository` object, in order to create a fresh object.
    We can call this service method to add the record from the Spring MVC controller.
    We need to create the object of `LdapAuthUser`, set the data, and call the service
    method from the controller method, as follows:'
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**创建**：使用`existsById()`命令来检查是否已存在具有相同ID的用户。ID的类型为`javax.naming.Name`。`LdapNameBuilder`类用于构建ID。如果用户不存在，则会在`ldapAuthRepository`对象上调用`save`方法，以创建一个新的对象。我们可以通过Spring
    MVC控制器调用此服务方法来添加记录。我们需要创建`LdapAuthUser`对象，设置数据，并从控制器方法中调用服务方法，如下所示：'
- en: '[PRE8]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: To create a new user, the object of the model class (`LdapAuthUser`) needs to
    be created first, along with its attribute.
  id: totrans-167
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要创建新用户，首先需要创建模型类（`LdapAuthUser`）的对象及其属性。
- en: Since we are creating a new user, it is required to set `isNew` to `true`, to
    make sure that the Spring Data module considers it a new record. Without doing
    this, the system will throw an error.
  id: totrans-168
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于我们正在创建新用户，需要将`isNew`设置为`true`，以确保Spring Data模块将其视为新记录。如果不这样做，系统将抛出错误。
- en: We also need to set the value of `id`. The `LdapNameBuilder` is used to create
    the object of the type `javax.naming.Name` (`id`). It is also required to add
    values like `uid=kpatel` (`username`) and `ou=users` in `id`.
  id: totrans-169
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们还需要设置`id`的值。`LdapNameBuilder`用于创建`javax.naming.Name`类型的对象（`id`）。在`id`中还需要添加类似`uid=kpatel`（用户名）和`ou=users`的值。
- en: '**READ**:To read the LDAP user with `username`, the `findOne()` method is used.
    We need to pass the LDAP query inside of this method. The `LdapQueryBuilder` class
    is used to create the LDAP query, which matches the `username` against the `uid`.'
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**读取**：要读取具有`username`的LDAP用户，使用`findOne()`方法。我们需要将LDAP查询传递到这个方法中。`LdapQueryBuilder`类用于创建LDAP查询，该查询将`username`与`uid`匹配。'
- en: '**UPDATE**: The update operation is straightforward. The `save` method of `ldapAuthRepository` will
    actually update the LDAP user.'
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**更新**：更新操作很简单。`ldapAuthRepository`的`save`方法实际上会更新LDAP用户。'
- en: '**DELETE**: When deleting a user, first, it is required to check whether the
    user exists. Again, `fineOne` can be used to retrieve the existing user. The `delete`
    operation can only be executed if a user exists.'
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**删除**：在删除用户时，首先需要检查用户是否存在。再次，可以使用`findOne`来检索现有用户。只有当用户存在时，才能执行`delete`操作。'
- en: 'Additionally, we can use the following methods to perform authentication programmatically,
    in the service class, as follows:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们可以使用以下方法在服务类中以编程方式执行身份验证，如下所示：
- en: '[PRE9]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The `authenticateLdapUserWithLdapQuery` and `authenticateLdapUserWithContext`
    are the custom methods defined in the `LdapAuthRepositoryCustomImpl` class, where
    we can define the custom method to interact with LDAP. We will discuss this topic
    further in the next section.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '`authenticateLdapUserWithLdapQuery` 和 `authenticateLdapUserWithContext` 是在
    `LdapAuthRepositoryCustomImpl` 类中定义的自定义方法，其中我们可以定义自定义方法以与 LDAP 交互。我们将在下一节进一步讨论此主题。'
- en: Upon successful authentication, these methods will return `true`; otherwise,
    they will be `false`. We need to pass the password in a plain text format for
    both of these methods. This is how the Spring Data repository is used to perform
    CRUD operations on LDAP users. Alternatively, we can use `LdapTemplate` to perform
    CRUD operations, as well as other complex business functions.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在认证成功后，这些方法将返回 `true`；否则，它们将返回 `false`。我们需要以纯文本格式为这两个方法传递密码。这就是 Spring Data
    仓库如何用于在 LDAP 用户上执行 CRUD 操作。或者，我们也可以使用 `LdapTemplate` 来执行 CRUD 操作，以及其他复杂的业务功能。
- en: Performing CRUD operations with LdapTemplate
  id: totrans-177
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 LdapTemplate 执行 CRUD 操作
- en: The Spring Data repository is a convenient way to interact with the underlying
    data provider, as it is easy to use and requires less code, because the implementation
    is provided by the Spring Data module out of the box. However, this simplicity
    comes with certain limitations. For example, with the repository programming model,
    we only have basic CRUD operations available to use. For more complex business
    needs, we need to extend this and provide our own repository implementation. This
    is where the Template model comes into the picture.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Data 仓库是与底层数据提供者交互的便捷方式，因为它易于使用且代码量少，因为实现是由 Spring Data 模块提供的。然而，这种简单性伴随着某些限制。例如，使用仓库编程模型，我们只有基本的
    CRUD 操作可用。对于更复杂的业务需求，我们需要扩展它并提供自己的仓库实现。这就是模板模型出现的地方。
- en: The template model in the Spring Data module is less handy than repository abstraction,
    but it is more powerful in terms of furnishing more fine-grained control for complex
    operations that we execute on the data store. We will look at the same CRUD operations
    with the Spring Data template model. Of course, the motive is to learn how to
    prepare the Spring Data template so that it can be used for complex business functions.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Data 模块中的模板模型在方便性上不如仓库抽象，但在提供更细粒度控制复杂操作方面更强大。我们将使用 Spring Data 模板模型查看相同的
    CRUD 操作。当然，目的是学习如何准备 Spring Data 模板，以便它可以用于复杂的业务功能。
- en: Initializing LdapTemplate
  id: totrans-180
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 初始化 LdapTemplate
- en: 'Spring Data provides templates for each of the underlying data providers, like
    `JdbcTemplate`, `JpaTemplate`, `MongoTemplate`, `ElasticSearchTemplate`, `CassandraTemplate`,
    and so on. The `LdapTemplate` is the one that is used to communicate with the
    LDAP server. We will first initialize `LdapTemplate`. Add the following methods
    to the `LdapDataConfig` class:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Data 为每个底层数据提供者提供模板，如 `JdbcTemplate`、`JpaTemplate`、`MongoTemplate`、`ElasticSearchTemplate`、`CassandraTemplate`
    等。`LdapTemplate` 是用于与 LDAP 服务器通信的模板。我们首先初始化 `LdapTemplate`。将以下方法添加到 `LdapDataConfig`
    类中：
- en: '[PRE10]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The `getLdapContextSrc()` method first creates an object of `LdapContextSource`
    and initializes it with the LDAP connection parameters that were read from `application.properties`.
    The `@Bean` annotation will export this object as a Spring bean. The second method, `getLdapTemplate()`,
    uses the object of `LdapContextSoruce` and initializes the object of the `LdapTemplate`
    class; then, it is exposed as a Spring bean with `id=ldapTemplate`, with the `@Bean`
    annotation.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '`getLdapContextSrc()` 方法首先创建一个 `LdapContextSource` 对象，并使用从 `application.properties`
    中读取的 LDAP 连接参数对其进行初始化。`@Bean` 注解将此对象导出为一个 Spring bean。第二个方法 `getLdapTemplate()`
    使用 `LdapContextSoruce` 对象，并初始化 `LdapTemplate` 类的对象；然后，它通过 `@Bean` 注解以 `id=ldapTemplate`
    的形式暴露为一个 Spring bean。'
- en: Using LdapTemplate to perform CRUD operations
  id: totrans-184
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 LdapTemplate 执行 CRUD 操作
- en: Now, we have initialized the `LdapTemplate` object. Next, we will use it to
    perform various CRUD operations. We will use `LdapTemplate` in the Spring Data
    repository structure. For this, we need to extend the Spring Data repository model
    and provide a custom implementation.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经初始化了 `LdapTemplate` 对象。接下来，我们将使用它来执行各种 CRUD 操作。我们将在 Spring Data 仓库结构中使用
    `LdapTemplate`。为此，我们需要扩展 Spring Data 仓库模型并提供自定义实现。
- en: 'Create an interface: `LdapAuthRepositoryCustom`. This is a place where we can
    define customized methods that are not directly available with the repository
    abstraction. Update the definition of the `LdapAuthRepository` interface, as follows:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个接口：`LdapAuthRepositoryCustom`。这是一个可以定义自定义方法的地方，这些方法在仓库抽象中不可直接使用。更新`LdapAuthRepository`接口的定义，如下所示：
- en: '[PRE11]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'This is a glue point of the custom implementation with the Spring Data repository
    framework. Finally, define the `LdapAuthRepositoryCustomImpl` class that implements
    the `LdapAuthRepositoryCustom` interface. This is the class where the implementation
    of custom methods are defined, as follows:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 这是自定义实现与Spring Data仓库框架的粘合点。最后，定义`LdapAuthRepositoryCustomImpl`类，该类实现了`LdapAuthRepositoryCustom`接口。这是定义自定义方法的地方，如下所示：
- en: '[PRE12]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The `LdapAuthRepositoryCustomImpl` implements the `LdapAuthRepositoryCustom`
    interface, which is used to declare custom repository methods. This class has
    an instance variable of the type `LdapTemplate`, which is injected with the `@Autowired`
    annotation (created in the `LdapDataConfig` class). Next, we will look at some
    of the methods defined in this class, as follows.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '`LdapAuthRepositoryCustomImpl`实现了`LdapAuthRepositoryCustom`接口，用于声明自定义仓库方法。这个类有一个类型为`LdapTemplate`的实例变量，它通过`@Autowired`注解（在`LdapDataConfig`类中创建）进行注入。接下来，我们将查看这个类中定义的一些方法，如下所示。'
- en: '**CREATE operation:** The following code block describes how the CREATE operation
    is used to add a new LDAP user, with `ldapTemplate`:'
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**创建操作：**以下代码块描述了如何使用`ldapTemplate`通过创建操作添加新的LDAP用户：'
- en: '[PRE13]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The first method is straightforward. It uses `ldapTemplate` to create an LDAP
    user with the model object. We have set `isNew` to `true`, to make sure that there
    will not be any issues while creating the LDAP user. The second method, `createByBindOperation`,
    uses a low-level API to create the LDAP user. The object of `DirContextAdapter`
    is first initialized with various model attributes, like `objectClass`, `cn`,
    `sn`, `uid`, `userPassword`, and `dn`. The `LdapNameBuilder` class is used to
    create the DN of the LDAP user. Finally, the `bind` method of `ldapTemplate` is
    used to create the user. We can use either of these methods to create a user.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 第一种方法很简单。它使用`ldapTemplate`通过模型对象创建LDAP用户。我们已将`isNew`设置为`true`，以确保在创建LDAP用户时不会出现任何问题。第二种方法`createByBindOperation`使用低级API创建LDAP用户。首先初始化`DirContextAdapter`对象，包含各种模型属性，如`objectClass`、`cn`、`sn`、`uid`、`userPassword`和`dn`。使用`LdapNameBuilder`类创建LDAP用户的DN。最后，使用`ldapTemplate`的`bind`方法创建用户。我们可以使用这两种方法中的任何一种来创建用户。
- en: '**READ operation: **The following code block depicts how the READ operation
    is used to fetch the LDAP user, with `ldapTemplate`:'
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**读取操作：**以下代码块展示了如何使用`ldapTemplate`通过读取操作获取LDAP用户：'
- en: '[PRE14]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: These are a few methods that read the user from the LDAP server. The `LdapQueryBuilder`
    is used to construct a query that can be used to perform a search of various attributes,
    such as `uid`, and `surname`. It can also be used to find users with matching
    attributes, with the `like` query.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是一些从LDAP服务器读取用户的方法。`LdapQueryBuilder`用于构建一个查询，可以用于执行对各种属性（如`uid`和`surname`）的搜索。它也可以用于使用`like`查询查找具有匹配属性的用户。
- en: '**UPDATE operation:**The following code block shows how the UPDATE operation
    updates the LDAP user, with `ldapTemplate`:'
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**更新操作：**以下代码块展示了如何使用`ldapTemplate`通过更新操作更新LDAP用户：'
- en: '[PRE15]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The `update` method is straightforward. The `update()` method is used to update
    the LDAP user with the model object.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '`update`方法很简单。`update()`方法用于使用模型对象更新LDAP用户。'
- en: '**DELETE operation:** The following code block describes how the DELETE operation
    is used to delete the LDAP user, with `ldapTemplate`:'
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**删除操作：**以下代码块描述了如何使用`ldapTemplate`通过DELETE操作删除LDAP用户：'
- en: '[PRE16]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The first method is straightforward. It simply calls the `delete` method on
    the `ldapTemplate` object to delete the LDAP user. The second method first creates
    the user DN, and then calls the `unbind` method on `ldapTemplate`, to delete the
    user.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 第一种方法很简单。它只是调用`ldapTemplate`对象上的`delete`方法来删除LDAP用户。第二种方法首先创建用户DN，然后调用`ldapTemplate`上的`unbind`方法来删除用户。
- en: The `delete` method on `ldapTemplate` simply calls the `unbind` method with
    a null check on the given entity. So, both of the methods, `delete()` and `unbind()`,
    are ultimately doing the same thing.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 在`ldapTemplate`上的`delete`方法简单地调用`unbind`方法，并对给定的实体进行空检查。因此，`delete()`和`unbind()`这两个方法最终都在做同样的事情。
- en: 'In addition to the basic CRUD operations, we can perform some other operations
    with `ldapTemplate`, as follows:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 除了基本的CRUD操作外，我们还可以使用`ldapTemplate`执行一些其他操作，如下所示：
- en: '[PRE17]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The first method calls the `authenticate` method on the `ldapTemplate` by passing
    the `LdapQuery` and `password`. The `LdapQueryBuilder` is used to create the LDAP
    query for the given username. The second method calls `getContextSource().getContet()`
    on the `ldapTemplate` object by passing the user DN and password. The context
    is required to be closed at the end. The user DN is obtained for a given `userName`
    with the `getDnForUser()` method, as follows:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个方法通过传递`LdapQuery`和密码在`ldapTemplate`上调用`authenticate`方法。使用`LdapQueryBuilder`为给定用户名创建LDAP查询。第二个方法通过传递用户DN和密码在`ldapTemplate`对象上调用`getContextSource().getContet()`。上下文在结束时需要关闭。使用`getDnForUser()`方法根据给定的`userName`获取用户DN，如下所示：
- en: '[PRE18]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The `search` method of `ldapTemplate` is called by passing `LdapQuery` and an
    implementation of `ContextMapper`, and finally, it returns a user DN (for example, `uid=npatel`,
    `ou=users`, `o=packtPublisher`) for the given username.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '`ldapTemplate`的`search`方法通过传递`LdapQuery`和`ContextMapper`的实现来调用，并最终返回给定用户名的用户DN（例如，`uid=npatel`，`ou=users`，`o=packtPublisher`）。'
- en: LDAP authorization with Spring Security
  id: totrans-209
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Spring Security的LDAP授权
- en: You saw LDAP authentication with Spring Security in the previous section. Next,
    we will look at how to perform authorization. Let's recall that **authorization**
    is a verification process of whether an entity should have access to something.
    In short, authorization concerns the rules that will identify who is allowed to
    do what. After successful authentication, a user can perform various actions,
    based on the authority they have.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 您在上一节中看到了使用Spring Security的LDAP身份验证。接下来，我们将探讨如何执行授权。让我们回顾一下，**授权**是一个验证过程，以确定实体是否应该有权访问某些内容。简而言之，授权涉及将确定谁被允许做什么的规则。在身份验证成功后，用户可以根据他们拥有的权限执行各种操作。
- en: Let's recall that authentication deals with login credentials to verify valid
    users. Authorization is more of a check of whether a user has the authority to
    perform various actions, like adding, updating, viewing, or deleting a resource. An
    authorization happens after the user has been successfully authenticated. In this
    section, we will look at how to authorize an LDAP user.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾一下，身份验证处理登录凭证以验证有效用户。授权更多的是检查用户是否有权执行各种操作，如添加、更新、查看或删除资源。授权发生在用户成功认证之后。在本节中，我们将探讨如何授权LDAP用户。
- en: So far, you have seen that the user's details are maintained at the LDAP server,
    which is used by Spring Security to perform authentication. Similarly, we will
    set up authorization details in the LDAP server and fetch them in Spring Security
    to achieve authorization.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，您已经看到用户详情是在LDAP服务器中维护的，Spring Security使用它来进行身份验证。同样，我们将在LDAP服务器中设置授权详情，并在Spring
    Security中获取它们以实现授权。
- en: Creating roles in the LDAP server
  id: totrans-213
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在LDAP服务器中创建角色
- en: 'As you saw in the previous section, we have created the `users` entity (`ou=users`)
    under the root entity (`o=packtPublisher`), and have kept all users under that
    entity in the LDAP server. Similarly, to store authorization information, we will
    create a new entity directly under the root entity in Apache DS, with the following
    steps:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 如您在上一节中看到的，我们在根实体`o=packtPublisher`下创建了`users`实体（`ou=users`），并将所有用户都保存在该实体下，在LDAP服务器中。同样，为了存储授权信息，我们将在Apache
    DS中直接在根实体下创建一个新的实体，步骤如下：
- en: Right-click on the partition `o=packtPublisher` and select New | New Entryfrom
    the LDAP Browser window.
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在LDAP浏览器窗口中，右键单击分区`o=packtPublisher`并选择New | New Entry。
- en: Choose the option Create entry from scratch and click on the Next button.
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择从零开始创建条目并点击Next按钮。
- en: We are going to add an entity type organization unit, so choose the organizationalUnit
    object class and click on the Nextbutton.
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将添加一个实体类型组织单元，因此选择organizationalUnit对象类并点击Next按钮。
- en: We will use `ou` (organizational unit) as the RDN and roles as its value. The
    DN is automatically calculated when we give the value of the RDN. You can use
    more than one attribute (or the same attribute multiple times, with different
    values) for the RDN. The DN will then be calculated by appending each of them
    with a comma.
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将使用`ou`（组织单元）作为RDN，并将角色作为其值。当我们给出RDN的值时，DN会自动计算。您可以为RDN使用多个属性（或相同的属性多次，具有不同的值）。然后，DN将通过在每个属性后附加逗号来计算。
- en: Click on the Next button, followed by the Finish button, and the entry `ou=roles` will
    be added under `o=packtPublisher`. The updated structure will be visible in the LDAP
    Browser window.
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击“下一步”按钮，然后点击“完成”按钮，`ou=roles` 将被添加到 `o=packtPublisher` 之下。更新后的结构将在 LDAP 浏览器窗口中可见。
- en: 'Next, we will add the actual role entries under the `ou=roles` entry. The steps
    are as follows:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将在 `ou=roles` 条目下添加实际的角色条目。步骤如下：
- en: Right-click on the roles entity (`ou=roles`) and select* New | New Entry*.
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在角色实体（`ou=roles`）上右键单击，并选择*“新建 | 新条目”*。
- en: Choose the option Create entry from scratch and click on Next*.*
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择“从头创建条目”选项，然后点击“下一步”*.*。
- en: To add a role, choose `groupOfNames` as the object class that represents a role.
    Click on the Next button.
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要添加一个角色，选择表示角色的对象类 `groupOfNames`。点击“下一步”按钮。
- en: We are going to add a role, so we will use the attribute `cn` (common name)
    as the RDN. Just give the value as `ADMIN`. At this moment, the DN is calculated
    as `cn=ADMIN`, `ou=roles`, `o=packtPublisher`. Click on the Next button.
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将添加一个角色，因此我们将使用属性 `cn`（通用名称）作为 RDN。只需将值设置为 `ADMIN`。此时，DN 被计算为 `cn=ADMIN`,
    `ou=roles`, `o=packtPublisher`。点击“下一步”按钮。
- en: Since this entity has `groupOfNames` as the object class, the system will ask
    for the member assignment in the next window.
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于此实体具有 `groupOfNames` 作为对象类，系统将在下一个窗口中要求进行成员分配。
- en: Click on the Browse button and choose the user that you want to assign this
    role, under the `o=packtPublisher` entry. Click on the OK button.
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击“浏览”按钮，并在 `o=packtPublisher` 条目下选择您想要分配此角色的用户。点击“确定”按钮。
- en: 'The following are the steps for assigning multiple members in the given role:'
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下是在给定角色中分配多个成员的步骤：
- en: Select any of the role entries from the LDAP Browser window. Right-click in
    the middle section (where the details of the selected role are visible a tabular
    format) and choose New Attribute.
  id: totrans-228
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 LDAP 浏览器窗口中选择任何角色条目。在中间部分（所选角色的详细信息以表格格式可见）右键单击，并选择“新建属性”。
- en: Give the value of Attribute type as `member`, click on Next*,* and click on
    the Finish button; you will see the same window for selecting the user to assign
    to this role.
  id: totrans-229
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将属性类型值设为 `member`，点击“下一步”*.*，然后点击“完成”按钮；您将看到用于选择分配此角色的用户的相同窗口。
- en: 'Execute these steps and create the following two roles under the roles entry:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 执行这些步骤，并在角色条目下创建以下两个角色：
- en: '`ADMIN`'
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ADMIN`'
- en: '`USER`'
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`USER`'
- en: The role structure has been created in Apache DS. We will now import these details
    to perform authorization.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 角色结构已在 Apache DS 中创建。现在我们将导入这些详细信息以执行授权。
- en: Importing role information to perform authorization
  id: totrans-234
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将角色信息导入以执行授权
- en: In the *Example DIT structures* section of this chapter, we created a role entity
    (`ou=roles`) under the root entity (`o=packtPublisher`). The role entity contains
    various roles as its child entities. We will look at how to use these roles to
    perform authorization with Spring Security. We have already configured Spring
    Security to perform authentication with LDAP. We will now add two sample pages,
    and configure it so that one page is only accessible by a user with the `ADMIN`
    role, and the other is accessible by a user with either the `USER` or `ADMIN`
    role.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的“*示例 DIT 结构*”部分，我们在根实体（`o=packtPublisher`）下创建了一个角色实体（`ou=roles`）。该角色实体包含各种子实体作为其角色。我们将探讨如何使用这些角色通过
    Spring Security 进行授权。我们已配置 Spring Security 使用 LDAP 进行认证。现在我们将添加两个示例页面，并配置它们，使得一个页面只能由具有
    `ADMIN` 角色的用户访问，而另一个页面则由具有 `USER` 或 `ADMIN` 角色的用户访问。
- en: 'To achieve this, the changes need to be done in the `configure` method of the `WebSecurityConfig`
    class that we created for Spring Security configuration. The updated method should
    look as follows:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 要实现这一点，需要在为 Spring Security 配置创建的 `WebSecurityConfig` 类的 `configure` 方法中进行更改。更新后的方法应如下所示：
- en: '[PRE19]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: We have added an admin page (with the URL `/adminPage/`) and a user page (with
    the URL `/usePage/`), and have configured them so that they can be accessed by
    a user with the `ADMIN` and `USER` role, respectively.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已添加了一个管理员页面（URL 为 `/adminPage/`）和一个用户页面（URL 为 `/usePage/`），并已配置它们，以便分别由具有
    `ADMIN` 和 `USER` 角色的用户访问。
- en: Additionally, we need to create respective Thymeleaf templates under the `src/main/resources/templates`
    folder and entries for both of these pages in the Spring MVC controller class,
    and update the menu structure (defined in the header template) to accommodate
    these pages. The full details are mentioned in the source code, which is available
    in GitHub ([https://github.com/PacktPublishing/Spring-5.0-Projects](https://github.com/PacktPublishing/Spring-5.0-Projects)).
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们还需要在`src/main/resources/templates`文件夹下创建相应的Thymeleaf模板，并在Spring MVC控制器类中为这两个页面创建条目，并更新菜单结构（在页眉模板中定义），以容纳这些页面。详细内容在源代码中有所说明，源代码可在GitHub上找到（[https://github.com/PacktPublishing/Spring-5.0-Projects](https://github.com/PacktPublishing/Spring-5.0-Projects)）。
- en: 'Next, we will update the `configure` method that represents the LDAP configuration
    with Spring Security. This method takes an object of the type `AuthenticationManagerBuilder`.
    After making the required changes, this method will look as follows:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将更新代表LDAP配置的`configure`方法，使用Spring Security。此方法接受一个类型为`AuthenticationManagerBuilder`的对象。在做出必要的更改后，此方法将如下所示：
- en: '[PRE20]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The following are the changes that we made for authorization:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是我们在授权方面所做的更改：
- en: Added the `groupSearchBase` method call and passed the value as `ou=roles`,
    which represents the base for group search. The group search base value (`ou=roles`)
    is stored in an `ldapAuthStructure` object that we created to hold LDAP connection
    properties.
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加了`groupSearchBase`方法调用，并将值传递为`ou=roles`，这代表组搜索的基础。组搜索基础值（`ou=roles`）存储在我们创建的用于保存LDAP连接属性的`ldapAuthStructure`对象中。
- en: Added a `groupSearchFilter` method call and passed the value as `member={0}`.
    It is used to define the pattern to search the members. The `{0}` will be substituted
    by the actual user DN at runtime.
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加了一个`groupSearchFilter`方法调用，并将值传递为`member={0}`。它用于定义搜索成员的模式。`{0}`将在运行时被实际的用户DN所替换。
- en: The additional method `rolePrefix("")` is placed to set the role prefix. In
    absence of this method call, the role name will be prepended with `ROLE_` by Spring
    Security. As an example, for the role `ADMIN` defined in the LDAP server, the
    actual role return by Spring Security would be `ROLE_ADMIN`. To avoid this, we
    call this method and simply pass an empty string, so that we get the exact role
    name that we defined in the LDAP server.
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将额外的`rolePrefix("")`方法放置以设置角色前缀。如果没有这个方法调用，Spring Security将使用`ROLE_`前缀来添加角色名称。例如，对于在LDAP服务器中定义的`ADMIN`角色，Spring
    Security实际返回的角色将是`ROLE_ADMIN`。为了避免这种情况，我们调用此方法并简单地传递一个空字符串，这样我们就可以得到在LDAP服务器中定义的确切角色名称。
- en: The configuration part of the authorization is over. You can create some sample
    users in Apache DS, assign them roles, and check whether they are able to access
    the pages that we have created. A user that does not have any role cannot access
    any of the pages (admin or user).
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 授权配置部分已经完成。你可以在Apache DS中创建一些示例用户，分配给他们角色，并检查他们是否能够访问我们创建的页面。没有任何角色的用户无法访问任何页面（无论是管理员页面还是用户页面）。
- en: This was all about the integration of LDAP using Spring Security. In the next
    section, we will look at OAuth integration.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是使用Spring Security集成LDAP的全部内容。在下一节中，我们将探讨OAuth集成。
- en: OAuth
  id: totrans-248
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: OAuth
- en: A typical web application requires credentials, in the form of a username/password,
    to perform authentication. The HTML form is used to ask for credentials in the
    browser, and then send them to the server. The server then authenticates the information,
    creates and maintains a session at the server side, and sends the session ID back
    to the browser.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 一个典型的Web应用程序需要凭证，以用户名/密码的形式进行身份验证。HTML表单用于在浏览器中请求凭证，然后将它们发送到服务器。服务器随后验证信息，在服务器端创建并维护一个会话，并将会话ID发送回浏览器。
- en: The session ID will be sent in each request, and the server will map the session
    with the session ID and pull certain information from the database to perform
    authorization. The browser generally stores the session ID in cookies. As long
    as the session is active, a user can access the restricted resources, based on
    the authorities assigned.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 会话ID将在每个请求中发送，服务器将根据会话ID将会话与信息进行映射，并从数据库中提取某些信息以执行授权。浏览器通常将会话ID存储在cookies中。只要会话处于活动状态，用户就可以根据分配的权限访问受限制的资源。
- en: 'This is a quite simple and easy mechanism for client-server interaction, and
    hence, it is still used by many web applications and services today. However,
    there are certain limitations to this model, as follows:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个相当简单且易于客户端-服务器交互的机制，因此，它至今仍被许多Web应用程序和服务所使用。然而，这种模型存在某些局限性，如下所述：
- en: Generally, the cookies are stateful, so the server needs to keep track of the
    session and check with the database (or in the memory) for every request. This
    may lead to overhead on the server. Additionally, the authorization process is
    closely associated with the application server, which results in a tightly coupled
    system.
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通常，cookie是有状态的，因此服务器需要跟踪会话并在每次请求时与数据库（或在内存中）进行核对。这可能导致服务器上的开销。此外，授权过程与应用服务器紧密相关，导致系统紧密耦合。
- en: For REST clients, like a native mobile app, cookies may not work properly.
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于REST客户端，如原生移动应用，cookie可能无法正常工作。
- en: If the application functionality is spread across multiple domains, additional
    configuration may be required to maintain the cookie value.
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果应用功能分布在多个域中，可能需要额外的配置来维护cookie值。
- en: The cookie-based model has the limitation of granting third-party client access.
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于cookie的模型存在授予第三方客户端访问权限的限制。
- en: '**OAuth** overcomes these restrictions. By definition, it is an authorization
    framework (or protocol, more precisely), allowing for the application to access
    resources within the same or different applications. In other words, OAuth 2.0
    allows limited access to protected resources to a third-party application, on
    behalf of a resource owner. It supports authorization flows for mobile, web, and
    desktop applications. The current version of this protocol is OAuth 2.0\. We will
    integrate OAuth 2.0 with Spring Security.'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: '**OAuth**克服了这些限制。根据定义，它是一个授权框架（或更精确地说，是一个协议），允许应用访问同一或不同应用内的资源。换句话说，OAuth 2.0允许第三方应用代表资源所有者有限地访问受保护资源。它支持移动、Web和桌面应用的授权流程。当前该协议的版本是OAuth
    2.0。我们将OAuth 2.0与Spring Security集成。'
- en: Even though OAuth has certain characteristics that are not available with a
    normal client-server mechanism with the session, the former cannot replace the
    latter. For example, a banking application must be implemented with a client-server
    mechanism. The comparison given here is to showcase how OAuth can be used to provide
    access to third-party applications.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管OAuth具有某些与带有会话的正常客户端-服务器机制不同的特性，但前者不能取代后者。例如，银行应用必须使用客户端-服务器机制来实现。这里给出的比较是为了展示OAuth如何被用来提供对第三方应用的访问。
- en: OAuth roles
  id: totrans-258
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: OAuth角色
- en: 'Before moving further, it is important that you understand certain terminologies
    used in OAuth. This will provide a profound understanding of its underlying concepts.
    They are referred to as OAuth roles, as follows:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前，了解OAuth中使用的某些术语非常重要。这将提供对其底层概念的深刻理解。它们被称为OAuth角色，如下所示：
- en: '**Resource owner:** A person or entity that can grant access to protected resources.
    The OAuth protocol is not limited to a person. An application to application interaction
    can happen with OAuth. If the resource owner is a person (or user), it is called
    an end user.'
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**资源所有者**：可以授予受保护资源访问权限的个人或实体。OAuth协议不仅限于个人。应用与应用之间的交互可以通过OAuth进行。如果资源所有者是个人（或用户），则称为最终用户。'
- en: '**Authorization server: **As its name suggests, it is an entity that provides
    authorization, in the form of a token. After the resource owner is authenticated
    successfully, the authorization server will issue an access token to a client.'
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**授权服务器**：正如其名所示，它是一个提供授权的实体，形式为令牌。在资源所有者成功认证后，授权服务器将向客户端颁发访问令牌。'
- en: '**Resource server: **This is the server that holds the protected resources.
    When a request for a protected resource comes to the resource server, it will
    verify the access token with the authorization server and respond accordingly.'
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**资源服务器**：这是持有受保护资源的服务器。当请求受保护资源的请求到达资源服务器时，它将使用授权服务器验证访问令牌并相应地做出响应。'
- en: '**Client: **An entity that initiates the request to access the protected resource
    in support of a resource owner is called a **client**. It can be in any form,
    like a mobile application asking for credentials or a web-based application that
    provides an alternate login functionality with social media (like Facebook or
    Google).'
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**客户端**：发起请求以支持资源所有者访问受保护资源的实体称为**客户端**。它可以以任何形式存在，如请求凭证的移动应用或提供社交媒体（如Facebook或Google）替代登录功能的基于Web的应用。'
- en: 'The relationships between these roles is illustrated in the following diagram:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 这些角色之间的关系在以下图中展示：
- en: '![](img/4449129b-3238-4c98-a1ce-eea5fec9ee78.png)'
  id: totrans-265
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/4449129b-3238-4c98-a1ce-eea5fec9ee78.png)'
- en: The end user, who is the Resource owner, interacts with an application, which
    acts as a Client here. The Client will talk to the Authorization server. The Resource
    owner provides credentials, and it will be authenticated at the Authorization
    server first. Upon successful identification, the Authorization server issues
    an access token, which is used by the Client to access the secure resources on
    the Resource server, in support of the Resource owner. The Authorization server is
    also known as an **identity provider**.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 最终用户，即资源所有者，与一个充当客户端的应用程序进行交互。在这里，客户端将与授权服务器通信。资源所有者提供凭证，并在授权服务器首先进行认证。成功识别后，授权服务器会发放一个访问令牌，该令牌由客户端用于访问资源服务器上的受保护资源，以支持资源所有者。授权服务器也被称为**身份提供者**。
- en: Let's look at the process of authorization in OAuth with a real-life scenario.
    Suppose that John has a car with a smart key. Nowadays, a vehicle with a smart
    key is common, wherein the vehicle cannot be operated (not even unlocked or started)
    without a smart key in your pocket. John has asked his friend Charles to pick
    him up from the airport. He already has already given him a smart key. Charles
    uses the smart key and starts the car.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一个现实生活中的场景来了解OAuth中的授权过程。假设约翰有一辆带有智能钥匙的汽车。如今，带有智能钥匙的汽车很常见，没有智能钥匙在口袋里，车辆无法操作（甚至无法解锁或启动）。约翰已经让他的朋友查尔斯去机场接他。他已经给了他一个智能钥匙。查尔斯使用智能钥匙启动了汽车。
- en: In this analogy, the smart key gives Charles the authorization to operate John's
    car, as authorization involves the resources a user has access to, and what it
    can do with those resources. John, in this case, is the end user (Resource owner),
    whereas Charles is a Client. The smart key is an access token, whereas the car's
    security system can be considered an Authorization server (or identity provider)
    who authorizes Charles (Client) with a smart key (access token). The whole car
    is the Resource server (Charles can use other features of the car, like the AC,
    music system, and so on, as he is authorized to use the car with the access token
    (smart key)).
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个类比中，智能钥匙赋予查尔斯操作约翰汽车的授权，因为授权涉及用户可以访问的资源以及他们可以对这些资源做什么。在这种情况下，约翰是最终用户（资源所有者），而查尔斯是客户端。智能钥匙是访问令牌，而汽车的安保系统可以被视为授权服务器（或身份提供者），它通过智能钥匙（访问令牌）授权查尔斯（客户端）。整个汽车是资源服务器（查尔斯可以使用汽车的其它功能，如空调、音响系统等，因为他有权使用带有访问令牌（智能钥匙）的汽车）。
- en: Grant types
  id: totrans-269
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 授权类型
- en: The crux of the OAuth protocol is to provide access tokens for authorization.
    The way of retrieving the access token is called a **grant**. There are various
    ways (grants) to access and use the access token. OAuth 2.0 provides different
    grants for different scenarios, like the level of trust for the application, the
    type of the application, and so on.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: OAuth协议的核心是提供访问令牌进行授权。获取访问令牌的方式被称为**授权类型**。有各种方式（授权类型）来访问和使用访问令牌。OAuth 2.0为不同的场景提供不同的授权类型，如应用程序的信任级别、应用程序类型等。
- en: 'OAuth 2.0 supports the following types of grants. Selecting the one that best
    fits an application depends on the type of that application:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: OAuth 2.0支持以下类型的授权。选择最适合应用程序的类型取决于该应用程序的类型：
- en: Authorization code
  id: totrans-272
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 授权码
- en: Implicit
  id: totrans-273
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 隐式
- en: Resource Owner Password Credentials
  id: totrans-274
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 资源所有者密码凭证
- en: Client Credentials
  id: totrans-275
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 客户端凭证
- en: 'Let''s look at each of these grant types in detail: how they work, and into
    which situations they fit best.'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们详细看看每种授权类型：它们是如何工作的，以及它们最适合哪些情况。
- en: Authorization code
  id: totrans-277
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 授权码
- en: Being the most commonly and widely used, the authorization code grant is the
    best fit for server-side applications. The **Client** would be a web application.
    To make sure that the **Client** interacts with the **Authorization Server** properly,
    it is required to configure certain connection parameters, like the *Client ID* and
    *Client Secret, *with the **Client**. Since the **Client** is a web application,
    these parameters can be maintained secretly.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 作为最常用和最广泛使用的授权类型，授权码授权最适合服务器端应用程序。客户端将是一个Web应用程序。为了确保客户端与授权服务器正确交互，需要配置某些连接参数，如*客户端ID*和*客户端密钥*，与客户端一起。由于客户端是Web应用程序，这些参数可以保密地维护。
- en: 'In this grant type, a **Client** must be able to collaborate with a **User
    Agent (Browser)**, because the authorization code is routed through the browser.
    The process of obtaining an access token for an authorization code grant can be
    described with the following diagram. Since the **Resource Owner** is authenticated
    at the **Authorization Server**, its credentials will not be shared with the **Client**:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种授权类型中，**客户端**必须能够与**用户代理（浏览器**）协作，因为授权码是通过浏览器路由的。授权码授权获取访问令牌的过程可以用以下图表描述。由于**资源所有者**在**授权服务器**上进行了身份验证，其凭证将不会与**客户端**共享：
- en: '![](img/ee105b78-23eb-48c0-a39d-4b34868c9461.png)'
  id: totrans-280
  prefs: []
  type: TYPE_IMG
  zh: '![图片描述](img/ee105b78-23eb-48c0-a39d-4b34868c9461.png)'
- en: 'In this grant type, the access token is obtained through the following steps:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 在此授权类型中，访问令牌是通过以下步骤获得的：
- en: The **Client** is configured to establish a connection to the authorization
    server. It will open the link in the **User Agent (Browser)**. This link contains
    other information, which will be used by the authorization server to identify
    and respond back to the **Client**. Generally, the link opens in a separate window,
    and it contains a login form to authenticate a user as the first step towards
    authorization.
  id: totrans-282
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**客户端**被配置为与授权服务器建立连接。它将在**用户代理（浏览器**）中打开链接。此链接包含其他信息，这些信息将被授权服务器用于识别并回应**客户端**。通常，链接将在新窗口中打开，并包含一个登录表单，作为授权的第一步来验证用户。'
- en: A user (**Resource Owner**) then enters the credentials, in the form of a username
    and password.
  id: totrans-283
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，用户（**资源所有者**）以用户名和密码的形式输入凭证。
- en: The browser (**User Agent**) then sends these credentials to the **Authorization
    Server**.
  id: totrans-284
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 浏览器（**用户代理**）然后将这些凭证发送到**授权服务器**。
- en: The **Authorization Server** verifies the credentials and sends the response
    back to the **Client** with the authorization code.
  id: totrans-285
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**授权服务器**验证凭证，并将带有授权码的响应发送回**客户端**。'
- en: Upon receiving the authorization code, the **Client** will exchange it with
    the **Authorization Server** to get an access token, and optionally, a refresh
    token.
  id: totrans-286
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在收到授权码后，**客户端**将与之交换以从**授权服务器**获取访问令牌，以及可选的刷新令牌。
- en: After getting an access token, the **Client** can talk to the **Resource Server**
    to get protected resources.
  id: totrans-287
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取访问令牌后，**客户端**可以与**资源服务器**通信以获取受保护资源。
- en: The authorization code flow can be used with web and mobile app clients. Generally,
    web app clients use *Client ID* and *Client Secret,* while mobile app clients
    use the **Proof Key for Code Exchange (PKCE)** mechanism and utilize code challenges
    and code verifiers.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 授权码流可以与Web和移动应用客户端一起使用。通常，Web应用客户端使用*客户端ID*和*客户端密钥*，而移动应用客户端使用**证明密钥用于代码交换（PKCE**）机制，并利用代码挑战和代码验证器。
- en: Implicit
  id: totrans-289
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 隐式
- en: The implicit grant type was designed specifically for single-page JavaScript
    applications running in the browser. It is most similar to the authorization code
    flow. The only difference is in the process of exchanging the authorization code.
    In the implicit grant type, a client will not receive an authorization code from
    the **Authorization Server**, in contrast with the authorization code grant type,
    due to security reasons.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 隐式授权类型是专门为在浏览器中运行的单一页面JavaScript应用程序设计的。它与授权码流最相似。唯一的区别在于授权码交换的过程。在隐式授权类型中，客户端不会从**授权服务器**接收授权码，与授权码授权类型不同，这是出于安全原因。
- en: Alternatively, once a **User Agent** successfully sends the credentials, the
    **Authorization Server** issues an access token directly to the **Client**. Since
    the implicit flow is targeted at single-page JavaScript applications, the refresh
    token is also not allowed. The whole process is described in the following diagram.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，一旦**用户代理**成功发送凭证，**授权服务器**将直接向**客户端**颁发访问令牌。由于隐式流针对的是单一页面JavaScript应用程序，因此也不允许刷新令牌。整个过程在以下图表中描述。
- en: 'Since the **Authorization Server** directly issues an access token, the round-trip
    of the request-response between the **Client** and **Authorization Server** is
    reduced, as compare to the authorization code flow:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 由于**授权服务器**直接颁发访问令牌，因此与**客户端**和**授权服务器**之间的请求-响应往返次数减少，与授权码流相比：
- en: '![](img/9910f850-7806-4a80-9137-05a4462f6891.png)'
  id: totrans-293
  prefs: []
  type: TYPE_IMG
  zh: '![图片描述](img/9910f850-7806-4a80-9137-05a4462f6891.png)'
- en: 'This process happens in the following sequence:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 此过程按照以下顺序发生：
- en: The Client will open the link in a separate window in the User Agent (browser),
    which contains a login form to authenticate a user as a first step towards authorization.
  id: totrans-295
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**客户端**将在用户代理（浏览器）中打开一个新窗口，其中包含一个登录表单，以验证用户身份作为授权的第一步。'
- en: A user (Resource Owner) then enters the credentials, in the form of a username
    and password.
  id: totrans-296
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，用户（资源所有者）以用户名和密码的形式输入凭证。
- en: The browser (User Agent) then sends these credentials to the Authorization Server.
  id: totrans-297
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 浏览器（用户代理）然后将这些凭证发送到授权服务器。
- en: The Authorization Server verifies the credentials and sends the access token
    directly to the Client.
  id: totrans-298
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**授权服务器**验证凭证，并将访问令牌直接发送给**客户端**。'
- en: After getting the access token, the Client can talk to the Resource Server to
    get protected resources.
  id: totrans-299
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在获得访问令牌后，**客户端**可以与资源服务器交谈以获取受保护的资源。
- en: Resource Owner Password Credentials
  id: totrans-300
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 资源所有者密码凭证
- en: 'The Resource Owner Password Credentials grant type should be used for a highly
    trusted client, because it handles the user credentials directly. In other words,
    this grant type should only be used when there is plenty of certainty and faith
    between the **Resource owner** and the **Client**. Mostly, the client will be
    a first-party application. The credentials will be used by the **Client** directly,
    to interact with the **Authorization Server** and get an access token. The flow
    can be described with the following diagram:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 资源所有者密码凭证授权类型应用于高度受信任的客户端，因为它直接处理用户凭证。换句话说，此授权类型仅在**资源所有者**和**客户端**之间有大量确定性时才应使用。通常，客户端将是一个第一方应用程序。凭证将由**客户端**直接使用，以与**授权服务器**交互并获得访问令牌。流程可以用以下图示描述：
- en: '![](img/54da154e-3463-4a25-94b1-ca3c42307b4c.png)'
  id: totrans-302
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/54da154e-3463-4a25-94b1-ca3c42307b4c.png)'
- en: 'This flow can be described as follows:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 此流程可以描述如下：
- en: The **Client** is highly trusted, so it will directly ask the **Resource Owner**
    to provide credentials. The **Client** could be a highly indulged application.
  id: totrans-304
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**客户端**高度受信任，因此它将直接要求**资源所有者**提供凭证。**客户端**可能是一个高度宠爱的应用程序。'
- en: The credentials will be sent by the **Client** to the **Authorization Server**.
    The **Client** will also send its own identity to the **Authorization Server**.
    In response, the **Authorization Server** will send back the access token, and
    optionally, a refresh token.
  id: totrans-305
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 凭证将由**客户端**发送到**授权服务器**。**客户端**还将向**授权服务器**发送其自己的身份。作为回应，**授权服务器**将发送访问令牌，以及可选的刷新令牌。
- en: The access token is used by the client to access the protected resources of
    the **Resource Server**.
  id: totrans-306
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 客户端使用访问令牌来访问**资源服务器**受保护的资源。
- en: Client Credentials
  id: totrans-307
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 客户端凭证
- en: 'The Client Credentials grant type is similar to the Resource Owner Password
    Credentials flow. In the Client Credentials grant, the **Client** interacts with
    the **Authorization Server**, provides the identification by sending the Client
    ID and Client Secrets, and gets the access token. Once the access token is received,
    the **Client** will interact with the **Resource Server**. In this case, a refresh
    token should not be used. The process flow is illustrated by the following diagram:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端凭证授权类型与资源所有者密码凭证流程类似。在客户端凭证授权中，**客户端**与**授权服务器**交互，通过发送客户端ID和客户端密钥来提供识别，并获得访问令牌。一旦收到访问令牌，**客户端**将与**资源服务器**交互。在这种情况下，不应使用刷新令牌。流程图如下所示：
- en: '![](img/c04d5470-6da0-402c-b287-ad9c20a87106.png)'
  id: totrans-309
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/c04d5470-6da0-402c-b287-ad9c20a87106.png)'
- en: The Client ID and Client Secrets are configured with the **Client**. The **Client**
    will interact with the **Authorization Server** to get an access token.
  id: totrans-310
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**客户端ID**和**客户端密钥**与**客户端**配置。**客户端**将与**授权服务器**交互以获取访问令牌。'
- en: After getting the access token, the **Client** can interact with the **Resource
    Server** to access protected resources.
  id: totrans-311
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在获得访问令牌后，**客户端**可以与**资源服务器**交互以访问受保护的资源。
- en: Which grant type should be used?
  id: totrans-312
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 应使用哪种授权类型？
- en: Having seen the details about each grant type, it is important to understand
    the right grant type for a given application. There are various factors that play
    a vital role in grant type selection, like end user identification, the type of
    client (server-side, web-based, native, client-side), and the level of assurance
    between the client and resource owner.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 在了解了每种授权类型的详细信息后，了解给定应用程序的正确授权类型非常重要。在授权类型选择中起着关键作用的因素有很多，例如最终用户识别、客户端类型（服务器端、基于Web、本地、客户端）以及客户端和资源所有者之间的保证水平。
- en: If we are planning to build an app and allow for the access of resources to
    other third-party apps, then the authorization code flow is the right choice.
    It is a highly recommended grant type for a publicly hosted application. On the
    other hand, if a client is JavaScript-based and runs in a browser, we should go
    with the implicit grant type for a third-party client, and the resource owner
    password credentials grant for a first-party client.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们计划构建一个应用程序并允许其他第三方应用程序访问资源，那么授权码流是正确的选择。它是公开托管应用程序高度推荐的一种授权类型。另一方面，如果客户端是基于JavaScript并在浏览器中运行，我们应该为第三方客户端选择隐式授权类型，而对于第一方客户端，则应使用资源所有者密码凭证授权。
- en: If a client is a native (mobile) application, we can select the resource owner
    password credentials grant type. If the resource owner does not need the identity
    of the end user and the client itself behaves like a resource owner, we should
    use the client credentials grant type. Typically, a client credentialsgrant is
    used where the machine (and not a user) needs the authorization to access protected
    resources, and user permission is not required.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 如果客户端是本地（移动）应用程序，我们可以选择资源所有者密码凭证授权类型。如果资源所有者不需要最终用户的身份，并且客户端本身表现得像资源所有者，我们应该使用客户端凭证授权类型。通常，客户端凭证授权用于机器（而不是用户）需要授权访问受保护资源，且不需要用户权限。
- en: Spring Security integration with OAuth
  id: totrans-316
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Spring Security与OAuth集成
- en: Having seen the basic fundamentals of what OAuth 2.0 is and how it works, we
    will now look at the integration of OAuth in Spring Security. We will continue
    to work with the same application that we created for LDAP, and will make the
    necessary changes for OAuth integration.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 在了解了OAuth 2.0的基本原理及其工作方式之后，我们现在将探讨OAuth在Spring Security中的集成。我们将继续使用为LDAP创建的相同应用程序，并对其进行必要的更改以实现OAuth集成。
- en: For the OAuth demonstration, we will use readily available authorization providers.
    Spring Security supports Google, Facebook, Okta, and GitHub providers out of the
    box. Choosing one of them would only require certain configurations, and things
    would start to work. We will select Google as an authorization server (provider)
    to build OAuth for our application. The grant type that we will use in this integration
    is authorization code.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 对于OAuth演示，我们将使用现成的授权提供程序。Spring Security默认支持Google、Facebook、Okta和GitHub提供程序。选择其中之一只需要进行某些配置，然后一切就会开始工作。我们将选择Google作为授权服务器（提供程序）来为我们构建OAuth。在这个集成中，我们将使用授权码作为授权类型。
- en: Every authorization provider supports some sort of mechanism that enables the
    clients to establish a connection with the service. This process is known as **application
    registration**.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 每个授权提供程序都支持某种机制，允许客户端与服务建立连接。这个过程被称为**应用注册**。
- en: Application registration
  id: totrans-320
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 应用注册
- en: 'Let''s register (or create) an application at Google, which provides connection
    access to use the authorization service. This is an essential step before start
    to implement OAuth. Google provides an **API console** to register an application.
    A valid Google account is required to access the API console. Go to [https://console.developers.google.com/apis/credentials ](https://console.developers.google.com/apis/credentials)and
    follow these steps:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在Google上注册（或创建）一个应用程序，该应用程序提供连接访问以使用授权服务。这是开始实现OAuth之前的一个基本步骤。Google提供了一个**API控制台**用于注册应用程序。访问API控制台需要一个有效的Google账户。请访问[https://console.developers.google.com/apis/credentials](https://console.developers.google.com/apis/credentials)并按照以下步骤操作：
- en: Click on the Create credentials button in the Credentials tab, and click on
    the OAuth client ID option. Select the application type as Web Application.
  id: totrans-322
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在“凭证”选项卡中单击“创建凭证”按钮，然后单击“OAuth客户端ID”选项。选择应用程序类型为Web应用程序。
- en: Give an appropriate name (like `SpringOAuthDemo`).
  id: totrans-323
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 给出适当的名称（例如 `SpringOAuthDemo`）。
- en: We need to set the authorized redirect URI in the Google console, which represents
    a path upon which users are redirected after they are successfully authorized
    by Google. The default implementation, provided by Spring Security for Google,
    has configured the redirect URI as `/login/oauth2/code/google`. Apparently, the
    valid redirect URI, in our case, would be [http://localhost:8080/springuath/login/oauth2/code/google](http://localhost:8080/springuath/login/oauth2/code/google) (considering
    `8080` as the port and `springauth`as the context name). Give this URI in Authorized
    redirectURIs in the Google console, and click on the Create button.
  id: totrans-324
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要在Google控制台中设置授权重定向URI，它代表用户在通过Google成功授权后将被重定向的路径。Spring Security为Google提供的默认实现已将重定向URI配置为`/login/oauth2/code/google`。显然，在我们的情况下，有效的重定向URI将是[http://localhost:8080/springuath/login/oauth2/code/google](http://localhost:8080/springuath/login/oauth2/code/google)（考虑到`8080`为端口号，`springauth`为上下文名称）。在Google控制台的“授权重定向URI”中提供此URI，然后点击“创建”按钮。
- en: 'Upon successful registration of the application, Google will create client
    credentials in the form of the client ID and client secret, as shown in the following
    screenshot:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序成功注册后，Google将创建客户端凭据，以客户端ID和客户端密钥的形式，如下面的截图所示：
- en: '![](img/6f5dc88c-7ffc-433d-b918-008d54e3e628.png)'
  id: totrans-326
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/6f5dc88c-7ffc-433d-b918-008d54e3e628.png)'
- en: The client ID is a kind of public key used by the Google service API to identify
    the application that we have registered. It is also used to construct authorization
    URLs of the Google login form. The client secret, as its name suggests, is a kind
    of private key. When the application (that we registered) requests the details
    of a user account, at the moment the user credentials are sent, the client secret
    will be used to validate the identity of the application. Because of this, the
    client secret must be kept private between the application and the client.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端ID是一种公钥，由Google服务API用于识别我们已注册的应用程序。它还用于构建Google登录表单的授权URL。客户端密钥，正如其名称所示，是一种私钥。当（我们注册的应用程序）请求用户账户的详细信息时，在用户凭证发送的那一刻，客户端密钥将用于验证应用程序的身份。因此，客户端密钥必须在应用程序和客户端之间保持私密。
- en: Changes in the Spring Boot application
  id: totrans-328
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Spring Boot应用程序中的更改
- en: After completing the preceding requirements, we will start to make the necessary
    changes in the Spring Boot application that we created for LDAP authentication.
    The aim is to build a central authentication and authorization server that will
    work with both technologies (LDAP and OAuth).
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 完成前面的要求后，我们将开始对我们为LDAP认证创建的Spring Boot应用程序进行必要的更改。目标是构建一个中央认证和授权服务器，该服务器将同时与两种技术（LDAP和OAuth）协同工作。
- en: 'When the user enters a plain username and password, the authentication and
    authorization will be done with LDAP. We will configure our application with Google,
    for OAuth. The very first step for OAuth integration is to declare the relevant
    starters. Spring Boot provides support for OAuth in the form of starters. Add
    the following starter entries in a `pom.xml` file:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户输入普通用户名和密码时，认证和授权将通过LDAP完成。我们将使用Google和OAuth配置我们的应用程序。OAuth集成的第一步是声明相关的启动器。Spring
    Boot以启动器的形式提供对OAuth的支持。在`pom.xml`文件中添加以下启动器条目：
- en: '[PRE21]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Upon defining this starter, Spring Boot will add the following dependencies,
    which are essentials for OAuth integration, automatically:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 定义此启动器后，Spring Boot将自动添加以下依赖项，这些依赖项对于OAuth集成是必需的：
- en: '[PRE22]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Next, we will add properties for the client ID and client secret, along with
    the provider and client name, in the `application.propeties` file. These properties
    are prefixed with `spring.security.oauth.client.registration`, along with the
    provider name and property name. Set these properties with the `Client ID` and
    `Client Secret` that we created in the Google developer console in the previous
    section, as follows:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将在`application.properties`文件中添加客户端ID和客户端密钥的属性，以及提供者和客户端名称。这些属性以`spring.security.oauth.client.registration`为前缀，包括提供者名称和属性名称。按照以下方式设置这些属性，使用我们在上一节中在Google开发者控制台中创建的`Client
    ID`和`Client Secret`：
- en: '[PRE23]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The default OAuth configuration
  id: totrans-336
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 默认OAuth配置
- en: 'Spring Security allows for configuring multiple OAuth clients. In addition
    to Google, Spring Security also supports default configurations for Facebook,
    GitHub, and Okta, out of the box. That means that all required classes and configurations
    are readily available, and we just need to define the client credentials (`Client
    ID` and `Client Secret`). Next, we will update the `configure(HttpSecurity http)`
    method of the `WebSecurityConfig` class, as follows:'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Security允许配置多个OAuth客户端。除了Google之外，Spring Security还支持Facebook、GitHub和Okta的默认配置，开箱即用。这意味着所有必需的类和配置都
    readily 可用，我们只需要定义客户端凭证（`Client ID`和`Client Secret`）。接下来，我们将更新`WebSecurityConfig`类的`configure(HttpSecurity
    http)`方法，如下所示：
- en: '[PRE24]'
  id: totrans-338
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The oauth2Login() method will initiate an OAuth call. At this moment, while
    executing the application, the preceding method will make an OAuth call to Google.
    A user will be asked for a valid Google login credential. Upon successful authentication,
    it will show the home page.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: '`oauth2Login()`方法将启动OAuth调用。在此时刻，当执行应用程序时，前面的方法将向Google发起OAuth调用。用户将被要求提供有效的Google登录凭证。认证成功后，它将显示主页。'
- en: If we set the properties for at least one client, Spring Security will automatically
    enable the `Oauth2ClientAutoConfiguration` class, which will make all of the necessary
    arrangements to enable OAuth login, without even defining the preceding `WebSecurityConfig`
    class.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们为至少一个客户端设置了属性，Spring Security将自动启用`Oauth2ClientAutoConfiguration`类，这将使所有必要的安排以启用OAuth登录，甚至不需要定义前面的`WebSecurityConfig`类。
- en: If more than one client is configured in the `application.properties` file,
    the system will show a list of those clients, with a default login (username and
    password) form. It will be the autogenerated login page. We can perform a login
    with any of those configured clients.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在`application.properties`文件中配置了多个客户端，系统将显示这些客户端的列表，并带有默认的登录表单（用户名和密码）。这将是一个自动生成的登录页面。我们可以使用任何配置的客户端进行登录。
- en: 'It is quite obvious to show the name of the user at the top, to indicate which
    user is currently logged in. We can get the name of the user that has been authenticated
    at Google with the following code snippet:'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 在顶部显示用户名以指示当前登录的用户是非常明显的。我们可以使用以下代码片段获取在Google上认证的用户名：
- en: '[PRE25]'
  id: totrans-343
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: This method is defined with `ModelAttribute`, meaning it can be directly used
    in the presentation layer with the `${currentUserName}` expression. We are getting
    an instance of `Authentication`, and checking if it is of the type `OAuth2AuthenticationToken`.
    The `getPrincipal()` method will return the user details, along with the attributes.
    The `name` attribute returns the name of the user that logged in with Google.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法使用`ModelAttribute`定义，这意味着它可以直接在表示层中使用`${currentUserName}`表达式。我们正在获取`Authentication`的一个实例，并检查它是否为`OAuth2AuthenticationToken`类型。`getPrincipal()`方法将返回用户详情以及属性。`name`属性将返回使用Google登录的用户名。
- en: The other part will be executed when we perform authentication with LDAP, which
    gets the `userName` from the `Authentication` object, and then calls the custom
    service method (`ldapAuthService.getUser()`) to fetch the LDAP user object. It
    is then used to get the name of the user (the first name and surname).
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 另一部分将在我们使用LDAP进行认证时执行，它从`Authentication`对象中获取`userName`，然后调用自定义服务方法（`ldapAuthService.getUser()`）来获取LDAP用户对象。然后使用它来获取用户名（名和姓）。
- en: OAuth with a custom login page
  id: totrans-346
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用自定义登录页面的OAuth
- en: 'This is how OAuth can be integrated with Spring Security. In the preceding
    configuration, Spring Boot provides an autogenerated login page, which may suffice
    for testing purposes. In real scenarios, we may need a customized login page.
    To build a custom login page, we need to make certain configuration changes in
    the `configure(HttpSecurity http)` method, as follows:'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是OAuth如何与Spring Security集成的。在前面的配置中，Spring Boot提供了一个自动生成的登录页面，这可能适用于测试目的。在实际场景中，我们可能需要一个定制的登录页面。要构建自定义登录页面，我们需要在`configure(HttpSecurity
    http)`方法中进行某些配置更改，如下所示：
- en: '[PRE26]'
  id: totrans-348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: This looks similar to what we configured for LDAP. The only change is that we
    are using `oauth2Login()` instead of `formLogin()`. The call for `super.configure(http)`has
    been removed at the end, as it is no longer required. If we place it there, Spring
    Boot will show an autogenerated login page, so make sure to remove it at the end.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 这看起来与我们为LDAP配置的类似。唯一的区别是我们使用`oauth2Login()`而不是`formLogin()`。在末尾已经移除了对`super.configure(http)`的调用，因为它不再需要。如果我们将其放置在那里，Spring
    Boot将显示一个自动生成的登录页面，所以请确保在末尾将其移除。
- en: 'This change will show the custom login page, but the list of OAuth providers
    will not be visible automatically. We need to prepare the list manually, and show
    them in the login page. To achieve this, we will need to update the controller
    method, `showLoginPage()`, as follows. This method basically shows the login page:'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 此更改将显示自定义登录页面，但OAuth提供者的列表不会自动可见。我们需要手动准备此列表，并在登录页面中显示它们。为了实现这一点，我们需要更新控制器方法`showLoginPage()`，如下所示。此方法基本上显示登录页面：
- en: '[PRE27]'
  id: totrans-351
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: This is the login method that we already created at the beginning of the chapter,
    in order to show the login form. The changes are made specifically for OAuth.
    First, the instance of `ClientRegistrationRepository` is injected, which represents
    the repository and stores the OAuth client's primary details. It is an interface
    type, and Spring Boot provides the instance of the `InMemoryClientRegistrationRepository` class
    as a default implementation. The `InMemoryClientRegistrationRepository` maintains
    a map for `ClientRegistration`, a class that represents the OAuth providers.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们在本章开头创建的登录方法，用于显示登录表单。更改专门针对OAuth进行。首先，注入了`ClientRegistrationRepository`的实例，它表示存储OAuth客户端主要详情的仓库。它是一个接口类型，Spring
    Boot提供了`InMemoryClientRegistrationRepository`类的实例作为默认实现。`InMemoryClientRegistrationRepository`维护一个`ClientRegistration`映射，该映射表示OAuth提供者。
- en: 'In the preceding code, we are getting the map of `ClientRegistration` from
    `clientRegistrationRepository`, iterating it, and preparing the list of OAuth
    providers with a name and authorization URL that is prefixed with `oauth2/authorization`.
    We set it as a model attribute, so that it will be available to the presentation
    layer. After applying these changes, the login page will look as follows:'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们从`clientRegistrationRepository`获取`ClientRegistration`映射，迭代它，并使用以`oauth2/authorization`为前缀的名称和授权URL准备OAuth提供者列表。我们将它设置为模型属性，以便它对表示层可用。应用这些更改后，登录页面将如下所示：
- en: '![](img/8b464a88-ab49-4f0f-9a25-08e2fa631a07.png)'
  id: totrans-354
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/8b464a88-ab49-4f0f-9a25-08e2fa631a07.png)'
- en: Dual authentication with OAuth and LDAP
  id: totrans-355
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: OAuth和LDAP的双因素认证
- en: The application will now show a custom login page, along with the list of OAuth
    clients that we configured. Still, when we enter the credentials manually in the
    login form, nothing will happen, because the Spring Security is configured for
    OAuth. The user, when entering credentials in a login form, should be authenticated
    with LDAP. To achieve this, we need to perform certain configurations specifically
    within LDAP.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序现在将显示自定义登录页面，以及我们配置的OAuth客户端列表。尽管如此，当我们手动在登录表单中输入凭据时，什么也不会发生，因为Spring Security已配置为OAuth。当用户在登录表单中输入凭据时，应使用LDAP进行认证。为了实现这一点，我们需要在LDAP中进行特定的配置。
- en: 'Here, the goal is to perform manual authentication with LDAP. Spring Security
    provides a way to define a custom authentication provider, by implementing the `AuthenticationProvider`
    interface. First, we will write a class that implements this interface and performs
    LDAP authentication, as follows:'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，目标是使用LDAP进行手动认证。Spring Security提供了一种通过实现`AuthenticationProvider`接口来定义自定义认证提供者的方式。首先，我们将编写一个实现此接口并执行LDAP认证的类，如下所示：
- en: '[PRE28]'
  id: totrans-358
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The class `CustomLdapAuthProvider` is defined with the `@Component` annotation,
    meaning that Spring will configure it as a bean, so that it can be available to
    other components with the `@Autowired` annotation. The `AuthenticationProvider`
    interface declares the following two methods:'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 类`CustomLdapAuthProvider`使用`@Component`注解定义，这意味着Spring会将其配置为一个bean，以便其他带有`@Autowired`注解的组件可以使用它。`AuthenticationProvider`接口声明了以下两个方法：
- en: '`Authentication authenticate(Authentication authentication)`: This is the place
    where we can provide custom authentication.'
  id: totrans-360
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Authentication authenticate(Authentication authentication)`：这是我们可以提供自定义认证的地方。'
- en: '`boolean supports(Class<?> authentication)`: This method indicates whether
    this custom authentication provider supports the indicated authenticated object.'
  id: totrans-361
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`boolean supports(Class<?> authentication)`：此方法指示此自定义认证提供者是否支持指示的认证对象。'
- en: In the `authenticate` method, we are first getting the `username` and `password`
    from an instance of `Authentication`. Then, we are doing manual authentication
    by calling the custom service method `authenticateLdapUserWithContext`, which
    we already created for LDAP authentication. If this method returns `true`, it
    means that the credentials are valid.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 在`authenticate`方法中，我们首先从`Authentication`实例中获取`username`和`password`。然后，通过调用我们已为LDAP认证创建的自定义服务方法`authenticateLdapUserWithContext`进行手动认证。如果此方法返回`true`，则表示凭证有效。
- en: 'Along with verifying the credentials, we also need to fetch the authorities
    (roles) that a user has. To get them, we have defined a method in the custom repository
    `impl` class (`LdapAuthRepositoryCustomImpl`), as follows:'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 除了验证凭证外，我们还需要获取用户拥有的权限（角色）。为此，我们在自定义仓库`impl`类（`LdapAuthRepositoryCustomImpl`）中定义了一个方法，如下所示：
- en: '[PRE29]'
  id: totrans-364
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The `getUserAuthorities` method takes the `userName` and returns the list of
    authorities. Let's recall that for roles, we have created a separate entity (`ou=roles`)
    in Apache DS. All of its children represent actual roles (with the attribute `cn`
    as the role name). Any LDAP user that is a member of a particular authority (role)
    is added with the `member` attribute. The aim is to fetch all the authorities
    of which the current user is a member.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: '`getUserAuthorities`方法接受`userName`并返回权限列表。让我们回顾一下，对于角色，我们在Apache DS中创建了一个单独的实体（`ou=roles`）。它的所有子实体代表实际的角色（属性`cn`作为角色名称）。任何是特定权限（角色）成员的LDAP用户都会通过`member`属性添加。目标是获取当前用户是成员的所有权限。'
- en: The search method on `ldapTemplate` takes `LdapQuery` and the `ContextMapper`
    object and returns the list of authorities. The `LdapQuery` is built with a group
    filter of `objectclass` and value of member attribute. The value of `objectclass`
    is the same as the name of the `objectclass` that we gave to the entity (`ou=roles`)
    in LDAP. The value of the member attribute will be a valid user DN; for example,
    `uid=npatel`, `ou=users`, `o=packtPublisher`. The `ContextMapper` is a mechanism
    to retrieve only the required values from the `search` method. More specifically,
    `ContextMapper` can be used to retrieve custom results (wrap the selected value
    in custom POJO).
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: '`ldapTemplate`上的搜索方法接受`LdapQuery`和`ContextMapper`对象，并返回权限列表。`LdapQuery`使用`objectclass`的组过滤器以及成员属性的值构建。`objectclass`的值与我们在LDAP中给实体（`ou=roles`）指定的`objectclass`名称相同。成员属性的值将是一个有效的用户DN；例如，`uid=npatel`，`ou=users`，`o=packtPublisher`。`ContextMapper`是一种从`search`方法中检索所需值的机制。更具体地说，`ContextMapper`可以用来检索自定义结果（将选定的值包装在自定义POJO中）。'
- en: 'This can be done by providing the implementation for a `ContextMapper` interface.
    We have created a class for this implementation, as follows:'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以通过提供`ContextMapper`接口的实现来完成。为此，我们创建了一个类，如下所示：
- en: '[PRE30]'
  id: totrans-368
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The `ContextMapper` interface is a raw type, so we have defined the type as `LdapGranntedAuthority`,
    which is nothing but a custom POJO. In the `mapFromContext` method, the object
    of `DirContextAdapter` is used to fetch the name of the role with the attribute
    `cn`. This role name is then set in the instance of `LdapGranntedAuthority`, and
    finally, returns it. The `LdapGranntedAuthority` class looks as follows:'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: '`ContextMapper`接口是一个原始类型，因此我们将类型定义为`LdapGranntedAuthority`，这实际上是一个自定义POJO。在`mapFromContext`方法中，使用`DirContextAdapter`对象通过属性`cn`获取角色的名称。然后，将此角色名称设置在`LdapGranntedAuthority`实例中，并最终返回它。`LdapGranntedAuthority`类如下所示：'
- en: '[PRE31]'
  id: totrans-370
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: This POJO implements the `GrantedAuthority` interface to set the name of the
    authority (role). Now, let's go back to the authenticate method of the `CustomLdapAuthProvider`
    class. After getting the authorities, we are creating the object of the `UsernamePasswordAuthenticationToken`
    class with the username, password, and list of authorities. The `UsernamePasswordAuthenticationToken`
    class basically provides an implementation of the `Authentication` interface.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 此POJO实现了`GrantedAuthority`接口以设置权限（角色）的名称。现在，让我们回到`CustomLdapAuthProvider`类的`authenticate`方法。在获取权限后，我们使用用户名、密码和权限列表创建`UsernamePasswordAuthenticationToken`类的对象。`UsernamePasswordAuthenticationToken`类基本上提供了`Authentication`接口的实现。
- en: 'Next, with the help of this custom authentication provider, we will do manual
    authentication. Before that, we have to change the action of the login form, since
    the default (`/login`) will no longer work automatically. Change the path from
    `/login` to `/ldapLogin` in the login form. We also need to create a corresponding
    controller method to handle the login flow manually, as follows:'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，借助这个自定义认证提供者，我们将进行手动认证。在此之前，我们必须更改登录表单的操作，因为默认的（`/login`）将无法自动工作。将登录表单的路径从
    `/login` 更改为 `/ldapLogin`。我们还需要创建一个相应的控制器方法来手动处理登录流程，如下所示：
- en: '[PRE32]'
  id: totrans-373
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The instance of `CustomLdapAuthProvider` is injected with the `@Autowired` annotation.
    This method is defined with the `@PostMapping` annotation, to handle the login
    form with the POST method. We are creating the instance of `UsernamePasswordAuthenticationToken`
    with the username and password that were submitted with the login form, and we
    pass it to the `authenticate` method of `CustomLdapAuthProvider`, which basically
    does authentication with LDAP and fetches the user authorities. Once the authentication
    is done, we will store the authentication object in the Spring Security context.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: '`CustomLdapAuthProvider` 实例通过 `@Autowired` 注解进行注入。此方法使用 `@PostMapping` 注解定义，用于处理使用
    POST 方法的登录表单。我们使用登录表单提交的用户名和密码创建 `UsernamePasswordAuthenticationToken` 实例，并将其传递给
    `CustomLdapAuthProvider` 的 `authenticate` 方法，该方法基本上使用 LDAP 进行身份验证并获取用户权限。一旦完成身份验证，我们将认证对象存储在
    Spring Security 上下文中。'
- en: Finally, we have saved the security context in an HTTP session, so that Spring
    Security will create and maintain the user authentication information in the session.
    After performing all of these processes, we are checking whether the authentication
    is successful by calling the `isAuthenticated` method on the authentication object.
    Based on the authentication status (success or failure), we are redirecting the
    flow to either a private page (upon successful authentication) or a login page
    (upon failed authentication). This was all about using dual authentication with
    LDAP and OAuth. Next, we will illustrate OAuth implementation on a custom authorization
    server.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们已经将安全上下文保存在 HTTP 会话中，以便 Spring Security 将在会话中创建并维护用户认证信息。在执行所有这些过程之后，我们通过在认证对象上调用
    `isAuthenticated` 方法来检查认证是否成功。根据认证状态（成功或失败），我们将流程重定向到私有页面（在成功认证的情况下）或登录页面（在认证失败的情况下）。这全部都是关于使用
    LDAP 和 OAuth 进行双重认证。接下来，我们将展示在自定义授权服务器上的 OAuth 实现。
- en: OAuth authorization with a custom authorization server
  id: totrans-376
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用自定义授权服务器的 OAuth 授权
- en: Now, you have seen OAuth integration with Spring using third-party providers
    (Google). In this section, we will build a custom authorization server (provider)
    and do OAuth authorization. We will also build our own resource server, and we'll
    access the resources once the authorization is done.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您已经看到了使用第三方提供者（Google）通过 Spring 集成 OAuth。在本节中，我们将构建一个自定义授权服务器（提供者）并执行 OAuth
    授权。我们还将构建自己的资源服务器，并在授权完成后访问资源。
- en: In the previous section, the authorization code grant type was used with Google.
    We will implement an implicit grant type in this section. Let's recall that the
    implicit grant type was specially designed for JavaScript applications. Since
    it runs in a browser, the authorization server directly sends the access token.
    There is no support for refresh tokens, for security purposes.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们使用 Google 的授权代码授予类型。在本节中，我们将实现隐式授予类型。让我们回顾一下，隐式授予类型是专门为 JavaScript 应用程序设计的。由于它在浏览器中运行，授权服务器直接发送访问令牌。出于安全考虑，不支持刷新令牌。
- en: We will first develop a custom authorization server (provider) that will provide
    the access token. We can consider it in place of Google in the previous section,
    where we developed a client for authorization. For our custom authorization, we
    will set up a client with credentials (an ID and secret), which will be used to
    provide authorization (in the form of providing an access token).
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先开发一个自定义授权服务器（提供者），它将提供访问令牌。我们可以将其视为上一节中我们开发授权客户端的地方，即 Google。对于我们的自定义授权，我们将设置一个带有凭证（ID
    和密钥）的客户端，这些凭证将用于提供授权（以提供访问令牌的形式）。
- en: We will create separate Spring Boot applications for the authorization and resource
    server, and we will need to run them simultaneously, in order to test the functionality.
    To avoid the port clashing (the default is 8080 for both applications), we need
    to explicitly set the port while running them. To do so, you need to give a different
    port with the property `server.port` in the `application.properties` file.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
- en: Authorization server configuration
  id: totrans-381
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will develop a separate Spring Boot application and apply the necessary
    configurations to use it as an authorization server. This is our custom authorization
    server. Create a Spring Boot application with the name `SpringCustomAuthorization`and
    add the following component, which is basically an essential entry point to building
    a custom authorization server:'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-383
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: With the `@EnableAuthorizationServer` annotation, this class claims to present
    a configuration for the authorization server. In order to understand the concept
    in more detail, we will associate each step for configuring the custom authorization
    server with what we already did in the Google OAuth integration. The very first
    step in this configuration is to define a client, which basically talks to an
    authorization server to get an access token.
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
- en: The `configure(ClientDetailsServiceConfigurer clients)` method is used to define
    a client with various metadata, like the client ID, grant type, scopes, secret,
    and redirection URI. The `resourceId` is used to make the pair with the resource
    server. We will configure the same `resourceId` while creating a resource server
    later in this chapter. The type of client that we have used here is in-memory,
    which is appropriate for developmental purposes.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
- en: Another type is JDBC, wherein the client details can be stored in the database.
    We can configure multiple clients in this method, and each can be separated with
    the `.and()` method call. The client is created within an authorization server.
    We can relate this to the client that we created in the Google developer console.
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
- en: The `tokenStore()` method is used to construct an access token. Spring provides
    various mechanisms, like `InMemoryTokenStore`, `JdbcTokenStore`, `JwkTokenStore`,
    and `JwtTokenStore`, to create a token. Out of these, we have used `JwtTokenStore`.
    The `accessTokenConverter()` method is used to encode/decode the token with a
    signing key.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
- en: We need to use the same signing key while configuring the token store at the
    resource server. The `tokenServices()` method is used to configure the token service
    with the token store, along with a few settings. Since the grant type is implicit,
    the refresh token is not allowed, so we are setting `setSupportRefreshToken()`
    to `false`. We can also set how long the token is valid, through the `setAccessTokenValiditySeconds()`
    method. Since this is an implicit flow and will be used by a JavaScript application,
    the token should be short-lived, for security reasons.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, the `configure(AuthorizationServerEndpointsConfigurer endpoints)` method
    is a glue point to group the things that we have configured so far together. Generally,
    user authentication is performed prior to authorization, and the object of `AuthenticationManager`
    is used to perform the authentication. After defining the authorization configuration,
    let''s make it secure by applying security configurations, as follows:'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`configure(AuthorizationServerEndpointsConfigurer endpoints)`方法是一个粘合点，用于将我们迄今为止配置的所有内容组合在一起。通常，用户认证在授权之前进行，`AuthenticationManager`对象用于执行认证。在定义授权配置后，让我们通过应用安全配置来使其安全，如下所示：
- en: '[PRE34]'
  id: totrans-390
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: With the `@EnableWebSecurity` annotation, Spring Security will be applied to
    the authorization server. It is a normal Spring Security configuration that you
    have already seen in previous sections. The `/oauth/authorize` is a default authorization
    endpoint. The resource server will initiate an authorization call on this path,
    so we have configured it in the `configure` method.
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 通过`@EnableWebSecurity`注解，Spring Security将被应用于授权服务器。这是一个你已经在前面章节中见过的正常Spring
    Security配置。`/oauth/authorize`是一个默认的授权端点。资源服务器将在这个路径上发起授权调用，因此我们在`configure`方法中进行了配置。
- en: We have created an in-memory user with credentials and authority. We can associate
    it with the user account hold in Google, which is being asked when we initiate
    authorization with Google. In our case, we will provide this credential when the
    authorization process is initiated at the custom authorization server.
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已创建了一个具有凭证和权限的内存用户。我们可以将其与在Google中持有的用户账户关联，这是当我们使用Google进行授权时被询问的。在我们的情况下，当在自定义授权服务器中启动授权过程时，我们将提供此凭证。
- en: Our authorization server is now ready. It cannot be accessed directly; instead,
    the resource server initiates the request with certain parameters. Next, we will
    build the resource server.
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的资源服务器现在已准备就绪。它不能直接访问；相反，资源服务器会以某些参数的形式发起请求。接下来，我们将构建资源服务器。
- en: Resource server configuration
  id: totrans-394
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 资源服务器配置
- en: As its name suggests, a **resource server** holds resources (in the form of
    data, services, files, and so on), which can be accessed by the resource owner
    by providing valid authorization. The process of providing authorization happens
    in the form of a **token sharing mechanism**.
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 如其名所示，一个**资源服务器**持有资源（以数据、服务、文件等形式），资源所有者可以通过提供有效的授权来访问这些资源。授权提供的过程以**令牌共享机制**的形式发生。
- en: The authorization server creates a token after authentication, which is used
    by a resource server to serve the restricted resources. For all incoming requests
    for protected resources, the resource server will check the validity of the access
    token with the authorization server. This is the flow of the system, in brief.
    Now, we will create a resource server with a separate Spring Boot application.
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 授权服务器在认证后创建一个令牌，该令牌由资源服务器用于提供受限制的资源。对于所有受保护资源的传入请求，资源服务器将使用授权服务器检查访问令牌的有效性。简要来说，这就是系统的流程。现在，我们将使用单独的Spring
    Boot应用程序创建一个资源服务器。
- en: 'Spring allows for creating a resource server by declaring certain essential
    configurations, as follows:'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: Spring 允许通过声明某些基本配置来创建资源服务器，如下所示：
- en: '[PRE35]'
  id: totrans-398
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: The `@EnableResourceServer` annotation will instruct Spring Security to treat
    the component as the resource server and to authenticate incoming requests with
    an access token. In this configuration, we are using the same `resourceId` that
    we used in the authorization server. Also, the process of creating and converting
    the token, along with the signing key, is the same as what we implemented in the
    authorization server.
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: '`@EnableResourceServer`注解将指示Spring Security将组件视为资源服务器，并使用访问令牌对传入请求进行认证。在这个配置中，我们使用与授权服务器相同的`resourceId`。此外，创建和转换令牌以及签名密钥的过程与我们在授权服务器中实现的过程相同。'
- en: For a token of the type `Jwt`, we can also use the public-private key as a signing
    key for generating an access token. In a normal case, the signing key declared at
    the authorization and resource server must be the same.
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 对于类型为`Jwt`的令牌，我们也可以使用公私钥作为签名密钥来生成访问令牌。在正常情况下，授权和资源服务器中声明的签名密钥必须相同。
- en: 'The `configure(HttpSecurity http)` method of this class is a place where we
    can configure the path of protected resources. In our case, we are configuring
    `/api/**`, meaning that any path that starts with `/api/` is considered secure.
    Without a valid token, the user cannot access that path. We also defined the appropriate
    denied handler to show an appropriate message, in the case of invalid tokens or
    insufficient privileges. Next, we will configure Spring Security for the resource
    server, as follows:'
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-402
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'This is a straightforward security configuration, where we have declared certain
    paths to be accessible by all. Next, we will create a Spring MVC controller, which
    will show the page from which we can initiate authorization, as follows:'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-404
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The first two methods show the home page and private page, respectively. We
    will show a link on the home page that will initiate the authorization process.
    This link will call the `authorizeUser()` method (with the link `/customAuth`).
    This method fetches the client metadata that is defined in the `application.properties`
    file, as follows:'
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-406
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: In the `authorizeUser()` method, we are redirecting the flow to the authorization
    URI, along with the `client-id`, `client-secret`, `grant-type`, and `response-type`
    parameters. The `oauth/authorize` is a default authorization endpoint.
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
- en: Let's recall that, while doing a client setup in the authorization server, we
    configured the `redirectUri` as [http://localhost:8082/privatePage](http://localhost:8082/privatePage),
    meaning that after authorization, the flow will go back to this URL, which ultimately
    shows a private page, along with the access token.
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
- en: 'Once we get the token, we can start to consume the protected resources. We
    have defined the path `/api/**` as protected resources in the resource server
    configuration. So, let''s create a REST controller, as follows, which will provide
    the resources. For demo purpose, we will return some sample data:'
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-410
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: The REST controller is configured with path `/api`, meaning that all of its
    methods can be accessible with the valid authorization token. Now, it is time
    to run the application and test the flow. We will first run the resource server
    application ([http://localhost:8082](http://localhost:8082), assuming it is running
    on port `8082`). It will show a link, which will redirect the flow to the authorization
    server.
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
- en: Soon after the flow reaches the authorization server, it prompts a login page.
    This is because an authorization server required a valid authentication before
    even starting authorization. This makes sense, because the authorization server
    will authorize the given user account, and for this, a user must be logged in.
    We will use the in-memory credentials that we created for the authorization server.
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
- en: 'Soon after logging in, the authorization server shows an intermediate page
    and asks a user to either allows or denies. Based on that, a user can access the
    restricted resource on the resource server, as follows:'
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/56135b7d-db6e-4b8f-a40d-26515f933566.png)'
  id: totrans-414
  prefs: []
  type: TYPE_IMG
- en: This is similar to when we created a client in the Google developer console
    and did authorization with it. At that time, first, we gave Google the credentials,
    and after authentication, it asked for the approval of access for the client.
    When we authorize the client, it will redirect to the private page of the resource
    server with an access token.
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
- en: At this moment, the access token is returned with `#` character in the response.
    To access any protected resources, we need to append the access token with `?`,
    so that it will be supplied as a request parameter. Without this, the resource
    server will not allow for accessing any protected resources.
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we can access protected resources with the access token. The rest controller
    (with the path `/api`) will serve the resources. For example, the URL [http://localhost:8082/api/usergreeting?access_token=<token_string>](http://localhost:8082/api/usergreeting?access_token=%3Ctoken_string%3E)
    will give the following output:'
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/39988647-0eeb-4943-8c43-532f04a1dbaa.png)'
  id: totrans-418
  prefs: []
  type: TYPE_IMG
- en: It will show a `token expired` error if the request is made after the token
    validity is over. It will also throw an `invalid token` error if the original
    token is altered. Without supplying the token, it will show an error like, `Full
    authentication is required to access this resource`.
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
- en: Method-level resource permissions
  id: totrans-420
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now, an authorized user can access all of the resources that we have configured.
    How good would it be if the resources could be accessed based on user roles? It
    would provide for more fine-grained control over the resources. This is possible
    by applying method-level configurations in Spring Security. For this, first, we
    need to define a class that represents method-level Spring Security configurations,
    as follows:'
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-422
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: The `@EnableGlobalMethodSecurity` annotation is required to define authorization
    constraints at the method level. The base class, `GlobalMethodSecurityConfiguration`,
    provides a default implementation of method-level security configuration.
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
- en: We have overridden the `createExpressionHandle` method to supply `OAuth2MethodSecurityExpressionHandler`
    instead of `DefaultMethodSecurityExpressionHandler`, which is provided out of
    the box. Spring Security uses an AOP proxy mechanism to apply method-level security
    configurations.
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
- en: The `prePostEnabled` and `securedEnabled` options enable respective annotations
    at the method level, to define authorization rules. For example, `prePostEnabled`
    will allow for defining the Spring Security pre/post annotations `@PreAuthorize`
    and `@PostAuthorize`. These annotations allow for expression-based access control,
    meaning that we can use Spring **EL (Expression Language)** to describe the rule.
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
- en: 'The `@PreAuthorize` will evaluate the expression before entering the method,
    while the `@PostAuthorize` will verify the expression after method execution has
    completed, and could alter the result. The `securedEnabled` option of `@EnableGlobalMethodSecurity`
    is used to define the `@Secured` annotation. With the `@Secuired` annotation,
    we can specify a list of roles on a method. Let''s look at a few examples of this
    annotation, as follows:'
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-427
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'The `getUserAccnt` method will be accessible by the user that has a role as
    `ROLE_USER`. The `getCompanyPolicy` method will be invoked by a user who has at
    least one role among `ROLE_USER` and `ROLE_ADMIN`. The `@Secuired` annotation
    does not allow for defining an expression with Spring EL. On the other hand, the `@PreAuthorize`
    and `@PostAuthorize` annotations allow for Spring EL to define the expression,
    meaning that we can define the more complex condition. Let''s look at some examples
    of `@PreAuthorize`, as follows:'
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-429
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'The first method (`adminResource`) is accessible for the user with a `USER`
    role, and the client should have a `read` scope. Let''s recall that for the client
    that we configured in the authorization server, we set three scopes: read, write,
    and trust. The `#oauth2` variable is provided out of the box, and is used to check
    the various scopes that a client has. We can utilize other methods on the `#oauth2`
    variable, like `clientHasRole()`, `clientHasAnyRole()`, `hasAnyScope()`, `isOAuth()`, `isUser()`, `isClient()`,
    and so on. They are defined in the class `OAuth2SecurityExpressionMethods`. In
    short, the variable `#oauth2` represents the object of this class.'
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
- en: 'The second method (`userResource`) is a bit more complex, and can be accessed
    under the following conditions:'
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
- en: A user has a `USER` role and a client has a `read` scope
  id: totrans-432
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A request is not of the OAuth type (it may be raised by a machine client) and
    a user has a `USER` role
  id: totrans-433
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The third method (`listAllSampleUsers`) is similar to the second method, and
    can be accessed in the following situations:'
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
- en: A user has an `ADMIN` role
  id: totrans-435
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A client has a `trust` scope
  id: totrans-436
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A request is not of the OAuth type (it may be raised by a machine client) and
    a user has an `ADMIN` role
  id: totrans-437
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This is how the implicit grant type can be implemented with the custom authorization
    server. There are certain things that require attention while using the implicit
    grant type. Since it was designed for JavaScript applications, both the authorization
    and resource server should be securely accessible (with HTTPS). The second thing
    is, in an implicit grant type, the access token is directly returned by the authorization
    server to the browser, instead of at a trusted backend; it is highly recommended
    to configure short-lived access tokens, to mitigate the risk of the access token
    being leaked.
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
- en: Another challenge in the implicit flow is that it does not allow refresh tokens.
    That means that after the short-lived token has expired, a user should be prompt
    to initiate the flow again; or, a better method might be to set a mechanism, like
    `iframe`, to get the new token without interruption.
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
- en: As an exercise, you could create a few more users with different roles in the
    authorization server, and configure the resource methods with those roles, checking
    how they are accessible.
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-441
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Security is an essential part of any system. How effective it is depends on
    various aspects, like simplicity, feature richness, ease of integration with other
    systems, flexibility, robustness, and so on. This whole chapter was based on Spring
    Security. It is a fully-fledged framework that's used to secure J2EE-based applications.
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we explored Spring Security more closely, especially how it
    can be integrated with LDAP and OAuth. We started with the basics of LDAP, including
    its data structure and setup; we created the structure in Apache DS, which is
    an LDAP server. Then, we explored the required configurations with Spring Security,
    to integrate it with LDAP.
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
- en: Along with authentication with LDAP, we explored how to manage users in LDAP
    from a Spring application. We used the Spring Data framework to achieve this.
    Next, we created a structure for the role (authority) in LDAP. In the same sequence,
    we fetched the role details and implemented authorization in Spring Security with
    LDAP.
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
- en: Later in the chapter, we started to cover another mechanism, called OAuth. It
    is an open standard for token-based authorization. We began with the basics of
    OAuth roles, then explored details about various grant types; you also learned
    which grant should be used when. Going further, we started on Spring Security
    integration with OAuth. We used Google to implement the authorization code flow
    with Spring Security.
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
- en: With the default OAuth implementation, Spring Security shows the autogenerated
    login page. We showed how to implement a custom login page in OAuth. Up to that
    point, you had only seen the two different mechanisms, LDAP and OAuth, independently.
    We integrated both of them together, creating dual authentication.
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
- en: We then implemented OAuth with the authorization code flow. Next, we showed
    how to implement the implicit flow with custom authorization and the resource
    server. We performed a set of configurations for both the authorization and resource
    server, and we successfully implemented an implicit flow. Towards the end, we
    applied method-level authorization in Spring Security.
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
- en: In next chapter, we will explore another tool, called JHipster. It is an open
    source application generator framework that's mainly used to develop web applications
    and microservices with responsive web fronts (Angular or React) and the Spring
    framework as a backend.
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
