<html><head></head><body><div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Advanced REST APIs</h1>
                </header>
            
            <article class="calibre2">
                
<p class="calibre6">In this chapter, <span class="calibre10">we're going to take a look at adding designs to a REST API using contract and validation. Then, we will learn about using JSON Web Tokens for authentication. And finally, we'll explore diagnosability, that is, logging, metrics, and tracing for a REST API. In this chapter, we'll cover the following topics:</span></p>
<ul class="calibre14">
<li class="calibre15">Applying Design by Contract—adding validation</li>
<li class="calibre15">Using JSON Web Tokens for authentication</li>
<li class="calibre15">Diagnosability—logging, metrics, and tracing</li>
</ul>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Applying Design by Contract – adding validation</h1>
                </header>
            
            <article class="calibre2">
                
<p class="calibre6">In this section, we're going to take a look at adding validation to the <kbd class="calibre17">@PathParam</kbd> annotation using Javax validation annotations. We will be adding validation POJOs and <kbd class="calibre17">POST</kbd> bodies using Javax validation annotations. I'm going to show you how to send the HTTP 404 status code for bad and invalid requests.</p>
<p class="calibre6">Let's switch to our IDE. As usual, we will prepare a small template project to get started. We create a <kbd class="calibre17">BookResource</kbd> similar to the one created in the previous <a href="c828a46b-ed97-455d-8228-15b525774aa5.xhtml" class="pcalibre pcalibre3 pcalibre1 calibre12 pcalibre2">Chapter 5</a>, <em class="calibre18">Using Server-Sent Events (SSEs)</em>. There's one thing missing though: there's nothing that tells the API that the ISBN is valid. Let's assume we wanted to add a validation for the ISBN and make sure that it's always 10-characters long and that it only contains digits. Of course, we could program this manually, but there's a better approach.</p>
<p class="calibre6">Instead, we can use Javax validation for this. Let's do that by adding the <kbd class="calibre17">@Pattern</kbd> annotation. If you hover over the <kbd class="calibre17">@Pattern</kbd> annotation in your IDE, you'll see that this annotation comes from the Javax validation constraints package. We want to use <kbd class="calibre17">@Pattern</kbd> to say that we want a regular expression (<kbd class="calibre17">regexp</kbd>) only <kbd class="calibre17">[0-9]</kbd>, and it needs to be 10-digits long; that's all you need to validate the ISBN in this case:</p>
<pre class="calibre22">    @GET<br class="calibre2"/>    @Path("/{isbn}")<br class="calibre2"/>    public Response book(@PathParam("isbn") @Pattern(<br class="calibre2"/>      regexp = "[0-9]{10}") String isbn) {<br class="calibre2"/>        Book book = Optional.ofNullable(books.get(isbn))<br class="calibre2"/>                    .orElseThrow(NotFoundException::new);<br class="calibre2"/>        return Response.ok(book).build();<br class="calibre2"/>    }</pre>
<p class="calibre6">We have the <kbd class="calibre17">@POST</kbd> method to create a new book, and we are unsure whether the book sent is valid. First, we add a Javax validation (<kbd class="calibre17">@Valid</kbd>) annotation. In this case, we use <kbd class="calibre17">@Valid</kbd>, which refers the validation to the annotations within the <kbd class="calibre17">Book</kbd> class:</p>
<pre class="calibre22">    @POST<br class="calibre2"/>    @Consumes(MediaType.APPLICATION_JSON)<br class="calibre2"/>    public Response create(@Valid Book book, <br class="calibre2"/>      @Context UriInfo uriInfo) {<br class="calibre2"/>        books.put(book.isbn, book);<br class="calibre2"/><br class="calibre2"/>        URI uri = uriInfo.getBaseUriBuilder()<br class="calibre2"/>          .path(BooksResource.class).path(book.isbn).build();<br class="calibre2"/>        return Response.created(uri).build();<br class="calibre2"/>    }</pre>
<p class="calibre6">The <kbd class="calibre17">Book</kbd> class has an <kbd class="calibre17">isbn</kbd> and a <kbd class="calibre17">title</kbd> but no Javax validation annotations. The ISBN should be a valid ISBN and the title should neither be null nor blank. We add the <kbd class="calibre17">@NotBlank</kbd> and <kbd class="calibre17">@NotNull</kbd> annotations for the <kbd class="calibre17">title</kbd> and <kbd class="calibre17">@Pattern</kbd> of <kbd class="calibre17">isbn</kbd>:</p>
<pre class="calibre22">public static class Book {<br class="calibre2"/><br class="calibre2"/>        @Pattern(regexp = "[0-9]{10}")<br class="calibre2"/>        private String isbn;<br class="calibre2"/>        @NotNull<br class="calibre2"/>        @NotBlank<br class="calibre2"/>        private String title;</pre>
<p class="calibre6">Let's put this to the test. Let's open our Postman client and try out the <span class="calibre10">GET Books list</span> API. We see here that we get one book back:</p>
<p class="cdpaligncenter"><img src="Images/e91cb270-da64-4fa5-8303-3f396b266af1.png" width="744" height="356" class="calibre70"/></p>
<p class="calibre6">Now let's try to get a book with an invalid ISBN and see what happens; click on the <span class="calibre10">GET Invalid Book</span> API (<kbd class="calibre17">http://localhost:8080/advanced/books/4711</kbd>). You see <kbd class="calibre17">4711</kbd> in the URI we pass, which is not a valid ISBN because it's not 10-digits long. If we send this, we expect that the server will send us back a bad request; this tells us the request we sent is not valid. If we request a valid book (<span class="calibre10">GET Valid Book</span>), we get status <span class="calibre10">200 OK</span>, which means the first validations work.</p>
<p class="calibre6">Let's create a new valid book by requesting <span class="calibre10">POST new valid book</span>; we can see it has a valid ISBN—10-digits long—and a title. We send this and we get status code <span class="calibre10">201 Created</span> back, as shown in the following screenshot:</p>
<p class="cdpaligncenter"><img src="Images/dbf9a5cb-269e-4469-b465-c6e1249fa593.png" width="759" height="193" class="calibre71"/></p>
<p class="calibre6">Now let's create an invalid book by requesting <span class="calibre10">POST invalid book</span>. Have a look at the <span class="calibre10">Body</span>; you'll see an empty <kbd class="calibre17">title</kbd> and an invalid <kbd class="calibre17">isbn</kbd>:</p>
<pre class="calibre22">{<br class="calibre2"/>    "isbn": "1234560".<br class="calibre2"/>    "title": ""<br class="calibre2"/>}</pre>
<p class="calibre6">If we send this request, we get <span class="calibre10">400 Bad Request</span>; the server will not accept any bad books that do not comply with our validation annotations.</p>
<p class="calibre6">In the next section, we're going to have a look at using JSON Web Tokens for authentication.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Using JSON Web Tokens for authentication</h1>
                </header>
            
            <article class="calibre2">
                
<p class="calibre6">In this section, we're going to take a look at decoding <strong class="calibre8">JSON Web Tokens</strong> (<strong class="calibre8">JWTs</strong>) using the Auth<span class="calibre10"><span class="calibre10">0</span></span> library. We'll see how you can implement and use the <kbd class="calibre17">ContainerRequest</kbd> and <kbd class="calibre17">ContainerResponse</kbd> filters to handle JWT authentication for our REST resources. Finally, we'll be injecting and using decoded JWT in our REST resources.</p>
<p class="calibre6">Let's get started. If you visit the JWT website (<a href="https://jwt.io/" class="pcalibre pcalibre3 pcalibre1 calibre12 pcalibre2">https://jwt.io/</a>), you can find relevant information about JWT. Under <span class="calibre10">Debugger</span>, you can see what a JWT looks like. We can see the token under <span class="calibre10">Encoded</span>—it consists of a <span class="calibre10">HEADER</span>, <span class="calibre10">PAYLOAD</span>, and <span class="calibre10">VERIFY SIGNATURE</span>. This JWT uses symmetric encryption to generate the signature. Therefore this value will later be transmitted by the HTTP authorization header:</p>
<p class="cdpaligncenter"><img src="Images/a7d71f08-d188-433c-8a86-3837dc6e90b6.png" class="calibre72"/></p>
<p class="calibre6">As usual, we prepare a small template project to get started. First, we activate a third-party library, which is required to handle JWT and decode it. We do that by adding the following dependency in the POM file:</p>
<pre class="calibre22">    &lt;dependency&gt;<br class="calibre2"/>        &lt;groupId&gt;com.auth0&lt;/groupId&gt;<br class="calibre2"/>        &lt;artifactId&gt;java-jwt&lt;/artifactId&gt;<br class="calibre2"/>        &lt;version&gt;3.3.0&lt;/version&gt;<br class="calibre2"/>    &lt;/dependency&gt;</pre>
<p class="calibre6">Next, we need to implement the <kbd class="calibre17"><span class="calibre4">ContainerResponse</span></kbd> and <kbd class="calibre17"><span class="calibre4">ContainerRequest</span></kbd> filters; we do that in the <kbd class="calibre17">JwtAuthzVerifier</kbd> class. We let the <kbd class="calibre17"><span class="calibre4">JwtAuthzVerifier</span></kbd> class implement <kbd class="calibre17"><span class="calibre4">ContainerRequestFilter</span></kbd> and <kbd class="calibre17"><span class="calibre4">ContainerResponseFilter</span></kbd>:</p>
<pre class="calibre22">@Provider<br class="calibre2"/>public class JwtAuthzVerifier implements ContainerRequestFilter, ContainerResponseFilter {</pre>
<p class="calibre6">Let's implement those two methods. We need to implement <kbd class="calibre17">filter</kbd>. To do so, we extract the authorization header from <kbd class="calibre17">requestContext</kbd> and then decode the bearer token (<kbd class="calibre17">decodeBearerToken</kbd>):</p>
<pre class="calibre22">    @Override<br class="calibre2"/>    public void filter(ContainerRequestContext requestContext) {<br class="calibre2"/>        try {<br class="calibre2"/>            String header = getAuthorizationHeader(requestContext);<br class="calibre2"/>            decodeBearerToken(header);<br class="calibre2"/>        }</pre>
<p class="calibre6">To obtain the request header, we use <kbd class="calibre17">ContainerRequestContext</kbd> and extract <kbd class="calibre17">AUTHORIZATION_HEADER</kbd>:</p>
<pre class="calibre22">    private String getAuthorizationHeader(<br class="calibre2"/>      ContainerRequestContext requestContext) {<br class="calibre2"/>        return requestContext.getHeaderString(AUTHORIZATION_HEADER);<br class="calibre2"/>    }</pre>
<p class="calibre6">Once we have that, we can decode the bearer token. This is where we will use the Auth0 library. We've provided a bit of verification code, which is basically programming against the used library. Finally, on the response, we will throw away the decoded JWT:</p>
<pre class="calibre22">    private void decodeBearerToken(String authorization) {<br class="calibre2"/>        String token = extractJwtToken(authorization);<br class="calibre2"/>        Verification verification = <br class="calibre2"/>          JWT.require(getSecret()).acceptLeeway(1L);<br class="calibre2"/>        DecodedJWT jwt = verify(token, verification);<br class="calibre2"/>        decodedJWT.set(jwt);<br class="calibre2"/>    }</pre>
<p class="calibre6">That's almost it, but a couple of things are missing. We need to annotate <kbd class="calibre17">@Provider</kbd> under <kbd class="calibre17">@ApplicationScoped</kbd>. We also need an annotation that will be active, so we call <kbd class="calibre17">@JwtAuthz</kbd>:</p>
<pre class="calibre22">@ApplicationScoped<br class="calibre2"/>@JwtAuthz<br class="calibre2"/>@Provider</pre>
<p class="calibre6">Let's have a look at the <kbd class="calibre17"><span class="calibre4">@JwtAuthz</span></kbd> annotation. So far, this is a very basic annotation, but we need a special <span class="calibre10">annotation. W</span>e need the <kbd class="calibre17">@NameBinding</kbd> annotation. Basically, this annotation binds the annotated <kbd class="calibre17">@Provider</kbd>, which we've done in the <kbd class="calibre17">JwtAuthzVerifier</kbd> class. In this case, we can put the <kbd class="calibre17">@Target</kbd> annotation on a <kbd class="calibre17">TYPE</kbd>, which is the REST resource, or a REST method:</p>
<pre class="calibre22">@NameBinding<br class="calibre2"/>@Retention(RetentionPolicy.RUNTIME)<br class="calibre2"/>@Target({ElementType.TYPE, ElementType.METHOD})<br class="calibre2"/>public @interface JwtAuthz {<br class="calibre2"/>}</pre>
<p class="calibre6">Next, we need to activate our resource and the verifier. Let's jump to <kbd class="calibre17">AuthenticationResource</kbd> and to the last final bit. We need to activate our JWT filter for this resource. We do that using the <kbd class="calibre17">@JwtAuthz</kbd> annotation directly on the resource:</p>
<pre class="calibre22">@Path("/jwt")<br class="calibre2"/>@JwtAuthz<br class="calibre2"/>public class AuthenticationResource {</pre>
<p class="calibre6">Then we inject the decoded JWT:</p>
<pre class="calibre22">    @Inject<br class="calibre2"/>    private DecodedJWT decodedJWT;</pre>
<p class="calibre6">Finally, we add an <kbd class="calibre17">authenticate</kbd> method. We obtain the claims (<kbd class="calibre17">decodedJWT.getClaims()</kbd>) of the decoded JWT. We construct a <kbd class="calibre17">response</kbd> and echo the <kbd class="calibre17">name</kbd> and <kbd class="calibre17">subject</kbd> claims:</p>
<pre class="calibre22">    @GET<br class="calibre2"/>    @Path("/authenticate")<br class="calibre2"/>    public Response authenticate() {<br class="calibre2"/>        Map&lt;String, Claim&gt; claims = decodedJWT.getClaims();<br class="calibre2"/><br class="calibre2"/>        JsonObject response = Json.createObjectBuilder()<br class="calibre2"/>                .add("name", claims.get("name").asString())<br class="calibre2"/>                .add("subject", claims.get("sub").asString())<br class="calibre2"/>                .build();<br class="calibre2"/><br class="calibre2"/>        return Response.ok(response).build();<br class="calibre2"/>    }<br class="calibre2"/>}</pre>
<p class="calibre6">Let's switch to our REST client. If you want to access this resource, go to the path of our <kbd class="calibre17">authenticate</kbd> resource. Here, we've prepared an <kbd class="calibre17">Authorization</kbd> header, and in the <span class="calibre10">Value</span> we use <kbd class="calibre17">Bearer</kbd> as a token type followed by the JSON Web Token in encoded format. When we send this, we should expect the <span class="calibre10">200 OK</span> status. You should see the decoded <kbd class="calibre17">name</kbd> and <kbd class="calibre17">subject</kbd> claims:</p>
<p class="cdpaligncenter"><img src="Images/a4cbc5b1-bc3b-4bae-b076-2be6b531f876.png" width="690" height="491" class="calibre73"/></p>
<p class="calibre6">Let's assume we changed the <span class="calibre10">Value</span> of the <kbd class="calibre17">Authorization</kbd> header to <kbd class="calibre17">Bearer notvalid</kbd>. If we send this, we should get <span class="calibre10">401 Unauthorized</span> and the <kbd class="calibre17">Invalid JWT token.</kbd> message. We just secured our REST API using a simple JWT authentication:</p>
<p class="calibre6"/>
<p class="calibre6"/>
<p class="cdpaligncenter"><img src="Images/63bd77cc-a4d8-47d4-9401-0d8b84d4e87b.png" width="902" height="467" class="calibre74"/></p>
<p class="calibre6">In the next section, we will talk about diagnosability and adding logging, metrics, and tracing to your REST APIs.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Diagnosability – logging, metrics, and tracing</h1>
                </header>
            
            <article class="calibre2">
                
<p class="calibre6">In this section, we're going to take a look at adding request-and-response logging using the Jersey logging feature. We'll have a look at using MicroProfile 1.2 APIs to add metrics and health endpoints. Finally, we'll see how we can include tracing with the <kbd class="calibre17">OpenTracing</kbd> API and Jaeger.</p>
<p class="calibre6">Before we start, let's have a quick look at the diagnosability triangle. Diagnosability is really important when it comes to developing web services and distributed applications. When people talk about metrics, you might have heard of Prometheus; when it comes to logging, maybe you've heard about Fluentd; and for tracing, OpenTracing is the most state-of-the-art API out there. Make sure you have a look at these technologies and their stacks.</p>
<p class="calibre6"/>
<p class="calibre6">Let's explore the diagnosability triangle for a small web service:</p>
<p class="cdpaligncenter"><img src="Images/727f06ad-8c5d-460d-ba17-b05464817def.png" class="calibre75"/></p>
<div class="mce-root">The diagnosability triangle</div>
<p class="calibre6">Let's open the IDE to get started. Open the POM file and add a few dependencies. The first dependency we want to enable is the <kbd class="calibre17">jersey.core</kbd> or <kbd class="calibre17">jersey-common</kbd> dependency. This is where the logging feature and the logging filter reside:</p>
<pre class="calibre22"><br class="calibre2"/>    &lt;dependency&gt;<br class="calibre2"/>        &lt;groupId&gt;org.glassfish.jersey.core&lt;/groupId&gt;<br class="calibre2"/>        &lt;artifactId&gt;jersey-common&lt;/artifactId&gt;<br class="calibre2"/>        &lt;version&gt;2.26&lt;/version&gt;<br class="calibre2"/>        &lt;scope&gt;provided&lt;/scope&gt;<br class="calibre2"/>    &lt;/dependency&gt;</pre>
<p class="calibre6">To enable request-and-response logging for every request, we activate <kbd class="calibre17">LoggingFeature</kbd> in the <kbd class="calibre17">JAXRSConfiguration</kbd> class:</p>
<pre class="calibre22">        classes.add(MetricsResource.class);<br class="calibre2"/>        classes.add(LoggingFeature.class);<br class="calibre2"/><br class="calibre2"/>        return classes;<br class="calibre2"/>    }</pre>
<p class="calibre6">If you hover over <kbd class="calibre17">LoggingFeature</kbd> in our IDE, you can see that it comes from the <kbd class="calibre17">jersey-common</kbd> module; usually this is already provided so we don't need to write it—no extra dependency to add. The final thing we want to do is modify <kbd class="calibre17">LoggingFeature</kbd>. Here, we add a few extra properties and we're done:</p>
<pre class="calibre22">        properties.put(LoggingFeature.LOGGING_FEATURE_LOGGER_NAME,   <br class="calibre2"/>          "RequestLogger");<br class="calibre2"/>        properties.put(LoggingFeature.LOGGING_FEATURE_LOGGER_LEVEL, <br class="calibre2"/>          Level.INFO.getName());</pre>
<p class="calibre6">This will log every request and every response to your log file. Be careful; it will produce some seriously large logs. Next, we look at how we can use MicroProfile APIs to add metrics and health checks.</p>
<p class="calibre6">Let's switch to our POM and activate MicroProfile APIs. Since we're using Payara micro edition, those APIs are also available to us. There are APIs for health checks, metrics, fault-tolerance if you need it, and for JWT Auth if you don't want to implement this yourself. We need to add the following dependencies in our POM file (the entire code can be found at <a href="https://github.com/PacktPublishing/Building-RESTful-Web-Services-with-Java-EE-8" class="pcalibre pcalibre3 pcalibre1 calibre12 pcalibre2">https://github.com/PacktPublishing/Building-RESTful-Web-Services-with-Java-EE-8</a>):</p>
<pre class="calibre22"><br class="calibre2"/>    &lt;dependency&gt;<br class="calibre2"/>        &lt;groupId&gt;org.eclipse.microprofile.health&lt;/groupId&gt;<br class="calibre2"/>        &lt;artifactId&gt;microprofile-health-api&lt;/artifactId&gt;<br class="calibre2"/>        &lt;version&gt;1.0&lt;/version&gt;<br class="calibre2"/>        &lt;scope&gt;provided&lt;/scope&gt; <br class="calibre2"/>    &lt;/dependency&gt;<br class="calibre2"/>    ...<br class="calibre2"/>    ...<br class="calibre2"/>    &lt;dependency&gt;<br class="calibre2"/>        &lt;groupId&gt;org.eclipse.microprofile.jwt&lt;/groupId&gt;<br class="calibre2"/>        &lt;artifactId&gt;microprofile-jwt-auth-api&lt;/artifactId&gt;<br class="calibre2"/>        &lt;version&gt;1.0&lt;/version&gt;<br class="calibre2"/>        &lt;scope&gt;provided&lt;/scope&gt;<br class="calibre2"/>    &lt;/dependency&gt;</pre>
<p class="calibre6">Let's go to <kbd class="calibre17">MetricsResource</kbd> and add a few metrics. This is actually really straightforward. Imagine you have a REST resource and you're interested in how long it took for the invocation of the <kbd class="calibre17">POST</kbd> request. For this, you can add the <kbd class="calibre17">@Timed</kbd> annotation. We specify we want the <kbd class="calibre17">unit</kbd> in <kbd class="calibre17">"milliseconds"</kbd> and MicroProfile will make sure that every invocation is timed:</p>
<pre class="calibre22">    @POST<br class="calibre2"/>    @Path("/timed")<br class="calibre2"/>    @Timed(displayName = "Timed invocation", unit = "milliseconds")</pre>
<p class="calibre6">It's even easier if you just want to count invocations. For this, we can use the <kbd class="calibre17">@Counted</kbd> annotation:</p>
<pre class="calibre22">    @POST<br class="calibre2"/>    @Path("/counted")<br class="calibre2"/>    @Counted(monotonic = true)</pre>
<p class="calibre6">Finally, if you're interested in the current absolute value, you can use <kbd class="calibre17">@Gauge</kbd>:</p>
<pre class="calibre22">    @Gauge(displayName = "Gauge invocation", unit = "seconds")<br class="calibre2"/>    public long gauge() {<br class="calibre2"/>        return poolSize.get();</pre>
<p class="calibre6">So <kbd class="calibre17">@Counted</kbd>, <kbd class="calibre17">@Gauge</kbd>, and <kbd class="calibre17">@Timed</kbd> are the three metric annotations you can use.</p>
<p class="calibre6">Maybe we also want to add some health checks, because a good microservice should provide health checks. We can specify an <kbd class="calibre17">@ApplicationScoped</kbd> bean. We annotate it using <kbd class="calibre17">@Health</kbd>, which implements <kbd class="calibre17">HealthCheck</kbd>; this comes from the MicroProfile API. Then we implement our basic health-check logic:</p>
<pre class="calibre22">public class EverythingOkHealthCheck implements HealthCheck {<br class="calibre2"/>    @Override<br class="calibre2"/>    public HealthCheckResponse call() {<br class="calibre2"/>        return HealthCheckResponse<br class="calibre2"/>                .named("everythingOk")<br class="calibre2"/>                .up()<br class="calibre2"/>                .withData("message", "Everything is OK!")<br class="calibre2"/>                .build();<br class="calibre2"/>    }<br class="calibre2"/>}</pre>
<p class="calibre6">The last thing is tracing—this is a really complicated issue. I want to show you how we can add tracing to your web service. First, we add the tracing API, then we add Jaeger as the tracing implementation. We also use a special annotation to add OpenTracing to JAX-RS 2:</p>
<pre class="calibre22"><br class="calibre2"/>    &lt;dependency&gt;<br class="calibre2"/>        &lt;groupId&gt;io.opentracing&lt;/groupId&gt;<br class="calibre2"/>        &lt;artifactId&gt;opentracing-api&lt;/artifactId&gt;<br class="calibre2"/>        &lt;version&gt;0.31.0&lt;/version&gt;<br class="calibre2"/>    &lt;/dependency&gt;<br class="calibre2"/>    &lt;dependency&gt;<br class="calibre2"/>        &lt;groupId&gt;com.uber.jaeger&lt;/groupId&gt;<br class="calibre2"/>        &lt;artifactId&gt;jaeger-core&lt;/artifactId&gt;<br class="calibre2"/>        &lt;version&gt;0.25.0&lt;/version&gt;<br class="calibre2"/>    &lt;/dependency&gt;<br class="calibre2"/>    &lt;dependency&gt;<br class="calibre2"/>        &lt;groupId&gt;io.opentracing.contrib&lt;/groupId&gt;<br class="calibre2"/>        &lt;artifactId&gt;opentracing-jaxrs2&lt;/artifactId&gt;<br class="calibre2"/>        &lt;version&gt;0.1.3&lt;/version&gt;<br class="calibre2"/>    &lt;/dependency&gt;</pre>
<p class="calibre6">These are the required dependencies. After this we just need to activate the tracer. This is done in only a couple of lines of code. <span class="calibre10">We construct a tracing <kbd class="calibre17">Configuration</kbd> from the environment. We register this <kbd class="calibre17">Configuration</kbd> and <kbd class="calibre17">getTracer</kbd> using <kbd class="calibre17">GlobalTracer</kbd></span>:</p>
<pre class="calibre22">@WebListener<br class="calibre2"/>public class OpenTracingContextInitializer implements ServletContextListener {<br class="calibre2"/>    @Override<br class="calibre2"/>    public void contextInitialized(ServletContextEvent sce) {<br class="calibre2"/>        Configuration configuration = Configuration.fromEnv();<br class="calibre2"/>        GlobalTracer.register(configuration.getTracer());<br class="calibre2"/>    }<br class="calibre2"/>}</pre>
<p class="calibre6">Let's see what our web service looks like.</p>
<p class="calibre6">Open Postman and issue a few requests, such as <span class="calibre10">POST Timed Metric</span> and <span class="calibre10">POST Counted Metric</span>. <span class="calibre10"><span class="calibre10">POST Timed Metric</span></span> invokes the <kbd class="calibre17">@Timed</kbd> request. <span class="calibre10"><span class="calibre10">POST Counted Metric</span></span> invokes the <kbd class="calibre17">@Counted</kbd> request; we invoke this one a couple of times.</p>
<p class="calibre6">We invoke the <span class="calibre10">GET Metrics</span> endpoint, which is provided automatically by the MicroProfile implementation. We issue our metrics and we can see our custom metrics, such as <kbd class="calibre17">MetricsResource.gauge</kbd>, <kbd class="calibre17"><span class="calibre4">MetricsResource.timed</span></kbd>, and <kbd class="calibre17"><span class="calibre4">MetricsResource.timed</span></kbd>.</p>
<p class="calibre6">If we don't want JSON and want to use Prometheus, we can do that by invoking the <span class="calibre10">Metrics for Prometheus</span> GET request. We can see the Prometheus metrics data automatically provided.</p>
<p class="calibre6">You can also invoke the <span class="calibre10">GET Healthcheck</span> request to see whether everything is okay, we should get the following Body in Postman:</p>
<pre class="calibre22">{<br class="calibre2"/>    "outcome": "UP"/<br class="calibre2"/>    "checks": [<br class="calibre2"/>        {<br class="calibre2"/>            "name": "everythingOk",<br class="calibre2"/>            "state": "UP",<br class="calibre2"/>            "data": {<br class="calibre2"/>                "message": "Everything is OK"<br class="calibre2"/>            }<br class="calibre2"/>        }<br class="calibre2"/>    ]<br class="calibre2"/>}</pre>
<p class="calibre6">Everything is working and we're done.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article class="calibre2">
                
<p class="calibre6">In this chapter, we looked at validating REST API parameters and payloads using Javax validation. We learned how to add JWT paste authentication to a REST service and decoded JSON Web Tokens manually. Finally, we talked about adding, logging, and metrics, and tracing using Jersey, MicroProfile, and other open source components.</p>


            </article>

            
        </section>
    </div>



  </body></html>