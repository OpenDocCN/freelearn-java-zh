- en: 15\. Processing Data with Streams
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 15. 使用流处理数据
- en: Overview
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 概述
- en: This chapter discusses the Stream API in Java that allows you to write effectively,
    with fewer lines of code. Once you have a firm grasp of the differences between
    parallel and sequential streams (defined and outlined in the early sections),
    you will be able to practice using the Java Stream API to work with arrays and
    collections by first learning how to create and close those streams. The next
    step is to explore the different types of operations available to you in Java,
    their definitions and their respective functions. The first you will encounter
    are terminal operations and reducers which you will use to extract data from a
    stream of elements. You will then move on to intermediate operations to filter,
    map, and otherwise mutate stream structures. And, finally, in this chapter's final
    exercise and activity, you will learn to apply different types of collectors to
    wrap stream elements in new containers.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章讨论了Java中的Stream API，它允许你用更少的代码行有效地编写程序。一旦你掌握了并行流和顺序流之间的区别（在早期章节中定义和概述），你将能够通过首先学习如何创建和关闭这些流来练习使用Java
    Stream API来处理数组和集合。下一步是探索Java中可用的不同类型的操作、它们的定义和相应的功能。你将首先遇到的是终端操作和归约器，你将使用它们从元素流中提取数据。然后，你将转向中间操作来过滤、映射以及其他方式修改流结构。最后，在本章的最后练习和活动中，你将学习如何应用不同类型的收集器来将流元素包装在新容器中。
- en: Introduction
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: Java 8 introduced the new Stream API. With streams, Java programmers can now
    use a more declarative style of writing programs that you have previously only
    seen in functional programming languages or functional programming libraries.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: Java 8引入了新的Stream API。有了流，Java程序员现在可以使用一种更声明性的编程风格来编写程序，这种风格你之前只在函数式编程语言或函数式编程库中见过。
- en: Using streams, you can now write more expressive programs with fewer lines of
    code, and easily chain multiple operations on large lists. Streams also make it
    simple to parallelize your operations on lists—that is, should you have very large
    lists or complex operations. One thing that is important to remember about streams
    is that, while it might appear as though they're an improved collection, they're
    actually not. Streams do not have any storage of their own; instead, they use
    the storage of the supplied source.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 使用流，你现在可以用更少的代码行写出更具有表现力的程序，并且可以轻松地对大列表上的多个操作进行链式调用。流还使得在列表上并行化操作变得简单——也就是说，如果你有非常大的列表或复杂的操作。关于流，有一件重要的事情需要记住，那就是，尽管它们可能看起来像是一个改进的集合，但实际上并不是。流没有自己的存储；相反，它们使用提供源的数据存储。
- en: 'In Java, there are four types of streams: `Stream`, which is used for streaming
    objects; `IntStream`, which is for streaming integers; `LongStream`, which streams
    longs; and finally, `DoubleStream`, which, of course, streams doubles. All of
    these streams work in exactly the same way, except they''re specialized to work
    with their respective types.'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java中，有四种类型的流：`Stream`，用于流式传输对象；`IntStream`，用于流式传输整数；`LongStream`，用于流式传输长整型；最后是`DoubleStream`，当然，用于流式传输双精度浮点数。所有这些流都以完全相同的方式工作，除了它们专门用于处理各自的数据类型。
- en: Note
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Diving into the code, you'll find that each of these types is just an interface
    with static methods pointing back to the `StreamSupport` class. This is the core
    API for anyone wanting to write stream-specific libraries. However, when building
    an application, you're usually fine to use the four standard stream interfaces
    and static generator functions.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 深入代码，你会发现这些类型只是指向`StreamSupport`类的静态方法的接口。这是任何想要编写特定流库的人的核心API。然而，在构建应用程序时，通常可以使用四个标准流接口和静态生成函数。
- en: The source of a stream can be either single elements, collections, arrays, or
    even files. Following the stream source is a number of intermediate operations
    that form the core pipeline. The pipeline ends with a terminal operation that,
    usually, either loops through the remaining elements to create a side effect or
    reduces them to a specific value—for example, counting how many elements there
    are left in the last stream.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 流的来源可以是单个元素、集合、数组，甚至是文件。在流源之后是一系列中间操作，它们构成了核心管道。管道以终端操作结束，通常，它要么遍历剩余的元素以创建副作用，要么将它们减少到特定值——例如，计算最后一个流中剩余元素的数量。
- en: Note
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Streams are lazily constructed and executed. This means that a stream is not
    run until the terminal operation has been executed. Source elements are also only
    read as needed; that is, only the required elements are carried through to the
    next operation.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 流是延迟构建和执行的。这意味着只有在执行终端操作时，流才会运行。源元素也只有在需要时才会读取；也就是说，只有所需的元素会被传递到下一个操作。
- en: Creating Streams
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建流
- en: 'There are multiple ways of creating streams in Java; the simplest of these
    is by using the `Stream.of()` function. This function can take either a single
    object or multiple objects in `varargs`:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java中创建流有多种方式；其中最简单的是使用`Stream.of()`函数。这个函数可以接受单个对象或`varargs`中的多个对象：
- en: '[PRE0]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'If you have multiple objects in your stream, then use the `varargs` version:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你流中有多个对象，则使用`varargs`版本：
- en: '[PRE1]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The primitive versions of these streams work in an identical fashion; just replace
    the `Object` instances with integers, longs, or doubles.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 这些流的原始版本以相同的方式工作；只需将`Object`实例替换为整数、长整型或双精度浮点型。
- en: 'You can also create streams from different collections—for example, lists and
    arrays. Creating a stream from a list will look like this:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以从不同的集合中创建流——例如，列表和数组。从列表创建流看起来像这样：
- en: '[PRE2]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'To create a stream from an array of items, you can use the `Arrays` class,
    just like the primitive versions of streams do:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 要从项目数组创建流，你可以使用`Arrays`类，就像原始版本的流一样：
- en: '[PRE3]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'There is one special type of stream that covers the dreaded null type gracefully,
    and is detailed as follows:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 有一种特殊的流类型可以优雅地处理令人讨厌的null类型，具体如下：
- en: '[PRE4]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This stream will take one single object that can be null. If the object is null,
    then it will generate an empty stream; alternatively, if the object is not null,
    it will generate a stream of that one object. This can, of course, be very handy
    in situations where we're unsure about the state of sources.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 这个流将取一个单独的对象，该对象可以是null。如果对象为null，则将生成一个空流；或者，如果对象不为null，则将生成一个包含该单个对象的流。当然，在不确定源状态的情况下，这可以非常方便。
- en: 'Another way to generate a stream of elements is by using the `Stream.iterate()`
    generator function. This function will generate an infinite number of elements
    in your stream until you tell it to stop, starting at the seed element:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 生成元素流的另一种方法是使用`Stream.iterate()`生成函数。这个函数将在你告诉它停止之前，在流中生成无限数量的元素，从种子元素开始：
- en: '[PRE5]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'In this example, we''re creating a stream of five elements, starting with index
    `0`. This stream will contain the elements `0`, `1`, `2`, `3`, and `4`:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们正在创建一个包含五个元素的流，从索引`0`开始。这个流将包含元素`0`、`1`、`2`、`3`和`4`：
- en: Note
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The `Stream.iterate()` generator function can be quite hazardous if you do not
    provide the proper limits. There are a number of ways to create infinite streams—usually
    by placing operations in the wrong order or forgetting to apply a limit to the
    stream.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 如果不提供适当的限制，`Stream.iterate()`生成函数可能会非常危险。有几种方法可以创建无限流——通常是通过错误地放置操作顺序或忘记对流应用限制。
- en: There is also a special `Builder` class, which is embedded in the `Stream` type.
    This `Builder` class allows you to add elements as you create them; it removes
    the need to keep an `ArrayList`—or other collection—as a temporary buffer for
    elements.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，还有一个特殊的`Builder`类，它嵌入在`Stream`类型中。这个`Builder`类允许你在创建元素时添加元素；它消除了需要保持`ArrayList`或其他集合作为元素临时缓冲区的需求。
- en: 'The `Builder` class has a very simple API; you can `accept()` an element into
    the builder, which is perfect when you want to generate elements from a loop:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '`Builder`类有一个非常简单的API；你可以将一个元素`accept()`到构建器中，这在你想从循环中生成元素时非常完美：'
- en: '[PRE6]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'You can also `add()` elements to the builder. The `add()` method allows chaining,
    which is perfect for when you don''t want to generate elements from a loop, but
    instead add them in a single line:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以向构建器中`add()`元素。`add()`方法允许链式调用，这在你不希望从循环中生成元素，而是希望在一行中添加它们时非常完美：
- en: '[PRE7]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'To create the stream using a builder, you can call the `build()` method when
    all the methods have been added. However, note that if you try to add elements
    to the builder after the `build()` method has been called, it will throw an `IllegalStateException`:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 使用构建器创建流时，当所有方法都已添加后，你可以调用`build()`方法。然而，请注意，如果在调用`build()`方法之后尝试向构建器中添加元素，它将抛出`IllegalStateException`异常：
- en: '[PRE8]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: All these simple ways of creating streams use the same underlying helper class,
    called `StreamSupport`. This class has a number of helpful and advanced methods
    for creating streams with different properties. The common denominator for all
    of these streams is `Spliterator`.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些创建流的方法都使用相同的底层辅助类，称为`StreamSupport`。此类具有创建具有不同属性的流的许多有用和高级方法。所有这些流的共同特征是`Spliterator`。
- en: Parallel Streams
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 并行流
- en: Streams are either sequential or parallel in the Java Stream API. Sequential
    streams use just a single thread in order to perform any operation. Usually, you'll
    find that this stream is more than enough to solve most problems; however, sometimes,
    you may require multiple threads running on multiple cores.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java Stream API中，流要么是顺序的，要么是并行的。顺序流仅使用单个线程来执行任何操作。通常，您会发现这个流足以解决大多数问题；然而，有时您可能需要多个核心上的多个线程运行。
- en: Parallel streams are operated on in parallel by multiple threads on multiple
    cores. They utilize `ForkJoinPool` in the JVM to launch multiple threads. They
    can be a very powerful tool when you find yourself in a performance hotspot. However,
    as parallel streams utilize multiple threads, you should be wary of using them
    unless needed; the overhead of parallel streams may very well create more problems
    than they solve.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 并行流在多个核心上的多个线程上并行操作。它们在JVM中使用`ForkJoinPool`来启动多个线程。当您发现自己处于性能热点时，它们可以是一个非常强大的工具。然而，由于并行流使用多个线程，除非需要，否则您应该谨慎使用它们；并行流的开销可能会产生比解决的问题更多的问题。
- en: Note
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Parallel streams are a double-edged sword. They can be extremely useful in certain
    situations, however, at the same time, they can completely lock your program down.
    As parallel streams utilize the common `ForkJoinPool`, they spawn threads that
    may block your application and other system components to such a degree that the
    user will be affected.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 并行流是一把双刃剑。在某些情况下，它们可能非常有用，然而，同时，它们也可能完全锁定您的程序。因为并行流使用公共的`ForkJoinPool`，它们可能会产生线程，这些线程可能会阻塞您的应用程序和其他系统组件，以至于用户会受到
    影响。
- en: 'To create a parallel stream, you can use the `Collections.parallelStream()`
    method, which will attempt to create a parallel stream:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建并行流，您可以使用`Collections.parallelStream()`方法，它将尝试创建一个并行流：
- en: '[PRE9]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Alternatively, you can make a stream parallel by using the `BaseStream.parallel()`
    intermediate operation:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，您可以使用`BaseStream.parallel()`中间操作使流并行化：
- en: '[PRE10]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Note that, at any point between the source and the terminal operation, you
    can change the type of the stream, using the `BaseStream.parallel()` or `BaseStream.sequential()`
    operations. These operations will only have an impact on the stream if they need
    to change the underlying state of the stream; if the stream already has the correct
    state, it will simply return itself. Calling `BaseStream.parallel()` multiple
    times will have no impact on performance:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在源和终端操作之间，您可以使用`BaseStream.parallel()`或`BaseStream.sequential()`操作更改流的类型。如果需要更改流的底层状态，这些操作将对流产生影响；如果流已经具有正确的状态，它将简单地返回自身。多次调用`BaseStream.parallel()`对性能没有影响：
- en: '[PRE11]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Encounter Order
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 遭遇顺序
- en: Depending on the type of the source for the stream, it may have a different
    encounter order. Lists, for example, have a built-in ordering of elements—also
    called the index. The ordering of the source also means that elements will be
    encountered in that order; however, you can change this encounter order using
    the `BaseStream.unordered()` and `Stream.sorted()` intermediate operations.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 根据流源的类型，它可能具有不同的遭遇顺序。例如，列表具有内置的元素排序——也称为索引。源排序还意味着元素将以该顺序被遇到；然而，您可以使用`BaseStream.unordered()`和`Stream.sorted()`中间操作来更改这种遭遇顺序。
- en: The `unordered()` operation doesn't change the ordering of a stream; instead,
    it only attempts to remove a specific attribute and informs us whether a stream
    is ordered or not. The elements will still have a specific order. The whole point
    of unordered streams is to make other operations more performant when applied
    to parallel streams. Applying the `unordered()` operation to a sequential stream
    will make it non-deterministic.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '`unordered()`操作不会改变流的排序；相反，它只尝试移除一个特定属性并通知我们流是否已排序。元素仍然具有特定的顺序。无序流的整个目的就是在应用于并行流时使其他操作更高效。将`unordered()`操作应用于顺序流将使其非确定性。'
- en: Closing Streams
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 关闭流
- en: Much like the streams of previous Java versions, `InputStream` and `OutputStream`,
    the Stream API includes a `close()` operation. However, in most cases, you'll
    never actually need to worry about closing your streams. The only time you should
    worry about closing your streams is when the source is a system resource—such
    as files or sockets—which need to be closed to avoid hogging resources from the
    system.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 与之前 Java 版本的流类似，`InputStream` 和 `OutputStream`，Stream API 包含一个 `close()` 操作。然而，在大多数情况下，你实际上根本不需要担心关闭你的流。你应该担心关闭流的情况是当源是一个系统资源——例如文件或套接字——需要关闭以避免占用系统资源。
- en: 'The `close()` operation returns void, meaning that after you call `close()`,
    the stream is unavailable for any other intermediate or terminal operations; although
    it is possible to register `close` handlers that will be informed when the stream
    has been closed. The `close` handler is a `Runnable` functional interface; preferably,
    you''ll register them using a lambda function:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '`close()` 操作返回 void，这意味着在调用 `close()` 之后，流将无法进行任何其他中间或终端操作；尽管可以在流关闭时注册 `close`
    处理器来通知。`close` 处理器是一个 `Runnable` 函数式接口；最好使用 lambda 函数来注册它们：'
- en: '[PRE12]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'You can register any number of `close` handlers in your pipeline. The `close`
    handlers will always run even if any one of them renders an exception in their
    code. Additionally, it is worth noting that they will always be called in the
    same order in which they''re added to the pipeline, regardless of the encounter
    order of the stream:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在你的管道中注册任意数量的 `close` 处理器。即使其中任何一个处理器在其代码中抛出异常，`close` 处理器也总是会运行。此外，值得注意的是，它们将始终以它们被添加到管道中的相同顺序被调用，而不管流的遇到顺序如何：
- en: '[PRE13]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Note
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Even if it's possible to register a close handler on any stream, it might not
    actually run if the stream doesn't need to be closed.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 即使可以在任何流上注册关闭处理器，如果流不需要关闭，它可能实际上不会运行。
- en: 'Since Java 7, there is an interface called `AutoCloseable`, which will attempt
    to automatically close held resources in a `try-with-resources` statement. The
    `BaseStream` interface, which all streams inherit from, extends this `AutoCloseable`
    interface. This means that any stream will attempt to release resources automatically
    if wrapped in a try-with-resources statement:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 自 Java 7 以来，有一个名为 `AutoCloseable` 的接口，它将尝试在 try-with-resources 语句中自动关闭所持有的资源。所有流都继承自的
    `BaseStream` 接口扩展了这个 `AutoCloseable` 接口。这意味着任何流如果被包裹在 try-with-resources 语句中，都会尝试自动释放资源：
- en: '[PRE14]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: While the preceding example does work, there's rarely any reason to wrap a basic
    stream in a try-with-resources statement, other than if you explicitly need to
    run logic when the stream has finished running. This example will first print
    `true` to the terminal, and after that print `Closed`.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然前面的例子确实可行，但通常没有必要在基本流上包裹 try-with-resources 语句，除非你明确需要在流运行完成后执行逻辑。此示例将首先将
    `true` 打印到终端，然后打印 `Closed`。
- en: Terminal Operations
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 终端操作
- en: Every pipeline needs to end with a terminal operation; without this, the pipeline
    will not be executed. Unlike intermediate operations, terminal operations may
    have various return values as they mark the end of the pipeline. You cannot apply
    another operation after a terminal operation.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 每个管道都需要以终端操作结束；没有这个，管道将不会执行。与中间操作不同，终端操作可能有各种返回值，因为它们标志着管道的结束。在终端操作之后，你不能应用另一个操作。
- en: Note
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: When a terminal operation is applied to a stream, you cannot use that stream
    again. Therefore, storing references to streams in code can cause confusion as
    to how that reference might be used – you're not allowed to "split" a stream into
    two different use cases. If you attempt to apply operations on a stream that already
    had the terminal operation executed, then it will throw an `IllegalStateException`
    with the message `stream has already been operated upon or closed`.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 当对流应用终端操作时，你不能再使用该流。因此，在代码中存储流的引用可能会导致混淆，不清楚该引用可能如何使用——不允许“分割”流到两个不同的用例。如果你尝试对一个已经执行了终端操作的流应用操作，那么它将抛出一个带有消息“stream
    has already been operated upon or closed”的 `IllegalStateException`。
- en: 'There are 16 different terminal operations in the Stream API—each of them with
    their own specific use cases. The following is an explanation of each of them:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: Stream API 中有 16 种不同的终端操作——每个都有其特定的用例。以下是对每个操作的说明：
- en: '`forEach`: This terminal operator acts like a normal `for` loop; it will run
    some code for each element in the stream. This is not a thread-safe operation,
    so you''ll need to provide synchronization should you find yourself using shared
    state:'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`forEach`：这个终端操作像是一个普通的`for`循环；它将为流中的每个元素运行一些代码。这不是一个线程安全的操作，所以如果你发现自己正在使用共享状态，你需要提供同步：'
- en: '[PRE15]'
  id: totrans-69
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'If this operation is applied on a parallel pipeline, the order in which elements
    are acted on will not be guaranteed:'
  id: totrans-70
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果在这个并行管道上应用此操作，元素被作用的方式的顺序将无法保证：
- en: '[PRE16]'
  id: totrans-71
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: If the order in which the elements are acted on matters, you should use the
    `forEachOrdered()` terminal operation instead.
  id: totrans-72
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果元素被作用的方式的顺序很重要，你应该使用`forEachOrdered()`终端操作。
- en: '`forEachOrdered`: Much like the `forEach()` terminal operation, this will allow
    you to perform an action for each element in the stream. However, the `forEachOrdered()`
    operation will guarantee the order in which elements are processed, regardless
    of how many threads they''re processed on:'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`forEachOrdered`：与`forEach()`终端操作类似，这将允许你对流中的每个元素执行一个操作。然而，`forEachOrdered()`操作将保证处理元素的顺序，无论它们在多少个线程上被处理：'
- en: '[PRE17]'
  id: totrans-74
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Here, you can see a parallel stream with a defined encounter order. Using the
    `forEachOrdered()` operation, it will always encounter elements in the natural,
    indexed order.
  id: totrans-75
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这里，你可以看到具有定义的遭遇顺序的并行流。使用`forEachOrdered()`操作，它将始终按自然顺序、索引顺序遇到元素。
- en: '`toArray`: These two terminal operations will allow you to convert the elements
    of the stream into an array. The basic version will generate an `Object` array:'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`toArray`：这两个终端操作将允许你将流中的元素转换为数组。基本版本将生成一个`Object`数组：'
- en: '[PRE18]'
  id: totrans-77
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'If you need a specific type of array, you can supply a constructor reference
    for the type of array you need:'
  id: totrans-78
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果你需要一个特定类型的数组，你可以提供一个构造器引用来指定所需的数组类型：
- en: '[PRE19]'
  id: totrans-79
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'A third option is to also write your own generator for the `toArray()` operation:'
  id: totrans-80
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 第三种选择是为你自己的`toArray()`操作编写自己的生成器：
- en: '[PRE20]'
  id: totrans-81
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '`reduce`: To perform a reduction on a stream means to only extract the interesting
    parts of the elements of that stream and reduce them to a single value. There
    are two generic `reduce` operations available. The first, simpler one, takes an
    accumulator function as an argument. It is usually used after a map operation
    is applied on a stream:'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`reduce`：对一个流进行归约意味着只提取该流元素的有用部分，并将它们归约为一个单一值。有两个通用的`reduce`操作可用。第一个，更简单的一个，接受一个累加函数作为参数。它通常在流上应用了映射操作之后使用：'
- en: '[PRE21]'
  id: totrans-83
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The second, more complex version takes an identity that also acts as the initial
    value of the reduction. It also requires an accumulator function where the reduction
    takes place, as well as a combining function to define how two elements are reduced:'
  id: totrans-84
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 第二个更复杂的版本采用了一个同时作为归约初始值的身份。它还要求一个累加函数，其中归约发生，以及一个组合函数来定义如何将两个元素归约：
- en: '[PRE22]'
  id: totrans-85
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: In this example, the accumulator adds up the result of the combining function
    to the identity value, which, in this case, is the total sum of the reduction.
  id: totrans-86
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这个例子中，累加函数将组合函数的结果加到身份值上，在这种情况下，是归约的总和。
- en: '`sum`: This is a more specific reduction operation, which will sum all elements
    in the stream. This terminal operation is only available for `IntStream`, `LongStream`,
    and `DoubleStream`. To use this functionality in a more generic stream, you would
    have to implement a pipeline using the `reduce()` operation, usually preceded
    by a `map()` operation. The following example illustrates the use of `IntStream`:'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sum`：这是一个更具体的归约操作，它将流中的所有元素相加。这个终端操作仅适用于`IntStream`、`LongStream`和`DoubleStream`。要在更通用的流中使用此功能，你需要实现一个使用`reduce()`操作的管道，通常在`map()`操作之前：'
- en: '[PRE23]'
  id: totrans-88
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'This will print the result as `30`. The following example illustrates the use
    of `LongStream`:'
  id: totrans-89
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这将打印出结果为`30`。以下示例说明了`LongStream`的使用：
- en: '[PRE24]'
  id: totrans-90
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'This will print the result as `22`. The following example illustrates the use
    of `DoubleStream`:'
  id: totrans-91
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这将打印出结果为`22`。以下示例说明了`DoubleStream`的使用：
- en: '[PRE25]'
  id: totrans-92
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: This will print the result as `20.6`.
  id: totrans-93
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这将打印出结果为`20.6`。
- en: '`collect`: The collection operation is like the reduce operation, in that it
    takes the elements of a stream and creates a new result. However, instead of reducing
    the stream to a single value, `collect` can take the elements and generate a new
    container or collection that holds all the remaining elements; for example, a
    list. Usually, you would use the `Collectors` `help` class, as it contains a lot
    of ready-to-use collect operations:'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`collect`：收集操作类似于reduce操作，因为它接受流中的元素并创建一个新的结果。然而，与reduce操作不同，`collect`可以接受元素并生成一个新的容器或集合，该集合包含所有剩余的元素；例如，一个列表。通常，你会使用`Collectors`的`help`类，因为它包含许多现成的收集操作：'
- en: '[PRE26]'
  id: totrans-95
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'This would print `[6, 3, 8, 12, 3, 9]` to the console. You can review more
    usages of `Collectors` in the *Using Collectors* section. Another option is to
    write your own supplier, accumulator, and combiner for the `collect()` operation:'
  id: totrans-96
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这将在控制台打印`[6, 3, 8, 12, 3, 9]`。你可以在*使用收集器*部分查看`Collectors`的更多用法。另一种选择是为`collect()`操作编写自己的供应商、累加器和组合器：
- en: '[PRE27]'
  id: totrans-97
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'This can, of course, be simplified in this example by using method references:'
  id: totrans-98
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当然，在这个例子中，可以通过使用方法引用来简化：
- en: '[PRE28]'
  id: totrans-99
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '`min`: As the name suggests, this terminal operation will return the minimum
    value, wrapped in an `Optional`, of all elements in the stream specified according
    to a `Comparator`. In most cases, you''d use the `Comparator.comparingInt()`,
    `Comparator.comparingLong()`, or `Comparator.comparingDouble()` static helper
    functions when applying this operation:'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`min`：正如其名所示，这个终端操作将返回流中所有元素的最小值，用`Optional`包装，并按照指定的`Comparator`进行指定。在应用此操作时，大多数情况下你会使用`Comparator.comparingInt()`、`Comparator.comparingLong()`或`Comparator.comparingDouble()`静态辅助函数：'
- en: '[PRE29]'
  id: totrans-101
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: This should write `Optional[3]`.
  id: totrans-102
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这应该写入`Optional[3]`。
- en: '`max`: The opposite of the `min()` operation, the `max()` operation returns
    the value of the element with the maximum value according to a specified `Comparator`,
    wrapped in an `Optional`:'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`max`：与`min()`操作相反，`max()`操作返回具有最大值的元素的值，根据指定的`Comparator`进行包装，并用`Optional`包装：'
- en: '[PRE30]'
  id: totrans-104
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: This will print `Optional[12]` to the terminal.
  id: totrans-105
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这将在终端打印`Optional[12]`。
- en: '`average`: This is a special type of terminal operation that is only available
    on `IntStream`, `LongStream`, and `DoubleStream`. It returns an `OptionalDouble`
    containing the average of all elements in the stream:'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`average`：这是一个特殊的终端操作，仅在`IntStream`、`LongStream`和`DoubleStream`上可用。它返回一个包含流中所有元素平均值的`OptionalDouble`：'
- en: '[PRE31]'
  id: totrans-107
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: This will give you an `Optional` with the containing value `6.833333333333333`.
  id: totrans-108
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这将为你提供一个包含值`6.833333333333333`的`Optional`。
- en: '`count`: This is a simple terminal operator returning the number of elements
    in the stream. It''s worth noting that, sometimes, the `count()` terminal operation
    will find more efficient ways of calculating the size of the stream. In these
    cases, the pipeline will not even be executed:'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`count`：这是一个简单的终端操作，返回流中的元素数量。值得注意的是，有时`count()`终端操作会找到计算流大小的更有效的方法。在这些情况下，管道甚至不会执行：'
- en: '[PRE32]'
  id: totrans-110
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '`anyMatch`: The `anyMatch()` terminal operator will return true if any of the
    elements in the stream match the specified predicate:'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`anyMatch`：如果流中的任何元素匹配指定的谓词，则`anyMatch()`终端操作将返回`true`：'
- en: '[PRE33]'
  id: totrans-112
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: As there is an element with a value above 10, this pipeline will return `true`.
  id: totrans-113
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 由于有一个值大于10的元素，这个管道将返回`true`。
- en: '`allMatch`: The `allMatch()` terminal operator will return `true` if all the
    elements in the stream match the specified predicate:'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`allMatch`：如果流中的所有元素都匹配指定的谓词，则`allMatch()`终端操作将返回`true`：'
- en: '[PRE34]'
  id: totrans-115
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Since this source has elements whose values are below 10, it should return `false`.
  id: totrans-116
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 由于这个源有值小于10的元素，它应该返回`false`。
- en: '`noneMatch`: Opposite to `allMatch()`, the `noneMatch()` terminal operator
    will return `true` if none of the elements in the stream match the specified predicate:'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`noneMatch`：与`allMatch()`相反，如果流中的没有任何元素匹配指定的谓词，则`noneMatch()`终端操作将返回`true`：'
- en: '[PRE35]'
  id: totrans-118
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Because the stream has elements of values above 10, this will also return `false`.
  id: totrans-119
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 因为流中有值大于10的元素，所以这也会返回`false`。
- en: '`findFirst`: This retrieves the first element of the stream, wrapped in an
    `Optional`:'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`findFirst`：这检索流中的第一个元素，并用`Optional`包装：'
- en: '[PRE36]'
  id: totrans-121
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: This will print `Optional[6]` to the terminal. If there were no elements in
    the stream, it would instead print `Optional.empty`.
  id: totrans-122
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这将在终端打印`Optional[6]`。如果流中没有元素，它将打印`Optional.empty`。
- en: '`findAny`: Much like the `findFirst()` terminal operation, the `findAny()`
    operation will return an element wrapped in an `Optional`. This operation, however,
    will return any one of the elements that remain. You should never really assume
    which element it will return. This operation will, usually, act faster than the
    `findFirst()` operation, especially in parallel streams. It''s ideal when you
    just need to know whether there are any elements left but don''t really care about
    which remain:'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`findAny`：与`findFirst()`终端操作类似，`findAny()`操作将返回一个被`Optional`包装的元素。然而，这个操作将返回剩余元素中的任何一个。你实际上永远不应该假设它会返回哪个元素。通常，这个操作会比`findFirst()`操作运行得更快，尤其是在并行流中。当你只需要知道是否还有剩余元素，但并不真正关心哪些元素剩余时，这是理想的：'
- en: '[PRE37]'
  id: totrans-124
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '`iterator`: This is a terminal operator that generates an iterator that lets
    you traverse elements:'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`iterator`：这是一个终端操作，它生成一个迭代器，让你遍历元素：'
- en: '[PRE38]'
  id: totrans-126
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '`summaryStatistics`: This is a special terminal operation that is available
    for `IntStream`, `LongStream`, and `DoubleStream`. It will return a special type—for
    example, `IntSummaryStatistics`—describing the elements of the stream:'
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`summaryStatistics`：这是一个特殊的终端操作，适用于`IntStream`、`LongStream`和`DoubleStream`。它将返回一个特殊类型——例如，`IntSummaryStatistics`——描述流中的元素：'
- en: '[PRE39]'
  id: totrans-128
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'This will print all the summaries of the three streams to the terminal, which
    should look like this:'
  id: totrans-129
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这将打印出三个流的所有摘要到终端，其外观应该如下所示：
- en: '[PRE40]'
  id: totrans-130
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Intermediate Operations
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 中间操作
- en: A stream can take any number of intermediate operations following the creation
    of the stream. An intermediate operation is often a filter or mapping of some
    type, but there are other types as well. Every intermediate operation returns
    another stream; that way, you can chain any number of intermediate operations
    to your pipeline.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 流可以接受任意数量的中间操作，这些操作是在创建流之后进行的。中间操作通常是某种类型的过滤器或映射，但还有其他类型。每个中间操作都会返回另一个流；这样，你可以将任意数量的中间操作链接到你的管道中。
- en: The order of intermediate operations is very important as the stream returned
    from an operation will only reference the remaining or required elements of the
    previous stream.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 中间操作的顺序非常重要，因为从操作返回的流将只引用前一个流中剩余或所需的元素。
- en: 'There are several different types of intermediate operations. The following
    is an explanation of each of them:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种不同的中间操作类型。以下是对每种类型的解释：
- en: '`filter`: As the name suggests, this intermediate operation will return a subset
    of elements from the stream. It uses a predicate when applying the matching pattern,
    which is a functional interface that returns a `Boolean`. The easiest and most
    common way to implement this is using a lambda function:'
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`filter`：正如其名所示，这个中间操作将从流中返回一个子集元素。它在应用匹配模式时使用谓词，这是一个返回`Boolean`的功能接口。实现这个接口最简单和最常见的方式是使用lambda函数：'
- en: '[PRE41]'
  id: totrans-136
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: In this example, the `filter` method will filter away any elements that have
    a value that is 3 or lower. The `forEach()` terminal operation will then take
    the remaining elements and print them all in a loop.
  id: totrans-137
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这个示例中，`filter`方法将过滤掉任何值等于或小于3的元素。然后，`forEach()`终端操作将取剩余的元素，并在循环中打印它们。
- en: '`map`: The `map` operation will apply a special function to every element of
    the stream and return the modified elements:'
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`map`：`map`操作将应用一个特殊函数到流中的每个元素，并返回修改后的元素：'
- en: '[PRE42]'
  id: totrans-139
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: This pipeline will take the strings, convert them to integers using the `map()`
    operation, and then print either `true` or `false` depending on whether the parsed
    string value is more than 3\. This is just one simple example of `map`; this method
    is incredibly versatile in transforming your stream into something very different.
  id: totrans-140
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这个管道将取字符串，使用`map()`操作将它们转换为整数，然后根据解析的字符串值是否大于3来打印`true`或`false`。这只是`map`的一个简单示例；这种方法在将流转换为非常不同的东西时非常灵活。
- en: 'There are also special versions of this intermediate operation that will return
    integer values, long values, and double values. They''re called `mapToInt()`,
    `mapToLong()`, and `mapToDouble()`, respectively:'
  id: totrans-141
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此外，这个中间操作还有特殊的版本，将返回整数值、长值和双精度值。它们分别称为`mapToInt()`、`mapToLong()`和`mapToDouble()`：
- en: '[PRE43]'
  id: totrans-142
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Note that these special case `map` operations will return `IntStream`, `LongStream`,
    or `DoubleStream` rather than `Stream<Integer>`, `Stream<Long>`, or `Stream<Double>`.
  id: totrans-143
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意，这些特殊的`map`操作将返回`IntStream`、`LongStream`或`DoubleStream`，而不是`Stream<Integer>`、`Stream<Long>`或`Stream<Double>`。
- en: '`flatMap`: This gives you an easy way of flattening a multidimensional data
    structure into one single stream—for example, a stream of objects that themselves
    contain objects or arrays. With `flatMap()`, you can take these sub elements and
    concatenate them into a single stream:'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`flatMap`: 这为你提供了一个将多维数据结构扁平化到一个单一流中的简单方法——例如，一个包含对象或数组的对象的流。使用 `flatMap()`，你可以将这些子元素连接成一个单一的流：'
- en: '[PRE44]'
  id: totrans-145
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'In this example pipeline, we''re creating a stream from multiple lists; then,
    in the `flatMap` operation, we''re extracting streams of each list. The `flatMap`
    operation then concatenates them into a single stream, which we loop through with
    `forEach`. The terminal will print out the full stream: `123456789`.'
  id: totrans-146
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这个示例管道中，我们从一个多个列表中创建一个流；然后，在 `flatMap` 操作中，我们提取每个列表的流。`flatMap` 操作然后将它们连接成一个单一的流，我们通过
    `forEach` 遍历它。终端将打印出完整的流：`123456789`。
- en: 'The `flatMap` function also exists as an integer, long, and double special
    operations—`flatMapToInt`, `flatMapToLong`, and `flatMapToDouble`—which, of course,
    will return the respective typed stream:'
  id: totrans-147
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`flatMap` 函数也存在于整数、长和双精度特殊操作中——`flatMapToInt`、`flatMapToLong` 和 `flatMapToDouble`——当然，它们将返回相应的类型流：'
- en: '`distinct`: This will return all the unique elements in the stream. If there
    are duplicate elements in the stream, the first item will be returned:'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`distinct`: 这将返回流中的所有唯一元素。如果流中有重复的元素，则将返回第一个项目：'
- en: '[PRE45]'
  id: totrans-149
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Here, we're starting with a stream of six elements, however, four of them are
    identical in value. The `distinct()` operation will filter these elements and
    the remaining three will be printed to the terminal.
  id: totrans-150
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这里，我们从一个包含六个元素的流开始，然而，其中四个在值上是相同的。`distinct()` 操作将过滤这些元素，剩下的三个将被打印到终端。
- en: '`sorted`: The `sorted` intermediate operation exists in two versions. The first
    version, without arguments, assumes that the elements of the `map` can be sorted
    in the natural order—implementing the `Comparable` interface. If they can''t be
    sorted, then an exception will be thrown:'
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sorted`: `sorted` 中间操作存在两个版本。第一个版本没有参数，假设 `map` 的元素可以按自然顺序排序——实现 `Comparable`
    接口。如果它们不能排序，则将抛出异常：'
- en: '[PRE46]'
  id: totrans-152
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'The second version of the `sorted` operation takes a `Comparator` as an argument,
    and will return the sorted elements accordingly:'
  id: totrans-153
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`sorted` 操作的第二个版本接受一个 `Comparator` 作为参数，并将相应地返回排序后的元素：'
- en: '[PRE47]'
  id: totrans-154
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: '`unordered`: The opposite of `sorted`, the `unordered` intermediate operation
    will impose an unordered encounter order on the streams elements. Using this operation
    on parallel streams can, sometimes, improve the performance, as certain intermediate
    and terminal stateful operations perform better with a more relaxed ordering of
    elements:'
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`unordered`: 与 `sorted` 相反，`unordered` 中间操作将对流的元素施加无序的遭遇顺序。在并行流上使用此操作有时可以提高性能，因为某些中间和终端状态操作在元素顺序更宽松的情况下表现更好：'
- en: '[PRE48]'
  id: totrans-156
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: '`limit`: This returns a new stream with `n` number of elements. If the number
    of elements is fewer than the requested limit, it has no effect:'
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`limit`: 这个操作返回一个包含 `n` 个元素的新的流。如果元素的数量少于请求的限制，则没有效果：'
- en: '[PRE49]'
  id: totrans-158
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: The result of running this example will be `123`, ignoring any elements beyond
    the third element.
  id: totrans-159
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 运行此示例的结果将是 `123`，忽略任何超过第三个元素的元素。
- en: '`skip`: This skips the first `n` elements of this stream and returns the remaining
    elements in a new stream:'
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`skip`: 这个操作将跳过此流的前 `n` 个元素，并返回一个包含剩余元素的新流：'
- en: '[PRE50]'
  id: totrans-161
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: This will print `456` to the terminal, skipping the first three elements.
  id: totrans-162
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这将打印 `456` 到终端，跳过前三个元素。
- en: '`boxed`: The special primitive streams, `IntStream`, `LongStream`, and `DoubleStream`,
    all have access to the `boxed()` operation. This operation will "box" each primitive
    element in the class version of said type, and return that stream. `IntStream`
    will return `Stream<Integer>`, `LongStream` will return `Stream<Long>`, and `DoubleStream`
    will return `Stream<Double>`:'
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`boxed`: 特殊的原始流 `IntStream`、`LongStream` 和 `DoubleStream` 都可以访问 `boxed()` 操作。此操作将“封装”每个原始元素在相应类型的类版本中，并返回该流。`IntStream`
    将返回 `Stream<Integer>`，`LongStream` 将返回 `Stream<Long>`，而 `DoubleStream` 将返回 `Stream<Double>`：'
- en: '[PRE51]'
  id: totrans-164
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'This example will take each primitive stream, box it in the corresponding object
    type, and then print the value together with the class name of the type:'
  id: totrans-165
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这个示例将取每个原始流，将其封装在相应的对象类型中，然后打印出值以及该类型的类名：
- en: '[PRE52]'
  id: totrans-166
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: '`takeWhile`: This is a special type of operation that acts differently depending
    on whether the stream is ordered or not. If the stream is ordered—that is, it
    has a defined encounter order—it will return a stream containing the longest streak
    of matching elements that match the predicate, starting with the first element
    in the stream. This stream of elements, which always starts with the first element,
    is also sometimes called a prefix:'
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE53]'
  id: totrans-168
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'This pipeline will print `222` to the terminal. You should note, however, that
    this operation will return an empty stream if the first element doesn''t match
    the predicate. This is because of the inner workings of `takeWhile()`; that is,
    it will start at the first element and continue until the first element fails
    to match—giving you an empty stream:'
  id: totrans-169
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE54]'
  id: totrans-170
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: If the stream is unordered—that is, it has no defined encounter order—the `takeWhile()`
    operation may return any matching subset of elements, including the empty subset.
    In this use case, a `filter()` operation might be more suitable.
  id: totrans-171
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`dropWhile`: The `dropWhile()` operation is the opposite of `takeWhile()`.
    Just like `takeWhile()`, it will act differently depending on whether the stream
    is ordered or not. If the stream is ordered, it will drop the longest prefix matching
    the predicate, instead of returning the prefix like `takeWhile()` does:'
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE55]'
  id: totrans-173
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: This pipeline will print `3125` to the terminal, dropping the matching prefix,
    which is the first three 2's. If the stream is unordered, the operation may drop
    any subset of elements, or drop an empty subset, effectively returning the whole
    stream. Be careful when using this operation on unordered streams.
  id: totrans-174
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`ForkJoinPool`. Most streams are sequential unless specifically created as
    parallel, or turned into parallel using this intermediate operation.'
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Sequential**: This returns a sequential stream and is the opposite of parallel.'
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`peek`: This intermediate operation is mainly used to examine the stream after
    other intermediate operations have been applied. Usually, the goal is to understand
    how the operations have affected the elements. In the following example, we''re
    printing how each element traverses each stream operation in the pipeline:'
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE56]'
  id: totrans-178
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: The terminal will read `653338111922244470005` in this example. What we can
    quickly deduce is that any elements with a value of 5 or above will only be printed
    once. `Peek` will follow each element in turn through the whole stream; that's
    why the order may seem odd. 6 and 5 will only be printed once, as they're filtered
    after the first `peek` operation. 3, however, will be triggered on all three `peek()`
    operations, hence there are three 3's in a row. The last number 5 in the output
    is just the count of the remaining elements.
  id: totrans-179
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'While the `peek()` operation is most commonly used to examine elements as they
    traverse the pipeline, it is also possible to mutate the elements of the stream
    using these operations. Consider the following class definition:'
  id: totrans-180
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE57]'
  id: totrans-181
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Then, consider adding a number of these values to a stream that has a mutating
    `peek` operation applied to it:'
  id: totrans-182
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE58]'
  id: totrans-183
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE58]'
- en: The sum of these objects should have been, if we disregard the `peek()` operation,
    6\. However, the `peek` operation is mutating each object to have a value of zero—effectively
    making the sum zero. While this is possible, it was never designed to be used
    like this. Using `peek()` to mutate is not recommended as it is not thread-safe,
    and accessing any shared state might cause exceptions. The different `map()` operations
    are usually a better option.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 1: Using the Stream API'
  id: totrans-185
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'An online grocery shop that allows customers to collect, and save, multiple
    different shopping carts at the same time has asked you to implement a joint checkout
    for their multiple-shopping cart system. The checkout procedure should concatenate
    the price for all items in all shopping carts, and then present that to the customer.
    To do this, perform the following steps:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: If IntelliJ is already started but no project is open, then select `Create New
    Project`. If IntelliJ already has a project opened, then select `File` | `New`
    | `Project` from the menu.
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the `New Project` dialog box, select the `Java project`, and then click `Next`.
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Check the box to create the project from a template. Select `Command Line App`,
    and then click `Next`.
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Give the new project the name `Chapter15`.
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: IntelliJ will give you a default project location. If you wish to select one,
    you may enter it here.
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set the package name to `com.packt.java.chapter15`.
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click `Finish`.
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: IntelliJ will create your project, called `Chapter15`, with the standard folder
    structure. IntelliJ will also create the main entry point for your application,
    called `Main.java`.
  id: totrans-194
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Rename this file to `Exercise1.java`. When you''re done, it should look like
    this:'
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  id: totrans-196
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Create a new inner class, called `ShoppingArticle`. Make it static so that
    we can easily access it from the main entry point for our program. This class
    should contain the name of the article and the price of that article. Let the
    `price` be a double variable:'
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  id: totrans-198
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Now create a simple `ShoppingCart` class. In this version, we will only allow
    one item per article in the cart, so a list will be enough to keep the articles
    in `ShoppingCart`:'
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE61]'
  id: totrans-200
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Create your first shopping cart, `fruitCart`, and add three fruit articles
    to it – `Orange`, `Apple`, and `Banana`—one of each type. Set the per-unit price
    to `1.5`, `1.7`, and `2.2` `Java-$` each:'
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE62]'
  id: totrans-202
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Create another `ShoppingCart`, but this time with vegetables—`Cucumber`, `Salad`,
    and `Tomatoes`. Set a price in Java-$ for them as well, as `0.8`, `1.2`, and `2.7`:'
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE63]'
  id: totrans-204
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Wrap up the test shopping carts with a third and final `shoppingCart` containing
    some meat and fish. They''re usually a little more expensive than fruit and vegetables:'
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE64]'
  id: totrans-206
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Now it''s time to start implementing the function that will calculate the total
    price of all the items in the shopping carts. Declare a new function that takes
    a `ShoppingCart` `vararg` as an argument and returns a double. Let it be static
    so that we can easily use it in the `main` function:'
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE65]'
  id: totrans-208
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Build a pipeline starting with a stream of all of the carts:'
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE66]'
  id: totrans-210
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Add a `flatMap()` operation to extract a single stream of `ShoppingArticles`
    for all `ShoppingCarts`:'
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE67]'
  id: totrans-212
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Extract the price for each `ShoppingArticle` using the `mapToDouble()` operation;
    this will create a `DoubleStream`:'
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE68]'
  id: totrans-214
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Finally, reduce the prices of all `ShoppingArticle` to a sum, using the `sum()`
    method that is available in `DoubleStream`:'
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE69]'
  id: totrans-216
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Now you have a function that will reduce a list of `ShoppingCart` to a unified
    sum in Java-$. All you have to do now is to apply this function to your `ShoppingCart`
    class, and then print out the resulting sum to the terminal, rounding it to two
    decimals:'
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE70]'
  id: totrans-218
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE70]'
- en: Note
  id: totrans-219
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'You can refer the complete code at: [https://packt.live/2qzLaHx](https://packt.live/2qzLaHx).'
  id: totrans-220
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: You've now created your first complete piece of code using the functional Java
    Stream API. You've created a stream of complex objects, applying a mapping operation
    to the elements of the stream to transform them, and then another mapping operation
    to transform the elements yet again, changing the stream type twice. Finally,
    you reduced the whole stream to a single primitive value that was presented to
    the user.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: 'Activity 1: Applying Discount on the Items'
  id: totrans-222
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Improve the preceding example by adding a function that applies a discount for
    certain items in the shopping carts, before calculating the final price. Ensure
    the price calculation is still correct.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: The solution for this activity can be found on page 563.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: Using Collectors
  id: totrans-226
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Collectors** in Java are a very powerful tool when you need to extract certain
    data points, descriptions, or elements from large data structures. They offer
    a very understandable way of describing what you want to do with a stream of elements,
    without needing to write complex logic.'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: There are a number of helpful default implementations of the `Collector` interface
    that you can start using easily. Most of these collectors will not allow null
    values; that is, if they find a null value in your stream, they will throw a `NullPointerException`.
    Before using a collector to reduce your elements in any of these containers, you
    should take care to handle null elements in the stream.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is an introduction to all default Collectors:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: '`toCollection`: This generic collector will allow you to wrap your elements
    in any known class implementing the `Collection` interface; examples include `ArrayList`,
    `HashSet`, `LinkedList`, `TreeSet`, and others:'
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE71]'
  id: totrans-231
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE71]'
- en: '`toList`: This will reduce your elements into an `ArrayList` implementation.
    If you need a more specific type of list, you should use the `toCollection()`
    collector:'
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE72]'
  id: totrans-233
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE72]'
- en: '`toUnmodifiableList`: This is essentially the same as the `toList()` collector,
    with the one difference that it uses the `List.of()` generator function to make
    the list unmodifiable:'
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE73]'
  id: totrans-235
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE73]'
- en: '`toSet`: This wraps the elements in a `HashSet`:'
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE74]'
  id: totrans-237
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE74]'
- en: '`toUnmodifiableSet`: This is just like the `toSet()` collector, with the difference
    being that it will use the `Set.of()` generator to create an unmodifiable set:'
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE75]'
  id: totrans-239
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE75]'
- en: '`joining`: This collector will use a `StringBuilder` to concatenate the elements
    of the stream into a string without any separating characters:'
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE76]'
  id: totrans-241
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'This will print `onetwothreefourfive` to the terminal. If you need the elements
    to be separated by a comma, for example, use `Collectors.joining(",")`:'
  id: totrans-242
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE77]'
  id: totrans-243
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'In this example, you get `one,two,three,four,five` printed to the terminal.
    Finally, you have the option of adding a prefix and a suffix to the generated
    string as well:'
  id: totrans-244
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE78]'
  id: totrans-245
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'The prefix and suffix are added to the string, not each element. The generated
    string will look like: `Prefixone,two,three,four,fiveSuffix`.'
  id: totrans-246
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`mapping`: This is a special type of collector that allows you to apply a mapping
    to each element of the stream before applying a defined collector:'
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE79]'
  id: totrans-248
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE79]'
- en: Here, we're starting with a source of `List<String>` and collecting to a `Set<String>`.
    But before we collect, we're concatenating a `-suffix` string to each element
    using the `mapping()` collector.
  id: totrans-249
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`flatMapping`. Just like the `flatMap()` intermediate operation, this collector
    will allow you to apply a flat mapping to the stream elements, before collecting
    them to a new container. In the following example, we start with a source, `List<Set<String>>`,
    then we flatten it out to a `Stream<Set<String>>` and apply `Collector.toList()`—effectively
    turning all the sets into a single list instead:'
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE80]'
  id: totrans-251
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE80]'
- en: '`filter()` intermediate operation, here, you''re allowed to apply a filtering
    before you implement operations on the stream.'
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE81]'
  id: totrans-253
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE81]'
- en: '`collectingAndThen`: This special collector will allow you to finish the collection
    off with a special function; for example, turning your collection into an immutable
    collection:'
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE82]'
  id: totrans-255
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE82]'
- en: '`counting`: This produces the same result as the `count()` intermediate operation:'
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE83]'
  id: totrans-257
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE83]'
- en: '`minBy`: This collector is equivalent to using the `min()` terminal operator.
    The following example will print `Optional[1]` to the terminal:'
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE84]'
  id: totrans-259
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE84]'
- en: '`maxBy`: You''ll get the same result using this collector as you would with
    the `max()` terminal operator:'
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE85]'
  id: totrans-261
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE85]'
- en: '`summingInt`: This is an alternative to the `reduce()` intermediate operation,
    and is used to calculate the sum of all elements in the stream:'
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE86]'
  id: totrans-263
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE86]'
- en: '`summingLong`: This is the same as `Collector.summingInt()`, but will instead
    produce a sum in the `long` type:'
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE87]'
  id: totrans-265
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE87]'
- en: '`summingDouble`: This is the same as `Collector.summingLong()`, but will instead
    produce a sum in the `double` type:'
  id: totrans-266
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE88]'
  id: totrans-267
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE88]'
- en: '`averagingInt`: Returns the average the integers passed:'
  id: totrans-268
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE89]'
  id: totrans-269
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE89]'
- en: '`averagingLong`: Returns the average the longs passed:'
  id: totrans-270
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE90]'
  id: totrans-271
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE90]'
- en: '`averagingDouble`: Returns the average of the numbers passed in the argument:'
  id: totrans-272
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE91]'
  id: totrans-273
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE91]'
- en: '`reduce()` terminal operator, which this collector inherits its name and operation
    from.'
  id: totrans-274
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`groupingBy`: This collector will group elements according to a given function
    and collect them according to a given collection type. Consider the following
    example class, describing a car:'
  id: totrans-275
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE92]'
  id: totrans-276
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'If you would like to sort a few cars according to their brand and collect them
    into new containers, then it''s simple with the `groupingBy()` collector:'
  id: totrans-277
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE93]'
  id: totrans-278
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE93]'
- en: 'Here, we have four different cars. Then, we apply the `groupingBy()` collector
    based on the brand of cars. This will produce a `Map<String, List<Car>>` collection,
    where `String` is the brand of the car, and the `List` contains all the cars for
    said brand. This will always return `Map`; however, it is possible to define what
    kind of collection to gather the grouped elements in. In the following example,
    we''ve grouped them into `Set` instead of the default list:'
  id: totrans-279
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE94]'
  id: totrans-280
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE94]'
- en: 'The `groupingBy` collector becomes even more powerful if you combine it with
    another collector—for example, the `reducing` collector:'
  id: totrans-281
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE95]'
  id: totrans-282
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 'In this example, we group the cars by brand and then reduce them to only show
    the car of each brand with the most powerful engine. This kind of combination,
    of course, also works with other collectors, such as filtering, counting, and
    others:'
  id: totrans-283
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`groupingBy` collector, and has the exact same API.'
  id: totrans-284
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`partitioningBy`: The `partitioningBy` collector works in a similar way to
    the `groupingBy` collector, with the difference being that it will group elements
    into two collections that either matches a predicate or doesn''t match a predicate.
    It will wrap these two collections into `Map`, where the `true` keyword will reference
    the collection of elements that matches the predicate, and the `false` keyword
    will reference the elements that don''t match the predicate:'
  id: totrans-285
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE96]'
  id: totrans-286
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE96]'
- en: 'You can also select which kind of collection the elements should be wrapped
    in, just like the `groupingBy` collector:'
  id: totrans-287
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE97]'
  id: totrans-288
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE97]'
- en: '`toMap`: This collector will allow you to create a `map` from your stream elements
    by defining a mapping function, where you provide a key and value to put into
    the `map`. Often, this is just a unique identifier in the element and the element
    itself.'
  id: totrans-289
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This can be a little bit tricky because if you provide a duplicate element,
    then your pipeline will throw an `IllegalStateException` since `Map` is not allowed
    duplicate keys:'
  id: totrans-290
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE98]'
  id: totrans-291
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE98]'
- en: 'This simple example demonstrates how to map a string representation of an integer
    to the actual integer. If you know you may have duplicate elements, then you can
    supply a `merge` function to resolve that conflict:'
  id: totrans-292
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE99]'
  id: totrans-293
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE99]'
- en: 'You also have the option of generating your own type of `Map` by applying a
    `factory` function at the very end of the collector. Here, we''re telling the
    collector to generate a fresh `TreeMap` for us:'
  id: totrans-294
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE100]'
  id: totrans-295
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE100]'
- en: '`toUnmodifiableMap`: This is essentially the same as `toMap`, with the same
    API; however, it returns unmodifiable versions of `Map` instead. This is perfect
    for when you know you will never mutate the data in `Map`.'
  id: totrans-296
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`toConcurrentMap`: Because of the way `Map` is implemented, it can be a bit
    hazardous to performance when using it in parallel streams. In this case, it''s
    recommended that you use the `toConcurrentMap()` collector instead. This has a
    similar API to the other `toMap` functions, with the difference being that it
    will return instances of `ConcurrentMap` rather than `Map`.'
  id: totrans-297
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Car` class from previous collectors, you could produce a summary of all car
    engines like this:'
  id: totrans-298
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE101]'
  id: totrans-299
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE101]'
- en: I/O Streams
  id: totrans-300
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Apart from collections and other primitives, you can use files and I/O streams
    as sources in your pipelines. This makes writing tasks against servers very descriptive.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
- en: Because these types of resources generally need to be closed properly, you should
    use a try-with-resources statement to ensure the resources are handed back to
    the system when you're done with them.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider having a CSV file called `authors.csv` with these contents:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE102]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: 'You can put this file into a stream using a try-with-resources statement:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE103]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: 'In I/O streams, you can add `onClose` handlers to receive a notification when
    the stream is closed. Unlike other streams, this will be closed automatically
    when the resources for the stream have been closed. In this example, that''s handled
    automatically by the try-with-resources statement. In the following example, we''ve
    added an `onClose` handler that will print the word `Closed` when the stream has
    been closed:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE104]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: 'Here is the same example written with an `InputStream` instead. Notice that
    the code is now more verbose, having three nested object creations:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE105]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: 'Exercise 2: Converting CSV to a List'
  id: totrans-311
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A web-based grocery shop has implemented its very own database based on a standard
    Java `List` collection, and has also implemented a backup system where the database
    is backed up to CSV files. However, they still haven't built a way of restoring
    that database from a CSV file. They have asked you to build a system that will
    read such a CSV file, inflating its contents to a list.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
- en: 'The database backup CSV file contains one single type of object: `ShoppingArticle`.
    Each article has a `name`, a `price`, a `category`, and finally, a `unit`. The
    name, category, and unit should each be a `String`, and the price a `double`:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
- en: Open the `Chapter15` project in IDEA if it's not already open.
  id: totrans-314
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new Java class, using `File`| `New` | `Java`.
  id: totrans-315
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Enter `Exercise2` as the name, and then select `OK`.
  id: totrans-316
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'IntelliJ will create your new class; it should look something like the following
    snippet:'
  id: totrans-317
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE106]'
  id: totrans-318
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE106]'
- en: 'Add a `main` method to this class. This is where you''ll write the bulk of
    your application. Your class should now look like this:'
  id: totrans-319
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE107]'
  id: totrans-320
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE107]'
- en: 'Create a `ShoppingArticle` inner class and make it static so that you can easily
    use it in the main method. Override the `toString` method to make it easy to print
    articles to the terminal later:'
  id: totrans-321
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE108]'
  id: totrans-322
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE108]'
- en: Create a new folder in your project called `res` if it doesn't already exist.
    Then, place it in the root, next to the `src` folder.
  id: totrans-323
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Copy the `database.csv` file from GitHub to your project and place it in the
    `res` folder.
  id: totrans-324
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Back in your `Exercise2.java` class, add a function that produces `List<ShoppingArticle>`.
    This will be our function to load the database into a list. Since the function
    will be loading a file, it needs to throw an I/O exception (`IOException`):'
  id: totrans-325
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE109]'
  id: totrans-326
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE109]'
- en: 'Call this function from your `main` method:'
  id: totrans-327
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE110]'
  id: totrans-328
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE110]'
- en: 'Start by loading the database file with a try-with-resources block. Use `Files.lines`
    to load all the lines from the `database.csv` file. It should look something like
    this:'
  id: totrans-329
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE111]'
  id: totrans-330
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE111]'
- en: 'Let''s peek into the stream in order to look at the state of it right now.
    Intermediate operations will only run when there''s a terminal operation defined,
    so add a `count()` at the end just to force it to execute the whole pipeline:'
  id: totrans-331
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE112]'
  id: totrans-332
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE112]'
- en: This should print every single line of the file. Notice that it also prints
    the header line—which we're not concerned with when converting to `ShoppingArticles`.
  id: totrans-333
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Since we''re not really interested in the first row, add a `skip` operation
    just before the `count()` method:'
  id: totrans-334
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE113]'
  id: totrans-335
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE113]'
- en: 'Now you have every single line of the database file loaded as elements in the
    stream, except for the header. It''s time to extract every piece of data from
    those lines; a suitable operation for this is `map`. Split every line into `String`
    arrays using the `split()` function:'
  id: totrans-336
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE114]'
  id: totrans-337
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE114]'
- en: 'Add another `peek` operation to find out how the `map` operation changed the
    stream; your stream type should now be `Stream<String[]>`:'
  id: totrans-338
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE115]'
  id: totrans-339
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE115]'
- en: 'Add another `map` operation, but this time to turn the stream into `Stream<ShoppingArticle>`:'
  id: totrans-340
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE116]'
  id: totrans-341
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE116]'
- en: 'Now you can peek again to ensure the articles were created properly:'
  id: totrans-342
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE117]'
  id: totrans-343
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE117]'
- en: 'Collect all the articles in a list. Use an unmodifiable list to protect the
    database from unwanted modifications:'
  id: totrans-344
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE118]'
  id: totrans-345
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE118]'
- en: This may seem verbose, as some operations could have been applied together to
    make it shorter. However, there's a point to keeping every single operation small,
    and that's to make the whole logic very transparent. If you find a problem with
    the pipeline, you can simply move a single operation in the pipeline, and that
    should sort all problems.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
- en: If you combine multiple steps in an operation, it's more difficult to move the
    operations around in the pipeline or to replace it fully.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
- en: 'Activity 2: Searching for Specifics'
  id: totrans-348
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'With the database loaded, apply some searching logic:'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
- en: Build a function that will find the cheapest fruit from a list of `ShoppingArticles`.
  id: totrans-350
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Build a function that will find the most expensive vegetable from a list of
    `ShoppingArticles`.
  id: totrans-351
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Build a function that will gather all fruits in a separate list.
  id: totrans-352
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Build a function that will find the five least expensive articles in the database.
  id: totrans-353
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Build a function that will find the five most expensive articles in the database.
  id: totrans-354
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  id: totrans-355
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The Solution for this Activity can be found on page 564.
  id: totrans-356
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Summary
  id: totrans-357
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Descriptive code is always an ideal to strive for when writing programs. The
    simpler the code is, the easier it will be to communicate your intentions to colleagues
    and other interested parties.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
- en: The Java Streams API allows you to construct simple, and highly descriptive
    functions. Quite often they'll be pure functions since the Streams API makes it
    very easy to avoid manipulating state.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we'll delve further into functional programming topics,
    exploring the different functional interfaces available.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
