- en: 15\. Processing Data with Streams
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Overview
  prefs: []
  type: TYPE_NORMAL
- en: This chapter discusses the Stream API in Java that allows you to write effectively,
    with fewer lines of code. Once you have a firm grasp of the differences between
    parallel and sequential streams (defined and outlined in the early sections),
    you will be able to practice using the Java Stream API to work with arrays and
    collections by first learning how to create and close those streams. The next
    step is to explore the different types of operations available to you in Java,
    their definitions and their respective functions. The first you will encounter
    are terminal operations and reducers which you will use to extract data from a
    stream of elements. You will then move on to intermediate operations to filter,
    map, and otherwise mutate stream structures. And, finally, in this chapter's final
    exercise and activity, you will learn to apply different types of collectors to
    wrap stream elements in new containers.
  prefs: []
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Java 8 introduced the new Stream API. With streams, Java programmers can now
    use a more declarative style of writing programs that you have previously only
    seen in functional programming languages or functional programming libraries.
  prefs: []
  type: TYPE_NORMAL
- en: Using streams, you can now write more expressive programs with fewer lines of
    code, and easily chain multiple operations on large lists. Streams also make it
    simple to parallelize your operations on lists—that is, should you have very large
    lists or complex operations. One thing that is important to remember about streams
    is that, while it might appear as though they're an improved collection, they're
    actually not. Streams do not have any storage of their own; instead, they use
    the storage of the supplied source.
  prefs: []
  type: TYPE_NORMAL
- en: 'In Java, there are four types of streams: `Stream`, which is used for streaming
    objects; `IntStream`, which is for streaming integers; `LongStream`, which streams
    longs; and finally, `DoubleStream`, which, of course, streams doubles. All of
    these streams work in exactly the same way, except they''re specialized to work
    with their respective types.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Diving into the code, you'll find that each of these types is just an interface
    with static methods pointing back to the `StreamSupport` class. This is the core
    API for anyone wanting to write stream-specific libraries. However, when building
    an application, you're usually fine to use the four standard stream interfaces
    and static generator functions.
  prefs: []
  type: TYPE_NORMAL
- en: The source of a stream can be either single elements, collections, arrays, or
    even files. Following the stream source is a number of intermediate operations
    that form the core pipeline. The pipeline ends with a terminal operation that,
    usually, either loops through the remaining elements to create a side effect or
    reduces them to a specific value—for example, counting how many elements there
    are left in the last stream.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Streams are lazily constructed and executed. This means that a stream is not
    run until the terminal operation has been executed. Source elements are also only
    read as needed; that is, only the required elements are carried through to the
    next operation.
  prefs: []
  type: TYPE_NORMAL
- en: Creating Streams
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are multiple ways of creating streams in Java; the simplest of these
    is by using the `Stream.of()` function. This function can take either a single
    object or multiple objects in `varargs`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'If you have multiple objects in your stream, then use the `varargs` version:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The primitive versions of these streams work in an identical fashion; just replace
    the `Object` instances with integers, longs, or doubles.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also create streams from different collections—for example, lists and
    arrays. Creating a stream from a list will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'To create a stream from an array of items, you can use the `Arrays` class,
    just like the primitive versions of streams do:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'There is one special type of stream that covers the dreaded null type gracefully,
    and is detailed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: This stream will take one single object that can be null. If the object is null,
    then it will generate an empty stream; alternatively, if the object is not null,
    it will generate a stream of that one object. This can, of course, be very handy
    in situations where we're unsure about the state of sources.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another way to generate a stream of elements is by using the `Stream.iterate()`
    generator function. This function will generate an infinite number of elements
    in your stream until you tell it to stop, starting at the seed element:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example, we''re creating a stream of five elements, starting with index
    `0`. This stream will contain the elements `0`, `1`, `2`, `3`, and `4`:'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The `Stream.iterate()` generator function can be quite hazardous if you do not
    provide the proper limits. There are a number of ways to create infinite streams—usually
    by placing operations in the wrong order or forgetting to apply a limit to the
    stream.
  prefs: []
  type: TYPE_NORMAL
- en: There is also a special `Builder` class, which is embedded in the `Stream` type.
    This `Builder` class allows you to add elements as you create them; it removes
    the need to keep an `ArrayList`—or other collection—as a temporary buffer for
    elements.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Builder` class has a very simple API; you can `accept()` an element into
    the builder, which is perfect when you want to generate elements from a loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also `add()` elements to the builder. The `add()` method allows chaining,
    which is perfect for when you don''t want to generate elements from a loop, but
    instead add them in a single line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'To create the stream using a builder, you can call the `build()` method when
    all the methods have been added. However, note that if you try to add elements
    to the builder after the `build()` method has been called, it will throw an `IllegalStateException`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: All these simple ways of creating streams use the same underlying helper class,
    called `StreamSupport`. This class has a number of helpful and advanced methods
    for creating streams with different properties. The common denominator for all
    of these streams is `Spliterator`.
  prefs: []
  type: TYPE_NORMAL
- en: Parallel Streams
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Streams are either sequential or parallel in the Java Stream API. Sequential
    streams use just a single thread in order to perform any operation. Usually, you'll
    find that this stream is more than enough to solve most problems; however, sometimes,
    you may require multiple threads running on multiple cores.
  prefs: []
  type: TYPE_NORMAL
- en: Parallel streams are operated on in parallel by multiple threads on multiple
    cores. They utilize `ForkJoinPool` in the JVM to launch multiple threads. They
    can be a very powerful tool when you find yourself in a performance hotspot. However,
    as parallel streams utilize multiple threads, you should be wary of using them
    unless needed; the overhead of parallel streams may very well create more problems
    than they solve.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Parallel streams are a double-edged sword. They can be extremely useful in certain
    situations, however, at the same time, they can completely lock your program down.
    As parallel streams utilize the common `ForkJoinPool`, they spawn threads that
    may block your application and other system components to such a degree that the
    user will be affected.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create a parallel stream, you can use the `Collections.parallelStream()`
    method, which will attempt to create a parallel stream:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, you can make a stream parallel by using the `BaseStream.parallel()`
    intermediate operation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that, at any point between the source and the terminal operation, you
    can change the type of the stream, using the `BaseStream.parallel()` or `BaseStream.sequential()`
    operations. These operations will only have an impact on the stream if they need
    to change the underlying state of the stream; if the stream already has the correct
    state, it will simply return itself. Calling `BaseStream.parallel()` multiple
    times will have no impact on performance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Encounter Order
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Depending on the type of the source for the stream, it may have a different
    encounter order. Lists, for example, have a built-in ordering of elements—also
    called the index. The ordering of the source also means that elements will be
    encountered in that order; however, you can change this encounter order using
    the `BaseStream.unordered()` and `Stream.sorted()` intermediate operations.
  prefs: []
  type: TYPE_NORMAL
- en: The `unordered()` operation doesn't change the ordering of a stream; instead,
    it only attempts to remove a specific attribute and informs us whether a stream
    is ordered or not. The elements will still have a specific order. The whole point
    of unordered streams is to make other operations more performant when applied
    to parallel streams. Applying the `unordered()` operation to a sequential stream
    will make it non-deterministic.
  prefs: []
  type: TYPE_NORMAL
- en: Closing Streams
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Much like the streams of previous Java versions, `InputStream` and `OutputStream`,
    the Stream API includes a `close()` operation. However, in most cases, you'll
    never actually need to worry about closing your streams. The only time you should
    worry about closing your streams is when the source is a system resource—such
    as files or sockets—which need to be closed to avoid hogging resources from the
    system.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `close()` operation returns void, meaning that after you call `close()`,
    the stream is unavailable for any other intermediate or terminal operations; although
    it is possible to register `close` handlers that will be informed when the stream
    has been closed. The `close` handler is a `Runnable` functional interface; preferably,
    you''ll register them using a lambda function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'You can register any number of `close` handlers in your pipeline. The `close`
    handlers will always run even if any one of them renders an exception in their
    code. Additionally, it is worth noting that they will always be called in the
    same order in which they''re added to the pipeline, regardless of the encounter
    order of the stream:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Even if it's possible to register a close handler on any stream, it might not
    actually run if the stream doesn't need to be closed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since Java 7, there is an interface called `AutoCloseable`, which will attempt
    to automatically close held resources in a `try-with-resources` statement. The
    `BaseStream` interface, which all streams inherit from, extends this `AutoCloseable`
    interface. This means that any stream will attempt to release resources automatically
    if wrapped in a try-with-resources statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: While the preceding example does work, there's rarely any reason to wrap a basic
    stream in a try-with-resources statement, other than if you explicitly need to
    run logic when the stream has finished running. This example will first print
    `true` to the terminal, and after that print `Closed`.
  prefs: []
  type: TYPE_NORMAL
- en: Terminal Operations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Every pipeline needs to end with a terminal operation; without this, the pipeline
    will not be executed. Unlike intermediate operations, terminal operations may
    have various return values as they mark the end of the pipeline. You cannot apply
    another operation after a terminal operation.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: When a terminal operation is applied to a stream, you cannot use that stream
    again. Therefore, storing references to streams in code can cause confusion as
    to how that reference might be used – you're not allowed to "split" a stream into
    two different use cases. If you attempt to apply operations on a stream that already
    had the terminal operation executed, then it will throw an `IllegalStateException`
    with the message `stream has already been operated upon or closed`.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are 16 different terminal operations in the Stream API—each of them with
    their own specific use cases. The following is an explanation of each of them:'
  prefs: []
  type: TYPE_NORMAL
- en: '`forEach`: This terminal operator acts like a normal `for` loop; it will run
    some code for each element in the stream. This is not a thread-safe operation,
    so you''ll need to provide synchronization should you find yourself using shared
    state:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If this operation is applied on a parallel pipeline, the order in which elements
    are acted on will not be guaranteed:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: If the order in which the elements are acted on matters, you should use the
    `forEachOrdered()` terminal operation instead.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`forEachOrdered`: Much like the `forEach()` terminal operation, this will allow
    you to perform an action for each element in the stream. However, the `forEachOrdered()`
    operation will guarantee the order in which elements are processed, regardless
    of how many threads they''re processed on:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here, you can see a parallel stream with a defined encounter order. Using the
    `forEachOrdered()` operation, it will always encounter elements in the natural,
    indexed order.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`toArray`: These two terminal operations will allow you to convert the elements
    of the stream into an array. The basic version will generate an `Object` array:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If you need a specific type of array, you can supply a constructor reference
    for the type of array you need:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'A third option is to also write your own generator for the `toArray()` operation:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`reduce`: To perform a reduction on a stream means to only extract the interesting
    parts of the elements of that stream and reduce them to a single value. There
    are two generic `reduce` operations available. The first, simpler one, takes an
    accumulator function as an argument. It is usually used after a map operation
    is applied on a stream:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The second, more complex version takes an identity that also acts as the initial
    value of the reduction. It also requires an accumulator function where the reduction
    takes place, as well as a combining function to define how two elements are reduced:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In this example, the accumulator adds up the result of the combining function
    to the identity value, which, in this case, is the total sum of the reduction.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`sum`: This is a more specific reduction operation, which will sum all elements
    in the stream. This terminal operation is only available for `IntStream`, `LongStream`,
    and `DoubleStream`. To use this functionality in a more generic stream, you would
    have to implement a pipeline using the `reduce()` operation, usually preceded
    by a `map()` operation. The following example illustrates the use of `IntStream`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This will print the result as `30`. The following example illustrates the use
    of `LongStream`:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This will print the result as `22`. The following example illustrates the use
    of `DoubleStream`:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This will print the result as `20.6`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`collect`: The collection operation is like the reduce operation, in that it
    takes the elements of a stream and creates a new result. However, instead of reducing
    the stream to a single value, `collect` can take the elements and generate a new
    container or collection that holds all the remaining elements; for example, a
    list. Usually, you would use the `Collectors` `help` class, as it contains a lot
    of ready-to-use collect operations:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This would print `[6, 3, 8, 12, 3, 9]` to the console. You can review more
    usages of `Collectors` in the *Using Collectors* section. Another option is to
    write your own supplier, accumulator, and combiner for the `collect()` operation:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This can, of course, be simplified in this example by using method references:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`min`: As the name suggests, this terminal operation will return the minimum
    value, wrapped in an `Optional`, of all elements in the stream specified according
    to a `Comparator`. In most cases, you''d use the `Comparator.comparingInt()`,
    `Comparator.comparingLong()`, or `Comparator.comparingDouble()` static helper
    functions when applying this operation:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This should write `Optional[3]`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`max`: The opposite of the `min()` operation, the `max()` operation returns
    the value of the element with the maximum value according to a specified `Comparator`,
    wrapped in an `Optional`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This will print `Optional[12]` to the terminal.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`average`: This is a special type of terminal operation that is only available
    on `IntStream`, `LongStream`, and `DoubleStream`. It returns an `OptionalDouble`
    containing the average of all elements in the stream:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This will give you an `Optional` with the containing value `6.833333333333333`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`count`: This is a simple terminal operator returning the number of elements
    in the stream. It''s worth noting that, sometimes, the `count()` terminal operation
    will find more efficient ways of calculating the size of the stream. In these
    cases, the pipeline will not even be executed:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`anyMatch`: The `anyMatch()` terminal operator will return true if any of the
    elements in the stream match the specified predicate:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: As there is an element with a value above 10, this pipeline will return `true`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`allMatch`: The `allMatch()` terminal operator will return `true` if all the
    elements in the stream match the specified predicate:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Since this source has elements whose values are below 10, it should return `false`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`noneMatch`: Opposite to `allMatch()`, the `noneMatch()` terminal operator
    will return `true` if none of the elements in the stream match the specified predicate:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Because the stream has elements of values above 10, this will also return `false`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`findFirst`: This retrieves the first element of the stream, wrapped in an
    `Optional`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This will print `Optional[6]` to the terminal. If there were no elements in
    the stream, it would instead print `Optional.empty`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`findAny`: Much like the `findFirst()` terminal operation, the `findAny()`
    operation will return an element wrapped in an `Optional`. This operation, however,
    will return any one of the elements that remain. You should never really assume
    which element it will return. This operation will, usually, act faster than the
    `findFirst()` operation, especially in parallel streams. It''s ideal when you
    just need to know whether there are any elements left but don''t really care about
    which remain:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`iterator`: This is a terminal operator that generates an iterator that lets
    you traverse elements:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`summaryStatistics`: This is a special terminal operation that is available
    for `IntStream`, `LongStream`, and `DoubleStream`. It will return a special type—for
    example, `IntSummaryStatistics`—describing the elements of the stream:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This will print all the summaries of the three streams to the terminal, which
    should look like this:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Intermediate Operations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A stream can take any number of intermediate operations following the creation
    of the stream. An intermediate operation is often a filter or mapping of some
    type, but there are other types as well. Every intermediate operation returns
    another stream; that way, you can chain any number of intermediate operations
    to your pipeline.
  prefs: []
  type: TYPE_NORMAL
- en: The order of intermediate operations is very important as the stream returned
    from an operation will only reference the remaining or required elements of the
    previous stream.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are several different types of intermediate operations. The following
    is an explanation of each of them:'
  prefs: []
  type: TYPE_NORMAL
- en: '`filter`: As the name suggests, this intermediate operation will return a subset
    of elements from the stream. It uses a predicate when applying the matching pattern,
    which is a functional interface that returns a `Boolean`. The easiest and most
    common way to implement this is using a lambda function:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In this example, the `filter` method will filter away any elements that have
    a value that is 3 or lower. The `forEach()` terminal operation will then take
    the remaining elements and print them all in a loop.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`map`: The `map` operation will apply a special function to every element of
    the stream and return the modified elements:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This pipeline will take the strings, convert them to integers using the `map()`
    operation, and then print either `true` or `false` depending on whether the parsed
    string value is more than 3\. This is just one simple example of `map`; this method
    is incredibly versatile in transforming your stream into something very different.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'There are also special versions of this intermediate operation that will return
    integer values, long values, and double values. They''re called `mapToInt()`,
    `mapToLong()`, and `mapToDouble()`, respectively:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note that these special case `map` operations will return `IntStream`, `LongStream`,
    or `DoubleStream` rather than `Stream<Integer>`, `Stream<Long>`, or `Stream<Double>`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`flatMap`: This gives you an easy way of flattening a multidimensional data
    structure into one single stream—for example, a stream of objects that themselves
    contain objects or arrays. With `flatMap()`, you can take these sub elements and
    concatenate them into a single stream:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In this example pipeline, we''re creating a stream from multiple lists; then,
    in the `flatMap` operation, we''re extracting streams of each list. The `flatMap`
    operation then concatenates them into a single stream, which we loop through with
    `forEach`. The terminal will print out the full stream: `123456789`.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The `flatMap` function also exists as an integer, long, and double special
    operations—`flatMapToInt`, `flatMapToLong`, and `flatMapToDouble`—which, of course,
    will return the respective typed stream:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`distinct`: This will return all the unique elements in the stream. If there
    are duplicate elements in the stream, the first item will be returned:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here, we're starting with a stream of six elements, however, four of them are
    identical in value. The `distinct()` operation will filter these elements and
    the remaining three will be printed to the terminal.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`sorted`: The `sorted` intermediate operation exists in two versions. The first
    version, without arguments, assumes that the elements of the `map` can be sorted
    in the natural order—implementing the `Comparable` interface. If they can''t be
    sorted, then an exception will be thrown:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The second version of the `sorted` operation takes a `Comparator` as an argument,
    and will return the sorted elements accordingly:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`unordered`: The opposite of `sorted`, the `unordered` intermediate operation
    will impose an unordered encounter order on the streams elements. Using this operation
    on parallel streams can, sometimes, improve the performance, as certain intermediate
    and terminal stateful operations perform better with a more relaxed ordering of
    elements:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`limit`: This returns a new stream with `n` number of elements. If the number
    of elements is fewer than the requested limit, it has no effect:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The result of running this example will be `123`, ignoring any elements beyond
    the third element.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`skip`: This skips the first `n` elements of this stream and returns the remaining
    elements in a new stream:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This will print `456` to the terminal, skipping the first three elements.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`boxed`: The special primitive streams, `IntStream`, `LongStream`, and `DoubleStream`,
    all have access to the `boxed()` operation. This operation will "box" each primitive
    element in the class version of said type, and return that stream. `IntStream`
    will return `Stream<Integer>`, `LongStream` will return `Stream<Long>`, and `DoubleStream`
    will return `Stream<Double>`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This example will take each primitive stream, box it in the corresponding object
    type, and then print the value together with the class name of the type:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`takeWhile`: This is a special type of operation that acts differently depending
    on whether the stream is ordered or not. If the stream is ordered—that is, it
    has a defined encounter order—it will return a stream containing the longest streak
    of matching elements that match the predicate, starting with the first element
    in the stream. This stream of elements, which always starts with the first element,
    is also sometimes called a prefix:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This pipeline will print `222` to the terminal. You should note, however, that
    this operation will return an empty stream if the first element doesn''t match
    the predicate. This is because of the inner workings of `takeWhile()`; that is,
    it will start at the first element and continue until the first element fails
    to match—giving you an empty stream:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: If the stream is unordered—that is, it has no defined encounter order—the `takeWhile()`
    operation may return any matching subset of elements, including the empty subset.
    In this use case, a `filter()` operation might be more suitable.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`dropWhile`: The `dropWhile()` operation is the opposite of `takeWhile()`.
    Just like `takeWhile()`, it will act differently depending on whether the stream
    is ordered or not. If the stream is ordered, it will drop the longest prefix matching
    the predicate, instead of returning the prefix like `takeWhile()` does:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This pipeline will print `3125` to the terminal, dropping the matching prefix,
    which is the first three 2's. If the stream is unordered, the operation may drop
    any subset of elements, or drop an empty subset, effectively returning the whole
    stream. Be careful when using this operation on unordered streams.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`ForkJoinPool`. Most streams are sequential unless specifically created as
    parallel, or turned into parallel using this intermediate operation.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Sequential**: This returns a sequential stream and is the opposite of parallel.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`peek`: This intermediate operation is mainly used to examine the stream after
    other intermediate operations have been applied. Usually, the goal is to understand
    how the operations have affected the elements. In the following example, we''re
    printing how each element traverses each stream operation in the pipeline:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The terminal will read `653338111922244470005` in this example. What we can
    quickly deduce is that any elements with a value of 5 or above will only be printed
    once. `Peek` will follow each element in turn through the whole stream; that's
    why the order may seem odd. 6 and 5 will only be printed once, as they're filtered
    after the first `peek` operation. 3, however, will be triggered on all three `peek()`
    operations, hence there are three 3's in a row. The last number 5 in the output
    is just the count of the remaining elements.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'While the `peek()` operation is most commonly used to examine elements as they
    traverse the pipeline, it is also possible to mutate the elements of the stream
    using these operations. Consider the following class definition:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, consider adding a number of these values to a stream that has a mutating
    `peek` operation applied to it:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The sum of these objects should have been, if we disregard the `peek()` operation,
    6\. However, the `peek` operation is mutating each object to have a value of zero—effectively
    making the sum zero. While this is possible, it was never designed to be used
    like this. Using `peek()` to mutate is not recommended as it is not thread-safe,
    and accessing any shared state might cause exceptions. The different `map()` operations
    are usually a better option.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 1: Using the Stream API'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'An online grocery shop that allows customers to collect, and save, multiple
    different shopping carts at the same time has asked you to implement a joint checkout
    for their multiple-shopping cart system. The checkout procedure should concatenate
    the price for all items in all shopping carts, and then present that to the customer.
    To do this, perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: If IntelliJ is already started but no project is open, then select `Create New
    Project`. If IntelliJ already has a project opened, then select `File` | `New`
    | `Project` from the menu.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the `New Project` dialog box, select the `Java project`, and then click `Next`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Check the box to create the project from a template. Select `Command Line App`,
    and then click `Next`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Give the new project the name `Chapter15`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: IntelliJ will give you a default project location. If you wish to select one,
    you may enter it here.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set the package name to `com.packt.java.chapter15`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click `Finish`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: IntelliJ will create your project, called `Chapter15`, with the standard folder
    structure. IntelliJ will also create the main entry point for your application,
    called `Main.java`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Rename this file to `Exercise1.java`. When you''re done, it should look like
    this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a new inner class, called `ShoppingArticle`. Make it static so that
    we can easily access it from the main entry point for our program. This class
    should contain the name of the article and the price of that article. Let the
    `price` be a double variable:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now create a simple `ShoppingCart` class. In this version, we will only allow
    one item per article in the cart, so a list will be enough to keep the articles
    in `ShoppingCart`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create your first shopping cart, `fruitCart`, and add three fruit articles
    to it – `Orange`, `Apple`, and `Banana`—one of each type. Set the per-unit price
    to `1.5`, `1.7`, and `2.2` `Java-$` each:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create another `ShoppingCart`, but this time with vegetables—`Cucumber`, `Salad`,
    and `Tomatoes`. Set a price in Java-$ for them as well, as `0.8`, `1.2`, and `2.7`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Wrap up the test shopping carts with a third and final `shoppingCart` containing
    some meat and fish. They''re usually a little more expensive than fruit and vegetables:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now it''s time to start implementing the function that will calculate the total
    price of all the items in the shopping carts. Declare a new function that takes
    a `ShoppingCart` `vararg` as an argument and returns a double. Let it be static
    so that we can easily use it in the `main` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Build a pipeline starting with a stream of all of the carts:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add a `flatMap()` operation to extract a single stream of `ShoppingArticles`
    for all `ShoppingCarts`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Extract the price for each `ShoppingArticle` using the `mapToDouble()` operation;
    this will create a `DoubleStream`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, reduce the prices of all `ShoppingArticle` to a sum, using the `sum()`
    method that is available in `DoubleStream`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now you have a function that will reduce a list of `ShoppingCart` to a unified
    sum in Java-$. All you have to do now is to apply this function to your `ShoppingCart`
    class, and then print out the resulting sum to the terminal, rounding it to two
    decimals:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'You can refer the complete code at: [https://packt.live/2qzLaHx](https://packt.live/2qzLaHx).'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: You've now created your first complete piece of code using the functional Java
    Stream API. You've created a stream of complex objects, applying a mapping operation
    to the elements of the stream to transform them, and then another mapping operation
    to transform the elements yet again, changing the stream type twice. Finally,
    you reduced the whole stream to a single primitive value that was presented to
    the user.
  prefs: []
  type: TYPE_NORMAL
- en: 'Activity 1: Applying Discount on the Items'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Improve the preceding example by adding a function that applies a discount for
    certain items in the shopping carts, before calculating the final price. Ensure
    the price calculation is still correct.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The solution for this activity can be found on page 563.
  prefs: []
  type: TYPE_NORMAL
- en: Using Collectors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Collectors** in Java are a very powerful tool when you need to extract certain
    data points, descriptions, or elements from large data structures. They offer
    a very understandable way of describing what you want to do with a stream of elements,
    without needing to write complex logic.'
  prefs: []
  type: TYPE_NORMAL
- en: There are a number of helpful default implementations of the `Collector` interface
    that you can start using easily. Most of these collectors will not allow null
    values; that is, if they find a null value in your stream, they will throw a `NullPointerException`.
    Before using a collector to reduce your elements in any of these containers, you
    should take care to handle null elements in the stream.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is an introduction to all default Collectors:'
  prefs: []
  type: TYPE_NORMAL
- en: '`toCollection`: This generic collector will allow you to wrap your elements
    in any known class implementing the `Collection` interface; examples include `ArrayList`,
    `HashSet`, `LinkedList`, `TreeSet`, and others:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`toList`: This will reduce your elements into an `ArrayList` implementation.
    If you need a more specific type of list, you should use the `toCollection()`
    collector:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`toUnmodifiableList`: This is essentially the same as the `toList()` collector,
    with the one difference that it uses the `List.of()` generator function to make
    the list unmodifiable:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`toSet`: This wraps the elements in a `HashSet`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`toUnmodifiableSet`: This is just like the `toSet()` collector, with the difference
    being that it will use the `Set.of()` generator to create an unmodifiable set:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`joining`: This collector will use a `StringBuilder` to concatenate the elements
    of the stream into a string without any separating characters:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This will print `onetwothreefourfive` to the terminal. If you need the elements
    to be separated by a comma, for example, use `Collectors.joining(",")`:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In this example, you get `one,two,three,four,five` printed to the terminal.
    Finally, you have the option of adding a prefix and a suffix to the generated
    string as well:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The prefix and suffix are added to the string, not each element. The generated
    string will look like: `Prefixone,two,three,four,fiveSuffix`.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`mapping`: This is a special type of collector that allows you to apply a mapping
    to each element of the stream before applying a defined collector:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here, we're starting with a source of `List<String>` and collecting to a `Set<String>`.
    But before we collect, we're concatenating a `-suffix` string to each element
    using the `mapping()` collector.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`flatMapping`. Just like the `flatMap()` intermediate operation, this collector
    will allow you to apply a flat mapping to the stream elements, before collecting
    them to a new container. In the following example, we start with a source, `List<Set<String>>`,
    then we flatten it out to a `Stream<Set<String>>` and apply `Collector.toList()`—effectively
    turning all the sets into a single list instead:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`filter()` intermediate operation, here, you''re allowed to apply a filtering
    before you implement operations on the stream.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`collectingAndThen`: This special collector will allow you to finish the collection
    off with a special function; for example, turning your collection into an immutable
    collection:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`counting`: This produces the same result as the `count()` intermediate operation:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`minBy`: This collector is equivalent to using the `min()` terminal operator.
    The following example will print `Optional[1]` to the terminal:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`maxBy`: You''ll get the same result using this collector as you would with
    the `max()` terminal operator:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`summingInt`: This is an alternative to the `reduce()` intermediate operation,
    and is used to calculate the sum of all elements in the stream:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`summingLong`: This is the same as `Collector.summingInt()`, but will instead
    produce a sum in the `long` type:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`summingDouble`: This is the same as `Collector.summingLong()`, but will instead
    produce a sum in the `double` type:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`averagingInt`: Returns the average the integers passed:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`averagingLong`: Returns the average the longs passed:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`averagingDouble`: Returns the average of the numbers passed in the argument:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`reduce()` terminal operator, which this collector inherits its name and operation
    from.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`groupingBy`: This collector will group elements according to a given function
    and collect them according to a given collection type. Consider the following
    example class, describing a car:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If you would like to sort a few cars according to their brand and collect them
    into new containers, then it''s simple with the `groupingBy()` collector:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Here, we have four different cars. Then, we apply the `groupingBy()` collector
    based on the brand of cars. This will produce a `Map<String, List<Car>>` collection,
    where `String` is the brand of the car, and the `List` contains all the cars for
    said brand. This will always return `Map`; however, it is possible to define what
    kind of collection to gather the grouped elements in. In the following example,
    we''ve grouped them into `Set` instead of the default list:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `groupingBy` collector becomes even more powerful if you combine it with
    another collector—for example, the `reducing` collector:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In this example, we group the cars by brand and then reduce them to only show
    the car of each brand with the most powerful engine. This kind of combination,
    of course, also works with other collectors, such as filtering, counting, and
    others:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`groupingBy` collector, and has the exact same API.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`partitioningBy`: The `partitioningBy` collector works in a similar way to
    the `groupingBy` collector, with the difference being that it will group elements
    into two collections that either matches a predicate or doesn''t match a predicate.
    It will wrap these two collections into `Map`, where the `true` keyword will reference
    the collection of elements that matches the predicate, and the `false` keyword
    will reference the elements that don''t match the predicate:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You can also select which kind of collection the elements should be wrapped
    in, just like the `groupingBy` collector:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`toMap`: This collector will allow you to create a `map` from your stream elements
    by defining a mapping function, where you provide a key and value to put into
    the `map`. Often, this is just a unique identifier in the element and the element
    itself.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This can be a little bit tricky because if you provide a duplicate element,
    then your pipeline will throw an `IllegalStateException` since `Map` is not allowed
    duplicate keys:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This simple example demonstrates how to map a string representation of an integer
    to the actual integer. If you know you may have duplicate elements, then you can
    supply a `merge` function to resolve that conflict:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You also have the option of generating your own type of `Map` by applying a
    `factory` function at the very end of the collector. Here, we''re telling the
    collector to generate a fresh `TreeMap` for us:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`toUnmodifiableMap`: This is essentially the same as `toMap`, with the same
    API; however, it returns unmodifiable versions of `Map` instead. This is perfect
    for when you know you will never mutate the data in `Map`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`toConcurrentMap`: Because of the way `Map` is implemented, it can be a bit
    hazardous to performance when using it in parallel streams. In this case, it''s
    recommended that you use the `toConcurrentMap()` collector instead. This has a
    similar API to the other `toMap` functions, with the difference being that it
    will return instances of `ConcurrentMap` rather than `Map`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Car` class from previous collectors, you could produce a summary of all car
    engines like this:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: I/O Streams
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Apart from collections and other primitives, you can use files and I/O streams
    as sources in your pipelines. This makes writing tasks against servers very descriptive.
  prefs: []
  type: TYPE_NORMAL
- en: Because these types of resources generally need to be closed properly, you should
    use a try-with-resources statement to ensure the resources are handed back to
    the system when you're done with them.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider having a CSV file called `authors.csv` with these contents:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: 'You can put this file into a stream using a try-with-resources statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: 'In I/O streams, you can add `onClose` handlers to receive a notification when
    the stream is closed. Unlike other streams, this will be closed automatically
    when the resources for the stream have been closed. In this example, that''s handled
    automatically by the try-with-resources statement. In the following example, we''ve
    added an `onClose` handler that will print the word `Closed` when the stream has
    been closed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the same example written with an `InputStream` instead. Notice that
    the code is now more verbose, having three nested object creations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: 'Exercise 2: Converting CSV to a List'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A web-based grocery shop has implemented its very own database based on a standard
    Java `List` collection, and has also implemented a backup system where the database
    is backed up to CSV files. However, they still haven't built a way of restoring
    that database from a CSV file. They have asked you to build a system that will
    read such a CSV file, inflating its contents to a list.
  prefs: []
  type: TYPE_NORMAL
- en: 'The database backup CSV file contains one single type of object: `ShoppingArticle`.
    Each article has a `name`, a `price`, a `category`, and finally, a `unit`. The
    name, category, and unit should each be a `String`, and the price a `double`:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the `Chapter15` project in IDEA if it's not already open.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new Java class, using `File`| `New` | `Java`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Enter `Exercise2` as the name, and then select `OK`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'IntelliJ will create your new class; it should look something like the following
    snippet:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE106]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add a `main` method to this class. This is where you''ll write the bulk of
    your application. Your class should now look like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE107]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a `ShoppingArticle` inner class and make it static so that you can easily
    use it in the main method. Override the `toString` method to make it easy to print
    articles to the terminal later:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE108]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Create a new folder in your project called `res` if it doesn't already exist.
    Then, place it in the root, next to the `src` folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Copy the `database.csv` file from GitHub to your project and place it in the
    `res` folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Back in your `Exercise2.java` class, add a function that produces `List<ShoppingArticle>`.
    This will be our function to load the database into a list. Since the function
    will be loading a file, it needs to throw an I/O exception (`IOException`):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE109]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Call this function from your `main` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE110]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Start by loading the database file with a try-with-resources block. Use `Files.lines`
    to load all the lines from the `database.csv` file. It should look something like
    this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE111]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Let''s peek into the stream in order to look at the state of it right now.
    Intermediate operations will only run when there''s a terminal operation defined,
    so add a `count()` at the end just to force it to execute the whole pipeline:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE112]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This should print every single line of the file. Notice that it also prints
    the header line—which we're not concerned with when converting to `ShoppingArticles`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Since we''re not really interested in the first row, add a `skip` operation
    just before the `count()` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE113]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now you have every single line of the database file loaded as elements in the
    stream, except for the header. It''s time to extract every piece of data from
    those lines; a suitable operation for this is `map`. Split every line into `String`
    arrays using the `split()` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE114]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add another `peek` operation to find out how the `map` operation changed the
    stream; your stream type should now be `Stream<String[]>`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE115]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add another `map` operation, but this time to turn the stream into `Stream<ShoppingArticle>`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE116]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now you can peek again to ensure the articles were created properly:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE117]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Collect all the articles in a list. Use an unmodifiable list to protect the
    database from unwanted modifications:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE118]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This may seem verbose, as some operations could have been applied together to
    make it shorter. However, there's a point to keeping every single operation small,
    and that's to make the whole logic very transparent. If you find a problem with
    the pipeline, you can simply move a single operation in the pipeline, and that
    should sort all problems.
  prefs: []
  type: TYPE_NORMAL
- en: If you combine multiple steps in an operation, it's more difficult to move the
    operations around in the pipeline or to replace it fully.
  prefs: []
  type: TYPE_NORMAL
- en: 'Activity 2: Searching for Specifics'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'With the database loaded, apply some searching logic:'
  prefs: []
  type: TYPE_NORMAL
- en: Build a function that will find the cheapest fruit from a list of `ShoppingArticles`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Build a function that will find the most expensive vegetable from a list of
    `ShoppingArticles`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Build a function that will gather all fruits in a separate list.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Build a function that will find the five least expensive articles in the database.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Build a function that will find the five most expensive articles in the database.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The Solution for this Activity can be found on page 564.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Descriptive code is always an ideal to strive for when writing programs. The
    simpler the code is, the easier it will be to communicate your intentions to colleagues
    and other interested parties.
  prefs: []
  type: TYPE_NORMAL
- en: The Java Streams API allows you to construct simple, and highly descriptive
    functions. Quite often they'll be pure functions since the Streams API makes it
    very easy to avoid manipulating state.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we'll delve further into functional programming topics,
    exploring the different functional interfaces available.
  prefs: []
  type: TYPE_NORMAL
