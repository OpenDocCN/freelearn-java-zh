- en: '3'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Observability, Monitoring, and Application Management
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Monitoring and observability are crucial aspects of managing and maintaining
    the health, performance, and reliability of modern applications. In microservices-oriented
    applications, with multiple instances of different services running at the same
    time to deliver a solution, observability and monitoring help in understanding
    the interactions between these services and identifying issues.
  prefs: []
  type: TYPE_NORMAL
- en: Monitoring plays a crucial role in large environments, enabling resource utilization
    and performance metrics to be tracked. This, in turn, facilitates dynamically
    scaling resources to effectively meet the demands of the system. This is especially
    useful in cloud computing environments, where you pay for the resources used and
    where you can adapt your application resources to the real demands of your users.
    Without monitoring, how do you know if your application is running at 100% CPU
    and the response time is so slow that your users abandon your application?
  prefs: []
  type: TYPE_NORMAL
- en: When you have multiple microservices running in your application and there’s
    an issue, observability is crucial in identifying the failing component and the
    context in which errors occur.
  prefs: []
  type: TYPE_NORMAL
- en: Observability and monitoring are also very important for continuous improvement.
    You can use the insights gained from monitoring to make data-driven decisions,
    enhance performance, and refine the solution over time.
  prefs: []
  type: TYPE_NORMAL
- en: Spring Boot, through Actuator, provides not only monitoring but also management
    capabilities that allow you to interact with the application in production environments.
    This capability not only allows you to detect potential issues in the application
    but also helps in troubleshooting at runtime.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, you will gain insights into activating observability and monitoring
    features within your Spring Boot applications. We’ll start by providing health
    checks in your application. Here, you’ll learn how to leverage the data that’s
    generated by your application through popular open source solutions. This chapter
    will also cover creating traces within your system, allowing you to correlate
    activities across different microservices and explore them using Zipkin. Additionally,
    you will learn how to monitor the exposed metrics of your application using Prometheus
    and Grafana. Beyond the standard metrics provided by Spring Boot and its associated
    components, you will generate custom metrics tailored to your application’s specifics
    and monitor them. Once your application becomes both monitorable and observable,
    you can also integrate with commercial tools while considering the plethora of
    powerful monitoring solutions available in the market that are well-suited for
    production environments. Finally, you will learn how to change application settings
    at runtime so that you can troubleshoot your application.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we’re going to cover the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Adding Actuator to your application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a custom Actuator endpoint
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using probes and creating a custom health check
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing distributed tracing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Accessing standard metrics
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating your own metrics
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Integrating your application with Prometheus and Grafana
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Changing the settings of a running application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we’ll need to run different tools, such as Prometheus, Grafana,
    and Zipkin. As usual, the simplest way to run them on your computer is using Docker.
    You can get Docker from its product page: [https://www.docker.com/products/docker-desktop/](https://www.docker.com/products/docker-desktop/).
    I will explain how to deploy each tool in its corresponding recipe.'
  prefs: []
  type: TYPE_NORMAL
- en: 'All the recipes that will be demonstrated in this chapter can be found at:
    [https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook/tree/main/chapter3](https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook/tree/main/chapter3).'
  prefs: []
  type: TYPE_NORMAL
- en: Adding Actuator to your application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So, you plan to develop a new RESTful API to complete your football-related
    suite of services. You are concerned about the responsiveness of your application
    and our aim to provide a resilient service. For that reason, you are very interested
    in monitoring your application health properly.
  prefs: []
  type: TYPE_NORMAL
- en: Before you start to monitor your application, your application should be monitorable.
    For that, you have decided to start using **Spring** **Boot Actuator**.
  prefs: []
  type: TYPE_NORMAL
- en: Spring Boot Actuator comprises a set of production-ready functionalities packaged
    with the Spring Framework. It incorporates various built-in tools and endpoints
    that are designed to allow you to monitor, manage, and interact with Spring Boot
    applications within a production setting. Actuator simplifies the process of comprehending
    and resolving runtime behaviors in Spring Boot applications.
  prefs: []
  type: TYPE_NORMAL
- en: The Actuator module exposes multiple endpoints, including `health`, `metrics`,
    `info`, `dump`, and `env`, among others, offering operational insights into the
    running application. Once this dependency is included, you have a lot of out-of-the-box
    endpoints available. Customizing and extending these endpoints can easily be achieved
    and provides flexibility in terms of configuration.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, you will learn how to include Spring Boot Actuator in your project
    and use some of the endpoints that are provided out of the box.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this recipe, we’ll create an application using the *Spring Initializr* tool.
    As you did in previous chapters of this book, you can use the tool in your browser
    by going to [https://start.spring.io](https://start.spring.io) or integrating
    it into your favorite code editor.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s create a project with Actuator enabled and start exploring the endpoints
    provided:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a project using the *Spring Initializr* tool. Open [https://start.spring.io](https://start.spring.io)
    and use the same parameters that you used in the *Creating a RESTful API recipe*
    of [*Chapter 1*](B21646_01.xhtml#_idTextAnchor020), except change the following
    options:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For `fooballobs`
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: For **Dependencies**, select **Spring Web** and **Spring** **Boot Actuator**
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Download the template that was generated with *Spring Initializr* and unzip
    the content to your working directory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'If you run the application now, you can access the health endpoint at `/actuator/health`.
    Before running the application, we’ll expose some endpoints. For that, create
    an `application.yml` file in the `resources` folder and add the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'http://localhost:8080/actuator/env: This endpoint returns the environment variables
    of the application.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`http://localhost:8080/actuator/metrics`: This endpoint returns a list that
    contains the metrics that have been exposed by the application. You can get the
    values of any of the metrics that have been exposed by appending the name to the
    metrics endpoint. For instance, to get `process.cpu.usage`, you can request http://localhost:8080/actuator/metrics/process.cpu.usage.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`http://localhost:8080/actuator/beans`: This endpoint returns a list with the
    beans registered in the IoC container – that is, a list of beans that can be injected
    into other beans.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`http://localhost:8080/actuator/loggers`: This endpoint returns the list of
    log levels and loggers of the application. It also allows to modify the log level
    at runtime.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In this recipe, you exposed just some of the available endpoints. You can find
    the full list of built-in endpoints at [https://docs.spring.io/spring-boot/docs/current/reference/html/actuator.html#actuator.endpoints](https://docs.spring.io/spring-boot/docs/current/reference/html/actuator.html#actuator.endpoints).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When you integrate Actuator into your application, it provides a set of endpoints
    that can be used for monitoring your application and managing its behavior. In
    addition to the built-in endpoints, it lets you add your own.
  prefs: []
  type: TYPE_NORMAL
- en: Endpoints can be enabled or disabled. By default, all endpoints are enabled
    except the shutdown endpoint – as its name suggests, you can use it to gracefully
    shut down the application. Then, the endpoints can be exposed, meaning that they
    can be accessed remotely using HTTP requests or JMX. By default, only the health
    endpoint is exposed. In this book, we’ll mostly focus on HTTP as it can be used
    with standard monitoring tools not specific to the Java ecosystem. HTTP is only
    available for web applications; if you’re developing another type of application,
    you will need to use JMX.
  prefs: []
  type: TYPE_NORMAL
- en: Depending on the components you use, more data will be exposed. For instance,
    when you include Spring Data JPA, the Spring Data metrics become available, so
    you will have to configure the number of open connections and other relevant metrics
    for Spring Data monitoring.
  prefs: []
  type: TYPE_NORMAL
- en: There’s more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Some of the endpoints provided by Actuator may expose very sensitive information.
    So, the health endpoint is the only one that’s exposed by default. If your applications
    can only be accessed inside a virtual network or protected with a firewall, maybe
    you can keep endpoints open. Whether your application is publicly exposed or you
    simply want to control who accesses your Actuator endpoint, you may want to protect
    them, as explained in [*Chapter 2*](B21646_02.xhtml#_idTextAnchor066). For instance,
    a security configuration could look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: You can refer to Spring Boot’s official documentation at [https://docs.spring.io/spring-boot/docs/current/reference/html/actuator.html#actuator.endpoints.security](https://docs.spring.io/spring-boot/docs/current/reference/html/actuator.html#actuator.endpoints.security)
    for more details.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In addition to endpoints provided by Spring Boot and the components used, Actuator
    provides a flexible implementation that allows you to create your own endpoints.
    Later in this chapter, you will learn how to create your own Actuator endpoint,
    metrics, and custom health checks.
  prefs: []
  type: TYPE_NORMAL
- en: See the *Creating a custom Actuator endpoint*, *Creating a custom health check*,
    and *Creating your own metrics* recipes for more information.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a custom Actuator endpoint
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In our example, we are developing a new RESTful API that requires a file to
    be loaded from blob storage. That file doesn’t change frequently, which means
    it’s loaded in memory at application startup and is not reloaded again automatically.
    You need to know which version of the file is loaded, and you want to force a
    reload when there is a new version.
  prefs: []
  type: TYPE_NORMAL
- en: To implement this feature, you will use a custom Actuator endpoint. This endpoint
    will have a `GET` operation to return the current file version, and a `POST` method
    to reload the file.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this recipe, you will reuse the application you created in the *Adding Actuator
    to your application* recipe. I’ve prepared a working version in this book’s GitHub
    repository at [https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook/](https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook/).
    It can be found in the `chapter3/recipe3-2/start` folder.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s modify the RESTful API so that it loads a file from a folder and returns
    some results. Once you’ve done this, you’ll need to create a custom Actuator endpoint
    that returns the file that’s been loaded. You will also need to configure the
    endpoint to reload the file:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Start by creating a class that loads a file and keeps the content in memory:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let’s name it `FileLoader` and add the following code:'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To load the file and keep the content in memory, add the following code:'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, add a public method so that you can load the first file that’s found in
    the folder that’s passed in the constructor:'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, create a class annotated with `@Endpoint` to define the custom Actuator
    endpoint. Name it `FootballCustomEndpoint`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This class receives a `FileLoader` object in the constructor to perform the
    necessary actions.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now, create the custom endpoint operations in `FootballCustomEndpoint`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a method annotated with `@ReadOperation` to retrieve the file version
    in use:'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a method annotated with `@WriteOperation` to refresh the file:'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, you need to create a bean for both the `FileLoader` and `FootballCustom``Endpoint`
    classes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a class named `FootballConfiguration` and annotate it with `@Configuration`:'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note that there is a field annotated with `@Value`. It will load the folder
    path containing the file to load from the configuration.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a method that produces a bean for `FileLoader`:'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, create a method that produces `FootballCustomEndpoint`:'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Since `FileLoader` needs to load the file by using the `loadFile` method, you
    will need to create a class that implement an `ApplicationRunner` interface:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Modify the `application.yml` file in the `resources` folder:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add a setting that provides a path to the folder containing the file to load:'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the new Actuator endpoint:'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a sample RESTful controller that returns the content that’s loaded in
    memory by the `FileLoader` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The service is now ready to test. Execute the application and perform the following
    requests:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Get the current file version using the custom Actuator endpoint. For that,
    open your terminal and execute the following `curl` request:'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: You will receive the filename as a response – that is, `teams/1.0.0.json`.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let’s create a new version of the file. Rename the file `1.0.1.json` and add
    a new element to the `teams` array, like so:'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, use the custom Actuator endpoint to refresh the file in the application.
    For that, in your terminal, execute the following `curl` request:'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Check the current file version again; you will now get `teams/1.0.``.json`.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: You can also use a RESTful API to validate that the results correspond with
    the content of the file.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: By creating a bean with the `@Endpoint` annotation, Actuator exposes all methods
    annotated with `@ReadOperation`, `@WriteOperation`, and `@DeleteOperation` over
    JMX and HTTP. This example is not much different from a regular RESTful endpoint,
    but the purpose is different as it’s used to manage the application or library
    you developed. Of course, you can implement your custom Actuator endpoint, but
    usually, Actuator endpoints are provided as part of a component that is used by
    others and may require some internal information or behavior to be exposed. For
    instance, database drivers such as PostgreSQL, database connection pool managers
    such as HikariCP, and caching systems such as Redis usually provide Actuator endpoints.
    If you plan to create some kind of system or library that will be used by others
    and you are interested in exposing some internals to facilitate management in
    runtime, Actuator endpoints are a great solution.
  prefs: []
  type: TYPE_NORMAL
- en: An `ApplicationRunner` is a component that is executed right after the application
    starts. When Spring Boot executes, the `ApplicationRunner` isn’t ready to accept
    requests yet. You can define more than one `ApplicationRunner`. Once all the `ApplicationRunner`
    components are executed, the application is ready to accept requests.
  prefs: []
  type: TYPE_NORMAL
- en: Using probes and creating a custom health check
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Your new football trading service is getting readily adopted by football fans.
    This service is used to exchange stickers with football players’ pictures on them
    between fans. To accelerate the process, the service caches some data in the application’s
    memory. You need to ensure that the cache is filled before you start serving requests.
  prefs: []
  type: TYPE_NORMAL
- en: Under normal conditions, the football trading service works fine; however, under
    heavy load, the application instances start degrading and after some instability,
    they end up being unresponsive. To counteract this, you prepare some stress tests
    in the lab environment. However, you realize that the application starts degrading
    because you have issues connecting to the database. At the same time, you realize
    that those kinds of issues happen when the application has more than 90 pending
    orders. While you find a definitive solution, you decide to expose when the application
    is unable to process more requests and create a health check that verifies if
    it can connect to the database.
  prefs: []
  type: TYPE_NORMAL
- en: Probes are mostly used by container orchestrators, such as Kubernetes, to verify
    that the application is ready to accept requests and when it is already working
    to indicate that it’s alive. In Kubernetes, they are known as readiness and liveness
    probes.
  prefs: []
  type: TYPE_NORMAL
- en: A health check is a mechanism to verify that the application has everything
    ready to work – for instance, it’s able to connect to a database.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, you will learn how to expose a readiness check, how to change
    your liveness state, and how to create a custom health check that can be used
    by the hosting platform or a monitoring system to determine the health of your
    application instances and when your application is ready to accept requests.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this recipe, you will reuse the application you created in the *Creating
    a custom Actuator endpoint* recipe. I’ve prepared a working version in this book’s
    GitHub repository at [https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook/](https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook/).
    It can be found in the `chapter3/recipe3-3/start` folder.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this recipe, you will verify that the application can connect to the application
    database. We’ll use PostgreSQL as a database. To run PostgreSQL locally, we’ll
    use Docker. You can download and start the database just by executing the following
    command in your terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'If you created any database in [*Chapter 5*](B21646_05.xhtml#_idTextAnchor203),
    you can reuse it here. This recipe doesn’t perform any real queries – it just
    verifies it can connect. If you don’t have a database created in the container,
    you can create a database using the **psql** tool. For that, execute the following
    command in your terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'You will be prompted for a password. Specify `packt` and press **intro**. You
    will be connected to a PostgreSQL terminal. Execute the following command to create
    a database:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Now, you can exit the database by executing the `quit;` command.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this recipe, you’ll configure your application so that it can manage probes
    and create a custom health check to verify that the application can connect to
    the database:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Start by updating the `application.yml` file in the `resources` folder so that
    it can enable readiness and liveness probes. For that, include the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, create a class that emulates the football trading service. Name it `TradingService`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This class will manage the trading requests. When trading a request, if it
    detects that there are more than 90 pending orders, it will notify you that the
    application cannot manage more requests. For that, it will use `ApplicationEventPublisher`,
    which will be injected into the constructor:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, define a method that returns the number of pending orders. We’ll simulate
    this by returning a random number between 0 and 100:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, you can create a method that manages the trading operations. If there
    are more than 90 pending orders, it will change the state of the application:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, configure the connection to the database:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add Spring Data JDBC and PostgreSQL dependencies. For that, in the `pom.xml`
    file, add the following dependencies:'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the following configuration to the `application.yml` file in the `resources`
    folder:'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, let’s create a health indicator:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'For that, create a class named `FootballHealthIndicator` that implements the
    `HealthIndicator` interface:'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'As it will connect to the database, inject `JdbcTemplate` into the constructor:'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, override the health method so that you can perform connectivity checking:'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Before testing the application, you can modify the `FileLoader` class, simulating
    it so that it takes a few seconds to load the file. You can do this by modifying
    the `loadFile` method by adding the following code. This will make the application
    wait 10 seconds before it loads the file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, let’s test the application’s readiness:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Before running the application, execute the following command in your terminal:'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This command will execute a request to the readiness probe every second.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Start the application. You will see that the output of the `watch` command
    changes. First, it will appear as **OUT_OF_SERVICE**:'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 3.1: Readiness status set to OUT_OF_SERVICE](img/B21646_03_1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.1: Readiness status set to OUT_OF_SERVICE'
  prefs: []
  type: TYPE_NORMAL
- en: 'After 10 seconds or the time you configured in *Step 5*, it will change to
    **UP**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 3.2: Readiness status changed to UP](img/B21646_03_2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.2: Readiness status changed to UP'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, test the application’s liveness:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Again, execute a `watch` command, but this time, make requests to the liveness
    probe’s endpoint:'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Remember that if there are more than 90 pending requests, it will mark itself
    as failing. Since a random number between 0 and 100 is selected, there’s a 10%
    possibility it will fail.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'You will see that the readiness endpoint returns `watch` command for the Actuator
    health endpoint:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'it will return **UP** every time. To verify that it detects when it cannot
    connect to the database, stop the PostgreSQL container. To do so, run the following
    command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: You will see that the Actuator endpoint will take longer to respond and that
    the response will be **DOWN**.
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Readiness and liveness probes are enabled automatically when Spring Boot detects
    it’s running on Kubernetes, but you can enable them manually. In this recipe,
    we enabled them explicitly, but if you run the application on Kubernetes, this
    will be done automatically.
  prefs: []
  type: TYPE_NORMAL
- en: Readiness and liveness probes should not check any external component. They
    should verify that the application is ready internally and that it’s capable of
    responding. On the other hand, health checks should verify that all dependent
    components are available.
  prefs: []
  type: TYPE_NORMAL
- en: The Spring Boot application life cycle goes through different states, and it
    generates events every time it changes its state. I won’t explain all possible
    application states here; instead, I’ll focus on the relevant states during readiness
    probes. The first state is `starting`. Once Spring Boot initializes the components,
    it changes to `started`. At this point, it’s not ready yet, so it needs to run
    all `ApplicationRunner` and `CommandLineRunner` instances defined in the application.
    Once all of them are executed, it changes to `ready`. In this recipe, we introduced
    a delay of 10 seconds in the `loadFile` method. During this period, the readiness
    status was **OUT_OF_SERVICE**. Once it had loaded the file, it changed to **UP**.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to learn more, take a look at the following Spring Boot documentation:
    [https://docs.spring.io/spring-boot/docs/current/reference/html/features.html#features.spring-application.application-events-and-listeners](https://docs.spring.io/spring-boot/docs/current/reference/html/features.html#features.spring-application.application-events-and-listeners).'
  prefs: []
  type: TYPE_NORMAL
- en: Be careful while checking other components. First, if it is another service,
    such as the one we created in this recipe, it will likely also have probes and
    health checks. Checking this via your service can be redundant. Second, try to
    make light checks; otherwise, you may generate too much load, which can cause
    performance issues. In this recipe, the SQL command we used was `SELECT 1`. This
    command connects to the database but doesn’t require computing resources from
    the database engine out of the connection itself.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Health checks should not necessarily imply that you check the health of all
    the dependencies of your application. Rather, you should check if your application
    has any problems that could be solved by reducing the load or by rebooting. If
    your application depends on an unresponsive service and you mark your application
    as unhealthy, the application instance will be restarted. However, if your problem
    is in another application, the problem won’t disappear, and the application will
    be restarted again and again without solving the problem. For that kind of scenario,
    consider implementing a *circuit breaker* solution. See [https://spring.io/guides/gs/cloud-circuit-breaker/](https://spring.io/guides/gs/cloud-circuit-breaker/)
    for guidance on how to implement this using Spring Cloud.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing distributed tracing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, you’ve created a solution with two microservices, the football trading
    microservice and the client microservice. Among other features, the trading microservice
    provides the ranking of players. The client microservice enhances the list of
    players by adding the ranking that was obtained from the trading microservice.
  prefs: []
  type: TYPE_NORMAL
- en: Distributed tracing emerges as a crucial tool as it offers a systematic approach
    to monitoring, analyzing, and optimizing the flow of requests between microservices.
    Distributed tracing is a method of monitoring and visualizing the flow of requests
    as they propagate through various components of a distributed system, providing
    insights into performance, latency, and dependencies between services.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, you will learn how to enable distributed tracing for your microservices,
    export the data to Zipkin, and access the results.
  prefs: []
  type: TYPE_NORMAL
- en: Zipkin is an open source distributed tracing system that helps developers trace,
    monitor, and visualize the paths of requests as they travel through various microservices
    in a distributed system, providing valuable insights into performance and dependencies.
    What you will learn about Zipkin in this recipe can be easily adapted to other
    tools.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this recipe, we’ll visualize the traces using Zipkin. You can deploy it
    on your computer using Docker. For that, open your terminal and execute the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: The preceding command will download an image with an OpenZipkin server, if you
    don’t have one already, and start the server.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll reuse the trading service we created in the *Using probes and creating
    a custom health check* recipe. If you haven’t completed it yet, don’t worry –
    I’ve prepared a working version in this book’s GitHub repository at [https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook/](https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook/).
    It can be found in the `chapter3/recipe3-4/start` folder.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s enable distributed tracing in the existing trading service and create
    the new client service. For the new client service, we’ll need to ensure that
    distributed tracing is enabled as well. Before starting, ensure that your OpenZipkin
    server is running, as explained in the *Getting* *ready* section:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Start by enabling distributed tracing in the trading microservice you created
    in the *Using probes and creating a custom health* *check* recipe:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'For that, open the `pom.xml` file and add the following dependencies:'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The first dependency is a bridge between `application.yml` file in the `resources`
    folder and add the following setting:'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: By default, sampling is only set to 10%. This means that only 10% of traces
    are sent. With this change, you will send 100% of the traces.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the same `application.yml` file, add the following configuration:'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This change is not mandatory but helps identify the service in distributed tracing.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Next, create the ranking endpoint in the football trading microservice that
    will be consumed by the client microservice. For that, in `FootballController`,
    create the following method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: To simulate random errors, this method throws an exception when a random number
    from 0 to 99 is greater than 97 – that is, 2% of the time.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Next, create a new application that will act as the client application. As
    usual, you can create the template using the *Spring* *Initializr* tool:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open [https://start.spring.io](https://start.spring.io) and use the same parameters
    that you did in the *Creating a RESTful API* recipe of [*Chapter 1*](B21646_01.xhtml#_idTextAnchor020),
    except change the following options:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: For `fooballclient`
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For `pom.xml` file and add the following dependencies:'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: 'In the client application, add a RESTful controller:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Name it `PlayersController`:'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: 'This application must call the trading service. For that, it will use `RestTemplate`.
    To achieve the correlation between service calls, you should use `RestTemplateBuilder`
    to create `RestTemplate`. Then, inject `RestTemplateBuilder` into the controller’s
    constructor:'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, you can create the controller method that calls the trading service of
    the other application:'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: 'Configure client application tracing in the `application.yml` file:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: As you did in the trading service, you should set `sampling` to `1.0` so that
    100% of the traces will be recorded. To distinguish the client application from
    the trading service application, set the `spring.application.name` property to
    `football-client`.
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'To avoid port conflicts with the trading application, configure the client
    application so that it uses port `8090`. To do that, add the following parameter
    to the `application.yml` file:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, you can test the application. Call the client application; it will make
    multiple calls to the trading service. To make continuous requests to the client
    application, you can execute the following command in your terminal:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, open Zipkin to see the traces. For that, go to `http://localhost:9411/`
    in your browser:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Figure 3.3: The Zipkin home page](img/B21646_03_3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.3: The Zipkin home page'
  prefs: []
  type: TYPE_NORMAL
- en: 'On the home page, click **RUN QUERY** to see the traces that have been generated:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.4: Root traces in Zipkin](img/B21646_03_4.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.4: Root traces in Zipkin'
  prefs: []
  type: TYPE_NORMAL
- en: 'On this page, you will see that the traces from the client application are
    root traces. Since we introduced a random error, you will see that there are failed
    and successful traces. If you click the **SHOW** button for any of these traces,
    you will see the traces of both RESTful APIs. There will be a main request for
    the client service and nested requests for the trading service:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.5: Trace details, including nested traces](img/B21646_03_5.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.5: Trace details, including nested traces'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also view the dependencies between services by clicking on the **Dependencies**
    link on the top bar:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.6: Viewing the dependencies between services in Zipkin](img/B21646_03_6.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.6: Viewing the dependencies between services in Zipkin'
  prefs: []
  type: TYPE_NORMAL
- en: Here, you can see the dependencies between the `football-client` application
    and the `trading-service` application.
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Micrometer* is a library that allows you to instrument your application without
    dependencies with specific vendors. This means that your code won’t change if
    you decide to use another tool, such as *Wavefront*, instead of Zipkin.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `io.micrometer:micrometer-tracing-bridge-otel` dependency creates a bridge
    between *Micrometer* and *OpenTelemetry*, after which the `io.opentelemetry: opentelemetry-exporter-zipkin`
    dependency exports from *OpenTelemetry* to *Zipkin*. If you want to use another
    tool to monitor your traces, you just need to change these dependencies, without
    any additional code changes.'
  prefs: []
  type: TYPE_NORMAL
- en: The default address to send traces to Zipkin is `http://localhost:9411`. That’s
    why we didn’t need to configure it explicitly. In a production environment, you
    can use the `management.zipkin.tracing.endpoint` property.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we used `RestTemplateBuilder`. This is important as it configures
    `RestTemplate` by adding the tracing headers to the outgoing requests. Then, the
    target service gathers the tracing headers that can be used to nest the traces
    in the called application to the root trace from the client application. In reactive
    applications, you should use `WebClient.Builder` instead of `RestTemplateBuilder`.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we configured 100% sampling. This means that we send all traces
    to the tracing server. We did this for learning purposes; normally, you shouldn’t
    do this in production as you can overload the tracing server by, for example,
    deploying a server via Zipkin or ingesting a lot of data if you’re using a managed
    service in the cloud. The amount of data that’s ingested directly affects monitoring
    systems – that is, the more data you ingest, the more it will cost you. However,
    even if you deploy your own tracing server, you will need to scale up as well.
    So, either way, it can increase your overall cost. In a large-scale system, having
    a sampling rate of 10% is more than enough to detect issues between services as
    well as understand the dependencies between the components.
  prefs: []
  type: TYPE_NORMAL
- en: There’s more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Micrometer tracing creates spans – that is, units of work or segments of a distributed
    trace that represent the execution of a specific operation, for each request.
    Spans capture information about the duration, context, and any associated metadata
    related to the respective operation.
  prefs: []
  type: TYPE_NORMAL
- en: You can create a span by starting an observation using the `ObservationRegistry`
    component. For instance, say `TradingService` has different important parts that
    you want to trace, such as *Collect data* and *Process data*. You can create different
    spans for those in your code.
  prefs: []
  type: TYPE_NORMAL
- en: 'To implement this, you will need to inject `ObservationRegistry` into your
    controller using the Spring Boot dependency container. For that, you need to define
    the `ObservationRegistry` parameter in the controller’s constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, you must create the observations in the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: Note that the observations include the player with `lowCardinalityKeyValue`
    to facilitate finding spans through this data.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Some parts of the code have been removed for brevity. You can find the full
    version in this book’s GitHub repository at https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook/.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, in Zipkin, you can see the custom spans nested in `trading-service`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.7: Custom spans in Zipkin](img/B21646_03_7.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.7: Custom spans in Zipkin'
  prefs: []
  type: TYPE_NORMAL
- en: The `trading-service` span contains two nested spans, and both have a custom
    tag that specifies the player’s name.
  prefs: []
  type: TYPE_NORMAL
- en: Accessing standard metrics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Your Football Trading service continues to grow by being adopted by football
    fans. You need to understand how it performs better so that you can adapt to demand
    while optimizing the resources that are used to provide the service.
  prefs: []
  type: TYPE_NORMAL
- en: You can use the standard metrics provided by Spring Boot Actuator and its related
    components for real-time insights into your application’s behavior. For instance,
    you can find out how much CPU and memory has been used by your application or
    the time spent in **garbage collection** (**GC**). These are the basic metrics
    that give you a general understanding of the performance of the application.
  prefs: []
  type: TYPE_NORMAL
- en: Other metrics are more subtle, such as the metrics provided by the web container,
    Tomcat – for instance, the number of active sessions, the number of sessions rejected,
    and the number of sessions that have expired. Similarly, the database connection
    pool, which is `hikaricp` by default, also exposes some metrics. For instance,
    you can view the number of active sessions, the number of waiting sessions, or
    the number of sessions that have been rejected. These types of metrics can be
    an indicator of problems in your application that aren’t easy to detect just by
    using classic metrics such as CPU and memory utilization.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, you will learn how to access standard metrics and how to detect
    some common application issues. You will also learn how to perform a load test
    using JMeter, but it’s not the main purpose of this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this recipe, you will reuse the applications you created in the *Implementing
    distributed tracing* recipe. If you haven’t completed that recipe yet, I’ve prepared
    a working version that you can find in this book’s GitHub repository at https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook/,
    in the `chapter3/recipe3-5/start` folder. These applications depend on PostgreSQL
    and also export activities to Zipkin, as explained in the previous recipe. Both
    PostgreSQL and Zipkin can be run locally using Docker.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we’ll perform some load tests using JMeter, a popular load-testing
    tool. You can download JMeter from the project website at [https://jmeter.apache.org/download_jmeter.cgi](https://jmeter.apache.org/download_jmeter.cgi).
    Here, you can download a ZIP file containing JMeter binaries and unzip it; no
    further installation is required. To run JMeter, go to the folder where you unzipped
    the binaries and open the `bin` folder. Here, you will find different scripts
    to launch JMeter, depending on your operating system. For Unix-based operating
    systems, you can run the `jmeter.sh` script, while for Windows, you can run the
    `jmeter.bat` script.
  prefs: []
  type: TYPE_NORMAL
- en: I’ve created two JMeter scripts to create some load against the application.
    You can find them in this book’s GitHub repository, in the `chapter3/recipe3-5/jmeter`
    folder.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this recipe, we’ll use the JMeter scripts mentioned in the *Getting ready*
    section to generate a workload for the football application. Then, we’ll observe
    the metrics provided by Spring Boot and its related components. Follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Before running the first load test, ensure that the trading application is
    running and the `metrics` endpoint is exposed. As explained in the *Adding Actuator
    to your application* recipe, this can be done by adding the `metrics` value to
    the `management.endpoints.web.exposure.include` parameter. If you followed the
    previous recipes or used the working version I’ve prepared, as explained in the
    *Getting ready* section, the `application.yml` file should look like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '![Figure 3.8: The number of threads in JMeter](img/B21646_03_8.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.8: The number of threads in JMeter'
  prefs: []
  type: TYPE_NORMAL
- en: If you want to adjust the number of threads, click **Main Thread Group** and
    adjust **Number of** **Threads (users)**.
  prefs: []
  type: TYPE_NORMAL
- en: Once the application is ready, you can run the JMeter script.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s observe the metrics of the application. Go to `http://localhost:8080/actuator/metrics`
    to see the full list of exposed metrics. You can get any of these metrics by appending
    the metric’s name to the `/actuator/metrics` path. Typically, you will get the
    CPU and memory-related counters:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: With `http://localhost:8080/actuator/metrics/process.cpu.usage`, you will get
    the percentage of CPU being used by the application process
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: With http://localhost:8080/actuator/metrics/system.cpu.usage, you will get the
    percentage of CPU being used by the system
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: With `http://localhost:8080/actuator/metrics/jvm.memory.used` you will get the
    amount of memory being used by your application
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'As an example, the result of the `process.cpu.usage` metric looks like this:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Stop the test – you need to create a new endpoint to access the database. For
    that, follow these steps:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a new `DataService` class and inject `JdbcTemplate` into the constructor:'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, create a method that makes a call to the database. To simulate a slow
    database query, you can use the `pg_sleep` PostgreSQL command. This command waits
    for a given number of seconds or fraction of seconds:'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Finally, run another JMeter script that makes a request to the same `/football`
    path and returns a list of teams, as well as the new path, `/stats/{player}`,
    which performs a long request to the database. Again, 30 threads are running these
    requests infinitely.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the first load test, we can see that there is a bottleneck in the application’s
    CPU. In a real-world scenario, the CPU metric can be used to scale the application
    automatically, such as by adding new instances of the application. That’s the
    kind of bottleneck that we could expect under heavy loads.
  prefs: []
  type: TYPE_NORMAL
- en: In the second load test, there is no physical resource bottleneck, but there’s
    a query that takes a long time and blocks a connection that cannot be reused for
    other requests. In a real-world scenario, you could increase the number of available
    connections in the connection pool, but only up to a certain limit, since this
    is a very expensive and finite resource.
  prefs: []
  type: TYPE_NORMAL
- en: If you look at `system.cpu.usage` and `process.cpu.usage`, you will see that
    the values are much lower than `1.0`, which we observed in the previous load test.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also look at the metrics related to the database connection pool. The
    default database connection pool in Spring Data is HikariCP, and all the metrics
    related to this component are `hikaricp.*`. Let’s consider the following metrics:'
  prefs: []
  type: TYPE_NORMAL
- en: '`hikaricp.connections.max`: This value specifies the maximum number of real
    database connections that `hikaricp` will open in the PostgreSQL server. This
    number won’t change during the execution of the test as the value is static during
    the application life cycle. By default, it’s set to `10`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`hikaricp.connections.active`: This is the number of active connections – that
    is, the connections that are executing something in the database server. Under
    light loads, the number will be less than the maximum. Since the database operation
    is long (up to 1 second), and there are 30 concurrent threads for only 10 maximum
    connections, this number will be 10 or near 10 during the execution of the JMeter
    script.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`hikaricp.connections.pending`: When there are no available connections in
    the connection pool, this metric queues the requests. This metric specifies the
    number of connections waiting for an available connection. This number will be
    greater than 1 during the JMeter script’s execution.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`hikaricp.connections.timeout`: If a request is waiting for more than a given
    amount of time –30 seconds by default – it will time out. After executing the
    JMeter script, you will see that this metric will be more than 1.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Opening a physical database connection is an expensive operation. To avoid the
    overhead of creating a connection, there is a mechanism known as a database connection
    pool that keeps some already created connections ready to be used. When a process
    needs to connect to the database, it gets the connection from the pool and returns
    it to the pool once the operation is finished. In the second stress test, there
    were no connections as they took a long time to complete, so they took a long
    time to return to the pool. When there are no available connections, the connection
    pool enqueues the connection until one is released. That’s why you saw `pending`
    connections. After some time, you will see timeout connections. Those are the
    connections that were enqueued for more than 30 seconds.
  prefs: []
  type: TYPE_NORMAL
- en: This situation also impacts the web container. By default, the number of threads
    to serve HTTP requests is finite and there is also a pool. When there are no more
    available threads, the web container – in this case, Tomcat – will enqueue the
    requests. In this kind of situation, when an HTTP request is mostly waiting for
    a dependency to complete, it appears the Reactive framework. In this case, the
    application uses special kinds of threads – non-blocking threads – that are intended
    for I/O operations. These types of threads allow the application to continue processing
    other tasks while waiting for responses from external services.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You can visualize your metrics with standard monitoring tools. In the *Integrating
    your application with Prometheus and Grafana* recipe, you will learn how to integrate
    application metrics with Prometheus and visualize them with Grafana. These are
    two popular open source tools that are part of the **Cloud Native Computing**
    **Foundation** (**CNCF**).
  prefs: []
  type: TYPE_NORMAL
- en: Creating your own metrics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, you’ve created a new feature in your Football Trading service where
    users can list a card for exchange and another user can bid for the traded card.
    When a new bid is received, it is queued in memory until it is committed as it
    requires a bunch of complex validations. There are a lot of expectations for this
    new feature, and you want to be sure it works well. For that reason, you want
    to monitor the bids that are received, how many bids are pending to be committed,
    and the duration of this process.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, you will learn how to create custom metrics using **Micrometer**.
    Micrometer is an open source metrics collection library for Java applications
    that is very well integrated with Spring Boot Actuator. Other libraries can use
    the telemetry data generated by Micrometer to export to different monitoring systems.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are different types of metrics:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Counter**: As the name suggests, it counts how many times something happened.
    We can use this type of metric to find out how many bids were received.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Gauge**: This metric provides a value in a given moment. We can use it to
    find out how many bids are waiting to be processed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Timer**: This metric measures the duration of a given operation. We can use
    it to find out the time spent per bid.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this recipe, we’ll reuse the projects from the *Accessing standard metrics*
    recipe. I’ve prepared a working version if you haven’t completed that recipe yet.
    You can find it in this book’s GitHub repository at [https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook/](https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook/),
    in the `chapter3/recipe3-6/start` folder.
  prefs: []
  type: TYPE_NORMAL
- en: To simulate a workload for the new feature, I’ve created a JMeter script. You
    can find it in this book’s GitHub repository, in the `chapter3/recipe3-6/jmeter`
    folder. You can download JMeter from the project website at [https://jmeter.apache.org/download_jmeter.cgi](https://jmeter.apache.org/download_jmeter.cgi).
    Here, you can download a ZIP file that contains JMeter binaries and unzip it –
    no further installation is required. To run JMeter, go to the folder where you
    unzipped the binaries, then open the `bin` folder. Here, you can find different
    scripts to launch JMeter, depending on your operating system. For Unix, you can
    run the `jmeter.sh` script, while for Windows, you can run the `jmeter.bat` script.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this recipe, you’ll incorporate your custom metrics into the football trading
    application. This enhancement will offer improved insights into your application’s
    performance during runtime:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Go to your trading application and create a new service class named `AuctionService`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Inject `MeterRegistry` into the constructor. In the same constructor, create
    a counter for the bids received, a timer for the duration of the bid to be processed,
    and a gauge for the bids waiting to be confirmed. The class should look like this:'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note that `gauge` returns the size of the map that’s used to keep the bids that
    have been received in memory.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, create a method to process the bids. In this method, you will use the `bidDuration`
    timer to measure the duration of the operation and increase the number of bids
    received using `bidReceivedCounter`.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Use the `ordersTradedCounter` and `tradedDuration` metrics in a new method
    named `tradeCards`. The method should look like this:'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, expose this feature in the `FootballController` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Inject your new `AuctionService` into the constructor:'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note that all the other parameters and fields have been omitted for simplicity.
    Since we are reusing the same project from previous recipes, you should have more
    parameters in the constructor, and you should have other fields as well.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a new method that will present bids for players using the new service:'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now, you can run the application and start generating some load. To do this,
    open the `loadBids.jmx` file in JMeter. You can find this file in this book’s
    GitHub repository at https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook/,
    in the `chapter3/recipe3-6/jmeter` folder. Then, run the script in JMeter and
    keep it running while you observe the metrics.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Observe the counters you created:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'If you open the Actuator metrics endpoint at `http://localhost:8080/actuator/metrics`,
    you will see the new metrics that have been created: `football.bids.duration`,
    `football.bids.pending`, and `football.bids.receieved`. If you append the names
    of these metrics to the Actuator metrics endpoint, you will get the values of
    each metric.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Open `http://localhost:8080/actuator/metrics/football.bids.received` to get
    the number of bids that have been received. You will see the total number of bids.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Open `http://localhost:8080/actuator/metrics/football.bids.duration` to get
    the bids processing duration.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Open `http://localhost:8080/actuator/metrics/football.bids.pending` to get the
    number of bids that are pending.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: For counters and duration, normally, the monitoring tools also provide a rate
    that’s calculated from the total values and based on the frequency of observation.
    It’s more interesting in terms of performance analysis to know the bid processing
    rate than the total number. The same goes for the duration.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Stop the JMeter script.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `MeterRegistry` class registers the metrics, after which they are automatically
    exposed in the Actuator metrics endpoint.
  prefs: []
  type: TYPE_NORMAL
- en: '`gauge` calls the delegate that’s been assigned to the metric. This delegate
    will be executed according to the observation frequency. In this recipe, we call
    the endpoint explicitly. If you use a monitoring tool, it will be observed periodically.
    Keep in mind that this operation should be as lightweight as possible because
    it will be called frequently.'
  prefs: []
  type: TYPE_NORMAL
- en: Timer metrics measure the time spent on the execution of the delegate provided.
  prefs: []
  type: TYPE_NORMAL
- en: A counter metric increments the value of the counter. If you don’t provide a
    value when calling the `increment` method, as we did in this recipe, it just increments
    by 1\. You can provide a number as a parameter of method increment, at which point
    it will increment the counter value by the number provided. This number should
    always be positive.
  prefs: []
  type: TYPE_NORMAL
- en: There’s more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You can create metrics by using a more declarative approach with `ObservedAspect`
    bean.
  prefs: []
  type: TYPE_NORMAL
- en: 'To add the dependency to the *AOP starter*, include the following in your `pom.xml`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'To configure the `ObserverAspect` bean, add the following method to the `Football``Configuration`
    class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'At this point, you can use the `@Observed` annotation in your code to generate
    metrics automatically. For instance, in this recipe, we could annotate the `AuctionService`
    class with `@Observed`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, you can simplify the class as you don’t need to explicitly create the
    counters in the constructor. In the `addBidAOP` method, you only need to focus
    on the application logic:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'When you run the application and `AuctionService` is used (the metrics are
    created lazily the first time the methods are used), you will see that there are
    two new metrics in the Actuator metrics endpoint:'
  prefs: []
  type: TYPE_NORMAL
- en: '`football.auction`: Provides general counters for the methods defined in your
    annotated class'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`football.auction.active`: Provides counters for active executions for the
    methods defined in your annotated class'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following is a sample of the `football.auction` metric that was obtained
    from `http://localhost:8080/actuator/endpoint/football.auction`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'You can get metrics for a specific method using tags. For instance, to get
    the metrics of the `addBidAOP` method, you can perform the following request:
    `http://localhost:8080/actuator/metrics/football.auction?tag=method:addBidAOP`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'This service is implemented in this book’s GitHub repository at `https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook`,
    in the `chapter3/recipe3-8/end` folder. As mentioned previously, the metric is
    created lazily, so you should invoke this service to make it available. You can
    do this by executing the following `curl` request in your terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: Integrating your application with Prometheus and Grafana
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You have a successful Football Trading application, and you can observe it by
    calling the various Actuator endpoints. However, this way of observing the application
    is too manual. So, you want a system that allows you to automate how your application
    is monitored.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, you will learn how to expose the metrics of your application
    using a format that can be used by **Prometheus**, after which you will use the
    Prometheus data as a source for **Grafana**. Prometheus is an open source monitoring
    solution that collects and aggregates metrics as time series data, then stores
    the events in real time so that the events can be used to monitor your application.
    Grafana is an open source tool for visualization that allows you to create custom
    dashboards, graphs, and even alerts. One of the sources Grafana can use is the
    data collected by Prometheus. The combination of both tools is a very popular
    choice due to its ease of use, flexibility, and scalability.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this recipe, you will reuse the outcome of the *Creating your own metrics*
    recipe. I’ve prepared a working version of this in case you haven’t completed
    it yet. You can find it in this book’s GitHub repository at https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook/,
    in the `chapter3/recipe3-7/start` folder.
  prefs: []
  type: TYPE_NORMAL
- en: You will use Prometheus and Grafana servers. As usual, the easiest way to run
    Prometheus and Grafana on your local computer is by using Docker.
  prefs: []
  type: TYPE_NORMAL
- en: 'To download and start Prometheus, run the following command in your terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: This command uses the `-v` parameter to mount a volume to a file named `prometheus.yml`.
    This file contains the configuration for Prometheus. The configuration will be
    described and created as part of this recipe in the *How to do* *it…* section.
  prefs: []
  type: TYPE_NORMAL
- en: 'To download and start Grafana, run the following command in your terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: To simulate a workload for the new feature, I’ve created a JMeter script. You
    can find it in this book’s GitHub repository, in the `chapter3/recipe3-7/jmeter`
    folder. You can download JMeter from the project’s website at [https://jmeter.apache.org/download_jmeter.cgi](https://jmeter.apache.org/download_jmeter.cgi).
    From here, download a ZIP file containing JMeter binaries and unzip it; no further
    installation is required. To run JMeter, go to the folder where you unzipped the
    binaries, then open the `bin` folder. Here, you will find different scripts to
    launch JMeter, depending on your operating system. For Unix, you can run the `jmeter`
    script, while for Windows, you can run the `jmeter.bat` script.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'First, we’ll configure our application so that it exposes a Prometheus endpoint.
    Afterward, we’ll set up Prometheus and Grafana so that we can ingest the data
    provided by our application:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s start by exposing a Prometheus endpoint to the trading application. For
    that, two steps are necessary:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following dependency to the `pom.xml` file:'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Expose the Prometheus endpoint. To do so, open the `application.yml` file in
    the `resources` folder and add the following highlighted properties:'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: You can run the application and open the Prometheus endpoint at http://localhost:8080/actuator/prometheus.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The next step is running Prometheus and configuring it to consume the newly
    exposed endpoint. You can configure Prometheus by creating a `.yaml` configuration
    file and mounting it on the Prometheus Docker image:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Prometheus will be hosted on Docker, while the application will be hosted on
    your computer, the Docker host. The first task is obtaining the IP address of
    your computer. On Linux, you can run the following command in your Terminal:'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'On Windows, you can run the following command in your terminal:'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: If you run your application in `ip addr show` in a WSL terminal.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: For instance, the IP of my interface is `172.26.109.186` when I run `ip addr
    show`. I will use this value to configure the Prometheus YAML file.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let’s continue by creating the configuration file using the IP address we obtained
    in the previous step. In the project’s root directory, create an application named
    `prometheus.yml` with the following content:'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note that we configured the metrics path exposed by our application, and the
    target is the IP address and port of our application.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, run the Prometheus container using the configuration file. For that, in
    the same directory you created the configuration file, execute the following command
    in your terminal:'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, Prometheus should be working and *scrapping* your application to get observability
    data. To verify it’s working, you can open Prometheus at http://localhost:9090,
    then open the **Status** menu and select **Targets**:![Figure 3.9: Prometheus
    targets](img/B21646_03_9.jpg)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Figure 3.9: Prometheus targets'
  prefs: []
  type: TYPE_NORMAL
- en: Verify that the status of your target is working. It should be **UP**.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use Prometheus to visualize the data from your application. Go to the
    Prometheus home page, search for any metric, and click on **Execute** to see the
    data. If you select the **Graph** tab, you will see the data in graphical form:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 3.10: Visualizing data in Prometheus](img/B21646_03_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.10: Visualizing data in Prometheus'
  prefs: []
  type: TYPE_NORMAL
- en: 'The visualization capabilities that are available in Prometheus are a bit limited,
    but we can use Grafana and connect it to Prometheus to achieve better visualization:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Ensure that Grafana is running. As explained in the *Getting ready* section,
    you can run Grafana using Docker by executing the following command in your terminal:'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, you can open Grafana by opening the following address in your browser:
    `http://localhost:3000`. You will be asked for your credentials. You can use the
    default credentials – that is, user set to `admin` and password set to `admin`.'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Next, you will need to connect Prometheus as a Grafana data source. At this
    point, both containers are running in Docker:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'First, you will need to obtain the Prometheus IP address in Docker. You can
    get this information by inspecting the container. Execute the following commands
    to get the IP address of the container:'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'To retrieve the container ID, run the following command:'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'My container ID was `5affa2883c43`. Replace this with your container ID when
    running the following command:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'My terminal looks like this:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 3.11: Using docker inspect to get the container’s IP address](img/B21646_03_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.11: Using docker inspect to get the container’s IP address'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, open the menu on the left and select **Connections** | **Data sources**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 3.12: Opening Data sources](img/B21646_03_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.12: Opening Data sources'
  prefs: []
  type: TYPE_NORMAL
- en: 'Click `Prometheus` in the search bar:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.13: Selecting Prometheus as a data source](img/B21646_03_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.13: Selecting Prometheus as a data source'
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, configure the `172.17.0.3`, but you likely have another value. The port
    is `9090`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.14: Configuring the Prometheus server URL property](img/B21646_03_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.14: Configuring the Prometheus server URL property'
  prefs: []
  type: TYPE_NORMAL
- en: You can keep the default value for the rest of the parameters. At the bottom
    of the page, you’ll find the **Save & Test** button. Click on it. At this point,
    you can start visualizing data by building a dashboard.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, create a dashboard to visualize the number of pending bids. Go to
    `football_bids_pending`, and then click **Run queries**. Change the time range
    to the last 30 minutes. Finally, click **Save**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 3.15: Configuring a panel](img/B21646_03_15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.15: Configuring a panel'
  prefs: []
  type: TYPE_NORMAL
- en: Now, save your dashboard. Name it `Pending Bids`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Run a load test to see how metrics are visualized in the panel. You can use
    the JMeter script I created to generate some traffic. You can find it in this
    book’s GitHub repository at [https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook/](https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook/),
    in the `chapter3/recipe3-7/jmeter` folder. The Grafana panel should look like
    this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 3.16: Pending bids visualized in Grafana](img/B21646_03_16.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.16: Pending bids visualized in Grafana'
  prefs: []
  type: TYPE_NORMAL
- en: With that, you’ve learned how to visualize your metrics in powerful tools such
    as Grafana.
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Prometheus is an extensible tool that can use exporters. These exporters are
    jobs that run in Prometheus and can get data from external sources if they’re
    exposed using the appropriate format. This recipe’s job scrapes the data, meaning
    that it gets the data from the external source periodically. In this recipe, we
    configured our application to export the data in a format that Prometheus can
    understand, after which we configured a target to retrieve that data.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some of the benefits of using Prometheus are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: It can take metrics from multiple sources – not only applications but also infrastructure
    components.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It allows PromQL to be used, a language for querying and aggregating data. You
    can combine this data from multiple sources to extract relevant information for
    monitoring.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can create alerts based on queries and the thresholds you define. For instance,
    we could use CPU usage thresholds or our pending bids to send an alert.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Grafana can take data from different sources; one of them is Prometheus. This
    combination is very popular for monitoring solutions. Grafana can be used for
    advanced visualizations, and it also allows you to create alerts and send notifications.
    This is very important as it improves the monitoring automation process.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we used these popular open source tools, but the same approach
    can be used with other commercial tools. Usually, monitoring tools manage tracing,
    logging, and metrics, adding capabilities for visualization, such as dashboards
    and alerting by different channels.
  prefs: []
  type: TYPE_NORMAL
- en: An important thing to think about is when you should use traces or metrics for
    monitoring. Traces are very useful in showing the relationship between services
    and finding the specific operations using data from the transaction itself. This
    is very helpful in finding the root cause of an issue. The main issue with traces
    is that in scenarios with a high volume of operations, the amount of data that’s
    generated can be huge, and usually, the traces are sampled so that all the data
    that’s been generated can be processed and the cost can be controlled.
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, the metrics aggregate the measurements, and they just export
    those aggregated measurements periodically to create the time series data. Then,
    the data that’s generated is constant, regardless of the traffic managed by the
    target system. The main advantage of metrics is that they don’t require sampling
    and the data that’s generated is quite precise. For that reason, the metrics are
    more appropriate for certain types of alerts. However, when you need to find the
    root cause of an issue, traces are more appropriate.
  prefs: []
  type: TYPE_NORMAL
- en: Changing the settings of a running application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, you’ve added logging to your successful football trading application,
    and it receives quite a lot of traffic. The program creates logs in different
    places. These logs can help you figure out what the program did while it was running.
    Not every log is equally important. So, the program uses various log levels, ranging
    from debugging to error logs. Sorting logs by their level prevents an excessive
    number of logs from being created. However, you want to ensure you can change
    the minimum level of logs to be processed without restarting or redeploying your
    application.
  prefs: []
  type: TYPE_NORMAL
- en: Some Spring Boot Actuator endpoints allow you to make changes in runtime, with
    no need to restart the application. The logging endpoint is one of those endpoints
    as it allows you to change the minimum level of logging.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, you will learn how to change the logging level of a running
    application.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this recipe, you will reuse the outcome of the *Integrating your application
    with Prometheus and Grafana* recipe. I’ve prepared a working version in case you
    haven’t completed it yet. You can find it in this book’s GitHub repository at
    https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook/, in the `chapter3/recipe3-8/start`
    folder.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this recipe, you’ll adapt the football trading application so that it generates
    logs with different levels of importance. Once you’ve done this you’ll learn how
    to change the level at runtime:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let’s add some logs to the `TradingService` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a logger for the class. You can define a static member for this purpose:'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, add debug and information logging to the `getPendingOrders` method:'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You can also add some logging for the `tradeCards` method:'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, you can perform some requests and validate that the information is being
    logged. You can execute the following command in your terminal to execute a request
    every second:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You will see that only `INFO` and `WARN` logs are processed:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 3.17: Only INFO and WARN logs are processed](img/B21646_03_17.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.17: Only INFO and WARN logs are processed'
  prefs: []
  type: TYPE_NORMAL
- en: This is because the default level is `INFO`. This means that only `INFO` or
    higher priority levels are logged.
  prefs: []
  type: TYPE_NORMAL
- en: You can verify the log level by calling the Actuator `loggers` endpoint. Go
    to http://localhost:8080/actuator/loggers. You will see the available log levels,
    as well as the loggers that are defined in your application. You will see that
    there is a logger for your service class, `com.packt.footballobs.service.TradingService`,
    and that the effective level is `INFO`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let’s say you’ve detected an issue in the application, and you want to activate
    the `DEBUG` level. Let’s change it by using the Actuator `loggers` endpoint. For
    that, you just need to perform the following request:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You will see that it now generates logs for `DEBUG` as well:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 3.18: DEBUG and higher critical logs are generated](img/B21646_03_18.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.18: DEBUG and higher critical logs are generated'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you verify the `loggers` endpoint, as explained in *Step 3*, you will see
    that the `TradingService` class now has two attributes:'
  prefs: []
  type: TYPE_NORMAL
- en: '`configuredLevel`: `DEBUG`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`effectiveLevel`: `DEBUG`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now that you’ve verified the logs, you decide to change the log level to `WARN`
    by running the following command since too much noise is generated by `DEBUG`
    and `INFO` logs:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: If you verify the `loggers` endpoint, as explained in *Step 3*, you will see
    that the `TradingService` level is `WARN`. If you continue making requests, you
    will see that only `WARN` logs are emitted.
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As we saw in the *Creating a custom Actuator endpoint* recipe, some endpoints
    implement update and delete operations. The `loggers` endpoint allows you to change
    the log level. This is a very helpful feature when you need to find issues in
    production as you no longer need to restart your application.
  prefs: []
  type: TYPE_NORMAL
- en: In an application with high traffic, you will usually want to have a high log
    level, such as `WARN`. This is the warning level and is typically used to indicate
    that there is a potential issue or anomaly that should be noted. It signifies
    a situation that may not necessarily be an error, but it could lead to problems
    if it’s not addressed. The reason for using higher log levels, such as `WARN`,
    is that the logs are usually saved by the monitoring system. If the application
    generates too many logs, it requires more resources to process and retain them,
    and that can be costly. At the same time, `DEBUG` and `INFO` logs are not critical
    and they can generate too much information, making it more difficult to find the
    root cause of the problems.
  prefs: []
  type: TYPE_NORMAL
- en: There’s more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Other standard endpoints are part of Spring Boot that allow you to make changes
    at runtime. For instance, the `sessions` endpoint allows you to retrieve and delete
    user sessions.
  prefs: []
  type: TYPE_NORMAL
