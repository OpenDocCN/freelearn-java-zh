- en: JavaServer Faces
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JavaServer Faces
- en: In this chapter, we will cover **JavaServer** **Faces** (**JSF**), the standard
    component framework of the Java EE platform. Java EE 8 includes JSF 2.3, the latest
    version of JSF. JSF relies a lot on convention over configuration—if we follow
    JSF conventions then we don't need to write a lot of configuration. In most cases,
    we don't need to write any configuration at all. This fact, combined with the
    fact that `web.xml` has been optional since Java EE 6, means that, in many cases,
    we can write complete web applications without having to write a single line of
    XML.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍 **JavaServer Faces**（**JSF**），它是 Java EE 平台的标准组件框架。Java EE 8 包含了
    JSF 2.3，这是 JSF 的最新版本。JSF 非常依赖于约定优于配置——如果我们遵循 JSF 的约定，那么我们就不需要编写很多配置。在大多数情况下，我们甚至不需要编写任何配置。这一事实，加上从
    Java EE 6 开始 `web.xml` 是可选的，意味着在许多情况下，我们可以编写完整的 Web 应用程序，而无需编写任何一行 XML。
- en: 'We will cover the following topics in this chapter:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们将涵盖以下主题：
- en: Facelets
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Facelets
- en: JSF project stages
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JSF 项目阶段
- en: Data validation
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据验证
- en: Named beans
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 命名 Bean
- en: Navigation
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 导航
- en: Ajax-enabling JSF applications
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 启用 JSF 应用程序的 Ajax 功能
- en: JSF HTML5 support
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JSF HTML5 支持
- en: Faces flows
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Faces 流
- en: JSF artifact injection
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JSF 艺术品注入
- en: JSF WebSocket support
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JSF WebSocket 支持
- en: JSF component libraries
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JSF 组件库
- en: Introducing JSF
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍 JSF
- en: JSF 2.0 introduced a number of enhancements to make JSF application development
    easier. In the following few sections, we will explore some of these features.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: JSF 2.0 引入了许多增强功能，使 JSF 应用程序开发更加容易。在接下来的几节中，我们将探讨这些功能的一些。
- en: Readers not familiar with earlier versions of JSF may not understand the following
    few sections completely. Not to worry, everything will be perfectly clear by the
    end of this chapter.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 对于不熟悉 JSF 早期版本的读者来说，可能无法完全理解以下几节。不用担心，到本章结束时，一切都会变得非常清晰。
- en: Facelets
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Facelets
- en: One notable difference between modern versions of JSF and earlier versions is
    that Facelets is now the preferred view technology. Earlier versions of JSF used
    **Java Server Pages** (**JSP**) as their default view technology. Since the JSP
    technology predates JSF, sometimes using JSP with JSF felt unnatural or created
    problems. For example, the JSP lifecycle is different from the JSF lifecycle;
    this mismatch introduced some problems for JSF 1.x application developers.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 现代版本的 JSF 与早期版本之间一个显著的差异是，Facelets 现在是首选的视图技术。早期版本的 JSF 使用 **Java Server Pages**（**JSP**）作为其默认的视图技术。由于
    JSP 技术早于 JSF，有时使用 JSP 与 JSF 感觉不自然或造成问题。例如，JSP 生命周期与 JSF 生命周期不同；这种不匹配为 JSF 1.x
    应用程序开发者引入了一些问题。
- en: JSF was designed from the beginning to support multiple view technologies. To
    take advantage of this capability, Jacob Hookom wrote a view technology specifically
    for JSF. He named his view technology **Facelets**. Facelets was so successful
    it became a de-facto standard for JSF. The JSF expert group recognized Facelets'
    popularity and made it the official view technology for JSF in version 2.0 of
    the JSF specification.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: JSF 从一开始就被设计为支持多种视图技术。为了利用这一功能，Jacob Hookom 编写了一种专门针对 JSF 的视图技术。他将自己的视图技术命名为
    **Facelets**。Facelets 非常成功，成为了 JSF 的实际标准。JSF 专家组认识到 Facelets 的流行，并在 JSF 规范的 2.0
    版本中将 Facelets 设为官方视图技术。
- en: Optional faces-config.xml
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可选的 faces-config.xml
- en: Legacy J2EE applications suffered from what some have considered to be excessive
    XML configuration.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 传统的 J2EE 应用程序遭受了一些人认为过度的 XML 配置问题。
- en: Java EE 5 took some measures to reduce XML configuration considerably. Java
    EE 6 reduced the required configuration even further, making the JSF configuration
    file, `faces-config.xml`, optional in JSF 2.0.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: Java EE 5 采取了一些措施来显著减少 XML 配置。Java EE 6 进一步减少了所需的配置，使得 JSF 配置文件 `faces-config.xml`
    在 JSF 2.0 中成为可选的。
- en: In JSF 2.0 and newer versions, JSF managed beans can be configured via the `@ManagedBean`
    annotation, obviating the need to configure them in `faces-config.xml`. Java EE
    6 introduced the **Contexts and Dependency Injection** (**CDI**) API, which provides
    an alternate way of implementing functionality typically implemented with JSF
    managed beans. As of JSF 2.2, CDI named beans are preferred over JSF managed beans;
    JSF 2.3 went even further, deprecating specific JSF-managed beans in favor of
    CDI named beans.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在 JSF 2.0 及更高版本中，可以通过 `@ManagedBean` 注解配置 JSF 管理 Bean，从而无需在 `faces-config.xml`
    中配置它们。Java EE 6 引入了 **上下文和依赖注入**（**CDI**）API，它提供了一种实现通常使用 JSF 管理 Bean 实现的功能的替代方法。截至
    JSF 2.2，CDI 命名 Bean 优于 JSF 管理 Bean；JSF 2.3 更进一步，废弃了特定的 JSF 管理 Bean，转而使用 CDI 命名
    Bean。
- en: 'Additionally, there is a convention for JSF navigation: if the value of the
    action attribute of a JSF 2.0 command link or command button matches the name
    of a facelet (minus the XHTML extension), then by convention, the application
    will navigate to the facelet matching the action name. This convention allows
    us to avoid having to configure application navigation in `faces-config.xml`.'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，JSF导航有一个惯例：如果一个JSF 2.0命令链接或命令按钮的动作属性的值与一个facelet（去掉XHTML扩展名）的名称相匹配，那么按照惯例，应用程序将导航到与动作名称匹配的facelet。这个惯例允许我们避免在
    `faces-config.xml` 中配置应用程序导航。
- en: For many modern JSF applications, `faces-config.xml` is completely unnecessary
    as long as we follow established JSF conventions.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 对于许多现代JSF应用程序，只要我们遵循既定的JSF惯例，`faces-config.xml` 完全没有必要。
- en: Standard resource locations
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 标准资源位置
- en: JSF 2.0 introduced standard resource locations. Resources are artifacts a page
    or JSF component needs to render properly. Resource examples include CSS stylesheets,
    JavaScript files, and images.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: JSF 2.0引入了标准资源位置。资源是页面或JSF组件需要正确渲染的工件。资源示例包括CSS样式表、JavaScript文件和图片。
- en: In JSF 2.0 and newer versions, resources can be placed in a subdirectory under
    a folder called `resources`, either at the root of the WAR file or under its `META-INF`
    directory. By convention, JSF components know they can retrieve resources from
    one of these two locations.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在JSF 2.0及更高版本中，资源可以放置在名为 `resources` 的文件夹下的子目录中，无论是WAR文件的根目录下还是其 `META-INF`
    目录下。按照惯例，JSF组件知道它们可以从这两个位置之一检索资源。
- en: In order to avoid cluttering the `resources` directory, `resources` are typically
    placed in a subdirectory. This subdirectory is referred to from the `library`
    attribute of JSF components.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免使 `resources` 目录杂乱，通常将 `资源` 放置在子目录中。这个子目录由JSF组件的 `library` 属性引用。
- en: For example, we could place a CSS stylesheet called `styles.css` under `/resources/css/styles.css`.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们可以在 `/resources/css/styles.css` 下放置一个名为 `styles.css` 的CSS样式表。
- en: 'In our JSF pages, we could retrieve this CSS file using the `<h:outputStylesheet>`
    tag, as follows:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的JSF页面中，我们可以使用 `<h:outputStylesheet>` 标签检索这个CSS文件，如下所示：
- en: '[PRE0]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The value of the `library` attribute must match the subdirectory where our `stylesheet`
    is located.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '`library` 属性的值必须与我们的 `stylesheet` 所在的子目录相匹配。'
- en: 'Similarly, we could have a JavaScript file under `/resources/scripts/somescript.js`
    and an image under `/resources/images/logo.png`, and we could access these `resources`
    as follows:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，我们可以在 `/resources/scripts/somescript.js` 下放置一个JavaScript文件，在 `/resources/images/logo.png`
    下放置一个图片，并且我们可以按照以下方式访问这些 `资源`：
- en: '[PRE1]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'And:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 以及：
- en: '[PRE2]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Notice that, in each case, the value of the `library` attribute matches the
    corresponding subdirectory name under the `resources` directory, and the value
    of the `name` attribute matches the resource's file name.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在每种情况下，`library` 属性的值与 `resources` 目录下的相应子目录名称相匹配，而 `name` 属性的值与资源的文件名相匹配。
- en: Developing our first JSF application
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开发我们的第一个JSF应用程序
- en: To illustrate basic JSF concepts, we will develop a simple application consisting
    of two Facelet pages and a single CDI named bean.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明基本的JSF概念，我们将开发一个由两个Facelet页面和一个名为CDI的单个命名bean组成的简单应用程序。
- en: Facelets
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Facelets
- en: 'As we mentioned in this chapter''s introduction, the default view technology
    for JSF 2.0 and newer versions is **Facelets**. Facelets need to be written using
    standard XML. The most popular way to develop Facelet pages is to use XHTML in
    conjunction with JSF-specific XML namespaces. The following example shows how
    a typical Facelet page looks:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在本章引言中提到的，JSF 2.0及更高版本的默认视图技术是**Facelets**。Facelets需要使用标准XML编写。开发Facelet页面的最流行方式是结合使用XHTML和JSF特定的XML命名空间。以下示例显示了典型的Facelet页面看起来是什么样子：
- en: '[PRE3]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The following screenshot illustrates how the previous page renders in the browser:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图说明了前一个页面在浏览器中的渲染效果：
- en: '![](img/dcb5841f-5eb1-4f8c-88e1-de9865c95345.png)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![](img/dcb5841f-5eb1-4f8c-88e1-de9865c95345.png)'
- en: The preceding screenshot, of course, was taken after entering some data in every
    text field; originally each text field was blank.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，前面的截图是在每个文本字段输入一些数据之后拍摄的；最初每个文本字段都是空的。
- en: Pretty much any Facelet JSF page will include the two namespaces illustrated
    in the example. The first namespace (``) is for tags that render HTML components;
    by convention, the prefix `h` (for HTML) is used when using this `tag` library.``
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 几乎任何Facelet JSF页面都会包含示例中展示的两个命名空间。第一个命名空间（`h:`）用于渲染HTML组件的标签；按照惯例，当使用这个 `标签`
    库时，使用前缀 `h`（代表HTML）。
- en: The second namespace (``) is the core JSF `tag` library, by convention, the
    prefix `f` (for faces) is used when using this `tag` library.``
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个命名空间（``）是核心JSF `tag`库，按照惯例，当使用这个`tag`库时，前缀`f`（代表faces）被使用。`
- en: The first JSF-specific tags we see in the preceding example are the `<h:head>`
    and `<h:body>` tags. These tags are analogous to the standard HTML `<head>` and
    `<body>` tags, and are rendered as such when the page is displayed in the browser.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，我们首先看到的与JSF相关的标签是`<h:head>`和`<h:body>`标签。这些标签与标准的HTML `<head>`和`<body>`标签类似，当页面在浏览器中显示时，它们会被这样渲染。
- en: The `<h:outputStylesheet>` tag is used to load a CSS stylesheet from a well-known
    location (JSF standardizes the locations of resources, such as CSS stylesheets
    and JavaScript files; this will be discussed in detail later in the chapter).
    The value of the `library` attribute must correspond to the directory where the
    CSS file resides (this directory must be under a `resources` directory). The `name`
    attribute must correspond to the name of the CSS stylesheet we want to load.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '`<h:outputStylesheet>`标签用于从一个已知位置（JSF标准化了资源的位置，如CSS样式表和JavaScript文件；这将在本章后面详细讨论）加载CSS样式表。`library`属性的值必须与CSS文件所在的目录相对应（这个目录必须在`resources`目录下）。`name`属性的值必须与我们要加载的CSS样式表的名称相对应。'
- en: The next tag we see is the `<h:form>` tag. This tag generates an HTML form when
    the page is rendered. As can be seen in the example, there is no need to specify
    an `action` or a `method` attribute for this tag; as a matter of fact, there is
    no `action` or `method` attribute for this tag. The `action` attribute for the
    rendered HTML form will be generated automatically, and the `method` attribute
    will always be `post`. The `id` attribute of `<h:form>` is optional; however,
    it is a good idea to always add it, since it makes debugging JSF applications
    easier.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个我们看到的标签是`<h:form>`标签。当页面渲染时，这个标签会生成一个HTML表单。正如示例所示，不需要为这个标签指定`action`或`method`属性；实际上，这个标签没有`action`或`method`属性。渲染的HTML表单的`action`属性将自动生成，而`method`属性始终是`post`。`<h:form>`的`id`属性是可选的；然而，始终添加它是一个好主意，因为它使得调试JSF应用程序变得更加容易。
- en: The next tag we see is the `<h:messages>` tag. As its name implies, this tag
    is used to display any messages. As we will see shortly, JSF can automatically
    generate validation messages, displayed inside this tag. Additionally, arbitrary
    messages can be added programmatically via the `addMessage()` method defined in
    `javax.faces.context.FacesContext`.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个我们看到的标签是`<h:messages>`标签。正如其名所示，这个标签用于显示任何消息。正如我们很快就会看到的，JSF可以自动生成验证消息，并在该标签内显示。此外，可以通过`javax.faces.context.FacesContext`中定义的`addMessage()`方法以编程方式添加任意消息。
- en: The next JSF tag we see is `<h:panelGrid>`. This tag is roughly equivalent to
    an HTML table, but it works a bit differently. Instead of declaring rows (`<tr>`)
    and cells (`<td>`), the `<h:panelGrid>` tag has a `columns` attribute; the value
    of this attribute indicates the number of columns in the table rendered by this
    tag. As we place components inside this tag, they will be placed in a row until
    the number of columns defined in the `columns` attribute is reached, when the
    next component will be placed in the next row. In the example, the value of the
    columns attribute is `2`, therefore the first two tags will be placed in the first
    row, the next two will be placed in the second row, and so forth.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的JSF标签是`<h:panelGrid>`。这个标签大致相当于HTML表格，但它的工作方式略有不同。不是通过声明行（`<tr>`）和单元格（`<td>`），`<h:panelGrid>`标签有一个`columns`属性；这个属性的值表示由这个标签渲染的表格中的列数。当我们在这个标签内放置组件时，它们将按行放置，直到达到`columns`属性定义的列数，此时下一个组件将被放置在下一行。在示例中，`columns`属性的值是`2`，因此前两个标签将被放置在第一行，接下来的两个将被放置在第二行，以此类推。
- en: 'Another interesting attribute of `<h:panelGrid>` is the `columnClasses` attribute.
    This attribute assigns a CSS class to each column in the rendered table. In the
    example, two CSS classes (separated by a comma) are used as the value for this
    attribute. This has the effect of assigning the first CSS class to the first column,
    and the second one to the second column. Had there been three or more columns,
    the third one would have gotten the first CSS class, the fourth one the second
    one, and so on, alternating between the first one and the second one. To clarify
    how this works, the next code snippet illustrates a portion of the source of the
    HTML markup generated by the preceding page:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '`<h:panelGrid>` 的另一个有趣属性是 `columnClasses` 属性。这个属性为渲染表格中的每一列分配一个 CSS 类。在示例中，使用两个
    CSS 类（用逗号分隔）作为此属性的值。这会产生将第一个 CSS 类分配给第一列，第二个分配给第二列的效果。如果有三列或更多列，第三列将获得第一个 CSS
    类，第四列获得第二个，依此类推，交替进行。为了阐明这是如何工作的，下面的代码片段展示了前面页面生成的 HTML 标记源的一部分：'
- en: '[PRE4]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Notice how each `<td>` tag has an alternating CSS tag—`"rightAlign"` or `"leftAlign"`;
    we achieved this by assigning the value `"rightAlign,leftAlign"` to the `columnClasses`
    attribute of `<h:panelGrid>`. We should note that the CSS classes we are using
    in our example are defined in the CSS stylesheet we loaded via the `<h:outputStylesheet>`
    we discussed earlier. The ID's of the generated markup are a combination of the
    ID we gave to the `<h:form>` component, plus the ID of each individual component.
    Notice that we didn't assign an ID to the `<h:commandButton>` component near the
    end of the page, so the JSF runtime assigned one automatically.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到每个 `<td>` 标签都有一个交替的 CSS 标签——“rightAlign” 或 “leftAlign”；我们通过将值 `"rightAlign,leftAlign"`
    分配给 `<h:panelGrid>` 的 `columnClasses` 属性来实现这一点。我们应该注意，我们在示例中使用的 CSS 类是在我们之前讨论的
    `<h:outputStylesheet>` 加载的 CSS 样式表中定义的。生成的标记的 ID 是我们分配给 `<h:form>` 组件的 ID 以及每个单独组件的
    ID 的组合。注意，我们在页面末尾附近没有为 `<h:commandButton>` 组件分配 ID，因此 JSF 运行时自动分配了一个。
- en: At this point in the example, we start adding components inside `<h:panelGrid>`.
    These components will be rendered inside the table rendered by `<h:panelGrid>`.
    As we mentioned before, the number of columns in the rendered table is defined
    by the `columns` attribute of `<h:panelGrid>`. Therefore, we don't need to worry
    about columns (or rows), we can just start adding components and they will be
    placed in the right place.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在示例的这个阶段，我们开始在 `<h:panelGrid>` 内部添加组件。这些组件将被渲染在由 `<h:panelGrid>` 渲染的表格内。正如我们之前提到的，渲染表格的列数由
    `<h:panelGrid>` 的 `columns` 属性定义。因此，我们不需要担心列（或行），我们只需开始添加组件，它们就会被放置在正确的位置。
- en: The next tag we see is the `<h:outputLabel>` tag. This tag renders as an HTML
    `label` element. Labels are associated with other components via the `for` attribute,
    whose value must match the ID of the component that the label is for.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我们接下来看到的标签是 `<h:outputLabel>` 标签。这个标签渲染为一个 HTML `label` 元素。标签通过 `for` 属性与其他组件关联，其值必须与标签所针对的组件的
    ID 匹配。
- en: Next, we see the `<h:inputText>` tag. This tag generates a text field in the
    rendered page. Its `label` attribute is used for any validation messages; it lets
    the user know what field the message refers to.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们看到 `<h:inputText>` 标签。这个标签在渲染的页面中生成一个文本字段。它的 `label` 属性用于任何验证消息；它让用户知道消息指的是哪个字段。
- en: Although it is not mandatory for the value of the `label` attribute of `<h:inputText>`
    to match the label displayed on the page, it is highly recommended to use this
    value. In case of an error, this will let the user know exactly what field the
    message is referring to.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 `<h:inputText>` 的 `label` 属性的值与页面上显示的标签匹配不是强制性的，但强烈建议使用此值。在出现错误的情况下，这将使用户确切知道消息指的是哪个字段。
- en: 'Of particular interest is the tag''s `value` attribute. What we see as the
    value for this attribute is a **value binding expression**. What this means is
    that this value is tied to a property of one of the application''s named beans.
    In the example, this particular text field is tied to a property called `firstName`
    in a named bean called `customer`. When a user enters a value for this text field
    and submits the form, the corresponding property in the named bean is updated
    with this value. The tag''s `required` attribute is optional; valid values for
    it are `true` and `false`. If this attribute is set to `true`, the container will
    not let the user submit the form until the user enters some data for the text
    field. If the user attempts to submit the form without entering a required value,
    the page will be reloaded and an error message will be displayed inside the `<h:messages>`
    tag:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 特别值得注意的是该标签的`value`属性。我们看到的这个属性的值是一个**值绑定表达式**。这意味着这个值与一个应用命名bean的属性相关联。在示例中，这个特定的文本字段与名为`customer`的命名bean中的`firstName`属性相关联。当用户为这个文本字段输入值并提交表单时，命名bean中相应的属性会更新为这个值。标签的`required`属性是可选的；它的有效值是`true`和`false`。如果这个属性设置为`true`，容器将不允许用户提交表单，直到用户为文本字段输入一些数据。如果用户尝试不输入必需的值提交表单，页面将被重新加载，并在`<h:messages>`标签内显示错误消息：
- en: '![](img/c9b523d5-2144-4efc-8ef1-bfc807dbccae.png)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/c9b523d5-2144-4efc-8ef1-bfc807dbccae.png)'
- en: The preceding screenshot illustrates the default error message shown when the
    user attempts to save the form in the example without entering a value for the
    customer's first name. The first part of the message (First Name) is taken from
    the value of the `label` attribute of the corresponding `<h:inputTextField>` tag.
    The text of the message can be customized, as well as its style (font, color,
    and more.). We will cover how to do this later in the chapter.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图展示了当用户尝试在示例中保存表单而没有输入客户的首名值时显示的默认错误消息。消息的第一部分（First Name）来自相应`<h:inputTextField>`标签的`label`属性值。消息的文本可以自定义，以及其样式（字体、颜色等）。我们将在本章后面介绍如何进行这些操作。
- en: Project stages
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 项目阶段
- en: Having a `<h:messages>` tag on every JSF page is a good idea; without it, the
    user might not see validation messages and will have no idea why the form submission
    is not going through. By default, JSF validation messages do not generate any
    output in the application server log. A common mistake new JSF developers make
    is failing to add a `<h:messages>` tag to their pages; without it, if validation
    fails, then the navigation seems to fail for no reason (the same page is rendered
    if navigation fails and, without a `<h:messages>` tag, no error messages are displayed
    in the browser).
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在每个JSF页面上放置一个`<h:messages>`标签是个好主意；没有它，用户可能看不到验证消息，并且不知道为什么表单提交没有成功。默认情况下，JSF验证消息不会在应用服务器日志中生成任何输出。新JSF开发者常见的错误是未能将`<h:messages>`标签添加到他们的页面上；如果没有它，如果验证失败，则导航似乎没有原因失败（如果导航失败，则渲染同一页面，如果没有`<h:messages>`标签，浏览器中不会显示错误消息）。
- en: To avoid this situation, JSF 2.0 introduced the concept of **project stages**.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免这种情况，JSF 2.0引入了**项目阶段**的概念。
- en: 'The following project stages are defined in JSF 2.0 and newer versions:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在JSF 2.0及更高版本中定义了以下项目阶段：
- en: Production
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 生产
- en: Development
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开发
- en: UnitTest
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单元测试
- en: SystemTest
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 系统测试
- en: We can define the project stage as an initialization parameter to the Faces
    servlet in `web.xml`, or as a custom JNDI resource. The preferred way of setting
    the project stage is through a custom JNDI resource.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将项目阶段定义为`web.xml`中Faces servlet的初始化参数，或者作为一个自定义的JNDI资源。设置项目阶段的首选方式是通过自定义JNDI资源。
- en: The process to map global JNDI resources to component resources is application
    server-specific; when using GlassFish, a change needs to be made to the application's
    `web.xml`, plus we need to use a GlassFish-specific deployment descriptor.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 将全局JNDI资源映射到组件资源的流程是应用服务器特定的；当使用GlassFish时，需要修改应用的`web.xml`文件，并且我们需要使用GlassFish特定的部署描述符。
- en: 'Setting up a custom JNDI resource is application server-specific, consult your
    application server documentation for details. If we are using GlassFish to deploy
    our application, we can set up a custom JNDI by logging in to the web console,
    navigating to JNDI | Custom Resources, then clicking the New... button:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 设置自定义JNDI资源是应用服务器特定的，请查阅您的应用服务器文档以获取详细信息。如果我们使用GlassFish来部署我们的应用，可以通过登录到Web控制台，导航到JNDI
    | 自定义资源，然后点击新建...按钮来设置自定义JNDI：
- en: '![](img/65263f05-a968-490d-b530-ecc2094d67ca.png)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![](img/65263f05-a968-490d-b530-ecc2094d67ca.png)'
- en: 'In the resulting page, we need to enter the following information:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在生成的页面中，我们需要输入以下信息：
- en: '| JNDI Name | `javax.faces.PROJECT_STAGE` |'
  id: totrans-77
  prefs: []
  type: TYPE_TB
  zh: '| JNDI名称 | `javax.faces.PROJECT_STAGE` |'
- en: '| Resource Type | `java.lang.String` |'
  id: totrans-78
  prefs: []
  type: TYPE_TB
  zh: '| 资源类型 | `java.lang.String` |'
- en: 'After entering these two values, the Factory Class field will be automatically
    populated with the value : `org.glassfish.resources.custom.factory.PrimitivesAndStringFactory`.'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 输入这两个值后，工厂类字段将自动填充为值：`org.glassfish.resources.custom.factory.PrimitivesAndStringFactory`。
- en: After entering the values, we need to add a new property with a name of value
    and a value corresponding to the project stage we want to use (Development, in
    the preceding screenshot).
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 输入这些值后，我们需要添加一个名为value的新属性，其值对应于我们想要使用的项目阶段（在先前的屏幕截图中为Development）。
- en: 'Setting the project stage allows us to perform some logic only if we are running
    in a specific stage. For instance, in one of our named beans, we could have code
    that looks like this:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 设置项目阶段允许我们在特定阶段运行时执行一些逻辑。例如，在我们的一个命名bean中，我们可能有如下代码：
- en: '[PRE5]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'As we can see, project stages allow us to modify our code''s behavior for different
    environments. More importantly, setting the project stage allows the JSF engine
    to behave a bit differently based on the project stage setting. Relevant to our
    discussion, setting the project stage to Development results in additional logging
    statements in the application server log. Therefore, if we forget to add a `<h:messages>`
    tag to our page, our project stage is Development, and validation fails; a Validation
    Error will be displayed on the page even if we omit the `<h:messages>` component:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，项目阶段允许我们根据不同的环境修改我们代码的行为。更重要的是，设置项目阶段允许JSF引擎根据项目阶段设置以略有不同的方式运行。与我们的讨论相关，将项目阶段设置为Development会导致在应用程序服务器日志中生成额外的日志语句。因此，如果我们忘记在我们的页面上添加`<h:messages>`标签，我们的项目阶段是Development，验证失败；即使我们省略了`<h:messages>`组件，页面上也会显示验证错误：
- en: '![](img/f5026fc8-5db0-4038-bf35-fc4368d3988b.png)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f5026fc8-5db0-4038-bf35-fc4368d3988b.png)'
- en: In the default `Production` stage, this error message is not displayed in the
    page, leaving us confused as to why our page navigation doesn't seem to be working.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在默认的`Production`阶段，此错误消息不会在页面上显示，这让我们对我们的页面导航似乎不起作用感到困惑。
- en: Validation
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 验证
- en: 'Notice that each `<h:inputField>` tag has a nested `<f:validateLength>` tag.
    As its name implies, this tag validates that the entered value for the text field
    is between a minimum and maximum length. Minimum and maximum values are defined
    by the tag''s `minimum` and `maximum` attributes. `<f:validateLength>` is one
    of the standard validators included with JSF. Just like with the `required` attribute
    of `<h:inputText>`, JSF will automatically display a default error message when
    a user attempts to submit a form with a value that does not validate:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到每个`<h:inputField>`标签都有一个嵌套的`<f:validateLength>`标签。正如其名称所暗示的，此标签验证输入的文本字段值是否在最小和最大长度之间。最小和最大值由标签的`minimum`和`maximum`属性定义。《f:validateLength》是JSF附带的标准验证器之一。就像`<h:inputText>`的`required`属性一样，当用户尝试提交一个值未通过验证的表单时，JSF将自动显示默认错误消息：
- en: '![](img/fbc4ee7f-2ba5-48b7-a7d3-dfa73575cb13.png)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
  zh: '![](img/fbc4ee7f-2ba5-48b7-a7d3-dfa73575cb13.png)'
- en: Again, the default message and style can be overridden; we will cover how to
    do this later in the chapter.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，默认消息和样式可以被覆盖；我们将在本章后面介绍如何做到这一点。
- en: 'In addition to `<f:validateLength>`, JSF includes other standard validators,
    which are listed in the following table:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 除了`<f:validateLength>`之外，JSF还包括其他标准验证器，这些验证器在以下表中列出：
- en: '| **Validation tag** | **Description** |'
  id: totrans-91
  prefs: []
  type: TYPE_TB
  zh: '| **验证标签** | **描述** |'
- en: '| `<f:validateBean>` | Bean validation allows us to validate named `bean` values
    by using annotations in our named beans without having to add validators to our
    JSF tags. This tag allows us to fine-tune bean validation if necessary. |'
  id: totrans-92
  prefs: []
  type: TYPE_TB
  zh: '`<f:validateBean>` | Bean验证允许我们通过在命名`bean`中使用注解来验证命名`bean`的值，而无需向我们的JSF标签添加验证器。此标签允许我们在必要时微调bean验证。
    |'
- en: '| `<f:validateDoubleRange>` | Validates that the input is a valid `Double`
    value between the two values specified by the tag''s `minimum` and `maximum` attributes,
    inclusive. |'
  id: totrans-93
  prefs: []
  type: TYPE_TB
  zh: '| `<f:validateDoubleRange>` | 验证输入是否是有效的`Double`值，该值在标签的`minimum`和`maximum`属性指定的两个值之间，包括这两个值。
    |'
- en: '| `<f:validateLength>` | Validates that the input''s length is between the
    values specified by the tag''s `minimum` and `maximum` values, inclusive. |'
  id: totrans-94
  prefs: []
  type: TYPE_TB
  zh: '| `<f:validateLength>` | 验证输入的长度是否在标签的`minimum`和`maximum`值之间，包括这两个值。 |'
- en: '| `<f:validateLongRange>` | Validates that the input is a valid `Double` value
    between the values specified by the tag''s `minimum` and `maximum` attributes,
    inclusive. |'
  id: totrans-95
  prefs: []
  type: TYPE_TB
  zh: '| `<f:validateLongRange>` | 验证输入是否为在标签的`minimum`和`maximum`属性指定的值之间的有效`Double`值，包括这些值。
    |'
- en: '| `<f:validateRegex>` | Validates that the input matches a regular expression
    pattern specified in the tag''s `pattern` attribute. |'
  id: totrans-96
  prefs: []
  type: TYPE_TB
  zh: '| `<f:validateRegex>` | 验证输入是否与标签的`pattern`属性中指定的正则表达式模式匹配。 |'
- en: '| `<f:validateRequired>` | Validates that the input is not empty. This tag
    is equivalent to setting the `required` attribute to `true` in the parent input
    field. |'
  id: totrans-97
  prefs: []
  type: TYPE_TB
  zh: '| `<f:validateRequired>` | 验证输入是否不为空。此标签等同于在父输入字段中将`required`属性设置为`true`。 |'
- en: Notice that in the description for `<f:validateBean>`, we briefly mentioned
    bean validation. The bean validation JSR aims to standardize JavaBean validation.
    JavaBeans are used across several other APIs that, up until recently, had to implement
    their own validation logic. JSF 2.0 adopted the bean validation standard to help
    validate named bean properties.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在`<f:validateBean>`的描述中，我们简要提到了bean验证。bean验证JSR旨在标准化JavaBean验证。JavaBeans被用于多个其他API中，直到最近，它们必须实现自己的验证逻辑。JSF
    2.0采用了bean验证标准，以帮助验证命名bean属性。
- en: If we want to take advantage of bean validation, all we need to do is annotate
    the desired field with the appropriate bean validation annotation, without having
    to explicitly use a JSF validator.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们要利用bean验证，我们只需要使用适当的bean验证注解注释所需的字段，而无需显式使用JSF验证器。
- en: For a complete list of bean validation annotations, refer to the `javax.validation.constraints`
    package in the Java EE 8 API at [https://javaee.github.io/javaee-spec/javadocs/](https://javaee.github.io/javaee-spec/javadocs/).
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取完整的bean验证注解列表，请参考Java EE 8 API中的`javax.validation.constraints`包，链接为[https://javaee.github.io/javaee-spec/javadocs/](https://javaee.github.io/javaee-spec/javadocs/).
- en: Grouping components
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分组组件
- en: '`<h:panelGroup>` is the next new tag in the example. Typically, `<h:panelGroup>`
    is used to group several components together so that they occupy a single cell
    in an `<h:panelGrid>`. This can be accomplished by adding components inside `<h:panelGroup>`
    and adding `<h:panelGroup>` to `<h:panelGrid>`. As can be seen in the example,
    this particular instance of `<h:panelGroup>` has no child components. In this
    particular case, the purpose of `<h:panelGroup>` is to have an empty cell and
    have the next component, `<h:commandButton>`, align with all other input fields
    in the form.'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '`<h:panelGroup>`是示例中的下一个新标签。通常，`<h:panelGroup>`用于将多个组件组合在一起，以便它们在`<h:panelGrid>`中占据单个单元格。这可以通过在`<h:panelGroup>`内添加组件并将`<h:panelGroup>`添加到`<h:panelGrid>`中来实现。如示例所示，这个特定的`<h:panelGroup>`实例没有子组件。在这种情况下，`<h:panelGroup>`的目的是有空单元格，并使下一个组件`<h:commandButton>`与表单中的所有其他输入字段对齐。'
- en: Form submission
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 表单提交
- en: '`<h:commandButton>` renders an HTML submit button in the browser. Just like
    with standard HTML, its purpose is to submit the form. Its `value` attribute simply
    sets the button''s label. This tag''s `action` attribute is used for navigation;
    the next page to show is based on the value of this attribute. The `action` attribute
    can have a `String` constant or a **method binding expression**, meaning that
    it can point to a `method` in a named bean that returns a string.'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '`<h:commandButton>`在浏览器中渲染一个HTML提交按钮。就像标准HTML一样，它的目的是提交表单。它的`value`属性简单地设置按钮的标签。此标签的`action`属性用于导航；要显示的下一页基于此属性的值。`action`属性可以有一个`String`常量或一个**方法绑定表达式**，这意味着它可以指向一个名为bean中的`method`，该方法返回一个字符串。'
- en: If the base name of a page in our application matches the value of the `action`
    attribute of a `<h:commandButton>` tag, then we navigate to this page when clicking
    the button. This JSF feature frees us from having to define navigation rules,
    like we used to have to do in older versions of JSF. In our example, our confirmation
    page is called `confirmation.xhtml`; therefore by convention, this page will be
    shown when the button is clicked, since the value of its `action` attribute (confirmation)
    matches the base name of the page.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们应用程序中页面的基本名称与`<h:commandButton>`标签的`action`属性值匹配，那么当我们点击按钮时，我们将导航到这个页面。这个JSF特性使我们免于定义导航规则，就像我们在JSF的旧版本中必须做的那样。在我们的示例中，我们的确认页面名为`confirmation.xhtml`；因此，按照惯例，当点击按钮时，将显示此页面，因为其`action`属性的值（confirmation）与页面的基本名称匹配。
- en: Even though the label for the button reads Save, in our simple example, clicking
    on the button won't actually save any data.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 即使按钮的标签显示为保存，在我们的简单示例中，点击按钮实际上并不会保存任何数据。
- en: Named beans
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 命名Bean
- en: 'There are two types of Java Beans that can interact with JSF pages: JSF managed
    beans and CDI named beans. JSF managed beans have been around since the first
    version of the JSF specification and can be used only in a JSF context. CDI named
    beans were introduced in Java EE 6 and can interoperate with other Java EE APIs,
    such as Enterprise JavaBeans. For this reason, CDI named beans are preferred over
    JSF managed beans.'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种Java Bean可以与JSF页面交互：JSF管理Bean和CDI命名Bean。JSF管理Bean自JSF规范的第一版以来就存在了，并且只能在JSF上下文中使用。CDI命名Bean是在Java
    EE 6中引入的，并且可以与其他Java EE API（如企业JavaBeans）交互。因此，CDI命名Bean比JSF管理Bean更受欢迎。
- en: 'To make a Java class a CDI named bean, all we need to do is make sure the class
    has a public, no argument constructor (one is created implicitly if there are
    no other constructors declared, which is the case in our example) and add the
    `@Named` annotation at the class level. Here is the managed bean for our example:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 要使一个Java类成为CDI命名Bean，我们只需要确保该类有一个公共的无参数构造函数（如果没有声明其他构造函数，则会隐式创建一个，正如我们的例子所示），并在类级别添加
    `@Named` 注解。以下是我们的示例中的管理Bean：
- en: '[PRE6]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The `@Named` class annotation designates this bean as a CDI named bean. This
    annotation has an optional `value` attribute we can use to give our bean a logical
    name for use in our JSF pages. However, by convention, the value of this attribute
    is the same as the class name (`Customer`, in our case), with its first character
    switched to lower case. In our example, we let this default behavior take place,
    therefore we access our bean's properties via the `customer` logical name. Notice
    the `value` attribute of any of the input fields in our example page to see this
    logical name in action.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '`@Named` 类注解指定这个Bean是一个CDI命名Bean。这个注解有一个可选的 `value` 属性，我们可以用它给我们的Bean一个用于JSF页面的逻辑名称。然而，按照惯例，这个属性的值与类名（在我们的例子中是
    `Customer`）相同，其第一个字符被转换为小写。在我们的例子中，我们让这个默认行为发生，因此我们通过 `customer` 逻辑名称访问我们的Bean属性。注意，在我们的示例页面中任何输入字段的
    `value` 属性，以查看这个逻辑名称的实际应用。'
- en: Notice that, other than the `@Named` and `@RequestScoped` annotations, there
    is nothing special about this bean. It is a standard JavaBean with private properties
    and corresponding `getter` and `setter` methods. The `@RequestScoped` annotation
    specifies that the bean should live through a single request. The different named
    bean, scopes, available for our JSF applications, are covered in the next section.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，除了 `@Named` 和 `@RequestScoped` 注解之外，这个Bean没有特别之处。它是一个标准的JavaBean，具有私有属性和相应的
    `getter` 和 `setter` 方法。`@RequestScoped` 注解指定Bean应该存在于单个请求中。我们JSF应用程序中可用的不同命名Bean作用域将在下一节中介绍。
- en: Named bean scopes
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 命名Bean作用域
- en: 'Managed beans always have a scope. A managed bean scope defines the lifespan
    of the application. The managed bean scope is defined by a class level annotation.
    The following table lists all valid managed bean scopes:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 管理Bean总是有一个作用域。管理Bean的作用域定义了应用程序的生命周期。管理Bean的作用域由类级别的注解定义。下表列出了所有有效的管理Bean作用域：
- en: '| **Named bean scope annotation** | **Description** |'
  id: totrans-115
  prefs: []
  type: TYPE_TB
  zh: '| **命名Bean作用域注解** | **描述** |'
- en: '| `@ApplicationScoped` | The same instance of application scoped named beans
    is available to all of our application''s clients. If one client modifies the
    value of an application scoped managed bean, the change is reflected across clients.
    |'
  id: totrans-116
  prefs: []
  type: TYPE_TB
  zh: '| `@ApplicationScoped` | 应用程序作用域的命名Bean的同一实例对所有我们的应用程序客户端都是可用的。如果一个客户端修改了应用程序作用域管理Bean的值，则更改将在客户端之间反映出来。|'
- en: '| `@SessionScoped` | An instance of each session scoped named bean is assigned
    to each of our application''s clients. A session-scoped named bean can be used
    to hold client-specific data across requests. |'
  id: totrans-117
  prefs: []
  type: TYPE_TB
  zh: '| `@SessionScoped` | 每个会话作用域的命名Bean实例都被分配给我们的应用程序的每个客户端。会话作用域的命名Bean可以用来在请求之间保持客户端特定的数据。|'
- en: '| `@RequestScoped` | Request scoped named beans only live through a single
    HTTP request. |'
  id: totrans-118
  prefs: []
  type: TYPE_TB
  zh: '| `@RequestScoped` | 请求作用域的命名Bean只存在于单个HTTP请求中。|'
- en: '| `@Dependent` | Dependent scoped named beans are assigned the same scope as
    the bean they are injected to. |'
  id: totrans-119
  prefs: []
  type: TYPE_TB
  zh: '| `@Dependent` | 依赖作用域的命名Bean被分配给它们注入到的Bean相同的范围。|'
- en: '| `@ConversationScoped` | The conversation scope can span multiple requests,
    but is typically shorter than the session scope. |'
  id: totrans-120
  prefs: []
  type: TYPE_TB
  zh: '| `@ConversationScoped` | 会话作用域可以跨越多个请求，但通常比会话作用域短。|'
- en: Navigation
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 导航
- en: As can be seen in our input page, when clicking on the Save button in the `customer_data_entry.xhtml`
    page, our application will navigate to a page called `confirmation.xhtml`. This
    happens because we are taking advantage of JSF's convention over configuration
    feature; if the value of the `action` attribute of a command button or link matches
    the base name of another page, then this navigation takes us to this page.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们的输入页面所示，当在 `customer_data_entry.xhtml` 页面中点击保存按钮时，我们的应用程序将导航到名为 `confirmation.xhtml`
    的页面。这是因为我们正在利用 JSF 的约定优于配置功能；如果命令按钮或链接的 `action` 属性值与另一个页面的基本名称匹配，则此导航将带我们到该页面。
- en: Same page reloading when clicking on a button or link that should navigate to
    another page? When JSF does not recognize the value of the `action` attribute
    of a command button or command link, it will by default navigate to the same page
    that was displayed in the browser when the user clicked on a button or link that
    is meant to navigate to another page.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 点击按钮或链接时是否会导致同一页面的重新加载？当 JSF 未能识别命令按钮或命令链接的 `action` 属性值时，它将默认导航到用户点击按钮或链接时在浏览器中显示的同一页面。该按钮或链接原本是用来导航到另一个页面的。
- en: If navigation does not seem to be working properly, chances are there is a typo
    in the value of this attribute. Remember that, by convention, JSF will look for
    a page whose base name matches the value of the `action` attribute of a command
    button or link.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 如果导航似乎没有正常工作，那么很可能是此属性值的拼写错误。记住，按照惯例，JSF 将寻找一个基本名称与命令按钮或链接的 `action` 属性值匹配的页面。
- en: 'The source for `confirmation.xhtml` looks like this:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '`confirmation.xhtml` 的来源看起来是这样的：'
- en: '[PRE7]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The `<h:outputText>` is the only tag on this page we haven''t covered before.
    This tag simply displays the value of its `value` attribute to the rendered page,
    its `value` attribute can be a simple string or a value binding expression. Since
    the value binding expressions in our `<h:outputText>` tags are the same expressions
    used in the previous page for the `<h:inputText>` tags, their values will correspond
    to the data the user entered:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '`<h:outputText>` 是我们之前没有介绍过的唯一标签。这个标签简单地将其 `value` 属性的值显示到渲染的页面，其 `value` 属性可以是简单的字符串或值绑定表达式。由于我们
    `<h:outputText>` 标签中的值绑定表达式与之前页面中 `<h:inputText>` 标签使用的相同表达式，它们的值将对应于用户输入的数据：'
- en: '![](img/8c8ad334-ff9d-4320-9762-f4a565b8c32c.png)'
  id: totrans-128
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/8c8ad334-ff9d-4320-9762-f4a565b8c32c.png)'
- en: In traditional (that is, non-JSF) Java web applications, we define URL patterns
    to be processed by specific servlets. Specifically for JSF, the suffixes `.jsf`
    or `.faces` are commonly used; another commonly used URL mapping for JSF is the
    `/faces` prefix. Under certain conditions, modern application servers automatically
    add all three mappings to the faces `servlet`, if these conditions are met, we
    don't have to specify any URL mappings at all.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在传统的（即非 JSF）Java web 应用程序中，我们定义 URL 模式以供特定的 servlet 处理。对于 JSF，通常使用 `.jsf` 或
    `.faces` 后缀；另一个常用的 JSF URL 映射是 `/faces` 前缀。在满足某些条件下，现代应用程序服务器会自动将所有三个映射添加到 faces
    `servlet`，如果这些条件得到满足，我们根本不需要指定任何 URL 映射。
- en: 'If any of these conditions are met, then the FacesServlet will be automatically
    mapped:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 如果满足以下任何条件，则 FacesServlet 将自动映射：
- en: There is a `faces-config.xml` file in the `WEB-INF` directory of our web application
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在我们 web 应用程序的 `WEB-INF` 目录中有一个 `faces-config.xml` 文件
- en: There is a `faces-config.xml` file in the `META-INF` directory of one of the
    dependencies of our web application
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在我们 web 应用程序的依赖项之一的 `META-INF` 目录中有一个 `faces-config.xml` 文件
- en: There is a filename ending in `.faces-config.xml` in the `META-INF` directory
    of one of the dependencies of our web application
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在我们 web 应用程序的依赖项之一的 `META-INF` 目录中有一个以 `.faces-config.xml` 结尾的文件名
- en: We declare a context parameter named `javax.faces.CONFIG_FILES` in our `web.xml`
    or a `web-fragment.xml` in one of the dependencies
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们在 `web.xml` 或依赖项中的一个 `web-fragment.xml` 中声明一个名为 `javax.faces.CONFIG_FILES`
    的上下文参数
- en: We pass a non-empty set of classes when invoking the `onStartup()` method of
    `ServletContextInitializer`
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在调用 `ServletContextInitializer` 的 `onStartup()` 方法时，传递一个非空的类集
- en: 'When none of the preceding conditions are met, we need to explicitly map the
    Faces `servlet` in our `web.xml` deployment descriptor, as illustrated here:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 当上述条件都不满足时，我们需要在我们的 `web.xml` 部署描述符中显式映射 Faces `servlet`，如下所示：
- en: '[PRE8]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The URL we used for the pages in our application was the name of our Facelets
    pages, prefixed by `/faces`.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应用中页面的 URL 是我们的 Facelets 页面的名称，前面加上 `/faces` 前缀。
- en: Custom data validation
  id: totrans-139
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自定义数据验证
- en: In addition to providing standard validators for our use, JSF allows us to create
    `custom validator`s. This can be done in one of two ways—by creating a `custom
    validator` class or by adding `validation` methods to our named beans.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 除了提供标准验证器供我们使用外，JSF 允许我们创建 `custom validator`s。这可以通过两种方式之一完成——通过创建一个 `custom
    validator` 类或通过向我们的命名豆中添加 `validation` 方法。
- en: Creating custom validators
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建自定义验证器
- en: In addition to the standard validators, JSF allows us to create custom validators
    by creating a Java class implementing the `javax.faces.validator.Validator` interface.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 除了标准验证器外，JSF 允许我们通过创建一个实现 `javax.faces.validator.Validator` 接口的 Java 类来创建自定义验证器。
- en: 'The following class implements an email validator, which we will use to validate
    the email text input field in our customer data entry screen:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 以下类实现了一个电子邮件验证器，我们将使用它来验证客户数据输入屏幕中的电子邮件文本输入字段：
- en: '[PRE9]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The `@FacesValidator` annotation registers our class as a JSF custom validator
    class. The value of its `value` attribute is the logical name that JSF pages can
    use to refer to it.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '`@FacesValidator` 注解将我们的类注册为 JSF 自定义验证器类。其 `value` 属性的值是 JSF 页面可以用来引用它的逻辑名称。'
- en: As can be seen in the example, the only method we need to implement when implementing
    the Validator interface is a method called `validate()`. This method takes three
    parameters—an instance of `javax.faces.context.FacesContext`, an instance of `javax.faces.component.UIComponent`,
    and an object. Typically, application developers only need to be concerned with
    the last two. The second parameter is the component whose data we are validating,
    the third parameter is the actual value. In the example, we cast `uiComponent`
    to `javax.faces.component.html.HtmlInputText`; this way, we get access to its
    `getLabel()` method, which we can use as part of the error message.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 如示例所示，在实现 Validator 接口时，我们只需要实现一个名为 `validate()` 的方法。该方法接受三个参数——一个 `javax.faces.context.FacesContext`
    实例、一个 `javax.faces.component.UIComponent` 实例和一个对象。通常，应用程序开发者只需关注后两个参数。第二个参数是我们正在验证数据的组件，第三个参数是实际值。在示例中，我们将
    `uiComponent` 强制转换为 `javax.faces.component.html.HtmlInputText`；这样，我们可以访问其 `getLabel()`
    方法，我们可以将其用作错误消息的一部分。
- en: If the entered value is not an invalid email address format, a new instance
    of `javax.faces.application.FacesMessage` is created, passing the error message
    to be displayed in the browser as its `constructor` parameter. We then throw a
    new `javax.faces.validator.ValidatorException`. The error message is then displayed
    in the browser; it gets there behind the scenes via the JSF API.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 如果输入的值不是无效的电子邮件地址格式，则创建一个新的 `javax.faces.application.FacesMessage` 实例，将要在浏览器中显示的错误消息作为其
    `constructor` 参数传递。然后我们抛出一个新的 `javax.faces.validator.ValidatorException`。错误消息随后在浏览器中显示；它通过
    JSF API 在幕后到达。
- en: '**Apache Commons Validator**: Our custom JSF validator uses `Apache Commons
    Validator` to do the actual validation. This library includes many common validations
    such as dates, credit card numbers, ISBN numbers, and emails. When implementing
    a custom validator, it''s worth investigating whether this library already has
    a validator that we can use.'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '**Apache Commons Validator**：我们的自定义 JSF 验证器使用 `Apache Commons Validator` 进行实际验证。这个库包括许多常见的验证，如日期、信用卡号码、ISBN
    号码和电子邮件。在实现自定义验证器时，值得调查这个库是否已经有一个我们可以使用的验证器。'
- en: 'In order to use our validator on our page, we need to use the `<f:validator>`
    JSF tag. The following Facelets page is a modified version of the customer data
    entry screen. This version uses the `<f:validator>` tag to validate email:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在我们的页面上使用我们的验证器，我们需要使用 `<f:validator>` JSF 标签。以下 Facelets 页面是客户数据输入屏幕的修改版本。这个版本使用
    `<f:validator>` 标签来验证电子邮件：
- en: '[PRE10]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'After writing our custom validator and modifying our page to take advantage
    of it, we can see our `validator` in action:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写我们的自定义验证器并修改我们的页面以利用它之后，我们可以看到我们的 `validator` 在行动：
- en: '![](img/af2c0ad7-d199-425b-8d34-e6ca0ba446bc.png)'
  id: totrans-152
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/af2c0ad7-d199-425b-8d34-e6ca0ba446bc.png)'
- en: Validator methods
  id: totrans-153
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 验证器方法
- en: 'Another way we can implement custom validation is by adding `validation` methods
    to one or more of the application''s named beans. The following `Java` class illustrates
    the use of `validator` methods for JSF validation:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以实施自定义验证的另一种方式是通过向应用程序的一个或多个命名豆中添加 `validation` 方法。以下 `Java` 类说明了使用 `validator`
    方法进行 JSF 验证的使用：
- en: '[PRE11]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: In this example, the class contains only the `validator` method, but that does
    not always have to be the case. We can give our `validator` method any name we
    want; however its return value must be `void`, and it must take the three parameters
    illustrated in the example, in that order. In other words, except for the method
    name, the signature of a `validator` method must be identical to the signature
    of the `validate()` method defined in the `javax.faces.validator.Validator` interface.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，该类只包含`validator`方法，但这并不总是必须的。我们可以给我们的`validator`方法起任何我们想要的名称；然而，它的返回值必须是`void`，并且它必须按照示例中所示顺序接受三个参数。换句话说，除了方法名外，验证器方法的签名必须与在`javax.faces.validator.Validator`接口中定义的`validate()`方法的签名相同。
- en: 'As we can see, the body of the preceding `validator` method is nearly identical
    to the body of our `custom validator` class, `validate()` method. We check the
    value entered by the user to make sure it contains only alphabetic characters
    and/or spaces; if it does not, then we throw a `ValidatorException` passing an
    instance of `FacesMessage` containing an appropriate error message `String`: `StringUtils`.'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，前面的`validator`方法体几乎与我们的`custom validator`类中的`validate()`方法体相同。我们检查用户输入的值以确保它只包含字母字符和/或空格；如果不满足，则抛出一个包含适当错误消息`String`的`ValidatorException`：`StringUtils`。
- en: In the example, we used `org.apache.commons.lang3.StringUtils` to perform the
    actual validation logic. In addition to the method used in the example, this class
    contains several methods for verifying that a `String` is numeric or alphanumeric.
    This class, part of the `Apache Commons Lang` library, is very useful when writing
    `custom validators`.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在示例中，我们使用了`org.apache.commons.lang3.StringUtils`来执行实际的验证逻辑。除了示例中使用的方法外，这个类还包含了一些用于验证`String`是否为数字或字母数字的方法。这个类是`Apache
    Commons Lang`库的一部分，在编写自定义验证器时非常有用。
- en: Since every `validator` method must be in a named bean, we need to make sure
    the class containing our `validator` method is annotated with the `@Named` annotation,
    as illustrated in our example.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 由于每个`validator`方法都必须在命名bean中，我们需要确保包含我们的`validator`方法的类被注解了`@Named`注解，正如我们在示例中所展示的那样。
- en: 'The last thing we need to do to use our `validator` method is to bind it to
    our component via the tag''s `validator` attribute:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要做的最后一件事是将我们的`validator`方法绑定到我们的组件，通过标签的`validator`属性：
- en: '[PRE12]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Since neither the first name nor the last name fields should accept anything
    other than alphabetic characters or spaces, we added our custom validator method
    to both of these fields.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 由于“姓氏”和“名字”字段都不应接受除字母字符和空格之外的内容，我们已将我们的自定义验证器方法添加到这两个字段。
- en: Notice that the value of the `validator` attribute of the `<h:inputText>` tag
    is a JSF expression language; it uses the default named bean name for the bean
    containing our `validation` method. `alphaValidator` is the name of our bean,
    and `validateAlpha` is the name of our `validator` method.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到`<h:inputText>`标签的`validator`属性的值是一个JSF表达式语言；它使用包含我们的`validation`方法的bean的默认命名bean名称。`alphaValidator`是我们bean的名称，而`validateAlpha`是我们`validator`方法的名称。
- en: 'After modifying our page to use our `custom validator`, we can now see it in
    action:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在修改我们的页面以使用我们的`custom validator`之后，我们现在可以看到它的实际应用：
- en: '![](img/d965e629-306a-42b9-80da-0ab5d7db9792.png)'
  id: totrans-165
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/d965e629-306a-42b9-80da-0ab5d7db9792.png)'
- en: Notice how, for the First Name field, both our custom validator message and
    the standard length validator were executed.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到对于“姓氏”字段，我们的自定义验证消息和标准的长度验证器都已被执行。
- en: Implementing `validator` methods have the advantage of not having the overhead
    of creating a whole class just for a single `validator` method (our example does
    just that, but in many cases, `validator` methods are added to an existing named
    bean containing other methods); however, the disadvantage is that each component
    can only be validated by a single `validator` method. When using `validator` classes,
    several `<f:validator>` tags can be nested inside the tag to be validated, therefore
    multiple validations, both custom and standard, can be done on the field.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 实现验证器方法的优势是无需创建一个仅用于单个`validator`方法的整个类（我们的示例就是这样做的，但在许多情况下，验证器方法被添加到包含其他方法的现有命名bean中）；然而，缺点是每个组件只能由单个验证器方法进行验证。当使用验证器类时，可以在要验证的标签内部嵌套多个`<f:validator>`标签，因此可以在字段上执行多个验证，包括自定义和标准验证。
- en: Customizing JSF's default messages
  id: totrans-168
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自定义JSF的默认消息
- en: Like we mentioned earlier, it is possible to customize the style (font, color,
    text, and so on) of JSF's default validation messages. Additionally, it is possible
    to modify the text of default JSF validation messages. In the following sections,
    we will explain how to modify error message formatting and text.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前提到的，可以自定义JSF默认验证消息的样式（字体、颜色、文本等）。此外，还可以修改默认JSF验证消息的文本。在接下来的章节中，我们将解释如何修改错误消息的格式和文本。
- en: Customizing message styles
  id: totrans-170
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自定义消息样式
- en: Customizing message styles can be done via **Cascading Style Sheets** (**CSS**).
    This can be accomplished by using the `<h:message>`, `style`, or `styleClass`
    attributes. The `style` attribute is used when we want to declare the CSS style
    inline. The `styleClass` attribute is used when we want to use a predefined style
    in a CSS style sheet or inside a `<style>` tag in our page.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过**层叠样式表**（**CSS**）来自定义消息样式。这可以通过使用`<h:message>`、`style`或`styleClass`属性来实现。当我们要声明内联CSS样式时，使用`style`属性。当我们要在CSS样式表中或在我们页面的`<style>`标签中使用预定义样式时，使用`styleClass`属性。
- en: 'The following markup illustrates using the `styleClass` attribute to alter
    the style of error messages; it is a modified version of the input page we saw
    in the previous section:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的标记示例展示了如何使用`styleClass`属性来改变错误消息的样式；这是我们在上一节中看到的输入页面的一个修改版本：
- en: '[PRE13]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The only difference between this page and the previous one is the use of the
    `styleClass` attribute of the `<h:messages>` tag. As we mentioned earlier, the
    value of the `styleClass` attribute must match the name of a CSS style defined
    in a cascading stylesheet that our page has access to.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 与前一页相比，唯一的区别是使用了`<h:messages>`标签的`styleClass`属性。正如我们之前提到的，`styleClass`属性的值必须与我们在级联样式表中定义的CSS样式的名称匹配。
- en: 'In our case, we defined a CSS style for messages as follows:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的案例中，我们为消息定义了如下CSS样式：
- en: '[PRE14]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Then we used this style as the value of the `styleClass` attribute of our `<h:messages>`
    tag.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们将这个样式用作我们`<h:messages>`标签的`styleClass`属性的值。
- en: 'The following screenshot illustrates how the validation error messages look
    after implementing this change:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的截图展示了实施此更改后验证错误消息的外观：
- en: '![](img/2f7df965-7cf7-4f95-8a8e-5cd220649e66.png)'
  id: totrans-179
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/2f7df965-7cf7-4f95-8a8e-5cd220649e66.png)'
- en: In this particular case, we just set the color of the error message text to
    red, but we are only limited only by CSS capabilities in setting the style of
    the error messages.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个特定案例中，我们只是将错误消息文本的颜色设置为红色，但我们仅限于CSS的能力来设置错误消息的样式。
- en: Pretty much any standard JSF component has both a `style` and a `styleClass`
    attribute that can be used to alter its style. The former is used for predefined
    CSS styles, the latter is used for inline CSS.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 几乎任何标准的JSF组件都同时具有`style`和`styleClass`属性，可以用来改变其样式。前者用于预定义的CSS样式，后者用于内联CSS。
- en: Customizing message text
  id: totrans-182
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自定义消息文本
- en: 'Sometimes it is desirable to override the text of JSF''s default validation
    errors. Default validation errors are defined in a resource bundle called `Messages.properties`.
    This file can typically be found inside one of the JSF JAR Files included with
    your application server. For example, GlassFish includes it inside a JAR file
    called `javax.faces.jar` file under `[glassfish installation directory]/glassfish/modules`.
    The file contains several messages; we are only interested in validation errors
    at this point. The default validation error messages are defined as follows:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 有时可能需要覆盖JSF默认验证错误的文本。默认验证错误定义在名为`Messages.properties`的资源包中。这个文件通常可以在应用程序服务器的JSF
    JAR文件中找到。例如，GlassFish将其包含在`[glassfish安装目录]/glassfish/modules`下的`javax.faces.jar`文件中。该文件包含多个消息；目前我们只对验证错误感兴趣。默认验证错误消息定义如下：
- en: '[PRE15]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'In order to override the default error messages, we need to create our own
    resource bundle, using the same keys used in the default one, but altering the
    values to suit our needs. Here is a very simple customized resource bundle for
    our application. For example, to overwrite the message for minimum length validation,
    we would add the following property to our custom resource bundle:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 为了覆盖默认的错误消息，我们需要创建自己的资源包，使用与默认资源包相同的键，但修改值以适应我们的需求。以下是我们应用程序的一个非常简单的自定义资源包示例。例如，要覆盖最小长度验证的消息，我们将在我们的自定义资源包中添加以下属性：
- en: '[PRE16]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'In this resource bundle, we override the error message for when the value entered
    for a field validated by the `<f:validateLength>` tag is less than the allowed
    minimum. In order to let our application know that we have a custom resource bundle
    for message properties, we need to modify the application''s `faces-config.xml`
    file:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个资源包中，我们覆盖了当使用 `<f:validateLength>` 标签验证的字段输入值小于允许的最小值时的错误信息。为了让我们的应用程序知道我们有一个自定义的资源包用于消息属性，我们需要修改应用程序的
    `faces-config.xml` 文件：
- en: '[PRE17]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: As we can see, the only thing we need to do to the application's `faces-config.xml`
    file is to add a `<message-bundle>` element indicating the name and location of
    the resource bundle containing our custom messages.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，我们只需要对应用程序的 `faces-config.xml` 文件进行修改，添加一个 `<message-bundle>` 元素，指定包含我们的自定义消息的资源包的名称和位置。
- en: Custom error message text definitions are one of the few cases where we still
    need to define a `faces-config.xml` file for modern JSF applications. However,
    notice how simple our `faces-config.xml` file is, a far cry from a typical `faces-config.xml`
    for JSF 1.x, which typically contains named bean definitions, navigation rules,
    and JSF validator definitions.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 自定义错误消息文本定义是我们仍然需要为现代 JSF 应用程序定义 `faces-config.xml` 文件的不多几个情况之一。然而，请注意我们的 `faces-config.xml`
    文件是多么简单，与典型的 JSF 1.x 的 `faces-config.xml` 相去甚远，后者通常包含命名 Bean 定义、导航规则和 JSF 验证器定义。
- en: After adding our custom message resource bundle and modifying the application's
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 在添加我们的自定义消息资源包并修改应用程序的
- en: '`faces-config.xml` file, we can see our custom validation message in action:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '`faces-config.xml` 文件后，我们可以看到我们的自定义验证消息在实际中的应用：'
- en: '![](img/563474d0-7122-4845-a9e0-7f4eccceb068.png)'
  id: totrans-193
  prefs: []
  type: TYPE_IMG
  zh: '![](img/563474d0-7122-4845-a9e0-7f4eccceb068.png)'
- en: As can be seen in the screenshot, if we haven't overridden a validation message,
    the default will still be displayed. In our resource bundle we only overrode the
    minimum length validation error message, therefore our custom error message is
    shown in the First Name text field. Since we didn't override the error message
    in the other standard JSF validators, the default error message is shown for each
    one of them. The email validator is the custom validator we developed previously
    in this chapter; since it is a custom validator, its error message is not affected.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 如截图所示，如果我们没有覆盖验证消息，默认消息仍然会显示。在我们的资源包中，我们只覆盖了最小长度验证错误消息，因此我们的自定义错误消息显示在“姓氏”文本字段中。由于我们没有在其他标准
    JSF 验证器中覆盖错误消息，因此每个验证器都会显示默认错误消息。电子邮件验证器是我们在本章中之前开发的自定义验证器；由于它是一个自定义验证器，其错误消息不受影响。
- en: Ajax-enabling JSF applications
  id: totrans-195
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 启用 Ajax 的 JSF 应用程序
- en: JSF allows us to easily implement **Ajax** (**Asynchronous JavaScript and XML**)
    functionality into our web applications by simply employing the `<f:ajax>` tag
    and CDI named beans, without needing to implement any JavaScript code or having
    to parse JSON strings to implement Ajax with JSF.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: JSF 允许我们通过简单地使用 `<f:ajax>` 标签和 CDI 命名 Bean，轻松地将 **Ajax**（**异步 JavaScript 和 XML**）功能实现到我们的
    Web 应用程序中，无需实现任何 JavaScript 代码或解析 JSON 字符串来实现带有 JSF 的 Ajax。
- en: 'The following illustrates a typical usage of the `<f:ajax>` tag:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 下图展示了 `<f:ajax>` 标签的典型用法：
- en: '[PRE18]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'After deploying our application, the preceding page renders as illustrated
    in the following screenshot:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 在部署我们的应用程序后，前一页渲染的结果如下截图所示：
- en: '![](img/ba04663c-2313-471b-9b86-7d2275a284f7.png)'
  id: totrans-200
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ba04663c-2313-471b-9b86-7d2275a284f7.png)'
- en: The preceding page illustrates two uses of the `<f:ajax>` tag. At the top of
    the page, we use this tag by implementing a typical Ajax Echo example, in which
    we have a `<h:outputText>` component updating itself with the value of an input
    text component. Whenever any character is entered into the input field, the value
    of the `<h:outputText>` component is automatically updated.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 前一页展示了 `<f:ajax>` 标签的两个用法。在页面顶部，我们通过实现一个典型的 Ajax Echo 示例来使用这个标签，其中有一个 `<h:outputText>`
    组件使用输入文本组件的值来更新自己。每当输入字段中输入任何字符时，`<h:outputText>` 组件的值会自动更新。
- en: To implement the functionality described in the previous paragraph, we put an
    `<f:ajax>` tag inside an `<h:inputText>` tag. The value of the `render` attribute
    of the `<f:ajax>` tag must correspond to the ID of a component we want to update
    after the Ajax request finishes. In our particular example, we want to update
    the `<h:outputText>` component with an ID of `textVal`, therefore this is the
    value we use for the render attribute of our `<f:ajax>` tag.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 要实现前一段描述的功能，我们在 `<h:inputText>` 标签内放置一个 `<f:ajax>` 标签。`<f:ajax>` 标签的 `render`
    属性值必须对应于在 Ajax 请求完成后希望更新的组件的 ID。在我们的特定示例中，我们希望更新 ID 为 `textVal` 的 `<h:outputText>`
    组件，因此这是我们 `<f:ajax>` 标签的 `render` 属性的值。
- en: In some cases we may need to render more than one JSF component after an Ajax
    event finishes. In order to accommodate this, we can add several IDs as the value
    of the `render` attribute, we simply need to separate them by spaces.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，我们可能需要在 Ajax 事件完成后渲染多个 JSF 组件。为了适应这种情况，我们可以将多个 ID 作为 `render` 属性的值，我们只需用空格将它们分开即可。
- en: The other `<f:ajax>` attribute we used in this instance is the `event` attribute.
    This attribute indicates the JavaScript event that triggers the Ajax event. In
    this particular case we need to trigger the event any time a key is released while
    a user is typing into the input field; therefore the appropriate event is to use
    is `keyup`.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 在此实例中，我们使用的其他 `<f:ajax>` 属性是 `event` 属性。此属性指示触发 Ajax 事件的 JavaScript 事件。在这种情况下，我们需要在用户在输入字段中输入时释放任何键时触发事件；因此，适当的事件是使用
    `keyup`。
- en: 'The following table lists all supported JavaScript events:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 以下表格列出了所有支持的 JavaScript 事件：
- en: '| **Event** | **Description** |'
  id: totrans-206
  prefs: []
  type: TYPE_TB
  zh: '| **事件** | **描述** |'
- en: '| `blur` | The component loses focus. |'
  id: totrans-207
  prefs: []
  type: TYPE_TB
  zh: '| `blur` | 组件失去焦点。|'
- en: '| `change` | The component loses focus and its value has been modified. |'
  id: totrans-208
  prefs: []
  type: TYPE_TB
  zh: '| `change` | 组件失去焦点且其值已被修改。|'
- en: '| `click` | The component is clicked on. |'
  id: totrans-209
  prefs: []
  type: TYPE_TB
  zh: '| `click` | 组件被点击。|'
- en: '| `dblclick` | The component is double-clicked on. |'
  id: totrans-210
  prefs: []
  type: TYPE_TB
  zh: '| `dblclick` | 组件被双击。|'
- en: '| `focus` | The component gains focus. |'
  id: totrans-211
  prefs: []
  type: TYPE_TB
  zh: '| `focus` | 组件获得焦点。|'
- en: '| `keydown` | A key is pressed while the component has focus. |'
  id: totrans-212
  prefs: []
  type: TYPE_TB
  zh: '| `keydown` | 当组件获得焦点时，按键被按下。|'
- en: '| `keypress` | A key is pressed or held down while the component has focus.
    |'
  id: totrans-213
  prefs: []
  type: TYPE_TB
  zh: '| `keypress` | 当组件获得焦点时，按键被按下或保持按下状态。|'
- en: '| `keyup` | A key is released while the component has focus. |'
  id: totrans-214
  prefs: []
  type: TYPE_TB
  zh: '| `keyup` | 当组件获得焦点时，按键被释放。|'
- en: '| `mousedown` | Mouse button is pressed while the component has focus. |'
  id: totrans-215
  prefs: []
  type: TYPE_TB
  zh: '| `mousedown` | 当组件获得焦点时，鼠标按钮被按下。|'
- en: '| `mousemove` | Mouse pointer is moved over the component. |'
  id: totrans-216
  prefs: []
  type: TYPE_TB
  zh: '| `mousemove` | 鼠标指针在组件上移动。|'
- en: '| `mouseout` | Mouse pointer leaves the component. |'
  id: totrans-217
  prefs: []
  type: TYPE_TB
  zh: '| `mouseout` | 鼠标指针离开组件。|'
- en: '| `mouseover` | Mouse pointer is placed over the component. |'
  id: totrans-218
  prefs: []
  type: TYPE_TB
  zh: '| `mouseover` | 鼠标指针放置在组件上。|'
- en: '| `mouseup` | Mouse button is released while the component has focus. |'
  id: totrans-219
  prefs: []
  type: TYPE_TB
  zh: '| `mouseup` | 当组件获得焦点时，鼠标按钮被释放。|'
- en: '| `select` | The component''s text is selected. |'
  id: totrans-220
  prefs: []
  type: TYPE_TB
  zh: '| `select` | 组件文本被选中。|'
- en: '| `valueChange` | Equivalent to change; the component loses focus and its value
    has been modified. |'
  id: totrans-221
  prefs: []
  type: TYPE_TB
  zh: '| `valueChange` | 等同于 change；组件失去焦点且其值已被修改。|'
- en: We use `<f:ajax>` once again further down in the page, to Ajax-enable a command
    button component. In this instance, we want to recalculate a value based on the
    value of two input components. In order to have the values on the server updated
    with the latest user input, we used the `execute` attribute of `<f:ajax>`; this
    attribute takes a space-separated list of component IDs for use as input. We then
    use the `render` attribute just like before to specify which components need to
    be re-rendered after the Ajax request finishes.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 在页面下方再次使用 `<f:ajax>`，以使命令按钮组件启用 Ajax。在这种情况下，我们希望根据两个输入组件的值重新计算一个值。为了使服务器上的值更新为最新的用户输入，我们使用了
    `<f:ajax>` 的 `execute` 属性；此属性接受一个空格分隔的组件 ID 列表，用作输入。然后，我们像之前一样使用 `render` 属性来指定在
    Ajax 请求完成后需要重新渲染的组件。
- en: Notice we are using the `actionListener` attribute of `<h:commandButton>`. This
    attribute is typically used whenever we don't need to navigate to another page
    after clicking the button. The value for this attribute is an `action listener`
    method we wrote in one of our named beans. `Action listener` methods must return
    `void`, and take an instance of `javax.faces.event.ActionEvent` as its sole parameter.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我们正在使用 `<h:commandButton>` 的 `actionListener` 属性。此属性通常在我们点击按钮后不需要导航到另一个页面时使用。此属性的值是我们在一个命名豆中编写的
    `action listener` 方法。`Action listener` 方法必须返回 `void`，并接受一个 `javax.faces.event.ActionEvent`
    实例作为其唯一参数。
- en: 'The named bean for our application looks like this:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应用程序的命名bean看起来像这样：
- en: '[PRE19]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Notice that we didn't have to do anything special in our named bean to enable
    Ajax in our application. It is all controlled by the `<f:ajax>` tag on the page.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们不需要在我们的命名bean中做任何特殊的事情来在我们的应用程序中启用Ajax。所有这些都由页面上的`<f:ajax>`标签控制。
- en: As we can see from this example, Ajax-enabling JSF applications is very simple;
    we simply need to use a single tag to Ajax-enable our page, without having to
    write a single line of JavaScript, JSON, or XML.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 从这个例子中我们可以看出，启用Ajax的JSF应用程序非常简单；我们只需使用一个标签就可以将页面Ajax化，无需编写任何JavaScript、JSON或XML代码。
- en: JSF HTML5 support
  id: totrans-228
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JSF HTML5支持
- en: HTML5 is the latest version of the HTML specification and includes several improvements
    over the previous version of HTML. Modern versions of JSF include several features
    to make JSF pages work nicely with HTML5.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: HTML5是HTML规范的最新版本，并在之前版本的HTML上包含了一些改进。JSF的现代版本包括几个特性，使得JSF页面能够很好地与HTML5协同工作。
- en: HTML5-friendly markup
  id: totrans-230
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: HTML5友好标记
- en: 'Through the use of pass-through elements, we can develop our pages using HTML5
    and also treat them as JSF components. To do this, we need to specify at least
    one element attributes using [http://xmlns.jcp.org/jsf namespace](http://xmlns.jcp.org/jsf%20namespace).
    The following example demonstrates this approach in action:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用透传元素，我们可以使用HTML5开发页面，并将它们视为JSF组件。为此，我们需要指定至少一个元素属性使用[http://xmlns.jcp.org/jsf命名空间](http://xmlns.jcp.org/jsf%20namespace)。以下示例展示了这种方法在实际中的应用：
- en: '[PRE20]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The first thing we should notice about the preceding example is the XML namespace
    prefixed by `jsf` near the top of the page. This namespace allows us to add JSF-specific
    attributes to HTML5 pages. When the JSF runtime encounters attributes prefixed
    by `jsf` in any of the tags on the page, it automatically converts the HTML5 tag
    to the equivalent JSF component. JSF-specific attributes are the same as in regular
    JSF pages, except they are prefixed with `jsf` therefore, at this point, they
    should be self-explanatory and will not be discussed in detail.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先应该注意的关于前面例子的是，在页面顶部附近带有`jsf`前缀的XML命名空间。这个命名空间允许我们在HTML5页面上添加JSF特定的属性。当JSF运行时遇到页面任何标签上以`jsf`为前缀的属性时，它会自动将HTML5标签转换为等效的JSF组件。JSF特定的属性与常规JSF页面中的属性相同，只是它们以`jsf`为前缀，因此，在这个阶段，它们应该是自解释的，不会详细讨论。
- en: The preceding example will render and behave just like the first example in
    this chapter.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的例子将渲染和表现就像本章中的第一个例子一样。
- en: The technique described in this section is useful if we have experienced HTML
    web designers in our team who prefer to have full control over the look of the
    page. The pages are developed using standard HTML5 with JSF-specific attributes
    so that the JSF runtime can manage user input.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 本节中描述的技术如果我们的团队中有经验丰富的HTML网页设计师，他们更喜欢对页面外观有完全控制权时非常有用。这些页面使用标准的HTML5和JSF特定的属性来开发，以便JSF运行时可以管理用户输入。
- en: If our team consists primarily of Java developers with limited CSS/HTML knowledge,
    then it is preferable to develop the web pages for our web application using JSF
    components. HTML5 introduced several new attributes that didn't exist in previous
    versions of HTML. For this reason, JSF 2.2 introduced the ability to add arbitrary
    attributes to JSF components; this JSF/HTML5 integration technique is discussed
    in the next section.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们的团队主要由有限的CSS/HTML知识的Java开发者组成，那么最好使用JSF组件来开发我们的Web应用程序的Web页面。HTML5引入了几个在之前HTML版本中不存在的属性。因此，JSF
    2.2引入了向JSF组件添加任意属性的能力；这种JSF/HTML5集成技术将在下一节中讨论。
- en: Pass-through attributes
  id: totrans-237
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 透传属性
- en: 'JSF allows the definition of any arbitrary attributes (not processed by the
    JSF engine); these attributes are simply rendered as-is on the generated HTML
    displayed in the browser. The following example is a new version of an earlier
    example in this chapter, modified to take advantage of the HTML5 pass-through
    attributes:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: JSF允许定义任何任意属性（不被JSF引擎处理）；这些属性在浏览器中显示的生成的HTML上简单地以原样渲染。以下示例是本章早期示例的新版本，修改后以利用HTML5透传属性：
- en: '[PRE21]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The first thing we should notice about this example is the addition of the `http://xmlns.jcp.org/jsf/passthrough">http://xmlns.jcp.org/jsf/passthrough`
    namespace, which allows us to add any arbitrary attributes to our JSF components.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先应该注意的关于这个例子的是添加了`http://xmlns.jcp.org/jsf/passthrough`命名空间，这允许我们向我们的JSF组件添加任何任意属性。
- en: In our example, we added the HTML5 `placeholder` attribute to all input text
    fields in our page; as we can see, we need it to be prefixed by the defined prefix
    for the namespace at the top of the application (`p`, in our case). The placeholder
    HTML attribute simply adds some placeholder text to input fields that are automatically
    deleted once the user starts typing on the input field (this technique was commonly
    implemented *by hand* using JavaScript before HTML5).
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的例子中，我们在页面上所有的输入文本字段中添加了HTML5的`placeholder`属性；正如我们所看到的，它需要以应用顶部定义的命名空间的前缀（在我们的例子中是`p`）为前缀。`placeholder`
    HTML属性简单地为输入字段添加一些占位文本，一旦用户开始在输入字段中输入，这些文本就会自动删除（在HTML5之前，这种技术通常通过JavaScript手动实现）。
- en: 'The following screenshot shows our updated page in action:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了我们的更新页面在实际操作中的效果：
- en: '![](img/58586e76-7ec8-4a30-b922-80a65636d3d7.png)'
  id: totrans-243
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/58586e76-7ec8-4a30-b922-80a65636d3d7.png)'
- en: JSF 2.2 Faces flows
  id: totrans-244
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JSF 2.2 Faces flows
- en: JSF 2.2 introduced Faces flows, which defines a scope that can span several
    pages. Flow scoped beans are created when the user enters a flow (a set of web
    pages), and are destroyed when the user leaves the flow.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: JSF 2.2引入了Faces flows，它定义了一个可以跨越多个页面的作用域。当用户进入流程（一组网页）时创建流作用域的bean，当用户离开流程时销毁。
- en: 'Faces flows adopts the convention over configuration principle of JSF. The
    following conventions are typically used when developing applications employing
    faces flows:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: Faces flows遵循JSF的约定优于配置原则。在开发使用faces flows的应用程序时，通常使用以下约定：
- en: All pages in the flow must be placed in a directory whose name defines the name
    of the flow
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 流程中的所有页面都必须放置在一个以流程名称命名的目录中。
- en: An XML configuration file named after the directory name, and suffixed with
    -flow, must exist inside the directory that contains the pages in the flow (the
    file may be empty, but it must exist)
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 必须在包含流程页面的目录内存在一个以目录名称命名并后缀为-flow的XML配置文件（文件可能为空，但必须存在）。
- en: The first page in the flow must be named after the directory name that contains
    the flow
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 流程中的第一个页面必须以包含流程的目录名称命名。
- en: The last page in the flow must not be located inside the directory containing
    the flow and must be named after the directory name and suffixed with -return
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 流程中的最后一个页面不能位于包含流程的目录内，并且必须以目录名称命名，后缀为-return。
- en: 'The following screenshot illustrates these conventions:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图说明了这些约定：
- en: '![](img/625ea753-8c0a-4de8-b33c-f1c06d98b2b3.png)'
  id: totrans-252
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/625ea753-8c0a-4de8-b33c-f1c06d98b2b3.png)'
- en: In the preceding example, we define a flow named `customerinfo`; by convention,
    these files are inside a directory named `customerinfo`, and the first page on
    the flow is named `customerinfo.xhtml` (there are no restrictions on the names
    of other pages in the flow). When we exit the flow, we navigate to a page named
    `flowname-return.xml`; in our case, since our flow is named `customerinfo`, the
    name of the page in question is `customerinfo-return.xhtml`, which follows the
    naming convention and takes us out of the flow.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们定义了一个名为`customerinfo`的流程；按照惯例，这些文件位于名为`customerinfo`的目录中，流程的第一个页面命名为`customerinfo.xhtml`（流程中其他页面的名称没有限制）。当我们退出流程时，我们将导航到一个名为`flowname-return.xml`的页面；在我们的例子中，由于我们的流程名为`customerinfo`，所以相关页面的名称是`customerinfo-return.xhtml`，它遵循命名约定并使我们退出流程。
- en: The markup for the pages doesn't illustrate anything we haven't seen before;
    therefore we will not show it. All example code is available as part of this book's
    code download bundle.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 页面的标记没有展示我们之前没有见过的内容；因此，我们不会展示它。所有示例代码都作为本书代码下载包的一部分提供。
- en: 'All of the previous pages store data in a named bean called `Customer`, which
    has a flow of scope:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 所有的前一个页面都将数据存储在一个名为`Customer`的命名bean中，它具有流程作用域。
- en: '[PRE22]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The `@FlowScoped` annotation has a value attribute that must match the name
    of the flow that the bean is meant to work with (`customerinfo`, in this example).
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: '`@FlowScoped`注解有一个值属性，它必须与bean打算与之一起工作的流程的名称匹配（在这个例子中是`customerinfo`）。'
- en: This example creates a wizard-style set of pages in which data for a user is
    entered across several pages in the flow.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例创建了一组向导风格的页面，用户可以在流程的多个页面中输入用户数据。
- en: 'In the first page, we enter name information:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一页，我们输入姓名信息：
- en: '![](img/9e5d34d5-7a57-4861-8591-7d393a686bf0.png)'
  id: totrans-260
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/9e5d34d5-7a57-4861-8591-7d393a686bf0.png)'
- en: 'In the second page, we enter address information:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二页，我们输入地址信息：
- en: '![](img/7a7d96a3-9280-4936-8a9d-f69924ca684a.png)'
  id: totrans-262
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/7a7d96a3-9280-4936-8a9d-f69924ca684a.png)'
- en: 'In the next page, we enter phone number information:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一页，我们输入电话号码信息：
- en: '![](img/646ffdc1-c73e-448b-b538-0596aaa7bb4a.png)'
  id: totrans-264
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/646ffdc1-c73e-448b-b538-0596aaa7bb4a.png)'
- en: 'Finally, we display a Confirmation page:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们显示一个确认页面：
- en: '![](img/77845a56-9aa1-4c2a-a2fc-f23416c8989e.png)'
  id: totrans-266
  prefs: []
  type: TYPE_IMG
  zh: '![](img/77845a56-9aa1-4c2a-a2fc-f23416c8989e.png)'
- en: If the user verifies that the information is correct, we navigate outside the
    flow to `customerinfo-return.xhtml`; otherwise, we go back to the first page in
    the flow to allow the user to make any necessary corrections.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 如果用户验证信息正确，我们将导航到`customerinfo-return.xhtml`页面外，否则我们将返回流程中的第一页，以便用户进行任何必要的更正。
- en: Injecting JSF artifacts
  id: totrans-268
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 注入JSF组件
- en: 'The JSF specification predates CDI. As such, many JSF artifacts, such as `FacesContext`
    and `ExternalContext`, had to be obtained via `static entry` methods; this resulted
    in hard-to-read boilerplate code. JSF 2.3 introduces the ability to inject JSF
    artifacts via CDI''s `@Inject` annotation, as seen in the following example:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: JSF规范早于CDI。因此，许多JSF组件，如`FacesContext`和`ExternalContext`，必须通过`static entry`方法获取；这导致了难以阅读的样板代码。JSF
    2.3引入了通过CDI的`@Inject`注解注入JSF组件的能力，如下例所示：
- en: '[PRE23]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: In this example, we need an instance of `FacesContext` so that we can send an
    arbitrary message to an `<h:messages>` component; as of JSF 2.3, we can simply
    annotate our instance of `FacesContext` with CDI's `@Inject` annotation.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们需要一个`FacesContext`的实例，以便我们可以向一个`<h:messages>`组件发送任意消息；从JSF 2.3开始，我们可以简单地使用CDI的`@Inject`注解来注解我们的`FacesContext`实例。
- en: '[Chapter 5](54a73845-4f4d-4129-a361-85c78007f495.xhtml), *Contexts and Dependency
    Injection,* covers CDI in detail.'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: '[第5章](54a73845-4f4d-4129-a361-85c78007f495.xhtml)，*上下文和依赖注入*，详细介绍了CDI。'
- en: 'In order for us to be able to successfully inject a JSF artifact into our CDI
    named beans, we need to add a CDI `beans.xml` deployment descriptor to the `WEB-INF`
    directory of our WAR file, making sure to set the `bean-discovery-mode` attribute
    of its `<beans>` tag to all:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 为了能够成功将JSF组件注入我们的CDI命名bean中，我们需要在我们的WAR文件的`WEB-INF`目录中添加一个CDI `beans.xml`部署描述符，确保将其`<beans>`标签的`bean-discovery-mode`属性设置为all：
- en: '[PRE24]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Additionally, we need to have a class in our WAR file annotated with the `@FacesConfig`
    annotation (we use this annotation to specify we are using JSF 2.3):'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们还需要在我们的WAR文件中有一个被`@FacesConfig`注解的类（我们使用此注解来指定我们正在使用JSF 2.3）：
- en: '[PRE25]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: As can be seen in the preceding example, the class containing the `@FacesConfig`
    annotation doesn't have to have any code. We specify that we are using JSF 2.3
    by passing `FacesConfig.Version.JSF_2_3` as the value of the annotation's version
    attribute.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 如前例所示，包含`@FacesConfig`注解的类不需要有任何代码。我们通过将`FacesConfig.Version.JSF_2_3`作为注解版本属性的值来指定我们正在使用JSF
    2.3。
- en: 'In addition to illustrating how to inject the JSF artifact, this example illustrates
    a JSF feature we haven''t seen before—the ability to send arbitrary messages to
    an `<h:messages>` component via the `addMessage()` method of `FacesContext`. Next,
    we show the markup corresponding to the preceding CDI named bean:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 除了说明如何注入JSF组件外，此示例还说明了我们之前未看到的JSF功能——通过`FacesContext`的`addMessage()`方法向`<h:messages>`组件发送任意消息的能力。接下来，我们将展示与前面CDI命名bean对应的标记：
- en: '[PRE26]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: When the user clicks on the button generated by the `<h:commandButton>` component,
    the `saveData()` method of our CDI named bean is invoked, which in turn creates
    an instance of `FacesMessage` and passes it to the `addMessage()` method of `FacesContext`,
    resulting in the message being shown in the browser.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户点击由`<h:commandButton>`组件生成的按钮时，我们的CDI命名bean的`saveData()`方法被调用，这反过来创建了一个`FacesMessage`实例并将其传递给`FacesContext`的`addMessage()`方法，从而在浏览器中显示消息。
- en: In case it isn't obvious, this simple example doesn't actually save any data;
    all we are illustrating here is how to pass arbitrary messages to the JSF `<h:messages>`
    component.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 如果不明显，这个简单的示例实际上并没有保存任何数据；我们在这里展示的只是如何将任意消息传递给JSF `<h:messages>`组件。
- en: 'The following screenshot assumes the user has already pressed the Save button.
    The message at the top is the result of our invocation to the `addMessage()` method
    of `FacesContext`:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图假设用户已经点击了保存按钮。顶部消息是我们对`FacesContext`的`addMessage()`方法的调用结果：
- en: '![](img/6a333c2a-0350-4ff5-8cdf-69e8af7a6f78.png)'
  id: totrans-283
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6a333c2a-0350-4ff5-8cdf-69e8af7a6f78.png)'
- en: JSF WebSocket support
  id: totrans-284
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JSF WebSocket支持
- en: In typical web applications, servers always respond to requests from a browser;
    there is no way for a server to send data to the client browser without responding
    to a request. **WebSocket** technology provides full duplex communication between
    a browser and a server, allowing servers to independently send data to a client,
    without having to respond to a request. WebSocket technology allows a myriad of
    new applications to be developed for the web, including updating stock tickers,
    multiplayer online games, and chat applications.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 在典型的Web应用程序中，服务器总是响应来自浏览器的请求；服务器没有不响应请求就向客户端浏览器发送数据的方法。**WebSocket**技术提供了浏览器和服务器之间的全双工通信，允许服务器独立地向客户端发送数据，而无需响应请求。WebSocket技术使得可以为Web开发出无数新的应用程序，包括更新股票行情、多人在线游戏和聊天应用程序。
- en: Although some of these types of web applications were developed before the advent
    of WebSockets, they relied on hacks to work around the limitations of the HTTP
    protocol. With WebSockets, these hacks are no longer necessary.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管一些这类Web应用程序是在WebSocket出现之前开发的，但它们依赖于一些技巧来绕过HTTP协议的限制。有了WebSocket，这些技巧就不再必要了。
- en: Traditionally, writing applications taking advantage of the WebSocket protocol
    required a lot of JavaScript code. JSF 2.3 introduces WebSocket support and abstracts
    out most of the JavaScript plumbing, allowing us to focus on developing the business
    logic of our applications.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 传统上，编写利用WebSocket协议的应用程序需要大量的JavaScript代码。JSF 2.3引入了WebSocket支持，并抽象出了大部分JavaScript底层代码，使我们能够专注于开发应用程序的业务逻辑。
- en: The following example illustrates a simple chat application developed using
    JSF 2.3 WebSocket support.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例展示了使用JSF 2.3 WebSocket支持开发的简单聊天应用程序。
- en: 'First, let''s take a look at an application-scoped CDI named bean responsible
    for sending messages to all browser clients:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们看看一个名为bean的应用范围CDI，它负责向所有浏览器客户端发送消息：
- en: '[PRE27]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: As shown in the preceding example, in order to send data via WebSockets to the
    clients we need to inject an instance of an implementation of the `javax.faces.push.PushContext`
    interface, and annotate it with the `@Push` annotation. To actually send the message
    to the client, we need to invoke the `send()` method of the injected `PushContext`
    implementation; in our example, this is done in the `send()` method of our CDI
    named bean.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 如前例所示，为了通过WebSockets向客户端发送数据，我们需要注入一个实现`javax.faces.push.PushContext`接口的实例，并用`@Push`注解标注它。要实际向客户端发送消息，我们需要调用注入的`PushContext`实现中的`send()`方法；在我们的例子中，这是在CDI
    named bean的`send()`方法中完成的。
- en: 'In our example, there is a session scoped CDI named bean that takes input from
    the user and passes it to the `send()` method of the preceding application scoped
    CDI named bean. Our session scoped CDI bean looks as follows:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的例子中，有一个会话范围的CDI named bean从用户那里获取输入，并将其传递给前面提到的应用范围CDI named bean的`send()`方法。我们的会话范围CDI
    bean如下所示：
- en: '[PRE28]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The `sendMessage()` method of the preceding class calls the `send()` method
    of the application scoped CDI bean we discussed earlier, passing the name of the
    user and the message to be broadcast to all browsers. The aforementioned `sendMessage()`
    method is invoked via Ajax when a user clicks a button on the corresponding page,
    as shown in the following markup:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的类中的`sendMessage()`方法调用我们之前讨论的应用范围CDI bean的`send()`方法，传递用户名和要向所有浏览器广播的消息。上述`sendMessage()`方法是通过Ajax在用户点击相应页面上的按钮时调用的，如下所示：
- en: '[PRE29]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The `<f:websocket>` tag in the preceding markup is needed to enable WebSocket
    support in our page. The value of its `channel` attribute links the page to the
    corresponding `PushContext` instance on the server (in our example, it is defined
    in the application scoped `JsfWebSocketMessageSender` CDI named bean). By convention,
    the value of the `channel` attribute must match the variable name on the corresponding
    CDI named bean (`pushContext`, in our example).
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的标记中，`<f:websocket>`标签是启用页面WebSocket支持所必需的。其`channel`属性的值将页面链接到服务器上相应的`PushContext`实例（在我们的例子中，它定义在应用范围的`JsfWebSocketMessageSender`
    CDI named bean中）。按照惯例，`channel`属性的值必须与相应CDI named bean上的变量名匹配（在我们的例子中是`pushContext`）。
- en: We're only showing the most relevant sections of the example; the complete example
    can be downloaded from this book's GitHub repository at [https://github.com/dheffelfinger/Java-EE-8-Application-Development-Code-Samples](https://github.com/dheffelfinger/Java-EE-8-Application-Development-Code-Samples).
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只展示了示例中最相关的部分；完整的示例可以从本书的GitHub仓库中下载，网址为[https://github.com/dheffelfinger/Java-EE-8-Application-Development-Code-Samples](https://github.com/dheffelfinger/Java-EE-8-Application-Development-Code-Samples)。
- en: 'After building and deploying our application we can see it in action:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建和部署我们的应用程序之后，我们可以看到它的实际运行情况：
- en: '![](img/545b3456-285a-461b-b05c-a03b4b9cc01b.png)'
  id: totrans-299
  prefs: []
  type: TYPE_IMG
  zh: '![](img/545b3456-285a-461b-b05c-a03b4b9cc01b.png)'
- en: Additional JSF component libraries
  id: totrans-300
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 其他JSF组件库
- en: 'In addition to the standard JSF component libraries, there are a number of
    third-party JSF tag libraries available. The following table lists some of the
    most popular:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 除了标准的JSF组件库之外，还有许多第三方JSF标签库可供选择。以下表格列出了其中一些最受欢迎的：
- en: '| **Tag library** | **Distributor** | **License** | **URL** |'
  id: totrans-302
  prefs: []
  type: TYPE_TB
  zh: '| **标签库** | **发行商** | **许可** | **URL** |'
- en: '| `ICEfaces` | ICEsoft | MPL 1.1 | [http://www.icefaces.org](http://www.icefaces.org)
    |'
  id: totrans-303
  prefs: []
  type: TYPE_TB
  zh: '| `ICEfaces` | ICEsoft | MPL 1.1 | [http://www.icefaces.org](http://www.icefaces.org)
    |'
- en: '| `RichFaces` | Red Hat/JBoss | LGPL | [http://www.jboss.org/richfaces](http://www.jboss.org/richfaces)
    |'
  id: totrans-304
  prefs: []
  type: TYPE_TB
  zh: '| `RichFaces` | Red Hat/JBoss | LGPL | [http://www.jboss.org/richfaces](http://www.jboss.org/richfaces)
    |'
- en: '| `Primefaces` | Prime Technology | Apache 2.0 | [http://www.primefaces.org](http://www.primefaces.org)
    |'
  id: totrans-305
  prefs: []
  type: TYPE_TB
  zh: '| `Primefaces` | Prime Technology | Apache 2.0 | [http://www.primefaces.org](http://www.primefaces.org)
    |'
- en: Summary
  id: totrans-306
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we covered how to develop web-based applications using JavaServer
    Faces, the standard component framework for the Java EE platform. We looked at
    how to write a simple application by creating pages using Facelets as the view
    technology and CDI named beans. We also covered how to validate user input by
    using JSF's standard validators, by creating our own custom validators or by writing
    `validator` methods. Additionally, we covered how to customize standard JSF error
    messages, both the message text and the message style (font, color, and such).
    Also, we covered how to develop Ajax-enabled JSF pages, as well as how to integrate
    JSF and HTML5.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了如何使用JavaServer Faces（Java EE平台的标准组件框架）开发基于Web的应用程序。我们探讨了如何通过使用Facelets作为视图技术以及CDI命名豆来创建页面来编写一个简单的应用程序。我们还介绍了如何使用JSF的标准验证器、创建自定义验证器或编写`validator`方法来验证用户输入。此外，我们还介绍了如何自定义标准的JSF错误消息，包括消息文本和消息样式（字体、颜色等）。还介绍了如何开发启用Ajax的JSF页面，以及如何集成JSF和HTML5。
