- en: JavaServer Faces
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will cover **JavaServer** **Faces** (**JSF**), the standard
    component framework of the Java EE platform. Java EE 8 includes JSF 2.3, the latest
    version of JSF. JSF relies a lot on convention over configuration—if we follow
    JSF conventions then we don't need to write a lot of configuration. In most cases,
    we don't need to write any configuration at all. This fact, combined with the
    fact that `web.xml` has been optional since Java EE 6, means that, in many cases,
    we can write complete web applications without having to write a single line of
    XML.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will cover the following topics in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Facelets
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: JSF project stages
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Data validation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Named beans
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Navigation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ajax-enabling JSF applications
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: JSF HTML5 support
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Faces flows
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: JSF artifact injection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: JSF WebSocket support
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: JSF component libraries
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introducing JSF
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: JSF 2.0 introduced a number of enhancements to make JSF application development
    easier. In the following few sections, we will explore some of these features.
  prefs: []
  type: TYPE_NORMAL
- en: Readers not familiar with earlier versions of JSF may not understand the following
    few sections completely. Not to worry, everything will be perfectly clear by the
    end of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Facelets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One notable difference between modern versions of JSF and earlier versions is
    that Facelets is now the preferred view technology. Earlier versions of JSF used
    **Java Server Pages** (**JSP**) as their default view technology. Since the JSP
    technology predates JSF, sometimes using JSP with JSF felt unnatural or created
    problems. For example, the JSP lifecycle is different from the JSF lifecycle;
    this mismatch introduced some problems for JSF 1.x application developers.
  prefs: []
  type: TYPE_NORMAL
- en: JSF was designed from the beginning to support multiple view technologies. To
    take advantage of this capability, Jacob Hookom wrote a view technology specifically
    for JSF. He named his view technology **Facelets**. Facelets was so successful
    it became a de-facto standard for JSF. The JSF expert group recognized Facelets'
    popularity and made it the official view technology for JSF in version 2.0 of
    the JSF specification.
  prefs: []
  type: TYPE_NORMAL
- en: Optional faces-config.xml
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Legacy J2EE applications suffered from what some have considered to be excessive
    XML configuration.
  prefs: []
  type: TYPE_NORMAL
- en: Java EE 5 took some measures to reduce XML configuration considerably. Java
    EE 6 reduced the required configuration even further, making the JSF configuration
    file, `faces-config.xml`, optional in JSF 2.0.
  prefs: []
  type: TYPE_NORMAL
- en: In JSF 2.0 and newer versions, JSF managed beans can be configured via the `@ManagedBean`
    annotation, obviating the need to configure them in `faces-config.xml`. Java EE
    6 introduced the **Contexts and Dependency Injection** (**CDI**) API, which provides
    an alternate way of implementing functionality typically implemented with JSF
    managed beans. As of JSF 2.2, CDI named beans are preferred over JSF managed beans;
    JSF 2.3 went even further, deprecating specific JSF-managed beans in favor of
    CDI named beans.
  prefs: []
  type: TYPE_NORMAL
- en: 'Additionally, there is a convention for JSF navigation: if the value of the
    action attribute of a JSF 2.0 command link or command button matches the name
    of a facelet (minus the XHTML extension), then by convention, the application
    will navigate to the facelet matching the action name. This convention allows
    us to avoid having to configure application navigation in `faces-config.xml`.'
  prefs: []
  type: TYPE_NORMAL
- en: For many modern JSF applications, `faces-config.xml` is completely unnecessary
    as long as we follow established JSF conventions.
  prefs: []
  type: TYPE_NORMAL
- en: Standard resource locations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: JSF 2.0 introduced standard resource locations. Resources are artifacts a page
    or JSF component needs to render properly. Resource examples include CSS stylesheets,
    JavaScript files, and images.
  prefs: []
  type: TYPE_NORMAL
- en: In JSF 2.0 and newer versions, resources can be placed in a subdirectory under
    a folder called `resources`, either at the root of the WAR file or under its `META-INF`
    directory. By convention, JSF components know they can retrieve resources from
    one of these two locations.
  prefs: []
  type: TYPE_NORMAL
- en: In order to avoid cluttering the `resources` directory, `resources` are typically
    placed in a subdirectory. This subdirectory is referred to from the `library`
    attribute of JSF components.
  prefs: []
  type: TYPE_NORMAL
- en: For example, we could place a CSS stylesheet called `styles.css` under `/resources/css/styles.css`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In our JSF pages, we could retrieve this CSS file using the `<h:outputStylesheet>`
    tag, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The value of the `library` attribute must match the subdirectory where our `stylesheet`
    is located.
  prefs: []
  type: TYPE_NORMAL
- en: 'Similarly, we could have a JavaScript file under `/resources/scripts/somescript.js`
    and an image under `/resources/images/logo.png`, and we could access these `resources`
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'And:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Notice that, in each case, the value of the `library` attribute matches the
    corresponding subdirectory name under the `resources` directory, and the value
    of the `name` attribute matches the resource's file name.
  prefs: []
  type: TYPE_NORMAL
- en: Developing our first JSF application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To illustrate basic JSF concepts, we will develop a simple application consisting
    of two Facelet pages and a single CDI named bean.
  prefs: []
  type: TYPE_NORMAL
- en: Facelets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As we mentioned in this chapter''s introduction, the default view technology
    for JSF 2.0 and newer versions is **Facelets**. Facelets need to be written using
    standard XML. The most popular way to develop Facelet pages is to use XHTML in
    conjunction with JSF-specific XML namespaces. The following example shows how
    a typical Facelet page looks:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The following screenshot illustrates how the previous page renders in the browser:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/dcb5841f-5eb1-4f8c-88e1-de9865c95345.png)'
  prefs: []
  type: TYPE_IMG
- en: The preceding screenshot, of course, was taken after entering some data in every
    text field; originally each text field was blank.
  prefs: []
  type: TYPE_NORMAL
- en: Pretty much any Facelet JSF page will include the two namespaces illustrated
    in the example. The first namespace (``) is for tags that render HTML components;
    by convention, the prefix `h` (for HTML) is used when using this `tag` library.``
  prefs: []
  type: TYPE_NORMAL
- en: The second namespace (``) is the core JSF `tag` library, by convention, the
    prefix `f` (for faces) is used when using this `tag` library.``
  prefs: []
  type: TYPE_NORMAL
- en: The first JSF-specific tags we see in the preceding example are the `<h:head>`
    and `<h:body>` tags. These tags are analogous to the standard HTML `<head>` and
    `<body>` tags, and are rendered as such when the page is displayed in the browser.
  prefs: []
  type: TYPE_NORMAL
- en: The `<h:outputStylesheet>` tag is used to load a CSS stylesheet from a well-known
    location (JSF standardizes the locations of resources, such as CSS stylesheets
    and JavaScript files; this will be discussed in detail later in the chapter).
    The value of the `library` attribute must correspond to the directory where the
    CSS file resides (this directory must be under a `resources` directory). The `name`
    attribute must correspond to the name of the CSS stylesheet we want to load.
  prefs: []
  type: TYPE_NORMAL
- en: The next tag we see is the `<h:form>` tag. This tag generates an HTML form when
    the page is rendered. As can be seen in the example, there is no need to specify
    an `action` or a `method` attribute for this tag; as a matter of fact, there is
    no `action` or `method` attribute for this tag. The `action` attribute for the
    rendered HTML form will be generated automatically, and the `method` attribute
    will always be `post`. The `id` attribute of `<h:form>` is optional; however,
    it is a good idea to always add it, since it makes debugging JSF applications
    easier.
  prefs: []
  type: TYPE_NORMAL
- en: The next tag we see is the `<h:messages>` tag. As its name implies, this tag
    is used to display any messages. As we will see shortly, JSF can automatically
    generate validation messages, displayed inside this tag. Additionally, arbitrary
    messages can be added programmatically via the `addMessage()` method defined in
    `javax.faces.context.FacesContext`.
  prefs: []
  type: TYPE_NORMAL
- en: The next JSF tag we see is `<h:panelGrid>`. This tag is roughly equivalent to
    an HTML table, but it works a bit differently. Instead of declaring rows (`<tr>`)
    and cells (`<td>`), the `<h:panelGrid>` tag has a `columns` attribute; the value
    of this attribute indicates the number of columns in the table rendered by this
    tag. As we place components inside this tag, they will be placed in a row until
    the number of columns defined in the `columns` attribute is reached, when the
    next component will be placed in the next row. In the example, the value of the
    columns attribute is `2`, therefore the first two tags will be placed in the first
    row, the next two will be placed in the second row, and so forth.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another interesting attribute of `<h:panelGrid>` is the `columnClasses` attribute.
    This attribute assigns a CSS class to each column in the rendered table. In the
    example, two CSS classes (separated by a comma) are used as the value for this
    attribute. This has the effect of assigning the first CSS class to the first column,
    and the second one to the second column. Had there been three or more columns,
    the third one would have gotten the first CSS class, the fourth one the second
    one, and so on, alternating between the first one and the second one. To clarify
    how this works, the next code snippet illustrates a portion of the source of the
    HTML markup generated by the preceding page:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Notice how each `<td>` tag has an alternating CSS tag—`"rightAlign"` or `"leftAlign"`;
    we achieved this by assigning the value `"rightAlign,leftAlign"` to the `columnClasses`
    attribute of `<h:panelGrid>`. We should note that the CSS classes we are using
    in our example are defined in the CSS stylesheet we loaded via the `<h:outputStylesheet>`
    we discussed earlier. The ID's of the generated markup are a combination of the
    ID we gave to the `<h:form>` component, plus the ID of each individual component.
    Notice that we didn't assign an ID to the `<h:commandButton>` component near the
    end of the page, so the JSF runtime assigned one automatically.
  prefs: []
  type: TYPE_NORMAL
- en: At this point in the example, we start adding components inside `<h:panelGrid>`.
    These components will be rendered inside the table rendered by `<h:panelGrid>`.
    As we mentioned before, the number of columns in the rendered table is defined
    by the `columns` attribute of `<h:panelGrid>`. Therefore, we don't need to worry
    about columns (or rows), we can just start adding components and they will be
    placed in the right place.
  prefs: []
  type: TYPE_NORMAL
- en: The next tag we see is the `<h:outputLabel>` tag. This tag renders as an HTML
    `label` element. Labels are associated with other components via the `for` attribute,
    whose value must match the ID of the component that the label is for.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we see the `<h:inputText>` tag. This tag generates a text field in the
    rendered page. Its `label` attribute is used for any validation messages; it lets
    the user know what field the message refers to.
  prefs: []
  type: TYPE_NORMAL
- en: Although it is not mandatory for the value of the `label` attribute of `<h:inputText>`
    to match the label displayed on the page, it is highly recommended to use this
    value. In case of an error, this will let the user know exactly what field the
    message is referring to.
  prefs: []
  type: TYPE_NORMAL
- en: 'Of particular interest is the tag''s `value` attribute. What we see as the
    value for this attribute is a **value binding expression**. What this means is
    that this value is tied to a property of one of the application''s named beans.
    In the example, this particular text field is tied to a property called `firstName`
    in a named bean called `customer`. When a user enters a value for this text field
    and submits the form, the corresponding property in the named bean is updated
    with this value. The tag''s `required` attribute is optional; valid values for
    it are `true` and `false`. If this attribute is set to `true`, the container will
    not let the user submit the form until the user enters some data for the text
    field. If the user attempts to submit the form without entering a required value,
    the page will be reloaded and an error message will be displayed inside the `<h:messages>`
    tag:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c9b523d5-2144-4efc-8ef1-bfc807dbccae.png)'
  prefs: []
  type: TYPE_IMG
- en: The preceding screenshot illustrates the default error message shown when the
    user attempts to save the form in the example without entering a value for the
    customer's first name. The first part of the message (First Name) is taken from
    the value of the `label` attribute of the corresponding `<h:inputTextField>` tag.
    The text of the message can be customized, as well as its style (font, color,
    and more.). We will cover how to do this later in the chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Project stages
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Having a `<h:messages>` tag on every JSF page is a good idea; without it, the
    user might not see validation messages and will have no idea why the form submission
    is not going through. By default, JSF validation messages do not generate any
    output in the application server log. A common mistake new JSF developers make
    is failing to add a `<h:messages>` tag to their pages; without it, if validation
    fails, then the navigation seems to fail for no reason (the same page is rendered
    if navigation fails and, without a `<h:messages>` tag, no error messages are displayed
    in the browser).
  prefs: []
  type: TYPE_NORMAL
- en: To avoid this situation, JSF 2.0 introduced the concept of **project stages**.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following project stages are defined in JSF 2.0 and newer versions:'
  prefs: []
  type: TYPE_NORMAL
- en: Production
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Development
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: UnitTest
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: SystemTest
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can define the project stage as an initialization parameter to the Faces
    servlet in `web.xml`, or as a custom JNDI resource. The preferred way of setting
    the project stage is through a custom JNDI resource.
  prefs: []
  type: TYPE_NORMAL
- en: The process to map global JNDI resources to component resources is application
    server-specific; when using GlassFish, a change needs to be made to the application's
    `web.xml`, plus we need to use a GlassFish-specific deployment descriptor.
  prefs: []
  type: TYPE_NORMAL
- en: 'Setting up a custom JNDI resource is application server-specific, consult your
    application server documentation for details. If we are using GlassFish to deploy
    our application, we can set up a custom JNDI by logging in to the web console,
    navigating to JNDI | Custom Resources, then clicking the New... button:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/65263f05-a968-490d-b530-ecc2094d67ca.png)'
  prefs: []
  type: TYPE_IMG
- en: 'In the resulting page, we need to enter the following information:'
  prefs: []
  type: TYPE_NORMAL
- en: '| JNDI Name | `javax.faces.PROJECT_STAGE` |'
  prefs: []
  type: TYPE_TB
- en: '| Resource Type | `java.lang.String` |'
  prefs: []
  type: TYPE_TB
- en: 'After entering these two values, the Factory Class field will be automatically
    populated with the value : `org.glassfish.resources.custom.factory.PrimitivesAndStringFactory`.'
  prefs: []
  type: TYPE_NORMAL
- en: After entering the values, we need to add a new property with a name of value
    and a value corresponding to the project stage we want to use (Development, in
    the preceding screenshot).
  prefs: []
  type: TYPE_NORMAL
- en: 'Setting the project stage allows us to perform some logic only if we are running
    in a specific stage. For instance, in one of our named beans, we could have code
    that looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'As we can see, project stages allow us to modify our code''s behavior for different
    environments. More importantly, setting the project stage allows the JSF engine
    to behave a bit differently based on the project stage setting. Relevant to our
    discussion, setting the project stage to Development results in additional logging
    statements in the application server log. Therefore, if we forget to add a `<h:messages>`
    tag to our page, our project stage is Development, and validation fails; a Validation
    Error will be displayed on the page even if we omit the `<h:messages>` component:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f5026fc8-5db0-4038-bf35-fc4368d3988b.png)'
  prefs: []
  type: TYPE_IMG
- en: In the default `Production` stage, this error message is not displayed in the
    page, leaving us confused as to why our page navigation doesn't seem to be working.
  prefs: []
  type: TYPE_NORMAL
- en: Validation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Notice that each `<h:inputField>` tag has a nested `<f:validateLength>` tag.
    As its name implies, this tag validates that the entered value for the text field
    is between a minimum and maximum length. Minimum and maximum values are defined
    by the tag''s `minimum` and `maximum` attributes. `<f:validateLength>` is one
    of the standard validators included with JSF. Just like with the `required` attribute
    of `<h:inputText>`, JSF will automatically display a default error message when
    a user attempts to submit a form with a value that does not validate:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/fbc4ee7f-2ba5-48b7-a7d3-dfa73575cb13.png)'
  prefs: []
  type: TYPE_IMG
- en: Again, the default message and style can be overridden; we will cover how to
    do this later in the chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition to `<f:validateLength>`, JSF includes other standard validators,
    which are listed in the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Validation tag** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `<f:validateBean>` | Bean validation allows us to validate named `bean` values
    by using annotations in our named beans without having to add validators to our
    JSF tags. This tag allows us to fine-tune bean validation if necessary. |'
  prefs: []
  type: TYPE_TB
- en: '| `<f:validateDoubleRange>` | Validates that the input is a valid `Double`
    value between the two values specified by the tag''s `minimum` and `maximum` attributes,
    inclusive. |'
  prefs: []
  type: TYPE_TB
- en: '| `<f:validateLength>` | Validates that the input''s length is between the
    values specified by the tag''s `minimum` and `maximum` values, inclusive. |'
  prefs: []
  type: TYPE_TB
- en: '| `<f:validateLongRange>` | Validates that the input is a valid `Double` value
    between the values specified by the tag''s `minimum` and `maximum` attributes,
    inclusive. |'
  prefs: []
  type: TYPE_TB
- en: '| `<f:validateRegex>` | Validates that the input matches a regular expression
    pattern specified in the tag''s `pattern` attribute. |'
  prefs: []
  type: TYPE_TB
- en: '| `<f:validateRequired>` | Validates that the input is not empty. This tag
    is equivalent to setting the `required` attribute to `true` in the parent input
    field. |'
  prefs: []
  type: TYPE_TB
- en: Notice that in the description for `<f:validateBean>`, we briefly mentioned
    bean validation. The bean validation JSR aims to standardize JavaBean validation.
    JavaBeans are used across several other APIs that, up until recently, had to implement
    their own validation logic. JSF 2.0 adopted the bean validation standard to help
    validate named bean properties.
  prefs: []
  type: TYPE_NORMAL
- en: If we want to take advantage of bean validation, all we need to do is annotate
    the desired field with the appropriate bean validation annotation, without having
    to explicitly use a JSF validator.
  prefs: []
  type: TYPE_NORMAL
- en: For a complete list of bean validation annotations, refer to the `javax.validation.constraints`
    package in the Java EE 8 API at [https://javaee.github.io/javaee-spec/javadocs/](https://javaee.github.io/javaee-spec/javadocs/).
  prefs: []
  type: TYPE_NORMAL
- en: Grouping components
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`<h:panelGroup>` is the next new tag in the example. Typically, `<h:panelGroup>`
    is used to group several components together so that they occupy a single cell
    in an `<h:panelGrid>`. This can be accomplished by adding components inside `<h:panelGroup>`
    and adding `<h:panelGroup>` to `<h:panelGrid>`. As can be seen in the example,
    this particular instance of `<h:panelGroup>` has no child components. In this
    particular case, the purpose of `<h:panelGroup>` is to have an empty cell and
    have the next component, `<h:commandButton>`, align with all other input fields
    in the form.'
  prefs: []
  type: TYPE_NORMAL
- en: Form submission
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`<h:commandButton>` renders an HTML submit button in the browser. Just like
    with standard HTML, its purpose is to submit the form. Its `value` attribute simply
    sets the button''s label. This tag''s `action` attribute is used for navigation;
    the next page to show is based on the value of this attribute. The `action` attribute
    can have a `String` constant or a **method binding expression**, meaning that
    it can point to a `method` in a named bean that returns a string.'
  prefs: []
  type: TYPE_NORMAL
- en: If the base name of a page in our application matches the value of the `action`
    attribute of a `<h:commandButton>` tag, then we navigate to this page when clicking
    the button. This JSF feature frees us from having to define navigation rules,
    like we used to have to do in older versions of JSF. In our example, our confirmation
    page is called `confirmation.xhtml`; therefore by convention, this page will be
    shown when the button is clicked, since the value of its `action` attribute (confirmation)
    matches the base name of the page.
  prefs: []
  type: TYPE_NORMAL
- en: Even though the label for the button reads Save, in our simple example, clicking
    on the button won't actually save any data.
  prefs: []
  type: TYPE_NORMAL
- en: Named beans
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are two types of Java Beans that can interact with JSF pages: JSF managed
    beans and CDI named beans. JSF managed beans have been around since the first
    version of the JSF specification and can be used only in a JSF context. CDI named
    beans were introduced in Java EE 6 and can interoperate with other Java EE APIs,
    such as Enterprise JavaBeans. For this reason, CDI named beans are preferred over
    JSF managed beans.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To make a Java class a CDI named bean, all we need to do is make sure the class
    has a public, no argument constructor (one is created implicitly if there are
    no other constructors declared, which is the case in our example) and add the
    `@Named` annotation at the class level. Here is the managed bean for our example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The `@Named` class annotation designates this bean as a CDI named bean. This
    annotation has an optional `value` attribute we can use to give our bean a logical
    name for use in our JSF pages. However, by convention, the value of this attribute
    is the same as the class name (`Customer`, in our case), with its first character
    switched to lower case. In our example, we let this default behavior take place,
    therefore we access our bean's properties via the `customer` logical name. Notice
    the `value` attribute of any of the input fields in our example page to see this
    logical name in action.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that, other than the `@Named` and `@RequestScoped` annotations, there
    is nothing special about this bean. It is a standard JavaBean with private properties
    and corresponding `getter` and `setter` methods. The `@RequestScoped` annotation
    specifies that the bean should live through a single request. The different named
    bean, scopes, available for our JSF applications, are covered in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Named bean scopes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Managed beans always have a scope. A managed bean scope defines the lifespan
    of the application. The managed bean scope is defined by a class level annotation.
    The following table lists all valid managed bean scopes:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Named bean scope annotation** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `@ApplicationScoped` | The same instance of application scoped named beans
    is available to all of our application''s clients. If one client modifies the
    value of an application scoped managed bean, the change is reflected across clients.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `@SessionScoped` | An instance of each session scoped named bean is assigned
    to each of our application''s clients. A session-scoped named bean can be used
    to hold client-specific data across requests. |'
  prefs: []
  type: TYPE_TB
- en: '| `@RequestScoped` | Request scoped named beans only live through a single
    HTTP request. |'
  prefs: []
  type: TYPE_TB
- en: '| `@Dependent` | Dependent scoped named beans are assigned the same scope as
    the bean they are injected to. |'
  prefs: []
  type: TYPE_TB
- en: '| `@ConversationScoped` | The conversation scope can span multiple requests,
    but is typically shorter than the session scope. |'
  prefs: []
  type: TYPE_TB
- en: Navigation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As can be seen in our input page, when clicking on the Save button in the `customer_data_entry.xhtml`
    page, our application will navigate to a page called `confirmation.xhtml`. This
    happens because we are taking advantage of JSF's convention over configuration
    feature; if the value of the `action` attribute of a command button or link matches
    the base name of another page, then this navigation takes us to this page.
  prefs: []
  type: TYPE_NORMAL
- en: Same page reloading when clicking on a button or link that should navigate to
    another page? When JSF does not recognize the value of the `action` attribute
    of a command button or command link, it will by default navigate to the same page
    that was displayed in the browser when the user clicked on a button or link that
    is meant to navigate to another page.
  prefs: []
  type: TYPE_NORMAL
- en: If navigation does not seem to be working properly, chances are there is a typo
    in the value of this attribute. Remember that, by convention, JSF will look for
    a page whose base name matches the value of the `action` attribute of a command
    button or link.
  prefs: []
  type: TYPE_NORMAL
- en: 'The source for `confirmation.xhtml` looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The `<h:outputText>` is the only tag on this page we haven''t covered before.
    This tag simply displays the value of its `value` attribute to the rendered page,
    its `value` attribute can be a simple string or a value binding expression. Since
    the value binding expressions in our `<h:outputText>` tags are the same expressions
    used in the previous page for the `<h:inputText>` tags, their values will correspond
    to the data the user entered:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8c8ad334-ff9d-4320-9762-f4a565b8c32c.png)'
  prefs: []
  type: TYPE_IMG
- en: In traditional (that is, non-JSF) Java web applications, we define URL patterns
    to be processed by specific servlets. Specifically for JSF, the suffixes `.jsf`
    or `.faces` are commonly used; another commonly used URL mapping for JSF is the
    `/faces` prefix. Under certain conditions, modern application servers automatically
    add all three mappings to the faces `servlet`, if these conditions are met, we
    don't have to specify any URL mappings at all.
  prefs: []
  type: TYPE_NORMAL
- en: 'If any of these conditions are met, then the FacesServlet will be automatically
    mapped:'
  prefs: []
  type: TYPE_NORMAL
- en: There is a `faces-config.xml` file in the `WEB-INF` directory of our web application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There is a `faces-config.xml` file in the `META-INF` directory of one of the
    dependencies of our web application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There is a filename ending in `.faces-config.xml` in the `META-INF` directory
    of one of the dependencies of our web application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We declare a context parameter named `javax.faces.CONFIG_FILES` in our `web.xml`
    or a `web-fragment.xml` in one of the dependencies
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We pass a non-empty set of classes when invoking the `onStartup()` method of
    `ServletContextInitializer`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'When none of the preceding conditions are met, we need to explicitly map the
    Faces `servlet` in our `web.xml` deployment descriptor, as illustrated here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The URL we used for the pages in our application was the name of our Facelets
    pages, prefixed by `/faces`.
  prefs: []
  type: TYPE_NORMAL
- en: Custom data validation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In addition to providing standard validators for our use, JSF allows us to create
    `custom validator`s. This can be done in one of two ways—by creating a `custom
    validator` class or by adding `validation` methods to our named beans.
  prefs: []
  type: TYPE_NORMAL
- en: Creating custom validators
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In addition to the standard validators, JSF allows us to create custom validators
    by creating a Java class implementing the `javax.faces.validator.Validator` interface.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following class implements an email validator, which we will use to validate
    the email text input field in our customer data entry screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The `@FacesValidator` annotation registers our class as a JSF custom validator
    class. The value of its `value` attribute is the logical name that JSF pages can
    use to refer to it.
  prefs: []
  type: TYPE_NORMAL
- en: As can be seen in the example, the only method we need to implement when implementing
    the Validator interface is a method called `validate()`. This method takes three
    parameters—an instance of `javax.faces.context.FacesContext`, an instance of `javax.faces.component.UIComponent`,
    and an object. Typically, application developers only need to be concerned with
    the last two. The second parameter is the component whose data we are validating,
    the third parameter is the actual value. In the example, we cast `uiComponent`
    to `javax.faces.component.html.HtmlInputText`; this way, we get access to its
    `getLabel()` method, which we can use as part of the error message.
  prefs: []
  type: TYPE_NORMAL
- en: If the entered value is not an invalid email address format, a new instance
    of `javax.faces.application.FacesMessage` is created, passing the error message
    to be displayed in the browser as its `constructor` parameter. We then throw a
    new `javax.faces.validator.ValidatorException`. The error message is then displayed
    in the browser; it gets there behind the scenes via the JSF API.
  prefs: []
  type: TYPE_NORMAL
- en: '**Apache Commons Validator**: Our custom JSF validator uses `Apache Commons
    Validator` to do the actual validation. This library includes many common validations
    such as dates, credit card numbers, ISBN numbers, and emails. When implementing
    a custom validator, it''s worth investigating whether this library already has
    a validator that we can use.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to use our validator on our page, we need to use the `<f:validator>`
    JSF tag. The following Facelets page is a modified version of the customer data
    entry screen. This version uses the `<f:validator>` tag to validate email:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'After writing our custom validator and modifying our page to take advantage
    of it, we can see our `validator` in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/af2c0ad7-d199-425b-8d34-e6ca0ba446bc.png)'
  prefs: []
  type: TYPE_IMG
- en: Validator methods
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Another way we can implement custom validation is by adding `validation` methods
    to one or more of the application''s named beans. The following `Java` class illustrates
    the use of `validator` methods for JSF validation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: In this example, the class contains only the `validator` method, but that does
    not always have to be the case. We can give our `validator` method any name we
    want; however its return value must be `void`, and it must take the three parameters
    illustrated in the example, in that order. In other words, except for the method
    name, the signature of a `validator` method must be identical to the signature
    of the `validate()` method defined in the `javax.faces.validator.Validator` interface.
  prefs: []
  type: TYPE_NORMAL
- en: 'As we can see, the body of the preceding `validator` method is nearly identical
    to the body of our `custom validator` class, `validate()` method. We check the
    value entered by the user to make sure it contains only alphabetic characters
    and/or spaces; if it does not, then we throw a `ValidatorException` passing an
    instance of `FacesMessage` containing an appropriate error message `String`: `StringUtils`.'
  prefs: []
  type: TYPE_NORMAL
- en: In the example, we used `org.apache.commons.lang3.StringUtils` to perform the
    actual validation logic. In addition to the method used in the example, this class
    contains several methods for verifying that a `String` is numeric or alphanumeric.
    This class, part of the `Apache Commons Lang` library, is very useful when writing
    `custom validators`.
  prefs: []
  type: TYPE_NORMAL
- en: Since every `validator` method must be in a named bean, we need to make sure
    the class containing our `validator` method is annotated with the `@Named` annotation,
    as illustrated in our example.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last thing we need to do to use our `validator` method is to bind it to
    our component via the tag''s `validator` attribute:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Since neither the first name nor the last name fields should accept anything
    other than alphabetic characters or spaces, we added our custom validator method
    to both of these fields.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that the value of the `validator` attribute of the `<h:inputText>` tag
    is a JSF expression language; it uses the default named bean name for the bean
    containing our `validation` method. `alphaValidator` is the name of our bean,
    and `validateAlpha` is the name of our `validator` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'After modifying our page to use our `custom validator`, we can now see it in
    action:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d965e629-306a-42b9-80da-0ab5d7db9792.png)'
  prefs: []
  type: TYPE_IMG
- en: Notice how, for the First Name field, both our custom validator message and
    the standard length validator were executed.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing `validator` methods have the advantage of not having the overhead
    of creating a whole class just for a single `validator` method (our example does
    just that, but in many cases, `validator` methods are added to an existing named
    bean containing other methods); however, the disadvantage is that each component
    can only be validated by a single `validator` method. When using `validator` classes,
    several `<f:validator>` tags can be nested inside the tag to be validated, therefore
    multiple validations, both custom and standard, can be done on the field.
  prefs: []
  type: TYPE_NORMAL
- en: Customizing JSF's default messages
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Like we mentioned earlier, it is possible to customize the style (font, color,
    text, and so on) of JSF's default validation messages. Additionally, it is possible
    to modify the text of default JSF validation messages. In the following sections,
    we will explain how to modify error message formatting and text.
  prefs: []
  type: TYPE_NORMAL
- en: Customizing message styles
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Customizing message styles can be done via **Cascading Style Sheets** (**CSS**).
    This can be accomplished by using the `<h:message>`, `style`, or `styleClass`
    attributes. The `style` attribute is used when we want to declare the CSS style
    inline. The `styleClass` attribute is used when we want to use a predefined style
    in a CSS style sheet or inside a `<style>` tag in our page.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following markup illustrates using the `styleClass` attribute to alter
    the style of error messages; it is a modified version of the input page we saw
    in the previous section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The only difference between this page and the previous one is the use of the
    `styleClass` attribute of the `<h:messages>` tag. As we mentioned earlier, the
    value of the `styleClass` attribute must match the name of a CSS style defined
    in a cascading stylesheet that our page has access to.
  prefs: []
  type: TYPE_NORMAL
- en: 'In our case, we defined a CSS style for messages as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Then we used this style as the value of the `styleClass` attribute of our `<h:messages>`
    tag.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot illustrates how the validation error messages look
    after implementing this change:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2f7df965-7cf7-4f95-8a8e-5cd220649e66.png)'
  prefs: []
  type: TYPE_IMG
- en: In this particular case, we just set the color of the error message text to
    red, but we are only limited only by CSS capabilities in setting the style of
    the error messages.
  prefs: []
  type: TYPE_NORMAL
- en: Pretty much any standard JSF component has both a `style` and a `styleClass`
    attribute that can be used to alter its style. The former is used for predefined
    CSS styles, the latter is used for inline CSS.
  prefs: []
  type: TYPE_NORMAL
- en: Customizing message text
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Sometimes it is desirable to override the text of JSF''s default validation
    errors. Default validation errors are defined in a resource bundle called `Messages.properties`.
    This file can typically be found inside one of the JSF JAR Files included with
    your application server. For example, GlassFish includes it inside a JAR file
    called `javax.faces.jar` file under `[glassfish installation directory]/glassfish/modules`.
    The file contains several messages; we are only interested in validation errors
    at this point. The default validation error messages are defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'In order to override the default error messages, we need to create our own
    resource bundle, using the same keys used in the default one, but altering the
    values to suit our needs. Here is a very simple customized resource bundle for
    our application. For example, to overwrite the message for minimum length validation,
    we would add the following property to our custom resource bundle:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'In this resource bundle, we override the error message for when the value entered
    for a field validated by the `<f:validateLength>` tag is less than the allowed
    minimum. In order to let our application know that we have a custom resource bundle
    for message properties, we need to modify the application''s `faces-config.xml`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: As we can see, the only thing we need to do to the application's `faces-config.xml`
    file is to add a `<message-bundle>` element indicating the name and location of
    the resource bundle containing our custom messages.
  prefs: []
  type: TYPE_NORMAL
- en: Custom error message text definitions are one of the few cases where we still
    need to define a `faces-config.xml` file for modern JSF applications. However,
    notice how simple our `faces-config.xml` file is, a far cry from a typical `faces-config.xml`
    for JSF 1.x, which typically contains named bean definitions, navigation rules,
    and JSF validator definitions.
  prefs: []
  type: TYPE_NORMAL
- en: After adding our custom message resource bundle and modifying the application's
  prefs: []
  type: TYPE_NORMAL
- en: '`faces-config.xml` file, we can see our custom validation message in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/563474d0-7122-4845-a9e0-7f4eccceb068.png)'
  prefs: []
  type: TYPE_IMG
- en: As can be seen in the screenshot, if we haven't overridden a validation message,
    the default will still be displayed. In our resource bundle we only overrode the
    minimum length validation error message, therefore our custom error message is
    shown in the First Name text field. Since we didn't override the error message
    in the other standard JSF validators, the default error message is shown for each
    one of them. The email validator is the custom validator we developed previously
    in this chapter; since it is a custom validator, its error message is not affected.
  prefs: []
  type: TYPE_NORMAL
- en: Ajax-enabling JSF applications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: JSF allows us to easily implement **Ajax** (**Asynchronous JavaScript and XML**)
    functionality into our web applications by simply employing the `<f:ajax>` tag
    and CDI named beans, without needing to implement any JavaScript code or having
    to parse JSON strings to implement Ajax with JSF.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following illustrates a typical usage of the `<f:ajax>` tag:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'After deploying our application, the preceding page renders as illustrated
    in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ba04663c-2313-471b-9b86-7d2275a284f7.png)'
  prefs: []
  type: TYPE_IMG
- en: The preceding page illustrates two uses of the `<f:ajax>` tag. At the top of
    the page, we use this tag by implementing a typical Ajax Echo example, in which
    we have a `<h:outputText>` component updating itself with the value of an input
    text component. Whenever any character is entered into the input field, the value
    of the `<h:outputText>` component is automatically updated.
  prefs: []
  type: TYPE_NORMAL
- en: To implement the functionality described in the previous paragraph, we put an
    `<f:ajax>` tag inside an `<h:inputText>` tag. The value of the `render` attribute
    of the `<f:ajax>` tag must correspond to the ID of a component we want to update
    after the Ajax request finishes. In our particular example, we want to update
    the `<h:outputText>` component with an ID of `textVal`, therefore this is the
    value we use for the render attribute of our `<f:ajax>` tag.
  prefs: []
  type: TYPE_NORMAL
- en: In some cases we may need to render more than one JSF component after an Ajax
    event finishes. In order to accommodate this, we can add several IDs as the value
    of the `render` attribute, we simply need to separate them by spaces.
  prefs: []
  type: TYPE_NORMAL
- en: The other `<f:ajax>` attribute we used in this instance is the `event` attribute.
    This attribute indicates the JavaScript event that triggers the Ajax event. In
    this particular case we need to trigger the event any time a key is released while
    a user is typing into the input field; therefore the appropriate event is to use
    is `keyup`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following table lists all supported JavaScript events:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Event** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `blur` | The component loses focus. |'
  prefs: []
  type: TYPE_TB
- en: '| `change` | The component loses focus and its value has been modified. |'
  prefs: []
  type: TYPE_TB
- en: '| `click` | The component is clicked on. |'
  prefs: []
  type: TYPE_TB
- en: '| `dblclick` | The component is double-clicked on. |'
  prefs: []
  type: TYPE_TB
- en: '| `focus` | The component gains focus. |'
  prefs: []
  type: TYPE_TB
- en: '| `keydown` | A key is pressed while the component has focus. |'
  prefs: []
  type: TYPE_TB
- en: '| `keypress` | A key is pressed or held down while the component has focus.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `keyup` | A key is released while the component has focus. |'
  prefs: []
  type: TYPE_TB
- en: '| `mousedown` | Mouse button is pressed while the component has focus. |'
  prefs: []
  type: TYPE_TB
- en: '| `mousemove` | Mouse pointer is moved over the component. |'
  prefs: []
  type: TYPE_TB
- en: '| `mouseout` | Mouse pointer leaves the component. |'
  prefs: []
  type: TYPE_TB
- en: '| `mouseover` | Mouse pointer is placed over the component. |'
  prefs: []
  type: TYPE_TB
- en: '| `mouseup` | Mouse button is released while the component has focus. |'
  prefs: []
  type: TYPE_TB
- en: '| `select` | The component''s text is selected. |'
  prefs: []
  type: TYPE_TB
- en: '| `valueChange` | Equivalent to change; the component loses focus and its value
    has been modified. |'
  prefs: []
  type: TYPE_TB
- en: We use `<f:ajax>` once again further down in the page, to Ajax-enable a command
    button component. In this instance, we want to recalculate a value based on the
    value of two input components. In order to have the values on the server updated
    with the latest user input, we used the `execute` attribute of `<f:ajax>`; this
    attribute takes a space-separated list of component IDs for use as input. We then
    use the `render` attribute just like before to specify which components need to
    be re-rendered after the Ajax request finishes.
  prefs: []
  type: TYPE_NORMAL
- en: Notice we are using the `actionListener` attribute of `<h:commandButton>`. This
    attribute is typically used whenever we don't need to navigate to another page
    after clicking the button. The value for this attribute is an `action listener`
    method we wrote in one of our named beans. `Action listener` methods must return
    `void`, and take an instance of `javax.faces.event.ActionEvent` as its sole parameter.
  prefs: []
  type: TYPE_NORMAL
- en: 'The named bean for our application looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Notice that we didn't have to do anything special in our named bean to enable
    Ajax in our application. It is all controlled by the `<f:ajax>` tag on the page.
  prefs: []
  type: TYPE_NORMAL
- en: As we can see from this example, Ajax-enabling JSF applications is very simple;
    we simply need to use a single tag to Ajax-enable our page, without having to
    write a single line of JavaScript, JSON, or XML.
  prefs: []
  type: TYPE_NORMAL
- en: JSF HTML5 support
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: HTML5 is the latest version of the HTML specification and includes several improvements
    over the previous version of HTML. Modern versions of JSF include several features
    to make JSF pages work nicely with HTML5.
  prefs: []
  type: TYPE_NORMAL
- en: HTML5-friendly markup
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Through the use of pass-through elements, we can develop our pages using HTML5
    and also treat them as JSF components. To do this, we need to specify at least
    one element attributes using [http://xmlns.jcp.org/jsf namespace](http://xmlns.jcp.org/jsf%20namespace).
    The following example demonstrates this approach in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The first thing we should notice about the preceding example is the XML namespace
    prefixed by `jsf` near the top of the page. This namespace allows us to add JSF-specific
    attributes to HTML5 pages. When the JSF runtime encounters attributes prefixed
    by `jsf` in any of the tags on the page, it automatically converts the HTML5 tag
    to the equivalent JSF component. JSF-specific attributes are the same as in regular
    JSF pages, except they are prefixed with `jsf` therefore, at this point, they
    should be self-explanatory and will not be discussed in detail.
  prefs: []
  type: TYPE_NORMAL
- en: The preceding example will render and behave just like the first example in
    this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: The technique described in this section is useful if we have experienced HTML
    web designers in our team who prefer to have full control over the look of the
    page. The pages are developed using standard HTML5 with JSF-specific attributes
    so that the JSF runtime can manage user input.
  prefs: []
  type: TYPE_NORMAL
- en: If our team consists primarily of Java developers with limited CSS/HTML knowledge,
    then it is preferable to develop the web pages for our web application using JSF
    components. HTML5 introduced several new attributes that didn't exist in previous
    versions of HTML. For this reason, JSF 2.2 introduced the ability to add arbitrary
    attributes to JSF components; this JSF/HTML5 integration technique is discussed
    in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Pass-through attributes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'JSF allows the definition of any arbitrary attributes (not processed by the
    JSF engine); these attributes are simply rendered as-is on the generated HTML
    displayed in the browser. The following example is a new version of an earlier
    example in this chapter, modified to take advantage of the HTML5 pass-through
    attributes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: The first thing we should notice about this example is the addition of the `http://xmlns.jcp.org/jsf/passthrough">http://xmlns.jcp.org/jsf/passthrough`
    namespace, which allows us to add any arbitrary attributes to our JSF components.
  prefs: []
  type: TYPE_NORMAL
- en: In our example, we added the HTML5 `placeholder` attribute to all input text
    fields in our page; as we can see, we need it to be prefixed by the defined prefix
    for the namespace at the top of the application (`p`, in our case). The placeholder
    HTML attribute simply adds some placeholder text to input fields that are automatically
    deleted once the user starts typing on the input field (this technique was commonly
    implemented *by hand* using JavaScript before HTML5).
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shows our updated page in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/58586e76-7ec8-4a30-b922-80a65636d3d7.png)'
  prefs: []
  type: TYPE_IMG
- en: JSF 2.2 Faces flows
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: JSF 2.2 introduced Faces flows, which defines a scope that can span several
    pages. Flow scoped beans are created when the user enters a flow (a set of web
    pages), and are destroyed when the user leaves the flow.
  prefs: []
  type: TYPE_NORMAL
- en: 'Faces flows adopts the convention over configuration principle of JSF. The
    following conventions are typically used when developing applications employing
    faces flows:'
  prefs: []
  type: TYPE_NORMAL
- en: All pages in the flow must be placed in a directory whose name defines the name
    of the flow
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An XML configuration file named after the directory name, and suffixed with
    -flow, must exist inside the directory that contains the pages in the flow (the
    file may be empty, but it must exist)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The first page in the flow must be named after the directory name that contains
    the flow
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The last page in the flow must not be located inside the directory containing
    the flow and must be named after the directory name and suffixed with -return
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following screenshot illustrates these conventions:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/625ea753-8c0a-4de8-b33c-f1c06d98b2b3.png)'
  prefs: []
  type: TYPE_IMG
- en: In the preceding example, we define a flow named `customerinfo`; by convention,
    these files are inside a directory named `customerinfo`, and the first page on
    the flow is named `customerinfo.xhtml` (there are no restrictions on the names
    of other pages in the flow). When we exit the flow, we navigate to a page named
    `flowname-return.xml`; in our case, since our flow is named `customerinfo`, the
    name of the page in question is `customerinfo-return.xhtml`, which follows the
    naming convention and takes us out of the flow.
  prefs: []
  type: TYPE_NORMAL
- en: The markup for the pages doesn't illustrate anything we haven't seen before;
    therefore we will not show it. All example code is available as part of this book's
    code download bundle.
  prefs: []
  type: TYPE_NORMAL
- en: 'All of the previous pages store data in a named bean called `Customer`, which
    has a flow of scope:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: The `@FlowScoped` annotation has a value attribute that must match the name
    of the flow that the bean is meant to work with (`customerinfo`, in this example).
  prefs: []
  type: TYPE_NORMAL
- en: This example creates a wizard-style set of pages in which data for a user is
    entered across several pages in the flow.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the first page, we enter name information:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9e5d34d5-7a57-4861-8591-7d393a686bf0.png)'
  prefs: []
  type: TYPE_IMG
- en: 'In the second page, we enter address information:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7a7d96a3-9280-4936-8a9d-f69924ca684a.png)'
  prefs: []
  type: TYPE_IMG
- en: 'In the next page, we enter phone number information:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/646ffdc1-c73e-448b-b538-0596aaa7bb4a.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Finally, we display a Confirmation page:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/77845a56-9aa1-4c2a-a2fc-f23416c8989e.png)'
  prefs: []
  type: TYPE_IMG
- en: If the user verifies that the information is correct, we navigate outside the
    flow to `customerinfo-return.xhtml`; otherwise, we go back to the first page in
    the flow to allow the user to make any necessary corrections.
  prefs: []
  type: TYPE_NORMAL
- en: Injecting JSF artifacts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The JSF specification predates CDI. As such, many JSF artifacts, such as `FacesContext`
    and `ExternalContext`, had to be obtained via `static entry` methods; this resulted
    in hard-to-read boilerplate code. JSF 2.3 introduces the ability to inject JSF
    artifacts via CDI''s `@Inject` annotation, as seen in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we need an instance of `FacesContext` so that we can send an
    arbitrary message to an `<h:messages>` component; as of JSF 2.3, we can simply
    annotate our instance of `FacesContext` with CDI's `@Inject` annotation.
  prefs: []
  type: TYPE_NORMAL
- en: '[Chapter 5](54a73845-4f4d-4129-a361-85c78007f495.xhtml), *Contexts and Dependency
    Injection,* covers CDI in detail.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In order for us to be able to successfully inject a JSF artifact into our CDI
    named beans, we need to add a CDI `beans.xml` deployment descriptor to the `WEB-INF`
    directory of our WAR file, making sure to set the `bean-discovery-mode` attribute
    of its `<beans>` tag to all:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Additionally, we need to have a class in our WAR file annotated with the `@FacesConfig`
    annotation (we use this annotation to specify we are using JSF 2.3):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: As can be seen in the preceding example, the class containing the `@FacesConfig`
    annotation doesn't have to have any code. We specify that we are using JSF 2.3
    by passing `FacesConfig.Version.JSF_2_3` as the value of the annotation's version
    attribute.
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition to illustrating how to inject the JSF artifact, this example illustrates
    a JSF feature we haven''t seen before—the ability to send arbitrary messages to
    an `<h:messages>` component via the `addMessage()` method of `FacesContext`. Next,
    we show the markup corresponding to the preceding CDI named bean:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: When the user clicks on the button generated by the `<h:commandButton>` component,
    the `saveData()` method of our CDI named bean is invoked, which in turn creates
    an instance of `FacesMessage` and passes it to the `addMessage()` method of `FacesContext`,
    resulting in the message being shown in the browser.
  prefs: []
  type: TYPE_NORMAL
- en: In case it isn't obvious, this simple example doesn't actually save any data;
    all we are illustrating here is how to pass arbitrary messages to the JSF `<h:messages>`
    component.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot assumes the user has already pressed the Save button.
    The message at the top is the result of our invocation to the `addMessage()` method
    of `FacesContext`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6a333c2a-0350-4ff5-8cdf-69e8af7a6f78.png)'
  prefs: []
  type: TYPE_IMG
- en: JSF WebSocket support
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In typical web applications, servers always respond to requests from a browser;
    there is no way for a server to send data to the client browser without responding
    to a request. **WebSocket** technology provides full duplex communication between
    a browser and a server, allowing servers to independently send data to a client,
    without having to respond to a request. WebSocket technology allows a myriad of
    new applications to be developed for the web, including updating stock tickers,
    multiplayer online games, and chat applications.
  prefs: []
  type: TYPE_NORMAL
- en: Although some of these types of web applications were developed before the advent
    of WebSockets, they relied on hacks to work around the limitations of the HTTP
    protocol. With WebSockets, these hacks are no longer necessary.
  prefs: []
  type: TYPE_NORMAL
- en: Traditionally, writing applications taking advantage of the WebSocket protocol
    required a lot of JavaScript code. JSF 2.3 introduces WebSocket support and abstracts
    out most of the JavaScript plumbing, allowing us to focus on developing the business
    logic of our applications.
  prefs: []
  type: TYPE_NORMAL
- en: The following example illustrates a simple chat application developed using
    JSF 2.3 WebSocket support.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let''s take a look at an application-scoped CDI named bean responsible
    for sending messages to all browser clients:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: As shown in the preceding example, in order to send data via WebSockets to the
    clients we need to inject an instance of an implementation of the `javax.faces.push.PushContext`
    interface, and annotate it with the `@Push` annotation. To actually send the message
    to the client, we need to invoke the `send()` method of the injected `PushContext`
    implementation; in our example, this is done in the `send()` method of our CDI
    named bean.
  prefs: []
  type: TYPE_NORMAL
- en: 'In our example, there is a session scoped CDI named bean that takes input from
    the user and passes it to the `send()` method of the preceding application scoped
    CDI named bean. Our session scoped CDI bean looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'The `sendMessage()` method of the preceding class calls the `send()` method
    of the application scoped CDI bean we discussed earlier, passing the name of the
    user and the message to be broadcast to all browsers. The aforementioned `sendMessage()`
    method is invoked via Ajax when a user clicks a button on the corresponding page,
    as shown in the following markup:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: The `<f:websocket>` tag in the preceding markup is needed to enable WebSocket
    support in our page. The value of its `channel` attribute links the page to the
    corresponding `PushContext` instance on the server (in our example, it is defined
    in the application scoped `JsfWebSocketMessageSender` CDI named bean). By convention,
    the value of the `channel` attribute must match the variable name on the corresponding
    CDI named bean (`pushContext`, in our example).
  prefs: []
  type: TYPE_NORMAL
- en: We're only showing the most relevant sections of the example; the complete example
    can be downloaded from this book's GitHub repository at [https://github.com/dheffelfinger/Java-EE-8-Application-Development-Code-Samples](https://github.com/dheffelfinger/Java-EE-8-Application-Development-Code-Samples).
  prefs: []
  type: TYPE_NORMAL
- en: 'After building and deploying our application we can see it in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/545b3456-285a-461b-b05c-a03b4b9cc01b.png)'
  prefs: []
  type: TYPE_IMG
- en: Additional JSF component libraries
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In addition to the standard JSF component libraries, there are a number of
    third-party JSF tag libraries available. The following table lists some of the
    most popular:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Tag library** | **Distributor** | **License** | **URL** |'
  prefs: []
  type: TYPE_TB
- en: '| `ICEfaces` | ICEsoft | MPL 1.1 | [http://www.icefaces.org](http://www.icefaces.org)
    |'
  prefs: []
  type: TYPE_TB
- en: '| `RichFaces` | Red Hat/JBoss | LGPL | [http://www.jboss.org/richfaces](http://www.jboss.org/richfaces)
    |'
  prefs: []
  type: TYPE_TB
- en: '| `Primefaces` | Prime Technology | Apache 2.0 | [http://www.primefaces.org](http://www.primefaces.org)
    |'
  prefs: []
  type: TYPE_TB
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we covered how to develop web-based applications using JavaServer
    Faces, the standard component framework for the Java EE platform. We looked at
    how to write a simple application by creating pages using Facelets as the view
    technology and CDI named beans. We also covered how to validate user input by
    using JSF's standard validators, by creating our own custom validators or by writing
    `validator` methods. Additionally, we covered how to customize standard JSF error
    messages, both the message text and the message style (font, color, and such).
    Also, we covered how to develop Ajax-enabled JSF pages, as well as how to integrate
    JSF and HTML5.
  prefs: []
  type: TYPE_NORMAL
