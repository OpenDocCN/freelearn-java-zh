- en: Creational Design Patterns
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建型设计模式
- en: From this chapter onward, we will be delving into the actual design patterns
    that are out there. We have already mentioned the importance of knowing and being
    able to properly make use of the different design patterns that exist.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 从本章开始，我们将深入研究实际存在的各种设计模式。我们已经提到了了解和能够正确使用不同设计模式的重要性。
- en: 'Design patterns can be thought of as best practices or even templates that
    can be used in solving specific problems. The number of problems that a developer
    will have to tackle is endless, and in many cases, different design patterns have
    to be combined. However, based on the aspects of a program on which a piece of
    code is written to solve a problem, we can split design patterns into the following
    main groups:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 可以将设计模式视为解决特定问题的最佳实践或甚至模板。开发者将不得不解决的问题数量是无限的，在许多情况下，必须结合不同的设计模式。然而，基于代码编写以解决程序中某个问题的方面，我们可以将设计模式分为以下主要类别：
- en: Creational
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建型
- en: Structural
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 结构型
- en: Behavioral
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 行为型
- en: 'This chapter will focus on the **creational design patterns**, and of course,
    we will look at them from the point of view of the Scala programming language.
    We will go through the following topics:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将专注于**创建型设计模式**，当然，我们将从Scala编程语言的角度来审视它们。我们将讨论以下主题：
- en: What are creational design patterns
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是创建型设计模式
- en: The factory method
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 工厂方法
- en: The abstract factory
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 抽象工厂
- en: Other factory design patterns
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其他工厂设计模式
- en: Lazy initialization
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 懒初始化
- en: The singleton
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单例
- en: The builder
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构造器
- en: The prototype
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 原型
- en: After formally defining the creational design patterns, we will look at each
    one of them separately in greater detail. We will focus on when and how to use
    them, when to avoid some patterns, and of course, show some relevant examples.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在正式定义创建型设计模式之后，我们将更详细地分别审视每一个。我们将关注何时以及如何使用它们，何时避免某些模式，当然，还会展示一些相关的例子。
- en: What are creational design patterns?
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是创建型设计模式？
- en: 'Creational design patterns, as the name suggests, deal with object creation.
    In some cases, creating objects in a program could involve some extra complexities,
    and creational design patterns hide these complexities in order to make the use
    of software components easier. The object creation complexity could be caused
    by any of the following:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 如其名所示，创建型设计模式处理对象创建。在某些情况下，在程序中创建对象可能涉及一些额外的复杂性，而创建型设计模式隐藏这些复杂性，以便使软件组件的使用更加容易。对象创建的复杂性可能由以下任何一个原因引起：
- en: The number of initialization parameters
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 初始化参数的数量
- en: Required validation
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 需要的验证
- en: The complexity of acquiring the required parameters
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获取所需参数的复杂性
- en: The preceding list could possibly be expanded even more and in many cases, these
    factors are present not just individually, but in combinations.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的列表可能还会进一步扩展，并且在许多情况下，这些因素不仅单独存在，而且以组合的形式存在。
- en: We will be focusing on the aspects of creational design patterns in the following
    sections of this chapter and hopefully, you will have a good understanding of
    why they are needed and how to use them in real life.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本章接下来的部分中关注创建型设计模式的各个方面，并希望你能对为什么需要它们以及如何在现实生活中使用它们有一个良好的理解。
- en: The factory method design pattern
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工厂方法设计模式
- en: The factory method design pattern exists in order to encapsulate an actual class
    instantiation. It simply provides an interface to create an object, and then the
    subclasses of the factory decide which concrete class to instantiate. This design
    pattern could become useful in cases where we want to create different objects
    during the runtime of the application. This design pattern is also helpful when
    object creation would otherwise require extra parameters to be passed by the developer.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 工厂方法设计模式的存在是为了封装实际的类实例化。它仅仅提供了一个创建对象的接口，然后工厂的子类决定实例化哪个具体的类。这种设计模式在需要在不同运行时创建不同对象的情况下可能很有用。当对象创建需要开发者传递额外的参数时，这种设计模式也很有帮助。
- en: Everything will become clearer with an example, and we will provide one in the
    following subsections.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 通过一个例子，一切都会变得清晰起来，我们将在以下小节中提供一个例子。
- en: An example class diagram
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一个示例类图
- en: For the factory method, we will be showing an example with databases. To keep
    things simple (just because the actual `java.sql.Connection` has a lot of methods),
    we will define our own `SimpleConnection` and it will have concrete implementations
    for `MySQL` and `PostgreSQL`.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 对于工厂方法，我们将通过数据库的例子来展示。为了使事情简单（因为实际的 `java.sql.Connection` 有很多方法），我们将定义自己的 `SimpleConnection`，并为
    `MySQL` 和 `PostgreSQL` 提供具体实现。
- en: 'The diagram for the connection classes looks like the following:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 连接类的图示如下：
- en: '![](img/6dbbcc16-bab6-4f54-864c-03829f38fca5.png)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6dbbcc16-bab6-4f54-864c-03829f38fca5.png)'
- en: 'Now, creating these connections will depend on the database we want to use.
    However, using them will be exactly the same because of the interface they provide.
    The actual creation might also involve some extra computations that we want to
    hide from the user and which will be relevant if we''re talking about a different
    constant for each database. That''s why we use a factory method design pattern.
    The following diagram shows how the rest of our code will be structured:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，创建这些连接将取决于我们想要使用的数据库。然而，由于它们提供的接口相同，使用它们的方式也将完全一样。实际的创建可能还涉及一些我们想要从用户那里隐藏的额外计算，这些计算在讨论每个数据库的不同常量时将是相关的。这就是我们使用工厂方法设计模式的原因。以下图示显示了我们的其余代码结构：
- en: '![](img/d77563c5-434b-4bfa-8a2d-8c148cc88e29.png)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d77563c5-434b-4bfa-8a2d-8c148cc88e29.png)'
- en: In the preceding figure, **MysqlClient** and **PgsqlClient** are the concrete
    implementations of the **DatabaseClient**. The factory method is **connect** and
    it returns a different connection in different clients. Since we override, the
    signature in the code still shows that the method returns a **SimpleConnection**,
    but the actual types are concrete. In the diagram, for clarity, we have chosen
    to show the actual returned type.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的图中，**MysqlClient** 和 **PgsqlClient** 是 **DatabaseClient** 的具体实现。工厂方法为 **connect**，它在不同客户端返回不同的连接。由于我们进行了重写，代码中的方法签名仍然显示该方法返回一个
    **SimpleConnection**，但实际上返回的是具体类型。在图中，为了清晰起见，我们选择显示实际返回的类型。
- en: A code example
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 代码示例
- en: 'From the preceding diagram, it is clear that depending on the database client
    we use, a different connection will be used and created. Now, let''s have a look
    at the code representation for the preceding diagrams. First is the `SimpleConnection`
    with its concrete implementations:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的图中可以看出，根据我们使用的数据库客户端，将使用和创建不同的连接。现在，让我们看看前面图的代码表示。首先是 `SimpleConnection`
    及其具体实现：
- en: '[PRE0]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'We use these implementations in our factory method, called `connect`. The following
    code snippet shows how we can take advantage of `connect` and how we can implement
    it in specific database clients:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在名为 `connect` 的工厂方法中使用这些实现。以下代码片段显示了如何利用 `connect` 并如何在特定数据库客户端中实现它：
- en: '[PRE1]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Using our database clients is then straightforward, as shown here:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 使用我们的数据库客户端很简单，如下所示：
- en: '[PRE2]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The preceding code example will produce the following output:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码示例将产生以下输出：
- en: '![](img/01845756-d26d-4581-be6d-33d30b57588e.png)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![](img/01845756-d26d-4581-be6d-33d30b57588e.png)'
- en: We saw how the factory method design pattern works. If we need to add another
    database client, then we can just extend `DatabaseClient` and return a class that
    extends `SimpleConnection` when we implement the `connect` method.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到了工厂方法设计模式是如何工作的。如果我们需要添加另一个数据库客户端，我们只需扩展 `DatabaseClient`，并在实现 `connect`
    方法时返回一个扩展 `SimpleConnection` 的类。
- en: The preceding choice to use an abstract class for the `DatabaseClient` and a
    trait for the `SimpleConnection` was just random. We could, of course, change
    the abstract class with a trait.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 前面选择使用抽象类作为 `DatabaseClient` 和特质作为 `SimpleConnection` 只是随机的。我们当然可以用特质替换抽象类。
- en: In other cases, the objects created by the factory method might require parameters
    in their constructor and these parameters could depend on some specific state
    or functionality of the object that owns the factory method. This is where this
    design pattern could actually shine.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在其他情况下，由工厂方法创建的对象可能在构造函数中需要参数，这些参数可能依赖于拥有工厂方法的对象的某些特定状态或功能。这正是这种设计模式可以真正发挥作用的地方。
- en: Scala alternatives
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Scala 的替代方案
- en: 'As with anything in software engineering, this design pattern could also be
    achieved using different approaches. Which one to use really boils down to the
    requirements and specific features of the application and objects being created.
    Some possible alternatives include the following:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 就像软件工程中的任何事物一样，这个设计模式也可以使用不同的方法来实现。到底使用哪种方法，实际上取决于应用程序和创建的对象的需求和特定功能。一些可能的替代方案包括以下内容：
- en: Passing the needed components to the class that needs them in the constructor
    (object composition). This, however, would mean that these components will be
    specific instances rather than new ones, every time a request for them is made.
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在构造函数中将所需的组件传递给需要它们的类（对象组合）。然而，这意味着每次请求这些组件时，它们将是特定的实例而不是新的实例。
- en: Passing a function that will create the objects we need.
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 传递一个将创建我们需要的对象的函数。
- en: Using the richness of Scala, we can avoid this design pattern or we can just
    be smarter about how we create the objects that we will be using or exposing whatever
    the factory method will be creating. There is no right or wrong way in the end.
    There is, however, a way that would make things simpler, both in terms of usage
    and maintenance, and it should be chosen by considering the specific requirements.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 利用Scala的丰富性，我们可以避免这种设计模式，或者我们可以更聪明地创建我们将要使用或暴露的对象，或者工厂方法将要创建的对象。最终，没有绝对的对错。然而，有一种方法可以使事情在用法和维护方面都更简单，这应该根据具体要求来选择。
- en: What it is good for?
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它有什么好处？
- en: As with other factories, the details of object creation are hidden. This means
    that if we change the way a specific instance has to be created, we would have
    to change only the factory methods that create it (this might involve a lot of
    creators though, depending on the design). The factory method allows us to use
    the abstract version of a class and defer the object creation to subclasses.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他工厂一样，对象创建的细节被隐藏了。这意味着如果我们需要改变特定实例的创建方式，我们只需要更改创建它的工厂方法（尽管这可能涉及到很多创建者，这取决于设计）。工厂方法允许我们使用类的抽象版本，并将对象创建推迟到子类。
- en: What it is not so good for?
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它有什么不好？
- en: 'In the preceding examples, we might quickly run into issues if we have more
    than one factory method. This would first require the programmer to implement
    many more methods, but more importantly, it could lead to the returned objects
    being incompatible. Let''s see this in a short example. First, we will declare
    another trait called `SimpleConnectionPrinter`, which will have one method that
    prints something when called:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，如果我们有多个工厂方法，我们可能会很快遇到问题。这首先要求程序员实现更多的方法，但更重要的是，它可能导致返回的对象不兼容。让我们通过一个简短的例子来看看这一点。首先，我们将声明另一个特质`SimpleConnectionPrinter`，它将有一个方法，当被调用时打印一些内容：
- en: '[PRE3]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Now, we want to change our `DatabaseClient` and name it differently (`BadDatabaseClient`).
    It will look like the following:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们想要改变我们的`DatabaseClient`并将其命名为不同的名称（`BadDatabaseClient`）。它看起来如下所示：
- en: '[PRE4]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The only difference here to our original example is that we have another factory
    method, that we will also call when executing a query. Similar to the `SimpleConnection`
    implementations, let''s now create two more for MySQL and PostgreSQL for our `SimpleConnectionPrinter`:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 与我们的原始示例相比，这里唯一的区别是我们还有一个工厂方法，我们也会在执行查询时调用它。类似于`SimpleConnection`实现，现在让我们为我们的`SimpleConnectionPrinter`创建两个更多用于MySQL和PostgreSQL的：
- en: '[PRE5]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'We can now apply the factory design pattern and create MySQL and PostgreSQL
    clients, as shown here:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以应用工厂设计模式并创建MySQL和PostgreSQL客户端，如下所示：
- en: '[PRE6]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The preceding implementations are completely valid. We can now use them in
    an example:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的实现是完全有效的。我们现在可以在一个例子中使用它们：
- en: '[PRE7]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'This example will have the following output:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子将产生以下输出：
- en: '![](img/1f6a5228-b54e-49d0-a92c-29502f749cd1.png)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1f6a5228-b54e-49d0-a92c-29502f749cd1.png)'
- en: What happened in the preceding example is that we got a logical error, and nothing
    notifies us about this. When the number of methods to implement grows, this could
    become a problem and mistakes could be easily made. For example, our code didn't throw
    an exception, but this pitfall could lead to runtime errors that could be really
    hard to discover and debug.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中发生的情况是我们遇到了逻辑错误，并且没有任何通知告诉我们这一点。当需要实现的方法数量增加时，这可能会成为一个问题，错误也容易被犯。例如，我们的代码没有抛出异常，但这个陷阱可能导致难以发现和调试的运行时错误。
- en: The abstract factory
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 抽象工厂
- en: The abstract factory is another design pattern from the family of *factory*
    patterns. The purpose is the same as all factory design patterns—to encapsulate
    the object creation logic and hide it from the user. The difference is how it
    is implemented.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 抽象工厂是*工厂*模式家族中的另一个设计模式。其目的是与所有工厂设计模式相同——封装对象创建逻辑并隐藏它。不同之处在于它的实现方式。
- en: The abstract factory design pattern relies on object composition in contrast
    to inheritance, which is used by the factory method. Here, we have a separate
    object, which provides an interface to create instances of the classes we need.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 与工厂方法使用的继承相比，抽象工厂设计模式依赖于对象组合。在这里，我们有一个单独的对象，它提供了一个接口来创建我们需要的类的实例。
- en: An example class diagram
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一个示例类图
- en: 'Let''s keep using the preceding `SimpleConnection` example here. The following
    diagram shows how the abstract factory is structured:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续使用之前的`SimpleConnection`示例。以下图显示了抽象工厂的结构：
- en: '![](img/130a3617-d23d-450b-81e8-0f4eb758362c.png)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![](img/130a3617-d23d-450b-81e8-0f4eb758362c.png)'
- en: As we can see from the preceding diagram, now we have a hierarchy of factories
    rather than a method inside our database client. We will be using the abstract
    **DatabaseConnectorFactory** in our application and it will be returning the right
    objects, depending on the actual instance type.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 如前图所示，现在我们有一个工厂的层次结构，而不是数据库客户端内部的某个方法。在我们的应用程序中，我们将使用抽象的**DatabaseConnectorFactory**，并且它将根据实际的实例类型返回正确的对象。
- en: A code example
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 代码示例
- en: 'Let''s have a look at our example from the source point of view. The following
    code listing shows the factory hierarchy:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从源代码的角度来看我们的示例。以下代码列表显示了工厂层次结构：
- en: '[PRE8]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'We can then use our factory by passing it to a class, that will call the required
    methods. Here is an example similar to the one we showed for the factory method
    design pattern:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过将其传递给一个类来使用我们的工厂，该类将调用所需的方法。以下是一个类似于我们之前展示的工厂方法设计模式的示例：
- en: '[PRE9]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Let''s see an example that uses our database client:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个使用我们的数据库客户端的示例：
- en: '[PRE10]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The following screenshot shows the output of this program:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了此程序的输出：
- en: '![](img/dc32b2bc-2570-48a4-a908-8ef4858124a3.png)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![](img/dc32b2bc-2570-48a4-a908-8ef4858124a3.png)'
- en: This is how the abstract factory design pattern works. If we need to add another
    database client to our application, we can achieve this by adding another class
    that extends `DatabaseConnectionFactory`. This is nice because it makes refactoring
    and extending easy.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是抽象工厂设计模式的工作方式。如果我们需要将另一个数据库客户端添加到我们的应用程序中，我们可以通过添加一个扩展`DatabaseConnectionFactory`的类来实现这一点。这很好，因为它使得重构和扩展变得容易。
- en: Scala alternatives
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Scala替代方案
- en: This design pattern can also be achieved using different approaches. The fact
    that we use object composition to pass a factory to our class indicates that we
    can do something else—we can simply pass a function, just because in Scala they
    are a part of unification and they are treated the same way as objects.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 这个设计模式也可以使用不同的方法实现。我们使用对象组合将工厂传递给我们的类的事实表明，我们可以做其他事情——我们只需传递一个函数，因为在Scala中，它们是统一的一部分，并且被当作对象一样对待。
- en: What it is good for?
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它适用于什么？
- en: As with all factories, the details of object creation are hidden. The abstract
    factory design pattern is particularly useful when we want to expose families
    of objects (for example, database connectors). The clients then become decoupled
    from the concrete classes. This pattern is commonly shown as an example in different
    UI toolkits, where elements differ for different operating systems. It is also
    quite testable because we can provide mocks instead of an actual factory to the
    clients.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 与所有工厂一样，对象的创建细节是隐藏的。当我们想要暴露对象家族（例如，数据库连接器）时，抽象工厂设计模式特别有用。客户端因此与具体类解耦。这个模式通常在不同的UI工具包中作为示例展示，其中元素因不同的操作系统而异。它也相当易于测试，因为我们可以向客户端提供模拟而不是实际的工厂。
- en: Even though the incompatibility problem that we mentioned previously is still
    present here, it is somewhat harder to encounter now. This is mainly because here,
    the client will actually just pass one single factory as a parameter, and in the
    case where we provide the user with concrete factories, everything was already
    taken care of when these factories were written.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们之前提到的不兼容性问题仍然存在，但现在遇到它的难度有所增加。这主要是因为在这里，客户端实际上只需传递一个单独的工厂作为参数，如果我们提供了具体的工厂，那么在编写这些工厂时，所有的事情都已经处理好了。
- en: What it is not so good for?
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它不适用于什么？
- en: It could be problematic if the objects and methods we are using (`SimpleConnection`,
    in our case) change signatures. In some cases, this pattern could also complicate
    our code unnecessarily and make it unreadable and hard to follow.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用的对象和方法（在我们的例子中是`SimpleConnection`）更改了签名，可能会出现问题。在某些情况下，这种模式也可能不必要地使我们的代码复杂化，使其难以阅读和跟踪。
- en: Other factory design patterns
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 其他工厂设计模式
- en: There are some different variations of the factory design patterns. In all cases
    though, the purpose is generally the same—hide creation complexity. In the following subsections,
    we will briefly mention two of the other factory design patterns—**static factory**
    and **simple factory**.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 工厂设计模式有多种不同的变体。不过，在所有情况下，目的通常都是相同的——隐藏创建复杂性。在接下来的小节中，我们将简要介绍两种其他的工厂设计模式——**静态工厂**和**简单工厂**。
- en: The static factory
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 静态工厂
- en: 'The static factory could be represented as a static method, which is a part
    of the base class. It is called to create concrete instances, which extend the
    base class. One of the biggest drawbacks here, however, is that if another extension
    of the base class is added, the base class (because of the static method) also
    has to be edited. Let''s show a simple example from the world of animals:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 静态工厂可以表示为一个静态方法，它是基类的一部分。它被调用以创建扩展基类的具体实例。然而，这里最大的缺点之一是，如果添加了基类的另一个扩展，由于静态方法，基类也必须被编辑。让我们从一个动物世界的简单例子来展示：
- en: '[PRE11]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Here, every time we add a new extension of `Animal`, we would have to change
    the `apply` method to account for it, especially if we want to account for the
    new types.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，每次我们添加`Animal`的新扩展时，我们都需要更改`apply`方法来考虑它，尤其是如果我们想要考虑新的类型。
- en: The preceding example uses the special apply method of the `Animal` companion
    object. We could have different versions of it and it would provide us with a
    syntactic sugar that allows us to simply use `Animal("mammal")`. This makes it
    even more convenient to use the factory, as its existence will be indicated by
    the good IDEs because of the base class.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的例子使用了`Animal`伴生对象的特殊`apply`方法。我们可以有不同的版本，它将为我们提供一种语法糖，允许我们简单地使用`Animal("mammal")`。这使得使用工厂变得更加方便，因为由于基类，其存在将由好的IDE指示。
- en: The simple factory
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简单工厂
- en: The simple factory is better than the static factory, because the actual factory
    functionality is in another class. This removes the requirement for the base class
    to be modified every time a new extension is added. This is similar to the abstract
    factory, but the difference is that here we don't have a base factory class, we
    use a concrete one instead. Usually, one starts with a simple factory, which evolves
    to abstract with time and project evolution.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 简单工厂比静态工厂更好，因为实际的工厂功能在另一个类中。这消除了每次添加新扩展时修改基类的要求。这与抽象工厂类似，但不同之处在于这里我们没有基工厂类，而是使用一个具体的类。通常，人们从一个简单的工厂开始，随着时间的推移和项目的演变，它逐渐演变为抽象工厂。
- en: Factory combinations
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工厂组合
- en: Of course, it is possible to combine different types of factories together.
    This, however, needs to be done with caution and only if necessary. Otherwise,
    overusing the design pattern could lead to bad code.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，可以将不同类型的工厂组合在一起。然而，这需要谨慎进行，并且只有在必要时才这么做。否则，过度使用设计模式可能会导致代码质量下降。
- en: Lazy initialization
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 懒加载
- en: Lazy initialization in software engineering is when we delay the instantiation
    of an object or a variable until the first time we need it. The idea behind this
    is to defer or even avoid some expensive operations.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 软件工程中的懒加载是指在第一次需要时才实例化一个对象或变量。这种做法背后的理念是推迟或甚至避免一些昂贵的操作。
- en: An example class diagram
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一个示例类图
- en: In other languages, such as Java, lazy initialization is often used in conjunction
    with the factory method design pattern. This method usually checks whether the
    object/variable we want to use is initialized; if not, it initializes the object
    and finally returns it. In consecutive uses, the already initialized object/variable
    is returned.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在其他语言中，例如Java，懒加载通常与工厂方法设计模式结合使用。这种方法通常检查我们想要使用的对象/变量是否已初始化；如果没有，它将初始化对象，并最终返回它。在连续使用中，已初始化的对象/变量将被返回。
- en: The Scala programming language has built-in support for lazy initialization.
    It makes use of the `lazy` keyword. That's why providing a class diagram in this
    case is pointless.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: Scala编程语言内置了对懒加载的支持。它使用了`lazy`关键字。这就是为什么在这种情况下提供类图是毫无意义的。
- en: A code example
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 代码示例
- en: Let's see how lazy initialization works in Scala and also prove that it is indeed
    lazy. We will look at an example that calculates a circle area. As we know, the
    formula is `pi * r²`. Programming languages have support for mathematical constants
    and this is not how we will do it in real life. However, the example is still
    relevant if we're talking about a different constant that is not widely known,
    or a constant that usually fluctuates around a value, but could be different every
    day.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看Scala中的懒加载是如何工作的，并证明它确实是懒加载的。我们将查看一个计算圆面积的示例。正如我们所知，公式是`π * r²`。编程语言支持数学常数，但这并不是我们在现实生活中会这样做的方式。然而，如果我们谈论的是一个不太为人所知的常数，或者一个通常围绕某个值波动但每天可能不同的常数，这个例子仍然相关。
- en: 'At school, we''ve been taught that pi is equal to 3.14\. This is true, however,
    there are many extra digits after that and if we really care about precision,
    we will need to account for them as well. For example, pi with 100 digits looks
    like this:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在学校，我们被教导π等于3.14。然而，这确实是正确的，但在那之后还有很多额外的数字，如果我们真的关心精度，我们也需要考虑它们。例如，100位数字的π看起来是这样的：
- en: '[PRE12]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'So, let''s create a utility that will return the area when given a circle radius.
    We will have our basic pi as a variable in our utility class, but we will also
    allow the users to decide if they want a precise area or not. If they do, we will
    read the 100-digit pi from a configuration file:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们创建一个实用工具，当给定圆的半径时，它会返回面积。在我们的实用工具类中，我们将有一个基本的π变量，但我们将允许用户决定他们是否想要精确的面积。如果他们想要，我们将从配置文件中读取100位数字的π：
- en: '[PRE13]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The preceding code does exactly what we said. Depending on precision, we will
    use a different version of pi. The lazy initialization here is useful because
    we might never ever need a precise area, or we could need it sometimes, but not
    others. Moreover, reading from a configuration file is an I/O operation, which
    is considered to be slow and it could have a negative effect when done multiple
    times. Let''s see how we use our utility:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码确实做了我们所说的。根据精度，我们将使用π的不同版本。这里的懒加载是有用的，因为我们可能永远不需要精确的面积，或者我们可能有时需要，有时不需要。此外，从配置文件中读取是一个I/O操作，被认为是慢的，并且当多次执行时可能会产生负面影响。让我们看看我们如何使用我们的实用工具：
- en: '[PRE14]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The output of this program will be the following:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 这个程序的输出将是以下内容：
- en: '![](img/ce5f3f84-1ff5-49bf-9d0e-51427e29de4a.png)'
  id: totrans-115
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/ce5f3f84-1ff5-49bf-9d0e-51427e29de4a.png)'
- en: We can have a few observations from our example output. First, the precision
    really matters and there are industries out there including financial institutions,
    space industry, and so on where precision is taken really seriously. Second, in
    the lazy initialization block, we used a `print` statement and it is printed when
    we used the precise implementation for the first time. Normal values get initialized
    when the instance is created. This shows that indeed, lazy initialization in Scala
    defers it until the variable is used for the first time.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以从我们的示例输出中得出一些观察结果。首先，精度确实很重要，有些行业，包括金融机构、航天工业等，对精度非常重视。其次，在懒加载初始化块中，我们使用了`print`语句，并且它是在我们第一次使用精确实现时打印的。正常值在实例创建时初始化。这表明，Scala中的懒加载确实是在变量第一次使用时才进行初始化。
- en: What it is good for?
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它有什么好处？
- en: Lazy initialization is particularly useful when initializing an object or variable
    that would take too long or might not even be needed. Some might say that we can
    simply use methods, and this is partly true. However, imagine a case where we
    might need to access a lazily initialized variable/object from multiple methods
    in different calls to our object. In this case, it is useful to store the result
    somewhere and just reuse it.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 懒加载初始化在初始化一个耗时过长或可能根本不需要的对象或变量时特别有用。有些人可能会说我们可以简单地使用方法，这在某种程度上是正确的。然而，想象一下，我们可能需要在对象的多次调用中从多个方法访问一个懒加载的变量/对象。在这种情况下，将结果存储在某个地方并重复使用它是很有用的。
- en: What it is not so good for?
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它不适用于什么？
- en: In languages other than Scala, some special care needs to be taken when lazy
    initialization is used in a multithreaded setting. In Java, for example, you need
    to do initialization in a `synchronized` block. In order to provide even better
    safety, *double-checked locking* is preferred. There is no such danger in Scala.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在Scala以外的语言中，当在多线程环境中使用懒加载时，需要特别注意。例如，在Java中，你需要在一个`synchronized`块中进行初始化。为了提供更好的安全性，*双重检查锁定*是首选的。在Scala中没有这样的危险。
- en: The singleton design pattern
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 单例设计模式
- en: The singleton design pattern ensures that a class has only one object instance
    in the entire application. It introduces a global state in the applications it
    is used in.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 单例设计模式确保在整个应用程序中，一个类只有一个对象实例。它在使用的应用程序中引入了全局状态。
- en: A singleton object can be initialized using different strategies—lazy initialization
    or eager initialization. This all depends on the intended use, the time it takes
    an object to be initialized, and so on.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 单例对象可以使用不同的策略进行初始化——懒加载初始化或急加载初始化。这完全取决于预期的用途、对象初始化所需的时间等因素。
- en: An example class diagram
  id: totrans-124
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一个示例类图
- en: Singletons are another example of design patterns, which are supported out of
    the box by the Scala programming language syntax. We achieve this by using the
    object keyword. In this case, again, providing a class diagram is not necessary,
    so we will step right into the example in the next subsection.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 单例是设计模式的一个例子，Scala编程语言的语法默认支持这些模式。我们通过使用对象关键字来实现这一点。在这种情况下，再次提供类图是不必要的，所以我们将直接进入下一小节的示例。
- en: A code example
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一个代码示例
- en: 'The aim of this example is to show how to create singleton instances in Scala
    and have an understanding of when exactly instances are created in Scala. We will
    look at a class called `StringUtils`, that provides different utility methods
    related to strings:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 本例的目的是展示如何在Scala中创建单例实例，并理解在Scala中实例的确切创建时间。我们将查看一个名为 `StringUtils` 的类，它提供了与字符串相关的不同实用方法：
- en: '[PRE15]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Using this class is then straightforward. Scala takes care of creating the
    object, thread safety, and so on:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 使用此类非常简单。Scala会负责创建对象、线程安全等：
- en: '[PRE16]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The output from this program will be the following:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 这个程序的输出将是以下内容：
- en: '![](img/9771e011-9d3c-4492-acbf-30cc6c4e4d03.png)'
  id: totrans-132
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9771e011-9d3c-4492-acbf-30cc6c4e4d03.png)'
- en: 'The preceding example is clear and even though the `StringUtils` object will
    be a singleton instance, it more resembles a class with static methods. This is
    actually how static methods are defined in Scala. It would be more interesting
    to add some state to a singleton class. The following example shows exactly this:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的例子很清晰，尽管 `StringUtils` 对象将是一个单例实例，但它更像是一个具有静态方法的类。这实际上就是在Scala中定义静态方法的方式。给单例类添加一些状态会更有趣。以下示例正好展示了这一点：
- en: '[PRE17]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The `AppRegistry` contains a concurrent map of all the users currently using
    the application. This is our global state and we have methods that allow us to
    manipulate it. We also have a `println` statement, which will be executed when
    the singleton instance is created. We can use our registry in the following application:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '`AppRegistry` 包含了一个所有当前使用应用程序的用户并发映射。这是我们全局状态，我们有一些方法可以操作它。我们还有一个 `println`
    语句，当单例实例创建时将会执行。我们可以在以下应用程序中使用我们的注册表：'
- en: '[PRE18]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Let''s run this example and see what the final output will be:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们运行这个示例，看看最终的输出会是什么：
- en: '![](img/c22edb63-6a1a-4530-a5e7-b991915f526e.png)'
  id: totrans-138
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c22edb63-6a1a-4530-a5e7-b991915f526e.png)'
- en: 'Now, our example presents a proper singleton instance, which contains a global
    state. This state will be accessible from all the application classes while the
    instance runs. From the example code and our output, we can make a few conclusions:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们的例子展示了一个合适的单例实例，它包含一个全局状态。在实例运行期间，所有应用程序类都可以访问这个状态。从示例代码和我们的输出中，我们可以得出一些结论：
- en: Singletons in Scala are lazily initialized
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Scala中的单例是懒加载的
- en: While creating a singleton instance, we cannot provide dynamic parameters to
    the singleton class instance
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在创建单例实例时，我们不能向单例类实例提供动态参数
- en: What it is good for?
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它有什么好处？
- en: In Scala, the singleton design pattern and static methods are implemented the
    same way. That's why singletons are useful for creating utility classes that have
    no state. Singletons in Scala can also be used to build ADTs, which we talked
    about in the previous chapters.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在Scala中，单例设计模式和静态方法以相同的方式进行实现。这就是为什么单例对于创建无状态的实用类非常有用。Scala中的单例还可以用来构建ADT（抽象数据类型），这在之前的章节中已经讨论过。
- en: Another thing that is strictly valid for Scala is that in Scala, singletons
    are created in a thread-safe way out of the box and without the need to take any
    special care.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Scala来说，还有一个严格有效的事实，那就是在Scala中，单例（singleton）是默认以线程安全的方式创建的，无需采取任何特殊措施。
- en: What it is not so good for?
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它有什么坏处？
- en: Often, the singleton design pattern is actually considered an anti-pattern.
    Many people say that global state should not exist the way it does with singleton
    classes. Some say that if you have to use singletons, you should try and refactor
    your code. While this is true in some cases, there is sometimes a good use for
    singletons. Generally, the rule of thumb is—if you can avoid them, then do.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，单例设计模式实际上被认为是反模式。许多人说全局状态不应该像单例类那样存在。有些人说，如果你必须使用单例，你应该尝试重构你的代码。虽然这在某些情况下是正确的，但有时单例也有其合理的使用场景。一般来说，一个经验法则是——如果你能避免使用它们，那么就避免使用。
- en: Another thing that could be pointed out specifically for Scala singletons is
    that they can really have only one instance. While this is the actual definition
    of the pattern, with other languages, we could have a predefined number of more
    than just one singleton object and have some control on this using custom logic.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Scala单例，还有一点需要特别指出，那就是它们确实只能有一个实例。虽然这是模式的实际定义，但在其他语言中，我们可能有一个预定义的多个单例对象，并可以通过自定义逻辑来控制这一点。
- en: This does not really affect Scala but it is still worth mentioning. In the case
    where a singleton is initialized lazily in an application, in order to provide
    thread safety, you need to rely on locking mechanisms, for example, the double-checked
    locking mentioned in the previous section. Accessing the singletons in an application,
    no matter if it's Scala or not, also needs to be done in a thread-safe way or
    the singleton should take care of this internally.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 这实际上并不影响Scala，但仍值得一提。在单例在应用程序中懒加载的情况下，为了提供线程安全，你需要依赖锁定机制，例如，前一小节中提到的双重检查锁定。无论是否是Scala，应用程序中对单例的访问也需要以线程安全的方式进行，或者单例应该内部处理这个问题。
- en: The builder design pattern
  id: totrans-149
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建设计模式
- en: The builder design pattern helps to create instances of classes using class
    methods rather than the class constructors. It is particularly useful in cases
    where a class might need multiple versions of its constructor in order to allow
    different usage scenarios.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 构建设计模式有助于使用类方法而不是类构造函数来创建类的实例。它在类可能需要多个构造函数版本以允许不同的使用场景的情况下特别有用。
- en: Moreover, in some cases, it might not even be possible to define all combinations
    or they might not be known. The builder design pattern uses an extra object, called
    `builder`, in order to receive and store initialization parameters before building
    the final version of an object.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，在某些情况下，甚至可能无法定义所有组合，或者它们可能未知。构建设计模式使用一个额外的对象，称为`builder`，来接收和存储在构建最终版本的对象之前的初始化参数。
- en: An example class diagram
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一个示例类图
- en: In this subsection, we will provide a class diagram for the builder pattern
    the way it was classically defined and the way it looks in other languages, including
    Java. Later, we will present different versions of the code on the basis of them
    being more appropriate for Scala and of the observations and discussions we will
    have around them.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在本小节中，我们将提供构建模式的类图，包括其经典定义和在其他语言（包括Java）中的样子。稍后，我们将基于它们更适合Scala以及我们对它们的观察和讨论，展示不同版本的代码。
- en: Let's have a `Person` class with different parameters—`firstName`, `lastName`,
    `age`, `departmentId`, and so on. We will show the actual code for it in the next
    subsection. Creating a concrete constructor, especially if those fields might
    not always be known or required, might take too much time. It would also make
    the code extremely hard to maintain in the future.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们有一个具有不同参数的`Person`类——`firstName`、`lastName`、`age`、`departmentId`等等。我们将在下一小节中展示它的实际代码。创建一个具体的构造函数，尤其是如果这些字段可能不是总是已知或必需的，可能会花费太多时间。这也会使未来的代码维护变得极其困难。
- en: 'A builder pattern seems like a good idea and the class diagram for it will
    look like the following:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 构建模式听起来是个好主意，其类图看起来如下：
- en: '![](img/7d5f9ce8-7791-4b38-abed-7a3184484666.png)'
  id: totrans-156
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/7d5f9ce8-7791-4b38-abed-7a3184484666.png)'
- en: As we already mentioned, this is how the builder pattern looks in purely object-oriented
    languages (not Scala). There could be different representations of it where the
    builder is abstracted, and then there are concrete builders. The same is true
    for the product that is being built. In the end, they all aim to get to the same
    point—make object creation easier.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们之前提到的，这是纯面向对象语言（非Scala）中构建模式的样子。它可能有不同的表示形式，其中构建器被抽象化，然后有具体的构建器。对于正在构建的产品也是如此。最终，它们都旨在达到同一个目标——使对象创建更容易。
- en: In the next subsection, we will provide code implementations that will show
    exactly how to use and write the builder design pattern in Scala.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个小节中，我们将提供代码实现，以展示如何在Scala中使用和编写建造者设计模式。
- en: A code example
  id: totrans-159
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 代码示例
- en: 'There are actually three main ways in which we can represent the builder design
    pattern in Scala:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，我们有三种主要方式可以在Scala中表示建造者设计模式：
- en: The classical way, as shown in the preceding diagram, is like other object-oriented
    languages. This way is actually not recommended, even though it is possible in
    Scala. It uses mutability in order to work, which contradicts the immutability
    principle of the language. We will show it here for completeness and in order
    to point out how much easier it is to achieve the builder design pattern using
    simple features of Scala.
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 经典的方式，如前面图所示，类似于其他面向对象的语言。实际上，虽然这在Scala中是可能的，但这种方式并不推荐。它使用可变性来工作，这与语言的不可变性原则相矛盾。我们将在这里展示它以示完整，并指出使用Scala的简单特性实现建造者模式有多容易。
- en: Using case classes with default parameters. We will see two versions—one that
    validates the parameters and another one that doesn't.
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用具有默认参数的案例类。我们将看到两个版本——一个验证参数，另一个不验证。
- en: Using generalized type constraints.
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用泛型类型约束。
- en: We will focus on these in the next few subsections. In order to keep things
    short and simple, we will have fewer fields in our classes; however, it has to
    be noted that the builder design pattern really shines when there is a large number
    of fields. You can experiment by adding more fields to the code examples that
    are provided in this book.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的几个小节中，我们将重点关注这些内容。为了使内容简短明了，我们将在类中减少字段数量；然而，需要注意的是，当字段数量较多时，建造者设计模式才能真正发挥其优势。您可以通过向本书提供的代码示例中添加更多字段来实验。
- en: A Java-like implementation
  id: totrans-165
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类似Java的实现
- en: 'This implementation directly reflects what we have in the previous diagram.
    First, let''s see what our `Person` class will look like:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 这种实现直接反映了我们之前图中的内容。首先，让我们看看我们的`Person`类将是什么样子：
- en: '[PRE19]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'As we can see in the preceding code, it takes a builder and uses the values
    set in the builder for initialization of its fields. The builder code will look
    like the following:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 如前述代码所示，它需要一个建造者，并使用在建造者中设置的值来初始化其字段。建造者代码将如下所示：
- en: '[PRE20]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Our builder has methods that can set each corresponding field of the `Person`
    class. These methods return the same instance of the builder and this allows us
    to chain many calls together. Here is how we can use our builder:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的建造者有可以设置`Person`类每个相应字段的方法。这些方法返回相同的建造者实例，这使得我们可以将多个调用链接在一起。以下是我们可以如何使用我们的建造者：
- en: '[PRE21]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: This is how to use the builder design pattern. Now, we can create a `Person`
    object and provide whatever data we have for it—even if we have a subset of all
    possible fields, we can specify them and the rest will have a default value. There
    is no need to create new constructors if other fields are being added to the `Person`
    class. They just need to be made available through the `PersonBuilder` class.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是如何使用建造者设计模式。现在，我们可以创建一个`Person`对象，并为其提供我们拥有的任何数据——即使我们只有所有可能字段的一个子集，我们也可以指定它们，其余的将具有默认值。如果向`Person`类添加其他字段，无需创建新的构造函数。它们只需通过`PersonBuilder`类提供即可。
- en: Implementation with a case class
  id: totrans-173
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用案例类实现
- en: The preceding builder design pattern looks nice and clear, but it requires writing
    some extra code and creating boilerplate. Moreover, it requires us to have mutable
    fields in the `PersonBuilder` class, which is against some of the principles in
    Scala.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的建造者设计模式看起来很清晰，但需要编写一些额外的代码和创建样板代码。此外，它要求我们在`PersonBuilder`类中拥有可变字段，这与Scala的一些原则相矛盾。
- en: Preferring immutability
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 偏好不可变性
- en: Immutability is an important principle in Scala and it should be preferred.
    The builder design pattern with case classes uses immutable fields and this is
    considered a good practice.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 不可变性是Scala中的一个重要原则，应该优先考虑。使用案例类的建造者设计模式使用不可变字段，这被认为是一种良好的实践。
- en: 'Scala has case classes, which make the implementation of the builder pattern
    much simpler. Here is what it will look like:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: Scala具有案例类，这使得建造者模式的实现变得更加简单。以下是它的样子：
- en: '[PRE22]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The use of this case class is similar to how the preceding builder design pattern
    is used:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 使用此案例类的方式与前面提到的建造者设计模式的使用方式相似：
- en: '[PRE23]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The preceding code is much shorter and easier to maintain than the first version.
    It allows the developer to do absolutely the same as the original builder pattern,
    but with a shorter and cleaner syntax. It also keeps the fields of the `Person`
    class immutable, which is a good practice to follow in Scala.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码比第一个版本更短，更容易维护。它允许开发者以绝对相同的方式使用原始构建器模式，但语法更简洁。它还保持了`Person`类的字段不可变，这是在Scala中遵循的良好实践。
- en: Choosing default values
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 选择默认值
- en: The choice of default values for the builder design pattern is entirely up to
    the developer. Some would prefer to use `Option` and put `None` when there is
    no value specified. Others might assign some different special values. This choice
    can be dictated by personal choice, the problem that is being solved, the style
    guides employed by an engineering team, and more.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 构建器设计模式的默认值选择完全取决于开发者。有些人可能更喜欢使用`Option`并在没有指定值时使用`None`。其他人可能会分配一些不同的特殊值。这个选择可以由个人选择、正在解决的问题、工程团队采用的风格指南等因素决定。
- en: One drawback of the preceding two approaches is that there is no validation.
    What if some components depended on each other and there are specific variables
    that require initialization? In the cases that use the preceding two approaches,
    we could run into runtime exceptions. The next subsection will show us how to
    make sure that validation and requirement satisfactions are implemented.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 前两种方法的一个缺点是没有验证。如果某些组件相互依赖，并且存在需要初始化的特定变量，会怎样呢？在使用前两种方法的案例中，我们可能会遇到运行时异常。下一小节将展示如何确保验证和需求满足得到实现。
- en: Using generalized type constraints
  id: totrans-185
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用通用类型约束
- en: In many cases in which we create objects in software engineering, we have dependencies.
    We either need to have something initialized in order to use a third component,
    or we require a specific order of initialization, and so on. Both builder pattern
    implementations we looked at earlier lack the capability to make sure something
    is or isn't initialized. This way, we need to create some extra validation around
    the builder design pattern in order to make sure everything will work as expected,
    yet we will see whether it is safe to create an object only during runtime.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在软件工程中创建对象时，我们常常会遇到依赖关系。我们可能需要初始化某些内容才能使用第三方组件，或者需要特定的初始化顺序，等等。我们之前讨论的两种构建器模式实现都缺乏确保某些内容是否初始化的能力。因此，我们需要在构建器设计模式周围创建一些额外的验证，以确保一切按预期工作，同时我们还将看到是否在运行时创建对象是安全的。
- en: Using some of the techniques we already looked at earlier in this book, we can
    create a builder that validates whether all requirements are satisfied during
    compile time. This is called a **type-safe builder**, and in the next example,
    we will present this pattern.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用本书前面已经讨论的一些技术，我们可以在编译时创建一个验证所有需求是否得到满足的构建器。这被称为**类型安全的构建器**，在下一个示例中，我们将展示这个模式。
- en: Changing the Person class
  id: totrans-188
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 修改Person类
- en: 'First of all, we start with the same classes as we have in the example where
    we showed the way in which Java uses the builder pattern. Now, let''s put a constraint
    on the example and say that every person must have at least `firstName` and `lastName`
    specified. In order to make the compiler aware that fields are being set, this
    needs to be encoded as a type. We will be using ADTs for this purpose. Let''s
    define the following:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们以我们在示例中展示Java如何使用构建器模式的相同类开始。现在，让我们对示例施加一个约束，即每个人必须指定至少`firstName`和`lastName`。为了使编译器意识到字段正在被设置，这需要编码为一个类型。我们将为此目的使用ADTs。让我们定义以下内容：
- en: '[PRE24]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The preceding abstract data types define the different steps of the build progress.
    Now, let''s make some refactoring to the builder class and the `Person` class:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 上述抽象数据类型定义了构建进度的不同步骤。现在，让我们对构建器类和`Person`类进行一些重构：
- en: '[PRE25]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'We will use the full constructor for the `Person` class rather than passing
    a builder. This is to show another way of building instances and keeping the code
    simpler in the later steps. The change would require the `build` method in the
    `PersonBuilder` to change as well to:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用`Person`类的完整构造函数而不是传递一个构建器。这是为了展示另一种构建实例的方法，并在后续步骤中使代码更简单。这个更改需要将`PersonBuilder`中的`build`方法也进行更改，如下所示：
- en: '[PRE26]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'This would require all the methods we have, which returned `PersonBuilder`
    before, to return `PersonBuilder[PassedStep]` now. Also, this would make it impossible
    to create a builder using the `new` keyword because the constructor is now private.
    Let''s add some more constructor overloads:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 这将要求我们之前返回`PersonBuilder`的所有方法现在返回`PersonBuilder[PassedStep]`。此外，这将使得使用`new`关键字创建构建器变得不可能，因为构造函数现在是私有的。让我们添加一些更多的构造函数重载：
- en: '[PRE27]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'We will see how these overloads are used later. We need to allow our users
    to create a builder using another method, since all constructors are invisible
    to the outside world. That''s why we should add a companion object, as shown here:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在稍后看到这些重载是如何使用的。我们需要允许我们的用户使用另一种方法创建构建器，因为所有构造函数对外部世界都是不可见的。这就是为什么我们应该添加一个伴随对象，如下所示：
- en: '[PRE28]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The companion object uses one of the constructors we previously defined and
    it also makes sure the object returned is at the right build step.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 伴随对象使用我们之前定义的一个构造函数，并确保返回的对象处于正确的构建步骤。
- en: Adding generalized type constraints to the required methods
  id: totrans-200
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将泛型类型约束添加到必需方法中
- en: 'What we have so far, however, is still not going to satisfy our requirements
    regarding what every `Person` object should have initialized. We would have to
    change some methods in the `PersonBuilder` class. These methods are `setFirstName`,
    `setLastName`, and `build`. Here are the changes to the set methods:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，到目前为止我们所拥有的仍然不能满足我们对每个`Person`对象应该初始化的内容的要求。我们不得不更改`PersonBuilder`类中的某些方法。这些方法是`setFirstName`、`setLastName`和`build`。以下是设置方法的更改：
- en: '[PRE29]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The interesting part comes with the `build` method. Let''s have a look at the
    following initial implementation:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的部分在于`build`方法。让我们看看以下初始实现：
- en: '[PRE30]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The preceding syntax sets a generalized type constraint and says that `build`
    can only be called on a builder, which has passed the `HasLastName` step. It seems
    like we are coming close to what we wanted to achieve, but now `build` will only
    work if `setLastName` was the last of those four methods called on the builder,
    and it will still not validate the other fields. Let''s use a similar approach
    for the `setFirstName` and `setLastName` methods and chain them up so that each
    one will require the previous one to be called before. Here is what the final
    code for our `PersonBuilder` class looks like (notice the other implicits in the
    set methods):'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的语法设置了一个泛型类型约束，并说明`build`只能在已通过`HasLastName`步骤的构建器上调用。看起来我们正在接近我们想要实现的目标，但现在`build`只有在`setLastName`是最后四个在构建器上调用的方法之一时才会工作，并且它仍然不会验证其他字段。让我们为`setFirstName`和`setLastName`方法使用类似的方法，并将它们链接起来，以便每个方法都需要在调用之前调用前一个方法。以下是我们的`PersonBuilder`类的最终代码（注意设置方法中的其他隐式声明）：
- en: '[PRE31]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Using the type-safe builder
  id: totrans-207
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用类型安全构建器
- en: 'We can now use the builder to create a `Person` object:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以使用构建器创建一个`Person`对象：
- en: '[PRE32]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'If we omit one of our two required methods or rearrange them in some way, we
    will get a compilation error similar to the following (the error is for the missing
    first name):'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们省略了两个必需方法中的一个或以某种方式重新排列它们，我们将得到类似于以下编译错误（错误是针对缺失的姓氏的）：
- en: '[PRE33]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The order requirement could be considered a slight drawback, especially if it's
    not needed.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 顺序要求可以被认为是一个轻微的缺点，特别是如果它不是必需的。
- en: 'Here are some observations about our type-safe builder:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 关于我们的类型安全构建器的观察如下：
- en: Using a type-safe builder, we can require a specific call order and certain
    fields to be initialized.
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用类型安全构建器，我们可以要求特定的调用顺序和某些字段被初始化。
- en: When we require multiple fields, we have to chain them, which makes the order
    of calls important. This could make the library hard to use in some cases.
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当我们需要多个字段时，我们必须将它们链接起来，这使得调用顺序变得很重要。这可能会使库在某些情况下难以使用。
- en: Compiler messages, when the builder is not used correctly, are not really informative.
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当构建器使用不正确时，编译器消息并不真正具有信息性。
- en: The code looks pretty much similar to how it would be implemented in Java.
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代码看起来几乎与在Java中实现的方式相同。
- en: The similarity in code with Java leads to relying on mutability, which is not
    recommended.
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与Java的代码相似性导致依赖于可变性，这是不建议的。
- en: Scala allows us to have a nice and clean implementation of a builder design
    pattern, which also has requirements for order and what is initialized. This is
    a good feature, even though sometimes it could be tedious and limiting in terms
    of how exactly methods are being used.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: Scala允许我们有一个既优雅又干净的构建器设计模式实现，它还对顺序和初始化的内容有要求。这是一个很好的特性，尽管有时它在方法的具体使用上可能会显得繁琐和受限。
- en: Using require statements
  id: totrans-220
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用require语句
- en: 'The type-safe builder we showed previously is nice, but it has some drawbacks:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前展示的类型安全构建器很好，但它有一些缺点：
- en: Complexity
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 复杂性
- en: Mutability
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可变性
- en: A predefined order of initialization
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 预定义的初始化顺序
- en: 'However, it could be quite useful because it allows us to write code that will
    be checked for correct usage as soon as we compile it. Sometimes, compile-time
    validation is not required, though. If this is the case, we can make things extremely
    simple and get rid of the entire complexity using the already known case classes
    and the `require` statements:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这可能会非常有用，因为它允许我们编写在编译时就会检查正确使用的代码。尽管有时不需要编译时验证。如果是这种情况，我们可以使事情变得极其简单，并使用已知的case类和`require`语句来消除整个复杂性：
- en: '[PRE34]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'If the preceding Boolean conditions are not satisfied, our code will throw
    an `IllegalArgumentException` with the correct message. We can use our class the
    same way as we would normally use a case class:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 如果前面的布尔条件不满足，我们的代码将抛出一个带有正确信息的`IllegalArgumentException`。我们可以像通常使用case类一样使用我们的类：
- en: '[PRE35]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: As we can see, things here are much simpler, fields are immutable, and we don't
    actually have any special order of initialization. Moreover, we can put meaningful
    messages that could help us diagnose potential issues. As long as compile-time
    validation is not required, this should be the preferred method.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，这里的事情要简单得多，字段是不可变的，我们实际上没有任何特殊的初始化顺序。此外，我们可以添加有助于诊断潜在问题的有意义的信息。只要不需要编译时验证，这应该是首选的方法。
- en: What it is good for?
  id: totrans-230
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它适用于什么？
- en: The builder design pattern is really good for cases in which we need to create
    a complex object and would otherwise have to define many constructors. It makes
    the creation of objects easier and somewhat cleaner and more readable using a
    step-by-step approach.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 构建器设计模式非常适合我们需要创建复杂对象且否则不得不定义许多构造函数的情况。它通过逐步方法使对象的创建更加容易，并且更加清晰、易于阅读。
- en: What it is not so good for?
  id: totrans-232
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它不适用于什么？
- en: As we saw in our type-safe builder example, adding more advanced logic and requirements
    could involve quite a bit of work. Without this possibility, the developer will
    risk the users of their classes making more mistakes. Also, the builder contains
    quite a lot of seemingly duplicate code, especially when it is implemented using
    a Java-like code.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在类型安全的构建器示例中所见，添加更高级的逻辑和要求可能需要相当多的工作。如果没有这种可能性，开发者将面临其类用户犯更多错误的风险。此外，构建器包含相当多的看似重复的代码，尤其是在使用类似Java的代码实现时。
- en: The prototype design pattern
  id: totrans-234
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 原型设计模式
- en: The prototype design pattern is a creational design pattern that involves creating
    objects by cloning them from existing ones. Its purpose is related to performance
    and keeping it high by trying to avoid expensive calls.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 原型设计模式是一种创建型设计模式，它涉及通过克隆现有对象来创建对象。其目的是与性能相关，并试图避免昂贵的调用以保持高性能。
- en: An example class diagram
  id: totrans-236
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一个示例类图
- en: 'In languages such as Java, we usually see a class that implements an interface
    with a `clone` method, which returns a new instance of the class. Consider the
    following diagram:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 在像Java这样的语言中，我们通常看到一个实现了具有`clone`方法的接口的类，该方法返回该类的新实例。考虑以下图示：
- en: '![](img/77c11047-0f87-40e1-ba8d-9143de8f0591.png)'
  id: totrans-238
  prefs: []
  type: TYPE_IMG
  zh: '![](img/77c11047-0f87-40e1-ba8d-9143de8f0591.png)'
- en: In the next section, we will provide a code example of the prototype design
    pattern from the point of view of Scala.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将从Scala的角度提供一个原型设计模式的代码示例。
- en: A code example
  id: totrans-240
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 代码示例
- en: 'The prototype design pattern is really easy to implement in Scala. We can just
    use one of the language features. Since the prototype design pattern really resembles
    how cells in biology divide, let''s use a cell as an example:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 原型设计模式在Scala中实现起来非常简单。我们可以使用语言的一个特性。由于原型设计模式与生物细胞分裂的方式非常相似，让我们以细胞为例：
- en: '[PRE36]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'In Scala, all case classes have a `copy` method, which returns a new instance
    that is cloned from the original one. It can also change some of the original
    properties while copying. Here is some example usage of our cell:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 在Scala中，所有case类都有一个`copy`方法，该方法返回一个从原始对象克隆的新实例。它还可以在复制时更改一些原始属性。以下是我们细胞的某些示例用法：
- en: '[PRE37]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The output of this example will be this:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例的输出将是这样的：
- en: '![](img/b6aa7488-2eef-49c4-8ffe-a5305f62f39a.png)'
  id: totrans-246
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b6aa7488-2eef-49c4-8ffe-a5305f62f39a.png)'
- en: As you can see, using `copy`, we acquired different instances of our prototype
    cell.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，使用`copy`，我们获得了原型细胞的不同实例。
- en: What it is good for?
  id: totrans-248
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它适用于什么？
- en: The prototype design pattern is useful when performance is important. Using
    the `copy` method, we can get instances that otherwise take time to create. The
    slowness could be caused by some calculations performed during creation, a database
    call that retrieves data, and so on.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 当性能很重要时，原型设计模式是有用的。使用`copy`方法，我们可以获得在其他情况下需要时间来创建的实例。这种缓慢可能是由创建过程中进行的某些计算、检索数据的数据库调用等原因造成的。
- en: What it is not so good for?
  id: totrans-250
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它不适用于什么？
- en: Mistakes and side effects could be caused using shallow copies of objects, where
    the actual references point to the original instances. Also, avoiding constructors
    could lead to bad code. The prototype design pattern should be really used in
    cases where there might be a massive performance impact without it.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 使用对象的浅拷贝可能会导致错误和副作用，其中实际引用指向原始实例。避免构造函数可能会导致糟糕的代码。原型设计模式应该真正用于在没有它的情况下可能会产生巨大性能影响的情况。
- en: Summary
  id: totrans-252
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This was the first chapter of this book that focused on some specific design
    patterns. We looked at the following creational design patterns—factory method,
    abstract factory, lazy initialization, singleton, builder, and prototype. Wherever
    relevant, we presented a diagram that visually showed class relationships. Also,
    we gave typical examples and went through the possible pitfalls and recommendations
    about when to use them.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 这是本书的第一章，专注于一些特定的设计模式。我们研究了以下创建型设计模式——工厂方法、抽象工厂、延迟初始化、单例、构建器和原型。在相关的地方，我们展示了显示类关系的图表。此外，我们还给出了典型示例，并讨论了使用它们的可能陷阱和建议。
- en: In real-life software engineering, design patterns are usually combined together
    rather than being used in an isolated manner. Some examples include a prototype
    that is being supplied by a singleton instance, abstract factories that can store
    different prototypes and supply copies when objects are created, factories that
    can use builders to create instances, and so on. In some cases, design patterns
    could be interchangeable depending on the use case. For example, lazy initialization
    could be enough to lower the performance impact and could be chosen instead of
    a prototype design pattern.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 在现实生活中的软件工程中，设计模式通常是组合使用，而不是孤立地使用。一些例子包括由单例实例提供的原型，能够存储不同原型并在创建对象时提供副本的抽象工厂，能够使用构建器创建实例的工厂，等等。在某些情况下，设计模式可以根据用例进行互换。例如，延迟初始化可能足以降低性能影响，可以替代原型设计模式。
- en: In the next chapter, we will continue our journey into design patterns; this
    time, we will focus on the *structural design patterns* family.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将继续我们的设计模式之旅；这次，我们将专注于*结构型设计模式*家族。
