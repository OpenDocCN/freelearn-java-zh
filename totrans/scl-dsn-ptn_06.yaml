- en: Creational Design Patterns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: From this chapter onward, we will be delving into the actual design patterns
    that are out there. We have already mentioned the importance of knowing and being
    able to properly make use of the different design patterns that exist.
  prefs: []
  type: TYPE_NORMAL
- en: 'Design patterns can be thought of as best practices or even templates that
    can be used in solving specific problems. The number of problems that a developer
    will have to tackle is endless, and in many cases, different design patterns have
    to be combined. However, based on the aspects of a program on which a piece of
    code is written to solve a problem, we can split design patterns into the following
    main groups:'
  prefs: []
  type: TYPE_NORMAL
- en: Creational
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Structural
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Behavioral
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This chapter will focus on the **creational design patterns**, and of course,
    we will look at them from the point of view of the Scala programming language.
    We will go through the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: What are creational design patterns
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The factory method
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The abstract factory
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Other factory design patterns
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Lazy initialization
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The singleton
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The builder
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The prototype
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: After formally defining the creational design patterns, we will look at each
    one of them separately in greater detail. We will focus on when and how to use
    them, when to avoid some patterns, and of course, show some relevant examples.
  prefs: []
  type: TYPE_NORMAL
- en: What are creational design patterns?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Creational design patterns, as the name suggests, deal with object creation.
    In some cases, creating objects in a program could involve some extra complexities,
    and creational design patterns hide these complexities in order to make the use
    of software components easier. The object creation complexity could be caused
    by any of the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The number of initialization parameters
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Required validation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The complexity of acquiring the required parameters
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The preceding list could possibly be expanded even more and in many cases, these
    factors are present not just individually, but in combinations.
  prefs: []
  type: TYPE_NORMAL
- en: We will be focusing on the aspects of creational design patterns in the following
    sections of this chapter and hopefully, you will have a good understanding of
    why they are needed and how to use them in real life.
  prefs: []
  type: TYPE_NORMAL
- en: The factory method design pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The factory method design pattern exists in order to encapsulate an actual class
    instantiation. It simply provides an interface to create an object, and then the
    subclasses of the factory decide which concrete class to instantiate. This design
    pattern could become useful in cases where we want to create different objects
    during the runtime of the application. This design pattern is also helpful when
    object creation would otherwise require extra parameters to be passed by the developer.
  prefs: []
  type: TYPE_NORMAL
- en: Everything will become clearer with an example, and we will provide one in the
    following subsections.
  prefs: []
  type: TYPE_NORMAL
- en: An example class diagram
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For the factory method, we will be showing an example with databases. To keep
    things simple (just because the actual `java.sql.Connection` has a lot of methods),
    we will define our own `SimpleConnection` and it will have concrete implementations
    for `MySQL` and `PostgreSQL`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The diagram for the connection classes looks like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6dbbcc16-bab6-4f54-864c-03829f38fca5.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, creating these connections will depend on the database we want to use.
    However, using them will be exactly the same because of the interface they provide.
    The actual creation might also involve some extra computations that we want to
    hide from the user and which will be relevant if we''re talking about a different
    constant for each database. That''s why we use a factory method design pattern.
    The following diagram shows how the rest of our code will be structured:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d77563c5-434b-4bfa-8a2d-8c148cc88e29.png)'
  prefs: []
  type: TYPE_IMG
- en: In the preceding figure, **MysqlClient** and **PgsqlClient** are the concrete
    implementations of the **DatabaseClient**. The factory method is **connect** and
    it returns a different connection in different clients. Since we override, the
    signature in the code still shows that the method returns a **SimpleConnection**,
    but the actual types are concrete. In the diagram, for clarity, we have chosen
    to show the actual returned type.
  prefs: []
  type: TYPE_NORMAL
- en: A code example
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'From the preceding diagram, it is clear that depending on the database client
    we use, a different connection will be used and created. Now, let''s have a look
    at the code representation for the preceding diagrams. First is the `SimpleConnection`
    with its concrete implementations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'We use these implementations in our factory method, called `connect`. The following
    code snippet shows how we can take advantage of `connect` and how we can implement
    it in specific database clients:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Using our database clients is then straightforward, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code example will produce the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/01845756-d26d-4581-be6d-33d30b57588e.png)'
  prefs: []
  type: TYPE_IMG
- en: We saw how the factory method design pattern works. If we need to add another
    database client, then we can just extend `DatabaseClient` and return a class that
    extends `SimpleConnection` when we implement the `connect` method.
  prefs: []
  type: TYPE_NORMAL
- en: The preceding choice to use an abstract class for the `DatabaseClient` and a
    trait for the `SimpleConnection` was just random. We could, of course, change
    the abstract class with a trait.
  prefs: []
  type: TYPE_NORMAL
- en: In other cases, the objects created by the factory method might require parameters
    in their constructor and these parameters could depend on some specific state
    or functionality of the object that owns the factory method. This is where this
    design pattern could actually shine.
  prefs: []
  type: TYPE_NORMAL
- en: Scala alternatives
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As with anything in software engineering, this design pattern could also be
    achieved using different approaches. Which one to use really boils down to the
    requirements and specific features of the application and objects being created.
    Some possible alternatives include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Passing the needed components to the class that needs them in the constructor
    (object composition). This, however, would mean that these components will be
    specific instances rather than new ones, every time a request for them is made.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Passing a function that will create the objects we need.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the richness of Scala, we can avoid this design pattern or we can just
    be smarter about how we create the objects that we will be using or exposing whatever
    the factory method will be creating. There is no right or wrong way in the end.
    There is, however, a way that would make things simpler, both in terms of usage
    and maintenance, and it should be chosen by considering the specific requirements.
  prefs: []
  type: TYPE_NORMAL
- en: What it is good for?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As with other factories, the details of object creation are hidden. This means
    that if we change the way a specific instance has to be created, we would have
    to change only the factory methods that create it (this might involve a lot of
    creators though, depending on the design). The factory method allows us to use
    the abstract version of a class and defer the object creation to subclasses.
  prefs: []
  type: TYPE_NORMAL
- en: What it is not so good for?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the preceding examples, we might quickly run into issues if we have more
    than one factory method. This would first require the programmer to implement
    many more methods, but more importantly, it could lead to the returned objects
    being incompatible. Let''s see this in a short example. First, we will declare
    another trait called `SimpleConnectionPrinter`, which will have one method that
    prints something when called:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we want to change our `DatabaseClient` and name it differently (`BadDatabaseClient`).
    It will look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The only difference here to our original example is that we have another factory
    method, that we will also call when executing a query. Similar to the `SimpleConnection`
    implementations, let''s now create two more for MySQL and PostgreSQL for our `SimpleConnectionPrinter`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now apply the factory design pattern and create MySQL and PostgreSQL
    clients, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding implementations are completely valid. We can now use them in
    an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'This example will have the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1f6a5228-b54e-49d0-a92c-29502f749cd1.png)'
  prefs: []
  type: TYPE_IMG
- en: What happened in the preceding example is that we got a logical error, and nothing
    notifies us about this. When the number of methods to implement grows, this could
    become a problem and mistakes could be easily made. For example, our code didn't throw
    an exception, but this pitfall could lead to runtime errors that could be really
    hard to discover and debug.
  prefs: []
  type: TYPE_NORMAL
- en: The abstract factory
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The abstract factory is another design pattern from the family of *factory*
    patterns. The purpose is the same as all factory design patterns—to encapsulate
    the object creation logic and hide it from the user. The difference is how it
    is implemented.
  prefs: []
  type: TYPE_NORMAL
- en: The abstract factory design pattern relies on object composition in contrast
    to inheritance, which is used by the factory method. Here, we have a separate
    object, which provides an interface to create instances of the classes we need.
  prefs: []
  type: TYPE_NORMAL
- en: An example class diagram
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s keep using the preceding `SimpleConnection` example here. The following
    diagram shows how the abstract factory is structured:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/130a3617-d23d-450b-81e8-0f4eb758362c.png)'
  prefs: []
  type: TYPE_IMG
- en: As we can see from the preceding diagram, now we have a hierarchy of factories
    rather than a method inside our database client. We will be using the abstract
    **DatabaseConnectorFactory** in our application and it will be returning the right
    objects, depending on the actual instance type.
  prefs: []
  type: TYPE_NORMAL
- en: A code example
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s have a look at our example from the source point of view. The following
    code listing shows the factory hierarchy:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'We can then use our factory by passing it to a class, that will call the required
    methods. Here is an example similar to the one we showed for the factory method
    design pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s see an example that uses our database client:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The following screenshot shows the output of this program:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/dc32b2bc-2570-48a4-a908-8ef4858124a3.png)'
  prefs: []
  type: TYPE_IMG
- en: This is how the abstract factory design pattern works. If we need to add another
    database client to our application, we can achieve this by adding another class
    that extends `DatabaseConnectionFactory`. This is nice because it makes refactoring
    and extending easy.
  prefs: []
  type: TYPE_NORMAL
- en: Scala alternatives
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This design pattern can also be achieved using different approaches. The fact
    that we use object composition to pass a factory to our class indicates that we
    can do something else—we can simply pass a function, just because in Scala they
    are a part of unification and they are treated the same way as objects.
  prefs: []
  type: TYPE_NORMAL
- en: What it is good for?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As with all factories, the details of object creation are hidden. The abstract
    factory design pattern is particularly useful when we want to expose families
    of objects (for example, database connectors). The clients then become decoupled
    from the concrete classes. This pattern is commonly shown as an example in different
    UI toolkits, where elements differ for different operating systems. It is also
    quite testable because we can provide mocks instead of an actual factory to the
    clients.
  prefs: []
  type: TYPE_NORMAL
- en: Even though the incompatibility problem that we mentioned previously is still
    present here, it is somewhat harder to encounter now. This is mainly because here,
    the client will actually just pass one single factory as a parameter, and in the
    case where we provide the user with concrete factories, everything was already
    taken care of when these factories were written.
  prefs: []
  type: TYPE_NORMAL
- en: What it is not so good for?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It could be problematic if the objects and methods we are using (`SimpleConnection`,
    in our case) change signatures. In some cases, this pattern could also complicate
    our code unnecessarily and make it unreadable and hard to follow.
  prefs: []
  type: TYPE_NORMAL
- en: Other factory design patterns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are some different variations of the factory design patterns. In all cases
    though, the purpose is generally the same—hide creation complexity. In the following subsections,
    we will briefly mention two of the other factory design patterns—**static factory**
    and **simple factory**.
  prefs: []
  type: TYPE_NORMAL
- en: The static factory
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The static factory could be represented as a static method, which is a part
    of the base class. It is called to create concrete instances, which extend the
    base class. One of the biggest drawbacks here, however, is that if another extension
    of the base class is added, the base class (because of the static method) also
    has to be edited. Let''s show a simple example from the world of animals:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Here, every time we add a new extension of `Animal`, we would have to change
    the `apply` method to account for it, especially if we want to account for the
    new types.
  prefs: []
  type: TYPE_NORMAL
- en: The preceding example uses the special apply method of the `Animal` companion
    object. We could have different versions of it and it would provide us with a
    syntactic sugar that allows us to simply use `Animal("mammal")`. This makes it
    even more convenient to use the factory, as its existence will be indicated by
    the good IDEs because of the base class.
  prefs: []
  type: TYPE_NORMAL
- en: The simple factory
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The simple factory is better than the static factory, because the actual factory
    functionality is in another class. This removes the requirement for the base class
    to be modified every time a new extension is added. This is similar to the abstract
    factory, but the difference is that here we don't have a base factory class, we
    use a concrete one instead. Usually, one starts with a simple factory, which evolves
    to abstract with time and project evolution.
  prefs: []
  type: TYPE_NORMAL
- en: Factory combinations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Of course, it is possible to combine different types of factories together.
    This, however, needs to be done with caution and only if necessary. Otherwise,
    overusing the design pattern could lead to bad code.
  prefs: []
  type: TYPE_NORMAL
- en: Lazy initialization
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Lazy initialization in software engineering is when we delay the instantiation
    of an object or a variable until the first time we need it. The idea behind this
    is to defer or even avoid some expensive operations.
  prefs: []
  type: TYPE_NORMAL
- en: An example class diagram
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In other languages, such as Java, lazy initialization is often used in conjunction
    with the factory method design pattern. This method usually checks whether the
    object/variable we want to use is initialized; if not, it initializes the object
    and finally returns it. In consecutive uses, the already initialized object/variable
    is returned.
  prefs: []
  type: TYPE_NORMAL
- en: The Scala programming language has built-in support for lazy initialization.
    It makes use of the `lazy` keyword. That's why providing a class diagram in this
    case is pointless.
  prefs: []
  type: TYPE_NORMAL
- en: A code example
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's see how lazy initialization works in Scala and also prove that it is indeed
    lazy. We will look at an example that calculates a circle area. As we know, the
    formula is `pi * r²`. Programming languages have support for mathematical constants
    and this is not how we will do it in real life. However, the example is still
    relevant if we're talking about a different constant that is not widely known,
    or a constant that usually fluctuates around a value, but could be different every
    day.
  prefs: []
  type: TYPE_NORMAL
- en: 'At school, we''ve been taught that pi is equal to 3.14\. This is true, however,
    there are many extra digits after that and if we really care about precision,
    we will need to account for them as well. For example, pi with 100 digits looks
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'So, let''s create a utility that will return the area when given a circle radius.
    We will have our basic pi as a variable in our utility class, but we will also
    allow the users to decide if they want a precise area or not. If they do, we will
    read the 100-digit pi from a configuration file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code does exactly what we said. Depending on precision, we will
    use a different version of pi. The lazy initialization here is useful because
    we might never ever need a precise area, or we could need it sometimes, but not
    others. Moreover, reading from a configuration file is an I/O operation, which
    is considered to be slow and it could have a negative effect when done multiple
    times. Let''s see how we use our utility:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of this program will be the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ce5f3f84-1ff5-49bf-9d0e-51427e29de4a.png)'
  prefs: []
  type: TYPE_IMG
- en: We can have a few observations from our example output. First, the precision
    really matters and there are industries out there including financial institutions,
    space industry, and so on where precision is taken really seriously. Second, in
    the lazy initialization block, we used a `print` statement and it is printed when
    we used the precise implementation for the first time. Normal values get initialized
    when the instance is created. This shows that indeed, lazy initialization in Scala
    defers it until the variable is used for the first time.
  prefs: []
  type: TYPE_NORMAL
- en: What it is good for?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Lazy initialization is particularly useful when initializing an object or variable
    that would take too long or might not even be needed. Some might say that we can
    simply use methods, and this is partly true. However, imagine a case where we
    might need to access a lazily initialized variable/object from multiple methods
    in different calls to our object. In this case, it is useful to store the result
    somewhere and just reuse it.
  prefs: []
  type: TYPE_NORMAL
- en: What it is not so good for?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In languages other than Scala, some special care needs to be taken when lazy
    initialization is used in a multithreaded setting. In Java, for example, you need
    to do initialization in a `synchronized` block. In order to provide even better
    safety, *double-checked locking* is preferred. There is no such danger in Scala.
  prefs: []
  type: TYPE_NORMAL
- en: The singleton design pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The singleton design pattern ensures that a class has only one object instance
    in the entire application. It introduces a global state in the applications it
    is used in.
  prefs: []
  type: TYPE_NORMAL
- en: A singleton object can be initialized using different strategies—lazy initialization
    or eager initialization. This all depends on the intended use, the time it takes
    an object to be initialized, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: An example class diagram
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Singletons are another example of design patterns, which are supported out of
    the box by the Scala programming language syntax. We achieve this by using the
    object keyword. In this case, again, providing a class diagram is not necessary,
    so we will step right into the example in the next subsection.
  prefs: []
  type: TYPE_NORMAL
- en: A code example
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The aim of this example is to show how to create singleton instances in Scala
    and have an understanding of when exactly instances are created in Scala. We will
    look at a class called `StringUtils`, that provides different utility methods
    related to strings:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Using this class is then straightforward. Scala takes care of creating the
    object, thread safety, and so on:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The output from this program will be the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9771e011-9d3c-4492-acbf-30cc6c4e4d03.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The preceding example is clear and even though the `StringUtils` object will
    be a singleton instance, it more resembles a class with static methods. This is
    actually how static methods are defined in Scala. It would be more interesting
    to add some state to a singleton class. The following example shows exactly this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The `AppRegistry` contains a concurrent map of all the users currently using
    the application. This is our global state and we have methods that allow us to
    manipulate it. We also have a `println` statement, which will be executed when
    the singleton instance is created. We can use our registry in the following application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s run this example and see what the final output will be:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c22edb63-6a1a-4530-a5e7-b991915f526e.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, our example presents a proper singleton instance, which contains a global
    state. This state will be accessible from all the application classes while the
    instance runs. From the example code and our output, we can make a few conclusions:'
  prefs: []
  type: TYPE_NORMAL
- en: Singletons in Scala are lazily initialized
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: While creating a singleton instance, we cannot provide dynamic parameters to
    the singleton class instance
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What it is good for?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In Scala, the singleton design pattern and static methods are implemented the
    same way. That's why singletons are useful for creating utility classes that have
    no state. Singletons in Scala can also be used to build ADTs, which we talked
    about in the previous chapters.
  prefs: []
  type: TYPE_NORMAL
- en: Another thing that is strictly valid for Scala is that in Scala, singletons
    are created in a thread-safe way out of the box and without the need to take any
    special care.
  prefs: []
  type: TYPE_NORMAL
- en: What it is not so good for?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Often, the singleton design pattern is actually considered an anti-pattern.
    Many people say that global state should not exist the way it does with singleton
    classes. Some say that if you have to use singletons, you should try and refactor
    your code. While this is true in some cases, there is sometimes a good use for
    singletons. Generally, the rule of thumb is—if you can avoid them, then do.
  prefs: []
  type: TYPE_NORMAL
- en: Another thing that could be pointed out specifically for Scala singletons is
    that they can really have only one instance. While this is the actual definition
    of the pattern, with other languages, we could have a predefined number of more
    than just one singleton object and have some control on this using custom logic.
  prefs: []
  type: TYPE_NORMAL
- en: This does not really affect Scala but it is still worth mentioning. In the case
    where a singleton is initialized lazily in an application, in order to provide
    thread safety, you need to rely on locking mechanisms, for example, the double-checked
    locking mentioned in the previous section. Accessing the singletons in an application,
    no matter if it's Scala or not, also needs to be done in a thread-safe way or
    the singleton should take care of this internally.
  prefs: []
  type: TYPE_NORMAL
- en: The builder design pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The builder design pattern helps to create instances of classes using class
    methods rather than the class constructors. It is particularly useful in cases
    where a class might need multiple versions of its constructor in order to allow
    different usage scenarios.
  prefs: []
  type: TYPE_NORMAL
- en: Moreover, in some cases, it might not even be possible to define all combinations
    or they might not be known. The builder design pattern uses an extra object, called
    `builder`, in order to receive and store initialization parameters before building
    the final version of an object.
  prefs: []
  type: TYPE_NORMAL
- en: An example class diagram
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this subsection, we will provide a class diagram for the builder pattern
    the way it was classically defined and the way it looks in other languages, including
    Java. Later, we will present different versions of the code on the basis of them
    being more appropriate for Scala and of the observations and discussions we will
    have around them.
  prefs: []
  type: TYPE_NORMAL
- en: Let's have a `Person` class with different parameters—`firstName`, `lastName`,
    `age`, `departmentId`, and so on. We will show the actual code for it in the next
    subsection. Creating a concrete constructor, especially if those fields might
    not always be known or required, might take too much time. It would also make
    the code extremely hard to maintain in the future.
  prefs: []
  type: TYPE_NORMAL
- en: 'A builder pattern seems like a good idea and the class diagram for it will
    look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7d5f9ce8-7791-4b38-abed-7a3184484666.png)'
  prefs: []
  type: TYPE_IMG
- en: As we already mentioned, this is how the builder pattern looks in purely object-oriented
    languages (not Scala). There could be different representations of it where the
    builder is abstracted, and then there are concrete builders. The same is true
    for the product that is being built. In the end, they all aim to get to the same
    point—make object creation easier.
  prefs: []
  type: TYPE_NORMAL
- en: In the next subsection, we will provide code implementations that will show
    exactly how to use and write the builder design pattern in Scala.
  prefs: []
  type: TYPE_NORMAL
- en: A code example
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are actually three main ways in which we can represent the builder design
    pattern in Scala:'
  prefs: []
  type: TYPE_NORMAL
- en: The classical way, as shown in the preceding diagram, is like other object-oriented
    languages. This way is actually not recommended, even though it is possible in
    Scala. It uses mutability in order to work, which contradicts the immutability
    principle of the language. We will show it here for completeness and in order
    to point out how much easier it is to achieve the builder design pattern using
    simple features of Scala.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using case classes with default parameters. We will see two versions—one that
    validates the parameters and another one that doesn't.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using generalized type constraints.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will focus on these in the next few subsections. In order to keep things
    short and simple, we will have fewer fields in our classes; however, it has to
    be noted that the builder design pattern really shines when there is a large number
    of fields. You can experiment by adding more fields to the code examples that
    are provided in this book.
  prefs: []
  type: TYPE_NORMAL
- en: A Java-like implementation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This implementation directly reflects what we have in the previous diagram.
    First, let''s see what our `Person` class will look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'As we can see in the preceding code, it takes a builder and uses the values
    set in the builder for initialization of its fields. The builder code will look
    like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Our builder has methods that can set each corresponding field of the `Person`
    class. These methods return the same instance of the builder and this allows us
    to chain many calls together. Here is how we can use our builder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: This is how to use the builder design pattern. Now, we can create a `Person`
    object and provide whatever data we have for it—even if we have a subset of all
    possible fields, we can specify them and the rest will have a default value. There
    is no need to create new constructors if other fields are being added to the `Person`
    class. They just need to be made available through the `PersonBuilder` class.
  prefs: []
  type: TYPE_NORMAL
- en: Implementation with a case class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The preceding builder design pattern looks nice and clear, but it requires writing
    some extra code and creating boilerplate. Moreover, it requires us to have mutable
    fields in the `PersonBuilder` class, which is against some of the principles in
    Scala.
  prefs: []
  type: TYPE_NORMAL
- en: Preferring immutability
  prefs: []
  type: TYPE_NORMAL
- en: Immutability is an important principle in Scala and it should be preferred.
    The builder design pattern with case classes uses immutable fields and this is
    considered a good practice.
  prefs: []
  type: TYPE_NORMAL
- en: 'Scala has case classes, which make the implementation of the builder pattern
    much simpler. Here is what it will look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The use of this case class is similar to how the preceding builder design pattern
    is used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code is much shorter and easier to maintain than the first version.
    It allows the developer to do absolutely the same as the original builder pattern,
    but with a shorter and cleaner syntax. It also keeps the fields of the `Person`
    class immutable, which is a good practice to follow in Scala.
  prefs: []
  type: TYPE_NORMAL
- en: Choosing default values
  prefs: []
  type: TYPE_NORMAL
- en: The choice of default values for the builder design pattern is entirely up to
    the developer. Some would prefer to use `Option` and put `None` when there is
    no value specified. Others might assign some different special values. This choice
    can be dictated by personal choice, the problem that is being solved, the style
    guides employed by an engineering team, and more.
  prefs: []
  type: TYPE_NORMAL
- en: One drawback of the preceding two approaches is that there is no validation.
    What if some components depended on each other and there are specific variables
    that require initialization? In the cases that use the preceding two approaches,
    we could run into runtime exceptions. The next subsection will show us how to
    make sure that validation and requirement satisfactions are implemented.
  prefs: []
  type: TYPE_NORMAL
- en: Using generalized type constraints
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In many cases in which we create objects in software engineering, we have dependencies.
    We either need to have something initialized in order to use a third component,
    or we require a specific order of initialization, and so on. Both builder pattern
    implementations we looked at earlier lack the capability to make sure something
    is or isn't initialized. This way, we need to create some extra validation around
    the builder design pattern in order to make sure everything will work as expected,
    yet we will see whether it is safe to create an object only during runtime.
  prefs: []
  type: TYPE_NORMAL
- en: Using some of the techniques we already looked at earlier in this book, we can
    create a builder that validates whether all requirements are satisfied during
    compile time. This is called a **type-safe builder**, and in the next example,
    we will present this pattern.
  prefs: []
  type: TYPE_NORMAL
- en: Changing the Person class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'First of all, we start with the same classes as we have in the example where
    we showed the way in which Java uses the builder pattern. Now, let''s put a constraint
    on the example and say that every person must have at least `firstName` and `lastName`
    specified. In order to make the compiler aware that fields are being set, this
    needs to be encoded as a type. We will be using ADTs for this purpose. Let''s
    define the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding abstract data types define the different steps of the build progress.
    Now, let''s make some refactoring to the builder class and the `Person` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'We will use the full constructor for the `Person` class rather than passing
    a builder. This is to show another way of building instances and keeping the code
    simpler in the later steps. The change would require the `build` method in the
    `PersonBuilder` to change as well to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'This would require all the methods we have, which returned `PersonBuilder`
    before, to return `PersonBuilder[PassedStep]` now. Also, this would make it impossible
    to create a builder using the `new` keyword because the constructor is now private.
    Let''s add some more constructor overloads:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'We will see how these overloads are used later. We need to allow our users
    to create a builder using another method, since all constructors are invisible
    to the outside world. That''s why we should add a companion object, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: The companion object uses one of the constructors we previously defined and
    it also makes sure the object returned is at the right build step.
  prefs: []
  type: TYPE_NORMAL
- en: Adding generalized type constraints to the required methods
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'What we have so far, however, is still not going to satisfy our requirements
    regarding what every `Person` object should have initialized. We would have to
    change some methods in the `PersonBuilder` class. These methods are `setFirstName`,
    `setLastName`, and `build`. Here are the changes to the set methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'The interesting part comes with the `build` method. Let''s have a look at the
    following initial implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding syntax sets a generalized type constraint and says that `build`
    can only be called on a builder, which has passed the `HasLastName` step. It seems
    like we are coming close to what we wanted to achieve, but now `build` will only
    work if `setLastName` was the last of those four methods called on the builder,
    and it will still not validate the other fields. Let''s use a similar approach
    for the `setFirstName` and `setLastName` methods and chain them up so that each
    one will require the previous one to be called before. Here is what the final
    code for our `PersonBuilder` class looks like (notice the other implicits in the
    set methods):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Using the type-safe builder
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We can now use the builder to create a `Person` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'If we omit one of our two required methods or rearrange them in some way, we
    will get a compilation error similar to the following (the error is for the missing
    first name):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: The order requirement could be considered a slight drawback, especially if it's
    not needed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are some observations about our type-safe builder:'
  prefs: []
  type: TYPE_NORMAL
- en: Using a type-safe builder, we can require a specific call order and certain
    fields to be initialized.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When we require multiple fields, we have to chain them, which makes the order
    of calls important. This could make the library hard to use in some cases.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Compiler messages, when the builder is not used correctly, are not really informative.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The code looks pretty much similar to how it would be implemented in Java.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The similarity in code with Java leads to relying on mutability, which is not
    recommended.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Scala allows us to have a nice and clean implementation of a builder design
    pattern, which also has requirements for order and what is initialized. This is
    a good feature, even though sometimes it could be tedious and limiting in terms
    of how exactly methods are being used.
  prefs: []
  type: TYPE_NORMAL
- en: Using require statements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The type-safe builder we showed previously is nice, but it has some drawbacks:'
  prefs: []
  type: TYPE_NORMAL
- en: Complexity
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mutability
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A predefined order of initialization
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'However, it could be quite useful because it allows us to write code that will
    be checked for correct usage as soon as we compile it. Sometimes, compile-time
    validation is not required, though. If this is the case, we can make things extremely
    simple and get rid of the entire complexity using the already known case classes
    and the `require` statements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'If the preceding Boolean conditions are not satisfied, our code will throw
    an `IllegalArgumentException` with the correct message. We can use our class the
    same way as we would normally use a case class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: As we can see, things here are much simpler, fields are immutable, and we don't
    actually have any special order of initialization. Moreover, we can put meaningful
    messages that could help us diagnose potential issues. As long as compile-time
    validation is not required, this should be the preferred method.
  prefs: []
  type: TYPE_NORMAL
- en: What it is good for?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The builder design pattern is really good for cases in which we need to create
    a complex object and would otherwise have to define many constructors. It makes
    the creation of objects easier and somewhat cleaner and more readable using a
    step-by-step approach.
  prefs: []
  type: TYPE_NORMAL
- en: What it is not so good for?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we saw in our type-safe builder example, adding more advanced logic and requirements
    could involve quite a bit of work. Without this possibility, the developer will
    risk the users of their classes making more mistakes. Also, the builder contains
    quite a lot of seemingly duplicate code, especially when it is implemented using
    a Java-like code.
  prefs: []
  type: TYPE_NORMAL
- en: The prototype design pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The prototype design pattern is a creational design pattern that involves creating
    objects by cloning them from existing ones. Its purpose is related to performance
    and keeping it high by trying to avoid expensive calls.
  prefs: []
  type: TYPE_NORMAL
- en: An example class diagram
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In languages such as Java, we usually see a class that implements an interface
    with a `clone` method, which returns a new instance of the class. Consider the
    following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/77c11047-0f87-40e1-ba8d-9143de8f0591.png)'
  prefs: []
  type: TYPE_IMG
- en: In the next section, we will provide a code example of the prototype design
    pattern from the point of view of Scala.
  prefs: []
  type: TYPE_NORMAL
- en: A code example
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The prototype design pattern is really easy to implement in Scala. We can just
    use one of the language features. Since the prototype design pattern really resembles
    how cells in biology divide, let''s use a cell as an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'In Scala, all case classes have a `copy` method, which returns a new instance
    that is cloned from the original one. It can also change some of the original
    properties while copying. Here is some example usage of our cell:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of this example will be this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b6aa7488-2eef-49c4-8ffe-a5305f62f39a.png)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, using `copy`, we acquired different instances of our prototype
    cell.
  prefs: []
  type: TYPE_NORMAL
- en: What it is good for?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The prototype design pattern is useful when performance is important. Using
    the `copy` method, we can get instances that otherwise take time to create. The
    slowness could be caused by some calculations performed during creation, a database
    call that retrieves data, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: What it is not so good for?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Mistakes and side effects could be caused using shallow copies of objects, where
    the actual references point to the original instances. Also, avoiding constructors
    could lead to bad code. The prototype design pattern should be really used in
    cases where there might be a massive performance impact without it.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This was the first chapter of this book that focused on some specific design
    patterns. We looked at the following creational design patterns—factory method,
    abstract factory, lazy initialization, singleton, builder, and prototype. Wherever
    relevant, we presented a diagram that visually showed class relationships. Also,
    we gave typical examples and went through the possible pitfalls and recommendations
    about when to use them.
  prefs: []
  type: TYPE_NORMAL
- en: In real-life software engineering, design patterns are usually combined together
    rather than being used in an isolated manner. Some examples include a prototype
    that is being supplied by a singleton instance, abstract factories that can store
    different prototypes and supply copies when objects are created, factories that
    can use builders to create instances, and so on. In some cases, design patterns
    could be interchangeable depending on the use case. For example, lazy initialization
    could be enough to lower the performance impact and could be chosen instead of
    a prototype design pattern.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will continue our journey into design patterns; this
    time, we will focus on the *structural design patterns* family.
  prefs: []
  type: TYPE_NORMAL
