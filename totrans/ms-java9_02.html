<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Discovering Java 9</h1>
                </header>
            
            <article>
                
<p>Java 9 represents a major release and consists of a large number of internal changes to the Java platform. Collectively, these internal changes represent a tremendous set of new possibilities for Java developers, some stemming from developer requests, others from Oracle-inspired enhancements. In this chapter, we will review 26 of the most important changes. Each change is related to a <strong>JDK Enhancement Proposal</strong> (<strong>JEP</strong>). JEPs are indexed and housed at <a href="http://openjdk.java.net/jeps/0">openjdk.java.net/jeps/0</a>. You can visit this site for additional information on each JEP.</p>
<div class="packt_infobox">The JEP program is part of Oracle's support for open source, open innovation, and open standards. While other open source Java projects can be found, OpenJDK is the only one supported by Oracle.</div>
<p>In this chapter, we will cover changes to the Java platform. These changes have several impressive implications, including:</p>
<ul>
<li>Heap space efficiencies</li>
<li>Memory allocation</li>
<li>Compilation process improvements</li>
<li>Type testing</li>
<li>Annotations</li>
<li>Automated runtime compiler tests</li>
<li>Improved garbage collection</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Improved Contended Locking [JEP 143]</h1>
                </header>
            
            <article>
                
<p>The JVM uses Heap space for classes and objects. The JVM allocates memory on the heap whenever we create an object. This helps facilitate Java's garbage collection which releases memory previously used to hold objects that no longer have a reference to it. Java Stack memory is a bit different and is usually much smaller than heap memory.</p>
<p>The JVM does a good job of managing data areas that are shared by multiple threads. It associates a monitor with every object and class; these monitors have locks that are controlled by a single thread at any one time. These locks, controlled by the JVM, are, in essence, giving the controlling thread the object's monitor.</p>
<p>So, what is contended locking? When a thread is in a queue for a currently locked object, it is said to be in contention for that lock. The following diagram shows a high-level view of this contention:</p>
<div class="mce-root CDPAlignCenter CDPAlign"><img height="228" width="367" src="assets/d08f3d3c-7ad3-4c5b-8f25-3e405467be9d.png"/></div>
<p class="mce-root CDPAlignLeft CDPAlign">As you can see in the preceding illustration, any threads in waiting cannot use a locked object until it is released.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Improvement goals</h1>
                </header>
            
            <article>
                
<p>The general goal of JEP 143 was to increase the overall performance of how the JVM manages contention over locked Java object monitors. The improvements to contended locking were all internal to the JVM and do not require any developer actions to benefit from them. The overall improvement goals were related to faster operations. These include:</p>
<ul>
<li>Faster monitor enter</li>
<li>Faster monitor exit</li>
<li>Faster notifications</li>
</ul>
<p>The notifications are the <kbd>notify()</kbd> and <kbd>notifyAll()</kbd> operations that are called when the locked status of an object is changed. Testing this improvement is not something you can easily accomplish. Greater efficiency, at any level, is welcome, so this improvement is one we can be thankful for even without any easily observable testing.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Segmented code cache [JEP 197]</h1>
                </header>
            
            <article>
                
<p>The segmented code cache JEP (197) upgrade was completed and results in faster, more efficient execution time. At the core of this change was the segmentation of the code cache into three distinct segments--non-method, profiled, and non-profiled code.</p>
<div class="packt_infobox">A code cache is the area of memory where the Java Virtual Machine stores generated native code.</div>
<p>Each of the aforementioned code cache segments will hold a specific type of compiled code. As you can see in the following diagram, the code heap areas are segmented by type of compiled code:</p>
<div class="CDPAlignCenter CDPAlign"><img height="203" width="384" src="assets/80b55837-7e19-4eaa-92d5-ec65f6e9e776.png"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Memory allocation</h1>
                </header>
            
            <article>
                
<p>The code heap containing non-method code is for JVM internal code and consists of a 3 MB fixed memory block. The rest of the code cache memory is equally allocated for the profiled code and non-profiled code segments. You have control of this via command-line commands.<br/>
The following command can be used to define the code heap size for the non-method compiled code:</p>
<pre><strong>-XX:NonMethodCodeCodeHeapSize</strong></pre>
<p>The following command can be used to define the code heap size for the profiled compiled methods:</p>
<pre><strong>-XX:ProfiledCodeHeapSize</strong></pre>
<p>The following command can be used to define the code heap size for the non-profiled compiled methods:</p>
<pre><strong>-XX:NonProfiledCodeHeapSize</strong></pre>
<p>This Java 9 feature certainly stands to improve Java application efficiency. It also impacts other processes that employ the code cache.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Smart Java compilation, phase two [JEP 199]</h1>
                </header>
            
            <article>
                
<p><span>The <span>JDK Enhancement Proposal 199 is aimed at improving the code compilation process. All Java developers will be familiar with the</span></span> <strong>javac</strong> tool for compiling source code to bytecode, which is used by the JVM to run Java programs. <strong>Smart Java Compilation</strong>, also referred to as Smart Javac and <strong>sjavac</strong>, adds a <em>smart</em> wrapper around the javac process. Perhaps the core improvement sjavac adds is that only the necessary code is recompiled. Necessary code, in this context, is code that has changed since the last compile cycle.</p>
<p>This enhancement might not get developers excited if they only work on small projects. Consider, however, the tremendous gains in efficiency when you continuously have to recompile your code for medium and large projects. The time developers stand to save is enough reason to embrace JEP 199.</p>
<p>How will this change how you compile your code? It probably will not, at least not yet. Javac will remain the default compiler. While sjavac offers efficiencies regarding incremental builds, Oracle has deemed it to not have sufficient stability to become part of the standard compilation workflow.</p>
<div class="packt_infobox">You can read more information about the smart javac wrapper tool here: <a href="http://cr.openjdk.java.net/~briangoetz/JDK-8030245/webrev/src/share/classes/com/sun/tools/sjavac/Main.java-.html">http://cr.openjdk.java.net/~briangoetz/JDK-8030245/webrev/src/share/classes/com/sun/tools/sjavac/Main.java-.html</a>.<a href="http://cr.openjdk.java.net/~briangoetz/JDK-8030245/webrev/src/share/classes/com/sun/tools/sjavac/Main.java-.html"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Resolving Lint and Doclint warnings [JEP 212]</h1>
                </header>
            
            <article>
                
<p><span>Do not worry if you are not familiar with Lint or Doclint in Java. As you can determine from the section title, they are sources that report warnings to javac. Let's take a look at each one:</span></p>
<ul>
<li><strong>Lint</strong> analyzes byte code and source code for javac. The goal of Lint is to identify security vulnerabilities in the code being analyzed. Lint can also provide insights into scalability and thread locking concerns. There is more to Lint, and the overall purpose is to save developers time.</li>
</ul>
<div class="packt_infobox"><span>You can read more about Lint here:</span> <a href="https://en.wikipedia.org/wiki/Lint_(software)"><span>https://en.wikipedia.org/wiki/Lint_(software)</span></a><span>.</span><a href="https://en.wikipedia.org/wiki/Lint_(software)"/></div>
<ul>
<li><strong>Doclint</strong> is similar to Lint and is specific to javadoc. Both Lint and Doclint report errors and warnings during the compile process. Resolution of these warnings was the focus of JEP 212. When using core libraries, there should not be any warnings. This mindset led to JEP 212, which has been resolved and implemented in Java 9.</li>
</ul>
<div class="packt_infobox">A comprehensive list of the Lint and Doclint warnings can be reviewed in the <a href="https://bugs.openjdk.java.net">https://bugs.openjdk.java.net</a> JDK Bug System.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Tiered attribution for javac [JEP 215]</h1>
                </header>
            
            <article>
                
<p><span>JEP 215 represents an impressive undertaking to streamline javac's type checking schema. Let's first review how type checking works in Java 8; then we will explore the changes in Java 9.</span></p>
<p>In Java 8, type checking of poly expressions is handled by a <strong>speculative attribution</strong> tool.</p>
<div class="packt_infobox">Speculative attribution is a method of type checking as part of javac's compilation process. It has a significant processing overhead.</div>
<p>Using the speculative attribution approach to type checking is accurate, but lacks efficiency. These checks include argument position, and are exponentially slower when testing in the midst of recursion, polymorphism, nested loops, and lambda expressions. So the goal with JEP 215 was to change the type checking schema to create faster results. The results themselves were not inaccurate with speculative attribution; they were just not generated rapidly.</p>
<p>The new approach, released with Java 9, uses a tiered attribution tool. This tool implements a tiered approach for type checking argument expressions for all method calls. Permissions are also made for method overriding. In order for this new schema to work, new structural types are created for each of the following listed types of method arguments:</p>
<ul>
<li>Lambda expressions</li>
<li>Poly expressions</li>
<li>Regular method calls</li>
<li>Method references</li>
<li>Diamond instance creation expressions</li>
</ul>
<p>The changes to javac from JEP 215 are more complex than what has been highlighted in this section. There is no immediate impact to developers other than a more efficient javac and time saved.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Annotations pipeline 2.0 [JEP 217]</h1>
                </header>
            
            <article>
                
<p><span>Java annotations refer to a special kind of metadata that resides inside your Java source code files. They are not stripped by javac, so that they can remain available to the JVM at runtime.</span></p>
<p>Annotations look similar to JavaDocs references because they start with the <kbd>@</kbd> symbol. There are three types of annotations. Let's examine each:</p>
<ul>
<li>The most basic form of annotation is a <strong>marker</strong> annotation. These are standalone annotations with the only component being the name of the animation. Here is an example:</li>
</ul>
<pre>        @thisIsAMarkerAnnotation<br/>        public double computeSometing(double x, double y) <br/>        {<br/>          // do something and return a double<br/>        }</pre>
<ul>
<li>The second type of annotation is one that contains a <em>single value</em>, or piece of data. As you can see in the following code, the annotation, which starts with the <kbd>@</kbd> symbol, is followed by parentheses containing data:</li>
</ul>
<pre>        @thisIsAMarkerAnnotation (data="compute x and y <br/>         coordinates")<br/>        public double computeSometing(double x, double y) <br/>        {<br/>          // do something and return a double<br/>        }</pre>
<p style="padding-left: 60px">An alternative way of coding the single value annotation type is to omit the <kbd>data=</kbd> component, as illustrated in the following code:</p>
<pre><span>        @thisIsAMarkerAnnotation ("compute x and y coordinates")</span><br/><span>        public double computeSometing(double x, double y) </span><br/><span>        {</span><br/><span>          // do something and return a double</span><br/><span>        }</span></pre>
<ul>
<li>The third type of annotation is when there is <em>more than one data component</em>. With this type of annotation, the <kbd>data=</kbd> component cannot be omitted. Here is an example:</li>
</ul>
<pre><span>        @thisIsAMarkerAnnotation (data="compute x and y <br/>         coordinates", purpose="determine intersecting point")</span><br/><span>         public double computeSometing(double x, double y) </span><br/><span>         {</span><br/><span>           // do something and return a double</span><br/><span>         }</span></pre>
<p>So, what has changed in Java 9? To answer this question, we need to recall a couple of changes introduced with Java 8 that impacted Java annotations:</p>
<ul>
<li>Lambda expressions</li>
<li>Repeated annotations</li>
<li>Java type annotations</li>
</ul>
<p>These Java 8 related changes impacted Java annotations, but did not usher in a change to how javac processed them. There were some hardcoded solutions that allowed javac to handle the new annotations, but they were not efficient. Moreover, this type of coding (hardcoding workarounds) is difficult to maintain.</p>
<p>So, JEP 217 focused on refactoring the javac annotation pipeline. This refactoring was all internal to javac, so it should not be evident to developers.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">New version-string scheme [JEP 223]</h1>
                </header>
            
            <article>
                
<p><span>Prior to Java 9, the release numbers did not follow industry standard versioning--<strong>semantic versioning</strong>. For example, at the time of writing, the last four JDK releases were:</span></p>
<ul>
<li>JDK 8 update 131</li>
<li>JDK 8 update 121</li>
<li>JDK 8 update 112</li>
</ul>
<div class="packt_infobox"><strong>Semantic versioning</strong> uses a major, minor, patch (0.0.0) schema:<br/>
<strong>Major</strong> equates to new API changes that are not backwards compatible.<br/>
<strong>Minor</strong> is when functionality is added that is backwards compatible.<br/>
<strong>Patch</strong> refers to bug fixes or minor changes that are backwards compatible.</div>
<p>Oracle has embraced semantic versioning for Java 9 and beyond. For Java, a <strong>major-minor-security</strong> schema will be used for the first three elements of Java version numbers:</p>
<ul>
<li><strong>Major</strong>: A major release consisting of a significant new set of features</li>
<li><strong>Minor</strong>: Revisions and bug fixes that are backwards compatible</li>
<li><strong>Security</strong>: Fixes deemed critical to improve security</li>
</ul>
<p>This description of JEP 223 might make the versioning schema seem basic. To the contrary, a very detailed set of rules and practices have been developed to manage the future version numbers. To demonstrate the complexity, see the following example:</p>
<pre>    1.9.0._32.b19</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Generating run-time compiler tests automatically [JEP 233]</h1>
                </header>
            
            <article>
                
<p><span>Java is arguably the most used programming language and resides on an increasingly diverse number of platforms. This exacerbates the problem of running targeted compiler tests in an efficient manner. The purpose of JEP 233 was to create a tool that could automate the runtime compiler tests.</span></p>
<p>The tool that was created starts by generating a random set of Java source code and/or byte code. The generated code will have three key characteristics:</p>
<ul>
<li>Be syntactically correct</li>
<li>Be semantically correct</li>
<li>Use a random seed that permits reusing the same randomly-generated code</li>
</ul>
<p>The source code that is randomly generated will be saved in the following directory:</p>
<pre>    hotspot/test/testlibrary/jit-tester</pre>
<p>These test cases will be stored for later re-use. They can be run from the <kbd>j-treg</kbd> directory or from the tool's makefile. One of the benefits of re-running saved tests is to test the stability of your system.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Testing class-file attributes generated by Javac [JEP 235]</h1>
                </header>
            
            <article>
                
<p><span>The lack of, or insufficient, capability to create tests for class-file attributes was the impetus behind JEP 235. The goal is to ensure javac creates a class-file's attributes completely and correctly. This suggests that even if some attributes are not used by the class-file, all class-files should be generated with a complete set of attributes. There also needs to be a way of testing that the class-files were created correctly, in regards to the file's attributes.</span></p>
<p>Prior to Java 9, there was no method of testing a class-file's attributes. Running a class and testing the code for anticipated or expected results was the most commonly used method of testing javac generated class-files. This technique falls short of testing to validate the file's attributes.</p>
<p>There are three categories of class-file attributes--attributes used by the JVM, optional attributes, and attributes not used by the JVM.</p>
<p>Attributes used by the JVM include:</p>
<ul>
<li><kbd>BootstrapMethods</kbd></li>
<li><kbd>Code</kbd></li>
<li><kbd>ConstantValue</kbd></li>
<li><kbd>Exceptions</kbd></li>
<li><kbd>StackMapTable</kbd></li>
</ul>
<p>Optional attributes include:</p>
<ul>
<li><kbd>Deprecated</kbd></li>
<li><kbd>LineNumberTable</kbd></li>
<li><kbd>LocalVariableTable</kbd></li>
<li><kbd>LocalVariableTypeTable</kbd></li>
<li><kbd>SourceDebugExtension</kbd></li>
<li><kbd>SourceFile</kbd></li>
</ul>
<p class="mce-root">Attributes not used by the JVM include:</p>
<ul>
<li><kbd>AnnotationDefault</kbd></li>
<li><kbd>EnclosingMethod</kbd></li>
<li><kbd>InnerClasses</kbd></li>
<li><kbd>MethodParameters</kbd></li>
<li><kbd>RuntimeInvisibleAnnotations</kbd></li>
<li><kbd>RuntimeInvisibleParameterAnnotations</kbd></li>
<li><kbd>RuntimeInvisibleTypeAnnotations</kbd></li>
<li><kbd>RuntimeVisibleAnnotations</kbd></li>
<li><kbd>RuntimeVisibleParameterAnnotations</kbd></li>
<li><kbd>RuntimeVisibleTypeAnnotations</kbd></li>
<li><kbd>Signature</kbd></li>
<li><kbd>Synthetic</kbd></li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Storing interned strings in CDS archives [JEP 250]</h1>
                </header>
            
            <article>
                
<p><span>The method in which strings are stored and accessed to and from <strong>Class Data Sharing</strong> (<strong>CDS</strong>) archives is inefficient, excessively time consuming, and wastes memory. The following diagram illustrates the method in which Java stores interned strings in a CDS archive:</span></p>
<div class="CDPAlignCenter CDPAlign"><img height="95" width="348" src="assets/83403665-1780-4ddb-b210-a48a73f3c8bb.png"/></div>
<p>The inefficiency stems from the current storage schema. Especially when the <strong>Class Data Sharing</strong> tool dumps the classes into the shared archive file, the constant pools containing <kbd>CONSTANT_String</kbd> items have a UTF-8 string representation.</p>
<div class="packt_infobox">UTF-8 is an 8-bit variable-length character encoding standard.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The problem</h1>
                </header>
            
            <article>
                
<p>With the current use of UTF-8, the strings must be converted to string objects, instances of the <kbd>java.lang.String</kbd> class. This conversion takes place on-demand which can result in slower systems and unnecessary memory usage. The processing time is extremely short, but the memory usage cannot be overlooked. Every character in an interned string requires at least 3 bytes of memory and potentially more.</p>
<p>A related problem is that the stored strings are not accessible to all JVM processes.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The solution</h1>
                </header>
            
            <article>
                
<p>CDS archives now allocate specific space on the heap for strings:</p>
<div class="CDPAlignCenter CDPAlign"><img height="127" width="472" src="assets/56d58b41-3585-4518-a9b7-140f836aec34.png"/></div>
<p>The string space is mapped using a shared-string table, hash tables, and deduplication.</p>
<div class="packt_infobox">Deduplication is a data compression technique that eliminates duplicative information in an archive.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Preparing JavaFX UI controls and CSS APIs for modularization [JEP 253]</h1>
                </header>
            
            <article>
                
<p><span>JavaFX is a set of packages that permits the design and development of media-rich graphical user interfaces. JavaFX applications provide developers with a great API for creating a consistent interface for applications. <strong>Cascading Style Sheets</strong> (<strong>CSS</strong>) can be used to customize the interfaces. One of the great things about JavaFX is that the tasks of programming and interface design can easily be separated.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">JavaFX overview</h1>
                </header>
            
            <article>
                
<p>There is a wonderful visual scripting tool called Scene Builder that allows you to create graphical user interfaces by using drag and drop and property settings. Scene Builder generates the necessary FXML files that are used by your <strong>Integrated Development Environment</strong> (<strong>IDE</strong>) such as NetBeans.</p>
<p>Here is a sample UI created with Scene Builder:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/212c2118-bfc9-4c03-b687-38b7d45203a9.png"/></div>
<p>And, here is the FXML file created by Scene Builder:</p>
<pre>    &lt;?xml version="1.0" encoding="UTF-8"?&gt;<br/><br/>    &lt;?import java.lang.*?&gt;<br/>    &lt;?import java.util.*?&gt;<br/>    &lt;?import javafx.scene.control.*?&gt;<br/>    &lt;?import javafx.scene.layout.*?&gt;<br/>    &lt;?import javafx.scene.paint.*?&gt;<br/>    &lt;?import javafx.scene.text.*?&gt;<br/><br/>    &lt;AnchorPane id="AnchorPane" maxHeight="-Infinity"<br/>     maxWidth="-Infinity" minHeight="-Infinity"<br/>     minWidth="-Infinity" prefHeight="400.0" prefWidth="600.0"<br/>      <br/>     &gt;<br/>     &lt;children&gt;<br/>       &lt;TitledPane animated="false" collapsible="false"<br/>        layoutX="108.0" layoutY="49.0" text="Sample"&gt;<br/>       &lt;content&gt;<br/>         &lt;AnchorPane id="Content" minHeight="0.0" minWidth="0.0"<br/>          prefHeight="180.0" prefWidth="200.0"&gt;<br/>         &lt;children&gt;<br/>           &lt;CheckBox layoutX="26.0" layoutY="33.0" <br/>            mnemonicParsing="false" prefWidth="94.0" <br/>            text="CheckBox" /&gt;<br/>           &lt;ColorPicker layoutX="26.0" layoutY="65.0" /&gt;<br/>           &lt;Hyperlink layoutX="26.0" layoutY="103.0"<br/>            text="Hyperlink" /&gt;<br/>           &lt;Label alignment="CENTER" layoutX="14.0" layoutY="5.0" <br/>            prefWidth="172.0" text="This is a Label"<br/>            textAlignment="CENTER"&gt;<br/>            &lt;font&gt;<br/>              &lt;Font size="14.0" /&gt;<br/>            &lt;/font&gt;<br/>           &lt;/Label&gt;<br/>           &lt;Button layoutX="81.0" layoutY="146.0" <br/>            mnemonicParsing="false" text="Button" /&gt;<br/>         &lt;/children&gt;<br/>         &lt;/AnchorPane&gt;<br/>       &lt;/content&gt;<br/>       &lt;/TitledPane&gt;<br/>     &lt;/children&gt;<br/>    &lt;/AnchorPane&gt;</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Implications for Java 9</h1>
                </header>
            
            <article>
                
<p>Prior to Java 9, JavaFX controls as well as CSS functionality were only available to developers by interfacing with internal APIs. Java 9's modularization has made the internal APIs inaccessible. Therefore, JEP 253 was created to define public, instead of internal, APIs.</p>
<p>This was a larger undertaking than it might seem. Here are a few actions that were taken as part of this JEP:</p>
<ul>
<li>Moving javaFX control skins from the internal to public API (<kbd>javafx.scene.skin</kbd>)</li>
<li>Ensuring API consistencies</li>
<li>Generation of a thorough javadoc</li>
</ul>
<p>The following classes were moved from internal packages to a public <kbd>javafx.scene.control.skin</kbd> package:</p>
<table>
<tbody>
<tr>
<td><kbd>AccordionSkin</kbd></td>
<td><kbd>ButtonBarSkin</kbd></td>
<td><kbd>ButtonSkin</kbd></td>
<td><kbd>CellSkinBase</kbd></td>
</tr>
<tr>
<td><kbd>CheckBoxSkin</kbd></td>
<td><kbd>ChoiceBoxSkin</kbd></td>
<td><kbd>ColorPickerSkin</kbd></td>
<td><kbd>ComboBoxBaseSkin</kbd></td>
</tr>
<tr>
<td><kbd>ComboBoxListViewSkin</kbd></td>
<td><kbd>ComboBoxPopupControl</kbd></td>
<td><kbd>ContextMenuSkin</kbd></td>
<td><kbd>DateCellSkin</kbd></td>
</tr>
<tr>
<td><kbd>DatePickerSkin</kbd></td>
<td><kbd>HyperLinkSkin</kbd></td>
<td><kbd>LabelSkin</kbd></td>
<td><kbd>LabeledSkinBase</kbd></td>
</tr>
<tr>
<td><kbd>ListCellSkin</kbd></td>
<td><kbd>ListViewSkin</kbd></td>
<td><kbd>MenuBarSkin</kbd></td>
<td><kbd>MenuButtonSkin</kbd></td>
</tr>
<tr>
<td><kbd>MenuButtonSkinbase</kbd></td>
<td><kbd>NestedTableColumHeader</kbd></td>
<td><kbd>PaginationSkin</kbd></td>
<td><kbd>ProgressBarSkin</kbd></td>
</tr>
<tr>
<td><kbd>ProgressIndicatorSkin</kbd></td>
<td><kbd>RadioButtonSkin</kbd></td>
<td><kbd>ScrollBarSkin</kbd></td>
<td><kbd>ScrollPaneSkin</kbd></td>
</tr>
<tr>
<td><kbd>SeparatorSkin</kbd></td>
<td><kbd>SliderSkin</kbd></td>
<td><kbd>SpinnerSkin</kbd></td>
<td><kbd>SplitMenuButtonSkin</kbd></td>
</tr>
<tr>
<td><kbd>SplitPaneSkin</kbd></td>
<td><kbd>TabPaneSkin</kbd></td>
<td><kbd>TableCellSkin</kbd></td>
<td><kbd>TableCellSkinBase</kbd></td>
</tr>
<tr>
<td><kbd>TableColumnHeader</kbd></td>
<td><kbd>TableHeaderRow</kbd></td>
<td><kbd>TableHeaderSkin</kbd></td>
<td><kbd>TableRowSkinBase</kbd></td>
</tr>
<tr>
<td><kbd>TableViewSkin</kbd></td>
<td><kbd>TableViewSkinBase</kbd></td>
<td><kbd>TextAreaSkin</kbd></td>
<td><kbd>TextFieldSkin</kbd></td>
</tr>
<tr>
<td><kbd>TextInputControlSkin</kbd></td>
<td><kbd>TitledPaneSkin</kbd></td>
<td><kbd>ToggleButtonSkin</kbd></td>
<td><kbd>TooBarSkin</kbd></td>
</tr>
<tr>
<td><kbd>TooltipSkin</kbd></td>
<td><kbd>TreeCellSkin</kbd></td>
<td><kbd>TreeTableCellSkin</kbd></td>
<td><kbd>TreeTableRowSkin</kbd></td>
</tr>
<tr>
<td><kbd>TreeTableViewSkin</kbd></td>
<td><kbd>TreeViewSkin</kbd></td>
<td><kbd>VirtualContainerBase</kbd></td>
<td><kbd>VirtualFlow</kbd></td>
</tr>
</tbody>
</table>
<p> </p>
<p>The public <kbd>javafx.css</kbd> package now has the additional classes:</p>
<ul>
<li><kbd>CascadingStyle.java:public class CascadingStyle implements Comparable&lt;CascadingStyle&gt;</kbd></li>
<li><kbd>CompoundSelector.java:final public class CompoundSelector extends Selector</kbd></li>
<li><kbd>CssError.java:public class CssError</kbd></li>
<li><kbd>Declaration.java:final public class Declaration</kbd></li>
<li><kbd>Rule.java:final public class Rule</kbd></li>
<li><kbd>Selector.java:abstract public class Selector</kbd></li>
<li><kbd>SimpleSelector.java:final public class SimpleSelector extends Selector</kbd></li>
<li><kbd>Size.java:final public class Size</kbd></li>
<li><kbd>Style.java:final public class Style</kbd></li>
<li><kbd>Stylesheet.java:public class Stylesheet</kbd></li>
<li><kbd>CssParser.java:final public class CssParser</kbd></li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Compact strings [JEP 254]</h1>
                </header>
            
            <article>
                
<p><span>The string data type is an important part of nearly every Java app. While JEP 254's aim was to make strings more space-efficient, it was approached with caution so that existing performance and compatibilities would not be negatively impacted.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Pre-Java 9 status</h1>
                </header>
            
            <article>
                
<p>Prior to Java 9, string data was stored as an array of chars. This required 16 bits for each char. It was determined that the majority of String objects could be stored with only 8 bits, or 1 byte of storage. This is due to the fact that most strings consist of Latin-1 characters.</p>
<div class="packt_infobox">The ISO Latin-1 Character Set is a single-byte set of character's encodings.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">New with Java 9</h1>
                </header>
            
            <article>
                
<p>Starting with Java 9, strings are now internally represented using a byte array along with a flag field for encoding references.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Merging selected Xerces 2.11.0 updates into JAXP [JEP 255]</h1>
                </header>
            
            <article>
                
<p><span>Xerces is a library used for parsing XML in Java. It was updated to 2.11.0 in late 2010, so JEP 255's aim was to update JAXP to incorporate changes in Xerces 2.11.0.</span></p>
<div class="packt_infobox">JAXP is Java's API for XML processing.</div>
<p>Prior to Java 9, the JDK's latest update regarding XML processing was based on Xerces 2.7.1. There were some additional changes to JDK 7 based on Xerces, 2.10.0. JEP 255 is a further refinement of the JAXP based on Xerces 2.11.0.</p>
<p>Xerces 2.11.0 supports the following standards:</p>
<ul>
<li>XML 1.0, Fourth Edition</li>
<li>Namespaces in XML 1.0, Second Edition</li>
<li>XML 1.1, Second Edition</li>
<li>Namespaces in XML 1.1, Second Edition</li>
<li>XML Inclusions 1.0, Second Edition</li>
<li><strong>Document Object Model</strong> (<strong>DOM</strong>)
<ul>
<li>Level 3
<ul>
<li>Core</li>
<li>Load &amp; save</li>
</ul>
</li>
<li>Level 2
<ul>
<li>Core</li>
<li>Events</li>
</ul>
</li>
</ul>
</li>
<li>Traversal &amp; Range</li>
<li>Element Traversal, First Edition</li>
<li>Simple API for XML 2.0.2</li>
<li><strong>Java APIs for XML Processing</strong> (<strong>JAXP</strong>) 1.4</li>
<li>Streaming API for XML 1.0</li>
<li>XML Schema 1.0</li>
<li>XML Schema 1.1</li>
<li>XML Schema Definition Language</li>
</ul>
<p>The JDK was updated to include the following Xerces 2.11.0 categories:</p>
<ul>
<li>Catalog resolver</li>
<li>Datatypes</li>
<li>Document Object Model Level 3</li>
<li>XML Schema Validation</li>
<li>XPointer</li>
</ul>
<p>The public API for JAXP was not changed in Java 9.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Updating JavaFX/Media to newer version of GStreamer [JEP 257]</h1>
                </header>
            
            <article>
                
<p><span>JavaFX is used for creating desktop and web applications. JavaFX was created to replace Swing as Java's standard GUI library. The <kbd>Media</kbd> class, <kbd>javafx.scene.media.Media</kbd>, is used to instantiate an object representing a media resource. JavaFX/Media refers to the following class:</span></p>
<pre>    public final class Media extends java.lang.Object</pre>
<p>This class provides referential data to a media resource. The <kbd>javafx.scene.media</kbd> package provides developers with the ability to incorporate media into their JavaFX applications. JavaFX/Media utilizes a GStreamer pipeline.</p>
<div class="packt_infobox">GStreamer is a multimedia processing framework that can be used to build systems that take in media from several different formats and, after processing, export them in selected formats.</div>
<p>The purpose of JEP 257 was to ensure JavaFX/Media was updated to include the latest release of GStreamer for stability, performance, and security assurances.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">HarfBuzz Font-Layout Engine [JEP 258]</h1>
                </header>
            
            <article>
                
<p><span>Prior to Java 9, the layout engine used to handle font complexities; specifically fonts that have rendering behaviors beyond what the common Latin fonts have. Java used the uniform client interface, also referred to as ICU, as the defacto text rendering tool. The ICU layout engine has been depreciated and, in Java 9, has been replaced with the HarfBuzz font layout engine.</span></p>
<p>HarfBuzz is an <strong>OpenType</strong> text rendering engine. This type of layout engine has the characteristic of providing script-aware code to help ensure text is laid out as desired.</p>
<div class="packt_infobox">OpenType is an HTML formatted font format specification.</div>
<p>The impetus for the change from the ICU Layout Engine to the HarfBuzz Font Layout Engine was IBM's decision to cease supporting the ICU Layout Engine. Therefore, the JDK was updated to contain the HarfBuzz Font Layout Engine.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">HiDPI graphics on Windows and Linux [JEP 263]</h1>
                </header>
            
            <article>
                
<p><span>JEP 263 was focused on ensuring the crispness of on-screen components, relative to the pixel density of the display. The following terms are relevant to this JEP and are provided along with the below listed descriptive information:</span></p>
<ul>
<li><strong>DPI-aware application</strong>: An application that is able to detect and scale images for the display's specific pixel density</li>
<li><strong>DPI-unaware application</strong>: An application that makes no attempt to detect and scale images for the display's specific pixel density</li>
<li><strong>HiDPI graphics</strong>: High dots-per-inch graphics</li>
<li><strong>Retina display</strong>: This term was created by Apple to refer to displays with a pixel density of at least 300 pixels per inch</li>
</ul>
<p>Displaying graphics, both images and graphical user interface components, to the user is typically of paramount performance. Displaying this imagery in high quality can be somewhat problematic. There is large variability in computer monitor DPIs. There are three basic approaches to developing for displays:</p>
<ul>
<li>Develop apps without regard for the potential different display dimensions. In other words, create a DPI-unaware application.</li>
<li>Develop a DPI-aware application that selectively uses pre-rendered image sizes for a given display.</li>
<li>Develop a DPI-aware application that properly scales images up/down to account for the specific display the application is run on.</li>
</ul>
<p>Clearly, the first two approaches are problematic, and for different reasons. With the first approach, the user experience is not considered. Of course, if the application was being developed for a very specific display with no expected pixel density variability, then this approach could be viable.</p>
<p>The second approach requires a lot of work on the design and development end to ensure images for each expected display density are created and implemented programmatically. In addition to the tremendous amount of work, the app size will unnecessarily increase, and new and different pixel densities will not have been accounted for.</p>
<p>The third approach is to create a DPI-aware application with efficient and effective scaling capabilities. This approach works well and has been proven with the Mac retina displays.</p>
<p>Prior to Java 9, automatic scaling and sizing was already implemented in Java for the Mac OS X operating system. This capability was added in Java 9 for Windows and Linux operating systems.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Marlin graphics renderer [JEP 265]</h1>
                </header>
            
            <article>
                
<p><span>JEP 265 replaced the Pisces graphics rasterizer with the Marlin graphics renderer in the Java 2D API. This API is used to draw 2D graphics and animations.</span></p>
<p>The goal was to replace Pisces with a rasterizer/renderer that was much more efficient and without any quality loss. This goal was realized in Java 9. An intended collateral benefit was to include a developer-accessible API. Previously, the means of interfacing with the AWT and Java 2D was internal.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Unicode 8.0.0 [JEP 267]</h1>
                </header>
            
            <article>
                
<p><span>Unicode 8.0.0 was released on June 17, 2015. JEP 267 focused on updating the relevant APIs to support Unicode 8.0.0.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">New in Unicode 8.0.0</h1>
                </header>
            
            <article>
                
<p>Unicode 8.0.0 added nearly 8,000 characters. Here are the highlights of the release:</p>
<ul>
<li>Ahom script for the Tai Ahom language (India)</li>
<li>Arwi, Tamil language (Arabic)</li>
<li>Cherokee symbols</li>
<li>CJK unified ideographs</li>
<li>Emoji symbols along with flesh-tone symbol modifiers</li>
<li>Georgian lari currency symbol</li>
<li>lk language (Uganda)</li>
<li>Kulango languge (<span>Côte d’Ivoire</span>)</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Updated Classes in Java 9</h1>
                </header>
            
            <article>
                
<p>In order to fully comply with the new Unicode standard, several Java classes were updated. The following listed classes were updated for Java 9 to comply with the new Unicode standard:</p>
<ul>
<li><kbd>java.awt.font.NumericShaper</kbd></li>
<li><kbd>java.lang.Character</kbd></li>
<li><kbd>java.lang.String</kbd></li>
<li><kbd>java.text.Bidi</kbd></li>
<li><kbd>java.text.BreakIterator</kbd></li>
<li><kbd>java.text.Normalizer</kbd></li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Reserved stack areas for critical sections [JEP 270]</h1>
                </header>
            
            <article>
                
<p><span>The goal of JEP 270 was to mitigate problems stemming from stack overflows during the execution of critical sections. This mitigation took the form of reserving additional thread stack space.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The pre-Java 9 situation</h1>
                </header>
            
            <article>
                
<p>The JVM throws a <kbd>StackOverflowError</kbd> when it is asked to perform data computation in a thread that has insufficient stack space and does not have permission to allocate additional space. This is an asynchronous exception. The JVM can also throw the <kbd>StackOverflowError</kbd> exception synchronously when a method is invoked.</p>
<p>When a method is invoked, an internal process is used to report the Stack Overflow. While the current schema works sufficiently for reporting the error, there is no room for the calling application to easily recover from the error. This can result in being more than a nuisance for developers and users. If the <kbd>StackOverflowError</kbd> was thrown during a critical computational operation, the data might be corrupted, causing additional problems.</p>
<p>While not the sole cause of these problems, the effected status of locks from the <kbd>ReentrantLock</kbd> class were a common cause of undesirable outcomes. This issue was evident in Java 7 because the <kbd>ConcurrentHasMap</kbd> code implemented the <kbd>ReentrantLock</kbd> class. The <kbd>ConcurrentHasMap</kbd> code was modified for Java 8, but problems still persisted for any implementation of the <kbd>ReentrantLock</kbd> class. Similar problems existed beyond just <kbd>ReentrantLock</kbd> class usage.</p>
<p>The following diagram provides a broad overview of the <kbd>StackOverflowError</kbd> problem:</p>
<div class="CDPAlignCenter CDPAlign"><img height="188" width="530" src="assets/3cf09c85-193f-4775-903d-812a81622175.png"/></div>
<p>In the next section, we will look at how this issue was resolved for Java 9.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">New in Java 9</h1>
                </header>
            
            <article>
                
<p>With the JEP 270 changes for Java 9, a critical section will automatically be given additional space so that it can complete its execution and not suffer from the <kbd>StackOverflowError</kbd>. This is predicated on the additional space allocation needs being small. The necessary changes have been made to the JVM to permit this functionality.</p>
<p>The JVM actually delays the <kbd>StackOverflowError</kbd>, or at least attempts to, while critical sections are executing. In order to capitalize on this new schema, methods must be annotated with the following:</p>
<pre>    jdk.internal.vm.annotation.ReservedStackAccess</pre>
<p>When a method has this annotation and a <kbd>StackOverflowError</kbd> condition exists, temporary access to the reserved memory space is granted. The new process is, at a high level of abstraction, presented as follows:</p>
<div class="CDPAlignCenter CDPAlign"><img height="271" width="495" src="assets/7a3c5ac5-5f52-41fc-806e-3767a1ce541e.png"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Dynamic linking of language-defined object models [JEP 276]</h1>
                </header>
            
            <article>
                
<p><span>Java interoperability was enhanced with JEP 276. The necessary JDK changes were made to permit runtime linkers from multiple languages to coexist in a single JVM instance. This change applies to high-level operations, as you would expect. An example of a relevant high-level operation is the reading or writing of a property with elements such as accessors and mutators.</span></p>
<p>The high-level operations apply to objects of unknown types. They can be invoked with <kbd>INVOKEDYNAMIC</kbd> instructions. Here is an example of calling an object's property when the object's type is unknown at compile time:</p>
<pre>    INVOKEDYNAMIC "dyn:getProp:age"</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Proof of concept</h1>
                </header>
            
            <article>
                
<p>Nashorn is a lightweight, high-performance, JavaScript runtime that permits embedding JavaScript in Java applications. This was created for Java 8 and replaced the previous JavaScript scripting engine that was based on Mozilla Rhino. Nashorn already has this functionality. It provides linkage between high-level operations on any object of unknown type, such as <kbd>obj.something</kbd>, where it produces the following:</p>
<pre>    INVOKEDYNAMIC "dyn.getProp.something"</pre>
<p>The dynamic linker springs into action and provides, when possible, the appropriate implementation.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Additional tests for humongous objects in G1 [JEP 278]</h1>
                </header>
            
            <article>
                
<p><span>One of the long-favored features of the Java platform is the behind the scenes garbage collection. JEP 278's focus was to create additional WhiteBox tests for humongous objects as a feature of the G1 garbage collector.</span></p>
<div class="packt_infobox">WhiteBox testing is an API used to query JVM internals. The WhiteBox testing API was introduced in Java 7 and upgraded in Java 8 and Java 9.</div>
<p>The G1 garbage collector works extremely well, but there was room for some improved efficiency. The way the G1 garbage collector worked is based on first dividing the heap into regions of equal size, illustrated as follows:</p>
<div class="CDPAlignCenter CDPAlign"><img height="326" width="328" src="assets/8a7a7ad8-1e26-41cd-9d1c-53f866e21cdc.png"/></div>
<p>The problem with the G1 garbage collector was how humongous objects were handled.</p>
<div class="packt_infobox">A humongous object in the context of garbage collection, is any object that takes up more than one region on the heap.</div>
<p>The problem with humongous objects was that if they took up any part of a region on the heap, the remaining space was not able to be allocated for other objects. In Java 9, the WhiteBox API was extended with four types of new methods:</p>
<ul>
<li>Methods with the purpose of blocking full garbage collection and to initiate concurrent marking.</li>
<li>Methods that can access individual G1 garbage collection heap regions. Access to these regions consist of attribute reading, such as with the current state of the region.</li>
<li>Methods with direct access to the G1 garbage collection internal variables.</li>
<li>Methods that can determine if humongous objects reside on the heap and, if so, in what regions.</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Improving test-failure troubleshooting [JEP 279]</h1>
                </header>
            
            <article>
                
<p><span>For developers that do a lot of testing, JEP 279 is worth reading about. Additional functionality has been added in Java 9 to automatically collect information to support troubleshooting test failures as well as timeouts. Collecting readily available diagnostic information during tests stands to provide developers and engineers with greater fidelity in their logs and other output.</span></p>
<p>There are two basic types of information in the context of testing--environmental and process.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Environmental information</h1>
                </header>
            
            <article>
                
<p>When running tests, the testing environment information can be important for troubleshooting efforts. This information includes the following:</p>
<ul>
<li>CPU loads</li>
<li>Disk space</li>
<li>I/O loads</li>
<li>Memory space</li>
<li>Open files</li>
<li>Open sockets</li>
<li>Processes running</li>
<li>System events</li>
<li>System messages</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Java process information</h1>
                </header>
            
            <article>
                
<p>There is also information available during the testing process directly related to Java processes. These include:</p>
<ul>
<li>C stacks</li>
<li>Core dumps</li>
<li>Mini dumps</li>
<li>Heap statistics</li>
<li>Java stacks</li>
</ul>
<div class="packt_tip">For additional information on this concept, read about the JDK's regression test harness (jtreg).</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Optimizing string concatenation [JEP 280]</h1>
                </header>
            
            <article>
                
<p><span>JEP 280 is an interesting enhancement for the Java platform. Prior to Java 9, string concatenation was translated by javac into</span> <kbd>StringBuilder : : append</kbd> <span>chains. This was a sub-optimal translation methodology often requiring <kbd>StringBuilder</kbd> presizing.</span></p>
<p>The enhancement changed the string concatenation bytecode sequence, generated by javac, so that it uses <kbd>INVOKEDYNAMIC</kbd> calls. The purpose of the enhancement was to increase optimization and to support future optimizations without the need to reformat the javac's bytecode.</p>
<div class="packt_tip">See JEP 276 for more information on <kbd>INVOKEDYNAMIC</kbd>.</div>
<p>The use of <kbd>INVOKEDYAMIC</kbd> calls to <kbd>java.lang.invoke.StringConcatFactory</kbd> allows us to use a methodology similar to lambda expressions instead of using StringBuilder's step-wise process. This results in more efficient processing of string concatenation.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">HotSpot C++ unit-test framework [JEP 281]</h1>
                </header>
            
            <article>
                
<p><span>HotSpot is the name of the JVM. This Java enhancement was intended to support the development of C++ unit tests for the JVM. Here is a partial, non-prioritized, list of goals for this enhancement:</span></p>
<ul>
<li>Command-line testing</li>
<li>Create appropriate documentation</li>
<li>Debug compile targets</li>
<li>Framework elasticity</li>
<li>IDE support</li>
<li>Individual and isolated unit testing</li>
<li>Individualized test results</li>
<li>Integrate with existing infrastructure</li>
<li>Internal test support</li>
<li>Positive and negative testing</li>
<li>Short execution time testing</li>
<li>Support all JDK 9 build platforms</li>
<li>Test compile targets</li>
<li>Test exclusion</li>
<li>Test grouping</li>
<li>Testing that requires the JVM to be initialized</li>
<li>Tests co-located with source code</li>
<li>Tests for platform-dependent code</li>
<li>Write and execute unit testing (for classes and methods)</li>
</ul>
<p>This enhancement is evidence of the increasing extensibility.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Enabling GTK 3 on Linux [JEP 283]</h1>
                </header>
            
            <article>
                
<p><span>GTK+, formally known as the GIMP toolbox, is a cross-platform tool used for creating <strong>Graphical User Interfaces</strong> (<strong>GUI</strong>). The tool consists of widgets accessible through its API. JEP 283's focus was to ensure GTK 2 and GTK 3 were supported on Linux when developing Java applications with graphical components. The implementation supports Java apps that employ JavaFX, AWT, and Swing.</span></p>
<p>We can create Java graphical applications with JavaFX, AWT, and Swing. Here is a table to summarize those three approaches as they relate to GTK, prior to Java 9:</p>
<table>
<tbody>
<tr>
<td><strong>Approach</strong></td>
<td><strong>Remarks</strong></td>
</tr>
<tr>
<td>JavaFX</td>
<td>
<ul>
<li>Uses a dynamic GTK function lookup</li>
<li>Interacts with AWT and Swing via JFXPanel</li>
<li>Uses AWT printing functionality</li>
</ul>
</td>
</tr>
<tr>
<td>AWT</td>
<td>
<ul>
<li>Uses a dynamic GTK function lookup</li>
</ul>
</td>
</tr>
<tr>
<td>Swing</td>
<td>
<ul>
<li>Uses a dynamic GTK function lookup</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p> </p>
<p>So, what changes were necessary to implement this JEP? For JavaFX, three specific things were changed:</p>
<ul>
<li>Automated testing was added for both GTK 2 and GTK 3</li>
<li>Functionality was added to dynamically load GTK 2</li>
<li>Support was added for GTK 3</li>
</ul>
<p>For AWT and Swing, the following changes were implemented:</p>
<ul>
<li>Automated testing was added for both GTK 2 and GTK 3</li>
<li><kbd>AwtRobot</kbd> was migrated to GTK 3</li>
<li><kbd>FileChooserDilaog</kbd> was updated for GTK 3</li>
<li>Functionality was added to dynamically load GTK 3</li>
<li>The Swing GTK LnF was modified to support GTK 3</li>
</ul>
<div class="packt_infobox">Swing GTK LnF is short for Swing GTK look and feel.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">New HotSpot build system [JEP 284]</h1>
                </header>
            
            <article>
                
<p><span>The Java platform used, prior to Java 9, was a build system riddled with duplicate code, redundancies, and other inefficiencies. The build system has been reworked for Java 9 based on the build-infra framework. In this context, infra is short for infrastructure. The overarching goal for JEP 284 was to upgrade the build system to one that was simplified. Specific goals included:</span></p>
<div>
<ul>
<li>Leverage existing build system</li>
<li>Maintainable code</li>
<li>Minimize duplicate code</li>
<li>Simplification</li>
<li>Support future enhancements</li>
</ul>
</div>
<p>You can learn more about Oracle's infrastructure framework at this site: <a href="http://www.oracle.com/technetwork/oem/frmwrk-infra-496656.html">http://www.oracle.com/technetwork/oem/frmwrk-infra-496656.html</a></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>In this chapter, we covered some impressive new features of the Java platform, with specific focus on javac, JDK libraries, and various test suites. Memory management improvements, including heap space efficiencies, memory allocation, and improved garbage collection represent a powerful new set of Java platform enhancements. Changes regarding the compilation process resulting in greater efficiencies were part of our chapter. We also covered important improvements, such as with the compilation process, type testing, annotations, and automated runtime compiler tests.</p>
<p>In the next chapter, we will look at several minor language enhancements introduced in Java 9.</p>


            </article>

            
        </section>
    </body></html>