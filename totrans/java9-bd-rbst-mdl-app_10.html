<html><head></head><body><div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Making Use of the ProcessHandle API</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">In the previous chapter, we discovered the <strong class="calibre8">Java Microbenchmark Harness</strong> (<strong class="calibre8">JMH</strong>). We explored performance tests and how to write them using JMH, the Java library for writing benchmarks for the Java Virtual Machine. We started with an overview of microbenchmarking, then looked at microbenchmarking with Maven, reviewed benchmarking options, and concluded with techniques for avoiding microbenchmarking pitfalls.</p>
<p class="mce-root">In this chapter, we will focus on the updates to the <kbd class="calibre16">Process</kbd> class and the new <kbd class="calibre16">java.lang.ProcessHandle</kbd> API. Prior to Java 9, managing processes in Java was never easy, because Java was rarely used to automate the controlling of other processes. The API was insufficient with some features lacking and some tasks needed to be solved in a system specific manner. For example, in Java 8, giving a process access to its own <strong class="calibre8">process identifier</strong> (<strong class="calibre8">PID</strong>) was an unnecessarily difficult task.</p>
<p class="mce-root">In this chapter, the reader will gain all the knowledge that is needed to write an application that manages other processes and utilizes the modern process management API of Java.</p>
<p class="mce-root">We will cover the following topics in this chapter:</p>
<ul class="calibre13">
<li class="calibre14">What is and how to use the new <kbd class="calibre16">ProcessHandle</kbd> interface</li>
<li class="calibre14">How to get the PID of the current process</li>
<li class="calibre14">How to list different processes that run in the operating system</li>
<li class="calibre14">How to effectively wait for an external process to finish</li>
<li class="calibre14">How to terminate external processes</li>
</ul>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">What are processes?</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">In this section, we will review what processes are in the context of Java application programming. If you are already familiar with processes, you might consider skipping this section.</p>
<p class="mce-root">Processes are executional units in the operating system. When you start a program, you start a process. When the machine boots the code, the first thing it does is, execute the boot process. This process then starts other processes that become the child of the boot process. These child processes may start other processes. This way, when the machine runs there are trees of processes running. When the machine does something, it is done in some code executing inside some process. The operating system also runs as several processes that execute simultaneously. Applications are executed as one or more processes. Most of the applications run as a single process but as an example, the Chrome browser starts several processes to do all the rendering and network communication operations that finally function as a browser.</p>
<p class="mce-root">To get a better idea about what processes are, start the task manager on Windows or the <span class="calibre7">Activity Monitor</span> on OS X and click on the <span class="calibre7">Process</span> tab. You will see the different processes that currently exist on the machine. Using these tools, you can look at the parameters of the processes, or you can kill an individual process.</p>
<p class="mce-root">The individual processes have their memory allocated for their work and they are not allowed to freely access each other's memory.</p>
<p class="mce-root">The execution unit scheduled by the operating system is a thread. A process consists of one or more threads. These threads are scheduled by the operating system scheduler and are executed in time slots.</p>
<p class="mce-root">With every operating system, processes have a process identifier, which is a number that identifies the process. No two processes can be active at a time, sharing the same PID. When we want to identify an active process in the operating system we use the PID. On Linux and other Unix-like operating systems, the <kbd class="calibre16">kill</kbd> command terminates a process. The argument to be passed to this program is the PID of the process, to terminate. Termination can be graceful. It is something like asking the process to exit. If the process decides not to, it can keep running. Programs can be prepared to stop upon such requests. For example, a Java application may add a <kbd class="calibre16">Thread</kbd> object calling the <kbd class="calibre16">Runtime.getRuntime().addShutdownHook(Thread t)</kbd> method. The <span class="calibre7">thread</span> passed is supposed to start when the process is asked to stop and the thread can perform all tasks that the program has to do before it exits. However, there is no guarantee that it does start. It depends on the actual implementation.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">The new ProcessHandle interface</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">There are two new interfaces and also their implementations in Java 9 supporting the handling of operating system processes. One of them is <kbd class="calibre16">ProcessHandle</kbd>, the other one is <kbd class="calibre16">ProcessHandle.Info</kbd>, a nested interface of the prior.</p>
<p class="mce-root">A <kbd class="calibre16">ProcessHandle</kbd> object identifies an operating system process and provides methods to manage the process. In prior versions of Java, this was possible only using operating system specific methods using the PID to identify the process. The major problem with this approach is that the PID is unique only while the process is active. When a process finishes, the operating system is free to reuse the <span class="calibre7">PID</span> for a new process. When we know only the PID of a process and check to see if the process is still running, what we are really doing is checking if there is an active process with that PID. Our process may be alive when we check it, but the next time our program queries the process state, it might be a different process.</p>
<p class="mce-root">The desktop and server operating systems try not to reuse the PID values for as long as possible. On some embedded systems the operating system may only use 16-bit to store the <span class="calibre7">PID</span>. When only 16-bit values are used, there is a greater chance that the PIDs will be reused. We can avoid this problem using the <kbd class="calibre16">ProcessHandle</kbd> API. We can receive a <kbd class="calibre16">ProcessHandle</kbd> and can call the <kbd class="calibre16">handle.isAlive()</kbd> method. This method will return <kbd class="calibre16">false</kbd> when the process finishes. This works even if the PID was reused.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Getting the PID of the current process</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">We can gain access to the PID of the processes via the handle. The <kbd class="calibre16">handle.getPid()</kbd><span class="calibre7">method</span> returns a <kbd class="calibre16">Long</kbd> representing the numerical value of the PID. Since it is safer to access the processes through the handle, the importance of this method is limited. It may come in handy when our code wants to give information about itself to some other management tool. It is a common practice for programs to create a file that has the numeric PID as the name of the file. It may be a requirement that a certain program does not run in multiple processes. In that case, the code writes its own PID file to a specific directory. If a PID file with that name already exists, processing stops. If the previous process crashed and terminated without deleting the PID file, then the system manager can easily delete the file and start the new process. If the program hangs, then the system manager can easily kill the dead process if s/he knows the PID.</p>
<p class="mce-root">To get the PID of the current process, the call chain <kbd class="calibre16">ProcessHandle.current(). getPid()</kbd> can be used.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Getting information about a process</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">To get information about a process, we need access to the <kbd class="calibre16">Info</kbd> object of the process. This is available through a <kbd class="calibre16">ProcessHandle</kbd>. We use a call to the <kbd class="calibre16">handle.info()</kbd> method to return it.</p>
<p class="mce-root">The <kbd class="calibre16">Info</kbd> interface defines query methods that deliver information about the process. These are:</p>
<ul class="calibre13">
<li class="calibre14"><kbd class="calibre16">command()</kbd> returns an <kbd class="calibre16">Optional&lt;String&gt;</kbd> containing the command that was used to start the process</li>
<li class="calibre14"><kbd class="calibre16">arguments()</kbd> returns an <kbd class="calibre16">Optional&lt;String[]&gt;</kbd> that contains the arguments that were used on the command-line after the command to start the process</li>
<li class="calibre14"><kbd class="calibre16">commandLine()</kbd> returns an <kbd class="calibre16">Optional&lt;String&gt;</kbd> that contains the whole command-line</li>
<li class="calibre14"><kbd class="calibre16">startInstant()</kbd> returns an <kbd class="calibre16">Optional&lt;Instant&gt;</kbd>, which essentially represents the time the process was started</li>
<li class="calibre14"><kbd class="calibre16">totalCpuDuration()</kbd> returns an <kbd class="calibre16">Optional&lt;Duration&gt;</kbd>, which represents the CPU time used by the process since it was started</li>
<li class="calibre14"><kbd class="calibre16">user()</kbd> returns an <kbd class="calibre16">Optional&lt;String&gt;</kbd> that holds the name of the user the process belongs to</li>
</ul>
<p class="mce-root">The values returned by these methods are all <kbd class="calibre16">Optional</kbd> because there is no guarantee that the actual operating system or the Java implementation can return the information. However, on most operating systems it should work and the returned values should be present.</p>
<p class="mce-root">The following sample code displays the information on a given process:</p>
<pre class="calibre21">    import java.io.IOException;<br class="calibre2"/>    import java.time.Duration;<br class="calibre2"/>    import java.time.Instant;<br class="calibre2"/>    public class ProcessHandleDemonstration<br class="calibre2"/>    {<br class="calibre2"/>      public static void main(String[] args) throws <br class="calibre2"/>       InterruptedException, IOException<br class="calibre2"/>      {<br class="calibre2"/>        provideProcessInformation(ProcessHandle.current());<br class="calibre2"/>        Process theProcess = new<br class="calibre2"/>         ProcessBuilder("SnippingTool.exe").start();<br class="calibre2"/>        provideProcessInformation(theProcess.toHandle());<br class="calibre2"/>        theProcess.waitFor();<br class="calibre2"/>        provideProcessInformation(theProcess.toHandle());<br class="calibre2"/>      }<br class="calibre2"/>      static void provideProcessInformation(ProcessHandle theHandle)<br class="calibre2"/>      {<br class="calibre2"/>        // get id<br class="calibre2"/>        long pid = ProcessHandle.current().pid();<br class="calibre2"/>        // Get handle information (if available)<br class="calibre2"/>        ProcessHandle.Info handleInformation = theHandle.info();<br class="calibre2"/>        // Print header<br class="calibre2"/>        System.out.println("|=============================|");<br class="calibre2"/>        System.out.println("| INFORMATION ON YOUR PROCESS |");<br class="calibre2"/>        System.out.println("|=============================|n");<br class="calibre2"/>        // Print the PID<br class="calibre2"/>        System.out.println("Process id (PID): " + pid);<br class="calibre2"/>        System.out.println("Process Owner: " + <br class="calibre2"/>          handleInformation.user().orElse(""));<br class="calibre2"/>        // Print additional information if available<br class="calibre2"/>        System.out.println("Command:" + <br class="calibre2"/>         handleInformation.command().orElse(""));<br class="calibre2"/>        String[] args = handleInformation.arguments().orElse<br class="calibre2"/>         (new String[]{});<br class="calibre2"/>        System.out.println("Argument(s): ");<br class="calibre2"/>        for (String arg: args) System.out.printf("t" + arg);<br class="calibre2"/>        System.out.println("Command line: " + handleInformation.<br class="calibre2"/>         commandLine().orElse(""));<br class="calibre2"/>        System.out.println("Start time: " + <br class="calibre2"/>         handleInformation.startInstant().<br class="calibre2"/>         orElse(Instant.now()).toString());<br class="calibre2"/>        System.out.printf("Run time duration: %sms%n",<br class="calibre2"/>         handleInformation.totalCpuDuration()<br class="calibre2"/>         .orElse(Duration.ofMillis(0)).toMillis());<br class="calibre2"/>      }<br class="calibre2"/>    }</pre>
<p class="mce-root">Here is the console output for the preceding code:</p>
<div class="mce-root1"><img class="image-border" src="Images/b6e50be9-a42b-4244-b5ef-9c56c07b0918.png" width="711" height="223"/></div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Listing processes</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">Prior to Java 9, we did not have the means to obtain a list of active processes. With Java 9 it is now possible to get the processes in a stream. There are three methods that return a <kbd class="calibre16">Stream&lt;ProcessHandle&gt;</kbd>. One lists the child processes. The other lists all the descendants; the children and the children of those recursively. The third lists all the processes.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Listing children</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">To get the stream of process handles that can be used to control the children, the static method <kbd class="calibre16">processHandle.children()</kbd> should be used. This will create a snapshot of the children processes of the process represented by <kbd class="calibre16">processHandle</kbd> and create the <kbd class="calibre16">Stream</kbd>. Since processes are dynamic there is no guarantee that during the code execution, while our program attends to the handles, that all children processes are still active. Some of them may terminate and our process may spawn new children, perhaps from a different thread. Thus the code should not assume that each of the <kbd class="calibre16">ProcessHandle</kbd> elements of the stream represents an active and running process.</p>
<p class="mce-root">The following program starts 10 command prompts in Windows and then counts the number of children processes and prints it to standard output:</p>
<pre class="calibre21">    package packt.mastering.java9.process;<br class="calibre2"/>    <br class="calibre2"/>    import java.io.IOException;<br class="calibre2"/><br class="calibre2"/>    public class ChildLister {<br class="calibre2"/>      public static void main(String[] args) throws IOException {<br class="calibre2"/>        for (int i = 0; i &lt; 10; i++) {<br class="calibre2"/>          new ProcessBuilder().command("cmd.exe").start();<br class="calibre2"/>        }<br class="calibre2"/>        System.out.println("Number of children :" +<br class="calibre2"/>         ProcessHandle.current().children().count());<br class="calibre2"/>      }<br class="calibre2"/>    }</pre>
<p class="mce-root">Executing the program will result in the following:</p>
<div class="mce-root1"><img class="image-border1" src="Images/2a4889f9-7db7-4782-ba6c-aeff89937ce5.png" width="1093" height="210"/></div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Listing descendants</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">Listing the descendants is very similar to listing children, but if we call the <kbd class="calibre16">processHandle.descendants()</kbd> method then the <kbd class="calibre16">Stream</kbd> will contain all the children processes and the children processes of those processes and so on. The following program starts command prompts with command-line arguments so that they also spawn another <kbd class="calibre16">cmd.exe</kbd> that terminates:</p>
<pre class="calibre21">    package packt.mastering.java9.process;<br class="calibre2"/><br class="calibre2"/>    import java.io.IOException;<br class="calibre2"/>    import java.util.stream.Collectors;<br class="calibre2"/><br class="calibre2"/>    public class DescendantLister {<br class="calibre2"/>      public static void main(String[] args) throws IOException {<br class="calibre2"/>        for (int i = 0; i &lt; 10; i++) {<br class="calibre2"/>          new ProcessBuilder().command("cmd.exe","/K","cmd").                <br class="calibre2"/>           start();<br class="calibre2"/>        }<br class="calibre2"/>        System.out.println("Number of descendants: " +<br class="calibre2"/>         ProcessHandle.current().descendants().count();<br class="calibre2"/>      }<br class="calibre2"/>    }</pre>
<p class="mce-root">Running the command a few times will result in the following, non-deterministic output:</p>
<div class="mce-root1"><img class="image-border2" src="Images/eeff92fc-0f2e-4f28-ae6a-733dbaf8a370.png"/></div>
<p class="mce-root">The output clearly demonstrates that when the <kbd class="calibre16">Stream</kbd> of the descendants is created not all processes are alive. The sample code starts 10 processes and each of them starts another. The <kbd class="calibre16">Stream</kbd> does not have 20 elements because some of these sub-processes were terminated during processing.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Listing all processes</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">Listing all the processes is slightly different from listing descendants and children. The method <kbd class="calibre16">allProcess()</kbd> is static and returns a <kbd class="calibre16">Stream</kbd> of handles of all processes that are active in the operating system at the time of execution.</p>
<p class="mce-root">The following sample code prints the process commands to the console that seem to be Java processes:</p>
<pre class="calibre21">    package packt.mastering.java9.process;<br class="calibre2"/>    import java.lang.ProcessHandle.Info;<br class="calibre2"/>    public class ProcessLister {<br class="calibre2"/>      private static void out(String format, Object... params) {<br class="calibre2"/>        System.out.println(String.format(format, params));<br class="calibre2"/>      }<br class="calibre2"/>      private static boolean looksLikeJavaProcess(Info info) {<br class="calibre2"/>        return info.command().isPresent() &amp;&amp;<br class="calibre2"/>         info.command().get().<br class="calibre2"/>         toLowerCase().indexOf("java") != -1;<br class="calibre2"/>      }<br class="calibre2"/><br class="calibre2"/>      public static void main(String[] args) {<br class="calibre2"/>        ProcessHandle.allProcesses().<br class="calibre2"/>         map(ProcessHandle::info).<br class="calibre2"/>         filter(info -&gt; looksLikeJavaProcess(info)).<br class="calibre2"/>         forEach(<br class="calibre2"/>           (info) -&gt; System.out.println(<br class="calibre2"/>             info.command().orElse("---"))<br class="calibre2"/>         );<br class="calibre2"/>      }<br class="calibre2"/><br class="calibre2"/>    }</pre>
<p class="mce-root">The output of the program lists all the process commands that have the string <kbd class="calibre16">java</kbd> inside:</p>
<div class="mce-root1"><img class="image-border3" src="Images/9f029ce2-ba76-4987-82b1-7a59f58d2e6e.png"/></div>
<p class="mce-root">Your actual output may, of course, be different.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Waiting for processes</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">When a process starts another process, it may wait for the process many times because it needs the result of the other program. If the structure of the task can be organized in a way that the parent program can do something else while waiting for the child process to finish, then the parent process can invoke the <kbd class="calibre16">isAlive()</kbd> method on the process handle. Many times, the parent process has nothing to do until the spawned process finishes. Old applications implemented loops that called the <kbd class="calibre16">Thread.sleep()</kbd> method so CPU was not excessively wasted and from time to time the process was checked to see if it was still alive. Java 9 offers a much better approach to the waiting process.</p>
<p class="mce-root">The <kbd class="calibre16">ProcessHandle</kbd> interface has a method called <kbd class="calibre16">onExit</kbd> that returns a <kbd class="calibre16">CompletableFuture</kbd>. This class was introduced in Java 8 and makes it possible to wait for a task to be finished without looping. If we have the handle to a process we can simply call the <kbd class="calibre16">handle.onExit().join()</kbd> method to wait until the process finishes. The <kbd class="calibre16">get()</kbd> method of the returned <kbd class="calibre16">CompletableFuture</kbd> will return the <kbd class="calibre16">ProcessHandle</kbd> instance that was used to create it in the first place.</p>
<p class="mce-root">We can call the <kbd class="calibre16">onExit()</kbd> method on the handle many times and each time it will return a different <kbd class="calibre16">CompletableFuture</kbd> object, each related to the same process. We can call the <kbd class="calibre16">cancel()</kbd> method on the object but it will only cancel the <kbd class="calibre16">CompletableFuture</kbd> object and not the process and also does not have any effect on the other <kbd class="calibre16">CompletableFuture</kbd> objects that were created from the same <kbd class="calibre16">ProcessHandle</kbd> instance.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Terminating processes</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">To terminate a process we can call the <kbd class="calibre16">destroy()</kbd> method or the <kbd class="calibre16">destroyForcibly()</kbd> method on the <kbd class="calibre16">ProcessHandle</kbd> instance. Both of these methods will terminate the process. The <kbd class="calibre16">destroy()</kbd> method is expected to terminate the process gracefully executing the process shutdown sequence. In this case the shutdown hooks added to the run time are executed if the actual implementation supports the graceful, normal termination of processes. The <kbd class="calibre16">destroyForcibly()</kbd> method will enforce process termination, and in this case the shutdown sequence will not be executed.</p>
<p class="mce-root">If the process managed by the handle is not alive then nothing happens when the code calls any of these methods. If there are any <kbd class="calibre16">CompletableFuture</kbd> objects created calling the <kbd class="calibre16">onExit()</kbd> method on the handle then they will be completed after the call to the <kbd class="calibre16">destroy()</kbd> or <kbd class="calibre16">destroyForcefully()</kbd> method when the process has terminated. This means that the <kbd class="calibre16">CompletableFuture</kbd> object will return from a <kbd class="calibre16">join()</kbd> or some similar method after some time when the process termination is complete and not immediately after <kbd class="calibre16">destroy()</kbd> or <kbd class="calibre16">destroyForcefully()</kbd> returned.</p>
<p class="mce-root">It is also important to note that process termination may depend on many things. If the actual process that is waiting to terminate another does not have the right to terminate the other process then the request will fail. In this case the return value of the method is <kbd class="calibre16">false</kbd>. It is also important to understand that a return value of <kbd class="calibre16">true</kbd> does not mean that the process has actually terminated. It only means that the termination request was accepted by the operating system and that the operating system will terminate the process at some point in the future. This will actually happen rather soon, but not instantaneously and thus it should not be a surprise if the method <kbd class="calibre16">isAlive()</kbd> returns <kbd class="calibre16">true</kbd> for some time after the method <kbd class="calibre16">destroy()</kbd> or <kbd class="calibre16">destroyForcefully()</kbd> returned the value <kbd class="calibre16">true</kbd>.</p>
<p class="mce-root">The difference between <kbd class="calibre16">destroy()</kbd> and <kbd class="calibre16">destroyForcefully()</kbd> is implementation specific. The Java standard does not state that <kbd class="calibre16">destroy()</kbd> does terminate the process letting the shutdown sequence be executed. It only <em class="calibre20">requests the process be killed. Whether the process represented by this ProcessHandle object is</em> <em class="calibre20">normally terminated</em> <em class="calibre20">or not is implementation dependent</em> (<a href="http://download.java.net/java/jdk9/docs/api/java/lang/ProcessHandle.html#supportsNormalTermination--" class="pcalibre pcalibre3 pcalibre1 calibre12 pcalibre2">http://download.java.net/java/jdk9/docs/api/java/lang/ProcessHandle.html#supportsNormalTermination--</a>)<em class="calibre20">.</em></p>
<div class="packt_infobox">To learn more about <kbd class="calibre39">ProcessHandle</kbd> interface, visit <span class="calibre5"><a href="http://download.java.net/java/jdk9/docs/api/java/lang/ProcessHandle.html" class="calibre25 pcalibre pcalibre3 pcalibre2 pcalibre1">http://download.java.net/java/jdk9/docs/api/java/lang/ProcessHandle.html</a>.</span></div>
<p class="mce-root">This is because some operating systems do not implement the graceful process termination feature. In such situations, the implementation of <kbd class="calibre16">destroy()</kbd> is the same as calling <kbd class="calibre16">destroyForcefully()</kbd>.The system specific implementation of the interface <kbd class="calibre16">ProcessHandle</kbd> must implement the method <kbd class="calibre16">supportsNormalTermination()</kbd> that is <kbd class="calibre16">true</kbd> only if the implementation supports normal (not forceful) process termination. The method is expected to return the same value for all invocations in an actual implementation and should not change the return value during the execution of a JVM instance. There is no need to call the method multiple times.</p>
<p class="mce-root">The following examples demonstrate process starting, process termination, and waiting for the process to terminate. In our example, we use two classes. This first class demonstrates the <kbd class="calibre16">.sleep()</kbd> method:</p>
<pre class="calibre21">    package packt.mastering.java9.process; 
 
    public class WaitForChildToBeTerminated  
    { 
      public static void main(String[] args) 
       throws InterruptedException  
      { 
        Thread.sleep(10_000); 
      } 
    } </pre>
<p class="mce-root">The second class in our example calls the <kbd class="calibre16">WaitForChildToBeTerminated</kbd> class:</p>
<pre class="calibre21">    package packt.mastering.java9.process;<br class="calibre2"/><br class="calibre2"/>    import java.io.IOException;<br class="calibre2"/>    import java.util.Arrays;<br class="calibre2"/>    import java.util.concurrent.CompletableFuture;<br class="calibre2"/>    import java.util.stream.Collectors;<br class="calibre2"/><br class="calibre2"/>    public class TerminateAProcessAfterWaiting {<br class="calibre2"/>      private static final int N = 10;<br class="calibre2"/><br class="calibre2"/>      public static void main(String[] args)<br class="calibre2"/>       throws IOException, InterruptedException {  <br class="calibre2"/>         ProcessHandle ph[] = new ProcessHandle[N];<br class="calibre2"/> 
         for (int i = 0; i &lt; N; i++)  
         {<br class="calibre2"/>           final ProcessBuilder pb = ew ProcessBuilder(). <br class="calibre2"/>            command("java", "-cp", "build/classes/main",<br class="calibre2"/>            "packt.mastering.java9.process.<br class="calibre2"/>            WaitForChildToBeTerminated");<br class="calibre2"/>           Process p = pb.start();<br class="calibre2"/>           ph[i] = p.toHandle();<br class="calibre2"/>         }<br class="calibre2"/>         long start = System.currentTimeMillis();<br class="calibre2"/>         Arrays.stream(ph).forEach(ProcessHandle::destroyForcibly);<br class="calibre2"/><br class="calibre2"/><br class="calibre2"/>         CompletableFuture.allOf(Arrays.stream(ph).<br class="calibre2"/>          map(ProcessHandle::onExit).<br class="calibre2"/>          collect(Collectors.toList()).<br class="calibre2"/>          toArray(new CompletableFuture[ph.length])).<br class="calibre2"/>          join();<br class="calibre2"/>         long duration = System.currentTimeMillis() - start;<br class="calibre2"/>         System.out.println("Duration " + duration + "ms");<br class="calibre2"/>      }<br class="calibre2"/>    }</pre>
<p class="mce-root">The preceding code starts 10 processes, each executing the program that sleeps <kbd class="calibre16">10</kbd> seconds. Then it forcibly destroys the processes, more specifically, the operating system is asked to destroy them. Our example joins the <kbd class="calibre16">CompletableFuture</kbd> that is composed from the array of <kbd class="calibre16">CompletableFuture</kbd> objects, which are created using the handles of the individual processes.</p>
<p class="mce-root">When all the processes are finished then it prints out the measured time in milliseconds. The time interval starts when the processes are created and the process creation loop finished. The end of the measured time interval is when the processes are recognized by the JVM returning from the <kbd class="calibre16">join()</kbd> method.</p>
<p class="mce-root">The sample code sets the sleeping time to 10 seconds. This is a more noticeable time period. Running the code twice and deleting the line that destroys the processes can result a much slower printout. Actually the measured and printed elapsed times will also show that terminating the processes has an effect.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">A small process controller application</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">To summarize and put into use all that we have learned in this chapter we look at a sample process control application. The functionality of the application is very simple. It reads from a series of configuration file(s) parameters how to start some processes and then if any of them stops, it tries to restart the process.</p>
<p class="mce-root">Even a real life application can be created from this demo version. You can extend the set of parameters of the process with environment variable specifications. You can add default directory for the process, input and output redirection or even how much CPU a process is allowed to consume without the controlling application killing and restarting it.</p>
<p class="mce-root">The application consists of four classes.</p>
<ul class="calibre13">
<li class="calibre14"><kbd class="calibre16">Main</kbd>: This class that contains the public static void main method and is used to start up the daemon.</li>
<li class="calibre14"><kbd class="calibre16">Parameters</kbd>: This class contains the configuration parameters for a process. In this simple case it will only contain one field, the <kbd class="calibre16">commandLine</kbd>. If the application gets extended this class will contain the default directory, the redirections, and CPU use limiting data.</li>
<li class="calibre14"><kbd class="calibre16">ParamsAndHandle</kbd>: This class that is nothing else than a data tuple holding a reference to a <kbd class="calibre16">Parameters</kbd> object and also a process handle. When a process dies and gets restarted the process handle is replaced by the new handle, but the reference to the <kbd class="calibre16">Parameters</kbd> object never changes, it is configuration.</li>
</ul>
<ul class="calibre13">
<li class="calibre14"><kbd class="calibre16">ControlDaemon</kbd>: This class implements the interface <kbd class="calibre16">Runnable</kbd> and is started as a separate thread.</li>
</ul>
<p class="mce-root">In the code we will use most of the process API we discussed in the previous sections, <em class="calibre20">Terminating processes</em> and we will use a lot of threading code and stream operations. Understanding the threading work of the JVM is important independent of the process management also. It has, however emphasized importance when used together with the process API.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Main class</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">The main method takes the name of the directory from the command line argument. It treats this as relative to the current working directory. It uses a separate method from the same class to read the set of configurations from the files in the directory and then starts the control daemon. The following code if the <kbd class="calibre16">main</kbd> method of the program:</p>
<pre class="calibre21">    public static void main(String[] args) throws IOException, 
     InterruptedException  
    {<br class="calibre2"/>      // DemoOutput.out() simulated - implementation no shown<br class="calibre2"/>      DemoOutput.out(new File(".").getAbsolutePath().toString());<br class="calibre2"/>      if (args.length == 0)    {<br class="calibre2"/>        System.err.println("Usage: daemon directory");<br class="calibre2"/>        System.exit(-1);<br class="calibre2"/>      }<br class="calibre2"/>      Set&lt;Parameters&gt; params = parametersSetFrom(args[0]);<br class="calibre2"/>      Thread t = new Thread(new ControlDaemon(params));<br class="calibre2"/>      t.start();<br class="calibre2"/>    }</pre>
<p class="mce-root">Although this is a daemon, we are starting it as a normal thread and not as a daemon thread. When a thread is set to be a daemon thread it will not keep the JVM alive. When all other non-daemon threads stop, the JVM will just exit and the daemon threads will be stopped. In our case, the daemon thread we execute is the only one that keeps the code running. After that was started the main thread has nothing more to do, but the JVM should stay alive, until it is killed by the operator issuing a Unix <kbd class="calibre16">kill</kbd> command or pressing <em class="calibre20"><span class="calibre7">Control</span></em> + <em class="calibre20"><span class="calibre7">C</span></em> on the command line.</p>
<p class="mce-root">Getting the list of the files that are in the directory specified and getting the parameters from the file is simple using the new <kbd class="calibre16">Files</kbd> and <kbd class="calibre16">Paths</kbd> classes from the JDK:</p>
<pre class="calibre21">    private static Set&lt;Parameters&gt;  
     GetListOfFilesInDirectory(String directory) throws IOException  
    {<br class="calibre2"/>      return Files.walk(Paths.get(directory))<br class="calibre2"/>       .map(Path::toFile)<br class="calibre2"/>       .filter(File::isFile)<br class="calibre2"/>       .map(file -&gt; Parameters.fromFile(file))<br class="calibre2"/>       .collect(Collectors.toSet());<br class="calibre2"/>    }</pre>
<p class="mce-root">We get a stream of the files in the form of <kbd class="calibre16">Path</kbd> objects, map it to <kbd class="calibre16">File</kbd> objects, then we filter out the directories if there are any in the configuration directory and map the remaining plain files to <kbd class="calibre16">Parameters</kbd> objects using the static method <kbd class="calibre16">fromFile</kbd> of the <kbd class="calibre16">Parameters</kbd> class. Finally, we return a <kbd class="calibre16">Set</kbd> of the objects.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Parameters class</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">Our <kbd class="calibre16">Parameters</kbd> class has a field and a constructor as listed as follows:</p>
<pre class="calibre21">    final String[] commandLine;<br class="calibre2"/><br class="calibre2"/>    public Parameters(String[] commandLine) {<br class="calibre2"/>      this.commandLine = commandLine;<br class="calibre2"/>    }</pre>
<p class="mce-root">The parameter class has two methods. The first method, <kbd class="calibre16">getCommandLineStrings</kbd>, gets the command line strings from the properties. This array contains the command and the command line parameters. If it was not defined in the file then we return an empty array:</p>
<pre class="calibre21">    private static String[] getCommandLineStrings(Properties props)  
    {<br class="calibre2"/>      return Optional<br class="calibre2"/>       .ofNullable(props.getProperty("commandLine"))<br class="calibre2"/>       .orElse("")<br class="calibre2"/>       .split("\s+");<br class="calibre2"/>    }</pre>
<p class="mce-root">The second method is the <kbd class="calibre16">static fromFile</kbd> that reads the properties from a properties file:</p>
<pre class="calibre21">    public static Parameters fromFile(final File file)  
    {<br class="calibre2"/>      final Properties props = new Properties();<br class="calibre2"/>      try (final InputStream is = new FileInputStream(file)) {<br class="calibre2"/>        props.load(is);<br class="calibre2"/>      }  catch (IOException e) {<br class="calibre2"/>           throw new RuntimeException(e);<br class="calibre2"/>      }<br class="calibre2"/>      return new Parameters(getCommandLineStrings(props));<br class="calibre2"/>    }</pre>
<p class="mce-root">If the set of parameters handled by the program is extended then this class should also be modified.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">The ParamsAndHandle class</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">The <kbd class="calibre16">ParamsAndHandle</kbd> is a very simple class that holds two fields. One for the parameters and the other is the handle to the process handle that is used to access the process started using the parameters:</p>
<pre class="calibre21">    public class ParamsAndHandle  
    {<br class="calibre2"/>      final Parameters params;<br class="calibre2"/>      ProcessHandle handle;<br class="calibre2"/><br class="calibre2"/>      public ParamsAndHandle(Parameters params,<br class="calibre2"/>        ProcessHandle handle) {<br class="calibre2"/>          this.params = params;<br class="calibre2"/>          this.handle = handle;<br class="calibre2"/>      }<br class="calibre2"/><br class="calibre2"/>      public ProcessHandle toHandle() {<br class="calibre2"/>        return handle;<br class="calibre2"/>      }<br class="calibre2"/>    }</pre>
<p class="mce-root">Since the class is closely tied to the <kbd class="calibre16">ControlDaemon</kbd> class from where it is used there is no mutator or accessor associated with the field. We see the two classes as something inside the same encapsulation boundaries. The <kbd class="calibre16">toHandle</kbd> method is there so that we can use it as a method handle, as we will see in the next chapter.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">The ControlDaemon class</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">The <kbd class="calibre16">ControlDaemon</kbd> class implements the <kbd class="calibre16">Runnable</kbd> interface and is started as a separate thread. The constructor gets the set of the parameters that were read from the properties files and converts them to a set of <kbd class="calibre16">ParamsAndHandle</kbd> objects:</p>
<pre class="calibre21">    private final Set&lt;ParamsAndHandle&gt; handlers;<br class="calibre2"/><br class="calibre2"/>    public ControlDaemon(Set&lt;Parameters&gt; params) {<br class="calibre2"/>      handlers = params<br class="calibre2"/>      .stream()<br class="calibre2"/>      .map( s -&gt; new ParamsAndHandle(s,null))<br class="calibre2"/>      .collect(Collectors.toSet());<br class="calibre2"/>    }</pre>
<p class="mce-root">Because the processes are not started at this point, the handles are all <kbd class="calibre16">null</kbd>. The <kbd class="calibre16">run()</kbd> method starts the processes:</p>
<pre class="calibre21">    @Override<br class="calibre2"/>    public void run() {<br class="calibre2"/>      try {<br class="calibre2"/>        for (ParamsAndHandle pah : handlers) {<br class="calibre2"/>          log.log(DEBUG, "Starting {0}", pah.params);<br class="calibre2"/>          ProcessHandle handle = start(pah.params);<br class="calibre2"/>          pah.handle = handle;<br class="calibre2"/>        }<br class="calibre2"/>        keepProcessesAlive();<br class="calibre2"/>        while (handlers.size() &gt; 0) {<br class="calibre2"/>          allMyProcesses().join();<br class="calibre2"/>        } 
      } catch (IOException e)  
        {<br class="calibre2"/>          log.log(ERROR, e);<br class="calibre2"/>        }<br class="calibre2"/>    }</pre>
<p class="mce-root">Processing goes through the set of parameters and uses the method (implemented in this class later) to start the processes. The handles to each process get to the <kbd class="calibre16">ParamsAndHandle</kbd> object. After that, the <kbd class="calibre16">keepProcessesAlive</kbd> method is called and waits for the processes to finish. When a process stops it gets restarted. If it cannot be restarted it will be removed from the set.</p>
<p class="mce-root">The <kbd class="calibre16">allMyProcesses</kbd> method (also implemented in this class) returns a <kbd class="calibre16">CompletableFuture</kbd> that gets completed when all the started processes have stopped. Some of the processes may have been restarted by the time the <kbd class="calibre16">join()</kbd> method returns. As long as there is at least one process running, the thread should run.</p>
<p class="mce-root">Using the <kbd class="calibre16">CompletableFuture</kbd> to wait for the processes and the <kbd class="calibre16">while</kbd> loop, we use minimal CPU to keep the thread alive so long as long there is at least one process we manage running, presumably even after a few restarts. We have to keep this thread alive even if it does not use CPU and executes no code most of the time to let the <kbd class="calibre16">keepProcessesAlive()</kbd> method do its work using <kbd class="calibre16">CompletableFutures</kbd>. The method is shown in the following code snippet:</p>
<pre class="calibre21">    private void keepProcessesAlive()  
    {<br class="calibre2"/>      anyOfMyProcesses()<br class="calibre2"/>       .thenAccept(ignore -&gt; {<br class="calibre2"/>         restartProcesses();<br class="calibre2"/>         keepProcessesAlive();<br class="calibre2"/>       });<br class="calibre2"/>    }</pre>
<p class="mce-root">The <kbd class="calibre16">keepProcessesAlive()</kbd> method calls the <kbd class="calibre16">anyOfMyProcesses()</kbd> method that returns a <kbd class="calibre16">CompletableFuture</kbd>, which is completed when any of the managed processes exits. The method schedules to execute the lambda passed as an argument to the <kbd class="calibre16">thenAccept()</kbd> method for the time the <kbd class="calibre16">CompletableFuture</kbd> is completed. The lambda does two things:</p>
<ul class="calibre13">
<li class="calibre14">Restarts the processes that are stopped (probably only one)</li>
<li class="calibre14">Calls the <kbd class="calibre16">keepProcessesAlive()</kbd> method</li>
</ul>
<p class="mce-root">It is important to understand that this call is not performed from within the <kbd class="calibre16">keepProcessesAlive()</kbd> method itself. This is not a recursive call. This is scheduled as a <kbd class="calibre16">CompletableFuture</kbd> action. We are not implementing a loop in a recursive call, because we would run out of stack space. We ask the JVM executors to execute this method again when the processes are restarted.</p>
<p class="mce-root">It is important to know that the JVM uses the default <kbd class="calibre16">ForkJoinPool</kbd> to schedule these tasks and this pool contains daemon threads. That is the reason we have to wait and keep the method running because that is the only non-daemon thread that prevents the JVM from exiting.</p>
<p class="mce-root">The next method is <kbd class="calibre16">restartProcesses()</kbd>:</p>
<pre class="calibre21">    private void restartProcesses()  
    {<br class="calibre2"/>      Set&lt;ParamsAndHandle&gt; failing = new HashSet&lt;&gt;();<br class="calibre2"/>      handlers.stream()<br class="calibre2"/>       .filter(pah -&gt; !pah.toHandle().isAlive())<br class="calibre2"/>       .forEach(pah -&gt; {<br class="calibre2"/>         try {<br class="calibre2"/>           pah.handle = start(pah.params);<br class="calibre2"/>         } catch (IOException e) {<br class="calibre2"/>             failing.add(pah);<br class="calibre2"/>         }<br class="calibre2"/>       });<br class="calibre2"/>       handlers.removeAll(failing);<br class="calibre2"/>    }</pre>
<p class="mce-root">This method starts the processes that are in our set of managed processes and which are not alive. If any of the restarts fail it removes the failing processes from the set. (Be aware not to remove it in the loop to avoid <kbd class="calibre16">ConcurrentModificationException</kbd>.)</p>
<p class="mce-root">The <kbd class="calibre16">anyOfMyProcesses()</kbd> and <kbd class="calibre16">allMyProcesses()</kbd> methods are using the auxiliary <kbd class="calibre16">completableFuturesOfTheProcessesand()</kbd> method and are straight forward:</p>
<pre class="calibre21">    private CompletableFuture anyOfMyProcesses()  
    {<br class="calibre2"/>      return CompletableFuture.anyOf(<br class="calibre2"/>        completableFuturesOfTheProcesses());<br class="calibre2"/>    }<br class="calibre2"/><br class="calibre2"/>    private CompletableFuture allMyProcesses() {<br class="calibre2"/>      return CompletableFuture.allOf(<br class="calibre2"/>        completableFuturesOfTheProcesses());<br class="calibre2"/>    }</pre>
<p class="mce-root">The <kbd class="calibre16">completableFuturesOfTheProcesses()</kbd> method returns an array of <kbd class="calibre16">CompletableFutures</kbd> created from the currently running managed processes calling their <kbd class="calibre16">onExit()</kbd> method. This is done in a compact and easy to read functional programming style, as shown here:</p>
<pre class="calibre21">    private CompletableFuture[] completableFuturesOfTheProcesses()  
    {<br class="calibre2"/>      return handlers.stream()<br class="calibre2"/>       .map(ParamsAndHandle::toHandle)<br class="calibre2"/>       .map(ProcessHandle::onExit)<br class="calibre2"/>       .collect(Collectors.toList())<br class="calibre2"/>       .toArray(new CompletableFuture[handlers.size()]);<br class="calibre2"/>    }</pre>
<p class="mce-root">The set is converted to a <kbd class="calibre16">stream</kbd>, mapped to a <kbd class="calibre16">stream</kbd> of <kbd class="calibre16">ProcessHandle</kbd> objects (this is why we needed the <kbd class="calibre16">toHandle()</kbd> method in the <kbd class="calibre16">ParamsAndHandle</kbd> class). Then the handles are mapped to <kbd class="calibre16">CompletableFuture</kbd> stream using the <kbd class="calibre16">onExit()</kbd> method and finally we collect it to a list and convert to an array.</p>
<p class="mce-root">Our last method to complete our sample application is as follows:</p>
<pre class="calibre21">    private ProcessHandle start(Parameters params)<br class="calibre2"/>     throws IOException {<br class="calibre2"/>       return new ProcessBuilder(params.commandLine)<br class="calibre2"/>        .start()<br class="calibre2"/>        .toHandle();<br class="calibre2"/>    }</pre>
<p class="mce-root">This method starts the process using a <kbd class="calibre16">ProcessBuilder</kbd> and returns the <kbd class="calibre16">ProcessHandle</kbd> so that we can replace the old one in our set and manage the new process.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">In this chapter we discussed how Java 9 better enables us to manage processes. Prior to Java 9, process management from within Java required OS specific implementations and was less than optimal in terms of CPU use and coding practice. The modern API, with new classes like <kbd class="calibre16">ProcessHandle,</kbd> makes it possible to handle almost all aspects of processes. We listed the new API, and had simple example codes for the use of each of them. In the second half of the chapter we put together a whole application managing processes where the learned API was put into practice.</p>
<p class="mce-root">In the next chapter, we will take a detailed look at the new Java Stack Walking API released with Java 9. We will use code samples to illustrate how to use the API.</p>


            </article>

            
        </section>
    </div>



  </body></html>