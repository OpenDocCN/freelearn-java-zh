["```java\n  def f1(x:Int, y:Int): Int =  x + y\n```", "```java\n   val f2: (Int,Int) => Int = (x,y) => (x+y).\n```", "```java\n   val f2 = (x:Int,y:Int) => (x+y).\n```", "```java\ndef twice(f: Int => Int): Int => Int = x => f(f(x))\n```", "```java\nval incr2 = (x:Int) => x+2val incr4 = twice(incr2)\nincr4(2)   //==6\ntwice(x=>x+2)(3)   // 7\n```", "```java\nval fname: (X1 … XN)  => Y = (x1:X1, … x2:XN) => expression\n```", "```java\n  val f:  Int=>Int = x => x+1\n```", "```java\ntrait Function1[-T1, +R] {\ndef apply(v1: T1): R\n  ….\n}\n```", "```java\n F[T]  covariant,  iff   A <: B =>  F[A]  <:  F[B]\n  F[T]   contravariant  iff  A >: B => F[A] <: F[B]\n```", "```java\n//   val twice(f:Int=>Int):Int=>Int = x => f(f(x))\nobject  Twice extends Function1[Function1[Int,Int],Function1[Int,Int]] \n{\n\tdef apply(f: Function1[Int,Int]): Function1[Int,Int] =new Function1[Int,Int] \n\t{\n\t\tdef apply(x:Int):Int =   f.apply(f.apply(x))\n\t}\n}\n```", "```java\nval incr2 = (x:Int) => x+2\nval incr4 = Twice(incr2)\nincr4(2)  //=6\nTwice(x=>x+2)(5) //=9\n```", "```java\n    g(f: (Int,Int)=>Int, x: Int, y:Int): Int = f(x,y)\n    ```", "```java\n    g(f: (Int,Int)=>Int)( x: Int, y:Int): Int = f(x,y)\n    ```", "```java\n    fix(f: (Int,Int)=>Int)( x: Int): Int => Int = y => f(x,y)\n    ```", "```java\nval printFun = Console.print _\n```", "```java\nval th = new Thread(()=> println(s\"threadId=${Thread.currentThread().getId}\"))\nth.start()\n```", "```java\n    def measure1(f: Unit => Unit): Long = {\n    \tval startTime = System.nanoTime()\n    f()\n    \tval endTime = System.nanoTime()\n    endTime – startTime\n    }\n\n    ```", "```java\n    def measure2(f: => Unit): Long = {\n    \tval startTime = System.nanoTime()\n    \tf\n    \tval endTime = System.nanoTime()\n    \tendTime – startTime\n    }\n\n    ```", "```java\n    object Measure3 extends Function1[Unit=>Unit,Long]\n    {\n    \toverride def apply(f: Unit=>Unit) = {\n    \t\tval startTime = System.nanoTime()\n    \t\tf()\n    \t\tval endTime = System.nanoTime()\n        endTime – startTime\n       }\n    }\n    ```", "```java\n_ + 1   is a shortcut for  x =>  x+1,   _ + _  -- for (x,y) => x + y.\n```", "```java\ntrait PartialFunction[-A, +B] extends (A => B) { \n/** Checks if a value is contained in the function's domain.\n*\n*@param  x   the value to test\n*  @return `'''true'''`, iff `x` is in the domain of this function, `'''false'''` otherwise.*/\ndef isDefinedAt(x: A): Boolean\n}\n```", "```java\nval pf: PartialFunction[Int,String] = {\ncase 0 => \"zero\"\ncase 1 => \"one\"\ncase 2 => \"two\"\ncase x:Int if x>0 => \"many\"}\n\npf.isDefinedAt(1)  - true\npf.isDefinedAt(-1)  - false\n\npf(-1)  throws exceptions.\n```", "```java\nval pf1: PartialFunction[Int,String] = pf orElse { case _ => \"other\" }\n```", "```java\npf andThen (_.length)(1)  \n```", "```java\n    class g1(f:PartialFunction[Int,Int]) extends \n    PartialFunction[Int,Int] {\n    \toverride def isDefinedAt(x: Int) =\n    \t\tf.isDefinedAt(x)\n    \toverride def apply(x: Int) =\n    \t\tf(x) + x \n    }\n    ```", "```java\n                   def g2(f:PartialFunction[Int,Int]):PartialFunction[Int,Int] = {\n    case x if f.isDefinedAt(x) => f(x)+x\n                    }\n    ```", "```java\n    class NVPair(name: String, value: String) extends \n    PartialFunction[String,String] {\n    \toverride def isDefinedAt(x: String): Boolean = (x==name)\n    \toverride def apply(x: String): String = {\n    \t\tif (x==name) value else throw new MatchError()\n    \t}\n    }\n    ```", "```java\n    val f = new NVPair(\"aa\",\"bb\") orElse new NVPair(\"cc\",\"dd\")\n    ```", "```java\n    case class Wrapper(x:Int)\n\n    w match {case Wrapper(x) => doSomething(x)}\n    ```", "```java\n    val container = Wrapper.unapply(w)\n    if (container.isDefined) {\n    \tval x = container.get\n    \tdoSomething(x)\n    }\n    ```", "```java\n    val container = Point.unapply(p)\n    if (container.isDefined) \n    {\n      val (x,y) = container.getdoSomething(x,y)\n    }\n    ```", "```java\n    sealed abstract class Option[+A]  {\n\n     def isEmpty: Boolean\n     def isDefined: Boolean = !isEmpty\n     def get: A\n\n      // …  other methods\n\n    }\n\n    final case class Some[+A](value: A) extends Option[A] {\n      def isEmpty = false\n      def get = value\n    }\n\n    case object None extends Option[Nothing] {\n      def isEmpty = true\n      def get = throw new NoSuchElementException(\"None.get\")\n    }\n    ```", "```java\n    case class Point(x:Int, y:Int)\n    ```", "```java\n    object Diagonal {\n    def unapply(p:Point): Option[Int] =if (p.x == p.y) Some(p.x) else None\n    }\n    ```", "```java\nval r1 = \"([\\\\d]+)\".r\nval r2 = \"([\\\\d]+)  ([^\\\\W]*)\".r\n\nv match {case r1(x) => \"1\"case r2(x,y) => \"2\"\n}\n```", "```java\n    object Words {def unapplySeq(arg: String):Option[Seq[String]] = {\n    val array = arg.split(\"\\\\W+\")\n    if (array.size == 1 && array(0).isEmpty ) {\n          None} else {\n      Some(array.toSeq)\n      }\n      }\n    }\n    ```", "```java\n        \"1\",    \"AA AA\",  \"AA   AA\",   \"ABC CBA\",  \"A B C D E     F G X-L\",\"\"    \n    \"AAA     AAA\" match {case Words(x,y) => (x,y)\n    }\n    ```", "```java\n    object AsSeq\n    {\n    def unapplySeq(x:Array[Int]):Option[Seq[Int]] = {Some(x)\n    }\n    }Array(1,2,3,6) match {case AsSeq(h, _*) => h \n    }\n    ```", "```java\npackage com.packt.courseware.l4\n\npackage object modes {\n  type ChatbotMode = PartialFunction[(String,EffectsProvider),Processed]\n\n     …\n}\n```", "```java\nval bye: ChatbotMode = { \ncase (\"bye\", eff) => Processed(\"bye\", bye, true) \n}\n```", "```java\ndef or(frs:ChatbotMode, snd: ChatbotMode): ChatbotMode = {\nval frsPost = frs.andThen(p => p.copy(nextMode = or(p.nextMode,snd)))\nval sndPost = snd.andThen(p => p.copy(nextMode = or(p.nextMode,frs)))\nfrsPost orElse sndPost\n}\n```", "```java\nimport modes._\ndef createInitMode() = otherwise (\nor(StoreRemindCommand.empty, or(bye,or(currentDate,currentTime))),\n  interestingIgnore)\n```", "```java\nval StorePattern = raw\"store ([^\\W]+) (.*)\".r;\nval RemindPattern = raw\"remind ([^\\W]+)\".r;\n\ndef process(state:RemindedState): ChatbotMode =\n{\n  case (StorePattern(n,v),effects) => Processed(\"ok\",process(state.store(n,v)),false)\n  case (RemindPattern(n),effects) if state.isDefinedAt(n) => Processed(state(n),process(state),false)\n}\n```", "```java\ntrait PartialFunction[-A, +B] extends (A => B) {\n ….\n\n  /** Turns this partial function into a plain function returning an `Option` result.\n  *  @see     Function.unlift\n  *  @return  a function that takes an argument `x` to `Some(this(x))` if `this`\n  *           is defined for `x`, and to `None` otherwise.\n  */\n  def lift: A => Option[B]\n\n}\n```", "```java\ntrait ChatbotMode {\ndef process(line:String,effects:EffectsProvider):Option[Processed]\ndef or(other: ChatbotMode) = OrMode(this,other)\ndef otherwise(other: ChatbotMode) = OtherwiseMode(this,other)}\n```", "```java\nobject ChatbotMode{\ndef partialFunction(f:PartialFunction[String,Processed]): ChatbotMode =\n{(line,effects) => f.lift(line) }}\n```", "```java\nval bye: ChatbotMode = ChatbotMode.partialFunction(\n                       { case \"bye\" => Processed(\"bye\", bye, true) })\n```", "```java\nval interestingIgnore: ChatbotMode = ( line, effects ) => \n                       Some(Processed(\"interesting...\",interestingIgnore,false))\n```", "```java\ncase class OrMode(frs:ChatbotMode, snd:ChatbotMode) extends ChatbotMode {\n\toverride def process(line: String, effects: EffectsProvider): Option[Processed] = {\n\t\tfrs.process(line,effects).map(p => p.copy(nextMode = OrMode(p.nextMode,snd))\n)orElse snd.process(line,effects).map(\np => p.copy(nextMode = OrMode(p.nextMode,frs))\n\t\t)\n\t}\n}\n\n```", "```java\n{ case \"bye\" => Processed(\"bye\", bye, true) }.lift\n\n```", "```java\n          x => if (x==\"bye\") Some(Processed(\"bye\", bye, true)) else None\n```", "```java\ndef unlift[X,Y](f: X => Option[Y]):PartialFunction[X,Y] = new PartialFunction[X,Y] {\n\toverride def isDefinedAt(x: X) =\n\tf(x).isDefined\n\toverride def apply(x: X) =\n\tf(x) match {\n\t\tcase Some(y) => y\n\t}\n}\n```", "```java\noverride def applyOrElse[A1 <: X, B1 >: Y](x: A1, default: A1 => B1): B1 =\n\tf(x) match {\n\t\tcase Some(y) =>y\n\t\tcase None => default(x)  \n}\n```"]