<html><head></head><body>
  <div id="_idContainer332" class="Basic-Text-Frame">
    <h1 class="chapterNumber">13</h1>
    <h1 id="_idParaDest-583" class="chapterTitle">Socket API and Simple Web Server</h1>
    <p class="normal">This chapter includes 11 problems covering<a id="_idIndexMarker1456"/> the Socket API and 8 problems covering JDK 18 <strong class="keyWord">Simple Web Server</strong> (<strong class="keyWord">SWS</strong>). In the first 11 problems we will discuss implementing socket-based applications such as blocking/non-blocking server/client applications, datagram-based applications, and multicast applications. In the second part of this chapter, we discuss SWS as a command-line tool and a suite of API points.</p>
    <p class="normal">At the end of this chapter, you’ll know how to write applications via the Socket API and how to use SWS for testing, debugging, and prototyping tasks.</p>
    <h1 id="_idParaDest-584" class="heading-1">Problems</h1>
    <p class="normal">Use the following problems to test your advanced programming prowess in Socket API and SWS. I strongly encourage you to give each problem a try before you turn to the solutions and download the example programs:</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="258"><strong class="keyWord">Introducing socket basics</strong>: Provide a brief but meaningful introduction to socket basics and related context (TCP, UDP, IP, etc.).</li>
      <li class="numberedList"><strong class="keyWord">Introducing TCP server/client applications</strong>: Introduce the knowledge needed for writing a blocking/non-blocking TCP server/client application. </li>
      <li class="numberedList"><strong class="keyWord">Introducing the Java Socket API</strong>: Highlight the main Socket API (NIO.2) needed for writing socket-based applications in Java.</li>
      <li class="numberedList"><strong class="keyWord">Writing a blocking TCP server/client application</strong>: Provide a detailed example (theory and code) of a blocking TCP server/client application.</li>
      <li class="numberedList"><strong class="keyWord">Writing a non-blocking TCP server/client application</strong>: Provide a detailed example (theory and code) of a non-blocking TCP server/client application.</li>
      <li class="numberedList"><strong class="keyWord">Writing UDP server/client applications</strong>: Write a UDP server/client application including a connectionless client and a connected client.</li>
      <li class="numberedList"><strong class="keyWord">Introducing multicasting</strong>: Explain in simple terms the meaning of multicast.</li>
      <li class="numberedList"><strong class="keyWord">Exploring network interfaces</strong>: Write a snippet of code that displays details about the network interfaces available on your machine.</li>
      <li class="numberedList"><strong class="keyWord">Writing a UDP multicast server/client application</strong>: Explain and exemplify the implementation of a UDP multicast-based application.</li>
      <li class="numberedList"><strong class="keyWord">Adding Key Encapsulation Mechanism (KEM) to a TCP server/client application</strong>: Explain and exemplify the usage of JDK 21 KEM for encrypting/decrypting the communication in a TCP server/client application.</li>
      <li class="numberedList"><strong class="keyWord">Reimplementing the legacy Socket API</strong>: Provide a quick overview of the Socket API evolution among JDK releases.</li>
      <li class="numberedList"><strong class="keyWord">Quick overview of SWS</strong>: Provide a brief introduction to the JDK 18 SWS. Explain how it works and what its key abstractions are.</li>
      <li class="numberedList"><strong class="keyWord">Exploring the SWS command-line tool</strong>: Provide a step-by-step guide for starting, using, and stopping SWS via the command line.</li>
      <li class="numberedList"><strong class="keyWord">Introducing the com.sun.net.httpserver API</strong>: Describe the pillars of the SWS API.</li>
      <li class="numberedList"><strong class="keyWord">Adapting request/exchange</strong>: Provide a few snippets of code that adapt the SWS request/exchange for custom scenarios.</li>
      <li class="numberedList"><strong class="keyWord">Complementing a conditional HttpHandler with another handler</strong>: Write an example that shows how to conditionally choose between two <code class="inlineCode">HttpHandler</code> instances.</li>
      <li class="numberedList"><strong class="keyWord">Implementing SWS for an in-memory file system</strong>: Write an SWS implementation that serves resources from an in-memory file system (for instance, the Google Jimfs in-memory file system or other similar solutions).</li>
      <li class="numberedList"><strong class="keyWord">Implementing SWS for a zip file system</strong>: Write an SWS implementation that serves resources from a ZIP archive.</li>
      <li class="numberedList"><strong class="keyWord">Implementing SWS for a Java runtime directory</strong>: Write an SWS implementation that serves resources from a Java runtime directory (JEP 220).</li>
    </ol>
    <p class="normal">The following sections describe solutions to the preceding problems. Remember that there usually isn’t a single correct way to solve a particular problem. Also, remember that the explanations shown here include only the most interesting and important details needed to solve the problems. Download the example solutions to see additional details and to experiment with the programs at <a href="https://github.com/PacktPublishing/Java-Coding-Problems-Second-Edition/tree/main/Chapter13"><span class="url">https://github.com/PacktPublishing/Java-Coding-Problems-Second-Edition/tree/main/Chapter13</span></a>.</p>
    <h1 id="_idParaDest-585" class="heading-1">258. Introducing socket basics</h1>
    <p class="normal">The socket notion was introduced<a id="_idIndexMarker1457"/> in the ‘80s. This notion was introduced on <strong class="keyWord">Berkeley Software Distribution</strong> (<strong class="keyWord">BSD</strong>) (a Unix flavor) as a solution for network communication between processes via <strong class="keyWord">Internet Protocol</strong> (<strong class="keyWord">IP</strong>). Java introduced its first cross-platform API for sockets in 1996 (JDK 1.0). As you’ll see soon, with just a few notions such as network interface, IP address and port, a Java developer can write applications that communicate via sockets.</p>
    <p class="normal">At the IP level, data travels from source to destination in chunks (<em class="italic">packets</em>) of data. Each packet is seen as an individual entity and there is no guarantee that all packets sent from a source will hit the destination. Nevertheless, on top<a id="_idIndexMarker1458"/> of IP, we have other<a id="_idIndexMarker1459"/> protocols that are more popular such as <strong class="keyWord">Transmission Control Protocol </strong>(<strong class="keyWord">TCP</strong>) and <strong class="keyWord">User Datagram Protocol </strong>(<strong class="keyWord">UDP</strong>). Moreover, on top of these protocols, we have the well-known HTTP, DNS, Telnet, and so on. Machine communication via sockets works on IP, so Java applications that use the Socket API can communicate with other socket-based applications (servers) based on their predefined protocol.</p>
    <p class="normal">Every machine connected to the Internet is represented by a number or numerical label, which is commonly named the <em class="italic">IP address</em> of that machine. As Java developers, we should know that there are categories of IP addresses:</p>
    <ul>
      <li class="bulletList">IPv4 – IP addresses represented on 32 bits (for instance, <code class="inlineCode">89.165.254.108</code>)</li>
      <li class="bulletList">IPv6 – IP addresses represented on 128 bits (for instance, <code class="inlineCode">2001:db8:3333:4444:5555:6666:7777:8888</code>)</li>
    </ul>
    <p class="normal">In addition, IP addresses are split into classes A, B, C, D, and E. For instance, class D of IP addresses ranges from <code class="inlineCode">224.0.0.0</code> to <code class="inlineCode">239.255.255.255</code> and is reserved for multicasting applications. And, of course, the <code class="inlineCode">127.0.0.1</code> is a special IP reserved for <em class="italic">localhost</em>.</p>
    <p class="normal">Now, speaking about ports, you should know that Java represents them as integers in the range <code class="inlineCode">0</code>-<code class="inlineCode">65535</code>. Some of the ports are famous and commonly associated with a certain type of server – for instance, port <code class="inlineCode">80</code> is associated with an HTTP server, port <code class="inlineCode">23</code> with a Telnet server, port <code class="inlineCode">21</code> with an FTP server, and so on.</p>
    <p class="normal">While these notions have books that go deep into detail dedicated to them, we have enough information here to start writing server/client applications that rely on sockets. Practically, in such a server/client application, we have a server that runs on a host (a remote or localhost identified via an IP address and a port). While running, the server listens for incoming clients on a certain port. A client can locate the server via these two coordinates: the server IP address and the port. A client needs to present to the server a local port (automatically assigned by the kernel or explicitly set by us) that is used by the server to locate the client. A socket (client socket) is associated or bound to this local port and is used for communicating with the server. Upon acceptance, the server gets a socket (server socket) as well that is bound<a id="_idIndexMarker1460"/> to a new local port (not the server port used for listening for incoming clients). Now, bidirectional communication can take place via these two sockets (endpoints).</p>
    <h1 id="_idParaDest-586" class="heading-1">259. Introducing TCP server/client applications</h1>
    <p class="normal">We don’t need to be TCP experts<a id="_idIndexMarker1461"/> in order to write a Java server/client TCP-based application. While this topic (TCP) is detailed (very well-documented) in dedicated books and articles, let’s have a brief overview of TCP principles.</p>
    <p class="normal">TCP’s goal is to provide a point-to-point communication mechanism between two endpoints. Once the connection between these two endpoints is established (via sockets) it remains open during the communication until one of the sides closes it (usually, the client). In other words, two processes that are on different machines or the same machine can communicate with each other as in a telephone connection. In the following figure, you can see a classical server-client session based on sockets:</p>
    <figure class="mediaobject"><img src="../Images/B19655_13_01.png" alt="Figure 13.1.png"/></figure>
    <p class="packt_figref">Figure 13.1: Server/client session based on sockets (TCP)</p>
    <p class="normal">A server/client TCP connection is represented by certain coordinates as follows:</p>
    <ul>
      <li class="bulletList">The server side is represented by its IP address and port</li>
      <li class="bulletList">The client side is represented by its IP address and port</li>
      <li class="bulletList">The server and client communicate via a protocol (UDP, TCP/IP, etc.)</li>
    </ul>
    <p class="normal">As you can see in <em class="italic">Figure 13.1</em>, the server’s socket is bound and it listens for clients’ requests (the server can communicate with many clients at the same time). The client’s socket is bound and is ready to request a connection to the server. Once the connection is accepted, they can bidirectionally communicate (complete read/write operations) until the client closes the connection. The client can connect again later.</p>
    <p class="normal">TCP (in contrast to UDP) is specialized in handling data packets being able to break data into packets, buffer data, and track-resend the lost or out-of-order data packets. Moreover, TCP is capable of controlling the speed of sending data in order to accommodate the processing capabilities of the receiver. TCP<a id="_idIndexMarker1462"/> can send data as I/O streams of data or as byte arrays.</p>
    <h2 id="_idParaDest-587" class="heading-2">Blocking vs. non-blocking mechanisms</h2>
    <p class="normal">A Java TCP-based server/client application<a id="_idIndexMarker1463"/> can be <em class="italic">blocking</em> or <em class="italic">non-blocking</em>. In a blocking<a id="_idIndexMarker1464"/> application, a given thread is blocked until the I/O is completely received. So, the thread cannot do anything else until the I/O is ready to be processed – it will just hang on. On the other hand, in a non-blocking application, the I/O requests are queued and the thread is free to do other tasks. The queued requests will be processed later by the kernel.</p>
    <p class="normal">From the Java implementation perspective, writing blocking applications is much easier than writing non-blocking applications. However, non-blocking applications are more performant and sustain scalability. NIO.2 supports both and we will implement both as well, but after a brief introduction to the Java Socket API.</p>
    <h1 id="_idParaDest-588" class="heading-1">260. Introducing the Java Socket API</h1>
    <p class="normal">Java Socket API support in Java<a id="_idIndexMarker1465"/> has constantly evolved from JDK 1.0 to JDK 7. Starting with JDK 7 and NIO.2, sockets support has been seriously improved with a new API (new classes and interfaces) for easily writing complex TCP/UDP-based applications. For instance, the <code class="inlineCode">NetworkChannel</code> interface was introduced as a common implementation point for all network channel classes. Any class that implements <code class="inlineCode">NetworkChannel</code> has access to common methods useful for handling channels to network sockets. Such classes are <code class="inlineCode">SocketChannel</code>, <code class="inlineCode">ServerSocketChannel</code>, and <code class="inlineCode">DatagramChannel</code>. These classes take advantage of methods for handling local addresses and for configuring socket options via <code class="inlineCode">SocketOption&lt;T&gt;</code> (interface) and <code class="inlineCode">StandardSocketOptions</code> (class). Moreover, this API exposes methods for accessing remote addresses, checking connection status, and shutting down sockets.</p>
    <p class="normal">One of the most important subinterfaces of <code class="inlineCode">NetworkChannel</code> is <code class="inlineCode">MulticastChannel</code>. This interface is implemented only by <code class="inlineCode">DatagramChannel</code> and it knows how to map a network channel that is capable of providing IP multicasting. Anybody can get a membership key (like a token) that can be used to join a multicast group and become a member. The membership key is useful for customizing your presence<a id="_idIndexMarker1466"/> in the multicast group (for instance, block or unblock datagrams based on their sender addresses).</p>
    <h2 id="_idParaDest-589" class="heading-2">Introducing NetworkChannel</h2>
    <p class="normal"><code class="inlineCode">NetworkChannel</code> provides methods that are common<a id="_idIndexMarker1467"/> to all sockets, so <code class="inlineCode">NetworkChannel</code> is a pillar of the Socket API. One of the most important methods exposed by <code class="inlineCode">NetworkChannel</code> is <code class="inlineCode">bind()</code>. As its name suggests, this method binds a socket channel to a local address (or in short, a socket is associated with a local address). More precisely, a socket is bound to a local address via an instance of <code class="inlineCode">InetSocketAddress</code> – this class extends the <code class="inlineCode">SocketAddress</code> (abstract class) and it maps a socket address as a hostname (IP)-port pair. The <code class="inlineCode">bind()</code> method returns the bound socket channel (server socket channel, datagram socket channel, and so on). The returned channel was explicitly/manually bound to the given host port or automatically (if no host port is given):</p>
    <pre class="programlisting code"><code class="hljs-code">NetworkChannel <span class="hljs-title">bind</span><span class="hljs-params">(SocketAddress local)</span> <span class="hljs-keyword">throws</span> IOException
</code></pre>
    <p class="normal">The bound local address can be obtained via <code class="inlineCode">getLocalAddress()</code>:</p>
    <pre class="programlisting code"><code class="hljs-code">SocketAddress <span class="hljs-title">getLocalAddress</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException
</code></pre>
    <p class="normal">If no address is present then this method returns <code class="inlineCode">null</code>.</p>
    <h3 id="_idParaDest-590" class="heading-3">Tackling socket options</h3>
    <p class="normal">A socket has several options<a id="_idIndexMarker1468"/> represented via the <code class="inlineCode">SocketOption&lt;T&gt;</code> interface. NIO.2 provides an implementation of <code class="inlineCode">SocketChannel&lt;T&gt;</code> as a set of standard options via <code class="inlineCode">StandardSocketOptions</code> as follows:</p>
    <ul>
      <li class="bulletList"><code class="inlineCode">IP_MULTICAST_IF</code>: Via this option, we set the <code class="inlineCode">NetworkInterface</code> used by a bounded datagram-oriented socket (or simply, datagram socket) for multicast datagrams. We can set this option explicitly or allow the <strong class="keyWord">operating system</strong> (<strong class="keyWord">OS</strong>) to choose one (if any is available) by leaving this option as default (<code class="inlineCode">null</code>).</li>
      <li class="bulletList"><code class="inlineCode">IP_MULTICAST_LOOP</code>: This is a flag option (defaults to <code class="inlineCode">true</code>) that can be set for a bounded datagram socket to control the <em class="italic">loopback</em> (<code class="inlineCode">true</code> means that the sent data should be looped back to your host) of multicast datagrams.</li>
      <li class="bulletList"><code class="inlineCode">IP_MULTICAST_TTL</code>: This option applies to a bounded datagram socket. It is known as <strong class="keyWord">time-to-live</strong> (<strong class="keyWord">TTL</strong>) and is useful for setting<a id="_idIndexMarker1469"/> the scope of multicast datagrams (setting the TTL for the multicast packets). By default, the value of this option is <code class="inlineCode">1</code>, which means that multicast datagrams are not sent beyond the local network. The value of this option ranges between <code class="inlineCode">0</code> and <code class="inlineCode">255</code>.</li>
      <li class="bulletList"><code class="inlineCode">IP_TOS</code>: Via this option, we set the value of the <strong class="keyWord">type-of-service</strong> (<strong class="keyWord">ToS</strong>) octet in IP packets for IPv4. It can be set anytime for a bounded datagram socket and its default value is <code class="inlineCode">0</code>. Further information on the ToS octet can be found in RFC 2474 and RFC 1349 (the interpretation of the ToS octet is network-specific).</li>
      <li class="bulletList"><code class="inlineCode">SO_BROADCAST</code>: This is a flag option that applies to a bounded datagram socket sending data to IPv4 broadcast addresses (defaults to <code class="inlineCode">false</code>). When it is <code class="inlineCode">true</code>, this option allows the transmission of broadcast datagrams.</li>
      <li class="bulletList"><code class="inlineCode">SO_KEEPALIVE</code>: This is a flag option (defaults to <code class="inlineCode">false</code>) that applies to a bounded socket for indicating if the connection should be kept alive by the OS or not.</li>
      <li class="bulletList"><code class="inlineCode">SO_LINGER</code>: This option<a id="_idIndexMarker1470"/> defines the so-called <em class="italic">linger interval</em> as an integer (timeout in seconds). The linger interval is specific to sockets that work in blocking mode only and it represents the timeout applied to the <code class="inlineCode">close()</code> method. In other words, when the <code class="inlineCode">close()</code> method is called on a socket, its execution will be blocked for this timeout (linger interval) while the OS attempts to transmit the unsent data (if it is possible). This option can be set at any time (by default, it has a negative value that is interpreted as disabled) and the maximum timeout is OS-specific.</li>
      <li class="bulletList"><code class="inlineCode">SO_RCVBUF</code>: This option is a positive integer that can be set before the socket is bound/connected (defaults to an OS-dependent value). You need this option if you want to set the size of the networking input buffer (in bytes).</li>
      <li class="bulletList"><code class="inlineCode">SO_SNDBUF</code>: This option is a positive<a id="_idIndexMarker1471"/> integer that can be set before the socket is bound/connected (defaults to an OS-dependent value). You need this option if you want to set the size of the networking output buffer (in bytes).</li>
      <li class="bulletList"><code class="inlineCode">SO_REUSEADDR</code>: Via this integer option, we can indicate if an address can be reused or not. For datagram multicasting (datagram sockets), this means that multiple programs can use (can be bound to) the same address. In the case of stream-oriented sockets (or simply, stream sockets), an address can be reused only if the previous connection is in the <code class="inlineCode">TIME_WAIT</code> state (the socket is about to be closed by the OS but it still waits for the client side to send possible late communications). The default value for this option is OS-dependent and it should be set before the socket is bound/connected.</li>
      <li class="bulletList"><code class="inlineCode">SO_REUSEPORT</code>: Via this integer option (available from JDK 9), we can indicate if a port can be reused or not. For datagram multicasting (datagram sockets) and stream sockets, this means that multiple sockets can use (can be bound to) the same port and address. The <code class="inlineCode">SO_REUSEPORT</code> should be set before connecting/binding the socket; otherwise, the OS will deliver its default value for it.</li>
      <li class="bulletList"><code class="inlineCode">TCP_NODELAY</code>: This flag option (defaults to <code class="inlineCode">false</code>) is used for enabling/disabling<a id="_idIndexMarker1472"/> Nagle’s algorithm (<a href="http://en.wikipedia.org/wiki/Nagle%27s_algorithm"><span class="url">http://en.wikipedia.org/wiki/Nagle%27s_algorithm</span></a>). It can be set at any time.</li>
    </ul>
    <p class="normal">Setting an option can be done via <code class="inlineCode">NetworkChannel.getOption()</code> while getting an option can be done via <code class="inlineCode">NetworkChannel.setOption()</code>:</p>
    <pre class="programlisting code"><code class="hljs-code">&lt;T&gt; T <span class="hljs-title">getOption</span><span class="hljs-params">(SocketOption&lt;T&gt; op_name)</span> <span class="hljs-keyword">throws</span> IOException
&lt;T&gt; NetworkChannel setOption(SocketOption&lt;T&gt; op_name, T op_value) 
  <span class="hljs-keyword">throws</span> IOException
</code></pre>
    <p class="normal">Moreover, via <code class="inlineCode">NetworkChannel</code>, we can obtain the options supported by a specific network socket via <code class="inlineCode">supportedOptions()</code>:</p>
    <pre class="programlisting code"><code class="hljs-code">Set&lt;SocketOption&lt;?&gt;&gt; supportedOptions()
</code></pre>
    <p class="normal">Having this information<a id="_idIndexMarker1473"/> in your hands, it is time to start writing out our first client/server socket-based application.</p>
    <h1 id="_idParaDest-591" class="heading-1">261. Writing a blocking TCP server/client application</h1>
    <p class="normal">In this problem, we will write<a id="_idIndexMarker1474"/> a blocking TCP server/client application. More precisely, let’s start with a single-thread blocking TCP echo server.</p>
    <h2 id="_idParaDest-592" class="heading-2">Writing a single-thread blocking TCP echo server</h2>
    <p class="normal">In order to write a single-thread blocking TCP<a id="_idIndexMarker1475"/> echo server, we will follow these steps:</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="1">Create a new server socket channel</li>
      <li class="numberedList">Configure the blocking mechanism</li>
      <li class="numberedList">Set the server socket channel options</li>
      <li class="numberedList">Bind the server socket channel</li>
      <li class="numberedList">Accept connections</li>
      <li class="numberedList">Transmit data over a connection</li>
      <li class="numberedList">Close the channel</li>
    </ol>
    <p class="normal">So, let’s start with the first step.</p>
    <h3 id="_idParaDest-593" class="heading-3">Creating a new server socket channel</h3>
    <p class="normal">Creating and opening a new server<a id="_idIndexMarker1476"/> socket channel (stream-oriented listening socket) can be done via the thread-safe <code class="inlineCode">java.nio.channels.ServerSocketChannel</code> API as follows:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-type">ServerSocketChannel</span> <span class="hljs-variable">serverSC</span> <span class="hljs-operator">=</span> ServerSocketChannel.open();
</code></pre>
    <p class="normal">The resulting server socket channel is not bound/connected. However, it is open, and this can be verified<a id="_idIndexMarker1477"/> via the <code class="inlineCode">isOpen()</code> method:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">if</span> (serverSC.isOpen()) {
  ...
}
</code></pre>
    <p class="normal">Next, let’s configure the blocking mechanism.</p>
    <h3 id="_idParaDest-594" class="heading-3">Configuring the blocking mechanism</h3>
    <p class="normal">Once the server socket channel<a id="_idIndexMarker1478"/> has been successfully opened, we can decide on the blocking mechanism. This can be done via the <code class="inlineCode">configureBlocking()</code> method, which gets a boolean argument (<code class="inlineCode">true</code> means a blocking server socket channel):</p>
    <pre class="programlisting code"><code class="hljs-code">serverSC.configureBlocking(<span class="hljs-literal">true</span>);
</code></pre>
    <p class="normal">A special type of channel (covered in subsequent problems) is <code class="inlineCode">SelectableChannel</code>. Such a channel is returned by the <code class="inlineCode">configureBlocking()</code> method (inherited from <code class="inlineCode">AbstractSelectableChannel</code>) and is useful for achieving <em class="italic">multiplexing</em> via the <code class="inlineCode">Selector</code> API. But, as I said, this is covered later.</p>
    <h3 id="_idParaDest-595" class="heading-3">Setting server socket channel options</h3>
    <p class="normal">Since all options have default values, we can<a id="_idIndexMarker1479"/> go with them out of the box or explicitly set only the ones that we need. For instance, let’s set the <code class="inlineCode">SO_RCVBUF</code> and <code class="inlineCode">SO_REUSEADDR</code> as follows:</p>
    <pre class="programlisting code"><code class="hljs-code">serverSC.setOption(StandardSocketOptions.SO_RCVBUF, <span class="hljs-number">4</span> * <span class="hljs-number">1024</span>);
serverSC.setOption(StandardSocketOptions.SO_REUSEADDR, <span class="hljs-literal">true</span>);
</code></pre>
    <p class="normal">The options supported for a server socket channel are available via <code class="inlineCode">supportedOptions()</code>:</p>
    <pre class="programlisting code"><code class="hljs-code">Set&lt;SocketOption&lt;?&gt;&gt; options = serverSC.supportedOptions();
<span class="hljs-keyword">for</span> (SocketOption&lt;?&gt; option : options)  {
  System.out.println(option);
}
</code></pre>
    <p class="normal">As you can see, you can simply print the supported options on the console.</p>
    <h3 id="_idParaDest-596" class="heading-3">Binding the server socket channel</h3>
    <p class="normal">Binding the server socket channel<a id="_idIndexMarker1480"/> to a local address is a very important step. We accomplish this via the <code class="inlineCode">bind()</code> method – for instance, let’s bind our <code class="inlineCode">serverSC</code> to localhost (<code class="inlineCode">127.0.0.1</code>) and to the arbitrarily chosen port, <code class="inlineCode">4444</code>:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">SERVER_PORT</span> <span class="hljs-operator">=</span> <span class="hljs-number">4444</span>;
<span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">SERVER_IP</span> <span class="hljs-operator">=</span> <span class="hljs-string">"127.0.0.1"</span>;
...
serverSC.bind(<span class="hljs-keyword">new</span> <span class="hljs-title">InetSocketAddress</span>(SERVER_IP, SERVER_PORT));
</code></pre>
    <p class="normal">If we omit the IP address and use the <code class="inlineCode">InetSocketAddress</code> constructor that takes only the port argument then Java will rely on the <em class="italic">wildcard </em>IP address. This address is a special local IP dedicated for bind operations only and typically it is interpreted as <em class="italic">any</em>:</p>
    <pre class="programlisting code"><code class="hljs-code">serverSC.bind(<span class="hljs-keyword">new</span> <span class="hljs-title">InetSocketAddress</span>(SERVER_PORT));
</code></pre>
    <p class="normal">However, when you decide to use the wildcard IP address keep in mind the following note.</p>
    <div class="note">
      <p class="normal"><strong class="keyWord">Important note</strong></p>
      <p class="normal">Pay attention that IP wildcard addresses may lead to undesirable complications in the presence of multiple network interfaces with separate IP addresses. If you are not prepared to handle such complications, then it is better to bind the socket to a specific network address, rather than to the IP wildcard.</p>
    </div>
    <p class="normal">If we need to specify the socket address (<code class="inlineCode">local_addr</code>) and the number of pending connections (<code class="inlineCode">pending_c</code>), then we should rely on the following <code class="inlineCode">bind()</code>:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> ServerSocketChannel <span class="hljs-title">bind</span><span class="hljs-params">(</span>
<span class="hljs-params">  </span><span class="hljs-type">SocketAddress</span><span class="hljs-params"> local_addr,</span><span class="hljs-type">int</span><span class="hljs-params"> pending_c)</span> <span class="hljs-keyword">throws</span> IOException
</code></pre>
    <p class="normal">Getting the bound local address (<code class="inlineCode">SocketAddress</code>) can be done via <code class="inlineCode">getLocalAddress()</code>. This method returns <code class="inlineCode">null</code> if the socket has not been bound yet.</p>
    <h3 id="_idParaDest-597" class="heading-3">Accepting connections</h3>
    <p class="normal">So far, the server socket channel<a id="_idIndexMarker1481"/> is open and bound. We are ready to accept the incoming clients. Since we set up the blocking mode, the application will be blocked until a connection is established (a client connection request is accepted) or an I/O error occurs.</p>
    <p class="normal">Accepting connections can be done via the <code class="inlineCode">accept()</code> method as follows:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-type">SocketChannel</span> <span class="hljs-variable">acceptSC</span> <span class="hljs-operator">=</span> serverSC.accept();
</code></pre>
    <p class="normal">This method returns a <code class="inlineCode">SocketChannel</code> representing the client socket channel (or simply, the socket channel associated with the new connection). The returned <code class="inlineCode">SocketChannel</code> is a selectable channel for stream sockets.</p>
    <div class="note">
      <p class="normal"><strong class="keyWord">Important note</strong></p>
      <p class="normal">If we call the <code class="inlineCode">accept()</code> method for a server socket channel that it was not bound to yet, then we will get back a <code class="inlineCode">NotYetBoundException</code> exception.</p>
    </div>
    <p class="normal">The remote address (<code class="inlineCode">SocketAddress</code>) to which<a id="_idIndexMarker1482"/> this channel’s socket is connected is available via the <code class="inlineCode">getRemoteAddress()</code> method:</p>
    <pre class="programlisting code"><code class="hljs-code">System.out.println(<span class="hljs-string">"New connection: "</span> 
  + acceptSC.getRemoteAddress());
</code></pre>
    <p class="normal">Next, let’s see how we can transmit data over this connection.</p>
    <h3 id="_idParaDest-598" class="heading-3">Transmitting data over a connection</h3>
    <p class="normal">At this point, the two-way connection<a id="_idIndexMarker1483"/> between the server and client is established and they can start transmitting data to each other. Each part can send/receive data packets mapped using the Java I/O streams or byte arrays. Implementing the communication protocol and choosing the proper API is quite flexible. For instance, we can rely on <code class="inlineCode">ByteBuffer</code> to implement our echo server:</p>
    <pre class="programlisting code"><code class="hljs-code">ByteBuffer tBuffer = ByteBuffer.allocateDirect(<span class="hljs-number">1024</span>);
...
<span class="hljs-keyword">while</span> (acceptSC.read(tBuffer) != -<span class="hljs-number">1</span>) {
  tBuffer.flip();
  acceptSC.write(tBuffer);
  <span class="hljs-keyword">if</span> (tBuffer.hasRemaining()) {
    tBuffer.compact();
  } <span class="hljs-keyword">else</span> {
    tBuffer.clear();
  }
}
</code></pre>
    <p class="normal">To support data transmission via <code class="inlineCode">ByteBuffer</code>, <code class="inlineCode">SocketChannel</code> exposes a set of <code class="inlineCode">read()</code>/<code class="inlineCode">write()</code> methods as follows:</p>
    <ul>
      <li class="bulletList">Read from a channel into the given buffer and return the number of bytes read (<code class="inlineCode">-1</code> if the end of stream has been reached):
        <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">(ByteBuffer dest_buffer)</span> 
  <span class="hljs-keyword">throws</span> IOException
<span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-title">read</span><span class="hljs-params">(ByteBuffer[] dests_buffers)</span> 
  <span class="hljs-keyword">throws</span> IOException
<span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-type">long</span> <span class="hljs-title">read</span><span class="hljs-params">(ByteBuffer[] dests_buffers, </span>
<span class="hljs-params">  </span><span class="hljs-type">int</span><span class="hljs-params"> buffer_offset, </span><span class="hljs-type">int</span><span class="hljs-params"> buffer_length)</span> <span class="hljs-keyword">throws</span> IOException
</code></pre>
      </li>
      <li class="bulletList">Write the bytes of a buffer into a channel and return the number of written bytes:
        <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-type">int</span> <span class="hljs-title">write</span><span class="hljs-params">(ByteBuffer source_buffer)</span>
 <span class="hljs-keyword">throws</span> IOException
<span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-title">write</span><span class="hljs-params">(ByteBuffer[] source_buffers)</span>
 <span class="hljs-keyword">throws</span> IOException
<span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-type">long</span> <span class="hljs-title">write</span><span class="hljs-params">(ByteBuffer[] source_buffers, </span>
<span class="hljs-params">  </span><span class="hljs-type">int</span><span class="hljs-params"> buffer_offset, </span><span class="hljs-type">int</span><span class="hljs-params"> buffer_length)</span> <span class="hljs-keyword">throws</span> IOException
</code></pre>
      </li>
    </ul>
    <p class="normal">If you prefer using the Java I/O API instead<a id="_idIndexMarker1484"/> of manipulating multiple instances of <code class="inlineCode">ByteBuffer</code>, then go for it:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-type">InputStream</span> <span class="hljs-variable">in</span> <span class="hljs-operator">=</span> acceptSC.socket().getInputStream();
<span class="hljs-type">OutputStream</span> <span class="hljs-variable">out</span> <span class="hljs-operator">=</span> acceptSC.socket().getOutputStream();
</code></pre>
    <p class="normal">Or, like this:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-type">BufferedReader</span> <span class="hljs-variable">in</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title">BufferedReader</span>(
  <span class="hljs-keyword">new</span> <span class="hljs-title">InputStreamReader</span>(acceptSC.getInputStream()));
<span class="hljs-type">PrintWriter</span> <span class="hljs-variable">out</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title">PrintWriter</span>(
  acceptSC.getOutputStream(), <span class="hljs-literal">true</span>);
</code></pre>
    <p class="normal">When I/O streams are involved, we have to talk about shutting down a connection for I/O as well. Without closing the channel, a connection for I/O can be shut down via <code class="inlineCode">shutdownInput()</code> and <code class="inlineCode">shutdownOutput()</code>. The <code class="inlineCode">shutdownInput()</code> method shuts down the connection for reading, while the <code class="inlineCode">shutdownOutput()</code> method shuts down the connection for writing. Attempting to read from a closed reading connection (end of stream) will result in<code class="inlineCode"> -1</code>. On the other hand, attempting to write on a closed writing connection will result in a <code class="inlineCode">ClosedChannelException</code> exception:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment">// connection will be shut down for reading</span>
acceptSC.shutdownInput();
<span class="hljs-comment">// connection will be shut down for writing</span>
acceptSC.shutdownOutput();
</code></pre>
    <p class="normal">On the other hand, if all you need is to check if a connection for I/O is open or not, this can be done via the following code:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-type">boolean</span> <span class="hljs-variable">inputdown</span> <span class="hljs-operator">=</span> acceptSC.socket().isInputShutdown();
<span class="hljs-type">boolean</span> <span class="hljs-variable">outputdown</span> <span class="hljs-operator">=</span> acceptSC.socket().isOutputShutdown();
</code></pre>
    <p class="normal">These checks are useful before<a id="_idIndexMarker1485"/> attempting to perform read/write operations via this connection for I/O.</p>
    <h3 id="_idParaDest-599" class="heading-3">Closing the channel</h3>
    <p class="normal">Closing a channel can be done<a id="_idIndexMarker1486"/> via the <code class="inlineCode">close()</code> method. If we want to close a certain client socket channel, then we rely on <code class="inlineCode">SocketChannel.close()</code> – this will not close the server (stop it listening for incoming clients). On the other hand, if we want to close the server to stop it listening for incoming clients, then simply call <code class="inlineCode">ServerSocketChannel.close()</code> as follows:</p>
    <pre class="programlisting code"><code class="hljs-code">acceptSC.close(); <span class="hljs-comment">// close a specific client</span>
serverSC.close(); <span class="hljs-comment">// close the server itself</span>
</code></pre>
    <p class="normal">Typically, you’ll close these resources in a <em class="italic">try-with-resources</em> block.</p>
    <h3 id="_idParaDest-600" class="heading-3">Putting it all together into the echo server</h3>
    <p class="normal">The source code of our echo <a id="_idIndexMarker1487"/>server can be obtained by chaining the previous snippets of code and adding some gluing code and comments:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> {
  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">SERVER_PORT</span> <span class="hljs-operator">=</span> <span class="hljs-number">4444</span>;
  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">SERVER_IP</span> <span class="hljs-operator">=</span> <span class="hljs-string">"127.0.0.1"</span>;
  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> {
    <span class="hljs-type">ByteBuffer</span> <span class="hljs-variable">tBuffer</span> <span class="hljs-operator">=</span> ByteBuffer.allocateDirect(<span class="hljs-number">1024</span>);
    <span class="hljs-comment">// open a brand new server socket channel</span>
    <span class="hljs-keyword">try</span> (<span class="hljs-type">ServerSocketChannel</span> <span class="hljs-variable">serverSC</span>
           <span class="hljs-operator">=</span> ServerSocketChannel.open()) {
      <span class="hljs-comment">// server socket channel was created</span>
      <span class="hljs-keyword">if</span> (serverSC.isOpen()) {
        <span class="hljs-comment">// configure the blocking mode</span>
        serverSC.configureBlocking(<span class="hljs-literal">true</span>);
        <span class="hljs-comment">// optionally, configure the server side options</span>
        serverSC.setOption(
          StandardSocketOptions.SO_RCVBUF, <span class="hljs-number">4</span> * <span class="hljs-number">1024</span>);
        serverSC.setOption(
          StandardSocketOptions.SO_REUSEADDR, <span class="hljs-literal">true</span>);
        <span class="hljs-comment">// bind the server socket channel to local address</span>
        serverSC.bind(<span class="hljs-keyword">new</span> <span class="hljs-title">InetSocketAddress</span>(
          SERVER_IP, SERVER_PORT));
        <span class="hljs-comment">// waiting for clients</span>
        System.out.println(<span class="hljs-string">"Waiting for clients ..."</span>);
        <span class="hljs-comment">// ready to accept incoming connections</span>
        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) {
          <span class="hljs-keyword">try</span> (<span class="hljs-type">SocketChannel</span> <span class="hljs-variable">acceptSC</span> <span class="hljs-operator">=</span> serverSC.accept()) {
            System.out.println(<span class="hljs-string">"New connection: "</span> 
              + acceptSC.getRemoteAddress());
            <span class="hljs-comment">// sending data</span>
            <span class="hljs-keyword">while</span> (acceptSC.read(tBuffer) != -<span class="hljs-number">1</span>) {
              tBuffer.flip();
              acceptSC.write(tBuffer);
              <span class="hljs-keyword">if</span> (tBuffer.hasRemaining()) {
                tBuffer.compact();
              } <span class="hljs-keyword">else</span> {
                tBuffer.clear();
              }
            }
          } <span class="hljs-keyword">catch</span> (IOException ex) {
            <span class="hljs-comment">// handle exception</span>
          }
        }
      } <span class="hljs-keyword">else</span> {
        System.out.println(
          <span class="hljs-string">"</span><span class="hljs-string">Server socket channel unavailable!"</span>);
      }
    } <span class="hljs-keyword">catch</span> (IOException ex) {
      System.err.println(ex);
      <span class="hljs-comment">// handle exception</span>
    }
  }
}
</code></pre>
    <p class="normal">Next, let’s focus on developing a client for our echo server.</p>
    <h2 id="_idParaDest-601" class="heading-2">Writing a single-thread blocking TCP client</h2>
    <p class="normal">Before writing a client, we have<a id="_idIndexMarker1488"/> to define how it works. For instance, our client connects to the server and sends the <em class="italic">Hey!</em> text. Afterward, it continues sending random integers in the range 0-100 until the number 50 is generated and sent. Once 50 are sent, the client will close the channel. The server will simply echo each message received from the client. Now, based on this scenario, we can develop a client by following these steps:</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="1">Create a new (client) socket channel</li>
      <li class="numberedList">Configure the blocking mechanism</li>
      <li class="numberedList">Connect the client socket channel</li>
      <li class="numberedList">Transmit data over a connection</li>
      <li class="numberedList">Close the channel</li>
    </ol>
    <p class="normal">Let’s tackle the first step.</p>
    <h3 id="_idParaDest-602" class="heading-3">Creating a new (client) socket channel</h3>
    <p class="normal">Creating and opening a new<a id="_idIndexMarker1489"/> client socket channel (stream-oriented connecting socket) can be done via the thread-safe <code class="inlineCode">java.nio.channels.SocketChannel</code> API as follows:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-type">SocketChannel</span> <span class="hljs-variable">clientSC</span> <span class="hljs-operator">=</span> SocketChannel.open();
</code></pre>
    <p class="normal">The resulting client socket channel is not connected. However, it is open, and this can be verified via the <code class="inlineCode">isOpen()</code> method:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">if</span> (clientSC.isOpen()) {
   ...
}
</code></pre>
    <p class="normal">However, a client socket channel can be opened and connected in a single step via the <code class="inlineCode">open(SocketAddress)</code> flavor. Next, let’s configure the blocking mechanism.</p>
    <h3 id="_idParaDest-603" class="heading-3">Configuring the blocking mechanism</h3>
    <p class="normal">Once the client socket channel<a id="_idIndexMarker1490"/> has been successfully opened, we can decide on the blocking mechanism. This can be done via the <code class="inlineCode">configureBlocking()</code> method, which gets a boolean argument (<code class="inlineCode">true</code> means a blocking client <a id="_idIndexMarker1491"/>socket channel):</p>
    <pre class="programlisting code"><code class="hljs-code">clientSC.configureBlocking(<span class="hljs-literal">true</span>);
</code></pre>
    <p class="normal">Next, we set a few options for this client socket channel.</p>
    <h3 id="_idParaDest-604" class="heading-3">Setting client socket channel options</h3>
    <p class="normal">The following options are specific<a id="_idIndexMarker1492"/> to a client socket channel: <code class="inlineCode">IP_TOS</code>, <code class="inlineCode">SO_RCVBUF</code>, <code class="inlineCode">SO_LINGER</code>, <code class="inlineCode">SO_OOBINLINE</code>, <code class="inlineCode">SO_REUSEADDR</code>, <code class="inlineCode">TCP_NODELAY</code>, <code class="inlineCode">SO_KEEPALIVE</code>, and <code class="inlineCode">SO_SNDBUF</code>. These options come with default values but they can be explicitly set as in this example:</p>
    <pre class="programlisting code"><code class="hljs-code">clientSC.setOption(
  StandardSocketOptions.SO_RCVBUF, <span class="hljs-number">131072</span>); <span class="hljs-comment">// 128 * 1024</span>
clientSC.setOption(
  StandardSocketOptions.SO_SNDBUF, <span class="hljs-number">131072</span>); <span class="hljs-comment">// 128 * 1024</span>
clientSC.setOption(
  StandardSocketOptions.SO_KEEPALIVE, <span class="hljs-literal">true</span>);
clientSC.setOption(
  StandardSocketOptions.SO_LINGER, <span class="hljs-number">5</span>);
</code></pre>
    <p class="normal">A client socket channel reveals the supported options via <code class="inlineCode">supportedOptions()</code>:</p>
    <pre class="programlisting code"><code class="hljs-code">Set&lt;SocketOption&lt;?&gt;&gt; options = clientSC.supportedOptions();
<span class="hljs-keyword">for</span> (SocketOption&lt;?&gt; option : options)  {
  System.out.println(option);
}
</code></pre>
    <p class="normal">As you can see, you can simply print the supported options to the console.</p>
    <h3 id="_idParaDest-605" class="heading-3">Connecting the client socket channel</h3>
    <p class="normal">After opening the client socket<a id="_idIndexMarker1493"/> channel, we have to connect it to the server that listens for incoming clients on <code class="inlineCode">127.0.0.1</code> and port <code class="inlineCode">4444</code>. This can be done via the <code class="inlineCode">connect()</code> method as follows:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">SERVER_PORT</span> <span class="hljs-operator">=</span> <span class="hljs-number">4444</span>;
<span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">SERVER_IP</span> <span class="hljs-operator">=</span> <span class="hljs-string">"127.0.0.1"</span>;
...
clientSC.connect(
  <span class="hljs-keyword">new</span> <span class="hljs-title">InetSocketAddress</span>(SERVER_IP, SERVER_PORT));
</code></pre>
    <p class="normal">Since this is a blocking client, the application blocks until a connection to this remote address is established or an I/O error occurs.</p>
    <p class="normal">Until transmitting data (sending/receiving data packets), you should ensure that the connection is available via <code class="inlineCode">isConnected()</code> as follows:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">if</span> (clientSC.isConnected()) {
  ...
}
</code></pre>
    <p class="normal">Moreover, keep in mind<a id="_idIndexMarker1494"/> the following note:</p>
    <div class="note">
      <p class="normal"><strong class="keyWord">Important note</strong></p>
      <p class="normal">In our simple example, the server and the client run on the same machine (<code class="inlineCode">localhost/127.0.0.1</code>). However, in reality, you should avoid hard-coding IP addresses and use the server hostname in place of its IP address. Since IP addresses can be changed and/or dynamically assigned via services such as DHCP, you should rely on hostnames (eventually configured via DNS).</p>
    </div>
    <p class="normal">Next, let’s see how we can send and receive data to/from the server.</p>
    <h3 id="_idParaDest-606" class="heading-3">Transmitting data over a connection</h3>
    <p class="normal">First, we send the text <em class="italic">Hey!</em>. Afterward, we send<a id="_idIndexMarker1495"/> integers between 0 and 100 until the integer 50 is generated. At the API level, we rely on <code class="inlineCode">ByteBuffer</code>/<code class="inlineCode">CharBuffer</code> as follows:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-type">ByteBuffer</span> <span class="hljs-variable">tBuffer</span> <span class="hljs-operator">=</span> ByteBuffer.allocateDirect(<span class="hljs-number">1024</span>);
<span class="hljs-type">ByteBuffer</span> <span class="hljs-variable">hBuffer</span> <span class="hljs-operator">=</span> ByteBuffer.wrap(<span class="hljs-string">"Hey !"</span>.getBytes());
<span class="hljs-type">ByteBuffer</span> <span class="hljs-variable">rBuffer</span>;
<span class="hljs-type">CharBuffer</span> <span class="hljs-variable">cBuffer</span>;
<span class="hljs-type">Charset</span> <span class="hljs-variable">charset</span> <span class="hljs-operator">=</span> Charset.defaultCharset();
<span class="hljs-type">CharsetDecoder</span> <span class="hljs-variable">chdecoder</span> <span class="hljs-operator">=</span> charset.newDecoder();
...
clientSC.write(hBuffer);
<span class="hljs-keyword">while</span> (clientSC.read(tBuffer) != -<span class="hljs-number">1</span>) {
  tBuffer.flip();
  cBuffer = chdecoder.decode(tBuffer);
  System.out.println(cBuffer.toString());
  <span class="hljs-keyword">if</span> (tBuffer.hasRemaining()) {
    tBuffer.compact();
  } <span class="hljs-keyword">else</span> {
    tBuffer.clear();
  }
  <span class="hljs-type">int</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title">Random</span>().nextInt(<span class="hljs-number">100</span>);
  <span class="hljs-keyword">if</span> (r == <span class="hljs-number">50</span>) {
    System.out.println(
      <span class="hljs-string">"Number 50 is here so the channel will be closed"</span>);
    <span class="hljs-keyword">break</span>;
  } <span class="hljs-keyword">else</span> {
    rBuffer = ByteBuffer.wrap(
      <span class="hljs-string">"Random number:"</span>.concat(String.valueOf(r)).getBytes());
    clientSC.write(rBuffer);
  }
}
</code></pre>
    <p class="normal">As you can see, we use <code class="inlineCode">ByteBuffer</code> for sending/receiving<a id="_idIndexMarker1496"/> data and <code class="inlineCode">CharBuffer</code> for decoding the data received from the server.</p>
    <h3 id="_idParaDest-607" class="heading-3">Closing the channel</h3>
    <p class="normal">Disconnecting the client<a id="_idIndexMarker1497"/> from the server (closing the client socket channel) can be done via the <code class="inlineCode">close()</code> method as follows:</p>
    <pre class="programlisting code"><code class="hljs-code">clientSC.close();
</code></pre>
    <p class="normal">Typically, you’ll close these resources in a <em class="italic">try-with-resources</em> block.</p>
    <h3 id="_idParaDest-608" class="heading-3">Putting it all together into the client</h3>
    <p class="normal">The source code of our client<a id="_idIndexMarker1498"/> can be obtained by chaining the previous snippets of code and adding some gluing code and comments:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> {
  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">SERVER_PORT</span> <span class="hljs-operator">=</span> <span class="hljs-number">4444</span>;
  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">SERVER_IP</span> <span class="hljs-operator">=</span> <span class="hljs-string">"127.0.0.1"</span>;
  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> {
    <span class="hljs-type">ByteBuffer</span> <span class="hljs-variable">tBuffer</span> <span class="hljs-operator">=</span> ByteBuffer.allocateDirect(<span class="hljs-number">1024</span>);
    <span class="hljs-type">ByteBuffer</span> <span class="hljs-variable">hBuffer</span> <span class="hljs-operator">=</span> ByteBuffer.wrap(<span class="hljs-string">"Hey !"</span>.getBytes());
    ByteBuffer rBuffer;
    CharBuffer cBuffer;
    <span class="hljs-type">Charset</span> <span class="hljs-variable">charset</span> <span class="hljs-operator">=</span> Charset.defaultCharset();
    <span class="hljs-type">CharsetDecoder</span> <span class="hljs-variable">chdecoder</span> <span class="hljs-operator">=</span> charset.newDecoder();
    <span class="hljs-comment">// create a brand new client socket channel</span>
    <span class="hljs-keyword">try</span> (<span class="hljs-type">SocketChannel</span> <span class="hljs-variable">clientSC</span> <span class="hljs-operator">=</span> SocketChannel.open()) {
      <span class="hljs-comment">// client socket channel was created</span>
      <span class="hljs-keyword">if</span> (clientSC.isOpen()) {
        <span class="hljs-comment">// configure the blocking mode</span>
        clientSC.configureBlocking(<span class="hljs-literal">true</span>);
        <span class="hljs-comment">// optionally, configure the client side options</span>
        clientSC.setOption(
          StandardSocketOptions.SO_RCVBUF, <span class="hljs-number">128</span> * <span class="hljs-number">1024</span>);
        clientSC.setOption(
          StandardSocketOptions.SO_SNDBUF, <span class="hljs-number">128</span> * <span class="hljs-number">1024</span>);
        clientSC.setOption(
          StandardSocketOptions.SO_KEEPALIVE, <span class="hljs-literal">true</span>);
        clientSC.setOption(
          StandardSocketOptions.SO_LINGER, <span class="hljs-number">5</span>);
        <span class="hljs-comment">// connect this channel's socket to the proper address</span>
        clientSC.connect(
          <span class="hljs-keyword">new</span> <span class="hljs-title">InetSocketAddress</span>(SERVER_IP, SERVER_PORT));
        <span class="hljs-comment">// check the connection availability</span>
          <span class="hljs-keyword">if</span> (clientSC.isConnected()) {
            <span class="hljs-comment">// sending data</span>
            clientSC.write(hBuffer);
            <span class="hljs-keyword">while</span> (clientSC.read(tBuffer) != -<span class="hljs-number">1</span>) {
              tBuffer.flip();
              cBuffer = chdecoder.decode(tBuffer);
              System.out.println(cBuffer.toString());
              <span class="hljs-keyword">if</span> (tBuffer.hasRemaining()) {
                tBuffer.compact();
              } <span class="hljs-keyword">else</span> {
                tBuffer.clear();
              }
              <span class="hljs-type">int</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title">Random</span>().nextInt(<span class="hljs-number">100</span>);
              <span class="hljs-keyword">if</span> (r == <span class="hljs-number">50</span>) {
                System.out.println(
                 <span class="hljs-string">"Number 50 is here so the channel</span>
<span class="hljs-string">                </span>  <span class="hljs-string">will be closed"</span>);
                <span class="hljs-keyword">break</span>;
              } <span class="hljs-keyword">else</span> {
                rBuffer = ByteBuffer.wrap(
                  <span class="hljs-string">"Random number:"</span>.concat(
                    String.valueOf(r)).getBytes());
                clientSC.write(rBuffer);
            }
          }
        } <span class="hljs-keyword">else</span> {
          System.out.println(<span class="hljs-string">"Connection unavailable!"</span>);
        }
      } <span class="hljs-keyword">else</span> {
        System.out.println(
          <span class="hljs-string">"Client socket channel unavailable!"</span>);
      }
    } <span class="hljs-keyword">catch</span> (IOException ex) {
      System.err.println(ex);
      <span class="hljs-comment">// handle exception</span>
    }
  }
}
</code></pre>
    <p class="normal">Finally, let’s test our server/client application.</p>
    <h2 id="_idParaDest-609" class="heading-2">Testing the blocking echo application</h2>
    <p class="normal">First, start the server<a id="_idIndexMarker1499"/> application. Second, start the client application and check out the console output:</p>
    <pre class="programlisting con"><code class="hljs-con">Hey !
Random number:17
Random number:31
Random number:53
…
Random number:7
Number 50 is here so the channel will be closed
</code></pre>
    <p class="normal">You can even start a few clients at the same time to see how it works. The server will display the remote address of each client.</p>
    <h1 id="_idParaDest-610" class="heading-1">262. Writing a non-blocking TCP server/client application</h1>
    <p class="normal">In this problem, we will write<a id="_idIndexMarker1500"/> a non-blocking TCP server/client application. </p>
    <p class="normal">A non-blocking socket (or a socket in non-blocking mode) allows us to perform I/O operations on socket channels without blocking the processes that are using it. The major steps of a non-blocking application are exactly the same as for a blocking application. The server is opened and bound to a local address ready to handle incoming clients. A client is opened and connected to the server. From this point forward, the server and the client can exchange data packets in a non-blocking fashion.</p>
    <p class="normal">When we refer to exchanging data in a non-blocking fashion, we refer to the pillar of non-blocking technology, which is the <code class="inlineCode">java.nio.channels.Selector</code> class. The role of the <code class="inlineCode">Selector</code> is to orchestrate data transfer across multiple available socket channels. Basically, a <code class="inlineCode">Selector</code> can monitor every single recorded socket channel and detect the channels that are available for data transfer in order to handle the clients’ requests. In addition, a <code class="inlineCode">Selector</code> is capable of handling multiple sockets’ I/O operations via a single thread. This is possible via a concept known as <em class="italic">multiplexing</em>. So, instead of having a thread per socket connection, <em class="italic">multiplexing</em> allows the usage of a single thread for multiple socket connections. The <code class="inlineCode">Selector</code> is known<a id="_idIndexMarker1501"/> and referred to as the <em class="italic">multiplexor</em> of a <code class="inlineCode">SelectableChannel</code> that is registered via the <code class="inlineCode">register()</code> method of <code class="inlineCode">SocketChannel</code> or <code class="inlineCode">ServerSocketChannel</code> (subclasses of <code class="inlineCode">SelectableChannel</code>). The <code class="inlineCode">Selector</code> and the <code class="inlineCode">SelectableChannel</code> are deregistered/deallocated<a id="_idIndexMarker1502"/> together.</p>
    <h2 id="_idParaDest-611" class="heading-2">Using the SelectionKey class</h2>
    <p class="normal">It is time to take a step further<a id="_idIndexMarker1503"/> and introduce the <code class="inlineCode">SelectionKey</code> class. A channel<a id="_idIndexMarker1504"/> is registered with a <code class="inlineCode">Selector</code> via an instance of <code class="inlineCode">java.nio.channels.SelectionKey</code> and all the <code class="inlineCode">SelectionKey</code> instances are known as selection keys. A selection key acts as a helper for the selector being used to sort the requests of a client. Practically, a selection key carries information (metadata) about a single client subrequest such as the type of subrequest (connect, write, read, and so on) and information needed to uniquely identify the client.</p>
    <p class="normal">During the registration of a <code class="inlineCode">SelectableChannel</code> with a <code class="inlineCode">Selector</code>, we point out the set of operations for which the key’s channel will be monitored by this selector – this is known as the <em class="italic">interest set</em>. When an operation becomes eligible to be performed, it becomes part of the so-called <em class="italic">ready set</em> (this set is initialized with 0 when the key is created). So, a selection key handles two operation sets (<em class="italic">interest set</em> and <em class="italic">ready set</em>) represented as integer values. Each bit of an operation set represents a category of selectable operations that are supported by the key’s channel. A key can be of one of the following types:</p>
    <ul>
      <li class="bulletList"><code class="inlineCode">SelectionKey.OP_ACCEPT</code> (<em class="italic">acceptable</em>): Bit for marking socket-accept operations</li>
      <li class="bulletList"><code class="inlineCode">SelectionKey.OP_CONNECT</code> (<em class="italic">connectable</em>): Bit for marking socket-connect operations</li>
      <li class="bulletList"><code class="inlineCode">SelectionKey.OP_READ</code> (<em class="italic">readable</em>): Bit for marking read operations</li>
      <li class="bulletList"><code class="inlineCode">SelectionKey.OP_WRITE</code> (<em class="italic">writable</em>): Bit for marking write operations</li>
    </ul>
    <p class="normal">A selector must handle three sets of selection keys as follows:</p>
    <ul>
      <li class="bulletList"><em class="italic">key-set</em>: Contains all the keys of the currently registered channel.</li>
      <li class="bulletList"><em class="italic">selected-key</em>: Every key that is ready for at least one of the operations from the key’s <em class="italic">interest set</em> is part of the <em class="italic">selected-key</em>.</li>
      <li class="bulletList"><em class="italic">canceled-key</em>: This contains all the keys that have been canceled but still have registered channels.<div class="note">
          <p class="normal"><strong class="keyWord">Important note</strong></p>
          <p class="normal">When a selector is created, these three sets are empty. Pay attention that the <code class="inlineCode">Selector</code> instances are thread-safe, but their key sets however are not.</p>
        </div>
      </li>
    </ul>
    <p class="normal">When some action takes place, the selector wakes up. It starts creating the <code class="inlineCode">SelectionKey</code>, where each such key contains information about the current request.</p>
    <p class="normal">The selector waits for the recorded events (for instance, incoming connection requests) in an infinite loop. Commonly, the first line of this loop is <code class="inlineCode">Selector.select()</code>. This is a blocking call that takes place until the <code class="inlineCode">Selector.wakeup()</code> method is called, at least one channel is selectable, or the current thread gets interrupted. There is also a <code class="inlineCode">select(long timeout)</code> method that works as <code class="inlineCode">select()</code> but with a timeout. In addition, we have <code class="inlineCode">selectNow()</code>, which is non-blocking – if there are no selectable channels, then <code class="inlineCode">selectNow()</code> returns <code class="inlineCode">0</code> immediately.</p>
    <p class="normal">Let’s assume that the selector<a id="_idIndexMarker1505"/> waits for a connection<a id="_idIndexMarker1506"/> attempt. When a client attempts to connect, the server checks the type of each key created by the selector. If the type is <code class="inlineCode">OP_ACCEPT</code> (acceptable key) then the <code class="inlineCode">SelectionKey.isAcceptable()</code> method takes action. When this method returns <code class="inlineCode">true</code> the server locates the client socket channel via the <code class="inlineCode">accept()</code> methods. In addition, it sets this socket channel as non-blocking and registers it to the selector as eligible for <code class="inlineCode">OP_READ</code> and/or <code class="inlineCode">OP_WRITE</code> operations. While processing the keys created by the selector the server removes them from the list (an <code class="inlineCode">Iterator</code> over these keys) in order to prevent the re-evaluation of the same key.</p>
    <p class="normal">So far, the client socket channel is registered to the selector for read/write operations. Now, if the client sends (writes to the channel) some data on the socket channel then the selector will inform the server side that it should/can read that data (in this scenario, the <code class="inlineCode">SelectionKey.isReadable()</code> method, returns <code class="inlineCode">true</code>). On the other hand, when the client receives (reads) some data from the server, the <code class="inlineCode">SelectionKey.isWritable()</code> method returns <code class="inlineCode">true</code>. </p>
    <p class="normal">The following diagram highlights <a id="_idIndexMarker1507"/>the selector-based<a id="_idIndexMarker1508"/> non-blocking flow:</p>
    <figure class="mediaobject"><img src="../Images/B19655_13_02.png" alt="Figure 13.2.png"/></figure>
    <p class="packt_figref">Figure 13.2: The selector-based non-blocking flow</p>
    <div class="note">
      <p class="normal"><strong class="keyWord">Important note</strong></p>
      <p class="normal">In non-blocking mode, we may<a id="_idIndexMarker1509"/> face the so-called <em class="italic">partial read/write</em>. This means that an I/O operation has partially transferred (read or written) some data (fewer bytes) or no data at all (0 bytes).</p>
    </div>
    <p class="normal">Next, let’s briefly cover the <code class="inlineCode">Selector</code> methods.</p>
    <h2 id="_idParaDest-612" class="heading-2">Using the Selector methods</h2>
    <p class="normal">Before coding a non-blocking TCP server/client<a id="_idIndexMarker1510"/> application, we have<a id="_idIndexMarker1511"/> to know a few built-in methods that sustain our goal:</p>
    <ul>
      <li class="bulletList"><code class="inlineCode">Selector.open()</code>: This creates and opens a new selector.</li>
      <li class="bulletList"><code class="inlineCode">Selector.select()</code>: This is a blocking operation that selects a set of keys.</li>
      <li class="bulletList"><code class="inlineCode">Selector.select(long t)</code>: This works exactly as <code class="inlineCode">select()</code>, but with a timeout specified in milliseconds. If there is nothing to select during <code class="inlineCode">t</code>, then this method returns <code class="inlineCode">0</code>.</li>
      <li class="bulletList"><code class="inlineCode">Selector.selectNow()</code>: This is a non-blocking version of <code class="inlineCode">select()</code>. If there is nothing to select, then this method returns <code class="inlineCode">0</code>.</li>
      <li class="bulletList"><code class="inlineCode">Selector.keys()</code>: This returns <code class="inlineCode">Set&lt;SelectionKey&gt;</code> (selector’s key set).</li>
      <li class="bulletList"><code class="inlineCode">Selector.selectedKeys()</code>: This returns <code class="inlineCode">Set&lt;SelectionKey&gt;</code> (selector’s selected key set).</li>
      <li class="bulletList"><code class="inlineCode">Selector.wakeup()</code>: The first selection operation (which has not yet returned) will return immediately.</li>
      <li class="bulletList"><code class="inlineCode">SelectionKey.isReadable()</code>: This checks if this key’s channel is ready for reading.</li>
      <li class="bulletList"><code class="inlineCode">SelectionKey.isWritable()</code>: This checks if this key’s channel is ready for writing.</li>
      <li class="bulletList"><code class="inlineCode">SelectionKey.isValid()</code>: This checks this key’s validity. An invalid key is canceled, its selector is closed, or its channel is closed.</li>
      <li class="bulletList"><code class="inlineCode">SelectionKey.isAcceptable()</code>: If this method returns <code class="inlineCode">true</code>, then a new socket connection will be accepted by this key’s channel.</li>
      <li class="bulletList"><code class="inlineCode">SelectionKey.isConnectable()</code>: This checks if this key’s channel has successfully finished or failed to finish its current socket connection operation.</li>
      <li class="bulletList"><code class="inlineCode">SelectionKey.interestOps()</code>: This returns this key’s <em class="italic">interest set</em>.</li>
      <li class="bulletList"><code class="inlineCode">SelectionKey.interestOps(t)</code>: This sets this key’s <em class="italic">interest set</em> to <code class="inlineCode">t</code>.</li>
      <li class="bulletList"><code class="inlineCode">SelectionKey.readyOps()</code>: This returns this key’s <em class="italic">ready-operation set</em>.</li>
      <li class="bulletList"><code class="inlineCode">SelectionKey.cancel()</code>: This cancels the registration of this key’s channel with its selector.</li>
    </ul>
    <p class="normal">Registering a channel with a given selector can be done via the <code class="inlineCode">register()</code> method of <code class="inlineCode">ServerSocketChannel</code> and <code class="inlineCode">SocketChannel</code>:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-title">SelectionKeyregister</span><span class="hljs-params">(</span>
<span class="hljs-params">  Selector s, </span><span class="hljs-type">int</span><span class="hljs-params"> p, Object a)</span> <span class="hljs-keyword">throws</span> ClosedChannelException
</code></pre>
    <p class="normal">The <code class="inlineCode">s</code> argument is the given selector. The <code class="inlineCode">p</code> argument is the <em class="italic">interest set</em> for the selection key, and the <code class="inlineCode">a</code> argument is the attachment<a id="_idIndexMarker1512"/> for the selection<a id="_idIndexMarker1513"/> key (may be <code class="inlineCode">null</code>).</p>
    <h2 id="_idParaDest-613" class="heading-2">Writing the non-blocking server</h2>
    <p class="normal">Based on the previous information, we can write<a id="_idIndexMarker1514"/> the following non-blocking echo server (the code may look a little bit large, but it is sprinkled with helpful comments):</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> {
  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">SERVER_PORT</span> <span class="hljs-operator">=</span> <span class="hljs-number">4444</span>;
  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Map&lt;SocketChannel, List&lt;<span class="hljs-type">byte</span>[]&gt;&gt;
    registerTrack = <span class="hljs-keyword">new</span> <span class="hljs-title">HashMap</span>&lt;&gt;();
  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">ByteBuffer</span> <span class="hljs-variable">tBuffer</span>
    <span class="hljs-operator">=</span> ByteBuffer.allocate(<span class="hljs-number">2</span> * <span class="hljs-number">1024</span>);
  <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">startEchoServer</span><span class="hljs-params">()</span> { 
    <span class="hljs-comment">// call the open() method for Selector/ServerSocketChannel</span>
    <span class="hljs-keyword">try</span> (<span class="hljs-type">Selector</span> <span class="hljs-variable">selector</span> <span class="hljs-operator">=</span> Selector.open();
      <span class="hljs-type">ServerSocketChannel</span> <span class="hljs-variable">serverSC</span>
        <span class="hljs-operator">=</span> ServerSocketChannel.open()) {
      <span class="hljs-comment">// ServerSocketChannel and Selector successfully opened</span>
      <span class="hljs-keyword">if</span> ((serverSC.isOpen()) &amp;&amp; (selector.isOpen())) {
        <span class="hljs-comment">// configure non-blocking mode</span>
        serverSC.configureBlocking(<span class="hljs-literal">false</span>);
        <span class="hljs-comment">// optionally, configure the client side options</span>
        serverSC.setOption(
          StandardSocketOptions.SO_RCVBUF, <span class="hljs-number">256</span> * <span class="hljs-number">1024</span>);
        serverSC.setOption(
          StandardSocketOptions.SO_REUSEADDR, <span class="hljs-literal">true</span>);
        <span class="hljs-comment">// bind the server socket channel to the port</span>
        serverSC.bind(<span class="hljs-keyword">new</span> <span class="hljs-title">InetSocketAddress</span>(SERVER_PORT));
        <span class="hljs-comment">// register this channel with the selector</span>
        serverSC.register(selector, SelectionKey.OP_ACCEPT);
        <span class="hljs-comment">// waiting for clients</span>
        System.out.println(<span class="hljs-string">"Waiting for clients ..."</span>);
        ...
</code></pre>
    <p class="normal">Next, we have the infinite<a id="_idIndexMarker1515"/> loop of the <code class="inlineCode">Selector</code>:</p>
    <pre class="programlisting code"><code class="hljs-code">        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) {
          <span class="hljs-comment">// waiting for events</span>
          selector.select();
          <span class="hljs-comment">// the selected keys have something to be processed</span>
          <span class="hljs-type">Iterator</span> <span class="hljs-variable">itkeys</span> <span class="hljs-operator">=</span>selector.selectedKeys().iterator();
          <span class="hljs-keyword">while</span> (itkeys.hasNext()) {
            <span class="hljs-type">SelectionKey</span> <span class="hljs-variable">selkey</span>
              <span class="hljs-operator">=</span> (SelectionKey) itkeys.next();
             <span class="hljs-comment">// avoid processing the same key twice</span>
            itkeys.remove();
            <span class="hljs-keyword">if</span> (!selkey.isValid()) {
              <span class="hljs-keyword">continue</span>;
            }
            <span class="hljs-keyword">if</span> (selkey.isAcceptable()) {
              acceptOperation(selkey, selector);
            } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (selkey.isReadable()) {
              <span class="hljs-built_in">this</span>.readOperation(selkey);
            } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (selkey.isWritable()) {
              <span class="hljs-built_in">this</span>.writeOperation(selkey);
            }
          }
        }
      } <span class="hljs-keyword">else</span> {
        System.out.println(
          <span class="hljs-string">"Cannot open the selector/channel"</span>);
      }
    } <span class="hljs-keyword">catch</span> (IOException ex) {
      System.err.println(ex);
      <span class="hljs-comment">// handle exception</span>
    }
  }
...
</code></pre>
    <p class="normal">Further, we have a set of helpers<a id="_idIndexMarker1516"/> responsible for accepting connections and performing read/write operations. First, we have the <code class="inlineCode">acceptOperation()</code> helper:</p>
    <pre class="programlisting code"><code class="hljs-code">  <span class="hljs-comment">// isAcceptable = true</span>
  <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">acceptOperation</span><span class="hljs-params">(SelectionKey selkey, </span>
<span class="hljs-params">        Selector selector)</span> <span class="hljs-keyword">throws</span> IOException {
    <span class="hljs-type">ServerSocketChannel</span> <span class="hljs-variable">serverSC</span>
      <span class="hljs-operator">=</span> (ServerSocketChannel) selkey.channel();
    <span class="hljs-type">SocketChannel</span> <span class="hljs-variable">acceptSC</span> <span class="hljs-operator">=</span> serverSC.accept();
    acceptSC.configureBlocking(<span class="hljs-literal">false</span>);
    System.out.println(<span class="hljs-string">"New connection: "</span> 
      + acceptSC.getRemoteAddress());
    <span class="hljs-comment">// send an welcome message</span>
    acceptSC.write(ByteBuffer.wrap(
      <span class="hljs-string">"Hey !\n"</span>.getBytes(<span class="hljs-string">"UTF-8"</span>)));
    <span class="hljs-comment">// register the channel with selector to support more I/O</span>
    registerTrack.put(acceptSC, <span class="hljs-keyword">new</span> <span class="hljs-title">ArrayList</span>&lt;&gt;());
    acceptSC.register(selector, SelectionKey.OP_READ);
  }
  ...
</code></pre>
    <p class="normal">The helpers for read/write operations are:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment">// isReadable = true</span>
  <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">readOperation</span><span class="hljs-params">(SelectionKey selkey)</span> {
    <span class="hljs-keyword">try</span> {
      <span class="hljs-type">SocketChannel</span> <span class="hljs-variable">socketC</span>
        <span class="hljs-operator">=</span> (SocketChannel) selkey.channel();
      tBuffer.clear();
      <span class="hljs-type">int</span> <span class="hljs-variable">byteRead</span> <span class="hljs-operator">=</span> -<span class="hljs-number">1</span>;
      <span class="hljs-keyword">try</span> {
        byteRead = socketC.read(tBuffer);
      } <span class="hljs-keyword">catch</span> (IOException e) {
        System.err.println(<span class="hljs-string">"Read error!"</span>);
        <span class="hljs-comment">// handle exception</span>
      }
      <span class="hljs-keyword">if</span> (byteRead == -<span class="hljs-number">1</span>) {
        <span class="hljs-built_in">this</span>.registerTrack.remove(socketC);
        System.out.println(<span class="hljs-string">"Connection was closed by: "</span> 
          + socketC.getRemoteAddress());
        socketC.close();
        selkey.cancel();
        <span class="hljs-keyword">return</span>;
      }
      <span class="hljs-type">byte</span>[] byteData = <span class="hljs-keyword">new</span> <span class="hljs-title">byte</span>[byteRead];
      System.arraycopy(
        tBuffer.array(), <span class="hljs-number">0</span>, byteData, <span class="hljs-number">0</span>, byteRead);
      System.out.println(<span class="hljs-keyword">new</span> <span class="hljs-title">String</span>(byteData, <span class="hljs-string">"UTF-8"</span>) 
        + <span class="hljs-string">" from "</span> + socketC.getRemoteAddress());
      <span class="hljs-comment">// send the bytes back to client</span>
      doEchoTask(selkey, byteData);
    } <span class="hljs-keyword">catch</span> (IOException ex) {
      System.err.println(ex);
      <span class="hljs-comment">// handle exception</span>
    }
  }
  <span class="hljs-comment">// isWritable = true</span>
  <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">writeOperation</span><span class="hljs-params">(SelectionKey selkey)</span> 
        <span class="hljs-keyword">throws</span> IOException {
    <span class="hljs-type">SocketChannel</span> <span class="hljs-variable">socketC</span> <span class="hljs-operator">=</span> (SocketChannel) selkey.channel();
    List&lt;<span class="hljs-type">byte</span>[]&gt; channelByteData = registerTrack.get(socketC);
    Iterator&lt;<span class="hljs-type">byte</span>[]&gt; iter = channelByteData.iterator();
    <span class="hljs-keyword">while</span> (iter.hasNext()) {
      <span class="hljs-type">byte</span>[] itb = iter.next();
      iter.remove();
      socketC.write(ByteBuffer.wrap(itb));
    }
    selkey.interestOps(SelectionKey.OP_READ);
  }
  <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doEchoTask</span><span class="hljs-params">(</span>
<span class="hljs-params">        SelectionKey selkey, </span><span class="hljs-type">byte</span><span class="hljs-params">[] dataByte)</span> {
    <span class="hljs-type">SocketChannel</span> <span class="hljs-variable">socketC</span> <span class="hljs-operator">=</span> (SocketChannel) selkey.channel();
    List&lt;<span class="hljs-type">byte</span>[]&gt; channelByteData = registerTrack.get(socketC);
    channelByteData.add(dataByte);
    selkey.interestOps(SelectionKey.OP_WRITE);
  }
  ...
</code></pre>
    <p class="normal">Finally, we have<a id="_idIndexMarker1517"/> to call the <code class="inlineCode">startEchoServer()</code>:</p>
    <pre class="programlisting code"><code class="hljs-code">  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> {
    <span class="hljs-type">Main</span> <span class="hljs-variable">main</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title">Main</span>();
    main.startEchoServer();
  }
}
</code></pre>
    <p class="normal">Next, let’s focus on writing the client for our non-blocking echo server.</p>
    <h2 id="_idParaDest-614" class="heading-2">Writing the non-blocking client</h2>
    <p class="normal">The main structure of the non-blocking client<a id="_idIndexMarker1518"/> is the same as the structure of the non-blocking server. However, there are a few things that are not the same and they deserve a brief overview as follows:</p>
    <ul>
      <li class="bulletList">The client socket channel must be registered with the <code class="inlineCode">SelectionKey.OP_CONNECT</code> operation. This is needed because the client must be informed by the selector when the non-blocking server accepts its connection request.</li>
      <li class="bulletList">While the server side may wait for incoming clients infinitely, a client cannot attempt to connect in the same way. In other words, a client will rely on <code class="inlineCode">Selector.select(long timeout)</code>. A timeout that ranges from 500 to 1,000 ms should do the job.</li>
      <li class="bulletList">The client is also responsible for checking if the key is connectable via <code class="inlineCode">SelectionKey.isConnectable()</code>. If this method returns <code class="inlineCode">true</code>, then the client joins the <code class="inlineCode">isConnectionPending()</code> and <code class="inlineCode">finishConnect()</code> APIs in a conditional statement. This construction is needed for closing any pending connections. Practically, the <code class="inlineCode">isConnectionPending()</code> method tells us if there is any connection operation in progress on the current client channel, while the <code class="inlineCode">finishConnect()</code> method will finish the process of connecting a socket channel.</li>
    </ul>
    <p class="normal">Now, we are ready to list the client code, which<a id="_idIndexMarker1519"/> follows the same scenario as in the previous problem (we send the <em class="italic">Hey!</em> text followed by random integers ranging from 0 to 100 until the number 50 is generated):</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> {
  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">SERVER_PORT</span> <span class="hljs-operator">=</span> <span class="hljs-number">4444</span>;
  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">SERVER_IP</span> <span class="hljs-operator">=</span> <span class="hljs-string">"127.0.0.1"</span>;
  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">TIMEOUT_SELECTOR</span> <span class="hljs-operator">=</span> <span class="hljs-number">1_000</span>;
  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> 
        <span class="hljs-keyword">throws</span> InterruptedException { 
    <span class="hljs-type">ByteBuffer</span> <span class="hljs-variable">tBuffer</span> <span class="hljs-operator">=</span> ByteBuffer.allocateDirect(<span class="hljs-number">2</span> * <span class="hljs-number">1024</span>);
    ByteBuffer rBuffer;
    CharBuffer cBuffer;
    <span class="hljs-type">Charset</span> <span class="hljs-variable">charset</span> <span class="hljs-operator">=</span> Charset.defaultCharset();
    <span class="hljs-type">CharsetDecoder</span> <span class="hljs-variable">chdecoder</span> <span class="hljs-operator">=</span> charset.newDecoder();
    <span class="hljs-comment">// call the open() for ServerSocketChannel and Selector</span>
    <span class="hljs-keyword">try</span> (<span class="hljs-type">Selector</span> <span class="hljs-variable">selector</span> <span class="hljs-operator">=</span> Selector.open();
      <span class="hljs-type">SocketChannel</span> <span class="hljs-variable">clientSC</span> <span class="hljs-operator">=</span> SocketChannel.open()) {
      <span class="hljs-comment">// ServerSocketChannel and Selector successfully opened</span>
      <span class="hljs-keyword">if</span> ((clientSC.isOpen()) &amp;&amp; (selector.isOpen())) {
        <span class="hljs-comment">// configure non-blocking mode</span>
        clientSC.configureBlocking(<span class="hljs-literal">false</span>);
        <span class="hljs-comment">// optionally, configure the client side options</span>
        clientSC.setOption(
          StandardSocketOptions.SO_RCVBUF, <span class="hljs-number">128</span> * <span class="hljs-number">1024</span>);
        clientSC.setOption(
          StandardSocketOptions.SO_SNDBUF, <span class="hljs-number">128</span> * <span class="hljs-number">1024</span>);
        clientSC.setOption(
          StandardSocketOptions.SO_KEEPALIVE, <span class="hljs-literal">true</span>);
        <span class="hljs-comment">// register this channel with the selector</span>
        clientSC.register(selector, SelectionKey.OP_CONNECT);
        <span class="hljs-comment">// connecting to the remote host</span>
        clientSC.connect(<span class="hljs-keyword">new</span> <span class="hljs-title">java</span>.net.InetSocketAddress(
          SERVER_IP, SERVER_PORT));
        System.out.println(<span class="hljs-string">"Local host: "</span> 
          + clientSC.getLocalAddress());
        ...
</code></pre>
    <p class="normal">Next, we are ready<a id="_idIndexMarker1520"/> to wait to connect to the server:</p>
    <pre class="programlisting code"><code class="hljs-code">        <span class="hljs-comment">// waiting for the connection</span>
        <span class="hljs-keyword">while</span> (selector.select(TIMEOUT_SELECTOR) &gt; <span class="hljs-number">0</span>) {
          <span class="hljs-comment">// get the keys</span>
          <span class="hljs-type">Set</span> <span class="hljs-variable">selkeys</span> <span class="hljs-operator">=</span> selector.selectedKeys();
          <span class="hljs-type">Iterator</span> <span class="hljs-variable">iter</span> <span class="hljs-operator">=</span> selkeys.iterator();
          <span class="hljs-comment">// traverse and process the keys</span>
          <span class="hljs-keyword">while</span> (iter.hasNext()) {
            <span class="hljs-type">SelectionKey</span> <span class="hljs-variable">selkey</span> <span class="hljs-operator">=</span> (SelectionKey) iter.next();
            <span class="hljs-comment">// remove the current key</span>
            iter.remove();
            <span class="hljs-comment">// get the key's socket channel</span>
            <span class="hljs-keyword">try</span> (<span class="hljs-type">SocketChannel</span> <span class="hljs-variable">keySC</span>
                  <span class="hljs-operator">=</span> (SocketChannel) selkey.channel()) {
              <span class="hljs-comment">// attempt a connection</span>
              <span class="hljs-keyword">if</span> (selkey.isConnectable()) {
                <span class="hljs-comment">// connection successfully achieved</span>
                System.out.println(
                  <span class="hljs-string">"Connection successfully achieved!"</span>);
                <span class="hljs-comment">// pending connections will be closed</span>
                <span class="hljs-keyword">if</span> (keySC.isConnectionPending()) {
                  keySC.finishConnect();
                }
                ...
</code></pre>
    <p class="normal">Once the client is connected, it can read/write data from/to<a id="_idIndexMarker1521"/> the server side:</p>
    <pre class="programlisting code"><code class="hljs-code">                <span class="hljs-comment">// read/write from/to server </span>
                <span class="hljs-keyword">while</span> (keySC.read(tBuffer) != -<span class="hljs-number">1</span>) {
                  tBuffer.flip();
                  cBuffer = chdecoder.decode(tBuffer);
                  System.out.println(cBuffer.toString());
                  <span class="hljs-keyword">if</span> (tBuffer.hasRemaining()) {
                    tBuffer.compact();
                  } <span class="hljs-keyword">else</span> {
                    tBuffer.clear();
                  }
                  <span class="hljs-type">int</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title">Random</span>().nextInt(<span class="hljs-number">100</span>);
                  <span class="hljs-keyword">if</span> (r == <span class="hljs-number">50</span>) {
                    System.out.println(
                      <span class="hljs-string">"Number 50 is here so </span>
<span class="hljs-string">                       the channel will be closed"</span>);
                    <span class="hljs-keyword">break</span>;
                  } <span class="hljs-keyword">else</span> {
                    rBuffer = ByteBuffer.wrap(
                      <span class="hljs-string">"Random number:"</span>.concat(
                        String.valueOf(r).concat(<span class="hljs-string">" "</span>))
                        .getBytes(<span class="hljs-string">"UTF-8"</span>));
                    keySC.write(rBuffer);
                  }
                }
              }
            } <span class="hljs-keyword">catch</span> (IOException ex) {
              System.err.println(ex);
              <span class="hljs-comment">// handle exception</span>
            }
          }
        }
      } <span class="hljs-keyword">else</span> {
        System.out.println(
          <span class="hljs-string">"Cannot open the selector/channel"</span>);
      }
    } <span class="hljs-keyword">catch</span> (IOException ex) {
      System.err.println(ex);
      <span class="hljs-comment">// handle exception</span>
    }
  }
}
</code></pre>
    <p class="normal">Finally, let’s test our non-blocking application.</p>
    <h2 id="_idParaDest-615" class="heading-2">Testing the non-blocking echo application</h2>
    <p class="normal">First, start the server side. Afterward, start<a id="_idIndexMarker1522"/> a few clients and check each console output:</p>
    <figure class="mediaobject"><img src="../Images/B19655_13_03.png" alt="Figure 13.3.png"/></figure>
    <p class="packt_figref">Figure 13.3: A possible output of our non-blocking server</p>
    <p class="normal">Keep in mind that this is not a multithreading<a id="_idIndexMarker1523"/> application. It is just a single-threaded application that relies on the <em class="italic">multiplexing</em> technique.</p>
    <h1 id="_idParaDest-616" class="heading-1">263. Writing UDP server/client applications</h1>
    <p class="normal">UDP is a protocol built on top<a id="_idIndexMarker1524"/> of IP. Via UDP, we can send data packets of at most 65,507 bytes (that is, 65,535-byte IP packet size – plus the minimum IP header of 20 bytes – plus the 8-byte UDP header = 65,507 bytes total). In UDP, data packets are seen as individual entities. In other words, no packet is aware of others. Data packets may arrive in any order or may not arrive at all. The sender will not be informed about the lost packets, so it will not know what to resend. Moreover, data packets may arrive too fast or too slow, so processing them may be a real challenge.</p>
    <p class="normal">While TCP is famous for high-reliability data transmissions, UDP is famous for low-overhead transmissions. So, UDP is more like sending a letter (remember that TCP is like a phone call). You write on the envelope the address of the receiver (here, the remote IP and port) and your address (here, local IP and port) and send it (here, over the wires). You don’t know if the letter will ever arrive at the receiver (here, the sender cannot trace the routes of the packets) and if you send more letters you cannot control the order of their arrival (here, an old packet can arrive after a more recent packet). In this context, UDP fits well if all you care about is speed. So, if you can afford losing packets and the order of receiving them is not important then UDP might be the right choice. For instance, an application that should send the state of a sensor every <em class="italic">n</em> milliseconds<a id="_idIndexMarker1525"/> may take advantage of the UDP protocol. </p>
    <h2 id="_idParaDest-617" class="heading-2">Writing a single-thread blocking UDP echo server</h2>
    <p class="normal">In order to write a single-thread blocking UDP echo<a id="_idIndexMarker1526"/> server, we will follow these steps:</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="1">Create a server datagram-oriented socket channel</li>
      <li class="numberedList">Set datagram-oriented socket channel options</li>
      <li class="numberedList">Bind the server datagram-oriented socket channel</li>
      <li class="numberedList">Transmit data packets</li>
      <li class="numberedList">Close the channel</li>
    </ol>
    <p class="normal">Let’s start with the first step.</p>
    <h3 id="_idParaDest-618" class="heading-3">Creating a server datagram-oriented socket channel</h3>
    <p class="normal">The climax of a server/client UDP application<a id="_idIndexMarker1527"/> is represented by a thread-safe selectable channel dedicated to working with datagram-oriented sockets (or simply, datagram sockets). In API terms, this is referred to as <code class="inlineCode">java.nio.channels.DatagramChannel</code>.</p>
    <p class="normal">Such a channel can be obtained via <code class="inlineCode">DatagramChannel.open()</code>, which gets a single parameter of the type <code class="inlineCode">java.net.ProtocolFamily</code>. The protocol family implementation (<code class="inlineCode">java.net.StandardProtocolFamily</code>) has two possible values:</p>
    <ul>
      <li class="bulletList"><code class="inlineCode">StandardProtocolFamily.INET</code>: IP version 4 (IPv4)</li>
      <li class="bulletList"><code class="inlineCode">StandardProtocolFamily.INET6</code>: IP version 6 (IPv6)</li>
    </ul>
    <p class="normal">Next, we focus on the datagram socket for IPv4, so we call the <code class="inlineCode">open()</code> method as follows:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-type">DatagramChannel</span> <span class="hljs-variable">dchannel</span>
  <span class="hljs-operator">=</span> DatagramChannel.open(StandardProtocolFamily.INET);
</code></pre>
    <p class="normal">If you don’t care about the protocol family, then you can call the <code class="inlineCode">open()</code> method without arguments. In that case, the protocol family is platform-dependent.</p>
    <p class="normal">Before going further, we can check if a datagram socket is open via the <code class="inlineCode">isOpen()</code> flag method:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">if</span> (dchannel.isOpen()) {
  ...
}
</code></pre>
    <p class="normal">A client datagram socket<a id="_idIndexMarker1528"/> can be opened in the same manner as a server datagram socket.</p>
    <h3 id="_idParaDest-619" class="heading-3">Setting datagram-oriented socket channel options</h3>
    <p class="normal">The options supported by a datagram<a id="_idIndexMarker1529"/> socket channel are <code class="inlineCode">SO_BROADCAST</code>, <code class="inlineCode">IP_TOS</code>, <code class="inlineCode">IP_MULTICAST_LOOP</code>, <code class="inlineCode">IP_MULTICAST_TTL</code>,<code class="inlineCode">SO_SNDBUF</code>, <code class="inlineCode">SO_REUSEADDR</code>, <code class="inlineCode">IP_MULTICAST_IF</code>, and <code class="inlineCode">SO_RCVBUF</code>. Here are some examples of setting a few of them:</p>
    <pre class="programlisting code"><code class="hljs-code">dchannel.setOption(StandardSocketOptions.SO_RCVBUF, <span class="hljs-number">4</span> * <span class="hljs-number">1024</span>);
dchannel.setOption(StandardSocketOptions.SO_SNDBUF, <span class="hljs-number">4</span> * <span class="hljs-number">1024</span>);
</code></pre>
    <p class="normal">The supported options are available via <code class="inlineCode">supportedOptions()</code>:</p>
    <pre class="programlisting code"><code class="hljs-code">Set&lt;SocketOption&lt;?&gt;&gt; options = dchannel.supportedOptions();
<span class="hljs-keyword">for</span>(SocketOption&lt;?&gt; option : options) {
  System.out.println(option);
}
</code></pre>
    <p class="normal">Next, let’s bind the server datagram socket.</p>
    <h3 id="_idParaDest-620" class="heading-3">Binding the server datagram-oriented socket channel</h3>
    <p class="normal">Before listening for connections, the server<a id="_idIndexMarker1530"/> datagram socket channel should be bound to a local address via the <code class="inlineCode">bind()</code> method. Here, we have <em class="italic">localhost</em> (<code class="inlineCode">127.0.0.1</code>) and the arbitrarily chosen port <code class="inlineCode">4444</code>:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">SERVER_PORT</span> <span class="hljs-operator">=</span> <span class="hljs-number">4444</span>;
<span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">SERVER_IP</span> <span class="hljs-operator">=</span> <span class="hljs-string">"127.0.0.1"</span>;
...
dchannel.bind(<span class="hljs-keyword">new</span> <span class="hljs-title">InetSocketAddress</span>(SERVER_IP, SERVER_PORT));
<span class="hljs-comment">// or, if you prefer the wildcard address</span>
dchannel.bind(<span class="hljs-keyword">new</span> <span class="hljs-title">InetSocketAddress</span>(SERVER_PORT));
</code></pre>
    <p class="normal">If we go for <code class="inlineCode">bind(null)</code>, then the local address will be automatically assigned. We can discover the local address<a id="_idIndexMarker1531"/> via the <code class="inlineCode">getLocalAddress()</code> method.</p>
    <h3 id="_idParaDest-621" class="heading-3">Transmitting data packets</h3>
    <p class="normal">The datagram-based echo server<a id="_idIndexMarker1532"/> is almost ready. We can start sending and receiving packets in a connectionless fashion (UDP is a connectionless network protocol). This can be done via <code class="inlineCode">send()</code> and <code class="inlineCode">receive()</code> methods. The <code class="inlineCode">send()</code> method gets the data to be sent as a <code class="inlineCode">ByteBuffer</code> and the remote address and returns the number of bytes sent. The official documentation gives us the best explanation of how it works:</p>
    <p class="normal"><em class="italic">If this channel is in non-blocking mode and there is sufficient room in the underlying output buffer, or if this channel is in blocking mode and sufficient room becomes available, then the remaining bytes in the given buffer are transmitted as a single datagram to the given target address. This method may be invoked at any time. If another thread has already initiated a write operation upon this channel, however, then an invocation of this method will block until the first operation is complete. If this channel’s socket is not bound then this method will first cause the socket to be bound to an address that is assigned automatically, as if by invoking the </em><em class="italic">bind() method with a parameter of null.</em></p>
    <p class="normal">On the other hand, the <code class="inlineCode">receive()</code> method gets the <code class="inlineCode">ByteBuffer</code> where you are expecting to find the received datagram. The datagram’s source address is the return of this method and it can be used to send back an answer packet (if this method returns <code class="inlineCode">null</code>, it means that the channel is in non-blocking mode and no datagram is immediately available). Again, the official documentation gives us the best explanation of how this method will act:</p>
    <p class="normal"><em class="italic">If a datagram is immediately available, or if this channel is in blocking mode and one eventually becomes available, then the datagram is copied into the given byte buffer and its source address is returned. If this channel is in non-blocking mode and a datagram is not immediately available then this method immediately returns null. This method may be invoked at any time. If another thread has already initiated a read operation upon this channel, however, then an invocation of this method will block until the first operation is complete. If this channel’s socket is not bound then this method will first cause the socket to be bound to an address that is assigned automatically, as if by invoking the bind() method with a parameter of null.</em></p>
    <p class="normal">The remote address can be discovered via <code class="inlineCode">getRemoteAddress()</code>.</p>
    <p class="normal">Our blocking echo server listens for packets in an infinite loop. When a packet is available (has arrived on the server), we extract from it the data and the address of the sender (the remote address). We use this address<a id="_idIndexMarker1533"/> to send back the same data (to echo):</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">MAX_SIZE_OF_PACKET</span> <span class="hljs-operator">=</span> <span class="hljs-number">65507</span>;
...
<span class="hljs-type">ByteBuffer</span> <span class="hljs-variable">echoBuffer</span>
  <span class="hljs-operator">=</span> ByteBuffer.allocateDirect(MAX_SIZE_OF_PACKET);
...
<span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) {
  <span class="hljs-type">SocketAddress</span> <span class="hljs-variable">clientSocketAddress</span>
    <span class="hljs-operator">=</span> dchannel.receive(echoBuffer);
  echoBuffer.flip();
  System.out.println(<span class="hljs-string">"Received "</span> + echoBuffer.limit()
    + <span class="hljs-string">" bytes from "</span> + clientSocketAddress.toString() 
    + <span class="hljs-string">"! Echo ..."</span>);
  dchannel.send(echoBuffer, clientSocketAddress);
  echoBuffer.clear();
}
</code></pre>
    <h3 id="_idParaDest-622" class="heading-3">Closing the channel</h3>
    <p class="normal">Disconnecting the datagram<a id="_idIndexMarker1534"/> socket channel can be done via the <code class="inlineCode">close()</code> method as follows:</p>
    <pre class="programlisting code"><code class="hljs-code">dchannel.close();
</code></pre>
    <p class="normal">Typically, you’ll close these resources in a <em class="italic">try-with-resources</em> block.</p>
    <h3 id="_idParaDest-623" class="heading-3">Putting it all together into the client</h3>
    <p class="normal">The source code of our server <a id="_idIndexMarker1535"/>can be obtained by chaining the previous snippets of code and adding some gluing code and comments:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> {
  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">SERVER_PORT</span> <span class="hljs-operator">=</span> <span class="hljs-number">4444</span>;
  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">SERVER_IP</span> <span class="hljs-operator">=</span> <span class="hljs-string">"127.0.0.1"</span>;
  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">MAX_SIZE_OF_PACKET</span> <span class="hljs-operator">=</span> <span class="hljs-number">65507</span>;
  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> {
    <span class="hljs-type">ByteBuffer</span> <span class="hljs-variable">echoBuffer</span>
      <span class="hljs-operator">=</span> ByteBuffer.allocateDirect(MAX_SIZE_OF_PACKET);
    <span class="hljs-comment">// create a datagram channel</span>
    <span class="hljs-keyword">try</span> (<span class="hljs-type">DatagramChannel</span> <span class="hljs-variable">dchannel</span>
      <span class="hljs-operator">=</span> DatagramChannel.open(StandardProtocolFamily.INET)) {
      <span class="hljs-comment">// if the channel was successfully opened</span>
      <span class="hljs-keyword">if</span> (dchannel.isOpen()) {
        System.out.println(<span class="hljs-string">"The echo server is ready!"</span>);
        <span class="hljs-comment">// optionally, configure the server side options</span>
        dchannel.setOption(
          StandardSocketOptions.SO_RCVBUF, <span class="hljs-number">4</span> * <span class="hljs-number">1024</span>);
        dchannel.setOption(
          StandardSocketOptions.SO_SNDBUF, <span class="hljs-number">4</span> * <span class="hljs-number">1024</span>);
        <span class="hljs-comment">// bind the channel to local address</span>
        dchannel.bind(<span class="hljs-keyword">new</span> <span class="hljs-title">InetSocketAddress</span>(
          SERVER_IP, SERVER_PORT));
        System.out.println(<span class="hljs-string">"Echo server available at: "</span> 
          + dchannel.getLocalAddress());
        System.out.println(<span class="hljs-string">"Ready to echo ..."</span>);
        <span class="hljs-comment">// sending data packets</span>
        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) {
          <span class="hljs-type">SocketAddress</span> <span class="hljs-variable">clientSocketAddress</span>
            <span class="hljs-operator">=</span> dchannel.receive(echoBuffer);
          echoBuffer.flip();
          System.out.println(<span class="hljs-string">"Received "</span> + echoBuffer.limit()
            + <span class="hljs-string">" bytes from "</span> + clientSocketAddress.toString() 
            + <span class="hljs-string">"! Echo ..."</span>);
          dchannel.send(echoBuffer, clientSocketAddress);
          echoBuffer.clear();
        }
      } <span class="hljs-keyword">else</span> {
        System.out.println(<span class="hljs-string">"The channel is unavailable!"</span>);
      }
    } <span class="hljs-keyword">catch</span> (SecurityException | IOException ex) {
      System.err.println(ex);
      <span class="hljs-comment">// handle exception</span>
  }
  }
}
</code></pre>
    <p class="normal">Next, let’s focus on writing a client for the echo server.</p>
    <h2 id="_idParaDest-624" class="heading-2">Writing a connectionless UDP client</h2>
    <p class="normal">In implementation terms, writing<a id="_idIndexMarker1536"/> a connectionless UDP client<a id="_idIndexMarker1537"/> is almost the same as writing the server side. We create a <code class="inlineCode">DatagramChannel</code>, set the needed options, and we are ready to go (ready to send/receive data packets). Notice that a datagram client doesn’t need to be bound (but it can be) to a local address because the server can extract the IP/port pair from each data packet – the server knows where the client lives. However, if the server was bound via <code class="inlineCode">bind(null)</code> (so, automatically bound) then the client should know the assigned server IP/port pair (server address). Of course, the reverse is also true: if the server is the first one sending a data packet (in this case, the client should be bound).</p>
    <p class="normal">In our case, the client is aware that the echo server listens on <code class="inlineCode">127.0.0.1</code>/<code class="inlineCode">4444</code>, so it can send the first data packet via the following code:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> {
  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">SERVER_PORT</span> <span class="hljs-operator">=</span> <span class="hljs-number">4444</span>;
  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">SERVER_IP</span> <span class="hljs-operator">=</span> <span class="hljs-string">"127.0.0.1"</span>;
  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">MAX_SIZE_OF_PACKET</span> <span class="hljs-operator">=</span> <span class="hljs-number">65507</span>;
  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> 
        <span class="hljs-keyword">throws</span> InterruptedException {
    CharBuffer cBuffer;
    <span class="hljs-type">Charset</span> <span class="hljs-variable">charset</span> <span class="hljs-operator">=</span> Charset.defaultCharset();
    <span class="hljs-type">CharsetDecoder</span> <span class="hljs-variable">chdecoder</span> <span class="hljs-operator">=</span> charset.newDecoder();
    <span class="hljs-type">ByteBuffer</span> <span class="hljs-variable">bufferToEcho</span> <span class="hljs-operator">=</span> ByteBuffer.wrap(
      <span class="hljs-string">"Echo: I'm a great server!"</span>.getBytes());
    <span class="hljs-type">ByteBuffer</span> <span class="hljs-variable">echoedBuffer</span>
      <span class="hljs-operator">=</span> ByteBuffer.allocateDirect(MAX_SIZE_OF_PACKET);
    <span class="hljs-comment">// create a datagram channel</span>
    <span class="hljs-keyword">try</span> (<span class="hljs-type">DatagramChannel</span> <span class="hljs-variable">dchannel</span>
      <span class="hljs-operator">=</span> DatagramChannel.open(StandardProtocolFamily.INET)) {
      <span class="hljs-comment">// if the channel was successfully opened</span>
      <span class="hljs-keyword">if</span> (dchannel.isOpen()) {
        <span class="hljs-comment">// optionally, configure the client side options</span>
        dchannel.setOption(
          StandardSocketOptions.SO_RCVBUF, <span class="hljs-number">4</span> * <span class="hljs-number">1024</span>);
        dchannel.setOption(
          StandardSocketOptions.SO_SNDBUF, <span class="hljs-number">4</span> * <span class="hljs-number">1024</span>);
        <span class="hljs-comment">// sending data packets</span>
        <span class="hljs-type">int</span> <span class="hljs-variable">sentBytes</span> <span class="hljs-operator">=</span> dchannel.send(bufferToEcho, 
          <span class="hljs-keyword">new</span> <span class="hljs-title">InetSocketAddress</span>(SERVER_IP, SERVER_PORT));
        System.out.println(<span class="hljs-string">"Sent "</span> + sentBytes
          + <span class="hljs-string">" bytes to the server"</span>);
        dchannel.receive(echoedBuffer);
        <span class="hljs-comment">// hack to wait for the server to echo</span>
        Thread.sleep(<span class="hljs-number">5000</span>);
        echoedBuffer.flip();
        cBuffer = chdecoder.decode(echoedBuffer);
        System.out.println(cBuffer.toString());
        echoedBuffer.clear();
      } <span class="hljs-keyword">else</span> {
        System.out.println(<span class="hljs-string">"Cannot open the channel"</span>);
      }
    } <span class="hljs-keyword">catch</span> (SecurityException | IOException ex) { 
      System.err.println(ex);
      <span class="hljs-comment">// handle exception</span>
    }
  }
}
</code></pre>
    <p class="normal">Finally, let’s test our blocking server/client datagram-based application.</p>
    <h2 id="_idParaDest-625" class="heading-2">Testing the UDP connectionless echo application</h2>
    <p class="normal">For testing our application, we start<a id="_idIndexMarker1538"/> the server, which will output these messages:</p>
    <pre class="programlisting con"><code class="hljs-con">The echo server is ready!
Echo server available at: /127.0.0.1:4444
Ready to echo ...
</code></pre>
    <p class="normal">Next, we start the client, which sends the text <em class="italic">Echo: I’m a great server!</em> to the server. The client will output the following:</p>
    <pre class="programlisting con"><code class="hljs-con">Sent 25 bytes to the server
</code></pre>
    <p class="normal">The server will receive this datagram and send it back:</p>
    <pre class="programlisting con"><code class="hljs-con">Received 25 bytes from /127.0.0.1:59111! Echo ...
</code></pre>
    <p class="normal">The client will wait for the server to echo for 5 seconds (arbitrarily chosen timeout). Since the server will echo the received datagram, the client will get it back and print it to the console:</p>
    <pre class="programlisting con"><code class="hljs-con">Echo: I'm a great server!
</code></pre>
    <p class="normal">At this moment, the client is stopped and the server continues to wait for incoming datagrams. So, don’t forget<a id="_idIndexMarker1539"/> to manually stop the server.</p>
    <h2 id="_idParaDest-626" class="heading-2">Writing a connected UDP client</h2>
    <p class="normal">Besides the connectionless<a id="_idIndexMarker1540"/> <code class="inlineCode">send()</code> and <code class="inlineCode">receive()</code> methods, the Java API<a id="_idIndexMarker1541"/> also supports the <code class="inlineCode">read()</code> and <code class="inlineCode">write()</code> methods. These methods work only for a connected UDP client and are based on <code class="inlineCode">ByteBuffer</code> for holding the read/write data. A connected UDP client (in contrast with a connectionless one) relies on a socket channel that allows interactions (sending/receiving datagrams) only with the given remote peer address. The client datagram socket remains connected. It must be explicitly closed.</p>
    <p class="normal">Connecting a UDP client is accomplished via the <code class="inlineCode">connect()</code> method, which takes as arguments the server-side remote address:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">SERVER_PORT</span> <span class="hljs-operator">=</span> <span class="hljs-number">4444</span>;
<span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">SERVER_IP</span> <span class="hljs-operator">=</span> <span class="hljs-string">"127.0.0.1"</span>;
...
dchannel.connect(<span class="hljs-keyword">new</span> <span class="hljs-title">InetSocketAddress</span>(
  SERVER_IP, SERVER_PORT));
</code></pre>
    <p class="normal">Since UDP is a connectionless protocol, the <code class="inlineCode">connect()</code> method doesn’t exchange any data packets with the server across the network. The method returns immediately without actually blocking the application. Mainly, the <code class="inlineCode">connect()</code> method can be called at any time since it doesn’t affect the currently processed read/write operations. Its goal is to bind this socket channel (if it is not) to an automatically assigned address (it’s like calling <code class="inlineCode">bind(null)</code>). </p>
    <p class="normal">The connection status can be obtained via <code class="inlineCode">isConnected()</code>:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">if</span> (dchannel.isConnected()) {
  ...
}
</code></pre>
    <p class="normal">In this context, writing a UDP-connected client for our UDP echo server can be done as follows:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> {
  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">SERVER_PORT</span> <span class="hljs-operator">=</span> <span class="hljs-number">4444</span>;
  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">SERVER_IP</span> <span class="hljs-operator">=</span> <span class="hljs-string">"127.0.0.1"</span>;
  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">MAX_SIZE_OF_PACKET</span> <span class="hljs-operator">=</span> <span class="hljs-number">65507</span>;
  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> {
    <span class="hljs-type">CharBuffer</span> <span class="hljs-variable">cBuffer</span>;
    <span class="hljs-type">Charset</span> <span class="hljs-variable">charset</span> <span class="hljs-operator">=</span> Charset.defaultCharset();
    <span class="hljs-type">CharsetDecoder</span> <span class="hljs-variable">chdecoder</span> <span class="hljs-operator">=</span> charset.newDecoder();
    <span class="hljs-type">ByteBuffer</span> <span class="hljs-variable">bufferToEcho</span> <span class="hljs-operator">=</span> ByteBuffer.wrap(
      <span class="hljs-string">"Echo: I'm a great server!"</span>.getBytes());
    <span class="hljs-type">ByteBuffer</span> <span class="hljs-variable">echoedBuffer</span>
      <span class="hljs-operator">=</span> ByteBuffer.allocateDirect(MAX_SIZE_OF_PACKET);
    <span class="hljs-comment">// create a datagram channel</span>
    <span class="hljs-keyword">try</span> (<span class="hljs-type">DatagramChannel</span> <span class="hljs-variable">dchannel</span>
        <span class="hljs-operator">=</span> DatagramChannel.open(StandardProtocolFamily.INET)) {
      <span class="hljs-comment">// optionally, configure the client side options</span>
      dchannel.setOption(
        StandardSocketOptions.SO_RCVBUF, <span class="hljs-number">4</span> * <span class="hljs-number">1024</span>);
      dchannel.setOption(
        StandardSocketOptions.SO_SNDBUF, <span class="hljs-number">4</span> * <span class="hljs-number">1024</span>);
      <span class="hljs-comment">// if the channel was successfully opened</span>
      <span class="hljs-keyword">if</span> (dchannel.isOpen()) {
        <span class="hljs-comment">// connect to server (remote address)</span>
        dchannel.connect(<span class="hljs-keyword">new</span> <span class="hljs-title">InetSocketAddress</span>(
          SERVER_IP, SERVER_PORT));
        <span class="hljs-comment">// if the channel was successfully connected</span>
        <span class="hljs-keyword">if</span> (dchannel.isConnected()) {
          <span class="hljs-comment">// sending data packets</span>
          <span class="hljs-type">int</span> <span class="hljs-variable">sentBytes</span> <span class="hljs-operator">=</span> dchannel.write(bufferToEcho);
          System.out.println(<span class="hljs-string">"Sent "</span> + sentBytes
            + <span class="hljs-string">" bytes to the server"</span>);
          dchannel.read(echoedBuffer);
          echoedBuffer.flip();
          cBuffer = chdecoder.decode(echoedBuffer);
          System.out.println(cBuffer.toString());
          echoedBuffer.clear();
        } <span class="hljs-keyword">else</span> {
          System.out.println(<span class="hljs-string">"Cannot connect the channel"</span>);
        }
      } <span class="hljs-keyword">else</span> {
        System.out.println(<span class="hljs-string">"Cannot open the channel"</span>);
      }
    } <span class="hljs-keyword">catch</span> (SecurityException | IOException ex) { 
      System.err.println(ex);
      <span class="hljs-comment">// handle exception</span>
    }
  }
}
</code></pre>
    <p class="normal">Testing this client<a id="_idIndexMarker1542"/> is straightforward. First, start<a id="_idIndexMarker1543"/> the server. Second, start the client and check out the console output.</p>
    <h1 id="_idParaDest-627" class="heading-1">264. Introducing multicasting</h1>
    <p class="normal">Multicasting is like a flavor<a id="_idIndexMarker1544"/> of internet broadcasting. We know that a TV station can broadcast (share) its signal from the source to all its subscribers or to everybody in a certain area. The exceptions are represented by the people who don’t have the proper receiver (equipment) or aren’t interested in this TV station.</p>
    <p class="normal">From a computer perspective, the TV station can be considered a source that sends datagrams to a group of listeners/subscribers or simply destination hosts. While point-to-point communication is possible via the <em class="italic">unicast transport service</em>, in multicasting (sending datagrams from a source to multiple destinations in a single call) we have the <em class="italic">multicast transport service</em>. In the case of the <em class="italic">unicast transport service</em>, sending the same data to multiple<a id="_idIndexMarker1545"/> points is possible via the so-called <em class="italic">replicated unicast</em> (practically each point receives a copy of the data).</p>
    <p class="normal">In multicasting terms, the receivers<a id="_idIndexMarker1546"/> of multicasted datagrams are known as a <em class="italic">group</em>. This group is uniquely identified by an IP of class D (224.0.0.0-239.255.255.255). A new client can listen and receive the multicasted datagrams only after it gets connected to the group via the corresponding IP address. There are multiple domains where multicasting is useful such as data-sharing management, conferencing, email groups, advertising, and so on.</p>
    <p class="normal">Java (NIO.2) shapes multicasting via the <code class="inlineCode">MulticastChannel</code> interface (a subinterface of <code class="inlineCode">NetworkChannel</code>), which has a single implementation named <code class="inlineCode">DatagramChannel</code>. This interface exposes two <code class="inlineCode">join()</code> methods as follows:</p>
    <pre class="programlisting code"><code class="hljs-code">MembershipKey <span class="hljs-title">join</span><span class="hljs-params">(InetAddress g, NetworkInterface i)</span> 
  <span class="hljs-keyword">throws</span> IOException
MembershipKey <span class="hljs-title">join</span><span class="hljs-params">(InetAddress g, NetworkInterface i, </span>
<span class="hljs-params">  InetAddress s)</span> <span class="hljs-keyword">throws</span> IOException
</code></pre>
    <p class="normal">A client who wants to join a multicast group must call one of these <code class="inlineCode">join()</code> methods. The first <code class="inlineCode">join()</code> method requires the IP address of the multicasting group and a network interface capable of performing multicasting. The second <code class="inlineCode">join()</code> method has an additional argument (<code class="inlineCode">InetAddress s</code>) for indicating a source address from which group members can begin receiving datagrams. Since membership is <em class="italic">cumulative</em>, we can use multiple sources with the same group and network interface. </p>
    <p class="normal">If a client manages to join a multicasting group, then it gets back a <code class="inlineCode">MembershipKey</code> instance, which acts as a token, useful for performing different actions in that group.</p>
    <div class="note">
      <p class="normal"><strong class="keyWord">Important note</strong></p>
      <p class="normal">A multicast channel can join multiple groups. Moreover, a multicast channel can join the same group on more than one network interface.</p>
    </div>
    <p class="normal">Leaving a multicast <a id="_idIndexMarker1547"/>group can be done at any moment via the <code class="inlineCode">close()</code> method.</p>
    <h2 id="_idParaDest-628" class="heading-2">A brief overview of MembershipKey</h2>
    <p class="normal">The most common actions<a id="_idIndexMarker1548"/> that can be performed by a client of a multicast group via the <code class="inlineCode">MembershipKey</code> instance are as follows:</p>
    <ul>
      <li class="bulletList"><strong class="keyWord">Block/unblock</strong>: By calling the <code class="inlineCode">block()</code> method with a source address, we can block datagrams sent from that source. On the other hand, we can unblock a source via the <code class="inlineCode">unblock()</code> method.</li>
      <li class="bulletList"><strong class="keyWord">Get group</strong>: The <code class="inlineCode">group()</code> method returns the source address (<code class="inlineCode">InetAddress</code>) of the group where the current membership key was created.</li>
      <li class="bulletList"><strong class="keyWord">Get channel</strong>: The <code class="inlineCode">channel()</code> method returns the channel (<code class="inlineCode">MulticastChannel</code>) of the group where the current membership key was created.</li>
      <li class="bulletList"><strong class="keyWord">Get source address</strong>: For a source-specific membership key (receive datagrams only from that source), the <code class="inlineCode">sourceAddress()</code> method returns the source address (<code class="inlineCode">InetAddress</code>).</li>
      <li class="bulletList"><strong class="keyWord">Get network interface</strong>: The network interface of this membership key (<code class="inlineCode">NetworkInterface</code>) is available via <code class="inlineCode">networkInterface()</code>.</li>
      <li class="bulletList"><strong class="keyWord">Check validity</strong>: If a membership key is valid, then the <code class="inlineCode">isValid()</code> method returns <code class="inlineCode">true</code>.</li>
      <li class="bulletList"><strong class="keyWord">Drop</strong>: Dropping membership (no longer receiving datagrams from this group) can be done via the <code class="inlineCode">drop()</code> method. Typically, a membership key becomes valid after creation and remains like this until the <code class="inlineCode">drop()</code> method is called or the channel is closed.</li>
    </ul>
    <p class="normal">Next, let’s talk about network interfaces.</p>
    <h1 id="_idParaDest-629" class="heading-1">265. Exploring network interfaces</h1>
    <p class="normal">In Java, a network interface is represented<a id="_idIndexMarker1549"/> by the <code class="inlineCode">NetworkInterface</code> API. Basically, a network interface is identified by a name and a list of IPs that are assigned to it. Via this information, we can associate a network interface with different network tasks such as a multicast group.</p>
    <p class="normal">The following snippet of code lists all network interfaces that are available on your machine:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> {
  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> 
         <span class="hljs-keyword">throws</span> SocketException {
    <span class="hljs-type">Enumeration</span> <span class="hljs-variable">allNetworkInterfaces</span>
      <span class="hljs-operator">=</span> NetworkInterface.getNetworkInterfaces();
    <span class="hljs-keyword">while</span> (allNetworkInterfaces.hasMoreElements()) {
      <span class="hljs-type">NetworkInterface</span> <span class="hljs-variable">ni</span> <span class="hljs-operator">=</span> (NetworkInterface) 
        allNetworkInterfaces.nextElement();
      System.out.println(<span class="hljs-string">"\nDisplay Name: "</span> 
        + ni.getDisplayName());
      System.out.println(ni.getDisplayName() 
        + <span class="hljs-string">" is up and running ? "</span> + ni.isUp());
      System.out.println(ni.getDisplayName() 
        + <span class="hljs-string">" is multicast capable ? "</span> 
        + ni.supportsMulticast());
      System.out.println(ni.getDisplayName() + <span class="hljs-string">" name: "</span>  
        + ni.getName());
      System.out.println(ni.getDisplayName() 
        + <span class="hljs-string">" is virtual ? "</span> + ni.isVirtual());
      <span class="hljs-type">Enumeration</span> <span class="hljs-variable">ips</span> <span class="hljs-operator">=</span> ni.getInetAddresses();
      <span class="hljs-keyword">if</span> (!ips.hasMoreElements()) {
        System.out.println(<span class="hljs-string">"IP addresses: none"</span>);
      } <span class="hljs-keyword">else</span> {
        System.out.println(<span class="hljs-string">"IP addresses:"</span>);
        <span class="hljs-keyword">while</span> (ips.hasMoreElements()) {
          <span class="hljs-type">InetAddress</span> <span class="hljs-variable">ip</span> <span class="hljs-operator">=</span> (InetAddress) ips.nextElement();
          System.out.println(<span class="hljs-string">"IP: "</span> + ip);
        }
      }
    }
  }
}
</code></pre>
    <p class="normal">For each network interface, we print at the console the display name (this is just a human-readable text that describes the network interface) and the name (this is useful to identify the network interface by name). In addition, we check if the network interface is virtual (if it is practically a subinterface), supports multicast, and is up and running. Running this application on my machine has returned multiple network interfaces, and in the following figure, there is a screenshot<a id="_idIndexMarker1550"/> that shows a network interface that supports multicast (<code class="inlineCode">ethernet_32775</code>):</p>
    <figure class="mediaobject"><img src="../Images/B19655_13_04.png" alt="Figure 13.4.png"/></figure>
    <p class="packt_figref">Figure 13.4: A multicast network interface</p>
    <p class="normal">Next, let’s see how we can use <code class="inlineCode">ethernet_32775</code><em class="italic"> </em>to write a server/client multicast application.</p>
    <h1 id="_idParaDest-630" class="heading-1">266. Writing a UDP multicast server/client application</h1>
    <p class="normal">In <em class="italic">Problem 263</em>, we developed a UDP<a id="_idIndexMarker1551"/> server/client application. So, based on that experience, we can go further and highlight the main aspects that can transform a classical UDP-based application into a multicast one.</p>
    <p class="normal">For instance, let’s assume that we want to write a multicast server that sends to the group (to all members interested in receiving datagrams from this server) a datagram that encapsulates the current date-time on the server. This datagram is sent every 10 seconds.</p>
    <h2 id="_idParaDest-631" class="heading-2">Writing a UDP multicast server</h2>
    <p class="normal">Writing a UDP multicast server starts<a id="_idIndexMarker1552"/> with a new <code class="inlineCode">DatagramChannel</code> instance obtained via the <code class="inlineCode">open()</code> method. Next, we set the <code class="inlineCode">IP_MULTICAST_IF</code> option (used to indicate the multicast network interface) and the <code class="inlineCode">SO_REUSEADDR</code> option (used to allow multiple members to bind to the same address – this should be done before binding the socket):</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> 
  <span class="hljs-variable">MULTICAST_NI_NAME</span> <span class="hljs-operator">=</span> <span class="hljs-string">"ethernet_32775"</span>;
...
<span class="hljs-type">NetworkInterface</span> <span class="hljs-variable">mni</span>
  <span class="hljs-operator">=</span> NetworkInterface.getByName(MULTICAST_NI_NAME);
dchannel.setOption(
  StandardSocketOptions.IP_MULTICAST_IF, mni);
dchannel.setOption(
  StandardSocketOptions.SO_REUSEADDR, <span class="hljs-literal">true</span>);
...
</code></pre>
    <p class="normal">Next, we call the <code class="inlineCode">bind()</code> method to bind the channel’s socket to the local address:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">SERVER_PORT</span> <span class="hljs-operator">=</span> <span class="hljs-number">4444</span>;
...
dchannel.bind(<span class="hljs-keyword">new</span> <span class="hljs-title">InetSocketAddress</span>(SERVER_PORT));
</code></pre>
    <p class="normal">Finally, we need the code for transmitting the datagram containing the date-time of the server. We have arbitrarily chosen <code class="inlineCode">225.4.5.6</code> as the IP address of the multicast group. Gluing everything together results<a id="_idIndexMarker1553"/> in the following server code:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> {
  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">SERVER_PORT</span> <span class="hljs-operator">=</span> <span class="hljs-number">4444</span>;
  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">MULTICAST_GROUP</span> <span class="hljs-operator">=</span> <span class="hljs-string">"225.4.5.6"</span>;
  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">MULTICAST_NI_NAME</span> 
    <span class="hljs-operator">=</span> <span class="hljs-string">"ethernet_32775"</span>;
  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> {
    ByteBufferd tBuffer;
    <span class="hljs-comment">// create a channel</span>
    <span class="hljs-keyword">try</span> (<span class="hljs-type">DatagramChannel</span> <span class="hljs-variable">dchannel</span>
      <span class="hljs-operator">=</span> DatagramChannel.open(StandardProtocolFamily.INET)) {
      <span class="hljs-comment">// if the channel was successfully opened</span>
      <span class="hljs-keyword">if</span> (dchannel.isOpen()) {
        <span class="hljs-comment">// get the multicast network interface</span>
        <span class="hljs-type">NetworkInterface</span> <span class="hljs-variable">mni</span>
          <span class="hljs-operator">=</span> NetworkInterface.getByName(MULTICAST_NI_NAME);
        <span class="hljs-comment">// optionally, configure the server side options</span>
        dchannel.setOption(
          StandardSocketOptions.IP_MULTICAST_IF, mni);
        dchannel.setOption(
          StandardSocketOptions.SO_REUSEADDR, <span class="hljs-literal">true</span>);
        <span class="hljs-comment">// bind the channel to local address</span>
        dchannel.bind(<span class="hljs-keyword">new</span> <span class="hljs-title">InetSocketAddress</span>(SERVER_PORT));
        System.out.println(
          <span class="hljs-string">"Server is ready...sending date-time info soon..."</span>);
        <span class="hljs-comment">// sending datagrams</span>
        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) {
          <span class="hljs-comment">// sleep for 10000 ms (10 seconds)</span>
          <span class="hljs-keyword">try</span> {
            Thread.sleep(<span class="hljs-number">10000</span>);
          } <span class="hljs-keyword">catch</span> (InterruptedException ex) {}
          System.out.println(<span class="hljs-string">"Sending date-time ..."</span>);
          dtBuffer = ByteBuffer.wrap(
            <span class="hljs-keyword">new</span> <span class="hljs-title">Date</span>().toString().getBytes());
          dchannel.send(dtBuffer, <span class="hljs-keyword">new</span> <span class="hljs-title">InetSocketAddress</span>(
            InetAddress.getByName(MULTICAST_GROUP), 
              SERVER_PORT));
            dtBuffer.flip();
          }
      } <span class="hljs-keyword">else</span> {
        System.out.println(<span class="hljs-string">"The channel is unavailable!"</span>);
      }
    } <span class="hljs-keyword">catch</span> (IOException ex) {
      System.err.println(ex);
    }
  }
}
</code></pre>
    <p class="normal">Next, let’s write<a id="_idIndexMarker1554"/> a client interested in receiving datagrams from this server.</p>
    <h2 id="_idParaDest-632" class="heading-2">Writing a UDP multicast client</h2>
    <p class="normal">Writing a UDP multicast client<a id="_idIndexMarker1555"/> is not very different from writing a multicast server. However, there are some differences – for instance, we may want to check via <code class="inlineCode">isMulticastAddress()</code> if the remote address (the address from where we receive datagrams) is a multicast address. Next, a client must join the multicast group, so it must call one of the <code class="inlineCode">join()</code> methods described earlier in <em class="italic">Problem 264</em>. Finally, the implementation should be written to receive datagrams as in the following code:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> {
  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">SERVER_PORT</span> <span class="hljs-operator">=</span> <span class="hljs-number">4444</span>;
  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">MAX_SIZE_OF_PACKET</span> <span class="hljs-operator">=</span> <span class="hljs-number">65507</span>;
  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">MULTICAST_GROUP</span> <span class="hljs-operator">=</span> <span class="hljs-string">"225.4.5.6"</span>;
  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">MULTICAST_NI_NAME</span> 
    <span class="hljs-operator">=</span> <span class="hljs-string">"ethernet_32775"</span>;
  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> {
    CharBuffer cBuffer;
    <span class="hljs-type">Charset</span> <span class="hljs-variable">charset</span> <span class="hljs-operator">=</span> Charset.defaultCharset();
    <span class="hljs-type">CharsetDecoder</span> <span class="hljs-variable">chdecoder</span> <span class="hljs-operator">=</span> charset.newDecoder();
    <span class="hljs-type">ByteBuffer</span> <span class="hljs-variable">dtBuffer</span>
      <span class="hljs-operator">=</span> ByteBuffer.allocateDirect(MAX_SIZE_OF_PACKET);
    <span class="hljs-comment">// create a channel</span>
    <span class="hljs-keyword">try</span> (<span class="hljs-type">DatagramChannel</span> <span class="hljs-variable">dchannel</span>
      <span class="hljs-operator">=</span> DatagramChannel.open(StandardProtocolFamily.INET)) {
      <span class="hljs-type">InetAddress</span> <span class="hljs-variable">multigroup</span> 
        <span class="hljs-operator">=</span> InetAddress.getByName(MULTICAST_GROUP);
      <span class="hljs-comment">// if the group address is multicast</span>
      <span class="hljs-keyword">if</span> (multigroup.isMulticastAddress()) {
        <span class="hljs-comment">// if the channel was successfully open</span>
        <span class="hljs-keyword">if</span> (dchannel.isOpen()) {
          <span class="hljs-comment">// get the multicast network interface</span>
          <span class="hljs-type">NetworkInterface</span> <span class="hljs-variable">mni</span>
            <span class="hljs-operator">=</span> NetworkInterface.getByName(MULTICAST_NI_NAME);
          <span class="hljs-comment">// optionally, configure the client side options</span>
          dchannel.setOption(
            StandardSocketOptions.SO_REUSEADDR, <span class="hljs-literal">true</span>);
          <span class="hljs-comment">// bind the channel to remote address </span>
          dchannel.bind(<span class="hljs-keyword">new</span> <span class="hljs-title">InetSocketAddress</span>(SERVER_PORT));
          <span class="hljs-comment">// join the multicast group and receive datagrams</span>
          MembershipKeymemkey = dchannel.join(
            multigroup, mni);
          <span class="hljs-comment">// wait to receive datagrams</span>
          <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) {
            <span class="hljs-keyword">if</span> (memkey.isValid()) {
              dchannel.receive(dtBuffer);
              dtBuffer.flip();
              cBuffer = chdecoder.decode(dtBuffer);
              System.out.println(cBuffer.toString());
              dtBuffer.clear();
            } <span class="hljs-keyword">else</span> {
                <span class="hljs-keyword">break</span>;
            }
          }
        } <span class="hljs-keyword">else</span> {
          System.out.println(<span class="hljs-string">"The channel is unavailable!"</span>);
        }
      } <span class="hljs-keyword">else</span> {
        System.out.println(<span class="hljs-string">"Not a multicast address!"</span>);
      }
    } <span class="hljs-keyword">catch</span> (IOException ex) {
        System.err.println(ex);
      <span class="hljs-comment">// handle exception</span>
    } 
  }
}
</code></pre>
    <p class="normal">Next, let’s talk<a id="_idIndexMarker1556"/> about blocking/unblocking datagrams.</p>
    <h2 id="_idParaDest-633" class="heading-2">Blocking/unblocking datagrams</h2>
    <p class="normal">As you already know, blocking datagrams<a id="_idIndexMarker1557"/> from a certain multicast group <a id="_idIndexMarker1558"/>can be done via the <code class="inlineCode">block()</code> method, while unblocking via the <code class="inlineCode">unblock()</code> method. Here is a snippet of code that blocks a list of addresses that we don’t like:</p>
    <pre class="programlisting code"><code class="hljs-code">List&lt;InetAddress&gt; dislike = ...;
<span class="hljs-type">DatagramChannel</span> <span class="hljs-variable">datagramChannel</span> <span class="hljs-operator">= </span>...;
<span class="hljs-type">MembershipKey</span> <span class="hljs-variable">memkey</span> <span class="hljs-operator">=</span> datagramChannel
  .join(group, network_interface);
<span class="hljs-keyword">if</span>(!dislike.isEmpty()){
  <span class="hljs-keyword">for</span>(InetAddress source : dislike){
    memkey.block(source);
  }
}
</code></pre>
    <p class="normal">Or, if you have a list of addresses that you like, then you can connect to all of them as follows:</p>
    <pre class="programlisting code"><code class="hljs-code">List&lt;InetAddress&gt; like = ...;
DatagramChannel dchannel = ...;
<span class="hljs-keyword">if</span> (!like.isEmpty()){
  <span class="hljs-keyword">for</span> (InetAddress source : like){
    dchannel.join(group, network_interface, source); 
  }
}
</code></pre>
    <p class="normal">Finally, let’s test our application.</p>
    <h2 id="_idParaDest-634" class="heading-2">Testing the multicasting server/client application</h2>
    <p class="normal">First, start the server and wait until<a id="_idIndexMarker1559"/> you see the following message in the console:</p>
    <pre class="programlisting con"><code class="hljs-con">Server is ready ... sending date-time info soon ...
</code></pre>
    <p class="normal">Then, you can start one or more instances of the client. At every 10 seconds, the server will send a datagram marked by the <em class="italic">Sending date-time ...</em> message:</p>
    <pre class="programlisting con"><code class="hljs-con">Server is ready ... sending date-time info soon ...
Sending date-time ...
Sending date-time ...
Sending date-time ...
</code></pre>
    <p class="normal">Every client that joined this multicast group will receive the datagrams from the server:</p>
    <pre class="programlisting con"><code class="hljs-con">Fri Aug 25 08:17:30 EEST 2023
Fri Aug 25 08:17:40 EEST 2023
Fri Aug 25 08:17:50 EEST 2023
</code></pre>
    <p class="normal">Done! Notice that this application suffers from some shortcomings. For instance, the server and the client are not aware of each other. The server sends datagrams even if no client is listening, and the client may wait for datagrams even if the server is offline. Challenge yourself to address these shortcomings by adding more control to each side. Moreover, feel free to experiment with blocking/non-blocking modes and connectionless/connected features for multicast applications.</p>
    <h1 id="_idParaDest-635" class="heading-1">267. Adding KEM to a TCP server/client application</h1>
    <p class="normal">In this problem, we attempt<a id="_idIndexMarker1560"/> to write a TCP server/client<a id="_idIndexMarker1561"/> application that communicates with each other via encrypted messages. The server side is referred to as the sender<a id="_idIndexMarker1562"/> and the client<a id="_idIndexMarker1563"/> as the receiver.</p>
    <p class="normal">In this context, a sender can encrypt a message using its private key, and the receiver decrypts it using the sender’s public key. In case you didn’t recognize this scenario, then allow me to mention that we are talking about <strong class="keyWord">Authenticated Key Exchange</strong> (<strong class="keyWord">AKE</strong>) within <strong class="keyWord">Public Key Encryption</strong> (<strong class="keyWord">PKE</strong>) or, in short, about encrypting/decrypting <a id="_idIndexMarker1564"/>messages based on the key exchange algorithms.</p>
    <p class="normal">AKE within PKE is a popular choice, but it is not secure. In other words, AKE vulnerabilities can be speculated by quantum computers that are capable of altering most key exchange algorithms. JDK 21 can prevent<a id="_idIndexMarker1565"/> such issues via the newly introduced KEM (<a href="https://en.wikipedia.org/wiki/Key_encapsulation_mechanism"><span class="url">https://en.wikipedia.org/wiki/Key_encapsulation_mechanism</span></a>). This is a final feature delivered as JEP 452.</p>
    <p class="normal">KEM schemes rely on a private-public<a id="_idIndexMarker1566"/> keypair and, additionally, on a common<a id="_idIndexMarker1567"/> secret key. KEM works on the following steps.</p>
    <h2 id="_idParaDest-636" class="heading-2">Generating a public-private keypair by the receiver</h2>
    <p class="normal">The receiver (client) generates a private-public keypair<a id="_idIndexMarker1568"/> via the old-school approach<a id="_idIndexMarker1569"/> known as the <code class="inlineCode">KeyPairGenerator</code> API. The public key is obtained<a id="_idIndexMarker1570"/> via <code class="inlineCode">getPublic()</code> and the private key via <code class="inlineCode">getPrivate()</code>. Here, we generate the keypairs for <strong class="keyWord">Diffie-Hellman</strong> (<strong class="keyWord">DH</strong>) key exchange with <em class="italic">Curve25519</em> as defined in RFC 7748:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> PublicKey publicKey;
<span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> PrivateKey privateKey;
...
<span class="hljs-keyword">static</span> {
  <span class="hljs-keyword">try</span> {
    <span class="hljs-type">KeyPairGenerator</span> <span class="hljs-variable">kpg</span>
      <span class="hljs-operator">=</span> KeyPairGenerator.getInstance(<span class="hljs-string">"X25519"</span>);
    <span class="hljs-type">KeyPair</span> <span class="hljs-variable">kp</span> <span class="hljs-operator">=</span> kpg.generateKeyPair();
    publicKey = kp.getPublic();
    privateKey = kp.getPrivate();
  } <span class="hljs-keyword">catch</span> (NoSuchAlgorithmException ex) {...}
}
</code></pre>
    <p class="normal">For now, we need only the public key.</p>
    <h2 id="_idParaDest-637" class="heading-2">Transmitting the public key to the sender</h2>
    <p class="normal">Next, the receiver sends the previously<a id="_idIndexMarker1571"/> generated public key<a id="_idIndexMarker1572"/> to the sender. This is done via the receiver’s <code class="inlineCode">SocketChannel</code>:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">try</span> (<span class="hljs-type">SocketChannel</span> <span class="hljs-variable">socketChannel</span> <span class="hljs-operator">=</span> SocketChannel.open()) {
  ...
  socketChannel.write(
    ByteBuffer.wrap(publicKey.getEncoded()));
  ...
}
</code></pre>
    <p class="normal">The sender needs<a id="_idIndexMarker1573"/> the receiver’s public<a id="_idIndexMarker1574"/> key to generate a secret key.</p>
    <h2 id="_idParaDest-638" class="heading-2">Generating the common secret key by the sender</h2>
    <p class="normal">First, the sender needs to reconstruct<a id="_idIndexMarker1575"/> the receiver’s <code class="inlineCode">PublicKey</code> instance from the received <code class="inlineCode">byte[]</code> and for this, it can use the <code class="inlineCode">KeyFactory</code> API as follows:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-type">KeyFactory</span> <span class="hljs-variable">kf</span> <span class="hljs-operator">=</span> KeyFactory.getInstance(<span class="hljs-string">"X25519"</span>);
<span class="hljs-type">PublicKey</span> <span class="hljs-variable">publicKeyReceiver</span> = kf.generatePublic(
  <span class="hljs-keyword">new</span> <span class="hljs-title">X509EncodedKeySpec</span>(buffer.array()));
</code></pre>
    <p class="normal">The <code class="inlineCode">buffer.array()</code> represents the <code class="inlineCode">byte[]</code> containing the bytes of the public key. With the <code class="inlineCode">PublicKey</code> in hand, the sender can rely on the KEM scheme to obtain the secret key. It starts by using the <code class="inlineCode">KEM</code> class from JDK 21, which provides the functionality of a KEM:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-type">KEM</span> <span class="hljs-variable">kemSender</span> <span class="hljs-operator">=</span> KEM.getInstance(<span class="hljs-string">"</span><span class="hljs-string">DHKEM"</span>);
</code></pre>
    <p class="normal">The DHKEM built-in algorithm<a id="_idIndexMarker1576"/> is an advanced version of the DH algorithm (<a href="https://en.wikipedia.org/wiki/Diffie%E2%80%93Hellman_key_exchange"><span class="url">https://en.wikipedia.org/wiki/Diffie%E2%80%93Hellman_key_exchange</span></a>).</p>
    <p class="normal">Next, the sender creates an <code class="inlineCode">Encapsulator</code> and calls the <code class="inlineCode">encapsulate()</code> method (known as the key encapsulation function), which <a id="_idIndexMarker1577"/>generates (at each call) a secret key and a key encapsulation message:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> SecretKey secretKeySender;
...
KEM.<span class="hljs-type">Encapsulator</span> <span class="hljs-variable">encorSender</span>
  <span class="hljs-operator">=</span> kemSender.newEncapsulator(publicKeyReceiver);
KEM.Encapsulate dencedSender = encorSender.encapsulate(
  <span class="hljs-number">0</span>, encorSender.secretSize(), <span class="hljs-string">"AES"</span>);
secretKeySender = encedSender.key();
</code></pre>
    <p class="normal">If we call the <code class="inlineCode">encapsulate()</code> method without arguments, then this is equivalent to <code class="inlineCode">encapsulate(0, encorSender.secretSize(), "Generic")</code>. But, as you can see, we preferred the <code class="inlineCode">AES</code> algorithm instead of <code class="inlineCode">Generic</code>.</p>
    <p class="normal">At this moment, the sender has the secret key and the encapsulation message via <code class="inlineCode">encedSender</code>. </p>
    <h2 id="_idParaDest-639" class="heading-2">Sending the encapsulation message to the receiver</h2>
    <p class="normal">Now, the sender will transmit<a id="_idIndexMarker1578"/> the key encapsulation message<a id="_idIndexMarker1579"/> to the receiver via the <code class="inlineCode">encapsulation()</code> method:</p>
    <pre class="programlisting code"><code class="hljs-code">socketChannel.write(ByteBuffer.wrap(
  encedSender.encapsulation()));
</code></pre>
    <p class="normal">The receiver is the only one capable of using their private key to decapsulate the received packet via a new <code class="inlineCode">Decapsulator</code>. Once it does this, the receiver has the secret key:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> SecretKey secretKeyReceiver;
...
<span class="hljs-type">KEM</span> <span class="hljs-variable">kemReceiver</span> <span class="hljs-operator">=</span> KEM.getInstance(<span class="hljs-string">"DHKEM"</span>);
KEM.<span class="hljs-type">Decapsulator</span> <span class="hljs-variable">decReceiver</span>
  <span class="hljs-operator">=</span> kemReceiver.newDecapsulator(privateKey);
secretKeyReceiver = decReceiver.decapsulate(
    buffer.array(), <span class="hljs-number">0</span>, decReceiver.secretSize(), <span class="hljs-string">"AES"</span>);
</code></pre>
    <p class="normal">The secret key of the sender (<code class="inlineCode">secretKeySender</code>) and the secret key of the receiver (<code class="inlineCode">secretKeyReceiver</code>) are identical.</p>
    <h2 id="_idParaDest-640" class="heading-2">Using the secret key to encrypt/decrypt messages</h2>
    <p class="normal">Now, the sender and receiver<a id="_idIndexMarker1580"/> can continue the communication<a id="_idIndexMarker1581"/> by encrypting/decrypting messages using the secret key and the well-known <code class="inlineCode">Cipher</code> API:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-type">Cipher</span> <span class="hljs-variable">cipher</span> <span class="hljs-operator">=</span> Cipher.getInstance(<span class="hljs-string">"..."</span>);
cipher.init(Cipher.ENCRYPT_MODE/DECRYPT_MODE, 
  secretKeyReceiver/secretKeySender);
socketChannel.write(ByteBuffer.wrap(
  cipher.doFinal(<span class="hljs-string">"some message"</span>.getBytes())));
</code></pre>
    <p class="normal">For instance, the receiver can send an encrypted token to the sender:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-type">Cipher</span> <span class="hljs-variable">cipher</span> <span class="hljs-operator">=</span> Cipher.getInstance(<span class="hljs-string">"AES/ECB/NoPadding"</span>);
cipher.init(Cipher.ENCRYPT_MODE, secretKeyReceiver);
socketChannel.write(ByteBuffer.wrap(
  cipher.doFinal(<span class="hljs-string">"My token is: 763"</span>.getBytes()))); 
</code></pre>
    <p class="normal">The sender may generate a password based on this token and send it back to the receiver:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment">// decrypt the token</span>
<span class="hljs-type">Cipher</span> <span class="hljs-variable">cipher</span> <span class="hljs-operator">=</span> Cipher.getInstance(<span class="hljs-string">"AES/ECB/NoPadding"</span>);
cipher.init(Cipher.DECRYPT_MODE, secretKeySender);
<span class="hljs-type">String</span> <span class="hljs-variable">decMessage</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title">String</span>(
  cipher.doFinal(message), Charset.defaultCharset());
<span class="hljs-comment">// generating the password based on token</span>
<span class="hljs-comment">// encrypt the password and send it</span>
cipher.init(Cipher.ENCRYPT_MODE, secretKeySender);
socketChannel.write(ByteBuffer.wrap(cipher.doFinal(
  <span class="hljs-string">"The generated password is: O98S!"</span>.getBytes())));
</code></pre>
    <p class="normal">Finally, the receiver<a id="_idIndexMarker1582"/> decrypts <a id="_idIndexMarker1583"/>the received password. In the bundled code, you can find the complete code.</p>
    <h1 id="_idParaDest-641" class="heading-1">268. Reimplementing the legacy Socket API</h1>
    <p class="normal">The Socket API has been improved<a id="_idIndexMarker1584"/> over time and it is still receiving attention for potential further improvements.</p>
    <p class="normal">Prior to JDK 13, the Socket API (<code class="inlineCode">java.net.ServerSocket</code> and <code class="inlineCode">java.net.Socket</code>) relied on <code class="inlineCode">PlainSocketImpl</code>. Starting with JDK 13 (JEP 353), this API has been replaced by <code class="inlineCode">NioSocketImpl</code>.</p>
    <p class="normal">As its name suggests, <code class="inlineCode">NioSocketImpl</code> is based on the NIO infrastructure. The new implementation doesn’t rely on the thread stack being capable of taking advantage of buffer cache mechanisms. Moreover, sockets can be closed via the <code class="inlineCode">java.lang.ref.Cleaner</code> mechanism, which gives special attention to how socket objects are garbage collected.</p>
    <p class="normal">Starting with JDK 15 (JEP 373, follow-on of JEP 353), the internal Socket API has been reimplemented at <code class="inlineCode">DatagramSocket</code> and <code class="inlineCode">MulticastSocket</code> APIs. The goal was to make these APIs simpler and easier to adapt to work with Project Loom (virtual threads).</p>
    <p class="normal">Whenever you prefer<a id="_idIndexMarker1585"/> to go for the old <code class="inlineCode">PlainSocketImpl</code>, you should run your code with the JVM <code class="inlineCode">-Djdk.net.usePlainSocketImpl=true</code> option.</p>
    <h1 id="_idParaDest-642" class="heading-1">269. Quick overview of SWS</h1>
    <p class="normal">SWS was added in JDK 18 under<a id="_idIndexMarker1586"/> JEP 408 in the <code class="inlineCode">jdk.httpserver</code> module. Basically, SWS is a minimalist implementation of a static file server capable of serving a single directory hierarchy. If the request points to a file, then SWS will serve that file. If the request points to a directory containing an index file, then the index file will be served; otherwise, the directory content will be listed.</p>
    <p class="normal">SWS is very easy to set up and is available as a command-line tool (<code class="inlineCode">jwebserver</code>) and as a suite of programmatic API points (<code class="inlineCode">com.sun.net.httpserver</code>). SWS supports HTTP 1.1 only (not HTTPS or HTTP/2) and it can respond only to the idempotent <code class="inlineCode">HEAD</code> and <code class="inlineCode">GET</code> requests (any other request type will return a 405 or 501 HTTP code).</p>
    <p class="normal">In addition, MIME types are set up automatically by SWS<a id="_idIndexMarker1587"/> and no security mechanism (for instance, OAuth) is available.</p>
    <h2 id="_idParaDest-643" class="heading-2">Key abstractions of SWS</h2>
    <p class="normal">To better understand how SWS works<a id="_idIndexMarker1588"/> behind the scenes, consider the following diagram:</p>
    <figure class="mediaobject"><img src="../Images/B19655_13_05.png" alt="Figure 13.10.png"/></figure>
    <p class="packt_figref">Figure 13.5: SWS key abstractions</p>
    <p class="normal">On the left-hand side, we have a client for SWS (for instance, a browser) that triggers the HTTP requests and gets back HTTP responses. An HTTP request-response cycle is also known as an <em class="italic">exchange</em> – a client triggers <a id="_idIndexMarker1589"/>a request and gets a response in exchange). On the right-hand side, there is an SWS containing the server, and a few <em class="italic">handlers</em> and <em class="italic">filters</em>. The server listens for incoming TCP connections. Next, each HTTP request is delegated to the proper handler (there can be one or more handlers). Here is where the request is practically handled by SWS. Finally, we have some filters. These are optional and they can be executed before processing the request (pre-processing filters) or after processing the request (post-processing filters – for instance, for logging purposes).</p>
    <p class="normal">Going further, an HTTP request flows through SWS as in the following diagram:</p>
    <figure class="mediaobject"><img src="../Images/B19655_13_06.png" alt="Figure 13.11.png"/></figure>
    <p class="packt_figref">Figure 13.6: SWS handlers and filters</p>
    <p class="normal">One of the abstractions used by SWS is <em class="italic">context</em>. A context is a mapping between a root URI part and a handler <code class="inlineCode">(/context/</code>). For instance, the URL <code class="inlineCode">http://localhost:9009/a/file.txt</code> has the context <code class="inlineCode">/a/</code>, which is associated with a certain handler. This way, SWS knows how to dispatch requests to handlers. In other words, SWS inspects the incoming request, extracts the context, and tries to find a handler<a id="_idIndexMarker1590"/> with a matching context. That handler will serve the requested resource (<code class="inlineCode">file.txt</code>). Finally, after the request is handled, a post-processing filter will log the request details.</p>
    <h1 id="_idParaDest-644" class="heading-1">270. Exploring the SWS command-line tool</h1>
    <p class="normal">The only prerequisite for running<a id="_idIndexMarker1591"/> the SWS command-line tool (<code class="inlineCode">jwebserver</code>) is JDK 18 and the following syntax:</p>
    <figure class="mediaobject"><img src="../Images/B19655_13_07.png" alt="Figure 13.5.png"/></figure>
    <p class="packt_figref">Figure 13.7: jwebserver command-line tool syntax</p>
    <p class="normal">The options of <code class="inlineCode">jwebserver</code> are straightforward. Here is a short description of the most useful ones:</p>
    <ul>
      <li class="bulletList"><code class="inlineCode">-b addr</code>: This is the binding address. It defaults to the loopback, <code class="inlineCode">127.0.0.1</code> or <code class="inlineCode">::1</code>. For all interfaces, we can use <code class="inlineCode">-b 0.0.0.0</code> or <code class="inlineCode">-b ::</code>. The <code class="inlineCode">–b addr</code> is similar to<code class="inlineCode">--bind-address addr</code>.</li>
      <li class="bulletList"><code class="inlineCode">-p port</code>: This specifies the port on which the SWS will listen for incoming requests. The default port is <code class="inlineCode">8000</code>. The <code class="inlineCode">–p</code> port option is similar to<code class="inlineCode">--port port</code>.</li>
      <li class="bulletList"><code class="inlineCode">-d dir</code>: The <code class="inlineCode">dir</code> variable points out the directory to be served. The default is the current directory. The <code class="inlineCode">–d dir</code> is similar to<code class="inlineCode">--directory dir</code>.</li>
      <li class="bulletList"><code class="inlineCode">-o level</code>: The <code class="inlineCode">level</code> variable can be <code class="inlineCode">none</code>, <code class="inlineCode">info</code> (default), or <code class="inlineCode">verbose</code> and it specifies the output format. The <code class="inlineCode">–o level</code> is similar to <code class="inlineCode">--output level</code>.</li>
    </ul>
    <p class="normal">You can list all options<a id="_idIndexMarker1592"/> and their description via the <code class="inlineCode">jwebsever –h</code> command. Keeping these options in mind, let’s start an SWS instance.</p>
    <h2 id="_idParaDest-645" class="heading-2">Starting SWS from the command line</h2>
    <p class="normal">Let’s assume that we want<a id="_idIndexMarker1593"/> to serve the files<a id="_idIndexMarker1594"/> from a directory named <code class="inlineCode">docs</code>, which contains a text file and a few image files (you’ll find this folder in the bundled code). For this, we open a command prompt (in Windows) and navigate to the <code class="inlineCode">docs</code> folder. Next, from this folder, we launch the <code class="inlineCode">jwebserver</code> command as in the following figure:</p>
    <figure class="mediaobject"><img src="../Images/B19655_13_08.png" alt="Figure 13.6.png"/></figure>
    <p class="packt_figref">Figure 13.8: Starting SWS via jwebserver command</p>
    <p class="normal">Next, we need to copy the URL displayed on the command prompt into a browser address bar (here, the URL is <code class="inlineCode">http://127.0.0.1:8000/</code>). Since our request points to the current directory (<code class="inlineCode">docs</code>), we get back the listing of this directory in the following figure:</p>
    <figure class="mediaobject"><img src="../Images/B19655_13_09.png" alt="Figure 13.7.png"/></figure>
    <p class="packt_figref">Figure 13.9: SWS serving the current directory listing</p>
    <p class="normal">If we click on <code class="inlineCode">books.txt</code> or on any of the images<a id="_idIndexMarker1595"/> then we will trigger a request<a id="_idIndexMarker1596"/> to a file, so SWS will return the file content and the browser will render it accordingly. </p>
    <p class="normal">Here is a screenshot of clicking on <code class="inlineCode">books.txt</code> and <code class="inlineCode">Java Coding Problems 2nd Edition.png</code>:</p>
    <figure class="mediaobject"><img src="../Images/B19655_13_10.png" alt="Figure 13.8.png"/></figure>
    <p class="packt_figref">Figure 13.10: SWS serving two files (a text file and an image)</p>
    <p class="normal">Meanwhile, SWS has logged<a id="_idIndexMarker1597"/> each of our requests<a id="_idIndexMarker1598"/> in the following image:</p>
    <figure class="mediaobject"><img src="../Images/B19655_13_11.png" alt="Figure 13.9.png"/></figure>
    <p class="packt_figref">Figure 13.11: SWS has logged the GET requests</p>
    <p class="normal">Done! Next, let’s see how we can configure the server.</p>
    <h2 id="_idParaDest-646" class="heading-2">Configuring SWS from the command line</h2>
    <p class="normal">Configuring SWS from the command line<a id="_idIndexMarker1599"/> can be done via the options<a id="_idIndexMarker1600"/> listed earlier. For instance, if we want to change the default port then we use <code class="inlineCode">–p port</code> (or <code class="inlineCode">--port port</code>). In the following example, we use port <code class="inlineCode">9009</code> instead of the default <code class="inlineCode">8000</code>. Moreover, we make our server available only to the address <code class="inlineCode">172.27.128.1</code> via <code class="inlineCode">–b addr</code> (this is an address specific to my machine representing a <em class="italic">Hyper-V virtual Ethernet adapter</em> supporting multicast):</p>
    <pre class="programlisting con"><code class="hljs-con">jwebserver -b 172.27.128.1 -p 9009
</code></pre>
    <p class="normal">This time, we open the browser and point it to <code class="inlineCode">http://172.27.128.1:9009/</code>.</p>
    <p class="normal">Feel free to test other options as well.</p>
    <h2 id="_idParaDest-647" class="heading-2">Stopping SWS from the command line</h2>
    <p class="normal">A SWS instance runs until<a id="_idIndexMarker1601"/> it is explicitly stopped. In Unix/Windows, we can<a id="_idIndexMarker1602"/> stop SWS from the command line by simply typing <em class="keystroke">Ctrl </em>+ <em class="keystroke">C</em>. Sometimes, you have to wait a few seconds until the server is stopped and the command prompt is available for other commands.</p>
    <h1 id="_idParaDest-648" class="heading-1">271. Introducing the com.sun.net.httpserver API</h1>
    <p class="normal">Since 2006, next to the SWS<a id="_idIndexMarker1603"/> command-line tool, we have the programmatic bridge represented by the <code class="inlineCode">com.sun.net.httpserver</code> API. Practically, the goal of this API is to allow us to programmatically launch an SWS instance in a very easy way.</p>
    <p class="normal">First, we have the <code class="inlineCode">SimpleFileServer</code>, which is the main API for creating an SWS instance via three static methods, <code class="inlineCode">createFileServer()</code>, <code class="inlineCode">createFileHandler()</code>, and <code class="inlineCode">createOutputFilter()</code>. We are especially interested in the <code class="inlineCode">createFileServer(InetSocketAddress addr, Path rootDirectory, SimpleFileServer.OutputLevel outputLevel)</code> method. As you can see, via this method, we can create an SWS instance with a given port, root directory (this should be an absolute path), and output level as follows:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-type">HttpServer</span> <span class="hljs-variable">sws</span> = SimpleFileServer.createFileServer(
  <span class="hljs-keyword">new</span> <span class="hljs-title">InetSocketAddress</span>(<span class="hljs-number">9009</span>),
  Path.of(<span class="hljs-string">"./docs"</span>).toAbsolutePath(),
  OutputLevel.VERBOSE);
sws.start();
</code></pre>
    <p class="normal">After running this application, an SWS will be available at <code class="inlineCode">http://localhost:9009/</code>.</p>
    <p class="normal">The default address is the loopback address, so you can also express the <code class="inlineCode">InetSocketAddress</code> as <code class="inlineCode">new InetSocketAddress(InetAddress.getLoopbackAddress(), 9009)</code>. Moreover, we can bind the server after creation via <code class="inlineCode">bind(InetSocketAddress addr, int backlog)</code>.</p>
    <p class="normal">For programmatically starting<a id="_idIndexMarker1604"/> and stopping the SWS instance, we have the <code class="inlineCode">start()</code> and <code class="inlineCode">stop()</code> methods.</p>
    <h2 id="_idParaDest-649" class="heading-2">Using a custom HttpHandler</h2>
    <p class="normal">Another approach for programmatically <a id="_idIndexMarker1605"/>creating a custom SWS instance relies on creating a file handler and passing it to the overloaded <code class="inlineCode">HttpServer.create()</code> method. The file handler can be created as follows:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-type">HttpHandler</span> <span class="hljs-variable">fileHandler</span> <span class="hljs-operator">=</span> SimpleFileServer.createFileHandler(
  Path.of(<span class="hljs-string">"./docs"</span>).toAbsolutePath());
</code></pre>
    <p class="normal">This file handler can be passed to <code class="inlineCode">HttpServer.create(InetSocketAddress addr, int backlog, String path, HttpHandler handler, Filter... filters)</code> next to the port, socket backlog (<em class="italic">maximum number of queued incoming connections to allow on the listening socket</em>), context path, and optional filters as follows:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-type">HttpServer</span> <span class="hljs-variable">sws</span> <span class="hljs-operator">=</span> HttpServer.create(
  <span class="hljs-keyword">new</span> <span class="hljs-title">InetSocketAddress</span>(<span class="hljs-number">9009</span>), <span class="hljs-number">10</span>, <span class="hljs-string">"/mybooks"</span>, fileHandler); 
sws.start();
</code></pre>
    <p class="normal">This time, the server will be available at <code class="inlineCode">http://localhost:9009/mybooks/</code>. If you want to achieve the same thing and still use <code class="inlineCode">createFileServer()</code>, then you need to explicitly set the context and the file handler via <code class="inlineCode">setContext()</code> and <code class="inlineCode">setHandler()</code> after creating an SWS as follows:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Path</span> <span class="hljs-variable">ROOT_DIRECTORY_PATH</span> <span class="hljs-operator">=</span> 
  Path.of(<span class="hljs-string">"./docs"</span>).toAbsolutePath();
...
<span class="hljs-type">HttpHandler</span> <span class="hljs-variable">fileHandler</span>
  <span class="hljs-operator">=</span> SimpleFileServer.createFileHandler(ROOT_DIRECTORY_PATH);
<span class="hljs-type">HttpServer</span> <span class="hljs-variable">sws</span> <span class="hljs-operator">=</span> SimpleFileServer.createFileServer(
  <span class="hljs-keyword">new</span> <span class="hljs-title">InetSocketAddress</span>(<span class="hljs-number">9009</span>),
  ROOT_DIRECTORY_PATH,
  OutputLevel.VERBOSE);
sws.createContext(<span class="hljs-string">"/mybooks"</span>).setHandler(fileHandler);
sws.start();
</code></pre>
    <p class="normal">There is also<a id="_idIndexMarker1606"/> a <code class="inlineCode">createContext(String path, HttpHandler handler)</code>. </p>
    <h2 id="_idParaDest-650" class="heading-2">Using a custom filter</h2>
    <p class="normal">Adding a post-processing filter<a id="_idIndexMarker1607"/> for SWS logging can be done via <code class="inlineCode">createOutputFilter(OutputStream out, OutputLevel outputLevel)</code>. So, we have to specify an output stream and the level of logging.</p>
    <p class="normal">We can have multiple filters (via the filters array, <code class="inlineCode">Filter...</code>), but here we create a single one that sends the log into a text file named <code class="inlineCode">swslog.txt</code>:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-type">HttpHandler</span> <span class="hljs-variable">fileHandler</span> <span class="hljs-operator">=</span> SimpleFileServer.createFileHandler(
  Path.of(<span class="hljs-string">"./docs"</span>).toAbsolutePath());
<span class="hljs-type">Path</span> <span class="hljs-variable">swslog</span> <span class="hljs-operator">=</span> Paths.get(<span class="hljs-string">"swslog.txt"</span>);
<span class="hljs-type">BufferedOutputStream</span> <span class="hljs-variable">output</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> 
  <span class="hljs-title">BufferedOutputStream</span>(Files.newOutputStream(swslog, 
    StandardOpenOption.CREATE, StandardOpenOption.WRITE));
<span class="hljs-type">Filter</span> <span class="hljs-variable">filter</span> <span class="hljs-operator">=</span> SimpleFileServer.createOutputFilter(output, 
  SimpleFileServer.OutputLevel.VERBOSE);
<span class="hljs-type">HttpServer</span> <span class="hljs-variable">sws</span> <span class="hljs-operator">=</span> HttpServer.create(
  <span class="hljs-keyword">new</span> <span class="hljs-title">InetSocketAddress</span>(<span class="hljs-number">9009</span>), <span class="hljs-number">10</span>, <span class="hljs-string">"/mybooks"</span>, 
  fileHandler, filter);
sws.start();
</code></pre>
    <p class="normal">This time, each request<a id="_idIndexMarker1608"/> solved by our SWS will be logged into <code class="inlineCode">swslog.txt</code>.</p>
    <h2 id="_idParaDest-651" class="heading-2">Using a custom executor</h2>
    <p class="normal">By default, all HTTP requests<a id="_idIndexMarker1609"/> of an SWS instance are handled by the thread that was created by the <code class="inlineCode">start()</code> method. But, we can specify any <code class="inlineCode">Executor</code> for handling the HTTP requests via the <code class="inlineCode">setExecutor()</code> method. For instance, we can rely on <code class="inlineCode">newVirtualThreadPerTaskExecutor()</code> as follows:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-type">HttpServer</span> <span class="hljs-variable">sws</span> <span class="hljs-operator">=</span> SimpleFileServer.createFileServer(
  <span class="hljs-keyword">new</span> <span class="hljs-title">InetSocketAddress</span>(<span class="hljs-number">9009</span>),
  Path.of(<span class="hljs-string">"./docs"</span>).toAbsolutePath(),
  OutputLevel.VERBOSE);
    sws.setExecutor(Executors.newVirtualThreadPerTaskExecutor());
  sws.start();
</code></pre>
    <p class="normal">Getting the current <code class="inlineCode">Executor</code> can be done<a id="_idIndexMarker1610"/> via the <code class="inlineCode">getExecutor()</code> method. If no <code class="inlineCode">Executor</code> was previously set, then <code class="inlineCode">getExecutor()</code> returns <code class="inlineCode">null</code>.</p>
    <h1 id="_idParaDest-652" class="heading-1">272. Adapting request/exchange</h1>
    <p class="normal">Adapting a request can be useful <a id="_idIndexMarker1611"/>for testing<a id="_idIndexMarker1612"/> and debugging purposes. Practically, we can adapt the request (<code class="inlineCode">com.sun.net.httpserver.Request</code>) before the handler sees it, so we can modify the initial request and pass the result to the handler. For this, we can rely on the pre-processing <code class="inlineCode">Filter.adaptRequest(String description, UnaryOperator&lt;Request&gt; requestOperator)</code> method. Besides the description, this method gets the effective request state of the exchange as <code class="inlineCode">UnaryOperator&lt;Request&gt;</code>.</p>
    <p class="normal">Here is an example that adds to each request the header <code class="inlineCode">Author</code> next to a post-processing filter that logs the request details to the console:</p>
    <pre class="programlisting code"><code class="hljs-code">HttpHandler fileHandler = ...;
<span class="hljs-type">Filter</span> <span class="hljs-variable">preFilter</span> <span class="hljs-operator">=</span> Filter.adaptRequest(
  <span class="hljs-string">"Add 'Author' header"</span>, r -&gt; r.with(
    <span class="hljs-string">"Author"</span>, List.of(<span class="hljs-string">"Anghel Leonard"</span>)));
<span class="hljs-type">Filter</span> <span class="hljs-variable">postFilter</span> <span class="hljs-operator">=</span> SimpleFileServer.createOutputFilter(
  out, SimpleFileServer.OutputLevel.VERBOSE);
HttpServer sws = HttpServer.create(
  <span class="hljs-keyword">new</span> <span class="hljs-title">InetSocketAddress</span>(<span class="hljs-number">9009</span>), <span class="hljs-number">10</span>, <span class="hljs-string">"/mybooks"</span>, 
    fileHandler, preFilter, postFilter);
sws.start();
</code></pre>
    <p class="normal">We can see that the <code class="inlineCode">Author</code> header<a id="_idIndexMarker1613"/> is added to each request<a id="_idIndexMarker1614"/> directly in the logs. In the following figure, you can see this header among other headers:</p>
    <figure class="mediaobject"><img src="../Images/B19655_13_12.png" alt="Figure 13.12.png"/></figure>
    <p class="packt_figref">Figure 13.12: The Author header was added</p>
    <p class="normal">Besides <code class="inlineCode">adaptRequest()</code>, the <code class="inlineCode">Filter</code> class defines the <code class="inlineCode">beforeHandler(String description, Consumer&lt;HttpExchange&gt; operation)</code> pre-processing filter and the <code class="inlineCode">afterHandler(String description, Consumer&lt;HttpExchange&gt; operation)</code> post-processing filter. In both cases, the <code class="inlineCode">operation</code> argument represents the effective implementation of the filter. As you can see, these filters are acting as hooks for <code class="inlineCode">com.sun.net.httpserver.HttpExchange</code>, which represents an <em class="italic">exchange</em> (an HTTP request and the response in exchange):</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-type">Filter</span> <span class="hljs-variable">preFilter</span> <span class="hljs-operator">=</span> Filter.beforeHandler(<span class="hljs-string">"some description"</span>, 
  exchange -&gt; { 
    <span class="hljs-comment">// do something with the exchange before handler</span>
  });
<span class="hljs-type">Filter</span> <span class="hljs-variable">postFilter</span> <span class="hljs-operator">=</span> Filter.afterHandler(<span class="hljs-string">"some description"</span>, 
  exchange -&gt; { 
    <span class="hljs-comment">// do something with the exchange after handler</span>
  });
</code></pre>
    <p class="normal">Via the <code class="inlineCode">exchange</code> object, we have<a id="_idIndexMarker1615"/> access to request/response<a id="_idIndexMarker1616"/> headers and body.</p>
    <h1 id="_idParaDest-653" class="heading-1">273. Complementing a conditional HttpHandler with another handler</h1>
    <p class="normal">Let’s assume that we want to choose<a id="_idIndexMarker1617"/> between two <code class="inlineCode">HttpHandler</code> instances based<a id="_idIndexMarker1618"/> on a condition. For instance, for all <code class="inlineCode">GET</code> requests, we want to use the following well-known <code class="inlineCode">HttpHandler</code>:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-type">HttpHandler</span> <span class="hljs-variable">fileHandler</span> <span class="hljs-operator">=</span> SimpleFileServer.createFileHandler(
  Path.of(<span class="hljs-string">"./docs"</span>).toAbsolutePath()); 
</code></pre>
    <p class="normal">For all other requests, we want to use an <code class="inlineCode">HttpHandler</code> that always returns the same resource (for instance, the text <em class="italic">No data available</em>). Defining a <code class="inlineCode">HttpHandler</code> that always returns the same code and resource (so, a <em class="italic">canned response</em>) can be done via the <code class="inlineCode">HttpHandlers.of(int statusCode, Headers headers, String body)</code> method as in the following example:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-type">HttpHandler</span> <span class="hljs-variable">complementHandler</span> <span class="hljs-operator">=</span> HttpHandlers.of(<span class="hljs-number">200</span>,   
  Headers.of(<span class="hljs-string">"Content-Type"</span>, <span class="hljs-string">"text/plain"</span>), 
    <span class="hljs-string">"No data available"</span>);
</code></pre>
    <p class="normal">In addition, the <code class="inlineCode">HttpHandler</code> class exposes a method that can decide between two <code class="inlineCode">HttpHandler</code> instances based on a condition. This method is <code class="inlineCode">handleOrElse(Predicate&lt;Request&gt; handlerTest, HttpHandler handler, HttpHandler fallbackHandler)</code>. As you can see, the condition is expressed as <code class="inlineCode">Predicate&lt;Request&gt;</code>, so in our case, we can write it as follows:</p>
    <pre class="programlisting code"><code class="hljs-code">Predicate&lt;Request&gt; predicate = request -&gt;
  request.getRequestMethod().equalsIgnoreCase(<span class="hljs-string">"GET"</span>);
</code></pre>
    <p class="normal">Next, all we have to do is to pass this <code class="inlineCode">Predicate&lt;Request&gt;</code> and the two handlers to the <code class="inlineCode">handleOrElse()</code> method:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-type">HttpHandler</span> <span class="hljs-variable">handler</span> <span class="hljs-operator">=</span> HttpHandlers.handleOrElse(
  predicate, fileHandler, complementHandler);
</code></pre>
    <p class="normal">If <code class="inlineCode">predicate</code> is evaluated to <code class="inlineCode">true</code> (so, an HTTP <code class="inlineCode">GET</code> request was received), then <code class="inlineCode">fileHandler</code> will be used; otherwise, <code class="inlineCode">complementHandler</code> will be used. Finally, we create and start an SWS instance as follows:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-type">HttpServer</span> <span class="hljs-variable">sws</span> <span class="hljs-operator">=</span> HttpServer.create(
  <span class="hljs-keyword">new</span> <span class="hljs-title">InetSocketAddress</span>(<span class="hljs-number">9009</span>), <span class="hljs-number">10</span>, <span class="hljs-string">"/mybooks"</span>, handler); 
sws.start();
</code></pre>
    <p class="normal">Notice that<a id="_idIndexMarker1619"/> the <a id="_idIndexMarker1620"/>passed <code class="inlineCode">HttpHandler</code> is <code class="inlineCode">handler</code>.</p>
    <h1 id="_idParaDest-654" class="heading-1">274. Implementing SWS for an in-memory file system</h1>
    <p class="normal">We already know that SWS can serve files<a id="_idIndexMarker1621"/> from the default local<a id="_idIndexMarker1622"/> file system. While this file system fits many scenarios, there are also use cases (for instance, testing scenarios) where it will be more practical to mock a directory structure in order to simulate certain expectations. In such scenarios, an in-memory file system will be more suitable than the local file system since we can avoid the creation/deletion of resources and we can use different platforms.</p>
    <p class="normal">An in-memory file system implementation for Java 8 (based on the <code class="inlineCode">java.nio.file</code> API) is provided by the Google project named <em class="italic">Jimfs</em> (<a href="https://github.com/google/jimfs"><span class="url">https://github.com/google/jimfs</span></a>). By following the instructions from the GitHub example, we wrote the following code for a simple in-memory file system:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Path <span class="hljs-title">inMemoryDirectory</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException {
  <span class="hljs-type">FileSystem</span> <span class="hljs-variable">fileSystem</span>
    <span class="hljs-operator">=</span> Jimfs.newFileSystem(Configuration.forCurrentPlatform());
  <span class="hljs-type">Path</span> <span class="hljs-variable">docs</span> <span class="hljs-operator">=</span> fileSystem.getPath(<span class="hljs-string">"docs"</span>);
  Files.createDirectory(docs);
  <span class="hljs-type">Path</span> <span class="hljs-variable">books</span> <span class="hljs-operator">=</span> docs.resolve(<span class="hljs-string">"books.txt"</span>); <span class="hljs-comment">// /docs/books.txt</span>
  Files.write(books, ImmutableList.of(
    <span class="hljs-string">"Java Coding Problems 1st Edition"</span>,
    <span class="hljs-string">"Java Coding Problems 2nd Edition"</span>,
    <span class="hljs-string">"jOOQ Masterclass"</span>,
    <span class="hljs-string">"The Complete Coding Interview Guide in Java"</span>),
    StandardCharsets.UTF_8);
  <span class="hljs-keyword">return</span> docs.toAbsolutePath();
}
</code></pre>
    <p class="normal">The path returned by the previous code is <code class="inlineCode">/docs/books.txt</code> (you can easily create any kind of directory/files hierarchy). Since the SWS file handler supports any kind of path’s file system that implements the <code class="inlineCode">java.nio.file</code> API, we should be able to start an SWS instance for the in-memory path returned via <code class="inlineCode">inMemoryDirectory()</code> as follows:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-type">HttpServer</span> <span class="hljs-variable">sws</span> <span class="hljs-operator">=</span> SimpleFileServer.createFileServer(
  <span class="hljs-keyword">new</span> <span class="hljs-title">InetSocketAddress</span>(<span class="hljs-number">9009</span>), inMemoryDirectory(),
  OutputLevel.VERBOSE);
sws.start();
</code></pre>
    <p class="normal">For testing, point <a id="_idIndexMarker1623"/> the browser<a id="_idIndexMarker1624"/> to <code class="inlineCode">http://localhost:9009</code>.</p>
    <h1 id="_idParaDest-655" class="heading-1">275. Implementing SWS for a zip file system</h1>
    <p class="normal">Using a ZIP file system can<a id="_idIndexMarker1625"/> also be a common<a id="_idIndexMarker1626"/> use case for SWS. The following snippet of code creates a ZIP file system via the <code class="inlineCode">java.nio.file</code> API and returns the corresponding path:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Path <span class="hljs-title">zipFileSystem</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException {
  Map&lt;String, String&gt; env = <span class="hljs-keyword">new</span> <span class="hljs-title">HashMap</span>&lt;&gt;();
  env.put(<span class="hljs-string">"create"</span>, <span class="hljs-string">"true"</span>);
  <span class="hljs-type">Path</span> <span class="hljs-variable">root</span> <span class="hljs-operator">=</span> Path.of(<span class="hljs-string">"./zips"</span>).toAbsolutePath();
  <span class="hljs-type">Path</span> <span class="hljs-variable">zipPath</span> <span class="hljs-operator">=</span> root.resolve(<span class="hljs-string">"docs.zip"</span>)
    .toAbsolutePath().normalize();
<span class="hljs-type">  FileSystem</span> <span class="hljs-variable">zipfs</span> <span class="hljs-operator">=</span> FileSystems.newFileSystem(zipPath, env);
  <span class="hljs-type">Path</span> <span class="hljs-variable">externalTxtFile</span> <span class="hljs-operator">=</span> Paths.get(<span class="hljs-string">"./docs/books.txt"</span>);
  <span class="hljs-type">Path</span> <span class="hljs-variable">pathInZipfile</span> <span class="hljs-operator">=</span> zipfs.getPath(<span class="hljs-string">"/bookszipped.txt"</span>);
  <span class="hljs-comment">// copy a file into the zip file</span>
  Files.copy(externalTxtFile, pathInZipfile,
             StandardCopyOption.REPLACE_EXISTING);
  <span class="hljs-keyword">return</span> zipfs.getPath(<span class="hljs-string">"</span><span class="hljs-string">/"</span>);
}
</code></pre>
    <p class="normal">The result is an archive named <code class="inlineCode">docs.zip</code> with a single file named <code class="inlineCode">bookszipped.txt</code>—this file was copied into the archive from the external <code class="inlineCode">/docs</code> folder where it is stored under the name <code class="inlineCode">books.txt</code>.</p>
    <p class="normal">Next, we can write our SWS instance as follows:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-type">HttpServer</span> <span class="hljs-variable">sws</span> <span class="hljs-operator">=</span> SimpleFileServer.createFileServer(
  <span class="hljs-keyword">new</span> <span class="hljs-title">InetSocketAddress</span>(<span class="hljs-number">9009</span>), zipFileSystem(),
  OutputLevel.VERBOSE);
sws.start();
</code></pre>
    <p class="normal">After starting the SWS<a id="_idIndexMarker1627"/> instance, just point the browser<a id="_idIndexMarker1628"/> to the <code class="inlineCode">http://localhost:9009/bookszipped.txt</code> URL and you should see the content of the text file.</p>
    <h1 id="_idParaDest-656" class="heading-1">276. Implementing SWS for a Java runtime directory</h1>
    <p class="normal">Starting with JDK 9 (JEP 220), the runtime<a id="_idIndexMarker1629"/> images have been restructured<a id="_idIndexMarker1630"/> to support modules and become more performant and secure. Moreover, naming stored modules, classes, and resources has received a new URI scheme (<code class="inlineCode">jrt</code>). Via the <code class="inlineCode">jrt</code> scheme, we can reference modules, classes, and resources contained in runtime images without touching the internal structure of the image. A <code class="inlineCode">jrt</code> URL looks as follows:</p>
    <pre class="programlisting code"><code class="hljs-code">jrt:/[$MODULE[/$PATH]]
</code></pre>
    <p class="normal">Here, <code class="inlineCode">$MODULE</code> is a module name (optional) and <code class="inlineCode">$PATH</code> (optional) represents the path to a certain class/resource file within that module. For instance, to point out the <code class="inlineCode">File</code> class, we write the following URL:</p>
    <pre class="programlisting code"><code class="hljs-code">jrt:/java.base/java/io/File.class
</code></pre>
    <p class="normal">In the <code class="inlineCode">jrt</code> file system, there is a top-level <code class="inlineCode">modules</code> directory that contains one subdirectory for each module in the image. So, we can fetch the proper path for SWS as follows:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Path <span class="hljs-title">jrtFileSystem</span><span class="hljs-params">()</span> {
  <span class="hljs-type">URI</span> <span class="hljs-variable">uri</span> <span class="hljs-operator">=</span> URI.create(<span class="hljs-string">"jrt:/"</span>);
  <span class="hljs-type">FileSystem</span> <span class="hljs-variable">jrtfs</span> <span class="hljs-operator">=</span> FileSystems.getFileSystem(uri);
  <span class="hljs-type">Path</span> <span class="hljs-variable">jrtRoot</span> <span class="hljs-operator">=</span> jrtfs.getPath(<span class="hljs-string">"modules"</span>).toAbsolutePath();
  <span class="hljs-keyword">return</span> jrtRoot;
}
</code></pre>
    <p class="normal">Next, SWS can serve the <code class="inlineCode">modules</code> directory of the given runtime image as follows:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-type">HttpServer</span> <span class="hljs-variable">sws</span> <span class="hljs-operator">=</span> SimpleFileServer.createFileServer(
  <span class="hljs-keyword">new</span> <span class="hljs-title">InetSocketAddress</span>(<span class="hljs-number">9009</span>), jrtFileSystem(),
  OutputLevel.VERBOSE);
sws.start();
</code></pre>
    <p class="normal">Finally, start SWS and point out the URL to a class/resource. For instance, the <code class="inlineCode">http://localhost:9009/java.base/java/io/File.class</code> URL will download<a id="_idIndexMarker1631"/> the <code class="inlineCode">File.class</code> for local<a id="_idIndexMarker1632"/> inspection.</p>
    <h1 id="_idParaDest-657" class="heading-1">Summary</h1>
    <p class="normal">This chapter covered 19 problems with Socket API and SWS. In the first part of this chapter, we covered NIO.2 features dedicated to TCP/UDP server/client applications. In the second part, we covered JDK 18 SWS as a command-line tool and as a suite of API points.</p>
    <h1 class="heading-1">Leave a review!</h1>
    <p class="normal">Enjoyed this book? Help readers like you by leaving an Amazon review. Scan the QR code below for a 20% discount code.</p>
    <p class="normal"><img src="../Images/Leave_Reivew_QR.png" style="width:10em;" alt="" role="presentation"/></p>
    <p class="normal" style="font-size:0.75em;"><em class="italic">*Limited Offer</em></p>
  </div>
</body></html>