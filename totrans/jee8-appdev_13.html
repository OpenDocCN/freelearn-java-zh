<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Servlet Development and Deployment</h1>
                </header>
            
            <article>
                
<p>In this chapter, we will discuss how to develop and deploy Java servlets. Servlets allow us, as application developers, to implement server-side logic in Java web and enterprise applications.</p>
<p>Some of the topics covered include:</p>
<ul>
<li>An explanation of what servlets are</li>
<li>Developing, configuring, packaging, and deploying our first servlet</li>
<li>HTML form processing</li>
<li>Forwarding HTTP requests</li>
<li>Redirecting HTTP responses</li>
<li>Persisting data across HTTP requests</li>
<li>Initializing servlets via annotations</li>
<li>Servlet filters</li>
<li>Servlet listeners</li>
<li>Servlet pluggability</li>
<li>Configuring web applications programmatically</li>
<li>Asynchronous processing</li>
<li>HTTP/2 server push support</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">What is a servlet?</h1>
                </header>
            
            <article>
                
<p>A servlet is a Java class used to extend the capabilities of servers that host server-side web applications. Servlets can respond to requests and generate responses. The base class for all servlets is <kbd>javax.servlet.GenericServlet</kbd>, defines a generic, protocol-independent servlet.</p>
<p>By far the most common type of servlet is an HTTP servlet. This type of servlet is used for handling HTTP requests and generating HTTP responses. An HTTP servlet is a class that extends the <kbd>javax.servlet.http.HttpServlet</kbd> class, which is a subclass of <kbd>javax.servlet.GenericServlet</kbd>.</p>
<p><span class="NormalPACKTChar">A servlet must implement one or more methods to respond to specific HTTP requests. These methods are overridden from the parent</span> <kbd>HttpServlet</kbd> class. As can be seen in the following table, these methods are named in such a way that knowing which one to use is intuitive:</p>
<table class="table">
<tbody>
<tr>
<td>
<p><strong>HTTP request</strong></p>
</td>
<td>
<p><strong>HttpServlet method</strong></p>
</td>
</tr>
<tr>
<td>
<p><kbd>GET</kbd></p>
</td>
<td>
<p><kbd>doGet</kbd>(<kbd>HttpServletRequest</kbd> request, <kbd>HttpServletResponse</kbd> response)</p>
</td>
</tr>
<tr>
<td>
<p><kbd>POST</kbd></p>
</td>
<td>
<p><kbd>doPost</kbd>(<kbd>HttpServletRequest</kbd> request, <kbd>HttpServletResponse</kbd> response)</p>
</td>
</tr>
<tr>
<td>
<p><kbd>PUT</kbd></p>
</td>
<td>
<p><kbd>doPut</kbd>(<kbd>HttpServletRequest</kbd> request, <kbd>HttpServletResponse</kbd> response)</p>
</td>
</tr>
<tr>
<td>
<p><kbd>DELETE</kbd></p>
</td>
<td>
<p><kbd>doDelete</kbd>(<kbd>HttpServletRequest</kbd> request, <kbd>HttpServletResponse</kbd> response)</p>
</td>
</tr>
</tbody>
</table>
<p>Â </p>
<p>Each of these methods takes the same two parameters, namely an instance of a class implementing the <kbd>javax.servlet.http.HttpServletRequest</kbd> <span class="InformationBoxPACKTChar">interface and an instance of a class implementing</span> <kbd>javax.servlet.http.HttpServletResponse</kbd><span class="InformationBoxPACKTChar">. These interfaces will be covered in detail later in this chapter.</span></p>
<div class="packt_infobox"><span class="InformationBoxPACKTChar">Application developers never call the preceding methods directly, they are called automatically by the application server whenever it receives the corresponding HTTP request.</span></div>
<p><span class="InformationBoxPACKTChar">Of the four methods listed previously,</span> <kbd>doGet()</kbd> <span class="InformationBoxPACKTChar">and</span> <kbd>doPost()</kbd> <span class="InformationBoxPACKTChar">are, by far, the most commonly used.</span></p>
<p><span class="InformationBoxPACKTChar">An HTTP <kbd>GET</kbd> request is generated whenever a user types the servlet's URL in the browser, when a user clicks on a link pointing to the servlet's URL, or when a user submits an HTML form using the <kbd>GET</kbd> method where the form's action points to the servlet's URL. In any of these cases, the code inside the servlet's</span> <kbd>doGet()</kbd> <span class="InformationBoxPACKTChar">method gets executed.</span></p>
<p><span class="InformationBoxPACKTChar">An HTTP <kbd>POST</kbd> request is typically generated when a user submits an HTML form using the <kbd>POST</kbd> method and an action pointing to the servlet's URL. In this case, the servlet's code inside the</span> <kbd>doPost()</kbd> <span class="InformationBoxPACKTChar">method gets executed.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Writing our first servlet</h1>
                </header>
            
            <article>
                
<p><span class="InformationBoxPACKTChar">In this section, we will develop a simple servlet to illustrate how to use the servlet API. The code for our servlet is as follows:</span></p>
<pre style="padding-left: 60px">package net.ensode.javaee8book.simpleapp; 
 
import java.io.IOException; 
import java.io.PrintWriter; 
 
import javax.servlet.http.HttpServlet; 
import javax.servlet.http.HttpServletRequest; 
import javax.servlet.http.HttpServletResponse; 
 
<strong>@WebServlet(urlPatterns = {"/simpleservlet"})</strong> 
public class SimpleServlet extends HttpServlet { 
 
    @Override 
    protected void doGet(HttpServletRequest req,    <br/>     HttpServletResponse res) { 
        try { 
            res.setContentType("text/html"); 
            PrintWriter printWriter = res.getWriter(); 
            printWriter.println("&lt;h2&gt;"); 
            printWriter 
                    .println("Hello servlet world!"); 
            printWriter.println("&lt;/h2&gt;"); 
        } catch (IOException ioException) { 
            ioException.printStackTrace(); 
        } 
    } 
} </pre>
<p>The <kbd>@WebServlet</kbd> annotation specifies that our class is a servlet; its <kbd>urlPatterns</kbd> attribute specifies the relative URL of our servlet.</p>
<div class="packt_infobox">Servlets can also be configured via a <kbd>web.xml</kbd> deployment descriptor; however, since Java EE 6 annotation-based configuration is preferred.</div>
<p><span class="InformationBoxPACKTChar">Since this servlet is meant to execute when a user enters its URL in the browser window, we need to override the</span> <kbd>doGet()</kbd> <span class="InformationBoxPACKTChar">method from the parent</span> <kbd>HttpServlet</kbd> <span class="InformationBoxPACKTChar">class. Like we explained previously, this method takes two parameters, an instance of a class implementing the</span> <kbd>javax.servlet.http.HttpServletRequest</kbd> <span class="InformationBoxPACKTChar">interface, and an instance of a class implementing the</span> <kbd>javax.servlet.http.HttpServletResponse</kbd> <span class="InformationBoxPACKTChar">interface.</span></p>
<div class="packt_infobox"><span class="InformationBoxPACKTChar">Even though</span> <kbd>HttpServletRequest</kbd> <span class="InformationBoxPACKTChar">and</span> <kbd>HttpServletResponse</kbd> <span class="InformationBoxPACKTChar">are interfaces, application developers don't typically write classes implementing them. When control goes to a servlet from an HTTP request, the application server provides objects implementing these interfaces.</span></div>
<p><span class="InformationBoxPACKTChar">The first thing our</span> <kbd>doGet()</kbd> <span class="InformationBoxPACKTChar">method does is to set the content type for the</span> <kbd>HttpServletResponse</kbd> <span class="InformationBoxPACKTChar">object to <kbd>"text/html"</kbd>. If we forget to do this, the default content type used is <kbd>"text/plain"</kbd>, which means HTML tags will be displayed on the page, as opposed to being interpreted by the browser.</span></p>
<p><span class="InformationBoxPACKTChar">Then we obtain an instance of</span> <kbd>java.io.PrintWriter</kbd> <span class="InformationBoxPACKTChar">by calling the</span> <kbd>HttpServletResponse.getWriter()</kbd> <span class="InformationBoxPACKTChar">method. We can then send text output to the browser by calling the</span> <kbd>PrintWriter.print()</kbd> <span class="InformationBoxPACKTChar">and</span> <kbd>PrintWriter.println()</kbd> <span class="InformationBoxPACKTChar">methods (the previous example uses</span> <kbd>println()</kbd> <span class="InformationBoxPACKTChar">exclusively). Since we set the content type to <kbd>"text/html"</kbd>, any HTML tags are interpreted pr</span>operl<span class="InformationBoxPACKTChar">y by the browser.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Testing the web application</h1>
                </header>
            
            <article>
                
<p>To verify that the servlet has been properly deployed, we need to point our browser to our application's URL, for example, <kbd><span class="InternetLink0">http://localhost:8080/simpleapp/simpleservlet</span></kbd>. After doing so, we should see a page like the one shown in the following screenshot:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img class=" image-border" src="assets/d82ab2cd-8846-411f-ab15-65eff3f119a0.png" style="width:30.42em;height:20.83em;"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Processing HTML forms</h1>
                </header>
            
            <article>
                
<p><span class="NormalPACKTChar">Servlets are rarely accessed by typing their URL directly into the browser. The most common use for servlets is to process data entered by users in an HTML form. In this section, we illustrate this process.</span></p>
<p><span class="NormalPACKTChar">The HTML file containing the form for our application looks like this:</span></p>
<pre style="padding-left: 60px">&lt;!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd"&gt; 
&lt;html&gt; 
    &lt;head&gt; 
        &lt;meta http-equiv="Content-Type" content="text/html; charset=UTF-8"&gt; 
        &lt;title&gt;Data Entry Page&lt;/title&gt; 
    &lt;/head&gt; 
    &lt;body&gt; 
<strong>        &lt;form method="post" action="formhandlerservlet"&gt;</strong> 
            &lt;table cellpadding="0" cellspacing="0" border="0"&gt; 
                &lt;tr&gt; 
                    &lt;td&gt;Please enter some text:&lt;/td&gt; 
                    &lt;td&gt;<br/>                     &lt;input type="text" name="enteredValue" /&gt;<br/>                    &lt;/td&gt;
                &lt;/tr&gt; 
                &lt;tr&gt; 
                    &lt;td&gt;&lt;/td&gt; 
<strong>                    &lt;td&gt;&lt;input type="submit" value="Submit"&gt;&lt;/td&gt;</strong> 
                &lt;/tr&gt; 
            &lt;/table&gt; 
        &lt;/form&gt; 
    &lt;/body&gt; 
&lt;/html&gt; </pre>
<p><span class="NormalPACKTChar">The value for the form's</span> <kbd>action</kbd> <span class="NormalPACKTChar">attribute must match the value of the servlet's</span> <kbd>urlPatterns</kbd> <span class="NormalPACKTChar">attribute in its</span> <kbd>@WebServlet</kbd> <span class="NormalPACKTChar">annotation. Since the value of the form's</span> <kbd>method</kbd> <span class="NormalPACKTChar">attribute is</span> <kbd>"post"</kbd><span class="NormalPACKTChar">, our servlet's</span> <kbd>doPost()</kbd> <span class="NormalPACKTChar">method will be executed when the form is submitted.</span></p>
<p><span class="NormalPACKTChar">Now let's take a look at our servlet's code:</span></p>
<pre style="padding-left: 60px">package net.ensode.javaee8book.formhandling; 
 
import java.io.IOException; 
import java.io.PrintWriter; 
import javax.servlet.annotation.WebServlet; 
 
import javax.servlet.http.HttpServlet; 
import javax.servlet.http.HttpServletRequest; 
import javax.servlet.http.HttpServletResponse; 
 
<strong>@WebServlet(urlPatterns = {"/formhandlerservlet"})</strong> 
public class FormHandlerServlet extends HttpServlet { 
 
    @Override 
    protected void doPost(HttpServletRequest request,   <br/>     HttpServletResponse response) { 
        String enteredValue; 
 
<strong>        enteredValue = request.getParameter("enteredValue");</strong> 
 
        response.setContentType("text/html"); 
 
        PrintWriter printWriter; 
        try { 
            printWriter = response.getWriter(); 
 
            printWriter.println("&lt;p&gt;"); 
            printWriter.print("You entered: "); 
<strong>            printWriter.print(enteredValue);</strong> 
            printWriter.print("&lt;/p&gt;"); 
        } catch (IOException e) { 
            e.printStackTrace(); 
        } 
    } 
} </pre>
<p><span class="NormalPACKTChar">As can be seen in this example, we obtain a reference to the value the user typed by calling the</span> <kbd>request.getParameter()</kbd> <span class="NormalPACKTChar">method. This method takes a single</span> <kbd>String</kbd> <span class="NormalPACKTChar">object as its sole parameter, and the value of this string must match the name of the input field in the HTML file. In this case, the HTML file has a text field named <kbd>"enteredValue"</kbd>:</span></p>
<pre>    <strong>&lt;input type="text" name="enteredValue" /&gt;</strong></pre>
<p><span class="NormalPACKTChar">Therefore the servlet has a corresponding line:</span></p>
<pre>    <strong>enteredValue = request.getParameter("enteredValue");</strong></pre>
<p><span class="NormalPACKTChar">This line is used to obtain the text entered by the user and store it in the <kbd>String</kbd> variable named</span> <kbd>enteredValue</kbd> <span class="NormalPACKTChar">(the name of the variable does not need to match the input field name, but naming it that way is good practice; it makes it easy to remember what value the variable is holding).</span></p>
<p><span class="NormalPACKTChar">After packaging the preceding three files in a WAR file called</span> <kbd>formhandling.war</kbd>, <span class="NormalPACKTChar">then deploying the WAR file, we can see the rendered</span> <span class="NormalPACKTChar">HTML file by entering a URL similar to the following in the browser (the exact URL will depend on the Java EE application server being used):</span> <kbd><span class="InternetLink0">http://localhost:8080/formhandling</span></kbd> <span class="NormalPACKTChar">.</span></p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img class=" image-border" src="assets/317765a7-0c8a-4aa1-9420-5612c01bfca5.png" style="width:28.50em;height:15.50em;"/></div>
<p><span class="NormalPACKTChar">After the user enters</span> <span class="packt_screen">some text</span> <span class="NormalPACKTChar">in the text field and submits the form (either by hitting "Enter" or clicking on the</span> <span class="packt_screen">S</span><span class="packt_screen">ubmit</span> <span class="NormalPACKTChar">button), we should see the output of the servlet:</span></p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img class=" image-border" src="assets/6e68644c-775c-4b45-895d-5a4c8cc88f61.png" style="width:27.75em;height:14.42em;"/></div>
<p><span class="NormalPACKTChar">The</span> <kbd>HttpServletRequest.getParameter()</kbd> <span class="NormalPACKTChar">method can be used to obtain the value of any HTML input field that can only return one value (text boxes, text areas, single selects, radio buttons, hidden fields, and so on). The procedure to obtain any of these fields' values is identical; in other words, the servlet doesn't care if the user typed in the value in a text field, selected it from a set of radio buttons, and so on. As long as the input field's name matches the value passed to the</span> <kbd>getParameter()</kbd> <span class="NormalPACKTChar">method, the previous code will work.</span></p>
<div class="packt_infobox"><span class="NormalPACKTChar">When dealing with radio buttons, all related radio buttons must have the same name. Calling the</span> <kbd>HttpServletRequest.getParameter()</kbd> <span class="NormalPACKTChar">method and passing the name of the radio buttons will return the value of the selected radio button.</span></div>
<p><span class="NormalPACKTChar">Some HTML input fields such as checkboxes and multiple select boxes allow the user to select more than one value. For these fields, instead of using the</span> <kbd>HttpServletRequest.getParameter()</kbd> <span class="NormalPACKTChar">method, the</span> <kbd>HttpServletRequest.getParameterValues()</kbd> <span class="NormalPACKTChar">method is used. This method also takes a <kbd>String</kbd> containing the input field's name as its only parameter, and returns an array of strings containing all the values that were selected by the user.</span></p>
<p><span class="NormalPACKTChar">The following example illustrates this case. The relevant sections of our new HTML markup are shown as follows:</span></p>
<pre style="padding-left: 60px"><strong>&lt;form method="post" action="multiplevaluefieldhandlerservlet"&gt;</strong> 
&lt;p&gt;Please enter one or more options.&lt;/p&gt; 
&lt;table cellpadding="0" cellspacing="0" border="0"&gt; 
  &lt;tr&gt; 
<strong>    &lt;td&gt;&lt;input name="options" type="checkbox" value="option1" /&gt;</strong> 
    Option 1&lt;/td&gt; 
  &lt;/tr&gt; 
  &lt;tr&gt; 
<strong>    &lt;td&gt;&lt;input name="options" type="checkbox" value="option2" /&gt;</strong> 
    Option 2&lt;/td&gt; 
  &lt;/tr&gt; 
  &lt;tr&gt; 
<strong>    &lt;td&gt;&lt;input name="options" type="checkbox" value="option3" /&gt;</strong> 
    Option 3&lt;/td&gt; 
  &lt;/tr&gt; 
  &lt;tr&gt; 
    &lt;td&gt;&lt;input type="submit" value="Submit" /&gt;&lt;/td&gt; 
  &lt;/tr&gt; 
&lt;/table&gt; 
&lt;/form&gt; </pre>
<p><span class="NormalPACKTChar">The new HTML file contains a simple form with three checkboxes and a submit button. Notice how every checkbox has the same value for its</span> <kbd>name</kbd> <span class="NormalPACKTChar">attribute. Like we mentioned before, any checkboxes that are clicked by the user will be sent to the servlet.</span></p>
<p><span class="NormalPACKTChar">Let's now take a look at the servlet that will handle the preceding HTML form:</span></p>
<pre style="padding-left: 60px">package net.ensode.javaee8book.multiplevaluefields; 
 
import java.io.IOException; 
import java.io.PrintWriter; 
import javax.servlet.annotation.WebServlet; 
 
import javax.servlet.http.HttpServlet; 
import javax.servlet.http.HttpServletRequest; 
import javax.servlet.http.HttpServletResponse; 
 
@WebServlet(urlPatterns = {"/multiplevaluefieldhandlerservlet"}) 
public class MultipleValueFieldHandlerServlet extends HttpServlet { 
 
    @Override 
    protected void doPost(HttpServletRequest request, 
        HttpServletResponse response) { 
<strong>       String[] selectedOptions =  <br/>        request.getParameterValues("options");</strong> 
 
        response.setContentType("text/html"); 
 
        try { 
            PrintWriter printWriter = response.getWriter(); 
 
            printWriter.println("&lt;p&gt;"); 
            printWriter.print("The following options were<br/>            selected:"); 
            printWriter.println("&lt;br/&gt;"); 
 
<strong>            if (selectedOptions != null) {</strong><strong>           <br/>              for (String option : selectedOptions) {</strong><strong>                       <br/>              printWriter.print(option);</strong><strong>       <br/>              printWriter.println("&lt;br/&gt;");</strong><strong>     <br/>              }</strong><strong>           <br/>            } else {</strong><strong>            <br/>                printWriter.println("None");</strong><strong>    <br/>            }</strong> 
            printWriter.println("&lt;/p&gt;"); 
        } catch (IOException e) { 
            e.printStackTrace(); 
        } 
    } 
} </pre>
<p><span class="NormalPACKTChar">The preceding code calls the</span> <kbd>request.getParameterValues()</kbd> <span class="NormalPACKTChar">method and assigns its return value to the</span> <kbd>selectedOptions</kbd> <span class="NormalPACKTChar">variable. Farther down the</span> <kbd>doPost()</kbd> <span class="NormalPACKTChar">method, the code traverses the</span> <kbd>selectedOptions</kbd> <span class="NormalPACKTChar">array and prints the selected values in the browser.</span></p>
<p><span class="NormalPACKTChar">If no checkboxes are clicked, the</span> <kbd>request.getParameterValues()</kbd> <span class="NormalPACKTChar">method will return</span> <kbd>null</kbd> <span class="NormalPACKTChar">, therefore it is a good idea to check for null before attempting to traverse through this method's return values.</span></p>
<p><span class="NormalPACKTChar">After packaging our new servlet in a WAR file and deploying it, we can see the changes in action by typing its URL in the browser window. For most application servers, the URL will be</span> <kbd><span class="InternetLink0">http://localhost:8080/formhandling/</span></kbd>.</p>
<div class="CDPAlignCenter CDPAlign"><img class=" image-border" src="assets/66d2e489-2b60-49dd-8859-0b5548f42032.png" style="width:22.08em;height:17.83em;"/></div>
<p>After submitting the form, control goes to our servlet, and the browser window should look something like this:</p>
<div class="CDPAlignCenter CDPAlign"><img class=" image-border" src="assets/74da8611-f55f-4b40-b471-b0620e99469b.png" style="width:28.42em;height:13.67em;"/></div>
<p>Of course, the actual message seen in the browser window will depend on what checkboxes the user clicked on.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Request forwarding and response redirection</h1>
                </header>
            
            <article>
                
<p>In many cases, one servlet processes form data, then transfers control to another servlet or JSP to do some more processing or display a confirmation message on the screen. There are two ways of doing this, either the request can be forwarded or the response can be redirected to another servlet or page.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Request forwarding</h1>
                </header>
            
            <article>
                
<p>Notice how text displayed in the previous section's example matches the value of the <kbd>value</kbd> attribute of the checkboxes that were clicked and not the labels displayed on the previous page. This might confuse the users. Let's modify the servlet to change these values so that they match the labels, then forward the request to another servlet that will display the confirmation message in the browser.</p>
<p>The new version of <kbd>MultipleValueFieldHandlerServlet</kbd> is shown as follows:</p>
<pre style="padding-left: 60px">package net.ensode.javaee8book.formhandling; 
 
import java.io.IOException; 
import java.util.ArrayList; 
 
import javax.servlet.ServletException; 
import javax.servlet.annotation.WebServlet; 
import javax.servlet.http.HttpServlet; 
import javax.servlet.http.HttpServletRequest; 
import javax.servlet.http.HttpServletResponse; 
 
@WebServlet(urlPatterns = {"/multiplevaluefieldhandlerservlet"}) 
public class MultipleValueFieldHandlerServlet extends HttpServlet { 
 
    protected void doPost(HttpServletRequest request,     <br/>    HttpServletResponse response) { 
        String[] selectedOptions =  <br/>        request.getParameterValues("options"); 
        ArrayList&lt;String&gt; selectedOptionLabels = null; 
 
        if (selectedOptions != null) { 
            selectedOptionLabels = new ArrayList&lt;String&gt;  <br/>            (selectedOptions.length); 
 
            for (String selectedOption : selectedOptions) { 
                if (selectedOption.equals("option1")) { 
                    selectedOptionLabels.add("Option 1"); 
                } else if (selectedOption.equals("option2")) { 
                    selectedOptionLabels.add("Option 2"); 
                } else if (selectedOption.equals("option3")) { 
                    selectedOptionLabels.add("Option 3"); 
                } 
            } 
        } 
 
<strong>        request.setAttribute("checkedLabels", <br/>         selectedOptionLabels);</strong> 
 
        try { 
<strong>            request.getRequestDispatcher("confirmationservlet").<br/>              forward(<br/>              request, response);</strong> 
        } catch (ServletException e) { 
            e.printStackTrace(); 
        } catch (IOException e) { 
            e.printStackTrace(); 
        } 
    } 
} </pre>
<p>This version of the servlet iterates through the selected options and adds the corresponding label to an <kbd>ArrayList</kbd> of strings. This string is then attached to the <kbd>request</kbd> object by calling the <kbd>request.setAttribute()</kbd> method. This method is used to attach any object to the request so that any other code we forward the request to can have access to it later.</p>
<p>After attaching the <kbd>ArrayList</kbd> to the request, we then forward the request to the new servlet in the following line of code:</p>
<pre>    <strong>request.getRequestDispatcher("confirmationservlet").forward(</strong>
    <strong> request, response);</strong></pre>
<p>The <kbd>String</kbd> argument to this method must match the value of the <kbd>urlPatterns</kbd> tag of the servlet's <kbd>@WebServlet</kbd> annotation.</p>
<p>At this point, control goes to our new servlet. The code for this new servlet is shown as follows:</p>
<pre style="padding-left: 60px">package net.ensode.javaee8book.requestforward; 
 
import java.io.IOException; 
import java.io.PrintWriter; 
import java.util.List; 
import javax.servlet.annotation.WebServlet; 
 
import javax.servlet.http.HttpServlet; 
import javax.servlet.http.HttpServletRequest; 
import javax.servlet.http.HttpServletResponse; 
 
@WebServlet(urlPatterns = {"/confirmationservlet"}) 
public class ConfirmationServlet extends HttpServlet { 
 
    @Override 
    protected void doPost(HttpServletRequest request,  <br/>    HttpServletResponse response) { 
        try { 
            PrintWriter printWriter; 
            List&lt;String&gt; checkedLabels = (List&lt;String&gt;) request 
                    .getAttribute("checkedLabels"); 
 
            response.setContentType("text/html"); 
            printWriter = response.getWriter(); 
            printWriter.println("&lt;p&gt;"); 
            printWriter.print("The following options were  <br/>            selected:"); 
            printWriter.println("&lt;br/&gt;"); 
 
            if (checkedLabels != null) { 
                for (String optionLabel : checkedLabels) { 
                    printWriter.print(optionLabel); 
                    printWriter.println("&lt;br/&gt;"); 
                } 
            } else { 
                printWriter.println("None"); 
            } 
            printWriter.println("&lt;/p&gt;"); 
        } catch (IOException ioException) { 
            ioException.printStackTrace(); 
        } 
    } 
} </pre>
<p>This code obtains the <kbd>ArrayList</kbd> that was attached to the request by the previous servlet. This is accomplished by calling the <kbd>request.getAttribute()</kbd> method; the parameter for this method must match the value used to attach the object to the request.</p>
<p>Once the preceding servlet obtains the list of option labels, it traverses through it and displays them in the browser:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img class=" image-border" src="assets/5b0879f1-5cba-4cd4-a48f-7046ba86c485.png" style="width:26.75em;height:13.33em;"/></div>
<p>Forwarding a request as described previously only works for other resources (servlets and JSP pages) in the same context as the code doing the forwarding. In simple terms, the servlet or JSP we want to forward to must be packaged in the same WAR file as the code that is invoking the <kbd>request.getRequestDispatcher().forward()</kbd> method. If we need to direct the user to a page in another context (or even another server), we can do it by redirecting the response object.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Response redirection</h1>
                </header>
            
            <article>
                
<p>One disadvantage of forwarding a request as described in the previous section is that requests can only be forwarded to other servlets or JSPs in the same context. If we need to direct the user to a page on a different context (deployed in another WAR file in the same server or deployed in a different server) we need to use the <kbd>HttpServletResponse.sendRedirect()</kbd> method.</p>
<p>To illustrate response redirection, let's develop a simple web application that asks the user to select their favorite search engine, then directs the user to his/her search engine of choice. The HTML page for this application would look like this:</p>
<pre style="padding-left: 60px">&lt;!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd"&gt; 
&lt;html&gt; 
    &lt;head&gt; 
        &lt;meta http-equiv="Content-Type" content="text/html; charset=UTF-8"&gt; 
        &lt;title&gt;Response Redirection Demo&lt;/title&gt; 
    &lt;/head&gt; 
    &lt;body&gt; 
<strong>        &lt;form method="post" action="responseredirectionservlet"&gt;</strong> 
            &lt;p&gt;Please indicate your favorite search engine.&lt;/p&gt; 
            &lt;table&gt; 
<strong>                &lt;tr&gt;</strong><strong>            <br/>                  &lt;td&gt;&lt;input type="radio" name="searchEngine"</strong><strong>                                  <br/>                       value="http://www.google.com"&gt;Google&lt;/td&gt;</strong><strong>                 <br/>                &lt;/tr&gt;</strong><strong>               <br/>                &lt;tr&gt;</strong><strong>                  <br/>                    &lt;td&gt;&lt;input type="radio" name="searchEngine"</strong><strong>                                <br/>                         value="http://www.bing.com"&gt;Bing&lt;/td&gt;</strong><strong>            <br/>                &lt;/tr&gt;</strong><strong>            <br/>                &lt;tr&gt;</strong><strong>              <br/>                    &lt;td&gt;&lt;input type="radio" name="searchEngine"</strong><strong>                                <br/>                         value="http://www.yahoo.com"&gt;Yahoo!&lt;/td&gt;</strong><strong>                                                    <br/>                &lt;/tr&gt;</strong> 
                &lt;tr&gt; 
                    &lt;td&gt;&lt;input type="submit" value="Submit" /&gt;&lt;/td&gt; 
                &lt;/tr&gt; 
            &lt;/table&gt; 
        &lt;/form&gt; 
    &lt;/body&gt; 
&lt;/html&gt; </pre>
<p>The HTML form in the previous markup code contains three radio buttons, the value for each of them is the URL for the search engine corresponding to the user's selection. Notice how the value for the name attribute of each radio button is the same, namely <kbd>"searchEngine"</kbd>. The servlet will obtain the value of the selected radio button by calling the <kbd>request.getParameter()</kbd> method and passing the string <kbd>"searchEngine"</kbd> as a parameter, as is demonstrated in the following code:</p>
<pre style="padding-left: 60px">package net.ensode.javaee8book.responseredirection; 
 
import java.io.IOException; 
import java.io.PrintWriter; 
import javax.servlet.annotation.WebServlet; 
 
import javax.servlet.http.HttpServlet; 
import javax.servlet.http.HttpServletRequest; 
import javax.servlet.http.HttpServletResponse; 
 
@WebServlet(urlPatterns = {"/responseredirectionservlet"}) 
public class ResponseRedirectionServlet extends HttpServlet { 
 
    @Override 
    protected void doPost(HttpServletRequest request,  <br/>    HttpServletResponse response) 
            throws IOException { 
<strong>        String url = request.getParameter("searchEngine");</strong> 
 
        if (url != null) { 
<strong>            response.sendRedirect(url);</strong> 
        } else { 
            PrintWriter printWriter = response.getWriter(); 
 
            printWriter.println("No search engine was selected."); 
        } 
    } 
} </pre>
<p>By calling <kbd>request.getParameter("searchEngine")</kbd>, the preceding code assigns the URL of the selected search engine to the <kbd>url</kbd> <span>variable.</span> Then (after checking for <kbd>null</kbd>, in case the user clicked on the submit button without selecting a search engine), it directs the user to the selected search engine by calling <kbd>response.sendRedirect()</kbd> and passing the <kbd>url</kbd> variable as a parameter.</p>
<p>The <kbd>web.xml</kbd> file for this application should be fairly straightforward and is not shown (it is part of this book's code download).</p>
<p>After packaging the code and deploying it, we can see it in action by typing a URL similar to the following in the browser: <kbd><span class="URLPACKT">http://localhost:8080/responseredirection/</span></kbd>.</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img class=" image-border" src="assets/a2cfc300-9367-48ef-81b1-6cf30e6e5337.png" style="width:18.33em;height:16.42em;"/></div>
<p>After clicking the <span class="packt_screen">S</span><span class="packt_screen">ubmit</span> button, the user is directed to their favorite search engine.</p>
<p>It should be noted that redirecting the response as illustrated previously creates a new HTTP request to the page we are redirecting to, therefore any request parameters and attributes are lost:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img class=" image-border" src="assets/59f9675f-fb6f-475b-b12a-63664079f454.png" style="width:34.42em;height:24.67em;"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Persisting application data across requests</h1>
                </header>
            
            <article>
                
<p>In the previous section, we saw how it is possible to store an object in the request by invoking the <kbd>HttpRequest.setAttribute()</kbd> method and how later this object can be retrieved by invoking the <kbd>HttpRequest.getAttribute()</kbd> method. This approach only works if the request was forwarded to the servlet invoking the <kbd>getAttribute()</kbd> method. If this is not the case, the <kbd>getAttribute()</kbd> method will return null.</p>
<p>It is possible to persist an object across requests. In addition to attaching an object to the request object, an object can also be attached to the session object or to the servlet context. The difference between these two is that objects attached to the session will not be visible to different users, whereas objects attached to the servlet context are.</p>
<p>Attaching objects to the session and servlet context is very similar to attaching objects to the request. To attach an object to the session, the <kbd>HttpServletRequest.getSession()</kbd> method must be invoked; this method returns an instance of <kbd>javax.servlet.http.HttpSession</kbd>. We then call the <kbd>HttpSession.setAttribute()</kbd> method to attach the object to the session. The following code fragment illustrates the process:</p>
<pre style="padding-left: 60px">protected void doPost(HttpServletRequest request, HttpServletResponse response) 
{ 
  . 
  . 
  . 
  Foo foo = new Foo(); //theoretical object 
<strong>  HttpSession session = request.getSession();</strong><strong>    <br/>  session.setAttribute("foo", foo);</strong> 
  . 
  . 
  . 
} </pre>
<p><span class="NormalPACKTChar">We can then retrieve the object from the session by calling the</span> <kbd>HttpSession.getAttribute()</kbd> <span class="NormalPACKTChar">method:</span></p>
<pre style="padding-left: 60px">protected void doPost(HttpServletRequest request, HttpServletResponse response) 
{ 
<strong>  HttpSession session = request.getSession(); <br/>  Foo foo =<br/>  (Foo)session.getAttribute("foo");</strong>
} </pre>
<p><span class="NormalPACKTChar">Notice how the return value of</span> <kbd>session.getAttribute()</kbd> <span class="NormalPACKTChar">needs to be cast to the appropriate type. This is necessary since the return value of this method is</span> <kbd>java.lang.Object</kbd> <span class="NormalPACKTChar">.</span></p>
<p><span class="NormalPACKTChar">The procedure to attach and retrieve objects to and from the servlet context is very similar. The servlet needs to call the</span> <kbd>getServletContext()</kbd> <span class="NormalPACKTChar">method (defined in a class called</span> <kbd>GenericServlet</kbd><span class="NormalPACKTChar">, which is the parent class of</span> <kbd>HttpServlet</kbd><span class="NormalPACKTChar">, which in turn is the parent class of our servlets). This method returns an instance of</span> <kbd>javax.servlet.ServletContext</kbd><span class="NormalPACKTChar">, which defines a</span> <kbd>setAttribute()</kbd> <span class="NormalPACKTChar">and a</span> <kbd>getAttribute()</kbd> <span class="NormalPACKTChar">method. These methods work the same way as their</span> <kbd>HttpServletRequest</kbd> <span class="NormalPACKTChar">and</span> <kbd>HttpSessionResponse</kbd> <span class="NormalPACKTChar">counterparts.</span></p>
<p><span class="NormalPACKTChar">The procedure to attach an object to the servlet context is illustrated in the following code snippet:</span></p>
<pre style="padding-left: 60px">protected void doPost(HttpServletRequest request, HttpServletResponse response) 
{ 
  //The getServletContext() method is defined higher in 
  //the inheritance hierarchy. 
<strong>  ServletContext servletContext = getServletContext();</strong> 
 
  Foo foo = new Foo(); 
  servletContext.setAttribute("foo", foo); 
  . 
  . 
  . 
} </pre>
<p><span class="NormalPACKTChar">The following code attaches the</span> <kbd>foo</kbd> <span class="NormalPACKTChar">object to the servlet context; this object will be available to any servlet in our application and will be the same across sessions. It can be retrieved by calling the</span> <kbd>ServletContext.getAttribute()</kbd> <span class="NormalPACKTChar">method, as is illustrated in the following code:</span></p>
<pre style="padding-left: 60px">protected void doPost(HttpServletRequest request, HttpServletResponse response) 
{ 
<strong>  ServletContext servletContext = getServletContext();<br/>  Foo foo = (Foo)servletContext.getAttribute(âfooâ);</strong>
  . 
  . 
  . 
} </pre>
<p><span class="NormalPACKTChar">This code obtains the</span> <kbd>foo</kbd> <span class="NormalPACKTChar">object from the request context; again, a cast is needed since the</span> <kbd>ServletContext.getAttribute()</kbd> <span class="NormalPACKTChar">method, like its counterparts, returns an instance of</span> <kbd>java.lang.Object</kbd><span class="NormalPACKTChar">.</span></p>
<div class="packt_infobox"><span class="NormalPACKTChar">Objects attached to the servlet context are said to have a scope of</span> <em>application</em><span class="NormalPACKTChar">. Similarly, objects attached to the session are said to have a scope of</span> <em>session</em><span class="NormalPACKTChar">, and objects attached to the request are said to have a scope of</span> <em>request</em><span class="NormalPACKTChar">.</span></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Passing initialization parameters to a servlet via annotations</h1>
                </header>
            
            <article>
                
<p>Sometimes it is useful to pass some initialization parameters to a servlet; that way we can make sure the servlet behaves differently based on the parameters that are sent to it. For example, we may want to configure a servlet to behave differently in development and production environments.</p>
<p>In the old days, servlet initialization parameters were sent via the <kbd>&lt;init-param&gt;</kbd> parameter in <kbd>web.xml</kbd>. As of servlet 3.0, initialization parameters can be passed to the servlet as the value of the <kbd>initParams</kbd> attribute of the <kbd>@WebServlet</kbd> annotation. The following example illustrates how to do this:</p>
<pre style="padding-left: 60px">package net.ensode.javaee8book.initparam; 
 
import java.io.IOException; 
import java.io.PrintWriter; 
import javax.servlet.ServletConfig; 
import javax.servlet.ServletException; 
import javax.servlet.annotation.WebInitParam; 
import javax.servlet.annotation.WebServlet; 
import javax.servlet.http.HttpServlet; 
import javax.servlet.http.HttpServletRequest; 
import javax.servlet.http.HttpServletResponse; 
 
<strong>@WebServlet(name = "InitParamsServlet", urlPatterns = {</strong><strong> <br/> "/InitParamsServlet"}, initParams = {</strong><strong> <br/>  @WebInitParam(name = "param1", value = "value1"),<br/></strong><strong>  @WebInitParam(name = "param2", value = "value2")})</strong> 
public class InitParamsServlet extends HttpServlet { 
 
  @Override 
  protected void doGet(HttpServletRequest request, 
          HttpServletResponse response) 
          throws ServletException, IOException { 
<strong>    ServletConfig servletConfig = getServletConfig();<br/></strong><strong>    String param1Val = servletConfig.getInitParameter("param1");</strong><strong>   <br/>    String param2Val = servletConfig.getInitParameter("param2");</strong> 
    response.setContentType("text/html"); 
    PrintWriter printWriter = response.getWriter(); 
 
    printWriter.println("&lt;p&gt;"); 
    printWriter.println("Value of param1 is " + param1Val); 
    printWriter.println("&lt;/p&gt;"); 
 
    printWriter.println("&lt;p&gt;"); 
    printWriter.println("Value of param2 is " + param2Val); 
    printWriter.println("&lt;/p&gt;"); 
  } 
} </pre>
<p>As we can see, the value of the <kbd>initParams</kbd> attribute of the <kbd>@WebServlet</kbd> annotation is an array of <kbd>@WebInitParam</kbd> annotations. Each <kbd>@WebInitParam</kbd> annotation has two attributesâ<kbd>name</kbd>, which corresponds to the parameter name, and <kbd>value</kbd>, which corresponds to the parameter value.</p>
<p>We can obtain the values of our parameters by invoking the <kbd>getInitParameter()</kbd> method on the <kbd>javax.servlet.ServletConfig</kbd> class. This method takes a single <kbd>String</kbd> argument as a parameter, corresponding to the parameter name, and returns a <kbd>String</kbd> corresponding to the parameter value.</p>
<p>Each servlet has a corresponding instance of <kbd>ServletConfig</kbd> assigned to it. As we can see in this example, we can obtain this instance by invoking <kbd>getServletConfig()</kbd>, which is a method inherited from <kbd>javax.servlet.GenericServlet</kbd>, the parent class of <kbd>HttpServlet</kbd>, which our servlets extend.</p>
<p>After packaging our servlet in a WAR file and deploying to our Java EE 8 application server of choice, we will see the following page rendered in the browser:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img class=" image-border" src="assets/ed3ce70e-dd48-4b61-865f-e437d4880940.png" style="width:27.33em;height:14.25em;"/></div>
<p>As we can see, the rendered values correspond to the values we set in each <kbd>@WebInitParam</kbd> annotation.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Servlet filters</h1>
                </header>
            
            <article>
                
<p>Filters were introduced to the servlet specification in version 2.3. A filter is an object that can dynamically intercept a request and manipulate its data before the request is handled by the servlet. Filters can also manipulate a response after a servlet's <kbd>doGet()</kbd> or <kbd>doPost()</kbd> method finishes, but before the output is sent to the browser.</p>
<p>The only way to configure a filter in earlier servlet specifications was to use the <kbd>&lt;filter-mapping&gt;</kbd> tag in <kbd>web.xml</kbd>. Servlet 3.0 introduced the ability to configure servlets via the <kbd>@WebFilter</kbd> annotation.</p>
<p>The following example illustrates how to do this:</p>
<pre style="padding-left: 60px">package net.ensode.javaee8book.simpleapp; 
 
import java.io.IOException; 
import java.util.Enumeration; 
import javax.servlet.Filter; 
import javax.servlet.FilterChain; 
import javax.servlet.FilterConfig; 
import javax.servlet.ServletContext; 
import javax.servlet.ServletException; 
import javax.servlet.ServletRequest; 
import javax.servlet.ServletResponse; 
import javax.servlet.annotation.WebFilter; 
import javax.servlet.annotation.WebInitParam; 
 
<strong>@WebFilter(filterName = "SimpleFilter", initParams = {</strong><strong> <br/> @WebInitParam(name = "filterparam1", value = "filtervalue1")},<br/></strong><strong>  urlPatterns = {"/InitParamsServlet"})</strong> 
public class SimpleFilter implements Filter { 
 
  private FilterConfig filterConfig; 
 
  @Override 
  public void init(FilterConfig filterConfig) throws 
          ServletException { 
    this.filterConfig = filterConfig; 
  } 
 
  @Override 
  public void doFilter(ServletRequest servletRequest, 
          ServletResponse servletResponse, FilterChain filterChain) 
          throws 
          IOException, ServletException { 
    ServletContext servletContext = <br/>     filterConfig.getServletContext(); 
    servletContext.log("Entering doFilter()"); 
    servletContext.log("initialization parameters: "); 
    Enumeration&lt;String&gt; initParameterNames = 
            filterConfig.getInitParameterNames(); 
    String parameterName; 
    String parameterValue; 
 
    while (initParameterNames.hasMoreElements()) { 
      parameterName = initParameterNames.nextElement(); 
      parameterValue = <br/>       filterConfig.getInitParameter(parameterName); 
      servletContext.log(parameterName + " = " + parameterValue); 
    } 
 
    servletContext.log("Invoking servlet..."); 
    filterChain.doFilter(servletRequest, servletResponse); 
    servletContext.log("Back from servlet invocation"); 
 
  } 
 
  @Override 
  public void destroy() { 
    filterConfig = null; 
  } 
} </pre>
<p>As we can see in the example, the <kbd>@WebFilter</kbd> annotation has several attributes we can use to configure the filter. Of special importance is the <kbd>urlPatterns</kbd> attribute. This attribute takes an array of <kbd>String</kbd> objects as its value, and each element in the array corresponds to a URL that our filter will intercept. In our example, we are intercepting a single URL pattern, which corresponds to the servlet we wrote in the previous section.</p>
<p>Other attributes in the <kbd>@WebFilter</kbd> annotation include the optional <kbd>filterName</kbd> attribute, which we can use to give our filter a name. If we don't specify a name for our filter, then the filter name defaults to the filter's class name.</p>
<p>As we can see in the previous example, we can send initialization parameters to a filter. This is done the same way we send initialization parameters to a servlet. The <kbd>@WebFilter</kbd> annotation has an <kbd>initParams</kbd> attribute that takes an array of <kbd>@WebInitParam</kbd> annotations as its value. We can obtain the values of said parameters by invoking the <kbd>getInitParameter()</kbd> method on <kbd>javax.servlet.FilterConfig</kbd>, as illustrated in the example.</p>
<p>Our filter is fairly simple, it simply sends some output to the server log before and after the servlet is invoked. Inspecting the server log after deploying our application and pointing the browser to the servlet's URL should reveal our filter's output:</p>
<pre>    <strong>[2017-05-31T20:02:46.044-0400] [glassfish 5.0] [INFO] [] [javax.enterprise.web] [tid: _ThreadID=112 _ThreadName=http-listener-1(5)] [timeMillis: 1496275366044] [levelValue: 800] [[</strong>
    <strong>  WebModule[/servletfilter] ServletContext.log():Entering doFilter()]]</strong>
    
    <strong>[2017-05-31T20:02:46.045-0400] [glassfish 5.0] [INFO] [] [javax.enterprise.web] [tid: _ThreadID=112 _ThreadName=http-listener-1(5)] [timeMillis: 1496275366045] [levelValue: 800] [[</strong>
    <strong>  WebModule[/servletfilter] ServletContext.log():initialization parameters: ]]</strong>
    
    <strong>[2017-05-31T20:02:46.045-0400] [glassfish 5.0] [INFO] [] [javax.enterprise.web] [tid: _ThreadID=112 _ThreadName=http-listener-1(5)] [timeMillis: 1496275366045] [levelValue: 800] [[</strong>
    <strong>  WebModule[/servletfilter] ServletContext.log():filterparam1 = filtervalue1]]</strong>
    
    <strong>[2017-05-31T20:02:46.045-0400] [glassfish 5.0] [INFO] [] [javax.enterprise.web] [tid: _ThreadID=112 _ThreadName=http-listener-1(5)] [timeMillis: 1496275366045] [levelValue: 800] [[</strong>
    <strong>  WebModule[/servletfilter] ServletContext.log():Invoking servlet...]]</strong>
    
    <strong>[2017-05-31T20:02:46.046-0400] [glassfish 5.0] [INFO] [] [javax.enterprise.web] [tid: _ThreadID=112 _ThreadName=http-listener-1(5)] [timeMillis: 1496275366046] [levelValue: 800] [[</strong>
    <strong>  WebModule[/servletfilter] ServletContext.log():Back from servlet invocation]]</strong></pre>
<p>Servlet filters, of course, have many real uses. They can be used for profiling web applications, for applying security, and for compressing data, among many other uses.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Servlet listeners</h1>
                </header>
            
            <article>
                
<p>During the lifetime of a typical web application, a number of events take place, such as HTTP requests getting created or destroyed, request or session attributes getting added, removed or modified, and so on and so forth.</p>
<p>The servlet API provides a number of listener interfaces we can implement in order to react to these events. All of these interfaces are in the <kbd>javax.servlet</kbd> package, and the following table summarizes them:</p>
<table class="table">
<tbody>
<tr>
<td>
<p><strong>Listener interface</strong></p>
</td>
<td>
<p><strong>Description</strong></p>
</td>
</tr>
<tr>
<td>
<p><kbd>ServletContextListener</kbd></p>
</td>
<td>
<p>Contains methods for handling context initialization and destruction events.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>ServletContextAttributeListener</kbd></p>
</td>
<td>
<p>Contains methods for reacting to any attributes added, removed, or replaced in the servlet context (application scope).</p>
</td>
</tr>
<tr>
<td>
<p><kbd>ServletRequestListener</kbd></p>
</td>
<td>
<p>Contains methods for handling request initialization and destruction events.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>ServletRequestAttributeListener</kbd></p>
</td>
<td>
<p>Contains methods for reacting to any attributes added, removed, or replaced in the request.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>HttpSessionListener</kbd></p>
</td>
<td>
<p>Contains methods for handling HTTP session initialization and destruction events.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>HttpSessionAttributeListener</kbd></p>
</td>
<td>
<p>Contains methods for reacting to any attributes added, removed, or replaced in the HTTP session.</p>
</td>
</tr>
</tbody>
</table>
<p>Â </p>
<p>All we need to do to handle any of the events handled by the interfaces described in the preceding table is to implement one of the previous interfaces and annotate it with the <kbd>@WebListener</kbd> interface, or declare it in the <kbd>web.xml</kbd> deployment descriptor via the <kbd>&lt;listener&gt;</kbd> tag. Unsurprisingly, the ability to use an annotation to register a listener was introduced in version 3.0 of the servlet specification.</p>
<p>The API for all of the preceding interfaces is fairly straightforward and intuitive. We will show an example for one of the preceding interfaces, and the others will be very similar.</p>
<div class="packt_infobox">The JavaDoc for all of the preceding interfaces can be found at: <a href="http://java.sun.com/javaee/6/docs/api/javax/servlet/http/package-summary.html"><span class="URLPACKT">https://javaee.github.io/javaee-spec/javadocs/</span></a><span class="URLPACKT">.</span></div>
<p>The following example illustrates how to implement the <kbd>ServletRequestListener</kbd> interface, which can be used to perform an action whenever an HTTP request is created or destroyed:</p>
<pre>    <span class="URLPACKT">package net.ensode.javaee8book.listener;</span>
    <span class="URLPACKT">import javax.servlet.ServletContext;</span>
    <span class="URLPACKT">import javax.servlet.ServletRequestEvent;</span>
    <span class="URLPACKT">import javax.servlet.ServletRequestListener;</span>
    <span class="URLPACKT">import javax.servlet.annotation.WebListener;</span>
    <strong>
      <span class="URLPACKT">@WebListener()</span>
    </strong>
    <span class="URLPACKT">public class HttpRequestListener implements ServletRequestListener   <br/>   {</span>
    
    <span class="URLPACKT">@Override</span>
    <strong>
      
      <span class="URLPACKT">public void requestInitialized(ServletRequestEvent  <br/>      servletRequestEvent) {</span>
    </strong>
    
    <span class="URLPACKT">ServletContext servletContext =</span>
    
    <span class="URLPACKT">servletRequestEvent.getServletContext();</span>
    
    <span class="URLPACKT">servletContext.log("New request initialized");</span>
    
    <span class="URLPACKT">}</span>
    
    <span class="URLPACKT">@Override</span>
    <strong>
      
      <span class="URLPACKT">public void requestDestroyed(ServletRequestEvent   <br/>      servletRequestEvent) {</span>
    </strong>
    
    <span class="URLPACKT">ServletContext servletContext =</span>
    
    <span class="URLPACKT">servletRequestEvent.getServletContext();</span>
    
    <span class="URLPACKT">servletContext.log("Request destroyed");</span>
    
    <span class="URLPACKT">}</span>
    <span class="URLPACKT">}</span></pre>
<p><span class="URLPACKT">As we can see, all we need to do to activate our listener class is to annotate it with the</span> <kbd>@WebListener</kbd> <span class="URLPACKT">annotation. Our listener must also implement one of the listener interfaces we listed previously. In our example, we chose to implement</span> <kbd>javax.servlet.ServletRequestListener</kbd>; <span class="URLPACKT">this interface has methods that are automatically invoked whenever an HTTP request is initialized or destroyed.</span></p>
<p>The <kbd>ServletRequestListener</kbd> interface has two methods, <kbd>requestInitialized()</kbd> and <kbd>requestDestroyed()</kbd>. In our previous, simple implementation we simply sent some output to the log, but of course we can do anything we need to do in our implementations<span class="URLPACKT">.</span></p>
<p>Deploying our previous listener along with the simple servlet we developed earlier in the chapter, we can see the following output in the application server log:</p>
<pre>    <strong>
<span class="URLPACKT">[2017-05-31T20:15:57.900-0400] [glassfish 5.0] [INFO] [] [javax.enterprise.web] [tid: _ThreadID=109 _ThreadName=http-listener-1(2)] [timeMillis: 1496276157900] [levelValue: 800] [[</span>
    </strong>
    <strong>
<span class="URLPACKT">WebModule[/servletlistener] ServletContext.log():New request initialized]]</span>
    </strong>
    
    <strong>
<span class="URLPACKT">[2017-05-31T20:15:58.013-0400] [glassfish 5.0] [INFO] [] [javax.enterprise.web] [tid: _ThreadID=109 _ThreadName=http-listener-1(2)] [timeMillis: 1496276158013] [levelValue: 800] [[</span>
    </strong>
    <br/><strong>WebModule[/servletlistener] ServletContext.log():Request destroyed]]
  </strong></pre>
<p><span class="URLPACKT">Implementing the other listener interfaces is just as simple and straightforward.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Pluggability</h1>
                </header>
            
            <article>
                
<p>When the original servlet API was released back in the late 1990s, writing servlets was the only way of writing server-side web applications in Java. Since then, several standard Java EE and third-party frameworks have been built on top of the Servlet API. Examples of such standard frameworks include JSP and JSF, and third-party frameworks include Struts, Wicket, Spring Web MVC, and several others.</p>
<p>Nowadays, very few (if any) Java web applications are built using the Servlet API directly; instead, the vast majority of projects utilize one of the several available Java web application frameworks. All of these frameworks use the Servlet API "under the covers", therefore setting up an application to use one of these frameworks has always involved making some configuration in the application's <kbd>web.xml</kbd> deployment descriptor. In some cases, some applications use more than one framework, but this tends to make the <kbd>web.xml</kbd> deployment descriptor fairly large and hard to maintain.</p>
<p>Servlet 3.0 introduced the concept of pluggability. Web application framework developers now have not one, but two ways to avoid having application developers have to modify the <kbd>web.xml</kbd> deployment descriptor in order to use their framework. Framework developers can choose to use annotations instead of a <kbd>web.xml</kbd> to configure their servlets; after doing this, all that is needed to use the framework is to include the library JAR file(s) provided by the framework developers in the application's WAR file. Alternatively, framework developers may choose to include a <kbd>web-fragment.xml</kbd> as part of the JAR file to be included in web applications that use their framework.</p>
<p><kbd>web-fragment.xml</kbd> is almost identical to <kbd>web.xml</kbd>, the main difference is that the root element of a <kbd>web-fragment.xml</kbd> is <kbd>&lt;web-fragment&gt;</kbd> as opposed to <kbd>&lt;web-app&gt;</kbd>. The following example illustrates a sample <kbd>web-fragment.xml</kbd>:</p>
<pre style="padding-left: 60px">&lt;?xml version="1.0" encoding="UTF-8"?&gt; 
&lt;web-fragment version="3.0"  
   
  xsi:schemaLocation="http://java.sun.com/xml/ns/javaee 
  http://java.sun.com/xml/ns/javaee/web-fragment_3_0.xsd"&gt; 
  &lt;servlet&gt; 
    &lt;servlet-name&gt;WebFragment&lt;/servlet-name&gt; 
    &lt;servlet-class&gt; 
      net.ensode.glassfishbook.webfragment.WebFragmentServlet 
    &lt;/servlet-class&gt; 
  &lt;/servlet&gt; 
  &lt;servlet-mapping&gt; 
    &lt;servlet-name&gt;WebFragment&lt;/servlet-name&gt; 
    &lt;url-pattern&gt;/WebFragment&lt;/url-pattern&gt; 
  &lt;/servlet-mapping&gt; 
&lt;/web-fragment&gt; </pre>
<p>As we can see, <kbd>web-fragment.xml</kbd> is almost identical to a typical <kbd>web.xml</kbd>. In this simple example, we only use the <kbd>&lt;servlet&gt;</kbd> and <kbd>&lt;servlet-mapping&gt;</kbd> elements, but all other usual <kbd>web.xml</kbd> elements, such as <kbd>&lt;filter&gt;</kbd>, <kbd>&lt;filter-mapping&gt;</kbd>, and <kbd>&lt;listener&gt;</kbd>, are available as well.</p>
<p>As specified in our <kbd>web-fragment.xml</kbd>, our servlet can be invoked via its URL pattern, <kbd>/WebFragment</kbd>, therefore the URL to execute our servlet once deployed as part of a web application would be <kbd><span class="InternetLink0">http://localhost:8080/webfragmentapp/WebFragment</span></kbd>. Of course, the host name, port, and context root must be adjusted as appropriate.</p>
<p>All we need to do for any Java EE-compliant application server to pick up the settings in <kbd>web-fragment.xml</kbd> is to place the file in the <kbd>META-INF</kbd> folder of the library where we pack our servlet, filter, and/or listener, then place our library's JAR file in the <kbd>lib</kbd> folder of the WAR file containing our application.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Configuring web applications programmatically</h1>
                </header>
            
            <article>
                
<p>In addition to allowing us to configure web applications through annotations and through a <kbd>web-fragment.xml</kbd>, Servlet 3.0 also allows us to configure our web applications programmatically at runtime.</p>
<p>The <kbd>ServletContext</kbd> class has new methods to configure servlets, filters, and listeners programmatically. The following example illustrates how to configure a servlet programmatically at runtime, without resorting to the <kbd>@WebServlet</kbd> annotation or to XML:</p>
<pre style="padding-left: 60px">package net.ensode.javaee8book.servlet; 
 
import javax.servlet.ServletContext; 
import javax.servlet.ServletContextEvent; 
import javax.servlet.ServletContextListener; 
import javax.servlet.ServletException; 
import javax.servlet.ServletRegistration; 
import javax.servlet.annotation.WebListener; 
 
@WebListener() 
public class ServletContextListenerImpl implements 
        ServletContextListener { 
 
  @Override 
  public void contextInitialized( 
          ServletContextEvent servletContextEvent) { 
    ServletContext servletContext = servletContextEvent. 
            getServletContext(); 
    try { 
<strong>      ProgrammaticallyConfiguredServlet servlet = servletContext.</strong><strong>               <br/>       createServlet(ProgrammaticallyConfiguredServlet.class);</strong><strong>       <br/>       servletContext.addServlet(<br/>       "ProgrammaticallyConfiguredServlet", </strong><strong>servlet);</strong><strong>   <br/>       ServletRegistration servletRegistration = servletContext.</strong><strong>                <br/>        getServletRegistration(</strong><strong>            <br/>        "ProgrammaticallyConfiguredServlet");</strong><strong>     <br/>       servletRegistration.addMapping(</strong><strong>               <br/>        "/ProgrammaticallyConfiguredServlet");</strong> 
    } catch (ServletException servletException) { 
      servletContext.log(servletException.getMessage()); 
    } 
  } 
 
  @Override 
  public void contextDestroyed( 
          ServletContextEvent servletContextEvent) { 
  } 
} </pre>
<p>In this example, we invoke the <kbd>createServlet()</kbd> method of <kbd>ServletContext</kbd> to create the servlet that we are about to configure. This method takes an instance of <kbd>java.lang.Class</kbd> corresponding to our servlet's class. This method returns a class implementing <kbd>javax.servlet.Servlet</kbd> or any of its child interfaces.</p>
<p>Once we create our servlet, we need to invoke <kbd>addServlet()</kbd> on our <kbd>ServletContext</kbd> instance to register our servlet with the servlet container. This method takes two parameters, the first being a <kbd>String</kbd> corresponding to the servlet name, the second being the servlet instance returned by the call to <kbd>createServlet()</kbd>.</p>
<p>Once we have registered our servlet, we need to add a URL mapping to it. In order to do this, we need to invoke the <kbd>getServletRegistration()</kbd> method on our <kbd>ServletContext</kbd> instance, passing the servlet name as a parameter. This method returns the servlet container's implementation of <kbd>javax.servlet.ServletRegistration</kbd>. From this object, we need to invoke its <kbd>addMapping()</kbd> method, passing the URL mapping we wish our servlet to handle.</p>
<p>Our example servlet is very simple, it simply displays a text message in the browser:</p>
<pre style="padding-left: 60px">package net.ensode.javaee8book.servlet; 
 
import java.io.IOException; 
import javax.servlet.ServletException; 
import javax.servlet.ServletOutputStream; 
import javax.servlet.http.HttpServlet; 
import javax.servlet.http.HttpServletRequest; 
import javax.servlet.http.HttpServletResponse; 
 
public class ProgrammaticallyConfiguredServlet extends HttpServlet { 
 
  @Override 
  protected void doGet(HttpServletRequest request, 
          HttpServletResponse response) 
          throws ServletException, IOException { 
    ServletOutputStream outputStream = response.getOutputStream(); 
 
    outputStream.println( 
            "This message was generated from a servlet that was " 
            + "configured programmatically."); 
  } 
} </pre>
<p>After packing our code in a WAR file, deploying to GlassFish, and pointing the browser to the appropriate URL (that is, <kbd><span class="InternetLink0">http://localhost:8080/programmaticservletwebapp/ProgrammaticallyConfiguredServlet</span></kbd>, assuming we packaged the application in a WAR file named <kbd>programmaticservletwebapp.war</kbd> and didn't override the default context root), we should see the following message in the browser:</p>
<pre><strong>This message was generated from a servlet that was configured programmatically.</strong></pre>
<p class="mce-root">The <kbd>ServletContext</kbd> interface has methods to create and add servlet filters and listeners, they work very similarly to the way the <kbd>addServlet()</kbd> and <kbd>createServlet()</kbd> methods work, therefore we won't be discussing them in detail. Refer to the Java EE API documentation at: <a href="https://javaee.github.io/javaee-spec/javadocs/"><span class="URLPACKT">https://javaee.github.io/javaee-spec/javadocs/</span></a> for details.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Asynchronous processing</h1>
                </header>
            
            <article>
                
<p>Traditionally, servlets have created a single thread per request in Java web applications. After a request is processed, the thread is made available for other requests to use. This model works fairly well for traditional web applications, for which HTTP requests are relatively few and far between. However, most modern web applications take advantage of Ajax (Asynchronous JavaScript and XML), a technique that makes web applications behave much more responsively than traditional web applications. Ajax has the side effect of generating a lot more HTTP requests than traditional web applications, if some of these threads block for a long time waiting for a resource to be ready, or do anything that takes a long time to process, it is possible our application may suffer from thread starvation.</p>
<p>To alleviate the situation described in the previous paragraph, the Servlet 3.0 specification introduced asynchronous processing. Using this new capability, we are no longer limited to a single thread per request. We can now spawn a separate thread and return the original thread back to the pool, to be reused by other clients.</p>
<p>The following example illustrates how to implement asynchronous processing using the new capabilities introduced in Servlet 3.0:</p>
<pre style="padding-left: 60px">package net.ensode.javaee8book.asynchronousservlet; 
 
import java.io.IOException; 
import java.util.logging.Level; 
import java.util.logging.Logger; 
import <a>javax.servlet.AsyncContext</a>; 
import javax.servlet.ServletException; 
import javax.servlet.annotation.WebServlet; 
import javax.servlet.http.HttpServlet; 
import javax.servlet.http.HttpServletRequest; 
import javax.servlet.http.HttpServletResponse; 
 
<strong>@WebServlet(name = "AsynchronousServlet", urlPatterns = {<br/></strong><strong> "/AsynchronousServlet"},<br/></strong><strong>  asyncSupported = true)</strong> 
public class AsynchronousServlet extends HttpServlet { 
 
  @Override 
  protected void doGet(HttpServletRequest request, 
          HttpServletResponse response) 
          throws ServletException, IOException { 
    final Logger logger = 
            Logger.getLogger(AsynchronousServlet.class.getName()); 
    logger.log(Level.INFO, "--- Entering doGet()"); 
<strong>    final AsyncContext ac = request.startAsync();</strong> 
    logger.log(Level.INFO, "---- invoking ac.start()"); 
<strong>    ac.start(new Runnable() {</strong> 
 
      @Override 
      public void run() { 
        logger.log(Level.INFO, "inside thread"); 
        try { 
          //simulate a long running process. 
          Thread.sleep(10000); 
        } catch (InterruptedException ex) { 
          Logger.getLogger(AsynchronousServlet.class.getName()). 
                  log(Level.SEVERE, null, ex); 
        } 
        try { 
<strong>          ac.getResponse().getWriter().</strong><strong>            <br/>           println("You should see this after a brief wait");</strong><strong>      <br/>          ac.complete();</strong> 
        } catch (IOException ex) { 
          Logger.getLogger(AsynchronousServlet.class.getName()). 
                  log(Level.SEVERE, null, ex); 
        } 
      } 
    }); 
    logger.log(Level.INFO, "Leaving doGet()"); 
  } 
} </pre>
<p>The first thing we need to do to make sure our asynchronous processing code works as expected is to set the <kbd>asyncSupported</kbd> attribute of the <kbd>@WebServlet</kbd> annotation to true.</p>
<p>To actually spawn an asynchronous process, we need to invoke the <kbd>startAsync()</kbd> method on the instance of <kbd>HttpServletRequest</kbd> that we receive as a parameter in the <kbd>doGet()</kbd> or <kbd>doPost()</kbd> method in our servlet. This method returns an instance of <kbd>javax.servlet.AsyncContext</kbd>. This class has a <kbd>start()</kbd> method that takes an instance of a class implementing <kbd>java.lang.Runnable</kbd> as its sole parameter. In our example, we used an anonymous inner class to implement <kbd>Runnable</kbd> in line; of course a standard Java class implementing <kbd>Runnable</kbd> can be used as well.</p>
<p>When we invoke the <kbd>start()</kbd> method of <kbd>AsyncContext</kbd>, a new thread is spawned and the <kbd>run()</kbd> method of the <kbd>Runnable</kbd> instance is executed. This thread runs in the background, the <kbd>doGet()</kbd> method returns immediately, and the request thread is immediately available to service other clients. It is important to notice that, even though the <kbd>doGet()</kbd> method returns immediately, the response is not committed until after the spawned <span>thread</span> finishes. It can signal it is done processing by invoking the <kbd>complete()</kbd> method on <kbd>AsyncContext</kbd>.</p>
<p>In the previous example, we sent some entries to the application server log file to better illustrate what is going on. By observing the application server log right after our servlet executes, we should notice that all log entries are written to the log within a fraction of a second of each other; the message <span class="packt_screen">You should see this after a brief wait</span> doesn't show in the browser until after the log entry indicating that we are leaving the <kbd>doGet()</kbd> method gets written to the log.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">HTTP/2 server push support</h1>
                </header>
            
            <article>
                
<p>HTTP/2 is the newest version of the HTTP protocol. It offers several advantages over HTTP 1.1. For example, with HTTP/2 there is a single connection between the browser and the server and this connection remains open until the user navigates to another page. HTTP/2 also offers multiplexing, meaning that several concurrent requests from the browser to the server are allowed. Additionally, HTTP/2 features server push, meaning that the server can send resources to the browser without the browser specifically having to request them.</p>
<p>HTTP/2 server push support was added to the servlet specification in version 4.0, released as part of Java EE 8. In this section, we'll see how we can write code to take advantage of HTTP/2's server push functionality. The following example illustrates how this can be done:</p>
<pre style="padding-left: 60px">package net.ensode.javaee8book.servlet; 
 
import java.io.IOException; 
import java.io.PrintWriter; 
import javax.servlet.ServletException; 
import javax.servlet.annotation.WebServlet; 
import javax.servlet.http.HttpServlet; 
import javax.servlet.http.HttpServletRequest; 
import javax.servlet.http.HttpServletResponse; 
import javax.servlet.http.PushBuilder; 
 
@WebServlet(name = "ServletPushDemoServlet", urlPatterns = {"/ServletPushDemoServlet"}) 
public class ServletPushDemoServlet extends HttpServlet { 
    @Override 
    protected void doPost(HttpServletRequest request, <br/>     HttpServletResponse response) 
            throws ServletException, IOException { 
<strong>        PushBuilder pushBuilder = request.newPushBuilder();</strong> 
 
        if (pushBuilder != null) { 
            //We know the browser is going to need the image 
            //so we push it before it even requests it. 
            //We could do the same for Javascript files, CSS, etc. 
<strong>            pushBuilder.path("images/david_heffelfinger.png").</strong><strong>                     <br/>             addHeader("content-type", "image/png").</strong><strong>            <br/>              push();</strong> 
            response.sendRedirect("response.html"); 
        } else { 
           //Gracefully handle the case when the browser does not  <br/>           support HTTP/2. 
        } 
    } 
} </pre>
<p>We can push resources to the browser via the new <kbd>PushBuilder</kbd> interface, introduced in version 4 of the servlet specification. We can obtain an instance of a class implementing <kbd>PushBuilder</kbd> by invoking the new <kbd>PushBuilder()</kbd> method on the instance of <kbd>HttpServletRequest</kbd> we get as a parameter in our <kbd>doPost()</kbd> method.</p>
<p>As its name implies, the <kbd>PushBuilder</kbd> interface implements the Builder pattern, meaning that most of its methods return a new instance of <kbd>PushBuilder</kbd> we can use, allowing us to conveniently chain together method invocations.</p>
<p>We indicate the path of the resource we'd like to push to the browser by invoking the appropriately named <kbd>path()</kbd> method from <kbd>PushBuilder</kbd>. This method takes a single <kbd>String</kbd> argument indicating the path of the resource to push. Paths beginning with a forward slash (<kbd>/</kbd>) indicate an absolute path, all other paths indicate a path relative to our application's context root.</p>
<p>Once we have specified the path of our resource, we can optionally set some HTTP headers; in our case, we are pushing an image in PNG format, therefore we set the content type as appropriate.</p>
<p>Finally, we invoke the <kbd>push()</kbd> method on our <kbd>PushBuilder</kbd> instance to actually push our resource to the browser.</p>
<p>What we accomplished with our example was pushing a resource to the browser before the browser submitted a request for it; this task was impossible before the HTTP/2 protocol was released.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>This chapter covered how to develop, configure, package, and deploy servlets. We also covered how to process HTML form information by accessing the HTTP request object. Additionally, forwarding HTTP requests from one servlet to another was covered, as well as redirecting the HTTP response to a different server.</p>
<p>We discussed how to persist objects in memory across requests by attaching them to the servlet context and the HTTP session. We also covered additional features of the servlet API, including configuring web applications via annotations, pluggability through <kbd>web-fragment.xml</kbd>, programmatic servlet configuration, and asynchronous processing. Finally, we covered the new Servlet 4.0 API that supports HTTP/2 server push.</p>


            </article>

            
        </section>
    </body></html>