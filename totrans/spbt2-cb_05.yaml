- en: Application Testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating tests for MVC controllers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuring a database schema and populating it
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating tests using an in-memory database
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating tests using mock objects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a JPA component test
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a WebMvc component test
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing tests using Cucumber
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing tests using Spock
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapters, we did a lot of coding. We created a new Spring Boot
    application from scratch, added an MVC component and some database services to
    it, made a few tweaks to the application behavior, and even wrote our very own
    Spring Boot starter. It is now time to take the next step and learn what kind
    of tools and capabilities Spring Boot offers when it comes to testing all this
    code, and how well it integrates with the other popular testing frameworks.
  prefs: []
  type: TYPE_NORMAL
- en: We will see how to use Spring JUnit integration to create unit tests. Next,
    we will explore the options of setting up the database with test data to test
    against it. We will then look to the **behavior-driven development** (**BDD**)
    tools Cucumber and Spock and see how they integrate with Spring Boot.
  prefs: []
  type: TYPE_NORMAL
- en: Creating tests for MVC controllers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapters, we made a lot of progress in gradually creating our
    application, but how do we know that it actually does what we want it to do? More
    importantly, how do we know for sure that after six months, or even a year from
    now, it will still continue to do what we expected it to do at the very beginning?
    This question is best answered by creating a set of tests, preferably automated,
    that run a suite of assertions against our code. This ensures that we constantly
    get the same and expected output given the specific input. Tests give us the much-needed
    peace of mind that our application not only elegantly is coded and looks beautiful,
    but that it also performs reliably and is as error-free as possible.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 4](6139967b-794e-479a-8461-d3197eb0322e.xhtml), *Writing Custom
    Spring Boot Starters*, we left off with our web application fitted with a custom-written
    Spring Boot starter. We will now create some basic tests to test our web application
    and to ensure that all the controllers expose the expected RESTful URLs, which
    we can rely on as the service API. This type of testing is a bit beyond what is
    commonly known as **unit testing** as it tests the entire web application, it
    requires the application context to be fully initialized, and all the beans should
    be wired together in order to work. This kind of testing is sometimes referred
    to as **integration** or **service testing**.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Spring Boot gets us going by creating a placeholder test file, `BookPubApplicationTests.java`,
    in the `src/test/java/com/example/bookpub` directory at the root of our project
    with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'In `build.gradle`, we also get a test dependency on `spring-boot-starter-test`,
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'We will go ahead and extend the basic template test to contain the following
    code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Execute the tests by running `./gradlew clean test`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'By looking at the console output, we can tell that our tests have succeeded
    and are running, but we don''t really see much information besides the following
    lines (truncated for brevity):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Better insight can be gathered by viewing the HTML reports that are generated
    by Gradle, which can be opened in the browser and reside in `build/reports/tests/index.html`,
    as shown in the following screenshot:![](img/a8e039b4-e823-4444-844c-b06e415813e1.png)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Clicking on `com.example.bookpub.BookPubApplicationTests` will take us to the
    individual test case breakdown, which shows the status of each test and how long
    it took to get executed, as follows:![](img/5eb6b09a-d98f-485a-b232-0fb40bfcc16d.png)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The more curious minds can also click on the Standard output button in order
    to see the runtime application logs that are produced during the execution of
    the test.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have created our first test, let's examine the code in detail.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will first look at the following annotations that have been declared for
    the `BookPubApplicationTests` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '`@RunWith(SpringRunner.class)`: This is a standard JUnit annotation that we
    can configure so as to use the `SpringRunner`, providing functionality to bootstrap the
    Spring Boot framework to the standard JUnit tests.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@SpringBootTest(webEnvironment=SpringBootTest.WebEnvironment.RANDOM_PORT)`:
    This is an annotation that marks the class as a Spring Boot test. It will use
    the Spring Boot framework to configure the test class instance, provide appropriate
    configuration, autowiring, and so on. The `webEnvironment=SpringBootTest.WebEnvironment.RANDOM_PORT`
    attribute means that the current test is going to use a real, running service
    instance and will require a complete context initialization and application startup,
    as if it were the real deal. The `RANDOM_PORT` value is used to tell Spring Boot
    to start the Tomcat server on a randomly-chosen HTTP port, which we will later
    obtain by declaring the `@LocalServerPortprivate int port;` value field. This
    ability to select a random HTTP port is very handy when running tests on a Jenkins
    or any other CI server where, if multiple jobs are running in parallel, you could
    encounter port collision.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With the class annotations magic dispelled, let's look at the content of the
    class itself. As this is a Spring Boot test, we can declare any objects that are
    managed by Spring to be `@Autowired` during the execution or set to a specific
    environment value using a `@Value` annotation. In our test, we autowired the `WebApplicationContext`
    and `BookRepository` objects, as well as an instance of `TestRestTemplate`, which
    we will use in the execution of the standard JUnit `@Test` annotated test cases.
  prefs: []
  type: TYPE_NORMAL
- en: In the first test case, the `contextLoads()` method, we will just assert that
    we have the `BookRepository` connection established and that it contains one book
    entry.
  prefs: []
  type: TYPE_NORMAL
- en: Our second test will ensure that our web application responds to a RESTful URL
    for a `Book` lookup via `ISBN - "/books/{isbn}"`. For this test, we will use the
    instance of `TestRestTemplate` and make a RESTful call to the running instance
    on a randomly-selected port. Spring Boot provides the value of the `port` field.
  prefs: []
  type: TYPE_NORMAL
- en: In the `webappBookIsbnApi` test, we are using a full URL with the starting part
    being `"http://localhost:" + port`, which is technically not required if `TestRestTemplate`
    was autowired and injected by Spring Boot. In this case, it is possible to use
    a relative URL, looking like `Book book = restTemplate.getForObject("/books/978-1-78528-415-1",
    Book.class);`, and `TestRestTemplate` will automatically determine the port of
    the running test server instance.
  prefs: []
  type: TYPE_NORMAL
- en: Alternatively, we can execute the same flavor of tests by going through the
    `MockMvc` object. This is provided by the Spring Test Framework and allows you
    to perform MVC testing without actually doing client-side-based testing through
    `RestTemplate`, but instead doing it fully on the server side where the controller
    requests are executed from the same context as the tested application.
  prefs: []
  type: TYPE_NORMAL
- en: In order to use `MockMvc`, we will use the `MockMvcBuilders` utility to build
    an instance using `@Autowired WebApplicationContext`. We will do this in the setup
    method so that we don't have to do it in every test explicitly.
  prefs: []
  type: TYPE_NORMAL
- en: It is also possible to get Spring Boot to automatically create an instance of
    `MockMvc`, if we annotate our test using `WebEnvironment.MOCK` instead of `RANDOM_PORT`.
    That configuration will only make the test run in the mock context, and no real
    server will be started. Our example shows how to combine having a real server
    instance and `MockMVC` in the same test class.
  prefs: []
  type: TYPE_NORMAL
- en: '`MockMvc` provides us with a very extensive set of capabilities in order to
    execute assertions on practically all the things that are related to a web request.
    It is designed to be used in a method-chained fashion, allowing us to link the
    various tests together and forming a nice, continuous logical chain:'
  prefs: []
  type: TYPE_NORMAL
- en: '`perform(get(...))`: This method sets up the web request. In our particular
    case, we perform a GET request but the `MockMvcRequestBuilders` class provides
    us with static helper functions for all the common method calls.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`andExpect(...)`: This method can be invoked multiple times, where each call
    represents an evaluation of a condition against the result of the `perform(...)`
    call. The argument of this call is any implementation of the `ResultMatcher` interface
    along with many stock ones that are provided by the `MockMvcResultMatchers` static
    utility class. This really opens up the possibility of having an infinite number
    of different checks such as verifying the response status, content type, values
    stored in a session, flash scope, verify redirects, contents of the rendering
    model or headers, and much more. We will use a third-party `json-path` add-on
    library (which is automatically brought as a `spring-boot-test` dependency) to
    test the JSON response data in order to ensure that it contains the right elements
    in the right tree hierarchy. `andExpect(jsonPath("$.name").value("Packt"))` validates
    that we have a name element at the root of the JSON document with a value of `Packt`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To learn more about the various possibilities that are available in MockMvc,
    you can refer to [https://github.com/spring-projects/spring-mvc-showcase/tree/master/src/test/java/org/springframework/samples/mvc](https://github.com/spring-projects/spring-mvc-showcase/tree/master/src/test/java/org/springframework/samples/mvc).
  prefs: []
  type: TYPE_NORMAL
- en: Configuring a database schema and populating it
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Earlier in the book, in [Chapter 2](bd85f38d-1b98-47d6-a98a-b22f4478f68e.xhtml),
    *Configuring Web Applications*, we manually added a few entries to the database
    in the `StartupRunner's run(...)` method. While doing so programmatically can
    be a quick and easy way to get something going very quickly, in the long run,
    it is not really a good idea to do so, especially when you are dealing with a
    large amount of data. It is also good practice to separate the database preparations,
    changes, and other configurations from the rest of the running application code,
    even if it is setting up the test cases. Thankfully, Spring has provided you with
    the support to make this task fairly easy and straightforward.
  prefs: []
  type: TYPE_NORMAL
- en: We will continue with the state of the application as we left it in the previous
    recipe. Spring provides us with a couple of ways to define how both the structure
    and data should be populated in the database. The first way relies on using Hibernate
    to automatically create the table structure by inferring it from our defined `@Entity`
    objects and using the `import.sql` file to populate the data. The second approach
    is to use the plain old Spring JDBC capability, which relies on using the `schema.sql`
    file that contains the database table definition and a corresponding `data.sql`
    file that contains the data.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'First, we will remove the programmatic database population which we created
    in [Chapter 2](bd85f38d-1b98-47d6-a98a-b22f4478f68e.xhtml), *Configuring Web Applications*.
    So let''s comment out the following code from the `StartupRunner''s run(...)`
    method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'If we were to run our tests, they might fail if the `test.h2.db` file is missing
    because they expect the data to be in the database. We will populate the database
    by creating a Hibernate `import.sql` file in the `src/main/resources` directory
    at the root of our project with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: On running the tests again by running `./gradlew clean test`, they are magically
    started and get passed again.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Another way to do this is to use the Spring JDBC support for `schema.sql` and
    `data.sql`. Let''s rename the newly-created `import.sql` file to `data.sql` and
    create a `schema.sql` file in the same directory with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: As we are now manually creating the database schema, we will need to tell the
    Hibernate mapper not to automatically derive one from the entities and populate
    the database with it. So, let's set the `spring.jpa.hibernate.ddl-auto=none` property
    in the `application.properties` file in the `src/main/resources` directory at
    the root of our project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Execute the tests by running `./gradlew clean test` and they should get passed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we actually explored two ways of achieving the same thing, and
    this is quite common when you are living in the Spring ecosystem. Depending on
    the components that are used, whether it's a plain Spring JDBC, Spring JPA with
    Hibernate, or the Flyway or Liquibase migrations, the approach of populating and
    initializing the database differs but the end result remains pretty much the same.
  prefs: []
  type: TYPE_NORMAL
- en: Both Flyway and Liquibase are frameworks that provide incremental database migration
    capabilities. This comes in very handy when one wants to maintain the incremental
    log of the database changes in a programmatic, describable fashion with the ability
    to quickly put the database in a desired state for a particular version. While
    these frameworks differ in their approach in terms of providing such support,
    they are similar in their purpose. More detailed information can be obtained at
    their respective sites, [http://flywaydb.org](http://flywaydb.org) and [http://www.liquibase.org](http://www.liquibase.org).
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding example, we explored two different ways of populating and initializing
    the database.
  prefs: []
  type: TYPE_NORMAL
- en: Initializing the database with Spring JPA and Hibernate
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this approach, most of the work is actually done by the `Hibernate` library
    and we merely set up the appropriate configurations and create conventionally
    expected files that are needed for Hibernate to do the work:'
  prefs: []
  type: TYPE_NORMAL
- en: The `spring.jpa.hibernate.ddl-auto=create-drop` setting instructs Hibernate
    to use the `@Entity` models and, based on their structure, automatically deduces
    the database schema. Upon starting the application, the calculated schema will
    be used to preinitialize the database table structure; when the application is
    shut down, it will all be destroyed. Even in the event that the application was
    forcefully terminated or it abruptly crashed, upon startup, if the existing tables
    are detected, they will be dropped and recreated from scratch. So it's probably
    not a good idea to rely on this for a production environment.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the `spring.jpa.hibernate.ddl-auto` property is not explicitly configured,
    Spring Boot uses create-drop for embedded databases such as H2 by default, so
    be careful and set it appropriately.
  prefs: []
  type: TYPE_NORMAL
- en: Hibernate expects that the `import.sql` file is residing in the root of the
    classpath. This is used to execute the declared SQL statements upon application
    startup. While any valid SQL statement can go in the file, it is recommended that
    you put in the data-importing statements such as `INSERT` or `UPDATE` and steer
    clear of table structure mutations, as the schema definition is already taken
    care of by Hibernate.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Initializing the database with Spring JDBC
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If the application does not use JPA, or you don''t want to depend on the Hibernate
    functionality explicitly, Spring offers you another way of getting the database
    set up, as long as the `spring-boot-starter-jdbc` dependency is present. So let''s
    take a look at what we did to get it to work, as shown in the following list:'
  prefs: []
  type: TYPE_NORMAL
- en: The `spring.jpa.hibernate.ddl-auto=none` setting tells Hibernate not to do any
    automatic handling of the database if the Hibernate dependency also exists, as
    it does in our case. This setting is good practice for a production environment
    as you probably don't want to get all of your database tables wiped clean inadvertently.
    That would be one hell of a disaster, that's for sure!
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `schema.sql` file is expected to exist in the root of the classpath. It
    is executed by Spring during the schema creation of the database upon every startup
    of the application. However, unlike Hibernate, this will not drop any of the existing
    tables automatically, so it might be a good idea to either use `DROP TABLE IF
    EXISTS` to delete an existing table before creating the new one, or use `CREATE
    TABLE IF NOT EXISTS` as part of the table creation SQL if you only want to create
    new tables when they don't already exist. This makes it a lot more flexible to
    declare the database structure evolution logic, thus making it safer to be used
    in production as well.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `data.sql` file is expected to exist in the root of the classpath. This
    is used to execute the data population SQL, so this is where all the `INSERT INTO`
    statements go.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Given that this is a Spring native functionality, we will also get the ability
    to define the schema and data files not only globally, but also as per the specific
    database platform. For example, we can have one set of files that we can use for
    Oracle, `schema-oracle.sql`, and a different one for MySQL, `schema-mysql.sql`.
    The same applies to the `data.sql` variants as well; however, they don't have
    to be defined per platform, so while you might have platform-specific schema files,
    there could be a shared data file. The `spring.datasource.platform` configuration
    value can be explicitly set if you want to override Spring Boot's automatically
    deduced value.
  prefs: []
  type: TYPE_NORMAL
- en: In case one wants to override the default names of `schema.sql` and `data.sql`,
    Spring Boot provides the configuration properties, which we can use to control
    `spring.datasource.schema` and `spring.datasource.data`.
  prefs: []
  type: TYPE_NORMAL
- en: Creating tests using an in-memory database
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous recipe, we explored how to get our databases set up with the
    desired tables and populated with the required data. When it comes to testing,
    one of the typical challenges is to get the environment set up correctly and predictably
    so that when the tests are executed, we can safely assert the behavior in a deterministic
    fashion. In an application that connects to a database, making sure that the database
    contains a deterministic dataset on which the assertions can be evaluated is extremely
    important. For an elaborate test suite, it is also necessary to be able to refresh
    or change that dataset based on the tests. Thankfully, Spring has some nice facilities
    that aid you in accomplishing this task.
  prefs: []
  type: TYPE_NORMAL
- en: We will pick up from the state of our `BookPub` application as we left it in
    the previous recipe. At this point, we have the `schema.sql` file defining all
    the tables, and we also need the database with some starting data that is defined
    in `data.sql`. In this recipe, we will extend our tests to use the specific data
    fixture files that are tailored to a particular test suite.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our first step will be to create a `resources` directory in the `src/test` directory
    at the root of our project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In this directory, we will start placing our fixture SQL data files. Let''s
    create a new file named `test-data.sql` in the resources directory with the following
    content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'We now need a way to load this file when our test runs. We will modify our
    `BookPubApplicationTests` class in the following way:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Execute the tests by running `./gradlew clean test`, and they should continue
    to get passed despite us adding another book and its author to the database.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We can also use the method of populating the database that we learned in the
    previous recipe. As the test code has its own `resources` directory, it is possible
    to add another `data.sql` file to it, and Spring Boot will use both the files
    to populate the database. Let''s go ahead and create the `data.sql` file in the
    `src/test/resources` directory at the root of our project with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: As Spring Boot collects all the occurrences of the data filesfrom the classpath, it
    is possible to place the data files in JARs or different physical locations that
    all end up being at the root of the classpath. It is also important to remember
    that the loading order of these scripts is not deterministic, and if you rely
    on certain referential IDs, it is better if you use selects to get them instead
    of making assumptions.
  prefs: []
  type: TYPE_NORMAL
- en: 'As we added another book to the database and we now have three of them, we
    should fix the assertion in our `contextLoads()` test method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Execute the tests by running `./gradlew clean test` and they should continue
    to get passed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'It would be a fair statement to say that when running unit tests, an in-memory
    database is probably more suitable for the role than a persistent one. Let''s
    create a dedicated test configuration instance of the `application.properties`
    file in the `src/test/resources` directory at the root of our project with the
    following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: It is important to know that Spring Boot loads only one `application.properties`
    file from the classpath. When we created another `application.properties` in `src/test/resources`,
    the previous one from `src/main/resources` was no longer loaded and thus none
    of the properties defined in it were merged in the environment. For this reason,
    you should configure all of the property values that are required. In our case,
    we had to redefine the `spring.jpa.hibernate.dll-auto` property, even though it
    was already declared in the `src/main/resources/application.properties` location.
  prefs: []
  type: TYPE_NORMAL
- en: Execute the tests by running `./gradlew clean test` and the tests should continue
    to get passed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we relied on the facility that is provided by Spring to initialize
    and populate the database in order to get our database populated with the data
    required to run the tests and assert on them. However, we also wanted to be able
    to use some data that was only relevant to a particular test suite. For this,
    we turned to the `ResourceDatabasePopulator` and `DatabasePopulatorUtils` classes
    to insert the desired data right before the test got executed. These are exactly
    the same classes that are used internally by Spring in order to handle the `schema.sql`
    and `data.sql` files, except now, we are explicitly defining the script files
    that we want to execute.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, let''s break up what we did step by step, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: We created a setup method named `loadDataFixtures()`, which we annotated with
    a `@Before` annotation to tell JUnit to run it before every test.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this method, we obtained a resource handle to the `classpath:/test-data.sql`
    data file that resides in our application's classpath and where we store our test
    data and execute it against `@Autowired DataSource ds`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As Spring can only autowire dependencies in the instances of the class, and
    the `@Before` annotated setup methods get executed for every test, we had to get
    a little creative in order to avoid repopulating our database with the duplicate
    data for every test instead of once per test suite/class. To achieve this, we
    created a `static boolean loadDataFixtures` variable that retained its state for
    every instance of the `BookPubApplicationTests` class, thus ensuring that we executed `DatabasePopulatorUtils`
    only once. The reason that the variable has to be static is as a new instance
    of the test class gets created for every test method that it runs in the class;
    having the `boolean` flag at the instance level will not do the trick.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Alternatively, we could have used the `@Sql` annotation instead of the `loadDataFixtures()`
    method and marked our `BookPubApplicationTests` class as `@Transactional` to make
    sure that the `test-data.sql` file got populated before every test method was
    run. Then we could have rolled back to the pre-execution state of the database.
  prefs: []
  type: TYPE_NORMAL
- en: This makes test setup a bit simpler and the transactional part allows for having
    tests that mutate the data in the database without worrying about race conditions,
    but this has the downside of executing the SQL population before every test, which
    adds a bit of extra latency.
  prefs: []
  type: TYPE_NORMAL
- en: 'To make this work, we need to remove the `loadDataFixtures()` method and add
    the following annotations to the `BookPubApplicationTests` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: For the finishing touch, we decided to have a separate `application.properties`
    file to be used for testing purposes. We added this to our `src/test/resources`
    classpath with a testing configuration of the in-memory database instead of using
    the file-based persistent one.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unlike `application.properties`, where only one file can be loaded from the
    classpath, Spring supports a number of profile configurations which will be merged
    together. So, instead of declaring a completely separate `application.properties`
    file, we could create an `application-test.properties` file and set an active
    profile to test while running the tests.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating tests using mock objects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous recipe, we used a data fixture file to populate an in-memory
    database in order to run our tests on predictable and static sets of data. While
    this makes the tests consistent and deterministic, we are still paying the price
    of having to create a database, populate it with data, and initialize all the
    JPA and connectivity components, which could be viewed as an excessive step for
    a test. Luckily, Spring Boot provides internal support for being able to mock
    beans and inject them as components in the tests for setup and further use as
    dependencies within an application context.
  prefs: []
  type: TYPE_NORMAL
- en: Let's examine how we can use the power of Mockito so that we don't need to rely
    on the database at all. We will learn how to elegantly mock the `Repository` instance
    objects using the Mockito framework and some `@MockBean` annotation cleverness.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'First, we will create a new `MockPublisherRepositoryTests` test class in the
    `src/test/java/com/example/bookpub` directory at the root of our project with
    the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Execute the tests by running `./gradlew clean test` and the tests should get
    passed
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are a few magical things happening here. Let''s start with the annotations
    that we put into the `MockPublisherRepositoryTests` class:'
  prefs: []
  type: TYPE_NORMAL
- en: The `@SpringBootTest` annotation's `webEnvironment` attribute was replaced with
    `WebEnvironment.NONE`. This is to inform Spring Boot that we don't want a full
    application web server to be initialized for this test, since we will only be
    interacting with the repository object, without making calls to controllers or
    using any part of the WebMvc stack. We did this to save test startup time, and
    if one is curious to see the difference, just simply switching it back to the `WebEnvironment.RANDOM_PORT`
    value and rerunning the test would show that the time has almost doubled. (On
    my beefy MacBook Pro, it increased from 5 seconds to almost 9.)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'With the application changes examined, let''s now look at what we did in the
    `MockPublisherRepositoryTests` class itself:'
  prefs: []
  type: TYPE_NORMAL
- en: The `@MockBean` annotation instructs Spring that this dependency is not a real
    instance, but a `mock` object currently backed by the Mockito framework. This
    has an interesting effect in that it actually replaces our `PublisherRepository`
    bean instance in the context with the mock one, so, everywhere within the context,
    all dependencies for `PublisherRepository` get wired with the mocked version instead
    of a real, database-backed one.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now that we know how the mocked instance of `PublisherRepository` gets injected
    into our tests, let''s take a look at the newly-created test setup methods. The
    two methods of particular interest are `setupPublisherRepositoryMock()` and `resetPublisherRepositoryMock()`.
    They are described as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The `setupPublisherRepositoryMock()` method is annotated with `@Before`, which
    tells JUnit to execute this method before running every `@Test` method in the
    class. We will use the Mockito framework in order to configure the behavior of
    our mocked instance. We configure it such, that when the `repository.count()`
    method is called, it will return `5` as a result. The Mockito, Junit, and Hamcrest
    libraries provide us with many convenient DLS-like methods, which we can use to
    define such rules with an English-like, easy-to-read style.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `resetPublisherRepositoryMock()` method is annotated with `@After`, which
    tells JUnit to execute this method after running every `@Test` method in the class.
    At the end of every test, we will need to reset the mocked behavior, so we will
    use the `reset(...)` method call to clear out all of our settings and get the
    mock ready for the next test, which can be used in another test suite altogether.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ideally, there is no need to reset the `mock` object at the end of the test
    run, as each test class gets its own context spawned up, so between test classes
    the instance of a mock is not shared. It is considered good practice to create
    many smaller tests instead of a single large one. There are, however, some use
    cases that warrant resetting the mock when it is being managed by a container
    injection, so I thought it was worth mentioning. For the best practices on using
    `reset(...)`, see [https://github.com/mockito/mockito/wiki/FAQ#can-i-reset-a-mock](https://github.com/mockito/mockito/wiki/FAQ#can-i-reset-a-mock).
  prefs: []
  type: TYPE_NORMAL
- en: Creating a JPA component test
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Most of our previous test examples had to start up the entire application and
    configure all the beans in order to execute. While that is not a big issue for
    our simple application, which has little code, it might prove an expensive and
    lengthy process for some larger, more complex enterprise-grade services. Considering
    that one of the key aspects of having good test coverage is a low execution time,
    we might want to opt out of having to bootstrap the entire application in order
    to test just one component, or *slice*, as Spring Boot refers to it.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will try to create a similar test to our previous `PublisherRepository`
    one, but without starting the entire container and initializing all the beans.
    Conveniently, Spring Boot provides us with the `@DataJpaTest` annotation, which
    we can put on our test class, and it will automatically configure all the components
    necessary for the JPA functionality, but not the entire context. So beans like
    controllers, services, and so on, will be missing. This test is very good at quickly
    testing the validity of entity domain object bindings, to make sure the field
    names, associations, and so on, have been configured correctly.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s create a new `JpaAuthorRepositoryTests` test class in the `src/test/java/com/example/bookpub`
    directory at the root of our project with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Execute the tests by running `./gradlew clean test` and the tests should continue
    to pass
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The key difference from our previous test is the absence of the `@SpringBootTest`
    annotation, which has been replaced with the `@DataJpaTest` annotation. The apparent
    simplicity of the test class itself is possible thanks to the `@DataJpaTest` annotation
    doing the bulk of the declarations and workload to configure the test environment.
    If we look inside the annotation definition, we will see a myriad of different
    internal annotations configuring all the necessary components. The important ones
    are the `@AutoConfigure*` annotations, such as `@AutoConfigureDataJpa` or `@AutoConfigureTestDatabase`.
    Those annotations essentially instruct Spring Boot to import the necessary component
    configurations when bootstrapping the test. For example, in `@DataJpaTest`, only
    `Cache`, `DataJpa`, `TestDatabase`, and `TestEntityManager` components would be
    configured and made available, which significantly reduces the test footprint,
    both memory-wise as well as startup and execution times. The specific configuration
    classes are then loaded, as we've seen before, from the `META-INF/spring.factories`
    descriptors provided by various artifacts.
  prefs: []
  type: TYPE_NORMAL
- en: With the right components initialized, we can take advantage of some preconfigured
    beans, such as `TestEntityManager`, which gives us the ability to interact with
    the test instance of the database, pre-initialize the desired state of its content,
    and manipulate test data. This gives us the guarantee that after each test suite
    is done executing, we will get a clean slate for the next set without the need
    of an explicit cleanup. This makes it easier to write tests, without having to
    worry about the order of execution and potential over stepping of changes from
    test suite to test suite, avoiding the inadvertent dirty state that makes tests
    inconsistent.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a WebMvc component test
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Another one of the collection of `*Test` slices is `@WebMvcTest`, which allows
    us to create tests for the WebMvc part of the application, quickly testing controllers,
    filters, and so on, while providing ability to use `@MockBean` to configure the
    necessary dependencies such as services, data repositories, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: This is another very useful testing slice provided by the Spring Boot Test Framework,
    and we will explore its use in this recipe, taking a look at how we can create
    an Mvc layer test for our `BookController` file, mocking the `BookRepository`
    service with a predefined dataset and making sure the returned JSON document is
    what we would expect based on that data.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'First, we will create a new `WebMvcBookControllerTests` test class in the `src/test/java/com/example/bookpub`
    directory at the root of our project with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Execute the tests by running `./gradlew clean test` and the tests should continue
    to pass
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The functionality of `@WebMvcTest` is very similar to the `@DataJpaTest` annotation
    we have seen in the previous recipe. The difference is really just a set of components
    that get initialized during the test bootstrap. Unlike `@DataJpaTest`, this time
    there are no database components that are provided for us, but instead we get
    the `WebMvc` and `MockMvc` configurations, which bring all the necessary foundations
    for initializing controllers, filters, interceptors, and so on. For that reason,
    we had to add `AuthorRepository` and `PublisherRepository` as mock beans into
    our test code, because otherwise the test would fail to start because Spring Boot
    would be unable to satisfy the bean dependency that the `StartupRunner` class
    has on those two repositories.
  prefs: []
  type: TYPE_NORMAL
- en: Another solution to this problem could be removing the dependency on those two
    repositories from the `StartupRunner` class, since we've commented out the code
    that uses them earlier in this chapter, in the *Configuring database schema and
    populating it* recipe. If that was not possible, I wanted to demonstrate how to
    handle the situation where you have bean dependencies in other classes, unrelated
    directly to the test, but causing startup failures during initialization and execution.
  prefs: []
  type: TYPE_NORMAL
- en: As one can see, unlike our previous recipe test, where we did not use any bean
    mocking since it was testing a lower-layer component without further dependencies,
    this time we need to provide a `BookRepository` mock, which is being used by our
    `BookController` class, the functionality of which we are testing.
  prefs: []
  type: TYPE_NORMAL
- en: We have already seen how to use the `@Before` annotation to preconfigure mock
    objects in the `MockPublisherRepositoryTests` class, so this time we are doing
    the configuration directly in the `webappBookApi` test method, similar to the
    style you will see when we learn about writing tests using the Spock framework.
  prefs: []
  type: TYPE_NORMAL
- en: Inside the `given(...)` call, we pre-configure the behavior of the `BookRepository`
    mock object, instructing it to return a specific `Book` instance when its `findBookByIsbn`
    method gets called with `"978-1-78528-415-1"` as an argument.
  prefs: []
  type: TYPE_NORMAL
- en: Our next call to `mockMvc.perform`with `/books/978-1-78528-415-1` triggers the
    invocation of the `BookController``getBook` method, which delegates the pre-wired
    mocked instance of `bookRepository` and uses our pre-configured `Book` object
    instance to run validation logic upon.
  prefs: []
  type: TYPE_NORMAL
- en: As evident from the log, we can see that only the WebMvc layer has been bootstrapped.
    No database or other components have been initialized, which has resulted in significant
    savings in runtime, taking only 3 seconds compared to the 9 seconds it took for
    a complete application bootstrap test earlier.
  prefs: []
  type: TYPE_NORMAL
- en: Writing tests using Cucumber
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Unit testing has been an expected part of the software development life cycle
    for quite some time now, and one can hardly imagine writing code without having
    unit tests along with it. The art of testing does not stay the same, and advances
    in testing philosophies have extended the concept of unit testing even further,
    introducing things such as service testing, integration testing, and, lastly,
    what is known as BDD that proposes to create the test suites describing the application
    behavior at large without getting down to the minute implementation details at
    the lower levels of the code. One such framework, which has gained a lot of popularity
    first in the Ruby world and later expanding to other languages including Java,
    is the Cucumber BDD.
  prefs: []
  type: TYPE_NORMAL
- en: For the purpose of this recipe, we will pick up on our previous example and
    continue enhancing the testing suite by adding the Cucumber-JVM implementation,
    which will provide us with the Java-based version of the original Ruby Cucumber
    framework, and create a few tests in order to demonstrate the capabilities and
    integration points with the Spring Boot application.
  prefs: []
  type: TYPE_NORMAL
- en: This recipe is by no means intended to cover the entire set of functionalities
    provided by the Cucumber testing framework and is mostly focused on the integration
    points of Cucumber and Spring Boot. To learn more about Cucumber-JVM, you can
    go to [https://cukes.info/docs#cucumber-implementations](https://cukes.info/docs#cucumber-implementations)
    or [https://github.com/cucumber/cucumber-jvm](https://github.com/cucumber/cucumber-jvm)
    for details.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The first thing that we need to do is add the necessary dependencies for the
    Cucumber libraries to our `build.gradle` file, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we will need to create a test driver class to run Cucumber tests. Let''s
    create a `RunCukeTests.java` file in the `src/test/java/com/example/bookpub` directory
    at the root of our project with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'With the driver class created, we are ready to start writing what Cucumber
    refers to as Step Definitions. I will talk briefly about what these are in the
    *How it works...* section of this recipe. For now, let''s create a `RepositoryStepdefs.java`
    file in the `src/test/java/com/example/bookpub` directory at the root of our project
    with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we will need to create a corresponding testing feature definition file
    named `repositories.feature` in the `src/test/resources/com/example/bookpub` directory
    at the root of our project with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Lastly, we will create one more data SQL file named `packt-books.sql` in the
    `src/test/resources` directory at the root of our project with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Execute the tests by running `./gradlew clean test` and the tests should get
    passed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: With the addition of Cucumber, we also get the results of the tests in both
    the JUnit report and Cucumber-specific report HTML files. If we open `build/reports/tests/index.html`
    in the browser and click on the Classes button, we will see our scenario in the
    table, as shown in the following screenshot:![](img/2f667267-e14b-457e-9ecc-f67e44bbc81e.png)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Selecting the Scenario: Load one book link will take us to the detailed report
    page, as shown in the following screenshot:![](img/eb744c2f-eb47-4d40-a585-809d15dfc6c8.png)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: As we can see, the descriptions are nicer than the class and method names that
    we saw in the original JUnit-based test cases.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Cucumber also generates its own report, which can be viewed by opening `build/reports/cucumber/index.html`
    in the browser.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Being a behavior-driven testing framework, the feature files allow us not only
    to define individual conditions, but also to declare entire scenario outlines,
    which make the defining of multiple assertions of similar data easier. Let''s
    create another feature file named `restful.feature` in the `src/test/resources/com/example/bookpub`
    directory at the root of our project with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'We will also create a corresponding `RestfulStepdefs.java` file in the `src/test/java/com/example/bookpub`
    directory at the root of our project with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Execute the tests by running `./gradlew clean test` and the tests should continue
    to get passed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you feel a bit lost after looking at all this code and following along without
    having a full understanding of what exactly is going on, here you will find a
    detailed breakdown of everything that we did.
  prefs: []
  type: TYPE_NORMAL
- en: Let's start with a quick overview of what **Step Definitions** are. As the Cucumber
    framework uses the **Gherkin** feature document files in order to describe the
    business rules that are to be tested, which are represented in the form of English-like
    sentence statements, these need to be translated into executable code. This is
    the job of the Step Definition classes. Every step in a defined feature scenario
    needs to be matched to a method in a Step Definition class that will execute it.
    This matching is done by declaring a regular expression in the step annotations
    above the methods. The regex contains the matching groups that Cucumber uses so
    as to extract the method arguments and pass them to the executing method.
  prefs: []
  type: TYPE_NORMAL
- en: 'In `RepositoryStepdefs`, we can see this in the following method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: The `@Given` annotation contains the regular expression that matches the `Given
    packt-books fixture is loaded` text, loaded from `repositories.feature` file,
    and extracts the `packt-books` text from the pattern, which is then passed as
    a `fixtureName` argument to the method. The `@When` and `@Then` annotations work
    on exactly the same principle. So, in effect, what the Cucumber framework does
    is it matches the English-like worded rules from the feature files to the matched
    patterns of the executing methods and extracts parts of the rules as arguments
    to the matched methods.
  prefs: []
  type: TYPE_NORMAL
- en: More information on Gherkin and how to use it can be found at [https://cukes.info/docs/reference#gherkin](https://cukes.info/docs/reference#gherkin).
  prefs: []
  type: TYPE_NORMAL
- en: With the basic Cucumber overview explained, let's shift our focus to how the
    tests integrate with Spring Boot and are configured.
  prefs: []
  type: TYPE_NORMAL
- en: 'It all starts with the driver harness class, which in our case is `RunCukeTests`.
    This class itself does not contain any tests, but it has two important annotations
    that stitch things together, `@RunWith(Cucumber.class)` and `@CucumberOptions`:'
  prefs: []
  type: TYPE_NORMAL
- en: '`@RunWith(Cucumber.class)`: This is a JUnit annotation that indicates that
    JUnit runner should use the Cucumber feature files to execute the tests.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@CucumberOptions`: This provides additional configuration for Cucumber:'
  prefs: []
  type: TYPE_NORMAL
- en: '`plugin={"pretty", "html:build/reports/cucumber"}`: This tells Cucumber to
    generate its reports in HTML format in the `build/reports/cucumber` directory.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`glue = {"cucumber.api.spring", "classpath:com.example.bookpub"}`: This is
    a very important setting, as it tells Cucumber which packages to load and from
    where to load them during the execution of the tests. The `cucumber.api.spring`
    package needs to be present in order to take advantage of the `cucumber-spring`
    integration library, and the `com.example.bookpub` package is the location of
    our Step Definition implementation classes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`monochrome = true`: This tells Cucumber not to print the output with the ANSI
    color as we integrate with JUnit, as it will not look correct in the saved console
    output files.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A complete list of the options can be found at [https://cukes.info/docs/reference/jvm#list-all-options](https://cukes.info/docs/reference/jvm#list-all-options).
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let''s look at the `RepositoryStepdefs` class. It starts with the following
    annotations at the class level:'
  prefs: []
  type: TYPE_NORMAL
- en: '`@WebAppConfiguration` instructs Spring that this class needs `WebApplicationContext` to
    be initialized, and it will be used for testing purposes during the execution'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@ContextConfiguration(classes = BookPubApplication.class` and `loader = SpringBootContextLoader.class)`
    instruct Spring to use the `BookPubApplication` class as a configuration for the
    Spring application context, as well as to use the `SpringBootContextLoader` class
    from Spring Boot in order to bootstrap the testing harness'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is important to note that these annotations have to match  all the Step Definition
    classes, or only one of the classes will be annotated with the `@ContextConfiguration`
    annotation to wire in the Spring support for the Cucumber test.
  prefs: []
  type: TYPE_NORMAL
- en: As the `cucumber-spring` integration does not know about Spring Boot but only
    about Spring, we can't use the `@SpringBootTest` meta-annotation. We have to resort
    to using only the annotations from Spring in order to stitch things together.
    Thankfully, we don't have to go through many hoops, but just declare the exact
    annotation that `SpringBootTest` facades by passing the desired configuration
    classes and loader.
  prefs: []
  type: TYPE_NORMAL
- en: Once the proper annotations are in place, Spring and Spring Boot will take over
    and provide us with the same convenience of autowiring beans as dependencies of
    our Step Definition classes.
  prefs: []
  type: TYPE_NORMAL
- en: One interesting characteristic of the Cucumber tests is the instantiation of
    a new instance of the Step Definition class for every execution of a **Scenario**.
    Even though the method namespace is global—meaning that we can use the methods
    that are declared in the different Step Definition classes—they operate on states
    defined in them and are not directly shared. It is, however, possible to `@Autowire`
    an instance of another Step Definition in a different Step Definition instance
    and rely on public methods or fields to access and mutate the data.
  prefs: []
  type: TYPE_NORMAL
- en: As a new instance gets created per scenario, the definition classes are stateful
    and rely on internal variables to keep a state among transitions from assertion
    to assertion. For example, in the `@When` annotated method, a particular state
    gets set, and in the `@Then` annotated method, a set of assertions on that state
    get evaluated. In our example of the `RepositoryStepdefs` class, we will internally
    set the state of the `loadedBook` class variable in its `searching_for_book_by_isbn(...)` method,
    which later gets used to assert on so as to verify the match of the book's title
    in the `book_title_will_be(...)` method afterwards. Due to this, if we mix the
    rules from the different definition classes in our feature files, the internal
    states would not be accessible among the multiple classes.
  prefs: []
  type: TYPE_NORMAL
- en: When integrating with Spring, one can use the injection of the mocked objects—as
    we have seen in `MockPublisherRepositoryTests` from one of our previous examples—and
    can have the shared `@Given` annotated method be used to set up the particular
    behavior of the mock for the given test. Then we can use the same dependency instance
    and inject it into another definition class that can be used in order to evaluate
    the `@Then` annotated assertion methods.
  prefs: []
  type: TYPE_NORMAL
- en: Another approach is the one that we saw in the second definition class, `RestfulStepdefs`,
    where we injected `BookRepository`. However, in `restful.feature`, we will be
    using the `Given packt-books fixture is loaded` behavior declaration that translates
    to the invocation of `data_fixture_is_loaded` method from the `RepositoryStepdefs` class,
    which shares the same instance of the injected `BookRepository` object, inserting
    the `packt-books.sql` data into it.
  prefs: []
  type: TYPE_NORMAL
- en: If we were to have a need to access the value of the `loadedBook` field from
    the `RepositoryStepdefs` instance inside the `RestfulStepdefs` class, we could
    declare the `@Autowired RepositoryStepdefs` field inside `RestfulStepdefs` and
    make the `loadedBook` field `public` instead of `private` to make it accessible
    to the outside world.
  prefs: []
  type: TYPE_NORMAL
- en: Another neat feature of the Cucumber and Spring integration is the use of the
    `@txn` annotation in the feature files. This tells Spring to execute the tests
    in a transaction wrapper, reset the database between the test executions, and
    guarantee a clean database state for every test.
  prefs: []
  type: TYPE_NORMAL
- en: Due to the global method namespace among all the Step Definition classes and
    test behavior defining feature files, we can use the power of Spring injection
    to our advantage so as to reuse the testing models and have a common setup logic
    for all of the tests. This makes the tests behave similarly to how our application
    would function in a real production environment.
  prefs: []
  type: TYPE_NORMAL
- en: Writing tests using Spock
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Another no-less-popular testing framework is Spock, which was written in Groovy
    by Peter Niederwieser. Being a Groovy-based framework, it is ideally suited to
    create testing suites for a majority of the JVM-based languages, especially for
    Java and Groovy itself. The dynamic language traits of Groovy make it well suited
    to write elegant, efficient, and expressive specifications in the Groovy language
    without the need for translations. It is done in Cucumber with the help of the
    Gherkin library. Being based on top of JUnit, and integrating with it through
    the JUnit's `@RunWith` facility, just like Cucumber does, it is an easy enhancement
    to the traditional unit tests and works well with all the existing tools, which
    have built-in support or integration with JUnit.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will pick up from where the previous recipe left off and
    enhance our test collection with a couple of Spock-based tests. In these tests,
    we will see how to set up MockMVC using the Spring dependency injection and testing
    harnesses. These will be used by the Spock test specifications in order to validate
    the fact that our data repository services will return the data as expected.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In order to add the Spock tests to our application, we will need to make a
    few changes to our `build.gradle` file first. As Spock tests are written in Groovy,
    the first thing to do is add a `groovy` plugin to our `build.gradle` file, as
    follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'We will also need to add the necessary Spock framework dependencies to the
    `build.gradle` dependencies block:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: As the tests will be in Groovy, we will need to create a new source directory
    for the files. Let's create the `src/test/groovy/com/example/bookpub` directory
    in the root of our project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now we are ready to write our first test. Create a `SpockBookRepositorySpecification.groovy`
    file in the `src/test/groovy/com/example/bookpub` directory at the root of our
    project with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Execute the tests by running `./gradlew clean test` and the tests should get
    passed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'As Spock integrates with JUnit, we can see the execution report of the Spock
    tests together with the rest of our test suite. If we open `build/reports/tests/index.html`
    in the browser and click the Classes button, we will see our specification in
    the table, as shown in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/a534256a-f4a6-4297-995e-5e37da0f0deb.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Selecting the com.example.bookpub.SpockBookRespositorySpecification link will
    take us to the detailed report page, which is as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/a2d3fda6-0523-4366-a865-e45b874fdb76.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Next, we will take our tests a bit further and explore the mocking functionality
    of the database repositories. Let''s use `PublisherRepository` as our candidate
    to mock, and wire it into the `BookController` class to provide a `getBooksByPublisher`
    functionality. Let''s add the following content to the `BookController` class
    in the `src/main/java/com/example/bookpub/controllers` directory at the root of
    our project:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s add the following to the `Publisher` class in the `src/main/java/com/example/bookpub/entity`
    directory at the root of our project:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Lastly, let''s add a getter and setter for the books to the `Publisher` entity
    class as well:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'With all the code additions completed, we are ready to add another test to
    the `SpockBookRepositorySpecification.groovy` file in the `src/test/groovy/com/example/bookpub`
    directory at the root of our project with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Execute the tests by running `./gradlew clean test` and the tests should continue
    to get passed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As you saw from this example, writing tests can be just as elaborate and sophisticated
    as the production code being tested itself. Let's examine the steps that we took
    in order to get the Spock tests integrated into our Spring Boot application.
  prefs: []
  type: TYPE_NORMAL
- en: The first thing that we did was to add a Groovy plugin in order to make our
    build Groovy-friendly, and we also added the required Spock library dependencies
    of `spock-core` and `spock-spring`, both of which are required to make Spock work
    with Spring's dependency injection and contexts.
  prefs: []
  type: TYPE_NORMAL
- en: The next step was to create the `SpockBookRepositorySpecification` Spock specification,
    which extends the Spock's specification abstract base class. Extending the `Specification`
    class is very important because this is how JUnit knows that our class is the
    test class that needs to be executed. If we look in the `Specification` source,
    we will see the `@RunWith(Sputnik.class)` annotation, just like the one that we
    used in the Cucumber recipe. In addition to the JUnit bootstrapping, the `Specification`
    class provides us with many helpful methods and mocking support as well.
  prefs: []
  type: TYPE_NORMAL
- en: For more information about the detailed capabilities that are offered by Spock,
    you can refer to the Spock documentation that is available at [http://spockframework.github.io/spock/docs/current/index.html](http://spockframework.github.io/spock/docs/current/index.html).
  prefs: []
  type: TYPE_NORMAL
- en: 'It is also worth mentioning that we used the same annotations for the `SpockBookRepositorySpecification`
    class as we did for our Spring Boot-based tests, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: The reason that we had to add `@AutoConfigureMockMvc` in addition to `@SpringBootTest`
    is to add functionality to allow us to use the `@Autowire MockMvc` instance instead
    of having to create one ourselves. Regular `@SpringBootTest` does not automatically
    create and configure an instance of a `MockMvc` object, so we could have either
    created it manually, as we did in `BookPubApplicationTests`, or added the `@AutoConfigureMockMvc`
    annotation, which is what gets used inside `@WebMvcTest`, to let Spring handle
    it for us. The good news is that we can always use the same annotation compositions
    as used by Spring Boot, and annotate our classes directly, which is exactly what
    we did.
  prefs: []
  type: TYPE_NORMAL
- en: 'Unlike Cucumber, Spock combines all the aspects of the test in one `Specification`
    class, dividing it into multiple blocks, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`setup`: This block is used to configure the specific test with variables,
    populating data, building mocks, and so on.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`expect`: This block is one of the stimulus blocks, as Spock defines it, designed
    to contain simple expressions asserting a state or condition. Besides evaluating
    the conditions, we can only define variables in this block, and nothing else is
    allowed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`when`: This block is another stimulus type block, which always goes together
    with `then`. It can contain any arbitrary code and is designed to define the behavior
    that we are trying to test.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`then`: This block is a response type block. It is similar to `expect` and
    can only contain conditions, exception checking, variable definition, and object
    interactions, such as how many times a particular method has been called and so
    forth.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: More information on interaction testing is available on Spock's website at [http://spockframework.github.io/spock/docs/current/interaction_based_testing.html](http://spockframework.org/spock/docs/1.0/interaction_based_testing.html).
  prefs: []
  type: TYPE_NORMAL
- en: '`cleanup`: This block is used to clean the state of the environment and potentially
    undo whatever changes were done as part of the individual test execution. In our
    recipe, this is where we will reset our `PublisherRepository` mock object.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Spock provides us with the instance-based `setup()` and `cleanup()` methods
    as well, which can be used to define the setup and cleanup behavior that is common
    to all the tests in the specification.
  prefs: []
  type: TYPE_NORMAL
- en: If we look at our `setup()` method, this is where we can configure the database
    population with the test data. An interesting and important nuance is that the `setup()`
    method gets executed before every test method, not once per class. It is important
    to keep that in mind when doing things like populating a database to avoid re-insertion
    of the same data multiple times without proper rollback.
  prefs: []
  type: TYPE_NORMAL
- en: To help us with that is the `@Transactional` annotation of the test methods.
    Just like the `@txn` tag in the Cucumber feature files, this annotation instructs
    Spock to execute the annotated method and its corresponding `setup()` and `cleanup()`
    executions with a transaction scope, which get rolled back after the particular
    test method is finished. We rely on this behavior to get a clean database state
    for every test, so we don't end up inserting duplicate data during the execution
    of the `setup()` method every time each of our tests runs.
  prefs: []
  type: TYPE_NORMAL
- en: Most of you are probably wondering why we had to add the `@JsonBackReference`
    annotation to our `Publisher` entity class. The answer has to do with the Jackson
    JSON parser and how it handles circular dependency. In our model, we have a book
    belonging to a publisher and each publisher has multiple books. When we created
    our `Publisher` class with the `Books` mock and assigned a publisher instance
    to a book—which later got put in the publisher's book collection—we created a
    circular reference. During the execution of the `BookController.getBooksByPublisher(...)`
    method, the Jackson renderer would have thrown `StackOverflowError` while trying
    to write the object model to JSON. By adding this annotation to `Publisher`, we
    told Jackson how the objects reference each other, so instead of trying to write
    out the complete object tree, Jackson now handles it correctly, thus avoiding
    the circular reference loop situation.
  prefs: []
  type: TYPE_NORMAL
- en: The last thing that is important to keep in mind is how Spring Boot handles
    and processes the repository interfaces that are annotated with `@RepositoryRestResource`.
    Unlike the `BookRepository` interface, which we have annotated with a plain `@Repository`
    annotation and later explicitly declared as an autowire dependency of our `BookController`
    class, we did not create an explicit controller to handle RESTful requests for
    the rest of our repository interfaces such as `PublisherRepository` and others.
    These interfaces get scanned by Spring Boot and automatically wrapped with the
    mapped endpoints that trap the requests and delegate the calls to the backing
    `SimpleJpaRepository` proxy. Due to this setup, we can use only the mock object
    replacement approach for these objects that have been explicitly injected as bean
    dependencies such as with our example of `BookRepository`. The good news is that
    in these situations, where we don't explicitly expect beans to be wired and only
    use some annotations to stereotype the interfaces for Spring Boot to do its magic,
    we can rely on Spring Boot to do the job correctly. We know that it has tested
    all the functionalities behind it so that we don't have to test them. To test
    the actual repository and entity functionality, we can use the `@DataJpaTest`
    annotation to do a specific JPA slice test instead.
  prefs: []
  type: TYPE_NORMAL
