["```java\nimport greenfoot.*;\nimport java.util.List;\nimport java.util.Stack;\n\npublic class MazeWorld extends World {\n  private int xOffset = 0;\n  private Hiker hiker;\n  private final static int SWIDTH = 600;\n  private final static int SHEIGHT = 400;\n  private final static int WWIDTH = 1200;\n  private final static int TWIDTH = 25;\n  private final static int THEIGHT = TWIDTH;\n  private final static int TILEOFFSET = TWIDTH/2;\n  private final static String validSpaces = \"WG\";\n\n  private final static String[] WORLD = {\n    \"BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB\",\n    \"BWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWUWWWWB\",\n    \"BWWWWWWWWWWWWWUUWWWWWWWWUUUUUUUWWWWWWWWWWWUWWWWB\",\n    \"BWWWWWUUUUUWWWUUUWWWWWWWWWWWWWWWWWWWWWWWWWUWWWWB\",\n    \"BWWWWWUUUUUWWWWWWWWWWWWWWWWWWWWWWWWWUWWWWUUUWWWB\",\n    \"BWWWWWWWWWWWWWWWWWUUUUUWWWWWWWWUUUUUUWWWWWWWWWWB\",\n    \"BWWWWWWWWWWWWWWWWWUUUUWWWWWWWWWUUUUUUUUWWWWWWWWB\",\n    \"BWWWWUUUUUUUWWWUWWWWWWWWWWWWWWWUWWWWWWWWWWWWWWWB\",\n    \"BWWWWWWWUUUWWWWUWWWWWWWWWWUWWWWUWWWWWWWWWWWWWWWB\",\n    \"BWWWWWWWWWWWWWWWWWWWWWWWWWUWWWWWWWWWWWWWWWWWUWWB\",\n    \"BWWWWWWWWWWWWWWWWWWWUUUUUUUWWWWWWWWWUUUUWWWWUWWB\",\n    \"BWWWWWWWWWWWWWUUWWWWUWWWWWWWWWWWWWWWUUUUWWWWUWWB\",\n    \"BWWWWWWWUUUUUUUUUWWWWWWWWWWWWWWWWWWWUUUUUUWWUWWB\",\n    \"BWWWWWWWUUUUUUUUUWWWWWWWWWUUWWWWWWWWWWWWWWWWUWWB\",\n    \"BWWWWWWWUWWWWWWWWWWWWWWWWWUUWWWWWWWWWWWWWWWWUWGB\",\n    \"BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB\"\n  };\n\n  public MazeWorld() {  \n    super(SWIDTH, SHEIGHT, 1, false); \n    createWorldFromTiles();\n    shiftWorld(0);    \n    prepare();\n  }\n\n  public void shiftWorld(int dx) {\n    if( (xOffset + dx) <= 0 && (xOffset + dx) >= SWIDTH - WWIDTH) {\n      xOffset = xOffset+dx;\n      shiftWorldActors(dx);\n    }\n  }\n\nprivate void shiftWorldActors(int dx) {\n    List<ScrollingActor> saList = getObjects(ScrollingActor.class);\n    for( ScrollingActor a : saList ) {\n      a.setAbsoluteLocation(dx);\n    }\n  }\n\n  private void createWorldFromTiles() {\n    for( int i=0; i < WORLD.length; i++ ) {\n      for( int j=0; j < WORLD[i].length(); j++ ) {\n        addActorAtTileLocation(WORLD[i].charAt(j), j, i);\n      }\n    }\n  }\n\n  private void addActorAtTileLocation(char c, int x, int y) {\n    Actor tile = null;\n    switch(c) {\n      case 'W':\n        tile = new WhiteBlock();\n        break;\n      case 'B':\n        tile = new BlackBlock();\n        break;\n      case 'U':\n        tile = new BlueBlock();\n        break;\n      case 'G':\n        tile = new GoldBlock();\n        break;\n    }\n    if( tile != null) addObject(tile, TILEOFFSET+x*TWIDTH, TILEOFFSET+y*THEIGHT);\n\n  }\n\n public int getTileWidth() {\n    return TWIDTH;\n  }\n\n  public int getTileHeight() {\n    return THEIGHT;\n  }\n\n  public int getTileOffset() {\n    return TILEOFFSET;\n  }\n\n  public String[] getStringWorld() {\n    return WORLD;\n  }\n\n  public int getXHiker() {\n    return hiker.getX()-xOffset;\n  }\n\n  public int getYHiker() {\n    return hiker.getY();\n  }\n\n  public String getValidSpaces() {\n    return validSpaces;\n  }\n\n  private void prepare()\n  {\n    hiker = new Hiker();\n    addObject(hiker, 80, 200);\n    addObject(new Mouse(), 60,40);\n    addObject(new Spider(), 1000,40);\n    addObject(new Spider(), 120,340);\n    addObject(new Spider(), 1050,250);\n    addObject(new Snake(), 1050,250);\n    addObject(new Mouse(), 1000,200);\n    addObject(new Snake(), 400,260);\n  }\n}\n```", "```java\nimport greenfoot.*;\n\npublic class Hiker extends Actor\n{\n  private static final int SPEED = 2;\n  private static final int BOUNDARY = 40;\n  private int speedX = SPEED;\n  private int speedY = SPEED;\n\n  public void act() {\n    handleKeyPresses();\n    handleCollisions();\n    boundedMove();\n  }\n\n  private void handleKeyPresses() {\n    handleArrowKey(\"left\", -SPEED, 0);\n    handleArrowKey(\"right\", SPEED, 0);\n    handleArrowKey(\"up\", 0, -SPEED);\n    handleArrowKey(\"down\", 0, SPEED);\n  }\n\n  private void handleArrowKey(String k, int sX, int sY) {\n    if( Greenfoot.isKeyDown(k) ) {\n      speedX = sX;\n      speedY = sY;\n    }\n  }\n\n  private void handleCollisions() {\n    if( isTouching(ScrollingEnemy.class) ) {\n      Greenfoot.stop(); // Game Over\n    }\n  }\n\n  private void boundedMove() {\n    setLocation(getX()+speedX, getY()+speedY);\n    if( isTouching(ScrollingObstacle.class) ) {\n      setLocation(getX()-speedX, getY()-speedY);\n    } else if( isTouching(GoldBlock.class) ) {\n      Greenfoot.stop(); // Game over...you Win!!\n    }else if( getX() > getWorld().getWidth() - BOUNDARY ) {\n      ((MazeWorld)getWorld()).shiftWorld(-speedX);\n      setLocation(getX()-speedX, getY()-speedY);\n    } else if( getX() < BOUNDARY ) {\n      ((MazeWorld)getWorld()).shiftWorld(-speedX);\n      setLocation(getX()-speedX, getY()-speedY);\n    }\n    speedX = 0;\n    speedY = 0;\n  }\n}\n```", "```java\nimport greenfoot.*;\n\npublic class ScrollingActor extends Actor {\n  public void setAbsoluteLocation(int dx) {\n    setLocation(getX()+dx, getY());\n  }\n}\n```", "```java\nimport greenfoot.*;\n\npublic class GoldBlock extends ScrollingActor {\n}\nimport greenfoot.*;\n\npublic class WhiteBlock extends ScrollingActor {\n}\n```", "```java\nimport greenfoot.*;\n\npublic class ScrollingObstacle extends ScrollingActor {\n}\n```", "```java\nimport greenfoot.*;\n\npublic class BlackBlock extends ScrollingObstacle {\n}\nimport greenfoot.*;\n\npublic class BlueBlock extends ScrollingObstacle {\n}\n```", "```java\nimport greenfoot.*;\n\nabstract public class ScrollingEnemy extends ScrollingActor {\n  protected static final int SPEED = 1;\n  private static final int BOUNDARY = 40;\n  protected int speedX = SPEED;\n  protected int speedY = SPEED;\n\n  protected void addedToWorld(World w) {\n    MazeWorld mw = (MazeWorld) w;\n    GreenfootImage img = getImage();\n    img.scale(mw.getTileWidth(),mw.getTileHeight());\n    setImage(img);\n  }\n\n  public void act() {\n    sense();\n    reaction();\n    boundedMove();\n  }\n\n  protected void sense() {\n    // No smarts\n  }\n\n  protected void reaction() {\n    // No reaction\n  }\n\n  protected void boundedMove() {\n    setLocation(getX()+speedX, getY()+speedY);\n    if( isTouching(ScrollingObstacle.class) ) {\n      setLocation(getX()-speedX, getY()-speedY);\n    }\n  }\n}\n```", "```java\nimport greenfoot.*;\n\npublic class Spider extends ScrollingEnemy {\n  private final static int SPEEDVARIATION = 3;\n  private final static int SPEEDCHANGECHANCE = 20;\n\n  protected void reaction() {\n    speedX = Greenfoot.getRandomNumber(1000) < SPEEDCHANGECHANCE ? Greenfoot.getRandomNumber(SPEEDVARIATION)-1 : speedX;\n    speedY = Greenfoot.getRandomNumber(1000) < \tSPEEDCHANGECHANCE ? Greenfoot.getRandomNumber(SPEEDVARIATION)-1 : speedY;\n  }\n}\n```", "```java\nimport greenfoot.*;\nimport java.util.List;\n\npublic class Snake extends ScrollingEnemy {\n  private static final int PATHLENGTH = 200;\n  private static final int INRANGE = 100;\n  private int pathCounter = PATHLENGTH;\n  private boolean pathing = false;\n  private int rememberSpeedX = 0;\n  private List<Hiker> lse;\n\n  public Snake() {\n    speedX = rememberSpeedX = SPEED;\n    speedY = 0;\n  }\n\n  protected void sense() {\n    // If near, move towards enemy\n    lse = getObjectsInRange(INRANGE,Hiker.class);\n    pathing = lse.isEmpty();\n  }\n\n  protected void reaction() {\n    if( pathing ) {\n      speedX = rememberSpeedX;\n      speedY = 0;\n      if( --pathCounter == 0 ) {\n        pathCounter = PATHLENGTH;\n        speedX = rememberSpeedX = -speedX;\n      }\n    } else {\n      speedX = lse.get(0).getX() > getX() ? 1 : -1;\n      speedY = lse.get(0).getY() > getY() ? 1 : -1;\n    }\n  }\n}\n```", "```java\nimport greenfoot.*;\nimport java.util.Stack;\n\npublic class Mouse extends ScrollingEnemy {\n  private TiledWorldPathfinding twp;\n  private Stack<Point> apath;\n  private int walkDelay = -1;\n  private final static int WALKDELAY = 40;\n  private int searchDelay = -1;\n  private final static int SEARCHDELAY = 130;\n  private int prevRow = 0;\n  private int prevCol = 0;\n\n  /* initilization */\n  protected void addedToWorld(World w) {\n    MazeWorld mw = (MazeWorld) w;\n    super.addedToWorld(w);\n    twp = new TiledWorldPathfinding\n    (mw.getStringWorld(),mw.getValidSpaces());\n    prevRow = getY()/mw.getTileWidth();\n    prevCol = getX()/mw.getTileWidth();\n    setLocation(prevCol*mw.getTileWidth()+mw.getTileWidth()/2,\n    prevRow*mw.getTileWidth()+mw.getTileWidth()/2);\n  }\n\n  protected void sense() {\n    // A* pathfinding determines direction\n    if( --searchDelay < 0) {\n      MazeWorld w = (MazeWorld) getWorld();\n      int hikerCol = w.getXHiker()/w.getTileWidth();\n      int hikerRow = w.getYHiker()/w.getTileWidth();\n      apath = twp.findShortestFeasiblePath(new\n      Point(prevRow,prevCol), new Point(hikerRow,hikerCol));\n      if( apath != null && !apath.isEmpty() ) apath.pop();\n      searchDelay = SEARCHDELAY;\n    }\n  }\n\n  protected void reaction() {\n    // Move in direction chosen by A* pathfinding\n    if( --walkDelay < 0 ) {\n      walkDelay = WALKDELAY;\n      if( apath != null && !apath.isEmpty() ) {\n        Point p = apath.pop();\n        MazeWorld w = (MazeWorld) getWorld();\n        speedX = (p.col-prevCol) * w.getTileWidth();\n        speedY = (p.row-prevRow) * w.getTileWidth();\n        prevCol = p.col;\n        prevRow = p.row;\n      }\n    } else {\n      speedX = 0;\n      speedY = 0;\n    }\n  }\n\n}\n```", "```java\nimport java.util.PriorityQueue;\nimport java.util.Queue;\nimport java.util.Stack;\n\npublic class TiledWorldPathfinding {\n  private String []world;\n  private String validSpaces;\n  private int worldColumns;\n  private int worldRows;\n  private Tile[][] tiledWorld;\n\n  public TiledWorldPathfinding(String []w, String vs) {\n    world = w;\n    worldColumns = w[0].length(); // number of columns\n    worldRows = w.length; // number of rows\n    tiledWorld = new Tile[worldRows][worldColumns];\n    validSpaces = vs;\n    resetWorld();\n  }\n\n  public void changeWorld( String []w ) {\n    world = w;\n    resetWorld();\n  }\n\n  public Stack<Point> findShortestFeasiblePath(Point start, Point end) {\n    Queue<Tile> openList = new PriorityQueue<Tile>();\n    Queue<Tile> closedList = new PriorityQueue<Tile>();\n    Stack<Point> answer = new Stack<Point>();\n\n    // Check for trivial case\n    if( start.equals(end) ) {\n      answer.push(start);\n      return answer;\n    }\n\n    // Check that both start and end are walkable\n    if( !tiledWorld[start.row][start.col].isWalkable() ) {\n      return null;\n    }\n    if( !tiledWorld[end.row][end.col].isWalkable() ) {\n      return null;\n    }\n\n    // Mark location of end point\n    tiledWorld[end.row][end.col].setEndNode();\n\n    // Add starting node to open list\n    openList.add(tiledWorld[start.row][start.col]);\n\n    // A* algorithm\n    runAStar(openList, closedList, end);\n\n    // derive the answer area from the marked up TileWorld\n    if( tiledWorld[end.row][end.col].getParent() == null ) {\n      resetWorld();\n      return null;\n    } else {\n      deriveWaypoints(answer, end);\n    }\n\n    // Prepare for next time\n    resetWorld();\n\n    // return result\n    return answer;\n  }\n\n  /* private methods */\n  private void runAStar(Queue<Tile> openList,\n  Queue<Tile> closedList, Point end) {\n    boolean done = false;\n    Tile t;\n\n    while( !openList.isEmpty() && !done ) {\n      t = openList.remove();\n      done = done || processNeighbor(t, t.getUp(), openList, end);\n      done = done || processNeighbor(t, t.getDown(), openList, end);\n      done = done || processNeighbor(t, t.getLeft(), openList, end);\n      done = done || processNeighbor(t, t.getRight(), openList, end);\n      t.setDone();\n      closedList.add(t);\n    }\n  }\n\n  private boolean processNeighbor( Tile parent, Tile node, Queue<Tile> openList, Point end) {\n    boolean retval = false;\n\n    if( node != null && !node.isDone() && node.isWalkable()) {\n      if( node.isEndNode() ) { // Are we done?\n        node.setParent(parent);\n        retval = true; // FOUND THE END NODE\n      } else {\n        node.setParent(parent);\n        node.setG(1 + parent.getG());\n        node.setH(calculateManhattenDistance(\n        node.getPoint(), end));\n        openList.add(node);\n      }\n    }\n    return retval;\n  }\n\n  private int calculateManhattenDistance(Point start,Point end)\n  {\n    return Math.abs(start.row - end.row) + Math.abs(start.col - end.col);\n  }\n\n  private void deriveWaypoints(Stack<Point> a, Point end) {\n    Tile tp = tiledWorld[end.row][end.col];\n\n    while( tp != null ) {\n      a.push(tp.getPoint());\n      tp = tp.getParent();\n    }\n  }\n\n  private void resetWorld() {\n    for( int i = 0; i<worldRows; i++ ) {\n      for(int j = 0; j<worldColumns; j++) {\n        tiledWorld[i][j] = new Tile();\n        tiledWorld[i][j].setPoint(i,j);\n      }\n    }\n    for( int i = 0; i<worldRows; i++ ) {\n      for(int j = 0; j<worldColumns; j++) {\n        Tile t = tiledWorld[i][j];;\n        if( validSpaces.indexOf(world[i].charAt(j)) == -1) {\n          t.setNotWalkable();\n        } else {\n          if( i == 0 ) {\n            t.setUp(null);\n          } else {\n            t.setUp(tiledWorld[i-1][j]);\n          }\n          if( i == worldRows-1 ) {\n            t.setDown(null);\n          } else {\n            t.setDown(tiledWorld[i+1][j]);\n          }\n          if( j == 0 ) {\n            t.setLeft(null);\n          } else {\n            t.setLeft(tiledWorld[i][j-1]);\n          }\n          if( j == worldColumns-1 ) {\n            t.setRight(null);\n          } else {\n            t.setRight(tiledWorld[i][j+1]);\n          }\n        }\n      }\n    }\n  }\n}\n```", "```java\nimport java.util.Comparator;\n\npublic class Tile implements Comparable<Tile> {\n  private int g = 0, h = 0;\n  private Tile up, down, left, right, parent;\n  private Point location;\n  private boolean walkable = true;\n  private boolean done = false;\n  private boolean isEndNode = false;\n\n  public Tile() {\n    parent = up = down = left = right = null;\n    location = new Point(0,0);\n  }\n\n  public Tile(Tile u, Tile d, Tile l, Tile r) {\n    up = u;\n    down = d;\n    left = l;\n    right = r;\n    parent = null;\n    location = new Point(0,0);\n  }\n\n  /* state methods */\n  public boolean isWalkable() {\n    return walkable;\n  }\n\n  public void setNotWalkable() {\n    walkable = false;\n  }\n\n  public boolean isDone() {\n    return done;\n  }\n\n  public void setDone() {\n    done = true;\n  }\n\n  public boolean isEndNode() {\n    return isEndNode;\n  }\n\n  public void setEndNode() {\n    isEndNode = true;\n  }\n\n  /* neighbors */\n  public void setParent(Tile t) {\n    parent = t;\n  }\n\n  public Tile getParent() {\n    return parent;\n  }\n\n  public void setUp(Tile t) {\n    up = t;\n  }\n\n  public Tile getUp() {\n    return up;\n  }\n\n  public void setDown(Tile t) {\n    down = t;\n  }\n\n  public Tile getDown() {\n    return down;\n  }\n\n  public void setRight(Tile t) {\n    right = t;\n  }\n\n  public Tile getRight() {\n    return right;\n  }\n\n  public void setLeft(Tile t) {\n    left = t;\n  }\n\n  public Tile getLeft() {\n    return left;\n  }\n\n  /* accessor methods */\n  public void setPoint(int _row, int _col) {\n    location.row = _row;\n    location.col = _col;\n  }\n\n  public Point getPoint() {\n    return location;\n  }\n\n  public void setG(int n) {\n    g = n;\n  }\n\n  public int getG() {\n    return g;\n  }\n\n  public void setH( int n) {\n    h = n;\n  }\n\n  public int getH() {\n    return h;\n  }\n\n  public int getF() {\n    return g+h;\n  }\n\n  // needed for Comparable interface\n  public int compareTo(Tile t) {\n    return getF()-t.getF();\n  }\n\n}\n```", "```java\npublic class Point {\n  public int row;\n  public int col;\n\n  public Point() {\n    row = col = 0;\n  }\n\n  public Point( int _row, int _col) {\n    row = _row;\n    col = _col;\n  } \n\n  public boolean equals(Point p) {\n    return (p.row == row) && (p.col == col);\n  }\n}\n```"]