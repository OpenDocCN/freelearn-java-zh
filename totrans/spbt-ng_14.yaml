- en: '14'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Adding Authentication in Angular
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we completed the CRUD features of our Angular application
    using the building blocks of NgRx. We also learned the step-by-step process of
    writing the actions, reducers, and effects in our application that will be used
    to modify the value of states. We also learned the difference between using and
    not using effects in the application. Effects are essential for us to communicate
    with the external APIs that allow the database changes to be synced in the NgRx
    store.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will learn how to add authentication in our Angular application;
    we will implement a login page that will provide a valid JWT, protect routes,
    and apply API authentication with the use of NgRx.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Adding user authentication
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Protecting routes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Calling an API
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The complete code for this chapter can be found at: https://github.com/PacktPublishing/Spring-Boot-and-Angular/tree/main/Chapter-14.'
  prefs: []
  type: TYPE_NORMAL
- en: Adding user authentication
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Adding user authentication is one of the main requirements in developing an
    application. This feature allows us to restrict pages and features from unauthorized
    users. We can achieve user authentication in different ways, and one way to implement
    this is by providing a login page that will ask for credentials.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s have a look at the step-by-step process of implementing the authentication
    feature.
  prefs: []
  type: TYPE_NORMAL
- en: The authentication API
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let us first recap the authentication API we created in our Spring Boot project.
    The endpoints for authentication are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`{BASE_URL}/authenticate`: The main endpoint for authentication accepts an
    object with email and password fields and returns a valid JWT that will be used
    for calling endpoints. The following is an example response object of the endpoint:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`{BASE_URL}/register`: The endpoint for creating new valid credentials for
    login. JWT, as stated in [*Chapter 7*](B18159_07.xhtml#_idTextAnchor123), *Adding
    Spring Boot Security with JWT*, is used chiefly on RESTful web services that cannot
    maintain a client state since JWT holds some information connected to the user.
    This will be used primarily in the headers of endpoints that we will request.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In our project, let’s create a service named `AuthenticateService` under the
    `core/services` folder by executing the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'After successfully creating the service, we will place the following code in
    the service:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '`AuthenticateService` will hold the two endpoints we will use for our login
    page. Now, let’s create the interceptor for our application.'
  prefs: []
  type: TYPE_NORMAL
- en: The HTTP interceptor
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`intercept()` function, which will enable us to get the outgoing request and
    call the next interceptor or the backend.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We will mainly use the interceptor to modify the headers of our endpoint requests,
    which will be responsible for adding the `Authorization: Bearer {JWT}` header
    for each invoked request.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To implement the interceptor, we will create the `core/interceptors/header.interceptor.ts`
    file, and we will place the following code within it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code example, we have added a new implementation for the `intercept()`
    function. The first step is to retrieve the valid JWT in our local storage that
    will be used in the HTTP headers. We will only use the JWT if the request endpoint
    has an `api/v1` substring, as these are the endpoints that are protected.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next step is to clone the request and add the `Authorization: Bearer {JWT}`
    header in the cloned request and call the `next()` function to call the API with
    the added header.'
  prefs: []
  type: TYPE_NORMAL
- en: We have now created our interceptor; the last step is to add the interceptor
    in `AppModule`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s have a look at the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code example, we will now intercept every HTTP call on the
    anti-heroes endpoint and will add the generated JWT in the request headers.
  prefs: []
  type: TYPE_NORMAL
- en: The authentication module
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The next step is to create an authentication module; this module will be responsible
    for holding the login and registration page that will accept the users and credentials
    and call the authenticate and register endpoints.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create the authentication module, we will execute the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'After successfully creating the authentication module, we will import several
    modules we need for our authentication module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Now, we will create the different parts of our module.
  prefs: []
  type: TYPE_NORMAL
- en: The authentication form
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We will create the main form for our authentication module; this is considered
    the dumb component of our module as it will accept and emit the values of the
    form to the login and registration page.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create the authentication form component, we will execute the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'After successfully creating the component, we will now implement the form’s
    code. In the TypeScript file of the `auth-form` component, we will place the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code example, we can see that we have created a reactive form
    with an email and password form control. We have also created an emitter that
    will pass the values of the form into the parent component, as this component
    will be used by both the login and the register page. Now, we will implement the
    HTML code and the CSS of the `auth-form` component.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'Please refer to the link provided for the entire code implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/PacktPublishing/Spring-Boot-and-Angular/tree/main/Chapter-14/superheroes/src/app/auth/components/auth-form](https://github.com/PacktPublishing/Spring-Boot-and-Angular/tree/main/Chapter-14/superheroes/src/app/auth/components/auth-form)'
  prefs: []
  type: TYPE_NORMAL
- en: In the implemented code, we have bound the reactive form with the email and
    password input. We have also created a condition where the button changes if the
    page is currently on login or register.
  prefs: []
  type: TYPE_NORMAL
- en: We have successfully created our authentication form; now, we will create our
    login and registration page.
  prefs: []
  type: TYPE_NORMAL
- en: The login and registration page
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The login and registration pages are considered to be the smart components of
    our application, as these are the components that will dispatch the action for
    calling the authentication API.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create the login and register page, we will execute the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'After successfully creating the two pages, we will run the code for the login
    and register components:'
  prefs: []
  type: TYPE_NORMAL
- en: Login Page
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Register Page
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code example, we can see that the login page and registration
    pages are using the same authentication form component. Once the form is submitted,
    it will pass the form value into the `login()` or `register()` functions to authenticate
    or create the user, respectively. If the login is successful, we will redirect
    the user to the anti-heroes list page and place the generated token from the API
    in the local storage.
  prefs: []
  type: TYPE_NORMAL
- en: The routing module
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The next step is to create the `auth-routing` module that will define the routes
    for the authentication module. To create the module, let’s execute the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'After creating the routing module, we will run the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'We also need to modify our `app-routing` module, as we need our base path to
    redirect to the login page; let’s implement the following modification:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding implemented code, we can see that once we go to the base path,
    this will now load the `AuthModule` and redirect us to the login page, as shown
    in *Figure 14**.1*.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 14.1 – The Login page](img/B18159_14_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 14.1 – The Login page
  prefs: []
  type: TYPE_NORMAL
- en: We should now be able to log in with our user in the database. If no user has
    been created, we can create a new one using the registration page, and once the
    login is successful, we will be redirected to the anti-hero list page, as shown
    in *Figure 14**.2*.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 14.2 – The anti-hero list page](img/B18159_14_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 14.2 – The anti-hero list page
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also observe that our valid JWT is already placed in our local storage
    as the HTTP interceptor is using the JWT. As we open a request made by our application,
    we can see that the headers have the generated JWT:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example headers, we can see that the `Authorization` header
    contains the valid JWT for every API request the application calls. The placement
    of the JWT in the header is done when our login is successful and we are redirected
    to the `AntiHeromodule`.
  prefs: []
  type: TYPE_NORMAL
- en: Token validation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The next step we need to do is to add token validation to check whether our
    token already expired. To implement this feature, we add the `@auth0/angular-jwt`
    library by executing the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The `@auth0/angular-jwt` library provides useful functions, such as `isTokenExpired()`,
    which checks whether the JWT is expired, and `decodeToken()`, which retrieves
    the information from the JWT.
  prefs: []
  type: TYPE_NORMAL
- en: 'After successfully installing the library, we will add the following code to
    our authenticate service:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'We also need to import the JWT module into our `app.module.ts` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: We will use the `isAuthenticated()` function on our login and register pages
    to check whether a JWT is present in our local storage. If there is a valid JWT,
    we will redirect the application to the anti-hero list page.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s have a look at the following implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Logout implementation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The last feature we need to implement is the logout function. To add this feature,
    the only function we need to add is a function that will remove the token from
    our storage. Let’s have the code implementation as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: authenticate.service.ts
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code example, we have added a `doLogout()` function that removes
    the token in the storage and redirects the application to the login page. Now,
    let’s edit our `navbar` component to have a logout button:'
  prefs: []
  type: TYPE_NORMAL
- en: navbar.component.html
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: navbar.component.css
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: navbar.component.ts
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code implementation, we created an emitter for our navbar component.
    This will emit the action we have triggered in our navbar, and it will be passed
    into our app component.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last step is to call the `doLogout()` function in our app component when
    the logout button is clicked. Let’s have a look at the code implementation, as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: app.component.html
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: app.component.ts
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code implementation, we injected the authenticate service into
    our app component and called the `doLogout()` function. If the action is `logout`,
    we have also added a listener to the router change to check if our route is currently
    on login or register, and if it is, we will remove the logout button on the navbar
    component.
  prefs: []
  type: TYPE_NORMAL
- en: We have successfully implemented user authentication with our application, but
    we will still improve this implementation as we go on through this chapter. In
    the next section, we will discuss how to protect routes in our Angular application.
  prefs: []
  type: TYPE_NORMAL
- en: Protecting routes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the essential features of Angular is router guards. Guards are helpful
    if we want to protect our routes from being accessed directly without authentication
    or prevent the user from losing changes when navigating accidentally from the
    route.
  prefs: []
  type: TYPE_NORMAL
- en: Guards are interfaces provided by Angular that allow us to control the accessibility
    of a route with a provided condition. These are applied directly to the routes
    we want to protect.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s have a look at some of the guards provided by Angular:'
  prefs: []
  type: TYPE_NORMAL
- en: '`CanActivate`: This is implemented on a route we want to prevent access to.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Method signature**:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: The preceding code defines the signature of the `CanActivate` guard. The function
    accepts the `ActivatedRouteSnapshot` and `RouterStateSnapshot` parameters and
    returns an `Observable` or `Promise` that can be of type `Boolean` or `UrlTree`.
  prefs: []
  type: TYPE_NORMAL
- en: '**Creating** **the guard**:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the preceding code example, we have created a new class named `AuthGuard`;
    we have also implemented it with the `CanActivate` guard and added the `canActivate()`
    function for the required logic.
  prefs: []
  type: TYPE_NORMAL
- en: '**Using** **the guard**:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the preceding code example, we have used the newly created `AuthGuard` class
    in our hero route to protect it from users without a valid JWT.
  prefs: []
  type: TYPE_NORMAL
- en: '`CanActivateChild`: This is similar to `CanActivateGuard`, but this guard is
    applied to prevent access to child routes. Once this is added to the parent route,
    the guard will protect all child routes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Method signature**:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: The preceding code example defines the signature of the `CanActivateChild` guard.
    The function accepts the `ActivatedRouteSnapshot` and `RouterStateSnapshot` parameters
    and returns an `Observable` or `Promise` that can be of type `Boolean` or `UrlTree`.
  prefs: []
  type: TYPE_NORMAL
- en: '**Creating** **the guard**:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE45]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE46]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE47]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE48]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE49]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the preceding code example, we have created a new class named `AuthGuard`.
    We have also implemented it with the `CanActivateChild` guard and added the `canActivateChild()`
    function for the required logic.
  prefs: []
  type: TYPE_NORMAL
- en: '**Using** **the guard**:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE51]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE52]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE53]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE54]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE55]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE56]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE57]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the preceding code example, we have used the newly created `AuthGuard` class
    in our user path to protect its child routes that navigate to the `ProfileComponent`
    and `SettingsComponent` components from users without a valid JWT.
  prefs: []
  type: TYPE_NORMAL
- en: '`CanLoad`: This guard is used for lazy-loaded modules. The `CanActivate` guard
    can only prevent users from navigating through a route; the `CanLoad` guard prevents
    both navigating to and downloading the lazy-loaded module.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Method signature**:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: The preceding code example defines the signature of the `CanLoad` guard. The
    function accepts the `Route` and `UrlSegment[]` parameters and returns an `Observable`
    or `Promise` that can be of type `Boolean`.
  prefs: []
  type: TYPE_NORMAL
- en: '**Creating** **the guard**:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE60]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE61]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE62]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE63]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE64]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE65]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the preceding code example, we have created a new class named `AuthGuard`.
    We have also implemented it with the `CanLoad` guard and added the `canLoad()`
    function for the required logic.
  prefs: []
  type: TYPE_NORMAL
- en: '**Using** **the guard**:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE67]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE68]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE69]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE70]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE71]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE72]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the preceding code example, we have used the newly created `AuthGuard` class
    in our hero route to protect it from users accessing and downloading the resources
    without a valid JWT.
  prefs: []
  type: TYPE_NORMAL
- en: '`CanDeactivate`: This is a guard used to prevent the user from navigating away
    from the current route. This is useful in scenarios such as filling out forms
    in the application, to avoid losing some changes on navigating out accidentally.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Method signature**:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: The preceding code example defines the signature of the `CanDeactivate` guard.
    The function accepts a generic component, the `ActivatedRouteSnapshot` and `RouterStateSnapshot`
    parameters, and returns an `Observable` or `Promise` that can be of type `Boolean`
    or `UrlTree`.
  prefs: []
  type: TYPE_NORMAL
- en: '**Creating** **the guard**:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE75]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE76]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE77]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE78]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE79]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE80]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE81]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE82]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE83]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE84]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the preceding implementation, we have created an interface that will be
    used in the component of the `CanDeactivateGuard` service:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code example, we have implemented the interface we have created
    for the component.
  prefs: []
  type: TYPE_NORMAL
- en: '**Using** **the guard**:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the preceding code example, we have used the newly created `CanDeactivateGuard`
    to prevent the user from navigating out of the `FormComponent` based on the applied
    condition on the `canDeactivate()` function.
  prefs: []
  type: TYPE_NORMAL
- en: We have learned about the different guards we can use in our application. Now,
    let’s implement this in our Angular project.
  prefs: []
  type: TYPE_NORMAL
- en: Project implementation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The first guard we need to apply in our application is the `CanLoad` guard.
    This is necessary as we want to protect our anti-heroes routes from being accessed
    if there is no valid JWT. To create the `CanLoad` guard, execute the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: After executing the command, select the `CanLoad` option to generate a new `AuthGuard`
    class. The only thing we need to change here is the implementation of the `canLoad()`
    function. The condition we want to apply is to allow the route and modules to
    be loaded if the JWT is valid.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s have a look at the following implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code example, we have used the `isAuthenticated()` function
    to check that the JWT is valid and not expired. If it is valid, this will return
    `true` and allow us to navigate the route. Otherwise, it will redirect us to the
    login page.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last step is to apply the `AuthGuard` class in the anti-heroes route; in
    the `app-routing.module.ts` file, we will use the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: We have now successfully applied the `CanLoad` guard in our anti-heroes route.
    To test whether this works, we can try deleting the token in our local storage,
    and this should redirect us to the login page having no valid JWT.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last route guard we need is the `CanDeactivate` guard; we will apply this
    guard on our anti-hero form to prevent the user from losing changes when navigating
    away from the form. To create our `CanDeactivate` guard, we will execute the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: After executing the command, select the `CanDeactivate` option, and this will
    generate a new `FormGuard` class. We will add an interface to this class that
    we will use in our `form` component.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s have a look at the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code example, we have created the `CanComponentDeactivate`
    interface that the form component will implement. This means that the condition
    will be placed in the component instead of the guard. In `FormComponent`, we will
    add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code example, we have implemented the `FormComponent` with
    the `CanComponentDeactivate` interface that we have created; we have added a `window.
    confirm()`, which will pop up a dialog box that will ask if the user wants to
    leave the current route. This is a simple implementation of the guard, as we can
    also add other conditions, such as if we only want to ask this question if there
    are changes in the form.
  prefs: []
  type: TYPE_NORMAL
- en: The last step is to apply the guard in the `FormComponent` route.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s have a look at the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: Once we have applied the `CanDeactivate` guard, navigating out from the anti-hero
    form will pop up a dialog box for the user, as shown in *Figure 14**.3*.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18159_14_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 14.3 – Dialog box on navigating away from the form
  prefs: []
  type: TYPE_NORMAL
- en: We have now successfully applied guards in our Angular application; in the next
    section, we will directly improve our calling of API authentication with the use
    of NgRx state management.
  prefs: []
  type: TYPE_NORMAL
- en: Calling an API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have already created user authentication in the previous section by calling
    the authentication service directly in our component. We have also stored the
    generated JWT in our local storage using the `setItem` function, which is also
    happening in our login component.
  prefs: []
  type: TYPE_NORMAL
- en: What we want to achieve is to reduce the responsibility of our components, and
    as we remember, we are using NgRx state management to call the APIs, and the only
    responsibility of our components is to dispatch the action, and NgRx will do the
    rest.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we will improve our API calls by using the building blocks
    of the NgRx state management.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the actions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The first step we need is to create the actions for our authentication feature.
    We will create a file named `auth.actions.ts` in the `auth/state` folder, and
    we will have the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, we can see that we have created four action types: the
    `LOGIN` type will be used for the effect responsible for calling the login API;
    the `CREATE_USER` type will be used for the effect accountable for calling the
    register API; the `SET_TOKEN` type will be used by a reducer that will set the
    generated JWT in the store after the login API has been reached; and lastly, the
    `AUTH_ERROR` type will be used to set errors in the store if the login or register
    API has returned an error.'
  prefs: []
  type: TYPE_NORMAL
- en: Creating the effects
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'After creating our actions, now, we will create the effects for calling the
    login and register API. We will create a file named `auth.effects.ts` in the `auth/state`
    folder, and we will have the following implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: Login Effect
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: Register Effect
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we have created effects for the login and register API.
    In the `loginUser$` effect, once the login API is successful, it will dispatch
    the `SET_TOKEN` action and pass the generated JWT, and this will also redirect
    us to the anti-heroes page.
  prefs: []
  type: TYPE_NORMAL
- en: This is the same behavior we implemented in the previous section. On the other
    hand, the `createUser$` effect, once the register API is successful, will redirect
    us to the login page again. This is a simple behavior, and you can customize what
    will happen next if the registration is successful.
  prefs: []
  type: TYPE_NORMAL
- en: We have also implemented the `AUTH_ERROR` action, which will be called when
    the login or register API fails.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the reducers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The next step we need is to create the reducers. We will create a file named
    `auth.reducers.ts` in the `auth/state` folder, and we will have the following
    implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code example, we can see that `AuthState` has two fields, which
    are `token` and `error`. The `token` field will contain the valid JWT once the
    `setToken` action is called when the authentication API is successful, and the
    `error` field will contain the generated error if the login or register API fails.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the selectors
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'After creating the reducers, we will now create our selector. In this case,
    our selector will be simple as we only need a selector for the `error` field.
    We will create a file named `auth.selectors.ts` in the `auth/state` folder, and
    we will have the following implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code example, we have created a selector for our `error` field;
    we will need this selector to display the error message in our component for the
    user.
  prefs: []
  type: TYPE_NORMAL
- en: Syncing in local storage
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The next feature we will implement is the syncing of our state in local storage.
    We can achieve this by using `localStorage.setItem()` in our application. However,
    using this will not be maintainable, and the setting of values in the storage
    will be in different places.
  prefs: []
  type: TYPE_NORMAL
- en: 'To have a better implementation, we will use the `ngrx-store-localstorage`
    library. To install the library, we will execute the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: 'After successfully installing the library, we should determine the states we
    want to sync with our local storage. In our case, we want the `token` field in
    our `auth` state to be synced. To achieve this, we make the following code changes
    in `auth.module.ts`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we can see that we have created a dedicated reducer that
    calls the `localStorageSync` from the `ngrx-store-localstorage`, which is responsible
    for adding values in the local storage.
  prefs: []
  type: TYPE_NORMAL
- en: We can also specify what fields we want to sync and, in this case, we have added
    the token in the keys array. Once the token state changes its value, the new value
    will also be placed in our storage.
  prefs: []
  type: TYPE_NORMAL
- en: Dispatching and selecting a component
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The last step is to dispatch the actions and use the selector for our login
    and register a component. Let’s have a look at the following code implementation
    for the login and register a component:'
  prefs: []
  type: TYPE_NORMAL
- en: login.component.ts
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: register.component.ts
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: We can see in the preceding code the login and register pages have almost the
    same implementation. We have already removed the call for the login and register
    service in the `submit` function and replaced it with the dispatching of an action.
    We have also used the `selectError()` selector to listen to see if the APIs have
    produced errors.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With this, we have reached the end of this chapter; let’s have a recap of the
    valuable things you have learned.
  prefs: []
  type: TYPE_NORMAL
- en: We now know how to implement user authentication in the Angular application,
    and we have used an HTTP interceptor to intercept HTTP requests to transform its
    headers and add the valid JWT for the API calls. We have also learned about the
    different route guards that allow us to protect routes from unauthorized access
    or prevent accidental loss of data when navigating out from the route. Lastly,
    we have learned how to use NgRx state management by improving how to implement
    authentication in Angular.
  prefs: []
  type: TYPE_NORMAL
- en: The next chapter will teach us how to write end-to-end testing in Angular using
    the Cypress framework.
  prefs: []
  type: TYPE_NORMAL
