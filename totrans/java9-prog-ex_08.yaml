- en: Extending Our E-Commerce Application
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 扩展我们的电子商务应用
- en: In the last chapter, we started developing an e-commerce application and we
    created the functionality to look up products based on their ID and, also, by
    some parameters. In this chapter, we will extend the functionality so that we
    can also order the products we selected. While doing so, we will learn new technologies,
    focusing on functional programming in Java and on some other language features,
    such as reflection and annotation handling during runtime, and scripting interface.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们开始开发一个电子商务应用，并创建了根据产品ID和一些参数查找产品的功能。在本章中，我们将扩展功能，以便我们还可以订购我们选择的产品。在这个过程中，我们将学习新技术，重点关注Java中的函数式编程以及一些其他语言特性，如运行时反射和注解处理，以及脚本接口。
- en: As we did in the previous chapters, we will develop the application step by
    step. As we discover the newly learnt technologies, we will refactor the code
    to enroll the new tools and methods to produce more readable and effective code.
    We will also mimic the development of real-life projects in the sense that at
    the start, we will have simple requirements, and later, new requirements will
    be set as our imagined business develops and sells more and more products. We
    will become imagined millionaires.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在前面的章节中所做的那样，我们将逐步开发应用。当我们发现新学的技术时，我们将重构代码，以引入新的工具和方法，以产生更易读和有效的代码。我们还将模仿真实项目的开发，即在开始时，我们将有简单的需求，而后来，随着我们想象中的业务发展和销售更多产品，新的需求将被设定。我们将成为想象中的百万富翁。
- en: 'We will use the code base of the previous chapter, and we will develop it further,
    though, in a new project. We will use Spring, Gradle, Tomcat, and soapUI, which
    are not new after we got acquainted with these in the previous chapter. In this
    chapter, you will learn the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用上一章的代码库，并将在此基础上进一步开发，尽管如此，我们将在一个新的项目中这样做。我们将使用Spring、Gradle、Tomcat和soapUI，这些在上一章中我们已经熟悉了。在本章中，你将学习以下主题：
- en: Annotation processing
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 注解处理
- en: Using reflection
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用反射
- en: 'Functional programming in Java using:'
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用以下方式在Java中进行函数式编程：
- en: Lambda expressions
  id: totrans-7
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: Lambda表达式
- en: Streams
  id: totrans-8
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 流
- en: Invoking scripts from Java
  id: totrans-9
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从Java调用脚本
- en: The MyBusiness ordering
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: MyBusiness订购
- en: The ordering process is a little bit more complicated than just looking up products.
    The order form itself lists products and amounts, and identifies who the customer
    for that order is. Identifiers give the products. All that we have to do is check
    that the products are available in our store, and we can deliver them to the given
    customer. This is the simplest approach; however, with some products, there are
    more restrictions. For example, when somebody orders a desk-side lamp, we deliver
    the power cord separately. The reason for this is that the power cord is specific
    to the country. We deliver different power cords to the United Kingdom and to
    Germany. One possible approach could be to identify the country of the customer.
    But this approach does not take into account that our customers are resellers.
    All customers could be located in the United Kingdom, and at the same time they
    may want to deliver the lamp with the power cable to Germany. To avoid such situations
    and ambiguity, it would be  apt that our customers order the desk-side lamp and
    the power cord as separate items in the same order. In some cases, we deliver
    the desk-side lamp without the power cord, but this is a special case. We need
    some logic to identify these special cases. Therefore, we have to implement logic
    to see if there is a power cord for a desk-side lamp and if there is no automatic
    handling of the order, it is refused. It does not mean that we will not deliver
    the product. We will only put the order in a queue and some operator will have
    to look at it.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 订单过程比仅仅查找产品要复杂一些。订单表单本身列出了产品和数量，并确定了该订单的客户是谁。标识符提供了产品信息。我们只需要检查这些产品是否在我们的商店中有货，并且我们可以将它们交付给指定的客户。这是最简单的方法；然而，对于某些产品，存在更多的限制。例如，当有人订购桌面台灯时，我们会单独交付电源线。这是因为电源线是特定于国家的。我们向英国和德国交付不同的电源线。一种可能的方法是识别客户的国籍。但这种方法没有考虑到我们的客户是转售商。所有客户可能都位于英国，同时他们可能希望将台灯和电源线一起运往德国。为了避免这种情况和歧义，我们的客户最好将桌面台灯和电源线作为同一订单中的单独项目订购。在某些情况下，我们不附带电源线交付桌面台灯，但这是一种特殊情况。我们需要一些逻辑来识别这些特殊情况。因此，我们必须实现逻辑来查看是否存在桌面台灯的电源线，如果没有自动处理订单，则拒绝订单。这并不意味着我们不会交付产品。我们只会将订单放入队列，然后某个操作员需要查看它。
- en: The problem with this approach is that the desk-side lamp is only one product
    that needs configuration support. The more products we have, the more specialities
    they may have, and the piece of code that checks the consistency of an order becomes
    more and more complex until it reaches a level of complexity that is not manageable.
    When a class or method becomes too complex, the programmers refactor it, splitting
    up the method or class into smaller pieces. We have to do the same with the product
    checking. We shouldn't try to create one huge class that checks for the product
    and all the possible order constellations, but rather we should have many smaller
    checks so that each checks only one small set.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法的缺点在于，桌面台灯只是需要配置支持的一个产品。我们拥有的产品越多，它们可能具有的专长就越多，检查订单一致性的代码变得越来越复杂，直到达到无法管理的复杂程度。当一个类或方法变得过于复杂时，程序员会对其进行重构，将方法或类拆分成更小的部分。我们必须对产品检查做同样的事情。我们不应该试图创建一个巨大的类来检查产品和所有可能的订单组合，而应该有许多较小的检查，以便每个检查只针对一个小集合。
- en: 'Checking for consistency is simpler in some cases. Checking whether the lamp
    has a power cord has a complexity any novice programmer can program. We use this
    example in our code because we want to focus on the actual structure of the code,
    and not on the complex nature of the check itself. In real life, however, the
    checks can be fairly complex. Imagine a shop that sells computers. It puts a configuration
    together: power supply, graphic cards, and motherboard, the appropriate CPU, and
    the memory. There are many choices and some of them may not work together. In
    a real-life situation, we need to check that the motherboard is compatible with
    the memory selected, that it has as many banks as are in the order, that they
    are appropriately paired (some memories can only be installed in pairs), that
    there is a compatible slot for the graphics card, and that the power has enough
    watts to reliably run the whole configuration. This is very complex and is better
    not mixed up with the code that checks if there is a power cord for a lamp.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，检查一致性更简单。检查灯具是否有电源线，其复杂度任何新手程序员都可以编写。我们在代码中使用这个例子，因为我们想关注代码的实际结构，而不是检查本身的复杂性质。然而，在现实生活中，检查可能相当复杂。想象一下一家销售电脑的商店。它组装一个配置：电源供应、显卡和主板，适当的CPU和内存。有许多选择，其中一些可能无法一起工作。在现实情况下，我们需要检查主板与所选内存兼容，主板有与订单中相同数量的存储器组，它们被适当配对（一些内存只能成对安装），有一个兼容的插槽用于显卡，以及电源有足够的瓦特数来可靠地运行整个配置。这是非常复杂的，最好不要与检查灯具是否有电源线的代码混淆。
- en: Setting up the project
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置项目
- en: 'Since we are still using Spring boot, the build file does not need any modification;
    we will use it as we will use the same file as in the last chapter. The package
    structure, however, is a bit different. This time, we do something more complicated
    than getting a request and responding to whatever the backend services deliver
    to us. Now, we have to implement complex business logic that, as we will see,
    needs many classes. When we have more than 10 classes, give or take, in a certain
    package, it is time to think about putting them into separate packages. The classes
    that are related to each other and have a similar functionality should be put
    into one package. This way, we will have a package for the following:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们仍在使用Spring Boot，构建文件不需要任何修改；我们将像使用上一章的文件一样使用它。然而，包结构略有不同。这次，我们要做比仅仅获取请求并响应后端服务提供的内容更复杂的事情。现在，我们必须实现复杂的企业逻辑，正如我们将看到的，这需要许多类。当我们在一个包中有10多个类时，是时候考虑将它们放入单独的包中。相互关联并具有相似功能的类应该放在一个包中。这样，我们将有一个包用于以下内容：
- en: The controllers (though we have only one in this example, but usually there
    are more)
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 控制器（尽管在这个例子中我们只有一个，但通常会有更多）
- en: Data storing beans that have no more functionality than storing data, thus,
    fields, setters, and getters
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 只具有存储数据功能的数据存储bean，因此，字段、setter和getter
- en: Checkers that will help us check power cords when a desk-side lamp is ordered
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当订购台式灯时帮助我们检查电源线的检查器
- en: Services that perform different services for the controller
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为控制器执行不同服务的服务
- en: The main package for our program that contains the `Application` class, `SpringConfiguration`,
    and some interfaces
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包含`Application`类、`SpringConfiguration`和一些接口的我们程序的主要包
- en: Order controller and DTOs
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 订单控制器和DTOs
- en: 'When a request comes to the server to order a bunch of products, it comes in
    an HTTPS `POST` request. The body of the request is encoded in JSON. Till now,
    we had controllers that were handling `GET` parameters, but handling `POST` requests
    is not much more difficult when we can rely on the data marshalling of Spring.
    The controller code itself is simple:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 当服务器收到一个请求来订购一系列产品时，它以HTTPS `POST`请求的形式到来。请求体以JSON编码。到目前为止，我们已经有处理`GET`参数的控制器，但当我们能够依赖Spring的数据绑定时，处理`POST`请求并不比这更困难。控制器代码本身很简单：
- en: '[PRE0]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'There is only one request that we handle in this controller: `order`. This
    is mapped to the URL, `/order`. The order is automatically converted from JSON
    to an order object from the request body. This is what the `@RequestBody` annotation
    asks Spring to do for us. The functionality of the controller simply checks the
    consistency of the order. If the order is consistent, then we accept the order;
    otherwise, we refuse it. The real-life example will also check that the order
    is not only consistent but also comes from a customer who is eligible for buying
    those products and that the products are available in the warehouse or, at least,
    can be delivered, based on the promises and lead time from the producers.'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个控制器中，我们只处理一个请求：`order`。这映射到 URL `/order`。订单会自动从请求体中转换为 JSON 格式的订单对象。这就是 `@RequestBody`
    注解要求 Spring 为我们做的事情。控制器的功能仅仅是检查订单的一致性。如果订单是一致的，那么我们接受订单；否则，我们拒绝它。现实生活中的例子也会检查订单不仅是一致的，而且来自有资格购买这些产品的客户，并且这些产品在仓库中有货，或者至少根据生产者的承诺和交货期可以交付。
- en: To check the consistency of the order, we need something that does this job
    for us. As we know that we have to modularize the code and not implement too many
    things in a single class, we need a checker object. This is provided automatically
    based on the annotation on the class and also on the constructor of the controller
    by `@Autowired`.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 要检查订单的一致性，我们需要一个为我们做这项工作的东西。正如我们所知，我们必须模块化代码，不要在单个类中实现太多东西，因此我们需要一个检查对象。这是根据类的注解和控制器构造函数的
    `@Autowired` 自动提供的。
- en: 'The `Order` class is a simple bean, simply listing the items:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '`Order` 类是一个简单的 JavaBean，仅列出项目：'
- en: '[PRE1]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The name of the package is `dtos`, which stands for the plural of **Data Transfer
    Object** (**DTO**). DTOs are objects that are used to transfer data between different
    components, usually over the network. Since the other side can be implemented
    in any language, the marshaling can be JSON, XML, or some other format that is
    capable of delivering nothing but data. These classes do not have real methods.
    DTOs usually have only fields, setters, and getters.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 包的名称是 `dtos`，代表 **数据传输对象**（DTO）的复数形式。DTOs 是用于在不同组件之间传输数据（通常通过网络）的对象。由于另一端可以用任何语言实现，序列化可以是
    JSON、XML 或其他仅能传输数据的格式。这些类没有实际的方法。DTOs 通常只有字段、设置器和获取器。
- en: 'The following is the class that contains one item in an order:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个包含订单中一个项目的类：
- en: '[PRE2]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The order confirmation is also in this package, and though this is also a true
    DTO, it has some simple auxiliary methods:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 订单确认也在此包中，尽管这也是一个真正的 DTO，但它有一些简单的辅助方法：
- en: '[PRE3]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: We provide two factory methods for the class. This is a little violation of
    the single responsibility principle that purists hate. Most of the time, when
    the code becomes more complex, such short cuts bite back, and the code has to
    be refactored to be cleaner. The purist solution would be to create a separate
    factory class. The use of the factory methods either from this class or from a
    separated class makes the code of the controller more readable.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为该类提供了两个工厂方法。这有点违反了单一职责原则，这是纯粹主义者所厌恶的。大多数时候，当代码变得更加复杂，这样的捷径会反过来咬人，代码不得不重构以变得更加简洁。纯粹主义的解决方案是创建一个单独的工厂类。使用这个类或分离的类的工厂方法可以使控制器的代码更易于阅读。
- en: The major task we have is the consistency check. The code, till this point,
    is almost trivial.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的主要任务是进行一致性检查。到目前为止，代码几乎是微不足道的。
- en: Consistency checker
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一致性检查器
- en: We have a consistency checker class, and an instance of it is injected into
    the controller. This class is used to check the consistency, but it does not actually
    perform the check itself. It only controls the different checkers that we provide
    and invokes them one by one to do the real work.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一个一致性检查器类，并且它的一个实例被注入到控制器中。这个类用于检查一致性，但它本身并不执行检查。它只控制我们提供的不同检查器，并依次调用它们来完成实际工作。
- en: 'We require that a consistency checker, such as the one that checks whether
    the order contains a power cord when a desk-side lamp is ordered, implements the
    `ConsistencyChecker` interface:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 我们要求一致性检查器，例如当订购台灯时检查订单是否包含电源线的一致性检查器，实现 `ConsistencyChecker` 接口：
- en: '[PRE4]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The method `isInconsistent` should return `true` if the order is inconsistent.
    It returns `false` if it does not know whether the order is inconsistent or not,
    but from the aspect that the actual checker examines the order, there is no inconsistency.
    Having several `ConsistencyChecker` classes, we have to invoke one after the other
    until one returns `true` or we are out of them. If none of them returns `true`,
    then we can safely assume, at least from the automated checkers' point of view,
    that the order is consistent.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '`isInconsistent`方法应该在订单不一致时返回`true`。如果它不知道订单是否不一致，则返回`false`，但从实际检查器检查订单的角度来看，没有不一致性。由于有多个`ConsistencyChecker`类，我们必须一个接一个地调用，直到其中一个返回`true`或者我们用完它们。如果没有一个返回`true`，那么至少从自动化检查器的角度来看，我们可以安全地假设订单是一致的。'
- en: We know at the start of the development that we will really have a lot of consistency
    checkers and not all are relevant for all of the orders. We want to avoid the
    invocation of each checker for each order. To do so, we implement some filtering.
    We let products specify what type of checks they need. This is a piece of product
    information, such as the size or the description. To accommodate this, we need
    to extend the `ProductInformation` class.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发初期，我们就知道我们将会真正拥有很多一致性检查器，并不是所有检查器都对所有订单都相关。我们希望避免为每个订单调用每个检查器。为了做到这一点，我们实现了一些过滤。我们让产品指定它们需要哪种类型的检查。这是一些产品信息，比如大小或描述。为了适应这一点，我们需要扩展`ProductInformation`类。
- en: We will create each `ConsistencyChecker` interface, implementing the class to
    be a Spring bean (annotated with the `@Component` annotation), and at the same
    time, we will annotate them with an annotation that specifies what type of checks
    they implement. At the same time, `ProductInformation` is extended, containing
    a set of `Annotation` class objects that specify which checkers to invoke. We
    could simply list the checker classes instead of the annotations, but this gives
    us some extra freedom in configuring the mapping between the products and the
    annotations. The annotation specifies the type of the products, and the checker
    classes are annotated. The desk-side lamp has the `PoweredDevice` type, and the
    checker class, `NeedPowercord`, is annotated with the `@PoweredDevice` annotation.
    If there is any other type of products that also needs a power cord, then the
    annotation of that type should be added to the `NeedPowercord` class, and our
    code will work. Since we start diving deep into annotations and annotation handling,
    we have to first learn what annotations really are. We have already used annotations
    since [Chapter 3](part0076.html), *Optimizing the Sort, Making Code Professional*
    but all we knew was how to use them, and that is usually dangerous without understanding
    what we did.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建每个`ConsistencyChecker`接口，实现类作为Spring bean（使用`@Component`注解标注），同时，我们将使用一个注解来指定它们实现哪种类型的检查。同时，`ProductInformation`被扩展，包含一组`Annotation`类对象，这些对象指定了要调用哪些检查器。我们本可以简单地列出检查器类而不是注解，但这给了我们在配置产品与注解之间的映射时一些额外的自由度。注解指定了产品的类型，检查器类被注解。台灯有`PoweredDevice`类型，检查器类`NeedPowercord`被`@PoweredDevice`注解标注。如果有其他类型的需要电源线的产品，那么该类型的注解应该添加到`NeedPowercord`类中，我们的代码就能工作。由于我们开始深入研究注解和注解处理，我们首先必须了解注解到底是什么。自从[第3章](part0076.html)，*优化排序，使代码专业*以来，我们已经使用了注解，但我们只知道如何使用它们，而且如果不理解我们所做的，这通常是危险的。
- en: Annotations
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 注解
- en: Annotations are used with the `@` character in front of them and can be attached
    to packages, classes, interfaces, fields, methods, method parameters, generic
    type declaration and use, and, finally, to annotations. Annotations can be used
    almost everywhere and they are used to describe some program meta information.
    For example, the `@RestController` annotation does not directly alter the behavior
    of the `OrderController` class. The behavior of the class is described by the
    Java code that is inside. The annotation helps Spring to understand what the class
    is and how it can and should be used. When Spring scans all the packages and classes
    to discover the different Spring beans, it sees the annotation on the class and
    takes it into account. There can be other annotations on the class that Spring
    does not understand. They may be used by some other framework or program code.
    Spring ignores them as any well-behaving framework. For example, as we will see
    later, we have in our code base, the `NeedPowercord` class , which is a Spring
    bean and, as such, annotated with the `@Component` annotation. At the same time,
    it is also annotated with the `@PoweredDevice` annotation. Spring has no idea
    about what a powered device is. This is something that we define and use. Spring
    ignores this.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 注解使用前面的`@`字符，可以附加到包、类、接口、字段、方法、方法参数、泛型类型声明和使用，以及最后，附加到注解上。注解几乎可以用于任何地方，它们用于描述一些程序元信息。例如，`@RestController`注解不会直接改变`OrderController`类的行为。类的行为由内部的Java代码描述。注解帮助Spring理解类是什么以及它应该如何以及如何使用。当Spring扫描所有包和类以发现不同的Spring
    beans时，它看到类上的注解并将其考虑在内。类上可能有Spring不理解的其它注解。它们可能被某些其他框架或程序代码使用。Spring像任何良好行为的框架一样忽略它们。例如，正如我们稍后将要看到的，在我们的代码库中，有一个名为`NeedPowercord`的类，它是一个Spring
    bean，因此被`@Component`注解标注。同时，它还被`@PoweredDevice`注解标注。Spring对什么是带电设备一无所知。这是我们定义和使用的。Spring忽略它。
- en: Packages, classes, interfaces, fields, and so on, can have many annotations
    attached to them. These annotations should simply be written in front of the declaration
    of the syntactical unit they are attached to.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 包、类、接口、字段等都可以附加许多注解。这些注解应该简单地写在它们所附加的语法单元声明之前。
- en: In the case of packages, the annotation has to be written in front of the package
    name in the `package-info.java` file. This file can be placed in the directory
    of the package and can be used to edit the *JavaDoc* for the package and also
    to add an annotation to the package. This file cannot contain any Java class since
    the name, `package-info`, is not a valid identifier.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在包的情况下，注解必须写在`package-info.java`文件中的包名之前。此文件可以放置在包的目录中，可以用来编辑包的*JavaDoc*，也可以用来向包添加注解。此文件不能包含任何Java类，因为`package-info`名称不是一个有效的标识符。
- en: 'We cannot just write anything in front of anything as an annotation. Annotations
    should be declared. They are in the runtime of Java special interfaces. The Java
    file that declares the `@PoweredDevice` annotation, for example, looks like this:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不能随意在任意位置写任何内容作为注解。注解应该被声明。它们位于Java运行时的特殊接口中。例如，声明`@PoweredDevice`注解的Java文件看起来像这样：
- en: '[PRE5]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The `@` character in front of the `interface` keyword shows us that this is
    a special one: an annotation type. There are some special rules; for example,
    an annotation interface should not extend any other interface, not even an annotation
    one. On the other hand, the compiler automatically makes the annotation interface
    so that it extends the JDK interface, `java.lang.annotation.Annotation`.'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '`interface`关键字前面的`@`字符表明这是一个特殊类型：注解类型。有一些特殊规则；例如，注解接口不应扩展任何其他接口，甚至不是注解接口。另一方面，编译器自动使注解接口扩展JDK接口`java.lang.annotation.Annotation`。'
- en: Annotations are in the source code, and thus, they are available during the
    compilation process. They can also be retained by the compiler and put into the
    generated class files, and when the class loader loads the class file, they may
    also be available during runtime. The default behavior is that the compiler stores
    the annotation along with the annotated element in the class file, but the class
    loader does not keep it available for runtime.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 注解位于源代码中，因此，它们在编译过程中是可用的。编译器还可以保留这些注解并将它们放入生成的类文件中，当类加载器加载类文件时，它们也可能在运行时可用。默认行为是编译器将注解与其注解的元素一起存储在类文件中，但类加载器不会在运行时保持它们可用。
- en: To handle annotations during the compilation process, the Java compiler has
    to be extended using annotation processors. This is a fairly advanced topic and
    there are only a few examples you can meet while working with Java. An annotation
    processor is a Java class that implements a special interface and is invoked by
    the compiler when it processes an annotation in the source file that the processor
    is declared to have an interest in.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 要在编译过程中处理注解，必须使用注解处理器扩展Java编译器。这是一个相当高级的话题，在处理Java时你只能遇到少数几个例子。注解处理器是一个实现了特殊接口的Java类，当编译器处理注解处理器声明的源文件中的注解时，会调用它。
- en: Annotation retention
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 注解保留
- en: Spring and other frameworks usually handle annotations during runtime. The compiler
    and the class loader have to be instructed that the annotation is to be kept available
    during runtime. To do so, the annotation interface itself has to be annotated
    using the `@Retention` annotation. This annotation has one parameter of the `RetentionPolicy`
    type, which is an `enum`. We will soon discuss how annotation parameters should
    be defined.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: Spring和其他框架通常在运行时处理注解。编译器和类加载器必须被指示注解在运行时应该保持可用。为此，必须使用`@Retention`注解来注解注解接口本身。这个注解有一个`RetentionPolicy`类型的参数，它是一个枚举。我们很快就会讨论注解参数应该如何定义。
- en: It is interesting to note that the `@Retention` annotation on the annotation
    interface has to be available in the class file; otherwise, the class loaders
    would not know how to treat an annotation. How do we signal that an annotation
    is to be kept by the compiler after the compilation process? We annotate the annotation
    interface declaration. Thus, the declaration of `@Retention` is annotated by itself
    and it is declared to be available in runtime.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的是要注意，注解接口上的`@Retention`注解必须在类文件中可用；否则，类加载器将不知道如何处理注解。我们如何通知编译器在编译过程结束后保留注解？我们注解注解接口声明。因此，`@Retention`的声明被自己注解，并声明为在运行时可用。
- en: The annotation declaration can be annotated using `@Retention(RetentionPolicy.SOURCE)`,
    `@Retention(RetentionPolicy.CLASS)`, or `@Retention(RetentionPolicy.RUNTIME)`.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 注解声明可以使用`@Retention(RetentionPolicy.SOURCE)`、`@Retention(RetentionPolicy.CLASS)`或`@Retention(RetentionPolicy.RUNTIME)`进行注解。
- en: Annotation target
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 注解目标
- en: The last retention type will be the most frequent used. There are also other
    annotations that can be used on annotation declarations. The `@Target` annotation
    can be used to restrict the use of the annotation to certain locations. The argument
    to this annotation is either a single `java.lang.annotation.ElementType` value
    or an array of these values. There is a good reason to restrict the use of annotations.
    It is much better to get a compilation time error when we place an annotation
    in the wrong place than hunting during runtime why the framework ignores our annotation.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 最后的保留类型将是使用最频繁的。还有其他可以在注解声明上使用的注解。`@Target`注解可以用来限制注解的使用范围。这个注解的参数是一个`java.lang.annotation.ElementType`的值或这些值的数组。限制注解的使用有一个很好的理由。当我们将注解放置在错误的位置时，得到编译时错误要比在运行时寻找框架为什么忽略我们的注解要好得多。
- en: Annotation parameters
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 注解参数
- en: Annotations, as we saw, can have parameters. To declare these parameters in
    the `@interface` declaration of the annotation, we use methods. These methods
    have a name and a return value, but they should not have an argument. You may
    try to declare some parameters, but the Java compiler will be strict and will
    not compile your code.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所见，注解可以有参数。为了在注解的`@interface`声明中声明这些参数，我们使用方法。这些方法有一个名称和返回值，但它们不应该有参数。你可以尝试声明一些参数，但Java编译器将会非常严格，不会编译你的代码。
- en: 'The values can be defined at the place where the annotation is used, using
    the name of the method and with the `=` character, assigning to them some value
    that is compatible with the type of the method. For example, let''s suppose that
    we modify the declaration of the annotation `PoweredDevice` to the following:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 这些值可以在使用注解的地方定义，使用方法名称和`=`字符，将一些与方法的类型兼容的值赋给它们。例如，假设我们修改注解`PoweredDevice`的声明如下：
- en: '[PRE6]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'In such a case, at the use of the annotation, we should specify some value
    for the parameter, such as the following:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，在使用注解时，我们应该为参数指定一些值，例如以下内容：
- en: '[PRE7]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'If the name of the parameter is a value and at the place of use of the annotation
    there is no other parameter defined, then the name, "value", may be skipped. For
    example, modifying the code as follows is a handy shorthand when we have only
    one parameter:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 如果参数的名称是一个值，并且在注解的使用位置没有定义其他参数，那么名称“value”可以被省略。例如，当我们只有一个参数时，按照以下方式修改代码是一个方便的缩写：
- en: '[PRE8]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'We can define optional parameters also using the `default` keyword following
    the method declaration. In this case, we have to define a default value for the
    parameter. Modifying the sample annotation we have further, we still can, but
    need not, specify the value. In the latter case, it will be an empty string:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以使用`default`关键字在方法声明后定义可选参数。在这种情况下，我们必须为参数定义一个默认值。进一步修改我们已有的示例注解，我们仍然可以，但不必指定值。在后一种情况下，它将是一个空字符串：
- en: '[PRE9]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Since the value we specify should be constant and calculable during compile
    time, there is not much use of complex types. Annotation parameters are usually
    strings, integers, and sometimes, doubles, or other primitive types. The exact
    list of the types given by the language specification is as follows:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们指定的值应该在编译时是常量和可计算的，因此复杂类型并没有太大的用途。注解参数通常是字符串、整数，有时是双精度浮点数或其他原始类型。语言规范提供的类型列表如下：
- en: Primitive (`double`, `int`, and so on)
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 原始类型（`double`、`int`等）
- en: String
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字符串
- en: Class
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类
- en: An enum
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 枚举
- en: Another annotation
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 另一个注解
- en: An array of any of the aforementioned types
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 上述任何类型的数组
- en: We have seen examples of `String` and also that `enum`:`Retention` and `Target`
    both have `enum` parameters. The interesting part we want to focus on is the last
    two items of the preceding list.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了`String`的例子，也看到了`enum`:`Retention`和`Target`都有`enum`参数。我们想要关注的有意思的部分是上述列表的最后两项。
- en: 'When the value of the parameter is an array, the value can be specified as
    comma-separated values between the `{` and`}` characters. For example:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 当参数的值是一个数组时，值可以在`{`和`}`字符之间指定为逗号分隔的值。例如：
- en: '[PRE10]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'This can then be added to the `@interface` annotation we can write:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以将其添加到我们可以编写的`@interface`注解中：
- en: '[PRE11]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'However, in case there is only one value we want to pass as the parameter value,
    we can still use the format:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果我们只想传递一个值作为参数值，我们仍然可以使用以下格式：
- en: '[PRE12]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'In this case, the value of the attribute will be an array of length `1`. When
    the value of an annotation is an array of annotation types, things get a bit more
    complex. We create an `@interface` annotation (note the plural in the name):'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，属性的值将是一个长度为`1`的数组。当注解的值是一个注解类型的数组时，事情会变得稍微复杂一些。我们创建一个`@interface`注解（注意名字中的复数形式）：
- en: '[PRE13]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The use of this annotation could be as follows:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 这个注解的使用可以如下所示：
- en: '[PRE14]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Note that this is not the same as having the `ParameteredPoweredDevice` annotation
    with three parameters. This is an annotation that has two parameters. Each parameter
    is an annotation. The first has one string parameter and the second has two.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这并不等同于拥有三个参数的`ParameteredPoweredDevice`注解。这是一个有两个参数的注解。每个参数都是一个注解。第一个有一个字符串参数，第二个有两个。
- en: As you can see, annotations can be fairly complex, and some of the frameworks
    (or rather the programmers who created them) ran amok using them. Before you start
    writing a framework, research to see whether there is already a framework that
    you can use. Also, check whether there is some other way to solve your problem.
    99% of annotation handling code could be avoided and made simpler. The less code
    we write for the same functionality, the happier we are. We programmers are the
    lazy types and this is the way it has to be.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，注解可以相当复杂，一些框架（或者更确切地说，创建它们的程序员）在使用它们时有些失控。在您开始编写框架之前，研究一下是否已经存在您可以使用的一个框架。同时，检查是否有其他方法可以解决您的问题。99%的注解处理代码可以避免，并变得简单。我们编写的代码越少，对于相同的功能就越满意。我们程序员是懒惰的类型，这就是必须这样做的原因。
- en: The last example, where the parameter of the annotation is an array of annotations,
    is important to understand how we can create repeatable annotations.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个例子，其中注解的参数是一个注解数组，理解我们如何创建可重复的注解是很重要的。
- en: Repeatable annotations
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可重复注解
- en: 'Annotate the declaration of the annotation with `@Repeatable` to denote that
    the annotation can be applied multiple times at one place. The parameter to this
    annotation is an annotation type that should have a parameter of type, which is
    an array of this annotation. Don''t try to understand! I''ll give an example instead.
    I already have, in fact: we have `@PoweredDevices`. It has an argument that is
    an array of `@ParameteredPoweredDevice`. Consider that we now annotate this `@interface`
    as the following:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`@Repeatable`注解注解注解的声明，以表示该注解可以在一个地方多次应用。这个注解的参数是一个注解类型，它应该有一个类型为该注解数组的参数。不要试图理解！我将给出一个例子。实际上，我已经有了：我们有`@PoweredDevices`。它有一个参数是一个`@ParameteredPoweredDevice`的数组。考虑我们现在将这个`@interface`注解如下：
- en: '[PRE15]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Then, we can simplify the use of `@ParameteredPoweredDevice`. We can repeat
    the annotation multiple times and the Java runtime will automatically enclose
    it in the wrapping class, which, in this case, is `@PoweredDevices`. In this case,
    the following two will be equivalent:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以简化`@ParameteredPoweredDevice`的使用。我们可以多次重复注解，Java运行时会自动将其封装在包装类中，在这种情况下是`@PoweredDevices`。在这种情况下，以下两个将是等效的：
- en: '[PRE16]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The reason for this complex approach is again an example of backward compatibility
    that Java strictly follows. Annotations were introduced in Java 1.5 and repeatable
    annotations have been available only since version 1.8\. We will soon talk about
    the reflection API that we use to handle the annotations during runtime. This
    API in the `java.lang.reflect.AnnotatedElement` interface has a `getAnnotation(annotationClass)`
    method, which returns an annotation. If a single annotation can appear more than
    once on a class, method, and so on, then there is no way of calling this method
    to get all the different instances with all the different parameters. Backward
    compatibility was ensured by introducing the containing type that wraps the multiple
    annotations.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 这种复杂方法的理由再次是Java严格遵循的后向兼容性的一个例子。注解是在Java 1.5中引入的，而可重复注解则只从版本1.8开始可用。我们很快就会谈到我们用来在运行时处理注解的反射API。这个API在`java.lang.reflect.AnnotatedElement`接口中有一个`getAnnotation(annotationClass)`方法，它返回一个注解。如果一个注解可以在类、方法等上出现多次，那么就没有办法调用这个方法来获取所有不同参数的不同实例。通过引入包含类型来包装多个注解，确保了后向兼容性。
- en: Annotation inheritance
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 注解继承
- en: Annotations, just like methods or fields, can be inherited between class hierarchies.
    If an annotation declaration is marked with `@Inherited`, then a class that extends
    another class with this annotation can inherit it. The annotation can be overridden
    in case the child class has the annotation. Because there is no multiple inheritance
    in Java, annotations on interfaces cannot be inherited. Even when the annotation
    is inherited, the application code that retrieves the annotation of a certain
    element can distinguish between the annotations that are inherited and those that
    are declared on the entity itself. There are methods to get the annotations and
    separate methods to get the declared annotations that are declared on the actual
    element, and not inherited.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 注解，就像方法或字段一样，可以在类层次结构之间继承。如果一个注解声明被标记为`@Inherited`，那么扩展了具有此注解的另一个类的类可以继承它。如果子类有注解，则可以覆盖注解。因为Java中没有多重继承，所以接口上的注解不能继承。即使注解被继承，检索特定元素注解的应用程序代码也可以区分继承的注解和实体本身声明的注解。有方法可以获取注解，还有单独的方法可以获取实际元素上声明的注解，而不是继承的。
- en: '@Documented annotations'
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`@Documented`注解'
- en: The `@Documented` annotation expresses the intent that the annotation is part
    of the contract of the entity and, this way, it has to get into the documentation.
    This is an annotation that the *JavaDoc* generator looks at when creating the
    documentation for an element that references the `@Documented` annotation.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '`@Documented`注解表达了这样的意图：注解是实体契约的一部分，因此它必须包含在文档中。这是一个*JavaDoc*生成器在创建引用`@Documented`注解的元素的文档时查看的注解。'
- en: JDK annotations
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JDK注解
- en: There are other annotations defined in the JDK in addition to those that are
    to be used to define annotations. We have already seen some of these. The most
    frequently used is the `@Override` annotation. When the compiler sees this annotation,
    it checks that the method really overrides some inherited method. Failing to do
    so will result in an error, saving us from miserable runtime debugging.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 除了用于定义注解的注解之外，JDK中还定义了其他一些注解。我们已经看到了其中的一些。最常用的是`@Override`注解。当编译器看到这个注解时，它会检查该方法是否真正覆盖了某个继承的方法。如果没有这样做，将会导致错误，从而避免我们在运行时调试中的痛苦。
- en: The `@Deprecated` annotation signals in the documentation of a method, class,
    or some other element that the element is not to be used. It is still there in
    the code, because some users may still use it, but in the case of a new development
    that depends on the library containing the element, the newly developed code should
    not use it. The annotation has two parameters. One parameter is `since`, which
    can have a string value and may deliver version information about how long or
    since which version of the method, or class is deprecated. The other parameter
    is `forRemoval`, which should be `true` if the element will not appear in the
    future versions of the library. Some methods may be deprecated because there are
    better alternatives but the developers do not intend to remove the method from
    the library. In such a case, the `forRemoval` can be set to `false`.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '`@Deprecated`注解在方法、类或其他元素的文档中表示该元素不应使用。它仍然存在于代码中，因为一些用户可能仍然会使用它，但在依赖于包含该元素库的新开发中，新开发的代码不应使用它。该注解有两个参数。一个参数是`since`，它可以有一个字符串值，可以提供关于方法或类何时或从哪个版本开始被弃用的版本信息。另一个参数是`forRemoval`，如果该元素将不会出现在库的未来版本中，则应设置为`true`。某些方法可能因为存在更好的替代方案而被弃用，但开发者并不打算从库中删除该方法。在这种情况下，`forRemoval`可以设置为`false`。'
- en: The `@SuppressWarning` annotation is also a frequently used one, though its
    use is questionable. It can be used to suppress some of the warnings of the compiler.
    It is recommended to write code, if possible, which can be compiled without any
    warning.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '`@SuppressWarning`注解也是一个常用的注解，尽管其使用是有疑问的。它可以用来抑制编译器的一些警告。如果可能，建议编写没有警告的代码。'
- en: The `@FunctionalInterface` annotation declares that an interface intends to
    have only one method. Such interfaces can be implemented as lambda expressions.
    You will learn about lambda expressions later in this chapter. When this annotation
    is applied on an interface and there is more than one method declared in the interface,
    the compiler will signal compilation error. This will prevent any developer early
    on from adding another method to an interface intended to be used together with
    functional programming and lambda expressions.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '`@FunctionalInterface`注解声明一个接口只打算有一个方法。这样的接口可以作为lambda表达式实现。你将在本章后面学习关于lambda表达式的内容。当这个注解应用于一个接口，并且接口中声明了多个方法时，编译器将发出编译错误。这将防止任何开发者早期向一个打算与函数式编程和lambda表达式一起使用的接口中添加另一个方法。'
- en: Using reflection
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用反射
- en: Now that you have learnt how to declare annotations and how to attach them to
    classes and methods, we can return to our `ProductInformation` class. Recall that
    we wanted to specify the type of products in this class and that each product
    type is represented by an `@interface` annotation. We have already listed it in
    the previous few pages, the one we will implement in our  `@PoweredDevice` example.
    We will develop the code assuming that later there will be many such annotations,
    product types, and consistency checkers that are annotated with `@Component` and
    with one or more of our annotations.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经学会了如何声明注解以及如何将它们附加到类和方法上，我们可以回到我们的`ProductInformation`类。回想一下，我们想要指定这个类中的产品类型，并且每种产品类型都由一个`@interface`注解表示。我们已经在之前的几页中列出了它，即我们将在`@PoweredDevice`示例中实现的一个。我们将假设将来会有许多这样的注解、产品类型和带有`@Component`以及一个或多个我们注解的一致性检查器。
- en: Getting annotations
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 获取注解
- en: 'We will extend the `ProductInformation` class with the following field:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用以下字段扩展`ProductInformation`类：
- en: '[PRE17]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Since this is a DTO, and Spring needs the setters and getters, we will also
    add a new getter and setter to it. This field will contain the list of classes
    that each class implement one of our annotations and also the built-in JDK interface,
    `Annotation`, because that is the way the Java compiler generates them. At this
    point, this may be a bit murky but I promise that the dawn will break and there
    will be light as we go on.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这是一个 DTO，Spring 需要设置器和获取器，因此我们也将添加一个新的获取器和设置器。这个字段将包含每个类实现的我们的一些注解以及内置的 JDK
    接口 `Annotation`，因为这就是 Java 编译器生成它们的方式。在这个阶段，这可能会有些模糊，但我保证随着我们的继续前进，曙光将破晓，光明将到来。
- en: To get the product information, we have to look it up by ID. This is the interface
    and service that we developed in the last chapter, except, this time, we have
    another new field. This is, in fact, a significant difference although the `ProductLookup`
    interface did not change at all. In the last chapter, we developed two versions.
    One of the versions was reading the data from a properties file, the other one
    was connecting to a REST service.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取产品信息，我们必须通过 ID 查找它。这是我们在上一章中开发的接口和服务，除了这次我们有一个新的字段。实际上，这是一个重大的区别，尽管 `ProductLookup`
    接口完全没有变化。在上一章中，我们开发了两个版本。其中一个版本是从属性文件中读取数据，另一个版本是连接到 REST 服务。
- en: Properties files are ugly and old technology but a must if ever you intend to
    pass a Java interview or work on enterprise applications developed at the start
    of the 21^(st) century. I had to include it in the last chapter. It was my own
    urge to include it in the book. At the same time, while coding for this chapter,
    I did not have the stomach to keep using it. I also wanted to show you that the
    same content could be managed in a JSON format.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 属性文件很丑陋，是过时的技术，但如果你打算通过 Java 面试或在 21 世纪初开发的企业应用程序中工作，则是必须的。我不得不将其包含在最后一章中。这是我自己强烈希望在书中包含它的愿望。同时，在编写这一章的代码时，我没有勇气继续使用它。我还想向你展示相同的内容可以用
    JSON 格式管理。
- en: 'Now, we will extend the implementation of `ResourceBasedProductLookup` to read
    the product information from JSON formatted resource files. Most of the code remains
    the same in the class; therefore, we only list the difference here:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将扩展 `ResourceBasedProductLookup` 的实现，以从 JSON 格式的资源文件中读取产品信息。在类中，大部分代码保持不变；因此，我们只列出这里的不同之处：
- en: '[PRE18]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'In the `project resources/products` directory we have a few JSON files. One
    of them contains the desk lamp product information:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `project resources/products` 目录中，我们有一些 JSON 文件。其中之一包含台灯产品的信息：
- en: '[PRE19]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The type of product is specified in a JSON array. In this example, this array
    has only one element and that element is the fully qualified name of the annotation
    interface that represents the type of product. When the JSON marshaller converts
    the JSON to a Java object, it recognizes that the field that needs this information
    is a `List`, so it converts the array to a list and, also, the elements from `String`
    to `Class` objects representing the annotation interface.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 产品类型在 JSON 数组中指定。在这个例子中，这个数组只有一个元素，而这个元素是表示产品类型的注解接口的完全限定名称。当 JSON 序列化器将 JSON
    转换为 Java 对象时，它会识别出需要此信息的字段是一个 `List`，因此它将数组转换为列表，并将元素从 `String` 转换为表示注解接口的 `Class`
    对象。
- en: 'Now that we have the resources loaded from JSON formatted resources and we
    saw how easy it is to read JSON data when using Spring, we can get back to the
    order consistency check. The `Checker` class implements the logic to collect the
    pluggable checkers and to invoke them. It also implements the annotation-based
    screening so as not to invoke the checkers we don''t really need for the actual
    products in the actual order:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经从 JSON 格式的资源中加载了资源，并看到了使用 Spring 读取 JSON 数据是多么容易，我们可以回到订单一致性检查。`Checker`
    类实现了收集可插拔检查器并调用它们的逻辑。它还实现了基于注解的筛选，以便不调用我们实际上不需要用于实际产品实际订单的检查器：
- en: '[PRE20]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: One of the interesting things to mention is that the Spring auto-wiring is very
    clever. We have a field with the `Collection<ConsistencyChecker>` type. Usually,
    auto-wiring works if there is exactly one class that has the same type as the
    resources to wire. In our case, we do not have any such candidate since this is
    a collection, but we have many `ConsistencyChecker` classes. All our checkers
    implement this interface and Spring recognizes it, instantiates them all, magically
    creates a collection of them, and injects the collection into this field.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个有趣的事情要提一下，那就是Spring的自动装配非常聪明。我们有一个`Collection<ConsistencyChecker>`类型的字段。通常，如果有一个恰好与要连接的资源类型相同的类，自动装配就会工作。在我们的情况下，我们没有这样的候选者，因为这是一个集合，但我们有多个`ConsistencyChecker`类。我们所有的检查器都实现了这个接口，Spring能够识别它们，实例化它们，神奇地创建一个它们的集合，并将这个集合注入到这个字段中。
- en: Usually a good framework works logically. I was not aware of this feature of
    Spring, but I thought that this would be logical and, magically, it worked. If
    things are logical and just work, you do not need to read and remember the documentation.
    A bit of caution does not harm however. After I experienced that this functionality
    works this way, I looked it up in the documentation to see that this is really
    a guaranteed feature of Spring and not something that just happens to work but
    may change in future versions without notice. Using only guaranteed features is
    extremely important but is neglected many times in our industry.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 通常一个好的框架在逻辑上是合理的。我之前并不了解Spring的这个特性，但我想这应该是合理的，神奇的是，它真的工作了。如果事情是合理的并且顺利运行，你就不需要阅读和记住文档。然而，一点谨慎并不会有害。在我体验过这个功能是这样工作的之后，我在文档中查看了这个功能，发现这确实是Spring的一个保证特性，而不是仅仅偶然工作，可能在未来的版本中未经通知而改变。只使用保证的特性非常重要，但我们的行业中经常被忽视。
- en: When the `isConsistent` method is invoked, it first collects the product information
    into `HashMap`, assigning a `ProductInformation` instance to each `OrderItem`.
    This is done in a separate class. After this, `ProductsCheckerCollector` collects
    the `ConsistencyChecker` instances needed by one or more product items. When we
    have this set, we need to invoke only those checkers that are annotated with one
    of the annotations that are in this set. We do that in a loop.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 当`isConsistent`方法被调用时，它首先将产品信息收集到`HashMap`中，为每个`OrderItem`分配一个`ProductInformation`实例。这是在一个单独的类中完成的。之后，`ProductsCheckerCollector`收集一个或多个产品项需要的`ConsistencyChecker`实例。当我们有了这个集合后，我们只需要调用那些带有这个集合中注解之一的检查器。我们在循环中这样做。
- en: In this code, we use reflection. We loop over the annotations that each checker
    has. To get the collection of annotations, we invoke `checker.getClass().getAnnotations()`.
    This invocation returns a collection of objects. Each object is an instance of
    some JDK runtime generated class that implements the interface we declared as
    an annotation in its own source file. There is no guarantee, though, that the
    dynamically created class implements only our `@interface` and not some other
    interfaces. Therefore, to get the actual annotation class, we have to invoke the
    `annotationType` method.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在此代码中，我们使用反射。我们遍历每个检查器拥有的注解。为了获取注解集合，我们调用`checker.getClass().getAnnotations()`。这个调用返回一个对象集合。每个对象都是实现我们自己在源文件中声明的注解接口的JDK运行时生成的类的实例。然而，没有保证动态创建的类只实现了我们的`@interface`而没有实现其他接口。因此，为了获取实际的注解类，我们必须调用`annotationType`方法。
- en: The `ProductCheckerCollector` and `ProductInformationCollector` classes are
    very simple, and we will discuss them later when we learn about streams. They
    will serve as a good example at that place, when we implement them using loops
    and, right after that, using streams.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '`ProductCheckerCollector`和`ProductInformationCollector`类非常简单，我们将在学习流时再讨论它们。它们将在那个地方作为一个很好的例子，当我们使用循环实现它们，然后立即使用流来实现。'
- en: 'Having them all, we can finally create our actual checker classes. The one
    that helps us see that there is a power cord ordered for our lamp is the following:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在拥有它们之后，我们最终可以创建我们的实际检查器类。帮助我们看到我们的台灯订购了电源线的那个类如下：
- en: '[PRE21]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The helper class contains simple methods that will be needed by many of the
    checkers, for example:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 辅助类包含许多检查器需要的简单方法，例如：
- en: '[PRE22]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Invoking methods
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调用方法
- en: In this example, we used only one single reflection call to get the annotations
    attached to a class. Reflection can do many more things. Handling annotations
    is the most important use for these calls since annotations do not have their
    own functionality and cannot be handled in any other way during runtime. Reflection,
    however, does not stop telling us what annotations a class or any other annotable
    element has. Reflection can be used to get a list of the methods of a class, the
    name of the methods as strings, the implemented interfaces of a class, the parent
    class it extends, the fields, the types of fields, and so on. Reflection generally
    provides methods and classes to walk through the actual code structure down to
    the method level, programmatically.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们只使用了一个单独的反射调用来获取附加到类上的注解。反射可以做更多的事情。处理注解是这些调用最重要的用途，因为注解没有自己的功能，并且在运行时无法以任何其他方式处理。然而，反射并没有停止告诉我们一个类或任何其他可注解元素有哪些注解。反射可以用来获取类的列表、方法名称作为字符串、类的实现接口、它扩展的父类、字段、字段类型等等。反射通常提供方法和类来遍历实际的代码结构，直到方法级别，以编程方式。
- en: This walkthrough does not only allow reading types and code structure but also
    makes it possible to set field values and call methods without knowing the methods'
    name at compile time. We can even set fields that are `private` and are not generally
    accessible by the outside world. It is also to note that accessing the methods
    and fields through reflection is usually slower than through compiled code because
    it always involves lookup by the name of the element in the code.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 这种遍历不仅允许读取类型和代码结构，而且还使得在编译时不知道方法名称的情况下设置字段值和调用方法成为可能。我们甚至可以设置那些是`private`且通常无法由外界访问的字段。还值得注意的是，通过反射访问方法和字段通常比通过编译代码慢，因为它总是涉及到在代码中通过元素名称进行查找。
- en: The rule of thumb is that if you see that you have to create code using reflection,
    then realize that you are probably creating a framework (or writing a book about
    Java that details reflection). Does it sound familiar?
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 经验法则表明，如果你发现必须使用反射来创建代码，那么意识到你可能正在创建一个框架（或者正在编写一本关于Java的书籍，详细介绍了反射）。这听起来熟悉吗？
- en: Spring also uses reflection to discover the classes, methods, and fields, and
    also to inject an object. It uses the URL class loader to list all the JAR files
    and directories that are on the class path, loads them, and examines the classes.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: Spring也使用反射来发现类、方法和字段，以及注入对象。它使用URL类加载器列出类路径上所有的JAR文件和目录，加载它们，并检查类。
- en: For a contrived example, for the sake of demonstration, let's assume that the
    `ConsistencyChecker` implementations were written by many external software vendors,
    and the architect who originally designed the program structure just forgot to
    include the `isConsistent` method in the interface. (At the same time, to save
    our mental health, we can also imagine that this person is not working anymore
    in the company for doing so.) As a consequence, the different vendors delivered
    Java classes that "implement" this interface but we cannot invoke the method,
    not only because we do not have a common parent interface that has this method
    but also because the vendors just happened to use different names for their methods.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 为了举例说明，为了演示目的，让我们假设`ConsistencyChecker`的实现是由许多外部软件供应商编写的，而最初设计程序结构的架构师恰好忘记在接口中包含`isConsistent`方法。（同时，为了保护我们的心理健康，我们也可以想象这个人因为这样做而不再在公司工作。）结果，不同的供应商提供了“实现”这个接口的Java类，但我们无法调用该方法，不仅因为我们没有具有此方法的公共父接口，而且因为供应商恰好使用了不同的方法名称。
- en: What can we do in this situation? Business-wise, asking all the vendors to rewrite
    their checkers is ruled out because them knowing we are in trouble attaches a
    hefty price tag to the task. Our managers want to avoid that cost and we developers
    also want to show that we can mend the situation and do miracles. (Later, I will
    have a comment on that.)
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下我们能做什么呢？从业务角度来看，要求所有供应商重写他们的检查器是不被允许的，因为他们知道我们遇到麻烦，这给任务贴上了高昂的标签。我们的经理们希望避免这种成本，我们开发者也希望表明我们可以修复这种情况并创造奇迹。（稍后，我会对此发表评论。）
- en: We could just have a class that knows every checker and how to invoke each of
    them in many different ways. This would require us to maintain the said class
    whenever a new checker is introduced to the system, and we want to avoid that.
    The whole plugin architecture we are using was invented for this very purpose
    in the first place.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以创建一个类，它知道每个校验器以及如何以多种不同的方式调用它们。这要求我们每次向系统中引入新的校验器时都要维护这个类，而我们希望避免这样做。我们最初发明整个插件架构正是为了这个目的。
- en: 'How can we invoke a method on an object that we know has only one declared
    method, which accepts an order as a parameter? That is where reflection comes
    into the picture. Instead of calling `checker.isInconsistent(order)`, we implement
    a small `private` method, `isInconsistent`, which calls the method, whatever its
    name is, via reflection:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何调用一个对象上的方法，我们知道这个对象只有一个声明的方法，它接受一个订单作为参数？这就是反射发挥作用的地方。我们不是调用`checker.isInconsistent(order)`，而是实现一个小的`private`方法`isInconsistent`，它通过反射调用该方法，无论其名称是什么：
- en: '[PRE23]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: We can get the class of the object by calling the `getClass` method, and on
    the object that represents the class itself, we can call `getDeclaredMethods`.
    Fortunately, the checker classes are not littered by many methods, so we check
    that there is only one method declared in the checker class. Note that there is
    also a `getMethods` method in the reflection library but it always will return
    more than one method. It returns the declared and the inherited methods. Because
    each and every class inherits from `java.lang.Object`, at least the methods of
    the `Object` class will be there.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过调用`getClass`方法来获取对象的类，对于代表类的对象本身，我们可以调用`getDeclaredMethods`。幸运的是，校验器类并没有被许多方法所充斥，因此我们检查校验器类中只声明了一个方法。请注意，反射库中还有一个`getMethods`方法，但它总是会返回多个方法。它返回声明和继承的方法。因为每个类都继承自`java.lang.Object`，至少`Object`类的那些方法都会存在。
- en: After this, we try to invoke the class using the `Method` object that represents
    the method in the reflection class. Note that this `Method` object is not directly
    attached to an instance. We retrieved the method from the class, and thus, when
    we invoke it, we should pass the object it should work on as a first parameter.
    This way, `x.y(z)`, becomes `method.invoke(x,z)`. The last parameter of invoke
    is a variable number of arguments that are passed as an `Object` array. In most
    cases, when we invoke a method, we know the arguments in our code even if we do
    not know the name of the method and have to use reflection. When even the arguments
    are not known but are available as a matter of calculation, then we have to pass
    them as an `Object` array.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在此之后，我们尝试使用代表反射类中方法的`Method`对象来调用类。请注意，这个`Method`对象并不是直接附加到一个实例上的。我们是从类中检索到这个方法的，因此当我们调用它时，我们应该将作为第一个参数传递给它应该工作的对象。这样，`x.y(z)`就变成了`method.invoke(x,z)`。`invoke`方法的最后一个参数是一个可变数量的参数，它们作为`Object`数组传递。在大多数情况下，当我们调用一个方法时，即使我们不知道方法的名称，也必须使用反射，我们也会知道我们的代码中的参数。当即使参数也不为人所知但可以通过计算获得时，我们必须将它们作为`Object`数组传递。
- en: Invoking a method via reflection is a risky call. If we try to call a method
    the normal way, which is `private`, then the compiler will signal an error. If
    the number of arguments or types are not appropriate, the compiler will again
    will give us an error. If the returned value is not `boolean`, or there is no
    return value at all, then we again get a compiler error. In the case of reflection,
    the compiler is clueless. It does not know what method we will invoke when the
    code is executing. The `invoke` method, on the other hand, can and will notice
    all these failures when it is invoked. If any of the aforementioned problems occur,
    then we will get exceptions. If the `invoke` method itself sees that it cannot
    perform what we ask of it, then it will throw `InvocationTargetException` or `IllegalAccessException`.
    If the conversion from the actual return value to `boolean` is not possible, then
    we will get `ClassCastException`.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 通过反射调用方法是一个风险很大的调用。如果我们尝试以正常的方式调用一个方法，比如`private`，编译器将会报错。如果参数的数量或类型不合适，编译器会再次给我们报错。如果返回值不是`boolean`，或者根本没有返回值，那么我们再次得到编译器错误。在反射的情况下，编译器是无知的。它不知道代码执行时将调用哪个方法。另一方面，`invoke`方法在调用时可以并会注意到所有这些失败。如果上述任何问题发生，我们将会得到异常。如果`invoke`方法本身看到它无法执行我们所要求的事情，那么它将抛出`InvocationTargetException`或`IllegalAccessException`。如果从实际返回值到`boolean`的转换不可能，那么我们将得到`ClassCastException`。
- en: About doing magic, it is a natural urge that we feel like making something extraordinary,
    something outstanding. This is okay when we are experimenting with something,
    doing a hobby job. On the other hand, this is strongly not okay when we are working
    on a professional job. Average programmers, who do not understand your brilliant
    solution, will maintain the code in an enterprise environment. They will turn
    your nicely combed code into haystack while fixing some bugs or implementing some
    minor new features. Even if you are the Mozart of programming, they will be, at
    best, no-name singers. A brilliant code in an enterprise environment can be a
    requiem, with all the implications of that metaphor.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 关于做魔术，这是一种自然的冲动，我们想要创造出非凡的、杰出的事物。当我们进行实验或从事爱好工作时，这是可以接受的。另一方面，当我们从事专业工作时，这却绝对是不妥的。那些不理解你聪明解决方案的普通程序员，会在企业环境中维护代码。他们会将你精心整理的代码变成一堆乱麻，在修复一些错误或实现一些小的新功能时。即使你是编程界的莫扎特，他们充其量也只是不知名的歌手。在企业环境中，一段精彩的代码可能就像一首挽歌，带有所有这个比喻的含义。
- en: Last but not least, the sad reality is that we are usually not the Mozarts of
    programming.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 最后但同样重要的是，一个令人悲伤的现实是，我们通常不是编程界的莫扎特。
- en: Note that in case the return value of the original value is primitive, then
    it will be converted to an object by reflection, and then we will convert it back
    to the primitive value. If the method does not have a return value, in other words,
    if it is `void`, then the reflection will return a `java.lang.Void` object. The
    `Void` object is only a placeholder. We cannot convert it to any primitive value
    or any other type of objects. It is needed because Java is strict and `invoke`
    has to return an `Object`, so the runtime needs something that it can return.
    All we can do is check that the returned value class is really `Void`.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，如果原始值的返回值是原始类型，那么它将通过反射转换为对象，然后我们将其转换回原始值。如果没有返回值，换句话说，如果它是`void`，那么反射将返回一个`java.lang.Void`对象。`Void`对象只是一个占位符。我们不能将其转换为任何原始值或任何其他类型的对象。这是必需的，因为Java是严格的，`invoke`必须返回一个`Object`，所以运行时需要一些可以返回的东西。我们所能做的就是检查返回值的类是否确实是`Void`。
- en: 'Let''s go on with the storyline and our solution. We submitted the code and
    it works in production for a while till a new update from a software vendor breaks
    it. We debug the code in the test environment and see that the class now contains
    more than one method. Our documentation clearly states that they should only have
    one `public` method, and they provided a code that has...hmm...we realize that
    the other methods are `private`. They are right; they can have `private` methods
    according to the contract, so we have to amend the code. We replace the lines
    that look up the one and only method:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续故事情节和我们的解决方案。我们提交了代码，它在生产环境中运行了一段时间，直到软件供应商的新更新将其破坏。我们在测试环境中调试代码，看到现在这个类包含多个方法。我们的文档明确指出，它们应该只有一个`public`方法，他们提供了一个有...嗯...我们意识到其他方法都是`private`的。他们是正确的；根据合同，他们可以有`private`方法，所以我们必须修改代码。我们替换了查找唯一方法的行：
- en: '[PRE24]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The new code will be as follows:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 新的代码如下：
- en: '[PRE25]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The new method we write to look up the one and only `public` method is as follows:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 我们编写的新方法来查找唯一的`public`方法如下：
- en: '[PRE26]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: To check whether the method is `public` or not, we use a `static` method from
    the `Modifier` class. There are methods to check all possible modifiers. The value
    that the `getModifiers` method returns is an `int` bit field. Different bits have
    different modifiers and there are constants that define these. This simplification
    leads to inconsistency, which you can check if a method is an interface or volatile,
    that is, actually nonsense. The fact is that bits that can only be used for other
    types of reflection objects will never be set.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 要检查方法是否是`public`的，我们使用`Modifier`类的一个`static`方法。有方法可以检查所有可能的修饰符。`getModifiers`方法返回的值是一个`int`位字段。不同的位有不同的修饰符，有一些常量定义了这些。这种简化导致了不一致性，你可以检查一个方法是否是接口或易失性的，实际上这是荒谬的。事实是，只能用于其他类型反射对象的位永远不会被设置。
- en: 'There is one exception, which is `volatile`. This bit is reused to signal bridge
    methods. Bridge methods are created by the compiler automatically and can have
    deep and complex issues that we do not discuss in this book. The reuse of the
    same bit does not cause confusion because a field can be `volatile`, but as a
    field, it cannot be a bridge method. Obviously, a field is a field and not a method.
    In the same way, a method cannot be a `volatile` field. The general rule is: do
    not use methods on reflection objects where they do not have a meaning; or else,
    know what you do.'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个例外，就是`volatile`。这个位被重新用于表示桥接方法。桥接方法是由编译器自动创建的，可能存在深奥和复杂的问题，我们在这本书中不讨论。由于重用了相同的位，所以不会引起混淆，因为字段可以是`volatile`的，但作为一个字段，它不能是桥接方法。显然，字段就是字段，而不是方法。同样，方法不能是`volatile`字段。一般规则是：不要在反射对象上使用没有意义的方法；否则，了解你在做什么。
- en: Making the storyline even more intricate, a new version of a checker accidentally
    implements the checking method as a package `private`. The programmer simply forgot
    to use the `public` keyword. For the sake of simplicity, let's assume that the
    classes declare only one method again, but it is not public. How do we solve this
    problem using reflection?
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使故事线更加复杂，一个检查器的版本意外地将检查方法实现为包`private`。程序员只是忘记使用`public`关键字。为了简化，让我们再次假设类只声明了一个方法，但这个方法不是公开的。我们如何使用反射来解决这个问题？
- en: 'Obviously, the simplest solution is to ask the vendors to fix the problem:
    it is their fault. In some cases, however, we must create a workaround over some
    problems. There is another solution: creating a class with a `public` method in
    the same package, invoking the package `private` methods from the other class,
    thus relaying the other class. As a matter of fact, this solution, as a workaround
    for such a bug, seems to be more logical and cleaner, but this time, we want to
    use reflection.'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，最简单的解决方案是要求供应商修复问题：这是他们的责任。然而，在某些情况下，我们必须在某个问题上创建一个解决方案。另一个解决方案是创建一个具有相同包中`public`方法的类，从其他类中调用包`private`方法，从而传递其他类。实际上，这个解决方案，作为此类错误的解决方案，似乎更加合理和干净，但这次，我们想使用反射。
- en: 'To avoid `java.lang.IllegalAccessException`, we have to set the `method` object
    as accessible. To do so, we have to insert the following line in front of the
    invocation:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免`java.lang.IllegalAccessException`，我们必须将`method`对象设置为可访问。为此，我们必须在调用之前插入以下行：
- en: '[PRE27]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Note that this will not change the method to `public`. It will only make the
    method accessible for invocation through the very instance of the `method` object
    that we set as accessible.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这不会将方法改为`public`。它只会使方法对于通过我们设置为可访问的`method`对象实例的可访问。
- en: I have seen code that checks whether a method is accessible or not by calling
    the `isAccessible` method and saves this information; it sets the method as accessible
    if it was not accessible and restores the original accessibility after the invocation.
    This is totally useless. As soon as the `method` variable goes out of scope, and
    there is no reference to the object we set the accessibility flag to, the effect
    of the setting wears off. Also, there is no penalty for setting the accessibility
    of a `public` or an otherwise callable method.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 我见过一些代码通过调用`isAccessible`方法来检查一个方法是否可访问，并将此信息保存下来；如果方法原本不可访问，则将其设置为可访问，并在调用后恢复原始的可访问性。这完全是多余的。一旦`method`变量超出作用域，并且没有引用我们设置可访问性标志的对象，设置的效果就会消失。此外，设置`public`或可调用的方法的可访问性没有惩罚。
- en: Setting fields
  id: totrans-157
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置字段
- en: 'We can also call `setAccessible` on `Field` objects and then we can even set
    the value of private fields using reflection. Without further fake stories, just
    for the sake of the example, let''s make a `ConsistencyChecker` named `SettableChecker`:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以在`Field`对象上调用`setAccessible`，然后我们可以甚至使用反射设置私有字段的值。不进一步编造故事，只是为了举例，让我们创建一个名为`ConsistencyChecker`的`SettableChecker`：
- en: '[PRE28]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'This checker will return `false`, unless we set the field to `true` using reflection.
    We do set it as such. We create a method in the `Checker` class and invoke it
    from the checking process for each checker:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 这个检查器将返回`false`，除非我们使用反射将字段设置为`true`。我们确实这样做了。我们在`Checker`类中创建了一个方法，并在检查过程中的每个检查器中调用它：
- en: '[PRE29]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The method goes through all the declared fields and if the name is `setValue`
    and the type is `boolean`, then it sets it to `true`. This will essentially render
    all orders that contain a powered device as rejected.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: Note that although `boolean` is a built-in language primitive, which is not
    a class by any means, it still has a class so that reflection can compare the
    type of the field gainst he class that `boolean` artificially has. Now `boolean.class`
    is a class literal in the language, and for each primitive, a similar constant
    can be used. The compiler identifies these as class literals and creates the appropriate
    pseudo class references in the byte code so that primitives can also be checked
    in this way, as demonstrated in the sample code of the `setValueInChecker` method.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: We checked that the field has the appropriate type, and we also called the `setAccessible`
    method on the field. Even though the compiler does not know that we really did
    everything to avoid `IllegalAccessException`, it still believes that calling `set`
    on `field` can throw such an exception, as it is declared. However, we know that
    it should not happen. (Famous last words of a programmer?) To handle this situation,
    we surround the method call with a `try` block, and in the `catch` branch, we
    log the exception.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: Functional programming in Java
  id: totrans-165
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Since we have created a lot of code in our example for this chapter, we will
    look at the functional programming features of Java, which will help us delete
    many lines from our code. The less code we have, the easier it is to maintain
    the application; thus, programmers love functional programming. But this is not
    the only reason why functional programming is so popular. It is also an excellent
    way to describe certain algorithms in a more readable and less error prone manner
    than conventional loops.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: Functional programming is not a new thing. The mathematical background was developed
    for it in the 1930s. One of the first (if not the first) functional programming
    languages is LISP. It was developed in the 1950s and it is still in use, so much
    that there is a version of the language implemented on the JVM (Clojure).
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: Functional programming, in short, means that we express the program structure
    in terms of functions. In this meaning, we should think of functions as in mathematics
    and not as the term is used in programming languages such as C. In Java, we have
    methods, and when we are following the functional programming paradigm, we create
    and use methods that behave like mathematical functions. A method is functional
    if it gives the same result no matter how many times we invoke it, just as *sin(0)*
    is always zero. Functional programming avoids changing the state of objects, and
    because the state is not changing, the results are always the same. This also
    eases debugging.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: If a function has once returned a certain value for the given arguments, it
    will always return the same value. We can also read the code as a declaration
    of the calculation more than as commands that are executed one after the other.
    If the execution order is not important, then the readability of the code may
    also increase.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: Java helps functional programming style with lambda expressions and streams.
    Note that these streams are not I/O streams and do not really have any relation
    to those.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: We will first take a short look at lambda expressions and what streams are,
    and then, we will convert some parts of our program to use these programming constructs.
    We will also see how much more readable these codes become.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: Readability is a debatable topic. A code may be readable to one developer and
    may be less readable to another. It very much depends on what they got used to.
    I experience many times that developers get distracted with streams. When developers
    first meet streams, the way to think about them and how they look is just strange.
    But this is the same as starting to learn using a bicycle. While you are still
    learning its use and you fall more than you roll, it is definitely slower than
    walking. On the other hand, once you have learnt how to ride a bike...
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: Lambda
  id: totrans-173
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We have already used lambda expressions in [Chapter 3](part0076.html), *Optimizing
    the Sort - Making Code Professional* when we wrote the exception-throwing test.
    In that code, we set the comparator to a special value that was throwing `RuntimeException`
    at each invocation:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The argument type is `Comparator`; therefore, what we have to set there should
    be an instance of a class that implements the `java.util.Comparator` interface.
    That interface defines only one method that implementations have to define: `compare.`
    Thus, we can define it as a lambda expression. Without lambda, if we need an instance,
    we have to type a lot. We have to create a class, name it, declare the `compare`
    method in it, and write the body of the method, as shown in the following code
    segment:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'At the location of use, we should instantiate the class and pass it as an argument:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: We may save a few characters if we define the class as an anonymous class but
    the overhead is still there. What we really need is the body of the one and single
    method that we have to define. This is where lambda comes into the picture.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: We can use a lambda expression in any place where we would otherwise need an
    instance of a class that has to define only one method. The methods that are defined
    and inherited from `Object` do not count, and we also do not care about the methods
    that are defined as `default` methods in the interface. They are there. Lambda
    defines the one that is not yet defined. In other words, lambda clearly depicts,
    with much less overhead as an anonymous class, that the value is a functionality
    that we pass as a parameter.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: 'The simple form of a lambda expression is as follows:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The parameters can be enclosed between parentheses or can only stand without.
    The body similarly can be enclosed between the `{` and`}` characters or it can
    be a simple expression. This way a lambda expression can reduce the overhead to
    a minimum, using the parentheses only where they are really needed.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: 'It is also an extremely useful feature of lambda expressions that we do not
    need to specify the types of the parameters in case it is obvious from the context
    where we use the expression. Thus, the preceding code segment can even be shorter,
    as follows:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The parameters, `a` and `b`, will have the type as needed. To make it even simpler,
    we can also omit the `(` and`)` characters around the parameters in case there
    is only one.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: 'The parentheses are not optional if there is more than one parameter. This
    is to avoid ambiguity in some situations. For example, the method call, `f(x,y->x+y)`
    could have been a method with two arguments: `x` and a lambda expression that
    has one parameter, `y`. At the same time, it could also be a method call with
    a lambda expression that has two parameters, `x` and `y`.'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: Lambda expressions are very handy when we want to pass functionality as an argument.
    The declaration of the type of argument at the place of the method declaration
    should be a functional interface type. These interfaces can optionally be annotated
    using `@FunctionalInterface`. The Java runtime has many such interfaces defined
    in the `java.util.function` package. We will discuss some of them in the next
    section along with their use in streams. For the rest, the standard Java documentation
    is available from Oracle.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: Streams
  id: totrans-190
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Streams were also new in Java 8, just like lambda expressions. They work together
    very strongly, so their appearance at the same time is not a surprise. Lambda
    expressions as well as streams support the functional programming style.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: The very first thing to clarify is that streams do not have anything to do with
    input and output streams, except the name. They are totally different things.
    Streams are more like collections with some significant differences. (If there
    were no differences, they would just have been collections.) Streams are essentially
    pipelines of operations that can run sequentially or in parallel. They obtain
    their data from collections or other sources, including data that is manufactured
    on-the-fly.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: Streams support the execution of the same calculation on multiple data. This
    structure is referred to as **Single Instruction Multiple Data** (**SIMD**). Don't
    be afraid of the expression. This is a very simple thing. We have already done
    that many times in this book. Loops are also kind of SIMD structures. When we
    loop through the checker classes to see whether any of those opposes the order,
    we perform the same instruction for each and every checker. Multiple checkers
    are multiple data.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: One problem with loops is that we define the order of execution when it is not
    needed. In the case of checkers, we do not really care what order the checkers
    are executed in. All we care about is that all are okay with the order. We still
    specify some order when we program the loop. This comes from the nature of loops,
    and there is no way we could change that. That is how they work. However, it would
    be nice if we could just, somehow, say *"do this and that for each and every checker"*.
    This is one point where streams come into the picture.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: Another point is that code that uses loops is more imperative rather than descriptive.
    When we read the program of a loop construct, we focus on the individual steps.
    We first see what the commands in the loop do. These commands work on the individual
    elements of the data and not on the whole collection or array.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: Later putting the individual steps together in our brain we realize what the
    big picture is, what the loop is for. In the case of streams, the description
    of operations is a level higher. Once we learn the stream methods, it is easier
    to read them. Stream methods work on the whole stream and not on the individual
    elements, and thus are more descriptive.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: '`java.lang.Stream` is an interface. An object with a type implementing this
    interface represents many objects and provides methods that can be used to perform
    instructions on these objects. The objects may or may not be available when we
    start the operation on one of them, or may just be created when needed. This is
    up to the actual implementation of the `Stream` interface. For example, suppose
    we generate a stream that contains `int` values using the following code:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: In the preceding code snippet, all the elements cannot be generated because
    the stream contains an infinite number of elements. This example will return the
    numbers 0, 1, 2, and so on until further stream operations, which are not listed
    here, terminate the calculation.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: When we program `Stream`, we usually create a stream from a `Collection`—not
    always, but many times. The `Collection` interface was extended in Java 8 to provide
    the `stream` and `parallelStream` methods. Both of them return stream objects
    that represent the elements of the collection. While `stream` returns the elements
    in the same order as they are in the collection in case there is a natural order,
    the `parallelStream` creates a stream that may be worked on in a parallel manner.
    In this case, if some of the methods that we use on the stream are implemented
    in that way, the code can use the multiple processors available in the computer.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: As soon as we have a stream, we can use the methods that the `Stream` interface
    defines. The one to start with is `forEach`. This method has one argument, which
    is usually provided as a lambda expression and will execute the lambda expression
    for each element of the stream.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `Checker` class, we have the `isConsistent` method. In this method,
    there is a loop that goes through the annotations of the checker class. If we
    wanted to log the interfaces that the annotation in the loop implements, we could
    add the following:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: In this example, we create a stream from an array using the factory method from
    the `Arrays` class. The array contains the interfaces returned by the reflection
    method, `getInterfaces`. The lambda expression has only one parameter; thus, we
    do not need to use parentheses around it. The body of the expression is a method
    call that returns no value; thus, we also omit the `{` and `}` characters.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: Why all this hassle? What is the gain? Why couldn't we just write a simple loop
    that logs the elements of the array?
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: The gains are readability and maintainability. When we create a program, we
    have to focus on *what* the program should do and not on *how* it should do it.
    In an ideal world, a specification would just be executable. We may actually get
    there in the future when programming work will be replaced by artificial intelligence.
    (Not the programmers, though.) We are not there, yet. We have to tell the computers
    how to do what we want to achieve. We used to have to enter binary codes on the
    console of PDP-11 to get machine code deployed into the memory to have it executed.
    Later, we had assemblers; still later, we had FORTRAN and other high-level programming
    languages that have replaced much of the programming work as it was 40 years ago.
    All these developments in programming shift the direction from *how* towards *what*.
    Today, we program in Java 9, and the road still has miles to go.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: The more we can express what to do instead of how to do, the shorter and more
    understandable our programs will be. It will contain the essence and not some
    artificial litter that is needed by the machines to just do what we want.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: When I see a loop in a code I have to maintain, I assume that there is some
    importance of the order in which the loop is executed. There may be no importance
    at all. It may be obvious after a few seconds. It may need minutes or more to
    realize that the ordering is not important. This time is wasted and can be saved
    with programming constructs that better express the *what to do* part instead
    of the *how to do*.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: Functional interfaces
  id: totrans-209
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The argument to the method should be `java.util.function.Consumer`. This is
    an interface that requires the `accept` method to be defined, and this method
    is `void`. The lambda expression or a class that implements this interface will
    *consume* the argument of the `accept` method and does not produce anything.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: There are several other interfaces defined in that package, each serving as
    a functional interface used to describe some method arguments that can be given
    as lambda expressions in the actual parameters.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: For example, the opposite of `Consumer` is `Supplier`. This interface has a
    method named `get` that does not need any argument but gives some `Object` as
    a return value.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: If there is an argument and also a returned value, the interface is called `Function`.
    If the returned value has to be the same type as the argument, then the `UnaryOperator`
    interface is our friend. Similarly, there is a `BinaryOperator` interface, which
    returns an object of the same type as the arguments. Just as we got from `Function`
    to `UnaryOperator`, we can see that in the other direction, there is also `BiFunction`
    in case the arguments and the return values do not share the type.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: These interfaces are not defined independently of each other. If a method requires
    `Function` and we have `UnaryOperator` to pass, it should not be a problem. `UnaryOperator`
    is nothing else but `Function` that has the same type of arguments. A method that
    can work with `Function`, which accepts an object and returns an object, should
    not have a problem if they have the same type. Those can be, but need not be,
    different.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: To let that happen, the `UnaryOperator` interface extends `Function` and thus
    can be used in the place of `Function`.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: The interfaces in this class we met so far are defined using generics. Because
    generic types cannot be primitives, the interfaces that operate on primitive values
    should be defined separately. `Predicate`, for example, is an interface that defines
    `booleantest(T t)`. It is a function that returns a `boolean` value and is used
    many times in stream methods.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: There are also interfaces, such as `BooleanSupplier`, `DoubleConsumer`, `DoubleToIntFunction`,
    and more, that work with primitive `boolean`, `double`, and `int`. The number
    of possible combinations of the different argument types and return values is
    infinite... almost.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: '**Fun fact**: To be very precise, it is not infinite. A method can have at
    most 254 arguments. This limit is specified in the JVM and not in the Java language
    specification. Of course, one is useless without the other. There are 8 primitive
    types (plus `Object`, plus the possibility that there are less than 254 arguments),
    which means that the total number of possible functional interfaces is 10^(254),
    give or take, a few magnitudes. Practically, infinite!'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: We should not expect to have all the possible interfaces defined in the JDK
    in this package. These are only those interfaces that are the most useful. There
    is no interface, for example, that uses `short` or `char`. If we need anything
    like that, then we can define the `interface` in our code. Or just think hard
    and find out how to use an already defined one. (I have never used the `short`
    type during my professional carrier. It was never needed.)
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: How are these functional interfaces used in streams? The `Stream` interface
    defines the methods that have some functional interface types as arguments. For
    example, the `allMatch` method has a `Predicate` argument and returns a `Boolean`
    value, which is `true` if all the elements in the stream match `Predicate`. In
    other words, this method returns `true` if and only if `Predicate`, supplied as
    an argument, returns `true` for each and every element of the stream.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following code, we will rewrite some of the methods that we implemented
    in our sample code using loops to use streams, and through these examples, we
    will discuss the most important methods that streams provide. We saved up two
    classes, `ProductsCheckerCollector` and `ProductInformationCollector`, to demonstrate
    the stream usage. We can start with these. `ProductsCheckerCollector` goes through
    all the products that are contained in the `Order` and collects the annotations
    that are listed in the products. Each product may contain zero, one, or many annotations.
    These are available in a list. The same annotation may be referenced multiple
    times. To avoid duplicates, we use `HashSet`, which will contain only one instance
    of the elements even if there are multiple instances in the products:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Now, let''s see how this method looks when we recode it using streams:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The major work of the method gets into a single, though huge, stream expression.
    We will cover the elements of the expression in the coming pages. `List` returned
    by `order.getItems` is converted calling the `stream` method:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: As we have already mentioned it briefly, the `stream` method is part of the
    `Collection` interface. Any class that implements the `Collection` interface will
    have this method, even those that were implemented before streams were introduced
    in Java 8\. This is because the `stream` method is implemented in the interface
    as a `default` method. This way, if we happen to implement a class implementing
    this interface, even if we do not need streams, we get it for free as an extra.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: The `default` methods in Java 8 were introduced to support backward compatibility
    of interfaces. Some of the interfaces of the JDK were to be modified to support
    lambda and functional programming. One example is the `stream` method. With the
    pre-Java 8 feature set, the classes implementing some of the modified interfaces
    should have been modified. They would have been required to implement the new
    method. Such a change is not backward compatible, and Java as a language and JDK
    was paying keen attention to be backward compatible. Thus, `default` methods were
    introduced. These let a developer extend an interface and still keep it backward
    compatible, providing a default implementation for the methods, which are new.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: Contrary to this philosophy, brand new functional interfaces of Java 8 JDK also
    have `default` methods, though, having no prior version in the JDK, they have
    nothing to be compatible with. In Java 9, interfaces were also extended and now
    they can contain not only `default` and `static` methods but also `private` methods.
    This way, interfaces became kind of equivalent to abstract classes, though there
    are no fields in an interface except constant `static` fields. This interface
    functionality open up is a much criticized feature, which just poses the programming
    style and structural issues that other languages allowing multiple class inheritance
    face. Java was avoiding this till Java 8 and Java 9.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: What is the take-away from this? Be careful with `default` methods and also
    with `private` methods in interfaces. Use them wisely if at all.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: The elements of this stream are `OrderItem` objects. We need `ProductInformation`
    for each `OrderItem`.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: Method references
  id: totrans-232
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Lucky that we have `Map`, which pairs order items with product information, so
    we can invoke `get` on `Map`:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: The `map` method is again something that has the same name as something else
    in Java and should not be confused. While the `Map` class is a data structure,
    the `map` method in the `Stream` interface performs mapping of the stream elements.
    The argument of the method is a `Function` (recall that this is a functional interface
    we recently discussed). This function converts a value, `T`, which is available
    as the element of the original stream (`Stream<T>`) to a value, `R`, and the return
    value of the `map` method is `Stream<R>`. The `map` method converts `Stream<T>`
    to `Stream<R>` using the given `Function<T,R>`, calling it for each element of
    the original stream and creating a new stream from the converted elements.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: We can say that the `Map` interface maps keys to values in a data structure
    in a static way, and the `Stream` method, `map`, maps one type of values to another
    (or the same) type of values dynamically.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: 'We have already seen that we can provide an instance of a functional interface
    in the form of a lambda expression. This argument is not a lambda expression.
    This is a method reference. It says that the `map` method should invoke the `get`
    method on `Map piMap` using the actual stream element as an argument. We are lucky
    that `get` also needs one argument, aren''t we? We could also write as follows:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: However, this would have been exactly the same as `piMap::get`.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: This way, we can reference an instance method that works on a certain instance.
    In our example, the instance is the one referenced by the `piMap` variable. It
    is also possible to reference `static` methods. In this case, the name of the
    class should be written in front of the `::` characters. We will soon see an example
    of this when we will use the `static` method, `nonNull`, from the `Objects` class
    (note that the class name is in plural, and it is in the `java.util` package and
    not `java.lang`).
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
- en: It is also possible to reference an instance method without giving the reference
    on which it should be invoked. This can be used in places where the functional
    interface method has an extra first parameter, which will be used as the instance.
    We have already used this in [Chapter 3](part0076.html), *Optimizing the Sort
    - Making Code Professional*, when we passed `String::compareTo`, when the expected
    argument was a `Comparator`. The `compareTo` method expects one argument, but
    the `compare` method in the `Comparator` interface needs two. In such a situation,
    the first argument will be used as the instance on which `compare` has to be invoked
    and the second argument is passed to `compare`. In this case, `String::compareTo`
    is the same as writing the lambda expression `(String a, String b) -> a.compareTo(b)`.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
- en: Last but not least, we can use method references to constructors. When we need
    a `Supplier` of (let's be simple) `Object`, we can write `Object::new`.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
- en: 'The next step is to filter out the `null` elements from the stream. Note that,
    at this point, the stream has `ProductInformation` elements:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: The `filter` method uses `Predicate` and creates a stream that contains only
    the elements that match the predicate. In this case, we used the reference to
    a `static` method. The `filter` method does not change the type of stream. It
    only filters out the elements.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
- en: The next method we apply is a bit anti-functional. Pure functional stream methods
    do not alter the state of any object. They create new objects that they return
    but, other than that, there is no side effect. `peek` itself is no different because
    it only returns a stream of the same elements as the one it is applied on. However,
    this *no-operation* feature lures the novice programmer to do something non-functional
    and write code with side-effects. After all, why use it if there is no (side)
    effect in calling it?
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'While the  `peek` method itself does not have any side effects, the execution
    of the lambda expression may have. However, this is also true for any of the other
    methods. It is just the fact that, in this case, it is more tempting to do something
    inadequate. Don''t. We are disciplined adults. As the name of the method suggests,
    we may peek into the stream but we are not supposed to do anything else. With
    programming being a particular activity, in this case, peeking, is adequate. And
    that is what we actually do in our code: we log something.'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
- en: 'After this, we get rid of the elements that have no `ProductInformation`; we
    also want to get rid of the elements that have, but there is no checker defined:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'In this case, we cannot use method references. Instead, we use a lambda expression.
    As an alternative solution, we may create a `boolean hasCheck` method in `ProductInformation`,
    which returns `true` if the `private` field check is not `null`. This would then
    read as follows:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: This is totally valid and works, although the class does not implement any functional
    interface and has many methods, not only this one. However, the method reference
    is explicit and specifies which method to invoke.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
- en: 'After this second filter, we log the elements again:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'The next method is `flatMap` and this is something special and not easy to
    comprehend. At least for me, it was a bit more difficult than understanding `map`
    and `filter` when I learned functional programming:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: This method expects that the lambda, method reference, or whatever is passed
    to it as an argument, creates a whole new stream of objects for each element of
    the original stream the method is invoked on. The result is, however, not a stream
    of streams, which also could be possible, but rather the returned streams are
    concatenated into one huge stream.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
- en: If the stream we apply it to is a stream of integer numbers, such as 1, 2, 3,
    ..., and the function for each number *n* returns a stream of three elements *n*,
    *n+1*, and *n+2*, then the resulting stream, `flatMap`, produces a stream containing
    1, 2, 3, 2, 3, 4, 3, 4, 5, 4, 5, 6, and so on.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, the stream we have should be collected to a `Set`. This is done by
    calling the `collector` method:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: The argument to the `collector` method is (again a name overuse) `Collector`.
    It can be used to collect the elements of the stream into some collection. Note
    that `Collector` is *not* a functional interface. You cannot just collect something
    using a lambda or a simple method. To collect the elements, we definitely need
    some place where the elements are collected as the ever-newer elements come from
    the stream. The `Collector` interface is not simple. Fortunately, the `java.util.streams.Collectors`
    class (again note the plural) has a lot of `static` methods that create and return
    `Object` that create and return `Collector` objects.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
- en: One of these is `toSet`, which returns a `Collector` that helps collect the
    elements of the stream into a `Set`. The `collect` method will return the `Set`
    when all the elements are there. There are other methods that help collect the
    stream elements by summing up the elements, calculating the average, or to a `List`,
    `Collection`, or to a `Map`. Collecting elements to a `Map` is a special thing,
    since each element of a `Map` is actually a key-value pair. We will see the example
    for that when we look at `ProductInformationCollector`.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
- en: 'The `ProductInformationCollector` class code contains the `collectProductInformation`
    method, which we will use from the `Checker` class as well as from the `ProductsCheckerCollector`
    class:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: The simple trick is to store the collected value in `Map`, and if that is not
    `null`, then just return the already calculated value, which may save a lot of
    service calls in case this method is called more than once handling the same HTTP
    request.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
- en: There are two ways of coding such a structure. One is checking the non-nullity
    of the `Map` and returning if the `Map` is already there. This pattern is widely
    used and has a name. This is called guarding *if*. In this case, there is more
    than one return statement in the method, which may be seen as a weakness or anti-pattern.
    On the other hand, the tabulation of the method is one tab shallower.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
- en: It is a matter of taste and in case you find yourself in the middle of a debate
    about one or the other solution, just do yourself a favor and let your peer win
    on this topic and save your stamina for more important issues, for example, whether
    you should use streams or just plain old loops.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s see how we can convert this solution into a functional style:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: We use a helper class, `Tuple`, which is nothing but two `Object` instances
    named `r` and `s`. We will list the code for this class later. It is very simple.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
- en: In the streams expression, we first create the stream from the collection, and
    then we map the `OrderItem` elements to a stream of `OrderItem` and `productId`
    tuples. Then we map these tuples to tuples that now contain `OrderItem` and `ProductInformation`.
    These two mappings could be done in one mapping call, which would perform the
    two steps only in one. I decided to create the two to have simpler steps in each
    line in a vain hope that the resulting code will be easier to comprehend.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
- en: The filter step is also nothing new. It just filters out invalid product information
    elements. There should actually be none. It happens if the order contains an order
    ID to a non-existent product. This is checked in the next statement when we look
    at the number of collected product information elements to see that all the items
    have proper information.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
- en: The interesting code is how we collect the elements of the stream into a `Map`.
    To do so, we again use the `collect` method and also the `Collectors` class. This
    time, the `toMap` method creates the `Collector`. This needs two `Function` resulting
    expressions. The first one should convert the element of the stream to the key
    and the second should result in the value to be used in the `Map`. Because the
    actual type of the key and the value is calculated from the result of the passed
    lambda expressions, we explicitly have to cast the fields of the tuple to the
    needed types.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, the simple `Tuple` class is as follows:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: There are still some classes in our code that deserve to be converted to functional
    style. These are the `Checker` and `CheckerHelper` classes.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `Checker` class, we can rewrite the `isConsistent` method:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Since you have already learnt most of the important stream methods, there is
    hardly any new issue here. We can mention the `anyMatch` method, which will return
    `true` if there is at least one element so that the `Predicate` parameter passed
    to `anyMatch` is `true`. It may also need some accommodation so that we could
    use a stream inside another stream. It very well may be an example when a stream
    expression is overcomplicated and needs to split up into smaller pieces using
    local variables.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, before we leave the functional style, we rewrite the `containsOneOf`
    method in the `CheckHelper` class. This contains no new elements and will help
    you check what you have learned about `map`, `filter`, `flatMap`, and `Collector`.
    Note that this method, as we discussed, returns `true` if `order` contains at
    least one of the order IDs given as strings:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'We create the stream of the `OrderItem` objects, and then we map it to a stream
    of the IDs of the products contained in the stream. Then we create another stream
    for each of the IDs with the elements of the ID and one of the string IDs given
    as the argument. Then, we flatten these substreams into one stream. This stream
    will contain `order.getItems().size()` times `ids.length` elements: all possible
    pairs. We will filter out those pairs that contain the same ID twice, and finally,
    we will count the number of elements in the stream.'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
- en: Scripting in Java 9
  id: totrans-284
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We are almost ready with our sample program for this chapter. There is one issue,
    though it is not professional. When we have a new product that needs a new checker,
    we have to create a new release of the code.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
- en: Programs in professional environments have releases. When the code is modified,
    bugs are fixed, or a new function is implemented, there are numerous steps that
    the organization requires before the application can go into production. These
    steps compose the release process. Some environments have lightweight release
    processes; others require rigorous and expensive checks. It is not because of
    the taste of the people in the organization, though. When the cost of a non-working
    production code is low and it does not matter if there is an outage or wrong functioning
    in the program, then the release process can be simple. This way, releases get
    out faster and cheaper. An example can be some chat program that is used for fun
    by the users. In such a situation, it may be more important to release new fancy
    features than ensuring bug-free working. On the other end of the palette, if you
    create code that controls an atomic power plant, the cost of failure can be pretty
    high. Serious testing and careful checking of all the features, even after the
    smallest change, can pay off.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
- en: In our example, simple checkers may be an area that is not likely to induce
    serious bugs. It is not impossible but the code is so simple...Yes, I know that
    such an argument is a bit fishy, but let's assume that these small routines could
    be changed with less testing and in an easier way than the other parts of the
    code. How to separate the code for these little scripts, then, so that they do
    not require a technical release, a new version of the application, and not even
    restarting the application? We have a new product that needs a new check and we
    want to have some way to inject this check into the application environment without
    any service disruption.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
- en: 'The solution we choose is scripting. Java programs can execute scripts written
    in *JavaScript*, *Groovy*, *Jython* (which is the *JVM* version of the language
    *Python*), and many other languages. Except *JavaScript*, the language interpreters
    of these languages are not a part of the JDK, but they all provide a standard
    interface, which is defined in the JDK. The consequence is that we can implement
    script execution in our code and the developers, who provide the scripts, are
    free to choose any of the available languages; we do not need to care to execute
    a *JavaScript* code. We will use the same API as to execute *Groovy* or *Jython*.
    The only thing we should know is what language the script is in. This is usually
    simple: we can guess that from the file extension, and if guessing is not enough,
    we can demand that the script developers put *JavaScript* into files with the
    `.js` extension, *Jython* into files with `.jy` or `.py`, *Groovy* into files
    with `.groovy`, and so on. It is also important to note that if we want our program
    to execute one of these languages, we should make sure that the interpreter is
    on the classpath. In the case of *JavaScript*, this is given; therefore, as a
    demonstration in this chapter, we will write our scripts in *JavaScript*. There
    will not be a lot; this is a Java book and not a *JavaScript* book after all.'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
- en: Scripting is usually a good choice when we want to pass the ability of programmatically
    configuring or extending our application. This is our case now.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
- en: 'The first thing we have to do is to extend the production information. In case
    there is a script that checks the consistency of an order that a product is in,
    we need a field where we can specify the name of the script:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: We do not want to specify more than one script per product; therefore, we do
    not need a list of script names. We have only one script specified by the name.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
- en: To be honest, the data structure for the checker classes and the annotations,
    allowing multiple annotations per product and also per checker class, was too
    complicated. We could not avoid that, though, to have a complex enough structure
    that could demonstrate the power and capability of stream expressions. Now that
    we are over that subject, we can go on using simpler data structures focusing
    on script execution.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
- en: We also have to modify the `Checker` class to not only use the checker classes
    but also the scripts. We cannot throw away the checker classes because, by the
    time we realize that we better need scripts for the purpose, we already have a
    lot of checker classes and we have no financing to rewrite them to be scripts.
    Well yes, we are in a book and not in real life, but in an enterprise, that would
    be the case. That is why you should be very careful while designing solutions
    for a corporate. The structures and the solutions will be there for a long time
    and it is not easy to throw a piece of code out just because it is technically
    not the best. If it works and is already there, the business will be extremely
    reluctant to spend money on code maintenance and refactoring.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
- en: 'Summary: we modify the `Checker` class. We need a new class that can execute
    our scripts; thus, the constructor is modified:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: We also have to use this `executor` in the `isConsistent` method`:`
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Note that in this code, we use parallel streams because, why not? Whenever it
    is possible, we can use parallel streams, even unordered, to tell the underlying
    system and also to the programmer fellows maintaining the code that order is not
    important.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
- en: 'We also modify one of our product JSON files to reference a script instead
    of a checker class through some annotation:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Even JSON is simpler. Note that as we decided to use JavaScript, we do not need
    to specify the file name extension when we name the script.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
- en: We may later consider further development when we will allow the product checker
    script maintainers to use different scripting languages. In such a case, we may
    still require that they specify the extension, and in case there is no extension,
    it will be added by our program as `.js`. In our current solution, we do not check
    that, but we may devote a few seconds to think about it to be sure that the solution
    can be further developed. It is important that we do not develop extra code for
    the sake of further development. Developers are not fortunetellers and cannot
    tell reliably what the future needs will be. That is the task of the business
    people.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
- en: 'We put the script into the `resource` directory of our project under the `scripts`
    directory. The name of the file has to be `powered_device.js` because this is
    the name we specified in the JSON file:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: This is an extremely simple JavaScript program. As a side note, when you iterate
    over a list or an array in JavaScript, the loop variable will iterate over the
    indexes of the collection or the array. Since I rarely program in JavaScript,
    I fell into this trap and it took me more than half an hour to debug the error
    I made.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
- en: We have prepared everything we need to call the script. We still have to invoke
    it. To do so, we use the JDK scripting API. First, we need a `ScriptEngineManager`.
    This manager is used to get access to the JavaScript engine. Although the JavaScript
    interpreter has been a part of the JDK since Java 7, it is still managed in an
    abstract way. It is one of the many possible interpreters that a Java program
    can use to execute script. It just happens to be there in the JDK, so we do not
    need to add the interpreter JAR to the classpath. `ScriptEngineManager` discovers
    all the interpreters that are on the classpath and registers them.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
- en: It does so using the Service Provider specification, which has been a part of
    the JDK for a long time, and by Java 9, it also got extra support in module handling.
    This requires the script interpreters to implement the `ScriptEngineFactory` interface
    and also to list the class that does it in the `META-INF/services/javax.script.ScriptEngineFactory`
    file. These files, from all the JAR files that are part of the classpath, are
    read as resources by `ScriptEngineManager`, and through this, it knows which classes
    implement script interpreters. The `ScriptEngineFactory` interface requires that
    the interpreters provide methods such as `getNames`, `getExtensions`, and `getMimeTypes`.
    The manager calls these methods to collect the information about the interpreters.
    When we ask a JavaScript interpreter, the manager will return the one created
    by the factory that said that one of its names is `JavaScript`.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
- en: To get access to the interpreters through the name, file name extension or mime-type
    is only one of the functions of `ScriptEngineManager`. The other one is to manage
    `Bindings`.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
- en: When we execute a script from within the Java code, we don't do it because we
    want to increase our dopamine levels. In the case of scripts, it does not happen.
    We want some results. We want to pass parameters and after the execution of the
    script, we want values back from the script that we can use in the Java code.
    This can happen in two ways. One is by passing parameters to a method or function
    implemented in the script and getting the return value from the script. This usually
    works, but it may even happen that some scripting language does not even have
    the notion of the function or method. In such a case, it is not a possibility.
    What is possible is to pass some environment to the script and read values from
    the environment after the script is executed. This environment is represented
    by `Bindings`.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
- en: '`Bindings` is a map that has `String` keys and `Object` values.'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
- en: 'In the case of most scripting languages, for example, in JavaScript, `Bindings`
    is connected to global variables in the script we execute. In other words, if
    we execute the following command in our Java program before invoking the script,
    then the JavaScript global variable, `globalVariable`, will reference the `myObject`
    object:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: We can create `Bindings` and pass it to `ScriptEngineManager` but just as well
    we can use the one that it creates automatically, and we can call the `put` method
    on the engine object directly.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
- en: There are two `Bindings` when we execute scripts. One is set on the `ScriptEngineManager`
    level. This is named global binding. There is also one managed by `ScriptEngine`
    itself. This is the local `Bindings`. From the script point of view, there is
    no difference. From the embedding side, there is some difference. In case we use
    the same `ScriptEngineManager` to create multiple `ScriptEngine` instances, then
    the global bindings are shared by them. If one gets a value, all of them see the
    same value; if one sets a value, all others will later see that changed value.
    The local binding is specific to the engine it is managed by. Since we only introduce
    Java scripting API in this book, we do not get into more details and we will not
    use `Bindings`. We are good with invoking a JavaScript function and to get the
    result from it.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
- en: 'The class that implements the script invocation is `CheckerScriptExecutor`:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: The only `public` method, `notConsistent`, gets the name of the script to execute
    and also `order`. The latter has to be passed to the script. First it gets `Reader`,
    which can read the script text, evaluates it, and finally returns the result in
    case it is `boolean` or can at least be converted to `boolean`. If any of the
    methods invoked from here that we implemented in this class is erroneous, it will
    throw an exception, but only after appropriately logging it. In such cases, the
    safe way is to refuse an order.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
- en: Actually, this is something that the business should decide. If there is a check
    script that cannot be executed, it is clearly an erroneous situation. In this
    case, accepting an order and later handling the problems manually has certain
    costs. Refusing an order or confirmation because of some internal bug is also
    not a happy path of the order process. We have to check which approach causes
    the least damage to the company. It is certainly not the duty of the programmer.
    In our situation, we are in an easy situation.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
- en: We assume that the business representatives said that the order in such a situation
    should be refused. In real life, similar decisions are many times refused by the
    business representatives saying that it just should not happen and the IT department
    has to ensure that the program and the whole operation is totally bug free. There
    is a psychological reason for such a response, but this really leads us extremely
    far from Java programming.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
- en: 'Engines can execute a script passed through `Reader` or as `String`. Because
    now we have the script code in a resource file, it seems to be a better idea to
    let the engine read the resource instead of reading it to a `String`:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'To read the script from a resource file, we use the Spring `ClassPathResource`
    class. The name of the script is prepended with the `scripts` directory and appended
    by the`.js` extension. The rest is fairly standard and nothing we have not seen
    in this book. The next method that evaluates the script is more interesting:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: To execute the method in the script, first of all, we need a script engine that
    is capable of handling **JavaScript**. We get the engine from the manager by its
    name. If it is not **JavaScript**, we should check that the returned `engine`
    is not `null`. In the case of **JavaScript**, the interpreter is part of the **JDK**
    and checking that the **JDK** conforms to the standard would be paranoid.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
- en: If ever we want to extend this class to handle not only **JavaScript** but also
    other types of scripts, this check has to be done, and also the script engine
    should probably be requested from the manager by the file name extension, which
    we do not have access to in this `private` method. But that is future development,
    not in this book.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
- en: When we have the engine, we have to evaluate the script. This will define the
    function in the script so that we can invoke it afterwards. To invoke it, we need
    some `Invocable` object. In the case of **JavaScript**, the engine also implements
    an `Invocable` interface. Not all script engines implement this interface. Some
    scripts do not have functions or methods, and there is nothing to invoke in them.
    Again, this is something to do later, when we want to allow not only **JavaScript**
    scripting but also other types of scripting.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
- en: 'To invoke the function, we pass its name to the `invokeFunction` method and
    also the arguments that we want to pass on. In this case, this is the `order`.
    In the case of **JavaScript**, the integration between the two languages is fairly
    developed. As in our example, we can access the field and the methods of the Java
    objects that are passed as arguments and the returned JavaScript `true` or `false`
    value is also converted to `Boolean` magically. There are some situations when
    the access is not that simple though:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: The last method of the class checks that the returned value, which can be anything
    since this is a script engine, is convertible to `boolean`.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
- en: It is important to note that the fact that some of the functionality is implemented
    in script does not guarantee that the application works seamlessly. There may
    be several issues and scripts may affect the inner working of the entire application.
    Some scripting engines provide special ways to protect the application from bad
    scripts, others do not. The fact that we do not pass but order to the script does
    not guarantee that a script cannot access other objects. Using reflection, `static`
    methods, and other techniques there can be ways to access just anything inside
    our Java program. We may be a bit easier with the testing cycle when only a script
    changes in our code base, but it does not mean that we should blindly trust any
    script.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
- en: In our example, it probably would be a very bad idea to let the producers of
    the products upload scripts to our system. They may provide their check scripts,
    but these scripts have to be reviewed from the security point of view before being
    deployed into the system. If this is properly done, then scripting is an extremely
    powerful extension to the Java ecosystem, giving great flexibility to our programs.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-333
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have developed the ordering system of our enterprise application.
    Along with the development of the code, we met many new things. You learned about
    annotations and how they can be handled by reflections. Although not strongly
    related, you learned how to use lambda expressions and streams to express some
    programming constructs simpler than conventional loops. In the last part of the
    chapter, we extended the application using scripting, by invoking JavaScript functions
    from Java and also by invoking Java methods from JavaScript.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
- en: In fact, with all this knowledge, we matured to a Java level that is needed
    for enterprise programming. The rest of the topics the book covers are for the
    aces. But you want to be one, don't you? This is why I wrote the rest of the chapters.
    Read on!
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
