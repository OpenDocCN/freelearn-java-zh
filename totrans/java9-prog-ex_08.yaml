- en: Extending Our E-Commerce Application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the last chapter, we started developing an e-commerce application and we
    created the functionality to look up products based on their ID and, also, by
    some parameters. In this chapter, we will extend the functionality so that we
    can also order the products we selected. While doing so, we will learn new technologies,
    focusing on functional programming in Java and on some other language features,
    such as reflection and annotation handling during runtime, and scripting interface.
  prefs: []
  type: TYPE_NORMAL
- en: As we did in the previous chapters, we will develop the application step by
    step. As we discover the newly learnt technologies, we will refactor the code
    to enroll the new tools and methods to produce more readable and effective code.
    We will also mimic the development of real-life projects in the sense that at
    the start, we will have simple requirements, and later, new requirements will
    be set as our imagined business develops and sells more and more products. We
    will become imagined millionaires.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will use the code base of the previous chapter, and we will develop it further,
    though, in a new project. We will use Spring, Gradle, Tomcat, and soapUI, which
    are not new after we got acquainted with these in the previous chapter. In this
    chapter, you will learn the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Annotation processing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using reflection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Functional programming in Java using:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Lambda expressions
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Streams
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Invoking scripts from Java
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The MyBusiness ordering
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The ordering process is a little bit more complicated than just looking up products.
    The order form itself lists products and amounts, and identifies who the customer
    for that order is. Identifiers give the products. All that we have to do is check
    that the products are available in our store, and we can deliver them to the given
    customer. This is the simplest approach; however, with some products, there are
    more restrictions. For example, when somebody orders a desk-side lamp, we deliver
    the power cord separately. The reason for this is that the power cord is specific
    to the country. We deliver different power cords to the United Kingdom and to
    Germany. One possible approach could be to identify the country of the customer.
    But this approach does not take into account that our customers are resellers.
    All customers could be located in the United Kingdom, and at the same time they
    may want to deliver the lamp with the power cable to Germany. To avoid such situations
    and ambiguity, it would be  apt that our customers order the desk-side lamp and
    the power cord as separate items in the same order. In some cases, we deliver
    the desk-side lamp without the power cord, but this is a special case. We need
    some logic to identify these special cases. Therefore, we have to implement logic
    to see if there is a power cord for a desk-side lamp and if there is no automatic
    handling of the order, it is refused. It does not mean that we will not deliver
    the product. We will only put the order in a queue and some operator will have
    to look at it.
  prefs: []
  type: TYPE_NORMAL
- en: The problem with this approach is that the desk-side lamp is only one product
    that needs configuration support. The more products we have, the more specialities
    they may have, and the piece of code that checks the consistency of an order becomes
    more and more complex until it reaches a level of complexity that is not manageable.
    When a class or method becomes too complex, the programmers refactor it, splitting
    up the method or class into smaller pieces. We have to do the same with the product
    checking. We shouldn't try to create one huge class that checks for the product
    and all the possible order constellations, but rather we should have many smaller
    checks so that each checks only one small set.
  prefs: []
  type: TYPE_NORMAL
- en: 'Checking for consistency is simpler in some cases. Checking whether the lamp
    has a power cord has a complexity any novice programmer can program. We use this
    example in our code because we want to focus on the actual structure of the code,
    and not on the complex nature of the check itself. In real life, however, the
    checks can be fairly complex. Imagine a shop that sells computers. It puts a configuration
    together: power supply, graphic cards, and motherboard, the appropriate CPU, and
    the memory. There are many choices and some of them may not work together. In
    a real-life situation, we need to check that the motherboard is compatible with
    the memory selected, that it has as many banks as are in the order, that they
    are appropriately paired (some memories can only be installed in pairs), that
    there is a compatible slot for the graphics card, and that the power has enough
    watts to reliably run the whole configuration. This is very complex and is better
    not mixed up with the code that checks if there is a power cord for a lamp.'
  prefs: []
  type: TYPE_NORMAL
- en: Setting up the project
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Since we are still using Spring boot, the build file does not need any modification;
    we will use it as we will use the same file as in the last chapter. The package
    structure, however, is a bit different. This time, we do something more complicated
    than getting a request and responding to whatever the backend services deliver
    to us. Now, we have to implement complex business logic that, as we will see,
    needs many classes. When we have more than 10 classes, give or take, in a certain
    package, it is time to think about putting them into separate packages. The classes
    that are related to each other and have a similar functionality should be put
    into one package. This way, we will have a package for the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The controllers (though we have only one in this example, but usually there
    are more)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Data storing beans that have no more functionality than storing data, thus,
    fields, setters, and getters
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Checkers that will help us check power cords when a desk-side lamp is ordered
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Services that perform different services for the controller
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The main package for our program that contains the `Application` class, `SpringConfiguration`,
    and some interfaces
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Order controller and DTOs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When a request comes to the server to order a bunch of products, it comes in
    an HTTPS `POST` request. The body of the request is encoded in JSON. Till now,
    we had controllers that were handling `GET` parameters, but handling `POST` requests
    is not much more difficult when we can rely on the data marshalling of Spring.
    The controller code itself is simple:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'There is only one request that we handle in this controller: `order`. This
    is mapped to the URL, `/order`. The order is automatically converted from JSON
    to an order object from the request body. This is what the `@RequestBody` annotation
    asks Spring to do for us. The functionality of the controller simply checks the
    consistency of the order. If the order is consistent, then we accept the order;
    otherwise, we refuse it. The real-life example will also check that the order
    is not only consistent but also comes from a customer who is eligible for buying
    those products and that the products are available in the warehouse or, at least,
    can be delivered, based on the promises and lead time from the producers.'
  prefs: []
  type: TYPE_NORMAL
- en: To check the consistency of the order, we need something that does this job
    for us. As we know that we have to modularize the code and not implement too many
    things in a single class, we need a checker object. This is provided automatically
    based on the annotation on the class and also on the constructor of the controller
    by `@Autowired`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Order` class is a simple bean, simply listing the items:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The name of the package is `dtos`, which stands for the plural of **Data Transfer
    Object** (**DTO**). DTOs are objects that are used to transfer data between different
    components, usually over the network. Since the other side can be implemented
    in any language, the marshaling can be JSON, XML, or some other format that is
    capable of delivering nothing but data. These classes do not have real methods.
    DTOs usually have only fields, setters, and getters.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is the class that contains one item in an order:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The order confirmation is also in this package, and though this is also a true
    DTO, it has some simple auxiliary methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: We provide two factory methods for the class. This is a little violation of
    the single responsibility principle that purists hate. Most of the time, when
    the code becomes more complex, such short cuts bite back, and the code has to
    be refactored to be cleaner. The purist solution would be to create a separate
    factory class. The use of the factory methods either from this class or from a
    separated class makes the code of the controller more readable.
  prefs: []
  type: TYPE_NORMAL
- en: The major task we have is the consistency check. The code, till this point,
    is almost trivial.
  prefs: []
  type: TYPE_NORMAL
- en: Consistency checker
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have a consistency checker class, and an instance of it is injected into
    the controller. This class is used to check the consistency, but it does not actually
    perform the check itself. It only controls the different checkers that we provide
    and invokes them one by one to do the real work.
  prefs: []
  type: TYPE_NORMAL
- en: 'We require that a consistency checker, such as the one that checks whether
    the order contains a power cord when a desk-side lamp is ordered, implements the
    `ConsistencyChecker` interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The method `isInconsistent` should return `true` if the order is inconsistent.
    It returns `false` if it does not know whether the order is inconsistent or not,
    but from the aspect that the actual checker examines the order, there is no inconsistency.
    Having several `ConsistencyChecker` classes, we have to invoke one after the other
    until one returns `true` or we are out of them. If none of them returns `true`,
    then we can safely assume, at least from the automated checkers' point of view,
    that the order is consistent.
  prefs: []
  type: TYPE_NORMAL
- en: We know at the start of the development that we will really have a lot of consistency
    checkers and not all are relevant for all of the orders. We want to avoid the
    invocation of each checker for each order. To do so, we implement some filtering.
    We let products specify what type of checks they need. This is a piece of product
    information, such as the size or the description. To accommodate this, we need
    to extend the `ProductInformation` class.
  prefs: []
  type: TYPE_NORMAL
- en: We will create each `ConsistencyChecker` interface, implementing the class to
    be a Spring bean (annotated with the `@Component` annotation), and at the same
    time, we will annotate them with an annotation that specifies what type of checks
    they implement. At the same time, `ProductInformation` is extended, containing
    a set of `Annotation` class objects that specify which checkers to invoke. We
    could simply list the checker classes instead of the annotations, but this gives
    us some extra freedom in configuring the mapping between the products and the
    annotations. The annotation specifies the type of the products, and the checker
    classes are annotated. The desk-side lamp has the `PoweredDevice` type, and the
    checker class, `NeedPowercord`, is annotated with the `@PoweredDevice` annotation.
    If there is any other type of products that also needs a power cord, then the
    annotation of that type should be added to the `NeedPowercord` class, and our
    code will work. Since we start diving deep into annotations and annotation handling,
    we have to first learn what annotations really are. We have already used annotations
    since [Chapter 3](part0076.html), *Optimizing the Sort, Making Code Professional*
    but all we knew was how to use them, and that is usually dangerous without understanding
    what we did.
  prefs: []
  type: TYPE_NORMAL
- en: Annotations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Annotations are used with the `@` character in front of them and can be attached
    to packages, classes, interfaces, fields, methods, method parameters, generic
    type declaration and use, and, finally, to annotations. Annotations can be used
    almost everywhere and they are used to describe some program meta information.
    For example, the `@RestController` annotation does not directly alter the behavior
    of the `OrderController` class. The behavior of the class is described by the
    Java code that is inside. The annotation helps Spring to understand what the class
    is and how it can and should be used. When Spring scans all the packages and classes
    to discover the different Spring beans, it sees the annotation on the class and
    takes it into account. There can be other annotations on the class that Spring
    does not understand. They may be used by some other framework or program code.
    Spring ignores them as any well-behaving framework. For example, as we will see
    later, we have in our code base, the `NeedPowercord` class , which is a Spring
    bean and, as such, annotated with the `@Component` annotation. At the same time,
    it is also annotated with the `@PoweredDevice` annotation. Spring has no idea
    about what a powered device is. This is something that we define and use. Spring
    ignores this.
  prefs: []
  type: TYPE_NORMAL
- en: Packages, classes, interfaces, fields, and so on, can have many annotations
    attached to them. These annotations should simply be written in front of the declaration
    of the syntactical unit they are attached to.
  prefs: []
  type: TYPE_NORMAL
- en: In the case of packages, the annotation has to be written in front of the package
    name in the `package-info.java` file. This file can be placed in the directory
    of the package and can be used to edit the *JavaDoc* for the package and also
    to add an annotation to the package. This file cannot contain any Java class since
    the name, `package-info`, is not a valid identifier.
  prefs: []
  type: TYPE_NORMAL
- en: 'We cannot just write anything in front of anything as an annotation. Annotations
    should be declared. They are in the runtime of Java special interfaces. The Java
    file that declares the `@PoweredDevice` annotation, for example, looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The `@` character in front of the `interface` keyword shows us that this is
    a special one: an annotation type. There are some special rules; for example,
    an annotation interface should not extend any other interface, not even an annotation
    one. On the other hand, the compiler automatically makes the annotation interface
    so that it extends the JDK interface, `java.lang.annotation.Annotation`.'
  prefs: []
  type: TYPE_NORMAL
- en: Annotations are in the source code, and thus, they are available during the
    compilation process. They can also be retained by the compiler and put into the
    generated class files, and when the class loader loads the class file, they may
    also be available during runtime. The default behavior is that the compiler stores
    the annotation along with the annotated element in the class file, but the class
    loader does not keep it available for runtime.
  prefs: []
  type: TYPE_NORMAL
- en: To handle annotations during the compilation process, the Java compiler has
    to be extended using annotation processors. This is a fairly advanced topic and
    there are only a few examples you can meet while working with Java. An annotation
    processor is a Java class that implements a special interface and is invoked by
    the compiler when it processes an annotation in the source file that the processor
    is declared to have an interest in.
  prefs: []
  type: TYPE_NORMAL
- en: Annotation retention
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Spring and other frameworks usually handle annotations during runtime. The compiler
    and the class loader have to be instructed that the annotation is to be kept available
    during runtime. To do so, the annotation interface itself has to be annotated
    using the `@Retention` annotation. This annotation has one parameter of the `RetentionPolicy`
    type, which is an `enum`. We will soon discuss how annotation parameters should
    be defined.
  prefs: []
  type: TYPE_NORMAL
- en: It is interesting to note that the `@Retention` annotation on the annotation
    interface has to be available in the class file; otherwise, the class loaders
    would not know how to treat an annotation. How do we signal that an annotation
    is to be kept by the compiler after the compilation process? We annotate the annotation
    interface declaration. Thus, the declaration of `@Retention` is annotated by itself
    and it is declared to be available in runtime.
  prefs: []
  type: TYPE_NORMAL
- en: The annotation declaration can be annotated using `@Retention(RetentionPolicy.SOURCE)`,
    `@Retention(RetentionPolicy.CLASS)`, or `@Retention(RetentionPolicy.RUNTIME)`.
  prefs: []
  type: TYPE_NORMAL
- en: Annotation target
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The last retention type will be the most frequent used. There are also other
    annotations that can be used on annotation declarations. The `@Target` annotation
    can be used to restrict the use of the annotation to certain locations. The argument
    to this annotation is either a single `java.lang.annotation.ElementType` value
    or an array of these values. There is a good reason to restrict the use of annotations.
    It is much better to get a compilation time error when we place an annotation
    in the wrong place than hunting during runtime why the framework ignores our annotation.
  prefs: []
  type: TYPE_NORMAL
- en: Annotation parameters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Annotations, as we saw, can have parameters. To declare these parameters in
    the `@interface` declaration of the annotation, we use methods. These methods
    have a name and a return value, but they should not have an argument. You may
    try to declare some parameters, but the Java compiler will be strict and will
    not compile your code.
  prefs: []
  type: TYPE_NORMAL
- en: 'The values can be defined at the place where the annotation is used, using
    the name of the method and with the `=` character, assigning to them some value
    that is compatible with the type of the method. For example, let''s suppose that
    we modify the declaration of the annotation `PoweredDevice` to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'In such a case, at the use of the annotation, we should specify some value
    for the parameter, such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'If the name of the parameter is a value and at the place of use of the annotation
    there is no other parameter defined, then the name, "value", may be skipped. For
    example, modifying the code as follows is a handy shorthand when we have only
    one parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'We can define optional parameters also using the `default` keyword following
    the method declaration. In this case, we have to define a default value for the
    parameter. Modifying the sample annotation we have further, we still can, but
    need not, specify the value. In the latter case, it will be an empty string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Since the value we specify should be constant and calculable during compile
    time, there is not much use of complex types. Annotation parameters are usually
    strings, integers, and sometimes, doubles, or other primitive types. The exact
    list of the types given by the language specification is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Primitive (`double`, `int`, and so on)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: String
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Class
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An enum
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Another annotation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An array of any of the aforementioned types
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We have seen examples of `String` and also that `enum`:`Retention` and `Target`
    both have `enum` parameters. The interesting part we want to focus on is the last
    two items of the preceding list.
  prefs: []
  type: TYPE_NORMAL
- en: 'When the value of the parameter is an array, the value can be specified as
    comma-separated values between the `{` and`}` characters. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'This can then be added to the `@interface` annotation we can write:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'However, in case there is only one value we want to pass as the parameter value,
    we can still use the format:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'In this case, the value of the attribute will be an array of length `1`. When
    the value of an annotation is an array of annotation types, things get a bit more
    complex. We create an `@interface` annotation (note the plural in the name):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The use of this annotation could be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Note that this is not the same as having the `ParameteredPoweredDevice` annotation
    with three parameters. This is an annotation that has two parameters. Each parameter
    is an annotation. The first has one string parameter and the second has two.
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, annotations can be fairly complex, and some of the frameworks
    (or rather the programmers who created them) ran amok using them. Before you start
    writing a framework, research to see whether there is already a framework that
    you can use. Also, check whether there is some other way to solve your problem.
    99% of annotation handling code could be avoided and made simpler. The less code
    we write for the same functionality, the happier we are. We programmers are the
    lazy types and this is the way it has to be.
  prefs: []
  type: TYPE_NORMAL
- en: The last example, where the parameter of the annotation is an array of annotations,
    is important to understand how we can create repeatable annotations.
  prefs: []
  type: TYPE_NORMAL
- en: Repeatable annotations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Annotate the declaration of the annotation with `@Repeatable` to denote that
    the annotation can be applied multiple times at one place. The parameter to this
    annotation is an annotation type that should have a parameter of type, which is
    an array of this annotation. Don''t try to understand! I''ll give an example instead.
    I already have, in fact: we have `@PoweredDevices`. It has an argument that is
    an array of `@ParameteredPoweredDevice`. Consider that we now annotate this `@interface`
    as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we can simplify the use of `@ParameteredPoweredDevice`. We can repeat
    the annotation multiple times and the Java runtime will automatically enclose
    it in the wrapping class, which, in this case, is `@PoweredDevices`. In this case,
    the following two will be equivalent:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The reason for this complex approach is again an example of backward compatibility
    that Java strictly follows. Annotations were introduced in Java 1.5 and repeatable
    annotations have been available only since version 1.8\. We will soon talk about
    the reflection API that we use to handle the annotations during runtime. This
    API in the `java.lang.reflect.AnnotatedElement` interface has a `getAnnotation(annotationClass)`
    method, which returns an annotation. If a single annotation can appear more than
    once on a class, method, and so on, then there is no way of calling this method
    to get all the different instances with all the different parameters. Backward
    compatibility was ensured by introducing the containing type that wraps the multiple
    annotations.
  prefs: []
  type: TYPE_NORMAL
- en: Annotation inheritance
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Annotations, just like methods or fields, can be inherited between class hierarchies.
    If an annotation declaration is marked with `@Inherited`, then a class that extends
    another class with this annotation can inherit it. The annotation can be overridden
    in case the child class has the annotation. Because there is no multiple inheritance
    in Java, annotations on interfaces cannot be inherited. Even when the annotation
    is inherited, the application code that retrieves the annotation of a certain
    element can distinguish between the annotations that are inherited and those that
    are declared on the entity itself. There are methods to get the annotations and
    separate methods to get the declared annotations that are declared on the actual
    element, and not inherited.
  prefs: []
  type: TYPE_NORMAL
- en: '@Documented annotations'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `@Documented` annotation expresses the intent that the annotation is part
    of the contract of the entity and, this way, it has to get into the documentation.
    This is an annotation that the *JavaDoc* generator looks at when creating the
    documentation for an element that references the `@Documented` annotation.
  prefs: []
  type: TYPE_NORMAL
- en: JDK annotations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are other annotations defined in the JDK in addition to those that are
    to be used to define annotations. We have already seen some of these. The most
    frequently used is the `@Override` annotation. When the compiler sees this annotation,
    it checks that the method really overrides some inherited method. Failing to do
    so will result in an error, saving us from miserable runtime debugging.
  prefs: []
  type: TYPE_NORMAL
- en: The `@Deprecated` annotation signals in the documentation of a method, class,
    or some other element that the element is not to be used. It is still there in
    the code, because some users may still use it, but in the case of a new development
    that depends on the library containing the element, the newly developed code should
    not use it. The annotation has two parameters. One parameter is `since`, which
    can have a string value and may deliver version information about how long or
    since which version of the method, or class is deprecated. The other parameter
    is `forRemoval`, which should be `true` if the element will not appear in the
    future versions of the library. Some methods may be deprecated because there are
    better alternatives but the developers do not intend to remove the method from
    the library. In such a case, the `forRemoval` can be set to `false`.
  prefs: []
  type: TYPE_NORMAL
- en: The `@SuppressWarning` annotation is also a frequently used one, though its
    use is questionable. It can be used to suppress some of the warnings of the compiler.
    It is recommended to write code, if possible, which can be compiled without any
    warning.
  prefs: []
  type: TYPE_NORMAL
- en: The `@FunctionalInterface` annotation declares that an interface intends to
    have only one method. Such interfaces can be implemented as lambda expressions.
    You will learn about lambda expressions later in this chapter. When this annotation
    is applied on an interface and there is more than one method declared in the interface,
    the compiler will signal compilation error. This will prevent any developer early
    on from adding another method to an interface intended to be used together with
    functional programming and lambda expressions.
  prefs: []
  type: TYPE_NORMAL
- en: Using reflection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that you have learnt how to declare annotations and how to attach them to
    classes and methods, we can return to our `ProductInformation` class. Recall that
    we wanted to specify the type of products in this class and that each product
    type is represented by an `@interface` annotation. We have already listed it in
    the previous few pages, the one we will implement in our  `@PoweredDevice` example.
    We will develop the code assuming that later there will be many such annotations,
    product types, and consistency checkers that are annotated with `@Component` and
    with one or more of our annotations.
  prefs: []
  type: TYPE_NORMAL
- en: Getting annotations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will extend the `ProductInformation` class with the following field:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Since this is a DTO, and Spring needs the setters and getters, we will also
    add a new getter and setter to it. This field will contain the list of classes
    that each class implement one of our annotations and also the built-in JDK interface,
    `Annotation`, because that is the way the Java compiler generates them. At this
    point, this may be a bit murky but I promise that the dawn will break and there
    will be light as we go on.
  prefs: []
  type: TYPE_NORMAL
- en: To get the product information, we have to look it up by ID. This is the interface
    and service that we developed in the last chapter, except, this time, we have
    another new field. This is, in fact, a significant difference although the `ProductLookup`
    interface did not change at all. In the last chapter, we developed two versions.
    One of the versions was reading the data from a properties file, the other one
    was connecting to a REST service.
  prefs: []
  type: TYPE_NORMAL
- en: Properties files are ugly and old technology but a must if ever you intend to
    pass a Java interview or work on enterprise applications developed at the start
    of the 21^(st) century. I had to include it in the last chapter. It was my own
    urge to include it in the book. At the same time, while coding for this chapter,
    I did not have the stomach to keep using it. I also wanted to show you that the
    same content could be managed in a JSON format.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we will extend the implementation of `ResourceBasedProductLookup` to read
    the product information from JSON formatted resource files. Most of the code remains
    the same in the class; therefore, we only list the difference here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `project resources/products` directory we have a few JSON files. One
    of them contains the desk lamp product information:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The type of product is specified in a JSON array. In this example, this array
    has only one element and that element is the fully qualified name of the annotation
    interface that represents the type of product. When the JSON marshaller converts
    the JSON to a Java object, it recognizes that the field that needs this information
    is a `List`, so it converts the array to a list and, also, the elements from `String`
    to `Class` objects representing the annotation interface.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have the resources loaded from JSON formatted resources and we
    saw how easy it is to read JSON data when using Spring, we can get back to the
    order consistency check. The `Checker` class implements the logic to collect the
    pluggable checkers and to invoke them. It also implements the annotation-based
    screening so as not to invoke the checkers we don''t really need for the actual
    products in the actual order:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: One of the interesting things to mention is that the Spring auto-wiring is very
    clever. We have a field with the `Collection<ConsistencyChecker>` type. Usually,
    auto-wiring works if there is exactly one class that has the same type as the
    resources to wire. In our case, we do not have any such candidate since this is
    a collection, but we have many `ConsistencyChecker` classes. All our checkers
    implement this interface and Spring recognizes it, instantiates them all, magically
    creates a collection of them, and injects the collection into this field.
  prefs: []
  type: TYPE_NORMAL
- en: Usually a good framework works logically. I was not aware of this feature of
    Spring, but I thought that this would be logical and, magically, it worked. If
    things are logical and just work, you do not need to read and remember the documentation.
    A bit of caution does not harm however. After I experienced that this functionality
    works this way, I looked it up in the documentation to see that this is really
    a guaranteed feature of Spring and not something that just happens to work but
    may change in future versions without notice. Using only guaranteed features is
    extremely important but is neglected many times in our industry.
  prefs: []
  type: TYPE_NORMAL
- en: When the `isConsistent` method is invoked, it first collects the product information
    into `HashMap`, assigning a `ProductInformation` instance to each `OrderItem`.
    This is done in a separate class. After this, `ProductsCheckerCollector` collects
    the `ConsistencyChecker` instances needed by one or more product items. When we
    have this set, we need to invoke only those checkers that are annotated with one
    of the annotations that are in this set. We do that in a loop.
  prefs: []
  type: TYPE_NORMAL
- en: In this code, we use reflection. We loop over the annotations that each checker
    has. To get the collection of annotations, we invoke `checker.getClass().getAnnotations()`.
    This invocation returns a collection of objects. Each object is an instance of
    some JDK runtime generated class that implements the interface we declared as
    an annotation in its own source file. There is no guarantee, though, that the
    dynamically created class implements only our `@interface` and not some other
    interfaces. Therefore, to get the actual annotation class, we have to invoke the
    `annotationType` method.
  prefs: []
  type: TYPE_NORMAL
- en: The `ProductCheckerCollector` and `ProductInformationCollector` classes are
    very simple, and we will discuss them later when we learn about streams. They
    will serve as a good example at that place, when we implement them using loops
    and, right after that, using streams.
  prefs: []
  type: TYPE_NORMAL
- en: 'Having them all, we can finally create our actual checker classes. The one
    that helps us see that there is a power cord ordered for our lamp is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The helper class contains simple methods that will be needed by many of the
    checkers, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Invoking methods
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this example, we used only one single reflection call to get the annotations
    attached to a class. Reflection can do many more things. Handling annotations
    is the most important use for these calls since annotations do not have their
    own functionality and cannot be handled in any other way during runtime. Reflection,
    however, does not stop telling us what annotations a class or any other annotable
    element has. Reflection can be used to get a list of the methods of a class, the
    name of the methods as strings, the implemented interfaces of a class, the parent
    class it extends, the fields, the types of fields, and so on. Reflection generally
    provides methods and classes to walk through the actual code structure down to
    the method level, programmatically.
  prefs: []
  type: TYPE_NORMAL
- en: This walkthrough does not only allow reading types and code structure but also
    makes it possible to set field values and call methods without knowing the methods'
    name at compile time. We can even set fields that are `private` and are not generally
    accessible by the outside world. It is also to note that accessing the methods
    and fields through reflection is usually slower than through compiled code because
    it always involves lookup by the name of the element in the code.
  prefs: []
  type: TYPE_NORMAL
- en: The rule of thumb is that if you see that you have to create code using reflection,
    then realize that you are probably creating a framework (or writing a book about
    Java that details reflection). Does it sound familiar?
  prefs: []
  type: TYPE_NORMAL
- en: Spring also uses reflection to discover the classes, methods, and fields, and
    also to inject an object. It uses the URL class loader to list all the JAR files
    and directories that are on the class path, loads them, and examines the classes.
  prefs: []
  type: TYPE_NORMAL
- en: For a contrived example, for the sake of demonstration, let's assume that the
    `ConsistencyChecker` implementations were written by many external software vendors,
    and the architect who originally designed the program structure just forgot to
    include the `isConsistent` method in the interface. (At the same time, to save
    our mental health, we can also imagine that this person is not working anymore
    in the company for doing so.) As a consequence, the different vendors delivered
    Java classes that "implement" this interface but we cannot invoke the method,
    not only because we do not have a common parent interface that has this method
    but also because the vendors just happened to use different names for their methods.
  prefs: []
  type: TYPE_NORMAL
- en: What can we do in this situation? Business-wise, asking all the vendors to rewrite
    their checkers is ruled out because them knowing we are in trouble attaches a
    hefty price tag to the task. Our managers want to avoid that cost and we developers
    also want to show that we can mend the situation and do miracles. (Later, I will
    have a comment on that.)
  prefs: []
  type: TYPE_NORMAL
- en: We could just have a class that knows every checker and how to invoke each of
    them in many different ways. This would require us to maintain the said class
    whenever a new checker is introduced to the system, and we want to avoid that.
    The whole plugin architecture we are using was invented for this very purpose
    in the first place.
  prefs: []
  type: TYPE_NORMAL
- en: 'How can we invoke a method on an object that we know has only one declared
    method, which accepts an order as a parameter? That is where reflection comes
    into the picture. Instead of calling `checker.isInconsistent(order)`, we implement
    a small `private` method, `isInconsistent`, which calls the method, whatever its
    name is, via reflection:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: We can get the class of the object by calling the `getClass` method, and on
    the object that represents the class itself, we can call `getDeclaredMethods`.
    Fortunately, the checker classes are not littered by many methods, so we check
    that there is only one method declared in the checker class. Note that there is
    also a `getMethods` method in the reflection library but it always will return
    more than one method. It returns the declared and the inherited methods. Because
    each and every class inherits from `java.lang.Object`, at least the methods of
    the `Object` class will be there.
  prefs: []
  type: TYPE_NORMAL
- en: After this, we try to invoke the class using the `Method` object that represents
    the method in the reflection class. Note that this `Method` object is not directly
    attached to an instance. We retrieved the method from the class, and thus, when
    we invoke it, we should pass the object it should work on as a first parameter.
    This way, `x.y(z)`, becomes `method.invoke(x,z)`. The last parameter of invoke
    is a variable number of arguments that are passed as an `Object` array. In most
    cases, when we invoke a method, we know the arguments in our code even if we do
    not know the name of the method and have to use reflection. When even the arguments
    are not known but are available as a matter of calculation, then we have to pass
    them as an `Object` array.
  prefs: []
  type: TYPE_NORMAL
- en: Invoking a method via reflection is a risky call. If we try to call a method
    the normal way, which is `private`, then the compiler will signal an error. If
    the number of arguments or types are not appropriate, the compiler will again
    will give us an error. If the returned value is not `boolean`, or there is no
    return value at all, then we again get a compiler error. In the case of reflection,
    the compiler is clueless. It does not know what method we will invoke when the
    code is executing. The `invoke` method, on the other hand, can and will notice
    all these failures when it is invoked. If any of the aforementioned problems occur,
    then we will get exceptions. If the `invoke` method itself sees that it cannot
    perform what we ask of it, then it will throw `InvocationTargetException` or `IllegalAccessException`.
    If the conversion from the actual return value to `boolean` is not possible, then
    we will get `ClassCastException`.
  prefs: []
  type: TYPE_NORMAL
- en: About doing magic, it is a natural urge that we feel like making something extraordinary,
    something outstanding. This is okay when we are experimenting with something,
    doing a hobby job. On the other hand, this is strongly not okay when we are working
    on a professional job. Average programmers, who do not understand your brilliant
    solution, will maintain the code in an enterprise environment. They will turn
    your nicely combed code into haystack while fixing some bugs or implementing some
    minor new features. Even if you are the Mozart of programming, they will be, at
    best, no-name singers. A brilliant code in an enterprise environment can be a
    requiem, with all the implications of that metaphor.
  prefs: []
  type: TYPE_NORMAL
- en: Last but not least, the sad reality is that we are usually not the Mozarts of
    programming.
  prefs: []
  type: TYPE_NORMAL
- en: Note that in case the return value of the original value is primitive, then
    it will be converted to an object by reflection, and then we will convert it back
    to the primitive value. If the method does not have a return value, in other words,
    if it is `void`, then the reflection will return a `java.lang.Void` object. The
    `Void` object is only a placeholder. We cannot convert it to any primitive value
    or any other type of objects. It is needed because Java is strict and `invoke`
    has to return an `Object`, so the runtime needs something that it can return.
    All we can do is check that the returned value class is really `Void`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s go on with the storyline and our solution. We submitted the code and
    it works in production for a while till a new update from a software vendor breaks
    it. We debug the code in the test environment and see that the class now contains
    more than one method. Our documentation clearly states that they should only have
    one `public` method, and they provided a code that has...hmm...we realize that
    the other methods are `private`. They are right; they can have `private` methods
    according to the contract, so we have to amend the code. We replace the lines
    that look up the one and only method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The new code will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'The new method we write to look up the one and only `public` method is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: To check whether the method is `public` or not, we use a `static` method from
    the `Modifier` class. There are methods to check all possible modifiers. The value
    that the `getModifiers` method returns is an `int` bit field. Different bits have
    different modifiers and there are constants that define these. This simplification
    leads to inconsistency, which you can check if a method is an interface or volatile,
    that is, actually nonsense. The fact is that bits that can only be used for other
    types of reflection objects will never be set.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is one exception, which is `volatile`. This bit is reused to signal bridge
    methods. Bridge methods are created by the compiler automatically and can have
    deep and complex issues that we do not discuss in this book. The reuse of the
    same bit does not cause confusion because a field can be `volatile`, but as a
    field, it cannot be a bridge method. Obviously, a field is a field and not a method.
    In the same way, a method cannot be a `volatile` field. The general rule is: do
    not use methods on reflection objects where they do not have a meaning; or else,
    know what you do.'
  prefs: []
  type: TYPE_NORMAL
- en: Making the storyline even more intricate, a new version of a checker accidentally
    implements the checking method as a package `private`. The programmer simply forgot
    to use the `public` keyword. For the sake of simplicity, let's assume that the
    classes declare only one method again, but it is not public. How do we solve this
    problem using reflection?
  prefs: []
  type: TYPE_NORMAL
- en: 'Obviously, the simplest solution is to ask the vendors to fix the problem:
    it is their fault. In some cases, however, we must create a workaround over some
    problems. There is another solution: creating a class with a `public` method in
    the same package, invoking the package `private` methods from the other class,
    thus relaying the other class. As a matter of fact, this solution, as a workaround
    for such a bug, seems to be more logical and cleaner, but this time, we want to
    use reflection.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To avoid `java.lang.IllegalAccessException`, we have to set the `method` object
    as accessible. To do so, we have to insert the following line in front of the
    invocation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Note that this will not change the method to `public`. It will only make the
    method accessible for invocation through the very instance of the `method` object
    that we set as accessible.
  prefs: []
  type: TYPE_NORMAL
- en: I have seen code that checks whether a method is accessible or not by calling
    the `isAccessible` method and saves this information; it sets the method as accessible
    if it was not accessible and restores the original accessibility after the invocation.
    This is totally useless. As soon as the `method` variable goes out of scope, and
    there is no reference to the object we set the accessibility flag to, the effect
    of the setting wears off. Also, there is no penalty for setting the accessibility
    of a `public` or an otherwise callable method.
  prefs: []
  type: TYPE_NORMAL
- en: Setting fields
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We can also call `setAccessible` on `Field` objects and then we can even set
    the value of private fields using reflection. Without further fake stories, just
    for the sake of the example, let''s make a `ConsistencyChecker` named `SettableChecker`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'This checker will return `false`, unless we set the field to `true` using reflection.
    We do set it as such. We create a method in the `Checker` class and invoke it
    from the checking process for each checker:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: The method goes through all the declared fields and if the name is `setValue`
    and the type is `boolean`, then it sets it to `true`. This will essentially render
    all orders that contain a powered device as rejected.
  prefs: []
  type: TYPE_NORMAL
- en: Note that although `boolean` is a built-in language primitive, which is not
    a class by any means, it still has a class so that reflection can compare the
    type of the field gainst he class that `boolean` artificially has. Now `boolean.class`
    is a class literal in the language, and for each primitive, a similar constant
    can be used. The compiler identifies these as class literals and creates the appropriate
    pseudo class references in the byte code so that primitives can also be checked
    in this way, as demonstrated in the sample code of the `setValueInChecker` method.
  prefs: []
  type: TYPE_NORMAL
- en: We checked that the field has the appropriate type, and we also called the `setAccessible`
    method on the field. Even though the compiler does not know that we really did
    everything to avoid `IllegalAccessException`, it still believes that calling `set`
    on `field` can throw such an exception, as it is declared. However, we know that
    it should not happen. (Famous last words of a programmer?) To handle this situation,
    we surround the method call with a `try` block, and in the `catch` branch, we
    log the exception.
  prefs: []
  type: TYPE_NORMAL
- en: Functional programming in Java
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Since we have created a lot of code in our example for this chapter, we will
    look at the functional programming features of Java, which will help us delete
    many lines from our code. The less code we have, the easier it is to maintain
    the application; thus, programmers love functional programming. But this is not
    the only reason why functional programming is so popular. It is also an excellent
    way to describe certain algorithms in a more readable and less error prone manner
    than conventional loops.
  prefs: []
  type: TYPE_NORMAL
- en: Functional programming is not a new thing. The mathematical background was developed
    for it in the 1930s. One of the first (if not the first) functional programming
    languages is LISP. It was developed in the 1950s and it is still in use, so much
    that there is a version of the language implemented on the JVM (Clojure).
  prefs: []
  type: TYPE_NORMAL
- en: Functional programming, in short, means that we express the program structure
    in terms of functions. In this meaning, we should think of functions as in mathematics
    and not as the term is used in programming languages such as C. In Java, we have
    methods, and when we are following the functional programming paradigm, we create
    and use methods that behave like mathematical functions. A method is functional
    if it gives the same result no matter how many times we invoke it, just as *sin(0)*
    is always zero. Functional programming avoids changing the state of objects, and
    because the state is not changing, the results are always the same. This also
    eases debugging.
  prefs: []
  type: TYPE_NORMAL
- en: If a function has once returned a certain value for the given arguments, it
    will always return the same value. We can also read the code as a declaration
    of the calculation more than as commands that are executed one after the other.
    If the execution order is not important, then the readability of the code may
    also increase.
  prefs: []
  type: TYPE_NORMAL
- en: Java helps functional programming style with lambda expressions and streams.
    Note that these streams are not I/O streams and do not really have any relation
    to those.
  prefs: []
  type: TYPE_NORMAL
- en: We will first take a short look at lambda expressions and what streams are,
    and then, we will convert some parts of our program to use these programming constructs.
    We will also see how much more readable these codes become.
  prefs: []
  type: TYPE_NORMAL
- en: Readability is a debatable topic. A code may be readable to one developer and
    may be less readable to another. It very much depends on what they got used to.
    I experience many times that developers get distracted with streams. When developers
    first meet streams, the way to think about them and how they look is just strange.
    But this is the same as starting to learn using a bicycle. While you are still
    learning its use and you fall more than you roll, it is definitely slower than
    walking. On the other hand, once you have learnt how to ride a bike...
  prefs: []
  type: TYPE_NORMAL
- en: Lambda
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We have already used lambda expressions in [Chapter 3](part0076.html), *Optimizing
    the Sort - Making Code Professional* when we wrote the exception-throwing test.
    In that code, we set the comparator to a special value that was throwing `RuntimeException`
    at each invocation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'The argument type is `Comparator`; therefore, what we have to set there should
    be an instance of a class that implements the `java.util.Comparator` interface.
    That interface defines only one method that implementations have to define: `compare.`
    Thus, we can define it as a lambda expression. Without lambda, if we need an instance,
    we have to type a lot. We have to create a class, name it, declare the `compare`
    method in it, and write the body of the method, as shown in the following code
    segment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'At the location of use, we should instantiate the class and pass it as an argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: We may save a few characters if we define the class as an anonymous class but
    the overhead is still there. What we really need is the body of the one and single
    method that we have to define. This is where lambda comes into the picture.
  prefs: []
  type: TYPE_NORMAL
- en: We can use a lambda expression in any place where we would otherwise need an
    instance of a class that has to define only one method. The methods that are defined
    and inherited from `Object` do not count, and we also do not care about the methods
    that are defined as `default` methods in the interface. They are there. Lambda
    defines the one that is not yet defined. In other words, lambda clearly depicts,
    with much less overhead as an anonymous class, that the value is a functionality
    that we pass as a parameter.
  prefs: []
  type: TYPE_NORMAL
- en: 'The simple form of a lambda expression is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: The parameters can be enclosed between parentheses or can only stand without.
    The body similarly can be enclosed between the `{` and`}` characters or it can
    be a simple expression. This way a lambda expression can reduce the overhead to
    a minimum, using the parentheses only where they are really needed.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is also an extremely useful feature of lambda expressions that we do not
    need to specify the types of the parameters in case it is obvious from the context
    where we use the expression. Thus, the preceding code segment can even be shorter,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: The parameters, `a` and `b`, will have the type as needed. To make it even simpler,
    we can also omit the `(` and`)` characters around the parameters in case there
    is only one.
  prefs: []
  type: TYPE_NORMAL
- en: 'The parentheses are not optional if there is more than one parameter. This
    is to avoid ambiguity in some situations. For example, the method call, `f(x,y->x+y)`
    could have been a method with two arguments: `x` and a lambda expression that
    has one parameter, `y`. At the same time, it could also be a method call with
    a lambda expression that has two parameters, `x` and `y`.'
  prefs: []
  type: TYPE_NORMAL
- en: Lambda expressions are very handy when we want to pass functionality as an argument.
    The declaration of the type of argument at the place of the method declaration
    should be a functional interface type. These interfaces can optionally be annotated
    using `@FunctionalInterface`. The Java runtime has many such interfaces defined
    in the `java.util.function` package. We will discuss some of them in the next
    section along with their use in streams. For the rest, the standard Java documentation
    is available from Oracle.
  prefs: []
  type: TYPE_NORMAL
- en: Streams
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Streams were also new in Java 8, just like lambda expressions. They work together
    very strongly, so their appearance at the same time is not a surprise. Lambda
    expressions as well as streams support the functional programming style.
  prefs: []
  type: TYPE_NORMAL
- en: The very first thing to clarify is that streams do not have anything to do with
    input and output streams, except the name. They are totally different things.
    Streams are more like collections with some significant differences. (If there
    were no differences, they would just have been collections.) Streams are essentially
    pipelines of operations that can run sequentially or in parallel. They obtain
    their data from collections or other sources, including data that is manufactured
    on-the-fly.
  prefs: []
  type: TYPE_NORMAL
- en: Streams support the execution of the same calculation on multiple data. This
    structure is referred to as **Single Instruction Multiple Data** (**SIMD**). Don't
    be afraid of the expression. This is a very simple thing. We have already done
    that many times in this book. Loops are also kind of SIMD structures. When we
    loop through the checker classes to see whether any of those opposes the order,
    we perform the same instruction for each and every checker. Multiple checkers
    are multiple data.
  prefs: []
  type: TYPE_NORMAL
- en: One problem with loops is that we define the order of execution when it is not
    needed. In the case of checkers, we do not really care what order the checkers
    are executed in. All we care about is that all are okay with the order. We still
    specify some order when we program the loop. This comes from the nature of loops,
    and there is no way we could change that. That is how they work. However, it would
    be nice if we could just, somehow, say *"do this and that for each and every checker"*.
    This is one point where streams come into the picture.
  prefs: []
  type: TYPE_NORMAL
- en: Another point is that code that uses loops is more imperative rather than descriptive.
    When we read the program of a loop construct, we focus on the individual steps.
    We first see what the commands in the loop do. These commands work on the individual
    elements of the data and not on the whole collection or array.
  prefs: []
  type: TYPE_NORMAL
- en: Later putting the individual steps together in our brain we realize what the
    big picture is, what the loop is for. In the case of streams, the description
    of operations is a level higher. Once we learn the stream methods, it is easier
    to read them. Stream methods work on the whole stream and not on the individual
    elements, and thus are more descriptive.
  prefs: []
  type: TYPE_NORMAL
- en: '`java.lang.Stream` is an interface. An object with a type implementing this
    interface represents many objects and provides methods that can be used to perform
    instructions on these objects. The objects may or may not be available when we
    start the operation on one of them, or may just be created when needed. This is
    up to the actual implementation of the `Stream` interface. For example, suppose
    we generate a stream that contains `int` values using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code snippet, all the elements cannot be generated because
    the stream contains an infinite number of elements. This example will return the
    numbers 0, 1, 2, and so on until further stream operations, which are not listed
    here, terminate the calculation.
  prefs: []
  type: TYPE_NORMAL
- en: When we program `Stream`, we usually create a stream from a `Collection`—not
    always, but many times. The `Collection` interface was extended in Java 8 to provide
    the `stream` and `parallelStream` methods. Both of them return stream objects
    that represent the elements of the collection. While `stream` returns the elements
    in the same order as they are in the collection in case there is a natural order,
    the `parallelStream` creates a stream that may be worked on in a parallel manner.
    In this case, if some of the methods that we use on the stream are implemented
    in that way, the code can use the multiple processors available in the computer.
  prefs: []
  type: TYPE_NORMAL
- en: As soon as we have a stream, we can use the methods that the `Stream` interface
    defines. The one to start with is `forEach`. This method has one argument, which
    is usually provided as a lambda expression and will execute the lambda expression
    for each element of the stream.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `Checker` class, we have the `isConsistent` method. In this method,
    there is a loop that goes through the annotations of the checker class. If we
    wanted to log the interfaces that the annotation in the loop implements, we could
    add the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we create a stream from an array using the factory method from
    the `Arrays` class. The array contains the interfaces returned by the reflection
    method, `getInterfaces`. The lambda expression has only one parameter; thus, we
    do not need to use parentheses around it. The body of the expression is a method
    call that returns no value; thus, we also omit the `{` and `}` characters.
  prefs: []
  type: TYPE_NORMAL
- en: Why all this hassle? What is the gain? Why couldn't we just write a simple loop
    that logs the elements of the array?
  prefs: []
  type: TYPE_NORMAL
- en: The gains are readability and maintainability. When we create a program, we
    have to focus on *what* the program should do and not on *how* it should do it.
    In an ideal world, a specification would just be executable. We may actually get
    there in the future when programming work will be replaced by artificial intelligence.
    (Not the programmers, though.) We are not there, yet. We have to tell the computers
    how to do what we want to achieve. We used to have to enter binary codes on the
    console of PDP-11 to get machine code deployed into the memory to have it executed.
    Later, we had assemblers; still later, we had FORTRAN and other high-level programming
    languages that have replaced much of the programming work as it was 40 years ago.
    All these developments in programming shift the direction from *how* towards *what*.
    Today, we program in Java 9, and the road still has miles to go.
  prefs: []
  type: TYPE_NORMAL
- en: The more we can express what to do instead of how to do, the shorter and more
    understandable our programs will be. It will contain the essence and not some
    artificial litter that is needed by the machines to just do what we want.
  prefs: []
  type: TYPE_NORMAL
- en: When I see a loop in a code I have to maintain, I assume that there is some
    importance of the order in which the loop is executed. There may be no importance
    at all. It may be obvious after a few seconds. It may need minutes or more to
    realize that the ordering is not important. This time is wasted and can be saved
    with programming constructs that better express the *what to do* part instead
    of the *how to do*.
  prefs: []
  type: TYPE_NORMAL
- en: Functional interfaces
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The argument to the method should be `java.util.function.Consumer`. This is
    an interface that requires the `accept` method to be defined, and this method
    is `void`. The lambda expression or a class that implements this interface will
    *consume* the argument of the `accept` method and does not produce anything.
  prefs: []
  type: TYPE_NORMAL
- en: There are several other interfaces defined in that package, each serving as
    a functional interface used to describe some method arguments that can be given
    as lambda expressions in the actual parameters.
  prefs: []
  type: TYPE_NORMAL
- en: For example, the opposite of `Consumer` is `Supplier`. This interface has a
    method named `get` that does not need any argument but gives some `Object` as
    a return value.
  prefs: []
  type: TYPE_NORMAL
- en: If there is an argument and also a returned value, the interface is called `Function`.
    If the returned value has to be the same type as the argument, then the `UnaryOperator`
    interface is our friend. Similarly, there is a `BinaryOperator` interface, which
    returns an object of the same type as the arguments. Just as we got from `Function`
    to `UnaryOperator`, we can see that in the other direction, there is also `BiFunction`
    in case the arguments and the return values do not share the type.
  prefs: []
  type: TYPE_NORMAL
- en: These interfaces are not defined independently of each other. If a method requires
    `Function` and we have `UnaryOperator` to pass, it should not be a problem. `UnaryOperator`
    is nothing else but `Function` that has the same type of arguments. A method that
    can work with `Function`, which accepts an object and returns an object, should
    not have a problem if they have the same type. Those can be, but need not be,
    different.
  prefs: []
  type: TYPE_NORMAL
- en: To let that happen, the `UnaryOperator` interface extends `Function` and thus
    can be used in the place of `Function`.
  prefs: []
  type: TYPE_NORMAL
- en: The interfaces in this class we met so far are defined using generics. Because
    generic types cannot be primitives, the interfaces that operate on primitive values
    should be defined separately. `Predicate`, for example, is an interface that defines
    `booleantest(T t)`. It is a function that returns a `boolean` value and is used
    many times in stream methods.
  prefs: []
  type: TYPE_NORMAL
- en: There are also interfaces, such as `BooleanSupplier`, `DoubleConsumer`, `DoubleToIntFunction`,
    and more, that work with primitive `boolean`, `double`, and `int`. The number
    of possible combinations of the different argument types and return values is
    infinite... almost.
  prefs: []
  type: TYPE_NORMAL
- en: '**Fun fact**: To be very precise, it is not infinite. A method can have at
    most 254 arguments. This limit is specified in the JVM and not in the Java language
    specification. Of course, one is useless without the other. There are 8 primitive
    types (plus `Object`, plus the possibility that there are less than 254 arguments),
    which means that the total number of possible functional interfaces is 10^(254),
    give or take, a few magnitudes. Practically, infinite!'
  prefs: []
  type: TYPE_NORMAL
- en: We should not expect to have all the possible interfaces defined in the JDK
    in this package. These are only those interfaces that are the most useful. There
    is no interface, for example, that uses `short` or `char`. If we need anything
    like that, then we can define the `interface` in our code. Or just think hard
    and find out how to use an already defined one. (I have never used the `short`
    type during my professional carrier. It was never needed.)
  prefs: []
  type: TYPE_NORMAL
- en: How are these functional interfaces used in streams? The `Stream` interface
    defines the methods that have some functional interface types as arguments. For
    example, the `allMatch` method has a `Predicate` argument and returns a `Boolean`
    value, which is `true` if all the elements in the stream match `Predicate`. In
    other words, this method returns `true` if and only if `Predicate`, supplied as
    an argument, returns `true` for each and every element of the stream.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following code, we will rewrite some of the methods that we implemented
    in our sample code using loops to use streams, and through these examples, we
    will discuss the most important methods that streams provide. We saved up two
    classes, `ProductsCheckerCollector` and `ProductInformationCollector`, to demonstrate
    the stream usage. We can start with these. `ProductsCheckerCollector` goes through
    all the products that are contained in the `Order` and collects the annotations
    that are listed in the products. Each product may contain zero, one, or many annotations.
    These are available in a list. The same annotation may be referenced multiple
    times. To avoid duplicates, we use `HashSet`, which will contain only one instance
    of the elements even if there are multiple instances in the products:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s see how this method looks when we recode it using streams:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'The major work of the method gets into a single, though huge, stream expression.
    We will cover the elements of the expression in the coming pages. `List` returned
    by `order.getItems` is converted calling the `stream` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: As we have already mentioned it briefly, the `stream` method is part of the
    `Collection` interface. Any class that implements the `Collection` interface will
    have this method, even those that were implemented before streams were introduced
    in Java 8\. This is because the `stream` method is implemented in the interface
    as a `default` method. This way, if we happen to implement a class implementing
    this interface, even if we do not need streams, we get it for free as an extra.
  prefs: []
  type: TYPE_NORMAL
- en: The `default` methods in Java 8 were introduced to support backward compatibility
    of interfaces. Some of the interfaces of the JDK were to be modified to support
    lambda and functional programming. One example is the `stream` method. With the
    pre-Java 8 feature set, the classes implementing some of the modified interfaces
    should have been modified. They would have been required to implement the new
    method. Such a change is not backward compatible, and Java as a language and JDK
    was paying keen attention to be backward compatible. Thus, `default` methods were
    introduced. These let a developer extend an interface and still keep it backward
    compatible, providing a default implementation for the methods, which are new.
  prefs: []
  type: TYPE_NORMAL
- en: Contrary to this philosophy, brand new functional interfaces of Java 8 JDK also
    have `default` methods, though, having no prior version in the JDK, they have
    nothing to be compatible with. In Java 9, interfaces were also extended and now
    they can contain not only `default` and `static` methods but also `private` methods.
    This way, interfaces became kind of equivalent to abstract classes, though there
    are no fields in an interface except constant `static` fields. This interface
    functionality open up is a much criticized feature, which just poses the programming
    style and structural issues that other languages allowing multiple class inheritance
    face. Java was avoiding this till Java 8 and Java 9.
  prefs: []
  type: TYPE_NORMAL
- en: What is the take-away from this? Be careful with `default` methods and also
    with `private` methods in interfaces. Use them wisely if at all.
  prefs: []
  type: TYPE_NORMAL
- en: The elements of this stream are `OrderItem` objects. We need `ProductInformation`
    for each `OrderItem`.
  prefs: []
  type: TYPE_NORMAL
- en: Method references
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Lucky that we have `Map`, which pairs order items with product information, so
    we can invoke `get` on `Map`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: The `map` method is again something that has the same name as something else
    in Java and should not be confused. While the `Map` class is a data structure,
    the `map` method in the `Stream` interface performs mapping of the stream elements.
    The argument of the method is a `Function` (recall that this is a functional interface
    we recently discussed). This function converts a value, `T`, which is available
    as the element of the original stream (`Stream<T>`) to a value, `R`, and the return
    value of the `map` method is `Stream<R>`. The `map` method converts `Stream<T>`
    to `Stream<R>` using the given `Function<T,R>`, calling it for each element of
    the original stream and creating a new stream from the converted elements.
  prefs: []
  type: TYPE_NORMAL
- en: We can say that the `Map` interface maps keys to values in a data structure
    in a static way, and the `Stream` method, `map`, maps one type of values to another
    (or the same) type of values dynamically.
  prefs: []
  type: TYPE_NORMAL
- en: 'We have already seen that we can provide an instance of a functional interface
    in the form of a lambda expression. This argument is not a lambda expression.
    This is a method reference. It says that the `map` method should invoke the `get`
    method on `Map piMap` using the actual stream element as an argument. We are lucky
    that `get` also needs one argument, aren''t we? We could also write as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: However, this would have been exactly the same as `piMap::get`.
  prefs: []
  type: TYPE_NORMAL
- en: This way, we can reference an instance method that works on a certain instance.
    In our example, the instance is the one referenced by the `piMap` variable. It
    is also possible to reference `static` methods. In this case, the name of the
    class should be written in front of the `::` characters. We will soon see an example
    of this when we will use the `static` method, `nonNull`, from the `Objects` class
    (note that the class name is in plural, and it is in the `java.util` package and
    not `java.lang`).
  prefs: []
  type: TYPE_NORMAL
- en: It is also possible to reference an instance method without giving the reference
    on which it should be invoked. This can be used in places where the functional
    interface method has an extra first parameter, which will be used as the instance.
    We have already used this in [Chapter 3](part0076.html), *Optimizing the Sort
    - Making Code Professional*, when we passed `String::compareTo`, when the expected
    argument was a `Comparator`. The `compareTo` method expects one argument, but
    the `compare` method in the `Comparator` interface needs two. In such a situation,
    the first argument will be used as the instance on which `compare` has to be invoked
    and the second argument is passed to `compare`. In this case, `String::compareTo`
    is the same as writing the lambda expression `(String a, String b) -> a.compareTo(b)`.
  prefs: []
  type: TYPE_NORMAL
- en: Last but not least, we can use method references to constructors. When we need
    a `Supplier` of (let's be simple) `Object`, we can write `Object::new`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next step is to filter out the `null` elements from the stream. Note that,
    at this point, the stream has `ProductInformation` elements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: The `filter` method uses `Predicate` and creates a stream that contains only
    the elements that match the predicate. In this case, we used the reference to
    a `static` method. The `filter` method does not change the type of stream. It
    only filters out the elements.
  prefs: []
  type: TYPE_NORMAL
- en: The next method we apply is a bit anti-functional. Pure functional stream methods
    do not alter the state of any object. They create new objects that they return
    but, other than that, there is no side effect. `peek` itself is no different because
    it only returns a stream of the same elements as the one it is applied on. However,
    this *no-operation* feature lures the novice programmer to do something non-functional
    and write code with side-effects. After all, why use it if there is no (side)
    effect in calling it?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'While the  `peek` method itself does not have any side effects, the execution
    of the lambda expression may have. However, this is also true for any of the other
    methods. It is just the fact that, in this case, it is more tempting to do something
    inadequate. Don''t. We are disciplined adults. As the name of the method suggests,
    we may peek into the stream but we are not supposed to do anything else. With
    programming being a particular activity, in this case, peeking, is adequate. And
    that is what we actually do in our code: we log something.'
  prefs: []
  type: TYPE_NORMAL
- en: 'After this, we get rid of the elements that have no `ProductInformation`; we
    also want to get rid of the elements that have, but there is no checker defined:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'In this case, we cannot use method references. Instead, we use a lambda expression.
    As an alternative solution, we may create a `boolean hasCheck` method in `ProductInformation`,
    which returns `true` if the `private` field check is not `null`. This would then
    read as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: This is totally valid and works, although the class does not implement any functional
    interface and has many methods, not only this one. However, the method reference
    is explicit and specifies which method to invoke.
  prefs: []
  type: TYPE_NORMAL
- en: 'After this second filter, we log the elements again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'The next method is `flatMap` and this is something special and not easy to
    comprehend. At least for me, it was a bit more difficult than understanding `map`
    and `filter` when I learned functional programming:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: This method expects that the lambda, method reference, or whatever is passed
    to it as an argument, creates a whole new stream of objects for each element of
    the original stream the method is invoked on. The result is, however, not a stream
    of streams, which also could be possible, but rather the returned streams are
    concatenated into one huge stream.
  prefs: []
  type: TYPE_NORMAL
- en: If the stream we apply it to is a stream of integer numbers, such as 1, 2, 3,
    ..., and the function for each number *n* returns a stream of three elements *n*,
    *n+1*, and *n+2*, then the resulting stream, `flatMap`, produces a stream containing
    1, 2, 3, 2, 3, 4, 3, 4, 5, 4, 5, 6, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, the stream we have should be collected to a `Set`. This is done by
    calling the `collector` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: The argument to the `collector` method is (again a name overuse) `Collector`.
    It can be used to collect the elements of the stream into some collection. Note
    that `Collector` is *not* a functional interface. You cannot just collect something
    using a lambda or a simple method. To collect the elements, we definitely need
    some place where the elements are collected as the ever-newer elements come from
    the stream. The `Collector` interface is not simple. Fortunately, the `java.util.streams.Collectors`
    class (again note the plural) has a lot of `static` methods that create and return
    `Object` that create and return `Collector` objects.
  prefs: []
  type: TYPE_NORMAL
- en: One of these is `toSet`, which returns a `Collector` that helps collect the
    elements of the stream into a `Set`. The `collect` method will return the `Set`
    when all the elements are there. There are other methods that help collect the
    stream elements by summing up the elements, calculating the average, or to a `List`,
    `Collection`, or to a `Map`. Collecting elements to a `Map` is a special thing,
    since each element of a `Map` is actually a key-value pair. We will see the example
    for that when we look at `ProductInformationCollector`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `ProductInformationCollector` class code contains the `collectProductInformation`
    method, which we will use from the `Checker` class as well as from the `ProductsCheckerCollector`
    class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: The simple trick is to store the collected value in `Map`, and if that is not
    `null`, then just return the already calculated value, which may save a lot of
    service calls in case this method is called more than once handling the same HTTP
    request.
  prefs: []
  type: TYPE_NORMAL
- en: There are two ways of coding such a structure. One is checking the non-nullity
    of the `Map` and returning if the `Map` is already there. This pattern is widely
    used and has a name. This is called guarding *if*. In this case, there is more
    than one return statement in the method, which may be seen as a weakness or anti-pattern.
    On the other hand, the tabulation of the method is one tab shallower.
  prefs: []
  type: TYPE_NORMAL
- en: It is a matter of taste and in case you find yourself in the middle of a debate
    about one or the other solution, just do yourself a favor and let your peer win
    on this topic and save your stamina for more important issues, for example, whether
    you should use streams or just plain old loops.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s see how we can convert this solution into a functional style:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: We use a helper class, `Tuple`, which is nothing but two `Object` instances
    named `r` and `s`. We will list the code for this class later. It is very simple.
  prefs: []
  type: TYPE_NORMAL
- en: In the streams expression, we first create the stream from the collection, and
    then we map the `OrderItem` elements to a stream of `OrderItem` and `productId`
    tuples. Then we map these tuples to tuples that now contain `OrderItem` and `ProductInformation`.
    These two mappings could be done in one mapping call, which would perform the
    two steps only in one. I decided to create the two to have simpler steps in each
    line in a vain hope that the resulting code will be easier to comprehend.
  prefs: []
  type: TYPE_NORMAL
- en: The filter step is also nothing new. It just filters out invalid product information
    elements. There should actually be none. It happens if the order contains an order
    ID to a non-existent product. This is checked in the next statement when we look
    at the number of collected product information elements to see that all the items
    have proper information.
  prefs: []
  type: TYPE_NORMAL
- en: The interesting code is how we collect the elements of the stream into a `Map`.
    To do so, we again use the `collect` method and also the `Collectors` class. This
    time, the `toMap` method creates the `Collector`. This needs two `Function` resulting
    expressions. The first one should convert the element of the stream to the key
    and the second should result in the value to be used in the `Map`. Because the
    actual type of the key and the value is calculated from the result of the passed
    lambda expressions, we explicitly have to cast the fields of the tuple to the
    needed types.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, the simple `Tuple` class is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: There are still some classes in our code that deserve to be converted to functional
    style. These are the `Checker` and `CheckerHelper` classes.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `Checker` class, we can rewrite the `isConsistent` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: Since you have already learnt most of the important stream methods, there is
    hardly any new issue here. We can mention the `anyMatch` method, which will return
    `true` if there is at least one element so that the `Predicate` parameter passed
    to `anyMatch` is `true`. It may also need some accommodation so that we could
    use a stream inside another stream. It very well may be an example when a stream
    expression is overcomplicated and needs to split up into smaller pieces using
    local variables.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, before we leave the functional style, we rewrite the `containsOneOf`
    method in the `CheckHelper` class. This contains no new elements and will help
    you check what you have learned about `map`, `filter`, `flatMap`, and `Collector`.
    Note that this method, as we discussed, returns `true` if `order` contains at
    least one of the order IDs given as strings:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'We create the stream of the `OrderItem` objects, and then we map it to a stream
    of the IDs of the products contained in the stream. Then we create another stream
    for each of the IDs with the elements of the ID and one of the string IDs given
    as the argument. Then, we flatten these substreams into one stream. This stream
    will contain `order.getItems().size()` times `ids.length` elements: all possible
    pairs. We will filter out those pairs that contain the same ID twice, and finally,
    we will count the number of elements in the stream.'
  prefs: []
  type: TYPE_NORMAL
- en: Scripting in Java 9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We are almost ready with our sample program for this chapter. There is one issue,
    though it is not professional. When we have a new product that needs a new checker,
    we have to create a new release of the code.
  prefs: []
  type: TYPE_NORMAL
- en: Programs in professional environments have releases. When the code is modified,
    bugs are fixed, or a new function is implemented, there are numerous steps that
    the organization requires before the application can go into production. These
    steps compose the release process. Some environments have lightweight release
    processes; others require rigorous and expensive checks. It is not because of
    the taste of the people in the organization, though. When the cost of a non-working
    production code is low and it does not matter if there is an outage or wrong functioning
    in the program, then the release process can be simple. This way, releases get
    out faster and cheaper. An example can be some chat program that is used for fun
    by the users. In such a situation, it may be more important to release new fancy
    features than ensuring bug-free working. On the other end of the palette, if you
    create code that controls an atomic power plant, the cost of failure can be pretty
    high. Serious testing and careful checking of all the features, even after the
    smallest change, can pay off.
  prefs: []
  type: TYPE_NORMAL
- en: In our example, simple checkers may be an area that is not likely to induce
    serious bugs. It is not impossible but the code is so simple...Yes, I know that
    such an argument is a bit fishy, but let's assume that these small routines could
    be changed with less testing and in an easier way than the other parts of the
    code. How to separate the code for these little scripts, then, so that they do
    not require a technical release, a new version of the application, and not even
    restarting the application? We have a new product that needs a new check and we
    want to have some way to inject this check into the application environment without
    any service disruption.
  prefs: []
  type: TYPE_NORMAL
- en: 'The solution we choose is scripting. Java programs can execute scripts written
    in *JavaScript*, *Groovy*, *Jython* (which is the *JVM* version of the language
    *Python*), and many other languages. Except *JavaScript*, the language interpreters
    of these languages are not a part of the JDK, but they all provide a standard
    interface, which is defined in the JDK. The consequence is that we can implement
    script execution in our code and the developers, who provide the scripts, are
    free to choose any of the available languages; we do not need to care to execute
    a *JavaScript* code. We will use the same API as to execute *Groovy* or *Jython*.
    The only thing we should know is what language the script is in. This is usually
    simple: we can guess that from the file extension, and if guessing is not enough,
    we can demand that the script developers put *JavaScript* into files with the
    `.js` extension, *Jython* into files with `.jy` or `.py`, *Groovy* into files
    with `.groovy`, and so on. It is also important to note that if we want our program
    to execute one of these languages, we should make sure that the interpreter is
    on the classpath. In the case of *JavaScript*, this is given; therefore, as a
    demonstration in this chapter, we will write our scripts in *JavaScript*. There
    will not be a lot; this is a Java book and not a *JavaScript* book after all.'
  prefs: []
  type: TYPE_NORMAL
- en: Scripting is usually a good choice when we want to pass the ability of programmatically
    configuring or extending our application. This is our case now.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first thing we have to do is to extend the production information. In case
    there is a script that checks the consistency of an order that a product is in,
    we need a field where we can specify the name of the script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: We do not want to specify more than one script per product; therefore, we do
    not need a list of script names. We have only one script specified by the name.
  prefs: []
  type: TYPE_NORMAL
- en: To be honest, the data structure for the checker classes and the annotations,
    allowing multiple annotations per product and also per checker class, was too
    complicated. We could not avoid that, though, to have a complex enough structure
    that could demonstrate the power and capability of stream expressions. Now that
    we are over that subject, we can go on using simpler data structures focusing
    on script execution.
  prefs: []
  type: TYPE_NORMAL
- en: We also have to modify the `Checker` class to not only use the checker classes
    but also the scripts. We cannot throw away the checker classes because, by the
    time we realize that we better need scripts for the purpose, we already have a
    lot of checker classes and we have no financing to rewrite them to be scripts.
    Well yes, we are in a book and not in real life, but in an enterprise, that would
    be the case. That is why you should be very careful while designing solutions
    for a corporate. The structures and the solutions will be there for a long time
    and it is not easy to throw a piece of code out just because it is technically
    not the best. If it works and is already there, the business will be extremely
    reluctant to spend money on code maintenance and refactoring.
  prefs: []
  type: TYPE_NORMAL
- en: 'Summary: we modify the `Checker` class. We need a new class that can execute
    our scripts; thus, the constructor is modified:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: We also have to use this `executor` in the `isConsistent` method`:`
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: Note that in this code, we use parallel streams because, why not? Whenever it
    is possible, we can use parallel streams, even unordered, to tell the underlying
    system and also to the programmer fellows maintaining the code that order is not
    important.
  prefs: []
  type: TYPE_NORMAL
- en: 'We also modify one of our product JSON files to reference a script instead
    of a checker class through some annotation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: Even JSON is simpler. Note that as we decided to use JavaScript, we do not need
    to specify the file name extension when we name the script.
  prefs: []
  type: TYPE_NORMAL
- en: We may later consider further development when we will allow the product checker
    script maintainers to use different scripting languages. In such a case, we may
    still require that they specify the extension, and in case there is no extension,
    it will be added by our program as `.js`. In our current solution, we do not check
    that, but we may devote a few seconds to think about it to be sure that the solution
    can be further developed. It is important that we do not develop extra code for
    the sake of further development. Developers are not fortunetellers and cannot
    tell reliably what the future needs will be. That is the task of the business
    people.
  prefs: []
  type: TYPE_NORMAL
- en: 'We put the script into the `resource` directory of our project under the `scripts`
    directory. The name of the file has to be `powered_device.js` because this is
    the name we specified in the JSON file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: This is an extremely simple JavaScript program. As a side note, when you iterate
    over a list or an array in JavaScript, the loop variable will iterate over the
    indexes of the collection or the array. Since I rarely program in JavaScript,
    I fell into this trap and it took me more than half an hour to debug the error
    I made.
  prefs: []
  type: TYPE_NORMAL
- en: We have prepared everything we need to call the script. We still have to invoke
    it. To do so, we use the JDK scripting API. First, we need a `ScriptEngineManager`.
    This manager is used to get access to the JavaScript engine. Although the JavaScript
    interpreter has been a part of the JDK since Java 7, it is still managed in an
    abstract way. It is one of the many possible interpreters that a Java program
    can use to execute script. It just happens to be there in the JDK, so we do not
    need to add the interpreter JAR to the classpath. `ScriptEngineManager` discovers
    all the interpreters that are on the classpath and registers them.
  prefs: []
  type: TYPE_NORMAL
- en: It does so using the Service Provider specification, which has been a part of
    the JDK for a long time, and by Java 9, it also got extra support in module handling.
    This requires the script interpreters to implement the `ScriptEngineFactory` interface
    and also to list the class that does it in the `META-INF/services/javax.script.ScriptEngineFactory`
    file. These files, from all the JAR files that are part of the classpath, are
    read as resources by `ScriptEngineManager`, and through this, it knows which classes
    implement script interpreters. The `ScriptEngineFactory` interface requires that
    the interpreters provide methods such as `getNames`, `getExtensions`, and `getMimeTypes`.
    The manager calls these methods to collect the information about the interpreters.
    When we ask a JavaScript interpreter, the manager will return the one created
    by the factory that said that one of its names is `JavaScript`.
  prefs: []
  type: TYPE_NORMAL
- en: To get access to the interpreters through the name, file name extension or mime-type
    is only one of the functions of `ScriptEngineManager`. The other one is to manage
    `Bindings`.
  prefs: []
  type: TYPE_NORMAL
- en: When we execute a script from within the Java code, we don't do it because we
    want to increase our dopamine levels. In the case of scripts, it does not happen.
    We want some results. We want to pass parameters and after the execution of the
    script, we want values back from the script that we can use in the Java code.
    This can happen in two ways. One is by passing parameters to a method or function
    implemented in the script and getting the return value from the script. This usually
    works, but it may even happen that some scripting language does not even have
    the notion of the function or method. In such a case, it is not a possibility.
    What is possible is to pass some environment to the script and read values from
    the environment after the script is executed. This environment is represented
    by `Bindings`.
  prefs: []
  type: TYPE_NORMAL
- en: '`Bindings` is a map that has `String` keys and `Object` values.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the case of most scripting languages, for example, in JavaScript, `Bindings`
    is connected to global variables in the script we execute. In other words, if
    we execute the following command in our Java program before invoking the script,
    then the JavaScript global variable, `globalVariable`, will reference the `myObject`
    object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: We can create `Bindings` and pass it to `ScriptEngineManager` but just as well
    we can use the one that it creates automatically, and we can call the `put` method
    on the engine object directly.
  prefs: []
  type: TYPE_NORMAL
- en: There are two `Bindings` when we execute scripts. One is set on the `ScriptEngineManager`
    level. This is named global binding. There is also one managed by `ScriptEngine`
    itself. This is the local `Bindings`. From the script point of view, there is
    no difference. From the embedding side, there is some difference. In case we use
    the same `ScriptEngineManager` to create multiple `ScriptEngine` instances, then
    the global bindings are shared by them. If one gets a value, all of them see the
    same value; if one sets a value, all others will later see that changed value.
    The local binding is specific to the engine it is managed by. Since we only introduce
    Java scripting API in this book, we do not get into more details and we will not
    use `Bindings`. We are good with invoking a JavaScript function and to get the
    result from it.
  prefs: []
  type: TYPE_NORMAL
- en: 'The class that implements the script invocation is `CheckerScriptExecutor`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: The only `public` method, `notConsistent`, gets the name of the script to execute
    and also `order`. The latter has to be passed to the script. First it gets `Reader`,
    which can read the script text, evaluates it, and finally returns the result in
    case it is `boolean` or can at least be converted to `boolean`. If any of the
    methods invoked from here that we implemented in this class is erroneous, it will
    throw an exception, but only after appropriately logging it. In such cases, the
    safe way is to refuse an order.
  prefs: []
  type: TYPE_NORMAL
- en: Actually, this is something that the business should decide. If there is a check
    script that cannot be executed, it is clearly an erroneous situation. In this
    case, accepting an order and later handling the problems manually has certain
    costs. Refusing an order or confirmation because of some internal bug is also
    not a happy path of the order process. We have to check which approach causes
    the least damage to the company. It is certainly not the duty of the programmer.
    In our situation, we are in an easy situation.
  prefs: []
  type: TYPE_NORMAL
- en: We assume that the business representatives said that the order in such a situation
    should be refused. In real life, similar decisions are many times refused by the
    business representatives saying that it just should not happen and the IT department
    has to ensure that the program and the whole operation is totally bug free. There
    is a psychological reason for such a response, but this really leads us extremely
    far from Java programming.
  prefs: []
  type: TYPE_NORMAL
- en: 'Engines can execute a script passed through `Reader` or as `String`. Because
    now we have the script code in a resource file, it seems to be a better idea to
    let the engine read the resource instead of reading it to a `String`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'To read the script from a resource file, we use the Spring `ClassPathResource`
    class. The name of the script is prepended with the `scripts` directory and appended
    by the`.js` extension. The rest is fairly standard and nothing we have not seen
    in this book. The next method that evaluates the script is more interesting:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: To execute the method in the script, first of all, we need a script engine that
    is capable of handling **JavaScript**. We get the engine from the manager by its
    name. If it is not **JavaScript**, we should check that the returned `engine`
    is not `null`. In the case of **JavaScript**, the interpreter is part of the **JDK**
    and checking that the **JDK** conforms to the standard would be paranoid.
  prefs: []
  type: TYPE_NORMAL
- en: If ever we want to extend this class to handle not only **JavaScript** but also
    other types of scripts, this check has to be done, and also the script engine
    should probably be requested from the manager by the file name extension, which
    we do not have access to in this `private` method. But that is future development,
    not in this book.
  prefs: []
  type: TYPE_NORMAL
- en: When we have the engine, we have to evaluate the script. This will define the
    function in the script so that we can invoke it afterwards. To invoke it, we need
    some `Invocable` object. In the case of **JavaScript**, the engine also implements
    an `Invocable` interface. Not all script engines implement this interface. Some
    scripts do not have functions or methods, and there is nothing to invoke in them.
    Again, this is something to do later, when we want to allow not only **JavaScript**
    scripting but also other types of scripting.
  prefs: []
  type: TYPE_NORMAL
- en: 'To invoke the function, we pass its name to the `invokeFunction` method and
    also the arguments that we want to pass on. In this case, this is the `order`.
    In the case of **JavaScript**, the integration between the two languages is fairly
    developed. As in our example, we can access the field and the methods of the Java
    objects that are passed as arguments and the returned JavaScript `true` or `false`
    value is also converted to `Boolean` magically. There are some situations when
    the access is not that simple though:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: The last method of the class checks that the returned value, which can be anything
    since this is a script engine, is convertible to `boolean`.
  prefs: []
  type: TYPE_NORMAL
- en: It is important to note that the fact that some of the functionality is implemented
    in script does not guarantee that the application works seamlessly. There may
    be several issues and scripts may affect the inner working of the entire application.
    Some scripting engines provide special ways to protect the application from bad
    scripts, others do not. The fact that we do not pass but order to the script does
    not guarantee that a script cannot access other objects. Using reflection, `static`
    methods, and other techniques there can be ways to access just anything inside
    our Java program. We may be a bit easier with the testing cycle when only a script
    changes in our code base, but it does not mean that we should blindly trust any
    script.
  prefs: []
  type: TYPE_NORMAL
- en: In our example, it probably would be a very bad idea to let the producers of
    the products upload scripts to our system. They may provide their check scripts,
    but these scripts have to be reviewed from the security point of view before being
    deployed into the system. If this is properly done, then scripting is an extremely
    powerful extension to the Java ecosystem, giving great flexibility to our programs.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have developed the ordering system of our enterprise application.
    Along with the development of the code, we met many new things. You learned about
    annotations and how they can be handled by reflections. Although not strongly
    related, you learned how to use lambda expressions and streams to express some
    programming constructs simpler than conventional loops. In the last part of the
    chapter, we extended the application using scripting, by invoking JavaScript functions
    from Java and also by invoking Java methods from JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: In fact, with all this knowledge, we matured to a Java level that is needed
    for enterprise programming. The rest of the topics the book covers are for the
    aces. But you want to be one, don't you? This is why I wrote the rest of the chapters.
    Read on!
  prefs: []
  type: TYPE_NORMAL
