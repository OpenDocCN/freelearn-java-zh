<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Spring Aspect Oriented Programming with Proxy and Decorator pattern</h1>
                </header>
            
            <article>
                
<p>Before you start reading this chapter, I want to share something with you; as I was writing this chapter, my wife Anamika, was taking a selfie and uploading it to several social media sites such as Facebook and WhatsApp. She keeps a track of the <em>likes</em>, However, uploading more photos uses more mobile data, and mobile data costs money. I rarely use social media as I prefer to avoid paying more to the internet company. Every month, the internet company knows how much to bill us. Now consider what would happen if the internet usage, total call duration and bill calculation was meticulously planned and managed by us? It's possible that some obsessive internet users would manage it and I'm really clueless as to how.</p>
<p>Calculating billing for internet usage and calls is an important function, but it is still not predominant for most internet users. For those like my wife, taking selfies, uploading photos to social media, and watching videos on YouTube are the kinds of things that most internet users are actively involved in. Managing and calculating their internet bill is a passive action for internet users.</p>
<p>Similarly some modules of the enterprise applications are like the internet billing calculator for our internet usage. There are some modules in the application that have important functionalities that need to be placed at multiple points in the application. But it is unexpected to explicitly call these functionalities at every points. Functionalities such as logging, security, and transaction management are important for your application but your business objects are not actively participating in it because your business objects need to focus on the business domain problems they're designed for, and leave certain aspects to be handled by someone else.</p>
<p>In software development, there are specific tasks to be performed at certain points in an application. These tasks or functions are known as <strong>cross-cutting concerns</strong>. In an application, all cross-cutting concerns are separate from the business logic of this application. Spring provides a module <strong>Aspect-Oriented Programming</strong> (<strong>AOP</strong>) to separate these cross-cutting concerns from the business logic.</p>
<p>As in <a href="fb30c4f8-9c4c-4705-b508-3782801e2a81.xhtml">Chapter 4</a>, <em>Wiring Beans using Dependency Injection Pattern</em>, you learned about the dependency injection to configure and resolve dependencies of collaborating objects in the application. Whereas DI promotes programming to interface and decoupling application objects from each other, Spring AOP promotes decoupling between the application's business logic and the cross-cutting concerns in the application.</p>
<p>In our bankapp example, transferring money from one account to another account is a business logic but logging this activity and securing the transaction are cross-cutting concerns in our bankapp application. That means logging, security, and transaction are common examples of the application of aspects.</p>
<p>In this chapter, you will explore Spring's support for aspects. It will cover the following points:</p>
<ul>
<li>Proxy pattern in Spring</li>
<li>Adapter design pattern to handle load time weaving</li>
<li>Decorator design pattern</li>
<li>Aspect-oriented programming</li>
<li>Problems resolved by AOP</li>
<li>Core AOP concepts</li>
<li>Defining point cuts</li>
<li>Implementing Advices</li>
<li>Creating aspects</li>
<li>Understanding AOP proxies</li>
</ul>
<p>Before we go further into our Spring AOP discussion, let's first understand the implemented patterns under the Spring AOP Framework, and see how these patterns are applied.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Proxy pattern in Spring</h1>
                </header>
            
            <article>
                
<p>Proxy design pattern provides an object of class that has the functionality of another class. This pattern comes under the structural design pattern of GOF design patterns. According to GOF pattern, <em>Provide a surrogate or placeholder for another object to control access to it</em>. The intent of this design pattern is to provide a different class for another class with its functionality to the outer world.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Proxying classes using Decorator pattern in Spring</h1>
                </header>
            
            <article>
                
<p>As you have seen in <a href="bd05acbb-a42a-4070-9e01-54a8ce049e41.xhtml" target="_blank">Chapter 3</a>, <em>Consideration of Structural and Behavioral Patterns</em>, according to GOF book, <em>Attach additional responsibilities to an object dynamically. Decorators provide a flexible alternative to subclassing for extending functionality.</em> This pattern allows you to add and remove behaviors to an individual object at the runtime dynamically or statically without changing the existing behavior of other associated objects from the same class.</p>
<p>In Spring AOP, CGLIB is used to create the proxy in the application. CGLIB proxying works by generating a subclass of the target class at runtime. Spring configures this generated subclass to delegate method calls to the original target--the subclass is used to implement the Decorator pattern, weaving in the advice.</p>
<p>Spring provides two ways to create the proxy in the application.</p>
<ul>
<li>CGLIB proxy</li>
<li>JDK proxy or dynamic proxy</li>
</ul>
<p>Let's see the following table:</p>
<table class="table">
<tbody>
<tr>
<td>
<p><strong>JDK proxy</strong></p>
</td>
<td>
<p><strong>CGLIB proxy</strong></p>
</td>
</tr>
<tr>
<td>
<p>Also called <strong>dynamic proxies</strong></p>
</td>
<td>
<p>NOT built into JDK</p>
</td>
</tr>
<tr>
<td>
<p>API is built into the JDK</p>
</td>
<td>
<p>Included in Spring JARs</p>
</td>
</tr>
<tr>
<td>
<p>Requirements: Java interface(s)</p>
</td>
<td>
<p>Used when interface not available</p>
</td>
</tr>
<tr>
<td>
<p>All interfaces proxied</p>
</td>
<td>
<p>Cannot be applied to final classes or methods</p>
</td>
</tr>
</tbody>
</table>
<p>Let's see the following figure:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img height="218" width="446" class=" image-border" src="assets/9b911954-7460-422b-be91-2ca3bb52de3e.png"/></div>
<div class="packt_infobox">Note--CGLIB proxying has one issue to be considered, that is, final methods can't be advised, as they can't be overridden.</div>
<p>In the following section let's learn more about the cross-cutting concerns.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">What are cross-cutting concerns?</h1>
                </header>
            
            <article>
                
<p>In any application, there is some generic functionality that is needed in many places. But this functionality is not related to the application's business logic. Suppose you perform a role-based security check before every business method in your application. Here security is a cross-cutting concern. It is required for any application but it is not necessary from the business point of view, it is a simple generic functionality we have to implement in many places in the application. The following are examples of the cross-cutting concerns for the enterprise application.</p>
<ul>
<li>Logging and tracing</li>
<li>Transaction management</li>
<li>Security</li>
<li>Caching</li>
<li>Error handling</li>
<li>Performance monitoring</li>
<li>Custom business rules</li>
</ul>
<p>Let's see how we will implement these cross-cutting concerns in our application by using aspects of Spring AOP.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">What is Aspect-Oriented Programming?</h1>
                </header>
            
            <article>
                
<p>As mentioned earlier, <strong>Aspect-Oriented Programming</strong> (<strong>AOP</strong>) enables modularization of cross-cutting concerns. It complements <strong>Object-oriented programming</strong> (<strong>OOP</strong>) which is another programing paradigm. OOP has class and object as key elements but AOP has aspect as key element. Aspects allow you to modularize some functionality across the application at multiple points. This type of functionality is known as <strong>cross-cutting concerns</strong>. For example, security is one of the cross-cutting concerns in the application, because we have to apply it at multiple methods where we want security. Similarly, transaction and logging are also cross-cutting concerns for the application and many more. Let's see in the following figure how these concerns are applied to the business modules:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img height="278" width="388" class=" image-border" src="assets/adfca5cd-3471-4fc6-9b82-e378370fb23a.png"/></div>
<p>As you can see in the preceding figure, there are three main business modules as <strong>TransferService</strong>, <strong>AccountService</strong>, and <strong>BankService</strong>. All business modules require some common functionality such as <strong>Security</strong>, <strong>Transaction</strong> management and <strong>Logging</strong>.</p>
<p>Let's check out what problems we have to face in the application if we do not use the Spring AOP.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Problems resolved by AOP</h1>
                </header>
            
            <article>
                
<p>As stated earlier, aspects enable modularization of cross-cutting concerns. So if you are not using aspects, then modularization of some cross-cutting functionality is not possible. It tends to mix the cross-cutting functionality with the business modules. If you use a common object-oriented principle to reuse the common functionalities such as security, logging and transaction management, <em>you need to use</em> inheritance or composition. But here using inheritance can violate the single responsibility of SOLID principles and also increase object hierarchy. Also, the composition can be complicated to handle across the application. That means, failing to modularize cross-cutting concerns leads to two main problems as follows:</p>
<ul>
<li>Code tangling</li>
<li>Code scattering</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Code tangling</h1>
                </header>
            
            <article>
                
<p>It is a coupling of concerns in the application. Code tangling occurs when there is a mixing of cross-cutting concerns with the application's business logic. It promotes tight coupling between the cross-cutting and business modules. Let's see the following code to understand more about code tangling:</p>
<pre>    public class TransferServiceImpl implements TransferService { 
      public void transfer(Account a, Account b, Double amount) { 
        //Security concern start here 
        if (!hasPermission(SecurityContext.getPrincipal()) { 
          throw new AccessDeniedException(); 
        } 
        //Security concern end here 
          
        //Business logic start here 
        Account aAct = accountRepository.findByAccountId(a); 
        Account bAct = accountRepository.findByAccountId(b); 
        accountRepository.transferAmount(aAct, bAct, amount); 
        ... 
      } 
    } </pre>
<p>As you can see in the preceding code, security concern code (highlighted) is mixing with application's business logic code. This situation is an example of code tangling. Here we have only included security concern, but in the enterprise application you have to implement multiple cross-cutting concerns such as logging, transaction management and so on. In such cases, it will be even more complicated to manage the code and make any change to the code, which may cause critical bugs in the code as follows in the figure:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img height="258" width="281" class=" image-border" src="assets/5e372d1d-cc14-4430-94d1-8926573c605a.png"/></div>
<p>In the preceding figure, you can see there are three cross-cutting concerns which are distributed across the <kbd>TransferService</kbd> business class and cross-cutting concerns logic mixing with <kbd>AccountService</kbd>'s business logic. This coupling between the concerns and application's logic is called <strong>code tangling</strong>. Let's see another main problem if we are using aspects for cross-cutting concern.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Code scattering</h1>
                </header>
            
            <article>
                
<p>This means that the same concern is spread across modules in the application. Code scattering promotes the duplicity of the concern's code across the application modules. Let's see the following code to understand more about code scattering:</p>
<pre>    public class TransferServiceImpl implements TransferService { 
      public void transfer(Account a, Account b, Double amount) { 
        //Security concern start here 
        if (!hasPermission(SecurityContext.getPrincipal()) { 
          throw new AccessDeniedException(); 
        } 
        //Security concern end here 
          
        //Business logic start here 
        ... 
      } 
    } 
 
    public class AccountServiceImpl implements AccountService { 
      public void withdrawl(Account a, Double amount) { 
        //Security concern start here 
        if (!hasPermission(SecurityContext.getPrincipal()) { 
          throw new AccessDeniedException(); 
        } 
        //Security concern end here 
          
        //Business logic start here 
        ... 
      } 
    } </pre>
<p>As you can see in the preceding code, there are two modules for the application, <kbd>TransferService</kbd> and <kbd>AccountService</kbd>. Both modules have the same cross-cutting concern code for the security. The bold highlighted code in both business modules are the same, it means there is code duplication here. The following figure illustrates code scattering:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img class=" image-border" src="assets/c8012756-1076-44af-b483-493e64d5e477.png"/></div>
<p>In the preceding figure, there are three business modules <strong>TransferService</strong>, <strong>AccountService</strong>, and <strong>BankService</strong>. Each business module contains cross-cutting concerns such as <strong>Security</strong>, <strong>Logging</strong> and <strong>Transaction</strong> management. All modules have the same code of concerns in the application. It is actually duplication of concerns code across the application.</p>
<p>Spring AOP provides solution for these two problems that is, code tangling and code scattering in the Spring application. Aspects enable modularization of cross-cutting concerns to avoid tangling and to eliminate scattering. Let's see in further section how AOP solves these problems.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How AOP Works to solve problems</h1>
                </header>
            
            <article>
                
<p>Spring AOP allows you to keep cross-cutting concern logic separate from the mainline application logic. That means, you can implement your mainline application logic and only focus on the core problem of the application. And you can write aspects to implement your cross-cutting concerns. Spring provides many aspects out-of-the-box. After creating the aspects, you can add these aspects that is, cross-cutting behaviors to the right places into your application. Let's see the following figure that illustrates the functionality of AOP:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img height="310" width="459" class=" image-border" src="assets/ef9a3a53-6425-4198-9c33-db865e4c4942.png"/></div>
<p>As you can see in the preceding figure, all aspects such as Security, Logging, and Transaction aspect are implemented separately in the application. We have added these aspects at the right places in the applications. Now our application logic is separate from the concerns. Let's see the following section defining the core AOP concepts and use AOP's terminology in your application.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Core AOP terminology and concepts</h1>
                </header>
            
            <article>
                
<p>As with other technologies, AOP has its own vocabularies. Let's start to learn some core AOP concepts and terminology. Spring used the AOP paradigm for the Spring AOP module. But unfortunately, terms used in the Spring AOP Framework are Spring-specific. These terms are used to describe AOP modules and features, but these aren't intuitive. In spite of this, these terms are used in order to understand AOP. Without an understanding of the AOP idiom you will not be able to understand AOP functionality. Basically, AOP is defined in terms of advice, pointcuts, and join points. Let's see the following figure that illustrates about the core AOP concepts and how they are tied together in the framework:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img height="260" width="451" class=" image-border" src="assets/f45ada93-dcf9-4f09-86db-f36b666fc9e6.png"/></div>
<p>In the preceding figure, you can see an AOP functionality, it is known as <strong>Advices</strong> and it is implemented into multiple points. These points are known as <strong>Joint Points</strong>, these are defined by using an expression. These expression are known as <strong>pointcuts</strong>. Let's understand these terms in detail using an example (remember my wife's internet bill story?).</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Advice</h1>
                </header>
            
            <article>
                
<p>An internet plan is used for calculating the bill according to data usage in MB or GB by the internet company. The internet company has a list of customers, also and they also company calculates the internet bill for them. So calculating bills and sending it to the customers is a core job for the internet company but not for customers. Likewise, each aspect has its own main job and also has a purpose for doing this job. The job of an aspect is known as advice in the AOP.</p>
<p>As you know now, advice is a job, aspect will perform this job, so there are some questions that come to in mind, when to perform this job and what will be in this job. Will this job be performed before a business method is invoked? Or will it be performed after the business method is invoked? Or will it be performed both before and after method invocation? Or it will be performed when business method throws an exception. Sometime this business method is also called the <strong>advised method</strong>. Let's see the following five kinds of advises used by Spring aspects:</p>
<ul>
<li><strong>Before:</strong> Advice's job executes before the <kbd>advised</kbd> method is invoked.</li>
</ul>
<div class="packt_infobox">If the advice throws an exception, target will not be called - this is a valid use of a Before Advice.</div>
<ul>
<li><strong>After:</strong> Advice's job executes after the advised method completes regardless of whether an exception has been thrown by the target or not.</li>
<li><strong>After-returning:</strong> Advice's job executes after the advised method successfully completes. For example, if a business method returns without throwing an exception.</li>
<li><strong>After-throwing:</strong> Advice's job executes if the advised method exits by throwing an exception.</li>
<li><strong>Around:</strong> This is one of the most powerful advice of Spring AOP, this advice surrounds the advised method, providing some advice's job before and after the advised method is invoked.</li>
</ul>
<p>In short, advice's job code to be executed at each selected point that is, Join Point, let's look into another term of AOP.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Join Point</h1>
                </header>
            
            <article>
                
<p>The internet company provides internet to many customers. Each customer has an internet plan and that plan needs to be used for their bill calculation. With the help of each internet plan, the company could potentially calculates the internet bill for all customers. Similarly, your application may have multiple number of places to apply advice. These places in the application are called <strong>join points</strong>. A join point is a point in the execution of a program such as a method call or exception thrown. In these points, Spring aspect inserts concern functionality in your application. Let's see how AOP knows about the join points and discuss another term of AOP concepts.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Pointcut</h1>
                </header>
            
            <article>
                
<p>Internet company makes a number of internet plans according to usage of internet data (customers like my wife need more data) because it is not possible for any internet company to provide same plan for all customers or a unique plan for each customer. Instead, each plan is assigned to the subset of the customers. In the same way, an advice is not necessary to apply to all join points in an application. You can define an expression that selects one or more Join Points in the application. This expression is known as <strong>pointcut</strong>. It helps to narrow down the join points advised by an aspect. Let's see another term of AOP that is Aspect.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Aspect</h1>
                </header>
            
            <article>
                
<p>An internet company knows which customer has what internet plan. On the basis of this information the internet company calculates an internet bill and sends it to the customer. In this example internet company is an aspect, internet plans are pointcuts and customers are join points, and calculating internet bills by the company is an advice. Likewise, in your application, an aspect is a module that encapsulates pointcuts and advice. Aspects know what it does; where and when it does it in the application. Let's see how AOP applies the aspect to the business methods.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Weaving</h1>
                </header>
            
            <article>
                
<p><strong>Weaving</strong> is a technique by which aspects are combined with the business code. This is a process of applying aspects to a target object by creating a new proxy object. Weaving can be done at the compile time or at class load time, or at runtime. Spring AOP uses the runtime weaving by using proxy pattern.</p>
<p>You have seen lot of terms used in the AOP. You must know about this terminology whenever your learn about any AOP Framework either AspectJ or Spring AOP. Spring has used AspectJ Framework to implement Spring AOP Framework. Spring AOP supports limited features of AspectJ. Spring AOP provides proxy-based AOP solution. Spring only supports the method joint points. Now you have some basic idea about Spring AOP and how it works, let's move on the next topics how to define pointcuts in the Spring's declarative AOP model.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Defining pointcuts</h1>
                </header>
            
            <article>
                
<p>As mentioned before, pointcuts are used to define a point where advice would be applied. So pointcut is one of the most important elements of an aspect in the application. Let's understand how to define pointcuts. In Spring AOP, we can use expression language to define the pointcuts. Spring AOP uses AspectJ's pointcut expression language for selecting where to apply advice. Spring AOP supports a subset of the pointcut designators available in AspectJ because as you know, Spring AOP is proxy-based and some designators do not support proxy-based AOP. Let's see following table has Spring AOP supported designators.</p>
<table class="table">
<tbody>
<tr>
<td>
<p><strong>Spring supported AspectJ designators</strong></p>
</td>
<td>
<p><strong>Description</strong></p>
</td>
</tr>
<tr>
<td>
<p>execution</p>
</td>
<td>
<p>It matches the join points by method executions, it is primary pointcut designator supported by Spring AOP.</p>
</td>
</tr>
<tr>
<td>
<p>within</p>
</td>
<td>
<p>It matches the join points by limit within certain types.</p>
</td>
</tr>
<tr>
<td>
<p>this</p>
</td>
<td>
<p>It limits matching to join points where the bean reference is an instance of the given type.</p>
</td>
</tr>
<tr>
<td>
<p>target</p>
</td>
<td>
<p>It limits matching to join points where the target object is of a given type.</p>
</td>
</tr>
<tr>
<td>
<p>args</p>
</td>
<td>
<p>It limits matching to join points where the arguments are instances of the given types.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>@target</kbd></p>
</td>
<td>
<p>It limits matching to join points where the target object has an annotation of the given type.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>@args</kbd></p>
</td>
<td>
<p>It limits matching to join points where the runtime, type of the actual arguments passed have annotations of the given type.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>@within</kbd></p>
</td>
<td>
<p>It limits matching to join points where the declared type of the target object has the given type annotation.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>@annotation</kbd></p>
</td>
<td>
<p>It limits matching to join points where the subject of the join point has the given annotation.</p>
</td>
</tr>
</tbody>
</table>
<p> </p>
<p>As listed earlier, Spring supported pointcut designators, execution is primary pointcut designator. So here I will only show you how to define pointcuts using execution designators. Let's see how to write the pointcut expression in the application.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Writing pointcuts</h1>
                </header>
            
            <article>
                
<p>We can write pointcuts by using execution designator as follows:</p>
<ul>
<li><strong>execution(&lt;method pattern&gt;)</strong>: The method must match the pattern as defined follows</li>
<li><strong>Can chain together to create composite pointcuts by using following operators</strong>: <kbd>&amp;&amp; (and)</kbd>, <kbd>|| (or)</kbd>, <kbd>! (not)</kbd></li>
<li><strong>Method pattern</strong>: Following is method pattern:
<ul>
<li><kbd>[Modifiers] ReturnType [ClassType]</kbd></li>
<li><kbd>MethodName ([Arguments]) [throws ExceptionType]</kbd></li>
</ul>
</li>
</ul>
<p>In the preceding method pattern, values within bracket <kbd>[ ]</kbd> that is, modifiers, <kbd>ClassType</kbd>, arguments and exceptions are all optional values. There is no need to define it for every pointcut using execution designator. Value without brackets such as <kbd>ReturnType</kbd>, and <kbd>MethodName</kbd> are mandatory to define.</p>
<p>Let's define a <kbd>TransferService</kbd> interface:</p>
<pre>    package com.packt.patterninspring.chapter6.bankapp.service; 
    public interface TransferService { 
      void transfer(String accountA, String accountB, Long amount); 
    } </pre>
<p><kbd>TransferService</kbd> is a service for transferring amounts from one to another account. Let's say that you want to write a logging aspect that triggers off <kbd>TransferService</kbd>'s <kbd>transfer()</kbd> method. The following figure illustrates a pointcut expression that can be used to apply advice whenever the <kbd>transfer()</kbd> method is executed:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img class=" image-border" src="assets/fd74bf26-fc3c-4b3a-a33e-28e15f5de131.png"/></div>
<p>As in the preceding figure, you can see, I used the <kbd>execution()</kbd> designator to select join point <kbd>TransferService</kbd>'s <kbd>transfer()</kbd> method. In preceding expression in figure, I have used an asterisk at the beginning of the expression. This means that method can return any type. And after asterisk, I have specified a fully qualified class name and name of method as <kbd>transfer()</kbd>. As method arguments, I have used double dot (..), it means that the pointcut can select a method whose name is <kbd>transfer()</kbd> with no parameter or any number of parameters.</p>
<p>Let's see following some more pointcut expressions to select join points:</p>
<ul>
<li>Any class or package:
<ul>
<li><strong>execution(void transfer*(String))</strong>: Any method starting with transfer that takes a single String parameter and has a void return type</li>
<li><strong>execution(* transfer(*))</strong>: Any method named <kbd>transfer()</kbd> that takes a single parameter</li>
<li><strong>execution(* transfer(int, ..))</strong>: Any method named transfer whose first parameter is an int (the <kbd>".."</kbd> signifies zero or more parameters may follow)</li>
</ul>
</li>
<li>Restrict by class:
<ul>
<li><kbd>execution(void com.packt.patterninspring.chapter6.bankapp.service.TransferServiceImpl.*(..))</kbd>: Any void method in the <kbd>TransferServiceImpl</kbd> class, it is including any sub-class, but will be ignored if a different implementation is used.</li>
</ul>
</li>
</ul>
<ul>
<li>Restrict by interface:
<ul>
<li><kbd>execution(void com.packt.patterninspring.chapter6.bankapp.service.TransferService.transfer(*))</kbd>: Any void <kbd>transfer()</kbd> method taking one argument, in any object implementing <kbd>TransferService</kbd>, it is more flexible choice--works if implementation changes.</li>
</ul>
</li>
<li>Using Annotations
<ul>
<li><kbd>execution(@javax.annotation.security.RolesAllowed void transfer*(..))</kbd>: Any void method whose name starts with <kbd>transfer</kbd> that is annotated with the <kbd>@RolesAllowed</kbd> annotation.</li>
</ul>
</li>
<li>Working with packages
<ul>
<li><kbd>execution(* com..bankapp.*.*(..))</kbd>: There is one directory between <kbd>com</kbd> and <kbd>bankapp</kbd></li>
<li><kbd>execution(* com.*.bankapp.*.*(..))</kbd>: There may be several directories between <kbd>bankapp</kbd> and <kbd>com</kbd></li>
<li><kbd>execution(* *..bankapp.*.*(..))</kbd>: Any sub-package called <kbd>bankapp</kbd></li>
</ul>
</li>
</ul>
<p>Now that you have seen that the basics of writing pointcuts, let's see how to write the advice and declare the aspects that use those pointcuts</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Creating aspects</h1>
                </header>
            
            <article>
                
<p class="mce-root">As I said earlier, <em>aspects</em> is one of the most important terms in the AOP. Aspect merges the pointcuts and advices in the application. Let's see how to define aspect in the application.</p>
<p>You've already defined the <kbd>TransferService</kbd> interface as the subject of your aspect's pointcuts. Now let's use AspectJ annotations to create an aspect.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Define aspects using Annotation</h1>
                </header>
            
            <article>
                
<p>Suppose in your bank application, you want to generate log for a money transfer service for auditing and tracking to understand customers' behaviors. A business never succeeds without understanding its customers. Whenever you will think about it from the perspective of a business, an auditing is required but isn't central to the function of the business itself; it's a separate concern. Therefore, it makes sense to define the auditing as an aspect that's applied to a transfer service. Let's see the following code which shows the <kbd>Auditing</kbd> class that defines the aspects for this concern:</p>
<pre>    package com.packt.patterninspring.chapter6.bankapp.aspect; 
 
    import org.aspectj.lang.annotation.AfterReturning; 
    import org.aspectj.lang.annotation.AfterThrowing; 
    import org.aspectj.lang.annotation.Aspect; 
    import org.aspectj.lang.annotation.Before; 
 
    @Aspect 
    public class Auditing { 
 
      //Before transfer service 
      @Before("execution(* com.packt.patterninspring.chapter6.bankapp.<br/>      service.TransferService.transfer(..))")  
      public void validate(){ 
        System.out.println("bank validate your credentials before <br/>        amount transferring"); 
      } 
 
      //Before transfer service 
      @Before("execution(* com.packt.patterninspring.chapter6.bankapp.<br/>      service.TransferService.transfer(..))")  
      public void transferInstantiate(){ 
        System.out.println("bank instantiate your amount <br/>        transferring"); 
      } 
 
      //After transfer service 
      @AfterReturning("execution(* com.packt.patterninspring.chapter6.<br/>      bankapp.service.TransferService.transfer(..))") 
      public void success(){ 
        System.out.println("bank successfully transferred amount"); 
      } 
 
      //After failed transfer service 
      @AfterThrowing("execution(* com.packt.patterninspring.chapter6.<br/>      bankapp.service.TransferService.transfer(..))") 
      public void rollback() { 
        System.out.println("bank rolled back your transferred amount"); 
      } 
    } </pre>
<p>As you can see how the <kbd>Auditing</kbd> class is annotated with <kbd>@Aspect</kbd> annotation. It means this class is not just Spring bean, it is an aspect of the application. And <kbd>Auditing</kbd> class has some methods, these are advices and define some logic within these methods. As we know that before beginning to transfer amount from an account to another, bank will validate (<kbd>validate ()</kbd>) the use credentials and after that instantiate (<kbd>transferInstantiate()</kbd>) this service. After successful validation (<kbd>success ()</kbd>) amount is transferred and the bank audits it. But if the amount transferring fails in any case, then the bank should roll back (<kbd>rollback ()</kbd>) that amount.</p>
<p>As you can see, all methods of <kbd>Auditing</kbd> aspects are annotated with advice annotations to indicate when those methods should be called. Spring AOP provides five type advice annotations for defining advice. Let's see in the following table:</p>
<table class="table">
<tbody>
<tr>
<td>
<p><strong>Annotation</strong></p>
</td>
<td>
<p><strong>Advice</strong></p>
</td>
</tr>
<tr>
<td>
<p><kbd>@Before</kbd></p>
</td>
<td>
<p>It is used for before advice, <kbd>advice</kbd>'s method executes before the advised method is invoked.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>@After</kbd></p>
</td>
<td>
<p>It is used for after advice, advice's method execute after the advised method executes normally or abnormally doesn't matter.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>@AfterReturning</kbd></p>
</td>
<td>
<p>It used for after returning advice, advice's method execute after the advised method complete successfully.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>@AfterThrowing</kbd></p>
</td>
<td>
<p>It used for after throwing advice, advice's method execute after the method terminate abnormally by throwing an exception.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>@Around</kbd></p>
</td>
<td>
<p>It is used for around advice, advice's method executes before and after the advised method invoked.</p>
</td>
</tr>
</tbody>
</table>
<p> </p>
<p>Let's see the implementation of advices and how these work in the application.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Implementing Advice</h1>
                </header>
            
            <article>
                
<p>As you know that, Spring provides five types of advices, let's see work flow of one by one.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Advice type - Before</h1>
                </header>
            
            <article>
                
<p>Let's see the following figure for before advice. This advice executes the before the target method:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img height="215" width="329" class=" image-border" src="assets/2326ca56-3752-4323-8173-14d3d5077e09.png"/></div>
<p>As you can see in figure, before advice is executed first and then it calls the <strong>Target</strong> method. As we know that Spring AOP is proxy-based. So a <strong>Proxy</strong> object is created of target class. It is based on Proxy design pattern and Decorator Design Pattern.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Before Advice example</h1>
                </header>
            
            <article>
                
<p>Let's see the use of <kbd>@Before</kbd> annotation:</p>
<pre>    //Before transfer service 
    @Before("execution(* com.packt.patterninspring.chapter6.<br/>    bankapp.service.TransferService.transfer(..))")  
    public void validate(){ 
      System.out.println("bank validate your credentials before amount <br/>      transferring"); 
    } 
 
    //Before transfer service 
    @Before("execution(* com.packt.patterninspring.chapter6.<br/>    bankapp.service.TransferService.transfer(..))")  
    public void transferInstantiate(){ 
      System.out.println("bank instantiate your amount transferring"); 
    } </pre>
<div class="packt_infobox">Note--if the advice throws an exception, target will not be called--this is a valid use of a Before Advice.</div>
<p>Now you have seen the before advice, let's have a look into another type advice.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Advice Types: After Returning</h1>
                </header>
            
            <article>
                
<p>Let's see the following figure for after returning advice. This advice executes the after the <strong>Target</strong> method executed successfully:</p>
<div class="CDPAlignCenter CDPAlign"><img height="206" width="369" class=" image-border" src="assets/83caf5aa-cf58-49e4-a856-16798371089a.png"/></div>
<p>As you can see in figure, the after returning advice is executed after the target returns successfully. This advice will never execute if target throws any exception in the application.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">After Returning Advice example</h1>
                </header>
            
            <article>
                
<p>Let's see the use of the <kbd>@AfterReturning</kbd> annotation:</p>
<pre>    //After transfer service 
    @AfterReturning("execution(* com.packt.patterninspring.chapter6.<br/>    bankapp.service.TransferService.transfer(..))") 
    public void success(){ 
      System.out.println("bank successfully transferred amount"); 
    } </pre>
<p>Now you have seen the after returning advice, let's move to another type advice in the Spring AOP.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Advice Types: After Throwing</h1>
                </header>
            
            <article>
                
<p>Let's see the following figure for after throwing advice. This advice executes the after the target method terminated abnormally. It mean the <kbd>target</kbd> method throws any exception, then this advice will be executed. Please refer to the following diagram:</p>
<div class="CDPAlignCenter CDPAlign"><img height="217" width="353" class=" image-border" src="assets/aa71dc23-ee24-4fe2-9ff6-46379859a877.png"/></div>
<p>As you can see in figure, the after throwing advice is executed after the target throws an exception. This advice will never execute if the target doesn't throw any exception in the application.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">After Throwing Advice example</h1>
                </header>
            
            <article>
                
<p>Let's see the use of the <kbd>@AfterThrowing</kbd> annotation:</p>
<pre>    //After failed transfer service 
    @AfterThrowing("execution(* com.packt.patterninspring.chapter6.<br/>    bankapp.service.TransferService.transfer(..))") 
    public void rollback() { 
      System.out.println("bank rolled back your transferred amount"); 
    } </pre>
<p>You can also use the <kbd>@AfterThrowing</kbd> annotation with the throwing attribute, it only invokes advice if the right exception type is thrown:</p>
<pre>    //After failed transfer service 
    @AfterThrowing(value = "execution(*       <br/>    com.packt.patterninspring.chapter6.<br/>    bankapp.service.TransferService.transfer(..))", throwing="e")) 
    public void rollback(DataAccessException e) { 
      System.out.println("bank rolled back your transferred amount"); 
    } </pre>
<p>Execute every time a <kbd>TransferService</kbd> class throws an exception of type <kbd>DataAccessException</kbd>.</p>
<div class="packt_tip">The <kbd>@AfterThrowing</kbd> advice will not stop the exception from propagating. However, it can throw a different type of exception.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Advice Types: After</h1>
                </header>
            
            <article>
                
<p>Let's see the following figure for <strong>AfterAdvice</strong>. This advice executes after the <strong>Target</strong> method is terminated normally or abnormally. It doesn't matter that <strong>Target</strong> method throws any exception or executes without any exception:</p>
<div class="CDPAlignCenter CDPAlign"><img height="201" width="329" class=" image-border" src="assets/1b0871fc-98a6-47c9-93c3-cc2f3b299093.png"/></div>
<p>As you can see in figure, the after advice is executed after the <kbd>target</kbd> method terminates by throwing any exception or normally.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">After Advice example</h1>
                </header>
            
            <article>
                
<p>Let's see the use of <kbd>@After</kbd> annotation:</p>
<pre>    //After transfer service 
    @After ("execution(* com.packt.patterninspring.chapter6.<br/>    bankapp.service.TransferService.transfer(..))") 
    public void trackTransactionAttempt(){ 
      System.out.println("bank has attempted a transaction"); 
    } </pre>
<p>Use <kbd>@After</kbd> annotation called regardless of whether an exception has been thrown by the target or not.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Advice Types - Around</h1>
                </header>
            
            <article>
                
<p>Let's see the following figure for <strong>AroundAdvice</strong>. This advice executes both times before and after the <strong>Target</strong> method is invoked. This advice is very powerful advice of Spring AOP. Many features of the Spring Framework are implemented by using this advice. This is the only advice in Spring which has capability to stop or proceed the target method execution. Please refer to the following diagram:</p>
<div class="CDPAlignCenter CDPAlign"><img height="216" width="351" class=" image-border" src="assets/f85e8209-cdcc-4a3f-8bfa-9b7d79f40e51.png"/></div>
<p>As you can see in the preceding figure, <strong>AroundAdvice</strong> executed two times, first time it is executed before the advised method and second time it is executed after advised method is invoked. And also this advice calls the <kbd>proceed()</kbd> method to execute the advised method in the application. Let's see the following example:</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Around Advice example</h1>
                </header>
            
            <article>
                
<p>Let's see the use of the <kbd>@Around</kbd> annotation:</p>
<pre>    @Around(execution(*    com.packt.patterninspring.chapter6.<br/>    bankapp.service.TransferService.createCache(..))) 
    public Object cache(ProceedingJoinPoint point){ 
    Object value = cacheStore.get(CacheUtils.toKey(point)); 
    if (value == null) { 
      value = point.proceed(); 
      cacheStore.put(CacheUtils.toKey(point), value); 
    } 
    return value; 
   } </pre>
<p>Here I used <kbd>@Around</kbd> annotation and a <kbd>ProceedingJoinPoint</kbd>, it inherits from Join Point and adds the <kbd>proceed()</kbd> method. As you can see in this example, this advice proceeds to target only if value is not already in the cache.</p>
<p>You have seen how to implement the advice in the application using annotations and how to create aspect and how to define pointcuts by annotations. In this example, we are using Auditing as an aspect class and it is annotated with <kbd>@Aspect</kbd> annotation, but this annotation will not work if you don't enable AOP proxy behavior of the Spring.</p>
<p>Let's see the following Java configuration file, <kbd>AppConfig.java</kbd>, you can turn on auto-proxying by applying the <kbd>@EnableAspectJAutoProxy</kbd> annotation at the class level:</p>
<pre>    package com.packt.patterninspring.chapter6.bankapp.config; 
 
    import org.springframework.context.annotation.Bean; 
    import org.springframework.context.annotation.ComponentScan; 
    import org.springframework.context.annotation.Configuration; 
    import org.springframework.context.annotation.<br/>      EnableAspectJAutoProxy; 
 
    import com.packt.patterninspring.chapter6.bankapp.aspect.Auditing; 
 
    @Configuration 
    @EnableAspectJAutoProxy 
    @ComponentScan 
    public class AppConfig { 
      @Bean 
      public Auditing auditing() { 
         return new Auditing(); 
      } 
   } </pre>
<p>If you're using XML configuration, let's see how to wire your beans in Spring and how to enable Spring AOP feature by using the <kbd>&lt;aop:aspectj-autoproxy&gt;</kbd> element from Spring's AOP namespace:</p>
<pre>    &lt;?xml version="1.0" encoding="UTF-8"?&gt; 
    &lt;beans  
       
       
       
      xsi:schemaLocation="http://www.springframework.org/schema/aop 
      http://www.springframework.org/schema/aop/spring-aop.xsd 
      http://www.springframework.org/schema/beans 
      http://www.springframework.org/schema/beans/spring-beans.xsd 
      http://www.springframework.org/schema/context 
      http://www.springframework.org/schema/context/spring-<br/>      context.xsd"&gt; 
      &lt;context:component-scan base- <br/>      package="com.packt.patterninspring.chapter6.bankapp" /&gt; 
      &lt;aop:aspectj-autoproxy /&gt; 
      &lt;bean class="com.packt.patterninspring.chapter6.<br/>      bankapp.aspect.Auditing" /&gt; 
    &lt;/beans&gt; </pre>
<p>Let's see how you can declare aspects in a Spring XML configuration file.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Define aspects using XML configuration</h1>
                </header>
            
            <article>
                
<p>As we know that, we can configure beans in the XML based configuration, similarly you can declare aspects in the XML configuration. Spring provides another AOP namespace and it offers many elements that are used to declare aspects in XML, let's see in the following tables:</p>
<table class="table">
<tbody>
<tr>
<td>
<p><strong>Annotation</strong></p>
</td>
<td>
<p><strong>Parallel XML element</strong></p>
</td>
<td>
<p><strong>Purpose of XML element</strong></p>
</td>
</tr>
<tr>
<td>
<p><kbd>@Before</kbd></p>
</td>
<td>
<p><kbd>&lt;aop:before&gt;</kbd></p>
</td>
<td>
<p>It defines before advice.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>@After</kbd></p>
</td>
<td>
<p><kbd>&lt;aop:after&gt;</kbd></p>
</td>
<td>
<p>It defines after advice.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>@AfterReturning</kbd></p>
</td>
<td>
<p><kbd>&lt;aop:after-returning&gt;</kbd></p>
</td>
<td>
<p>It defines after returning advice.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>@AfterThrowing</kbd></p>
</td>
<td>
<p><kbd>&lt;aop:after-throwing&gt;</kbd></p>
</td>
<td>
<p>It defines after throwing advice.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>@Around</kbd></p>
</td>
<td>
<p><kbd>&lt;aop:around&gt;</kbd></p>
</td>
<td>
<p>It defines around advice.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>@Aspect</kbd></p>
</td>
<td>
<p><kbd>&lt;aop:aspect&gt;</kbd></p>
</td>
<td>
<p>It defines an aspect.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>@EnableAspectJAutoProxy</kbd></p>
</td>
<td>
<p><kbd>&lt;aop:aspectj-autoproxy&gt;</kbd></p>
</td>
<td>
<p>It enables annotation-driven aspects using <kbd>@AspectJ</kbd>.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>@Pointcut</kbd></p>
</td>
<td>
<p><kbd>&lt;aop:pointcut&gt;</kbd></p>
</td>
<td>
<p>It defines a pointcut.</p>
</td>
</tr>
<tr>
<td>
<p>--</p>
</td>
<td>
<p><kbd>&lt;aop:advisor&gt;</kbd></p>
</td>
<td>
<p>It define AOP adviser</p>
</td>
</tr>
<tr>
<td>
<p>--</p>
</td>
<td>
<p><kbd>&lt;aop:config&gt;</kbd></p>
</td>
<td>
<p>It is top level AOP element</p>
</td>
</tr>
</tbody>
</table>
<p>As you can see in the preceding table, a number of AOP namespace elements are parallel to the corresponding annotation available in the Java based configuration. Let's see the following same example in the XML based configuration, first have a look into the aspect class <kbd>Auditing</kbd>. Let's remove all of those AspectJ annotations as shown in following code:</p>
<pre>    package com.packt.patterninspring.chapter6.bankapp.aspect; 
 
    public class Auditing { 
      public void validate(){ 
        System.out.println("bank validate your credentials before <br/>        amount transferring"); 
      } 
      public void transferInstantiate(){ 
        System.out.println("bank instantiate your amount <br/>        transferring"); 
      } 
      public void success(){ 
        System.out.println("bank successfully transferred amount"); 
      } 
      public void rollback() { 
        System.out.println("bank rolled back your transferred amount"); 
      } 
    } </pre>
<p>As you can see the preceding code, now our aspect class doesn't indicate that it is an aspect class. It is a basic Java POJO class with some methods. Let's see in next section how to declare advices in XML configuration:</p>
<pre>    &lt;aop:config&gt; 
      &lt;aop:aspect ref="auditing"&gt; 
        &lt;aop:before pointcut="execution(*    <br/>        com.packt.patterninspring.chapter6.bankapp.<br/>        service.TransferService.transfer(..))"  
        method="validate"/&gt; 
        &lt;aop:before pointcut="execution(*  <br/>        com.packt.patterninspring.chapter6.bankapp.<br/>        service.TransferService.transfer(..))"  
        method="transferInstantiate"/&gt; 
        &lt;aop:after-returning pointcut="execution(*  <br/>        com.packt.patterninspring.chapter6.<br/>        bankapp.service.TransferService.transfer(..))"  
        method="success"/&gt; 
        &lt;aop:after-throwing pointcut="execution(*  <br/>        com.packt.patterninspring.chapter6.bankapp.<br/>        service.TransferService.transfer(..))"  
        method="rollback"/&gt; 
      &lt;/aop:aspect&gt; 
    &lt;/aop:config&gt; </pre>
<p>As you can see, <kbd>&lt;aop-config&gt;</kbd> is using a top level element. In <kbd>&lt;aop:config&gt;</kbd>, you declare other elements like <kbd>&lt;aop:aspect&gt;</kbd>, this element has <kbd>ref</kbd> attribute and it references to the POJO bean Auditing. It indicates that <kbd>Auditing</kbd> is an aspect class in the application. Now <kbd>&lt;aop-aspect&gt;</kbd> element has advices and pointcuts elements. All logics are same as we have defined in Java configuration.</p>
<p>Let's see in the next section how spring create AOP proxy.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Understanding AOP proxies</h1>
                </header>
            
            <article>
                
<p>As you know that, Spring AOP is proxy-based. It mean Spring creates the proxy to weave the aspect between the business logic that is, in <kbd>target</kbd> object. It is based on the Proxy and Decorator design pattern. Let's see <kbd>TransferServiceImpl</kbd> class as an implementation of <kbd>TransferService</kbd> interface:</p>
<pre>    package com.packt.patterninspring.chapter6.bankapp.service; 
    import org.springframework.stereotype.Service; 
    public class TransferServiceImpl implements TransferService { 
      @Override 
      public void transfer(String accountA, String accountB, Long <br/>      amount) { 
        System.out.println(amount+" Amount has been tranfered from <br/>        "+accountA+" to "+accountB); 
      } 
    } </pre>
<p>Caller invokes this service (<kbd>transfer()</kbd> method) directly by the object reference, let's see the following figure to illustrate more:</p>
<div class="CDPAlignCenter CDPAlign"><img height="159" width="130" class=" image-border" src="assets/32f326cc-3a54-42ad-8912-5e0b5346bb20.png"/></div>
<p>As you can see that caller could directly call the service and do the task assigned to it.</p>
<p>But you declare this <kbd>TransferService</kbd> as a target for the aspect. Since this is done, things change slightly. Now this class wrapped by proxy and client code actually doesn't call this service directly, it calls routed by this proxy. Let's see the following diagram.</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img height="188" width="301" class=" image-border" src="assets/0488bcb2-9014-4db0-b912-7f2e31556772.png"/></div>
<p>As you can see in the preceding diagram, Spring apply the AOP-proxy to the object in the following sequence:</p>
<ol>
<li>Spring creates a proxy weaving aspect and target.</li>
<li>Proxy also implements target interface, that is, <kbd>TransferServive</kbd> interface.</li>
<li>All calls for transfer service method <kbd>transfer()</kbd> routed through proxy interceptor.</li>
<li>Matching advice is executed.</li>
<li>Then <kbd>target</kbd> method is executed.</li>
</ol>
<p>As preceding list, is the flow when you call the method that has the proxy created by Spring.</p>
<p>You have seen in this chapter the Spring AOP Framework, it has actually implemented some part of the AspectJ Framework using proxy-based aspect weaving. I think, this gave good knowledge about Spring AOP.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>In this chapter, we have seen the Spring AOP Framework and used design patterns behind this module. AOP is a very powerful paradigm and it complements the Object oriented programming. <strong>Aspect-Oriented Programming</strong> (<strong>AOP</strong>) modularizes cross-cutting concerns such as Logging, Security and Transaction. An aspect is a Java class annotated with <kbd>@Aspect</kbd> annotation. It defines a module containing the crosscutting behavior. This module separates from the application's business logic. We can reuse it in our application with other business modules without making any changes.</p>
<p>In Spring AOP, behavior is implemented as an advice method. You have learned in Spring, there are five types as Before, AfterThrowing, AfterReturning, After and Around. Around advice is a very powerful advice, there are interesting features implemented by using Around advice. You've learned how to weave these advices using load time weaving.</p>
<p>You have seen how to declare Pointcuts in the Spring application and pointcuts select joinpoints where advice applies.</p>
<p>Now we'll move to the essential part and look at how spring works in the backend to connect with database and read data for the application. Starting in the next chapter, you'll see how to build applications using JDBC template in Spring.</p>


            </article>

            
        </section>
    </body></html>