["```java\nuser> (doseq [n (range 5)]\n    (println (str \"Line \" n)))\nLine 0\nLine 1\nLine 2\nLine 3\nLine 4\nnil\n```", "```java\n(doseq [n (range 5)]\n (when (odd? n)\n  (println (str \"Line \" n))))\n```", "```java\n(doseq [n (filter odd? (range 5))]\n    (println (str \"Line \" n)))\n```", "```java\nuser> (take 5 (repeat \"myself\"))\n(\"myself\" \"myself\" \"myself\" \"myself\" \"myself\")\n```", "```java\nuser> (zipmap [:score :hits :friends :level :energy :boost] (repeat 0))\n{:score 0, :hits 0, :friends 0, :level 0, :energy 0, :boost 0}\n```", "```java\nuser> (take 10 (repeatedly (partial rand-int 100)))\n(21 52 38 59 86 73 53 53 60 90)\n```", "```java\nuser> (repeatedly 10 (partial rand-int 100))\n(55 0 65 34 64 19 21 63 25 94)\n```", "```java\nuser> (defn savings [principal yearly-rate]\n    (let [monthly-rate (+ 1 (/ yearly-rate 12))]\n     (iterate (fn [p] (* p monthly-rate)) principal)))\n```", "```java\nuser> (take 13 (savings 1000 0.01))\n(1000\n 1000.8333333333333\n 1001.667361111111\n 1002.5020839120368\n 1003.3375023152968\n 1004.1736169005594\n 1005.0104282479765\n 1005.847936938183\n 1006.6861435522981\n 1007.5250486719249\n 1008.3646528791514\n 1009.2049567565506\n 1010.045960887181)\n```", "```java\n    (ns groceries)\n    ```", "```java\n    grocery_store.clj\n    3  (def grocery-articles [{:name \"Flour\"\n    4               :weight 1000   ; grams\n    5               :max-dimension 140 ; millimeters\n    6              }\n    7              {:name \"Bread\"\n    8              :weight 350\n    9              :max-dimension 250}\n    10             {:name \"Potatoes\"\n    11             :weight 2500\n    12             :max-dimension 340}\n    13             {:name \"Pepper\"\n    14             :weight 85\n    15             :max-dimension 90}\n    The full file is available at https://packt.live/35r3Xng.\n    ```", "```java\n    (defn article-stream [n] \n     (repeatedly n #(rand-nth grocery-articles)))\n    ```", "```java\n    groceries> (article-stream 12)\n    ({:name \"Olive oil\", :weight 400, :max-dimension 280}\n     {:name \"Potatoes\", :weight 2500, :max-dimension 340}\n     {:name \"Green beans\", :weight 300, :max-dimension 120}\n     {:name \"Potatoes\", :weight 2500, :max-dimension 340}\n     {:name \"Flour\", :weight 1000, :max-dimension 140}\n     {:name \"Ice cream\", :weight 450, :max-dimension 200}\n     {:name \"Potatoes\", :weight 2500, :max-dimension 340}\n     {:name \"Green beans\", :weight 300, :max-dimension 120}\n     {:name \"Potatoes\", :weight 2500, :max-dimension 340}\n     {:name \"Ice cream\", :weight 450, :max-dimension 200}\n     {:name \"Pepper\", :weight 85, :max-dimension 90}\n     {:name \"Bread\", :weight 350, :max-dimension 250})\n    ```", "```java\n    groceries> (article-stream 5)\n    ({:name \"Potatoes\", :weight 2500, :max-dimension 340}\n     {:name \"Green beans\", :weight 300, :max-dimension 120}\n     {:name \"Bread\", :weight 350, :max-dimension 250}\n     {:name \"Olive oil\", :weight 400, :max-dimension 280}\n     {:name \"Pepper\", :weight 85, :max-dimension 90})\n    ```", "```java\n    function randomArticles (groceryArticles, n) {\n     var articles = [];\n     for (var i = 0; i < n.length; i++) {\n      articles.push(\n      groceryArticles[Math.random(groceryArticles.length – 1)]\n      );\n     }\n     return articles;\n    }\n    ```", "```java\n(defn recursive-sum [so-far numbers]\n (if (first numbers)\n  (recursive-sum\n   (+ so-far (first numbers))\n   (next numbers))\n  so-far))\n```", "```java\nuser> (recursive-sum 0 [300 25 8])\n333\n```", "```java\nuser> (next '())\nnil\n```", "```java\n    (defn full-bag? [items]\n     (let [weight (apply + (map :weight items))\n        size (apply + (map :max-dimension items))]\n      (or (> weight 3200)\n        (> size 800))))\n    ```", "```java\n    groceries> (full-bag? (article-stream 10))\n    true\n    groceries> (full-bag? (article-stream 1))\n    false\n    groceries> (full-bag? (article-stream 1000))\n    true\n    groceries> (full-bag? '())\n    false\n    ```", "```java\n    (defn bag-sequences* [{:keys [current-bag bags] :as acc} stream]\n     ;; TODO: write code\n    )\n    (defn bag-sequences [stream]\n     (bag-sequences* {:bags []\n              :current-bag []} stream))\n    ```", "```java\n    (defn bag-sequences* [{:keys [current-bag bags] :as acc} stream]\n     (cond\n      (not stream)\n      (conj bags current-bag)\n      ;; TODO: the other cond branches\n      ))\n    ```", "```java\n    (defn bag-sequences* [{:keys [current-bag bags] :as acc} stream]\n     (cond\n      (not stream)\n      (conj bags current-bag)\n      (full-bag? (conj current-bag (first stream)))\n      (bag-sequences* (assoc acc\n                  :current-bag [(first stream)]\n                  :bags (conj bags current-bag))\n              (next stream))\n      ;; TODO: one more branch, for when the bag is not full yet\n      ))\n    ```", "```java\n    (defn bag-sequences* [{:keys [current-bag bags] :as acc} stream]\n     (cond\n      (not stream)\n      (conj bags current-bag)\n      (full-bag? (conj current-bag (first stream)))\n      (bag-sequences* (assoc acc\n                  :current-bag [(first stream)]\n                  :bags (conj bags current-bag))\n              (next stream))\n      :otherwise-bag-not-full\n      (bag-sequences* (update acc :current-bag conj (first stream))\n              (next stream))))\n    ```", "```java\n    groceries> (bag-sequences (article-stream 12))\n    [[{:name \"Pepper\", :weight 85, :max-dimension 90}\n     {:name \"Pepper\", :weight 85, :max-dimension 90}\n     {:name \"Green beans\", :weight 300, :max-dimension 120}\n     {:name \"Flour\", :weight 1000, :max-dimension 140}\n     {:name \"Olive oil\", :weight 400, :max-dimension 280}]\n     [{:name \"Bread\", :weight 350, :max-dimension 250}\n     {:name \"Pepper\", :weight 85, :max-dimension 90}\n     {:name \"Green beans\", :weight 300, :max-dimension 120}\n     {:name \"Olive oil\", :weight 400, :max-dimension 280}]\n      [{:name \"Potatoes\", :weight 2500, :max-dimension 340}\n     {:name \"Bread\", :weight 350, :max-dimension 250}]]\n    ```", "```java\npackt-clj.recursion> (def production-bags (bag-sequences (article-stream 10000)))\nExecution error (StackOverflowError) at packt-clj.recursion/article-stream$fn (recursion.clj:34).\nnull\n```", "```java\nuser> (defn tiny-stack [a b]\n    (* b (+ a b)))\n#'user/tiny-stack\nuser> (tiny-stack 4 7)\n77\n```", "```java\n(defn recursive-sum [so-far numbers]\n (if (first numbers)\n  (recursive-sum\n   (+ so-far (first numbers))\n   (next numbers))\n  so-far))\n```", "```java\nuser> (recursive-sum 0 (range 10000))\nExecution error (StackOverflowError) at user/recursive-sum (REPL:53).\nnull\n```", "```java\nuser> (defn safe-recursive-sum [so-far numbers]\n    (if (first numbers)\n     (recur\n      (+ so-far (first numbers))\n      (next numbers))\n     so-far))\n#'user/safe-recursive-sum\nuser> (safe-recursive-sum 0 (range 10000))\n49995000\n```", "```java\n    (defn robust-bag-sequences* [{:keys [current-bag bags] :as acc} stream]\n     (cond\n      (not stream)\n      (conj bags current-bag)\n      (full-bag? (conj current-bag (first stream)))\n      (recur (assoc acc\n             :current-bag [(first stream)]\n             :bags (conj bags current-bag))\n          (next stream))\n      :otherwise-bag-not-full\n      (recur (assoc acc :current-bag (conj current-bag (first stream)))\n          (next stream))))\n    ```", "```java\n    (defn robust-bag-sequences [stream]\n     (robust-bag-sequences* {:bags []\n                 :current-bag []} stream))\n    ```", "```java\n    groceries> (def bags (robust-bag-sequences (article-stream 1000000)))\n    #'packt-clj.recursion/bags\n    groceries> (count bags)\n    343091\n    groceries> (first bags)\n    [{:name \"Olive oil\", :weight 400, :max-dimension 280}\n     {:name \"Potatoes\", :weight 2500, :max-dimension 340}]\n    ```", "```java\n(def process identity)\n(defn grocery-verification [input-items]\n  (loop [remaining-items input-items\n        processed-items []]\n    (if (not (seq remaining-items))\n      processed-items\n      (recur (next remaining-items)\n        (conj processed-items (process (first remaining-items)))))))\n```", "```java\n    (defn looping-robust-bag-sequences [stream]\n     )\n    ```", "```java\n    (defn looping-robust-bag-sequences [stream]\n     (loop [remaining-stream stream\n         acc {:current-bag []\n           :bags []}]\n        ;;TODO: the real work\n      ))\n    ```", "```java\n     (defn looping-robust-bag-sequences [stream]\n     (loop [remaining-stream stream\n         acc {:current-bag []\n           :bags []}]\n      (let [{:keys [current-bag bags]} acc]\n       (cond (not remaining-stream)\n          (conj bags current-bag)\n          (full-bag? (conj current-bag (first remaining-stream)))\n          (recur (next remaining-stream)\n              (assoc acc\n                 :current-bag [(first remaining-stream)]\n                 :bags (conj bags current-bag)))\n          :otherwise-bag-not-full\n          (recur (next remaining-stream)\n              (assoc acc :current-bag (conj current-bag (first remaining-stream)))))))) \n    ```", "```java\n    groceries> (looping-robust-bag-sequences (article-stream 8))\n    [[{:name \"Bread\", :weight 350, :max-dimension 250}\n     {:name \"Potatoes\", :weight 2500, :max-dimension 340}]\n     [{:name \"Potatoes\", :weight 2500, :max-dimension 340}]\n     [{:name \"Potatoes\", :weight 2500, :max-dimension 340}\n     {:name \"Olive oil\", :weight 400, :max-dimension 280}]\n     [{:name \"Flour\", :weight 1000, :max-dimension 140}\n     {:name \"Green beans\", :weight 300, :max-dimension 120}\n     {:name \"Pepper\", :weight 85, :max-dimension 90}]]\n    ```", "```java\n(def nested [5 12 [3 48 16] [1 [53 8 [[4 43]] [8 19 3]] 29]])\n```", "```java\n(defn naive-tree-sum [so-far x]\n (cond (not x) so-far\n    (integer? (first x)) (recur (+ so-far (first x)) (next x))\n    ; TODO: more code\n    ))\n```", "```java\n(defn naive-tree-sum [so-far x]\n (cond (not x) so-far\n    (integer? (first x)) (recur (+ so-far (first x)) (next x))\n    (or (seq? (first x)) (vector? (first x)))\n    (recur (recur so-far (first x)) (next x)))) ;; Warning!!!\n```", "```java\n1\\. Caused by java.lang.UnsupportedOperationException\n  Can only recur from tail position\n```", "```java\nuser> (defn less-naive-tree-sum [so-far x]\n        (cond (not x) so-far\n          (integer? (first x)) (less-naive-tree-sum (+ so-far (first x)) (next x))\n          (or (seq? (first x)) (vector? (first x)))\n          (less-naive-tree-sum (less-naive-tree-sum so-far (first x)) (next x))))\n#'user/less-naive-tree-sum\nuser> (less-naive-tree-sum 0 nested)\n252\n```", "```java\ntrain_routes.clj\n1  (def routes\n2   [[:paris :london 236]\n3    [:paris :frankfurt 121]\n4    [:paris :milan 129]\n5    [:milan :rome 95]\n6    [:milan :barcelona 258]\n7    [:milan :vienna 79]\n8    [:barcelona :madrid 141]\n9    [:madrid :lisbon 127]\n10   [:madrid :paris 314]\nThe full code for this step is available at https://packt.live/2FpIjVM\n```", "```java\n{:paris {:london 236\n     :frankfurt 121\n     :milan 129\n     ;;...etc...\n     }\n :milan {:paris 129\n     :vienna 79\n     :rome 95\n     ;;...etc...\n     }}\n```", "```java\n    (defn grouped-routes\n     [routes]\n     (->> routes\n        (group-by first)))\n    ```", "```java\n    train-routes> (:paris (grouped-routes routes))\n    [[:paris :london 236]\n     [:paris :frankfurt 121]\n     [:paris :milan 129]\n     [:paris :amsterdam 139]]\n    ```", "```java\n    (defn route-list->distance-map [route-list]\n     (->> route-list\n        (map (fn [[_ city cost]] [city cost]))\n        (into {})))\n    ```", "```java\n    train-routes> (route-list->distance-map [[:paris :milan 129]\n                                            [:paris :frankfurt 121]])\n    {:milan 129, :frankfurt 121}\n    ```", "```java\n    (defn grouped-routes\n     [routes]\n     (->> routes\n        (group-by first)\n        (map (fn [[k v]] [k (route-list->distance-map v)]))\n        (into {})))\n    ```", "```java\n    train-routes> (:paris (grouped-routes routes))\n    {:london 236, :frankfurt 121, :milan 129, :amsterdam 139}\n    ```", "```java\n    (defn grouped-routes\n     [routes]\n     (->> routes\n        (mapcat (fn [[origin-city dest-city cost :as r]]\n             [r [dest-city origin-city cost]]))\n        (group-by first)\n        (map (fn [[k v]] [k (route-list->distance-map v)]))\n        (into {})))\n    ```", "```java\n    train-routes> (:paris (grouped-routes routes))\n    {:london 236,\n     :frankfurt 121,\n     :milan 129,\n     :madrid 314,\n     :geneva 123,\n     :amsterdam 139}\n    ```", "```java\n    train-routes> (def lookup (grouped-routes routes))\n    #'train-routes/lookup\n    ```", "```java\n    train-routes> (get-in lookup [:paris :madrid])\n    314\n    ```", "```java\n    train-routes> (get-in lookup [:madrid :paris])\n    314\n    ```", "```java\n    train-routes> (get-in lookup [:paris :bratislava])\n    nil\n    ```", "```java\n [:paris :london nil]\n [:paris :amsterdam :berlin]\n [:paris :frankfurt :berlin]\n [:paris :frankfurt :prague nil]\n```", "```java\n    (defn find-path* [route-lookup destination path]\n     ;; TODO: write code\n     )\n    (defn find-path [route-lookup origin destination]\n     ;; TODO: write code\n     )\n    ```", "```java\n    (defn find-path [route-lookup origin destination]\n      (find-path* route-lookup destination [origin]))\n    ```", "```java\n    (defn find-path* [route-lookup destination path]\n     (let [position (last path)]\n      (cond\n       (= position destination) path\n       (get-in route-lookup [position destination])\n       (conj path destination)\n       ;; TODO: still not there\n       )))\n    ```", "```java\n    {:paris {:frankfurt 121\n         :milan 129\n         ;; etc.\n         }\n     ;; etc.\n     }\n    ```", "```java\n    train-routes> (find-path* lookup :sevilla [:sevilla])\n    [:sevilla]\n    ```", "```java\n    train-routes> (find-path lookup :sevilla :sevilla)\n    [:sevilla]\n    ```", "```java\n    train-routes> (find-path* lookup :madrid [:sevilla])\n    [:sevilla :madrid]\n    ```", "```java\n    (defn find-path* [route-lookup destination path]\n     (let [position (last path)]\n      (cond\n       (= position destination) path\n       (get-in route-lookup [position destination])\n       (conj path destination)\n       :otherwise-we-search\n       (let [path-set (set path)\n          from-here (remove path-set (keys (get route-lookup position)))]\n        (when-not (empty? from-here)\n         (->> from-here\n            (map (fn [pos] (find-path* route-lookup destination (conj path pos))))\n            (remove empty?)))))))\n    ```", "```java\n    train-routes> (set [:amsterdam :paris :milan])\n    #{:paris :milan :amsterdam}\n    train-routes> ((set [:amsterdam :paris :milan]) :berlin)\n    nil\n    train-routes> ((set [:amsterdam :paris :milan]) :paris)\n    :paris\n    ```", "```java\n    (remove path-set (keys (get route-lookup position)))\n    ```", "```java\n    (map (fn [pos] (find-path* route-lookup destination (conj path pos))))\n    ```", "```java\n    train-routes> (:paris lookup)\n    {:london 236,\n     :frankfurt 121,\n     :milan 129,\n     :madrid 314,\n     :geneva 123,\n     :amsterdam 139}\n    ```", "```java\n     [:london :paris :frankfurt]\n     [:london :paris :milan]\n     [:london :paris :madrid]\n     [:london :paris :geneva]\n     [:london :paris :amsterdam]\n    ```", "```java\n    train-routes> (def small-routes (grouped-routes [[:paris :milan 100][:paris :geneva 100][:geneva :rome 100][:milan :rome 100]]))\n    #'train-routes/small-routes\n    train-routes> small-routes\n    {:paris {:milan 100, :geneva 100},\n     :milan {:paris 100, :rome 100},\n     :geneva {:paris 100, :rome 100},\n     :rome {:geneva 100, :milan 100}}\n    ```", "```java\n    train-routes> (find-path* small-routes :rome [:paris])\n    ([:paris :milan :rome] [:paris :geneva :rome])\n    ```", "```java\n    train-routes> (def more-routes (grouped-routes [[:paris :milan 100]\n                                                   [:paris :geneva 100]\n                                                   [:paris :barcelona 100]\n                                                   [:barcelona :milan 100]\n                                                   [:geneva :rome 100]\n                                                   [:milan :rome 100]]))\n    #'train-routes/more-routes\n    ```", "```java\n    train-routes> (find-path* more-routes :rome [:paris])\n    ([:paris :milan :rome]\n     [:paris :geneva :rome]\n     ([:paris :barcelona :milan :rome]))\n    ```", "```java\n    train-routes> (def even-more-routes (grouped-routes [[:paris :milan 100]\n                                                        [:paris :geneva 100]\n                                                         [:paris :barcelona 100]\n                                                         [:barcelona :madrid 100]\n                                                         [:madrid :milan 100]\n                                                         [:barcelona :milan 100]\n                                                         [:geneva :rome 100]\n                                                         [:milan :rome 100]]))\n    #'train-routes/even-more-routes\n    train-routes> (find-path* even-more-routes :rome [:paris])\n    ([:paris :milan :rome]\n     [:paris :geneva :rome]\n     (([:paris :barcelona :madrid :milan :rome])\n     [:paris :barcelona :milan :rome]))\n    ```", "```java\n    (defn find-path* [route-lookup destination path]\n     (let [position (last path)]\n      (cond\n       (= position destination) path\n       (get-in route-lookup [position destination])\n       (conj path destination)\n       :otherwise-we-search\n       (let [path-set (set path)\n          from-here (remove path-set (keys (get route-lookup position)))]\n        (when-not (empty? from-here)\n         (->> from-here\n            (map (fn [pos] (find-path* route-lookup destination (conj path pos))))\n            (remove empty?)\n            (mapcat (fn [x] (if (keyword? (first x))\n                     [x]\n                     x)))))))))\n    ```", "```java\n    train-routes> (find-path* even-more-routes :rome [:paris])\n    ([:paris :milan :rome]\n     [:paris :geneva :rome]\n     [:paris :barcelona :madrid :milan :rome]\n     [:paris :barcelona :milan :rome])\n    ```", "```java\n    train-routes> (find-path* lookup :rome [:paris])\n    ([:paris :frankfurt :milan :rome]\n     [:paris :frankfurt :berlin :warsaw :prague :vienna :milan :rome]\n     [:paris :frankfurt :berlin :warsaw :prague :bratislava :vienna :milan :rome]\n     [:paris :frankfurt :berlin :warsaw :prague :budapest :vienna :milan :rome]\n     [:paris :frankfurt :geneva :milan :rome]\n     [:paris :frankfurt :prague :vienna :milan :rome]\n     [:paris :frankfurt :prague :bratislava :vienna :milan :rome]\n     [:paris :frankfurt :prague :budapest :vienna :milan :rome]\n     ;; etc. )\n    ```", "```java\n    (defn cost-of-route\n     [route-lookup route]\n     (apply +\n         (map (fn [start end]\n            (get-in route-lookup [start end]))\n           route\n           (next route))))\n    ```", "```java\n    train-routes> (cost-of-route lookup [:london :paris :amsterdam :berlin :warsaw])\n    603\n    ```", "```java\n    train-routes> (cost-of-route lookup [:london])\n    0\n    ```", "```java\n    (defn min-route [route-lookup routes]\n     (reduce (fn [current-best route]\n          (let [cost (cost-of-route route-lookup route)]\n           (if (or (< cost (:cost current-best))\n               (= 0 (:cost current-best)))\n              {:cost cost :best route}\n            current-best)))\n         {:cost 0 :best [(ffirst routes)]}\n         routes))\n    ```", "```java\n    (defn find-path [route-lookup origin destination]\n      (min-route route-lookup (find-path* route-lookup destination [origin])))\n    ```", "```java\n    train-routes> (find-path lookup :paris :rome)\n    {:cost 224, :best [:paris :milan :rome]}\n    train-routes> (find-path lookup :paris :berlin)\n    {:cost 291, :best [:paris :frankfurt :berlin]}\n    train-routes> (find-path lookup :warsaw :sevilla)\n    {:cost 720,\n     :best [:warsaw :prague :vienna :milan :barcelona :sevilla]}\n    ```", "```java\n<p>A short paragraph.</p>\n```", "```java\n    <input type=\"checkbox\" checked>\n    ```", "```java\n<div>Soon a paragraph <p>will start</div>, then end too late.</p>\n```", "```java\n[:p \"This paragraph is just an \"\n [:a {:href \"http://example.com\"} \"example\"] \".\"]\n```", "```java\n<p>This paragraph is just an <a href=\"http://example.com\">example</a>.</p>\n```"]