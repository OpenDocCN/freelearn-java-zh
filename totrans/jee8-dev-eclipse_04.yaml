- en: Unit Testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the last chapter, we learned how to create a web application that uses a
    database. In this chapter, we will learn how to write and execute unit tests in
    Eclipse for JEE applications. We will cover the following topics in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating and executing unit tests using Eclipse JEE
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Executing unit tests from Eclipse IDE
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mocking external dependencies for unit tests
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Calculating unit test coverage
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing the software that you develop is a very important part of the overall
    software development cycle. There are many types of testing; each one has a specific
    purpose, and each one varies in scope. Some examples of testing are functional
    testing, integration testing, scenario testing, and unit testing.
  prefs: []
  type: TYPE_NORMAL
- en: 'Of all these types, unit tests are the narrowest in scope and are typically
    coded and executed by developers. Each unit test is meant to test a specific and
    small piece of functionality (typically, a method in a class), and is expected
    to execute without any external dependencies. Here are some of the reasons why
    you should write efficient unit tests:'
  prefs: []
  type: TYPE_NORMAL
- en: To catch bugs early. If you find a bug in functional or integration testing,
    which have a much wider scope of testing, then it might be difficult to isolate
    the code that caused the bug. It is much easier to catch and fix bugs in unit
    testing, because unit tests, by definition, work in a narrower scope, and if a
    test fails, you will find out exactly where to go to fix the issue.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unit tests can help you catch any regression that you might have introduced
    when editing the code. There are good tools and libraries available for automating
    the execution of unit tests. For example, using build tools such as Ant and Maven,
    you can execute unit tests at the end of a successful build, so that you will
    immediately find out if the changes you have made have broken any previously working
    code.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As mentioned previously, writing unit tests and executing them is typically
    the responsibility of the developer. Therefore, most IDEs have good built-in support
    for writing and executing unit tests. Eclipse JEE is no exception. It has built-in
    support for JUnit, which is a popular unit testing framework for Java.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will see how to write and execute JUnit tests for the *Course
    Management* web application that we built in [Chapter 4](part0073.html#25JP20-d43a3a5ee6dd4ebc9d7c7e1cc8d7df55),
    *Creating JEE Database Applications*. However, first, here is a quick introduction
    to JUnit.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing JUnit
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: JUnit test classes are Java classes separate from the classes you want to test.
    Each test class can contain many test cases, which are just methods marked to
    be executed when JUnit tests are executed. A test suite is a collection of test
    classes.
  prefs: []
  type: TYPE_NORMAL
- en: The convention is to assign the test class the same name as that of the class
    you want to test, and append `Test` to that name. For example, if you wanted to
    test the `Course` class from the previous chapter, then you would create a JUnit
    test class and name it `CourseTest`. Test case (method) names start with `test`,
    followed by the name of the method in the class that you want to test; for example,
    if you wanted to test the `validate` method in the `Course` class, then you would
    create the `testValidate` method in the `CourseTest` class. Test classes are also
    created in the same package as the package in which the classes to be tested are
    present. In Maven projects, test classes are typically created under the `src/test/java`
    folder. The convention is to create the same package structure in the `test` folder
    as in the `src/main/java` folder.
  prefs: []
  type: TYPE_NORMAL
- en: 'JUnit supports annotations to mark unit tests and test suites. Here is a simple
    test case for the `Course` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Let's assume that the `validate` method checks that the course `name` is not
    null and that `credits` is greater than zero.
  prefs: []
  type: TYPE_NORMAL
- en: The preceding test case is marked with the `@Test` annotation. It creates an
    instance of the `Course` class, and then calls the `Assert.assertFalse` method
    to make sure that the `validate` method returns `false`, because `name` and `credits`
    are not set, and they will have their default values, which are `null` and `0`,
    respectively. `Assert` is a class provided by the JUnit library, and has many
    assert methods to test many conditions (see [http://junit.sourceforge.net/javadoc/org/junit/Assert.html](http://junit.sourceforge.net/javadoc/org/junit/Assert.html)
    for more information).
  prefs: []
  type: TYPE_NORMAL
- en: The test case, then, only sets the name, and does the same validation again,
    expecting the `validate` method to return `false`, because the credits are still
    zero. Finally, the test case sets both the name and credits, and calls the `Assert.assertTrue`
    method to ensure that `course.validate()` returns `true`. If any of the assertions
    fail, then the test case fails.
  prefs: []
  type: TYPE_NORMAL
- en: 'Other than `@Test`, you can use the following annotations provided by JUnit:'
  prefs: []
  type: TYPE_NORMAL
- en: '`@Before` and `@After`: Methods annotated with these annotations are executed
    before and after each test. You may want to initialize resources in `@Before`
    and free them in `@After`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@BeforeClass` and `@AfterClass`: Similar to `@Before` and `@After`, but instead
    of being called per test, these methods are called once per test class. A method
    with the `@BeforeClass` annotation is called before any of the test cases in that
    class are executed, and one with `@AfterClass` is called after all the test cases
    are executed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can find more annotations for JUnit at [https://junit.org/junit4/javadoc/latest/org/junit/package-summary.html](https://junit.org/junit4/javadoc/latest/org/junit/package-summary.html).
  prefs: []
  type: TYPE_NORMAL
- en: Creating and executing unit tests using Eclipse JEE
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To understand how to write unit tests, let''s take the JDBC version of the
    *Course Management* application that we developed in [Chapter 4](part0073.html#25JP20-d43a3a5ee6dd4ebc9d7c7e1cc8d7df55),
    *Creating JEE Database Applications*. Let''s start with a simple test case for
    validating a course. The following is the source code of `Course.java`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Creating unit test cases
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Maven projects follow certain conventions; the entire application source in
    a Maven project is in the `src/main/java` folder, and unit tests are expected
    to be in the `src/test/java` folder. In fact, when you create a Maven project
    in Eclipse, it creates the `src/test/java` folder for you. We are going to create
    our test cases in this folder. We are going to create the same package structure
    for the test classes as that for the application source; that is, to test the `packt.book.jee.eclipse.ch5.bean.Course`
    class, we will create the `packt.book.jee.eclipse.ch5.bean` package under the `src/test/java`
    folder and then create a JUnit test class called `CourseTest`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Right-click on the `src/test/java` folder in Package Explorer in Eclipse and
    select New | JUnit Test Case (if you do not find this option in the menu, select
    New | Other, and type `junit` into the Filter textbox. Then, select the JUnit
    Test Case option).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Enter the package name as `packt.book.jee.eclipse.ch5.bean` and the class name
    as `CourseTest`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the Browse... button next to the Class under test textbox. Type `course`
    into the Filter textbox and select the `Course` class:![](img/00127.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 5.1: JUnit test case wizard'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Click Next. The page shows methods in the class (`Course`) for which we want
    to create the test cases. Select the methods that you want to create test cases
    for.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We don''t want to test getters and setters because they are simple methods
    and don''t do much other than just getting or setting member variables. Presently,
    we will create a test case for only one method: `isValidTestCase`. Select the
    checkbox for this method:![](img/00128.jpeg)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 5.2: Select methods for test cases'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Click Finish. Eclipse checks whether JUnit libraries are included in your project,
    and if not, prompts you to include them:![](img/00129.jpeg)
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 5.3: Include JUnit libraries in project'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Click OK. Eclipse creates the package and the test class with one method/test
    case called `testIsValidCourse`. Note that the method is annotated with `@Test`,
    indicating that it is a JUnit test case.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'How do we test whether `isValidCourse` works as expected? We create an instance
    of the `Course` class, set some values that we know are valid/invalid, call the `isValidateCourse`
    method, and compare the results with the expected results. JUnit provides many
    methods in the `Assert` class to compare the actual results obtained by calling
    test methods with the expected results. So, let''s add the test code to the `testIsValidCourse`
    method:'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: We first create an instance of the `Course` class, and without setting any of
    its values, call the `isValidCourse` method. We know that it is not a valid course
    because the name and credits are the required fields in a valid course. So, we
    check whether the returned value of `isValidCourse` is false by calling the `Assert.assertFalse`
    method. We then set the name and check again, expecting the instance to be an
    invalid course. Then, we set a `0` credits value for `Course`, and, finally, we
    set `4` credits for `Course`. Now, `isValidCourse` is expected to return `true`
    because both the name and credits are valid. We verify this by calling `Assert.assertTrue`.
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Running unit test cases
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s run this test case in Eclipse. Right-click on the file, or anywhere
    in the project in Package Explorer, and select the Run As | JUnit Test menu. Eclipse
    finds all unit tests in the project, executes them, and shows the results in the
    JUnit view:'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '![](img/00130.jpeg)'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_IMG
- en: 'Figure 5.4: JUnit results view'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: This view shows a summary of the test cases run. In this case, it has run one
    test case, which was successful. The green bar shows that all test cases were
    executed successfully.
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now, let''s add one more check into the method:'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, run the test case again:'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '![](img/00131.jpeg)'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_IMG
- en: 'Figure 5.5: JUnit results view showing the failed test'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The test case failed because `course.isValidCourse()` returned `true` when
    the course name was set to an empty string, while the test case expected the instance
    to be an invalid course. So, we need to modify the `isValidCourse` method of the `Course`
    class to fix this failure:'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: We have added the condition to check the length of the `name` field. This should
    fix the test case failure. You can run the test case again to verify.
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Running unit test cases using Maven
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_H1
  type: TYPE_NORMAL
- en: You can run unit test cases using Maven, too. In fact, the install target of
    Maven also runs unit tests. However, it is possible to run only unit tests. To
    do this, right-click on the project in Package Explorer and select Run As | Maven test.
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'You might see the following error in the console:'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: 'The reason for this error is that we haven''t added a dependency on JUnit for
    our Maven project. Add the following dependency in `pom.xml`:'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: Refer to the *Using Maven for project management* section in [Chapter 2](part0037.html#1394Q0-d43a3a5ee6dd4ebc9d7c7e1cc8d7df55),
    *Creating a Simple JEE Web Application*, to learn how to add dependencies to a
    Maven project.
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Run the Maven test again; this time, the test should pass.
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Mocking external dependencies for unit tests
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_H1
  type: TYPE_NORMAL
- en: Unit tests are meant to execute without any external dependencies. We can certainly
    write methods at a granular level, such that the core business logic methods are
    totally separate from methods that have external dependencies. However, sometimes
    this is not practical, and we may have to write unit tests for code that are closely
    dependent on methods that access external systems.
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'For example, let''s assume that we have to add a method in our `Course` bean
    to add students to the course. We will also mandate that the course has an upper
    limit on the number of students that it can enroll, and once this limit is reached,
    no more students can be enrolled. Let''s add the following method to our `Course`
    bean:'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: The `addStudent` method first finds the current enrollment in the course. For
    this, it queries the database using the `CourseDAO` class. It then checks whether
    the current enrollment is less than the maximum enrollment. Then, it calls the `enrollStudentInCourse`
    method of `CourseDAO`.
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The `addStudent` method has an external dependency. It depends on successful
    access to an external database. We can write a unit test for this function as
    follows:'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: The `testAddStudent` method is meant to check whether  `addStudent` method works
    fine when all external dependencies are satisfied; in this case, it means that
    a database connection is established, the database server is up and running, and
    the tables are configured properly. If we want to verify that the functionality
    to enroll a student on a course works by taking into account all dependencies,
    then we should write a functional test. Unit tests only need to check whether
    code that does not depend on external dependencies works fine; in this case, it
    is a trivial check to verify that the total enrollment is less than the maximum
    allowed enrollment. This is a simple example, but in real applications you might
    have a lot more complex code to test.
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: The problem with the previous unit test is that we may have false failures,
    from the perspective of unit testing, because the database could be down or might
    not be configured correctly. One solution is to mock external dependencies; we
    can mock calls to the database (in this case, calls to `CourseDAO`). Instead of
    making real calls to the database, we can create stubs that will return some mock
    data or perform a mock operation. For example, we can write a mock function that
    returns some hardcoded value for the `getNumStudentsInCourse` method of `CourseDAO`.
    However, we don't want to modify the application source code to add mock methods.
    Fortunately, there are open source frameworks that let us mock dependencies in
    unit tests. Next, we will see how to mock dependencies using a popular framework
    called Mockito ([http://mockito.org/](http://mockito.org/)).
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Using Mockito
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_H1
  type: TYPE_NORMAL
- en: 'At a very high level, we can use Mockito to do two things:'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Provide wrapper implementations over dependent methods in the application class
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Verify that these wrapper implementations are called
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We specify the wrapper implementation using a static method of Mockito:'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: 'Further, we verify whether the wrapper method was called by calling another
    static method of Mockito:'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: 'To use Mockito in our project, we need to add a dependency on it in our `pom.xml`:'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: 'Before we start writing a unit test case using Mockito, we will make a small
    change in the `Course` class. Currently, `CourseDAO` in the `Course` class is
    private and there are no setters for it. Add the setter method (`setCourseDAO`)
    in the `Course` class:'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: Now, let's rewrite our test case using Mockito.
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'First, we need to tell Mockito which method calls we want to mock and what
    action should be taken in the mocked function (for example, return a specific
    value). In our example, we would like to mock the methods in `CourseDAO` that
    are called from the `Course.addStudent` method, because methods in `CourseDAO`
    access the database, and we want our unit tests to be independent of the data
    access code. Therefore, we create a mocked (wrapper) instance of `CourseDAO` using
    Mockito:'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, we tell Mockito which specific methods in this object to mock. We want
    to mock `getNumStudentsInCourse` and `getNumStudentsInCourse`as follows:'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: The code is in a `try...catch` block because the `getNumStudentsInCourse` and
    `getNumStudentsInCourse` methods throw `SQLException`. This will not happen when
    we mock the method because the mocked method will not call any SQL code. However,
    since the signature of these methods indicates that `SQLException` can be thrown
    from these methods, we have to call them in `try...catch` to avoid compiler errors.
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: The first statement in the `try` block tells Mockito that when the `getNumStudentsInCourse`
    method is called on the `courseDAO` object with the parameter `1` (course ID),
    it should return `60` from the mocked method.
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: The second statement tells Mockito that when `enrollStudentInCourse` is called
    on the `courseDAO` object with the arguments `1` (course ID) and `1` (student
    ID), it should do nothing. We don't really want to insert any record into the
    database from the unit test code.
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'We will now create the `Course` and `Student` objects and call the `addStudent`
    method of `Course`. This code is similar to the one we wrote in the preceding
    test case:'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: Note that the course ID and student ID that we used when creating the `Course`
    and `Student` objects, respectively, should match the arguments we passed to `getNumStudentsInCourse`
    and `enrollStudentInCourse` when mocking the methods.
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: We have set that the maximum number of students to be allowed in this course
    to `60`. When mocking `getNumStudentsInCourse`, we asked Mockito to also return
    `60`. Therefore, the `addStudent` method should throw an exception because the
    course is full. We will verify this by adding the `@Test` annotation later.
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'At the end of the test, we want to verify that the mocked method was actually
    called:'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: The preceding code verifies that `getNumStudentsInCourse` of `courseDAO` was
    called at least once by Mockito, when running this test.
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Here is the complete test case, including the `@Test` annotation attribute,
    to make sure that the function throws an exception:'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: Now, run the unit tests. All tests should pass.
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Here is a similar test case that makes Mockito return the current enrollment
    number of `59`, and makes sure that the student is enrolled successfully:'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: Note that this test case does not expect any exceptions to be thrown (if an
    exception is thrown, then the test case fails). We can also verify that the mocked
    `enrollStudentInCourse` method is called. We did not verify this in the previous
    test case because an exception was thrown before calling this method in the `Course.addStudent`
    method.
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'There are many topics of JUnit that we have not covered in this section. You
    are encouraged to read the JUnit documentation at [https://github.com/junit-team/junit4/wiki](https://github.com/junit-team/junit4/wiki).
    In particular, the following topics might be of interest to you:'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: JUnit test suites. You can aggregate test cases from different test classes
    in a suite. Find more information about test suites at [https://github.com/junit-team/junit4/wiki/Aggregating-tests-in-suites](https://github.com/junit-team/junit4/wiki/Aggregating-tests-in-suites).
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Parameterized test cases; find information at [https://github.com/junit-team/junit4/wiki/Parameterized-tests](https://github.com/junit-team/junit4/wiki/Parameterized-tests).
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: If you are using Apache Ant for building your project, then take a look at the
    JUnit Ant task at [https://ant.apache.org/manual/Tasks/junit.html](https://ant.apache.org/manual/Tasks/junit.html).
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Calculating unit test coverage
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Unit tests tell you whether your application code behaves as expected. Unit
    tests are important to maintain code quality and catch errors early in the development
    cycle. However, this goal is at risk if you do not write enough unit tests to
    test your application code, or if you have not tested all possible input conditions
    in the test cases and the exception paths. To measure the quality and adequacy
    of your test cases, you need to calculate the coverage of your test cases. In
    simple terms, coverage tells you what percentage of your application code was
    touched by running your unit tests. There are different measures to calculate
    coverage:'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Number of lines covered
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Number of branches covered (created using the `if`, `else`, `elseif`, `switch`,
    and `try`/`catch` statements)
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Number of functions covered
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Together, these three measures give a fair measurement of the quality of your
    unit tests. There are many code coverage tools for Java. In this chapter, we will
    take a look at an open source code coverage tool called JaCoCo ([http://www.eclemma.org/jacoco/](http://www.eclemma.org/jacoco/)).
    JaCoCo also has an Eclipse plugin ([http://www.eclemma.org/](http://www.eclemma.org/)),
    and we can measure code coverage from right within Eclipse.
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'You can install the JaCoCo plugin using the update URL ([http://update.eclemma.org/](http://update.eclemma.org/))
    or from Eclipse Marketplace. To install it using the update site, select the Help
    | Install New Software... menu. Click on the Add button and enter the name of
    the update site (you can give any name) and the update URL:'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '![](img/00132.jpeg)'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_IMG
- en: 'Figure 5.6: Add an update site for JaCoCo'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Then, follow the instructions to install the plugin.
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Alternatively, you can install it from the marketplace. Select the Help | Eclipse
    Marketplace... menu. Type `EclEmma` into the Find textbox, and click the Go button:'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '![](img/00133.jpeg)'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_IMG
- en: 'Figure 5.7: Install EclEmma code coverage plugin from Eclipse Marketplace'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Click the Install button and follow the instructions.
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: To verify that the plugin is installed properly, open Window | Show View | Other.
    Type `coverage` into the Filter textbox and make sure that the Coverage (under
    the Java category) view is available. Open the view.
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'To run a unit test with coverage, right-click on the project in Package Explorer
    and select Coverage As | JUnit Test. After the tests have run, the coverage information
    is displayed in the Coverage view:'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '![](img/00134.jpeg)'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_IMG
- en: 'Figure 5.8: Coverage results'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: How can you interpret these results? Overall, at the project level the coverage
    is 24.2%. This means that out of all the code that we have written in this application,
    our unit test case has touched only 24.2%. Then, there is the coverage percentage
    at the package level and at the class level.
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Double-click on `Course.java` in the Coverage view to see which lines are covered
    in this file. The following screenshot shows a part of the file where the red
    lines indicate the code that is not covered, and the green lines indicate the
    code that is covered:'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '![](img/00135.jpeg)'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_IMG
- en: 'Figure 5.9: Line coverage details'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: We have written unit tests for `addStudent`, and the coverage of this class
    is 100%, which is good. We haven't used all getters and setters in our unit tests,
    so some of them are not covered.
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: As you can see, the coverage results help you understand places in your code
    for which unit tests are not written, or which are partially covered by the unit
    tests. Based on this data, you can add unit tests for the code that is not covered.
    Of course, you may not want all lines to be covered if the code is very simple,
    such as the getters and setters in the preceding class, if the code is very simple.
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'In *Figure 5.8*, observe that the coverage tool has analyzed the test classes
    too. Typically, we don''t want to measure coverage on test classes; we want to
    measure the coverage of the application code by running the test classes. To exclude
    the test classes from this analysis, right-click on the project and select Coverage
    As | Coverage Configurations.... Click on the Coverage tab and select only CourseManagementJDBC
    - src/main/java:'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '![](img/00136.jpeg)'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_IMG
- en: 'Figure 5.10: Coverage configurations'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Click Coverage to run coverage with the new settings. You will see in the Coverage
    view that the test classes do not appear in the report, and that the overall test
    coverage on the project has also dropped.
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: If you want to run coverage using Maven, then refer to [http://www.eclemma.org/jacoco/trunk/doc/maven.html](http://www.eclemma.org/jacoco/trunk/doc/maven.html).
    Specifically, take a look at `pom.xml` ([http://jacoco.org/jacoco/trunk/doc/examples/build/pom-it.xml](http://jacoco.org/jacoco/trunk/doc/examples/build/pom-it.xml)),
    which creates reports for JUnit and JaCoCo coverage.
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_H1
  type: TYPE_NORMAL
- en: Writing unit tests is an important part of the application development process.
    Unit tests help you catch bugs in your application at very early stages; they
    also help you catch any regression because of subsequent code changes. JUnit and
    Eclipse provide an easy way to integrate unit tests into your development workflow.
    Eclipse also creates a nice report in the JUnit view, which makes it easy to identify
    the failed tests and jump to the line in the code where the test failed.
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Unit tests are meant to be executed without any external dependencies. Libraries
    such as Mockito help you to mock any external dependencies.
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Use coverage tools such as JaCoCo to find out the quality of the unit tests
    that you have written. Coverage tools tell you the percentage of the application
    code that is covered by your unit tests. You can also see in each class which
    lines are covered by your unit tests and which are not. Such a report can help
    you to decide whether you need to write more unit test cases or modify the existing
    unit test cases to cover important code that your unit tests have not tested.
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: In the next chapter, we will see how to debug Java applications from Eclipse.
    The chapter will also explain how to connect to a remote JEE server for debugging.
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
