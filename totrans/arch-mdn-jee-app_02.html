<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Designing and Structuring Java Enterprise Applications</h1>
                </header>
            
            <article>
                
<p>Every piece of software is designed in a certain way. The design includes the architecture of the system, structure of the projects, and structure and quality of the code. It can either communicate the intentions well or obfuscate them. Engineers need to design an enterprise application or system, b<span>efore it is implemented</span>. In order to do that, the purpose and motivations of the software need to be clear.</p>
<p>This chapter will cover:</p>
<ul>
<li>What aspects to focus on when developing software</li>
<li>Project build structures and Java EE build systems</li>
<li>How to structure enterprise projects modules</li>
<li>How to realize module package structures</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The purpose of enterprise applications</h1>
                </header>
            
            <article>
                
<p>Behind every action, be it in daily life, big organizations, or software projects, there should be a reason. We humans need reasons why we are doing things. In enterprise software development, there is no difference.</p>
<p>When we build software applications, the first question asked should be <em>why?</em>. Why is this piece of software needed? Why is it reasonable or required to spend time and effort to develop a solution? And why should the company care about developing that solution itself?</p>
<p>In other words, what is the application's purpose? What problem is this piece of software trying to solve? Do we want the application to implement an important business process? Will it generate revenue? Is it going to gather revenue directly, for example by selling products, or indirectly by marketing, supporting customers, or business processes? Are there other possibilities to support customers, employees, or business processes?</p>
<p>These and other questions target the application's business goals. Generally speaking, every piece of software needs a justification in the overall picture before we invest time and effort into it.</p>
<p>The most obvious legitimization is to implement necessary business use cases. These use cases bring certain value for the overall business and will sooner or later realize features and generate revenue. At the end of the day, the software should achieve the goal of implementing the business use cases as best as possible.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">What developers should focus on</h1>
                </header>
            
            <article>
                
<p>Therefore, software developers as well as project managers should first focus on meeting the business concerns and implementing the use cases.</p>
<p>This clearly sounds obvious, but too often the focus of enterprise projects starts drifting away into other concerns. Developer effort is spent on implementation details or features that have little benefit for solving the actual problem. How many logging implementations, home-grown enterprise frameworks, or over-engineered levels of abstractions have we seen in the past?</p>
<p>Non-functional requirements, quality of software, and so-called cross-cutting concerns are in fact an important aspect of software development. But the first and main focus of all engineering effort should be directed to meeting the business requirements and developing software that actually has a purpose.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Meeting customer's demands</h1>
                </header>
            
            <article>
                
<p>We have the following questions:</p>
<ul>
<li>What is the application's business purpose?</li>
<li>What are the most important features that users care about?</li>
<li>Which aspects will generate revenue?</li>
</ul>
<p>The answers to these questions should be known to the stakeholders. If not, then the correct way would be to take a step back, look at the overall picture of the software landscape, and reconsider the software's right to exist. Not in all cases the motivation will be purely business-driven. There are, in fact, a lot of cases where we will implement solutions that do not directly generate revenue but do so indirectly, by supporting others. These cases are certainly necessary and we will cover them and the general topic of how to construct reasonable system landscapes in <a href="">Chapter 8</a>, <em>Microservices and System Architecture</em>.</p>
<p>Besides these supporting software systems, we focus on business aspects. Having this main goal in mind, the first thing to address is how to model the business use cases and transform them into software. Only after that, the use cases are implemented using certain technologies.</p>
<p>These priorities will also reflect the customer demands. The application's stakeholders care about software that fulfills its purpose.</p>
<p>Software engineers tend to see this differently. They care about implementation details and the elegance of solutions. Engineers are often passionate about certain technologies and spend much time and effort choosing the right solutions as well as implementing them well. This includes a lot of technical cross-cutting concerns, such as logging, and so-called over-engineering, which is not mandatory for the business domain. Embracing software craftsmanship certainly has its importance and is essential for writing better software, but many times it is orthogonal to the client's motivations. Before spending time and effort with implementation details, engineers should be aware of the client's demands first.</p>
<p>Project timeline requirements are another aspect to consider. Software teams weigh business use cases against the quality of technical solutions. They tend to postpone required software tests or quality measures in order to meet deadlines. The technology used to implement the business application should support effective and pragmatic development.</p>
<p>When seeing the enterprise world through the eyes of a paying customer or a manager with limited time and budget, software engineers will likely understand their priorities. Caring about revenue-generating use cases first is mandatory. Technical necessities beyond these are seen by customers and managers as a <em>necessary evil</em>.</p>
<p>The rest of this book will show you how to meet and balance these two motivations with Java EE.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Outer enterprise project structure</h1>
                </header>
            
            <article>
                
<p>Having the goal of business use cases in mind, let's move our focus a bit more down to earth to real-world enterprise projects. In later chapters, we will see what methods are there to help us reflecting the business domains in the architecture in a suitable way.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Business and team structures</h1>
                </header>
            
            <article>
                
<p>Software projects are usually developed by a team of engineers, software developers, or architects. For simplicity, we will call them developers. Software developers, architects, testers, and all kind of engineers should arguably program from time to time.</p>
<p>However, in most situations we have several people working simultaneously on a software project. This already requires us to take a few things into account, mainly communication and organizational overhead. When we look at the structure within organizations with several teams working on multiple projects, or temporarily even the same project, we deal with even more challenges.</p>
<p>The Conway's law claims that:</p>
<div class="packt_quote">Organizations which design systems [...] are constrained to produce designs which are copies of the communication structures of these organizations.</div>
<div class="packt_quote CDPAlignRight CDPAlign">- Melvin Conway</div>
<p class="mce-root"><span>That being said, the way in which the teams are organized and communicate with each other will inevitably leak into software design. The organization chart of developers and their effective communication structures has to be considered when constructing software projects. We will have a detailed look into how to construct several distributed systems and more specific microservices in</span> <a href="">Chapter 8</a><span>,</span> <em>Microservices and System Architecture</em><span>.</span></p>
<p class="mce-root">Even in a single project owned by a team of few developers, there will likely be multiple features and bug fixes <span>being developed simultaneously</span>. This fact impacts how we plan the iterations, organize, and integrate source code, and build and deploy runnable software. In particular <a href="599c6821-8971-4489-931c-9e11b5e23afd.xhtml">Chapter 6</a>, <em>Application Development Workflows</em> and <a href="">Chapter 7</a>, <em>Testing</em> will cover this topic.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Software projects contents</h1>
                </header>
            
            <article>
                
<p>Enterprise software projects include several artifacts necessary to build and ship applications. Let's have a closer look at them.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Application source code</h1>
                </header>
            
            <article>
                
<p>First of all, all enterprise applications, like probably any application, are written in source code. The source code is arguably the most important part of our software project. It represents the application and all its functionality at its core and can be seen as the single source of truth of software behavior.</p>
<p>The project's sources are separated into code that runs on production and test code to verify the application's behavior. The technologies as well as the quality demands will vary for test and production code. In <a href="">Chapter 7</a>, <em>Testing</em>, we will deeply cover the technologies and structures of software tests. Apart from that chapter, the focus of this book lies on production code, which is shipped and which handles the business logic.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Software structures</h1>
                </header>
            
            <article>
                
<p>The software project organizes the source code in certain structures. In Java projects, we have the possibility to cluster components and responsibilities into Java packages and project modules, respectively:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/a3993e8c-d3db-4403-a5ca-129fcb4b833a.png"/></div>
<p>Structuring these components is obviously less a technical rather than an architectural necessity. Code that is packaged arbitrarily would technically run equally well. However, this structure helps engineers understanding the software and its responsibilities. By clustering software components that fulfill coherent features, we increase cohesion and achieve a better organization of the source code.</p>
<p>This and the next chapter will discuss the benefits of <em>Domain-Driven Design</em>, described in the book by Eric Evans, and the why and how to organize code in business-driven packages. For now, let's record that we group coherent components that form logical features into logical packages or project modules.</p>
<p>Java SE 9 comes with the possibility of shipping modules as Java 9 modules. These modules are, in essence, similar to the JAR files with the ability to declare dependencies and usages restrictions of other modules. Since this book is targeted for Java EE 8 and since the fact that the usage of Java 9 modules hasn't spread yet in real-world projects, we will cover only Java packages and project modules.</p>
<p>Breaking the structure of software projects further down, the next smaller unit of software components is a Java class. Classes and the responsibilities thereof encapsulate single functionalities in the domain. They are ideally loosely coupled and show a high cohesion.</p>
<p>A lot has been written about clean code practices and representing functionality in source code. The book <em>Clean Code</em> by Robert C. Martin, for example, explains methods such as proper naming or refactoring, that help achieve well-crafted source code in packages, classes and methods.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Version control systems</h1>
                </header>
            
            <article>
                
<p>The source code is kept under version control, since most software projects require coordination of simultaneous code changes, made by multiple developers. <strong>Version control systems</strong> (<strong>VCS</strong>) have established themselves as mandatory to reliably coordinate, track, and comprehend changes in software systems.</p>
<p>There are a lot of choices of version control systems, such as Git, Subversion, Mercurial or CVS. In the last years, <strong>distributed revision control</strong> systems, particularly <strong>Git</strong>, have been widely accepted as the state-of-the-art tools. They use a so-called <em>hash tree</em>, or <em>Merkle tree</em> to store and resolve individual commits, which enables efficient <em>diffs</em> and <em>merges</em>.</p>
<p>Distributed VCS enables developers to work with project repositories in distributed ways, without constantly requiring a network connection. Every workstation has its own repository, which includes the full history and is eventually synchronized with the central project repository.</p>
<p>As of writing this book, the vast majority of software projects use Git as version control system.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Binaries</h1>
                </header>
            
            <article>
                
<p>The VCS project repository should only contain the sources that are produced and maintained by developers. Certainly, enterprise applications will have to be deployed as some kind of binary artifacts. Only these shippable binaries can be executed as runnable software. The binaries are ultimately the outcome of the development and build process.</p>
<p>In the Java world this means that the Java source code is compiled to portable bytecode and is usually packaged as <strong>Web Application Archive</strong> (<strong>WAR</strong>) or <strong>Java Archive</strong> (<strong>JAR</strong>), respectively. WAR or JAR files comprise all classes and files required to ship an application, framework dependency, or library. The <strong>Java Virtual Machine</strong> (<strong>JVM</strong>) finally executes the bytecode and together with that, our business functionality.</p>
<p>In enterprise projects the deployment artifacts, the WAR or JAR files, are either deployed to an application container or already ship the container themselves. The application container is needed, since beside their distilled business logic, enterprise applications will have to integrate additional concerns, such as application life cycle or communication in various forms. For example, a web application that implements certain logic but is not addressable over HTTP communication has little value. In Java Enterprise, the application container is responsible for providing this integration. The packaged application contains the distilled business logic and is deployed to a server, which takes care of the rest.</p>
<p>In recent years, more Linux container technologies such as Docker have emerged. This carries the ideas of shippable binaries even further. The <em>binary</em> then not only contains the packaged Java application, but all components required to run the application. This, for examples, includes an application server, the Java Virtual Machine, and required operating system binaries. We will discuss the topic of shipping and deploying enterprise applications, especially regarding container technology, in <a href="f0a49441-e411-49c4-a4b6-c6193ba36094.xhtml">Chapter 4</a>, <em>Lightweight Java EE</em>.</p>
<p>The binaries are produced as part of the software build process. It enables to reliably recreate all binaries from the repository's sources. <span>Therefore, the binaries should not be kept under version control.</span> The same is true for generated source code. In the past, for example, JAX-WS classes which are required for SOAP communication were usually generated from descriptor files. Generated source code is created during the build process and should also not be kept under version control. The idea is to keep only the distilled source code in the repository and no artifacts that can be derived from it.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Build systems</h1>
                </header>
            
            <article>
                
<p>The build process is first of all responsible for compiling the sources of a Java software project into bytecode. This happens every time changes have been made to the project. All modern build systems ship with useful conventions to minimize the required configuration.</p>
<p>In the enterprise world, with all its different frameworks and libraries, an important step is to organize and define all dependencies on APIs and implementations. Build tools such as <strong>Apache Maven</strong> or <strong>Gradle</strong> support developers by including powerful dependency resolution mechanisms. The build tool adds all the dependencies with the corresponding versions required to compile or run the application, respectively. This simplyfies to setup the project among multiple developers. It also enables repeatable builds.</p>
<p>Packaging the compiled classes and their dependencies into deployment artifacts is also part of the build process. Depending on the used technology the artifacts are packaged as WAR or JAR files. <a href="f0a49441-e411-49c4-a4b6-c6193ba36094.xhtml">Chapter 4</a>, <em>Lightweight Java EE</em> will discuss the different ways of packaging Java enterprise applications together with their pros and cons.</p>
<p>The topics, <em>Gradle</em> and <em>Apache Maven</em>, will discuss the implementation and differences of the two main build systems in more depth.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Single versus multi-module projects</h1>
                </header>
            
            <article>
                
<p>As said before, we can organize the application's source code in Java packages and project modules, respectively. Project modules group related functionality together into separately buildable sub-projects. They are usually specified by the build systems.</p>
<p>At first, the motivations behind splitting up project modules are quite understandable. Grouping Java code and packages into related modules creates a clearer view for the developers, enables a better structure, and increases cohesion.</p>
<p>Another reason for multi-modules is build time performance. The more complex our software project becomes the longer it will take to compile and package it into artifacts. Developers mostly touch few locations in the projects at a time. Therefore, the idea is to not always rebuild the whole project, but only the modules necessary in order to apply the desired changes. This is an advertised advantage of the Gradle build system, to save time by rebuilding only what has changed.</p>
<p>Another argument for this practice is the possibility of reusing certain sub-modules in several projects. By building sub-projects into self-sufficient artifacts we could possibly take and include a sub-artifact in another software project. For example, a common practice is to design a <em>model</em> module that contains <span>the entities of the business domain, usually as</span> standalone <strong>plain old Java objects</strong> (<strong>POJOs</strong>). This model would be packaged to a JAR file and reused as a dependency in other enterprise projects.</p>
<p>There are, however, some drawbacks, or rather, illusions to this practice.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Illusion of reusability</h1>
                </header>
            
            <article>
                
<p>We have to remind ourselves that software projects are built by teams of developers and the project structure will therefore adhere to their communication structures. Reusing certain modules within several projects requires quite a bit of coordination.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Technical dependencies</h1>
                </header>
            
            <article>
                
<p>A project's module that is subject to be reused has to meet specific criteria. First of all the technology of the shared modules has to match the target project. This sounds obvious, but has quite some implications on the implementation details. Especially used libraries and frameworks will inevitably cause the involved modules to be coupled and dependent on the specific technology. For example, model classes in Java EE typically contain annotations from APIs such as JPA that need to be available in all dependent modules.</p>
<p>Third-party dependencies with specific versions that are required for a shared module to function correctly have even more technical impact. These dependencies then have to be available at runtime and must not collide with other dependencies or versions thereof. This can cause a lot of headache with colliding dependencies that are already available on the server. The same holds true for implementation details that contain implicit dependencies.</p>
<p>A typical example of this is JSON mapping libraries such as Jackson or Gson. A lot of third-party dependencies use these libraries in specific versions that might collide with other dependencies or versions at runtime. Another example is logging implementations such as <strong>Logback</strong> or <strong>Log4j</strong>.</p>
<p>In general, shared models should be as self-sufficient as possible or at least contain only stable dependencies that won't likely drift into these issues. A good example for a very stable dependency is the Java EE API. Because of the backwards-compatible nature of the Enterprise Edition, usage of the API and resulting functionality won't break if a newer version is introduced.</p>
<p>But even if the Java EE API is the only dependency of shared modules, it will bind the model to a specific version and reduce the freedom to change.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Organizational challenges</h1>
                </header>
            
            <article>
                
<p>Shared technology and dependencies come with organizational challenges. The greater the number of developers and teams, respectively, the bigger the impact of used technology and dependencies. Teams have to agree upon certain technology, used frameworks and libraries and versions thereof.</p>
<p>If a single teams want to change something in this graph of dependencies or some of the used technologies, this change requires a lot of coordination and overhead. <a href="">Chapter 8</a>, <em>Microservices and System Architecture</em>, covers this topic of sharing code and artifacts within several systems and whether this is advisable or not.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Reusability considerations</h1>
                </header>
            
            <article>
                
<p>The trade-off is always reusability and having to deal with these issues versus simplicity and potential duplication. Depending on the level of self-sufficiency, the choice will be made toward one or the other. Generally speaking, the cost of coordinating dependencies, versions, and technology, outweighs the benefits of avoiding redundancy.</p>
<p>An important question to be asked, however, is how the projects modules are layered either vertically or horizontally. An example for horizontal layering is the typical three-tier architecture of clustering into a <em>presentation</em>, <em>business</em> and <em>data layer</em>. Vertical layering means to group functionality based on their business domain. Examples would be modules for accounts, orders or articles, including all technical requirements such as HTTP endpoints or database access. Both types of modules can potentially be reused.</p>
<p>In reality horizontal layered modules like models are more likely subject to be shared among other projects. These types of modules naturally have a smaller variety of dependencies, ideally zero. On the contrary, vertical layered modules will contain implementation details and expect certain circumstances, for example, how the container is configured. And again, it depends a lot on the technology being used within the modules that are subject to share.</p>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Project artifacts</h1>
                </header>
            
            <article>
                
<p>Let's take a step back and look at the deployment artifacts of our enterprise application. Typically, an application results in a single artifact that will run our software. Even with several multi-modules being used at the end of the day, these will boil down to a single or few artifacts. So, in most of the cases all of this structure is flattened again into single JAR or WAR files. Looking at the reusability of modules, which is not necessarily being given, this raises the question of whether we need several modules per project at all. At the end of the day, introducing and managing sub-projects, vertical or horizontal, will require certain developer effort.</p>
<p>It is true that splitting up the code base can improve build performance if only sub-projects that have been changed are rebuilt. However, in the sub-chapters <em>Apache Maven</em> and <em>Gradle</em> and <a href="f0a49441-e411-49c4-a4b6-c6193ba36094.xhtml">Chapter 4</a>, <em>Lightweight Java EE</em> we will see that building a single reasonably designed project into a single artifact is sufficiently fast and that there are usually other aspects responsible for making builds slow.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">One project per artifact</h1>
                </header>
            
            <article>
                
<p>It is advisable to package the enterprise project into a single deployment artifact that emerges from a single project module. The number and structure of deployment artifacts then maps the structure of the software projects. If other artifacts emerge from the project, they are organized in separate project modules as well. This enables an understandable and lightweight project structure.</p>
<p>Usually, an enterprise project will result in a shippable JAR or WAR file, originating from a single project module. Yet sometimes, we do have good reasons to create modules that are shared among projects. These are then sensibly crafted as own project modules that build own artifacts, for example JAR files.</p>
<p>There are still other motivations for multi-module projects. System tests that verify a deployed enterprise application from the <em>outside</em> don't necessarily have dependencies on the production code. It makes sense, in some situations, to organize these tests in separate project modules that are part of a multi-module project.</p>
<p>Another example is frontend technologies that are just loosely coupled to the backend application. With modern client-centric JavaScript frameworks being used more and more, the coupling to the backend also decreases. The workflow and life cycle of developing frontends can vary from the backend application. Therefore, it can make sense to split the technology into several sub-projects or even several software projects. The topic, <em>Structuring for modern frontend technologies</em>, covers how to tackle these situations.</p>
<p>These situations, however, also fit the concept of mapping <em>artifacts</em> in the broader sense to project modules. A system test project is used and executed separately from the production code. Developing and building the frontend project could equally be differ from the backend part. There may be some other situations where it is advisable as well.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Build systems for Java EE</h1>
                </header>
            
            <article>
                
<p>The project modules are specified as modules of the build system. Whether we can follow the straightforward way of having a single project or multiple projects; for example, motivated by system tests, we will build and execute them as part of the build process.</p>
<p>A good build system needs to ship certain features. The main task of it is to compile the sources and package the binaries as artifacts. Required dependencies are also resolved and used for compilation or packaged, respectively. There are several scopes where dependencies are required, such as during compilation, testing, or runtime. Different scope definition specify whether dependencies are shipped with the artifact.</p>
<p>The project should be built in a reliable, reproducible way. Several builds with identical project contents and build configuration must produce the same results. This is important for implementing <strong>Continuous Delivery</strong> (<strong>CD</strong>) pipelines, which enable reproducible builds. That said the build system must be able to run on a <strong>Continuous Integration</strong> (<strong>CI</strong>) server, such as <strong>Jenkins</strong> or <strong>TeamCity</strong>. This requires the software to ship a command-line interface, especially for Unix-based systems. <a href="599c6821-8971-4489-931c-9e11b5e23afd.xhtml">Chapter 6</a>, <em>Application Development Workflows</em>, will show the motivations behind Continuous Delivery.</p>
<p>The build system will be used by software engineers working on various environments and operating systems, which should be supported as well. For JVM-based build systems this portability is usually given. It may be the case that projects have specific requirements such as native code that needs to be built on specific environments. For Java enterprise applications, however, this is usually not the case.</p>
<p>In general the build process should run as fast as possible. Booting up and configuring the build system should not require much time. The longer the build takes the higher the turnaround times and the slower the feedback engineers get from the build pipeline. In <a href="f0a49441-e411-49c4-a4b6-c6193ba36094.xhtml">Chapter 4</a>, <em>Lightweight Java EE,</em> we will cover more of this topic.</p>
<p>At the time of writing, Apache Maven is the most used build system well known to the majority of Java developers.</p>
<p>Maven is a Java-based build system configured by XML. It's projects are defined by a so-called <strong>project object model</strong> (<strong>POM</strong>). Maven makes use of a <strong>convention over configuration</strong> approach that minimizes the required configuration. The default configuration is well suited for Java applications.</p>
<p>Another build tool with high usage is Gradle. Gradle is a build tool that offers a Groovy-based <strong>Domain-Specific Language</strong> (<strong>DSL</strong>) to configure fully extensible and scriptable project builds. Since Groovy is a full programming language Gradle build scripts are naturally powerful and flexible.</p>
<p>Both Gradle and Maven include a sophisticated dependency management and are well suited to build Java-based projects. There are certainly still other build systems, such as SBT, however, Gradle and Maven are, by far, the most-used ones and will be covered in the following section.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Apache Maven</h1>
                </header>
            
            <article>
                
<p>Apache Maven is widely used in Java-based projects and known to the vast majority of enterprise developers. The wide-spread usage and the familiarity of this tool is certainly a benefit.</p>
<p>Maven is based on a <strong>convention over configuration</strong> approach which simplifies straightforward use cases. Maven's configuration, however, does not always provide flexibility. In fact, this inflexibility is sometimes a feature. Since it's cumbersome to change the default Maven project structure and build process, most of the Java enterprise projects come in a very similar and familiar way. New developers easily find their way through the project's build configuration.</p>
<p>The following snippet shows a typical example of a Maven project structure:</p>
<div class="CDPAlignCenter CDPAlign"><img height="191" width="217" src="assets/d1e10bd8-29c3-43a9-93eb-4151e67d690e.png"/></div>
<p>This will seem familiar to the majority of enterprise Java developers. This example web application is packaged as a WAR file.</p>
<p>One of the shortcomings of Apache Maven is its somewhat nontransparent way of defining used build plugins and dependencies thereof. Using the default build convention without explicitly specifying versions for plugins such as the <strong>Maven Compiler Plugin</strong> can result in unwanted changes of used versions. This violates the principle of repeatable builds.</p>
<p>Because of this, projects that require reproducibility often explicitly specify and override the plugin dependency versions in the POMs. By doing so, projects will be built using the same versions all the time, even if the default plugin versions change.</p>
<p>Super POM definitions are another common solution to specify exact plugin versions. Project POMs can inherit from parent projects and reduce boilerplate plugin definitions.</p>
<p>Developers can use the <em>effective POM</em> view that shows the resulting POM, after applying the default configuration and potential inheritance.</p>
<p>A typical issue with Maven POMs is that enterprise projects very often overuse the XML definitions. They prematurely introduce plugins or configuration that already would be covered by the build conventions. The following snippet shows the minimum POM requirements for a Java EE 8 project:</p>
<pre>&lt;project 
         
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0
         http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt;
    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;

    &lt;groupId&gt;com.example.cars&lt;/groupId&gt;
    &lt;artifactId&gt;car-manufacture&lt;/artifactId&gt;
    &lt;version&gt;1.0.1&lt;/version&gt;
    &lt;packaging&gt;war&lt;/packaging&gt;

    &lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;javax&lt;/groupId&gt;
            &lt;artifactId&gt;javaee-api&lt;/artifactId&gt;
            &lt;version&gt;8.0&lt;/version&gt;
            &lt;scope&gt;provided&lt;/scope&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;

    &lt;build&gt;
        &lt;finalName&gt;car-manufacture&lt;/finalName&gt;
    &lt;/build&gt;

    &lt;properties&gt;
        &lt;maven.compiler.source&gt;1.8&lt;/maven.compiler.source&gt;
        &lt;maven.compiler.target&gt;1.8&lt;/maven.compiler.target&gt;
        &lt;failOnMissingWebXml&gt;false&lt;/failOnMissingWebXml&gt;
        &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;
    &lt;/properties&gt;
&lt;/project&gt;</pre>
<p>The <em>car manufacture</em> application is built into a WAR artifact. The <kbd>finalName</kbd> overrides the implied name of the WAR file, here resulting in <kbd>car-manufacture.war</kbd>.</p>
<p>The specified Java EE 8 API is the only production dependency that a straightforward enterprise solution requires. <a href="f0a49441-e411-49c4-a4b6-c6193ba36094.xhtml">Chapter 4</a>, <em>Lightweight Java EE</em> will deeply cover the topic of project dependencies and their impact.</p>
<p>The provided <kbd>properties</kbd> tag removes the need to explicitly configure the build plugins. Maven plugins per convention uses properties for configuration. Specifying these will reconfigure the used plugin without needing to explicitly declare the full definitions.</p>
<p>The properties cause the project to be built using Java SE 8, with all source files considered to be encoded as UTF-8. The WAR file doesn't need to ship a <kbd>web.xml</kbd> deployment descriptor; this is why we instruct Maven not to fail the build on a missing descriptor. In the past, the Servlet API required deployment descriptors in order to configure and map the application's Servlets. Since the advent of Servlet API version 3, <kbd>web.xml</kbd> descriptors are not necessarily required anymore; Servlets are configurable using annotations.</p>
<p>Maven defines its build process in several phases, such as <em>compile</em>, <em>test</em>, or <em>package</em>. Depending on the chosen phase, multiple steps will be executed. For example, triggering the <em>package</em> phase will compile the <kbd>main</kbd> as well as <kbd>test</kbd> sources, run the test cases, and package all classes and resources into the artifact.</p>
<p>The Maven build commands are triggered in the IDE or the <kbd>mvn</kbd> command line, for example, as <kbd>mvn package</kbd>. This command triggers the <em>package</em> phase, resulting in a packaged artifact. More details on phases and functionality of Apache Maven can be found under its official documentation.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Gradle</h1>
                </header>
            
            <article>
                
<p>At the time of writing, Gradle is less commonly used in Java enterprise projects than Apache Maven. This may be due to enterprise developers often being unfamiliar with dynamic JVM languages such as Groovy, which Gradle uses as its build script language. However, writing Gradle build files doesn't require deep knowledge of Groovy.</p>
<p>Gradle comes with quite a few benefits, most importantly its flexibility. Developers can leverage the full power of a programming language in order to define and potentially customize the project build.</p>
<p><span>Gradle will keep a daemon running in the background, that is being reused after the first build, to speed up subsequent build executions.</span> It also keeps track of build inputs and outputs, whether changes have been made since the last build execution. This enables the system to cache steps and decrease the development build time.</p>
<p>However, depending on the complexity of the project and its used dependencies this optimization might not even be required. <a href="f0a49441-e411-49c4-a4b6-c6193ba36094.xhtml">Chapter 4</a>, <em>Lightweight Java EE</em> will cover the impact of project dependencies and zero-dependency applications.</p>
<p>The following snippet shows the build structure of a Gradle project:</p>
<div class="CDPAlignCenter CDPAlign"><img height="312" width="246" src="assets/46247618-3f58-4403-b4fc-0da571e05ade.png"/></div>
<p>As you can see, the structure is quite similar to Maven projects, with the difference being that built binaries are per default placed into the <kbd>build</kbd> directory.</p>
<p>It's common for Gradle projects to include a wrapper script for environments that have no Gradle installations.</p>
<p>The following code demonstrates an example of a <kbd>build.script</kbd> file:</p>
<pre>plugins {
    id 'war'
}

repositories {
    mavenCentral()
}

dependencies {
    providedCompile 'javax:javaee-api:8.0'
}</pre>
<p>Gradle build tasks are triggered via the command line, using <kbd>gradle</kbd> or the provided wrapper scripts. Executing <kbd>gradle build</kbd>, for example, is the analog of <kbd>mvn package</kbd>, compiling the sources, executing tests and building the artifact.</p>
<p>There are certain benefits of having a fully-fledged programming language defining the build files. With the build scripts being treated as code, developers are encouraged to apply clean code principles for definitions that become too complex. Sophisticated build steps can, for example, be refactored into several, readable methods.</p>
<p>However, this power also brings the danger of over-engineering the build. As said, the inflexibility of Apache Maven can be considered a feature; the possibility of easily customizing build scripts eventually leads to build definitions that are very specific to the project. Compared to Maven, overly-customized builds can be an obstacle for developers who are unfamiliar with the project.</p>
<p>Experience shows that the vast majority of enterprise project builds are quite similar. This raises the question of whether the flexibility Gradle provides is required. Projects that don't have any special requirements, unlike for example product development, are sufficiently covered using Maven as build system.</p>
<p>The rest of this book will thus use Maven when a build system is required as an example. All code examples, however, are equally well suited to use Gradle.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Structuring for modern frontend technologies</h1>
                </header>
            
            <article>
                
<p>After shedding light on modern build systems for enterprise systems, let's have a look at how to integrate frontend technologies into the backend.</p>
<p>Traditionally, this was pretty straightforward. The frontend of web applications were, in most of the cases, server-side rendered HTML pages, powered by JSP or JSF. The HTML was crafted on the server on demand, that is, on request, and returned to the client. In order to realize that, the JSP or JSF pages, respectively, have to reside on the backend. Therefore, the whole enterprise application would be shipped and deployed as single artifact.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Enter JavaScript frameworks</h1>
                </header>
            
            <article>
                
<p>With new frontend technologies, basically sophisticated JavaScript frameworks, and especially single page applications, this premise has changed quite a bit. The web frontend frameworks became more and more client-centric and included much more business logic than in the past. On the server side this meant that the interaction between backend and frontend moved from fine grained methods to more coarse grained, business use case methods.</p>
<p>So, the more client-centric and powerful the JavaScript frameworks became, the more the communication between frontend and backend went from tightly coupled requests and responses to a more <em>API-like</em> usage, typically JSON via HTTP. This also meant that the server-side became more client-agnostic. For example, communicating solely via <em>RESTful-like</em>, JSON-format APIs enables native or mobile clients such as smartphones to use the same API like the frontend does.</p>
<p>We have seen this movement in a lot of enterprise projects. However, one could argue about the relevance of putting more and more logic into the client side or whether a hybrid solution of having some parts rendered on the server-side and some on the client-side is more appropriate. Without going too much into this topic, let us look at a few key points.</p>
<p>Preparation of data or content will be performed faster on the server-side. There are more capabilities and resources available than on the client. The server can also utilize features such as caching and use the advantage of <em>seeing</em> the whole picture.</p>
<p>Sophisticated frontend technologies often include a navigation logic that makes use of so-called <em>hashbang</em> pages. An example of a hashbang page URL is <kbd>/car-manufacture/#!/cars/1234</kbd>. These pages, for example, <em>car 1234</em>, do not reside on the server, but are only rendered on the client-side. The URL of that sub-page is determined after the hash-sign, which is not taken into account while requesting resources over HTTP. That means that the client requests a generic <em>entry page</em> that then does the whole navigation logic including rendering sub-pages. This clearly reduces the number of requests, but has the drawback that the server cannot support preparing or pre-rendering content; everything happens on the client-side. There have been big companies such as Twitter that originally pursued this approach but went away from it again, due to this reason. In particular, viewing these pages on mobile devices comes with certain challenges. With potential slow mobile connections and less computing power, rendering and executing sophisticated client-logic on these devices do take longer than displaying pre-rendered HTML.</p>
<p>Compared to statically typed, high-level languages such as Java, JavaScript frontends do have the issue that dynamically typed languages introduce more potential errors while programming that would have been prevented by a compiler. Because of this reason, we have seen more sophisticated frontend technologies such as TypeScript emerging, which introduced static types and higher language features that are processed into JavaScript again.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Organizing modern frontends</h1>
                </header>
            
            <article>
                
<p>However, no matter which specific frontend technology is chosen, enterprise projects do have more sophisticated frontends than in the past. This comes with new challenges of how to organize the daily development work. Typically the work cycles of the frontend and the backend will vary slightly. Some developers will typically see themselves more on the backend and others more on the frontend side. Even if the team solely consists of <em>full-stack</em> developers, some de-facto roles are likely to emerge over time.</p>
<p>Depending on the used technology it therefore makes sense to separate the frontend into a single project. As said before, as soon as some part of the software is shipped individually or has different life cycles than the rest, it makes sense to create a dedicated project module.</p>
<p>If the frontend technology can be deployed without any backend dependencies other than the HTTP usage, organizing the project is pretty straightforward. The project can be built and deployed on a web server individually and will use one or several backends from the client side. This project then only consists of static resources, such as HTML, JavaScript, or CSS files, which are transferred to the client and executed there. There will be no tight technical dependencies to the used backends, besides the HTTP API.</p>
<p>This aspect clearly has to be communicated well upfront during development, as well as documented on the backend side. Typically, the backend defines HTTP resources that serve required content in JSON format, which can optionally be filtered by query parameters if necessary. The reason behind the JSON format being popular is that JavaScript client code can use the response directly as JavaScript objects without any other transformation required.</p>
<p>If the frontend will be deployed together with the backend as a single artifact the project structure requires more coordination. The artifact contains both layers of technology and compiles and packages both at build time. During development this combination isn't necessarily helpful if the cycles of developing the frontend vary from the backend side. A programmer currently focusing on the frontend side probably doesn't want to build the backend part each and every time. The same is true with the backend technology waiting for potentially slow JavaScript compilation and packaging.</p>
<p>In these cases, it makes sense to split the project into several modules that can be built individually. What has proven itself well is to package the frontend module as an individual module and to introduce it as a dependency of the backend module, which then will package it altogether. By doing this, the frontend module clearly can be built individually, whereas a backend developer can rebuild the backend part as well by using their latest version of the frontend. Therefore, build times are reduced on both sides.</p>
<p>To realize this feature, the Servlet API can deliver static resources that are packed not only in the archive, but also in contained JAR files. Resources that reside under <kbd>META-INF/resources</kbd> of a JAR file that is contained in the WAR file, are delivered by the Servlet container, as well. The frontend project contains all its required frontend technology, framework and tools, and builds a separate JAR file.</p>
<p>This enables developers to separate the frontend from the backend project to adapt to different life cycles.</p>
<p>The rest of this book will focus on the backend technology and business use cases that are accessible via machine to machine communication such as web services.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Enterprise project code structure</h1>
                </header>
            
            <article>
                
<p>After seeing how we can organize our enterprise project structure, let's have a closer look at the detailed structure within a project. Assuming we have modeled an enterprise system that is reasonable in size and responsibility, we now map the concerns of the project into code structures.</p>
<p>Previously, we have discussed vertical versus horizontal module layers. This is precisely one of the aspects we need to look into when structuring the project.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Situation in enterprise projects</h1>
                </header>
            
            <article>
                
<p>The structure of typical enterprise projects has traditionally been a three-tier architecture. Three-tiers means three technically motivated layers, namely the <em>presentation</em>, <em>business</em>, and <em>data layer</em>. That being said, the project is organized horizontally, with three sub-modules, or packages, respectively.</p>
<p>The idea is to separate concerns from the data layer, from the business layer, and both of them from the presentation layers, as well. Functionality on a <em>lower</em> layer can therefore not have any dependencies on a <em>higher</em> layer, only the other way around. The business layer cannot use functionality of the presentation layer, only vice versa. The same is true for the data layer not depending on the business layer.</p>
<p>Each technically motivated layer or module has its own internal dependencies, that cannot be used from the outside as well. For example, only the <em>data layer</em> would be able to use the database, no direct invocations from the <em>business</em> layer would be possible.</p>
<p>Another motivation is to be able to swap implementation details without impacting other layers. If the database technology would be changed in favor of another, that would in theory not affect the other two layers, since the data layer encapsulates these details. The same is true if the presentation technology changes. In fact, even several <em>presentation</em> layers can be developed with all of them using the same <em>business</em> layer components, at least if the layers are organized as separate modules.</p>
<p>We have seen heated discussions, mostly from high-level architects, about the necessity of organizing and separating responsibilities by technical concerns. However, there are some drawbacks from this approach.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Horizontal versus vertical layering</h1>
                </header>
            
            <article>
                
<p>Clean code is all about code that aims to be understood by humans not machines. The same holds true for designing domains and organizing responsibilities. We want to find structures that easily tell the engineers what the project is all about.</p>
<p>The challenge with structuring by technical concerns at already high layers of abstractions is that the purpose and domain of the software gets obfuscated and hidden in lower layers of abstraction. When someone unfamiliar with the project looks at the code structure the first thing that they see are the three technical layers, although names and numbers might differ in some cases. This will at least look familiar to them, but it tells nothing about the actual domain.</p>
<p>Software engineers seek to understand domain modules, not necessarily technical layers.</p>
<p>For example, when touching the <em>accounts</em> functionality, developers regard everything related to the accounts domain, not all the database access classes at once. Other than that, developers hardly search for <em>all database access classes</em>, but for that single class which handles that logic of their current domain.</p>
<p>The same is true when changes have to be made to the system. Changes in functionality are more likely to affect all technical layers of a single or a few business domains, but hardly all classes of a single technical layer at once. For example, changing a field to the user account likely affects the user model, database accesses, business use cases, and even the presentation logic, but not necessarily all the other model classes as well.</p>
<p>To make the idea what aspects developers are interested in more clearer, let me give another example. Imagine a family organized their clothes in a single big wardrobe. They could cluster all pants from all family members in a single drawer, as well as separate drawers for all socks and all shirts, respectively. But the family members won't likely search for all pants at once when they try to dress. Rather than this, they're just interested in their individual clothes, be it pants, shirts, socks, or something else. Therefore, it would make sense for them to organize by several areas of the wardrobe first, one per family member and then structuring by <em>technical clothes</em> aspects second, ideally following a similar structure. The same can be seen for software responsibilities.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Business-driven structure</h1>
                </header>
            
            <article>
                
<p>Uncle Bob once wrote about <em>Screaming Architectures</em> that should aim to at first tell the engineer what the whole enterprise project is about. The idea was that when looking at blueprints of buildings and seeing the structure and the detailed interior you immediately can tell: <em>this is a house</em>, <em>this is a library</em>, <em>this is a train station</em>. The same should hold true for software systems. You should be able to look at the project structure and be able to say: <em>this is an accounting system</em>, <em>this is a book store inventory system</em>, <em>this is an order management system</em>. Is this the case for the most projects we have? Or, does looking at the highest level of modules and packages rather tell us: <em>this is a Spring application</em>, <em>this system has a presentation, business and data layer</em>, <em>this system uses a Hazelcast cache</em>?</p>
<p>The technical implementations are certainly important to us developers. But again, the first thing that we focus on is business concerns. Following this approach, these aspects should be reflected in the project and module structure as well.</p>
<p>Most importantly, this means our domain should be reflected in the application structure. Just by looking at the highest hierarchy of package names should give a good idea of what the software is trying to do. We therefore layer after business concerns first, implementation details second.</p>
<p>Blueprint plans for buildings will also first build up a picture what the building is about, how the rooms are separated, and where doors and windows are located. Then, as a secondary priority they may specify used materials, bricks, and types of concrete being used.</p>
<p>As an outlook for microservices consider the following: designing vertical modules enables the team to split up the application into a system of several applications much more easily. Looking at the module dependencies, for example through static code analysis, provides a picture of where the integration points between the systems would be. These integration points would emerge in some form of communication between the applications. In theory, we can then take that single module, plus minimal <em>plumbing</em>, and package it as a separate, self-sufficient application.</p>
<p>A point on names: by using the term <em>modules</em> we, by now, focus on business driven modules that are realized in Java packages and sub-packages, not build project modules. The term <em>modules</em> then serves more as a concept, less as a strict technical realization.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Designing reasonable modules</h1>
                </header>
            
            <article>
                
<p>More down to earth, how do we find reasonably sized and structured modules?</p>
<p>Putting business concerns first, a good start is to draw overviews of all the responsibilities and use cases of the application. This may be part of a brainstorming session, ideally together with business domain experts if that step hasn't been done before. What are the application's responsibilities? What business motivated use cases do we have? Which coherent functionality can be seen? The answers to these questions already give a good idea which modules are likely to be represented, without <span>focusing on external systems, implementation details, or framework choices</span>.</p>
<p>In this step we also already consider dependencies between these business concerns. Dependencies are helpful indicators of whether modules should be split up or, especially when circular dependencies are found, should be merged together. Constructing these overview diagrams, starting from a higher level and working the way down in several iterations will give a clearer image of what the business contents of the application are. Generally speaking, the identified modules should match well with the business aspects identified by the domain experts.</p>
<p>To give an example, an online shopping application could identify modules for <em>users</em>, <em>recommendation</em>, <em>articles</em>, <em>payment</em>, and <em>shipping</em>. These would be reflected as the base domain modules:</p>
<div class="CDPAlignCenter CDPAlign"><img height="331" width="394" src="assets/86827232-c66e-4b88-b9c4-7fa61411aa97.png"/></div>
<p>The identified modules represent the base Java packages in our application.</p>
<p>It makes sense to put some effort into these considerations. However, as always, any <em>definitive</em> structure or implementation, no matter whether on code or module level, should be able to be changed later on. New requirements might emerge or there might be a better understanding later on, once the developers start to deep dive into the domain. Iterative refactoring, no matter on which level, will improve the quality of the system.</p>
<p><a href="">Chapter 8</a><span>,</span> <em>Microservices and System Architecture</em>, will show similar motivations and methodologies when designing systems that comprise distributed applications. Particularly, the Domain-Driven Design approaches of bounded contexts and context maps will be discussed.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Realizing package structures</h1>
                </header>
            
            <article>
                
<p>Assuming we found appropriate base Java packages to start with. Now, how do you realize the inner package structure, that is, which sub-packages to use?</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Package contents</h1>
                </header>
            
            <article>
                
<p>At first let's have a look at the contents of a vertically sliced module. Since it is modeled after business concerns, the module will include everything necessary to fulfill certain functionality.</p>
<p>First of all, the module includes technical entry points for use cases such as HTTP endpoints, presentation framework controllers, or JMS endpoints. These classes and methods usually make use of Java EE principles, such as inversion of control, to be called from the container as soon as some communication hits the application.</p>
<p>The functionalities that initiate the actual use cases are the next and equally important concern. They usually differ from the technical endpoints such that they don't contain any communication logic. The business use case boundaries are the entry point of our domain logic. They are implemented as managed beans, usually Stateless Sessions Beans, EJBs in other words, or CDI managed beans.</p>
<p>The boundaries initiate and implement the business logic. In cases where the logic of a use case consists of just a few steps the boundary can sufficiently contain the whole logic in the business method or private methods in the class definition. Then no other delegate is required. For the vast majority of use cases the boundary would delegate logic to corresponding services. These delegates have finer-grained responsibilities. Depending on the domain this includes implementing detailed business logic or accessing external systems such as databases. Following Domain-Driven Design language, these classes include services, transaction scripts, factories, and repositories.</p>
<p>The next type of objects are all classes that typically would be considered as <em>model</em> content, such as entities, value objects, and transfer objects. These classes represent the entities in the domain, but also can, and should, implement business logic. Examples are entity beans that are managed in the database, other POJOs, and enumerations.</p>
<p>In some cases the package might also contain cross-cutting concerns such as interceptors with business or technical responsibilities. All these types of components now have to be organized within a module.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Horizontal package layering</h1>
                </header>
            
            <article>
                
<p>If we were to organize the module contents, our first attempt probably would be to design the inner package structure by technical layering. Slicing up by business concerns first and technical ones second at least sounds reasonable.</p>
<p>In the <em>users</em> package this would mean to have sub-packages such as <em>controller</em>, <em>business</em> or <em>core</em>, <em>model</em>, <em>data</em> and <em>client</em>, respectively. By following this approach, we split up responsibilities inside the <em>users</em> package by their technical categories. In order to be consistent, all the other modules and packages in the project would have similar packages, depending on their contents. The idea is similar to a three-tier architecture, but inside of the domain modules.</p>
<p>One of the sub-packages would be considered to be the technical entry point, for instance <em>controller</em>. This package would contain the communication endpoints initiating the use case logic and serve as entry point outside of the application. The following shows the structure of a horizontally organized <kbd>users</kbd> package:</p>
<div class="CDPAlignCenter CDPAlign"><img height="322" width="326" src="assets/3db0ac0a-adde-467a-94e3-8066492acbb9.png"/></div>
<p>This structure is realized in Java packages as follows:</p>
<div class="CDPAlignCenter CDPAlign"><img height="184" width="161" src="assets/846313ce-1cb0-4168-93e8-c676b0677d3f.png"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Flat module package</h1>
                </header>
            
            <article>
                
<p>An even simpler and more straightforward approach to organize module contents is to directly put all related classes into this module package in a flat hierarchy. For the <kbd>users</kbd> package this means to place all classes, including user related use case entry points, user database access code, potential external system functionality, and the user entity classes themselves, directly into this package.</p>
<p>Depending on the complexity of the modules this can be a clean and straightforward approach or it can become too unorganized over time. Especially entities, value objects, and transfer objects can reach a number of classes that, if put into a single package, drastically reduce clarity and overview. However, it makes a lot of sense to start with this approach and refactor later.</p>
<p>The following shows the package structure of an example <kbd>users</kbd> package:</p>
<div class="CDPAlignCenter CDPAlign"><img height="118" width="212" src="assets/89782f98-faa5-42ea-84a7-b43607cbe0b4.png"/></div>
<p>A benefit of this approach is that it's well supported by the Java language. By default Java classes and methods come with package-private visibility. This fact together with organizing all classes in one place leverages encapsulations and visibility practices. C<span>omponents, that are desired to be accessible from outside of the package, get public visibility; all classes and methods that are only accessed from within this package define p</span>ackage-private visibility. The package can therefore encapsulate all internal concerns.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Entity Control Boundary</h1>
                </header>
            
            <article>
                
<p>Coping with the number of classes in the module package, there is another approach similar to technical layering, but with fewer and clearer defined packages. The idea is to structure due to what is a use case boundary of the module, which are subsequent business logic components, and which are entity classes.</p>
<p>This focuses on organizing module packages by their responsibilities, but with fewer technical details at the top package layer, compared to horizontal layering. The <strong>boundary</strong> package contains the use cases initiators, the boundaries, which are accessed from the outside of the system. These classes typically represent HTTP endpoints, message driven beans, frontend related controllers, or simply Enterprise Java Beans. They will implement the business driven use cases and optionally delegate to subsequent classes residing in the optional <strong>control</strong> package. The <strong>entity</strong> package contains all the <em>nouns</em> in the module, domain entities or transfer objects.</p>
<p>Ivar Jacobson has formed the term <strong>Entity Control Boundary</strong> for following way of organizing modules:</p>
<div class="CDPAlignCenter CDPAlign"><img height="206" width="265" src="assets/3879e8f1-419e-4893-95c8-1ac90cbda261.png"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Packages</h1>
                </header>
            
            <article>
                
<p>Let's have a closer look at the boundary package. The idea was that all business use cases called from the frontend or outside of the system are initiated here. Invocations for creation, update, or deletion of users, first land in classes residing in this package. Depending on the complexity of the use cases, the boundary either completely handles the logic itself or delegates into the control before becoming too complex.</p>
<p>For a Java enterprise application, classes in the boundary package are implemented as managed beans. As mentioned before, typically EJBs are used here.</p>
<p>If the logic in the boundary becomes too complex and not manageable within a single class anymore, we refactor the logic into delegates that are used in the boundary. These delegates or <em>controls</em> are placed in the control package. They typically <span>fulfill more detailed business logic or handle database or external system access by acting</span> within the technical transaction that was initiated in the boundary.</p>
<p>This structure increases cohesion and reusability and honors the single responsibility principle. The structure of the business use case becomes more readable, once we introduce these abstraction layers. You can start by looking at the boundary as the entry point of the use case, and retrace every delegated step one after another.</p>
<p>In Domain-Driven Design language, the contents of the control package includes services, transaction scripts, factories and repositories. However, the existence of a control package for business use cases is optional.</p>
<p>At the heart of our domain we have all entities and value objects. These, together with transfer objects, build up the model of our domain module, the objects that a use case typically deals with. They are organized within the entity package, the last one of the Entity Control Boundary pattern.</p>
<p>Now, what about presentation-related components and cross-cutting concerns such as Interceptors or framework <em>plumbing</em> logic? Fortunately, in a modern Java EE project required framework plumbing is kept within limits as we will see in <a href="329094a0-f41b-4ad1-b05e-cd52c4bb9e42.xhtml">Chapter 3</a>, <em>Implementing Modern Java Enterprise Applications</em>. The few things that are required, for example bootstrapping JAX-RS with the application activator class, are placed in the root package of our project or in a specific <kbd>platform</kbd> package. The same is true for cross-cutting concerns such as technically motivated interceptors that are not bound to a specific module, but the application as a whole. The number of these classes is typically not too high; if so, then a dedicated package makes sense. The danger of having such a platform package is that it naturally tempts developers to put other components in there as well. This place is just meant for the few platform specific classes; everything else should reside in its own business motivated module package.</p>
<p>The following is an example of the <kbd>users</kbd> module, using the Entity Control Boundary pattern:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/2edc5642-6f75-4394-ad53-c8f4cc4362bb.png"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Package access</h1>
                </header>
            
            <article>
                
<p>Not all accesses from every package of the Entity Control Boundary pattern are allowed or make sense, respectively. In general, the logic flow starts at the boundary, going down to the control and entity package. The boundary package therefore, has dependencies to both the control, if existent, and the entity package. Using boundaries of other modules are not allowed and won't make sense, since the boundary represents a business use case. Accessing another boundary would mean to invoke something that should be a separate, standalone use case. Therefore boundaries can only go <em>down</em> the hierarchy to controls.</p>
<p>However, dependencies and invocations from boundaries to controls of other modules are allowed and do make sense in some cases. Developers have to pay attention that the transaction scopes are still chosen correctly when accessing components from other modules. When accessing controls of other modules, it will also happen that they work with or return entities of that foreign module. This happens for more than trivial use cases and won't be an issue, as long as care is taken where the responsibilities are placed, and that the controls and entities are being used correctly.</p>
<p>Controls may access controls of other modules and their own and foreign entities. For the same reason as with boundaries, it makes no sense that a control invokes functionality of any boundary. This would be equivalent to starting new top-level business use cases within a running use case.</p>
<p>Entities are only allowed to depend on other entities. In some cases it will be necessary to have imports on controls, for example, if JPA entity listeners or JSON-B type converters exist that can implement sophisticated logic. These technically motivated cases are the exception where it should be allowed for simplicity to import these classes. Ideally, these entity <em>supporting</em> components, such as entity listeners or converters should reside directly in the entity package. Due to other dependencies and usage of delegates this premise cannot always be fulfilled, which should not lead to overly complex technical workarounds.</p>
<p>This also brings us to another more general topic.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Don't over-enforce architecture</h1>
                </header>
            
            <article>
                
<p>Whichever architectural pattern you choose, the main priority of the application should be the business domain. This is true for both finding reasonable, domain-motivated modules, but also how to structure the packages within a module, so that developers can work with it with least effort.</p>
<p>This is one important thing to note: developers should be able to work on the project without too complex or overly enforced structures and architectures. We have seen too many examples in the past that deliberately used technically driven layers or overly strict patterns, just to <em>match the book</em> and fulfill certain constraints. But these constraints are often self-motivated and don't fulfill any higher purpose. We should sensibly reconsider what is required and what just bloats the development processes. Search for the term <em>cargo cult programming</em> when you have the time, and you will find an interesting real-world story of following rules and rituals without questioning their purpose.</p>
<p>Therefore, don't over-complicate or over-enforce architecture. If there is a simple and straightforward way that fulfills what currently is required, just go for it. This is not only true for premature refactoring, but also for architectural design. If putting a few classes in a single, well-named package serves the purpose and clearly documents the reasoning, why not? If a business use case boundary class can already fulfill the whole, simple logic, why introduce empty delegates?</p>
<p>The trade-off of following an architectural pattern, even if not required in all places, is consistency versus simplicity. Having all packages, modules, and projects showing the same patterns and structure shows a picture familiar to developers. However, in <a href="">Chapter 8</a>, <em>Microservices and System Architecture</em> we will see that in greater detail, ultimately, consistency is a goal that isn't likely to be achieved within the whole organization, or even single projects. The benefits of crafting something simpler and eventually more flexible outweighs uniformity in many cases.</p>
<p>The same is true for overly trying to encapsulate the implementation using technical layers. It is definitely the case that modules as well as classes should encapsulate implementation details and provide clean and clear interfaces. However, these responsibilities can and should be contained in single, ideally self-sufficient packages or classes. Packaging the module's concerns by technical terms ultimately exposes the details to the rest of the module, for example, that a database or a client to an external system is being used. Organizing by domain motivation first, enables us to encapsulate functionality into single points of responsibility, transparent to the rest of the modules or application.</p>
<p>In order to prevent accidental misuse of a way of packaging, the easiest and most transparent way is to introduce static code analysis. Package imports in classes and whole packages can be scanned and analyzed to detect and prevent unwanted dependencies. This represents a security measurement, similar to test cases, to avoid careless mistakes. Static code analyses will typically run as an extended part of the build process on the Continuous Integration server, as they may take some time to build. In <a href="599c6821-8971-4489-931c-9e11b5e23afd.xhtml">Chapter 6</a>, <em>Application Development Workflows</em> we will cover this topic in more depth.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>Enterprise software should be built with the main priority to solve business problems, leading to business-driven applications and technology rather than to technology-driven solutions. The business use cases are what ultimately will generate revenue for the company.</p>
<p>If possible, enterprise applications should be developed in one build project per artifact, kept under version control. Splitting up a project into several, independent build modules that are in the end boiled down to a single artifact, doesn't add much value. For the coarse project structure it's advisable to structure the software modules vertically, not horizontally. This means to structure by business rather than technical concerns. Looking at the project structure should immediately tell developers what the project's domain and responsibilities are about.</p>
<p>An individual application module can, in the simplest way, be designed as a single, flat Java package. This is advisable if the number of classes per module is small. For more complex modules it makes sense to add another hierarchical layer using patterns such as Entity Control Boundary.</p>
<p>Software engineers should be reminded not to over-enforce software architecture. Well-thought-out design and bureaucratic organization certainly support developers a lot in crafting high quality software. Still, there is always a happy medium between reasonable design and over-engineering.</p>
<p>After seeing the course structure of enterprise projects and how to design modules, let's dive down one level to how to realize project modules. The following chapter will show you what it takes to implement enterprise applications with Java EE.</p>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>


            </article>

            
        </section>
    </body></html>