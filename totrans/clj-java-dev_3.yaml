- en: Chapter 3. Interacting with Java
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第3章。与Java交互
- en: We know a bit about how to organize our code and how that relates to packages
    in Java. Now, you surely need to use your old Java code and all the libraries
    you already know; Clojure encourages a new way to think about programming and
    it also allows you to use all the dependencies and code that you've already generated.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 我们对如何组织代码以及它与Java中的包的关系有一些了解。现在，你当然需要使用你旧的Java代码和所有你已知的库；Clojure鼓励一种新的编程思考方式，同时也允许你使用所有已经生成的依赖和代码。
- en: Clojure is a **Java Virtual Machine** (**JVM**) language and as such it is compatible
    with most Java dependencies and libraries out there; you should be able to use
    all the tools out there. You should also be able to use your Clojure programs
    with Java-only programs, this requires a bit of custom coding but in the end you
    can use Clojure in the right places of your project.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: Clojure是一种**Java虚拟机**（**JVM**）语言，因此它与大多数Java依赖项和库兼容；你应该能够使用所有这些工具。你也应该能够使用Java-only程序与Clojure程序一起使用，这需要一些自定义编码，但最终你可以在项目的正确位置使用Clojure。
- en: 'To be able to do this, we''ll have to learn:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 为了能够做到这一点，我们得学习：
- en: Using Maven dependencies
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Maven依赖项
- en: Using plain old Java classes from your Clojure code base
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Clojure代码库中使用普通的Java类
- en: A bit more about the Clojure language, in particular the `let` statements and
    destructuring
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关于Clojure语言的一些更多信息，特别是`let`语句和结构化
- en: Creating a Java interface for your Clojure code
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为你的Clojure代码创建Java接口
- en: Using the Java interface from other Java projects
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从其他Java项目中使用Java接口
- en: Using Maven dependencies
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Maven依赖项
- en: Let's say that we want to write an image manipulation program; it is a very
    simple program that should be able to create thumbnails. Most of our codebase
    is in Clojure, so we want to write this in Clojure too.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想要编写一个图像处理程序；这是一个非常简单的程序，应该能够创建缩略图。我们的代码库大部分是Clojure编写的，所以我们也想用Clojure来编写这个程序。
- en: There are a bunch of Java libraries meant to manipulate images, we decide to
    use imgscalr, which is very simple to use and it looks like it is available in
    Maven Central ([http://search.maven.org/](http://search.maven.org/)).
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多Java库旨在处理图像，我们决定使用imgscalr，它非常简单易用，看起来它在Maven Central中可用（[http://search.maven.org/](http://search.maven.org/)）。
- en: 'Let''s create a new Leiningen project, as shown:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个新的Leiningen项目，如下所示：
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Now, we need to edit the `project.clj` file in the thumbnails project:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要编辑缩略图项目的`project.clj`文件：
- en: '[PRE1]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'You can add the `imgscalr` dependency similar to the following code:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以像以下代码一样添加`imgscalr`依赖项：
- en: '[PRE2]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'As you can see, you just need to add a dependency to the `:dependencies` vector,
    the dependencies are automatically resolved from:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，你只需要将依赖项添加到`:dependencies`向量中，依赖项会自动从以下位置解析：
- en: Maven Local
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Maven本地仓库
- en: Maven Central
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Maven Central
- en: Clojars
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Clojars
- en: Note
  id: totrans-22
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The Maven Local points to your local maven repository that is in the `~/.m2`
    folder. If you wish, you can change it with Leiningen's `:local-repo` key.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: Maven本地仓库指向你的本地Maven仓库，该仓库位于`~/.m2`文件夹中。如果你愿意，你可以使用Leiningen的`:local-repo`键来更改它。
- en: 'You can add your own repositories, let''s say you need to add **jcenter** (Bintray''s
    Java repository) you can do so, as shown:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以添加自己的仓库，比如说你需要添加**jcenter**（Bintray的Java仓库），你可以这样做，如下所示：
- en: '[PRE3]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Note
  id: totrans-26
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'Leiningen supports a wide array of options to configure your project, for more
    information you can check the sample at Leiningen''s official repository: [https://github.com/technomancy/leiningen/blob/master/sample.project.clj](https://github.com/technomancy/leiningen/blob/master/sample.project.clj).'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: Leiningen支持广泛的选项来配置你的项目，更多详细信息，你可以查看Leiningen官方仓库中的示例：[https://github.com/technomancy/leiningen/blob/master/sample.project.clj](https://github.com/technomancy/leiningen/blob/master/sample.project.clj)。
- en: 'In order to download the dependencies, you have to execute the following code:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 为了下载依赖项，你必须执行以下代码：
- en: '[PRE4]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Tip
  id: totrans-30
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: You don't need to execute `lein deps` every time you want to download dependencies,
    you can do it to force a download but Leiningen will automatically download them
    when it needs to.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 你不需要每次想要下载依赖项时都执行`lein deps`，你可以这样做来强制下载，但Leiningen会在需要时自动下载它们。
- en: 'You can check the current dependencies by running:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过运行以下命令来检查当前依赖项：
- en: '[PRE5]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'You will get something similar to this:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 你将得到类似以下的内容：
- en: '[PRE6]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This lists your current dependency tree.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 这列出了你的当前依赖项树。
- en: Clojure interop syntax
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Clojure互操作语法
- en: Clojure was designed to be a Hosted Language, which means that it can run in
    different environments or runtimes. One important philosophy aspect is that Clojure
    does not attempt to get in the way of your original host; this allows you to use
    your knowledge of the underlying platform to your advantage.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: Clojure被设计成一种托管语言，这意味着它可以在不同的环境或运行时中运行。一个重要的哲学方面是Clojure不会试图阻碍你的原始宿主；这允许你利用你对底层平台的了解来获得优势。
- en: In this case, we are using the Java platform. Let's look at the basic interrupt
    syntax that we need to know.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们使用的是Java平台。让我们看看我们需要了解的基本中断语法。
- en: Creating an object
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建对象
- en: There are two ways to create an object in Clojure; for example, let's have a
    look at how to create an instance of `java.util.ArrayList`.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在Clojure中创建对象有两种方式；例如，让我们看看如何创建`java.util.ArrayList`的实例。
- en: '[PRE7]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Here, we are using the `new` special form, as you can see it receives a symbol
    (the name of the class `java.util.ArrayList`) and in this case it is an integer.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我们使用的是`new`特殊形式，正如你所见，它接收一个符号（类的名称`java.util.ArrayList`）并且在这种情况下它是一个整数。
- en: The symbol `java.util.ArrayList` represents the `classname` and any Java class
    name will do here.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 符号`java.util.ArrayList`代表`classname`，任何Java类名都可以在这里使用。
- en: Next, you can actually pass any number of parameters (including `0` parameters).
    The next parameters are the parameters of the constructor.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你可以实际传递任意数量的参数（包括`0`个参数）。下一个参数是构造函数的参数。
- en: 'Lets have a look at the other special syntax that is available to create objects:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看可用于创建对象的另一种特殊语法：
- en: '[PRE8]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The difference here is that we have a trailing dot; we prefer to see this syntax
    since it is shorter.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的不同之处在于我们有一个尾随的点；我们更喜欢看到这种语法，因为它更短。
- en: Calling an instance method
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 调用实例方法
- en: Once we have created our object we can call instance methods. This is done similar
    to how we call Clojure functions, using the special dot form.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们创建了我们的对象，我们就可以调用实例方法。这和调用Clojure函数的方式类似，使用特殊的点形式。
- en: 'If we want to add an element to our newly created list, we will have to do
    it, as shown:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想向新创建的列表中添加一个元素，我们必须按照以下方式操作：
- en: '[PRE9]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'This syntax might look a little strange; here is how this syntax is formed:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 这种语法可能看起来有点奇怪；以下是这种语法是如何形成的：
- en: '[PRE10]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Similar to the two different options that we had when creating an object, we
    have another way to do this:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于创建对象时我们有的两种不同选项，我们还有另一种方法来做这件事：
- en: '[PRE11]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: You might think that this is more familiar, since the method name starting with
    a dot resembles how we write the Java method calls.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会认为这更熟悉，因为以点开头的命名方法类似于我们写Java方法调用的方式。
- en: Calling a static method or function
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 调用静态方法或函数
- en: Being able to call methods and create objects gives us a great deal of power,
    with this simple construct we have gained a lot of power; we can now use most
    of the Java standard libraries and also the custom ones.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 能够调用方法和创建对象给了我们很大的权力，通过这个简单的结构，我们获得了许多权力；现在我们可以使用大多数Java标准库以及自定义库。
- en: However, we still need a few more things; one of the most important ones is
    calling static methods. The static methods have a feel similar to Clojure functions,
    there is no `this` instance, you can simply call them as normal Clojure functions.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们仍然需要一些其他的东西；其中最重要的一项是调用静态方法。静态方法的感觉类似于Clojure函数，没有`this`实例，你可以像调用正常的Clojure函数一样简单地调用它们。
- en: 'For instance, if we want an `emptyMap` from the `Collections` class, we can
    do it as shown:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果我们想从`Collections`类中获取一个`emptyMap`，我们可以按照以下方式操作：
- en: '[PRE12]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: You can think of static methods as functions and the class as a namespace. It
    is not exactly right but the mental model will help you understand it easily.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以把静态方法看作是函数，把类看作是一个命名空间。这并不完全正确，但这个心理模型将帮助你更容易地理解它。
- en: Accessing inner classes
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 访问内部类
- en: Another common doubt when using Java – Clojure interop is how to access inner
    classes.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Java-Clojure互操作时，另一个常见的疑问是如何访问内部类。
- en: Imagine you want to represent a single entry from a map with the `java.util.AbstractMap.SimpleEntry`
    class.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你想使用`java.util.AbstractMap.SimpleEntry`类来表示一个来自映射的单个条目。
- en: 'You might think that we have to do something similar to this:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会认为我们必须做类似这样的事情：
- en: '[PRE13]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'That''s what you will normally do when writing Java, but in Clojure you might
    need to do something such as this:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 这是你写Java时通常会做的事情，但在Clojure中你可能需要做类似这样的事情：
- en: '[PRE14]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'What we are seeing here is actually an exposed implementation detail; if you
    look at the classes in the JAR files or in your classpath, you will see the precise
    file name `AbstractMap$SimpleEntry`, as shown in the following screenshot:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里看到的是实际上是一个暴露的实现细节；如果你查看JAR文件中的类或你的类路径中的类，你会看到精确的文件名`AbstractMap$SimpleEntry`，如下面的截图所示：
- en: '![Accessing inner classes](img/00008.jpeg)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![访问内部类](img/00008.jpeg)'
- en: This is what you need to keep in mind, always prefix the inner classes with
    the parent (or more correctly containing) class (in this case `java.util.AbstractMap`)
    and the dollar sign.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 这是你需要记住的，总是用父类（或更准确地说，包含类）和美元符号作为内部类的开头（在这种情况下是`java.util.AbstractMap`）。
- en: Writing a simple image namespace
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写简单的图像命名空间
- en: Let's now write some Clojure code and create a file in `src/thumbnails/image.clj`.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们现在编写一些Clojure代码，并在`src/thumbnails/image.clj`中创建一个文件。
- en: 'Let''s try to do this the Clojure way. First of all, write the namespace declaration
    and evaluate it:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试用Clojure的方式来做这件事。首先，编写命名空间声明并评估它：
- en: '[PRE15]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Now open up a REPL and write the following code:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 现在打开REPL并编写以下代码：
- en: '[PRE16]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'We now have an image instance and you can call all of the Java methods in the
    REPL. This is one of Clojure''s core concepts, you can play with the REPL and
    check your code before really writing it and you can do it in an interactive way,
    as shown:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一个图像实例，你可以在REPL中调用所有的Java方法。这是Clojure的核心概念之一，你可以与REPL互动并检查你的代码，在真正编写它之前，你可以以交互式的方式进行，如下所示：
- en: '![Writing a simple image namespace](img/00009.jpeg)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![编写简单的图像命名空间](img/00009.jpeg)'
- en: 'In the end, we want to stickwith the following contents:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们希望坚持以下内容：
- en: '[PRE17]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Tip
  id: totrans-84
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: You can see that in this code we use the inner class syntax, with `Scalr$Mode`.
    Mode is not actually a class but an `enum`, you can use the same syntax for all
    other inner types.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到，在这段代码中我们使用了内部类语法，`Scalr$Mode`。模式实际上不是一个类，而是一个`enum`，你可以用相同的语法为所有其他内部类型使用。
- en: The code is pretty simple, it is very similar to what you've already seen; we'll
    go through the differences either way.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 代码相当简单，它与你已经看到的内容非常相似；我们将通过两种方式来探讨这些差异。
- en: 'You can import the following classes:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以导入以下类：
- en: '`javax.imageio.ImageIO`'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`javax.imageio.ImageIO`'
- en: '`java.awt.image.BufferedImageOp`'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`java.awt.image.BufferedImageOp`'
- en: '`org.imgscalr.Scalr`'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`org.imgscalr.Scalr`'
- en: '`org.imgscalr.Scalr.Mode`'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`org.imgscalr.Scalr.Mode`'
- en: You have to be careful with the `Mode` class, since it is an inner class (it
    is inside another class) Clojure uses the special name `Scalr$Mode`.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 你必须小心处理`Mode`类，因为它是一个内部类（它位于另一个类中），Clojure使用特殊的名称`Scalr$Mode`。
- en: Tip
  id: totrans-93
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: 'When importing inner classes, you have to be careful with the naming process,
    in Java you will use the name: `org.imgscalr.Scalr.Mode`; in Clojure you use the
    name: `org.imgscalr.Scalr$Mode`. The `load-image`, `save-image`, and `image-size`
    functions are self explanatory and the `generate-thumbnail` function is pretty
    simple as well; however, it has a special detail, it calls the following as the
    last argument:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 当导入内部类时，你必须小心命名过程，在Java中你将使用名称：`org.imgscalr.Scalr.Mode`；在Clojure中你使用名称：`org.imgscalr.Scalr$Mode`。`load-image`、`save-image`和`image-size`函数是自我解释的，而`generate-thumbnail`函数也很简单；然而，它有一个特殊细节，它将以下内容作为最后一个参数调用：
- en: '[PRE18]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: If you look at the ImageScalr javadoc, ([http://javadox.com/org.imgscalr/imgscalr-lib/4.2/org/imgscalr/Scalr.Mode.html](http://javadox.com/org.imgscalr/imgscalr-lib/4.2/org/imgscalr/Scalr.Mode.html))
    you can see that the `resize` method has several overloaded implementations; most
    of them have a `varargs` argument as their last argument. In Clojure, you have
    to declare these `varargs` arguments as an array.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你查看ImageScalr javadoc（[http://javadox.com/org.imgscalr/imgscalr-lib/4.2/org/imgscalr/Scalr.Mode.html](http://javadox.com/org.imgscalr/imgscalr-lib/4.2/org/imgscalr/Scalr.Mode.html)），你可以看到`resize`方法有几个重载实现；其中大多数都有`varargs`参数作为它们的最后一个参数。在Clojure中，你必须将这些`varargs`参数声明为数组。
- en: Writing the tests
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写测试
- en: Now that you have written your image processing code, it is a good time to write
    the tests.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经编写了图像处理代码，现在是编写测试的好时机。
- en: Let's just check if we can generate a thumbnail. Create a new `thumbnails.thumbnail-test`
    namespace, in the tests.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们检查一下是否可以生成缩略图。在测试中创建一个新的`thumbnails.thumbnail-test`命名空间。
- en: Remember, if you create the file, it must be named `test/thumbnails/thumbnail_test.clj`.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，如果你创建了文件，它必须命名为`test/thumbnails/thumbnail_test.clj`。
- en: 'Add the following contents to it:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下内容添加到其中：
- en: '[PRE19]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Here we are using some unknown features, such as the `let` form and destructuring.
    We will see this in more detail in the next section.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里我们使用了一些未知的功能，例如`let`形式和结构化。我们将在下一节中更详细地探讨这些内容。
- en: The let statement
  id: totrans-104
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 令语句
- en: Clojure gives us a `let` statement to name things; it allows us to do something
    very similar to variable declaration in other languages.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: Clojure提供了一个`let`语句来命名事物；它允许我们做类似于其他语言中变量声明的类似操作。
- en: 'Keep in mind that we are not actually creating a variable in the same sense,
    as in Java. In Java, whenever we declare a variable. We state that we want to
    reserve a certain amount of memory to store something in the later stages; it
    can be a value for primitives or a memory location for objects. What we do here
    is simply name a value. This is a local scope that is useful to write cleaner
    and easier to understand code. Lets have a look at how it works:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，我们实际上并没有以Java中相同的方式创建变量。在Java中，每当声明一个变量时，我们声明我们想要为后续阶段保留一定量的内存来存储某些东西；它可以是一个原始值的值或对象的内存位置。我们在这里所做的只是命名一个值。这是一个有用的局部作用域，可以编写更干净、更容易理解的代码。让我们看看它是如何工作的：
- en: '[PRE20]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'This is the simplest `let` statement that we could write and it is exactly
    the same as just writing `42`. However, we can write something a little more complex,
    such as this:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们可以写的最简单的`let`语句，它和直接写`42`完全一样。然而，我们可以写一些更复杂的，比如这个：
- en: '[PRE21]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'It looks self explanatory; to value `42` and `y,` we are assigning the value
    of multiplying `42` by `42`. In the end, we print `x is 42 and y 1764`. It is
    important to note two things here:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 这看起来很直观；将值`42`赋给`x`和`y`，我们实际上是将`42`乘以`42`的值赋给它们。最后，我们打印`x is 42 and y 1764`。这里有两个重要的事情需要注意：
- en: We can use a previously defined value in the `let` statement; for example, we
    use `x` when defining `y`.
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以在`let`语句中使用之前定义的值；例如，我们在定义`y`时使用`x`。
- en: The `let` statement creates a scope, we can't use `x` or `y` outside of our
    `let` statement.
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`let`语句创建了一个作用域，我们无法在`let`语句之外使用`x`或`y`。'
- en: 'The `let` statement can even be nested, we could do something similar to the
    following example:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '`let`语句甚至可以嵌套，我们可以做类似以下示例的事情：'
- en: '[PRE22]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: It is a bit more complicated, since we are opening an unneeded set of parentheses
    and also writing more code; however, it allows us to see how lexical scope works.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 它稍微复杂一些，因为我们打开了一组不必要的括号，并且写了更多的代码；然而，它允许我们看到词法作用域是如何工作的。
- en: 'Lets have a look at another interesting example:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看另一个有趣的例子：
- en: '[PRE23]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: In here, we are masking the value of `x` with `41` and again these are not variables.
    We are not changing a memory region, we are merely creating a new scope with a
    new *X* value.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们用`41`来遮蔽`x`的值，并且这些不是变量。我们并没有改变内存区域，我们只是在创建一个新的作用域，并赋予一个新的*X*值。
- en: 'Going back to our test, the `let` statement begins with the following code:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 回到我们的测试，`let`语句以以下代码开始：
- en: '[PRE24]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'It is pretty clear to understand, but the next line might prove a bit more
    difficult:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 它很容易理解，但下一行可能有点困难：
- en: '[PRE25]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: It looks pretty strange; we are assigning the value of (`image-size image`)
    to `[w _]` but `[w _]` is not a symbol name!
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 它看起来相当奇怪；我们将(`image-size image`)的值赋给`[w _]`，但`[w _]`不是一个符号名！
- en: What is happening here is that we are using a mechanism called destructuring
    to take the result of (`image-size image`) apart and just use the piece of information
    that we are interested in, which in this case is the width of the image.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 这里发生的事情是，我们正在使用一种称为解构的机制来分解(`image-size image`)的结果，并仅使用我们感兴趣的信息片段，在这种情况下是图像的宽度。
- en: 'Destructuring is one of the key features of Clojure, it can be used almost
    everywhere where symbol binding happens, such as:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 解构是Clojure的一个关键特性，它几乎可以在符号绑定发生的任何地方使用，例如：
- en: Let expressions
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 令表达式
- en: Function parameter lists
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数参数列表
- en: Destructuring helps write more concise code but it might strike you as strange
    when you are not used to it. Let's talk about it in depth in the next section.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 解构有助于编写更简洁的代码，但如果你不习惯它，可能会觉得有些奇怪。让我们在下一节深入讨论它。
- en: Destructuring in Clojure
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Clojure中的解构
- en: Destructuring is a feature in Clojure that is not common in other lisps; the
    idea is to allow you to write more concise code in scenarios where code doesn't
    really add value (for example, getting the first element from a list or the second
    parameter from a function) and concentrating only on what is important to you.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 解构是Clojure中一个在其他Lisp中不常见的特性；其想法是允许你在代码实际上没有增加价值的情况下编写更简洁的代码（例如，从列表中获取第一个元素或从函数中获取第二个参数），并只关注对你重要的事情。
- en: 'In order to understand this better, let''s see an example of why destructuring
    can help you:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地理解这一点，让我们看看解构如何帮助你的一个例子：
- en: '[PRE26]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: What's wrong with the previous code? Nothing really, but you need to start thinking
    about what is `v`, what the first value of `v` is, what the nth function does,
    and at what index `v` starts.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码有什么问题？实际上没有什么问题，但你需要开始思考`v`是什么，`v`的第一个值是什么，`nth`函数做什么，以及`v`从哪个索引开始。
- en: 'Instead we can do this:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以这样做：
- en: '[PRE27]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Once you are used to destructuring, you will see that you don't need to think
    about how to get the elements you need. In this case, we directly access the first,
    second, and third elements from our vector and use the first and third out of
    the three elements. With good naming it can become even easier.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你习惯了解构，你就会发现你不需要考虑如何获取你需要的元素。在这种情况下，我们直接从我们的向量中访问第一个、第二个和第三个元素，并使用这三个元素中的第一个和第三个。有了好的命名，这可以变得更加简单。
- en: Lets now take a deep dive into what destructuring is.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们深入探讨一下解构是什么。
- en: 'There are two types of destructuring:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 解构有两种类型：
- en: '**Sequential destructuring**: It allows us to take sequential data structures
    apart and bind the values that you are interested in directly to symbols'
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**顺序解构**：它允许我们将顺序数据结构拆分，并将你感兴趣的值直接绑定到符号'
- en: '**Associative destructuring**: It allows us to take maps apart and bind only
    the key reference values that you are interested in directly to symbols'
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**关联解构**：它允许我们将映射拆分，并将你感兴趣的键引用值直接绑定到符号'
- en: Sequential destructuring
  id: totrans-141
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 顺序解构
- en: 'Sequential destructuring should be easy to understand with some examples; lets
    have a look:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 通过一些示例，顺序解构应该很容易理解；让我们看看：
- en: '[PRE28]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: In these examples, as convention, we use `f` for first, `s` for second, `t`
    for third, and `a` for all the others.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些示例中，按照惯例，我们用`f`表示第一个，`s`表示第二个，`t`表示第三个，而`a`表示其他所有元素。
- en: 'The same destructuring idea and syntax can be used with function parameters,
    as shown in the next example:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 同样的解构思想和语法也可以用于函数参数，如下一个示例所示：
- en: '[PRE29]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Note
  id: totrans-147
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Here we use the symbol `_`, there is a convention in Clojure to use the `_`
    symbol whenever you are not interested in some value and you don't need to use
    it in the future. In the previous example, we aren't interested in the second
    parameter of the `func` function.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里我们使用符号`_`，Clojure中有一个惯例，即当你对某个值不感兴趣且将来不需要使用它时，使用`_`符号。在上一个示例中，我们对`func`函数的第二个参数不感兴趣。
- en: As you can see, it lets us write a much more concise code and focus only on
    what's important, which is the algorithm or business.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，它让我们能够编写更简洁的代码，只关注重要的部分，即算法或业务。
- en: Associative destructuring
  id: totrans-150
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 关联解构
- en: We've already seen sequential destructuring that allows getting certain elements
    of a sequence by index. In Clojure, there is also associative destructuring, which
    allows you to take just the keys of the map in which you are interested.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了顺序解构，它允许通过索引获取序列的某些元素。在Clojure中，还有关联解构，它允许你只获取你感兴趣的映射中的键。
- en: 'Again, an example is worth more than a thousand words:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，一个例子胜过千言万语：
- en: '[PRE30]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Tip
  id: totrans-154
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Thinking of symbols as keys to a map can feel strange, nonetheless it is important
    to remember this feature; it could come in handy at some point.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 将符号视为映射的键可能感觉有些奇怪，但重要的是要记住这个功能；它可能在某个时候派上用场。
- en: 'As you can see, it''s pretty simple too, but we have a few more options:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，这也很简单，但我们有更多选项：
- en: We can reference some keys and assigning them a name, as shown in the first
    and second example
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以引用一些键并给它们命名，如第一个和第二个示例所示
- en: We can reference keyword keys, as in the third example
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以引用关键字键，如第三个示例所示
- en: We can reference string keys, as in the fourth example
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以引用字符串键，如第四个示例所示
- en: We can define default values with the `:or` keyword!
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以使用`:or`关键字定义默认值！
- en: Destructuring is one of the most used features of Clojure and it allows you
    to write very concise code.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 解构是Clojure最常用的功能之一，它允许你编写非常简洁的代码。
- en: 'Going back to our test code, it should now be pretty easy to understand the
    get-`image-width` function:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 回到我们的测试代码，现在应该很容易理解`get-image-width`函数：
- en: '[PRE31]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: As you can see, it sets the image value as the loaded image and then it calculates
    the width, gets the width only and returns that value.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，它将图像值设置为加载的图像，然后计算宽度，只获取宽度并返回该值。
- en: 'We can now understand the `test-load-image` test:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以理解`test-load-image`测试：
- en: '[PRE32]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: It just initializes an `image-stream` value, it then loads an image from that
    stream and generates a thumbnail. It finally loads the generated thumbnail and
    checks that the image width is 50px.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 它只是初始化了一个 `image-stream` 值，然后从这个流中加载一个图像并生成缩略图。最后，它加载生成的缩略图并检查图像宽度是否为 50px。
- en: Now that we've written our tests and we are sure that everything works, we can
    use our little library from the Clojure projects, but what happens if we want
    to use it from a pure Java (or groovy, or scala) project?
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经编写了测试，并且我们确信一切正常，我们可以从 Clojure 项目中使用我们的小型库，但如果我们想从纯 Java（或 groovy，或 scala）项目中使用它会发生什么呢？
- en: Exposing your code to Java
  id: totrans-169
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将你的代码暴露给 Java
- en: 'If you want to be able to use Clojure code from other JVM languages, in Clojure,
    there are a couple of ways in which you can do it:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你希望能够从其他 JVM 语言中使用 Clojure 代码，在 Clojure 中，有几种方法可以实现：
- en: You can generate new Java classes and use them as you normally would; it can
    implement some interface or extend from some other class
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以生成新的 Java 类，并像通常一样使用它们；它可以实现某些接口或从某些其他类扩展。
- en: You can generate a proxy on the fly, this way you can implement a contract (in
    the form of a class or an interface) that some framework requires with little
    code and effort
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以即时生成代理，这样你就可以用很少的代码和努力实现一些框架所需的合约（以类或接口的形式）。
- en: You can use the `clojure.java.api` package to call Clojure functions directly
    from Java
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以使用 `clojure.java.api` 包直接从 Java 调用 Clojure 函数。
- en: Note
  id: totrans-174
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'You can find more information on how this works at the following location:
    [http://www.falkoriemenschneider.de/a__2014-03-22__Add-Awesomeness-to-your-Legacy-Java.html](http://www.falkoriemenschneider.de/a__2014-03-22__Add-Awesomeness-to-your-Legacy-Java.html).'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在以下位置找到更多关于如何实现的信息：[http://www.falkoriemenschneider.de/a__2014-03-22__Add-Awesomeness-to-your-Legacy-Java.html](http://www.falkoriemenschneider.de/a__2014-03-22__Add-Awesomeness-to-your-Legacy-Java.html)。
- en: Let's have a look at how we can define a Java class.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们如何定义一个 Java 类。
- en: 'Create a new namespace called `thumbnails.image-java` and write the following
    code:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个名为 `thumbnails.image-java` 的新命名空间，并编写以下代码：
- en: '[PRE33]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: This code is very similar to the Clojure code that we have already seen, except
    for the `gen-class` directive and the function names starting with a dash.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码与我们已经见过的 Clojure 代码非常相似，只是多了 `gen-class` 指令和以破折号开头的函数名。
- en: 'Let''s review the `gem-class` in better detail:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更详细地回顾一下 `gen-class`：
- en: '[PRE34]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: When the Clojure compiler sees this, it generates the byte code of a class but
    it needs a little help from the keywords to know how to generate the class.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 当 Clojure 编译器看到这个时，它会生成类的字节码，但它需要一点关键词的帮助来知道如何生成类。
- en: The name key defines the name of the class, it is a symbol
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 名称键定义了类的名称，它是一个符号。
- en: The main key defines whether this class should have a main method or not
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 主键定义了这个类是否应该有一个主方法。
- en: 'The method key defines all the methods and their signatures, it is a vector
    with three parts: `[methodName [parameterTypes] returnType]`'
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 方法键定义了所有方法和它们的签名，它是一个包含三个部分的向量：`[methodName [parameterTypes] returnType]`
- en: The methods are then implemented as functions starting with the (`-`) character,
    the prefix can be changed with the prefix key.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 然后方法作为以 (`-`) 字符开头的函数实现，前缀可以通过前缀键更改。
- en: You also need to tell Clojure to compile this class in advance, in Leiningen
    it can be achieved with `:aot`, go to your `project.clj` file and add an `:aot`
    key with the namespace or namespaces to be compiled in a vector; if you want everything
    to be compiled in advance, you could use the special `:all` value.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 你还需要告诉 Clojure 提前编译这个类，在 Leiningen 中，可以通过 `:aot` 实现，转到你的 `project.clj` 文件，并添加一个
    `:aot` 键，指定要编译的命名空间或命名空间列表；如果你希望所有内容都提前编译，可以使用特殊的 `:all` 值。
- en: 'In the end, you should have something similar to this:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你应该会有类似以下内容：
- en: '![Exposing your code to Java](img/00010.jpeg)'
  id: totrans-189
  prefs: []
  type: TYPE_IMG
  zh: '![将你的代码暴露给 Java](img/00010.jpeg)'
- en: Tip
  id: totrans-190
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: If you want all of your code to be compiled in advance, you can use `:aot :all`
    in your `project.clj`.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你希望所有代码都提前编译，你可以在 `project.clj` 中使用 `:aot :all`。
- en: 'Now, we can install our library to our Maven local repository. Go to the command
    line and run:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以将我们的库安装到我们的 Maven 本地仓库中。转到命令行并运行：
- en: '[PRE35]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'You''ll get an output similar to the following screenshot:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 你会得到类似于以下截图的输出：
- en: '![Exposing your code to Java](img/00011.jpeg)'
  id: totrans-195
  prefs: []
  type: TYPE_IMG
  zh: '![将你的代码暴露给 Java](img/00011.jpeg)'
- en: Now, you are good to go; you should have a `thumbnails:thumbnails:0.1.0-SNAPSHOT`
    dependency in your Maven local repository.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你已经准备好了；你应该在你的 Maven 本地仓库中有 `thumbnails:thumbnails:0.1.0-SNAPSHOT` 依赖项。
- en: Testing from Groovy
  id: totrans-197
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从 Groovy 进行测试
- en: In order to see how this works with several JVM languages, we will use Groovy
    and Gradle to test. We can use Java and Maven just as easily. Remember that you
    can get the source from the code bundle so that you don't need to know everything
    that's happening here.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 为了看到这如何与多种 JVM 语言一起工作，我们将使用 Groovy 和 Gradle 进行测试。我们同样可以轻松地使用 Java 和 Maven。记住，你可以从代码包中获取源代码，这样你就不需要了解这里发生的一切。
- en: 'There are two files here; in the `build.gradle` file, we specify that we want
    to use our local Maven repository and we specify our dependency, as:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有两个文件；在 `build.gradle` 文件中，我们指定我们想要使用我们的本地 Maven 仓库，并指定我们的依赖项，如下所示：
- en: '[PRE36]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Then we can write our test, as the following code:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以编写我们的测试，如下面的代码所示：
- en: '[PRE37]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'You can then run the tests:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你可以运行测试：
- en: '[PRE38]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: As you can see, it is very easy to run your code from Java, Groovy, or even
    Scala. There are other ways to use Clojure with Java, particularly, if you want
    to implement an interface or generate a class dynamically.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，从 Java、Groovy 或甚至 Scala 运行你的代码非常简单。还有其他方法可以将 Clojure 与 Java 结合使用，特别是如果你想要实现一个接口或动态生成一个类。
- en: Proxy and reify
  id: totrans-206
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 代理和具体化
- en: 'There are situations when you are interacting with Java libraries, where you
    must send an instance of a specific Java class to some method; writing a class
    isn''t the best option, you should rather create an instance that conforms to
    a contract expected by some framework on the fly. We have two options to do this:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 在与 Java 库交互的情况下，有时你必须向某个方法发送一个特定 Java 类的实例；编写一个类并不是最佳选择，你更应该创建一个即时符合某些框架预期契约的实例。我们有两个选项来完成这个任务：
- en: '**Proxy**: It allows you to implement a Java interface or extend from some
    super class. In reality, it creates a new object that calls your Clojure functions
    when needed'
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**代理**：它允许你实现 Java 接口或从某个超类扩展。实际上，它创建了一个新对象，当需要时调用你的 Clojure 函数。'
- en: '**Reify**: Reify allows you to implement interfaces and Clojure protocols (we
    will see them later). It is not capable of extending classes. It is a better performant
    than the proxy and should be used whenever possible.'
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**具体化**：具体化允许你实现接口和 Clojure 协议（我们稍后会看到）。它不能扩展类。它的性能比代理更好，应该尽可能使用。'
- en: 'Let''s look at a minimal example:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个最小示例：
- en: '[PRE39]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Tip
  id: totrans-212
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '`doto` is a macro that allows us to call several methods on an instance; you
    can think of it as a way to call all of the methods separately. It works great
    with Java Beans!'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '`doto` 是一个宏，允许我们在一个实例上调用多个方法；你可以将其视为分别调用所有方法的一种方式。它与 Java Beans 结合得很好！'
- en: 'Open up an REPL and write the code; it should show a window with a button that
    prints `Hello world` (in the terminal) when clicked:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 打开一个 REPL 并编写代码；它应该显示一个包含按钮的窗口，当点击按钮时（在终端中）会打印 `Hello world`：
- en: '![Proxy and reify](img/00012.jpeg)'
  id: totrans-215
  prefs: []
  type: TYPE_IMG
  zh: '![代理和具体化](img/00012.jpeg)'
- en: If you are familiar with swing, then you know that the `addActionListener` of
    `JButton` needs a callback which is an instance of `ActionListener` and we are
    creating said instance with the `reify` function.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你熟悉 Swing，那么你知道 `JButton` 的 `addActionListener` 需要一个回调，即 `ActionListener`
    的实例，而我们正是通过 `reify` 函数创建这个实例的。
- en: 'In Java code, you might normally do something similar to the following code:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Java 代码中，你可能会做类似以下代码的事情：
- en: '[PRE40]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'We call this an anonymous class and it is essentially the same as a closure
    in functional languages. In the previous example, the code was replaced by a reify:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 我们称之为匿名类，它本质上与函数式语言中的闭包相同。在上一个例子中，代码被具体化所取代：
- en: '[PRE41]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: The `reify` statement receives the interface that you are implementing and all
    the methods that you are implementing as you list. In this case, we just implement
    `actionPerformed` to receive the action event.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '`reify` 语句接收你要实现的接口以及你按列表实现的所有方法。在这种情况下，我们只实现了 `actionPerformed` 来接收动作事件。'
- en: 'This is the structure:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 这是结构：
- en: '[PRE42]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: This creates an instance of `ActionListener`, you can do the same with servlets,
    threads, collections, lists, or any other Java interface defined by anyone.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 这将创建一个 `ActionListener` 的实例，你可以用相同的方式处理 servlets、线程、集合、列表或任何其他人定义的 Java 接口。
- en: One particular thing that you need to remember here is that you need to always
    add `self` as the first parameter to your method implementations; it takes the
    place of the `this` keyword that works in Java.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你需要记住的一件特别的事情是，你需要在方法实现中始终将 `self` 作为第一个参数添加；它取代了在 Java 中工作的 `this` 关键字。
- en: Summary
  id: totrans-226
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you have gained a lot of power from Clojure with a few new
    primitives.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，你通过一些新的基本操作获得了 Clojure 的很多力量。
- en: 'As you can see, there are plenty of ways to interact with your current codebase;
    specifically, you can now:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，与你的现有代码库交互的方式有很多；具体来说，你现在可以：
- en: Use Java code from Clojure
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Clojure 代码中的 Java 代码
- en: Use Clojure code from Java
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Java 代码中的 Clojure 代码
- en: Reuse Java frameworks by creating objects that adhere to their contracts
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过创建遵守其契约的对象来重用 Java 框架
- en: With all of our new tools in mind, we are ready to tackle more concepts and
    a little bit more complexity with collections and data structures.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到我们所有的全新工具，我们现在准备处理更多概念以及稍微多一点的数据集合和数据结构复杂性。
