- en: Chapter 3. Interacting with Java
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We know a bit about how to organize our code and how that relates to packages
    in Java. Now, you surely need to use your old Java code and all the libraries
    you already know; Clojure encourages a new way to think about programming and
    it also allows you to use all the dependencies and code that you've already generated.
  prefs: []
  type: TYPE_NORMAL
- en: Clojure is a **Java Virtual Machine** (**JVM**) language and as such it is compatible
    with most Java dependencies and libraries out there; you should be able to use
    all the tools out there. You should also be able to use your Clojure programs
    with Java-only programs, this requires a bit of custom coding but in the end you
    can use Clojure in the right places of your project.
  prefs: []
  type: TYPE_NORMAL
- en: 'To be able to do this, we''ll have to learn:'
  prefs: []
  type: TYPE_NORMAL
- en: Using Maven dependencies
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using plain old Java classes from your Clojure code base
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A bit more about the Clojure language, in particular the `let` statements and
    destructuring
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a Java interface for your Clojure code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the Java interface from other Java projects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using Maven dependencies
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's say that we want to write an image manipulation program; it is a very
    simple program that should be able to create thumbnails. Most of our codebase
    is in Clojure, so we want to write this in Clojure too.
  prefs: []
  type: TYPE_NORMAL
- en: There are a bunch of Java libraries meant to manipulate images, we decide to
    use imgscalr, which is very simple to use and it looks like it is available in
    Maven Central ([http://search.maven.org/](http://search.maven.org/)).
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create a new Leiningen project, as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we need to edit the `project.clj` file in the thumbnails project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'You can add the `imgscalr` dependency similar to the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, you just need to add a dependency to the `:dependencies` vector,
    the dependencies are automatically resolved from:'
  prefs: []
  type: TYPE_NORMAL
- en: Maven Local
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Maven Central
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Clojars
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The Maven Local points to your local maven repository that is in the `~/.m2`
    folder. If you wish, you can change it with Leiningen's `:local-repo` key.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can add your own repositories, let''s say you need to add **jcenter** (Bintray''s
    Java repository) you can do so, as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Leiningen supports a wide array of options to configure your project, for more
    information you can check the sample at Leiningen''s official repository: [https://github.com/technomancy/leiningen/blob/master/sample.project.clj](https://github.com/technomancy/leiningen/blob/master/sample.project.clj).'
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to download the dependencies, you have to execute the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You don't need to execute `lein deps` every time you want to download dependencies,
    you can do it to force a download but Leiningen will automatically download them
    when it needs to.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can check the current dependencies by running:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'You will get something similar to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: This lists your current dependency tree.
  prefs: []
  type: TYPE_NORMAL
- en: Clojure interop syntax
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Clojure was designed to be a Hosted Language, which means that it can run in
    different environments or runtimes. One important philosophy aspect is that Clojure
    does not attempt to get in the way of your original host; this allows you to use
    your knowledge of the underlying platform to your advantage.
  prefs: []
  type: TYPE_NORMAL
- en: In this case, we are using the Java platform. Let's look at the basic interrupt
    syntax that we need to know.
  prefs: []
  type: TYPE_NORMAL
- en: Creating an object
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are two ways to create an object in Clojure; for example, let's have a
    look at how to create an instance of `java.util.ArrayList`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Here, we are using the `new` special form, as you can see it receives a symbol
    (the name of the class `java.util.ArrayList`) and in this case it is an integer.
  prefs: []
  type: TYPE_NORMAL
- en: The symbol `java.util.ArrayList` represents the `classname` and any Java class
    name will do here.
  prefs: []
  type: TYPE_NORMAL
- en: Next, you can actually pass any number of parameters (including `0` parameters).
    The next parameters are the parameters of the constructor.
  prefs: []
  type: TYPE_NORMAL
- en: 'Lets have a look at the other special syntax that is available to create objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The difference here is that we have a trailing dot; we prefer to see this syntax
    since it is shorter.
  prefs: []
  type: TYPE_NORMAL
- en: Calling an instance method
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Once we have created our object we can call instance methods. This is done similar
    to how we call Clojure functions, using the special dot form.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we want to add an element to our newly created list, we will have to do
    it, as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'This syntax might look a little strange; here is how this syntax is formed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Similar to the two different options that we had when creating an object, we
    have another way to do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: You might think that this is more familiar, since the method name starting with
    a dot resembles how we write the Java method calls.
  prefs: []
  type: TYPE_NORMAL
- en: Calling a static method or function
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Being able to call methods and create objects gives us a great deal of power,
    with this simple construct we have gained a lot of power; we can now use most
    of the Java standard libraries and also the custom ones.
  prefs: []
  type: TYPE_NORMAL
- en: However, we still need a few more things; one of the most important ones is
    calling static methods. The static methods have a feel similar to Clojure functions,
    there is no `this` instance, you can simply call them as normal Clojure functions.
  prefs: []
  type: TYPE_NORMAL
- en: 'For instance, if we want an `emptyMap` from the `Collections` class, we can
    do it as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: You can think of static methods as functions and the class as a namespace. It
    is not exactly right but the mental model will help you understand it easily.
  prefs: []
  type: TYPE_NORMAL
- en: Accessing inner classes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Another common doubt when using Java – Clojure interop is how to access inner
    classes.
  prefs: []
  type: TYPE_NORMAL
- en: Imagine you want to represent a single entry from a map with the `java.util.AbstractMap.SimpleEntry`
    class.
  prefs: []
  type: TYPE_NORMAL
- en: 'You might think that we have to do something similar to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'That''s what you will normally do when writing Java, but in Clojure you might
    need to do something such as this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'What we are seeing here is actually an exposed implementation detail; if you
    look at the classes in the JAR files or in your classpath, you will see the precise
    file name `AbstractMap$SimpleEntry`, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Accessing inner classes](img/00008.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: This is what you need to keep in mind, always prefix the inner classes with
    the parent (or more correctly containing) class (in this case `java.util.AbstractMap`)
    and the dollar sign.
  prefs: []
  type: TYPE_NORMAL
- en: Writing a simple image namespace
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's now write some Clojure code and create a file in `src/thumbnails/image.clj`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s try to do this the Clojure way. First of all, write the namespace declaration
    and evaluate it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Now open up a REPL and write the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'We now have an image instance and you can call all of the Java methods in the
    REPL. This is one of Clojure''s core concepts, you can play with the REPL and
    check your code before really writing it and you can do it in an interactive way,
    as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Writing a simple image namespace](img/00009.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'In the end, we want to stickwith the following contents:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can see that in this code we use the inner class syntax, with `Scalr$Mode`.
    Mode is not actually a class but an `enum`, you can use the same syntax for all
    other inner types.
  prefs: []
  type: TYPE_NORMAL
- en: The code is pretty simple, it is very similar to what you've already seen; we'll
    go through the differences either way.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can import the following classes:'
  prefs: []
  type: TYPE_NORMAL
- en: '`javax.imageio.ImageIO`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`java.awt.image.BufferedImageOp`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`org.imgscalr.Scalr`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`org.imgscalr.Scalr.Mode`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You have to be careful with the `Mode` class, since it is an inner class (it
    is inside another class) Clojure uses the special name `Scalr$Mode`.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'When importing inner classes, you have to be careful with the naming process,
    in Java you will use the name: `org.imgscalr.Scalr.Mode`; in Clojure you use the
    name: `org.imgscalr.Scalr$Mode`. The `load-image`, `save-image`, and `image-size`
    functions are self explanatory and the `generate-thumbnail` function is pretty
    simple as well; however, it has a special detail, it calls the following as the
    last argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: If you look at the ImageScalr javadoc, ([http://javadox.com/org.imgscalr/imgscalr-lib/4.2/org/imgscalr/Scalr.Mode.html](http://javadox.com/org.imgscalr/imgscalr-lib/4.2/org/imgscalr/Scalr.Mode.html))
    you can see that the `resize` method has several overloaded implementations; most
    of them have a `varargs` argument as their last argument. In Clojure, you have
    to declare these `varargs` arguments as an array.
  prefs: []
  type: TYPE_NORMAL
- en: Writing the tests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that you have written your image processing code, it is a good time to write
    the tests.
  prefs: []
  type: TYPE_NORMAL
- en: Let's just check if we can generate a thumbnail. Create a new `thumbnails.thumbnail-test`
    namespace, in the tests.
  prefs: []
  type: TYPE_NORMAL
- en: Remember, if you create the file, it must be named `test/thumbnails/thumbnail_test.clj`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following contents to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Here we are using some unknown features, such as the `let` form and destructuring.
    We will see this in more detail in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: The let statement
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Clojure gives us a `let` statement to name things; it allows us to do something
    very similar to variable declaration in other languages.
  prefs: []
  type: TYPE_NORMAL
- en: 'Keep in mind that we are not actually creating a variable in the same sense,
    as in Java. In Java, whenever we declare a variable. We state that we want to
    reserve a certain amount of memory to store something in the later stages; it
    can be a value for primitives or a memory location for objects. What we do here
    is simply name a value. This is a local scope that is useful to write cleaner
    and easier to understand code. Lets have a look at how it works:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'This is the simplest `let` statement that we could write and it is exactly
    the same as just writing `42`. However, we can write something a little more complex,
    such as this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'It looks self explanatory; to value `42` and `y,` we are assigning the value
    of multiplying `42` by `42`. In the end, we print `x is 42 and y 1764`. It is
    important to note two things here:'
  prefs: []
  type: TYPE_NORMAL
- en: We can use a previously defined value in the `let` statement; for example, we
    use `x` when defining `y`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `let` statement creates a scope, we can't use `x` or `y` outside of our
    `let` statement.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `let` statement can even be nested, we could do something similar to the
    following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: It is a bit more complicated, since we are opening an unneeded set of parentheses
    and also writing more code; however, it allows us to see how lexical scope works.
  prefs: []
  type: TYPE_NORMAL
- en: 'Lets have a look at another interesting example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: In here, we are masking the value of `x` with `41` and again these are not variables.
    We are not changing a memory region, we are merely creating a new scope with a
    new *X* value.
  prefs: []
  type: TYPE_NORMAL
- en: 'Going back to our test, the `let` statement begins with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'It is pretty clear to understand, but the next line might prove a bit more
    difficult:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: It looks pretty strange; we are assigning the value of (`image-size image`)
    to `[w _]` but `[w _]` is not a symbol name!
  prefs: []
  type: TYPE_NORMAL
- en: What is happening here is that we are using a mechanism called destructuring
    to take the result of (`image-size image`) apart and just use the piece of information
    that we are interested in, which in this case is the width of the image.
  prefs: []
  type: TYPE_NORMAL
- en: 'Destructuring is one of the key features of Clojure, it can be used almost
    everywhere where symbol binding happens, such as:'
  prefs: []
  type: TYPE_NORMAL
- en: Let expressions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Function parameter lists
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Destructuring helps write more concise code but it might strike you as strange
    when you are not used to it. Let's talk about it in depth in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Destructuring in Clojure
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Destructuring is a feature in Clojure that is not common in other lisps; the
    idea is to allow you to write more concise code in scenarios where code doesn't
    really add value (for example, getting the first element from a list or the second
    parameter from a function) and concentrating only on what is important to you.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to understand this better, let''s see an example of why destructuring
    can help you:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: What's wrong with the previous code? Nothing really, but you need to start thinking
    about what is `v`, what the first value of `v` is, what the nth function does,
    and at what index `v` starts.
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead we can do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Once you are used to destructuring, you will see that you don't need to think
    about how to get the elements you need. In this case, we directly access the first,
    second, and third elements from our vector and use the first and third out of
    the three elements. With good naming it can become even easier.
  prefs: []
  type: TYPE_NORMAL
- en: Lets now take a deep dive into what destructuring is.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two types of destructuring:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Sequential destructuring**: It allows us to take sequential data structures
    apart and bind the values that you are interested in directly to symbols'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Associative destructuring**: It allows us to take maps apart and bind only
    the key reference values that you are interested in directly to symbols'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sequential destructuring
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Sequential destructuring should be easy to understand with some examples; lets
    have a look:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: In these examples, as convention, we use `f` for first, `s` for second, `t`
    for third, and `a` for all the others.
  prefs: []
  type: TYPE_NORMAL
- en: 'The same destructuring idea and syntax can be used with function parameters,
    as shown in the next example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Here we use the symbol `_`, there is a convention in Clojure to use the `_`
    symbol whenever you are not interested in some value and you don't need to use
    it in the future. In the previous example, we aren't interested in the second
    parameter of the `func` function.
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, it lets us write a much more concise code and focus only on
    what's important, which is the algorithm or business.
  prefs: []
  type: TYPE_NORMAL
- en: Associative destructuring
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We've already seen sequential destructuring that allows getting certain elements
    of a sequence by index. In Clojure, there is also associative destructuring, which
    allows you to take just the keys of the map in which you are interested.
  prefs: []
  type: TYPE_NORMAL
- en: 'Again, an example is worth more than a thousand words:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Thinking of symbols as keys to a map can feel strange, nonetheless it is important
    to remember this feature; it could come in handy at some point.
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see, it''s pretty simple too, but we have a few more options:'
  prefs: []
  type: TYPE_NORMAL
- en: We can reference some keys and assigning them a name, as shown in the first
    and second example
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can reference keyword keys, as in the third example
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can reference string keys, as in the fourth example
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can define default values with the `:or` keyword!
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Destructuring is one of the most used features of Clojure and it allows you
    to write very concise code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Going back to our test code, it should now be pretty easy to understand the
    get-`image-width` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, it sets the image value as the loaded image and then it calculates
    the width, gets the width only and returns that value.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can now understand the `test-load-image` test:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: It just initializes an `image-stream` value, it then loads an image from that
    stream and generates a thumbnail. It finally loads the generated thumbnail and
    checks that the image width is 50px.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we've written our tests and we are sure that everything works, we can
    use our little library from the Clojure projects, but what happens if we want
    to use it from a pure Java (or groovy, or scala) project?
  prefs: []
  type: TYPE_NORMAL
- en: Exposing your code to Java
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If you want to be able to use Clojure code from other JVM languages, in Clojure,
    there are a couple of ways in which you can do it:'
  prefs: []
  type: TYPE_NORMAL
- en: You can generate new Java classes and use them as you normally would; it can
    implement some interface or extend from some other class
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can generate a proxy on the fly, this way you can implement a contract (in
    the form of a class or an interface) that some framework requires with little
    code and effort
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can use the `clojure.java.api` package to call Clojure functions directly
    from Java
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You can find more information on how this works at the following location:
    [http://www.falkoriemenschneider.de/a__2014-03-22__Add-Awesomeness-to-your-Legacy-Java.html](http://www.falkoriemenschneider.de/a__2014-03-22__Add-Awesomeness-to-your-Legacy-Java.html).'
  prefs: []
  type: TYPE_NORMAL
- en: Let's have a look at how we can define a Java class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new namespace called `thumbnails.image-java` and write the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: This code is very similar to the Clojure code that we have already seen, except
    for the `gen-class` directive and the function names starting with a dash.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s review the `gem-class` in better detail:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: When the Clojure compiler sees this, it generates the byte code of a class but
    it needs a little help from the keywords to know how to generate the class.
  prefs: []
  type: TYPE_NORMAL
- en: The name key defines the name of the class, it is a symbol
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The main key defines whether this class should have a main method or not
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The method key defines all the methods and their signatures, it is a vector
    with three parts: `[methodName [parameterTypes] returnType]`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The methods are then implemented as functions starting with the (`-`) character,
    the prefix can be changed with the prefix key.
  prefs: []
  type: TYPE_NORMAL
- en: You also need to tell Clojure to compile this class in advance, in Leiningen
    it can be achieved with `:aot`, go to your `project.clj` file and add an `:aot`
    key with the namespace or namespaces to be compiled in a vector; if you want everything
    to be compiled in advance, you could use the special `:all` value.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the end, you should have something similar to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Exposing your code to Java](img/00010.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you want all of your code to be compiled in advance, you can use `:aot :all`
    in your `project.clj`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we can install our library to our Maven local repository. Go to the command
    line and run:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'You''ll get an output similar to the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Exposing your code to Java](img/00011.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Now, you are good to go; you should have a `thumbnails:thumbnails:0.1.0-SNAPSHOT`
    dependency in your Maven local repository.
  prefs: []
  type: TYPE_NORMAL
- en: Testing from Groovy
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In order to see how this works with several JVM languages, we will use Groovy
    and Gradle to test. We can use Java and Maven just as easily. Remember that you
    can get the source from the code bundle so that you don't need to know everything
    that's happening here.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two files here; in the `build.gradle` file, we specify that we want
    to use our local Maven repository and we specify our dependency, as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we can write our test, as the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'You can then run the tests:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, it is very easy to run your code from Java, Groovy, or even
    Scala. There are other ways to use Clojure with Java, particularly, if you want
    to implement an interface or generate a class dynamically.
  prefs: []
  type: TYPE_NORMAL
- en: Proxy and reify
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are situations when you are interacting with Java libraries, where you
    must send an instance of a specific Java class to some method; writing a class
    isn''t the best option, you should rather create an instance that conforms to
    a contract expected by some framework on the fly. We have two options to do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Proxy**: It allows you to implement a Java interface or extend from some
    super class. In reality, it creates a new object that calls your Clojure functions
    when needed'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Reify**: Reify allows you to implement interfaces and Clojure protocols (we
    will see them later). It is not capable of extending classes. It is a better performant
    than the proxy and should be used whenever possible.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s look at a minimal example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`doto` is a macro that allows us to call several methods on an instance; you
    can think of it as a way to call all of the methods separately. It works great
    with Java Beans!'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open up an REPL and write the code; it should show a window with a button that
    prints `Hello world` (in the terminal) when clicked:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Proxy and reify](img/00012.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: If you are familiar with swing, then you know that the `addActionListener` of
    `JButton` needs a callback which is an instance of `ActionListener` and we are
    creating said instance with the `reify` function.
  prefs: []
  type: TYPE_NORMAL
- en: 'In Java code, you might normally do something similar to the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'We call this an anonymous class and it is essentially the same as a closure
    in functional languages. In the previous example, the code was replaced by a reify:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: The `reify` statement receives the interface that you are implementing and all
    the methods that you are implementing as you list. In this case, we just implement
    `actionPerformed` to receive the action event.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is the structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: This creates an instance of `ActionListener`, you can do the same with servlets,
    threads, collections, lists, or any other Java interface defined by anyone.
  prefs: []
  type: TYPE_NORMAL
- en: One particular thing that you need to remember here is that you need to always
    add `self` as the first parameter to your method implementations; it takes the
    place of the `this` keyword that works in Java.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you have gained a lot of power from Clojure with a few new
    primitives.
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see, there are plenty of ways to interact with your current codebase;
    specifically, you can now:'
  prefs: []
  type: TYPE_NORMAL
- en: Use Java code from Clojure
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use Clojure code from Java
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reuse Java frameworks by creating objects that adhere to their contracts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With all of our new tools in mind, we are ready to tackle more concepts and
    a little bit more complexity with collections and data structures.
  prefs: []
  type: TYPE_NORMAL
