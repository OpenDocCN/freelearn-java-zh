<html><head></head><body>
<div id="page" style="height:0pt"/><div class="book" title="Chapter&#xA0;5.&#xA0;Plugin Commands" id="1565U1-b66e70deee6e4ed481db4b113e303f23"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch05" class="calibre1"/>Chapter 5. Plugin Commands</h1></div></div></div><p class="calibre8">The nice thing about the Bukkit API is that it has the basic features already built into its framework. As programmers, we need not go out of our way to implement these basic features into plugins. In this chapter, we will discuss one of these features, namely the in-game commands that can be executed by a player. These are similar to the commands that you are already familiar with, such as <code class="email">/reload</code>, <code class="email">/gamemode</code>, or <code class="email">/give</code>. We will create a plugin that will <span class="strong"><em class="calibre9">enchant</em></span> an item. By the end of this chapter, once the plugin is complete, you will be able to type <code class="email">/enchant</code> to add your favorite enchantments to the item in your hand.</p><p class="calibre8">Commands are one of the easiest ways for players to communicate with a plugin. They also allow players to trigger the execution of a plugin's code. For these reasons, most plugins will have some sort of command. The Bukkit development team realized this and provided us with a simple way to register commands. Registering commands through Bukkit ensures that a plugin will know when a player types a command. It also prevents a plugin from having conflicts with another plugin's commands. The following are the three steps that we will cover to add a command to a plugin:</p><div class="book"><ul class="itemizedlist"><li class="listitem">Informing Bukkit that a plugin will be using a command</li><li class="listitem">Programming what a plugin will do when someone types a command</li><li class="listitem">Assigning newly written code to a specific command</li></ul></div></div>

<div class="book" title="Chapter&#xA0;5.&#xA0;Plugin Commands" id="1565U1-b66e70deee6e4ed481db4b113e303f23">
<div class="book" title="Adding a command to plugin.yml"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_1"><a id="ch05lvl1sec33" class="calibre1"/>Adding a command to plugin.yml</h1></div></div></div><p class="calibre8">Create a <a id="id128" class="calibre1"/>new Bukkit plugin as you did in <a class="calibre1" title="Chapter 3. Creating Your First Bukkit Plugin" href="part0026_split_000.html#OPEK1-b66e70deee6e4ed481db4b113e303f23">Chapter 3</a>, <span class="strong"><em class="calibre9">Creating Your First Bukkit Plugin</em></span>, but name it <code class="email">Enchanter</code>. Alternatively, you can create<a id="id129" class="calibre1"/> a copy of your existing project and modify the name, package, and so on in order to create a new plugin. This will eliminate the need to add the required libraries and configure the build script. A project can be copied by performing the following steps:</p><div class="book"><ol class="orderedlist"><li class="listitem" value="1">Right-click on the project that you wish to copy and select <span class="strong"><strong class="calibre2">Copy…</strong></span> from the menu.</li><li class="listitem" value="2">Set the project name. The project location should remain unchanged.</li><li class="listitem" value="3">Open <code class="email">build.xml</code>, as discussed in <a class="calibre1" title="Chapter 4. Testing on the Spigot Server" href="part0033_split_000.html#VF2I1-b66e70deee6e4ed481db4b113e303f23">Chapter 4</a>, <span class="strong"><em class="calibre9">Testing on the Spigot Server</em></span>, and change the project's name to match what was set in step 2.</li><li class="listitem" value="4">Update the package in your new project so that it is unique by right-clicking on the package and selecting <span class="strong"><strong class="calibre2">Rename…</strong></span> in the <span class="strong"><strong class="calibre2">Refactor</strong></span> menu item.</li><li class="listitem" value="5">Rename<a id="id130" class="calibre1"/> the main class, if necessary. You<a id="id131" class="calibre1"/> can also remove the methods or classes that you know will not be reused.</li><li class="listitem" value="6">Finally, modify the <code class="email">plugin.yml</code> file with the new plugin information, including name, main, version, and description.</li></ol><div class="calibre13"/></div><p class="calibre8">Next, we will inform Bukkit that we will use a command by modifying the <code class="email">plugin.yml</code> file of the plugin. As mentioned in <a class="calibre1" title="Chapter 2. Learning the Bukkit API" href="part0020_split_000.html#J2B81-b66e70deee6e4ed481db4b113e303f23">Chapter 2</a>, <span class="strong"><em class="calibre9">Learning the Bukkit API</em></span>, Spigot reads the YAML file in order to find out necessary information about the plugin. This information includes all the commands that your plugin will handle. Each command can have a description, a proper usage message, and aliases, which is similar to how <code class="email">rl</code> is an alias for <code class="email">reload</code>. The command that we will use for the plugin will be <code class="email">enchant</code>. It is typical to use lowercase letters for commands so that players do not have to worry about capitalization when typing the in-game command. The following code is a sample of how <code class="email">plugin.yml</code> will appear after the <code class="email">enchant</code> command is added:</p><div class="informalexample"><pre class="programlisting">name: Enchanter
version: 0.1
main: com.codisimus.enchanter.Enchanter
description: Used to quickly put enchantments on an item
commands:
  enchant:
    aliases: [e]
    description: Adds enchantments to the item in your hand
    usage: Hold the item you wish to enchant and type /enchant</pre></div><p class="calibre8">Note how the lines are indented. This indentation must be spaces and not tabs. NetBeans helps us automatically indent the necessary lines as you type them. In addition to this, NetBeans will automatically use spaces even if you use the <span class="strong"><em class="calibre9">Tab</em></span> key. Indentation is very important in YAML files as this determines the hierarchy of keys. The <code class="email">enchant command</code> is indented under <code class="email">commands</code> to indicate that it is a command for the plugin. The <code class="email">aliases</code>, <code class="email">description</code>, and <code class="email">usage</code> commands are indented under <code class="email">enchant</code> to indicate that they belong to the <code class="email">enchant</code> command.</p><div class="informalexample" title="Note"><h3 class="title2"><a id="tip13" class="calibre1"/>Tip</h3><p class="calibre8">The order of these three settings does not matter and they are optional.</p></div><p class="calibre8">The usage message will be displayed in case an error occurs or a player uses a command incorrectly. The description message can be viewed by issuing the help command for the plugin, that is, <code class="email">/help Enchanter</code>.</p><p class="calibre8">For <code class="email">aliases</code>, we<a id="id132" class="calibre1"/> have <code class="email">e</code> as a value. This means that we <a id="id133" class="calibre1"/>can type <code class="email">/e</code> if we feel that <code class="email">/enchant</code> is too long to type. You may have more aliases, but they must be put in a YAML list format. Lists in a YAML file can be created in two different ways. The first format involves separating each item by a comma and a space and enclosing the entire list in square brackets, as shown in the following piece of code:</p><div class="informalexample"><pre class="programlisting">aliases: [e, addenchants, powerup]</pre></div><p class="calibre8">The second format involves placing each item on a new line, which starts with a hyphen and a space, as shown in the following piece of code:</p><div class="informalexample"><pre class="programlisting">aliases:
  - e
  - addenchant
  - powerup</pre></div><p class="calibre8">The preferred method is usually determined by the length of the list. The second format is easier to read when lists are long. However, be careful not to have extra or missing spaces before the hyphen, as it will cause problems when a program tries to read the list. In general, ensure<a id="id134" class="calibre1"/> that your lists line up. For more information about the YAML language, visit <a class="calibre1" href="http://www.yaml.org/spec/1.2/spec.html">http://www.yaml.org/spec/1.2/spec.html</a>.</p><p class="calibre8">Multiple commands can be easily added to a plugin. The following code is an example of <code class="email">plugin.yml</code> with several commands:</p><div class="informalexample"><pre class="programlisting">name: Enchanter
version: 0.1
main: com.codisimus.enchanter.Enchanter
description: Used to quickly put enchantments on an item
commands:
  enchant:
    aliases: [e, addenchants]
    description: Adds enchantments to the item in your hand
    usage: Hold the item you wish to enchant and type /enchant
  superenchant:
    aliases:
      - powerup
  disenchant:
    description: Removes enchantments from the item in your hand
    usage: Hold the item you wish to disenchant and type /disenchant</pre></div></div></div>
<div class="book" title="Programming the command actions"><div class="book" id="164MG2-b66e70deee6e4ed481db4b113e303f23"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch05lvl1sec34" class="calibre1"/>Programming the command actions</h1></div></div></div><p class="calibre8">Once you<a id="id135" class="calibre1"/> have added the command to the <code class="email">plugin.yml</code> file, you can begin working on the code that the command will trigger. Create a new class in the NetBeans project. This new class will be called <code class="email">EnchantCommand</code>. You can name the class something else if you wish, but keep in mind that the name of a class should give you an idea of how the class is used without you having to open it. Place this class in the same package as that of <code class="email">Enchanter</code>, the main plugin class, as shown in the following screenshot:</p><div class="mediaobject"><img src="../images/00035.jpeg" alt="Programming the command actions" class="calibre10"/></div><p class="calibre11"> </p><div class="informalexample" title="Note"><h3 class="title2"><a id="tip14" class="calibre1"/>Tip</h3><p class="calibre8">Keep in mind that though the packages are structured similarly, you will use your own unique namespace, not <code class="email">com.codisimus</code>.</p></div><p class="calibre8">This new class will execute the <code class="email">enchant</code> command. Thus, it must implement the <code class="email">CommandExecutor</code> interface. We will append code to the class header to do this. This is similar to adding <code class="email">extends JavaPlugin</code> to the <code class="email">Enchanter</code> class. <code class="email">JavaPlugin</code> is a class. Therefore, we extended it with our class. <code class="email">CommandExecutor</code> is an interface, which means that we must implement it. Once we add <code class="email">implements CommandExecutor</code> to the class header of <code class="email">EnchantCommand</code>, a light bulb will appear to notify us of the need to import the <code class="email">CommandExecutor</code> class. Import the class, and the light bulb will still be there. It is now informing us<a id="id136" class="calibre1"/> that because we implemented an interface, we must implement all of its abstract methods. Click on the light bulb to do so, and the method that we need appears. This new method will be called when a player executes <a id="id137" class="calibre1"/>the <code class="email">enchant</code> command. The method provides us with the following four parameters:</p><div class="book"><ul class="itemizedlist"><li class="listitem"><code class="email">CommandSender sender</code><div class="book"><ul class="itemizedlist1"><li class="listitem">This command can be named <code class="email">cs</code> by default, but we will name it <code class="email">sender</code> because it is easy to forget what <code class="email">cs</code> stands for</li><li class="listitem">This is who sent the command</li><li class="listitem">It may be a player, the console, a command block, or even a custom <code class="email">CommandSender</code> interface that was created by another plugin</li></ul></div></li><li class="listitem"><code class="email">Command cmnd</code><div class="book"><ul class="itemizedlist1"><li class="listitem">This is the <code class="email">Command</code> object that the sender executes</li><li class="listitem">We will not need this as this class will be used for only a single command</li></ul></div></li><li class="listitem"><code class="email">String alias</code><div class="book"><ul class="itemizedlist1"><li class="listitem">This is which alias the sender typed</li><li class="listitem">For example, it might be <code class="email">enchant</code>, <code class="email">e</code>, <code class="email">addenchant</code>, or <code class="email">powerup</code></li></ul></div></li><li class="listitem"><code class="email">String[] args</code><div class="book"><ul class="itemizedlist1"><li class="listitem">This is an array of strings</li><li class="listitem">Each string is an argument that the sender type</li><li class="listitem">Arguments follow the alias and are separated by a space</li><li class="listitem">The command itself is not considered as an argument</li><li class="listitem">For example, if they type <code class="email">/enchant knockback 5</code>, then <code class="email">knockback</code> will be the first argument (<code class="email">args[0]</code>) and <code class="email">5</code> will be the second and final argument (<code class="email">args[1]</code>)</li><li class="listitem">We do not need to worry about the arguments at this point, because the <code class="email">enchant</code> command will not need any</li></ul></div></li></ul></div><p class="calibre8">As mentioned before, there are different kinds of <code class="email">CommandSenders</code>. The following image is an inheritance diagram for <code class="email">CommandSender</code>:</p><div class="mediaobject"><img src="../images/00036.jpeg" alt="Programming the command actions" class="calibre10"/></div><p class="calibre11"> </p><p class="calibre8">In this diagram, you can see that <code class="email">Player</code>, <code class="email">ConsoleCommandSender</code>, and a couple of other classes <a id="id138" class="calibre1"/>are all subtypes of <code class="email">CommandSender</code>. The purpose of the enchant command is to allow a player to enchant the item that they are holding. Therefore, a <code class="email">CommandSender</code> object that isn't a player will have no use for this command. In the <code class="email">onCommand</code> method, the first code that we write will be to check whether a player has executed the command. If we do not perform this check, then the plugin will crash when a nonplayer attempts to issue the <code class="email">enchant</code> command. We will check this by using an <code class="email">if</code> statement and the <code class="email">instanceof</code> keyword. The code for this is as follows:</p><div class="informalexample"><pre class="programlisting">if (sender instanceof Player)</pre></div><p class="calibre8">This code can be translated to this:</p><p class="calibre8">
<code class="email">if the command sender is a Player</code>
</p><p class="calibre8">This <code class="email">if</code> statement will let us know if it was a player who sent the command. If the command sender is not a player, then we want to stop executing the code. We will do this by using the <code class="email">return</code> keyword. However, the <code class="email">return</code> type for this method is <code class="email">boolean</code>. We must return a <code class="email">boolean</code> value, which will tell Bukkit whether the usage message needs to be shown to the command sender. Typically, for the <code class="email">onCommand</code> method, you want to return <code class="email">false</code> if the command is not executed successfully. In this case, it was not. Therefore, we will use the <code class="email">return false;</code> code. So far, inside the method, we have constructed the following code:</p><div class="informalexample"><pre class="programlisting">if (sender instanceof Player) {
  return false;
}</pre></div><p class="calibre8">However, this is not quite right. This asks Bukkit to return <code class="email">false</code> if the command sender is a player, but we want to return <code class="email">false</code> when the opposite is the case. We can accomplish this by adding an exclamation point. If you don't already know, in Java, an exclamation point is a <code class="email">NOT</code> operator and can be used to invert a <code class="email">boolean</code> value. We will correct the previous code by inverting the resulting value, as shown in the following code:</p><div class="informalexample"><pre class="programlisting">if (!(sender instanceof Player)) {
  return false;
}</pre></div><p class="calibre8">Note the<a id="id139" class="calibre1"/> extra set of parentheses. This is very important. Parentheses allow expressions to be grouped together. We want to invert the <code class="email">boolean</code> value that results from the <code class="email">sender instanceof Player</code> code. Without the parentheses, we would be attempting to invert the sender object, which does not make sense. As a result of this, the code would not be compiled.</p><p class="calibre8">Up to this point, the <code class="email">EnchantComand</code> class code is as follows:</p><div class="informalexample"><pre class="programlisting">package com.codisimus.enchanter;

import org.bukkit.command.Command;
import org.bukkit.command.CommandExecutor;
import org.bukkit.command.CommandSender;
import org.bukkit.entity.Player;

/**
 * Enchants the item that the command sender is holding
 */
public class EnchantCommand implements CommandExecutor {

  @Override
  public boolean onCommand(CommandSender sender, Command cmnd,String alias, String[] args) {
    //This command can only be executed by Players
    if (!(sender instanceof Player)) {
      return false;
    }
  }
    
}</pre></div><p class="calibre8">Now that we have taken care of the nonplayers, we are certain that the <code class="email">CommandSender</code> object is a player. We will want to work with the <code class="email">Player</code> object rather than the <code class="email">CommandSender</code> object because the <code class="email">Player</code> object will have a specific item in its hand. We can get the <code class="email">Player</code> object by <span class="strong"><em class="calibre9">casting</em></span> the <code class="email">CommandSender</code> object to <code class="email">Player</code>. By casting, we are telling Java that we know that the command sender is actually a <code class="email">Player object</code> rather than a <code class="email">ConsoleCommandSender object</code> or one of the other subtypes. Casting is done by using the following syntax:</p><div class="informalexample"><pre class="programlisting">Player player = (Player) sender;</pre></div><div class="informalexample" title="Note"><h3 class="title2"><a id="tip15" class="calibre1"/>Tip</h3><p class="calibre8">If you are not already familiar with casting, I again suggest that you learn some of <a id="id140" class="calibre1"/>these programming concepts at <a class="calibre1" href="http://codisimus.com/learnjava">codisimus.com/learnjava</a>.</p></div><p class="calibre8">Now that <a id="id141" class="calibre1"/>we have the <code class="email">Player object</code>, we need the item that they are holding. Looking at the Bukkit API documentation for the <code class="email">Player</code> class, which is<a id="id142" class="calibre1"/> available at <a class="calibre1" href="https://hub.spigotmc.org/javadocs/bukkit/org/bukkit/entity/Player.html">https://hub.spigotmc.org/javadocs/bukkit/org/bukkit/entity/Player.html</a>, you can see that there exists a <code class="email">getItemInHand</code> method, which is inherited from <code class="email">HumanEntity</code>. It will return an <code class="email">ItemStack</code> class, which is exactly what we want. This is demonstrated in the following piece of code:</p><div class="informalexample"><pre class="programlisting">ItemStack hand = player.getItemInHand();</pre></div><p class="calibre8">Before doing anything with this item, we have to ensure that there actually is an item to enchant. If the player runs the command when they have no item in their hand, we do not want the plugin to crash. We will check whether the value of <code class="email">ItemStack class</code> is <code class="email">null</code> and the type of the item is <code class="email">AIR</code>. In either case, we will return <code class="email">false</code>, as follows, because the command wasn't executed:</p><div class="informalexample"><pre class="programlisting">if (hand == null || hand.getType() == Material.AIR) {
  return false;
}</pre></div><div class="informalexample" title="Note"><h3 class="title2"><a id="tip16" class="calibre1"/>Tip</h3><p class="calibre8">If we do not include the <code class="email">null</code> check (hand == null) here in the code, we may encounter a <code class="email">NullPointerExceptions error</code>, as discussed in <span class="strong"><em class="calibre9">Testing on the Spigot Server</em></span>.</p></div><p class="calibre8">Now, we have a reference to the player and the item that they are holding. Our end goal is to enchant this item. Again, looking at the API documentation, we can find several methods to<a id="id143" class="calibre1"/> add enchantments to an <code class="email">ItemStack class</code> at <a class="calibre1" href="https://hub.spigotmc.org/javadocs/bukkit/org/bukkit/inventory/ItemStack.html">https://hub.spigotmc.org/javadocs/bukkit/org/bukkit/inventory/ItemStack.html</a>. Read through the descriptions to find out which one is right for us.</p><p class="calibre8">Two of the methods are used to add multiple enchantments at once. We may want to add more than one enchantment, but to simplify the code, we will only add one at a time. The two remaining methods are <code class="email">addEnchantment(Enchantment ench, int level)</code> and <code class="email">addUnsafeEnchantment(Enchantment ench, int level)</code>.</p><div class="informalexample" title="Note"><h3 class="title2"><a id="tip17" class="calibre1"/>Tip</h3><p class="calibre8">The description for the unsafe method states that: <span class="strong"><em class="calibre9">This method is unsafe and will ignore level restrictions or item type. Use at your own discretion. </em></span>This warning is provided because these unsafe enchantments have not been tested and could produce undesirable results. You shouldn't let this deter you from using the method but you will want to test the enchantment before using it with friends to ensure that it doesn't crash the server.</p></div><p class="calibre8">Therefore, if we <a id="id144" class="calibre1"/>choose to go with <code class="email">unsafe</code>, we can create powerful enchantments, such as a sharpness level of 10. Without a plugin, a sword is limited to a sharpness of level 5. With unsafe enchantments, we can also enchant items that were previously unenchantable, such as a fish with <code class="email">KNOCKBACK</code> or <code class="email">FIRE_ASPECT</code>. Now, you will start to discover all the fun and cool things that you can do with plugins and which could not be done with a vanilla game.</p><p class="calibre8">From a personal experience, I found out that the <code class="email">KNOCKBACK</code> enchantment is quite entertaining. In my example, I will apply <code class="email">KNOCKBACK</code> to the item, but you should of course choose whichever enchantment you prefer. For a full list of enchantments and what they do, visit<a id="id145" class="calibre1"/> the API docs at <a class="calibre1" href="https://hub.spigotmc.org/javadocs/bukkit/org/bukkit/enchantments/Enchantment.html">https://hub.spigotmc.org/javadocs/bukkit/org/bukkit/enchantments/Enchantment.html</a> or<a id="id146" class="calibre1"/> the Minecraft Wiki at <a class="calibre1" href="http://minecraft.gamepedia.com/Enchanting#Enchantments">http://minecraft.gamepedia.com/Enchanting#Enchantments</a>. Bukkit does warn us that using an unsafe method can cause problems. To avoid conflicts, try to keep the enchantment levels at 10 or below. With most enchantments, you will not even notice a difference after level 10. We have decided that we will use <code class="email">addUnsafeEnchantment(Enchantment ench, int level)</code>. This method takes an <code class="email">Enchantment</code> and an <code class="email">int</code> value as parameters. This <code class="email">int</code> value is of course the enchantment's level, as stated in the API documentation. We have decided what we want each of these parameters to be. We can complete the line of code, as shown in the following piece of code:</p><div class="informalexample"><pre class="programlisting">hand.addUnsafeEnchantment(Enchantment.KNOCKBACK, 10);</pre></div><p class="calibre8">For added fun, we will add the <code class="email">FIRE_ASPECT</code> enchantment as well, as shown in the following piece of code:</p><div class="informalexample"><pre class="programlisting">hand.addUnsafeEnchantment(Enchantment.FIRE_ASPECT, 1);</pre></div><p class="calibre8">At this point, everything will be executed successfully. Before we return <code class="email">true</code>, we should send a message to the player to let them know that everything worked as planned. We will use the <code class="email">sendMessage</code> method to send the message to only this player by using the following line of code. No one else on the server, including the console, will see the message:</p><div class="informalexample"><pre class="programlisting">player.sendMessage("Your item has been enchanted!");</pre></div><p class="calibre8">The completed class is shown in the following lines of code. Remember to comment your code as you type it. Some of the comments in the following code may seem unnecessary, as the code is easy enough to read. We will refer to this code by the term self-documentation. You only need to leave comments for the code that may be difficult to understand in the future or which may need clarification. While you are still learning, I encourage you to overuse comments. They won't hurt anything by being present, and they will clearly <a id="id147" class="calibre1"/>explain the code for you in case you need it:</p><div class="informalexample"><pre class="programlisting">package com.codisimus.enchanter;

import org.bukkit.Material;
import org.bukkit.command.Command;
import org.bukkit.command.CommandExecutor;
import org.bukkit.command.CommandSender;
import org.bukkit.enchantments.Enchantment;
import org.bukkit.entity.Player;
import org.bukkit.inventory.ItemStack;

/**
 * Enchants the item that the command sender is holding
 */
public class EnchantCommand implements CommandExecutor {

  @Override
  public boolean onCommand(CommandSender sender, Command cmnd,String alias, String[] args) {
  //This command can only be executed by Players
    if (!(sender instanceof Player)) {
    return false;
  }

  //Cast the command sender to a Player
  Player player = (Player) sender;

  //Retrieve the ItemStack that the Player is holding
  ItemStack hand = player.getItemInHand();

  //Return if the Player is not holding an Item
  if (hand == null || hand.getType() == Material.AIR) {
    return false;
  }

  //Add a level 10 Knockback enchantment
  hand.addUnsafeEnchantment(Enchantment.KNOCKBACK, 10);

  //Add a level 1 Fire Aspect enchantment
  hand.addUnsafeEnchantment(Enchantment.FIRE_ASPECT, 1);

  player.sendMessage("Your item has been enchanted!");
  return true;
  }

}</pre></div><p class="calibre8">The <a id="id148" class="calibre1"/>preceding code implements the enchant command. It verifies that the command sender is a player and that the player is holding an item. It then adds defined enchantments to the item. This concludes the work that needed to be done in the <code class="email">EnchantCommand</code> class.</p></div>
<div class="book" title="Assigning the executor for the enchant command" id="173721-b66e70deee6e4ed481db4b113e303f23"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch05lvl1sec35" class="calibre1"/>Assigning the executor for the enchant command</h1></div></div></div><p class="calibre8">We<a id="id149" class="calibre1"/> are almost ready to start using the command <a id="id150" class="calibre1"/>on the server. The only remaining step is to assign the class that we just wrote to the <code class="email">enchant</code> command. This is typically referred to as registering a command. In the <code class="email">onEnable</code> method of the <code class="email">Enchanter</code> class, we will get the <code class="email">enchant</code> command using the <code class="email">getCommand("enchant")</code> code.</p><div class="informalexample" title="Note"><h3 class="title2"><a id="tip18" class="calibre1"/>Tip</h3><p class="calibre8">The name of the command must be exactly as it is in <code class="email">plugin.yml</code>. This also means that this code will only retrieve commands that are specific to this plugin.</p></div><p class="calibre8">Once we have the enchant command, we can set a new instance of <code class="email">EnchantCommand</code> as the executor for the command. All of this can be done in one line, as shown in the following piece of code:</p><div class="informalexample"><pre class="programlisting">getCommand("enchant").setExecutor(new EnchantCommand());</pre></div><p class="calibre8">All that you will have in the <code class="email">main</code> class is shown in the following code:</p><div class="informalexample"><pre class="programlisting">package com.codisimus.enchanter;

import org.bukkit.plugin.java.JavaPlugin;

  /**
  * Enchants the item that the command sender is holding
  */
public class Enchanter extends JavaPlugin {
  @Override
  public void onEnable() {
    //Assign the executor of the enchant command
    getCommand("enchant").setExecutor(new EnchantCommand());
  }
}</pre></div></div>
<div class="book" title="Summary" id="181NK1-b66e70deee6e4ed481db4b113e303f23"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch05lvl1sec36" class="calibre1"/>Summary</h1></div></div></div><p class="calibre8">You now have a useful plugin to play with on your own server. You can build this plugin, as discussed in the previous chapter, and put it on your server to test. Try it with different items and observe how it works. There are many plugins that can be created and which solely function by using commands. With this knowledge, you have the potential to create numerous plugins. You can try a few plugins, like a plugin that teleports you to the spawn location of the world using <code class="email">/spawn</code>, a plugin that plays the Creeper Hiss sound to a specific player using <code class="email">/scare &lt;player&gt;</code>, and a plugin that strikes a player with lightning using <code class="email">/strike &lt;player&gt;</code> by yourself.</p><div class="informalexample" title="Note"><h3 class="title2"><a id="tip30" class="calibre1"/>Tip</h3><p class="calibre8">There is a <code class="email">strikeLightning</code> method within the <code class="email">World</code> class.</p></div><p class="calibre8">For the plugin, you will have to use arguments. First, you will need to check whether you were given the correct number of arguments. Then, you will have to get the first argument, as explained earlier in this chapter. This argument will be the name of a player. There is a method in the <code class="email">Bukkit</code> class to find a player with a given name.</p><p class="calibre8">If you are ever searching for a plugin idea, remember that the API documentation is a great source of inspiration. Also, people are always looking for plugins to be made on the Bukkit, Spigot, and Minecraft forums. In the next chapter, we will expand on the <code class="email">Enchanter</code> plugin by adding permissions to it. This will ensure that only privileged players will be able to enchant items using the <code class="email">enchant</code> command.</p></div></body></html>