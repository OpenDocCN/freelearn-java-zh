- en: Creating an Online Bookstore
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It is always beneficial to develop any web application in a layered fashion.
    A prominent n-tier (or sometimes 3-tier) solution is the layered architecture,
    which has been widely adopted as the standard pattern for designing most applications.
    It is not a new concept, and we have been using it for a long time.
  prefs: []
  type: TYPE_NORMAL
- en: 'A layered architecture separates the whole application into various layers
    of concerns, which are logically different from each other:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Presentation layer**: This layer contains the artifacts that are responsible
    for building a user interface or displaying the output to the end user'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Application layer**: This layer contains business logic and interacts with
    the presentation and persistence layers to makeup the flow of the application'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Persistence layer**: This layer stores the data in data stores such as databases,
    the filesystem, and external sources, and also retrieves it'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are numerous advantages of a layered architecture, such as increased reusability,
    flexibility, and consistency, because the layers are logically separated. Applications
    built with a layered architecture are self-contained in nature and can be executed
    independently of other applications. They are referred to as **monolithic applications**.
  prefs: []
  type: TYPE_NORMAL
- en: Since the beginning of this book, we have been creating a monolithic application
    to showcase and explore various concepts. Though logically separated as an n-tier
    architecture, monolithic applications face a maintenance nightmare once their
    size and complexity reach a certain level over a period of time. Such applications
    hold all the features and functionalities in one single package, which is wrapped
    as a single deployable unit.
  prefs: []
  type: TYPE_NORMAL
- en: '**Microservices**, on the other hand, are a different architectural approach,
    adopted by organizations such as Google, Amazon, Netflix, and many others, with
    the aim of meeting modern business needs and developing an application that is
    inherently complex in nature. The microservice architecture helps to solve the
    various problems that arise with monolithic applications.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The concept of microservices is not new; it has come to the fore to overcome
    the limitations of previous architectures. In this chapter, we will closely observe
    the evolution of microservice architecture by developing an online bookstore application
    along with following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to microservice architecture
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Principles and characteristics of microservice architecture
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Various approaches to designing a microservice frontend
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Defining the structure of the database
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exploring various Spring Cloud and Netflix OSS components to design microservices
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Making a microservice application secure
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'All the code used in this chapter can be downloaded from the following GitHub
    link: [https://github.com/PacktPublishing/Spring-5.0-Projects/tree/master/chapter06](https://github.com/PacktPublishing/Spring-5.0-Projects/tree/master/chapter06).
    The code can be executed on any operating system, although it has only been tested
    on Windows.'
  prefs: []
  type: TYPE_NORMAL
- en: Microservices introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Microservices have emerged as a promising architecture pattern that is widely
    accepted as a solution to modern trends in business. Enterprises use various channels,
    such as mobile platforms, analytics with big data, and social media interaction,
    as elements to grow the business and find new customers at a rapid pace. With
    all these artifacts, organizations are trying to design innovations that will
    help them to gain a strong market share, which is a quite a difficult goal to
    achieve with conventional delivery methodologies.
  prefs: []
  type: TYPE_NORMAL
- en: In the past, enterprises developed single monolithic and accumulated applications
    for their business needs. Today, this has changed, as the goal has shifted to
    developing a smart solution with a short turnaround time that focuses on a specific
    business need.
  prefs: []
  type: TYPE_NORMAL
- en: A good example is a traveling company that executes their business with a single
    monolithic application. What if they want to improve the customer experience by
    suggesting new traveling ideas based on user searches or, more specifically, their
    old trips, any special occasion or festival season, user preferences, or interests?
  prefs: []
  type: TYPE_NORMAL
- en: 'There are many scenarios where organizations wish to implement independent
    solutions for each of these use cases and plug them into core business logic,
    instead of keeping everything together as a single application, which means they
    have to keep updating and testing the whole application for any future business
    changes, as shown in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/80eb0165-de74-49f6-9c80-63bcdb00abe1.png)'
  prefs: []
  type: TYPE_IMG
- en: Instead of putting all these independent functionalities together with the core
    business logic, they can be plugged in independently. This approach is more flexible
    in terms of allowing new changes with a lower adoption cost. Additionally, they
    can be tested independently and more effectively. Any further changes can be accommodated
    with ease.
  prefs: []
  type: TYPE_NORMAL
- en: Such business scenarios expect an architecture that can adopt changes with minimal
    impact and cost, which makes it more agile. This is why the microservice approach
    has been developed.
  prefs: []
  type: TYPE_NORMAL
- en: Microservice architectures focus on designing an application in small parts,
    each of which is concerned with a specific function, instead of making the whole
    application a black box in a monolithic architecture.
  prefs: []
  type: TYPE_NORMAL
- en: In the last few years, the revolution in technological paradigms has completely
    changed the way we develop an application. This includes the frontend layer, with
    various popular frameworks for responsive capabilities and flexibility, such as
    Angular, React, Backbone, and Bootstrap, which completely change the user front.
  prefs: []
  type: TYPE_NORMAL
- en: With the introduction of cloud-aware and container mechanisms, the approach
    to designing and implementing the middle layer has been influenced. It also includes
    a change in the way we design persistence from using a relational database to
    NoSQL, which solved specific architectural concerns.
  prefs: []
  type: TYPE_NORMAL
- en: Microservice architecture
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As time passes, architectural styles have improved significantly. Various architecture
    patterns, such as mainframes, client-server, n-tier, and **service-oriented architecture** (**SOA**),
    have been popular at various points in history. However, these architectural were
    all involved in developing some sort of monolithic application, either directly
    or indirectly.
  prefs: []
  type: TYPE_NORMAL
- en: As the revolution happened in the technology stack, microservice architecture
    has come to the fore as a result of improvements in all previous architectures.
    The aim is to provide agility, reduce the turnaround time for adopting new changes,
    achieve scalable performance, and take full advantage of modern tools and frameworks.
  prefs: []
  type: TYPE_NORMAL
- en: 'Microservice architecture breaks an application into small, independent subsystems.
    They also can be referred to as a system of systems, as shown in the following
    diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7272ea49-c82b-48e0-b2b1-b3bdc8460292.png)'
  prefs: []
  type: TYPE_IMG
- en: Though the components are stored in different logical layers in a monolithic
    architecture, they are packaged in a single application structure. On the other
    hand, the microservice system is a set of independent subsystems, each packaged
    in their own project structure and deployed as independent units. You can consider
    a microservice architecture as a jigsaw puzzle where each microservice is a building
    block of a whole application.
  prefs: []
  type: TYPE_NORMAL
- en: In short, in a monolithic system, the components are logically different but
    part of single physical application, whereas in a microservice architecture, the
    subsystems are actual physical applications that form a giant logical application.
  prefs: []
  type: TYPE_NORMAL
- en: The microservice architecture is widely used now as a set of standards to refactor
    monolithic applications. Emerging from a hexagonal pattern, a microservice architecture
    promotes the encapsulation of a business function into an individual independent
    unit that is isolated from other functionality.
  prefs: []
  type: TYPE_NORMAL
- en: 'A **Hexagonal Architecture** puts input and output on the edges of a hexagon
    and keeps **Business Logic** at the center. This arrangement isolates the application
    from outside concerns, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7e48881f-2c05-4aca-b911-3accc56e4bdc.png)'
  prefs: []
  type: TYPE_IMG
- en: The inside part consists of **Business Logic**, whereas the outside consist
    of the UI, messaging, **REST**, database, and others. The outside parts can be
    swapped without affecting the core application functions. Each business function
    can be designed with the hexagonal model, which then interacts with others with
    a standard communication mechanism.
  prefs: []
  type: TYPE_NORMAL
- en: Let's look at the hexagonal pattern by taking an example. Consider you are developing
    an EMI calculator application that calculates the principal and interest amount
    based on total loan amount, interest rate, and tenure. This application keeps
    the provision of scanning the user input to calculate the loan data. The logic
    for taking user input is closely associated with the EMI calculator application.
    After a period of time, another application needs to use the EMI calculator application.
    In this case, the input mechanism needs to be updated.
  prefs: []
  type: TYPE_NORMAL
- en: 'To overcome this problem, the hexagonal pattern suggests isolating the EMI
    calculating logic from the input receiving mechanism by defining some sort of
    standard interface. This way, the EMI calculator is completely unaware of where
    the inputs come from. In this scenario, the interface for receiving input is referred
    to as a **Port**, while its implementation is known as an **Adapter**, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8b0e6111-8fe2-4bae-82dd-f40fa0546866.png)'
  prefs: []
  type: TYPE_IMG
- en: The hexagonal pattern is also referred to as the **Port **and** Adapter **pattern.
    The concept of the microservice architecture is derived from the hexagonal pattern,
    in which each hexagonal structure represents a self-contained and loosely coupled
    service (subsystem). Adding more hexagonal models is equivalent to adding more
    independent services.
  prefs: []
  type: TYPE_NORMAL
- en: That is why the microservice concept is logically compared with a honeycomb,
    in which multiple hexagons form a large and solid structure. Similarly, individual
    services (equivalent to individual hexagonal structures) form a larger application.
  prefs: []
  type: TYPE_NORMAL
- en: Microservice principles
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Although there is no straight definition or standard for defining microservices,
    there are certain qualities, criteria, and principles that must be considered
    while designing microservice applications. Let's take a look at some of them in
    this section.
  prefs: []
  type: TYPE_NORMAL
- en: High cohesion with a single responsibility
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**High cohesion** means a module or unit should execute a single business function.
    In the microservice architecture, an individual service should perform a single
    responsibility for a given application context. Sharing a single responsibility
    between multiple services should not be allowed. Also, a single service should
    not handle multiple responsibilities, in order to make the whole system truly
    modular.'
  prefs: []
  type: TYPE_NORMAL
- en: This is one of the striking differences between the monolithic and microservice
    architectures. The components are logically separated but are still part of a
    single application and share some common responsibilities in the former, but they
    are designed as independent small applications in the latter.
  prefs: []
  type: TYPE_NORMAL
- en: While designing microservices, the goal should be the scope of the business
    function executed by the microservice instead of making it smaller. The term **micro**
    is sometimes misleading, suggesting you should make the service as small as possible.
    The scope should be given the highest priority, instead of the size of the service.
  prefs: []
  type: TYPE_NORMAL
- en: Service autonomy
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While building a microservice application, the prime goal is to make each member
    (service) a standalone and independent building block. To make sure each service
    runs with optimal performance and provides reliable output, they must take full
    control over the underlying resources they use.
  prefs: []
  type: TYPE_NORMAL
- en: This can be achieved with the service autonomy principle. It recommends each
    service should be designed with autonomy in mind. By doing so, the control and
    ownership a service has over its own execution environment will be more effective,
    which would otherwise be difficult to achieve with shared resources in a monolithic
    architecture. This will greatly help in dealing with the scalability of the application.
  prefs: []
  type: TYPE_NORMAL
- en: Loose coupling
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An application should be designed with microservice architecture in such a way
    that each unit (service) should have (ideally) zero or the bare minimum impact
    on other components or services. If any sort of interaction or communication is
    required between services, they also should be loosely coupled in nature. This
    is the reason synchronous calls with RESTful APIs or asynchronous calls with a
    messaging framework are preferable.
  prefs: []
  type: TYPE_NORMAL
- en: Hide implementation through encapsulation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Microservices must isolate underlying implementation details from the outside world
    and define a standard interface to interact with it. This will not only reduce
    complexity, but also enhance the ability to adopt new changes easily, making the
    whole system more flexible and robust.
  prefs: []
  type: TYPE_NORMAL
- en: Domain-driven design
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Domain-driven design** (**DDD**) is a way to design a system with respect
    to the actual domain models used in the application. The architectural style of
    DDD is used to develop an application in independent units, each representing
    a specific domain model. It also suggests the way to behave and communicate between
    domain models. An ideal DDD has all the qualities required to develop a modular
    application. Due to this, it is an ideal candidate for consideration while implementing
    microservice architecture.'
  prefs: []
  type: TYPE_NORMAL
- en: Microservice characteristics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here are some characteristics of a microservice architecture:'
  prefs: []
  type: TYPE_NORMAL
- en: It is a way of designing an application as a group of small services, each executed
    in its own procedure.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Microservices can interact with each other internally, mostly through the HTTP
    API or some time-messaging mechanism such as AMQP or JMS.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each microservice is built to execute a specific business requirement. In other
    words, they are aligned to specific business needs or capabilities.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Microservices can be deployed independently with an automated mechanism.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Some sort of common or central process is required to manage microservices,
    which may or may not use the same technology stack as the individual microservices.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Microservices manage their life cycle independently of others.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Changes to one microservice do not impact on others as they run independently.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Microservices with Spring Cloud
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Generally, microservices are designed to be deployed in a distributed system.
    There are certain common patterns across distributed environments. Spring Cloud
    provides a predefined implementation of patterns that we can use to build a microservice
    application quickly. They are considered Spring Cloud sub-projects. We are going
    to take a brief look at a few of them, and we will also see how to use them while
    developing our online bookstore application.
  prefs: []
  type: TYPE_NORMAL
- en: Configuration management
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Configurations are part of any application, and in the Spring world they are
    in the form of the properties file, generally bundled with the application code.
    It is a tedious job to deploy the entire service any time there's a configuration
    change. What if a configuration can be managed outside of the application? This
    is a good idea because managing configurations externally allows us to reflect
    changes without deploying or even restarting a service. This is exactly what configuration
    management does. Configurations are allowed on the fly.
  prefs: []
  type: TYPE_NORMAL
- en: Service discovery
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we have seen, microservice applications are a collection of self-contained
    and independently deployable services that are running on the same or different
    physical machines, or on the cloud. Each service can be considered as an individual
    process that performs a specific responsibility.
  prefs: []
  type: TYPE_NORMAL
- en: Though they are separated in terms of executing different business functions,
    they are interconnected as a part of the whole application, and hence some sort
    of communication mechanism, with well-defined standards, is required.
  prefs: []
  type: TYPE_NORMAL
- en: For interprocess communication, as well as accessing a particular service, we
    need to know the location in terms of the port and IP of the service. Traditional
    monolithic applications are generally deployed and accessible with a static port
    and IP address. Also, they are deployed in a single package so that all the components/services
    are accessible with the same port and IP. The likelihood of changing the port
    and IP is also very low.
  prefs: []
  type: TYPE_NORMAL
- en: In contrast, microservice applications are distributed in nature and may be
    deployed on different machines or in the cloud. Additionally, more instances of
    the services may be added to improve the scalability of the system. In future,
    new services may be added dynamically. Due to this, the locations of microservices
    are dynamic.
  prefs: []
  type: TYPE_NORMAL
- en: Spring Cloud provides a **service discovery** functionality, which is actually
    used to locate the services in the distributed environment. Spring Cloud provides
    a Netflix Eureka-based discovery service out of the box. Alternatively, we can
    use Consul, Cloud Foundry, or Apache ZooKeeper with Spring Cloud as service discovery
    support.
  prefs: []
  type: TYPE_NORMAL
- en: Circuit breakers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Though microservices are designed to handle a single responsibility, they sometimes
    rely on other services to perform a set of actions owned by others. In this dependency
    channel, if one service goes down, the error will propagate to other services
    on the same channel. To avoid it, Spring Cloud provides a Netflix Hystrix-based
    fault tolerance solution, which is an implementation of the circuit breaker pattern.
  prefs: []
  type: TYPE_NORMAL
- en: Routing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Since the location of microservices can be changed dynamically, a routing mechanism
    is required to send the request to the specific service endpoint. Spring Cloud
    provides a simple and effective way to route APIs with advanced cross-cutting
    capabilities such as security, monitoring, filtering, and authentication through
    Zuul—another tool from Netflix, which is a server-side load balancer that's used
    for routing purposes as well. Zuul can also be used as a micro proxy, which routes
    the application using the proxy URL that was configured.
  prefs: []
  type: TYPE_NORMAL
- en: Another component used for routing is Spring Cloud Gateway, which is natively
    developed by Spring. It is built on Spring Framework 5 and may provide a better
    developer experience as it's closely integrated with Spring.
  prefs: []
  type: TYPE_NORMAL
- en: Spring Cloud Security
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Though microservices are accessed with standard interfaces, they need authentication
    and authorization in some use cases. Securing a microservice system is more complex
    than securing a monolithic system. Spring supports authentication with microservices
    through Spring Cloud Security with the Auth2 protocol to propagate the security
    context across the microservices in a distributed environment.
  prefs: []
  type: TYPE_NORMAL
- en: Distributed tracing service
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the microservice architecture, the application flow may pass through a chain
    of multiple service calls to execute a single business use case. Manually tracing
    the activities with the logs of multiple microservices is not an efficient solution.
    We may not get exactly what we want out of it. It is important to understand what
    is happening between the series of service call. This is quite helpful in debugging
    if an issue arises. Spring Cloud provides an effective way to trace the application
    flow in a distributed system through **Spring Cloud Sleuth**. It collects the
    call tracking data, which can be exported to **Zipkin**—another tool for visualizing
    the call trace.
  prefs: []
  type: TYPE_NORMAL
- en: Spring Cloud Stream
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To handle the high volumes of data streams, we may need to work with message
    broker implementations such as RabbitMQ or Apache Kafka. Spring Cloud provides
    an easy integration of a message broker with a high-level abstraction through
    Spring Cloud Stream. So, instead of actually implementing the message broker,
    Spring Cloud Stream will handle the messages and pass them to the actual broker
    client at runtime, based on its configuration. This makes the code portable and
    loosely coupled with any message broker implementation.
  prefs: []
  type: TYPE_NORMAL
- en: Developing an online bookstore application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we've looked at the microservice architecture, let's now do a practical exercise
    to understand the concept in more detail. We will follow the microservice pattern
    to develop a simple online bookstore application.
  prefs: []
  type: TYPE_NORMAL
- en: Application architecture
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We need to start by designing the application's architecture first. While designing
    microservice-based applications, first we need to think of a single monolithic
    application and then derive various parts or components that are independent of
    each other and can be thought of as possible candidates for being individual microservices.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will break the application into small parts based on the criteria we looked
    at in the previous sections, such as single responsibility, service autonomy,
    loose coupling, encapsulation, and DDD, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: User management
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Order management
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Catalog management
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Inventory management
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'They are considered independent domains or business functions. We will create
    individual microservices for each of them with the following high-level architecture:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e4f061d5-1704-48f2-9542-48f117b862d6.png)'
  prefs: []
  type: TYPE_IMG
- en: Database design
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While decomposing the application to adopt the microservice architecture, we
    need to rethink database design as well. In a distributed environment, there are
    multiple options for database design.
  prefs: []
  type: TYPE_NORMAL
- en: Single monolithic database for all microservices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this approach, though the microservices are independently designed as a
    separate subsystem, they still share a single monolithic database, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1cfdb862-0c96-49ab-b189-d552314e7e2e.png)'
  prefs: []
  type: TYPE_IMG
- en: Each microservice has its own set of tables, but all are part of a single database
    schema. The clear benefit of this option is simplicity, as a single database can
    be operated with ease. Also, transactions can be carried out in a more consistent
    way.
  prefs: []
  type: TYPE_NORMAL
- en: However, according to best practices, microservice should be independently deployable
    to get better scaling optimization. Another benefit of being independently deployable
    is the quick adoption of changes. As soon as multiple services depend on a single
    monolithic data store, this flexibility is reduced to take full advantage of the
    distributed environment, such as high cohesion and loose coupling.
  prefs: []
  type: TYPE_NORMAL
- en: Also, multiple teams generally work on the application side. They also need
    to face coupling with other teams while dealing with database changes. This will
    slow down the development and eventually add a delay in delivery. So, this is
    not an ideal scenario.
  prefs: []
  type: TYPE_NORMAL
- en: Separate service to handle database interaction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this scenario, instead of sharing a common database with all services, a
    separate service will be developed that will interact with the database only.
    All other services will talk to this service for any database operations instead
    of directly connecting with the database, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/02ad11c0-408e-45f7-a251-6a0a9b7d861b.png)'
  prefs: []
  type: TYPE_IMG
- en: Though the dependency of managing database-related actions is shifted to a separate
    service, it is still kind of a monolithic approach and has all the limitations
    of the first option. So, this is also not an optimized way to design the database
    for a microservice architecture.
  prefs: []
  type: TYPE_NORMAL
- en: Each microservice has its own database
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This option has a separate database for each individual service, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c8262572-6f27-411d-8f99-e3d003a07825.png)'
  prefs: []
  type: TYPE_IMG
- en: Instead of a single shared database across services, each service's database
    is an integral part of that service and cannot be accessed by other services directly.
    Another flexibility in this option is that each service is allowed to choose the
    type of data store that is the best fit for its capabilities. For example, if
    you have a search service, to perform the search in the system, you can use **Elasticsearch**
    as a data store.
  prefs: []
  type: TYPE_NORMAL
- en: 'This model has two further options:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Individual database schema per service:** Still use a single database server,
    but have a separate schema for each microservice. This option makes ownership
    cleaner, and it is an ideal option for most cases.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Individual database server per service:** Design separate database servers
    for each microservice. This option can be considered for services that require
    high throughput.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For simplicity, we will use MySQL to store the data. As per the system architecture,
    there will be a separate database schema for each microservice.
  prefs: []
  type: TYPE_NORMAL
- en: User schema
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This schema contains the tables that store user-related data. The **user**
    table holds user-specific data, which will be used for authentication, while the
    **delivery_address** table contains delivery address information:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7c432a3d-4f22-4b60-b66c-871a24a7dec1.png)'
  prefs: []
  type: TYPE_IMG
- en: There is a *one-to-many *relationship between the **user** and **delivery_address**
    tables.
  prefs: []
  type: TYPE_NORMAL
- en: Order schema
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This schema contains two tables, **order** and **order_item**. The relationship
    between them is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8d60f603-f7e3-46ba-9840-8ca9911869a1.png)'
  prefs: []
  type: TYPE_IMG
- en: The **order** table holds the generic details of each order, such as orderId,
    userId, order date, total amount, and shipping address. The **order_item** table
    saves individual item details.
  prefs: []
  type: TYPE_NORMAL
- en: Catalog schema
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This schema contains the product details. Since this is an online bookstore
    application, the **book** table contains details of the book. The **category**
    and **publisher** tables contain details about categories and publishers respectively.
    The relationship between these tables is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1d912f18-69b8-4c08-8648-9a8aef0d02bc.png)'
  prefs: []
  type: TYPE_IMG
- en: The **book** table has a *many-to-one* relationship to the **category** and
    **publisher** tables.
  prefs: []
  type: TYPE_NORMAL
- en: Inventory schema
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Every store has an inventory. This schema stores the inventory containing information
    about the books. There are two tables that store this information. The **inventory**
    table contains the current stock of the product (books in our case), while the **inventory_history**
    table shows the history of adding new books into the system:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3076c017-f24e-4e23-ac82-11822265584d.png)'
  prefs: []
  type: TYPE_IMG
- en: There is no relation between these tables.
  prefs: []
  type: TYPE_NORMAL
- en: Creating microservices with Spring Boot
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We are going to develop an online bookstore application with an architecture
    of small and independently deployable microservices that can be developed by individual
    teams. They are expected to be developed with a quick turnaround time. This is
    what Spring Boot is designed for. It is a tool used to create production-grade
    Spring-based enterprise applications with a little configuration in no time.
  prefs: []
  type: TYPE_NORMAL
- en: We will first develop individual services with Spring Boot to develop them quickly.
    Spring Cloud also has solid integration capabilities with Spring Boot. While developing
    microservices, Spring Boot takes care of all the low-level things and allows us
    to concentrate on the business logic.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we will create Spring Boot applications for specific functionalities.
    Once they are created, we will then add microservice-specific capabilities to
    each of them:'
  prefs: []
  type: TYPE_NORMAL
- en: '`user-service`: This service is intended to execute various operations related
    to users, such as registration, login, and user interaction'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`inventory-service`: This service performs various inventory operations performed
    by admin only'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`catalog-service`: This service is responsible for managing catalog information
    such as adding books, categories, and publisher details'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`order-service`: This service handles orders placed by a user'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'While creating an application with either the spring-io initializer or **Spring
    Tool Suite** (**STS**, an Eclipse-based IDE provided by Spring), initially we
    will add following dependencies:'
  prefs: []
  type: TYPE_NORMAL
- en: '**DevTools**: Used to improve the development time experience by adding auto-deploy/restart
    capabilities as a Maven dependency.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**JPA**: This will add a JPA-specific starter dependency, which is used to
    add JPA capabilities. We are going to use JPA (Hibernate implementation) to interact
    with the database.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**MySQL**: This will add a MySQL connector JAR to connect to the database.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Web**: This is used to add Spring MVC capabilities to the application. We
    will use a REST controller to access individual microservice applications.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding microservice-specific capabilities
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have created various Spring Boot applications for each individual functionality.
    They all are accessible (by default) on port `8080` one by one. However, they
    are not ready to be executed as microservices. Now we will add microservice-specific
    capabilities by adding a dependencies entry in the `pom.xml` file of each individual
    Spring Boot application.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following entry in the `dependencies` section of `pom.xml`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'You also need to add an entry for the current version of Spring Cloud next
    to the `<java-version>` entry as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the following entry after the `dependencies` section is complete in `pom.xml`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Make these changes in all four Spring Boot applications that we have developed.
    After applying these changes, they will no longer run independently as Spring
    Boot applications because we are now moving towards a microservice architecture.
  prefs: []
  type: TYPE_NORMAL
- en: Develop a service discovery server
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The real challenge in a microservice architecture is to access particular services
    because they are dynamically created and destroyed, so their location keeps changing.
    Additionally, we also need some sort of inter-service communication to fulfill
    certain business use cases that span the microservices. Also, multiple instances
    of each microservice can be created to scale up the application's performance.
  prefs: []
  type: TYPE_NORMAL
- en: In this situation, there must be a mechanism for locating the microservices.
    Spring Cloud provides a Netflix Eureka-based service discovery component for this
    purpose. Microservices can register themselves with the discovery server so that
    they can be accessed and interacted with by other services. Eureka Server is basically
    used for discovery, self-registration, and load balancing.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next up is to create a Eureka-based service that acts as a **service discovery
    server**. Creating a Eureka-based discovery service is similar to creating Spring
    Boot application with just a few configuration changes. Create a new Spring starter
    project with the following data:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d4906690-2cc9-49f8-aac4-c10aabbf09bf.png)'
  prefs: []
  type: TYPE_IMG
- en: 'On next screen, select Eureka Server under the Cloud Discovery option as a
    dependency and click Finish. Once the project is created, open the `bootstrap`
    class and add the code highlighted in bold as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'By default, the Eureka Server option is not enabled. The `@EnableEurekaServer`
    annotation is used to make it active for this application. That means this application
    will run as a Eureka discovery server. Next, we will add certain properties in
    the `application.properties` file as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: By default, the current Eureka server is also a Eureka client and will try to
    register itself as a Eureka client with the Eureka server. Since we want this
    application to behave as a server only, we need to explicitly set the `eureka.client.registerWithEureka`
    property to `false`. By default, Eureka server is accessible through port `8080`
    and it can be changed with the `server.port` property.
  prefs: []
  type: TYPE_NORMAL
- en: 'Each Eureka client will fetch registry details from Eureka server. In our case,
    we do not want to fetch the registry details, so, we explicitly set the `eureka.client.fetch-registry`
    property to `false`. Now run the application, and Eureka Server is accessible
    through `http://localhost:8761`. It will show the server details and all registered
    service details, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9936ba3b-c502-41cc-8bb9-9a57b39229e4.png)'
  prefs: []
  type: TYPE_IMG
- en: Currently, no services are registered with our Eureka discovery server, so it
    shows nothing in the Instances currently registered with Eureka section.
  prefs: []
  type: TYPE_NORMAL
- en: Eureka Server can be started in standalone or clustered mode. For simplicity,
    we have chosen standalone mode.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next up is to register the four microservices that we have developed with the
    Eureka discovery server. We have already added microservice-specific dependencies
    to them. Now, we need to add the Eureka client configurations. Because of the
    way we have configured Eureka server, we need to configure the Eureka client in
    each of the service''s `bootstrap` classes. For example, the Eureka client configuration
    for the user service''s bootstrap class is highlighted in bold as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The `@EnableDiscoveryClient` annotation will enable client configuration. Additionally,
    we need to add the following properties in the `application.properties` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The `spring.application.name` property will be used to register the application
    with a specific name. Add client configurations and start other services, and
    you will see them registered with Eureka server as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a7f7bb03-bb50-42a1-8161-f6f5f4c0d7bd.png)'
  prefs: []
  type: TYPE_IMG
- en: Another annotation, `@EnableEurekaClient`, can also be used for Eureka client
    configuration. The difference between `@EnableDiscoveryClient` and `@EnableEurekaClient`
    is that the former is more Spring-aware and works with discovery implementations
    other than Eureka, such as Consul and ZooKeeper; the latter is specific to Eureka
    only. So, if Eureka is present in the classpath, there is no difference between
    them.
  prefs: []
  type: TYPE_NORMAL
- en: Spring Cloud Eureka consists of client and server components. All the microservices
    are registered in the server registry, whereas each individual service behaves
    as a client. Any service that wants to discover other services should also be
    Eureka client-aware. The registration in the server happens with client identity
    (with its name) and URL (with its port).
  prefs: []
  type: TYPE_NORMAL
- en: 'The flow of communication between client and server happens as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: On starting the microservice, it reaches out to the server component and provides
    metadata for registration.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Eureka server validates the metadata and does the registration.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After registration, the microservice endpoint sends the ping to the server registry
    every 30 seconds (by default) to mark its presence.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The server will continuously verify the ping requests, and if no request comes
    for a certain period of time, it will remove the service from the registry automatically.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The server shares the registry information with all Eureka-aware clients, and
    they store it in the local cache. This information is then used by a microservice
    client to locate other clients in the distributed environment.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The server pushes the updates of registry information to all clients every 30
    seconds (by default).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Microservices registered with a server can be grouped into a zone. In this case,
    the zone information can be supplied at registration.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When any microservice sends a request for another microservice, Eureka server
    will try to search service instances running in the same zone to reduce the latency.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The interaction between the Eureka client and server happens through REST and
    JSON.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Designing an API gateway
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In typical microservice applications, it is quite possible that more than a
    hundred microservices are interacting with each other. There are certain common
    features that are required to be implemented for all these microservices:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Security**: We may need to check that authentication and authorization, or
    any other security policies required to make calls to microservices'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Restrict call rate**: This allows only a certain number of calls for a specific
    microservice in a given time'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Fault toleration**: If any service fails to respond, this sends an appropriate
    error signal'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Monitor**: This is used to monitor for specific events or values passed across
    the microservices'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Service aggregation**: This provides an aggregate response from multiple
    microservices in a single response, specifically in a bandwidth-restricted environment'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Routing**: Based on certain criteria (if call forwarding is required, for
    example), route all the calls from a specific user to a particular region to a
    specific service'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Load balancing**: This maintains the flow of calls to balance the load on
    the service instance'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Apart from this, we may want to restrict some of the services to end users and
    keep them private. To achieve these goals, we need some sort of API gateway, which
    will intercept all the calls from end users and all inter-service communication. So,
    instead of microservices talking with each other directly through REST calls,
    they will now interact with each other through an API gateway, which will provide
    all the features previously listed. Since all the calls are routed from the API
    gateway, it can also be used for debugging and analytic purposes.
  prefs: []
  type: TYPE_NORMAL
- en: Spring Cloud provides API gateway support through another Netflix implementation
    called **Zuul**. Next up, let's see how to set up Zuul.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up Zuul as an API gateway
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will create a Zuul proxy server as an independent Spring Boot service and
    register it with the Eureka discovery server. Create a new Spring starter project
    in Spring STS with Zuul, Eureka Discovery, and DevTool as dependencies.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once created, open the `bootstrap` class and update it as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The `@EnableZuulProxy` annotation will make this service a Zuul server. We
    also need to register it with the Eureka discovery server with the `@EnableDiscoveryClient`
    annotation. Every service registered with the Eureka name server needs a name
    (and a port). Add these details for the Zuul server in the `application.properties`
    file as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Now the API gateway server is ready and configured, but we did not specify what
    to do when intercepting requests. Zuul provides request handling support through
    various filters. They are categories in pre, post, routing, and error filters,
    each targeted for specific service call life cycles. Since Zuul is a Spring Boot-based
    service, we can customize the API gateway programmatically. Additionally, for
    any special requirement, Zuul supports developing custom filters. We will see
    how to add custom filters and examine how requests can be intercepted with it
    in a short while.
  prefs: []
  type: TYPE_NORMAL
- en: The Zuul API gateway server is also referred to as an Edge server.
  prefs: []
  type: TYPE_NORMAL
- en: Designing the UI
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we have seen, the microservice architecture is the best fit for modern applications
    that are big and distributed in nature. This type of architecture helps split
    the team that's working on a single monolithic application into a set of small
    and independent teams, focusing on one single module or functionality.
  prefs: []
  type: TYPE_NORMAL
- en: 'A microservice pattern has its own benefits, such as managing scalability and
    complexity, and easily adopting new changes in a short time frame. We have explored
    how Spring Cloud components help build a distributed application in the Spring
    Framework. So far, we have only talked about the middle and backend layers. This
    section is dedicated to an interesting topic: how to design a microservice frontend.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Unlike monolithic architectures, the frontend of a microservice application
    can be designed with different approaches, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Monolithic front
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Micro front
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Composite or modular front
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Monolithic front
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Though the microservice pattern divides the monolithic backend into multiple
    independent services, this may not be straightforward for the frontend. In the
    monolithic front approach, we keep the whole user interface in a single big frontend
    application that will talk to corresponding services through REST calls to perform
    tasks or to show data to the end user, as per the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c86ced6f-0e67-4947-a5ac-6a7c40309ecb.png)'
  prefs: []
  type: TYPE_IMG
- en: The clear benefits of this approach are an easy implementation and UI consistency
    across the application because everything is in a single place. On the downside,
    there may be a good amount of conflict regarding library versions, styling, and
    so on, as multiple teams are working on a single UI application.
  prefs: []
  type: TYPE_NORMAL
- en: Since everything is under one roof, it becomes harder to adopt changes as the
    application grows. Over a period of time, when business demand increases, it eventually
    becomes harder to maintain the application's UI as multiple teams spend most of
    their time solving problems.
  prefs: []
  type: TYPE_NORMAL
- en: Choose this approach only when you are sure that the application is divided
    into just a few microservices with limited scope for growth in the future.
  prefs: []
  type: TYPE_NORMAL
- en: Micro front
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this approach, each microservice has its own UI limited to the functionality
    it performs. So, along with the backend, the frontend is also decomposed as per
    the scope of the individual microservices, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/107ebd29-6907-433e-b8c9-80b55929a67d.png)'
  prefs: []
  type: TYPE_IMG
- en: 'This approach eliminates all the limitations of the monolithic frontend but
    then introduces certain new challenges. Though microservices are split as self-contained
    and independent executable units, and the final frontend should be presented with
    a single interface. In the micro front approach, the challenge is to combine the
    UIs of individual microservices in a single format. There are a number of ways
    of doing this. Though they overcome the limitations of the first approach, they
    introduce certain other issues:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Synchronize the UI across the microservices:** In this way, just copy and
    paste the UI of all services to each other and use the API gateway. Though this
    seems simple, it produces huge maintenance issues.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**IFrame:** Use a separate layout where the output of individual microservices
    can be clubbed with IFrame. However, this approach is also not brilliant because
    IFrame has its own limitations.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**HTML fragments:** You can write your own JavaScript code and glue the content
    of the microservices through HTML fragments. However, there are some limitations,
    and also lots of custom script you have to write on your own. Also, there may
    be a chance of services'' scripts and styles clashing.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Composite front
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This approach is a micro font approach with the right solution to aggregate
    the microservice output. The layout will be created with a single UI application,
    whereas the business UI of individual microservices will be plugged in from of
    web components, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/73dda3ad-a484-4091-910a-a683ad891fa5.png)'
  prefs: []
  type: TYPE_IMG
- en: Each microservice is responsible for producing a small UI area on the page.
    Composite UIs can be easily designed by creating a component in popular frontend
    frameworks such as Angular and React. On top of this, a framework such as *single-spa*
    ([https://single-spa.js.org](https://single-spa.js.org)) is designed to show aggregate
    output. It is basically a JavaScript library that shows a composite output of
    microservices as a single-page application running in a browser. Single-spa allows
    the coexistence of microservices developed in different frameworks.
  prefs: []
  type: TYPE_NORMAL
- en: This means that you can develop one microservice in Angular, a second in React,
    a third with Vue, and so on. This brings great flexibility and fulfills the aim
    of the microservice architecture being developed completely independently from
    the backend to the UI. As an enhanced version of the second approach, the composite
    font approach not only overcomes the limitation of the monolithic front approach
    but also suggests the right way to develop the front layer in a microservice architecture.
  prefs: []
  type: TYPE_NORMAL
- en: Other Spring Cloud and Netflix OSS components
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Spring Cloud provides a wrapper on top of various Netflix components that are
    used in microservice applications extensively. We have already explored the Eureka
    discovery server and Zuul. In this section, we will explore a few more Netflix
    OSS components, along with other Spring Cloud features.
  prefs: []
  type: TYPE_NORMAL
- en: Dynamic configuration in Spring Cloud
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we know, the microservice architecture consists of a number of small and
    independently deployable microservices that handle end-user calls and interact
    with each other. Based on the project's needs, they may run in various environments,
    such as development, testing, staging, production, and so on. To improve the scaling
    capabilities of an application, there may be multiple instances of microservices
    configured to work with the load balancer.
  prefs: []
  type: TYPE_NORMAL
- en: Each microservice possesses a set of configurations, including database configurations,
    interaction with other services, message broker configurations, and custom configurations.
    Handling microservice configurations between various environments is one of the
    most challenging parts of a microservice architecture.
  prefs: []
  type: TYPE_NORMAL
- en: Maintaining each microservices configuration manually would be too complex and
    difficult for the operations team. The best possible solution is to separate the
    configuration out from each microservice and maintain them all in one central
    place. This way, the dependency of environments on configuration can be handled
    more effectively.
  prefs: []
  type: TYPE_NORMAL
- en: 'Spring Cloud provides a component called **Spring Cloud Config**, which is
    used to externalize the microservice configuration. It uses a Git repository to
    store all the configurations in one place, as shown in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ad89b25b-5d72-4f41-8b14-386b396e11b6.png)'
  prefs: []
  type: TYPE_IMG
- en: We will create a separate service for central configuration with the Spring
    Cloud Config feature. The next few sections explain how to do this.
  prefs: []
  type: TYPE_NORMAL
- en: Step 1 – creating a Spring Boot service for the configuration server
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This is the most straightforward way of creating a component as a Spring Boot
    application. Create an application with STS and select the DevTool and Config
    server dependencies. Once the project is created, you can see the dependency in
    `pom.xml` that is responsible for adding Spring Cloud Config capabilities to the
    Spring Boot application, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Next up, let''s enable the Spring Cloud Config feature. Open the main `bootstrap`
    class and add the `@EnableConfigServer` annotation, which is used to enable external
    configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Since the configuration server will also be registered with the naming server
    (Eureka server), we need to define certain properties in the `application.properties`
    file as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Next up, let's install and configure Git.
  prefs: []
  type: TYPE_NORMAL
- en: Step 2 – configuring Spring Cloud Config with a Git repository
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The Spring Cloud Config server is ready. Now, we need to do the necessary configuration
    for Git repository integration. First, install the latest version of Git ([https://git-scm.com/downloads](https://git-scm.com/downloads))
    on your local machine and make sure it is available on a path. Create a directory
    on your local machine and initialize the Git repository with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'This will create an empty Git repository on the local machine. Next, add a
    properties file that holds the configuration details. Since the configuration
    server can hold configuration details for multiple microservices in Git, we need
    to follow a certain naming convention for the property file, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: As we have seen, microservices' IDs (or names) are defined with the `spring.application.name`
    property in the `application.properties` file. So, we need to create a property
    file with this name in the Git repository. For example, if the microservice name
    is `catalog-service`, then you need to create a `catalog-service.properties` file
    and store all the configurations for that microservice.
  prefs: []
  type: TYPE_NORMAL
- en: 'For different environments, you can create a property file with an active profile
    appended after the microservice name. For example, the name of the property file
    for the development environment would be `catalog-service-dev.properties`. Once
    you have created the files, add the configuration details and commit them to the
    Git repository with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The Git repository is now ready, so we need to point the configuration server
    to it. Open the `application.properties` file of the configuration server as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Since this is the local Git repository, the location of the repository folder
    is given with `file://` to point it to the local filesystem. The configuration
    server also allows configuration with a remote Git repository. In this case, you
    need to give the Git clone URL something like `https://github.com/<<accoun-tname>>/<<repo-name>>.git`
    for the `spring.cloud.config.server.git.uri` property.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will add some sample configurations and see how they can be reflected in
    the corresponding microservice. Create a`service.properties` file and add the
    following property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Step 3 – making each microservice Spring Cloud Config-aware using the Spring
    Cloud Config Client component
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The last step is to make the necessary changes to the microservice (configuration
    client) so that the configuration will be propagated by the configuration server
    once it is updated in the Git repository. The important point at this moment is
    to create a new property file called `bootstrap.properties` and copy all the properties
    from the `application.properties` file, or you can directly rename `application.properties`
    to `bootstrap.properties`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The reason is that Spring will process the `bootstrap.properties` file first,
    even before the bootstrap application and configuration server linked with it
    for configuration updates. You need to add a specific property in the `bootstrap.application`
    file, which will be used to connect the microservice with the configuration server,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The configuration server is accessible at `http://localhost:8901`. The microservice
    will fetch the configuration details with this URL. Next, we will access the configuration
    that we declared in the Git repository in the microservice with the REST controller,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: In this controller, we are accessing the configuration with `catalog.sample.data`
    with the `@Value` annotation. This annotation is used to read the properties defined
    in the local `application.properties` file. The magic is that we haven't defined
    any such property for the category service, but it will connect to the configuration
    server and fetch this property value from the Git repository internally.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `@RefreshScope` annotation will be used to fetch the latest configuration
    value whenever any change happens in the Git repository. You need to declare `@RefreshScope`
    for the component where you are reading the configuration value. When you start
    the `catalog-service` microservice, it will try to read the configuration from
    the configuration server, and you can verify it from the log as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: On startup, the `catalog-service` microservice will fetch the configuration
    from Git through the configuration server. This can be verified with the `http://localhost:8792/api/test/getSampleData` REST
    URL. When we make changes in the configuration and commit them to Git, they must
    be propagated to the microservice. This will not be done automatically, and you
    need to manually refresh it with Actuator—a tool provided by Spring Boot to monitor
    and manage applications. We will use the `/refresh` endpoint of Actuator to refresh
    the microservice with the latest configuration changes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Staring with Spring Boot 2.0, certain endpoints of Actuator (including `/refresh`)
    are not enabled by default. To enable them, you need to add the following property
    in the `bootstrap.properties` file of the `catalog-service` microservice:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, all endpoints are available, and configuration propagation can be done
    through a POST request to `http://localhost:8792/actuator/refresh`. Since this
    is a POST call, you need to use a REST client such as Postman. Once the refresh
    is completed, you will see the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'This is how configuration can be applied on the fly without restarting the
    microservice. The whole process can be performed in a series of actions in the
    following order:'
  prefs: []
  type: TYPE_NORMAL
- en: Update the files in the Git repository
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Do the Git commit
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Execute the refresh operation, and you will see the changes reflected in the
    corresponding microservice
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This is a great feature of managing configuration in one central place, and
    it can be applied to specific microservices with ease. However, not all properties
    can be applied this way. For example, application name and database-specific properties
    cannot be applied at runtime through Spring Cloud Config. However, custom configurations
    can be applied dynamically.
  prefs: []
  type: TYPE_NORMAL
- en: Making RESTful calls across microservices with Feign
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In microservice architecture, generally microservices interact with each other
    through HTTP REST web service calls. Typically, `RestTemplate` is used as a client
    to make REST API call programmatically in Spring-based applications. However,
    it requires a good amount of code to make a simple REST call. To make this simple,
    Spring Cloud provides Feign, another REST client that makes REST communication
    alot simpler than `RestTemplate`. Let's see how Feign makes calls to other services
    easy.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, `inventory-service` needs to talk with the `catalog-service` microservice to
    fetch book details. In this case, `inventory-service` will make a REST call to
    fetch a `Book` object for a given `bookId`. This would typically happen with the `RestTemplate`
    client as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'We are using `RestTemplate` to call the `catalog-service` microservice to fetch
    the book details for the given `bookId`. Spring Cloud inherits another component,
    called **Feign**, from Netflix, which can be used as a declarative REST client
    with great simplification. It is easily integrated with Ribbon, which can be used
    as a client-side load-balancer; we will talk about this in the next section. To
    use Feign, you need to add the following starter dependency:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, let''s enable Feign. Open the `bootstrap` class and add a `@EnableDiscoveryClient`
    annotation to scan the Feign client, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we will use Feign to invoke the service. We need to create a Feign proxy
    to talk to other services, just like we use the JPA repository to interact with
    the database. A Feign proxy can be created with Java as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: The `@FeignClient` annotation is used to define the Feign proxy. The `name`
    attribute points to the name of the target microservice declared in the Eureka
    naming server (specified with the `spring.application.name` property in the `application.properties`
    or `bootstrap.properties` file) we want to talk to. `url` is the address at which
    the target microservice is accessible. The `path` attribute is used to add the
    path prefix used by all method-level mapping.
  prefs: []
  type: TYPE_NORMAL
- en: 'We have created the interface method with the same method signature that we
    created in the REST controller. We will use this proxy in the REST controller
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: The instance of `CatalogServiceProxy` is injected by Spring through the `@Autowired`
    annotation. You can see how simple it is to make a RESTful web service. All the
    details are shifted from the controller to the Feign proxy. You will get the same
    output as `RestTemplate`, but the code is decoupled and simplified.
  prefs: []
  type: TYPE_NORMAL
- en: Assume the scenario where you are making more than a dozen REST calls to the `catalog-service` microservice.
    In this case, the Feign proxy helps us to manage all the code in one place. Other
    component classes do not need to know the underlying details.
  prefs: []
  type: TYPE_NORMAL
- en: Load balancing with Ribbon
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the last section, we saw how `inventory-service` can call `catalog-service`
    to fetch book details through Feign. However, in a distributed environment, it
    is quite possible that multiple instances of microservices are created to handle
    the enormous application load.
  prefs: []
  type: TYPE_NORMAL
- en: In a multi-instance environment, a mechanism is required to balance and divide
    a load of input requests seamlessly to send them to available instances. The system
    becomes fault tolerant. It also increases throughput, reduces response time, and
    optimizes resource utilization by avoiding single instances being overloaded.
    This will make the system more reliable and highly available.
  prefs: []
  type: TYPE_NORMAL
- en: Netflix provides a component called Ribbon, which works as a client-side load
    balancer that provides lots of flexibility and control while making HTTP and TCP
    calls. The term **client-side** refers to an individual microservice as Ribbon
    can be used to balance the flow of calls a microservice makes to other services.
  prefs: []
  type: TYPE_NORMAL
- en: Eureka can be easily integrated with Ribbon; however, we can configure Ribbon
    without Eureka. We will see how to configure Ribbon with and without Eureka.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring Ribbon without Eureka
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We are going to configure Ribbon while making calls from `inventory-service`
    to `catalog-service`, so if you have configured Eureka server, just remove it
    for the time being while we learn how Ribbon works without Eureka. The very first
    thing is to add the Ribbon starter dependency. Since we want to handle the call
    initiated from `inventory-service`, and add the dependency in `inventory-service`
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'In the previous section, we configured the Feign client to handle REST calls.
    We will use Ribbon along with the Feign client. Open the proxy class that we created
    in the previous section and add the Ribbon configuration as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'The `@RibbonClient` annotation is used to declare the Ribbon configuration
    with the `name` attribute pointing to the application on which we want to implement
    load balancing. The URL that we have configured with `FeignClient` is now removed
    and can be defined in the `application.properties` file as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: The property name will start with the name of the application that we have used
    with the `@RibbonClient` annotation. We need to define comma-separated URLs, each
    pointing to an individual instance of the `catalog-service` microservice. As per
    this configuration, the Ribbon client will handle the call from `invoice-service`
    to `catalog-service`, which has two instances running on ports `8792` and `8799`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will make the call to the Feign client on `inventory-service`, which eventually
    triggers the call to `catalog-service`. We will observe that the requests are
    divided into two instances of the `catalog-service` microservice. To verify which
    instance the request comes from, we will add the current server port in `BookDTO`,
    which will be shown in the response. The current server port can be obtained as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Spring injects the instance of the `Environment` class, which can be used to
    get current environment details. The current port is accessible with the `local.server.port` property.
    Next up, we will run two instances of the `catalog-service` microservice on these
    ports.
  prefs: []
  type: TYPE_NORMAL
- en: 'To start the Spring Boot application on a specific port, you need to right-click
    on the microservice project, select Run As | Run Configurations, and add the port
    in the Arguments tab with the -Dserver.port argument. You can also append the
    port in Name so that it can be easily identified as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f40a1aed-d764-49c7-8917-ea345252b22e.png)'
  prefs: []
  type: TYPE_IMG
- en: 'To add another instance, you need to right-click on the same instance of `catalog-service`
    created in the previous window, select Duplicate, and follow the same steps. The
    second time, use port `8799` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2f2b1602-77fb-4fc1-b903-eea34d132573.png)'
  prefs: []
  type: TYPE_IMG
- en: Run these two instances along with `inventory-service`. When you access `http://localhost:8793/api/inventory/get-inventory/3`,
    you will see the port is `8792` in the first request and `8799` in the second
    request. This is how the request is routed to a specific instance turn by turn.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring Ribbon with Eureka
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The problem in the first approach is that we still have to define the instance
    URLs manually. With Eureka, we can use its ability to resolve the microservice
    name dynamically and no more hardcore URLs are required. With Eureka, things are
    more straightforward. The Ribbon and Feign configuration will be changed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'No more `url` attributes are required for the `@FeignClient` annotation. Also,
    you can remove the `catalog-service.ribbon.listOfServers` property from the `application.properties`
    file of the `inventory-service` microservice. Start two instances of `catalog-service`
    along with `inventory-service` and make sure Eureka is running before you do.
    You will see two instances of `catalog-service` running in the Eureka console,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b591341b-b3d4-4f6e-ba89-4a2ee6feeaf1.png)'
  prefs: []
  type: TYPE_IMG
- en: When you go to `http://localhost:8793/api/inventory/get-inventory/3`, you will
    get the same behavior. Once the request reaches the instance on port `8792`, the
    second is on `8799`, and the third is also on `8792`. This is how Ribbon is configured
    with Feign to achieve load balancing. You can try creating a few more instances
    and check the behavior. Also, if any of the instances are down, Ribbon will stop
    sending requests to them, which makes the system fault tolerant.
  prefs: []
  type: TYPE_NORMAL
- en: Load balancing using RestTemplate
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Spring Cloud also supports the implementation of load balancing using `RestTemplate`.
    In this case, you need to expose the `RestTemplate` instance with load balancing
    capabilities instead of using it directly, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: In the previous case, the `@LoadBalanced` annotation will do the magic of balancing
    the load between the instances of other services to which we make a REST call.
    You need to inject this object in your controller and make the call with it.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring the API gateway
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In previous sections, we saw how to define Zuul as an API gateway. In subsequent
    sections, we explored other Netflix components, such as Feign and Ribbon, to make
    RESTful calls for inter-service communication. However, the interaction that we
    created happened directly between services. Though we have configured an API gateway
    with Zuul, we have not used it as a central point of the request flow. In this
    section, we will make the necessary configuration changes so that every request
    passes through our API gateway.
  prefs: []
  type: TYPE_NORMAL
- en: 'The very first thing we will learn is to implement a custom filter and configure
    it to the API gateway to trace the request and print it in the log. For simplicity,
    we will capture a few details about the current request. Open the Spring Boot
    application that we created for Zuul and add a filter class as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'For any custom filter, you need to extend an abstract class, `ZuulFilter`,
    which is provided by Netflix. There are certain abstract methods that we need
    to provide the implementation, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`shouldFilter()`: We apply this filter or not based on the return value of
    this method.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`filterType()`: As we have seen, Zuul supports various filters type such as `pre`,
    `post`, `error`*,* and so on. The `pre` filter will be executed after the request
    reaches Zuul and before it is routed to other microservices. Similarly, the `post`
    filter will be executed once the response returns from other microservices, and
    the `error` filter type will be triggered when an error happens in between.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`filterOrder()`: We can define as many filters as we want. This method defines
    their order of priority.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`run()`: This method is the placeholder where you can write your filter logic.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We use will another filter that will be triggered once the response comes back,
    filter type `post`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, let''s see how to access microservices through our API gateway. We have
    exposed a REST API for `inventory-service` as `http://localhost:8793/api/inventory/get-inventory/3`,
    and we will now update this URL to route the request from the API gateway. The
    pattern for the API gateway URL would be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'The Zuul API gateway will use the Eureka naming server to connect to the desired
    microservice. The service name in the previous pattern is the name (with the `spring.application.name` property
    in the `application.properties` or `bootstrap.properties` file) of the service
    registered in the Eureka naming server. The API gateway is accessible with `http://localhost:8781`,
    so to access the `inventory-service` URL with the API gateway, the new URL would
    be `http://localhost:8781/inventory-service/api/inventory/get-inventory/3`. You
    will get the request details in the Zuul log as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'This is how we can trace the request with various filters with the Zuul API
    gateway. However, the call is forwarded from `inventory-service` to `catalog-service`
    with Feign, which is still bypassing the API gateway and making a direct call
    to the microservice. Now, let''s see how to configure Feign so that the call is
    routed through the Zuul API gateway. The original Feign proxy was as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'The updated Feign proxy interface would be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: The change happened in the service name of the `@FeignClient` annotation. Previously,
    it was directly pointing to `catalog-service`, but now it is pointing to the Zuul
    API gateway service. `zuul-api-gateway` is the name of the Zuul API gateway service
    defined with the `spring.application.name` property in the `application.properties`
    file.
  prefs: []
  type: TYPE_NORMAL
- en: Run the URL again, and you will see the logs are printed twice. The loges are
    printed first, when the request reaches `inventory-service`, and second when the
    request is routed from `inventory-service` to `catalog-service` through Feign.
    This is how Zuul is configured to trace every request made across the microservices.
  prefs: []
  type: TYPE_NORMAL
- en: Securing an application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In a typical monolithic application, when the user logs in, an HTTP session
    will be created to hold user-specific information, which will be then used until
    the session expires. The session will be maintained by a common security component
    on the server side and all the requests are passed through it. So, it is straightforward
    to handle user authentication and authorization in a monolithic application.
  prefs: []
  type: TYPE_NORMAL
- en: If we want to follow the same pattern for microservice architecture, we need
    to implement a security component at every microservice level as well as in a
    central place (the gateway API) from where all the requests are routed. This is
    because microservices interact over the network, so the approach of applying security
    constraints is different.
  prefs: []
  type: TYPE_NORMAL
- en: Using Spring Security is a standard practice to meet the security needs of Spring-based
    Java applications. For microservices, Spring Cloud Security (another component
    from Spring Cloud) provides a one-stop solution to integrate Spring Security features
    with various components of the microservice architecture, such as the gateway
    proxy, a configuration server, load balancers, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: In a microservice environment, security concerns can be addressed through widely
    used standard security protocols such as OAuth2 and OpenID Connect. In [Chapter
    4](e36170b7-dbc6-4a4c-b7ba-e4830cd71efd.xhtml), *Building a Central Authentication
    Server*, we talked about OAuth2 in detail. Now, we will see how it can be used
    to meet security needs in a microservice architecture.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see how the OAuth security system works in a microservice architecture.
    The high-level flow of authorization looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2ea779af-d78b-45a3-816f-835331fe7f9a.png)'
  prefs: []
  type: TYPE_IMG
- en: 'To understand the series of actions, let''s take a use case of an order being
    placed by a user of the online bookstore. The whole process happens in the following
    steps:'
  prefs: []
  type: TYPE_NORMAL
- en: A user tries to access the order page through the Zuul proxy server (API gateway)
    and does not have a session or an access token.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The Zuul proxy then redirects a user to an authorization server with pre-configured
    parameters such as grant type, client ID, token URL, and authorization URL.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the user does not log in, the authorization server redirects to the login
    page.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once the user does log in with valid credentials, the authorization server generates
    a token and sends it back to the API gateway.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: On receiving the token, the API gateway (the Zuul proxy server) propagates the
    token downstream to the microservices it is proxying.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For restricted resources, the system will check whether a valid token exists.
    If not, the user will be redirected to the login page (or the token will be refreshed
    based on the grant type configured in the system).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The authentication server will be implemented as a separate microservice and
    registered in the Eureka discovery server. It can be created as a Spring Boot
    application with security-specific starter dependencies as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Spring Cloud Security has different starters for OAuth and standard Spring
    Security for the microservice architecture. Next, we will add the required configurations
    to make this application an authorization server, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: The `@EnableAuthorizationServer` annotation is used to declare the component
    as an authorization server. OAuth can be done with various third-party clients,
    and Spring Security provides support for Google, Facebook, Okta, and GitHub out
    of the box. In our case, we will define a custom authorization server.
  prefs: []
  type: TYPE_NORMAL
- en: The `configure(ClientDetailsServiceConfigurer clients)` method of this class
    is used to define configuration for the custom authorization client. It initializes
    the client with various configurations, such as `ClientId`, secret (a kind of
    client password), possible authorization grant types you want the client to support,
    various scopes that can be used to fine-tune access control, and user authority
    and `resourceId`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Spring OAuth is flexible enough to allow various mechanisms to generate the
    access token, and JWT is one of them. The `tokenStore()` and `tokenService()`
    methods are used to apply the required configuration for JWT. The `configure(AuthorizationServerEndpointsConfigurer
    endpoints)` method is used to configure tokens, along with the authentication
    manager. The `AuthenticationManager` object is injected from the `WebSecurityConfig`
    class as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: This class is responsible for configuring various endpoints, static resources,
    and the login page, along with the authentication mechanism. This is all about
    authorization server configuration. As we know, all requests are routed through
    the Zuul proxy server (an API Gateway), so we must configure it to route the requests
    for restricted resources to the authorization server.
  prefs: []
  type: TYPE_NORMAL
- en: The authorization server provides an access token that will be routed along
    with the request (in the header). When other microservices read it, they will
    verify the access token with the authorization server to allow the user to access
    restricted resources. In short, access tokens will be routed to various microservices.
    This requires some sort of SSO implementation, and with Spring Cloud Security,
    we can do it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Additionally, particular functionality (for example, placing an order) initiated
    by a user will eventually involve interaction with other microservices along with
    the Zuul proxy server, so they are considered resource servers in OAuth terminology.
    First, add the `@EnableOAuth2Sso` annotation to a `bootstrap` class of the Zuul
    proxy application, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'This annotation allows the Zuul proxy server to forward the access token generated
    by the authorization server downstream to other services involved in processing
    the request. The resource server configuration for the Zuul proxy server, as well
    as other microservices, should be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: The `@EnableResourceServer` annotation will enable the component as a resource
    server. `resourceId` should be the same as we configured in the authorization
    server. Also, we are using the same JWT token configuration that we set in the
    authorization server. The `configure` method is used to set the configuration
    for individual microservice endpoints.
  prefs: []
  type: TYPE_NORMAL
- en: 'We also need to set certain properties in the `application.properties` file,
    which will be used by the resource server to interact with the authorization server
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: The authorization server is configured to access `localhost:9999`. The resource
    server configuration, along with previous properties, need to be placed with every
    microservice that we want to access securely through OAuth.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Unlike other chapters and applications that we have seen so far in this book,
    this chapter introduced a new type of application development in a distributed
    environment. The term **microservice** has existed since 2011\. It has emerged
    as an enhancement of previous architectures.
  prefs: []
  type: TYPE_NORMAL
- en: With the introduction of Spring Cloud, developers can provide an implementation
    of various common patterns in a distributed environment. Starting with Spring
    Boot, creating a microservice application just takes a few configurations.
  prefs: []
  type: TYPE_NORMAL
- en: At the beginning of this chapter, we have explored what a microservice is and
    how it differs from the monolithic architecture, followed by various principles
    and criteria that need to be adhered to if you want to develop a microservice
    system. We then explored various Spring Cloud components and other Netflix OSS
    components in brief.
  prefs: []
  type: TYPE_NORMAL
- en: We have also learned how to create a microservice application by building a
    real-life example—an online bookstore application. We started with the application's
    architecture and the database design. We looked at creating microservices as Spring
    Boot applications with the required configurations.
  prefs: []
  type: TYPE_NORMAL
- en: We then saw practical examples of how to build various Netflix OSS and Spring
    Cloud components, such as a Eureka discovery server, a Zuul proxy server, a Feign
    client, Ribbon, and Spring Cloud Config. These components are the building blocks
    for developing a distributed application. We also saw various options and approaches
    to building a microservice frontend. Finally, we secured the application with
    Spring Cloud Security.
  prefs: []
  type: TYPE_NORMAL
- en: Java was the only de facto programming language for building Spring-based applications
    for quite a long time. However, the team at Pivotal (the company behind Spring)
    has started to support other functional programming languages, such as Scala.
    Starting with version 5, Spring announced support for Kotlin, a JVM-based language
    mainly used for Android applications. In the next chapter, we will dive into an
    altogether new way of building Spring applications with Kotlin.
  prefs: []
  type: TYPE_NORMAL
