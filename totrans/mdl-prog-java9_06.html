<html><head></head><body>
        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Module Resolution, Readability, and Accessibility</h1>
                
            
            <article>
                
<p class="calibre2">In the previous chapter, we significantly enhanced the address book viewer application by leveraging multiple platform APIs to add extra functionality. We implemented logging, XML parsing, and a UI module using JavaFX. The address book viewer application has come a long way from its simple <em class="calibre22">Hello world</em> origins. And in the process, you have acquired a good amount of knowledge about the Java module system and you should have the required know-how and tools to build any Java application of similar complexity.</p>
<p class="calibre2">Here's what you will be learning in this chapter:</p>
<ul class="calibre14">
<li class="calibre15">You'll be introduced to two important concepts and related terminologies--readability and accessibility</li>
<li class="calibre15">You'll learn some of the nuances about what makes modules readable and packages accessible</li>
<li class="calibre15">You'll learn some powerful new ways to tweak the default methods of specifying dependencies--implicit dependencies and qualified exports</li>
<li class="calibre15">You'll then apply these two new ways in the address book viewer application to tweak and optimize the dependencies using aggregator modules and qualified exports</li>
</ul>
<p class="calibre2">In this chapter, we'll do a significant deep-dive on some of the concepts we've learned only at a high level along the way. While you can use everything we've covered so far to build various different applications, there are certain nuances to several of the topics covered that will be helpful to learn and understand. Knowing about these concepts will help you use the module system in powerful new ways. In addition, some of the terminologies we'll learn in this chapter will help you understand and describe concepts and processes that run under the hood every time you use the module system.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Readability</h1>
                
            
            <article>
                
<p class="calibre2">Readability is an important concept in modularity and it describes how modules work with each other. We've been using module dependencies to have one module require another module and use its APIs. Whenever a module depends on another module, the first module is said to read the second module. Also, the second module is said to be readable by the first. When a module reads another module, it has access to the types exported by the second module. In other words, the readability relationship between two modules is the arrow in the module graph that we've seen so far.</p>
<p class="calibre2">For example, in the address book viewer application, the module <kbd class="calibre12">packt.addressbook</kbd> <em class="calibre22">reads </em><kbd class="calibre12">packt.sortutil</kbd>, <kbd class="calibre12">packt.contact</kbd>, and <kbd class="calibre12">java.logging</kbd>. That's because it <kbd class="calibre12">requires</kbd> those modules in the module descriptor.</p>
<p class="calibre2">Consider an example. The following diagram shows the relationships between three modules <strong class="calibre1">A</strong>, <strong class="calibre1">B</strong>, and <strong class="calibre1">C</strong>:</p>
<div class="packt_figure"><img class="image-border47" src="../images/00053.jpeg"/></div>
<p class="calibre2"><strong class="calibre1">Module A</strong> <span>requires </span><strong class="calibre1">module B</strong>. So, <strong class="calibre1">module A</strong> <em class="calibre22">reads</em> <strong class="calibre1">module B</strong>. <strong class="calibre1">Module B</strong> is <em class="calibre22">readable</em> by <strong class="calibre1">module A</strong>. <strong class="calibre1">Module C</strong> also <em class="calibre22">reads</em> <strong class="calibre1">module B</strong>. However, <strong class="calibre1">module C</strong> does not read <strong class="calibre1">module A</strong> and vice versa.</p>
<p class="calibre2">As you can tell, the <em class="calibre22">reads</em> relationship is not symmetric. If <strong class="calibre1">module A</strong> <em class="calibre22">reads</em> <strong class="calibre1">module B</strong>, it does not mean that <strong class="calibre1">module B</strong> reads <strong class="calibre1">module A</strong>. In fact, in the Java module system, we can guarantee that the <em class="calibre22">reads</em> relationship between modules is asymmetric. Why? Because if two modules <em class="calibre22">read</em> each other, what we'll end up with is a cyclic dependency, which is not allowed (see <a target="_blank" href="part0081.html#2D7TI0-ed2405f4162b4f86b565edd6b6d679fb" class="calibre4">Chapter 5</a>, <em class="calibre22">Using Platform APIs</em>). So to summarize, firstly, the <em class="calibre22">readability</em> relationship is established through the usage of the <kbd class="calibre12">requires</kbd> clause. Secondly, if a module <em class="calibre22">reads</em> another module, we can guarantee that the second module does not <em class="calibre22">read</em> the first module.</p>
<p class="calibre2">There are, however, two exceptions to this, and you can probably guess what they are, since we've already covered them. First, every module <em class="calibre22">reads</em> the <kbd class="calibre12">java.base</kbd> module. And this dependency is <em class="calibre22">automatic</em> and there's no explicit usage of the <kbd class="calibre12">requires</kbd> qualifier. Secondly, every module <em class="calibre22">reads</em> itself by definition, because a module automatically has access to all the public types in the module by default.</p>
<p class="calibre2">The readability relationship is fundamental to achieving one of the two primary goals of the Java module system--reliable configuration. We want to be able to reliably guarantee that the dependencies of all the modules in an application are satisfied. An additional advantage that we'll see more over time is the performance optimization of these formal modular relationships. No longer does the runtime need to scan the entire class path to find a given type. There are ways in which the runtime can optimally find the right module and thus the location to find types. This is a huge win!</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Accessibility</h1>
                
            
            <article>
                
<p class="calibre2">Accessibility is the other side of the Java modularity coin. If the <em class="calibre22">readability</em> relationship specifies what modules can read a given module, <em class="calibre22">accessibility</em> indicates what they actually do get when they read it. Not everything in a module is accessible to the other modules that read it. Only the public types in packages that are marked with an <kbd class="calibre12">exports</kbd> declaration are.</p>
<p class="calibre2">Thus, for a type in module B to be <em class="calibre22">accessible</em> in module A, the following needs to happen:</p>
<ul class="calibre14">
<li class="calibre15">Module A needs to <em class="calibre22">read</em> module B</li>
<li class="calibre15">Module B needs to export the package that contains the type</li>
<li class="calibre15">The type itself should be <kbd class="calibre12">public</kbd></li>
</ul>
<p class="calibre2">Let's look at an example and examine the readability and accessibility relationships. Consider two modules, <kbd class="calibre12">app</kbd> and <kbd class="calibre12">lib</kbd>. Module <kbd class="calibre12">app</kbd> has a <kbd class="calibre12">requires</kbd> qualifier for module <kbd class="calibre12">lib</kbd>. Module <kbd class="calibre12">lib</kbd> exports its package <kbd class="calibre12">lib.external</kbd>:</p>
<pre class="calibre23">    module app { 
      requires lib; 
    } 
    module lib { 
      exports lib.external; 
    } </pre>
<p class="calibre2">Let's say the <kbd class="calibre12">lib</kbd> module has the following structure:</p>
<div class="packt_figure"><img class="image-border48" src="../images/00054.jpeg"/></div>
<p class="calibre2">It has two packages--<kbd class="calibre12">lib.external</kbd> and <kbd class="calibre12">lib.internal</kbd>. Both packages contain one public interface and one package-private implementation.</p>
<div class="packt_infobox">Note: The implementation classes in this example don't have the <span class="packt_screen"><kbd class="calibre28">public</kbd> </span>keyword in the class declaration, which makes them visible only in the same package. They have the <em class="calibre29">default</em> package-private access level.</div>
<p class="calibre2">Let's try to answer the following questions:</p>
<ol class="calibre17">
<li value="1" class="calibre15">Does module <kbd class="calibre12">app</kbd> read module <kbd class="calibre12">lib</kbd>?</li>
</ol>
<p class="calibre24">This one should be simple. The answer is yes, because of the <kbd class="calibre12">requires</kbd> qualifier.</p>
<ol start="2" class="calibre17">
<li value="2" class="calibre15">Does module <kbd class="calibre12">lib</kbd> read module <kbd class="calibre12">app</kbd>?</li>
</ol>
<p class="calibre24">The answer is no. Hopefully equally simple!</p>
<ol start="3" class="calibre17">
<li value="3" class="calibre15">Is the type <kbd class="calibre12">LibApi</kbd> in module <kbd class="calibre12">lib</kbd> <em class="calibre22">accessible</em> to module <kbd class="calibre12">app</kbd>?</li>
</ol>
<p class="calibre24">Let's verify the two requirements for accessibility. Is the type <kbd class="calibre12">public</kbd>? Yes. Is the type in a package that's exported by the module? Yes. So, the answer is <kbd class="calibre12">LibApi</kbd> <em class="calibre22">is</em> accessible to module <kbd class="calibre12">app</kbd>.</p>
<ol start="4" class="calibre17">
<li value="4" class="calibre15">Is the type <kbd class="calibre12">InternalService</kbd> in module <kbd class="calibre12">lib</kbd> <em class="calibre22">accessible</em> to module <kbd class="calibre12">app</kbd>?</li>
</ol>
<p class="calibre24">No. Because even though the type is <kbd class="calibre12">public</kbd>, it belongs to a package that is not exported in the module definition of the <kbd class="calibre12">lib</kbd> module. The type <kbd class="calibre12">InternalImpl</kbd> is also not accessible to the <kbd class="calibre12">app</kbd> module.</p>
<ol start="5" class="calibre17">
<li value="5" class="calibre15">Is the type <kbd class="calibre12">LibApiImpl</kbd> in module <kbd class="calibre12">lib</kbd> <em class="calibre22">accessible</em> to module <kbd class="calibre12">app</kbd>?</li>
</ol>
<p class="calibre24">The answer is no, because it fails the requirement--is the type public? Since <kbd class="calibre12">LibApiImpl</kbd> <span>is package-private, it is not accessible outside the module, since it's not <kbd class="calibre12">public</kbd>. This is true even though the type belongs to an exported package. This scenario is, however, more interesting with a couple of important lessons we can learn from it. Let's look at them in detail.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Interface and implementation accessibility</h1>
                
            
            <article>
                
<p class="calibre2">What does it mean for an interface to be accessible to a module in Java 9? Quite obviously, it means that you can use the interface type in the code in that module. However, an interface is quite meaningless without an implementation. Does this mean that when you export a public interface (as in <kbd class="calibre12">LibApi</kbd>), but not the implementation (<kbd class="calibre12">LibApiImpl</kbd>), the implementation is essentially useless outside the module? Not quite!</p>
<p class="calibre2">Consider we add a static method in the <kbd class="calibre12">LibApi</kbd> interface to create an instance of <kbd class="calibre12">LibApiImpl</kbd>. We'll also add a handy <kbd class="calibre12">testMethod()</kbd> to the interface for us to call from another module to verify if it works. Notice that while the <kbd class="calibre12">createInstance</kbd> method is creating a new instance of <kbd class="calibre12">LibApiImpl</kbd>, its return type is the interface, and not the implementation. This is important, as we'll see in a bit:</p>
<pre class="calibre23">    package packt.lib.external; 
    public interface LibApi { 
      static LibApi createInstance() { 
        return new LibApiImpl(); 
      } 
      public void testMethod(); 
    } </pre>
<p class="calibre2">Let's build a simple implementation class that prints a message to the console. Note the missing <kbd class="calibre12">public</kbd> keyword in front of the class declaration. This means that this class is package-private, not <kbd class="calibre12">public</kbd>. So, even though it's in the package that's exported by the module, it's not <em class="calibre22">accessible</em> outside the module:</p>
<pre class="calibre23">    package packt.lib.external; 
    class LibApiImpl implements LibApi { 
      public void testMethod() { 
        System.out.println("Test method executed"); 
      } 
    } </pre>
<p class="calibre2">What happens if we access these types outside the <kbd class="calibre12">lib</kbd> module? Let's find out! Let's create a class <kbd class="calibre12">App.java</kbd> in the module <kbd class="calibre12">app</kbd>. Let's first try creating an instance of <kbd class="calibre12">LibApiImpl</kbd>:</p>
<pre class="calibre23">    package packt.app; 
    import packt.lib.external.LibApiImpl; 
    public class App { 
      public static void main(String[] args) { 
        LibApiImpl api = new LibApiImpl(); 
        api.testMethod(); 
      } 
    } </pre>
<p class="calibre2">What happens if we compile this?</p>
<pre class="calibre23"><strong class="calibre1">$ javac --module-source-path src -d out $(find . -name '*.java') 
./src/app/packt/lib/external/App.java:3: error: LibApiImpl is not public in packt.lib.external; cannot be accessed from outside package 
import packt.lib.external.LibApiImpl; 
                         ^ 
...</strong> </pre>
<p class="calibre2">Just as we thought. The package-private class isn't accessible, even though it's in the exported package. How about we use the interface to get its instance?</p>
<pre class="calibre23">    package packt.app; 
    import packt.lib.external.LibApi; 
    public class App { 
      public static void main(String[] args) { 
        LibApi api = LibApi.createInstance(); 
        api.testMethod(); 
      } 
    } </pre>
<p class="calibre2">We are now using the <kbd class="calibre12">createInstance()</kbd> method of the interface <kbd class="calibre12">LibApi</kbd> to create an instance of <kbd class="calibre12">LibApi</kbd>. It then calls <kbd class="calibre12">testMethod</kbd> on that instance. We know that <kbd class="calibre12">LibApi</kbd> is creating a new instance of <kbd class="calibre12">LibApiImpl</kbd>, and we know that that class is not accessible. Will this work now?</p>
<pre class="calibre23"><strong class="calibre1">$ javac --module-source-path src -d out $(find . -name '*.java') 
 
$ java --module-path out -m app/packt.app.App 
  Test method executed</strong> </pre>
<p class="calibre2">It does! Since we are not referring to the type <kbd class="calibre12">LibApiImpl</kbd> directly in the code, the compiler and runtime are perfectly happy to allow access to the instance through the interface. This is a valuable pattern in modules, as this lets you provide APIs that are public while still managing to change and rewrite the implementation underneath. This applies not just for non-public implementation classes in an exported package (as in this case); it also applies to public types sitting in packages that are <em class="calibre22">not</em> exported, thereby being equally inaccessible. So, let's revisit the question. Is the <kbd class="calibre12">LibApiImpl</kbd> accessible outside the module now? The answer is still no. However, the important lesson here is that the accessibility rules apply to usage of types and do not apply to dynamic instances of types at runtime. This is by design and is a great pattern to use to achieve implementation-level encapsulation.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Split packages</h1>
                
            
            <article>
                
<p class="calibre2">Here's a question that some of you might be asking already. The <kbd class="calibre12">LibApiImpl</kbd> class is package-private. So, there's no way it is accessible to a type outside the <kbd class="calibre12">packt.lib.external</kbd> package it is in. So, our attempt to access the type in <kbd class="calibre12">packt.app.App</kbd>, a completely different package, was bound to fail anyway! In fact, it would have failed even in Java 8 or earlier! How about if we try to access it from the same package in another module? If we were to create the same package <kbd class="calibre12">packt.lib.external</kbd> in the <kbd class="calibre12">app</kbd> module and create a new class there, would <em class="calibre22">that</em> class be able to access <kbd class="calibre12">LibApiImpl</kbd>? In this scenario, the consuming class is in the same package. Let's give it a try! You don't have to go too far. Just creating the same package from one module into another module doesn't work. Let's say you recreate the package in the <kbd class="calibre12">app</kbd> module and add any arbitrary Java type in it:</p>
<pre class="calibre23">    package packt.lib.external; 
    public class App { 
      public static void main(String[] args) { 
        System.out.println("Test"); 
      } 
    } </pre>
<p class="calibre2">We are not even using <kbd class="calibre12">LibApiImpl</kbd> here! We've just used the same package in another module. The compilation step will fail with the error:</p>
<pre class="calibre23"><strong class="calibre1">$ javac --module-source-path src -d out $(find . -name '*.java') 
./src/app/packt/lib/external/App.java:1: error: package exists in another module: lib 
package packt.lib.external; 
^ 
1 error </strong></pre>
<p class="calibre2">Yes! A package cannot exist in two modules at the same time. Well, not in two observable modules, at least! In other words, given a package in an application, it should be a part of one and only one module on the module path!</p>
<p class="calibre2">This is a significant deviation from how we've traditionally thought of libraries in Java. Having come this far, I don't have to highlight that modules are different from traditional JAR libraries. But here is yet another aspect that breaks the traditional <em class="calibre22">library</em> paradigm. Traditionally, multiple jars in the class path can contain the same package. We've seen this figure already in <a target="_blank" href="part0021.html#K0RQ0-ed2405f4162b4f86b565edd6b6d679fb" class="calibre4">Chapter 1</a>, <em class="calibre22">Introducing Java 9 Modularity</em>:</p>
<div class="packt_figure"><img class="image-border5" src="../images/00055.jpeg"/></div>
<p class="calibre2">With modules not allowing <em class="calibre22">sharing</em> of packages, or <em class="calibre22">split packages</em> as they're often called, we now end up with a new hierarchy. Modules at the top, packages under them, and then types under packages, as shown in the following diagram with a couple of example modules:</p>
<div class="packt_figure"><img class="image-border49" src="../images/00056.jpeg"/></div>
<p class="calibre2">This now results in another change to the way we think about packages. Packages are not grouping of types in the entire application anymore. Packages are grouping of types only inside a single module. When you create a package, you are <em class="calibre22">forced</em> to choose which module the types should all be in. One advantage of this approach, if we design our packages well, is clearer organization. There are also performance optimizations. The Java class loader internally maps each package to a single module, so when it's looking up types to load, it immediately knows where (and in which module) to find a given type.</p>
<div class="packt_infobox">This restriction of avoiding split packages will come back to be a bitter pain in the neck when migrating legacy Java codebases to Java 9 modules which we'll cover in <a target="_blank" href="part0172.html#5410O0-ed2405f4162b4f86b565edd6b6d679fb" class="calibre27">Chapter 11</a>, <em class="calibre29">Migrating Your Code to Java 9</em>. Also note that there are ways to bypass this restriction by using multiple class loaders, but that's beyond the scope of what we are covering here.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Tweaking modularity</h1>
                
            
            <article>
                
<p class="calibre2">We've looked at two language constructs you can use in the module descriptor--<em class="calibre22">requiring</em> modules and <em class="calibre22">exporting</em> packages. Together, they give you sufficient control over the interface of your modules and they address the two main goals of modularity--reliable configuration and strong encapsulation. However, in many real-world situations, you might sometimes find that these two alone are not enough to achieve certain things you want to do. For example, you may want to <kbd class="calibre12">export</kbd> a package from a module, only for it to be consumed by a certain other module, and not for public consumption. To handle many such special cases, the module system has some powerful features that we'll take a look at in this part of the chapter.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Implied readability</h1>
                
            
            <article>
                
<p class="calibre2">We looked at the problem of dependency leakage in <a target="_blank" href="part0081.html#2D7TI0-ed2405f4162b4f86b565edd6b6d679fb" class="calibre4">Chapter 5</a>, <em class="calibre22">Using Platform APIs</em>. The module that you depend on might have APIs that might also require you to use another module. Here's an example:</p>
<div class="packt_figure"><img class="image-border50" src="../images/00057.jpeg"/></div>
<pre class="calibre23">    module A { 
      requires B; 
    } 
 
    module B { 
      requires C; 
    } </pre>
<p class="calibre2">The module A  <kbd class="calibre12">requires</kbd> module B, which in turn <kbd class="calibre12">requires</kbd> C. We know that with this, A does not read C, since module dependencies are not <em class="calibre22">transitive</em> in nature. But what if it needs to? For instance, if B has an API whose return type is in module C.</p>
<p class="calibre2">A good example can be found in the platform module itself. Let's say you write your custom module that reads <kbd class="calibre12">java.sql</kbd>. And you'd like to use the <kbd class="calibre12">Driver</kbd> interface from the module. The <kbd class="calibre12">Driver</kbd> interface has a method called <kbd class="calibre12">getParentLogger()</kbd> that returns the type <kbd class="calibre12">Logger</kbd>. Here's what the method in the <kbd class="calibre12">Driver</kbd> interface looks like:</p>
<pre class="calibre23">    Logger getParentLogger() throws SQLFeatureNotSupportedException </pre>
<p class="calibre2">Here's your code in your custom module that calls the API from <kbd class="calibre12">java.sql</kbd>:</p>
<pre class="calibre23">    Logger myLogger = driver.getParentLogger();  </pre>
<p class="calibre2">To get this to work, you just need to add requires <kbd class="calibre12">java.sql</kbd> in your module definition, and you should be good to go, right? Not so fast! Think about the return type <kbd class="calibre12">Logger</kbd>. That type is actually coming from <kbd class="calibre12">java.logging</kbd>, like we've already seen. The <kbd class="calibre12">java.sql</kbd> module depends on <kbd class="calibre12">java.logging</kbd> for logging capabilities, so it isn't a problem for <em class="calibre22">that</em> module. But how about yours?</p>
<div class="packt_figure"><img class="image-border51" src="../images/00058.jpeg"/></div>
<p class="calibre2">Since <kbd class="calibre12">yourmodule</kbd> does not directly require <kbd class="calibre12">java.logging</kbd>, in order to use the <kbd class="calibre12">java.sql</kbd> API, you'd have to <kbd class="calibre12">require</kbd> the <kbd class="calibre12">java.logging</kbd> module too!</p>
<div class="packt_figure"><img class="image-border52" src="../images/00059.jpeg"/></div>
<p class="calibre2">As you can tell, this is not very convenient. If the usage of a certain module requires the use of other modules too, it just adds to the complexity of the API. Here, you'd need to have some documentation for the developers that says, <em class="calibre22">If you happen to use java.sql, don't forget to also require java.logging</em>.</p>
<p class="calibre2">Is there a better way? Although dependencies aren't transitive by default, what we'd like is the ability to selectively make only certain dependencies transitively available, for situations like this. Thankfully, this is possible in Java 9 by using the <kbd class="calibre12">transitive</kbd> keyword. When you declare <kbd class="calibre12">requires</kbd> on a module, you can also have that module be available and readable to any modules that depend on your module. The way to use this feature is like this--<kbd class="calibre12">requires transitive &lt;module-name&gt;;</kbd></p>
<p class="calibre2">In the following example, module A requires B. But module B <em class="calibre22">requires transitive C</em>:</p>
<pre class="calibre23">    module A { 
      requires B; 
    } 
 
    module B { 
      requires transitive C; 
    } </pre>
<p class="calibre2">Now, module C is readable by not only module B, but by all other modules that read module B. So here, A gets to read C too!</p>
<p class="calibre2">Notice that the <kbd class="calibre12">transitive</kbd> keyword is adding an additional semantic to the <kbd class="calibre12">requires</kbd> keyword. The line <kbd class="calibre12">requires transitive C</kbd> now makes C readable by all modules that read B, while at the same time retaining the meaning of <kbd class="calibre12">requires</kbd> that we've known all along--that B needs to read C too!</p>
<p class="calibre2">How does this affect the <em class="calibre22">readability</em> relationship we have just discussed? We know that A <em class="calibre22">reads</em> B because of the explicit <kbd class="calibre12">requires</kbd> relationship? But does A <em class="calibre22">read</em> C as well? The answer is yes, and this kind of readability relationship is referred to as <em class="calibre22">implied readability</em>. The relationship is not <em class="calibre22">explicit</em>, since there's no direct dependency declared by A on C. The readability is implied due to its transitive nature.</p>
<p class="calibre2">This feature is leveraged in the <kbd class="calibre12">java.sql</kbd> module to solve the problem with the <kbd class="calibre12">Logger</kbd> return type. If you run <kbd class="calibre12">java -d</kbd> on <kbd class="calibre12">java.sql</kbd>, you'll see this:</p>
<pre class="calibre23"><strong class="calibre1">$ java -d java.sql 
  module java.sql@9 
  exports java.sql 
  exports javax.sql 
  exports javax.transaction.xa 
  requires transitive java.logging 
  requires transitive java.xml 
  requires mandated java.base 
  uses java.sql.Driver</strong> </pre>
<p class="calibre2">Notice that the two modules <kbd class="calibre12">java.xml</kbd> and <kbd class="calibre12">java.logging</kbd> that <kbd class="calibre12">java.sql</kbd> requires are both marked <kbd class="calibre12">transitive</kbd>. Like we've just seen, this means that any module that requires <kbd class="calibre12">java.sql</kbd> <em class="calibre22">will</em> get access to the APIs in <kbd class="calibre12">java.xml</kbd> and <kbd class="calibre12">java.logging</kbd> automatically! This is a decision taken by the platform team because using many of the APIs in <kbd class="calibre12">java.sql</kbd> requires the use of the other two modules as well. So rather than having all the developers remember to <kbd class="calibre12">require</kbd> those too, the platform has made it <em class="calibre22">automatic</em>. This is why any module that depends on <kbd class="calibre12">java.sql</kbd> and calls the <kbd class="calibre12">Driver.getParentLogger()</kbd> will have no problems using the <kbd class="calibre12">Logger</kbd> type, since that module will have an implied readability on <kbd class="calibre12">java.logging</kbd>:</p>
<div class="packt_figure"><img class="image-border53" src="../images/00060.jpeg"/></div>
<p class="calibre2">Note that you need to be cautious about adding a lot of transitive dependencies in your modules. I mentioned dependency leakage in <a target="_blank" href="part0081.html#2D7TI0-ed2405f4162b4f86b565edd6b6d679fb" class="calibre4">Chapter 5</a>, <em class="calibre22">Using Platform APIs</em>, and how it's better to have all of your module's dependencies restricted in usage in your module. Any usage of APIs that the module exposes should only need to deal with types that are all exposed and available in the same module as well. The concept of transitive dependencies in a way seems to run counter to that philosophy. Thanks to <kbd class="calibre12">transitive</kbd>, any dependency leakages can be handled easily by making the modules containing the leaked types as <kbd class="calibre12">requires transitive</kbd>. But that's a slippery slope. Imagine having to depend on a module and inadvertently getting a dozen other module dependencies because they are all marked <kbd class="calibre12">requires transitive</kbd> in the module you need! Such module designs clearly violate the principles of modularity, and I highly recommend avoiding them unless absolutely required.</p>
<p class="calibre2">There is, however, a really interesting and handy usage of transitive dependencies that will help library developers. That is <em class="calibre22">aggregator modules</em>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Aggregator modules</h1>
                
            
            <article>
                
<p class="calibre2">An aggregator module is a module that does not provide any functionality on its own, but instead, its sole purpose is to gather and bundle together a bunch of other modules. As the name implies, these modules <em class="calibre22">aggregate</em> several other modules.</p>
<p class="calibre2">Let's assume you have a group of your favorite library modules that you often use together in your applications. Let's say this is a list of some core libraries, and whenever you write a module, it's very likely that you'll use pretty much every library in that list. Now, using every module in that list in any of your own modules involves specifying each of those modules using the <kbd class="calibre12">requires</kbd> clause. Depending on how big that list is, it can be tedious to specify the same set of core dependencies in every one of your module descriptors. Even if you were to do that once, it's hard to change the list of core libraries, perhaps to add a new one. Your only option would be to go through all your module descriptors again and make that change. Wouldn't it be nice if you could create a new module that bundles all your core libraries? That way you have the list in one place and you don't have to specify the complete list anywhere else. Any module that needs all those libraries can now express a dependency to this new <em class="calibre22">module bundle</em>! You can do just that by creating an essentially <em class="calibre22">empty</em> module with all the dependencies transitive.</p>
<p class="calibre2">Consider this example:</p>
<pre class="calibre23">    module librarybundle { 
      requires transitive core.foo; 
      requires transitive core.foo; 
      requires transitive core.baz; 
    } </pre>
<p class="calibre2">Here's a module called <kbd class="calibre12">librarybundle</kbd> that does not really export <em class="calibre22">anything</em>, since there are no <kbd class="calibre12">exports</kbd> packages specified in the module descriptor. This module doesn't really need to contain a single Java class! What it does do, however, is <kbd class="calibre12">requires transitive</kbd> three other libraries. So, any module that depends on the <kbd class="calibre12">librarybundle</kbd> module automatically reads those three libraries too.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Java platform aggregator modules</h1>
                
            
            <article>
                
<p class="calibre2">The Java platform has a couple of aggregator modules to represent the <em class="calibre22">complete</em> JRE, at least as we knew it in Java 8 and earlier. The <kbd class="calibre12">java.se</kbd> module essentially re-exports the entire Java SE platform. The <kbd class="calibre12">java.se.ee</kbd> module contains the subset of the platform that overlaps with Java EE and contains APIs such as web services, transactions, and the legacy CORBA APIs.</p>
<p class="calibre2">Running <kbd class="calibre12">java -d</kbd> on the <kbd class="calibre12">java.se</kbd> module shows us how it's implemented:</p>
<pre class="calibre23"><strong class="calibre1">$ java -d java.se
  java.se@9<br class="title-page-name"/>  requires java.scripting transitive<br class="title-page-name"/>  requires java.xml transitive<br class="title-page-name"/>  requires java.management.rmi transitive<br class="title-page-name"/>  requires java.logging transitive<br class="title-page-name"/>  requires java.sql transitive<br class="title-page-name"/>  requires java.base mandated<br class="title-page-name"/>  ...</strong></pre>
<p class="calibre2">Again, I hope you resist the temptation to use these aggregator modules in any new modules you create in your Java 9 code. You could practically throw in <kbd class="calibre12">requires java.se</kbd> in all your module definitions and not have to worry about doing any other <kbd class="calibre12">requires</kbd> ever again! But that again defeats the purpose of modularity and you are back to using the Java platform the way we did in Java 8 and earlier--by depending on the entirety of the platform APIs irrespective of what part of them you really need. These aggregator modules are mainly to be used for legacy code migration purposes, and that too as a temporary measure, in an attempt to get to more fine-grained dependencies eventually.</p>
<p class="calibre2">Although the <kbd class="calibre12">java.se.ee</kbd> module is deprecated and is not encouraged for use, there's an interesting observation to be made by examining it. While <kbd class="calibre12">java.se.ee</kbd> is a super set that includes all modules in <kbd class="calibre12">java.se</kbd> and then some more, its module definition doesn't re-declare a entire list of all the modules in the platform. What it does is simply require transitive the <kbd class="calibre12">java.se</kbd> module:</p>
<pre class="calibre23"><strong class="calibre1">$ java -d java.se.ee<br class="title-page-name"/>  java.se.ee@9<br class="title-page-name"/>  requires java.corba transitive<br class="title-page-name"/>  requires java.base mandated<br class="title-page-name"/>  ...<br class="title-page-name"/>  requires java.se transitive<br class="title-page-name"/></strong></pre>
<p class="calibre2">You can use this approach in your own modules to create aggregator modules of other aggregator modules! Pretty powerful stuff!</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Qualified exports</h1>
                
            
            <article>
                
<p class="calibre2">In the previous section, we looked at transitive dependencies that let us tweak the <em class="calibre22">readability</em> relationship between modules to handle some special use cases. In this section, you'll be introduced to a way you can tweak the <em class="calibre22">accessibility</em> relationships in some special cases. This can be done using a feature called <strong class="calibre1">qualified exports</strong>. Let's learn what they are.</p>
<p class="calibre2">You've already learned that the <kbd class="calibre12">exports</kbd> keyword lets you specify which packages in a module are allowed to be used outside the module. The exported packages form the <em class="calibre22">public contract</em> of the module, and any module that reads such a module automatically gets <em class="calibre22">accessibility</em> to those exported packages.</p>
<p class="calibre2">But there is a catch here! Ideally, you'd like to design your modules and APIs as standalone entities and you always have a clear idea about what the modules should export. But you might encounter real-world scenarios where that isn't the case. Sometimes you'll have to design modules to make them work well with others, and that incurs an interesting cost.</p>
<p class="calibre2">Consider that you have built a library module called <strong class="calibre1">B</strong> that is being used by a consumer module <strong class="calibre1">A</strong>:</p>
<div class="packt_figure"><img class="image-border54" src="../images/00061.jpeg"/></div>
<p class="calibre2">The developer of module A can obviously call the exported APIs of B now. But then, it so happens that they also need this one other API in module B that isn't exported yet. You didn't initially want to export that private package from module B because it's not something that's commonly needed outside B, but it turns out there's just one other module, module A, that really needs it! So, to make the developer of module A happy, you add that private package to the <kbd class="calibre12">exports</kbd> list from module B:</p>
<pre class="calibre23">    module B { 
      exports moduleb.public; 
      exports moduleb.privateA; // required only for module A 
    } </pre>
<p class="calibre2">After a while, a new module, module C, depends on module B. It too has an interesting use case where it needs another private API from module B. It's very likely that it's only C that'll ever need that API outside of B, but in order to make module C work, you have no option but to add that package to the exported packages of module B:</p>
<pre class="calibre23">    module B { 
      exports moduleb.public; 
      exports moduleb.privateA; // required only for module A 
      exports moduleb.privateC; // required only for module C 
    } </pre>
<p class="calibre2">I hope you notice the problem already. Now two originally private packages in module B are now public for use by every module that reads B, although the intent for exporting those packages was to satisfy two very small and specific use cases. If this goes on, the exported APIs in your module end up being the greatest common set of APIs that are sure to keep every consumer module happy. In the process, you've lost the advantages of encapsulation. Now that an internal package is exported, albeit with the intention to satisfy one module, it is available for <em class="calibre22">any</em> module to use. Wouldn't it be great if when exporting packages to a module, you could selectively specify <em class="calibre22">which modules</em> the packages need to be exported to? If so, then only those selected modules could access those specially exported packages. All other modules would only get the <em class="calibre22">publicly exported </em>packages.</p>
<p class="calibre2">This is possible using qualified exports. The <kbd class="calibre12">exports</kbd> clause in the module definition optionally lets you specify which module you need to export the package to. If you do that, the <kbd class="calibre12">export</kbd> is not public anymore. Only the module you specify has access to it. The syntax is:</p>
<pre class="calibre23">    exports &lt;package-name&gt; to &lt;module1&gt;, &lt;module2&gt;,... ;</pre>
<p class="calibre2">Applying this concept to our example module B, we can still have better encapsulation of our private packages by selectively giving modules A and C access to what they alone need:</p>
<pre class="calibre23">    module B { 
      exports moduleb.public;        // Public access to every module <br class="title-page-name"/>                                        that reads me  
      exports moduleb.privateA to A; // Exported only to module A 
      exports moduleb.privateC to C; // Exported only to module C 
    } </pre>
<p class="calibre2">With this change, package <kbd class="calibre12">moduleb.privateA</kbd> is <em class="calibre22">accessible</em> to A, but not to B or any other module that reads B. Similarly, <kbd class="calibre12">moduleb.privateC</kbd> is <em class="calibre22">accessible</em> only by C. Now, while the private APIs are still not fully encapsulated, you at least know for sure what modules they are accessed by, and so any changes are easier to manage.</p>
<p class="calibre2">An example usage of this feature in the Java platform is in the <kbd class="calibre12">java.base</kbd> module. This module contains a lot of core internal packages that have been deemed <em class="calibre22">internal</em> and that we Java developers are ideally not supposed to use. Unfortunately, other platform modules still need to use them, and encapsulating these internal packages prevents access to those platform modules too! Thus, you'll see a lot of these qualified exports where the internal APIs are exported just to the platform modules that need them. You can run the <kbd class="calibre12">java -d</kbd> command on <kbd class="calibre12">java.base</kbd> to see many instances of these:</p>
<pre class="calibre23"><strong class="calibre1">$ java -d java.base 
  module java.base@9
  ... 
  exports jdk.internal.ref to java.desktop, javafx.media 
  exports jdk.internal.math to java.desktop 
  exports sun.net.ext to jdk.net 
  exports jdk.internal.loader to java.desktop, java.logging,<br class="title-page-name"/>   </strong><strong class="calibre1">java.instrument, jdk.jlink</strong></pre>
<p class="calibre2">Remember that using qualified exports is generally not recommended. The principles of modularity recommend that a module should not be aware of who the consumers are. Qualified exports, by definition, add a certain level of coupling between two modules. The coupling is not forced--if you have a qualified export to a certain module, and that module isn't even in the module path to take advantage of it, there are no errors. But the coupling is there nevertheless, and so it's not a good idea to use qualified exports unless it's absolutely required.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Applying the concepts to address book viewer</h1>
                
            
            <article>
                
<p class="calibre2">We've learned about a couple of powerful ways in which we can tweak the <em class="calibre22">default</em> behavior of module dependencies in Java 9. Let's get hands-on now and apply some of these to our address book viewer application.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Creating a custom aggregator module</h1>
                
            
            <article>
                
<p class="calibre2">Notice that we have two modules in the address book viewer application that provides a view of the address book. The <kbd class="calibre12">packt.addressbook</kbd> module shows a simple list of contacts in command line. The <kbd class="calibre12">packt.addressbook.ui</kbd> module shows the address book contacts and details in UI form. Both these modules happen to use the two utility modules to get the list of contacts (<kbd class="calibre12">packt.contact</kbd>) and to sort them (<kbd class="calibre12">sort.util</kbd>). Here, we have just two modules, so it's not that big of a deal to add the requires descriptor for both of these modules in two places. But imagine if there were many more libraries and many more consumers! You'd be duplicating the list multiple times.</p>
<p class="calibre2">To avoid that, let's create an aggregator module that bundles and re-exports the <kbd class="calibre12">packt.contact</kbd> and <kbd class="calibre12">sort.util</kbd> modules. We can then have the <kbd class="calibre12">packt.addressbook</kbd> and <kbd class="calibre12">packt.addressbook.ui</kbd> modules depend on the aggregator module directly.</p>
<p class="calibre2">Let's call the aggregator module <kbd class="calibre12">packt.addressbook.lib</kbd>. This module acts as the <em class="calibre22">library</em> for all <kbd class="calibre12">addressbook</kbd> modules. Create a directory with the name of the module in the <kbd class="calibre12">src</kbd> folder and add the following code in its module descriptor:</p>
<pre class="calibre23">    module packt.addressbook.lib {   
      requires transitive packt.contact; 
      requires transitive packt.sortutil; 
    } </pre>
<p class="calibre2">This is actually the only file that this module would need. It doesn't provide any APIs of its own. It just has the module descriptor that <kbd class="calibre12">requires transitive</kbd> all the modules that it wants to re-export. Here, we choose for it to re-export the two custom utility modules we've created. We have the option here to add <kbd class="calibre12">requires transitive</kbd> on some of the platform modules as well, like <kbd class="calibre12">java.logging</kbd>. But we'll just stick with our custom modules for now.</p>
<p class="calibre2">The next step is to go to the consumer modules and change the direct dependencies to the aggregator module instead.</p>
<p class="calibre2">Here's the module descriptors for the two address book modules:</p>
<pre class="calibre23">    module packt.addressbook {   
      requires java.logging; 
      requires packt.addressbook.lib; 
    }<br class="title-page-name"/>    module packt.addressbook.ui { 
      exports packt.addressbook.ui;  
      requires java.logging; 
      requires javafx.base; 
      requires javafx.controls; 
      requires javafx.graphics; 
      requires packt.addressbook.lib; 
    } </pre>
<p class="calibre2">Compile and execute the two modules, and you should still see the output as before. Here's the updated dependency graph of our address book application now, excluding the platform modules. Notice that the transitive dependencies are illustrated with a dotted arrow to convey that while the dependency is not direct, it's still there!</p>
<div class="packt_figure"><img class="image-border55" src="../images/00062.gif"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Optimizing module imports</h1>
                
            
            <article>
                
<p class="calibre2">In the previous chapter, we created the GUI address viewer module that required the Java FX modules necessary for building the UI. Here's what the module descriptor looked like:</p>
<pre class="calibre23">    module packt.addressbook.ui { 
      exports packt.addressbook.ui;  
      requires java.logging; 
      requires javafx.base; 
      requires javafx.controls; 
      requires javafx.graphics; 
      requires packt.addressbook.lib; 
    } </pre>
<p class="calibre2">We'll now see that not all the modules imported are actually required, and we can optimize this list a bit, thanks to our new knowledge of transitive dependencies. Running <kbd class="calibre12">java -d</kbd> on <kbd class="calibre12">javafx.controls</kbd> gives us:</p>
<pre class="calibre23"><strong class="calibre1">$ java -d javafx.controls 
  module javafx.controls@9
  ... 
  requires transitive javafx.base 
  requires transitive javafx.graphics </strong></pre>
<p class="calibre2">Turns out the <kbd class="calibre12">javafx.base</kbd> and <kbd class="calibre12">javafx.graphics</kbd> modules are transitive dependencies of <kbd class="calibre12">javafx.controls</kbd> already. So, any module that <em class="calibre22">reads </em><kbd class="calibre12">javafx.controls</kbd> also <em class="calibre22">reads </em><kbd class="calibre12">javafx.base</kbd> and <kbd class="calibre12">javafx.graphics</kbd>! So, we can remove those two modules and just declare our dependency on <kbd class="calibre12">javafx.controls</kbd>, since that module alone pulls in all the dependencies we need. Here's the updated module descriptor for <kbd class="calibre12">packt.addressbook.ui</kbd>:</p>
<pre class="calibre23">    module packt.addressbook.ui { 
      exports packt.addressbook.ui;  
      requires java.logging; 
      requires javafx.controls; 
      requires packt.addressbook.lib; 
    } </pre>
<p class="calibre2">You should be able to recompile and execute the UI module to make sure things still work just the same.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Optimizing module exports</h1>
                
            
            <article>
                
<p class="calibre2">At the end of the previous chapter, we begrudgingly added the <kbd class="calibre12">exports</kbd> qualifier for the package containing the main JavaFX class in the module descriptor for the <kbd class="calibre12">packt.addressbook.ui</kbd> module. We did this because the way the JavaFX framework works, it needs to be able to access the class that extends <kbd class="calibre12">javafx.application.Application</kbd> that launches the UI application. We said how that isn't an ideal solution because not only are we exporting the package to the JavaFX framework, we are essentially exporting it to the whole world, that is, any module that reads <kbd class="calibre12">packt.addressbook.ui</kbd>.</p>
<p class="calibre2">With our new knowledge of qualified exports, we have just the solution for this problem! Instead of exporting <kbd class="calibre12">packt.addressbook.ui</kbd> globally, we can use a qualified export in order to export it just to the JavaFX module. Here, the module that needs access to the class is the module <kbd class="calibre12">java.graphics</kbd>. We've removed the explicit dependency, although the dependency is still implicitly there! With the qualified export to <kbd class="calibre12">java.graphics</kbd>, here's what the module descriptor looks like:</p>
<pre class="calibre23">    module packt.addressbook.ui {   
      exports packt.addressbook.ui to javafx.graphics;  
      requires java.logging; 
      requires javafx.controls; 
      requires packt.addressbook.lib; 
    } </pre>
<p class="calibre2">Again, you should be able to compile and run the code to make sure everything works well. With this change, you've retained encapsulation of the <kbd class="calibre12">Main</kbd> class while still making it available to the right JavaFX framework module that needs access to it.</p>
<p class="calibre2">There is a slightly better way to achieve this by using the  <kbd class="calibre12">opens</kbd> keyword if the problem is with reflective access only. We can use the concept of open modules. We'll be covering open modules in detail in <a target="_blank" href="part0134.html#3VPBC0-ed2405f4162b4f86b565edd6b6d679fb" class="calibre4">Chapter 9</a>, <em class="calibre22">Module Design Patterns and Strategies</em>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Summary</h1>
                
            
            <article>
                
<p class="calibre2">In this chapter, you've learned some important concepts and terminologies related to modularity, including <em class="calibre22">readability</em> and <em class="calibre22">accessibility</em>. You've also learned how the default behavior of the module system can be tweaked for certain specialized needs--using implied dependencies and qualified exports. And more importantly, you've understood some scenarios where such needs might be required, like aggregator modules and certain encapsulation challenges, and how these tweaks might be useful in such cases. We then looked at a few places in the address book viewer application where these tweaks helped us optimize and simplify dependencies while improving encapsulation.</p>
<p class="calibre2">In the next chapter, you'll learn about a whole new way of handling depended abstractions using a powerful concept in Java modularity--using services.</p>


            </article>

            
        </section>
    </body></html>