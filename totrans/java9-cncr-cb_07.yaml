- en: Concurrent Collections
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Using non-blocking thread-safe deques
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using blocking thread-safe deques
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using blocking thread-safe queue ordered by priority
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using thread-safe lists with delayed elements
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using thread-safe navigable maps
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using thread-safe HashMaps
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using atomic variables
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using atomic arrays
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the volatile keyword
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using variable handles
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Data structure** is a basic element of programming. Almost every program
    uses one or more types of data structure to store and manage data. The Java API
    provides the **Java Collections framework**. It contains interfaces, classes,
    and algorithms that implement a lot of different data structures that you can
    use in your programs.'
  prefs: []
  type: TYPE_NORMAL
- en: When you need to work with data collections in a concurrent program, you must
    be very careful with the implementation you choose. Most collection classes do
    not work with concurrent applications because they can't control concurrent access
    to their data. If a concurrent task shares a data structure that is unable to
    work with another concurrent task, you might have data inconsistency errors that
    will affect the operation of the program. One example of this kind of data structure
    is the `ArrayList` class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Java provides data collection processes that you can use in your concurrent
    programs without any problems or inconsistency. Basically, Java provides two kinds
    of collections to use in concurrent applications:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Blocking collections**: This kind of collection includes operations to add
    and remove data. If the operation can''t be done immediately, because the collection
    is either full or empty, the thread that makes the call will be blocked until
    the operation could be carried out.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Non-blocking collections**: This kind of collection also includes operations
    to add and remove data. But in this case, if the operation can''t be done immediately,
    it returns a `null` value or throws an exception; the thread that makes the call
    won''t be blocked here.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Through the recipes in this chapter, you will learn how to use some Java collections
    in your concurrent applications. These include:'
  prefs: []
  type: TYPE_NORMAL
- en: Non-blocking deques, using the `ConcurrentLinkedDeque` class
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Blocking deques, using the `LinkedBlockingDeque` class
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Blocking queues to be used with producers and consumers of data, using the `LinkedTransferQueue`
    class
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Blocking queues that order elements by priority, using the `PriorityBlockingQueue`
    class
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Blocking queues with delayed elements, using the `DelayQueue` class
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Non-blocking navigable maps, using the `ConcurrentSkipListMap` class
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Non-blocking hash tables, using the `ConcurrentHashMap` class
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Atomic variables, using the `AtomicLong` and `AtomicIntegerArray` classes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Variables stored in fields marked with the `volatile` keyword
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Atomic operations on the fields of individual classes, using variable handles.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using non-blocking thread-safe deques
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '"List" is referred to as the most basic collection. It has an undetermined
    number of elements, and you can add, read, or remove an element from any position.
    Concurrent lists allow various threads to add or remove elements from the list
    at a time, without producing any data inconsistency errors. Similar to lists,
    we have deques. A deque is a data structure similar to a queue, but in a deque,
    you can add or remove elements from either the front (head) or back (tail).'
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, you will learn how to use a non-blocking deque in a concurrent
    program. Non-blocking deques provide operations that, if not done immediately
    (for example, you want to get an element from a list but the list is empty), throw
    an exception or return a `null` value, depending on the operation. Java 7 introduced
    the `ConcurrentLinkedDeque` class that implements a non-blocking concurrent deque.
  prefs: []
  type: TYPE_NORMAL
- en: 'We are going to implement an example with the following two different tasks:'
  prefs: []
  type: TYPE_NORMAL
- en: One that adds thousands of elements to the deque
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: One that removes data from the deque
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The example of this recipe has been implemented using the Eclipse IDE. If you
    use Eclipse or a different IDE, such as NetBeans, open it and create a new Java
    project.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Follow these steps to implement the example:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a class named `AddTask` and specify that it implements the `Runnable`
    interface:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Declare a private `ConcurrentLinkedDeque` attribute parameterized by the `String`
    class named `list`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement the constructor of the class to initialize its attribute:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement the `run()` method of the class. This method will have a loop with
    5000 cycles. In each cycle, we will take the first and last elements of the deque
    so we will take a total of 10,000 elements:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a class named `PollTask` and specify that it implements the `Runnable`
    interface:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Declare a private `ConcurrentLinkedDeque` attribute parameterized by the `String`
    class named `list`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement the constructor of the class to initialize its attribute:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement the `run()` method of the class. It takes out 10,000 elements of
    the deque in a loop with 5,000 steps, taking off two elements in each step:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement the main class of the example by creating a class named `Main` and
    adding the `main()` method to it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a `ConcurrentLinkedDeque` object parameterized by the `String` class
    named `list`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Create an array of 100 `Thread` objects named `threads`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Create 100 `AddTask` objects and threads to run each one of them. Store every
    thread in the array created earlier and start them:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Wait for the completion of the threads using the `join()` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Write the size of the list in the console:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Create 100 `PollTask` objects and threads to run each one of them. Store every
    thread in the array created earlier and start them:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Wait for the finalization of the threads using the `join()` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Write the size of the list in the console:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this recipe, we used the `ConcurrentLinkedDeque` object parameterized by
    the `String` class to work with a non-blocking concurrent deque of data. The following
    screenshot shows the output of an execution of this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00043.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: First, you executed 100 `AddTask` tasks to add elements to the list. Each one
    of these tasks inserts 10,000 elements to the list using the `add()` method. This
    method adds new elements at the end of the deque. When all the tasks had finished,
    you wrote the number of elements of the deque in the console. At that moment,
    the deque had 1,000,000 elements.
  prefs: []
  type: TYPE_NORMAL
- en: Then, you executed 100 `PollTask` tasks to remove elements from the deque. Each
    one of these tasks removes 10,000 elements from the deque using the `pollFirst()`
    and `pollLast()` methods. The `pollFirst()` method returns and removes the first
    element of the deque, and the `pollLast()` method returns and removes the last
    element of the deque. If the deque is empty, they return a `null` value. When
    all the tasks had finished, you wrote the number of elements of the deque in the
    console. At that moment, the list had zero elements. Take into account that the
    `ConcurrentLinkedDeque` data structure doesn't allow you to add `null` values.
  prefs: []
  type: TYPE_NORMAL
- en: To write the number of elements in the deque, you used the `size()` method.
    You have to take into account that this method can return a value that is not
    real, especially if you use it when there are threads adding to or deleting data
    from the list. The method has to traverse the entire deque to count the elements,
    and the contents of the list can change with this operation. Only if you use them
    when there aren't any threads modifying the deque, you will have the guarantee
    that the returned result would be correct.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `ConcurrentLinkedDeque` class provides more methods to get elements from
    the deque:'
  prefs: []
  type: TYPE_NORMAL
- en: '`getFirst()` and `getLast()`: These methods return the first and last element
    from the deque, respectively. They don''t remove the returned element from the
    deque. If the deque is empty, they throw a `NoSuchElementExcpetion` exception.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`peek()`, `peekFirst()`, and `peekLast()`: These methods return the first and
    the last element of the deque, respectively. They don''t remove the returned element
    from the deque. If the deque is empty, they return a `null` value.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`remove()`, `removeFirst()`, and `removeLast()`: These methods return the first
    and last element of the deque, respectively. They remove the returned element
    as well. If the deque is empty, they throw a `NoSuchElementException` exception.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using blocking thread-safe deques
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The most basic collection is referred to as a list. A list has an unlimited
    number of elements, and you can add, read, or remove an element from any position.
    A concurrent list allows various threads to add or remove elements from the list
    at a time without producing any data inconsistency. Similar to lists, we have
    deques. A deque is a data structure similar to a queue, but in a deque, you can
    add or remove elements from either the front (head) or back (tail).
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, you will learn how to use blocking deques in your concurrent
    programs. The main difference between blocking deques and non-blocking deques
    is that blocking deques have methods to insert and delete elements that, if not
    done immediately because the list is either full or empty, block the thread that
    make the call until the operation could be carried out. Java includes the `LinkedBlockingDeque`
    class that implements a blocking deque.
  prefs: []
  type: TYPE_NORMAL
- en: 'You are going to implement an example with the following two tasks:'
  prefs: []
  type: TYPE_NORMAL
- en: One that adds thousands of elements to the deque
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: One that massively removes data from the same list
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The example of this recipe has been implemented using the Eclipse IDE. If you
    use Eclipse
  prefs: []
  type: TYPE_NORMAL
- en: or a different IDE, such as NetBeans, open it and create a new Java project.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Follow the steps described next to implement the example:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a class named `Client` and specify that it implements the `Runnable`
    interface:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Declare a private `LinkedBlockingDeque` attribute parameterized by the `String`
    class named `requestList`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement the constructor of the class to initialize its attributes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement the `run()` method. Insert five `String` objects into the deque per
    second using the `put()` method of the `requestList` object. Repeat this cycle
    three times:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Create the main class of the example by creating a class named `Main` and adding
    the `main()` method to it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Declare and create `LinkedBlockingDeque` parameterized by the `String` class
    named list specifying a fixed size of three:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Create and start a `Thread` object to execute a client task:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Get three `String` objects from the list every 300 milliseconds using the `take()`
    method of the list object. Repeat this cycle five times. Write the strings in
    the console:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Write a message to indicate the end of the program:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, you used `LinkedBlockingDeque`, parameterized by the `String`
    class, to work with a non-blocking concurrent deque of data.
  prefs: []
  type: TYPE_NORMAL
- en: The `Client` class uses the `put()` method to insert strings into the deque.
    If the deque is full (because you have created it with fixed capacity), the method
    will block the execution of its thread until there is empty space in the list.
  prefs: []
  type: TYPE_NORMAL
- en: The `Main` class uses the `take()` method to get strings from the deque. If
    the deque is empty, the method blocks the execution of its thread until there
    are elements in the deque.
  prefs: []
  type: TYPE_NORMAL
- en: Both the methods of the `LinkedBlockingDeque` class used in this example can
    throw an `InterruptedException` exception if they are interrupted while they are
    being blocked. So, you have to include the necessary code to catch this exception.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `LinkedBlockingDeque` class also provides methods to insert and get elements
    from the deque that, instead of being blocked, throws an exception or returns
    the `null` value. These methods are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`takeFirst()` and `takeLast()`: These return the first and last element of
    the deque, respectively. They remove the returned element from the deque. If the
    deque is empty, they block the thread until there are elements in the deque.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`getFirst()` and `getLast()`: These return the first and last element of the
    deque, respectively. They don''t remove the returned element from the deque. If
    the deque is empty, they throw a `NoSuchElementExcpetion` exception.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`peek()`, `peekFirst()`, and `peekLast()`: The `peekFirst()` and `peekLast()`
    methods return the first and last element of the deque, respectively. They don''t
    remove the returned element from the deque. If the deque is empty, they return
    a `null` value.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`poll()`, `pollFirst()`, and `pollLast()`: The `pollFirst()` and `pollLast()`
    methods return the first and last element of the deque, respectively. They remove
    the returned element from the deque. If the list is empty, they return a `null`
    value.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`add()`, `addFirst()`, and `addLast()`: The `addFirst()` and `addLast()` methods
    add an element to the first and last position, respectively. If the deque is full
    (created with fixed capacity), they throw an `IllegalStateException` exception.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The *Using non-blocking thread-safe deques* recipe in this chapter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using blocking thread-safe queue ordered by priority
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When you work with data structures, you may typically feel the need to have
    an ordered queue. Java provides `PriorityBlockingQueue` that has this functionality.
  prefs: []
  type: TYPE_NORMAL
- en: 'All the elements you want to add to `PriorityBlockingQueue` have to implement
    the `Comparable` interface; alternatively, you can include `Comparator` in the
    queue''s constructor. This interface has a method called `compareTo()` that receives
    an object of the same type. So you have two objects to compare: the one that is
    executing the method and the one that is received as a parameter. The method must
    return a number less than zero if the local object is less than the parameter.
    It should return a number bigger than zero if the local object is greater than
    the parameter. The number must be zero if both the objects are equal.'
  prefs: []
  type: TYPE_NORMAL
- en: '`PriorityBlockingQueue` uses the `compareTo()` method when you insert an element
    in it to determine the position of the element inserted. Bigger elements will
    either be the tail or head of the queue, depending on the `compareTo()` method.'
  prefs: []
  type: TYPE_NORMAL
- en: Another important characteristic of `PriorityBlockingQueue` is that it's a **blocking
    data structure**. It has methods that, if unable to perform the operation immediately,
    will block the thread until they are able to do it.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, you will learn how to use the `PriorityBlockingQueue` class
    by implementing an example, where you are going to store a lot of events with
    different priorities in the same list, to check that the queue will be ordered
    as you want.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The example of this recipe has been implemented using the Eclipse IDE. If you
    use Eclipse
  prefs: []
  type: TYPE_NORMAL
- en: or a different IDE, such as NetBeans, open it and create a new Java project.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Follow these steps to implement the example:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a class named `Event` and specify that it implements the `Comparable`
    interface parameterized by the `Event` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Declare a private `int` attribute named `thread` to store the number of threads
    that have created the event:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Declare a private `int` attribute named `priority` to store the priority of
    the event:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement the constructor of the class to initialize its attributes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement the `getThread()` method to return the value of the thread attribute:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement the `getPriority()` method to return the value of the priority attribute:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement the `compareTo()` method. It receives `Event` as a parameter and
    compares the priority of the current event and the one received as a parameter.
    It returns `-1` if the priority of the current event is bigger, `0` if both the
    priorities are equal, and `1` if the priority of the current event is smaller.
    Note that this is the opposite of most `Comparator.compareTo()` implementations:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a class named `Task` and specify that it implements the `Runnable` interface:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Declare a private `int` attribute named `id` to store the number that identifies
    the task:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Declare a private `PriorityBlockingQueue` attribute parameterized by the `Event`
    class named `queue` to store the events generated by the task:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement the constructor of the class to initialize its attributes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement the `run()` method. It stores 1,000 events in the queue, using its
    ID, to identify the task that creates the event and we assign to each event a
    different priority from 1 to 1000\. Use the `add()` method to store the events
    in the queue:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement the main class of the example by creating a class named `Main` and
    adding the `main()` method to it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a `PriorityBlockingQueue` object parameterized by the `Event` class
    named `queue`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Create an array of five `Thread` objects to store the threads that will execute
    the five tasks:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Create five `Task` objects. Store the threads in the array created earlier:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Start the five threads created earlier:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Wait for the finalization of the five threads using the `join()` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Write the actual size of the queue in the console and the events stored in
    it. Use the `poll()` method to take off the events from the queue:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Write a message to the console with the final size of the queue:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this example, you implemented a priority queue of `Event` objects using `PriorityBlockingQueue`.
    As mentioned in the introduction, all the elements stored in `PriorityBlockingQueue`
    have to implement the `Comparable` interface or provide a `Comparator` object
    to the constructor of the queue. In this case, you used the first approach, so
    you implemented the `compareTo()` method in the `Event` class.
  prefs: []
  type: TYPE_NORMAL
- en: All the events have a priority attribute. The elements that have a higher value
    of priority will be the first elements in the queue. When you implement the `compareTo()`
    method, if the event executing the method has a priority higher than the priority
    of the event passed as a parameter, it returns `-1` as the result. In another
    case, if the event executing the method has a priority lower than the priority
    of the event passed as a parameter, it returns `1` as the result. If both objects
    have the same priority, the `compareTo()` method returns `0`. In this case, the
    `PriorityBlockingQueue` class doesn't guarantee the order of the elements.
  prefs: []
  type: TYPE_NORMAL
- en: We implemented the `Task` class to add the `Event` objects to the priority queue.
    Each task object adds 1,000 events to the queue, with priorities between `0` and
    `999`, using the `add()` method.
  prefs: []
  type: TYPE_NORMAL
- en: The `main()` method of the `Main` class creates five `Task` objects and executes
    them in the corresponding threads. When all the threads had finished their execution,
    you wrote all the elements to the console. To get the elements from the queue,
    we used the `poll()` method. This method returns and removes the first element
    from the queue.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shows part of the output of an execution of the program:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00044.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: You can see how the queue has a size of 5,000 elements and how the first elements
    have the biggest priority value.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `PriorityBlockingQueue` class has other interesting methods. The following
    is a description of some of them:'
  prefs: []
  type: TYPE_NORMAL
- en: '`clear()`: This method removes all the elements of the queue.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`take()`: This method returns and removes the first element of the queue. If
    the queue is empty, it blocks its thread until the queue has elements.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`put(E e)`: This is the class used to parameterize the `PriorityBlockingQueue`
    class. It inserts the element that is passed as a parameter into the queue.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`peek()`: This method returns the first element of the queue but doesn''t remove
    it.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The *Using blocking thread-safe deques* recipe in this chapter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using thread-safe lists with delayed elements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'An interesting data structure provided by the Java API, which you can use in
    concurrent applications, is implemented in the `DelayQueue` class. In this class,
    you can store elements with an activation date. The methods that return or extract
    elements from the queue will ignore these elements whose data will appear in the
    future. They are invisible to these methods.To obtain this behavior, the elements
    you want to store in the `DelayQueue` class need to have the `Delayed` interface
    implemented. This interface allows you to work with delayed objects. This interface
    has the `getDelay()` method that returns the time until the activation of the
    element. This interface forces you to implement the following two methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '`compareTo(Delayed o)`: The `Delayed` interface extends the `Comparable` interface.
    This method will return a value less than zero if the object that is executing
    the method has a delay smaller than the object passed as a parameter. It will
    return a value greater than zero if the object that is executing the method has
    a delay bigger than the object passed as a parameter. It will return zero if both
    the objects have the same delay.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`getDelay(TimeUnit unit)`: This method has to return the time remaining until
    the activation date in units, as specified by the unit parameter. The `TimeUnit`
    class is an enumeration with the following constants: `DAYS`, `HOURS`, `MICROSECONDS`,
    `MILLISECONDS`, `MINUTES`, `NANOSECONDS`, and `SECONDS`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this example, you will learn how to use the `DelaydQueue` class by storing
    in it some events with different activation dates.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The example of this recipe has been implemented using the Eclipse IDE. If you
    use Eclipse
  prefs: []
  type: TYPE_NORMAL
- en: or a different IDE, such as NetBeans, open it and create a new Java project.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Follow these steps to implement the example:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a class named `Event` and specify that it implements the `Delayed` interface:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Declare a private `Date` attribute named `startDate`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement the constructor of the class to initialize its attribute:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement the `compareTo()` method. It receives a `Delayed` object as its parameter.
    Return the difference between the delay of the current object and the one passed
    as a parameter:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement the `getDelay()` method. Return the difference between the start
    date of the object and the actual date in `TimeUnit`, which is received as a parameter:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a class named `Task` and specify that it implements the `Runnable` interface:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'Declare a private `int` attribute named `id` to store a number that identifies
    this task:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'Declare a private `DelayQueue` attribute parameterized by the `Event` class
    named `queue`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement the constructor of the class to initialize its attributes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement the `run()` method. First, calculate the activation date of the events
    that this task is going to create. Then, add the number of seconds equal to the
    ID of the object to the actual date:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'Store 100 events in the queue using the `add()` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement the main class of the example by creating a class named `Main` and
    adding the `main()` method to it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a `DelayQueue` object parameterized by the `Event` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'Create an array of five `Thread` objects to store the tasks you''re going to
    execute:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'Create five `Task` objects with different IDs:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'Launch all the five tasks created earlier:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'Wait for the finalization of the threads using the `join()` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'Write to the console the events stored in the queue. When the size of the queue
    is bigger than zero, use the `poll()` method to obtain an `Event` class. If it
    returns `null`, put the main thread to sleep for 500 milliseconds for the activation
    of more events:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we implemented the `Event` class. This class has a unique attribute,
    the activation date of the events, and it implements the `Delayed` interface.
    You can store `Event` objects in the `DelayQueue` class.
  prefs: []
  type: TYPE_NORMAL
- en: The `getDelay()` method returns the number of nanoseconds between the activation
    date and the actual date. Both dates are objects of the `Date` class. You used
    the `getTime()` method that returns a date converted into milliseconds. Then,
    you converted this value into `TimeUnit`, which was received as a parameter. The
    `DelayQueue` class works in nanoseconds, but at this point, it's transparent to
    you.
  prefs: []
  type: TYPE_NORMAL
- en: The `compareTo()` method returns a value less than zero if the delay of the
    object executing the method is smaller than the delay of the object passed as
    a parameter. It returns a value greater than zero if the delay of the object executing
    the method is bigger than the delay of the object passed as a parameter. It returns
    `0` if both the delays are equal.
  prefs: []
  type: TYPE_NORMAL
- en: You also implemented the `Task` class. This class has an `integer` attribute
    named `id`. When a `Task` object is executed, it adds the number of seconds that
    is equal to the ID of the task to the actual date, and this refers to the activation
    date of the events stored by this task in the `DelayQueue` class. Each `Task`
    object stores 100 events in the queue using the `add()` method.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, in the `main()` method of the `Main` class, you created five `Task`
    objects and executed them in their corresponding threads. When these threads finished
    their execution, you wrote all the events using the `poll()` method in the console.
    This method retrieves and removes the first element of the queue. If the queue
    does not have any active element, it returns the `null` value. You call the `poll()`
    method, and if it returns an `Event` class, you increment a counter. When it returns
    the `null` value, you write the value of the counter in the console and put the
    thread to sleep for half a second to wait for more active events. When you obtained
    the 500 events stored in the queue, the execution of the program finished.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shows part of the output of an execution of the program:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00045.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: You can see how the program only gets 100 events when it is activated.
  prefs: []
  type: TYPE_NORMAL
- en: You must be very careful with the `size()` method. It returns the total number
    of elements in the list that includes both active and non-active elements.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `DelayQueue` class has other interesting methods, which are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`clear()`: This method removes all the elements of the queue.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`offer(E e)`: Here, `E` represents the class used to parameterize the `DelayQueue`
    class. This method inserts the element that is passed as a parameter into the
    queue.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`peek()`: This method retrieves but doesn''t remove the first element of the
    queue.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`take()`: This method retrieves and removes the first element of the queue.
    If there aren''t any active elements, the thread that is executing the method
    will be blocked until the thread gets some active elements.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The *Using blocking thread-safe deques* recipe in this chapter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using thread-safe navigable maps
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `ConcurrentNavigableMap` is an interface that defines interesting data
    structures provided by the Java API that you can use in your concurrent programs.
    The classes that implement the `ConcurrentNavigableMap` interface stores elements
    in two parts:'
  prefs: []
  type: TYPE_NORMAL
- en: A **key** that uniquely identifies an element
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The rest of the data that defines the element, called **value**
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Java API also provides a class that implements `ConcurrentSkipListMap`,
    which is the interface that implements a non-blocking list with the behavior of
    the `ConcurrentNavigableMap` interface. Internally, it uses a **Skip List** to
    store data. A Skip List is a data structure based on parallel lists that allow
    us to get the kind of efficiency that is associated with a binary tree. You can
    get more information about Skip Lists at [https://en.wikipedia.org/wiki/Skip_list](https://en.wikipedia.org/wiki/Skip_list).
    With it, you can get a sorted data structure, instead of a sorted list, with better
    access time to insert, search, or delete elements.
  prefs: []
  type: TYPE_NORMAL
- en: Skip List was introduced by William Pugh in 1990.
  prefs: []
  type: TYPE_NORMAL
- en: When you insert an element to a map, the map uses a key to order them; therefore,
    all the elements will be ordered. The keys have to implement the `Comparable`
    interface, or you have to supply a `Comparator` class to the constructor of the
    map. The class also provides methods to obtain a submap of the map, in addition
    to the ones that return a concrete element.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, you will learn how to use the `ConcurrentSkipListMap` class
    to implement a map of contacts.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The example of this recipe has been implemented using the Eclipse IDE. If you
    use Eclipse or a different IDE, such as NetBeans, open it and create a new Java
    project.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Follow these steps to implement the example:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a class named `Contact`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'Declare two private `String` attributes named `name` and `phone`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement the constructor of the class to initialize its attributes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement the methods to return the values of the `name` and `phone` attributes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a class named `Task` and specify that it implements the `Runnable` interface:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'Declare a private `ConcurrentSkipListMap` attribute, parameterized by the `String`
    and `Contact` classes, named `map`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'Declare a private `String` attribute named `id` to store the ID of the current
    task:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement the constructor of the class to store its attributes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement the `run()` method. It stores 1,000 different contacts in the map
    using the ID of the task and an incremental number to create `Contact` objects.
    Use the `put()` method to store the contacts in the map:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement the main class of the example by creating a class named `Main` and
    adding the `main()` method to it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a `ConcurrentSkipListMap` object, parameterized by the `String` and
    `Conctact` classes, named `map`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'Create an array for 26 `Thread` objects to store all the `Task` objects that
    you''re going to execute:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'Create and launch 26 `task` objects and assign a capital letter to the ID of
    each task:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'Wait for the finalization of the threads using the `join()` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: 'Get the first entry of the map using the `firstEntry()` method. Write its data
    to the console:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: 'Get the last entry of the map using the `lastEntry()` method. Write its data
    to the console:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: 'Obtain a submap of the map using the `subMap()` method. Write its data to the
    console:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we implemented a `Task` class to store `Contact` objects in
    a navigable map. Each contact has a name, which is the ID of the task that creates
    it, and a phone number, which is a number between 1,000 and 2,000\. We concatenated
    these values as keys for the contacts. Each `Task` object creates 1,000 contacts;
    these contacts are stored in the navigable map using the `put()` method.
  prefs: []
  type: TYPE_NORMAL
- en: If you insert an element with a key that exists in the map, the element associated
    with that key will be replaced by the new element.
  prefs: []
  type: TYPE_NORMAL
- en: The `main()` method of the `Main` class creates 26 `Task` objects, using the
    letters between A and Z as IDs. Then, you used some methods to obtain data from
    the map. The `firstEntry()` method returns a `Map.Entry` object with the first
    element of the map. This method doesn't remove the element from the map. The object
    contains the key and the element. To obtain the element, you called the `getValue()`
    method. You can use the `getKey()` method to obtain the key of that element.
  prefs: []
  type: TYPE_NORMAL
- en: The `lastEntry()` method returns a `Map.Entry` object with the last element
    of the map. The `subMap()` method returns the `ConcurrentNavigableMap` object
    with part of the elements of the map, in this case, the elements that had keys
    between `A1996` and `B1002`. You used the `pollFirst()` method to process the
    elements of the `subMap()` method. This method returns and removes the first `Map.Entry`
    object of the submap.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shows the output of an execution of the program:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00046.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `ConcurrentSkipListMap` class has other interesting methods. Some of them
    are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`headMap(K toKey)`: Here, `K` is the class of the key values used in the parameterization
    of the `ConcurrentSkipListMap` object. This method returns a submap of the first
    elements of the map with the elements that have a key smaller than the one passed
    as a parameter.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`tailMap(K fromKey)`: Here, `K` is the class of the key values used in the
    parameterization of the `ConcurrentSkipListMap` object. This method returns a
    submap of the last elements of the map with the elements that have a key greater
    than the one passed as a parameter.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`putIfAbsent(K key, V Value)`: This method inserts the value specified as a
    parameter and also the key specified as a parameter if it doesn''t exist in the
    map.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`pollLastEntry()`: This method returns and removes a `Map.Entry` object with
    the last element of the map.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`replace(K key, V Value)`: This method replaces the value associated with the
    key specified as a parameter if this key exists in the map.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The *Using non-blocking thread-safe deques* recipe in this chapter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using thread-safe HashMaps
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A hash table is a data structure that allows you to map a key to a value. Internally,
    it usually uses an array to store the elements and a hash function to calculate
    the position of the element in the array, using its key. The main advantage of
    this data structure is that the insert, delete, and search operations are very
    fast here, so it's very useful in situations when you have to carry out a lot
    of search operations.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Java API provides different hash table implementations through the `Map`
    and `ConcurrentMap` interfaces. The `ConcurrentMap` interface provides thread-safety
    and atomic guarantees to all the operations, so you can use them in concurrent
    applications. The `ConcurrentHashMap` class implements the `ConcurrentMap` interface
    and adds some more methods to the ones defined in the interface. This class supports
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Full concurrency of read operations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: High expected concurrency for insert and delete operations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Both the elements (class and interface) were introduced in Java version 5, but
    in version 8, a lot of new methods similar to the ones provided by the stream
    API were developed.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, you will learn how to use the `ConcurrentHashMap` class in your
    application and the most important methods it provides.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The example of this recipe has been implemented using the Eclipse IDE. If you
    use Eclipse or a different IDE, such as NetBeans, open it and create a new Java
    project.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Follow these steps to implement the example:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a class named `Operation` with three attributes: a `String` attribute
    named `user`, a `String` attribute named `operation`, and a `Date` attribute named
    `time`. Add the methods to get and set the values of the attributes. The code
    of this class is very simple, so it won''t be included here.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a class named `HashFiller`. Specify that it implements the `Runnable`
    interface:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: 'Declare a private `ConsurrentHashMap` attribute named `userHash`. The key of
    the hash will be a `String` type and its value will be a `ConcurrentLinkedDeque`
    object of `Operation` objects. Implement the constructor of the class to initialize
    the attribute:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement the `run()` method. We''re going to fill `ConcurrentHashMap` with
    100 random `Operation` objects. First, generate random data and then use the `addOperationToHash()`
    method to insert the object in the hash:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement the `addOperationToHash()` method. It receives the hash and the operation
    you want to add as parameters. The key in the map will be the user assigned to
    the operation. We use the `computeIfAbsent()` method to obtain the `ConcurrentLinkedDeque`
    object associated with the key. If the key exists, this method returns the value
    associated with it. If it doesn''t, it executes the lambda expression passed as
    a parameter to this method to generate the value and associate it with the key.
    In this case, we generate a new `ConcurrentLinkedDeque` object. Finally, insert
    the operation to the deque:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: 'Now implement the `Main` class and include the `main()` method. First, declare
    a `ConcurrentHashMap` object and a `HashFiller` task:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: 'Execute 10 threads with the `HashFiller` class and wait for their finalization
    using the `join()` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, extract the information of `ConcurrentHashMap`. First, extract the number
    of elements stored in it with the `size()` method. Then, use the `forEach()` method
    to apply an action to all the elements stored in the hash. The first parameter
    is the parallelism threshold. This is the minimum number of elements required
    to make the operation execute in a concurrent way. We have specified the value
    10 and the hash has 100 elements, so the operation will be executed in a parallel
    way. The lambda expression receives two parameters: key and value. Print the key
    and size of `ConcurrentLinkedDeque` stored as a value:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, use the `forEachEntry()` method. This is similar to the previous one,
    but the lambda expression receives an `Entry` object as a parameter instead of
    receiving two parameters. You can use this entry object to obtain the key and
    value:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, use the `search()` method to find the first element that satisfies the
    search function specified. In our case, we search for an operation whose operation
    code ends in 1\. As occurs with the `forEach()` method, we specify a parallelism
    threshold:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: 'Use the `search()` method again, but this time, use it to find a user with
    more than 10 operations:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, use the `reduce()` method to calculate the total number of operations
    stored in the hash:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we implemented an application that uses `ConcurrentHashMap`
    to store information about operations made by users. Internally, the hash table
    uses the user attribute of the `Operation` class as a key and `ConcurrentLinkedDeque`
    (a non-blocking concurrent list) as its value to store all the operations associated
    with that user.
  prefs: []
  type: TYPE_NORMAL
- en: First, we filled the hash with some random data using 10 different threads.
    We implemented the `HashFiller` task for this purpose. The biggest problem with
    these tasks is what happens when you have to insert a key in the hash table. If
    two threads want to add the same key at the same time, you can lose the data inserted
    by one of the threads and have a data-race condition. To solve this problem, we
    used the `computeIfAbsent()` method.
  prefs: []
  type: TYPE_NORMAL
- en: This method receives a key and an implementation of the `Function` interface
    that can be expressed as a lambda expression; the key and implementation are received
    as parameters. If the key exists, the method returns the value associated with
    the key. If it doesn't, the method executes the `Function` object specified and
    adds the key and value returned by `Function` to the HashMap. In our case, the
    key didn't exist, so we created a new instance of the `ConcurrentLinkedDeque`
    class. The main advantage of this method is that it's executed atomically; so,
    if another thread tries to do the same operation, it will be blocked until this
    operation is finished.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, in the `main()` method, we used other methods of `ConcurrentHashMap`
    to process the information stored in the hash. We used the following methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '`forEach()`: This method receives an implementation of the `BiConsumer` interface
    that can be expressed as a lambda expression; it is received as a parameter. The
    other two parameters of this expression represent the key and value of the element
    we''re processing. This method applies the expression to all the elements stored
    in `ConcurrentHashMap`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`forEachEntry()`: This method is equivalent to the previous one, but here the
    expression is an implementation of the `Consumer` interface. It receives an `Entry`
    object that stores the key and value of the entry we''re processing as a parameter.
    This is another way to express the same functionality.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`search()`: This method receives the implementation of the `BiFunction` interface
    that can be expressed as a lambda expression; it is received as a parameter. This
    function also receives the key and value of the entry of the `ConcurrentHashMap`
    object we''re processing as parameters. It returns the first non-null value returned
    by `BiFunction`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`reduce()`: This method receives two `BiFunction` interfaces to reduce the
    elements of `ConcurrentHashMap` to a unique value. This allows you to implement
    a `MapReduce` operation with the elements of `ConcurrentHashMap`. The first `BiFunction`
    interface allows you to transform the key and value of the elements into a unique
    value, and the second `BiFunction` interface allows you to aggregate the values
    of two different elements.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All the methods described so far have a first parameter named `parallelismThreshold`.
    This parameter is described as *...the (estimated) number of elements needed for
    this operation to be executed in parallel...,* that is to say, if `ConcurrentHashMap`
    has fewer elements than the value specified in the parameter, the method is executed
    in a sequential way. On the contrary (as in our case), the method is executed
    in a parallel way.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`ConcurrentHashMap` has more methods than what''s specified in the previous
    section. We enumerate some of them in the following list:'
  prefs: []
  type: TYPE_NORMAL
- en: '`forEachKey()` and `forEachValue()`: These methods are similar to the `forEach()`
    methods, but in this case, the expression processes the keys and values stored
    in `ConcurrentHashMap`, respectively.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`searchEntries()`, `searchKeys()`, and `searchValues()`: These methods are
    similar to the `search()` method explained before. However, in this case, the
    expression passed as a parameter receives an `Entry` object, a key, or a value
    of the elements stored in `ConcurrentHashMap`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`reduceEntries()`, `reduceKeys()`, and `reduceValues()`: These methods are
    similar to the `reduce()` method explained before. However, in this case, the
    expression passed as a parameter receives an `Entry` object, a key, or a value
    of the elements stored in `ConcurrentHashMap`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`reduceXXXToDouble()`, `reduceXXXToLong()`, and `reduceXXXToInt()`: These methods
    allow you to make a reduction of the elements of `ConcurrentHashMap` by generating
    a `double`, `long`, or `int` value, respectively.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`computeIfPresent()`: This method complements the `computeIfAbsent()` method.
    In this case, it receives a key and an implementation of the `BiFunction` interface
    that can be expressed as a lambda expression. If the key exists in the `HashMap`,
    the method applies the expression to calculate the new value of the key. The `BiFunction`
    interface receives the key and the actual value of that key as parameters, and
    it returns the new value.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`merge()`: This method receives a key, value, and implementation of the `BiFunction`
    interface that can be expressed as a lambda expression; they are received as parameters.
    If the key doesn''t exist in `ConcurrentHashMap`, it inserts it there and associates
    the value parameter with it. If it exists, execute `BiFunction` to calculate the
    new value associated with the key. The `BiFunction` interface receives the key
    and its actual value as parameters and returns the new value associated with the
    key.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`getOrDefault()`: This method receives a key and a default value as parameters.
    If the key exists in `ConcurrentHashMap`, it returns its associated value. Otherwise,
    it returns the default value.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The *Using thread-safe navigable maps *recipe in this chapter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Reducing the elements of a stream* recipe in [Chapter 6](part0249.html#7DES20-69b77957c9a14e36a0bec5f5a1363736),
    *Parallel and Reactive Streams*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using atomic variables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Atomic variables** were introduced in Java version 5 to provide atomic operations
    on single variables. When you work with a normal variable, each operation that
    you implement in Java is transformed into several instructions of Java byte code
    that is understandable by the JVM when you compile the program. For example, when
    you assign a value to a variable, you only use one instruction in Java; however,
    when you compile this program, it is transformed into various instructions in
    the JVM language. This can lead to data inconsistency errors when you work with
    multiple threads that share a variable.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To avoid these problems, Java introduced atomic variables. When a thread is
    doing an operation with an atomic variable and if other threads want to do an
    operation with the same variable, the implementation of the class includes a mechanism
    to check that the operation is done atomically. Basically, the operation gets
    the value of the variable, changes the value to a local variable, and then tries
    to change the old value with the new one. If the old value is still the same,
    it is substituted; if not, the method begins the operation again. This operation
    is called **Compare and Set**. It implements the modification of the value of
    a variable in the following three steps:'
  prefs: []
  type: TYPE_NORMAL
- en: You get the value of the variable, which is the old value of the variable.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You change the value of the variable in a temporal variable, which is the new
    value of the variable.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You substitute the old value with the new value if the old value is equal to
    the actual value of the variable. The old value may be different from the actual
    value if another thread changes the value of the variable.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Some of these variables, for example, the `LongAccumulator` class, receive an
    operation as a parameter that could be executed inside some of its methods. These
    operations must be free from any side effects, as they might be executed multiple
    times in every value update.
  prefs: []
  type: TYPE_NORMAL
- en: Atomic variables don't use locks or other synchronization mechanisms to protect
    access to their values. All their operations are based on Compare and Set. It's
    guaranteed that several threads can work with an atomic variable at a time without
    generating data inconsistency errors; plus, they simplify the implementation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Java 8 has added four new atomic classes. First we have the `LongAdder` and
    `DoubleAdder` classes; they store `long` and `double` values that are updated
    frequently by different threads. You can obtain the same functionality as that
    of the `LongAdder` class with the `AtomicLong` class, but the former provides
    better performance. The other two classes are `LongAccumulator` and `DoubleAccumulator`.
    These classes are similar to the previous one, but here, you have to specify two
    parameters in the constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: The initial value of the counter.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A `LongBinaryOperator` or `DoubleBinaryOperator` that can be indicated as a
    lambda expression. This expression receives the old value of the variable and
    the increment you want to apply and returns the new value of the variable.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In this recipe, you will learn how to use atomic variables implementing a bank
    account and two different tasks: one that adds money to the account and one that
    subtracts money from it. You will use the `AtomicLong` class in the implementation
    of the example.'
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The example of this recipe has been implemented using the Eclipse IDE. If you
    are using Eclipse or a different IDE, such as NetBeans, open it and create a new
    Java project.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Follow these steps to implement the example:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a class named `Account` to simulate a bank account:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: 'Declare a private `AtomicLong` attribute named `balance` to store the balance
    of the account. In addition, declare a private `LongAdder` attribute named operations
    and a private `DoubleAccumulator` attribute named commission:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement the constructor of the class to initialize its attributes. For the
    `DoubleAccumulator` class, the identity value is `0` and we update the actual
    value with the result of multiply `0.2` to the increment passed as parameter:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement the method to get the value of the three attributes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement a method named `setBalance()` to establish the value of the balance
    attribute. We also have to initialize the operations and commission attributes
    using the `reset()` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement a method named `addAmount()` to increment the value of the `balance`
    attribute. In addition, use the `increment()` method of the `LongAdder` class
    to increment the value of the `operations` attribute and the `accumulate()` method
    by one unit to add 20 percent of the amount value to the `commission` object:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement a method named `substractAmount()` to decrement the value of the
    `balance` attribute. As it occurs with the `addAmount()` method, we modify the
    values of the `operations` and `commission` attributes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a class named `Company` and specify that it implements the `Runnable`
    interface. This class will simulate the payments made by a company:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: 'Declare a private `Account` attribute named `account`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement the constructor of the class to initialize its attribute:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement the `run()` method of the task. Use the `addAmount()` method of the
    account to make 10 increments of 1,000 each in its balance:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a class named `Bank` and specify that it implements the `Runnable` interface.
    This class will simulate the withdrawal of money from the account:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: 'Declare a private `Account` attribute named `account`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement the constructor of the class to initialize its attribute:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement the `run()` method of the task. Use the `subtractAmount()` method
    of the account to make 10 decrements of 1,000 each from its balance:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement the main class of the example by creating a class named `Main` and
    adding the `main()` method to it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE107]'
  prefs: []
  type: TYPE_PRE
- en: 'Create an `Account` object and set its balance to `1000`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE108]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a new `Company` task and a thread to execute it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE109]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a new `Bank` task and a thread to execute it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE110]'
  prefs: []
  type: TYPE_PRE
- en: 'Write the initial balance of the account in the console:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE111]'
  prefs: []
  type: TYPE_PRE
- en: 'Start the threads:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE112]'
  prefs: []
  type: TYPE_PRE
- en: 'Wait for the finalization of the threads using the `join()` method and write
    the final balance in the console, the number of operations, and the accumulated
    commission of the account:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE113]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The key to this example is in the `Account` class. In this class, we declared
    an `AtomicLong` variable named `balance` to store the balance of the account,
    a `LongAdder` variable named `operations` to store the number of operations we
    made with the account, and a `DoubleAccumulator` variable named `commission` to
    store the value of the commissions of the operations. In the constructor of the
    `commission` object, we specified that the value will be incremented with the
    expression `0.2*y`. With this, we wanted to specify that we will increment the
    actual value of the variable with the result of its multiplication by `0.2` and
    the value of the parameter we pass to the `accumulate()` method.
  prefs: []
  type: TYPE_NORMAL
- en: To implement the `getBalance()` method that returns the value of the `balance`
    attribute, we used the `get()` method of the `AtomicLong` class. To implement
    the `getOperations()` method that returns a `long` value with the number of operations,
    we used the `longValue()` method. To implement the `getCommission()` method, we
    used the `get()` method of the `DoubleAccumulator` class. To implement the `setBalance()`
    method that establishes the value of the balance attribute, we used the `set()`
    method of the `AtomicLong` class.
  prefs: []
  type: TYPE_NORMAL
- en: To implement the `addAmount()` method that adds an import to the balance of
    the account, we used the `getAndAdd()` method of the `AtomicLong` class that returns
    the value and increments it by the value specified as a parameter. We also used
    the `increment()` method of the `LongAdder` class that increments the value of
    the variable by one and the `accumulate()` method of the `DoubleAccumulator` class
    to increment the value of the `commission` attribute following the specified expression.
    Take into account that the `addAmount()` method is not atomic as a whole although
    it calls three atomic operations.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, to implement the `subtractAmount()` method that decrements the value
    of the `balance` attribute, we used the `getAndAdd()` method. We also included
    calls to the `increment()` and `accumulate()` methods of the `LongAdder` and `DoubleAccumulator`
    classes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, we implemented two different tasks:'
  prefs: []
  type: TYPE_NORMAL
- en: The `Company` class simulates a company that increments the balance of the account.
    Each task of this class makes 10 increments of 1,000 each.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `Bank` class simulates a bank where the proprietary of the bank account
    takes out its money. Each task of this class makes 10 decrements of 1,000 each.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the `Main` class, you created an `Account` object with a balance of 1,000\.
    Then, you executed a bank task and a company task so the final balance of the
    account is the same as the initial one.
  prefs: []
  type: TYPE_NORMAL
- en: 'When you execute the program, you will see how the final balance is the same
    as the initial one. The following screenshot shows the output of an execution
    of this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00047.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As mentioned in the introduction, there are other atomic classes in Java. `AtomicBoolean`,
    `AtomicInteger`, and `AtomicReference` are other examples of atomic classes.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `LongAdder` class provides other interesting methods as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`add()`: To increment the value of the internal counter by the value specified
    as a parameter'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`decrement()`: To decrement the internal counter by one'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`reset()`: To return the internal value to zero'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can also use the `DoubleAdder` class that is similar to `LongAdder`, but
    it doesn't have the `increment()` and `decrement()` methods and the internal counter
    is a `double` value.
  prefs: []
  type: TYPE_NORMAL
- en: You can also use the `LongAccumulator` class that is similar to `DoubleAccumulator`
    but with an internal `long` counter.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The *Synchronizing a method* recipe in [Chapter 2](part0081.html#2D7TI0-69b77957c9a14e36a0bec5f5a1363736),
    *Basic Thread Synchronization*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using atomic arrays
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Consider that you need to implement a concurrent application that has one or
    more objects shared by several threads. In such a scenario, you have to protect
    access to their attributes using a synchronization mechanism, such as locks or
    the `synchronized` keyword, to avoid data inconsistency errors.
  prefs: []
  type: TYPE_NORMAL
- en: 'These mechanisms have the following problems:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Deadlock: This situation occurs when a thread is blocked waiting for a lock
    that is locked by other threads that will never free it. This situation blocks
    the program, so it will never finish.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If only one thread is accessing the shared object, it has to execute the code
    necessary to get and release the lock.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To provide better performance in this situation, the **compare-and-swap operation**
    was developed. This operation implements the modification of the value of a variable
    in the following three steps:'
  prefs: []
  type: TYPE_NORMAL
- en: You get the value of the variable, which is the old value of the variable.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You change the value of the variable in a temporal variable, which is the new
    value of the variable.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You substitute the old value with the new value if the old value is equal to
    the actual value of the variable. The old value may be different from the actual
    value if another thread has changed it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: With this mechanism, you don't need to use a synchronization mechanism, so you
    avoid deadlocks and you obtain better performance. This mechanism also has its
    drawbacks. Operations must be free from any side effects as they might be retried
    using livelocks with highly contended resources; they are also harder to monitor
    for performance when compared with standard locks.
  prefs: []
  type: TYPE_NORMAL
- en: Java implements this mechanism in **atomic variables**. These variables provide
    the `compareAndSet()` method, which is an implementation of the compare-and-swap
    operation and other methods based on it.
  prefs: []
  type: TYPE_NORMAL
- en: Java also introduced **atomic arrays** that provide atomic operations for arrays
    of `integer` or `long` numbers. In this recipe, you will learn how to use the
    `AtomicIntegerArray` class to work with atomic arrays. Take into account that
    if you use `AtomicInteger[]`, it's not a thread-safe object. The individual `AtomicInteger`
    objects are thread-safe, but the array as a data structure is not.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The example of this recipe has been implemented using the Eclipse IDE. If you
    use Eclipse or a different IDE, such as NetBeans, open it and create a new Java
    project.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Follow these steps to implement the example:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a class named `Incrementer` and specify that it implements the `Runnable`
    interface:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE114]'
  prefs: []
  type: TYPE_PRE
- en: 'Declare a private `AtomicIntegerArray` attribute named `vector` to store an
    array of `integer` numbers:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE115]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement the constructor of the class to initialize its attribute:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE116]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement the `run()` method. Increment all the elements of the array using
    the `getAndIncrement()` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE117]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a class named `Decrementer` and specify that it implements the `Runnable`
    interface:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE118]'
  prefs: []
  type: TYPE_PRE
- en: 'Declare a private `AtomicIntegerArray` attribute named `vector` to store an
    array of `integer` numbers:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE119]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement the constructor of the class to initialize its attribute:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE120]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement the `run()` method. Decrement all the elements of the array using
    the `getAndDecrement()` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE121]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement the main class of the example by creating a class named `Main` and
    adding the `main()` method to it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE122]'
  prefs: []
  type: TYPE_PRE
- en: 'Declare a constant named `THREADS` and assign the value `100` to it. Create
    an `AtomicIntegerArray` object with 1,000 elements:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE123]'
  prefs: []
  type: TYPE_PRE
- en: 'Create an `Incrementer` task to work with the atomic array created earlier:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE124]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a `Decrementer` task to work with the atomic array created earlier:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE125]'
  prefs: []
  type: TYPE_PRE
- en: 'Create two arrays to store 100 `Thread` objects:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE126]'
  prefs: []
  type: TYPE_PRE
- en: 'Create and launch 100 threads to execute the `Incrementer` task and another
    100 threads to execute the `Decrementer` task. Store the threads in the arrays
    created earlier:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE127]'
  prefs: []
  type: TYPE_PRE
- en: 'Wait for the finalization of the threads using the `join()` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE128]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE129]'
  prefs: []
  type: TYPE_PRE
- en: 'In the console, write the elements of the atomic array distinct from zero.
    Use the `get()` method to obtain the elements of the atomic array:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE130]'
  prefs: []
  type: TYPE_PRE
- en: 'Write a message in the console indicating the finalization of the example:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE131]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this example, you implemented two different tasks to work with an `AtomicIntegerArray`
    object:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Incrementer`: This class increments all the elements of the array using the
    `getAndIncrement()` method'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Decrementer`: This class decrements all the elements of the array using the
    `getAndDecrement()` method'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the `Main` class, you created `AtomicIntegerArray` with 1,000 elements, then
    you executed 100 incrementer and 100 decrementer tasks. At the end of these tasks,
    if there were no inconsistency errors, all the elements of the array must have
    the value `0`. If you execute the program, you will see how the program only writes
    the final message to the console because all the elements are zero.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Nowadays, Java provides another atomic array class. It's called the `AtomicLongArray`
    class and it provides the same methods as the `IntegerAtomicArray` class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Other interesting methods provided by these classes are:'
  prefs: []
  type: TYPE_NORMAL
- en: '`get(int i)`: Returns the value of the array position specified by the parameter'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`set(int I, int newValue)`: Establishes the value of the array position specified
    by the parameter.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The *Using atomic variables* recipe in this chapter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the volatile keyword
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Almost every application reads and writes data to the main memory of the computer.
    For performance reasons, these operations aren't performed directly in the memory.
    CPUs have a system of cache memory, so applications write data in the cache and
    then the data is moved from the cache to the main memory.
  prefs: []
  type: TYPE_NORMAL
- en: In multithread applications, concurrent threads run in different CPUs or cores
    inside a CPU. When a thread modifies a variable stored in the memory, the modification
    is made in the cache or the CPU or core where it's running. However, there's no
    guarantee about when that modification would reach the main memory. If another
    thread wants to read the value of the data, it's possible that it would not read
    the modified value because it's not in the main memory of the computer.
  prefs: []
  type: TYPE_NORMAL
- en: To solve this problem (there are other solutions, such as the `synchronized`
    keyword), the Java language includes the `volatile` keyword. It's a modifier that
    allows you to specify that a variable must always be read from and stored in the
    main memory, not the cache of your CPU. You should use the volatile keyword when
    it's important that other threads have visibility of the actual value of the variable;
    however, order of access to that variable is not important. In this scenario,
    the `volatile` keyword will give you better performance because it doesn't need
    to get any monitor or lock to access the variable. On the contrary, if the order
    of access to the variable is important, you must use another synchronization mechanism.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, you will learn how to use the volatile keyword and the effects
    of its use.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The example of this recipe has been implemented using the Eclipse IDE. If you
    use Eclipse or a different IDE, such as NetBeans, open it and create a new Java
    project.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Follow these steps to implement the example:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a class named `Flag` with a public `Boolean` attribute named `flag`
    initialized to the `true` value:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE132]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a class named `VolatileFlag` with a public Boolean attribute named `flag`
    initialized to the `true` value. We add the `volatile` modifier to the declaration
    of this attribute:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE133]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a class named `Task` and specify that it implements the `Runnable` interface.
    It has a private `Flag` attribute and a constructor to initialize it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE134]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement the `run()` method of this task. It will increment an `int` variable
    when the value of the `flag` attribute is `true`. Then, write the final value
    of the variable:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE135]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE136]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a class named `VolatileTask` and specify that it implements the `Runnable`
    interface. It has a private `VolatileFlag` attribute and a constructor to initialize
    it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE137]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement the `run()` method of this task. It''s equal to the one in the `Task`
    class, so it won''t be included here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Implement the `Main` class with the `main()` method. First, create four objects
    of the `VolatileFlag`, `Flag`, `VolatileTask`, and `Task` classes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE138]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, create two threads to execute the tasks, start them, and sleep the main
    thread for a second:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE139]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, change the value of the `volatileFlag` variable to stop the execution
    of `volatileTask` and sleep the main thread for a second:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE140]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, change the value of the `task` object to stop the execution of the
    task and sleep the main thread for a second:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE141]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following screenshot shows the output of the example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00048.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The application doesn't finish its execution because the `task` thread has not
    finished. When we change the value of `volatileFlag`-as its `flag` attribute is
    marked as `volatile`--the new value is written in the main memory and `VolatileTask`
    accesses the value immediately and finishes its execution. On the contrary, when
    you change the value of the `flag` object--as its `flag` attribute is not marked
    as volatile-the new value is stored in the cache of the main thread and the task
    object doesn't see the new value and never ends its execution. The `volatile`
    keyword is important not only because it requires that the writes are flushed,
    but also because it ensures that reads are not cached and they fetch the up-to-date
    value from the main memory. It's very important and very often neglected.
  prefs: []
  type: TYPE_NORMAL
- en: Take into account that the `volatile` keyword guarantees that modifications
    are written in the main memory, but its contrary is not always true. For example,
    if you work with a non-volatile integer value shared by more than one thread and
    make a lot of modifications, you may be able to see the modifications made by
    other threads because they were written in the main memory. However, there's no
    guarantee that these changes were passed from the cache to the main memory.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `volatile` keyword only works well when the value of the shared variable
    is only modified by one thread. If the variable is modified by multiple threads,
    the `volatile` keyword doesn't protect you from possible data-race conditions.
    It also doesn't make operations, such as `+` or `-`, atomic. For example, the
    `++` operator over a volatile variable is not thread-safe.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since Java 5, **Java Memory Model** has a happens--before guarantee established
    with the `volatile` keyword. This fact has two implications:'
  prefs: []
  type: TYPE_NORMAL
- en: When you modify a volatile variable, its value is sent to the main memory. The
    value of all the variables modified previously by the same thread are sent too.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Compilers can't reorder sentences that modify a volatile variable for an optimization
    purpose. It can reorder the previous operations and the later ones, but not the
    modifications of a volatile variable. The changes that happen before these modifications
    will be visible to those instructions.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The *Using atomic variables* and *Using atomic arrays* recipe in this chapter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using variable handles
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Variable handles are a new feature of Java 9 that allow you to get a typed reference
    to a variable (attribute, static field, or array element) in order to access it
    in different modes. You can, for example, protect access to this variable in a
    concurrent application by allowing atomic access to the variable. Until now, you
    could only obtain this behavior with atomic variables, but now, you can use variable
    handles to obtain the same functionality without using any synchronization mechanism.
    A variable handle also allows you to get additional access modes to a variable.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, you will learn how to obtain and use a variable handle and the
    benefits you obtain using it.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The example of this recipe has been implemented using the Eclipse IDE. If you
    use Eclipse or a different IDE, such as NetBeans, open it and create a new Java
    project.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Follow these steps to implement the example:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a class named `Account` with two double public attributes named `amount`
    and `unsafeAmount`. Implement the constructor to initialize its values:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE142]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a class named `Decrementer` and specify that it implements the `Runnable`
    interface. It has a private `Account` attribute initialized in the constructor
    of the class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE143]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement the `run()` method. This method will make 10,000 decrement operations
    in the `amount` and `unsafeAmount` attributes. To modify the value of the amount
    attribute, use `VarHandle`. Obtain it using the `lookup()` method of the `MethodHandles`
    class, then use the `getAndAdd()` method to modify the value of the attribute.
    To modify the `unsafeAmount` attribute, use the `=` operator:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE144]'
  prefs: []
  type: TYPE_PRE
- en: Implement a class named `Incrementer`. This will be equivalent to the `Drementer`
    class, but it will increase the value of the account. The source code of this
    class won't be included here.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Finally, implement the `Main` class with the `main()` method. First, create
    an `account` object:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE145]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, create a thread to execute an `Incrementer` task and a thread to execute
    a `Decrementer` task. Start them and wait for their finalization using the `join()`
    method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE146]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, write the value of the amount and `unsafeAmount` attributes in the
    console:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE147]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following screenshot shows the output of an execution of the application:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00049.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: As you make the same number of increment and decrement operations, the expected
    result in both cases is `0`. We obtain this result with the amount attribute because
    as we access it using the `VarHandle`, we guarantee atomic access to its modifications.
    On the other hand, the `unsafeAmount` doesn't have the expected value. Access
    to this value is not protected and we have a data-race condition.
  prefs: []
  type: TYPE_NORMAL
- en: To use a variable handle, first we have to obtain it using the `lookup()` method
    of the `MethodHandles` class, followed by the `in()` method and then the `findVarHandle()`
    method. The `lookup()` method returns a `Lookup` object, the `in()` method returns
    a `Lookup` object of the specified class—in our case, the `Account` class—and
    `findVarHandle()` generates `VarHandle` for the attribute we want to access.
  prefs: []
  type: TYPE_NORMAL
- en: Once we have the `VarHandle` object, we can use different methods to use different
    access modes. In this example, we used the `getAndAdd()` method. This method guarantees
    atomic access to increment the value of the attribute. We pass to them the object
    we want to access and the value of the increment.
  prefs: []
  type: TYPE_NORMAL
- en: The next section provides more information about the different access modes
    and the methods you can use in each case.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You have four different access types to a variable with a variable handle:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Read mode**: This is used to get read mode access to a variable. You can
    use the following methods:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`get()`: Read the value of the variable as if it was declared non-volatile'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`getVolatile()`: Read the value of the variable as if it was declared volatile'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`getAcquire()`: Read the value of the variable and guarantee that the following
    instructions that modify or access this variable are not reordered before the
    instructions for optimization purposes'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`getOpaque()`: Read the value of variable and guarantee that the instructions
    of the current thread are not reordered; no guarantee is provided for other threads'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Write mode**: This is used to get write access mode to a variable. You can
    use the `set()`, `setVolatile()`, `setRelease()`, and `setOpaque()` methods. They
    are equivalent to the previous ones but with write access.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Atomic access mode**: This is used to get a functionality that is similar
    to the one provided by the atomic variables with operations to, for example, compare
    and get the value of the variable. You can use the following methods:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`compareAndSet()`: Change the value of the variable as it was declared as a
    volatile variable if the expected value passed as parameter is equal to the current
    value of the variable'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`weakCompareAndSet()` and `weakCompareAndSetVolatile()`: Possibly atomically''
    changes the value of the variable as it was declared as non-volatile or volatile
    variables respectively if the expected value passed as parameter is equals to
    the current value of the variable'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Numerical update access mode**: This is to modify numerical values in an
    atomic way.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The *Using atomic variables* and *Using atomic arrays* recipe in this chapter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
