- en: Concurrent Collections
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: Using non-blocking thread-safe deques
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using blocking thread-safe deques
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using blocking thread-safe queue ordered by priority
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using thread-safe lists with delayed elements
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using thread-safe navigable maps
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using thread-safe HashMaps
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using atomic variables
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using atomic arrays
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the volatile keyword
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using variable handles
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Data structure** is a basic element of programming. Almost every program
    uses one or more types of data structure to store and manage data. The Java API
    provides the **Java Collections framework**. It contains interfaces, classes,
    and algorithms that implement a lot of different data structures that you can
    use in your programs.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: When you need to work with data collections in a concurrent program, you must
    be very careful with the implementation you choose. Most collection classes do
    not work with concurrent applications because they can't control concurrent access
    to their data. If a concurrent task shares a data structure that is unable to
    work with another concurrent task, you might have data inconsistency errors that
    will affect the operation of the program. One example of this kind of data structure
    is the `ArrayList` class.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: 'Java provides data collection processes that you can use in your concurrent
    programs without any problems or inconsistency. Basically, Java provides two kinds
    of collections to use in concurrent applications:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: '**Blocking collections**: This kind of collection includes operations to add
    and remove data. If the operation can''t be done immediately, because the collection
    is either full or empty, the thread that makes the call will be blocked until
    the operation could be carried out.'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Non-blocking collections**: This kind of collection also includes operations
    to add and remove data. But in this case, if the operation can''t be done immediately,
    it returns a `null` value or throws an exception; the thread that makes the call
    won''t be blocked here.'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Through the recipes in this chapter, you will learn how to use some Java collections
    in your concurrent applications. These include:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: Non-blocking deques, using the `ConcurrentLinkedDeque` class
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Blocking deques, using the `LinkedBlockingDeque` class
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Blocking queues to be used with producers and consumers of data, using the `LinkedTransferQueue`
    class
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Blocking queues that order elements by priority, using the `PriorityBlockingQueue`
    class
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Blocking queues with delayed elements, using the `DelayQueue` class
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Non-blocking navigable maps, using the `ConcurrentSkipListMap` class
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Non-blocking hash tables, using the `ConcurrentHashMap` class
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Atomic variables, using the `AtomicLong` and `AtomicIntegerArray` classes
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Variables stored in fields marked with the `volatile` keyword
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Atomic operations on the fields of individual classes, using variable handles.
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using non-blocking thread-safe deques
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '"List" is referred to as the most basic collection. It has an undetermined
    number of elements, and you can add, read, or remove an element from any position.
    Concurrent lists allow various threads to add or remove elements from the list
    at a time, without producing any data inconsistency errors. Similar to lists,
    we have deques. A deque is a data structure similar to a queue, but in a deque,
    you can add or remove elements from either the front (head) or back (tail).'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: “列表”被称为最基本的数据集合。它包含不确定数量的元素，你可以从任何位置添加、读取或移除一个元素。并发列表允许各种线程同时向列表添加或移除元素，而不会产生任何数据不一致错误。类似于列表，我们还有双端队列。双端队列是一种类似于队列的数据结构，但在双端队列中，你可以从前面（头部）或后面（尾部）添加或移除元素。
- en: In this recipe, you will learn how to use a non-blocking deque in a concurrent
    program. Non-blocking deques provide operations that, if not done immediately
    (for example, you want to get an element from a list but the list is empty), throw
    an exception or return a `null` value, depending on the operation. Java 7 introduced
    the `ConcurrentLinkedDeque` class that implements a non-blocking concurrent deque.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，你将学习如何在并发程序中使用非阻塞双端队列。非阻塞双端队列提供操作，如果立即不执行（例如，你想从列表中获取一个元素，但列表为空），则抛出异常或返回`null`值，具体取决于操作。Java
    7引入了`ConcurrentLinkedDeque`类，该类实现了一个非阻塞的并发双端队列。
- en: 'We are going to implement an example with the following two different tasks:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将实现以下两个不同任务的示例：
- en: One that adds thousands of elements to the deque
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向双端队列添加数千个元素
- en: One that removes data from the deque
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从双端队列中移除数据
- en: Getting ready
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: The example of this recipe has been implemented using the Eclipse IDE. If you
    use Eclipse or a different IDE, such as NetBeans, open it and create a new Java
    project.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 本菜谱的示例已使用Eclipse IDE实现。如果你使用Eclipse或NetBeans等其他IDE，请打开它并创建一个新的Java项目。
- en: How to do it...
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何实现...
- en: 'Follow these steps to implement the example:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤实现示例：
- en: 'Create a class named `AddTask` and specify that it implements the `Runnable`
    interface:'
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`AddTask`的类并指定它实现`Runnable`接口：
- en: '[PRE0]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Declare a private `ConcurrentLinkedDeque` attribute parameterized by the `String`
    class named `list`:'
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明一个名为`list`的私有`ConcurrentLinkedDeque`属性，由`String`类参数化：
- en: '[PRE1]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Implement the constructor of the class to initialize its attribute:'
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现类的构造函数以初始化其属性：
- en: '[PRE2]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Implement the `run()` method of the class. This method will have a loop with
    5000 cycles. In each cycle, we will take the first and last elements of the deque
    so we will take a total of 10,000 elements:'
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现类的`run()`方法。该方法将有一个5000次的循环。在每个循环中，我们将从双端队列中取出第一个和最后一个元素，因此我们将取出总共10,000个元素：
- en: '[PRE3]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Create a class named `PollTask` and specify that it implements the `Runnable`
    interface:'
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`PollTask`的类并指定它实现`Runnable`接口：
- en: '[PRE4]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Declare a private `ConcurrentLinkedDeque` attribute parameterized by the `String`
    class named `list`:'
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明一个名为`list`的私有`ConcurrentLinkedDeque`属性，由`String`类参数化：
- en: '[PRE5]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Implement the constructor of the class to initialize its attribute:'
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现类的构造函数以初始化其属性：
- en: '[PRE6]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Implement the `run()` method of the class. It takes out 10,000 elements of
    the deque in a loop with 5,000 steps, taking off two elements in each step:'
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现类的`run()`方法。它通过循环以5,000步取出双端队列中的10,000个元素，每步移除两个元素：
- en: '[PRE7]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Implement the main class of the example by creating a class named `Main` and
    adding the `main()` method to it:'
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过创建一个名为`Main`的类并添加`main()`方法来实现示例的主类：
- en: '[PRE8]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Create a `ConcurrentLinkedDeque` object parameterized by the `String` class
    named `list`:'
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个由`String`类参数化的名为`list`的`ConcurrentLinkedDeque`对象：
- en: '[PRE9]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Create an array of 100 `Thread` objects named `threads`:'
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`threads`的100个`Thread`对象数组：
- en: '[PRE10]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Create 100 `AddTask` objects and threads to run each one of them. Store every
    thread in the array created earlier and start them:'
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建100个`AddTask`对象和线程来运行它们中的每一个。将每个线程存储在之前创建的数组中并启动它们：
- en: '[PRE11]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Wait for the completion of the threads using the `join()` method:'
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`join()`方法等待线程的完成：
- en: '[PRE12]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Write the size of the list in the console:'
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在控制台输出列表的大小：
- en: '[PRE13]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Create 100 `PollTask` objects and threads to run each one of them. Store every
    thread in the array created earlier and start them:'
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建100个`PollTask`对象和线程来运行它们中的每一个。将每个线程存储在之前创建的数组中并启动它们：
- en: '[PRE14]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Wait for the finalization of the threads using the `join()` method:'
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`join()`方法等待线程的最终化：
- en: '[PRE15]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Write the size of the list in the console:'
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在控制台输出列表的大小：
- en: '[PRE16]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: How it works...
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'In this recipe, we used the `ConcurrentLinkedDeque` object parameterized by
    the `String` class to work with a non-blocking concurrent deque of data. The following
    screenshot shows the output of an execution of this example:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们使用了由 `String` 类参数化的 `ConcurrentLinkedDeque` 对象来处理非阻塞的并发数据双端队列。以下截图显示了此示例的执行输出：
- en: '![](img/00043.jpeg)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00043.jpeg)'
- en: First, you executed 100 `AddTask` tasks to add elements to the list. Each one
    of these tasks inserts 10,000 elements to the list using the `add()` method. This
    method adds new elements at the end of the deque. When all the tasks had finished,
    you wrote the number of elements of the deque in the console. At that moment,
    the deque had 1,000,000 elements.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你执行了100个 `AddTask` 任务向列表中添加元素。每个任务使用 `add()` 方法向列表中插入10,000个元素。此方法将新元素添加到双端队列的末尾。当所有任务完成后，你在控制台输出了双端队列的元素数量。那时，双端队列有1,000,000个元素。
- en: Then, you executed 100 `PollTask` tasks to remove elements from the deque. Each
    one of these tasks removes 10,000 elements from the deque using the `pollFirst()`
    and `pollLast()` methods. The `pollFirst()` method returns and removes the first
    element of the deque, and the `pollLast()` method returns and removes the last
    element of the deque. If the deque is empty, they return a `null` value. When
    all the tasks had finished, you wrote the number of elements of the deque in the
    console. At that moment, the list had zero elements. Take into account that the
    `ConcurrentLinkedDeque` data structure doesn't allow you to add `null` values.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你执行了100个 `PollTask` 任务从双端队列中移除元素。每个任务使用 `pollFirst()` 和 `pollLast()` 方法从双端队列中移除10,000个元素。`pollFirst()`
    方法返回并移除双端队列的第一个元素，而 `pollLast()` 方法返回并移除双端队列的最后一个元素。如果双端队列为空，它们返回一个 `null` 值。当所有任务完成后，你在控制台输出了双端队列的元素数量。那时，列表中的元素数量为零。请注意，`ConcurrentLinkedDeque`
    数据结构不允许你添加 `null` 值。
- en: To write the number of elements in the deque, you used the `size()` method.
    You have to take into account that this method can return a value that is not
    real, especially if you use it when there are threads adding to or deleting data
    from the list. The method has to traverse the entire deque to count the elements,
    and the contents of the list can change with this operation. Only if you use them
    when there aren't any threads modifying the deque, you will have the guarantee
    that the returned result would be correct.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 要写入双端队列中的元素数量，你使用了 `size()` 方法。你必须考虑到，此方法可能返回一个非实际值，特别是当你使用它在有线程向列表添加或从列表删除数据时。该方法必须遍历整个双端队列来计数元素，并且列表的内容可能会因为此操作而改变。只有在你使用它们而没有线程修改双端队列时，你才能保证返回的结果是正确的。
- en: There's more...
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更多...
- en: 'The `ConcurrentLinkedDeque` class provides more methods to get elements from
    the deque:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '`ConcurrentLinkedDeque` 类提供了更多方法来从双端队列中获取元素：'
- en: '`getFirst()` and `getLast()`: These methods return the first and last element
    from the deque, respectively. They don''t remove the returned element from the
    deque. If the deque is empty, they throw a `NoSuchElementExcpetion` exception.'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getFirst()` 和 `getLast()`: 这些方法分别从双端队列中返回第一个和最后一个元素。它们不会从双端队列中移除返回的元素。如果双端队列为空，它们会抛出
    `NoSuchElementExcpetion` 异常。'
- en: '`peek()`, `peekFirst()`, and `peekLast()`: These methods return the first and
    the last element of the deque, respectively. They don''t remove the returned element
    from the deque. If the deque is empty, they return a `null` value.'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`peek()`, `peekFirst()`, 和 `peekLast()`: 这些方法分别返回双端队列的第一个和最后一个元素。它们不会从双端队列中移除返回的元素。如果双端队列为空，它们返回一个
    `null` 值。'
- en: '`remove()`, `removeFirst()`, and `removeLast()`: These methods return the first
    and last element of the deque, respectively. They remove the returned element
    as well. If the deque is empty, they throw a `NoSuchElementException` exception.'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`remove()`, `removeFirst()`, 和 `removeLast()`: 这些方法分别返回双端队列的第一个和最后一个元素。它们也会移除返回的元素。如果双端队列为空，它们会抛出
    `NoSuchElementException` 异常。'
- en: Using blocking thread-safe deques
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用阻塞线程安全的双端队列
- en: The most basic collection is referred to as a list. A list has an unlimited
    number of elements, and you can add, read, or remove an element from any position.
    A concurrent list allows various threads to add or remove elements from the list
    at a time without producing any data inconsistency. Similar to lists, we have
    deques. A deque is a data structure similar to a queue, but in a deque, you can
    add or remove elements from either the front (head) or back (tail).
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 最基本的集合被称为列表。列表具有无限数量的元素，你可以从任何位置添加、读取或删除一个元素。并发列表允许各种线程同时向列表添加或删除元素，而不会产生任何数据不一致性。与列表类似，我们还有双端队列。双端队列是一种类似于队列的数据结构，但在双端队列中，你可以从前面（头部）或后面（尾部）添加或删除元素。
- en: In this recipe, you will learn how to use blocking deques in your concurrent
    programs. The main difference between blocking deques and non-blocking deques
    is that blocking deques have methods to insert and delete elements that, if not
    done immediately because the list is either full or empty, block the thread that
    make the call until the operation could be carried out. Java includes the `LinkedBlockingDeque`
    class that implements a blocking deque.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在此菜谱中，你将学习如何在你的并发程序中使用阻塞双端队列。阻塞双端队列与非阻塞双端队列之间的主要区别在于，阻塞双端队列具有插入和删除元素的方法，如果由于列表已满或为空而无法立即执行，则这些方法将阻塞调用线程，直到操作可以执行。Java包括实现了阻塞双端队列的`LinkedBlockingDeque`类。
- en: 'You are going to implement an example with the following two tasks:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 你将实现以下两个任务的示例：
- en: One that adds thousands of elements to the deque
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个向双端队列添加数千个元素的操作
- en: One that massively removes data from the same list
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个从同一列表大量删除数据的操作
- en: Getting ready
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: The example of this recipe has been implemented using the Eclipse IDE. If you
    use Eclipse
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 此菜谱的示例已使用Eclipse IDE实现。如果你使用Eclipse
- en: or a different IDE, such as NetBeans, open it and create a new Java project.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 或者使用不同的IDE，例如NetBeans，打开它并创建一个新的Java项目。
- en: How to do it...
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Follow the steps described next to implement the example:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤描述实现示例：
- en: 'Create a class named `Client` and specify that it implements the `Runnable`
    interface:'
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`Client`的类并指定它实现`Runnable`接口：
- en: '[PRE17]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Declare a private `LinkedBlockingDeque` attribute parameterized by the `String`
    class named `requestList`:'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明一个名为`requestList`的私有`LinkedBlockingDeque`属性，该属性由`String`类参数化：
- en: '[PRE18]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Implement the constructor of the class to initialize its attributes:'
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现类的构造函数以初始化其属性：
- en: '[PRE19]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Implement the `run()` method. Insert five `String` objects into the deque per
    second using the `put()` method of the `requestList` object. Repeat this cycle
    three times:'
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现该`run()`方法。每秒使用`requestList`对象的`put()`方法将五个`String`对象插入到双端队列中。重复此循环三次：
- en: '[PRE20]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Create the main class of the example by creating a class named `Main` and adding
    the `main()` method to it:'
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过创建一个名为`Main`的类并添加`main()`方法来创建示例的主类：
- en: '[PRE21]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Declare and create `LinkedBlockingDeque` parameterized by the `String` class
    named list specifying a fixed size of three:'
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明并创建一个名为`list`的`LinkedBlockingDeque`，该双端队列由`String`类参数化，并指定固定大小为三：
- en: '[PRE22]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Create and start a `Thread` object to execute a client task:'
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建并启动一个`Thread`对象以执行客户端任务：
- en: '[PRE23]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Get three `String` objects from the list every 300 milliseconds using the `take()`
    method of the list object. Repeat this cycle five times. Write the strings in
    the console:'
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 每300毫秒使用列表对象的`take()`方法从列表中获取三个`String`对象。重复此循环五次。将字符串写入控制台：
- en: '[PRE24]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Write a message to indicate the end of the program:'
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一条消息以指示程序结束：
- en: '[PRE25]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: How it works...
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In this recipe, you used `LinkedBlockingDeque`, parameterized by the `String`
    class, to work with a non-blocking concurrent deque of data.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在此菜谱中，你使用了由`String`类参数化的`LinkedBlockingDeque`，以处理非阻塞的并发数据双端队列。
- en: The `Client` class uses the `put()` method to insert strings into the deque.
    If the deque is full (because you have created it with fixed capacity), the method
    will block the execution of its thread until there is empty space in the list.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '`Client`类使用`put()`方法将字符串插入到双端队列中。如果双端队列已满（因为你已使用固定容量创建它），则该方法将阻塞其线程的执行，直到列表中有空余空间。'
- en: The `Main` class uses the `take()` method to get strings from the deque. If
    the deque is empty, the method blocks the execution of its thread until there
    are elements in the deque.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '`Main`类使用`take()`方法从双端队列中获取字符串。如果双端队列为空，则该方法将阻塞其线程的执行，直到双端队列中有元素。'
- en: Both the methods of the `LinkedBlockingDeque` class used in this example can
    throw an `InterruptedException` exception if they are interrupted while they are
    being blocked. So, you have to include the necessary code to catch this exception.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在本例中使用的 `LinkedBlockingDeque` 类的这两种方法如果在被阻塞时被中断，可能会抛出一个 `InterruptedException`
    异常。因此，你必须包含必要的代码来捕获这个异常。
- en: There's more...
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更多内容...
- en: 'The `LinkedBlockingDeque` class also provides methods to insert and get elements
    from the deque that, instead of being blocked, throws an exception or returns
    the `null` value. These methods are as follows:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '`LinkedBlockingDeque` 类还提供了插入和从双端队列获取元素的方法，这些方法不是阻塞的，而是抛出异常或返回 `null` 值。这些方法如下：'
- en: '`takeFirst()` and `takeLast()`: These return the first and last element of
    the deque, respectively. They remove the returned element from the deque. If the
    deque is empty, they block the thread until there are elements in the deque.'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`takeFirst()` 和 `takeLast()`：这些方法分别返回双端队列的第一个和最后一个元素。它们会从双端队列中移除返回的元素。如果双端队列为空，它们会阻塞线程，直到双端队列中有元素为止。'
- en: '`getFirst()` and `getLast()`: These return the first and last element of the
    deque, respectively. They don''t remove the returned element from the deque. If
    the deque is empty, they throw a `NoSuchElementExcpetion` exception.'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getFirst()` 和 `getLast()`：这些方法分别返回双端队列的第一个和最后一个元素。它们不会从双端队列中移除返回的元素。如果双端队列为空，它们抛出一个
    `NoSuchElementException` 异常。'
- en: '`peek()`, `peekFirst()`, and `peekLast()`: The `peekFirst()` and `peekLast()`
    methods return the first and last element of the deque, respectively. They don''t
    remove the returned element from the deque. If the deque is empty, they return
    a `null` value.'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`peek()`、`peekFirst()` 和 `peekLast()`：`peekFirst()` 和 `peekLast()` 方法分别返回双端队列的第一个和最后一个元素。它们不会从双端队列中移除返回的元素。如果双端队列为空，它们返回一个
    `null` 值。'
- en: '`poll()`, `pollFirst()`, and `pollLast()`: The `pollFirst()` and `pollLast()`
    methods return the first and last element of the deque, respectively. They remove
    the returned element from the deque. If the list is empty, they return a `null`
    value.'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`poll()`、`pollFirst()` 和 `pollLast()`：`pollFirst()` 和 `pollLast()` 方法分别返回双端队列的第一个和最后一个元素。它们会从双端队列中移除返回的元素。如果列表为空，它们返回一个
    `null` 值。'
- en: '`add()`, `addFirst()`, and `addLast()`: The `addFirst()` and `addLast()` methods
    add an element to the first and last position, respectively. If the deque is full
    (created with fixed capacity), they throw an `IllegalStateException` exception.'
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`add()`、`addFirst()` 和 `addLast()`：`addFirst()` 和 `addLast()` 方法分别将元素添加到第一个和最后一个位置。如果双端队列已满（使用固定容量创建），它们会抛出一个
    `IllegalStateException` 异常。'
- en: See also
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: The *Using non-blocking thread-safe deques* recipe in this chapter
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本章中使用的 *使用非阻塞线程安全的双端队列* 烹饪配方
- en: Using blocking thread-safe queue ordered by priority
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用按优先级排序的阻塞线程安全队列
- en: When you work with data structures, you may typically feel the need to have
    an ordered queue. Java provides `PriorityBlockingQueue` that has this functionality.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 当你与数据结构一起工作时，你可能通常会感到需要有一个有序队列。Java 提供了具有此功能的 `PriorityBlockingQueue`。
- en: 'All the elements you want to add to `PriorityBlockingQueue` have to implement
    the `Comparable` interface; alternatively, you can include `Comparator` in the
    queue''s constructor. This interface has a method called `compareTo()` that receives
    an object of the same type. So you have two objects to compare: the one that is
    executing the method and the one that is received as a parameter. The method must
    return a number less than zero if the local object is less than the parameter.
    It should return a number bigger than zero if the local object is greater than
    the parameter. The number must be zero if both the objects are equal.'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 你想要添加到 `PriorityBlockingQueue` 中的所有元素都必须实现 `Comparable` 接口；或者，你可以在队列的构造函数中包含
    `Comparator`。此接口有一个名为 `compareTo()` 的方法，它接收相同类型的对象。因此，你有两个对象要比较：一个是执行方法的对象，另一个是作为参数接收的对象。如果本地对象小于参数，该方法必须返回一个小于零的数字。如果本地对象大于参数，它应该返回一个大于零的数字。如果两个对象都相等，数字必须为零。
- en: '`PriorityBlockingQueue` uses the `compareTo()` method when you insert an element
    in it to determine the position of the element inserted. Bigger elements will
    either be the tail or head of the queue, depending on the `compareTo()` method.'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在 `PriorityBlockingQueue` 中插入一个元素时，`PriorityBlockingQueue` 使用 `compareTo()`
    方法来确定插入元素的位置。较大的元素将根据 `compareTo()` 方法是队列的尾部还是头部。
- en: Another important characteristic of `PriorityBlockingQueue` is that it's a **blocking
    data structure**. It has methods that, if unable to perform the operation immediately,
    will block the thread until they are able to do it.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '`PriorityBlockingQueue` 的另一个重要特性是它是一个 **阻塞数据结构**。它具有方法，如果无法立即执行操作，将阻塞线程，直到它们能够执行。'
- en: In this recipe, you will learn how to use the `PriorityBlockingQueue` class
    by implementing an example, where you are going to store a lot of events with
    different priorities in the same list, to check that the queue will be ordered
    as you want.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在本食谱中，您将通过实现一个示例来学习如何使用 `PriorityBlockingQueue` 类，在该示例中，您将在同一个列表中存储具有不同优先级的大量事件，以检查队列是否按您希望的方式排序。
- en: Getting ready
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: The example of this recipe has been implemented using the Eclipse IDE. If you
    use Eclipse
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 本食谱的示例已使用 Eclipse IDE 实现。如果您使用 Eclipse 或其他不同的 IDE，例如 NetBeans，请打开它并创建一个新的 Java
    项目。
- en: or a different IDE, such as NetBeans, open it and create a new Java project.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 或打开不同的 IDE，例如 NetBeans，创建一个新的 Java 项目。
- en: How to do it...
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Follow these steps to implement the example:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤实现示例：
- en: 'Create a class named `Event` and specify that it implements the `Comparable`
    interface parameterized by the `Event` class:'
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `Event` 的类，并指定它实现由 `Event` 类参数化的 `Comparable` 接口：
- en: '[PRE26]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Declare a private `int` attribute named `thread` to store the number of threads
    that have created the event:'
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明一个名为 `thread` 的私有 `int` 属性，用于存储创建事件的线程数：
- en: '[PRE27]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Declare a private `int` attribute named `priority` to store the priority of
    the event:'
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明一个名为 `priority` 的私有 `int` 属性，用于存储事件的优先级：
- en: '[PRE28]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Implement the constructor of the class to initialize its attributes:'
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现类的构造函数以初始化其属性：
- en: '[PRE29]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Implement the `getThread()` method to return the value of the thread attribute:'
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现返回线程属性值的 `getThread()` 方法：
- en: '[PRE30]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Implement the `getPriority()` method to return the value of the priority attribute:'
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现返回优先级属性值的 `getPriority()` 方法：
- en: '[PRE31]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Implement the `compareTo()` method. It receives `Event` as a parameter and
    compares the priority of the current event and the one received as a parameter.
    It returns `-1` if the priority of the current event is bigger, `0` if both the
    priorities are equal, and `1` if the priority of the current event is smaller.
    Note that this is the opposite of most `Comparator.compareTo()` implementations:'
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现比较方法 `compareTo()`。它接收 `Event` 作为参数，比较当前事件和接收到的参数的优先级。如果当前事件的优先级更高，则返回 `-1`；如果两个优先级相等，则返回
    `0`；如果当前事件的优先级更低，则返回 `1`。注意，这与大多数 `Comparator.compareTo()` 实现相反：
- en: '[PRE32]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Create a class named `Task` and specify that it implements the `Runnable` interface:'
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `Task` 的类，并指定它实现 `Runnable` 接口：
- en: '[PRE33]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Declare a private `int` attribute named `id` to store the number that identifies
    the task:'
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明一个名为 `id` 的私有 `int` 属性，用于存储标识任务的数字：
- en: '[PRE34]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Declare a private `PriorityBlockingQueue` attribute parameterized by the `Event`
    class named `queue` to store the events generated by the task:'
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明一个名为 `queue` 的私有 `PriorityBlockingQueue` 属性，参数化为 `Event` 类，用于存储任务生成的事件：
- en: '[PRE35]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Implement the constructor of the class to initialize its attributes:'
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现类的构造函数以初始化其属性：
- en: '[PRE36]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Implement the `run()` method. It stores 1,000 events in the queue, using its
    ID, to identify the task that creates the event and we assign to each event a
    different priority from 1 to 1000\. Use the `add()` method to store the events
    in the queue:'
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现 `run()` 方法。在队列中存储 1,000 个事件，使用其 ID 来标识创建事件的任务，并为每个事件分配一个从 1 到 1000 的不同优先级。使用
    `add()` 方法将事件存储在队列中：
- en: '[PRE37]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Implement the main class of the example by creating a class named `Main` and
    adding the `main()` method to it:'
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过创建一个名为 `Main` 的类并添加 `main()` 方法来实现示例的主类：
- en: '[PRE38]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Create a `PriorityBlockingQueue` object parameterized by the `Event` class
    named `queue`:'
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `queue` 的 `PriorityBlockingQueue` 对象，参数化为 `Event` 类：
- en: '[PRE39]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Create an array of five `Thread` objects to store the threads that will execute
    the five tasks:'
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个包含五个 `Thread` 对象的数组以存储将执行五个任务的线程：
- en: '[PRE40]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Create five `Task` objects. Store the threads in the array created earlier:'
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建五个 `Task` 对象。将线程存储在之前创建的数组中：
- en: '[PRE41]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Start the five threads created earlier:'
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动之前创建的五个线程：
- en: '[PRE42]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Wait for the finalization of the five threads using the `join()` method:'
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `join()` 方法等待五个线程的最终化：
- en: '[PRE43]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Write the actual size of the queue in the console and the events stored in
    it. Use the `poll()` method to take off the events from the queue:'
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在控制台中写入队列的实际大小和存储在其中的事件。使用 `poll()` 方法从队列中取出事件：
- en: '[PRE44]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Write a message to the console with the final size of the queue:'
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向控制台写入队列的最终大小信息：
- en: '[PRE45]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: How it works...
  id: totrans-178
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In this example, you implemented a priority queue of `Event` objects using `PriorityBlockingQueue`.
    As mentioned in the introduction, all the elements stored in `PriorityBlockingQueue`
    have to implement the `Comparable` interface or provide a `Comparator` object
    to the constructor of the queue. In this case, you used the first approach, so
    you implemented the `compareTo()` method in the `Event` class.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，你使用`PriorityBlockingQueue`实现了`Event`对象的优先队列。如介绍中所述，存储在`PriorityBlockingQueue`中的所有元素都必须实现`Comparable`接口或向队列的构造函数提供`Comparator`对象。在这种情况下，你采用了第一种方法，因此在`Event`类中实现了`compareTo()`方法。
- en: All the events have a priority attribute. The elements that have a higher value
    of priority will be the first elements in the queue. When you implement the `compareTo()`
    method, if the event executing the method has a priority higher than the priority
    of the event passed as a parameter, it returns `-1` as the result. In another
    case, if the event executing the method has a priority lower than the priority
    of the event passed as a parameter, it returns `1` as the result. If both objects
    have the same priority, the `compareTo()` method returns `0`. In this case, the
    `PriorityBlockingQueue` class doesn't guarantee the order of the elements.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 所有事件都有一个优先级属性。优先级值较高的元素将是队列中的第一个元素。当你实现`compareTo()`方法时，如果执行此方法的事件的优先级高于作为参数传递的事件的优先级，它返回`-1`作为结果。在另一种情况下，如果执行此方法的事件的优先级低于作为参数传递的事件的优先级，它返回`1`作为结果。如果两个对象具有相同的优先级，`compareTo()`方法返回`0`。在这种情况下，`PriorityBlockingQueue`类不保证元素的顺序。
- en: We implemented the `Task` class to add the `Event` objects to the priority queue.
    Each task object adds 1,000 events to the queue, with priorities between `0` and
    `999`, using the `add()` method.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 我们实现了`Task`类，以便将`Event`对象添加到优先队列中。每个任务对象使用`add()`方法将1,000个事件添加到队列中，优先级在`0`到`999`之间。
- en: The `main()` method of the `Main` class creates five `Task` objects and executes
    them in the corresponding threads. When all the threads had finished their execution,
    you wrote all the elements to the console. To get the elements from the queue,
    we used the `poll()` method. This method returns and removes the first element
    from the queue.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '`Main`类的`main()`方法创建了五个`Task`对象，并在相应的线程中执行它们。当所有线程完成执行后，你将所有元素写入控制台。要从队列中获取元素，我们使用了`poll()`方法。此方法返回并移除队列中的第一个元素。'
- en: 'The following screenshot shows part of the output of an execution of the program:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了程序执行输出的一部分：
- en: '![](img/00044.jpeg)'
  id: totrans-184
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00044.jpeg)'
- en: You can see how the queue has a size of 5,000 elements and how the first elements
    have the biggest priority value.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到队列有5,000个元素，以及第一个元素具有最大的优先级值。
- en: There's more...
  id: totrans-186
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'The `PriorityBlockingQueue` class has other interesting methods. The following
    is a description of some of them:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '`PriorityBlockingQueue`类还有其他一些有趣的方法。以下是一些方法的描述：'
- en: '`clear()`: This method removes all the elements of the queue.'
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`clear()`: 此方法移除队列中的所有元素。'
- en: '`take()`: This method returns and removes the first element of the queue. If
    the queue is empty, it blocks its thread until the queue has elements.'
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`take()`: 此方法返回并移除队列的第一个元素。如果队列是空的，它将阻塞其线程，直到队列有元素。'
- en: '`put(E e)`: This is the class used to parameterize the `PriorityBlockingQueue`
    class. It inserts the element that is passed as a parameter into the queue.'
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`put(E e)`: 这是用于参数化`PriorityBlockingQueue`类的类。它将作为参数传递的元素插入到队列中。'
- en: '`peek()`: This method returns the first element of the queue but doesn''t remove
    it.'
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`peek()`: 此方法返回队列的第一个元素，但不移除它。'
- en: See also
  id: totrans-192
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: The *Using blocking thread-safe deques* recipe in this chapter
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本章中的*使用阻塞线程安全的双端队列*配方
- en: Using thread-safe lists with delayed elements
  id: totrans-194
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用带有延迟元素的线程安全列表
- en: 'An interesting data structure provided by the Java API, which you can use in
    concurrent applications, is implemented in the `DelayQueue` class. In this class,
    you can store elements with an activation date. The methods that return or extract
    elements from the queue will ignore these elements whose data will appear in the
    future. They are invisible to these methods.To obtain this behavior, the elements
    you want to store in the `DelayQueue` class need to have the `Delayed` interface
    implemented. This interface allows you to work with delayed objects. This interface
    has the `getDelay()` method that returns the time until the activation of the
    element. This interface forces you to implement the following two methods:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: Java API 提供的一个有趣的数据结构，你可以在并发应用程序中使用，是在 `DelayQueue` 类中实现的。在这个类中，你可以存储具有激活日期的元素。返回或从队列中提取元素的方法将忽略这些元素，其数据将在未来出现。它们对这些方法不可见。为了获得这种行为，你想要存储在
    `DelayQueue` 类中的元素需要实现 `Delayed` 接口。此接口允许你处理延迟对象。此接口有一个 `getDelay()` 方法，它返回元素激活的时间。此接口强制你实现以下两个方法：
- en: '`compareTo(Delayed o)`: The `Delayed` interface extends the `Comparable` interface.
    This method will return a value less than zero if the object that is executing
    the method has a delay smaller than the object passed as a parameter. It will
    return a value greater than zero if the object that is executing the method has
    a delay bigger than the object passed as a parameter. It will return zero if both
    the objects have the same delay.'
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`compareTo(Delayed o)`: `Delayed` 接口扩展了 `Comparable` 接口。如果执行此方法的对象具有比作为参数传递的对象更小的延迟，则此方法将返回一个小于零的值。如果执行此方法的对象具有比作为参数传递的对象更大的延迟，则返回一个大于零的值。如果两个对象具有相同的延迟，则返回零。'
- en: '`getDelay(TimeUnit unit)`: This method has to return the time remaining until
    the activation date in units, as specified by the unit parameter. The `TimeUnit`
    class is an enumeration with the following constants: `DAYS`, `HOURS`, `MICROSECONDS`,
    `MILLISECONDS`, `MINUTES`, `NANOSECONDS`, and `SECONDS`.'
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getDelay(TimeUnit unit)`: 此方法必须返回直到激活日期剩余的时间，以单位为单位，由单位参数指定。`TimeUnit` 类是一个枚举，具有以下常量：`DAYS`、`HOURS`、`MICROSECONDS`、`MILLISECONDS`、`MINUTES`、`NANOSECONDS`
    和 `SECONDS`。'
- en: In this example, you will learn how to use the `DelaydQueue` class by storing
    in it some events with different activation dates.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 在本例中，你将学习如何通过在其中存储具有不同激活日期的一些事件来使用 `DelaydQueue` 类。
- en: Getting ready
  id: totrans-199
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: The example of this recipe has been implemented using the Eclipse IDE. If you
    use Eclipse
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 本食谱的示例已使用 Eclipse IDE 实现。如果你使用 Eclipse
- en: or a different IDE, such as NetBeans, open it and create a new Java project.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 或者使用不同的 IDE，例如 NetBeans，打开它并创建一个新的 Java 项目。
- en: How to do it...
  id: totrans-202
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Follow these steps to implement the example:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤实现示例：
- en: 'Create a class named `Event` and specify that it implements the `Delayed` interface:'
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `Event` 的类，并指定它实现 `Delayed` 接口：
- en: '[PRE46]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Declare a private `Date` attribute named `startDate`:'
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明一个名为 `startDate` 的私有 `Date` 属性：
- en: '[PRE47]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Implement the constructor of the class to initialize its attribute:'
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现类的构造函数以初始化其属性：
- en: '[PRE48]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Implement the `compareTo()` method. It receives a `Delayed` object as its parameter.
    Return the difference between the delay of the current object and the one passed
    as a parameter:'
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现 `compareTo()` 方法。它接收一个 `Delayed` 对象作为其参数。返回当前对象延迟与作为参数传递的对象之间的差值：
- en: '[PRE49]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Implement the `getDelay()` method. Return the difference between the start
    date of the object and the actual date in `TimeUnit`, which is received as a parameter:'
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现 `getDelay()` 方法。返回对象开始日期与实际日期在 `TimeUnit` 中的差值，该值作为参数接收：
- en: '[PRE50]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Create a class named `Task` and specify that it implements the `Runnable` interface:'
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `Task` 的类，并指定它实现 `Runnable` 接口：
- en: '[PRE51]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Declare a private `int` attribute named `id` to store a number that identifies
    this task:'
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明一个名为 `id` 的私有 `int` 属性，用于存储一个标识此任务的数字：
- en: '[PRE52]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Declare a private `DelayQueue` attribute parameterized by the `Event` class
    named `queue`:'
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明一个名为 `queue` 的私有 `DelayQueue` 属性，该属性由 `Event` 类参数化：
- en: '[PRE53]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Implement the constructor of the class to initialize its attributes:'
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现类的构造函数以初始化其属性：
- en: '[PRE54]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Implement the `run()` method. First, calculate the activation date of the events
    that this task is going to create. Then, add the number of seconds equal to the
    ID of the object to the actual date:'
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现 `run()` 方法。首先，计算此任务将要创建的事件的激活日期。然后，将对象的 ID 等于的秒数加到实际日期上：
- en: '[PRE55]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Store 100 events in the queue using the `add()` method:'
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `add()` 方法在队列中存储 100 个事件：
- en: '[PRE56]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Implement the main class of the example by creating a class named `Main` and
    adding the `main()` method to it:'
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Create a `DelayQueue` object parameterized by the `Event` class:'
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Create an array of five `Thread` objects to store the tasks you''re going to
    execute:'
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Create five `Task` objects with different IDs:'
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Launch all the five tasks created earlier:'
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE61]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Wait for the finalization of the threads using the `join()` method:'
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE62]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Write to the console the events stored in the queue. When the size of the queue
    is bigger than zero, use the `poll()` method to obtain an `Event` class. If it
    returns `null`, put the main thread to sleep for 500 milliseconds for the activation
    of more events:'
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE63]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: How it works...
  id: totrans-240
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we implemented the `Event` class. This class has a unique attribute,
    the activation date of the events, and it implements the `Delayed` interface.
    You can store `Event` objects in the `DelayQueue` class.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
- en: The `getDelay()` method returns the number of nanoseconds between the activation
    date and the actual date. Both dates are objects of the `Date` class. You used
    the `getTime()` method that returns a date converted into milliseconds. Then,
    you converted this value into `TimeUnit`, which was received as a parameter. The
    `DelayQueue` class works in nanoseconds, but at this point, it's transparent to
    you.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
- en: The `compareTo()` method returns a value less than zero if the delay of the
    object executing the method is smaller than the delay of the object passed as
    a parameter. It returns a value greater than zero if the delay of the object executing
    the method is bigger than the delay of the object passed as a parameter. It returns
    `0` if both the delays are equal.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
- en: You also implemented the `Task` class. This class has an `integer` attribute
    named `id`. When a `Task` object is executed, it adds the number of seconds that
    is equal to the ID of the task to the actual date, and this refers to the activation
    date of the events stored by this task in the `DelayQueue` class. Each `Task`
    object stores 100 events in the queue using the `add()` method.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
- en: Finally, in the `main()` method of the `Main` class, you created five `Task`
    objects and executed them in their corresponding threads. When these threads finished
    their execution, you wrote all the events using the `poll()` method in the console.
    This method retrieves and removes the first element of the queue. If the queue
    does not have any active element, it returns the `null` value. You call the `poll()`
    method, and if it returns an `Event` class, you increment a counter. When it returns
    the `null` value, you write the value of the counter in the console and put the
    thread to sleep for half a second to wait for more active events. When you obtained
    the 500 events stored in the queue, the execution of the program finished.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shows part of the output of an execution of the program:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00045.jpeg)'
  id: totrans-247
  prefs: []
  type: TYPE_IMG
- en: You can see how the program only gets 100 events when it is activated.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
- en: You must be very careful with the `size()` method. It returns the total number
    of elements in the list that includes both active and non-active elements.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  id: totrans-250
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `DelayQueue` class has other interesting methods, which are as follows:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
- en: '`clear()`: This method removes all the elements of the queue.'
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`offer(E e)`: Here, `E` represents the class used to parameterize the `DelayQueue`
    class. This method inserts the element that is passed as a parameter into the
    queue.'
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`peek()`: This method retrieves but doesn''t remove the first element of the
    queue.'
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`take()`: This method retrieves and removes the first element of the queue.
    If there aren''t any active elements, the thread that is executing the method
    will be blocked until the thread gets some active elements.'
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: See also
  id: totrans-256
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The *Using blocking thread-safe deques* recipe in this chapter
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using thread-safe navigable maps
  id: totrans-258
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `ConcurrentNavigableMap` is an interface that defines interesting data
    structures provided by the Java API that you can use in your concurrent programs.
    The classes that implement the `ConcurrentNavigableMap` interface stores elements
    in two parts:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
- en: A **key** that uniquely identifies an element
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The rest of the data that defines the element, called **value**
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Java API also provides a class that implements `ConcurrentSkipListMap`,
    which is the interface that implements a non-blocking list with the behavior of
    the `ConcurrentNavigableMap` interface. Internally, it uses a **Skip List** to
    store data. A Skip List is a data structure based on parallel lists that allow
    us to get the kind of efficiency that is associated with a binary tree. You can
    get more information about Skip Lists at [https://en.wikipedia.org/wiki/Skip_list](https://en.wikipedia.org/wiki/Skip_list).
    With it, you can get a sorted data structure, instead of a sorted list, with better
    access time to insert, search, or delete elements.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
- en: Skip List was introduced by William Pugh in 1990.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
- en: When you insert an element to a map, the map uses a key to order them; therefore,
    all the elements will be ordered. The keys have to implement the `Comparable`
    interface, or you have to supply a `Comparator` class to the constructor of the
    map. The class also provides methods to obtain a submap of the map, in addition
    to the ones that return a concrete element.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, you will learn how to use the `ConcurrentSkipListMap` class
    to implement a map of contacts.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-266
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The example of this recipe has been implemented using the Eclipse IDE. If you
    use Eclipse or a different IDE, such as NetBeans, open it and create a new Java
    project.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-268
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Follow these steps to implement the example:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a class named `Contact`:'
  id: totrans-270
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE64]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Declare two private `String` attributes named `name` and `phone`:'
  id: totrans-272
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE65]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Implement the constructor of the class to initialize its attributes:'
  id: totrans-274
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE66]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Implement the methods to return the values of the `name` and `phone` attributes:'
  id: totrans-276
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE67]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Create a class named `Task` and specify that it implements the `Runnable` interface:'
  id: totrans-278
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE68]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Declare a private `ConcurrentSkipListMap` attribute, parameterized by the `String`
    and `Contact` classes, named `map`:'
  id: totrans-280
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE69]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Declare a private `String` attribute named `id` to store the ID of the current
    task:'
  id: totrans-282
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE70]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Implement the constructor of the class to store its attributes:'
  id: totrans-284
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE71]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'Implement the `run()` method. It stores 1,000 different contacts in the map
    using the ID of the task and an incremental number to create `Contact` objects.
    Use the `put()` method to store the contacts in the map:'
  id: totrans-286
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE72]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'Implement the main class of the example by creating a class named `Main` and
    adding the `main()` method to it:'
  id: totrans-288
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE73]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'Create a `ConcurrentSkipListMap` object, parameterized by the `String` and
    `Conctact` classes, named `map`:'
  id: totrans-290
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE74]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'Create an array for 26 `Thread` objects to store all the `Task` objects that
    you''re going to execute:'
  id: totrans-292
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE75]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'Create and launch 26 `task` objects and assign a capital letter to the ID of
    each task:'
  id: totrans-294
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE76]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'Wait for the finalization of the threads using the `join()` method:'
  id: totrans-296
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE77]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'Get the first entry of the map using the `firstEntry()` method. Write its data
    to the console:'
  id: totrans-298
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE78]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'Get the last entry of the map using the `lastEntry()` method. Write its data
    to the console:'
  id: totrans-300
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE79]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'Obtain a submap of the map using the `subMap()` method. Write its data to the
    console:'
  id: totrans-302
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE80]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: How it works...
  id: totrans-304
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we implemented a `Task` class to store `Contact` objects in
    a navigable map. Each contact has a name, which is the ID of the task that creates
    it, and a phone number, which is a number between 1,000 and 2,000\. We concatenated
    these values as keys for the contacts. Each `Task` object creates 1,000 contacts;
    these contacts are stored in the navigable map using the `put()` method.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
- en: If you insert an element with a key that exists in the map, the element associated
    with that key will be replaced by the new element.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
- en: The `main()` method of the `Main` class creates 26 `Task` objects, using the
    letters between A and Z as IDs. Then, you used some methods to obtain data from
    the map. The `firstEntry()` method returns a `Map.Entry` object with the first
    element of the map. This method doesn't remove the element from the map. The object
    contains the key and the element. To obtain the element, you called the `getValue()`
    method. You can use the `getKey()` method to obtain the key of that element.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
- en: The `lastEntry()` method returns a `Map.Entry` object with the last element
    of the map. The `subMap()` method returns the `ConcurrentNavigableMap` object
    with part of the elements of the map, in this case, the elements that had keys
    between `A1996` and `B1002`. You used the `pollFirst()` method to process the
    elements of the `subMap()` method. This method returns and removes the first `Map.Entry`
    object of the submap.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shows the output of an execution of the program:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00046.jpeg)'
  id: totrans-310
  prefs: []
  type: TYPE_IMG
- en: There's more...
  id: totrans-311
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `ConcurrentSkipListMap` class has other interesting methods. Some of them
    are as follows:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
- en: '`headMap(K toKey)`: Here, `K` is the class of the key values used in the parameterization
    of the `ConcurrentSkipListMap` object. This method returns a submap of the first
    elements of the map with the elements that have a key smaller than the one passed
    as a parameter.'
  id: totrans-313
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`tailMap(K fromKey)`: Here, `K` is the class of the key values used in the
    parameterization of the `ConcurrentSkipListMap` object. This method returns a
    submap of the last elements of the map with the elements that have a key greater
    than the one passed as a parameter.'
  id: totrans-314
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`putIfAbsent(K key, V Value)`: This method inserts the value specified as a
    parameter and also the key specified as a parameter if it doesn''t exist in the
    map.'
  id: totrans-315
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`pollLastEntry()`: This method returns and removes a `Map.Entry` object with
    the last element of the map.'
  id: totrans-316
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`replace(K key, V Value)`: This method replaces the value associated with the
    key specified as a parameter if this key exists in the map.'
  id: totrans-317
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: See also
  id: totrans-318
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The *Using non-blocking thread-safe deques* recipe in this chapter
  id: totrans-319
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using thread-safe HashMaps
  id: totrans-320
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A hash table is a data structure that allows you to map a key to a value. Internally,
    it usually uses an array to store the elements and a hash function to calculate
    the position of the element in the array, using its key. The main advantage of
    this data structure is that the insert, delete, and search operations are very
    fast here, so it's very useful in situations when you have to carry out a lot
    of search operations.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
- en: 'The Java API provides different hash table implementations through the `Map`
    and `ConcurrentMap` interfaces. The `ConcurrentMap` interface provides thread-safety
    and atomic guarantees to all the operations, so you can use them in concurrent
    applications. The `ConcurrentHashMap` class implements the `ConcurrentMap` interface
    and adds some more methods to the ones defined in the interface. This class supports
    the following:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
- en: Full concurrency of read operations
  id: totrans-323
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: High expected concurrency for insert and delete operations
  id: totrans-324
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Both the elements (class and interface) were introduced in Java version 5, but
    in version 8, a lot of new methods similar to the ones provided by the stream
    API were developed.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, you will learn how to use the `ConcurrentHashMap` class in your
    application and the most important methods it provides.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-327
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The example of this recipe has been implemented using the Eclipse IDE. If you
    use Eclipse or a different IDE, such as NetBeans, open it and create a new Java
    project.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-329
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Follow these steps to implement the example:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a class named `Operation` with three attributes: a `String` attribute
    named `user`, a `String` attribute named `operation`, and a `Date` attribute named
    `time`. Add the methods to get and set the values of the attributes. The code
    of this class is very simple, so it won''t be included here.'
  id: totrans-331
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a class named `HashFiller`. Specify that it implements the `Runnable`
    interface:'
  id: totrans-332
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE81]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'Declare a private `ConsurrentHashMap` attribute named `userHash`. The key of
    the hash will be a `String` type and its value will be a `ConcurrentLinkedDeque`
    object of `Operation` objects. Implement the constructor of the class to initialize
    the attribute:'
  id: totrans-334
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE82]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'Implement the `run()` method. We''re going to fill `ConcurrentHashMap` with
    100 random `Operation` objects. First, generate random data and then use the `addOperationToHash()`
    method to insert the object in the hash:'
  id: totrans-336
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE83]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'Implement the `addOperationToHash()` method. It receives the hash and the operation
    you want to add as parameters. The key in the map will be the user assigned to
    the operation. We use the `computeIfAbsent()` method to obtain the `ConcurrentLinkedDeque`
    object associated with the key. If the key exists, this method returns the value
    associated with it. If it doesn''t, it executes the lambda expression passed as
    a parameter to this method to generate the value and associate it with the key.
    In this case, we generate a new `ConcurrentLinkedDeque` object. Finally, insert
    the operation to the deque:'
  id: totrans-338
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE84]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'Now implement the `Main` class and include the `main()` method. First, declare
    a `ConcurrentHashMap` object and a `HashFiller` task:'
  id: totrans-340
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE85]'
  id: totrans-341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'Execute 10 threads with the `HashFiller` class and wait for their finalization
    using the `join()` method:'
  id: totrans-342
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE86]'
  id: totrans-343
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'Now, extract the information of `ConcurrentHashMap`. First, extract the number
    of elements stored in it with the `size()` method. Then, use the `forEach()` method
    to apply an action to all the elements stored in the hash. The first parameter
    is the parallelism threshold. This is the minimum number of elements required
    to make the operation execute in a concurrent way. We have specified the value
    10 and the hash has 100 elements, so the operation will be executed in a parallel
    way. The lambda expression receives two parameters: key and value. Print the key
    and size of `ConcurrentLinkedDeque` stored as a value:'
  id: totrans-344
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE87]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'Then, use the `forEachEntry()` method. This is similar to the previous one,
    but the lambda expression receives an `Entry` object as a parameter instead of
    receiving two parameters. You can use this entry object to obtain the key and
    value:'
  id: totrans-346
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE88]'
  id: totrans-347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'Then, use the `search()` method to find the first element that satisfies the
    search function specified. In our case, we search for an operation whose operation
    code ends in 1\. As occurs with the `forEach()` method, we specify a parallelism
    threshold:'
  id: totrans-348
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE89]'
  id: totrans-349
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'Use the `search()` method again, but this time, use it to find a user with
    more than 10 operations:'
  id: totrans-350
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE90]'
  id: totrans-351
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'Finally, use the `reduce()` method to calculate the total number of operations
    stored in the hash:'
  id: totrans-352
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE91]'
  id: totrans-353
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: How it works...
  id: totrans-354
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we implemented an application that uses `ConcurrentHashMap`
    to store information about operations made by users. Internally, the hash table
    uses the user attribute of the `Operation` class as a key and `ConcurrentLinkedDeque`
    (a non-blocking concurrent list) as its value to store all the operations associated
    with that user.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
- en: First, we filled the hash with some random data using 10 different threads.
    We implemented the `HashFiller` task for this purpose. The biggest problem with
    these tasks is what happens when you have to insert a key in the hash table. If
    two threads want to add the same key at the same time, you can lose the data inserted
    by one of the threads and have a data-race condition. To solve this problem, we
    used the `computeIfAbsent()` method.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
- en: This method receives a key and an implementation of the `Function` interface
    that can be expressed as a lambda expression; the key and implementation are received
    as parameters. If the key exists, the method returns the value associated with
    the key. If it doesn't, the method executes the `Function` object specified and
    adds the key and value returned by `Function` to the HashMap. In our case, the
    key didn't exist, so we created a new instance of the `ConcurrentLinkedDeque`
    class. The main advantage of this method is that it's executed atomically; so,
    if another thread tries to do the same operation, it will be blocked until this
    operation is finished.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, in the `main()` method, we used other methods of `ConcurrentHashMap`
    to process the information stored in the hash. We used the following methods:'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
- en: '`forEach()`: This method receives an implementation of the `BiConsumer` interface
    that can be expressed as a lambda expression; it is received as a parameter. The
    other two parameters of this expression represent the key and value of the element
    we''re processing. This method applies the expression to all the elements stored
    in `ConcurrentHashMap`.'
  id: totrans-359
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`forEachEntry()`: This method is equivalent to the previous one, but here the
    expression is an implementation of the `Consumer` interface. It receives an `Entry`
    object that stores the key and value of the entry we''re processing as a parameter.
    This is another way to express the same functionality.'
  id: totrans-360
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`search()`: This method receives the implementation of the `BiFunction` interface
    that can be expressed as a lambda expression; it is received as a parameter. This
    function also receives the key and value of the entry of the `ConcurrentHashMap`
    object we''re processing as parameters. It returns the first non-null value returned
    by `BiFunction`.'
  id: totrans-361
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`reduce()`: This method receives two `BiFunction` interfaces to reduce the
    elements of `ConcurrentHashMap` to a unique value. This allows you to implement
    a `MapReduce` operation with the elements of `ConcurrentHashMap`. The first `BiFunction`
    interface allows you to transform the key and value of the elements into a unique
    value, and the second `BiFunction` interface allows you to aggregate the values
    of two different elements.'
  id: totrans-362
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All the methods described so far have a first parameter named `parallelismThreshold`.
    This parameter is described as *...the (estimated) number of elements needed for
    this operation to be executed in parallel...,* that is to say, if `ConcurrentHashMap`
    has fewer elements than the value specified in the parameter, the method is executed
    in a sequential way. On the contrary (as in our case), the method is executed
    in a parallel way.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  id: totrans-364
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`ConcurrentHashMap` has more methods than what''s specified in the previous
    section. We enumerate some of them in the following list:'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
- en: '`forEachKey()` and `forEachValue()`: These methods are similar to the `forEach()`
    methods, but in this case, the expression processes the keys and values stored
    in `ConcurrentHashMap`, respectively.'
  id: totrans-366
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`searchEntries()`, `searchKeys()`, and `searchValues()`: These methods are
    similar to the `search()` method explained before. However, in this case, the
    expression passed as a parameter receives an `Entry` object, a key, or a value
    of the elements stored in `ConcurrentHashMap`.'
  id: totrans-367
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`reduceEntries()`, `reduceKeys()`, and `reduceValues()`: These methods are
    similar to the `reduce()` method explained before. However, in this case, the
    expression passed as a parameter receives an `Entry` object, a key, or a value
    of the elements stored in `ConcurrentHashMap`.'
  id: totrans-368
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`reduceXXXToDouble()`, `reduceXXXToLong()`, and `reduceXXXToInt()`: These methods
    allow you to make a reduction of the elements of `ConcurrentHashMap` by generating
    a `double`, `long`, or `int` value, respectively.'
  id: totrans-369
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`computeIfPresent()`: This method complements the `computeIfAbsent()` method.
    In this case, it receives a key and an implementation of the `BiFunction` interface
    that can be expressed as a lambda expression. If the key exists in the `HashMap`,
    the method applies the expression to calculate the new value of the key. The `BiFunction`
    interface receives the key and the actual value of that key as parameters, and
    it returns the new value.'
  id: totrans-370
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`merge()`: This method receives a key, value, and implementation of the `BiFunction`
    interface that can be expressed as a lambda expression; they are received as parameters.
    If the key doesn''t exist in `ConcurrentHashMap`, it inserts it there and associates
    the value parameter with it. If it exists, execute `BiFunction` to calculate the
    new value associated with the key. The `BiFunction` interface receives the key
    and its actual value as parameters and returns the new value associated with the
    key.'
  id: totrans-371
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`getOrDefault()`: This method receives a key and a default value as parameters.
    If the key exists in `ConcurrentHashMap`, it returns its associated value. Otherwise,
    it returns the default value.'
  id: totrans-372
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: See also
  id: totrans-373
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The *Using thread-safe navigable maps *recipe in this chapter
  id: totrans-374
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Reducing the elements of a stream* recipe in [Chapter 6](part0249.html#7DES20-69b77957c9a14e36a0bec5f5a1363736),
    *Parallel and Reactive Streams*
  id: totrans-375
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using atomic variables
  id: totrans-376
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Atomic variables** were introduced in Java version 5 to provide atomic operations
    on single variables. When you work with a normal variable, each operation that
    you implement in Java is transformed into several instructions of Java byte code
    that is understandable by the JVM when you compile the program. For example, when
    you assign a value to a variable, you only use one instruction in Java; however,
    when you compile this program, it is transformed into various instructions in
    the JVM language. This can lead to data inconsistency errors when you work with
    multiple threads that share a variable.'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
- en: 'To avoid these problems, Java introduced atomic variables. When a thread is
    doing an operation with an atomic variable and if other threads want to do an
    operation with the same variable, the implementation of the class includes a mechanism
    to check that the operation is done atomically. Basically, the operation gets
    the value of the variable, changes the value to a local variable, and then tries
    to change the old value with the new one. If the old value is still the same,
    it is substituted; if not, the method begins the operation again. This operation
    is called **Compare and Set**. It implements the modification of the value of
    a variable in the following three steps:'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
- en: You get the value of the variable, which is the old value of the variable.
  id: totrans-379
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You change the value of the variable in a temporal variable, which is the new
    value of the variable.
  id: totrans-380
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You substitute the old value with the new value if the old value is equal to
    the actual value of the variable. The old value may be different from the actual
    value if another thread changes the value of the variable.
  id: totrans-381
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Some of these variables, for example, the `LongAccumulator` class, receive an
    operation as a parameter that could be executed inside some of its methods. These
    operations must be free from any side effects, as they might be executed multiple
    times in every value update.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
- en: Atomic variables don't use locks or other synchronization mechanisms to protect
    access to their values. All their operations are based on Compare and Set. It's
    guaranteed that several threads can work with an atomic variable at a time without
    generating data inconsistency errors; plus, they simplify the implementation.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
- en: 'Java 8 has added four new atomic classes. First we have the `LongAdder` and
    `DoubleAdder` classes; they store `long` and `double` values that are updated
    frequently by different threads. You can obtain the same functionality as that
    of the `LongAdder` class with the `AtomicLong` class, but the former provides
    better performance. The other two classes are `LongAccumulator` and `DoubleAccumulator`.
    These classes are similar to the previous one, but here, you have to specify two
    parameters in the constructor:'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
- en: The initial value of the counter.
  id: totrans-385
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A `LongBinaryOperator` or `DoubleBinaryOperator` that can be indicated as a
    lambda expression. This expression receives the old value of the variable and
    the increment you want to apply and returns the new value of the variable.
  id: totrans-386
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In this recipe, you will learn how to use atomic variables implementing a bank
    account and two different tasks: one that adds money to the account and one that
    subtracts money from it. You will use the `AtomicLong` class in the implementation
    of the example.'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-388
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The example of this recipe has been implemented using the Eclipse IDE. If you
    are using Eclipse or a different IDE, such as NetBeans, open it and create a new
    Java project.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-390
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Follow these steps to implement the example:'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a class named `Account` to simulate a bank account:'
  id: totrans-392
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE92]'
  id: totrans-393
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'Declare a private `AtomicLong` attribute named `balance` to store the balance
    of the account. In addition, declare a private `LongAdder` attribute named operations
    and a private `DoubleAccumulator` attribute named commission:'
  id: totrans-394
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE93]'
  id: totrans-395
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: 'Implement the constructor of the class to initialize its attributes. For the
    `DoubleAccumulator` class, the identity value is `0` and we update the actual
    value with the result of multiply `0.2` to the increment passed as parameter:'
  id: totrans-396
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE94]'
  id: totrans-397
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: 'Implement the method to get the value of the three attributes:'
  id: totrans-398
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE95]'
  id: totrans-399
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 'Implement a method named `setBalance()` to establish the value of the balance
    attribute. We also have to initialize the operations and commission attributes
    using the `reset()` method:'
  id: totrans-400
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE96]'
  id: totrans-401
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: 'Implement a method named `addAmount()` to increment the value of the `balance`
    attribute. In addition, use the `increment()` method of the `LongAdder` class
    to increment the value of the `operations` attribute and the `accumulate()` method
    by one unit to add 20 percent of the amount value to the `commission` object:'
  id: totrans-402
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE97]'
  id: totrans-403
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: 'Implement a method named `substractAmount()` to decrement the value of the
    `balance` attribute. As it occurs with the `addAmount()` method, we modify the
    values of the `operations` and `commission` attributes:'
  id: totrans-404
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE98]'
  id: totrans-405
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: 'Create a class named `Company` and specify that it implements the `Runnable`
    interface. This class will simulate the payments made by a company:'
  id: totrans-406
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE99]'
  id: totrans-407
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: 'Declare a private `Account` attribute named `account`:'
  id: totrans-408
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE100]'
  id: totrans-409
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: 'Implement the constructor of the class to initialize its attribute:'
  id: totrans-410
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE101]'
  id: totrans-411
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: 'Implement the `run()` method of the task. Use the `addAmount()` method of the
    account to make 10 increments of 1,000 each in its balance:'
  id: totrans-412
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE102]'
  id: totrans-413
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: 'Create a class named `Bank` and specify that it implements the `Runnable` interface.
    This class will simulate the withdrawal of money from the account:'
  id: totrans-414
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE103]'
  id: totrans-415
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: 'Declare a private `Account` attribute named `account`:'
  id: totrans-416
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE104]'
  id: totrans-417
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: 'Implement the constructor of the class to initialize its attribute:'
  id: totrans-418
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE105]'
  id: totrans-419
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: 'Implement the `run()` method of the task. Use the `subtractAmount()` method
    of the account to make 10 decrements of 1,000 each from its balance:'
  id: totrans-420
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE106]'
  id: totrans-421
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: 'Implement the main class of the example by creating a class named `Main` and
    adding the `main()` method to it:'
  id: totrans-422
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE107]'
  id: totrans-423
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: 'Create an `Account` object and set its balance to `1000`:'
  id: totrans-424
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE108]'
  id: totrans-425
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: 'Create a new `Company` task and a thread to execute it:'
  id: totrans-426
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE109]'
  id: totrans-427
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: 'Create a new `Bank` task and a thread to execute it:'
  id: totrans-428
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE110]'
  id: totrans-429
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: 'Write the initial balance of the account in the console:'
  id: totrans-430
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE111]'
  id: totrans-431
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: 'Start the threads:'
  id: totrans-432
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE112]'
  id: totrans-433
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: 'Wait for the finalization of the threads using the `join()` method and write
    the final balance in the console, the number of operations, and the accumulated
    commission of the account:'
  id: totrans-434
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE113]'
  id: totrans-435
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: How it works...
  id: totrans-436
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The key to this example is in the `Account` class. In this class, we declared
    an `AtomicLong` variable named `balance` to store the balance of the account,
    a `LongAdder` variable named `operations` to store the number of operations we
    made with the account, and a `DoubleAccumulator` variable named `commission` to
    store the value of the commissions of the operations. In the constructor of the
    `commission` object, we specified that the value will be incremented with the
    expression `0.2*y`. With this, we wanted to specify that we will increment the
    actual value of the variable with the result of its multiplication by `0.2` and
    the value of the parameter we pass to the `accumulate()` method.
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
- en: To implement the `getBalance()` method that returns the value of the `balance`
    attribute, we used the `get()` method of the `AtomicLong` class. To implement
    the `getOperations()` method that returns a `long` value with the number of operations,
    we used the `longValue()` method. To implement the `getCommission()` method, we
    used the `get()` method of the `DoubleAccumulator` class. To implement the `setBalance()`
    method that establishes the value of the balance attribute, we used the `set()`
    method of the `AtomicLong` class.
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
- en: To implement the `addAmount()` method that adds an import to the balance of
    the account, we used the `getAndAdd()` method of the `AtomicLong` class that returns
    the value and increments it by the value specified as a parameter. We also used
    the `increment()` method of the `LongAdder` class that increments the value of
    the variable by one and the `accumulate()` method of the `DoubleAccumulator` class
    to increment the value of the `commission` attribute following the specified expression.
    Take into account that the `addAmount()` method is not atomic as a whole although
    it calls three atomic operations.
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
- en: Finally, to implement the `subtractAmount()` method that decrements the value
    of the `balance` attribute, we used the `getAndAdd()` method. We also included
    calls to the `increment()` and `accumulate()` methods of the `LongAdder` and `DoubleAccumulator`
    classes.
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, we implemented two different tasks:'
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
- en: The `Company` class simulates a company that increments the balance of the account.
    Each task of this class makes 10 increments of 1,000 each.
  id: totrans-442
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `Bank` class simulates a bank where the proprietary of the bank account
    takes out its money. Each task of this class makes 10 decrements of 1,000 each.
  id: totrans-443
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the `Main` class, you created an `Account` object with a balance of 1,000\.
    Then, you executed a bank task and a company task so the final balance of the
    account is the same as the initial one.
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
- en: 'When you execute the program, you will see how the final balance is the same
    as the initial one. The following screenshot shows the output of an execution
    of this example:'
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00047.jpeg)'
  id: totrans-446
  prefs: []
  type: TYPE_IMG
- en: There's more...
  id: totrans-447
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As mentioned in the introduction, there are other atomic classes in Java. `AtomicBoolean`,
    `AtomicInteger`, and `AtomicReference` are other examples of atomic classes.
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
- en: 'The `LongAdder` class provides other interesting methods as follows:'
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
- en: '`add()`: To increment the value of the internal counter by the value specified
    as a parameter'
  id: totrans-450
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`decrement()`: To decrement the internal counter by one'
  id: totrans-451
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`reset()`: To return the internal value to zero'
  id: totrans-452
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can also use the `DoubleAdder` class that is similar to `LongAdder`, but
    it doesn't have the `increment()` and `decrement()` methods and the internal counter
    is a `double` value.
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
- en: You can also use the `LongAccumulator` class that is similar to `DoubleAccumulator`
    but with an internal `long` counter.
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
- en: See also
  id: totrans-455
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The *Synchronizing a method* recipe in [Chapter 2](part0081.html#2D7TI0-69b77957c9a14e36a0bec5f5a1363736),
    *Basic Thread Synchronization*
  id: totrans-456
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using atomic arrays
  id: totrans-457
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Consider that you need to implement a concurrent application that has one or
    more objects shared by several threads. In such a scenario, you have to protect
    access to their attributes using a synchronization mechanism, such as locks or
    the `synchronized` keyword, to avoid data inconsistency errors.
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
- en: 'These mechanisms have the following problems:'
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
- en: 'Deadlock: This situation occurs when a thread is blocked waiting for a lock
    that is locked by other threads that will never free it. This situation blocks
    the program, so it will never finish.'
  id: totrans-460
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If only one thread is accessing the shared object, it has to execute the code
    necessary to get and release the lock.
  id: totrans-461
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To provide better performance in this situation, the **compare-and-swap operation**
    was developed. This operation implements the modification of the value of a variable
    in the following three steps:'
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
- en: You get the value of the variable, which is the old value of the variable.
  id: totrans-463
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You change the value of the variable in a temporal variable, which is the new
    value of the variable.
  id: totrans-464
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You substitute the old value with the new value if the old value is equal to
    the actual value of the variable. The old value may be different from the actual
    value if another thread has changed it.
  id: totrans-465
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: With this mechanism, you don't need to use a synchronization mechanism, so you
    avoid deadlocks and you obtain better performance. This mechanism also has its
    drawbacks. Operations must be free from any side effects as they might be retried
    using livelocks with highly contended resources; they are also harder to monitor
    for performance when compared with standard locks.
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
- en: Java implements this mechanism in **atomic variables**. These variables provide
    the `compareAndSet()` method, which is an implementation of the compare-and-swap
    operation and other methods based on it.
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
- en: Java also introduced **atomic arrays** that provide atomic operations for arrays
    of `integer` or `long` numbers. In this recipe, you will learn how to use the
    `AtomicIntegerArray` class to work with atomic arrays. Take into account that
    if you use `AtomicInteger[]`, it's not a thread-safe object. The individual `AtomicInteger`
    objects are thread-safe, but the array as a data structure is not.
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-469
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The example of this recipe has been implemented using the Eclipse IDE. If you
    use Eclipse or a different IDE, such as NetBeans, open it and create a new Java
    project.
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-471
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Follow these steps to implement the example:'
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a class named `Incrementer` and specify that it implements the `Runnable`
    interface:'
  id: totrans-473
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE114]'
  id: totrans-474
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: 'Declare a private `AtomicIntegerArray` attribute named `vector` to store an
    array of `integer` numbers:'
  id: totrans-475
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE115]'
  id: totrans-476
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: 'Implement the constructor of the class to initialize its attribute:'
  id: totrans-477
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE116]'
  id: totrans-478
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: 'Implement the `run()` method. Increment all the elements of the array using
    the `getAndIncrement()` method:'
  id: totrans-479
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE117]'
  id: totrans-480
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: 'Create a class named `Decrementer` and specify that it implements the `Runnable`
    interface:'
  id: totrans-481
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE118]'
  id: totrans-482
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: 'Declare a private `AtomicIntegerArray` attribute named `vector` to store an
    array of `integer` numbers:'
  id: totrans-483
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE119]'
  id: totrans-484
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: 'Implement the constructor of the class to initialize its attribute:'
  id: totrans-485
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE120]'
  id: totrans-486
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: 'Implement the `run()` method. Decrement all the elements of the array using
    the `getAndDecrement()` method:'
  id: totrans-487
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE121]'
  id: totrans-488
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: 'Implement the main class of the example by creating a class named `Main` and
    adding the `main()` method to it:'
  id: totrans-489
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE122]'
  id: totrans-490
  prefs: []
  type: TYPE_PRE
  zh: '[PRE122]'
- en: 'Declare a constant named `THREADS` and assign the value `100` to it. Create
    an `AtomicIntegerArray` object with 1,000 elements:'
  id: totrans-491
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE123]'
  id: totrans-492
  prefs: []
  type: TYPE_PRE
  zh: '[PRE123]'
- en: 'Create an `Incrementer` task to work with the atomic array created earlier:'
  id: totrans-493
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE124]'
  id: totrans-494
  prefs: []
  type: TYPE_PRE
  zh: '[PRE124]'
- en: 'Create a `Decrementer` task to work with the atomic array created earlier:'
  id: totrans-495
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE125]'
  id: totrans-496
  prefs: []
  type: TYPE_PRE
  zh: '[PRE125]'
- en: 'Create two arrays to store 100 `Thread` objects:'
  id: totrans-497
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE126]'
  id: totrans-498
  prefs: []
  type: TYPE_PRE
  zh: '[PRE126]'
- en: 'Create and launch 100 threads to execute the `Incrementer` task and another
    100 threads to execute the `Decrementer` task. Store the threads in the arrays
    created earlier:'
  id: totrans-499
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE127]'
  id: totrans-500
  prefs: []
  type: TYPE_PRE
  zh: '[PRE127]'
- en: 'Wait for the finalization of the threads using the `join()` method:'
  id: totrans-501
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE128]'
  id: totrans-502
  prefs: []
  type: TYPE_PRE
  zh: '[PRE128]'
- en: '[PRE129]'
  id: totrans-503
  prefs: []
  type: TYPE_PRE
  zh: '[PRE129]'
- en: 'In the console, write the elements of the atomic array distinct from zero.
    Use the `get()` method to obtain the elements of the atomic array:'
  id: totrans-504
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE130]'
  id: totrans-505
  prefs: []
  type: TYPE_PRE
  zh: '[PRE130]'
- en: 'Write a message in the console indicating the finalization of the example:'
  id: totrans-506
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE131]'
  id: totrans-507
  prefs: []
  type: TYPE_PRE
  zh: '[PRE131]'
- en: How it works...
  id: totrans-508
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this example, you implemented two different tasks to work with an `AtomicIntegerArray`
    object:'
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
- en: '`Incrementer`: This class increments all the elements of the array using the
    `getAndIncrement()` method'
  id: totrans-510
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Decrementer`: This class decrements all the elements of the array using the
    `getAndDecrement()` method'
  id: totrans-511
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the `Main` class, you created `AtomicIntegerArray` with 1,000 elements, then
    you executed 100 incrementer and 100 decrementer tasks. At the end of these tasks,
    if there were no inconsistency errors, all the elements of the array must have
    the value `0`. If you execute the program, you will see how the program only writes
    the final message to the console because all the elements are zero.
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  id: totrans-513
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Nowadays, Java provides another atomic array class. It's called the `AtomicLongArray`
    class and it provides the same methods as the `IntegerAtomicArray` class.
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
- en: 'Other interesting methods provided by these classes are:'
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
- en: '`get(int i)`: Returns the value of the array position specified by the parameter'
  id: totrans-516
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`set(int I, int newValue)`: Establishes the value of the array position specified
    by the parameter.'
  id: totrans-517
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: See also
  id: totrans-518
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The *Using atomic variables* recipe in this chapter
  id: totrans-519
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the volatile keyword
  id: totrans-520
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Almost every application reads and writes data to the main memory of the computer.
    For performance reasons, these operations aren't performed directly in the memory.
    CPUs have a system of cache memory, so applications write data in the cache and
    then the data is moved from the cache to the main memory.
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
- en: In multithread applications, concurrent threads run in different CPUs or cores
    inside a CPU. When a thread modifies a variable stored in the memory, the modification
    is made in the cache or the CPU or core where it's running. However, there's no
    guarantee about when that modification would reach the main memory. If another
    thread wants to read the value of the data, it's possible that it would not read
    the modified value because it's not in the main memory of the computer.
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
- en: To solve this problem (there are other solutions, such as the `synchronized`
    keyword), the Java language includes the `volatile` keyword. It's a modifier that
    allows you to specify that a variable must always be read from and stored in the
    main memory, not the cache of your CPU. You should use the volatile keyword when
    it's important that other threads have visibility of the actual value of the variable;
    however, order of access to that variable is not important. In this scenario,
    the `volatile` keyword will give you better performance because it doesn't need
    to get any monitor or lock to access the variable. On the contrary, if the order
    of access to the variable is important, you must use another synchronization mechanism.
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, you will learn how to use the volatile keyword and the effects
    of its use.
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-525
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The example of this recipe has been implemented using the Eclipse IDE. If you
    use Eclipse or a different IDE, such as NetBeans, open it and create a new Java
    project.
  id: totrans-526
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-527
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Follow these steps to implement the example:'
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a class named `Flag` with a public `Boolean` attribute named `flag`
    initialized to the `true` value:'
  id: totrans-529
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE132]'
  id: totrans-530
  prefs: []
  type: TYPE_PRE
  zh: '[PRE132]'
- en: 'Create a class named `VolatileFlag` with a public Boolean attribute named `flag`
    initialized to the `true` value. We add the `volatile` modifier to the declaration
    of this attribute:'
  id: totrans-531
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE133]'
  id: totrans-532
  prefs: []
  type: TYPE_PRE
  zh: '[PRE133]'
- en: 'Create a class named `Task` and specify that it implements the `Runnable` interface.
    It has a private `Flag` attribute and a constructor to initialize it:'
  id: totrans-533
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE134]'
  id: totrans-534
  prefs: []
  type: TYPE_PRE
  zh: '[PRE134]'
- en: 'Implement the `run()` method of this task. It will increment an `int` variable
    when the value of the `flag` attribute is `true`. Then, write the final value
    of the variable:'
  id: totrans-535
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE135]'
  id: totrans-536
  prefs: []
  type: TYPE_PRE
  zh: '[PRE135]'
- en: '[PRE136]'
  id: totrans-537
  prefs: []
  type: TYPE_PRE
  zh: '[PRE136]'
- en: 'Create a class named `VolatileTask` and specify that it implements the `Runnable`
    interface. It has a private `VolatileFlag` attribute and a constructor to initialize
    it:'
  id: totrans-538
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE137]'
  id: totrans-539
  prefs: []
  type: TYPE_PRE
  zh: '[PRE137]'
- en: 'Implement the `run()` method of this task. It''s equal to the one in the `Task`
    class, so it won''t be included here:'
  id: totrans-540
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Implement the `Main` class with the `main()` method. First, create four objects
    of the `VolatileFlag`, `Flag`, `VolatileTask`, and `Task` classes:'
  id: totrans-541
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE138]'
  id: totrans-542
  prefs: []
  type: TYPE_PRE
  zh: '[PRE138]'
- en: 'Then, create two threads to execute the tasks, start them, and sleep the main
    thread for a second:'
  id: totrans-543
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE139]'
  id: totrans-544
  prefs: []
  type: TYPE_PRE
  zh: '[PRE139]'
- en: 'Then, change the value of the `volatileFlag` variable to stop the execution
    of `volatileTask` and sleep the main thread for a second:'
  id: totrans-545
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE140]'
  id: totrans-546
  prefs: []
  type: TYPE_PRE
  zh: '[PRE140]'
- en: 'Finally, change the value of the `task` object to stop the execution of the
    task and sleep the main thread for a second:'
  id: totrans-547
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE141]'
  id: totrans-548
  prefs: []
  type: TYPE_PRE
  zh: '[PRE141]'
- en: How it works...
  id: totrans-549
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following screenshot shows the output of the example:'
  id: totrans-550
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00048.jpeg)'
  id: totrans-551
  prefs: []
  type: TYPE_IMG
- en: The application doesn't finish its execution because the `task` thread has not
    finished. When we change the value of `volatileFlag`-as its `flag` attribute is
    marked as `volatile`--the new value is written in the main memory and `VolatileTask`
    accesses the value immediately and finishes its execution. On the contrary, when
    you change the value of the `flag` object--as its `flag` attribute is not marked
    as volatile-the new value is stored in the cache of the main thread and the task
    object doesn't see the new value and never ends its execution. The `volatile`
    keyword is important not only because it requires that the writes are flushed,
    but also because it ensures that reads are not cached and they fetch the up-to-date
    value from the main memory. It's very important and very often neglected.
  id: totrans-552
  prefs: []
  type: TYPE_NORMAL
- en: Take into account that the `volatile` keyword guarantees that modifications
    are written in the main memory, but its contrary is not always true. For example,
    if you work with a non-volatile integer value shared by more than one thread and
    make a lot of modifications, you may be able to see the modifications made by
    other threads because they were written in the main memory. However, there's no
    guarantee that these changes were passed from the cache to the main memory.
  id: totrans-553
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  id: totrans-554
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `volatile` keyword only works well when the value of the shared variable
    is only modified by one thread. If the variable is modified by multiple threads,
    the `volatile` keyword doesn't protect you from possible data-race conditions.
    It also doesn't make operations, such as `+` or `-`, atomic. For example, the
    `++` operator over a volatile variable is not thread-safe.
  id: totrans-555
  prefs: []
  type: TYPE_NORMAL
- en: 'Since Java 5, **Java Memory Model** has a happens--before guarantee established
    with the `volatile` keyword. This fact has two implications:'
  id: totrans-556
  prefs: []
  type: TYPE_NORMAL
- en: When you modify a volatile variable, its value is sent to the main memory. The
    value of all the variables modified previously by the same thread are sent too.
  id: totrans-557
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Compilers can't reorder sentences that modify a volatile variable for an optimization
    purpose. It can reorder the previous operations and the later ones, but not the
    modifications of a volatile variable. The changes that happen before these modifications
    will be visible to those instructions.
  id: totrans-558
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: See also
  id: totrans-559
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The *Using atomic variables* and *Using atomic arrays* recipe in this chapter
  id: totrans-560
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using variable handles
  id: totrans-561
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Variable handles are a new feature of Java 9 that allow you to get a typed reference
    to a variable (attribute, static field, or array element) in order to access it
    in different modes. You can, for example, protect access to this variable in a
    concurrent application by allowing atomic access to the variable. Until now, you
    could only obtain this behavior with atomic variables, but now, you can use variable
    handles to obtain the same functionality without using any synchronization mechanism.
    A variable handle also allows you to get additional access modes to a variable.
  id: totrans-562
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, you will learn how to obtain and use a variable handle and the
    benefits you obtain using it.
  id: totrans-563
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-564
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The example of this recipe has been implemented using the Eclipse IDE. If you
    use Eclipse or a different IDE, such as NetBeans, open it and create a new Java
    project.
  id: totrans-565
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-566
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Follow these steps to implement the example:'
  id: totrans-567
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a class named `Account` with two double public attributes named `amount`
    and `unsafeAmount`. Implement the constructor to initialize its values:'
  id: totrans-568
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE142]'
  id: totrans-569
  prefs: []
  type: TYPE_PRE
  zh: '[PRE142]'
- en: 'Create a class named `Decrementer` and specify that it implements the `Runnable`
    interface. It has a private `Account` attribute initialized in the constructor
    of the class:'
  id: totrans-570
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE143]'
  id: totrans-571
  prefs: []
  type: TYPE_PRE
  zh: '[PRE143]'
- en: 'Implement the `run()` method. This method will make 10,000 decrement operations
    in the `amount` and `unsafeAmount` attributes. To modify the value of the amount
    attribute, use `VarHandle`. Obtain it using the `lookup()` method of the `MethodHandles`
    class, then use the `getAndAdd()` method to modify the value of the attribute.
    To modify the `unsafeAmount` attribute, use the `=` operator:'
  id: totrans-572
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE144]'
  id: totrans-573
  prefs: []
  type: TYPE_PRE
  zh: '[PRE144]'
- en: Implement a class named `Incrementer`. This will be equivalent to the `Drementer`
    class, but it will increase the value of the account. The source code of this
    class won't be included here.
  id: totrans-574
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Finally, implement the `Main` class with the `main()` method. First, create
    an `account` object:'
  id: totrans-575
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE145]'
  id: totrans-576
  prefs: []
  type: TYPE_PRE
  zh: '[PRE145]'
- en: 'Then, create a thread to execute an `Incrementer` task and a thread to execute
    a `Decrementer` task. Start them and wait for their finalization using the `join()`
    method:'
  id: totrans-577
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE146]'
  id: totrans-578
  prefs: []
  type: TYPE_PRE
  zh: '[PRE146]'
- en: 'Finally, write the value of the amount and `unsafeAmount` attributes in the
    console:'
  id: totrans-579
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE147]'
  id: totrans-580
  prefs: []
  type: TYPE_PRE
  zh: '[PRE147]'
- en: How it works...
  id: totrans-581
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following screenshot shows the output of an execution of the application:'
  id: totrans-582
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00049.jpeg)'
  id: totrans-583
  prefs: []
  type: TYPE_IMG
- en: As you make the same number of increment and decrement operations, the expected
    result in both cases is `0`. We obtain this result with the amount attribute because
    as we access it using the `VarHandle`, we guarantee atomic access to its modifications.
    On the other hand, the `unsafeAmount` doesn't have the expected value. Access
    to this value is not protected and we have a data-race condition.
  id: totrans-584
  prefs: []
  type: TYPE_NORMAL
- en: To use a variable handle, first we have to obtain it using the `lookup()` method
    of the `MethodHandles` class, followed by the `in()` method and then the `findVarHandle()`
    method. The `lookup()` method returns a `Lookup` object, the `in()` method returns
    a `Lookup` object of the specified class—in our case, the `Account` class—and
    `findVarHandle()` generates `VarHandle` for the attribute we want to access.
  id: totrans-585
  prefs: []
  type: TYPE_NORMAL
- en: Once we have the `VarHandle` object, we can use different methods to use different
    access modes. In this example, we used the `getAndAdd()` method. This method guarantees
    atomic access to increment the value of the attribute. We pass to them the object
    we want to access and the value of the increment.
  id: totrans-586
  prefs: []
  type: TYPE_NORMAL
- en: The next section provides more information about the different access modes
    and the methods you can use in each case.
  id: totrans-587
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  id: totrans-588
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You have four different access types to a variable with a variable handle:'
  id: totrans-589
  prefs: []
  type: TYPE_NORMAL
- en: '**Read mode**: This is used to get read mode access to a variable. You can
    use the following methods:'
  id: totrans-590
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`get()`: Read the value of the variable as if it was declared non-volatile'
  id: totrans-591
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`getVolatile()`: Read the value of the variable as if it was declared volatile'
  id: totrans-592
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`getAcquire()`: Read the value of the variable and guarantee that the following
    instructions that modify or access this variable are not reordered before the
    instructions for optimization purposes'
  id: totrans-593
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`getOpaque()`: Read the value of variable and guarantee that the instructions
    of the current thread are not reordered; no guarantee is provided for other threads'
  id: totrans-594
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Write mode**: This is used to get write access mode to a variable. You can
    use the `set()`, `setVolatile()`, `setRelease()`, and `setOpaque()` methods. They
    are equivalent to the previous ones but with write access.'
  id: totrans-595
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Atomic access mode**: This is used to get a functionality that is similar
    to the one provided by the atomic variables with operations to, for example, compare
    and get the value of the variable. You can use the following methods:'
  id: totrans-596
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`compareAndSet()`: Change the value of the variable as it was declared as a
    volatile variable if the expected value passed as parameter is equal to the current
    value of the variable'
  id: totrans-597
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`weakCompareAndSet()` and `weakCompareAndSetVolatile()`: Possibly atomically''
    changes the value of the variable as it was declared as non-volatile or volatile
    variables respectively if the expected value passed as parameter is equals to
    the current value of the variable'
  id: totrans-598
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Numerical update access mode**: This is to modify numerical values in an
    atomic way.'
  id: totrans-599
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: See also
  id: totrans-600
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The *Using atomic variables* and *Using atomic arrays* recipe in this chapter
  id: totrans-601
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
