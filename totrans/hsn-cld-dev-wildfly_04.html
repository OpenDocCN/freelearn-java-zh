<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Tuning the Configuration of Your Services</h1>
                </header>
            
            <article>
                
<p class="western"><span><span>In this chapter, you will learn how to configure your Swarm services. We will show you practical examples of different configuration tools that are available and how you can use them to steer the behavior of your applications.</span></span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Modifying Swarm configuration</h1>
                </header>
            
            <article>
                
<p>The fractions available in Swarm come with reasonable defaults. In the examples that we have seen so far, we didn't touch any configuration and yet we were able to see the applications working. Now, we will show you how you can tune the configuration of Swarm-created services.</p>
<p>Swarm provides a set of tools that allows you to modify the configuration of your applications. In the following section, we will introduce them one by one and show their usage in different scenarios. Let's start with the simplest one: system properties.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">System properties</h1>
                </header>
            
            <article>
                
<p>You are able to modify the configuration by specifying system properties. Let's return to our <span class="packt_screen">catalog-service</span>. As you saw in the <span class="packt_screen">catalog-service</span> examples from the last chapter, the JAX-RS application was listening for HTTP requests on port 8080, which is the default configuration. Let's suppose that we want to change that port.</p>
<p>What we have to do is specify the <kbd>swarm.http.port</kbd> property during the application execution, as follows:</p>
<pre>mvn clean wildfly-swarm:run -Dswarm.http.port=12345</pre>
<p>When running the web browser, we can see that, indeed, the port on which the application runs has been changed:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/6f977254-4fb7-47db-9127-8c3f3a389086.png"/></div>
<p>What has just happened here then? The undertow fraction has discovered that there is a configuration property that overrides the standard HTTP port, and it modifies the socket's configuration accordingly. As a result, the running application is using the specified port.</p>
<p>Each fraction contains a group of properties that can be used to configure it. You will be able to find them in Swarm documentation.</p>
<p>The method of editing the properties is very simple and can be sufficient in many cases, but the entry point to the more complex programmatic configurations may be more feasible let's learn how to do it.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Implementing your own main class</h1>
                </header>
            
            <article>
                
<p>Each Swarm service contains the <kbd>main</kbd> class which is responsible for creating and configuring a runtime for the service and running service code on it. Swarm creates the default implementation of the <kbd>main</kbd> class (in fact, the default class was used in all the examples till now), but you are able to provide your own implementation of the <kbd>Main</kbd> class if you want to modify the default behavior. An example of such modification may be providing an additional configuration.</p>
<p class="mce-root">Let's return to the <span class="packt_screen">catalog-service</span>. Let's recall its current operation: we created a <kbd>jaxrs</kbd> resource and injected the service providing the invitation message using CDI. Now, let's modify this example to provide our own <kbd>main</kbd> class.</p>
<div class="packt_infobox">Examples reference: <kbd>chapter4/catalog-service-first-main</kbd></div>
<p class="mce-root">In order to do it, we have to modify the <kbd>pom.xml</kbd> of the <span class="packt_screen">catalog-service</span> in the following way:</p>
<pre><span>(...)<br/></span><span><br/></span><span>    &lt;dependencies&gt;<br/><strong>        &lt;!-- 2 --&gt;</strong><br/></span><strong>        &lt;dependency&gt;<br/>            &lt;groupId&gt;org.wildfly.swarm&lt;/groupId&gt;<br/>            &lt;artifactId&gt;jaxrs&lt;/artifactId&gt;<br/>            &lt;version&gt;${version.wildfly.swarm}&lt;/version&gt;<br/>        &lt;/dependency&gt;<br/>        &lt;dependency&gt;<br/>            &lt;groupId&gt;org.wildfly.swarm&lt;/groupId&gt;<br/>            &lt;artifactId&gt;cdi&lt;/artifactId&gt;<br/>            &lt;version&gt;${version.wildfly.swarm}&lt;/version&gt;<br/></strong><span><strong>        &lt;/dependency&gt;</strong><br/></span><span>    &lt;/dependencies&gt;<br/></span><span><br/></span><span>    &lt;build&gt;<br/></span><span>        &lt;plugins&gt;<br/></span><span>            &lt;plugin&gt;<br/></span><span>                &lt;artifactId&gt;</span>maven-war-plugin<span>&lt;/artifactId&gt;<br/></span><span>                &lt;version&gt;</span>${version.war.plugin}<span>&lt;/version&gt;<br/></span><span>                &lt;configuration&gt;<br/></span><span>                    &lt;failOnMissingWebXml&gt;</span>false<span>&lt;/failOnMissingWebXml&gt;<br/></span><span>                &lt;/configuration&gt;<br/></span><span>            &lt;/plugin&gt;<br/></span><span>            &lt;plugin&gt;<br/></span><span>                &lt;groupId&gt;</span>org.wildfly.swarm<span>&lt;/groupId&gt;<br/></span><span>                &lt;artifactId&gt;</span>wildfly-swarm-plugin<span>&lt;/artifactId&gt;<br/></span><span>                &lt;version&gt;</span>${version.wildfly.swarm}<span>&lt;/version&gt;<br/><strong>                &lt;!-- 1 --&gt;</strong><br/></span><strong>                &lt;configuration&gt;<br/>                    &lt;mainClass&gt;org.packt.swarm.petstore.catalog.Main&lt;/mainClass&gt;<br/></strong><span><strong>                &lt;/configuration&gt;</strong><br/></span><span>                &lt;executions&gt;<br/></span><span>                    &lt;execution&gt;<br/></span><span>                        &lt;phase&gt;</span>package<span>&lt;/phase&gt;<br/></span><span>                        &lt;goals&gt;<br/></span><span>                            &lt;goal&gt;</span>package<span>&lt;/goal&gt;<br/></span><span>                        &lt;/goals&gt;<br/></span><span>                    &lt;/execution&gt;<br/></span><span>                &lt;/executions&gt;<br/></span><span>            &lt;/plugin&gt;<br/></span><span>        &lt;/plugins&gt;<br/></span><span>    &lt;/build&gt;<br/></span><span><br/></span><span>&lt;/project&gt;</span></pre>
<p>We have to modify the Swarm plugin so that its configuration contains the class with our <kbd>main</kbd> method (1). When using your own <kbd>main</kbd> method, you have to specify manually on which fractions your service depends (2). </p>
<p>Now, let's take a look at the <kbd>org.packt.swarm.petstore.Main</kbd> class, which implements the <kbd>main</kbd> method:</p>
<pre><span>package </span>org.packt.swarm.petstore.catalog<span>;<br/></span><span><br/></span><span>import </span>org.jboss.logging.Logger<span>;<br/></span><span>import </span>org.wildfly.swarm.Swarm<span>;<br/></span><span><br/></span><span>public class </span>Main {<br/><br/>    <span>public static void </span><span>main</span>(String[] args) <span>throws </span>Exception {<br/><strong>        //1<br/>        new Swarm().start().deploy();<br/>        //2<br/>        Logger.getLogger(Main.class).info("I'M HERE!")</strong><span><strong>;</strong><br/></span><span>    </span>}<br/>}</pre>
<p>We created the instance of the <kbd>org.wildfly.swarm.Swarm</kbd> class (1). The <kbd>start</kbd> method has created the container, and the <kbd>deploy</kbd> method has deployed the created archive on it. We have also created (2) the log output to prove that the class is indeed working. We will look at the <kbd>Swarm</kbd> class in greater detail in just a moment, but before that here is the mentioned proof:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/13651764-af24-43ea-8d63-93743ab53505.png"/></div>
<p>The message is there, and the method has been executed.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The Swarm class</h1>
                </header>
            
            <article>
                
<p>As we have seen in the preceding section, if you are implementing your own <kbd>main</kbd> method, you will interact with the <kbd>org.wildfly.swarm.Swarm</kbd> class. This class is responsible for instantiating the container based on the provided configuration and creating and deploying the archive with your application. Both of those steps can be modified by operations on the <kbd>Swarm</kbd> class. Let's learn more about them.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Providing the configuration</h1>
                </header>
            
            <article>
                
<p>The <kbd>Swarm</kbd> class provides a group of methods that allow you to modify the configuration using the Java API, such as <kbd>fraction</kbd>, <kbd>socketBinding</kbd>, and <kbd>outboundSocketBinding</kbd>. The latter two methods, as their names imply, allow you to create your own socket binding and outbound socket binding groups. The method that is the most interesting to us is the <kbd>fraction</kbd> method. It takes one argument for the <kbd>org.wildfly.swarm.spi.api.Fraction</kbd> class implementations—the <kbd>fraction</kbd>. You will be able to modify and reconfigure all the fractions and provide them to Swarm. Let's get a first grasp of this functionality on our favorite example, that is, changing the HTTP port of the <kbd>CatalogService</kbd>. </p>
<div class="packt_infobox">Examples reference: <kbd>chapter4/catalog-service-config-main</kbd></div>
<p>Firstly, we have to add the <kbd>UndertowFraction</kbd> dependency to our <kbd>pom.xml</kbd>:</p>
<pre><span>(...)<br/></span><span><br/></span><span>    &lt;dependencies&gt;<br/></span><span>        &lt;dependency&gt;<br/></span><span>            &lt;groupId&gt;</span>org.jboss.spec.javax.ws.rs<span>&lt;/groupId&gt;<br/></span><span>            &lt;artifactId&gt;</span>jboss-jaxrs-api_2.0_spec<span>&lt;/artifactId&gt;<br/></span><span>            &lt;scope&gt;</span>provided<span>&lt;/scope&gt;<br/></span><span>        &lt;/dependency&gt;<br/></span><span>        &lt;dependency&gt;<br/></span><span>            &lt;groupId&gt;</span>javax.enterprise<span>&lt;/groupId&gt;<br/></span><span>            &lt;artifactId&gt;</span>cdi-api<span>&lt;/artifactId&gt;<br/></span><span>            &lt;scope&gt;</span>provided<span>&lt;/scope&gt;<br/></span><span>        &lt;/dependency&gt;<br/></span><span>        &lt;dependency&gt;<br/></span><span>            &lt;groupId&gt;</span>org.wildfly.swarm<span>&lt;/groupId&gt;<br/></span><span>            &lt;artifactId&gt;</span>jaxrs<span>&lt;/artifactId&gt;<br/></span><span>            &lt;version&gt;</span>${version.wildfly.swarm}<span>&lt;/version&gt;<br/></span><span>        &lt;/dependency&gt;<br/></span><span>        &lt;dependency&gt;<br/></span><span>            &lt;groupId&gt;</span>org.wildfly.swarm<span>&lt;/groupId&gt;<br/></span><span>            &lt;artifactId&gt;</span>cdi<span>&lt;/artifactId&gt;<br/></span><span>            &lt;version&gt;</span>${version.wildfly.swarm}<span>&lt;/version&gt;<br/></span><span>        &lt;/dependency&gt;<br/></span><strong>        &lt;!-- 1 --&gt;<br/>        &lt;dependency&gt;<br/>            &lt;groupId&gt;org.wildfly.swarm&lt;/groupId&gt;<br/>            &lt;artifactId&gt;undertow&lt;/artifactId&gt;<br/>            &lt;version&gt;${version.wildfly.swarm}&lt;/version&gt;<br/></strong><span><strong>        &lt;/dependency&gt;</strong><br/></span><span>        &lt;dependency&gt;<br/></span><span>            &lt;groupId&gt;</span>org.jboss.logging<span>&lt;/groupId&gt;<br/></span><span>            &lt;artifactId&gt;</span>jboss-logging<span>&lt;/artifactId&gt;<br/></span><span>            &lt;version&gt;</span>3.3.0.Final<span>&lt;/version&gt;<br/></span><span>            &lt;scope&gt;</span>provided<span>&lt;/scope&gt;<br/></span><span>        &lt;/dependency&gt;<br/></span><span><br/></span><span>    &lt;/dependencies&gt;<br/></span><span><br/></span><span>(...)</span></pre>
<p>Secondly, let's reimplement the <kbd>main</kbd> method:</p>
<pre><span>package </span>org.packt.swarm.petstore.catalog<span>;<br/></span><span><br/></span><span>import </span>org.wildfly.swarm.Swarm<span>;<br/></span><span>import </span>org.wildfly.swarm.undertow.UndertowFraction<span>;<br/></span><span><br/></span><span>public class </span>Main {<br/><br/>    <span>public static void </span><span>main</span>(String[] args) <span>throws </span>Exception {<br/><strong>        //1<br/>        UndertowFraction undertowFraction = new UndertowFraction();<br/>        //2<br/>        undertowFraction.applyDefaults();<br/>        //3<br/>        undertowFraction.httpPort(12345);<br/>        //4<br/>        Swarm swarm = new Swarm();<br/>        //5<br/>        swarm.fraction(undertowFraction);<br/>        //6<br/>        swarm.start().deploy()</strong><span><strong>;</strong><br/></span><span>    </span>}<br/>}</pre>
<p>If you run the preceding code, you will indeed see the same result as in the property example: the application is running on the <kbd>12345</kbd> port. So, what has just happened?</p>
<p>At the beginning of the preceding code, we created the <kbd>UndertowFraction</kbd> (1)  and run the <kbd>applyDefaults</kbd> method (2). If the <kbd>fraction</kbd> is automatically created by Swarm, the default configuration is applied to it. On the other hand, if you create the <kbd>fraction</kbd> manually, you are creating the empty <kbd>fraction</kbd> object with no configuration. That's what the <kbd>applyDefaults</kbd><em> </em>method is for. It applies the default configuration to the <kbd>fraction</kbd> object. As a result, whenever you don't want to create the configuration from scratch and just modify it, you have to invoke the <kbd>applyDefaults</kbd><em> </em>method first and apply your configuration changes after that. That's exactly the scenario in our simple example. We didn't want to create the full configuration manually. Instead, we only wanted to change the one configuration parameter—the listening port. As a result, we applied the default configuration to the <kbd>fraction</kbd> object, and after that, we only changed the HTTP port.</p>
<p>We created the <kbd>UndertowFraction</kbd> object that represents the configuration of the Undertow fraction. We have to provide this configuration to the container that will run the service. In order to do it, we used Swarm's <kbd>fraction</kbd> method (4). It is worth mentioning here that the application still consists of many <kbd>fraction</kbd>s but we have provided only the <kbd>Undertowfraction</kbd> configuration. If we don't add a customized <kbd>fraction</kbd> configuration to the <kbd>Swarm</kbd> class, then the default configuration is used. Swarm is still going to bootstrap CDI and JAX-RS among others, but their configuration will be created automatically, just as it was in our first example. On the other hand, the <kbd>Undertowconfiguration</kbd> object is provided by us manually and Swarm will use it. </p>
<p>After the application is configured, we are ready to start and deploy (5) it, just as we did in the previous example. If we run our application, we will see the same result that we obtained in the example that used the system property—the application runs on port <kbd>12345</kbd>.</p>
<p>However, in the property example, we have to add<span> only</span> one configuration parameter, and, here, we have to do quite a lot of stuff. You may ask whether you can use the Java API to provide a more elaborate configuration but still resort to the properties in cases such as an HTTP port; that's a good question. Let's find out.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Using your own main along with properties</h1>
                </header>
            
            <article>
                
<p>Let's modify the <kbd>Main</kbd> class to the simplest possible form:</p>
<pre><span>package </span>org.packt.swarm.petstore<span>;<br/></span><span><br/></span><span>import </span>org.jboss.logging.Logger<span>;<br/></span><span>import </span>org.wildfly.swarm.Swarm<span>;<br/></span><span><br/></span><span>public class </span>Main {<br/><br/>    <span>public static void </span><span>main</span>(String[] args) <span>throws </span>Exception {<br/>        new Swarm().start().deploy();<span><br/></span><span>    </span>}<br/>}</pre>
<p>Then, run it with the HTTP port property: </p>
<pre>mvn clean wildfly-swarm:run -Dswarm.http.port=12345</pre>
<p>Also, we will check in in the browser:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/3b021482-ea66-41f4-8e21-6820b71ea03a.png" style=""/></div>
<p><span>Well, it didn</span>'t work. So, as it just turned out, you are not able to do it, sorry.</p>
<p>I am kidding, of course. You can do it, but as it turned out, we have, completely accidentally, made a small mistake in our code from the last listing. What is wrong with it? The system properties with which the <kbd>main</kbd> method was executed were not propagated to Swarm in any way. Consider that, on the other hand, we have written our code in the following way:</p>
<pre>package org.packt.swarm.petstore;<br/><br/>import org.jboss.logging.Logger;<br/>import org.wildfly.swarm.Swarm;<br/><br/>public class Main {<br/><br/> public static void main(String[] args) throws Exception {<br/> <strong>//1</strong><br/> <strong>new Swarm(args)</strong>.start().deploy();<br/> Logger.getLogger(Main.class).info("I'M HERE!");<br/> }<br/>}</pre>
<p>The application will use specified properties and present the application behavior we will be able to see that it is working correctly.</p>
<p>To sum up, you are now able to mix the Java API with a properties-based configuration, but you have to remember to create Swarm with <kbd>main</kbd> function arguments.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Java API</h1>
                </header>
            
            <article>
                
<p>Let's return to the <kbd>Swarm</kbd> class. We have already seen that we are able to create the fraction class with our own configuration and hand it on to the <kbd>Swarm</kbd> class. In fact, we are able to steer the whole Swarm configuration programmatically. To create a more elaborate example, let's extend our <kbd>CatalogService</kbd> so that it stores its data in a database.</p>
<div class="packt_infobox">Examples reference: <kbd>chapter4/catalog-service-database</kbd>.</div>
<p>Let's start with editing the <kbd>pom.xml</kbd>:</p>
<pre><span>(...)<br/><br/></span><span>    &lt;properties&gt;<br/></span><span>        (...)<br/></span><strong>        &lt;version.hibernate.api&gt;1.0.0.Final&lt;/version.hibernate.api&gt;<br/>        &lt;version.h2&gt;1.4.187</strong><span><strong>&lt;/version.h2&gt;</strong><br/></span><span>    &lt;/properties&gt;<br/></span><span><br/></span><span>    (...)<br/></span><span><br/></span><span>    &lt;dependencies&gt;<br/></span><span>        (...)</span><span><br/></span><span>        &lt;dependency&gt;<br/></span><span>            &lt;groupId&gt;</span>org.wildfly.swarm<span>&lt;/groupId&gt;<br/></span><span>            &lt;artifactId&gt;</span>cdi<span>&lt;/artifactId&gt;<br/></span><span>            &lt;version&gt;</span>${version.wildfly.swarm}<span>&lt;/version&gt;<br/></span><span>        &lt;/dependency&gt;<br/><strong>        //1</strong><br/></span><strong>        &lt;dependency&gt;<br/>            &lt;groupId&gt;org.wildfly.swarm&lt;/groupId&gt;<br/>            &lt;artifactId&gt;datasources&lt;/artifactId&gt;<br/>            &lt;version&gt;${version.wildfly.swarm}&lt;/version&gt;<br/>        &lt;/dependency&gt;<br/>        //2<br/>        &lt;dependency&gt;<br/>            &lt;groupId&gt;org.wildfly.swarm&lt;/groupId&gt;<br/>            &lt;artifactId&gt;jpa&lt;/artifactId&gt;<br/>            &lt;version&gt;${version.wildfly.swarm}&lt;/version&gt;<br/>        &lt;/dependency&gt;<br/>        //3<br/>        &lt;dependency&gt;<br/>            &lt;groupId&gt;org.hibernate.javax.persistence&lt;/groupId&gt;<br/>            &lt;artifactId&gt;hibernate-jpa-2.1-api&lt;/artifactId&gt;<br/>            &lt;version&gt;${version.hibernate.api}&lt;/version&gt;<br/>        &lt;/dependency&gt;<br/>        //4<br/>        &lt;dependency&gt;<br/>            &lt;groupId&gt;com.h2database&lt;/groupId&gt;<br/>            &lt;artifactId&gt;h2&lt;/artifactId&gt;<br/>            &lt;version&gt;${version.h2}&lt;/version&gt;<br/>        &lt;/dependency&gt;<br/></strong><span><br/></span><span>    &lt;/dependencies&gt;<br/></span><span><br/></span><span>   (...)<br/></span><span><br/></span><span>&lt;/project&gt;</span></pre>
<p>We have added four new Maven dependencies. In order to configure our own <kbd>datasource</kbd>, we have to add the <kbd>datasource</kbd>s fraction (1). As we will use the Java Persistence API, we will need both the <kbd>jpa</kbd> fraction and the JPA API (2). We will also use <kbd>h2</kbd> in-memory database, and we need its <kbd>dependency</kbd> too (3). Finally, we provide the <kbd>dependency</kbd> to <kbd>h2</kbd> database (4).</p>
<p>As we are going to persist the data about pets available in the store, we have to modify the <kbd>Item</kbd> class so that it is an entity, a JPA object representing a state that will be persisted in the relational database:</p>
<pre><span>package </span>org.packt.swarm.petstore.catalog.model<span>;<br/></span><span><br/></span><span>import </span>com.fasterxml.jackson.annotation.<span>JsonIgnore</span><span>;<br/></span><span><br/></span><span>import </span>javax.persistence.<span>Column</span><span>;<br/></span><span>import </span>javax.persistence.<span>Entity</span><span>;<br/></span><span>import </span>javax.persistence.<span>Id</span><span>;<br/></span><span>import </span>javax.persistence.<span>NamedQueries</span><span>;<br/></span><span>import </span>javax.persistence.<span>NamedQuery</span><span>;<br/></span><span>import </span>javax.persistence.<span>Table</span><span>;<br/></span><span><br/></span><strong>//1<br/>@Entity<br/>//2<br/>@Table(name = "item")</strong><br/><strong>//3<br/>@NamedQueries({</strong><br/><strong>        @NamedQuery(name="Item.findById",<br/>                query="SELECT i FROM Item i WHERE i.itemId = :itemId"),<br/>})</strong><br/><span>public class </span>Item {<br/><br/><strong>    //4<br/>    @Id<br/>    @JsonIgnore<br/>    private int id;<br/><br/>    //5<br/>    @Column(length = 30)</strong><br/><strong>    private String itemId;<br/><br/>    //6<br/>    @Column(length = 30)</strong><br/><strong>    private String name</strong><span><strong>;</strong><br/></span><span>    </span><span>@Column<br/></span><span>    </span><span>private int </span><span>quantity</span><span>;<br/></span><span><br/></span><span>    </span><span>@Column<br/></span><span>    </span><span>private </span>String <span>description</span><span>;<br/></span><span><br/></span><span>    public </span>String <span>getItemId</span>() {<br/>        <span>return </span><span>itemId</span><span>;<br/></span><span>    </span>}<br/><br/>    <span>public void </span><span>setItemId</span>(String itemId) {<br/>        <span>this</span>.<span>itemId </span>= itemId<span>;<br/></span><span>    </span>}<br/><br/>    <span>public </span>String <span>getName</span>() {<br/>        <span>return </span><span>name</span><span>;<br/></span><span>    </span>}<br/><br/>    <span>public void </span><span>setName</span>(String name) {<br/>        <span>this</span>.<span>name </span>= name<span>;<br/></span><span>    </span>}<br/><br/>    <span>public int </span><span>getQuantity</span>() {<br/>        <span>return </span><span>quantity</span><span>;<br/></span><span>    </span>}<br/><br/>    <span>public void </span><span>setQuantity</span>(<span>int </span>quantity) {<br/>        <span>this</span>.<span>quantity </span>= quantity<span>;<br/></span><span>    </span>}<br/><br/>    <span>public </span>String <span>getDescription</span>() {<br/>        <span>return </span><span>description</span><span>;<br/></span><span>    </span>}<br/><br/>    <span>public void </span><span>setDescription</span>(String description) {<br/>        <span>this</span>.<span>description </span>= description<span>;<br/></span><span>    </span>}<br/>}</pre>
<p>This is a simple <kbd>jpa</kbd> entity (1) with the corresponding table named <kbd>"ITEM"</kbd> (2). We have created the <kbd>NamedQuery</kbd> (3) to find pets by <kbd>name</kbd>. We have added the database ID field (4). Furthermore, we have added the <kbd>@Column</kbd> annotations so that <kbd>name</kbd> and <kbd>quantity</kbd> fields are persisted to the database (5).</p>
<p>We would also need to modify our <kbd>CatalogService</kbd> class so that it can load pet data from the database:</p>
<pre><span>package </span>org.packt.swarm.petstore.catalog<span>;<br/></span><span><br/></span><span>import </span>org.packt.swarm.petstore.catalog.model.Item<span>;<br/></span><span><br/></span><span>import </span>javax.enterprise.context.<span>ApplicationScoped</span><span>;<br/></span><span>import </span>javax.persistence.EntityManager<span>;<br/></span><span>import </span>javax.persistence.<span>PersistenceContext</span><span>;<br/></span><span><br/></span><span><br/></span><span>@ApplicationScoped<br/></span><span>public class </span><span>CatalogService</span> {<br/><br/><strong>    //1</strong><br/><strong>    @PersistenceContext(unitName = "CatalogPU")</strong><br/><strong>    private EntityManager em</strong><span><strong>;</strong><br/></span><span><br/><strong>    //2</strong><br/></span></pre>
<pre><strong>    public Item searchById(String itemId) {</strong><br/><strong>        return em.createNamedQuery("Item.findById", Item.class).setParameter("itemId", itemId).getSingleResult();</strong><span><br/>&gt;</span><span>    </span>}<br/><br/>}</pre>
<p>We referenced the <kbd>CatalogPU</kbd><em> </em>persistence context (we will configure it in a moment) and used a named query defined in an <kbd>Item</kbd> class to find pets by <kbd>id</kbd> (2).</p>
<p>OK, let's move to the interesting part. We will create and use in-memory <kbd>h2</kbd> <kbd>datasource</kbd>; The following is the code to do so:</p>
<pre><span>package </span>org.packt.swarm.petstore.catalog<span>;<br/></span><span><br/></span><span>import </span>org.wildfly.swarm.Swarm<span>;<br/></span><span>import </span>org.wildfly.swarm.datasources.DatasourcesFraction<span>;<br/></span><span><br/></span><span>public class </span>Main {<br/><br/>    <span>public static void </span><span>main</span>(String[] args) <span>throws </span>Exception {<br/>        DatasourcesFraction datasourcesFraction = <span>new </span>DatasourcesFraction()<br/><strong>                //1<br/>                .jdbcDriver("h2", (d) -&gt; {</strong><br/><strong>                    d.driverClassName("org.h2.Driver");<br/>                    d.xaDatasourceClass("org.h2.jdbcx.JdbcDataSource");<br/>                    d.driverModuleName("com.h2database.h2");<br/>                })<br/></strong><strong>                //2<br/>                .dataSource("CatalogDS", (ds) -&gt; {</strong><br/><strong>                    ds.driverName("h2");<br/>                    ds.connectionUrl("jdbc:h2:mem:test;DB_CLOSE_DELAY=-1;DB_CLOSE_ON_EXIT=FALSE");<br/>                    ds.userName("sa");<br/>                    ds.password("sa");<br/>                })</strong><span><strong>;</strong><br/></span><span><br/></span><span>        </span>Swarm swarm = <span>new </span>Swarm()<span>;<br/></span><span>        </span>swarm.fraction(datasourcesFraction)<span>;<br/></span><span>        </span>swarm.start().deploy()<span>;<br/></span><span>    </span>}<br/>}</pre>
<p>The configuration of the <kbd>datasourcesFraction</kbd> is a bit more complex than the simple port change—let's look at it in greater detail. In (1), we defined the <strong>Java Database Connectivity</strong> (<strong>JDBC</strong>) driver named <kbd>"h2"</kbd> and provided lambda expression implementing the <kbd>org.wildfly.swarm.config.JDBCDriverConsumer</kbd> class—this is basically the acceptor that allows you to apply the additional configuration to the created JDBC driver. The analogous situation happens in (2). Here, we created the <span><kbd>CatalogDS</kbd> </span>datasource and applied an additional configuration using the <kbd>org.wildfly.swarm.config.DatasourcesConsumer</kbd> class.</p>
<p>As you can see in the preceding code, this configuration is not as trivial as the <kbd>Undertowport</kbd> change, but don't worry. Swarm comes with the current Java API library with each release, and as all the configuration options are described there, you don't have to rely on guesswork while configuring your application using this method [<span>1</span>].</p>
<p>We still have to do more things to make our example work, such as provide <kbd>persistence.xml</kbd> and fill our database with a group of messages on startup.</p>
<p>Let's start with the first thing. The following is our <kbd>persistence.xml</kbd> file:</p>
<pre><span>&lt;?</span><span>xml version=</span><span>"1.0" </span><span>encoding=</span><span>"UTF-8"</span><span>?&gt;<br/></span><span>&lt;persistence<br/></span><span>        </span><span>xmlns:</span><span>xsi</span><span>=</span><span>"http://www.w3.org/2001/XMLSchema-instance"<br/></span><span>        </span><span>version=</span><span>"2.1"<br/></span><span>        </span><span>xmlns=</span><span>"http://xmlns.jcp.org/xml/ns/persistence"<br/></span><span>        </span><span>xsi</span><span>:schemaLocation=</span><span>"http://xmlns.jcp.org/xml/ns/persistence http://xmlns.jcp.org/xml/ns/persistence/persistence_2_1.xsd"</span><span>&gt;<br/></span><strong>    &lt;!-- 1 --&gt;<br/>    &lt;persistence-unit name="CatalogPU" transaction-type="JTA"&gt;<br/>        &lt;!-- 2 --&gt;<br/>        &lt;jta-data-source&gt;java:jboss/datasources/CatalogDS&lt;/jta-data-source&gt;<br/>        &lt;properties&gt;<br/>            &lt;!-- 3 --&gt;<br/>            &lt;property name="javax.persistence.schema-generation.database.action" value="drop-and-create"/&gt;<br/>            &lt;property name="javax.persistence.schema-generation.create-source" value="metadata"/&gt;<br/>            &lt;property name="javax.persistence.schema-generation.drop-source" value="metadata"/&gt;<br/>            &lt;!-- 4 --&gt;<br/>            &lt;property name="javax.persistence.sql-load-script-source" value="META-INF/load.sql"</strong><span><strong>/&gt;</strong><br/></span><span>        &lt;/properties&gt;<br/></span><span>    &lt;/persistence-unit&gt;<br/></span><span>&lt;/persistence&gt;</span></pre>
<p>In the preceding configuration, we created the persistent-unit named <kbd>CatalogPU</kbd>, which uses <kbd>JTA</kbd> transactions (1), made the persistent-unit use the <kbd>CatalogDS</kbd> datasource created earlier (2), provided a configuration that will make the database create the new database on the deployment and delete it on undeployment using entity classes metadata (3), and, finally, provided the load script (4).</p>
<p>The problem is that we don't have it yet; let's add it then:</p>
<pre><span>INSERT INTO </span>ITEM(id, itemId, name, description, quantity) <span>VALUES </span>(<span>1</span>, <span>'turtle'</span>, <span>'turtle'</span>,  <span>'Slow friendly reptile. Let your busy self see how it spends a hundred years of his life laying on sand and swimming.'</span>, <span>5</span>);<br/><span>INSERT INTO </span>ITEM(id, itemId, name, description, quantity) <span>VALUES </span>(<span>2</span>, <span>'hamster'</span>, <span>'hamster'</span>, <span>'Energetic rodent - great as a first pet. Will be your only inmate that takes his fitness training serviously.'</span>, <span>10</span>);<br/><span>INSERT INTO </span>ITEM(id, itemId, name, description, quantity) <span>VALUES </span>(<span>3</span>, <span>'goldfish'</span>, <span>'goldfish'</span>, <span>'With its beauty it will be the decoration of you aquarium. Likes gourmet fish feed and postmodern poetry.'</span>, <span>3</span>);<br/><span>INSERT INTO </span>ITEM(id, itemId, name, description, quantity) <span>VALUES </span>(<span>4</span>, <span>'lion'</span>, <span>'lion'</span>, <span>'Big cat with fancy mane. Loves playing the tag and cuddling with other animals and people.'</span>, <span>9</span>);</pre>
<p>After all that is finally done, we should be able to see our application working. Let's try it now:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/648bbecc-8f5c-49dd-a3df-6bbe60bcc966.png"/></div>
<p>Oops! Instead of the browser page with a message, an awful red log appears. What went wrong? Let's take a look at the first read message: <kbd>"WFLYJCA0041: Failed to load module for driver [com.h2database.h2]"</kbd>. True, as this is a custom driver module, we have to add it to our application manually. How are we able to do that? That is simple too.</p>
<p>To add an additional custom module to our application, we have to add it to the <kbd>resources</kbd> directory of our application:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/b8972de7-bbec-4945-92dc-149c1ccd599e.jpg"/></div>
<p>As shown in the preceding screenshot, the <kbd>modules</kbd> directory has to be placed inside the Maven's <kbd>resources</kbd> directory inside our application, and the directory structure has to match the module name. Let's look at the module descriptor:</p>
<pre><span>&lt;?</span><span>xml version</span><span>="1.0" </span><span>encoding</span><span>="UTF-8"</span><span>?&gt;<br/></span><strong>&lt;!-- 1 --&gt;<br/>&lt;module  name="com.h2database.h2"</strong><span><strong>&gt;</strong><br/></span><span><br/></span><span>  &lt;resources&gt;<br/></span><span>    </span><strong>&lt;!-- 2 --&gt;<br/>    &lt;artifact name="com.h2database:h2:1.4.187"</strong><span><strong>/&gt;</strong><br/></span><span>  &lt;/resources&gt;<br/></span><span>  </span><strong>&lt;!-- 3 --&gt;<br/>  &lt;dependencies&gt;<br/>    &lt;module name="javax.api"/&gt;<br/>    &lt;module name="javax.transaction.api"/&gt;<br/>    &lt;module name="javax.servlet.api" optional="true"/&gt;<br/></strong><span><strong>  &lt;/dependencies&gt;</strong><br/></span><span>&lt;/module&gt;<br/></span></pre>
<p>To recall, this is the same kind of descriptor that we presented in <a href="c00cfc93-f395-446e-9132-242f02216783.xhtml">Chapter 2</a>, <em>Getting Familiar with WildFly Swarm</em>, where we described the concept of modular classloading. In the preceding file, we are creating a module with the <kbd>"com.h2database.h2"</kbd> name (1), specifying that the only resource is the <kbd>h2</kbd> database artifact. Note that we are referencing the artifact using Maven coordinates. Finally, we have to specify all the module dependencies (3).</p>
<p>Let's build and run the application again. We are indeed able to look up our pets now:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/62112f99-add2-46fd-a8aa-b14e34aaf609.png" style=""/></div>
<p>We are indeed, able to search pets by <kbd>id</kbd> now.</p>
<p>Let's continue with the <kbd>Swarm</kbd> class usage. The next thing that we will look at is its <kbd>deploy</kbd> method.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Modifying your archive</h1>
                </header>
            
            <article>
                
<p>In our previous examples, each time we created the <kbd>Swarm</kbd> instance and applied some configuration on top of it, we used the no-argument <kbd>deploy</kbd> method. This method takes the archive generated by the standard Maven build and deploys it on the previously configured container. This is not the only version of the <kbd>deploy</kbd> method, though. You are able to create your own archive (or archives) and deploy them to the Swarm container. How? It is possible using the <kbd>ShrinkWrap</kbd> API.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The ShrinkWrap API</h1>
                </header>
            
            <article>
                
<p>If you have ever worked with WildFly AS, and, especially, its testing framework Arquillian, you are probably also familiar with the <kbd>ShrinkWrap</kbd> API, which is used to build application archives before they are deployed in the test environment. However, if you have never used it, don't worry—the API is very simple and straightforward.</p>
<p>The central class in the API is the <kbd>org.jboss.shrinkwrap.api.Archive</kbd><em> </em>instance. It is an abstract class that represents the archive. The concrete implementations that interest us the most are <kbd>org.jboss.shrinkwrap.api.spec.JavaArchive</kbd> and <kbd>org.jboss.shrinkwrap.api.spec.WebArchive</kbd> that represent JARs and WARs as you probably have guessed. The API is simple; it contains a bunch of methods that allow you to add resources to the archive. Let's see its operation in practice.</p>
<p>For the sake of this example, let's return to the first <kbd>CatalogService</kbd> version, which contained only the <kbd>jaxrs</kbd> resource and application.</p>
<div class="packt_infobox">Examples reference: <kbd>chapter4/catalog-service-shrinkwrap</kbd></div>
<p>To see the <kbd>ShrinkWrap</kbd> in action, we have to modify the <kbd>pom.xml</kbd><em> </em>file:</p>
<pre><span>(...)<br/></span><span><br/></span><span>    &lt;dependencies&gt;<br/></span><span>        &lt;dependency&gt;<br/></span><span>            &lt;groupId&gt;</span>org.jboss.spec.javax.ws.rs<span>&lt;/groupId&gt;<br/></span><span>            &lt;artifactId&gt;</span>jboss-jaxrs-api_2.0_spec<span>&lt;/artifactId&gt;<br/></span><span>            &lt;scope&gt;</span>provided<span>&lt;/scope&gt;<br/></span><span>        &lt;/dependency&gt;<br/></span><strong>        &lt;!-- 1 --&gt;<br/>        &lt;dependency&gt;<br/>            &lt;groupId&gt;org.wildfly.swarm&lt;/groupId&gt;<br/>            &lt;artifactId&gt;jaxrs&lt;/artifactId&gt;<br/>            &lt;version&gt;${version.wildfly.swarm}&lt;/version&gt;<br/></strong><span><strong>        &lt;/dependency&gt;</strong><br/></span><span>    &lt;/dependencies&gt;<br/></span><span><br/></span><span>    &lt;build&gt;<br/></span><span>        &lt;plugins&gt;<br/></span><span>            &lt;plugin&gt;<br/></span><span>                &lt;artifactId&gt;</span>maven-war-plugin<span>&lt;/artifactId&gt;<br/></span><span>                &lt;version&gt;</span>${version.war.plugin}<span>&lt;/version&gt;<br/></span><span>                &lt;configuration&gt;<br/></span><span>                    &lt;failOnMissingWebXml&gt;</span>false<span>&lt;/failOnMissingWebXml&gt;<br/></span><span>                &lt;/configuration&gt;<br/></span><span>            &lt;/plugin&gt;</span><span><br/></span><span>            &lt;plugin&gt;<br/></span><span>                &lt;groupId&gt;</span>org.wildfly.swarm<span>&lt;/groupId&gt;<br/></span><span>                &lt;artifactId&gt;</span>wildfly-swarm-plugin<span>&lt;/artifactId&gt;<br/></span><span>                &lt;version&gt;</span>${version.wildfly.swarm}<span>&lt;/version&gt;<br/></span><strong>                &lt;!-- 2 --&gt;<br/>                &lt;configuration&gt;<br/>                    &lt;mainClass&gt;org.packt.swarm.petstore.catalog.Main&lt;/mainClass&gt;<br/></strong><span><strong>                &lt;/configuration&gt;</strong><br/></span><span>                &lt;executions&gt;<br/></span><span>                    &lt;execution&gt;<br/></span><span>                        &lt;goals&gt;<br/></span><span>                            &lt;goal&gt;</span>package<span>&lt;/goal&gt;<br/></span><span>                        &lt;/goals&gt;<br/></span><span>                    &lt;/execution&gt;<br/></span><span>                &lt;/executions&gt;<br/></span><span>            &lt;/plugin&gt;<br/></span><span>        &lt;/plugins&gt;<br/></span><span>    &lt;/build&gt;<br/></span><span><br/></span><span>(...)</span></pre>
<p>As we are providing our own <kbd>main</kbd>, we have to explicitly add the dependency on the <kbd>jaxrs</kbd> fraction (1). We also have to add the method to the Swarm plugin configuration (2).</p>
<p>Let's look at the <kbd>ShrinkWrap</kbd> API usage in the <kbd>org.packt.swarm.petstore.Main</kbd> class:</p>
<pre><span>package </span>org.packt.swarm.petstore.catalog<span>;<br/></span><span><br/></span><span>import </span>org.jboss.shrinkwrap.api.ShrinkWrap<span>;<br/></span><span>import </span>org.wildfly.swarm.Swarm<span>;<br/></span><span>import </span>org.wildfly.swarm.jaxrs.JAXRSArchive<span>;<br/></span><span><br/></span><span>public class </span>Main {<br/><br/>    <span>public static void </span><span>main</span>(String[] args) <span>throws </span>Exception {<br/><br/>        Swarm swarm = <span>new </span>Swarm()<span>;<br/></span><span>        </span>swarm.start()<span>;<br/></span><span><br/></span><strong>        //1<br/>        JAXRSArchive deployment = ShrinkWrap.create(JAXRSArchive.class, "deployment.war");<br/>        //2<br/>        deployment.addClasses(CatalogApplication.class, CatalogResource.class, Item.class);<br/>        swarm.deploy(deployment)</strong><span><strong>;</strong><br/></span><span>    </span>}<br/>}</pre>
<p>We created the web archive (1), added the classes that our example consists of (2), and deployed them on the created container (3). As a result, we have manually done the same thing that Swarm does for us automatically.</p>
<p>We have used the <kbd>addClass</kbd> method to add created classes to the archive. In a similar way, you are able to use other <kbd>ShrinkWrap</kbd> API methods. The <kbd>org.jboss.shrinkwrap.api.spec.JavaArchive</kbd><em> </em>class apart from the native archive methods (<kbd>add</kbd> and <kbd>addDirectory)</kbd>) contains the methods that make it easy to work with classes (<kbd>addClass</kbd> <span>and</span> <kbd>addPackage</kbd>), resources (<kbd>addResource</kbd>), and manifests (<kbd>setManifest</kbd> <span>and</span> <kbd>addManifestResource</kbd>). The <kbd>org.jboss.shrinkwrap.api.spec.WebArchive</kbd><em> </em>class additionally adds web resource methods (<kbd>addWebResource</kbd> <span>and</span> <kbd>setWebXML</kbd>). As in the preceding example, using those methods is usually straightforward, but in the case of any doubts, you can take advantage of the <kbd>ShrinkWrap</kbd> Java API.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Obtaining the default archive</h1>
                </header>
            
            <article>
                
<p>Isn't <kbd>ShrinkWrap</kbd> too tedious to be useful in any real-life circumstances? After all, we don't want to manually add all classes and resources from our application to the archive. You don't have to worry about it—you will be able to obtain default deployment from the Swarm instance:</p>
<pre>package org.packt.swarm.petstore.catalog;<br/><br/>import org.jboss.shrinkwrap.api.Archive;<br/>import org.wildfly.swarm.Swarm;<br/><br/>public class Main {<br/><br/> public static void main(String[] args) throws Exception {<br/><br/> Swarm swarm = new Swarm();<br/> swarm.start();<br/><br/><strong> //1<br/> Archive&lt;?&gt; deployment = swarm.createDefaultDeployment();</strong><br/> swarm.deploy(deployment);<br/><br/> }<br/><br/>}</pre>
<p>As you see in the preceding example, we were able to obtain the default deployment by invoking the <kbd>createDefaultDeployment()</kbd> method. After we have it, we can only additional needed resources to it.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Swarm ShrinkWrap extensions</h1>
                </header>
            
            <article>
                
<p>Swarm adds its own classes to complement the <kbd>ShripWrap</kbd> API. Let's introduce them.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">JARArchive</h1>
                </header>
            
            <article>
                
<p>The <span><kbd>org.wildfly.swarm.spi.api.JARArchive</kbd> is an alternative to the <kbd>JavaArchive</kbd></span>. <span>Apart from all functions provided by it, the <kbd>JARArchive</kbd> adds an API to easily add modules, Maven dependencies, and service provider implementations. </span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">WARArchive</h1>
                </header>
            
            <article>
                
<p>As the <kbd>WebArchive</kbd> adds a functionality on top of <kbd>JavaArchive</kbd>, the <kbd>WARArchive</kbd> adds new features on top of the <kbd>JARArchive</kbd>. Apart from an interface that allows working with web resources, it adds the possibility to easily add the static web content. Let's look at this for an example.</p>
<p>As usual, we need the <kbd>pom.xml:</kbd></p>
<pre><span>(...)<br/></span><span><br/></span><span>    </span><strong>&lt;!-- 1 --&gt;<br/>    &lt;dependencies&gt;<br/>        &lt;dependency&gt;<br/>            &lt;groupId&gt;org.wildfly.swarm&lt;/groupId&gt;<br/>            &lt;artifactId&gt;undertow&lt;/artifactId&gt;<br/>            &lt;version&gt;${version.wildfly.swarm}&lt;/version&gt;<br/>        &lt;/dependency&gt;<br/></strong><span><strong>    &lt;/dependencies&gt;</strong><br/></span><span><br/></span><span>(...)</span></pre>
<p>As we are using our own <kbd>main</kbd>, we will need to add an <kbd>undertow</kbd> fraction dependency (1) and configure the <kbd>main</kbd> method (2).</p>
<p>Our static content will be a simple <span class="packt_screen">Hello World</span> page:</p>
<pre><span>&lt;html&gt;<br/></span><span>&lt;body&gt;<br/></span><span>&lt;h1&gt;</span>Hello World!<span>&lt;/h1&gt;<br/></span><span>&lt;/body&gt;<br/></span><span>&lt;/html&gt;</span></pre>
<p>We will add this class to the <kbd>webpage</kbd> directory inside our application's resources:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/ab8d6a54-6b03-42d0-9369-61741ae8b6a7.png" style=""/></div>
<p>The <kbd>main</kbd> class looks like this:</p>
<pre><span>package </span>org.packt.swarm.petstore.catalog<span>;<br/></span><span><br/></span><span>import </span>org.jboss.shrinkwrap.api.ShrinkWrap<span>;<br/></span><span>import </span>org.wildfly.swarm.Swarm<span>;<br/></span><span>import </span>org.wildfly.swarm.undertow.WARArchive<span>;<br/></span><span><br/></span><span>public class </span>Main {<br/><br/>    <span>public static void </span><span>main</span>(String[] args) <span>throws </span>Exception {<br/><br/>        Swarm swarm = <span>new </span>Swarm()<span>;<br/></span><span><br/></span><strong>        //1<br/>        WARArchive deployment = ShrinkWrap.create(WARArchive.class);<br/>        //2<br/>        deployment.staticContent("webpage")</strong><span><strong>;</strong><br/></span><span><br/></span><span>        </span>swarm.start().deploy(deployment)<span>;<br/></span><span><br/></span><span>    </span>}<br/>}</pre>
<p>We have created the <kbd>WARArchive</kbd> and invoked the <kbd>staticContent</kbd> method. When we open the web browser, we will see the <span class="packt_screen">Hello World</span> page:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/a42fac63-e643-4e5c-a393-d0a77453b151.jpg"/></div>
<p>What has happened? The static content method has copied all non-Java files from the <kbd>webpage</kbd> directory (one file in our example) to the created archive so that they can be seen by <kbd>undertow</kbd>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">JAXRSArchive</h1>
                </header>
            
            <article>
                
<p>The last type of Swarm archive that we want to look at right now is the <kbd>org.wildfly.swarm.JAXRSArchive</kbd>. This archive adds the ability to create a default JAX-RS application with the application path set to <kbd>"/"</kbd>. Till now, we have been doing this manually in all our examples. With the JAX-RS Archive, this class will be added automatically.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"> XML configuration</h1>
                </header>
            
            <article>
                
<p>Although Java API is convenient, this is not the only option that we have. If you are familiar with the WildFly XML configuration, or if you are migrating your application to Swarm and have a working XML file, you don't have to translate it to Java API as you can use it directly.</p>
<div class="packt_infobox">Examples reference: <kbd>chapter4/catalog-service-xmlconfig</kbd></div>
<p>Let's return to our database example. You may configure the datasource using XML. In such a case, the XML configuration will look like this:</p>
<pre><span>&lt;subsystem </span><span>xmlns=</span><span>"urn:jboss:domain:datasources:4.0"</span><span>&gt;<br/></span><span>    &lt;datasources&gt;<br/></span><span>        &lt;drivers&gt;<br/></span><span>            &lt;driver </span><span>name=</span><span>"h2" </span><span>module=</span><span>"com.h2database.h2"</span><span>&gt;<br/></span><span>                &lt;driver-class&gt;</span>org.h2.Driver<span>&lt;/driver-class&gt;<br/></span><span>                &lt;xa-datasource-class&gt;</span>org.h2.jdbcx.JdbcDataSource<span>&lt;/xa-datasource-class&gt;<br/></span><span>            &lt;/driver&gt;<br/></span><span>        &lt;/drivers&gt;<br/></span><span>        &lt;datasource </span><span>jndi-name=</span><span>"java:jboss/datasources/CatalogDS" </span><span>pool-name=</span><span>"CatalogDS" </span><span>enabled=</span><span>"true" </span><span>use-java-context=</span><span>"true"</span><span>&gt;<br/></span><span>            &lt;connection-url&gt;</span>jdbc:h2:mem:test;DB_CLOSE_DELAY=-1;DB_CLOSE_ON_EXIT=FALSE<span>&lt;/connection-url&gt;<br/></span><span>            &lt;driver&gt;</span>h2<span>&lt;/driver&gt;<br/></span><span>        &lt;/datasource&gt;<br/></span><span>        &lt;datasource </span><span>jndi-name=</span><span>"java:jboss/datasources/ExampleDS" </span><span>pool-name=</span><span>"ExampleDS" </span><span>enabled=</span><span>"true" </span><span>use-java-context=</span><span>"true"</span><span>&gt;<br/></span><span>            &lt;connection-url&gt;</span>jdbc:h2:mem:test;DB_CLOSE_DELAY=-1;DB_CLOSE_ON_EXIT=FALSE<span>&lt;/connection-url&gt;<br/></span><span>            &lt;driver&gt;</span>h2<span>&lt;/driver&gt;<br/></span><span>            &lt;security&gt;<br/></span><span>                &lt;user-name&gt;</span>sa<span>&lt;/user-name&gt;<br/></span><span>                &lt;password&gt;</span>sa<span>&lt;/password&gt;<br/></span><span>            &lt;/security&gt;<br/></span><span>        &lt;/datasource&gt;<br/></span><span>    &lt;/datasources&gt;<br/></span><span>&lt;/subsystem&gt;</span></pre>
<p>We have to add this configuration file to the <kbd>resources</kbd> directory:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/b7410646-ea8f-4454-aef5-44462e54287d.png" style=""/></div>
<p>Finally, we also have to tell Swarm to use the configuration file. The following is the modified <kbd>Main</kbd> class:</p>
<pre><span>package </span>org.packt.swarm.petstore.catalog<span>;<br/></span><span><br/></span><span>import </span>org.jboss.shrinkwrap.api.Archive<span>;<br/></span><span>import </span>org.wildfly.swarm.Swarm<span>;<br/></span><span>import </span>org.wildfly.swarm.datasources.DatasourcesFraction<span>;<br/></span><span>import </span>org.wildfly.swarm.jaxrs.JAXRSArchive<span>;<br/></span><span>import </span>org.wildfly.swarm.undertow.UndertowFraction<span>;<br/></span><span>import </span>org.wildfly.swarm.undertow.WARArchive<span>;<br/></span><span><br/></span><span>import </span>java.net.URL<span>;<br/></span><span><br/></span><span>public class </span>Main {<br/><br/>    <span>public static void </span><span>main</span>(String[] args) <span>throws </span>Exception {<br/><br/>        Swarm swarm = <span>new </span>Swarm()<span>;<br/></span><span><br/></span><strong>        //1<br/>        ClassLoader cl = Main.class.getClassLoader();<br/>        URL xmlConfig = cl.getResource("datasources.xml")</strong><span><strong>;</strong><br/></span><span><br/></span><strong>        //2<br/>        swarm.withXmlConfig(xmlConfig)</strong><span><strong>;</strong><br/></span><span><br/></span><span>        </span>swarm.start().deploy()<span>;<br/></span><span><br/></span><span>    </span>}</pre>
<p>We have obtained the classloader to be able to locate the configuration file(1). After reading the file, we instructed Swarm to use the configuration from it (2). </p>
<p>However, we have used the whole configuration file—will Swarm use all the subsystems now? The answer is no; only the fractions, whose dependencies have been specified will be added to the container. Swarm, given the XML file, will read only the configuration of those subsystems whose fractions constitute it. You are also able to provide a file with only those subsystems that you want to configure using XML.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">YAML configuration</h1>
                </header>
            
            <article>
                
<p class="mce-root">Another way in which you can provide Swarm configuration is YAML data serialization language.</p>
<p>Once more, let's start with the port-change example. We will start again with JAX-RS example and modify it to use the YAML configuration.</p>
<p>First, let's create the HTTP<span>-</span><kbd>port.yml</kbd> configuration file inside the <kbd>resources</kbd> directory:</p>
<pre><span>swarm:<br/></span><span>  http:<br/></span><span>    port: </span>12345</pre>
<p>The nested properties are translated to flat properties by Swarm. So, the property specified by the preceding file is translated to <kbd>swarm.http.port</kbd>, which we know well already.</p>
<p>To use the following configuration, we have to modify our <kbd>Main</kbd> class:</p>
<pre><span>package </span>org.packt.swarm.petstore.catalog<span>;<br/></span><span><br/></span><span>import </span>org.wildfly.swarm.Swarm<span>;<br/></span><span><br/></span><span>import </span>java.net.URL<span>;<br/></span><span><br/></span><span>public class </span>Main {<br/><br/>    <span>public static void </span><span>main</span>(String[] args) <span>throws </span>Exception {<br/><br/>        Swarm swarm = <span>new </span>Swarm()<span>;<br/></span><span><br/></span><span>        </span><span>/<strong>/1</strong><br/></span><strong>        ClassLoader cl = Main.class.getClassLoader();<br/>        URL yamlConfig = cl.getResource("http-port.yml")</strong><span><strong>;</strong><br/></span><span><br/></span><span>        </span><strong>//2<br/>        swarm.withConfig(yamlConfig)</strong><span><strong>;</strong><br/></span><span><br/></span><span>        </span>swarm.start().deploy()<span>;<br/></span><span>    </span>}<br/>}</pre>
<p>After obtaining the configuration from the <kbd>classpath</kbd> (1), we informed Swarm to use it using the <kbd>withConfig</kbd> method. That's it; now, Swarm will use the <kbd>12345</kbd> port.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Project stages</h1>
                </header>
            
            <article>
                
<p>The strength of the YAML configuration is its ability to provide different groups properties for different project stages. Again, let's take a look at the example first. </p>
<p>The new configuration file looks like this:</p>
<pre><span>swarm:<br/></span><span>  http:<br/></span><span>    port: </span>8080<br/>---<br/><span>project:<br/></span><span>    stage: </span>test<br/><span>swarm:<br/></span><span>    http:<br/></span><span>        port: </span>12345<br/>---<br/><span>project:<br/></span><span>    stage: </span>QA<br/><span>swarm:<br/></span><span>    http:<br/></span><span>        port: </span>12346</pre>
<p>The different parts of the file gather the configuration for different project stages. The first group is the default configuration. It is used when no stage name is provided. The other two specify the configurations for test and <kbd>QA</kbd> stages. However, how do you know the stage in which the application currently runs? You have to provide the <span><kbd>swarm.project.stage</kbd> property. So, consider that, for example, we run the preceding example with the following command:</span></p>
<pre><strong>mvn wildfly-swarm:run -Dswarm.project.stage=QA</strong></pre>
<p>Then, we will be able to access our application on the <kbd>12346</kbd><span> port.</span> </p>
<p>As you will have noticed in the preceding code, the YAML configuration makes it easy to create the configuration for different environments and choose what group of properties should be used using a simple command-line argument.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">YAML database configuration</h1>
                </header>
            
            <article>
                
<p>As an another YAML config example, we are going to show you how to configure the datasources with the YAML configuration file. Let's take a look:</p>
<div class="packt_infobox">Examples reference: <kbd>chapter 4/catalog-service-database-ymlconfig</kbd></div>
<p>The example is very similar to the XML configuration example. We have to exchange the configuration file for its YAML equivalent:</p>
<pre><span>swarm:<br/></span><span>  datasources:<br/></span><span>    data-sources:<br/></span><span>      CatalogDS:<br/></span><span>        driver-name: </span>h2<br/>        <span>connection-url: </span>jdbc:h2:mem:test;DB_CLOSE_DELAY=-1;DB_CLOSE_ON_EXIT=FALSE<br/>        <span>user-name: </span>sa<br/>        <span>password: </span>sa<br/>    <span>jdbc-drivers:<br/></span><span>          h2:<br/></span><span>            driver-class-name: </span>org.h2.Driver<br/>            <span>xa-datasource-name: </span>org.h2.jdbcx.JdbcDataSource<br/>            <span>driver-module-name: </span>com.h2database.h2<br/><br/></pre>
<p>And also need to make the <kbd>Main</kbd> class use it (1):</p>
<pre><span>package </span>org.packt.swarm.petstore.catalog<span>;<br/></span><span><br/></span><span>import </span>org.wildfly.swarm.Swarm<span>;<br/></span><span><br/></span><span>import </span>java.net.URL<span>;<br/></span><span><br/></span><span>public class </span>Main {<br/><br/>    <span>public static void </span><span>main</span>(String[] args) <span>throws </span>Exception {<br/>        Swarm swarm = <span>new </span>Swarm()<span>;<br/></span><span><br/><strong>        //1</strong><br/></span><strong>        ClassLoader cl = Main.class.getClassLoader();<br/>        URL ymlConfig = cl.getResource("datasources.yml");<br/><br/>        swarm.withConfig(ymlConfig)</strong><span><strong>;</strong><br/></span><span><br/></span><span>        </span>swarm.start().deploy()<span>;<br/></span><span>    </span>}<br/>}</pre>
<p><span>We are going to use such configurations a lot in the examples throughout the book. </span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Mixing the configurations</h1>
                </header>
            
            <article>
                
<p>Now, what about mixing configurations? Are you allowed to do this? Yup. Let's look at the following code:</p>
<pre>package org.packt.swarm.petstore.catalog;<br/><br/>import org.jboss.shrinkwrap.api.Archive;<br/>import org.wildfly.swarm.Swarm;<br/>import org.wildfly.swarm.datasources.DatasourcesFraction;<br/>import org.wildfly.swarm.undertow.UndertowFraction;<br/><br/>public class Main {<br/><br/> public static void main(String[] args) throws Exception {<br/> Swarm swarm = new Swarm();<br/> <br/><strong> //1<br/> ClassLoader cl = Main.class.getClassLoader();<br/> URL xmlConfig = cl.getResource("standalone.xml");<br/> swarm.withXMLFile(xmlFile);</strong><br/> <br/><strong> //2<br/> UndertowFraction undertowFraction = new UndertowFraction();<br/> undertowFraction.applyDefaults();<br/> undertowFraction.httpPort(12345);<br/> swarm.fraction(undertowFraction);</strong><br/> <br/><strong> //3<br/> Archive&lt;?&gt; deployment = swarm.createDefaultDeployment();<br/> deployment.addModule("com.h2database.h2");</strong><br/> <br/> <strong>//4<br/> swarm.start().deploy();</strong><br/> }<br/><br/>}</pre>
<p>It is another variation of our database example, and you already know what is happening in the whole code. Just to recall, we loaded the configuration file and informed Swarm to use it (1), created the <kbd>UndertowFraction</kbd> and configured it to use the <kbd>12345</kbd> port (2), added the driver module to the application (3), and, finally, started the application and deployed the created archive on it (4).</p>
<p>What would be the result of such code? As you probably have guessed, after running the application, we will be able to see the random messages on <kbd>localhost:12345/hello</kbd>.</p>
<p>Note that you are able to mix XML and Java API configurations. Can you use the properties too? Sure. Let's add <kbd>swarm.http.port</kbd> with the <kbd>12346</kbd> <span>port </span>to the command line, and we will be able to see our messages on the address. Yeah, we have a conflict here. Is this an error? It is not an error. Swarm attaches different priorities to different configuration methods. The precedence is as follows:</p>
<ol>
<li>Java API overrides the configuration specified by XML</li>
<li>YAML overrides the configuration specified by Java API</li>
<li>Finally, the system properties override the YAML configuration</li>
<li>As a result, in our last example, we will see our messages on the <kbd>12346</kbd> port</li>
</ol>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>In this chapter, you learned how to configure services created using Swarm. You learned how to modify the Swarm behavior using the system properties, provide your own <kbd>main</kbd> method and use it to provide the Swarm configuration using either Java API or XML, and, finally, how to modify the content of the deployed application.</p>
<p>After the three initial chapters, you are now able to use WildFly Swarm to build microservices. In the next chapters, you will learn OpenShift so you are able to deploy your services in the cloud.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Further reading</h1>
                </header>
            
            <article>
                
<p> <a href="http://wildfly-swarm.io/documentation/">http://wildfly-swarm.io/documentation/</a></p>
<p class="mce-root"/>
<p class="mce-root"/>


            </article>

            
        </section>
    </body></html>