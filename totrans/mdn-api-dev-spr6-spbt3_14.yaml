- en: '14'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '14'
- en: GraphQL API Development and Testing
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: GraphQL API开发和测试
- en: In the previous chapter, we learned about the fundamental concepts of GraphQL.
    You are going to use that knowledge to develop and test GraphQL-based APIs in
    this chapter. You will implement GraphQL-based APIs for a sample application in
    this chapter. The GraphQL server implementation will be developed based on a **design-first**
    approach, the way you defined the OpenAPI specification in [*Chapter 3*](B19349_03.xhtml#_idTextAnchor080),
    *API Specifications and Implementation*, and designed the schema in [*Chapter
    11*](B19349_11.xhtml#_idTextAnchor250), *gRPC API Development* *and Testing*.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们学习了GraphQL的基本概念。您将利用这些知识在本章中开发和测试基于GraphQL的API。您将在本章中为示例应用程序实现基于GraphQL的API。GraphQL服务器的实现将基于**设计优先**的方法，这与您在[*第3章*](B19349_03.xhtml#_idTextAnchor080)中定义的OpenAPI规范的方式相同，在[*第11章*](B19349_11.xhtml#_idTextAnchor250)中设计了模式，*gRPC
    API开发和测试*。
- en: After completing this chapter, you will have learned how to practically implement
    the GraphQL concepts learned about in the previous chapter and about the implementation
    of the GraphQL server using Java and Spring and its testing.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 完成本章学习后，您将学会如何实际应用在前一章中学到的GraphQL概念，以及使用Java和Spring实现GraphQL服务器及其测试。
- en: 'This chapter will cover the following main topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主要主题：
- en: Workflow and tooling for GraphQL
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GraphQL的工作流程和工具
- en: Implementing the GraphQL server
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现GraphQL服务器
- en: Documenting APIs
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 记录API文档
- en: Test automation
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试自动化
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: The code for this chapter is available at
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码可在以下位置找到
- en: '[https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/dev/Chapter14](https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/dev/Chapter14)'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/dev/Chapter14](https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/dev/Chapter14)'
- en: Workflow and tooling for GraphQL
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: GraphQL的工作流程和工具
- en: As per the data graph (data structure) way of thinking in GraphQL, data is exposed
    using an API consisting of graphs of objects. These objects are connected using
    relations. GraphQL only exposes a single API endpoint. Clients query this endpoint,
    which uses a *single data graph*. On top of that, the data graph may resolve data
    from a single source, or multiple sources, by following the **OneGraph principle**
    of GraphQL. These sources could be a database, legacy system, or services that
    expose data using REST/gRPC/SOAP.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 根据GraphQL中数据图（数据结构）的思维方式，数据通过由对象图组成的API进行暴露。这些对象通过关系相互连接。GraphQL仅暴露一个API端点。客户端查询此端点，它使用一个*单一数据图*。在此基础上，数据图可以通过遵循GraphQL的**OneGraph原则**从单一来源或多个来源解析数据。这些来源可以是数据库、遗留系统或使用REST/gRPC/SOAP暴露数据的服务。
- en: 'The GraphQL server can be implemented in the following two ways:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: GraphQL服务器可以通过以下两种方式实现：
- en: '**Standalone GraphQL service**: A standalone GraphQL service contains a single
    data graph. It could be a monolithic app or based on a microservice architecture
    that fetches the data from single or multiple sources (having no GraphQL API).'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**独立GraphQL服务**：一个独立的GraphQL服务包含一个单一的数据图。它可能是一个单体应用程序，或者基于微服务架构，从单一或多个来源（没有GraphQL
    API）获取数据。'
- en: '**Federated GraphQL services**: It’s very easy to query a single data graph
    for comprehensive data fetching. However, enterprise applications are made using
    multiple services; hence, you can’t have a single data graph unless you build
    a monolithic system. If you don’t build a monolithic system, then you will have
    multiple service-specific data graphs.'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**联邦GraphQL服务**：查询单一数据图以获取综合数据非常容易。然而，企业应用程序是由多个服务构建的；因此，除非构建一个单体系统，否则您无法拥有单一的数据图。如果您不构建单体系统，那么您将拥有多个特定于服务的独立数据图。'
- en: This is where you make use of federated GraphQL services. A federated GraphQL
    service contains a **single distributed graph** exposed using a gateway. Clients
    call the gateway, which is an entry point into the system. The data graph is distributed
    among multiple services and each service can maintain its own development and
    release cycle independently. Having said that, federated GraphQL services still
    follow the OneGraph principle. Therefore, the client queries the single endpoint
    to fetch any part of the graph.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是您使用联邦GraphQL服务的地方。一个联邦GraphQL服务包含一个**单个分布式图**，通过网关暴露。客户端调用网关，它是进入系统的入口点。数据图分布在多个服务中，每个服务可以独立维护其自身的开发和发布周期。话虽如此，联邦GraphQL服务仍然遵循OneGraph原则。因此，客户端查询单个端点以获取图的任何部分。
- en: Let’s assume that a sample e-commerce app is developed using GraphQL federated
    services. It has products, orders, shipping, inventory, customers, and other services
    that expose the domain-specific data graphs using the GraphQL API.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 假设一个示例电子商务应用是使用GraphQL联邦服务开发的。它有产品、订单、运输、库存、客户和其他服务，这些服务使用GraphQL API公开了特定领域的图数据。
- en: 'Let’s look at a high-level diagram of GraphQL federated e-commerce services,
    as follows:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一下GraphQL联邦电子商务服务的高级图示，如下所示：
- en: '![Figure 14.1 – Federated GraphQL services](img/Figure_14.1_B19349.jpg)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![图14.1 – 联邦GraphQL服务](img/Figure_14.1_B19349.jpg)'
- en: Figure 14.1 – Federated GraphQL services
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.1 – 联邦GraphQL服务
- en: Let’s say the GraphQL client queries for a list of the most ordered products
    with the least inventory by calling the `Gateway` endpoint. This query may have
    fields from `Orders`, `Products`, and `Inventory`. Each service is responsible
    for resolving only the respective part of a data graph. `Orders` would resolve
    order-related data, `Products` would resolve product-related data, `Inventory`
    would resolve inventory-related data, and so on. `Gateway` then consolidates the
    graph data and sends it back to the clients.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 假设GraphQL客户端通过调用`Gateway`端点查询最常订购且库存最少的产品的列表。此查询可能包含来自`Orders`、`Products`和`Inventory`的字段。每个服务只负责解决数据图的相关部分。`Orders`将解决订单相关数据，`Products`将解决产品相关数据，`Inventory`将解决库存相关数据，等等。然后`Gateway`整合图数据并将其发送回客户端。
- en: The `graphql-java` library ([https://www.graphql-java.com](https://www.graphql-java.com))
    provides the Java implementation of the GraphQL specification. Its source code
    is available at [https://github.com/graphql-java/graphql-java](https://github.com/graphql-java/graphql-java).
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '`graphql-java`库([https://www.graphql-java.com](https://www.graphql-java.com))提供了GraphQL规范的Java实现。其源代码可在[https://github.com/graphql-java/graphql-java](https://github.com/graphql-java/graphql-java)找到。'
- en: Spring provides a Spring Boot Starter project for GraphQL based on `graphql-java`,
    available at [https://github.com/spring-projects/spring-graphql](https://github.com/spring-projects/spring-graphql).
    However, we are going to use the Spring-based Netflix `graphql-java` library.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: Spring提供了一个基于`graphql-java`的GraphQL Spring Boot Starter项目，可在[https://github.com/spring-projects/spring-graphql](https://github.com/spring-projects/spring-graphql)找到。然而，我们将使用基于Spring的Netflix
    `graphql-java`库。
- en: Netflix open sourced the DGS framework after using it in production in February
    2021\. It is continuously being enhanced and supported by the community. Netflix
    uses the same open sourced DGS framework codebase in production environments,
    which gives the assurance of the code’s quality and future maintenance. The OTT
    Disney+ platform was also built using the Netflix DGS framework ([https://webcache.googleusercontent.com/search?q=cache:ec4kC7jBjMQJ:https://help.apps.disneyplus.com/3rd-party-libs.html&cd=14&hl=en&ct=clnk&gl=in&client=firefox-b-d](https://webcache.googleusercontent.com/search?q=cache:ec4kC7jBjMQJ:https://help.apps.disneyplus.com/3rd-party-libs.html&cd=14&hl=en&ct=clnk&gl=in&client=firefox-b-d)).
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: Netflix在2021年2月将其在生产环境中使用的DGS框架开源。它正在由社区持续增强和支持。Netflix在生产环境中使用相同的开源DGS框架代码库，这保证了代码的质量和未来的维护。OTT
    Disney+平台也是使用Netflix DGS框架构建的([https://webcache.googleusercontent.com/search?q=cache:ec4kC7jBjMQJ:https://help.apps.disneyplus.com/3rd-party-libs.html&cd=14&hl=en&ct=clnk&gl=in&client=firefox-b-d](https://webcache.googleusercontent.com/search?q=cache:ec4kC7jBjMQJ:https://help.apps.disneyplus.com/3rd-party-libs.html&cd=14&hl=en&ct=clnk&gl=in&client=firefox-b-d))).
- en: 'It provides the following features:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 它提供了以下功能：
- en: A Spring Boot starter and integration with Spring Security
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Spring Boot启动器和与Spring Security的集成
- en: Full WebFlux support
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 全面的WebFlux支持
- en: A Gradle plugin for code generation from a GraphQL schema
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于从GraphQL模式生成代码的Gradle插件
- en: Support for interfaces and union types, plus the provision of custom scalar
    types
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 支持接口和联合类型，并提供自定义标量类型
- en: Support for GraphQL subscriptions using WebSocket and server-sent events
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 支持 WebSocket 和服务器发送事件使用 GraphQL 订阅
- en: Error handling
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 错误处理
- en: Pluggable instrumentation and Micrometer integration
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可插拔的仪器和 Micrometer 集成
- en: GraphQL federated services with easy integration with GraphQL federation
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 GraphQL 联邦与 GraphQL 联邦轻松集成的 GraphQL 联邦服务
- en: Dynamic schemas with hot reloading schemas
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 带有热加载模式的动态模式
- en: Operation caching
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 操作缓存
- en: File upload
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文件上传
- en: GraphQL Java client
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GraphQL Java 客户端
- en: GraphQL test framework
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GraphQL 测试框架
- en: Let’s write a GraphQL server using Netflix’s DGS framework in the next section.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将使用 Netflix 的 DGS 框架编写一个 GraphQL 服务器。
- en: Implementing the GraphQL server
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现 GraphQL 服务器
- en: You are going to develop a standalone GraphQL server in this chapter. The knowledge
    you acquire while developing the standalone GraphQL server can be used to implement
    federated GraphQL services.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您将开发一个独立的 GraphQL 服务器。在开发独立 GraphQL 服务器时获得的知识可以用于实现联邦 GraphQL 服务。
- en: Let’s create the Gradle project first in the next subsection.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一小节中，让我们首先创建 Gradle 项目。
- en: Creating the gRPC server project
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建 gRPC 服务器项目
- en: 'Either you can use the [*Chapter 14*](B19349_14.xhtml#_idTextAnchor313) code
    by cloning the Git repository ([https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/dev/Chapter14](https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/dev/Chapter14))
    or you can start by creating a new Spring project from scratch using Spring Initializr
    for the server and client with the following options:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以选择克隆 Git 仓库中的 [*第14章*](B19349_14.xhtml#_idTextAnchor313) 代码（[https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/dev/Chapter14](https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/dev/Chapter14)）或从零开始使用
    Spring Initializr 创建服务器和客户端项目，以下为选项：
- en: '`Gradle -` `Groovy`'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Gradle -` `Groovy`'
- en: '`Java`'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Java`'
- en: '`3.0.8`'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`3.0.8`'
- en: The preferred version is 3.0+; if not available, you can modify it later manually
    in the `build.gradle` file
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 推荐的版本是 3.0+；如果不可用，您可以在稍后的 `build.gradle` 文件中手动修改。
- en: '`com.packt.modern.api`'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`com.packt.modern.api`'
- en: '`chapter14`'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`第14章`'
- en: '`chapter14`'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`第14章`'
- en: '`Chapter 14 code of book Modern API Development with Spring and Spring Boot`
    `Ed 2`'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 《使用 Spring 和 Spring Boot 开发现代 API》第 14 章代码 第 2 版
- en: '`com.packt.modern.api`'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`com.packt.modern.api`'
- en: '`JAR`'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`JAR`'
- en: '`17`'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`17`'
- en: 'You can change it to another version, such as 17/20/21, in the `build.gradle`
    file later, as shown in the following code block:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在 `build.gradle` 文件中将其更改为其他版本，例如 17/20/21，如下面的代码块所示：
- en: '[PRE0]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '`org.springframework.boot:spring-boot-starter-web`'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`org.springframework.boot:spring-boot-starter-web`'
- en: Then, you can click on the **GENERATE** button and download the project. The
    downloaded project will be used to create the GraphQL server.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，您可以点击**生成**按钮并下载项目。下载的项目将用于创建 GraphQL 服务器。
- en: Next, let’s add the GraphQL DGS dependencies to the newly created project.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们将 GraphQL DGS 依赖项添加到新创建的项目中。
- en: Adding the GraphQL DGS dependencies
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加 GraphQL DGS 依赖项
- en: 'Once the Gradle project is available, you can modify the `build.gradle` file
    to include the GDS dependencies and plugin as shown in the following code:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦 Gradle 项目可用，您就可以修改 `build.gradle` 文件以包含 GDS 依赖项和插件，如下面的代码所示：
- en: '[PRE1]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '[https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/dev/Chapter14/build.gradle](https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/dev/Chapter14/build.gradle)'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/dev/Chapter14/build.gradle](https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/dev/Chapter14/build.gradle)'
- en: 'Here, first, the DGS Codegen plugin is added, which will generate the code
    from the GraphQL schema file. Next, the following five dependencies are added:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，首先添加了 DGS Codegen 插件，它将从 GraphQL 模式文件生成代码。接下来，添加以下五个依赖项：
- en: '`graphql-dgs-platform-dependencies`: The DGS platform dependencies for the
    DGS bill of materials (BOM)'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`graphql-dgs-platform-dependencies`: 用于 DGS 材料清单 (BOM) 的 DGS 平台依赖项'
- en: '`graphql-dgs-spring-boot-starter`: The DGS Spring Boot Starter library for
    DGS Spring support'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`graphql-dgs-spring-boot-starter`: 用于 DGS Spring 支持的 DGS Spring Boot Starter
    库'
- en: '`graphql-dgs-extended-scalars`: The DGS extended scalars library for custom
    scalar types'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`graphql-dgs-extended-scalars`: 用于自定义标量类型的 DGS 扩展标量库'
- en: '`graphql-dgs-spring-boot-micrometer`: The DGS library to provide integration
    with Micrometer to provide support for metrics and instrumentation along with
    Spring Actuator'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`graphql-dgs-spring-boot-micrometer`: 提供与 Micrometer 集成的 DGS 库，以提供对指标和仪表化的支持，以及
    Spring Actuator'
- en: '`graphql-dgs-subscriptions-websockets-autoconfigure`: To provide the autoconfiguration
    for GraphQL WebSocket support'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`graphql-dgs-subscriptions-websockets-autoconfigure`: 提供对 GraphQL WebSocket
    支持的自动配置'
- en: Please note that the `datafaker` library is used here to generate the domain
    seed data.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这里使用了 `datafaker` 库来生成领域种子数据。
- en: 'Next, let’s configure the DGS Codegen plugin in the same `build.gradle` file
    as shown in the next code block:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们在相同的 `build.gradle` 文件中配置 DGS Codegen 插件，如下面的代码块所示：
- en: '[PRE2]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'You have configured the following two properties of DGS Codegen using the `generateJava`
    task, which uses the Gradle plugin `com.netflix.graphql.dgs.codegen.GenerateJavaTask`
    class:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经使用 `generateJava` 任务配置了 DGS Codegen 的以下两个属性，该任务使用 Gradle 插件 `com.netflix.graphql.dgs.codegen.GenerateJavaTask`
    类：
- en: '`generateClient`: This determines whether you would like to generate the client
    or not'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`generateClient`: 这确定你是否想要生成客户端'
- en: '`packageName`: The Java package name of the generated Java classes'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`packageName`: 生成的 Java 类的 Java 包名'
- en: 'The DGS Codegen plugin picks GraphQL schema files from the `src/main/resources/schema`
    directory by default. However, you can modify it using the `schemaPaths` property,
    which accepts an array. You can add this property to the previous code of `generateTask`
    along with `packageName` and `generateClient` if you want to change the default
    schema location, as shown next:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: DGS Codegen 插件默认从 `src/main/resources/schema` 目录中选取 GraphQL 模式文件。然而，你可以使用 `schemaPaths`
    属性来修改它，该属性接受一个数组。如果你想更改默认的模式位置，可以将此属性添加到之前的 `generateTask` 代码中，包括 `packageName`
    和 `generateClient`，如下所示：
- en: '[PRE3]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'typeMapping = ["GraphQLType": "mypackage.JavaType"]'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 'typeMapping = ["GraphQLType": "mypackage.JavaType"]'
- en: '[PRE4]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'type Query {    products(filter: ProductCriteria): [Product]!'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 'type Query {    products(filter: ProductCriteria): [Product]!'
- en: 'product(id: ID!): Product'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 'product(id: ID!): Product'
- en: '}'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: type Mutation {
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: type Mutation {
- en: 'addTag(productId: ID!, tags: [TagInput!]!): Product'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 'addTag(productId: ID!, tags: [TagInput!]!): Product'
- en: 'addQuantity(productId: ID!, quantity: Int!): Product'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 'addQuantity(productId: ID!, quantity: Int!): Product'
- en: '}'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: type Subscription {
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: type Subscription {
- en: 'quantityChanged: Product'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 'quantityChanged: Product'
- en: '}'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '[PRE5]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'type Product {     id: String'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 'type Product {     id: 字符串'
- en: 'name: String'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 'name: 字符串'
- en: 'description: String'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 'description: 字符串'
- en: 'imageUrl: String'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 'imageUrl: 字符串'
- en: 'price: BigDecimal'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 'price: BigDecimal'
- en: 'count: Int'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 'count: 整数'
- en: 'tags: [Tag]'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 'tags: [Tag]'
- en: '}'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: input ProductCriteria {
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: input ProductCriteria {
- en: 'tags: [TagInput] = []'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 'tags: [TagInput] = []'
- en: 'name: String = ""'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 'name: 字符串 = ""'
- en: 'page: Int = 1'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 'page: 整数 = 1'
- en: 'size: Int = 10'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 'size: 整数 = 10'
- en: '}'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: input TagInput {
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: input TagInput {
- en: 'name: String'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 'name: 字符串'
- en: '}'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: type Tag {
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: type Tag {
- en: 'id: String'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 'id: 字符串'
- en: 'name: String'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 'name: 字符串'
- en: '}'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '[PRE6]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'java.math.BigDecimal in the code generator plugin. Let’s add it to the build.gradle
    file as shown next (check the highlighted line):'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: java.math.BigDecimal 在代码生成插件中。让我们将其添加到下一个 build.gradle 文件中，如下所示（检查高亮行）：
- en: '[PRE7]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'After these changes, your project is ready to generate the GraphQL objects
    and client. You can run the following command from the project root directory
    to build the project:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些更改之后，你的项目已准备好生成 GraphQL 对象和客户端。你可以从项目根目录运行以下命令来构建项目：
- en: '[PRE8]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This command will generate the Java classes in the `build/generated` directory.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令将在 `build/generated` 目录中生成 Java 类。
- en: Before you start implementing the GraphQL root types, let’s discuss the custom
    scalar types in the next subsection.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在你开始实现 GraphQL 根类型之前，让我们在下一小节中讨论自定义标量类型。
- en: Adding custom scalar types
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 添加自定义标量类型
- en: You are going to use `BigDecimal` to capture the monetary values. This is a
    custom scalar type; therefore, you need to add this custom scalar to the code
    so that the DGS framework can pick it for serialization and deserialization. (You
    also need to add a mapping to the Gradle code generator plugin.)
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 你将使用 `BigDecimal` 来捕获货币值。这是一个自定义标量类型；因此，你需要将此自定义标量添加到代码中，以便 DGS 框架可以将其用于序列化和反序列化。（你还需要将映射添加到
    Gradle 代码生成插件中。）
- en: There are two ways to add the custom scalar type – by implementing the `Coercing`
    interface and by making use of the `graphql-dgs-extended-scalars` library. We
    are going to use the latter because it has fewer lines and the actual implementation
    is provided by the Netflix DGS framework.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 添加自定义标量类型有两种方式——通过实现 `Coercing` 接口和利用 `graphql-dgs-extended-scalars` 库。我们将使用后者，因为它行数更少，并且实际的实现由
    Netflix DGS 框架提供。
- en: The first, crude way of adding the scalar type is to implement the `graphql.schema.Coercing`
    interface and annotate it with the `@DgsScalar` annotation. Here, you need to
    write the boiler plate code yourself.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 第一种，最原始的添加标量类型的方法是实现 `graphql.schema.Coercing` 接口，并用 `@DgsScalar` 注解进行标注。在这里，你需要自己编写样板代码。
- en: 'Instead, we will opt for the second method, which involves using the scalar
    type provided by the DGS framework, which is well tested on production systems.
    The `graphql.schema.Coercing` interface is provided by the `graphql-java` library.
    The `DateTimeScalar` scalar type is implemented using `Coercing`, as shown in
    the following code:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，我们将选择第二种方法，该方法涉及使用 DGS 框架提供的标量类型，该类型已在生产系统上经过良好测试。`graphql.schema.Coercing`
    接口由 `graphql-java` 库提供。`DateTimeScalar` 标量类型使用 `Coercing` 实现，如下面的代码所示：
- en: '[PRE9]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Here, you have overridden the three methods – `serialize()`, `parseValue()`,
    and `parseLiteral()` – of the `Coercing` interface to implement serialization
    and parsing for the `DateTimeScalar` custom scalar type.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你重写了 `Coercing` 接口的三个方法——`serialize()`、`parseValue()` 和 `parseLiteral()`——以实现
    `DateTimeScalar` 自定义标量类型的序列化和解析。
- en: However, you are going to use the second method – the `graphql-dgs-extended-scalars`
    library – for registering new scalar types. This library has already been added
    in the `build.gradle` file. Let’s make use of the `graphql-dgs-extended-scalars`
    library to register the `BigDecimalScaler` type.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，你将使用第二种方法——`graphql-dgs-extended-scalars` 库——来注册新的标量类型。这个库已经在 `build.gradle`
    文件中添加了。让我们利用 `graphql-dgs-extended-scalars` 库来注册 `BigDecimalScaler` 类型。
- en: 'Create a new Java file called `BigDecimalScaler.java` and add the following
    code to it:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个名为 `BigDecimalScaler.java` 的新 Java 文件，并将以下代码添加到其中：
- en: '[PRE10]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '[https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/blob/dev/Chapter14/src/main/java/com/packt/modern/api/scalar/BigDecimalScalar.java](https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/blob/dev/Chapter14/src/main/java/com/packt/modern/api/scalar/BigDecimalScalar.java)'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/blob/dev/Chapter14/src/main/java/com/packt/modern/api/scalar/BigDecimalScalar.java](https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/blob/dev/Chapter14/src/main/java/com/packt/modern/api/scalar/BigDecimalScalar.java)'
- en: Here, you are making use of `DgsRuntimeWiring` to add the custom `GraphQLBigDecimal`
    scalar provided by the `graphql-dgs-extended-scalars` library. The `RuntimeWiring`
    class comprises data fetchers, type resolvers, and custom scalars that are needed
    to wire together a functional `GraphQLSchema` class. The `DgsRuntimeWiring` annotation
    marks the method as runtime wiring. So, you can perform the customization before
    the `RuntimeWiring` class gets executed. Basically, you are adding the `GraphQLBigDecimal`
    scalar type to `RuntimeWiring.Builder` for runtime wiring execution.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你正在使用 `DgsRuntimeWiring` 来添加由 `graphql-dgs-extended-scalars` 库提供的自定义 `GraphQLBigDecimal`
    标量。`RuntimeWiring` 类包含数据获取器、类型解析器和自定义标量，这些是连接一个功能性的 `GraphQLSchema` 类所必需的。`DgsRuntimeWiring`
    注解将方法标记为运行时连接。因此，你可以在 `RuntimeWiring` 类执行之前进行自定义。基本上，你正在将 `GraphQLBigDecimal`
    标量类型添加到 `RuntimeWiring.Builder` 以进行运行时连接执行。
- en: The `BigDecimalScalar` class is marked with the `@Dgs``Component` annotation.
    The DGS framework is an annotation-based Spring Boot programming model. The DGS
    framework provides these types of annotations (such as `@DgsComponent`) for Spring
    Boot. A class marked with `@DgsComponent` is a DGS component as well as a regular
    Spring component.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '`BigDecimalScalar` 类被标记为 `@DgsComponent` 注解。DGS 框架是一个基于注解的 Spring Boot 编程模型。DGS
    框架为 Spring Boot 提供了这些类型的注解（如 `@DgsComponent`）。被 `@DgsComponent` 标记的类既是 DGS 组件也是常规的
    Spring 组件。'
- en: Similarly, you have added the `DateTimeScalar` type. The code for the `DateTimeScalar`
    scalar type is available at [https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/dev/Chapter14/src/main/java/com/packt/modern/api/scalar/DateTimeScalar.java](https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/dev/Chapter14/src/main/java/com/packt/modern/api/scalar/DateTimeScalar.java).
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，你已经添加了 `DateTimeScalar` 类型。`DateTimeScalar` 标量类型的代码可以在 [https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/dev/Chapter14/src/main/java/com/packt/modern/api/scalar/DateTimeScalar.java](https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/dev/Chapter14/src/main/java/com/packt/modern/api/scalar/DateTimeScalar.java)
    找到。
- en: All the schema details and its documentation can be explored using the GraphQL
    documentation that is available in GraphiQL or similar tools. Let’s find out how
    you find the auto-generated documentation next.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 所有模式细节及其文档都可以通过GraphiQL或类似工具中可用的GraphQL文档进行探索。让我们找出如何找到自动生成的文档。
- en: Documenting APIs
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 记录API
- en: You can use GraphiQL or a playground tool that provides a graphical interface
    to explore the GraphQL schema and documentation.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用GraphiQL或提供图形界面的playground工具来探索GraphQL模式和文档。
- en: On GraphiQL (`http://localhost:8080/graphiql`, which can be started by running
    the `jar` built out of this chapter code), you can open the document explorer
    by clicking on the book icon available in the top-left corner of the page. Once
    you click on it, it will display the documentation.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在GraphiQL（`http://localhost:8080/graphiql`，可以通过运行本章代码构建的`jar`启动），您可以通过点击页面左上角的书本图标打开文档浏览器。一旦点击，它将显示文档。
- en: However, if you are looking for a static page, then you can use tools such as
    `graphdoc` ([https://github.com/2fd/graphdoc](https://github.com/2fd/graphdoc))
    to generate the static documentation for the GraphQL APIs.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果您正在寻找一个静态页面，那么您可以使用诸如`graphdoc`（[https://github.com/2fd/graphdoc](https://github.com/2fd/graphdoc)）之类的工具来生成GraphQL
    API的静态文档。
- en: Next, let’s start implementing GraphQL root types. First, you are going to implement
    GraphQL queries.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们开始实现GraphQL根类型。首先，您将实现GraphQL查询。
- en: Implementing GraphQL queries
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 实现GraphQL查询
- en: Both the queries we introduced in the schema in the previous section are straightforward.
    You pass a product ID to find a product identified by that ID – that’s the product
    query for you. Next, you pass the optional product criteria to find the products
    based on the given criteria; otherwise, products are returned based on the default
    values of the fields of product criteria.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在上一节模式中引入的查询都很简单。您传递一个产品ID以找到由该ID标识的产品——这就是您的产品查询。接下来，您传递可选的产品标准以根据给定标准查找产品；否则，将根据产品标准字段默认值返回产品。
- en: In REST, you implemented the controller class in the *Implementing the OAS code
    interfaces* section of [*Chapter 3*](B19349_03.xhtml#_idTextAnchor080), *API Specifications
    and Implementation*. You created a controller, passed the call to the service,
    and the service called the repository to fetch the data from the database. You
    are going to use the same design. However, you are going to use `ConcurrentHashMap`
    in place of the database to simplify the code. This can also be used in your automated
    tests.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在REST中，您在[*第3章*](B19349_03.xhtml#_idTextAnchor080)的*实现OAS代码接口*部分实现了控制器类，*API规范和实现*。您创建了一个控制器，将调用传递给服务，然后服务调用存储库从数据库中获取数据。您将使用相同的设计。但是，您将使用`ConcurrentHashMap`代替数据库以简化代码。这也可以用于您的自动化测试。
- en: 'Let’s create a repository class for that, as shown in the next code block:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个存储库类，如下一个代码块所示：
- en: '[PRE11]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '[https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/dev/Chapter14/src/main/java/com/packt/modern/api/repository/Repository.java](https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/dev/Chapter14/src/main/java/com/packt/modern/api/repository/Repository.java)'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/dev/Chapter14/src/main/java/com/packt/modern/api/repository/Repository.java](https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/dev/Chapter14/src/main/java/com/packt/modern/api/repository/Repository.java)'
- en: These are straightforward signatures for fetching the product and collection
    of products.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是用于获取产品和产品集合的简单签名。
- en: 'Let’s implement the newly created repository interface using `ConcurrentHashMap`,
    as shown in the next code block:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用`ConcurrentHashMap`实现新创建的存储库接口，如下一个代码块所示：
- en: '[PRE12]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '[https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/dev/Chapter14/src/main/java/com/packt/modern/api/repository/InMemRepository.java](https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/dev/Chapter14/src/main/java/com/packt/modern/api/repository/InMemRepository.java)'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/dev/Chapter14/src/main/java/com/packt/modern/api/repository/InMemRepository.java](https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/dev/Chapter14/src/main/java/com/packt/modern/api/repository/InMemRepository.java)'
- en: 'Here, you have created two instances of `ConcurrentHashMap` for storing the
    products and tags. Let’s add the seed data to these maps using the constructor:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，您已经创建了两个`ConcurrentHashMap`实例来存储产品和标签。让我们使用构造函数将这些种子数据添加到这些映射中：
- en: '[PRE13]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This code first generates the tags and then stores them in the `tagEntities`
    map. The code also attaches the tags to new products before storing products in
    the `productEntities` map. This has been done for development purposes only. You
    should use the database in production applications.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码首先生成标签，然后将其存储在`tagEntities`映射中。代码还在将产品存储在`productEntities`映射之前将标签附加到新产品上。这只是为了开发目的而做的。在生产应用程序中，您应该使用数据库。
- en: 'Now, the `getProduct` and `getProducts` methods are straightforward, as shown
    in the next code block:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，`getProduct`和`getProducts`方法很简单，如下一个代码块所示：
- en: '[PRE14]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The `getProduct` method performs the basic validations and returns the product.
    The `getProducts` method simply returns the collection of products converted from
    the map.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '`getProduct`方法执行基本验证并返回产品。`getProducts`方法简单地返回从映射转换的产品集合。'
- en: 'Now, you can add the service and its implementation. Let’s add the service
    interface as shown in the next code block:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您可以添加服务和其实现。让我们添加下一个代码块中显示的服务接口：
- en: '[PRE15]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '[https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/dev/Chapter14/src/main/java/com/packt/modern/api/services/ProductService.java](https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/dev/Chapter14/src/main/java/com/packt/modern/api/services/ProductService.java)'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/dev/Chapter14/src/main/java/com/packt/modern/api/services/ProductService.java](https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/dev/Chapter14/src/main/java/com/packt/modern/api/services/ProductService.java)'
- en: 'These service method implementations simply call the repository to fetch the
    data. Let’s add the implementation shown in the next code block:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 这些服务方法实现只是简单地调用存储库来获取数据。让我们添加下一个代码块中显示的实现：
- en: '[PRE16]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '[https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/dev/Chapter14/src/main/java/com/packt/modern/api/services/ProductServiceImpl.java](https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/dev/Chapter14/src/main/java/com/packt/modern/api/services/ProductServiceImpl.java)'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/dev/Chapter14/src/main/java/com/packt/modern/api/services/ProductServiceImpl.java](https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/dev/Chapter14/src/main/java/com/packt/modern/api/services/ProductServiceImpl.java)'
- en: Here, the repository is injected using constructor injection.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，使用构造函数注入将存储库注入。
- en: 'Let’s add the `getProducts()` method also, which performs filtering based on
    given filtering criteria, as shown in the next code block:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们添加`getProducts()`方法，它根据给定的过滤条件执行过滤，如下一个代码块所示：
- en: '[PRE17]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This method first checks whether criteria are given or not. If criteria are
    not given, then it calls the repository and returns all the products.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法首先检查是否提供了条件。如果没有提供条件，则调用存储库并返回所有产品。
- en: If criteria are given, then it creates the `predicates` list. These `predicates`
    are then used to filter out the matching products and return to the calling function.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 如果提供了条件，它将创建`predicates`列表。然后，这些`predicates`被用来过滤匹配的产品并返回给调用函数。
- en: 'Now comes the most critical piece of GraphQL query implementation: writing
    the data fetchers. First, let’s write the data fetcher for the `product` query.'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是GraphQL查询实现中最关键的部分：编写数据检索器。首先，让我们编写`product`查询的数据检索器。
- en: Writing fetchers for GraphQL queries
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 编写GraphQL查询的检索器
- en: You are going to write data fetchers in this section. Data fetchers, as the
    name suggests, retrieve the information from the source that is from a persistent
    store such as a database or a third-party API/document store. You will learn how
    to write data fetchers to retrieve a single field of data, a single object, and
    a collection of objects.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 您将在本节中编写数据检索器。数据检索器，如名称所示，从持久存储源检索信息，例如数据库或第三方API/文档存储。您将学习如何编写数据检索器以检索单个字段的数据、单个对象和对象集合。
- en: Writing the data fetcher for product
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 编写产品的数据检索器
- en: The data fetcher is a critical DSG component for serving GraphQL requests that
    fetches the data and the DSG internally resolves each of the fields. You mark
    them with the special `@DgsComponent` DGS annotation. These are types of Spring
    components that the DGS framework scans and uses for serving requests.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 数据获取器是服务 GraphQL 请求的关键 DSG 组件，它获取数据，DSG 内部解析每个字段。您使用特殊的 `@DgsComponent` DGS
    注解标记它们。这些是 DGS 框架扫描并用于服务请求的 Spring 组件类型。
- en: 'Let’s create a new file called `ProductDatafetcher.java` in the `datafetchers`
    package to represent a DGS data fetcher component. It will have a data fetcher
    method for serving the `product` query. You can add the following code to it:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在 `datafetchers` 包中创建一个名为 `ProductDatafetcher.java` 的新文件，以表示 DGS 数据获取器组件。它将有一个用于服务
    `product` 查询的数据获取器方法。您可以将以下代码添加到其中：
- en: '[PRE18]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '[https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/dev/Chapter14/src/main/java/com/packt/modern/api/datafetchers/ProductDatafetcher.java](https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/dev/Chapter14/src/main/java/com/packt/modern/api/datafetchers/ProductDatafetcher.java)'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/dev/Chapter14/src/main/java/com/packt/modern/api/datafetchers/ProductDatafetcher.java](https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/dev/Chapter14/src/main/java/com/packt/modern/api/datafetchers/ProductDatafetcher.java)'
- en: Here, you create a product service bean injection using the constructor. This
    service bean helps you to find the product based on the given product ID.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，您使用构造函数创建了一个产品服务 bean 注入。此服务 bean 帮助您根据给定的产品 ID 查找产品。
- en: 'Two other important DGS framework annotations have been used in the `getProduct`
    method. Let’s understand what they do:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `getProduct` 方法中使用了两个其他重要的 DGS 框架注解。让我们了解它们的作用：
- en: '`@DgsData`: This is a data fetcher annotation that marks the method as the
    data fetcher. The `parentType` property represents the type, and the `field` property
    represents the type’s (`parentType`) field. Therefore, you can say that method
    will fetch the field of the given type.'
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@DgsData`：这是一个数据获取器注解，将方法标记为数据获取器。`parentType` 属性表示类型，`field` 属性表示类型（`parentType`）的字段。因此，可以说该方法将获取给定类型的字段。'
- en: You have set `Query` as `parentType`. The `field` property is set as a `product`
    query. Therefore, this method works as an entry point for the GraphQL query product
    call. The `@DsgData` annotation properties are set using the `DgsConstants` constants
    class.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 您已将 `Query` 设置为 `parentType`。`field` 属性被设置为 `product` 查询。因此，此方法作为 GraphQL 查询产品调用的入口点。`@DsgData`
    注解属性使用 `DgsConstants` 常量类设置。
- en: '`DgsConstants` is generated by the DGS Gradle plugin, which contains all the
    constant parts of the schema.'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '`DgsConstants` 由 DGS Gradle 插件生成，它包含模式的所有常量部分。'
- en: '`@InputArgument`: This annotation allows you to capture the arguments passed
    by the GraphQL requests. Here, the value of the `id` parameter is captured and
    assigned to the `id` string variable.'
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@InputArgument`：此注解允许您捕获 GraphQL 请求传递的参数。在此，`id` 参数的值被捕获并分配给 `id` 字符串变量。'
- en: You can find the test cases related to this data fetcher method in the *Test*
    *automation* section.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在 *测试* *自动化* 部分找到与此数据获取器方法相关的测试用例。
- en: Similarly, you can write the data fetcher method for the `products` query. Let’s
    code it in the next subsection.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，您可以编写 `products` 查询的数据获取器方法。让我们在下一个小节中编写它。
- en: Writing the data fetcher for a collection of products
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 编写产品集合的数据获取器
- en: 'Let’s create a new file called `ProductsDatafetcher.java` in the `datafetchers`
    package to represent a DGS data fetcher component. It will have a data fetcher
    method for serving the `products` query. You can add the following code to it:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在 `datafetchers` 包中创建一个名为 `ProductsDatafetcher.java` 的新文件，以表示 DGS 数据获取器组件。它将有一个用于服务
    `products` 查询的数据获取器方法。您可以将以下代码添加到其中：
- en: '[PRE19]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '[https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/dev/Chapter14/src/main/java/com/packt/modern/api/datafetchers/ProductsDatafetcher.java](https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/dev/Chapter14/src/main/java/com/packt/modern/api/datafetchers/ProductsDatafetcher.java)'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/dev/Chapter14/src/main/java/com/packt/modern/api/datafetchers/ProductsDatafetcher.java](https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/dev/Chapter14/src/main/java/com/packt/modern/api/datafetchers/ProductsDatafetcher.java)'
- en: This `getProducts()` method does not look different from the data fetcher method
    returned for `getProduct()` in the second-to-last code block. Here, the `parentType`
    and `field` properties of `@DsgData` indicate that this method will be used to
    fetch the collection of products for the `products` query (note that we are using
    the plural form here).
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 `getProducts()` 方法看起来与为 `getProduct()` 返回的数据获取方法没有区别，它在倒数第二个代码块中。在这里，`@DsgData`
    的 `parentType` 和 `field` 属性表明这个方法将用于获取 `products` 查询的产品集合（注意我们在这里使用的是复数形式）。
- en: 'You are done with the GraphQL query implementation. You can now test your changes.
    You need to build the application before running the test. Let’s build the application
    using the following command:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 您已经完成了 GraphQL 查询的实现。现在您可以测试您的更改了。在运行测试之前，您需要构建应用程序。让我们使用以下命令来构建应用程序：
- en: '[PRE20]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Once the build is done successfully, you can run the following command to run
    the application:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦构建成功，您可以使用以下命令来运行应用程序：
- en: '[PRE21]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The application should be running on the default port `8080` if you have not
    made any changes to the port settings.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您没有对端口号进行任何更改，应用程序应该运行在默认端口 `8080`。
- en: 'Now, you can open a browser window and open GraphiQL using the following URL:
    `http://localhost:8080/graphiql` (part of the DGS framework). Change the host/port
    accordingly if required.'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您可以在浏览器窗口中打开 GraphiQL，使用以下 URL：`http://localhost:8080/graphiql`（DGS 框架的一部分）。如有必要，请相应地更改主机/端口。
- en: 'You can use the following query to fetch the collection of products:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用以下查询来获取产品集合：
- en: '[PRE22]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Once you run the preceding query, it will fetch the products matching the given
    criteria in the filter.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦运行前面的查询，它将获取与过滤器中给定标准匹配的产品。
- en: '![Figure 14.2 – GraphQL query execution in the GraphiQL tool](img/Figure_14.2_B19349.jpg)'
  id: totrans-198
  prefs: []
  type: TYPE_IMG
  zh: '![图 14.2 – 在 GraphiQL 工具中执行 GraphQL 查询](img/Figure_14.2_B19349.jpg)'
- en: Figure 14.2 – GraphQL query execution in the GraphiQL tool
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.2 – 在 GraphiQL 工具中执行 GraphQL 查询
- en: This will work great. However, what if you want to fetch the tags separately?
    You might have relations (such as orders with billing information) in objects
    that may be fetched from separate databases or services, or from two separate
    tables. In that case, you might want to add a field resolver using the data fetcher
    method.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 这将工作得很好。但是，如果您想单独获取标签呢？对象中可能存在关系（例如带有账单信息的订单），这些关系可能来自不同的数据库或服务，或者来自两个不同的表。在这种情况下，您可能想添加一个字段解析器，使用数据获取方法。
- en: Let’s add a field resolver using the data fetcher method in the next subsection.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在下一小节中添加一个字段解析器，使用数据获取方法。
- en: Writing the field resolver using the data fetcher method
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 使用数据获取方法编写字段解析器
- en: So far, you don’t have a separate data fetcher for fetching the tags. You fetch
    the products, and it also fetches the tags for you because we are using a concurrent
    map that stores both queries’ data together. Therefore, first, you need to write
    a new data fetcher method for fetching the tags for a given product.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，您还没有为获取标签单独的数据获取器。您获取产品，它也会为您获取标签，因为我们使用了一个并发映射，它一起存储了两个查询的数据。因此，首先，您需要为给定产品编写一个新的数据获取方法来获取标签。
- en: 'Let’s add the `tags()` method to the `ProductsDatafetcher` class to fetch the
    tags, as shown in the next code block:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在 `ProductsDatafetcher` 类中添加 `tags()` 方法来获取标签，如下一个代码块所示：
- en: '[PRE23]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '[https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/dev/Chapter14/src/main/java/com/packt/modern/api/datafetchers/ProductsDatafetcher.java](https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/dev/Chapter14/src/main/java/com/packt/modern/api/datafetchers/ProductsDatafetcher.java)'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/dev/Chapter14/src/main/java/com/packt/modern/api/datafetchers/ProductsDatafetcher.java](https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/dev/Chapter14/src/main/java/com/packt/modern/api/datafetchers/ProductsDatafetcher.java)'
- en: Here, the `tags()` method has a different set of values for the `@DsgData` properties.
    The `parentType` property is not set to a root type like in earlier data fetcher
    methods, which were set to `Query`. Instead, it is set to an object type – `Product`.
    The `field` property is set to `tags`.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`tags()` 方法对于 `@DsgData` 属性有一组不同的值。`parentType` 属性没有设置为像早期数据获取方法中那样的根类型，例如设置为
    `Query`。相反，它被设置为对象类型 – `Product`。`field` 属性被设置为 `tags`。
- en: This method will be called for fetching the tags for each individual product
    because it is a field resolver for the `tags` field of the `Product` object. Therefore,
    if you have 20 products, this method will be called 20 times to fetch the tags
    for each of the 20 products. This is an *N+1* problem, which we learned about
    in the *Solving the N+1 problem* section in [*Chapter 13*](B19349_13.xhtml#_idTextAnchor288),
    *Getting Started* *with GraphQL*.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方法将被调用以获取每个单独产品的标签，因为它是 `Product` 对象的 `tags` 字段的字段解析器。因此，如果你有 20 个产品，这个方法将被调用
    20 次以获取 20 个产品的标签。这是一个 *N+1* 问题，我们在 [*第 13 章*](B19349_13.xhtml#_idTextAnchor288)
    的 *Solving the N+1 problem* 节中学习了，*GraphQL 入门*。
- en: In the N+1 problem, extra database calls are made for fetching the data for
    relations. Therefore, given a collection of products, it may hit a database for
    fetching the tags for each product separately.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 在 N+1 问题中，为了获取关系数据，会进行额外的数据库调用。因此，给定一个产品集合，它可能需要单独为每个产品查询标签而访问数据库。
- en: You know that you must use data loaders to avoid the N+1 problem. Data loaders
    cache all the IDs of products before fetching their corresponding tags in a single
    query.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 你知道你必须使用数据加载器来避免 N+1 问题。数据加载器在执行单个查询之前会缓存所有产品的 ID，然后获取它们对应的标签。
- en: Next, let’s learn how to implement a data loader for fixing the N+1 problem
    in this case.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们学习如何实现一个数据加载器来解决此情况中的 N+1 问题。
- en: Writing a data loader for solving the N+1 problem
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 编写数据加载器以解决 N+1 问题
- en: You are going to make use of the `DataFetchingEnvironment` class as an argument
    in the data fetcher methods. It is injected by the `graphql-java` library in the
    data fetcher methods to provide the execution context. This execution context
    contains information about the resolver, such as the object and its fields. You
    can also use them in special use cases such as loading the data loader classes.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 你将使用 `DataFetchingEnvironment` 类作为数据获取方法中的参数。它由 `graphql-java` 库注入到数据获取方法中，以提供执行上下文。这个执行上下文包含有关解析器的信息，例如对象及其字段。你还可以在特殊用例中使用它们，例如加载数据加载器类。
- en: 'Let’s modify the `tags()` method in the `ProductsDatafetcher` class mentioned
    in the previous code block to fetch the tags without the N+1 problem, as shown
    in the next code block:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们修改前面代码块中提到的 `ProductsDatafetcher` 类中的 `tags()` 方法，以无 N+1 问题地获取标签，如下一个代码块所示：
- en: '[PRE24]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '[https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/dev/Chapter14/src/main/java/com/packt/modern/api/datafetchers/ProductsDatafetcher.java](https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/dev/Chapter14/src/main/java/com/packt/modern/api/datafetchers/ProductsDatafetcher.java)'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/dev/Chapter14/src/main/java/com/packt/modern/api/datafetchers/ProductsDatafetcher.java](https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/dev/Chapter14/src/main/java/com/packt/modern/api/datafetchers/ProductsDatafetcher.java)'
- en: Here, the modified `tags()` data fetcher method performs the `fetch` method
    using a data loader and returns the collection of tags wrapped inside `CompletableFuture`.
    And it will be called only once even if the number of products is more than *1*.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，修改后的 `tags()` 数据获取方法使用数据加载器执行 `fetch` 方法，并返回包含在 `CompletableFuture` 中的标签集合。即使产品数量超过
    *1*，它也只会被调用一次。
- en: What is CompletableFuture?
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 什么是 CompletableFuture？
- en: '`CompletableFuture` is a Java concurrency class that represents the result
    of asynchronous computation, which is marked as completed explicitly. It can chain
    multiple dependent tasks asynchronously where the next task will be triggered
    when the current task’s result is available.'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: '`CompletableFuture` 是一个表示异步计算结果的 Java 并发类，其完成状态是显式标记的。它可以异步地链式执行多个依赖任务，当当前任务的结果可用时，下一个任务将被触发。'
- en: You are using `DsgDataFetchingEnvironment` as an argument. It implements the
    `DataFetchingEnvironment` interface and provides ways to load the data loader
    class by both its class and name. Here, you are using the data loader class to
    load the data loader.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 你正在使用 `DsgDataFetchingEnvironment` 作为参数。它实现了 `DataFetchingEnvironment` 接口，并提供通过其类和名称加载数据加载器类的方法。在这里，你正在使用数据加载器类来加载数据加载器。
- en: The `getSource()` method of `DsgDataFetchingEnvironment` returns the value from
    the `parentType` property of `@DsgData`. Therefore, `getSource()` returns `Product`.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '`DsgDataFetchingEnvironment` 的 `getSource()` 方法返回 `@DsgData` 的 `parentType`
    属性的值。因此，`getSource()` 返回 `Product`。'
- en: This modified data fetcher method will fetch the tags for a given list of products
    in a single call. This method will fetch the tags for a list of products because
    the data loader class implements `MappedBatchLoader`, which performs the operation
    using batches.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 此修改后的数据获取方法将单次调用中获取给定产品列表的标签。此方法将获取产品列表的标签，因为数据加载器类实现了`MappedBatchLoader`，它使用批处理执行操作。
- en: The data loader class fetches the tags of the given product (by ID) using the
    data loader in batches. The magic lies in returning `CompletableFuture`. Therefore,
    though you are passing a single product ID as an argument, the data loader processes
    it in bunches. Let’s implement this data loader class (`TagsDataloaderWithContext`)
    next to dig into it more.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 数据加载器类使用批处理方式获取给定产品（通过ID）的标签。这里的魔法在于返回`CompletableFuture`。因此，尽管你只传递了一个产品ID作为参数，但数据加载器以批量方式处理它。让我们接下来实现这个数据加载器类（`TagsDataloaderWithContext`），以便更深入地了解它。
- en: 'You can create a data loader class in two ways – with context or without context.
    Data loaders without context implement `MappedBatchLoader`, which has the following
    method signature:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过两种方式创建数据加载器类——带有上下文或不带有上下文。没有上下文的数据加载器实现了`MappedBatchLoader`，它具有以下方法签名：
- en: '[PRE25]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'On the other hand, data loaders with context implement the `MappedBatchLoaderWithContext`
    interface, which has the following method signature:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，具有上下文的数据加载器实现了`MappedBatchLoaderWithContext`接口，该接口具有以下方法签名：
- en: '[PRE26]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Both are the same as far as data loading is concerned. However, the data loader
    with context provides you with extra information (through `BatchLoaderEnvironment`)
    that can be used for various additional features, such as authentication, authorization,
    or passing the database details.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 在数据加载方面，两者是相同的。然而，具有上下文的数据加载器为你提供了额外的信息（通过`BatchLoaderEnvironment`），这些信息可用于各种附加功能，如身份验证、授权或传递数据库详细信息。
- en: 'Create a new Java file called `TagsDataloaderWithContext.java` in the `dataloaders`
    package with the following code:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 在`dataloaders`包中创建一个名为`TagsDataloaderWithContext.java`的新Java文件，并包含以下代码：
- en: '[PRE27]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '[https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/dev/Chapter14/src/main/java/com/packt/modern/api/dataloaders/TagsDataloaderWithContext.java](https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/dev/Chapter14/src/main/java/com/packt/modern/api/dataloaders/TagsDataloaderWithContext.java)'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/dev/Chapter14/src/main/java/com/packt/modern/api/dataloaders/TagsDataloaderWithContext.java](https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/dev/Chapter14/src/main/java/com/packt/modern/api/dataloaders/TagsDataloaderWithContext.java)'
- en: Here, it implements the `load()` method from the `MappedBatchLoaderWithContext`
    interface. It contains the `BatchLoaderEnvironment` argument, which provides the
    environment context, which can contain user authentication and authorization information
    or database information. However, we are not using it because we don’t have any
    additional information related to authentication, authorization, or the database
    to pass to the repository or underlying data access layer. If you do, you can
    make use of the `environment` argument.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，它实现了`MappedBatchLoaderWithContext`接口的`load()`方法。它包含`BatchLoaderEnvironment`参数，该参数提供环境上下文，可以包含用户身份验证和授权信息或数据库信息。然而，我们没有使用它，因为我们没有与身份验证、授权或数据库相关的任何附加信息要传递给存储库或底层数据访问层。如果你有，你可以使用`environment`参数。
- en: You can also find the data loader without context at [https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/dev/Chapter14/src/main/java/com/packt/modern/api/dataloaders/TagDataloader.java](https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/dev/Chapter14/src/main/java/com/packt/modern/api/dataloaders/TagDataloader.java).
    Its code is more or less like what we have written for the data loader with context.
    The only difference is we haven’t used the context.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以在[https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/dev/Chapter14/src/main/java/com/packt/modern/api/dataloaders/TagDataloader.java](https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/dev/Chapter14/src/main/java/com/packt/modern/api/dataloaders/TagDataloader.java)中找到没有上下文的数据加载器。其代码与我们所写的具有上下文的数据加载器代码大致相同。唯一的区别是我们没有使用上下文。
- en: You can see that it makes use of the tag’s service to fetch the tags. Then,
    it simply returns the completion stage by supplying the tags received from the
    tag service. This operation is performed in a batch by the data loader.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到它使用了标签服务来获取标签。然后，它简单地通过提供从标签服务收到的标签来返回完成阶段。此操作由数据加载器批量执行。
- en: 'You can create a new tag service and its implementation as follows:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以创建一个新的标签服务及其实现，如下所示：
- en: '[PRE28]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '[https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/dev/Chapter14/src/main/java/com/packt/modern/api/services/TagService.java](https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/dev/Chapter14/src/main/java/com/packt/modern/api/services/TagService.java)'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/dev/Chapter14/src/main/java/com/packt/modern/api/repository/Repository.java](https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/dev/Chapter14/src/main/java/com/packt/modern/api/repository/Repository.java)'
- en: This is the signature of the `getTags` method, which returns the map of product
    IDs with corresponding tags.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 这是`getTags`方法的签名，它返回产品ID与对应标签的映射。
- en: 'Let’s implement this interface as shown in the next code block:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们按照以下代码块实现此接口：
- en: '[PRE29]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '[https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/dev/Chapter14/src/main/java/com/packt/modern/api/services/TagServiceImpl.java](https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/dev/Chapter14/src/main/java/com/packt/modern/api/services/TagServiceImpl.java)'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/dev/Chapter14/src/main/java/com/packt/modern/api/repository/InMemRepository.java](https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/dev/Chapter14/src/main/java/com/packt/modern/api/repository/InMemRepository.java)'
- en: Here, the implemented method is straightforward. It passes the call to the repository,
    which fetches the tags based on the passed collection of product IDs.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，实现的方法很简单。它将调用传递给存储库的调用，根据传递的产品ID集合获取标签。
- en: 'You can add `getProductTagMappings` to the `src/main/java/com/packt/ modern/api/repository/Repository.java`
    interface as shown in the next line:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将`getProductTagMappings`添加到`src/main/java/com/packt/modern/api/repository/Repository.java`接口中，如下所示：
- en: '[PRE30]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Then, you can implement this method in the `src/main/java/com/packt/ modern/api/repository/InMemRepository.java`
    class as shown in the next code block:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你可以在`src/main/java/com/packt/modern/api/repository/InMemRepository.java`类中实现此方法，如下所示：
- en: '[PRE31]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Here, the code first creates the stream of the product map’s entry set, then
    filters the products that match the product passed in this method. At the end,
    it converts filtered products to map the product ID with the `Key` and `Tags`
    values and then returns `map`.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，代码首先创建了产品映射集合的流，然后过滤出与通过此方法传入的产品匹配的产品。最后，它将过滤后的产品转换为以`Key`和`Tags`值为键的产品ID映射，然后返回`map`。
- en: Now, if you call the `product` GraphQL query, and even if products are fetched
    with a properly normalized database, it loads the product tags in batches without
    the *N+1* problem.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果你调用`product` GraphQL查询，即使产品是通过正确归一化的数据库获取的，它也会批量加载产品标签，而不存在*N+1*问题。
- en: You are done with GraphQL query implementation and should be comfortable with
    implementing queries on your own.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经完成了GraphQL查询的实现，并且应该能够独立实现查询。
- en: Next, you are going to implement GraphQL mutations.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你将实现GraphQL变异操作。
- en: Implementing GraphQL mutations
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 实现GraphQL变异操作
- en: As per the GraphQL schema, you are going to implement two mutations – `addTag`
    and `addQuantity`.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 根据GraphQL模式，你将实现两个变异操作 - `addTag`和`addQuantity`。
- en: The `addTag` mutation takes `productId` and a collection of tags as arguments
    and returns the `Product` object. The `addQuantity` mutation takes `productId`
    and the quantity to add and returns `Product`.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: '`addTag`变异操作接受`productId`和一组标签作为参数，并返回`Product`对象。`addQuantity`变异操作接受`productId`和要添加的数量，并返回`Product`。'
- en: 'Let’s add this implementation to the existing `ProductDatafetcher` class as
    shown in the following code block:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将此实现添加到现有的`ProductDatafetcher`类中，如下所示：
- en: '[PRE32]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '[https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/dev/Chapter14/src/main/java/com/packt/modern/api/datafetchers/ProductsDatafetcher.java](https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/dev/Chapter14/src/main/java/com/packt/modern/api/datafetchers/ProductsDatafetcher.java)'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/dev/Chapter14/src/main/java/com/packt/modern/api/datafetchers/ProductsDatafetcher.java](https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/dev/Chapter14/src/main/java/com/packt/modern/api/datafetchers/ProductsDatafetcher.java)'
- en: Here, these signatures follow the respective mutations written in the GraphQL
    schema. You are using another DGS framework `@DgsMutation` annotation, which is
    a type of `@DgsData` annotation that is marked on methods to denote them as a
    data fetcher method. The `@DgsMutation` annotation, by default, has the `Mutation`
    value set to the `parentType` property. You just must set the `field` property
    in this annotation. Both methods have their respective values set to the `field`
    property in the `@``DgsMutation` annotation.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，这些签名遵循GraphQL模式中编写的相应突变（mutations）。您正在使用另一个DGS框架`@DgsMutation`注解，这是一种标记在方法上以表示它们为数据获取方法（data
    fetcher method）的`@DgsData`注解。默认情况下，`@DgsMutation`注解将`Mutation`值设置为`parentType`属性。您只需在此注解中设置`field`属性。两个方法都有其各自的值设置为`@DgsMutation`注解中的`field`属性。
- en: Notice that the `@InputArgument` annotation for tags uses another `collectionType`
    property that is used for setting the type of input. It is required when the input
    type is not scalar. If you don’t use it, you’ll get an error. Therefore, make
    sure to use the `collectionType` property whenever you have a non-scalar type
    input.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，用于标签的`@InputArgument`注解使用另一个`collectionType`属性，该属性用于设置输入类型。当输入类型不是标量（scalar）时，它是必需的。如果不使用它，您将得到一个错误。因此，确保在具有非标量类型输入时始终使用`collectionType`属性。
- en: 'These methods use the tag and product services to perform the requested operations.
    So far, you have not added the tag service into the `ProductDatafetcher` class.
    Therefore, you need to add `TagService` first, as shown in the next code block:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 这些方法使用标签和产品服务来执行请求的操作。到目前为止，您还没有将标签服务添加到`ProductDatafetcher`类中。因此，您需要首先添加`TagService`，如下面的代码块所示：
- en: '[PRE33]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Here, the `TagService` bean has been injected using the constructor.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`TagService`豆（bean）已经通过构造函数注入。
- en: Now, you need to implement the `addTag()` method in the `TagService` and `addQuantity`
    methods in `ProductService`. Both the interfaces and their implementations are
    straightforward and pass the call to the repository to perform the operations.
    You can find the complete source code `TagService` and `ProductService` classes
    in the GitHub code repository ([https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/dev/Chapter14/src/main/java/com/packt/modern/api/services](https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/dev/Chapter14/src/main/java/com/packt/modern/api/services)).
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您需要在`TagService`中实现`addTag()`方法，在`ProductService`中实现`addQuantity`方法。这两个接口及其实现都很直接，将调用传递给仓库以执行操作。您可以在GitHub代码仓库中找到`TagService`和`ProductService`类的完整源代码（[https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/dev/Chapter14/src/main/java/com/packt/modern/api/services](https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/dev/Chapter14/src/main/java/com/packt/modern/api/services)）。
- en: 'Let’s also add these two methods to the `Repository` interface as shown in
    the next code block:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们也将这两个方法添加到`Repository`接口中，如下面的代码块所示：
- en: '[PRE34]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: These signatures in the `src/main/java/com/packt/modern/api/repository /Repository.java`
    interface also follow the respective mutations written in the GraphQL schema.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: '`src/main/java/com/packt/modern/api/repository/Repository.java`接口中的这些签名也遵循GraphQL模式中编写的相应突变。'
- en: 'Let’s implement the `addTags()` method first in the `src/main/java/com/packt/
    modern/api/repository/InMemRepository.java` class, as shown in the next code block:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先在`src/main/java/com/packt/modern/api/repository/InMemRepository.java`类中实现`addTags()`方法，如下面的代码块所示：
- en: '[PRE35]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '[https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/dev/Chapter14/src/main/java/com/packt/modern/api/repository/InMemRepository.java](https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/dev/Chapter14/src/main/java/com/packt/modern/api/repository/InMemRepository.java)'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/dev/Chapter14/src/main/java/com/packt/modern/api/repository/InMemRepository.java](https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/dev/Chapter14/src/main/java/com/packt/modern/api/repository/InMemRepository.java)'
- en: Here, you first perform the validation for the `productId` and `tags` arguments.
    If everything goes fine, then you add the tags to the product, update the concurrent
    map, and return the updated product.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你首先对`productId`和`tags`参数进行验证。如果一切顺利，那么你将标签添加到产品中，更新并发映射，并返回更新后的产品。
- en: 'You are done with the implementation of GraphQL mutations. You can now test
    your changes. You need to build the application before running the test. Let’s
    build the application using the following command:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经完成了GraphQL突变的实现。你现在可以测试你的更改了。在运行测试之前，你需要构建应用程序。让我们使用以下命令来构建应用程序：
- en: '[PRE36]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Once the build is done successfully, you can run the following command to run
    the application:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦构建成功，你可以运行以下命令来运行应用程序：
- en: '[PRE37]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: The application should be running on default port `8080` if you have not made
    any changes to the port settings.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你没有对端口号进行任何更改，应用程序应该运行在默认端口`8080`。
- en: 'Now, you can open a browser window and open *GraphiQL* using the following
    URL: [http://localhost:8080/graphiql](http://localhost:8080/graphiql) (part of
    the DGS framework). Change the host/port accordingly if required.'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以打开一个浏览器窗口，使用以下URL打开*GraphiQL*：[http://localhost:8080/graphiql](http://localhost:8080/graphiql)（DGS框架的一部分）。如果需要，相应地更改主机/端口。
- en: 'You can use the following GraphQL request to perform the `addTag` mutation:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用以下GraphQL请求来执行`addTag`突变：
- en: '[PRE38]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Here, you are adding the tags to the given `productId`; therefore, you pass
    `productId` and `tags` as arguments. You can use the following GraphQL request
    to perform the `addQuantity` mutation:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你正在给给定的`productId`添加标签；因此，你需要将`productId`和`tags`作为参数传递。你可以使用以下GraphQL请求来执行`addQuantity`突变：
- en: '[PRE39]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Here, you pass `productId` and `quantity` as arguments. You have learned how
    to implement GraphQL mutations in the GraphQL server. Let’s implement GraphQL
    subscriptions in the next section.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你将`productId`和`quantity`作为参数传递。你已经学会了如何在GraphQL服务器中实现GraphQL突变。让我们在下一节中实现GraphQL订阅。
- en: Implementing and testing GraphQL subscriptions
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 实现和测试GraphQL订阅
- en: Subscription is another GraphQL root type that sends the object to the subscriber
    (client) when a particular event occurs.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 订阅是另一个GraphQL根类型，当特定事件发生时，它会向订阅者（客户端）发送对象。
- en: Let’s assume an online shop offers a discount on products when the product’s
    inventory reaches a certain level. You cannot track each product’s quantity manually
    and then perform the computation and trigger the discount. To do things faster
    (or reduce manual intervention), this is where you can make use of a subscription.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 假设一个在线商店在产品的库存达到一定水平时对产品提供折扣。你不能手动跟踪每个产品的数量，然后进行计算并触发折扣。为了更快地完成这些事情（或减少人工干预），这就是你可以使用订阅的地方。
- en: Each change in the product’s inventory (quantity) through the `addQuantity()`
    mutation should trigger the event and the subscriber should receive the updated
    product and hence the quantity. Then, the subscriber can place the logic and automate
    this process.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 通过`addQuantity()`突变对产品库存（数量）的每次更改都应触发事件，并且订阅者应接收到更新后的产品以及数量。然后，订阅者可以放置逻辑并自动化这个过程。
- en: Let’s write the subscription that will send the updated product object to the
    subscriber. You are going to use Reactive Streams and WebSocket to implement this
    functionality.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们编写一个订阅，它将发送更新后的产品对象给订阅者。你将使用响应式流和WebSocket来实现这个功能。
- en: 'You need to enable CORS. Let’s enable it by adding the following properties
    into the `application.properties` file:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要启用CORS。让我们通过在`application.properties`文件中添加以下属性来启用它：
- en: '[PRE40]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '[https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/dev/Chapter14/src/main/resources/application.properties](https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/dev/Chapter14/src/main/resources/application.properties)'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/dev/Chapter14/src/main/resources/application.properties](https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/dev/Chapter14/src/main/resources/application.properties)'
- en: Here, you have also enabled the actuator metrics and tracing for GraphQL along
    with exposing the health and metrics actuator endpoints.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你还将GraphQL的actuator指标和跟踪启用，并公开健康和指标actuator端点。
- en: In `build.gradle`, you have `graphql-dgs-subscriptions-websockets-autoconfigure`
    to take care of the auto-configuration of WebSocket that is required for WebSocket-based
    GraphQL subscriptions.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 在`build.gradle`中，你有`graphql-dgs-subscriptions-websockets-autoconfigure`来自动配置WebSocket，这对于基于WebSocket的GraphQL订阅是必需的。
- en: 'You can add the following subscription data fetcher to the `ProductDatafetcher`
    class as shown in the following code:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将以下订阅数据获取器添加到`ProductDatafetcher`类中，如下面的代码所示：
- en: '[PRE41]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '[https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/dev/Chapter14/src/main/java/com/packt/modern/api/datafetchers/ProductDatafetcher.java](https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/dev/Chapter14/src/main/java/com/packt/modern/api/datafetchers/ProductDatafetcher.java)'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/dev/Chapter14/src/main/java/com/packt/modern/api/datafetchers/ProductDatafetcher.java](https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/dev/Chapter14/src/main/java/com/packt/modern/api/datafetchers/ProductDatafetcher.java)'
- en: Here, you are using another DGS framework annotation, `@DgsSubscription`, which
    is a type of `@DgsData` annotation that is marked on a method to denote it as
    a data fetcher method. The `@DgsSubscription` annotation, by default, has the
    `Subscription` value set to the `parentType` property. You just must set the `field`
    property in this annotation. By setting `field` to `quantityChanged`, you are
    indicating to the DGS framework to use this method when the subscription request
    for `quantityChanged` is called.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，你正在使用另一个DGS框架注解`@DgsSubscription`，它是一种标记在方法上的`@DgsData`注解，表示它是一个数据获取方法。默认情况下，`@DgsSubscription`注解将`Subscription`值设置为`parentType`属性。你只需在此注解中设置`field`属性。通过将`field`设置为`quantityChanged`，你正在指示DGS框架在调用`quantityChanged`订阅请求时使用此方法。
- en: The `Subscription` method returns the `Publisher` instance, which can send an
    unbound number of objects (in this case, `Product` instances) to multiple subscribers.
    Therefore, the client just needs to subscribe to the product publisher.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: '`Subscription`方法返回`Publisher`实例，它可以向多个订阅者发送未绑定数量的对象（在这种情况下，`Product`实例）。因此，客户端只需订阅产品发布者。'
- en: You need to add a new method to the `ProductService` interface and its implementation
    in the `ProductServiceImpl` class. The method signature in the `ProductService`
    interface and its implementation are straightforward. It passes the call to the
    repository to perform the operation. You can have a look at the source code in
    the book’s GitHub code repository.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要在`ProductService`接口中添加一个新的方法，并在`ProductServiceImpl`类中实现它。`ProductService`接口及其实现的方法签名很简单。它将调用传递给仓库以执行操作。你可以在书中GitHub代码仓库中查看源代码。
- en: 'The actual work is being performed by the repository. Therefore, you need to
    make certain changes in the repository, as shown in the following steps:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 实际工作是由仓库执行的。因此，你需要在仓库中进行一些更改，如下面的步骤所示：
- en: 'First, add the following method signature to the repository interface:'
  id: totrans-298
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，将以下方法签名添加到仓库接口中：
- en: '[PRE42]'
  id: totrans-299
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '2.  Next, you have to implement the `getProductPublisher()` method in the `InMemRepository`
    class. This method returns the product publisher as shown in the following code:'
  id: totrans-300
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 2.  接下来，你必须在`InMemRepository`类中实现`getProductPublisher()`方法。此方法返回产品发布者，如下面的代码所示：
- en: '[PRE43]'
  id: totrans-301
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '3.  Now, we need all the magic to be performed by Reactive Streams. First,
    let’s declare the `FluxSink<Product>` and `ConnectableFlux<Product>` (which is
    returned by the repository) variables:'
  id: totrans-302
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 3.  现在，我们需要Reactive Streams来完成所有魔法。首先，让我们声明`FluxSink<Product>`和`ConnectableFlux<Product>`（由仓库返回）变量：
- en: '[PRE44]'
  id: totrans-303
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Flux<Product> is a product stream publisher that passes the baton to productsStream
    (FluxSink) to emit the next signals followed by onError() or onComplete() events.
    This means productsStream should emit the signal when the product quantity gets
    changed. When Flux<Product> calls the publish() method, it returns an instance
    of connectableFlux, which is assigned to productPublisher (the one that is returned
    by the subscription).
  id: totrans-304
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`Flux<Product>`是一个产品流发布者，它将接力棒传递给`productsStream`（`FluxSink`）以发射下一个信号，随后是`onError()`或`onComplete()`事件。这意味着`productsStream`应该在产品数量发生变化时发射信号。当`Flux<Product>`调用`publish()`方法时，它返回一个`connectableFlux`实例，该实例被分配给`productPublisher`（由订阅返回的那个）。'
- en: '[PRE45]'
  id: totrans-305
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'You are almost done with the setup. You just need to emit the signal (product)
    when the product gets changed. Let’s add the following highlighted line to the
    `addQuantity()` method before it returns the product, as shown in the following
    code:'
  id: totrans-306
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你几乎完成了设置。你只需在产品发生变化时发射信号（产品）。让我们在`addQuantity()`方法返回产品之前添加以下突出显示的行，如下面的代码所示：
- en: '[PRE46]'
  id: totrans-307
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: You have completed the subscription `quantityChanged` implementation. You can
    test it next.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经完成了`quantityChanged`订阅的实现。你可以接下来进行测试。
- en: 'You need to build the application before running the test. Let’s build the
    application using the following command:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行测试之前，您需要构建应用程序。让我们使用以下命令来构建应用程序：
- en: '[PRE47]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Once the build is done successfully, you can run the following command to run
    the application:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦构建成功，您可以使用以下命令来运行应用程序：
- en: '[PRE48]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: The application should be running on the default port `8080` if you have not
    made any changes to the port settings.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您没有更改端口号设置，应用程序应该运行在默认端口 `8080`。
- en: Before testing the GraphQL subscription, you need to understand the GraphQL
    subscription protocol over WebSocket.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 在测试 GraphQL 订阅之前，您需要了解 GraphQL 通过 WebSocket 的订阅协议。
- en: Understanding the WebSocket sub-protocol for GraphQL
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 理解 GraphQL 的 WebSocket 子协议
- en: You have implemented the GraphQL subscription over WebSocket in this chapter.
    In WebSocket-based subscription implementation, the network socket is the main
    communication channel between the GraphQL server and the client.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 您在本章中实现了 GraphQL 通过 WebSocket 的订阅。在基于 WebSocket 的订阅实现中，网络套接字是 GraphQL 服务器和客户端之间的主要通信通道。
- en: The `graphql-dgs-subscriptions-websockets-autoconfigure` dependency’s current
    implementation (*version 6.0.5*) makes use of `graphql-transport-ws` sub-protocol
    specifications. In this sub-protocol, messages are represented using the JSON
    format, and over the network, these JSON messages are *stringified*. Both the
    server and client should conform to this message structure.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: '`graphql-dgs-subscriptions-websockets-autoconfigure` 依赖项的当前实现（*版本 6.0.5*）使用了
    `graphql-transport-ws` 子协议规范。在这个子协议中，消息使用 JSON 格式表示，并且在网络中，这些 JSON 消息被 *stringified*。服务器和客户端都应该符合这种消息结构。'
- en: 'There are the following types of messages (code in Kotlin from the DGS framework):'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 存在以下类型的消息（以下代码来自 DGS 框架的 Kotlin）：
- en: '[PRE49]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'You might have got the idea about the life cycle of a GraphQL subscription
    over WebSocket by looking at the message type. Let’s understand the life cycle
    of a subscription in detail:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 通过查看消息类型，您可能已经对 GraphQL 通过 WebSocket 的订阅生命周期有了了解。让我们详细理解订阅的生命周期：
- en: '`CONNECTION_INIT`): The client initiates the communication by sending this
    type of message. The connection initialization message contains two fields – `type`
    (`''connection_init''`) and `payload`. The `payload` field is an optional field.
    Its (`ConnectionInitMessage`) structure is represented as follows:'
  id: totrans-321
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`CONNECTION_INIT`）：客户端通过发送此类消息来启动通信。连接初始化消息包含两个字段 – `type` （`''connection_init''`）和
    `payload`。`payload` 字段是可选字段。其结构（`ConnectionInitMessage`）表示如下：'
- en: '[PRE50]'
  id: totrans-322
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: '2.  `CONNECTION_ACK`): The server sends the connection acknowledgment in response
    to a successful connection initialization request. It means the server is ready
    for subscription. Its structure (`ConnectionAckMessage`) is represented as follows:'
  id: totrans-323
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 2.  `CONNECTION_ACK`）：服务器在成功初始化连接请求后发送连接确认。这意味着服务器已准备好进行订阅。其结构（`ConnectionAckMessage`）表示如下：
- en: '[PRE51]'
  id: totrans-324
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: '3.  `SUBSCRIBE`): The client now can send the `subscribe` request. If the client
    sends the `subscribe` request without getting a connection acknowledgment from
    the server, the client may get the error `4401: Unauthorized`.'
  id: totrans-325
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '3.  `SUBSCRIBE`）：客户端现在可以发送 `subscribe` 请求。如果客户端在没有从服务器获得连接确认的情况下发送 `subscribe`
    请求，客户端可能会收到错误 `4401: Unauthorized`。'
- en: 'This request contains three fields – `id`, `type`, and `payload`. Here, each
    new subscription request should contain a unique `id`; otherwise, the server may
    throw `4409: Subscriber for <unique-operation-id> already exists`. The server
    keeps track of the `id`, until the subscription is active. The moment the subscription
    is complete, the client can reuse the `id`. The structure of this message type
    (`SubscribeMessage`) is as follows:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: '这个请求包含三个字段 – `id`、`type` 和 `payload`。在这里，每个新的订阅请求都应该包含一个唯一的 `id`；否则，服务器可能会抛出
    `4409: Subscriber for <unique-operation-id> already exists`。服务器会跟踪 `id`，直到订阅处于活动状态。一旦订阅完成，客户端可以重新使用
    `id`。此消息类型（`SubscribeMessage`）的结构如下：'
- en: '[PRE52]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: '`NEXT`): After a successful subscription operation, the client receives the
    messages of type `NEXT` from the server that contain the data related to the operation
    the client subscribes to. Data is part of the `payload` field. The server keeps
    sending these message types to the client until GraphQL subscription events occur.
    Once the operation gets completed, the server sends the complete message to the
    client. Its message type (`NextMessage`) is represented by the following:'
  id: totrans-328
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`NEXT`）：在成功的订阅操作之后，客户端从服务器接收类型为 `NEXT` 的消息，这些消息包含客户端订阅的操作相关的数据。数据是 `payload`
    字段的一部分。服务器会持续向客户端发送这些消息类型，直到 GraphQL 订阅事件发生。一旦操作完成，服务器会将完整消息发送给客户端。其消息类型（`NextMessage`）由以下结构表示：'
- en: '[PRE53]'
  id: totrans-329
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: '2.  `COMPLETE`): `Complete` is a bi-directional message, which can be sent
    by both the server and client:'
  id: totrans-330
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 2. `COMPLETE`）：`Complete` 是一种双向消息，可以由服务器和客户端发送：
- en: '*Client to Server*: The client can send the complete message to the server
    when the client wants to stop listening to the message sent by the server. Since
    it’s a duplex call, the client should ignore the messages that are en route when
    the client sends a complete request.'
  id: totrans-331
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*客户端到服务器*：当客户端想要停止监听服务器发送的消息时，客户端可以将完整消息发送给服务器。由于这是一个双向调用，当客户端发送完整请求时，客户端应该忽略正在传输中的消息。'
- en: '*Server to Client*: The server sends the complete message to the client when
    the requested operation is completed by the server. The server doesn’t send the
    complete message when an error message is sent by the server for the subscription
    request by the client.'
  id: totrans-332
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*服务器到客户端*：当服务器完成请求的操作时，服务器会将完整消息发送给客户端。当服务器为客户端的订阅请求发送错误消息时，服务器不会发送完整消息。'
- en: 'The message type (`CompleteMessage`) is represented by the following structure:'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 消息类型（`CompleteMessage`）由以下结构表示：
- en: '[PRE54]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: '`ERROR`): The server sends an error message when the server encounters any
    operation execution error. Its type (`ErrorMessage`) is represented by the following
    structure:'
  id: totrans-335
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`ERROR`）：当服务器遇到任何操作执行错误时，服务器会发送错误消息。其类型（`ErrorMessage`）由以下结构表示：'
- en: '[PRE55]'
  id: totrans-336
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: '2.  `PING` and `PONG`: These are bi-directional message types and are sent
    by both the server and client. If the client sends a `ping` message, the server
    should immediately send a `pong` message and vice versa. These messages are useful
    for detecting networking problems and network latency. Both `ping` (`PingMessage`)
    and `pong` (`PongMessage`) contain the following structure:'
  id: totrans-337
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 2. `PING` 和 `PONG`：这些是双向消息类型，由服务器和客户端发送。如果客户端发送 `ping` 消息，服务器应立即发送 `pong` 消息，反之亦然。这些消息对于检测网络问题和网络延迟很有用。`ping`
    (`PingMessage`) 和 `pong` (`PongMessage`) 都包含以下结构：
- en: '[PRE56]'
  id: totrans-338
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Understanding the subscription life cycle will help you test the subscription
    thoroughly.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 理解订阅生命周期将帮助您彻底测试订阅。
- en: You can use any tool that supports GraphQL subscription testing. We’ll test
    it using the Insomnia WebSocket request client – a bit of a crude way so you can
    understand the complete life cycle of the GraphQL subscription.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用任何支持 GraphQL 订阅测试的工具。我们将使用 Insomnia WebSocket 请求客户端进行测试 – 这是一种比较原始的方法，以便您理解
    GraphQL 订阅的完整生命周期。
- en: '![Figure 14.3 – GraphQL subscription connection_init call in the Insomnia client](img/Figure_14.3_B19349.jpg)'
  id: totrans-341
  prefs: []
  type: TYPE_IMG
  zh: '![图 14.3 – Insomnia 客户端中的 GraphQL 订阅 connection_init 调用](img/Figure_14.3_B19349.jpg)'
- en: Figure 14.3 – GraphQL subscription connection_init call in the Insomnia client
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.3 – Insomnia 客户端中的 GraphQL 订阅 connection_init 调用
- en: Testing GraphQL subscriptions using Insomnia WebSocket
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Insomnia WebSocket 测试 GraphQL 订阅
- en: 'Let’s perform the following steps to test the subscription manually:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们执行以下步骤以手动测试订阅：
- en: First, add a new request using *WebSocket Request* by using the (**+**) drop-down
    menu available in the top-left corner.
  id: totrans-345
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，通过使用位于左上角顶部的（**+**）下拉菜单，使用 *WebSocket 请求* 添加一个新的请求。
- en: 'Then add the following URL in the **URL** box:'
  id: totrans-346
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后在 **URL** 框中添加以下 URL：
- en: '[PRE57]'
  id: totrans-347
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE57]'
- en: '3.  Then, add the following headers in the **Headers** tab:'
  id: totrans-348
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 3. 然后，在 **Headers** 选项卡中添加以下头部信息：
- en: '[PRE58]'
  id: totrans-349
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE58]'
- en: Here, through the headers, you upgrade the connection to WebSocket; therefore,
    the server sends the `101 Switching Protocol` response. Also, you can see that
    you are using the `graphql-transport-ws` GraphQL sub-protocol.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，通过头部信息，您将连接升级为 WebSocket；因此，服务器会发送 `101 Switching Protocol` 响应。您还可以看到您正在使用
    `graphql-transport-ws` GraphQL 子协议。
- en: 'Then, add the following payload in the **JSON** tab for connection initialization
    (see *Figure 14**.3*):'
  id: totrans-351
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，在 **JSON** 选项卡中添加以下用于连接初始化的负载（参见 *图 14**.3*）：
- en: '[PRE59]'
  id: totrans-352
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 2.  Then, click on the **Send** button (don’t click on the **Connect** button
    – if you do, then it needs to be followed by one more click on **Send**).
  id: totrans-353
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 2.  然后，点击**发送**按钮（不要点击**连接**按钮 – 如果你点击了，那么它需要随后再点击一次**发送**）。
- en: 'On a successful connection, you will receive the following acknowledgment message
    from the server. It means the server is ready to serve the subscription request
    (shown in *Figure 14**.3*):'
  id: totrans-354
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在成功连接后，你将收到服务器发送的以下确认消息。这意味着服务器已准备好服务订阅请求（如图*14.3*所示）：
- en: '[PRE60]'
  id: totrans-355
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE60]'
- en: '4.  Then, use the following payload in the **JSON** tab:'
  id: totrans-356
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 4.  然后，在**JSON**选项卡中使用以下有效载荷：
- en: '[PRE61]'
  id: totrans-357
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE61]'
- en: Here, you are adding a unique ID to the message. The type of message is set
    to `subscribe`. You can send a `subscribe` message because a connection acknowledgment
    is received by the client. The `query` field contains the GraphQL subscription
    query.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你正在向消息添加一个唯一ID。消息类型设置为`subscribe`。你可以发送一个`subscribe`消息，因为客户端收到了连接确认。`query`字段包含GraphQL订阅查询。
- en: Then, again click on the **Send** button (don’t click on the **Connect** button
    – if you do, then it needs to be followed by one more click on **Send**).
  id: totrans-359
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，再次点击**发送**按钮（不要点击**连接**按钮 – 如果你点击了，那么它需要随后再点击一次**发送**）。
- en: 'After clicking on the `addQuantity` mutation to trigger the publication of
    the event by using the following payload:'
  id: totrans-360
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在点击`addQuantity`突变以使用以下有效载荷触发事件的发布后：
- en: '[PRE62]'
  id: totrans-361
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 3.  After a successful mutation call, you can check the subscription output
    in the Insomnia client. You will find an incoming JSON message that will display
    the increased quantity, as shown in *Figure 14**.4*.
  id: totrans-362
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 3.  在成功调用突变后，你可以在Insomnia客户端中检查订阅输出。你将找到一个显示增加数量的传入JSON消息，如图*14.4*所示。
- en: You can repeat *steps 9 and 10* to get the (`NEXT` type) messages.
  id: totrans-363
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你可以重复*步骤9和10*以获取（`NEXT`类型）消息。
- en: Once you are done, you can send the following JSON payload to complete the call
    as shown in *Figure 14**.4:*
  id: totrans-364
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦完成，你可以发送以下JSON有效载荷以完成调用，如图*14.4*所示：
- en: '[PRE63]'
  id: totrans-365
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE63]'
- en: '![Figure 14.4 – GraphQL subscription’s next and complete calls in the Insomnia
    client](img/Figure_14.4_B19349.jpg)'
  id: totrans-366
  prefs: []
  type: TYPE_IMG
  zh: '![图14.4 – 在Insomnia客户端中GraphQL订阅的下一个和完成调用](img/Figure_14.4_B19349.jpg)'
- en: Figure 14.4 – GraphQL subscription’s next and complete calls in the Insomnia
    client
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.4 – 在Insomnia客户端中GraphQL订阅的下一个和完成调用
- en: This is the way you can implement and test the GraphQL subscription over WebSocket.
    You will automate the test for GraphQL subscription in the *Testing GraphQL subscriptions
    using automated test code* subsection in this chapter.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是你可以实现和测试GraphQL WebSocket订阅的方式。你将在本章的“使用自动化测试代码测试GraphQL订阅”小节中自动化测试GraphQL订阅。
- en: Next, you should know about the instrumentation that helps to implement the
    tracing, logging, and metrics collection. Let’s discuss this in the next subsection.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你应该了解有助于实现跟踪、日志记录和指标收集的仪表。让我们在下一个小节中讨论这个问题。
- en: Instrumenting the GraphQL APIs
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 仪表化GraphQL API
- en: The GraphQL Java library supports the instrumentation of the GraphQL APIs. This
    can be used to support metrics, tracing, and logging. The DGS framework also uses
    it. You just must mark the instrumentation class with the Spring `@``Component`
    annotation.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: GraphQL Java库支持GraphQL API的仪表化。这可以用于支持指标、跟踪和日志记录。DGS框架也使用它。你只需将仪表化类标记为Spring的`@Component`注解即可。
- en: The instrumentation bean can be implemented using the `graphql.execution. instrumentation.Instumentation`
    interface. Here, you have to write boilerplate code, which may increase the unit
    test automation code for you. Another way that is much easier is to extend the
    `SimpleInstrumentation` class, which does the simple implementation for you. However,
    you can override the methods for custom implementation.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 仪表化Bean可以使用`graphql.execution.instrumentation.Instumentation`接口实现。在这里，你必须编写样板代码，这可能会增加你的单元测试自动化代码。另一种更简单的方法是扩展`SimpleInstrumentation`类，它为你做了简单的实现。然而，你可以覆盖方法以进行自定义实现。
- en: Let’s add instrumentation that will record the time taken by the data fetcher
    and complete GraphQL request processing. This metric may help you to fine-tune
    the performance and identify the fields that take more time to resolve.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们添加记录数据获取器和完成GraphQL请求处理的耗时情况的仪表。这个指标可能有助于你微调性能并识别耗时较长的字段。
- en: Before adding the tracing, let’s add the custom header in the response.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 在添加跟踪之前，让我们在响应中添加自定义标题。
- en: Adding a custom header
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 添加自定义标题
- en: 'Let’s create the `DemoInstrumentation.java` file in the `instrumentation` package
    and add the following code:'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在`instrumentation`包中创建`DemoInstrumentation.java`文件，并添加以下代码：
- en: '[PRE64]'
  id: totrans-377
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: '[https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/dev/Chapter14/src/main/java/com/packt/modern/api/instrumentation/DemoInstrumentation.java](https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/dev/Chapter14/src/main/java/com/packt/modern/api/instrumentation/DemoInstrumentation.java)'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/dev/Chapter14/src/main/java/com/packt/modern/api/instrumentation/DemoInstrumentation.java](https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/dev/Chapter14/src/main/java/com/packt/modern/api/instrumentation/DemoInstrumentation.java)'
- en: Here, this class extends `SimpleInstrumentation` and is created as a Spring
    bean by marking it as `@Component`. The `SimpleInstrumentation` class allows you
    to instrument the execution result. Here, you can see that you have added the
    custom header in the response. Let’s test it.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，这个类扩展了`SimpleInstrumentation`，并通过标记为`@Component`创建为Spring bean。`SimpleInstrumentation`类允许你仪表化执行结果。在这里，你可以看到你已经在响应中添加了自定义头。让我们测试它。
- en: 'You can build and execute the project after adding the previous code and then
    execute the following mutation:'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 在添加了之前的代码后，你可以构建并执行项目，然后执行以下突变：
- en: '[PRE65]'
  id: totrans-381
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: You’ll find the instrumented `myHeader` header and its value in the response
    headers.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 你将在响应头中找到仪表化的`myHeader`头及其值。
- en: 'Now, you can instrument the tracing information in your response by adding
    the following bean to your project:'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以通过向你的项目中添加以下bean来在你的响应中仪表化跟踪信息：
- en: '[PRE66]'
  id: totrans-384
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: '[https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/dev/Chapter14/src/main/java/com/packt/modern/api/instrumentation/InstrumentationConfig.java](https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/dev/Chapter14/src/main/java/com/packt/modern/api/instrumentation/InstrumentationConfig.java)'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/dev/Chapter14/src/main/java/com/packt/modern/api/instrumentation/InstrumentationConfig.java](https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/dev/Chapter14/src/main/java/com/packt/modern/api/instrumentation/InstrumentationConfig.java)'
- en: This configuration does the magic. You must remember that you need `com.netflix.graphql.dgs:graphql-dgs-spring-boot-micrometer`
    along with Spring Actuator dependencies in your `build.gradle` file to make it
    work.
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 此配置完成了魔法。你必须记住，你需要在`build.gradle`文件中添加`com.netflix.graphql.dgs:graphql-dgs-spring-boot-micrometer`以及Spring
    Actuator依赖项才能使其工作。
- en: The previous code adds the execution result metrics provided by the DGS framework
    to GraphQL API responses. This metric includes the tracing time and duration,
    validation time and duration, the resolver’s information, and so on.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码将DGS框架提供的执行结果指标添加到GraphQL API响应中。此指标包括跟踪时间和持续时间、验证时间和持续时间、解析器的信息等。
- en: Once you have this instrumentation in place and execute any query or mutation,
    the result will include the extension fields consisting of the result metrics
    instrumented by the `Instrumentation` bean (GraphQL Tracing) created in the previous
    code.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你设置了这种仪器并执行任何查询或突变，结果将包括由之前代码中创建的`Instrumentation` bean（GraphQL Tracing）仪表化的扩展字段，即结果指标。
- en: 'Let’s execute the following mutation in GraphiQL (`http://localhost:8080/graphiql`):'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在GraphiQL（`http://localhost:8080/graphiql`）中执行以下突变：
- en: '[PRE67]'
  id: totrans-390
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'The previous mutation will provide the following response with instrumented
    metrics:'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的突变将提供以下带有仪表化指标的响应：
- en: '[PRE68]'
  id: totrans-392
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: Here, you can see that it not only returns `data` but also provides the instrumented
    metrics in the `extensions` field. Please note that you should keep this instrumentation
    enabled only for the development environment to fine-tune the GraphQL implementation
    and benchmarking, and keep it disabled for the production environment.
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你可以看到它不仅返回`data`，还在`extensions`字段中提供了仪表化的指标。请注意，你应该只在开发环境中启用此仪表化，以微调GraphQL实现和基准测试，而在生产环境中应禁用。
- en: Let’s find out more about the instrumentation metrics in the next subsection.
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们了解下一小节中关于仪表化指标的相关内容。
- en: Integration with Micrometer
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 与Micrometer的集成
- en: You have added `graphql-dgs-spring-boot-micrometer` as one of the dependencies
    in `build.gradle`. This library provides GraphQL metrics out of the box such as
    `gql.query`, `gql-resolver`, and so on.
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经在`build.gradle`中将`graphql-dgs-spring-boot-micrometer`作为依赖项之一添加。这个库提供了开箱即用的GraphQL指标，如`gql.query`、`gql-resolver`等。
- en: 'You can expose the `metrics` endpoint by adding the following line in the `application.properties`
    file:'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过在`application.properties`文件中添加以下行来暴露`metrics`端点：
- en: '[PRE69]'
  id: totrans-398
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: http://localhost:8080/actuator/metrics
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: http://localhost:8080/actuator/metrics
- en: '[PRE70]'
  id: totrans-400
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: http://localhost:8080/actuator/metrics/gql.query
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: http://localhost:8080/actuator/metrics/gql.query
- en: '[PRE71]'
  id: totrans-402
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: '{  "name": "gql.query",'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: '{  "name": "gql.query",'
- en: '"baseUnit": "seconds",'
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: '"baseUnit": "seconds",'
- en: '"measurements": [{'
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: '"measurements": [{'
- en: '"statistic": "COUNT",  "value": 4.0'
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: '"statistic": "COUNT",  "value": 4.0'
- en: '}, {'
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: '};'
- en: '"statistic": "TOTAL_TIME", "value": 1.403888175'
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: '"statistic": "TOTAL_TIME", "value": 1.403888175'
- en: '}, {'
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: '}, {'
- en: '"statistic": "MAX", "value": 0.0'
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: '"statistic": "MAX", "value": 0.0'
- en: '}],'
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: '}];'
- en: '"availableTags": [{'
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: '"availableTags": [{'
- en: '"tag": "gql.query.sig.hash",'
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: '"tag": "gql.query.sig.hash",'
- en: '"values": ["10e750742768cb7c428699…",'
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: '"values": ["10e750742768cb7c428699…",'
- en: '"a750f4b9bb5d40f2d23b01…"]'
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: '"a750f4b9bb5d40f2d23b01…"]'
- en: '}, {'
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: '}, {'
- en: '"tag": "gql.operation",'
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: '"tag": "gql.operation",'
- en: '"values": ["SUBSCRIPTION", "MUTATION"]'
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: '"values": ["SUBSCRIPTION", "MUTATION"]'
- en: '}, {'
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: '}, {'
- en: '"tag": "gql.query.complexity", "values": ["10"]'
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: '"tag": "gql.query.complexity", "values": ["10"]'
- en: '}, {'
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: '}, {'
- en: '"tag": "gql.operation.name", "values": ["anonymous"]'
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: '"tag": "gql.operation.name", "values": ["anonymous"]'
- en: '}, {'
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: '}, {'
- en: '"tag": "outcome", "values": ["success", "failure"]'
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: '"tag": "outcome", "values": ["success", "failure"]'
- en: '}]'
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: '}]'
- en: '}'
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '[PRE72]'
  id: totrans-427
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: '@SpringBootTest(classes = { DgsAutoConfiguration.class,     ProductDatafetcher.class,BigDecimalScalar.class
    })'
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: '@SpringBootTest(classes = { DgsAutoConfiguration.class,     ProductDatafetcher.class,BigDecimalScalar.class
    })'
- en: public class ProductDatafetcherTest {
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: public class ProductDatafetcherTest {
- en: private final InMemRepository repo = new InMemRepository();
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: private final InMemRepository repo = new InMemRepository();
- en: private final int TEN = 10;
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: private final int TEN = 10;
- en: '@Autowired'
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: '@Autowired'
- en: private DgsQueryExecutor dgsQueryExecutor;
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: private DgsQueryExecutor dgsQueryExecutor;
- en: '@MockBean'
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: '@MockBean'
- en: private ProductService productService;
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: private ProductService productService;
- en: '@MockBean'
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: '@MockBean'
- en: private TagService tagService;
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: private TagService tagService;
- en: // continue …
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: // continue …
- en: '[PRE73]'
  id: totrans-439
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: '@BeforeEachpublic void beforeEach() {'
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: '@BeforeEachpublic void beforeEach() {'
- en: List<Tag> tags = new ArrayList<>();
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: List<Tag> tags = new ArrayList<>();
- en: tags.add(Tag.newBuilder().id("tag1").name("Tag 1").build());
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: tags.add(Tag.newBuilder().id("tag1").name("Tag 1").build());
- en: Product product = Product.newBuilder().id("any")
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: Product product = Product.newBuilder().id("any")
- en: .name("mock title").description("mock description")
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: .name("mock title").description("mock description")
- en: .price(BigDecimal.valueOf(20.20)).count(100)
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: .price(BigDecimal.valueOf(20.20)).count(100)
- en: .tags(tags).build();
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: .tags(tags).build();
- en: given(productService.getProduct
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: given(productService.getProduct
- en: ("any")).willReturn(product);
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: ("any")).willReturn(product);
- en: tags.add(Tag.newBuilder().id("tag2")
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: tags.add(Tag.newBuilder().id("tag2")
- en: .name("addTags").build());
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: .name("addTags").build());
- en: product.setTags(tags);
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: product.setTags(tags);
- en: given(tagService.addTags("any",
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: given(tagService.addTags("any",
- en: List.of(TagInput.newBuilder().name("addTags").build())))
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: List.of(TagInput.newBuilder().name("addTags").build())))
- en: .willAnswer(invocation -> product);
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: .willAnswer(invocation -> product);
- en: '}'
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '[PRE74]'
  id: totrans-456
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: '@Test@DisplayName("Verify JSON returned by the query ''product''")'
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: '@Test@DisplayName("验证查询''product''返回的JSON")'
- en: public void product() {
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: public void product() {
- en: String name = dgsQueryExecutor.executeAndExtractJsonPath(
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: String name = dgsQueryExecutor.executeAndExtractJsonPath(
- en: '"{product(id: \"any\"){ name }}",'
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: '"{product(id: \"any\"){ name }}",'
- en: '"data.product.name");'
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: '"data.product.name");'
- en: assertThat(name).contains("mock title");
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: assertThat(name).contains("mock title");
- en: '}'
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '[PRE75]'
  id: totrans-464
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: '@Test@DisplayName("Verify exception to query product – invalid ID")'
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: '@Test@DisplayName("验证查询产品时的异常 - 无效ID")'
- en: public void productWithException() {
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: public void productWithException() {
- en: given(productService.getProduct("any"))
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: given(productService.getProduct("any"))
- en: .willThrow(new RuntimeException
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: .willThrow(new RuntimeException
- en: ("Invalid Product ID."));
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: ("无效的产品ID。"));
- en: ExecutionResult res = dgsQueryExecutor.execute(
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: ExecutionResult res = dgsQueryExecutor.execute(
- en: '"{ product (id: \"any\") { name }}");'
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: '"{ product (id: \"any\") { name }}");'
- en: verify(productService, times(1)).getProduct("any");
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: verify(productService, times(1)).getProduct("any");
- en: assertThat(res.getErrors()).isNotEmpty();
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: assertThat(res.getErrors()).isNotEmpty();
- en: assertThat(res.getErrors().get(0).getMessage()).isEqualTo(
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: assertThat(res.getErrors().get(0).getMessage()).isEqualTo(
- en: '"java.lang.RuntimeException:'
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: '"java.lang.RuntimeException:'
- en: Invalid Product ID.");
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: '"无效的产品ID。");'
- en: '}'
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '[PRE76]'
  id: totrans-478
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: '@Test@DisplayName("Verify JSON using GraphQLQueryRequest")'
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: '@Test@DisplayName("验证使用GraphQLQueryRequest的JSON")'
- en: void productsWithQueryApi() {
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
  zh: void productsWithQueryApi() {
- en: GraphQLQueryRequest gqlRequest = new GraphQLQueryRequest(
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: GraphQLQueryRequest gqlRequest = new GraphQLQueryRequest(
- en: ProductGraphQLQuery.newRequest().id("any").build(),
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: ProductGraphQLQuery.newRequest().id("any").build(),
- en: new ProductProjectionRoot().id().name());
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: new ProductProjectionRoot().id().name());
- en: String name = dgsQueryExecutor.executeAndExtractJsonPath(
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: String name = dgsQueryExecutor.executeAndExtractJsonPath(
- en: gqlRequest.serialize(), "data.product.name");
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
  zh: gqlRequest.serialize(), "data.product.name");
- en: assertThat(name).contains("mock title");
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: assertThat(name).contains("mock title");
- en: '}'
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '[PRE77]'
  id: totrans-488
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: '@Test@DisplayName("Verify Tags returned by the query ''product''")'
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
  zh: '@Test@DisplayName("验证查询''product''返回的标签")'
- en: void productsWithTags() {
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: void productsWithTags() {
- en: GraphQLQueryRequest gqlRequest = new GraphQLQueryRequest(
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
  zh: GraphQLQueryRequest gqlRequest = new GraphQLQueryRequest(
- en: ProductGraphQLQuery.newRequest().id("any").build(),
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: ProductGraphQLQuery.newRequest().id("任何").build(),
- en: new ProductProjectionRoot().id().name().tags()
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
  zh: new ProductProjectionRoot().id().name().tags()
- en: .id().name());
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
  zh: .id().name());
- en: Product product = dgsQueryExecutor
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
  zh: Product product = dgsQueryExecutor
- en: .executeAndExtractJsonPathAsObject(gqlRequest.serialize(),
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
  zh: .executeAndExtractJsonPathAsObject(gqlRequest.serialize(),
- en: '"data.product", new TypeRef<>() {});'
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
  zh: '"data.product", new TypeRef<>() {});'
- en: assertThat(product.getId()).isEqualTo("any");
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
  zh: 断言product.getId()等于"任何";
- en: assertThat(product.getName()).isEqualTo("mock title");
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
  zh: 断言product.getName())等于"模拟标题";
- en: assertThat(product.getTags().size()).isEqualTo(2);
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
  zh: 断言product.getTags().的大小等于2；
- en: assertThat(product.getTags().get(0).getName())
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
  zh: 断言product.getTags().get(0).getName())
- en: .isEqualTo("Tag 1");
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
  zh: .isEqualTo("标签 1");
- en: '}'
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '[PRE78]'
  id: totrans-504
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: '@Test@DisplayName("Verify the mutation ''addTags''")'
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
  zh: '@Test@DisplayName("验证突变 ''addTags''")'
- en: void addTagsMutation() {
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
  zh: void addTagsMutation() {
- en: GraphQLQueryRequest gqlRequest = new GraphQLQueryRequest(
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
  zh: GraphQLQueryRequest gqlRequest = new GraphQLQueryRequest(
- en: AddTagGraphQLQuery.newRequest().productId("any")
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
  zh: AddTagGraphQLQuery.newRequest().productId("任何")
- en: .tags(List.of(TagInput.newBuilder()
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
  zh: .tags(List.of(TagInput.newBuilder()
- en: .name("addTags").build())).build(),
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
  zh: .name("addTags").build())).build(),
- en: new AddTagProjectionRoot().name().count());
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
  zh: new AddTagProjectionRoot().name().count());
- en: ExecutionResult exeResult = dgsQueryExecutor.execute(
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
  zh: ExecutionResult exeResult = dgsQueryExecutor.execute(
- en: gqlRequest.serialize());
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
  zh: gqlRequest.serialize());
- en: assertThat(exeResult.getErrors()).isEmpty();
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
  zh: 断言exeResult.getErrors()为空；
- en: verify(tagService).addTags("any", List.of(
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
  zh: verify(tagService).addTags("任何", List.of(
- en: TagInput.newBuilder().name("addTags").build()));
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
  zh: TagInput.newBuilder().name("addTags").build()));
- en: '}'
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '[PRE79]'
  id: totrans-518
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: '@Test@DisplayName("Verify the mutation ''addQuantity''")'
  id: totrans-519
  prefs: []
  type: TYPE_NORMAL
  zh: '@Test@DisplayName("验证突变 ''addQuantity''")'
- en: void addQuantityMutation() {
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
  zh: void addQuantityMutation() {
- en: given(productService.addQuantity("a1s2d3f4-1", TEN))
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
  zh: given(productService.addQuantity("a1s2d3f4-1", 十))
- en: .willReturn(repo.addQuantity("a1s2d3f4-1", TEN));
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
  zh: .willReturn(repo.addQuantity("a1s2d3f4-1", 十));
- en: GraphQLQueryRequest gqlRequest = new GraphQLQueryRequest(
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
  zh: GraphQLQueryRequest gqlRequest = new GraphQLQueryRequest(
- en: AddQuantityGraphQLQuery.newRequest()
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
  zh: AddQuantityGraphQLQuery.newRequest()
- en: .productId("a1s2d3f4-1").quantity(TEN).build(),
  id: totrans-525
  prefs: []
  type: TYPE_NORMAL
  zh: .productId("a1s2d3f4-1").quantity(十).build(),
- en: new AddQuantityProjectionRoot().name().count());
  id: totrans-526
  prefs: []
  type: TYPE_NORMAL
  zh: new AddQuantityProjectionRoot().name().count());
- en: ExecutionResult exeResult = dgsQueryExecutor
  id: totrans-527
  prefs: []
  type: TYPE_NORMAL
  zh: ExecutionResult exeResult = dgsQueryExecutor
- en: .execute(gqlRequest.serialize());
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
  zh: .execute(gqlRequest.serialize());
- en: assertThat(executionResult.getErrors()).isEmpty();
  id: totrans-529
  prefs: []
  type: TYPE_NORMAL
  zh: 断言executionResult.getErrors()为空；
- en: Object obj = executionResult.getData();
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
  zh: Object obj = executionResult.getData();
- en: assertThat(obj).isNotNull();
  id: totrans-531
  prefs: []
  type: TYPE_NORMAL
  zh: 断言obj不为null；
- en: Map<String, Object> data = (Map)((Map
  id: totrans-532
  prefs: []
  type: TYPE_NORMAL
  zh: Map<String, Object> data = (Map)((Map
- en: )exeResult.getData()).get(MUTATION.AddQuantity);
  id: totrans-533
  prefs: []
  type: TYPE_NORMAL
  zh: )exeResult.getData()).get(MUTATION.AddQuantity);
- en: org.hamcrest.MatcherAssert.assertThat(
  id: totrans-534
  prefs: []
  type: TYPE_NORMAL
  zh: org.hamcrest.MatcherAssert.assertThat(
- en: (Integer) data.get("count"), greaterThan(TEN));
  id: totrans-535
  prefs: []
  type: TYPE_NORMAL
  zh: (Integer) data.get("count"), 大于(十));
- en: '}'
  id: totrans-536
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '[PRE80]'
  id: totrans-537
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: '@Test@DisplayName("Verify the subscription ''quantityChanged''")'
  id: totrans-538
  prefs: []
  type: TYPE_NORMAL
  zh: '@Test@DisplayName("验证订阅 ''quantityChanged''")'
- en: void reviewSubscription() {
  id: totrans-539
  prefs: []
  type: TYPE_NORMAL
  zh: void reviewSubscription() {
- en: given(productService.gerProductPublisher())
  id: totrans-540
  prefs: []
  type: TYPE_NORMAL
  zh: given(productService.gerProductPublisher())
- en: .willReturn(repo.getProductPublisher());
  id: totrans-541
  prefs: []
  type: TYPE_NORMAL
  zh: .willReturn(repo.getProductPublisher());
- en: ExecutionResult exeResult = dgsQueryExecutor.execute(
  id: totrans-542
  prefs: []
  type: TYPE_NORMAL
  zh: ExecutionResult exeResult = dgsQueryExecutor.execute(
- en: '"subscription {quantityChanged'
  id: totrans-543
  prefs: []
  type: TYPE_NORMAL
  zh: '"订阅 {quantityChanged'
- en: '{id name price count}}");'
  id: totrans-544
  prefs: []
  type: TYPE_NORMAL
  zh: '{id name price count}}");'
- en: Publisher<ExecutionResult> pub = exeResult.getData();
  id: totrans-545
  prefs: []
  type: TYPE_NORMAL
  zh: Publisher<ExecutionResult> pub = exeResult.getData();
- en: List<Product> products = new CopyOnWriteArrayList<>();
  id: totrans-546
  prefs: []
  type: TYPE_NORMAL
  zh: List<Product> products = new CopyOnWriteArrayList<>();
- en: pub.subscribe(new Subscriber<>() {
  id: totrans-547
  prefs: []
  type: TYPE_NORMAL
  zh: pub.subscribe(new Subscriber<>() {
- en: '@Override'
  id: totrans-548
  prefs: []
  type: TYPE_NORMAL
  zh: '@Override'
- en: public void onSubscribe(Subscription s) {s.request(2);}
  id: totrans-549
  prefs: []
  type: TYPE_NORMAL
  zh: public void onSubscribe(Subscription s) {s.request(2);}
- en: '@Override'
  id: totrans-550
  prefs: []
  type: TYPE_NORMAL
  zh: '@Override'
- en: public void onNext(ExecutionResult result) {
  id: totrans-551
  prefs: []
  type: TYPE_NORMAL
  zh: public void onNext(ExecutionResult result) {
- en: if (result.getErrors().size() > 0) {
  id: totrans-552
  prefs: []
  type: TYPE_NORMAL
  zh: 如果result.getErrors().的大小大于0 {
- en: System.out.println(result.getErrors());
  id: totrans-553
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println(result.getErrors());
- en: '}'
  id: totrans-554
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: Map<String, Object> data = result.getData();
  id: totrans-555
  prefs: []
  type: TYPE_NORMAL
  zh: Map<String, Object> data = result.getData();
- en: products.add(
  id: totrans-556
  prefs: []
  type: TYPE_NORMAL
  zh: products.add(
- en: new ObjectMapper().convertValue(data.get(
  id: totrans-557
  prefs: []
  type: TYPE_NORMAL
  zh: new ObjectMapper().convertValue(data.get(
- en: SUBSCRIPTION.QuantityChanged), Product.class));
  id: totrans-558
  prefs: []
  type: TYPE_NORMAL
  zh: SUBSCRIPTION.QuantityChanged), Product.class));
- en: '}'
  id: totrans-559
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '@Override'
  id: totrans-560
  prefs: []
  type: TYPE_NORMAL
  zh: '@Override'
- en: public void onError(Throwable t) {}
  id: totrans-561
  prefs: []
  type: TYPE_NORMAL
  zh: public void onError(Throwable t) {}
- en: '@Override'
  id: totrans-562
  prefs: []
  type: TYPE_NORMAL
  zh: '@Override'
- en: public void onComplete() {}
  id: totrans-563
  prefs: []
  type: TYPE_NORMAL
  zh: public void onComplete() {}
- en: '});'
  id: totrans-564
  prefs: []
  type: TYPE_NORMAL
  zh: '});'
- en: addQuantityMutation();
  id: totrans-565
  prefs: []
  type: TYPE_NORMAL
  zh: addQuantityMutation();
- en: Integer count = products.get(0).getCount();
  id: totrans-566
  prefs: []
  type: TYPE_NORMAL
  zh: Integer count = products.get(0).getCount();
- en: addQuantityMutation();
  id: totrans-567
  prefs: []
  type: TYPE_NORMAL
  zh: addQuantityMutation();
- en: assertThat(products.get(0).getId())
  id: totrans-568
  prefs: []
  type: TYPE_NORMAL
  zh: 断言products.get(0).getId()
- en: .isEqualTo(products.get(1).getId());
  id: totrans-569
  prefs: []
  type: TYPE_NORMAL
  zh: .isEqualTo(products.get(1).getId());
- en: assertThat(products.get(1).getCount())
  id: totrans-570
  prefs: []
  type: TYPE_NORMAL
  zh: 断言products.get(1).getCount())
- en: .isEqualTo(count + TEN);
  id: totrans-571
  prefs: []
  type: TYPE_NORMAL
  zh: .isEqualTo(count + 十);
- en: '}'
  id: totrans-572
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-573
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '[PRE81]'
  id: totrans-574
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: '[PRE82]'
  id: totrans-575
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
