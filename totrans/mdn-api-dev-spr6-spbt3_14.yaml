- en: '14'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: GraphQL API Development and Testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we learned about the fundamental concepts of GraphQL.
    You are going to use that knowledge to develop and test GraphQL-based APIs in
    this chapter. You will implement GraphQL-based APIs for a sample application in
    this chapter. The GraphQL server implementation will be developed based on a **design-first**
    approach, the way you defined the OpenAPI specification in [*Chapter 3*](B19349_03.xhtml#_idTextAnchor080),
    *API Specifications and Implementation*, and designed the schema in [*Chapter
    11*](B19349_11.xhtml#_idTextAnchor250), *gRPC API Development* *and Testing*.
  prefs: []
  type: TYPE_NORMAL
- en: After completing this chapter, you will have learned how to practically implement
    the GraphQL concepts learned about in the previous chapter and about the implementation
    of the GraphQL server using Java and Spring and its testing.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter will cover the following main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Workflow and tooling for GraphQL
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing the GraphQL server
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Documenting APIs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Test automation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The code for this chapter is available at
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/dev/Chapter14](https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/dev/Chapter14)'
  prefs: []
  type: TYPE_NORMAL
- en: Workflow and tooling for GraphQL
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As per the data graph (data structure) way of thinking in GraphQL, data is exposed
    using an API consisting of graphs of objects. These objects are connected using
    relations. GraphQL only exposes a single API endpoint. Clients query this endpoint,
    which uses a *single data graph*. On top of that, the data graph may resolve data
    from a single source, or multiple sources, by following the **OneGraph principle**
    of GraphQL. These sources could be a database, legacy system, or services that
    expose data using REST/gRPC/SOAP.
  prefs: []
  type: TYPE_NORMAL
- en: 'The GraphQL server can be implemented in the following two ways:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Standalone GraphQL service**: A standalone GraphQL service contains a single
    data graph. It could be a monolithic app or based on a microservice architecture
    that fetches the data from single or multiple sources (having no GraphQL API).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Federated GraphQL services**: It’s very easy to query a single data graph
    for comprehensive data fetching. However, enterprise applications are made using
    multiple services; hence, you can’t have a single data graph unless you build
    a monolithic system. If you don’t build a monolithic system, then you will have
    multiple service-specific data graphs.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This is where you make use of federated GraphQL services. A federated GraphQL
    service contains a **single distributed graph** exposed using a gateway. Clients
    call the gateway, which is an entry point into the system. The data graph is distributed
    among multiple services and each service can maintain its own development and
    release cycle independently. Having said that, federated GraphQL services still
    follow the OneGraph principle. Therefore, the client queries the single endpoint
    to fetch any part of the graph.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s assume that a sample e-commerce app is developed using GraphQL federated
    services. It has products, orders, shipping, inventory, customers, and other services
    that expose the domain-specific data graphs using the GraphQL API.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s look at a high-level diagram of GraphQL federated e-commerce services,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 14.1 – Federated GraphQL services](img/Figure_14.1_B19349.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 14.1 – Federated GraphQL services
  prefs: []
  type: TYPE_NORMAL
- en: Let’s say the GraphQL client queries for a list of the most ordered products
    with the least inventory by calling the `Gateway` endpoint. This query may have
    fields from `Orders`, `Products`, and `Inventory`. Each service is responsible
    for resolving only the respective part of a data graph. `Orders` would resolve
    order-related data, `Products` would resolve product-related data, `Inventory`
    would resolve inventory-related data, and so on. `Gateway` then consolidates the
    graph data and sends it back to the clients.
  prefs: []
  type: TYPE_NORMAL
- en: The `graphql-java` library ([https://www.graphql-java.com](https://www.graphql-java.com))
    provides the Java implementation of the GraphQL specification. Its source code
    is available at [https://github.com/graphql-java/graphql-java](https://github.com/graphql-java/graphql-java).
  prefs: []
  type: TYPE_NORMAL
- en: Spring provides a Spring Boot Starter project for GraphQL based on `graphql-java`,
    available at [https://github.com/spring-projects/spring-graphql](https://github.com/spring-projects/spring-graphql).
    However, we are going to use the Spring-based Netflix `graphql-java` library.
  prefs: []
  type: TYPE_NORMAL
- en: Netflix open sourced the DGS framework after using it in production in February
    2021\. It is continuously being enhanced and supported by the community. Netflix
    uses the same open sourced DGS framework codebase in production environments,
    which gives the assurance of the code’s quality and future maintenance. The OTT
    Disney+ platform was also built using the Netflix DGS framework ([https://webcache.googleusercontent.com/search?q=cache:ec4kC7jBjMQJ:https://help.apps.disneyplus.com/3rd-party-libs.html&cd=14&hl=en&ct=clnk&gl=in&client=firefox-b-d](https://webcache.googleusercontent.com/search?q=cache:ec4kC7jBjMQJ:https://help.apps.disneyplus.com/3rd-party-libs.html&cd=14&hl=en&ct=clnk&gl=in&client=firefox-b-d)).
  prefs: []
  type: TYPE_NORMAL
- en: 'It provides the following features:'
  prefs: []
  type: TYPE_NORMAL
- en: A Spring Boot starter and integration with Spring Security
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Full WebFlux support
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A Gradle plugin for code generation from a GraphQL schema
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Support for interfaces and union types, plus the provision of custom scalar
    types
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Support for GraphQL subscriptions using WebSocket and server-sent events
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Error handling
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pluggable instrumentation and Micrometer integration
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: GraphQL federated services with easy integration with GraphQL federation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dynamic schemas with hot reloading schemas
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Operation caching
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: File upload
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: GraphQL Java client
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: GraphQL test framework
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let’s write a GraphQL server using Netflix’s DGS framework in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the GraphQL server
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You are going to develop a standalone GraphQL server in this chapter. The knowledge
    you acquire while developing the standalone GraphQL server can be used to implement
    federated GraphQL services.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s create the Gradle project first in the next subsection.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the gRPC server project
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Either you can use the [*Chapter 14*](B19349_14.xhtml#_idTextAnchor313) code
    by cloning the Git repository ([https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/dev/Chapter14](https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/dev/Chapter14))
    or you can start by creating a new Spring project from scratch using Spring Initializr
    for the server and client with the following options:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Gradle -` `Groovy`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Java`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`3.0.8`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The preferred version is 3.0+; if not available, you can modify it later manually
    in the `build.gradle` file
  prefs: []
  type: TYPE_NORMAL
- en: '`com.packt.modern.api`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`chapter14`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`chapter14`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Chapter 14 code of book Modern API Development with Spring and Spring Boot`
    `Ed 2`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`com.packt.modern.api`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`JAR`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`17`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You can change it to another version, such as 17/20/21, in the `build.gradle`
    file later, as shown in the following code block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '`org.springframework.boot:spring-boot-starter-web`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Then, you can click on the **GENERATE** button and download the project. The
    downloaded project will be used to create the GraphQL server.
  prefs: []
  type: TYPE_NORMAL
- en: Next, let’s add the GraphQL DGS dependencies to the newly created project.
  prefs: []
  type: TYPE_NORMAL
- en: Adding the GraphQL DGS dependencies
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Once the Gradle project is available, you can modify the `build.gradle` file
    to include the GDS dependencies and plugin as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '[https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/dev/Chapter14/build.gradle](https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/dev/Chapter14/build.gradle)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, first, the DGS Codegen plugin is added, which will generate the code
    from the GraphQL schema file. Next, the following five dependencies are added:'
  prefs: []
  type: TYPE_NORMAL
- en: '`graphql-dgs-platform-dependencies`: The DGS platform dependencies for the
    DGS bill of materials (BOM)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`graphql-dgs-spring-boot-starter`: The DGS Spring Boot Starter library for
    DGS Spring support'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`graphql-dgs-extended-scalars`: The DGS extended scalars library for custom
    scalar types'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`graphql-dgs-spring-boot-micrometer`: The DGS library to provide integration
    with Micrometer to provide support for metrics and instrumentation along with
    Spring Actuator'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`graphql-dgs-subscriptions-websockets-autoconfigure`: To provide the autoconfiguration
    for GraphQL WebSocket support'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Please note that the `datafaker` library is used here to generate the domain
    seed data.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, let’s configure the DGS Codegen plugin in the same `build.gradle` file
    as shown in the next code block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'You have configured the following two properties of DGS Codegen using the `generateJava`
    task, which uses the Gradle plugin `com.netflix.graphql.dgs.codegen.GenerateJavaTask`
    class:'
  prefs: []
  type: TYPE_NORMAL
- en: '`generateClient`: This determines whether you would like to generate the client
    or not'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`packageName`: The Java package name of the generated Java classes'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The DGS Codegen plugin picks GraphQL schema files from the `src/main/resources/schema`
    directory by default. However, you can modify it using the `schemaPaths` property,
    which accepts an array. You can add this property to the previous code of `generateTask`
    along with `packageName` and `generateClient` if you want to change the default
    schema location, as shown next:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'typeMapping = ["GraphQLType": "mypackage.JavaType"]'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'type Query {    products(filter: ProductCriteria): [Product]!'
  prefs: []
  type: TYPE_NORMAL
- en: 'product(id: ID!): Product'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: type Mutation {
  prefs: []
  type: TYPE_NORMAL
- en: 'addTag(productId: ID!, tags: [TagInput!]!): Product'
  prefs: []
  type: TYPE_NORMAL
- en: 'addQuantity(productId: ID!, quantity: Int!): Product'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: type Subscription {
  prefs: []
  type: TYPE_NORMAL
- en: 'quantityChanged: Product'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'type Product {     id: String'
  prefs: []
  type: TYPE_NORMAL
- en: 'name: String'
  prefs: []
  type: TYPE_NORMAL
- en: 'description: String'
  prefs: []
  type: TYPE_NORMAL
- en: 'imageUrl: String'
  prefs: []
  type: TYPE_NORMAL
- en: 'price: BigDecimal'
  prefs: []
  type: TYPE_NORMAL
- en: 'count: Int'
  prefs: []
  type: TYPE_NORMAL
- en: 'tags: [Tag]'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: input ProductCriteria {
  prefs: []
  type: TYPE_NORMAL
- en: 'tags: [TagInput] = []'
  prefs: []
  type: TYPE_NORMAL
- en: 'name: String = ""'
  prefs: []
  type: TYPE_NORMAL
- en: 'page: Int = 1'
  prefs: []
  type: TYPE_NORMAL
- en: 'size: Int = 10'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: input TagInput {
  prefs: []
  type: TYPE_NORMAL
- en: 'name: String'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: type Tag {
  prefs: []
  type: TYPE_NORMAL
- en: 'id: String'
  prefs: []
  type: TYPE_NORMAL
- en: 'name: String'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'java.math.BigDecimal in the code generator plugin. Let’s add it to the build.gradle
    file as shown next (check the highlighted line):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'After these changes, your project is ready to generate the GraphQL objects
    and client. You can run the following command from the project root directory
    to build the project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: This command will generate the Java classes in the `build/generated` directory.
  prefs: []
  type: TYPE_NORMAL
- en: Before you start implementing the GraphQL root types, let’s discuss the custom
    scalar types in the next subsection.
  prefs: []
  type: TYPE_NORMAL
- en: Adding custom scalar types
  prefs: []
  type: TYPE_NORMAL
- en: You are going to use `BigDecimal` to capture the monetary values. This is a
    custom scalar type; therefore, you need to add this custom scalar to the code
    so that the DGS framework can pick it for serialization and deserialization. (You
    also need to add a mapping to the Gradle code generator plugin.)
  prefs: []
  type: TYPE_NORMAL
- en: There are two ways to add the custom scalar type – by implementing the `Coercing`
    interface and by making use of the `graphql-dgs-extended-scalars` library. We
    are going to use the latter because it has fewer lines and the actual implementation
    is provided by the Netflix DGS framework.
  prefs: []
  type: TYPE_NORMAL
- en: The first, crude way of adding the scalar type is to implement the `graphql.schema.Coercing`
    interface and annotate it with the `@DgsScalar` annotation. Here, you need to
    write the boiler plate code yourself.
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead, we will opt for the second method, which involves using the scalar
    type provided by the DGS framework, which is well tested on production systems.
    The `graphql.schema.Coercing` interface is provided by the `graphql-java` library.
    The `DateTimeScalar` scalar type is implemented using `Coercing`, as shown in
    the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Here, you have overridden the three methods – `serialize()`, `parseValue()`,
    and `parseLiteral()` – of the `Coercing` interface to implement serialization
    and parsing for the `DateTimeScalar` custom scalar type.
  prefs: []
  type: TYPE_NORMAL
- en: However, you are going to use the second method – the `graphql-dgs-extended-scalars`
    library – for registering new scalar types. This library has already been added
    in the `build.gradle` file. Let’s make use of the `graphql-dgs-extended-scalars`
    library to register the `BigDecimalScaler` type.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new Java file called `BigDecimalScaler.java` and add the following
    code to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '[https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/blob/dev/Chapter14/src/main/java/com/packt/modern/api/scalar/BigDecimalScalar.java](https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/blob/dev/Chapter14/src/main/java/com/packt/modern/api/scalar/BigDecimalScalar.java)'
  prefs: []
  type: TYPE_NORMAL
- en: Here, you are making use of `DgsRuntimeWiring` to add the custom `GraphQLBigDecimal`
    scalar provided by the `graphql-dgs-extended-scalars` library. The `RuntimeWiring`
    class comprises data fetchers, type resolvers, and custom scalars that are needed
    to wire together a functional `GraphQLSchema` class. The `DgsRuntimeWiring` annotation
    marks the method as runtime wiring. So, you can perform the customization before
    the `RuntimeWiring` class gets executed. Basically, you are adding the `GraphQLBigDecimal`
    scalar type to `RuntimeWiring.Builder` for runtime wiring execution.
  prefs: []
  type: TYPE_NORMAL
- en: The `BigDecimalScalar` class is marked with the `@Dgs``Component` annotation.
    The DGS framework is an annotation-based Spring Boot programming model. The DGS
    framework provides these types of annotations (such as `@DgsComponent`) for Spring
    Boot. A class marked with `@DgsComponent` is a DGS component as well as a regular
    Spring component.
  prefs: []
  type: TYPE_NORMAL
- en: Similarly, you have added the `DateTimeScalar` type. The code for the `DateTimeScalar`
    scalar type is available at [https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/dev/Chapter14/src/main/java/com/packt/modern/api/scalar/DateTimeScalar.java](https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/dev/Chapter14/src/main/java/com/packt/modern/api/scalar/DateTimeScalar.java).
  prefs: []
  type: TYPE_NORMAL
- en: All the schema details and its documentation can be explored using the GraphQL
    documentation that is available in GraphiQL or similar tools. Let’s find out how
    you find the auto-generated documentation next.
  prefs: []
  type: TYPE_NORMAL
- en: Documenting APIs
  prefs: []
  type: TYPE_NORMAL
- en: You can use GraphiQL or a playground tool that provides a graphical interface
    to explore the GraphQL schema and documentation.
  prefs: []
  type: TYPE_NORMAL
- en: On GraphiQL (`http://localhost:8080/graphiql`, which can be started by running
    the `jar` built out of this chapter code), you can open the document explorer
    by clicking on the book icon available in the top-left corner of the page. Once
    you click on it, it will display the documentation.
  prefs: []
  type: TYPE_NORMAL
- en: However, if you are looking for a static page, then you can use tools such as
    `graphdoc` ([https://github.com/2fd/graphdoc](https://github.com/2fd/graphdoc))
    to generate the static documentation for the GraphQL APIs.
  prefs: []
  type: TYPE_NORMAL
- en: Next, let’s start implementing GraphQL root types. First, you are going to implement
    GraphQL queries.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing GraphQL queries
  prefs: []
  type: TYPE_NORMAL
- en: Both the queries we introduced in the schema in the previous section are straightforward.
    You pass a product ID to find a product identified by that ID – that’s the product
    query for you. Next, you pass the optional product criteria to find the products
    based on the given criteria; otherwise, products are returned based on the default
    values of the fields of product criteria.
  prefs: []
  type: TYPE_NORMAL
- en: In REST, you implemented the controller class in the *Implementing the OAS code
    interfaces* section of [*Chapter 3*](B19349_03.xhtml#_idTextAnchor080), *API Specifications
    and Implementation*. You created a controller, passed the call to the service,
    and the service called the repository to fetch the data from the database. You
    are going to use the same design. However, you are going to use `ConcurrentHashMap`
    in place of the database to simplify the code. This can also be used in your automated
    tests.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s create a repository class for that, as shown in the next code block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '[https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/dev/Chapter14/src/main/java/com/packt/modern/api/repository/Repository.java](https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/dev/Chapter14/src/main/java/com/packt/modern/api/repository/Repository.java)'
  prefs: []
  type: TYPE_NORMAL
- en: These are straightforward signatures for fetching the product and collection
    of products.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s implement the newly created repository interface using `ConcurrentHashMap`,
    as shown in the next code block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '[https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/dev/Chapter14/src/main/java/com/packt/modern/api/repository/InMemRepository.java](https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/dev/Chapter14/src/main/java/com/packt/modern/api/repository/InMemRepository.java)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, you have created two instances of `ConcurrentHashMap` for storing the
    products and tags. Let’s add the seed data to these maps using the constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: This code first generates the tags and then stores them in the `tagEntities`
    map. The code also attaches the tags to new products before storing products in
    the `productEntities` map. This has been done for development purposes only. You
    should use the database in production applications.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, the `getProduct` and `getProducts` methods are straightforward, as shown
    in the next code block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The `getProduct` method performs the basic validations and returns the product.
    The `getProducts` method simply returns the collection of products converted from
    the map.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, you can add the service and its implementation. Let’s add the service
    interface as shown in the next code block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '[https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/dev/Chapter14/src/main/java/com/packt/modern/api/services/ProductService.java](https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/dev/Chapter14/src/main/java/com/packt/modern/api/services/ProductService.java)'
  prefs: []
  type: TYPE_NORMAL
- en: 'These service method implementations simply call the repository to fetch the
    data. Let’s add the implementation shown in the next code block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '[https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/dev/Chapter14/src/main/java/com/packt/modern/api/services/ProductServiceImpl.java](https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/dev/Chapter14/src/main/java/com/packt/modern/api/services/ProductServiceImpl.java)'
  prefs: []
  type: TYPE_NORMAL
- en: Here, the repository is injected using constructor injection.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s add the `getProducts()` method also, which performs filtering based on
    given filtering criteria, as shown in the next code block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: This method first checks whether criteria are given or not. If criteria are
    not given, then it calls the repository and returns all the products.
  prefs: []
  type: TYPE_NORMAL
- en: If criteria are given, then it creates the `predicates` list. These `predicates`
    are then used to filter out the matching products and return to the calling function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now comes the most critical piece of GraphQL query implementation: writing
    the data fetchers. First, let’s write the data fetcher for the `product` query.'
  prefs: []
  type: TYPE_NORMAL
- en: Writing fetchers for GraphQL queries
  prefs: []
  type: TYPE_NORMAL
- en: You are going to write data fetchers in this section. Data fetchers, as the
    name suggests, retrieve the information from the source that is from a persistent
    store such as a database or a third-party API/document store. You will learn how
    to write data fetchers to retrieve a single field of data, a single object, and
    a collection of objects.
  prefs: []
  type: TYPE_NORMAL
- en: Writing the data fetcher for product
  prefs: []
  type: TYPE_NORMAL
- en: The data fetcher is a critical DSG component for serving GraphQL requests that
    fetches the data and the DSG internally resolves each of the fields. You mark
    them with the special `@DgsComponent` DGS annotation. These are types of Spring
    components that the DGS framework scans and uses for serving requests.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s create a new file called `ProductDatafetcher.java` in the `datafetchers`
    package to represent a DGS data fetcher component. It will have a data fetcher
    method for serving the `product` query. You can add the following code to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '[https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/dev/Chapter14/src/main/java/com/packt/modern/api/datafetchers/ProductDatafetcher.java](https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/dev/Chapter14/src/main/java/com/packt/modern/api/datafetchers/ProductDatafetcher.java)'
  prefs: []
  type: TYPE_NORMAL
- en: Here, you create a product service bean injection using the constructor. This
    service bean helps you to find the product based on the given product ID.
  prefs: []
  type: TYPE_NORMAL
- en: 'Two other important DGS framework annotations have been used in the `getProduct`
    method. Let’s understand what they do:'
  prefs: []
  type: TYPE_NORMAL
- en: '`@DgsData`: This is a data fetcher annotation that marks the method as the
    data fetcher. The `parentType` property represents the type, and the `field` property
    represents the type’s (`parentType`) field. Therefore, you can say that method
    will fetch the field of the given type.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You have set `Query` as `parentType`. The `field` property is set as a `product`
    query. Therefore, this method works as an entry point for the GraphQL query product
    call. The `@DsgData` annotation properties are set using the `DgsConstants` constants
    class.
  prefs: []
  type: TYPE_NORMAL
- en: '`DgsConstants` is generated by the DGS Gradle plugin, which contains all the
    constant parts of the schema.'
  prefs: []
  type: TYPE_NORMAL
- en: '`@InputArgument`: This annotation allows you to capture the arguments passed
    by the GraphQL requests. Here, the value of the `id` parameter is captured and
    assigned to the `id` string variable.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can find the test cases related to this data fetcher method in the *Test*
    *automation* section.
  prefs: []
  type: TYPE_NORMAL
- en: Similarly, you can write the data fetcher method for the `products` query. Let’s
    code it in the next subsection.
  prefs: []
  type: TYPE_NORMAL
- en: Writing the data fetcher for a collection of products
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s create a new file called `ProductsDatafetcher.java` in the `datafetchers`
    package to represent a DGS data fetcher component. It will have a data fetcher
    method for serving the `products` query. You can add the following code to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '[https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/dev/Chapter14/src/main/java/com/packt/modern/api/datafetchers/ProductsDatafetcher.java](https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/dev/Chapter14/src/main/java/com/packt/modern/api/datafetchers/ProductsDatafetcher.java)'
  prefs: []
  type: TYPE_NORMAL
- en: This `getProducts()` method does not look different from the data fetcher method
    returned for `getProduct()` in the second-to-last code block. Here, the `parentType`
    and `field` properties of `@DsgData` indicate that this method will be used to
    fetch the collection of products for the `products` query (note that we are using
    the plural form here).
  prefs: []
  type: TYPE_NORMAL
- en: 'You are done with the GraphQL query implementation. You can now test your changes.
    You need to build the application before running the test. Let’s build the application
    using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the build is done successfully, you can run the following command to run
    the application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: The application should be running on the default port `8080` if you have not
    made any changes to the port settings.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, you can open a browser window and open GraphiQL using the following URL:
    `http://localhost:8080/graphiql` (part of the DGS framework). Change the host/port
    accordingly if required.'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use the following query to fetch the collection of products:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Once you run the preceding query, it will fetch the products matching the given
    criteria in the filter.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 14.2 – GraphQL query execution in the GraphiQL tool](img/Figure_14.2_B19349.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 14.2 – GraphQL query execution in the GraphiQL tool
  prefs: []
  type: TYPE_NORMAL
- en: This will work great. However, what if you want to fetch the tags separately?
    You might have relations (such as orders with billing information) in objects
    that may be fetched from separate databases or services, or from two separate
    tables. In that case, you might want to add a field resolver using the data fetcher
    method.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s add a field resolver using the data fetcher method in the next subsection.
  prefs: []
  type: TYPE_NORMAL
- en: Writing the field resolver using the data fetcher method
  prefs: []
  type: TYPE_NORMAL
- en: So far, you don’t have a separate data fetcher for fetching the tags. You fetch
    the products, and it also fetches the tags for you because we are using a concurrent
    map that stores both queries’ data together. Therefore, first, you need to write
    a new data fetcher method for fetching the tags for a given product.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s add the `tags()` method to the `ProductsDatafetcher` class to fetch the
    tags, as shown in the next code block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: '[https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/dev/Chapter14/src/main/java/com/packt/modern/api/datafetchers/ProductsDatafetcher.java](https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/dev/Chapter14/src/main/java/com/packt/modern/api/datafetchers/ProductsDatafetcher.java)'
  prefs: []
  type: TYPE_NORMAL
- en: Here, the `tags()` method has a different set of values for the `@DsgData` properties.
    The `parentType` property is not set to a root type like in earlier data fetcher
    methods, which were set to `Query`. Instead, it is set to an object type – `Product`.
    The `field` property is set to `tags`.
  prefs: []
  type: TYPE_NORMAL
- en: This method will be called for fetching the tags for each individual product
    because it is a field resolver for the `tags` field of the `Product` object. Therefore,
    if you have 20 products, this method will be called 20 times to fetch the tags
    for each of the 20 products. This is an *N+1* problem, which we learned about
    in the *Solving the N+1 problem* section in [*Chapter 13*](B19349_13.xhtml#_idTextAnchor288),
    *Getting Started* *with GraphQL*.
  prefs: []
  type: TYPE_NORMAL
- en: In the N+1 problem, extra database calls are made for fetching the data for
    relations. Therefore, given a collection of products, it may hit a database for
    fetching the tags for each product separately.
  prefs: []
  type: TYPE_NORMAL
- en: You know that you must use data loaders to avoid the N+1 problem. Data loaders
    cache all the IDs of products before fetching their corresponding tags in a single
    query.
  prefs: []
  type: TYPE_NORMAL
- en: Next, let’s learn how to implement a data loader for fixing the N+1 problem
    in this case.
  prefs: []
  type: TYPE_NORMAL
- en: Writing a data loader for solving the N+1 problem
  prefs: []
  type: TYPE_NORMAL
- en: You are going to make use of the `DataFetchingEnvironment` class as an argument
    in the data fetcher methods. It is injected by the `graphql-java` library in the
    data fetcher methods to provide the execution context. This execution context
    contains information about the resolver, such as the object and its fields. You
    can also use them in special use cases such as loading the data loader classes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s modify the `tags()` method in the `ProductsDatafetcher` class mentioned
    in the previous code block to fetch the tags without the N+1 problem, as shown
    in the next code block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: '[https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/dev/Chapter14/src/main/java/com/packt/modern/api/datafetchers/ProductsDatafetcher.java](https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/dev/Chapter14/src/main/java/com/packt/modern/api/datafetchers/ProductsDatafetcher.java)'
  prefs: []
  type: TYPE_NORMAL
- en: Here, the modified `tags()` data fetcher method performs the `fetch` method
    using a data loader and returns the collection of tags wrapped inside `CompletableFuture`.
    And it will be called only once even if the number of products is more than *1*.
  prefs: []
  type: TYPE_NORMAL
- en: What is CompletableFuture?
  prefs: []
  type: TYPE_NORMAL
- en: '`CompletableFuture` is a Java concurrency class that represents the result
    of asynchronous computation, which is marked as completed explicitly. It can chain
    multiple dependent tasks asynchronously where the next task will be triggered
    when the current task’s result is available.'
  prefs: []
  type: TYPE_NORMAL
- en: You are using `DsgDataFetchingEnvironment` as an argument. It implements the
    `DataFetchingEnvironment` interface and provides ways to load the data loader
    class by both its class and name. Here, you are using the data loader class to
    load the data loader.
  prefs: []
  type: TYPE_NORMAL
- en: The `getSource()` method of `DsgDataFetchingEnvironment` returns the value from
    the `parentType` property of `@DsgData`. Therefore, `getSource()` returns `Product`.
  prefs: []
  type: TYPE_NORMAL
- en: This modified data fetcher method will fetch the tags for a given list of products
    in a single call. This method will fetch the tags for a list of products because
    the data loader class implements `MappedBatchLoader`, which performs the operation
    using batches.
  prefs: []
  type: TYPE_NORMAL
- en: The data loader class fetches the tags of the given product (by ID) using the
    data loader in batches. The magic lies in returning `CompletableFuture`. Therefore,
    though you are passing a single product ID as an argument, the data loader processes
    it in bunches. Let’s implement this data loader class (`TagsDataloaderWithContext`)
    next to dig into it more.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can create a data loader class in two ways – with context or without context.
    Data loaders without context implement `MappedBatchLoader`, which has the following
    method signature:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'On the other hand, data loaders with context implement the `MappedBatchLoaderWithContext`
    interface, which has the following method signature:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Both are the same as far as data loading is concerned. However, the data loader
    with context provides you with extra information (through `BatchLoaderEnvironment`)
    that can be used for various additional features, such as authentication, authorization,
    or passing the database details.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new Java file called `TagsDataloaderWithContext.java` in the `dataloaders`
    package with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: '[https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/dev/Chapter14/src/main/java/com/packt/modern/api/dataloaders/TagsDataloaderWithContext.java](https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/dev/Chapter14/src/main/java/com/packt/modern/api/dataloaders/TagsDataloaderWithContext.java)'
  prefs: []
  type: TYPE_NORMAL
- en: Here, it implements the `load()` method from the `MappedBatchLoaderWithContext`
    interface. It contains the `BatchLoaderEnvironment` argument, which provides the
    environment context, which can contain user authentication and authorization information
    or database information. However, we are not using it because we don’t have any
    additional information related to authentication, authorization, or the database
    to pass to the repository or underlying data access layer. If you do, you can
    make use of the `environment` argument.
  prefs: []
  type: TYPE_NORMAL
- en: You can also find the data loader without context at [https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/dev/Chapter14/src/main/java/com/packt/modern/api/dataloaders/TagDataloader.java](https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/dev/Chapter14/src/main/java/com/packt/modern/api/dataloaders/TagDataloader.java).
    Its code is more or less like what we have written for the data loader with context.
    The only difference is we haven’t used the context.
  prefs: []
  type: TYPE_NORMAL
- en: You can see that it makes use of the tag’s service to fetch the tags. Then,
    it simply returns the completion stage by supplying the tags received from the
    tag service. This operation is performed in a batch by the data loader.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can create a new tag service and its implementation as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: '[https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/dev/Chapter14/src/main/java/com/packt/modern/api/services/TagService.java](https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/dev/Chapter14/src/main/java/com/packt/modern/api/services/TagService.java)'
  prefs: []
  type: TYPE_NORMAL
- en: This is the signature of the `getTags` method, which returns the map of product
    IDs with corresponding tags.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s implement this interface as shown in the next code block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: '[https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/dev/Chapter14/src/main/java/com/packt/modern/api/services/TagServiceImpl.java](https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/dev/Chapter14/src/main/java/com/packt/modern/api/services/TagServiceImpl.java)'
  prefs: []
  type: TYPE_NORMAL
- en: Here, the implemented method is straightforward. It passes the call to the repository,
    which fetches the tags based on the passed collection of product IDs.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can add `getProductTagMappings` to the `src/main/java/com/packt/ modern/api/repository/Repository.java`
    interface as shown in the next line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, you can implement this method in the `src/main/java/com/packt/ modern/api/repository/InMemRepository.java`
    class as shown in the next code block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Here, the code first creates the stream of the product map’s entry set, then
    filters the products that match the product passed in this method. At the end,
    it converts filtered products to map the product ID with the `Key` and `Tags`
    values and then returns `map`.
  prefs: []
  type: TYPE_NORMAL
- en: Now, if you call the `product` GraphQL query, and even if products are fetched
    with a properly normalized database, it loads the product tags in batches without
    the *N+1* problem.
  prefs: []
  type: TYPE_NORMAL
- en: You are done with GraphQL query implementation and should be comfortable with
    implementing queries on your own.
  prefs: []
  type: TYPE_NORMAL
- en: Next, you are going to implement GraphQL mutations.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing GraphQL mutations
  prefs: []
  type: TYPE_NORMAL
- en: As per the GraphQL schema, you are going to implement two mutations – `addTag`
    and `addQuantity`.
  prefs: []
  type: TYPE_NORMAL
- en: The `addTag` mutation takes `productId` and a collection of tags as arguments
    and returns the `Product` object. The `addQuantity` mutation takes `productId`
    and the quantity to add and returns `Product`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s add this implementation to the existing `ProductDatafetcher` class as
    shown in the following code block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: '[https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/dev/Chapter14/src/main/java/com/packt/modern/api/datafetchers/ProductsDatafetcher.java](https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/dev/Chapter14/src/main/java/com/packt/modern/api/datafetchers/ProductsDatafetcher.java)'
  prefs: []
  type: TYPE_NORMAL
- en: Here, these signatures follow the respective mutations written in the GraphQL
    schema. You are using another DGS framework `@DgsMutation` annotation, which is
    a type of `@DgsData` annotation that is marked on methods to denote them as a
    data fetcher method. The `@DgsMutation` annotation, by default, has the `Mutation`
    value set to the `parentType` property. You just must set the `field` property
    in this annotation. Both methods have their respective values set to the `field`
    property in the `@``DgsMutation` annotation.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that the `@InputArgument` annotation for tags uses another `collectionType`
    property that is used for setting the type of input. It is required when the input
    type is not scalar. If you don’t use it, you’ll get an error. Therefore, make
    sure to use the `collectionType` property whenever you have a non-scalar type
    input.
  prefs: []
  type: TYPE_NORMAL
- en: 'These methods use the tag and product services to perform the requested operations.
    So far, you have not added the tag service into the `ProductDatafetcher` class.
    Therefore, you need to add `TagService` first, as shown in the next code block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Here, the `TagService` bean has been injected using the constructor.
  prefs: []
  type: TYPE_NORMAL
- en: Now, you need to implement the `addTag()` method in the `TagService` and `addQuantity`
    methods in `ProductService`. Both the interfaces and their implementations are
    straightforward and pass the call to the repository to perform the operations.
    You can find the complete source code `TagService` and `ProductService` classes
    in the GitHub code repository ([https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/dev/Chapter14/src/main/java/com/packt/modern/api/services](https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/dev/Chapter14/src/main/java/com/packt/modern/api/services)).
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s also add these two methods to the `Repository` interface as shown in
    the next code block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: These signatures in the `src/main/java/com/packt/modern/api/repository /Repository.java`
    interface also follow the respective mutations written in the GraphQL schema.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s implement the `addTags()` method first in the `src/main/java/com/packt/
    modern/api/repository/InMemRepository.java` class, as shown in the next code block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: '[https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/dev/Chapter14/src/main/java/com/packt/modern/api/repository/InMemRepository.java](https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/dev/Chapter14/src/main/java/com/packt/modern/api/repository/InMemRepository.java)'
  prefs: []
  type: TYPE_NORMAL
- en: Here, you first perform the validation for the `productId` and `tags` arguments.
    If everything goes fine, then you add the tags to the product, update the concurrent
    map, and return the updated product.
  prefs: []
  type: TYPE_NORMAL
- en: 'You are done with the implementation of GraphQL mutations. You can now test
    your changes. You need to build the application before running the test. Let’s
    build the application using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the build is done successfully, you can run the following command to run
    the application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: The application should be running on default port `8080` if you have not made
    any changes to the port settings.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, you can open a browser window and open *GraphiQL* using the following
    URL: [http://localhost:8080/graphiql](http://localhost:8080/graphiql) (part of
    the DGS framework). Change the host/port accordingly if required.'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use the following GraphQL request to perform the `addTag` mutation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, you are adding the tags to the given `productId`; therefore, you pass
    `productId` and `tags` as arguments. You can use the following GraphQL request
    to perform the `addQuantity` mutation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Here, you pass `productId` and `quantity` as arguments. You have learned how
    to implement GraphQL mutations in the GraphQL server. Let’s implement GraphQL
    subscriptions in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing and testing GraphQL subscriptions
  prefs: []
  type: TYPE_NORMAL
- en: Subscription is another GraphQL root type that sends the object to the subscriber
    (client) when a particular event occurs.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s assume an online shop offers a discount on products when the product’s
    inventory reaches a certain level. You cannot track each product’s quantity manually
    and then perform the computation and trigger the discount. To do things faster
    (or reduce manual intervention), this is where you can make use of a subscription.
  prefs: []
  type: TYPE_NORMAL
- en: Each change in the product’s inventory (quantity) through the `addQuantity()`
    mutation should trigger the event and the subscriber should receive the updated
    product and hence the quantity. Then, the subscriber can place the logic and automate
    this process.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s write the subscription that will send the updated product object to the
    subscriber. You are going to use Reactive Streams and WebSocket to implement this
    functionality.
  prefs: []
  type: TYPE_NORMAL
- en: 'You need to enable CORS. Let’s enable it by adding the following properties
    into the `application.properties` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: '[https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/dev/Chapter14/src/main/resources/application.properties](https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/dev/Chapter14/src/main/resources/application.properties)'
  prefs: []
  type: TYPE_NORMAL
- en: Here, you have also enabled the actuator metrics and tracing for GraphQL along
    with exposing the health and metrics actuator endpoints.
  prefs: []
  type: TYPE_NORMAL
- en: In `build.gradle`, you have `graphql-dgs-subscriptions-websockets-autoconfigure`
    to take care of the auto-configuration of WebSocket that is required for WebSocket-based
    GraphQL subscriptions.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can add the following subscription data fetcher to the `ProductDatafetcher`
    class as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: '[https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/dev/Chapter14/src/main/java/com/packt/modern/api/datafetchers/ProductDatafetcher.java](https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/dev/Chapter14/src/main/java/com/packt/modern/api/datafetchers/ProductDatafetcher.java)'
  prefs: []
  type: TYPE_NORMAL
- en: Here, you are using another DGS framework annotation, `@DgsSubscription`, which
    is a type of `@DgsData` annotation that is marked on a method to denote it as
    a data fetcher method. The `@DgsSubscription` annotation, by default, has the
    `Subscription` value set to the `parentType` property. You just must set the `field`
    property in this annotation. By setting `field` to `quantityChanged`, you are
    indicating to the DGS framework to use this method when the subscription request
    for `quantityChanged` is called.
  prefs: []
  type: TYPE_NORMAL
- en: The `Subscription` method returns the `Publisher` instance, which can send an
    unbound number of objects (in this case, `Product` instances) to multiple subscribers.
    Therefore, the client just needs to subscribe to the product publisher.
  prefs: []
  type: TYPE_NORMAL
- en: You need to add a new method to the `ProductService` interface and its implementation
    in the `ProductServiceImpl` class. The method signature in the `ProductService`
    interface and its implementation are straightforward. It passes the call to the
    repository to perform the operation. You can have a look at the source code in
    the book’s GitHub code repository.
  prefs: []
  type: TYPE_NORMAL
- en: 'The actual work is being performed by the repository. Therefore, you need to
    make certain changes in the repository, as shown in the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, add the following method signature to the repository interface:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '2.  Next, you have to implement the `getProductPublisher()` method in the `InMemRepository`
    class. This method returns the product publisher as shown in the following code:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '3.  Now, we need all the magic to be performed by Reactive Streams. First,
    let’s declare the `FluxSink<Product>` and `ConnectableFlux<Product>` (which is
    returned by the repository) variables:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Flux<Product> is a product stream publisher that passes the baton to productsStream
    (FluxSink) to emit the next signals followed by onError() or onComplete() events.
    This means productsStream should emit the signal when the product quantity gets
    changed. When Flux<Product> calls the publish() method, it returns an instance
    of connectableFlux, which is assigned to productPublisher (the one that is returned
    by the subscription).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You are almost done with the setup. You just need to emit the signal (product)
    when the product gets changed. Let’s add the following highlighted line to the
    `addQuantity()` method before it returns the product, as shown in the following
    code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: You have completed the subscription `quantityChanged` implementation. You can
    test it next.
  prefs: []
  type: TYPE_NORMAL
- en: 'You need to build the application before running the test. Let’s build the
    application using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the build is done successfully, you can run the following command to run
    the application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: The application should be running on the default port `8080` if you have not
    made any changes to the port settings.
  prefs: []
  type: TYPE_NORMAL
- en: Before testing the GraphQL subscription, you need to understand the GraphQL
    subscription protocol over WebSocket.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the WebSocket sub-protocol for GraphQL
  prefs: []
  type: TYPE_NORMAL
- en: You have implemented the GraphQL subscription over WebSocket in this chapter.
    In WebSocket-based subscription implementation, the network socket is the main
    communication channel between the GraphQL server and the client.
  prefs: []
  type: TYPE_NORMAL
- en: The `graphql-dgs-subscriptions-websockets-autoconfigure` dependency’s current
    implementation (*version 6.0.5*) makes use of `graphql-transport-ws` sub-protocol
    specifications. In this sub-protocol, messages are represented using the JSON
    format, and over the network, these JSON messages are *stringified*. Both the
    server and client should conform to this message structure.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are the following types of messages (code in Kotlin from the DGS framework):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'You might have got the idea about the life cycle of a GraphQL subscription
    over WebSocket by looking at the message type. Let’s understand the life cycle
    of a subscription in detail:'
  prefs: []
  type: TYPE_NORMAL
- en: '`CONNECTION_INIT`): The client initiates the communication by sending this
    type of message. The connection initialization message contains two fields – `type`
    (`''connection_init''`) and `payload`. The `payload` field is an optional field.
    Its (`ConnectionInitMessage`) structure is represented as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '2.  `CONNECTION_ACK`): The server sends the connection acknowledgment in response
    to a successful connection initialization request. It means the server is ready
    for subscription. Its structure (`ConnectionAckMessage`) is represented as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '3.  `SUBSCRIBE`): The client now can send the `subscribe` request. If the client
    sends the `subscribe` request without getting a connection acknowledgment from
    the server, the client may get the error `4401: Unauthorized`.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'This request contains three fields – `id`, `type`, and `payload`. Here, each
    new subscription request should contain a unique `id`; otherwise, the server may
    throw `4409: Subscriber for <unique-operation-id> already exists`. The server
    keeps track of the `id`, until the subscription is active. The moment the subscription
    is complete, the client can reuse the `id`. The structure of this message type
    (`SubscribeMessage`) is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: '`NEXT`): After a successful subscription operation, the client receives the
    messages of type `NEXT` from the server that contain the data related to the operation
    the client subscribes to. Data is part of the `payload` field. The server keeps
    sending these message types to the client until GraphQL subscription events occur.
    Once the operation gets completed, the server sends the complete message to the
    client. Its message type (`NextMessage`) is represented by the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '2.  `COMPLETE`): `Complete` is a bi-directional message, which can be sent
    by both the server and client:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '*Client to Server*: The client can send the complete message to the server
    when the client wants to stop listening to the message sent by the server. Since
    it’s a duplex call, the client should ignore the messages that are en route when
    the client sends a complete request.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Server to Client*: The server sends the complete message to the client when
    the requested operation is completed by the server. The server doesn’t send the
    complete message when an error message is sent by the server for the subscription
    request by the client.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The message type (`CompleteMessage`) is represented by the following structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: '`ERROR`): The server sends an error message when the server encounters any
    operation execution error. Its type (`ErrorMessage`) is represented by the following
    structure:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '2.  `PING` and `PONG`: These are bi-directional message types and are sent
    by both the server and client. If the client sends a `ping` message, the server
    should immediately send a `pong` message and vice versa. These messages are useful
    for detecting networking problems and network latency. Both `ping` (`PingMessage`)
    and `pong` (`PongMessage`) contain the following structure:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Understanding the subscription life cycle will help you test the subscription
    thoroughly.
  prefs: []
  type: TYPE_NORMAL
- en: You can use any tool that supports GraphQL subscription testing. We’ll test
    it using the Insomnia WebSocket request client – a bit of a crude way so you can
    understand the complete life cycle of the GraphQL subscription.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 14.3 – GraphQL subscription connection_init call in the Insomnia client](img/Figure_14.3_B19349.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 14.3 – GraphQL subscription connection_init call in the Insomnia client
  prefs: []
  type: TYPE_NORMAL
- en: Testing GraphQL subscriptions using Insomnia WebSocket
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s perform the following steps to test the subscription manually:'
  prefs: []
  type: TYPE_NORMAL
- en: First, add a new request using *WebSocket Request* by using the (**+**) drop-down
    menu available in the top-left corner.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Then add the following URL in the **URL** box:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '3.  Then, add the following headers in the **Headers** tab:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here, through the headers, you upgrade the connection to WebSocket; therefore,
    the server sends the `101 Switching Protocol` response. Also, you can see that
    you are using the `graphql-transport-ws` GraphQL sub-protocol.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, add the following payload in the **JSON** tab for connection initialization
    (see *Figure 14**.3*):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 2.  Then, click on the **Send** button (don’t click on the **Connect** button
    – if you do, then it needs to be followed by one more click on **Send**).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'On a successful connection, you will receive the following acknowledgment message
    from the server. It means the server is ready to serve the subscription request
    (shown in *Figure 14**.3*):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '4.  Then, use the following payload in the **JSON** tab:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here, you are adding a unique ID to the message. The type of message is set
    to `subscribe`. You can send a `subscribe` message because a connection acknowledgment
    is received by the client. The `query` field contains the GraphQL subscription
    query.
  prefs: []
  type: TYPE_NORMAL
- en: Then, again click on the **Send** button (don’t click on the **Connect** button
    – if you do, then it needs to be followed by one more click on **Send**).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'After clicking on the `addQuantity` mutation to trigger the publication of
    the event by using the following payload:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 3.  After a successful mutation call, you can check the subscription output
    in the Insomnia client. You will find an incoming JSON message that will display
    the increased quantity, as shown in *Figure 14**.4*.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: You can repeat *steps 9 and 10* to get the (`NEXT` type) messages.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once you are done, you can send the following JSON payload to complete the call
    as shown in *Figure 14**.4:*
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '![Figure 14.4 – GraphQL subscription’s next and complete calls in the Insomnia
    client](img/Figure_14.4_B19349.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 14.4 – GraphQL subscription’s next and complete calls in the Insomnia
    client
  prefs: []
  type: TYPE_NORMAL
- en: This is the way you can implement and test the GraphQL subscription over WebSocket.
    You will automate the test for GraphQL subscription in the *Testing GraphQL subscriptions
    using automated test code* subsection in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Next, you should know about the instrumentation that helps to implement the
    tracing, logging, and metrics collection. Let’s discuss this in the next subsection.
  prefs: []
  type: TYPE_NORMAL
- en: Instrumenting the GraphQL APIs
  prefs: []
  type: TYPE_NORMAL
- en: The GraphQL Java library supports the instrumentation of the GraphQL APIs. This
    can be used to support metrics, tracing, and logging. The DGS framework also uses
    it. You just must mark the instrumentation class with the Spring `@``Component`
    annotation.
  prefs: []
  type: TYPE_NORMAL
- en: The instrumentation bean can be implemented using the `graphql.execution. instrumentation.Instumentation`
    interface. Here, you have to write boilerplate code, which may increase the unit
    test automation code for you. Another way that is much easier is to extend the
    `SimpleInstrumentation` class, which does the simple implementation for you. However,
    you can override the methods for custom implementation.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s add instrumentation that will record the time taken by the data fetcher
    and complete GraphQL request processing. This metric may help you to fine-tune
    the performance and identify the fields that take more time to resolve.
  prefs: []
  type: TYPE_NORMAL
- en: Before adding the tracing, let’s add the custom header in the response.
  prefs: []
  type: TYPE_NORMAL
- en: Adding a custom header
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s create the `DemoInstrumentation.java` file in the `instrumentation` package
    and add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: '[https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/dev/Chapter14/src/main/java/com/packt/modern/api/instrumentation/DemoInstrumentation.java](https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/dev/Chapter14/src/main/java/com/packt/modern/api/instrumentation/DemoInstrumentation.java)'
  prefs: []
  type: TYPE_NORMAL
- en: Here, this class extends `SimpleInstrumentation` and is created as a Spring
    bean by marking it as `@Component`. The `SimpleInstrumentation` class allows you
    to instrument the execution result. Here, you can see that you have added the
    custom header in the response. Let’s test it.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can build and execute the project after adding the previous code and then
    execute the following mutation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: You’ll find the instrumented `myHeader` header and its value in the response
    headers.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, you can instrument the tracing information in your response by adding
    the following bean to your project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: '[https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/dev/Chapter14/src/main/java/com/packt/modern/api/instrumentation/InstrumentationConfig.java](https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/dev/Chapter14/src/main/java/com/packt/modern/api/instrumentation/InstrumentationConfig.java)'
  prefs: []
  type: TYPE_NORMAL
- en: This configuration does the magic. You must remember that you need `com.netflix.graphql.dgs:graphql-dgs-spring-boot-micrometer`
    along with Spring Actuator dependencies in your `build.gradle` file to make it
    work.
  prefs: []
  type: TYPE_NORMAL
- en: The previous code adds the execution result metrics provided by the DGS framework
    to GraphQL API responses. This metric includes the tracing time and duration,
    validation time and duration, the resolver’s information, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: Once you have this instrumentation in place and execute any query or mutation,
    the result will include the extension fields consisting of the result metrics
    instrumented by the `Instrumentation` bean (GraphQL Tracing) created in the previous
    code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s execute the following mutation in GraphiQL (`http://localhost:8080/graphiql`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'The previous mutation will provide the following response with instrumented
    metrics:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: Here, you can see that it not only returns `data` but also provides the instrumented
    metrics in the `extensions` field. Please note that you should keep this instrumentation
    enabled only for the development environment to fine-tune the GraphQL implementation
    and benchmarking, and keep it disabled for the production environment.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s find out more about the instrumentation metrics in the next subsection.
  prefs: []
  type: TYPE_NORMAL
- en: Integration with Micrometer
  prefs: []
  type: TYPE_NORMAL
- en: You have added `graphql-dgs-spring-boot-micrometer` as one of the dependencies
    in `build.gradle`. This library provides GraphQL metrics out of the box such as
    `gql.query`, `gql-resolver`, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can expose the `metrics` endpoint by adding the following line in the `application.properties`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: http://localhost:8080/actuator/metrics
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: http://localhost:8080/actuator/metrics/gql.query
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: '{  "name": "gql.query",'
  prefs: []
  type: TYPE_NORMAL
- en: '"baseUnit": "seconds",'
  prefs: []
  type: TYPE_NORMAL
- en: '"measurements": [{'
  prefs: []
  type: TYPE_NORMAL
- en: '"statistic": "COUNT",  "value": 4.0'
  prefs: []
  type: TYPE_NORMAL
- en: '}, {'
  prefs: []
  type: TYPE_NORMAL
- en: '"statistic": "TOTAL_TIME", "value": 1.403888175'
  prefs: []
  type: TYPE_NORMAL
- en: '}, {'
  prefs: []
  type: TYPE_NORMAL
- en: '"statistic": "MAX", "value": 0.0'
  prefs: []
  type: TYPE_NORMAL
- en: '}],'
  prefs: []
  type: TYPE_NORMAL
- en: '"availableTags": [{'
  prefs: []
  type: TYPE_NORMAL
- en: '"tag": "gql.query.sig.hash",'
  prefs: []
  type: TYPE_NORMAL
- en: '"values": ["10e750742768cb7c428699…",'
  prefs: []
  type: TYPE_NORMAL
- en: '"a750f4b9bb5d40f2d23b01…"]'
  prefs: []
  type: TYPE_NORMAL
- en: '}, {'
  prefs: []
  type: TYPE_NORMAL
- en: '"tag": "gql.operation",'
  prefs: []
  type: TYPE_NORMAL
- en: '"values": ["SUBSCRIPTION", "MUTATION"]'
  prefs: []
  type: TYPE_NORMAL
- en: '}, {'
  prefs: []
  type: TYPE_NORMAL
- en: '"tag": "gql.query.complexity", "values": ["10"]'
  prefs: []
  type: TYPE_NORMAL
- en: '}, {'
  prefs: []
  type: TYPE_NORMAL
- en: '"tag": "gql.operation.name", "values": ["anonymous"]'
  prefs: []
  type: TYPE_NORMAL
- en: '}, {'
  prefs: []
  type: TYPE_NORMAL
- en: '"tag": "outcome", "values": ["success", "failure"]'
  prefs: []
  type: TYPE_NORMAL
- en: '}]'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: '@SpringBootTest(classes = { DgsAutoConfiguration.class,     ProductDatafetcher.class,BigDecimalScalar.class
    })'
  prefs: []
  type: TYPE_NORMAL
- en: public class ProductDatafetcherTest {
  prefs: []
  type: TYPE_NORMAL
- en: private final InMemRepository repo = new InMemRepository();
  prefs: []
  type: TYPE_NORMAL
- en: private final int TEN = 10;
  prefs: []
  type: TYPE_NORMAL
- en: '@Autowired'
  prefs: []
  type: TYPE_NORMAL
- en: private DgsQueryExecutor dgsQueryExecutor;
  prefs: []
  type: TYPE_NORMAL
- en: '@MockBean'
  prefs: []
  type: TYPE_NORMAL
- en: private ProductService productService;
  prefs: []
  type: TYPE_NORMAL
- en: '@MockBean'
  prefs: []
  type: TYPE_NORMAL
- en: private TagService tagService;
  prefs: []
  type: TYPE_NORMAL
- en: // continue …
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: '@BeforeEachpublic void beforeEach() {'
  prefs: []
  type: TYPE_NORMAL
- en: List<Tag> tags = new ArrayList<>();
  prefs: []
  type: TYPE_NORMAL
- en: tags.add(Tag.newBuilder().id("tag1").name("Tag 1").build());
  prefs: []
  type: TYPE_NORMAL
- en: Product product = Product.newBuilder().id("any")
  prefs: []
  type: TYPE_NORMAL
- en: .name("mock title").description("mock description")
  prefs: []
  type: TYPE_NORMAL
- en: .price(BigDecimal.valueOf(20.20)).count(100)
  prefs: []
  type: TYPE_NORMAL
- en: .tags(tags).build();
  prefs: []
  type: TYPE_NORMAL
- en: given(productService.getProduct
  prefs: []
  type: TYPE_NORMAL
- en: ("any")).willReturn(product);
  prefs: []
  type: TYPE_NORMAL
- en: tags.add(Tag.newBuilder().id("tag2")
  prefs: []
  type: TYPE_NORMAL
- en: .name("addTags").build());
  prefs: []
  type: TYPE_NORMAL
- en: product.setTags(tags);
  prefs: []
  type: TYPE_NORMAL
- en: given(tagService.addTags("any",
  prefs: []
  type: TYPE_NORMAL
- en: List.of(TagInput.newBuilder().name("addTags").build())))
  prefs: []
  type: TYPE_NORMAL
- en: .willAnswer(invocation -> product);
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: '@Test@DisplayName("Verify JSON returned by the query ''product''")'
  prefs: []
  type: TYPE_NORMAL
- en: public void product() {
  prefs: []
  type: TYPE_NORMAL
- en: String name = dgsQueryExecutor.executeAndExtractJsonPath(
  prefs: []
  type: TYPE_NORMAL
- en: '"{product(id: \"any\"){ name }}",'
  prefs: []
  type: TYPE_NORMAL
- en: '"data.product.name");'
  prefs: []
  type: TYPE_NORMAL
- en: assertThat(name).contains("mock title");
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: '@Test@DisplayName("Verify exception to query product – invalid ID")'
  prefs: []
  type: TYPE_NORMAL
- en: public void productWithException() {
  prefs: []
  type: TYPE_NORMAL
- en: given(productService.getProduct("any"))
  prefs: []
  type: TYPE_NORMAL
- en: .willThrow(new RuntimeException
  prefs: []
  type: TYPE_NORMAL
- en: ("Invalid Product ID."));
  prefs: []
  type: TYPE_NORMAL
- en: ExecutionResult res = dgsQueryExecutor.execute(
  prefs: []
  type: TYPE_NORMAL
- en: '"{ product (id: \"any\") { name }}");'
  prefs: []
  type: TYPE_NORMAL
- en: verify(productService, times(1)).getProduct("any");
  prefs: []
  type: TYPE_NORMAL
- en: assertThat(res.getErrors()).isNotEmpty();
  prefs: []
  type: TYPE_NORMAL
- en: assertThat(res.getErrors().get(0).getMessage()).isEqualTo(
  prefs: []
  type: TYPE_NORMAL
- en: '"java.lang.RuntimeException:'
  prefs: []
  type: TYPE_NORMAL
- en: Invalid Product ID.");
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: '@Test@DisplayName("Verify JSON using GraphQLQueryRequest")'
  prefs: []
  type: TYPE_NORMAL
- en: void productsWithQueryApi() {
  prefs: []
  type: TYPE_NORMAL
- en: GraphQLQueryRequest gqlRequest = new GraphQLQueryRequest(
  prefs: []
  type: TYPE_NORMAL
- en: ProductGraphQLQuery.newRequest().id("any").build(),
  prefs: []
  type: TYPE_NORMAL
- en: new ProductProjectionRoot().id().name());
  prefs: []
  type: TYPE_NORMAL
- en: String name = dgsQueryExecutor.executeAndExtractJsonPath(
  prefs: []
  type: TYPE_NORMAL
- en: gqlRequest.serialize(), "data.product.name");
  prefs: []
  type: TYPE_NORMAL
- en: assertThat(name).contains("mock title");
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: '@Test@DisplayName("Verify Tags returned by the query ''product''")'
  prefs: []
  type: TYPE_NORMAL
- en: void productsWithTags() {
  prefs: []
  type: TYPE_NORMAL
- en: GraphQLQueryRequest gqlRequest = new GraphQLQueryRequest(
  prefs: []
  type: TYPE_NORMAL
- en: ProductGraphQLQuery.newRequest().id("any").build(),
  prefs: []
  type: TYPE_NORMAL
- en: new ProductProjectionRoot().id().name().tags()
  prefs: []
  type: TYPE_NORMAL
- en: .id().name());
  prefs: []
  type: TYPE_NORMAL
- en: Product product = dgsQueryExecutor
  prefs: []
  type: TYPE_NORMAL
- en: .executeAndExtractJsonPathAsObject(gqlRequest.serialize(),
  prefs: []
  type: TYPE_NORMAL
- en: '"data.product", new TypeRef<>() {});'
  prefs: []
  type: TYPE_NORMAL
- en: assertThat(product.getId()).isEqualTo("any");
  prefs: []
  type: TYPE_NORMAL
- en: assertThat(product.getName()).isEqualTo("mock title");
  prefs: []
  type: TYPE_NORMAL
- en: assertThat(product.getTags().size()).isEqualTo(2);
  prefs: []
  type: TYPE_NORMAL
- en: assertThat(product.getTags().get(0).getName())
  prefs: []
  type: TYPE_NORMAL
- en: .isEqualTo("Tag 1");
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: '@Test@DisplayName("Verify the mutation ''addTags''")'
  prefs: []
  type: TYPE_NORMAL
- en: void addTagsMutation() {
  prefs: []
  type: TYPE_NORMAL
- en: GraphQLQueryRequest gqlRequest = new GraphQLQueryRequest(
  prefs: []
  type: TYPE_NORMAL
- en: AddTagGraphQLQuery.newRequest().productId("any")
  prefs: []
  type: TYPE_NORMAL
- en: .tags(List.of(TagInput.newBuilder()
  prefs: []
  type: TYPE_NORMAL
- en: .name("addTags").build())).build(),
  prefs: []
  type: TYPE_NORMAL
- en: new AddTagProjectionRoot().name().count());
  prefs: []
  type: TYPE_NORMAL
- en: ExecutionResult exeResult = dgsQueryExecutor.execute(
  prefs: []
  type: TYPE_NORMAL
- en: gqlRequest.serialize());
  prefs: []
  type: TYPE_NORMAL
- en: assertThat(exeResult.getErrors()).isEmpty();
  prefs: []
  type: TYPE_NORMAL
- en: verify(tagService).addTags("any", List.of(
  prefs: []
  type: TYPE_NORMAL
- en: TagInput.newBuilder().name("addTags").build()));
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: '@Test@DisplayName("Verify the mutation ''addQuantity''")'
  prefs: []
  type: TYPE_NORMAL
- en: void addQuantityMutation() {
  prefs: []
  type: TYPE_NORMAL
- en: given(productService.addQuantity("a1s2d3f4-1", TEN))
  prefs: []
  type: TYPE_NORMAL
- en: .willReturn(repo.addQuantity("a1s2d3f4-1", TEN));
  prefs: []
  type: TYPE_NORMAL
- en: GraphQLQueryRequest gqlRequest = new GraphQLQueryRequest(
  prefs: []
  type: TYPE_NORMAL
- en: AddQuantityGraphQLQuery.newRequest()
  prefs: []
  type: TYPE_NORMAL
- en: .productId("a1s2d3f4-1").quantity(TEN).build(),
  prefs: []
  type: TYPE_NORMAL
- en: new AddQuantityProjectionRoot().name().count());
  prefs: []
  type: TYPE_NORMAL
- en: ExecutionResult exeResult = dgsQueryExecutor
  prefs: []
  type: TYPE_NORMAL
- en: .execute(gqlRequest.serialize());
  prefs: []
  type: TYPE_NORMAL
- en: assertThat(executionResult.getErrors()).isEmpty();
  prefs: []
  type: TYPE_NORMAL
- en: Object obj = executionResult.getData();
  prefs: []
  type: TYPE_NORMAL
- en: assertThat(obj).isNotNull();
  prefs: []
  type: TYPE_NORMAL
- en: Map<String, Object> data = (Map)((Map
  prefs: []
  type: TYPE_NORMAL
- en: )exeResult.getData()).get(MUTATION.AddQuantity);
  prefs: []
  type: TYPE_NORMAL
- en: org.hamcrest.MatcherAssert.assertThat(
  prefs: []
  type: TYPE_NORMAL
- en: (Integer) data.get("count"), greaterThan(TEN));
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: '@Test@DisplayName("Verify the subscription ''quantityChanged''")'
  prefs: []
  type: TYPE_NORMAL
- en: void reviewSubscription() {
  prefs: []
  type: TYPE_NORMAL
- en: given(productService.gerProductPublisher())
  prefs: []
  type: TYPE_NORMAL
- en: .willReturn(repo.getProductPublisher());
  prefs: []
  type: TYPE_NORMAL
- en: ExecutionResult exeResult = dgsQueryExecutor.execute(
  prefs: []
  type: TYPE_NORMAL
- en: '"subscription {quantityChanged'
  prefs: []
  type: TYPE_NORMAL
- en: '{id name price count}}");'
  prefs: []
  type: TYPE_NORMAL
- en: Publisher<ExecutionResult> pub = exeResult.getData();
  prefs: []
  type: TYPE_NORMAL
- en: List<Product> products = new CopyOnWriteArrayList<>();
  prefs: []
  type: TYPE_NORMAL
- en: pub.subscribe(new Subscriber<>() {
  prefs: []
  type: TYPE_NORMAL
- en: '@Override'
  prefs: []
  type: TYPE_NORMAL
- en: public void onSubscribe(Subscription s) {s.request(2);}
  prefs: []
  type: TYPE_NORMAL
- en: '@Override'
  prefs: []
  type: TYPE_NORMAL
- en: public void onNext(ExecutionResult result) {
  prefs: []
  type: TYPE_NORMAL
- en: if (result.getErrors().size() > 0) {
  prefs: []
  type: TYPE_NORMAL
- en: System.out.println(result.getErrors());
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: Map<String, Object> data = result.getData();
  prefs: []
  type: TYPE_NORMAL
- en: products.add(
  prefs: []
  type: TYPE_NORMAL
- en: new ObjectMapper().convertValue(data.get(
  prefs: []
  type: TYPE_NORMAL
- en: SUBSCRIPTION.QuantityChanged), Product.class));
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '@Override'
  prefs: []
  type: TYPE_NORMAL
- en: public void onError(Throwable t) {}
  prefs: []
  type: TYPE_NORMAL
- en: '@Override'
  prefs: []
  type: TYPE_NORMAL
- en: public void onComplete() {}
  prefs: []
  type: TYPE_NORMAL
- en: '});'
  prefs: []
  type: TYPE_NORMAL
- en: addQuantityMutation();
  prefs: []
  type: TYPE_NORMAL
- en: Integer count = products.get(0).getCount();
  prefs: []
  type: TYPE_NORMAL
- en: addQuantityMutation();
  prefs: []
  type: TYPE_NORMAL
- en: assertThat(products.get(0).getId())
  prefs: []
  type: TYPE_NORMAL
- en: .isEqualTo(products.get(1).getId());
  prefs: []
  type: TYPE_NORMAL
- en: assertThat(products.get(1).getCount())
  prefs: []
  type: TYPE_NORMAL
- en: .isEqualTo(count + TEN);
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
