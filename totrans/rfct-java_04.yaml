- en: '4'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When we talk about refactoring, as we have already mentioned, we essentially
    mean rewriting the code in a better way (where “better” can have various meanings)
    without changing its behavior. This last point is crucial, and we have not yet
    delved deep enough into it. To ensure that the behavior does not change and, in
    general, to approach every refactoring with a high level of confidence, it is
    necessary to be covered by an adequate set of tests.
  prefs: []
  type: TYPE_NORMAL
- en: 'It may sound obvious, but a test is nothing more than a way to verify the functionality
    of certain software (whether it is a piece of code, a module, or an entire architecture)
    against a set of requirements. In practice, we’re saying: “*Check that my code,
    given a certain input X, produces a certain output Y*.” It can be much more complex
    than that, but for now, let’s settle with this explanation.'
  prefs: []
  type: TYPE_NORMAL
- en: There can be various types of tests, as well as different approaches to writing
    them, as we will see during the course of this chapter. But before discussing
    the “how,” we will look at why testing is essential, especially when it comes
    to refactoring. Within the context of refactoring, I would say testing is a fundamental
    condition.
  prefs: []
  type: TYPE_NORMAL
- en: Fortunately, there are methodologies and tools that can assist us, such as the
    famous **JUnit framework**. In terms of methodologies, it is certainly worth mentioning
    **Test-Driven Development** (**TDD**), which *serves* refactoring and simultaneously
    *uses* refactoring – you will see what I mean by this somewhat cryptic statement.
    But to be truly safe, it is also necessary to ensure that most of the implemented
    functionalities have been rigorously tested; also, for this, we have tools that
    can save us quite a bit of headaches.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we’ll cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Why you should test, and why you should do it often
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unit testing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Integration testing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Contract testing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Be safe – checking and improving your test coverage
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Test-driven development
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Before anything else, however, as a famous book by Simon Sinek suggests, let’s
    start with “why.”
  prefs: []
  type: TYPE_NORMAL
- en: Why you should test (often)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As already mentioned, testing is a fundamental part of the work of a software
    engineer. It is a statement that we can all agree on – I would say it is almost
    intuitive – but let’s try to dig a little deeper and truly understand why it is
    essential to test our code (and our code interacting with other code and systems).
    The reasons I am about to present are not necessarily listed in order of importance,
    and they may not be the only ones. I am sharing what, in my experience, has been
    significant.
  prefs: []
  type: TYPE_NORMAL
- en: Identifying and fixing defects
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let’s start with the most obvious motivation. Testing your software allows you
    to identify defects (bugs), errors, and faults. In this regard, we have included
    an article in the *Further reading* section that explains the differences between
    these terms, which are often used interchangeably. These issues can manifest in
    various forms, such as functional flaws, performance bottlenecks, security vulnerabilities,
    or usability problems. When left unresolved, these problems can have severe consequences,
    leading to system failures, data breaches, dissatisfied users, and costly rework.
  prefs: []
  type: TYPE_NORMAL
- en: By conducting comprehensive testing throughout the development cycle, developers
    can detect and address these issues early on. This proactive approach to testing
    allows them to pinpoint and rectify potential problems before they escalate into
    more significant issues, thereby minimizing the risk of critical defects in the
    final product.
  prefs: []
  type: TYPE_NORMAL
- en: One of the primary benefits of early bug identification and resolution is the
    prevention of downstream complications. As the development progresses, the complexity
    of the software typically increases, making it more challenging to identify and
    fix defects. Bugs that go unnoticed in the initial stages can compound as new
    features are added, resulting in a cascade of interconnected problems that are
    difficult and time-consuming to resolve.
  prefs: []
  type: TYPE_NORMAL
- en: Moreover, addressing bugs at later stages of development – or, worse, after
    the software is released – can significantly impact the project’s timeline and
    budget. The cost of fixing defects in the production phase is usually much higher
    than resolving them during the development phase. Additionally, urgent bug fixes
    might necessitate disrupting regular development activities, leading to delays
    in delivering new features or updates (I can already see you nodding and sighing).
  prefs: []
  type: TYPE_NORMAL
- en: In brief, the more you test and the earlier you do so (that is, test small chunks
    of software while you’re writing it – we’ll see in a moment how we can be helped
    in such an activity), the better it is. Thinking a bit more laterally, anticipating
    potential issues brings both financial benefits (cost-effectiveness) and risk
    mitigation, especially in the case of software where even small defects can lead
    to significant damages (consider, for example, sectors such as healthcare, finance,
    or the aerospace industry).
  prefs: []
  type: TYPE_NORMAL
- en: Ensuring quality and reliability
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Testing is a critical aspect of the software development process that goes beyond
    simply identifying bugs and defects. It involves a systematic and comprehensive
    examination of the software to ensure that it meets the required quality standards
    and performs as expected. This process is essential to deliver a reliable, stable,
    and high-quality product that meets the needs and expectations of its users.
  prefs: []
  type: TYPE_NORMAL
- en: When software undergoes thorough testing, it is placed under rigorous scrutiny
    across various dimensions. **Functional testing** verifies that the software’s
    features and functionalities behave correctly and in accordance with the specified
    requirements. **Non-functional testing**, on the other hand, evaluates aspects
    such as performance, security, usability, and compatibility to ensure that the
    software meets the expected levels in these areas.
  prefs: []
  type: TYPE_NORMAL
- en: By subjecting the software to a suite of tests, developers can have confidence
    that the application will operate smoothly under normal conditions and handle
    challenging scenarios without unexpected crashes or malfunctions. This is especially
    crucial in mission-critical systems where any unforeseen issues could have severe
    consequences.
  prefs: []
  type: TYPE_NORMAL
- en: 'When talking about quality and reliability, it is worth defining some terms
    that I often hear being used – and I sometimes use myself – incorrectly. Let’s
    define what performance tests, load tests, and stress tests are:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Performance tests**: These are tests designed to assess the speed, responsiveness,
    and overall efficiency of a system or software under specific conditions. They
    aim to evaluate how well the system performs in normal situations.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Load tests**: Load tests are conducted to evaluate how well a system can
    handle a specific amount of load or user activity. The objective is to determine
    the system’s capacity and identify any performance bottlenecks under anticipated
    loads. They are a subset of performance tests.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Stress tests**: Stress tests involve pushing the system or software beyond
    its normal operating limits. The purpose is to check how the system behaves under
    extreme conditions, such as high user traffic, excessive data volumes, or limited
    resources. The goal is to identify potential weaknesses or failures in the system’s
    stability and resilience. Stress tests are also used for sizing environments (e.g.,
    you need to set up a new tier, and you know in advance how many resources you
    will need) or simply to know what the limit is, so you know in advance if and
    when to scale.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There is a very common tool, used for performance testing, which you probably
    know, called `jmeter-java-dsl`, you have the option to write your performance
    tests in Java, taking advantage of IDEs’ autocompletion and inline documentation.
    To get started, you can find a good resource in the *Further* *reading* section.
  prefs: []
  type: TYPE_NORMAL
- en: While JMeter remains one of the popular load-testing tools, scaling it for a
    large, distributed test can be somewhat challenging, particularly when dealing
    with multiple machines that require intricate configurations to communicate effectively.
    Additionally, executing large JMeter tests may lead to a range of orchestrating
    issues.
  prefs: []
  type: TYPE_NORMAL
- en: Customer satisfaction
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Customer satisfaction is the level of contentment customers feel after using
    a product or service, based on their perceptions and expectations. It’s a critical
    indicator of business success, impacting loyalty and reputation. There are many
    ways to measure it; jump to the *Further reading* section if you’d like to learn
    more.
  prefs: []
  type: TYPE_NORMAL
- en: High-quality software that undergoes rigorous testing not only ensures its reliability
    but also increases the likelihood of meeting the needs and expectations of its
    users. When customers find the software to be efficient, stable, and bug-free,
    they are more likely to be satisfied with their experience.
  prefs: []
  type: TYPE_NORMAL
- en: Satisfied customers tend to build a sense of trust and loyalty toward the product
    and the company behind it. They are more inclined to continue using the software
    for extended periods, fostering long-term engagement and loyalty. Moreover, happy
    customers often become advocates for the product, enthusiastically recommending
    it to their peers, friends, and colleagues.
  prefs: []
  type: TYPE_NORMAL
- en: Word-of-mouth referrals from satisfied users can be a powerful driver for the
    software’s success. Positive recommendations can significantly expand the software’s
    user base, leading to increased adoption rates and potential revenue growth for
    the company.
  prefs: []
  type: TYPE_NORMAL
- en: Compliance and standards
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In certain industries, such as healthcare, finance, and aerospace, the software
    used plays a critical role in the safety, security, and well-being of individuals
    and organizations. Due to the high stakes involved, these industries are subject
    to strict regulations and standards that software must adhere to.
  prefs: []
  type: TYPE_NORMAL
- en: In healthcare, for example, software for medical devices and health management
    must meet strict regulations set by authorities such as the FDA and EMA to ensure
    patient safety. The financial industry relies on software to handle critical tasks,
    and compliance with SEC and FCA standards is vital to protect consumers from fraud
    and data breaches. Similarly, aerospace software must adhere to FAA and EASA standards
    to ensure passenger safety and avoid accidents or operational disruptions. Non-compliance
    can have severe consequences for all these sectors.
  prefs: []
  type: TYPE_NORMAL
- en: Testing helps identify and address potential issues, vulnerabilities, and defects
    that could compromise the software’s performance, security, or compliance. By
    conducting deep testing, organizations can avoid legal and financial consequences
    that may arise from non-compliance with industry regulations.
  prefs: []
  type: TYPE_NORMAL
- en: Security
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In today’s digital landscape, where cyber threats and attacks are becoming increasingly
    sophisticated, it is imperative to fortify software systems against potential
    security breaches.
  prefs: []
  type: TYPE_NORMAL
- en: During the testing process, security experts and testers employ various methodologies
    and tools to simulate real-world attack scenarios, attempting to exploit weaknesses
    in the software’s defenses. This includes techniques such as penetration testing,
    where testers try to gain unauthorized access to the system, and vulnerability
    assessments, which identify potential areas of weakness.
  prefs: []
  type: TYPE_NORMAL
- en: By conducting such tests, developers can proactively identify and address security
    flaws before the software is deployed to the production environment. This proactive
    approach significantly reduces the risk of potential security breaches that could
    lead to data breaches, unauthorized access, or service disruptions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are some suggestions to effectively integrate security testing into the
    **Software Development Life Cycle** (**SDLC**); these are just a few ideas, based
    on what we have encountered in experience, and we suggest you look deeper into
    each point if it piques your interest:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Create security requirements specific to your application**: Ensure these
    requirements align with industry standards and compliance regulations.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Training and awareness**: Train developers and the development team on secure
    coding practices, fostering a security-aware culture within your organization.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Dependency scanning**: Regularly scan third-party dependencies for known
    vulnerabilities. Implement or use automated tools that can alert you when a dependency
    has a security issue.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Penetration testing**: Conduct penetration testing to simulate real-world
    attacks. Test the application from an attacker’s perspective to identify vulnerabilities
    that automated tools might miss.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These are just some of the measures we’ve seen implemented in companies, usually
    large companies that have dedicated teams. These activities are not only time-consuming
    but also very complex and require specific skills.
  prefs: []
  type: TYPE_NORMAL
- en: Integration and compatibility
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Testing plays a crucial role in verifying the seamless integration and compatibility
    of software with other components or systems. In today’s complex technological
    landscape, software rarely operates in isolation; it often interacts with various
    hardware, software modules, databases, APIs, and external systems. Ensuring that
    all these pieces work harmoniously together is essential for the overall success
    and efficiency of the application.
  prefs: []
  type: TYPE_NORMAL
- en: One of the primary testing methodologies used to assess integration and compatibility
    is **integration testing**. This type of testing focuses on evaluating how different
    modules or components of the software interact and exchange data with each other.
    We’ll deep dive into this topic in a dedicated section.
  prefs: []
  type: TYPE_NORMAL
- en: '**Compatibility testing** is another vital aspect of the testing process. With
    the wide variety of devices, operating systems, web browsers, and configurations
    available, it is essential to validate that the software functions correctly across
    different environments. Compatibility testing involves testing the software on
    various platforms to ensure that it behaves consistently and uniformly across
    all of them.'
  prefs: []
  type: TYPE_NORMAL
- en: By conducting compatibility testing, developers can identify platform-specific
    issues and make necessary adjustments to the software. This not only improves
    the user experience but also expands the potential user base, as a broader range
    of users can access and use the software without encountering compatibility-related
    problems.
  prefs: []
  type: TYPE_NORMAL
- en: Integration and compatibility issues can arise at different stages of software
    development, from the initial design to the final implementation. By incorporating
    testing throughout the development process, developers can proactively address
    these challenges, reducing the likelihood of integration bottlenecks (that is,
    a point in a system where the flow of data or functionality between different
    components is restricted, causing delays or inefficiencies) or compatibility conflicts
    in the later stages of the project.
  prefs: []
  type: TYPE_NORMAL
- en: Confidence and peace of mind
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It might sound strange, but rigorous testing of our software allows us to sleep
    more peacefully, and that is not a trivial matter. Let me explain further. If
    every time we release a new version of our software, we know that it has been
    well tested and we are confident in its proper functioning, this increases the
    team’s self-confidence and, ultimately, we work better, which is undoubtedly a
    benefit for everyone. When we work better, we become more productive and produce
    something of higher quality.
  prefs: []
  type: TYPE_NORMAL
- en: Furthermore, I must add that many developers don’t enjoy working on bugs, especially
    when they are complex to identify and resolve. Bug-fixing is time-consuming and
    often difficult to predict. As already mentioned, it takes time away from the
    team’s core activities.
  prefs: []
  type: TYPE_NORMAL
- en: That’s why it’s essential for developers to care about testing; it’s not only
    crucial in itself but also affects people’s well-being in some way. The primary
    goal (before clean code and refactoring – which cannot be safely done without
    a proper battery of tests) of developers must be that their software is adequately
    and automatically tested every time a change is made. The first and most immediate
    way to perform automatic tests is to write so-called “unit tests”; in Java, the
    most widely used framework for this is undoubtedly JUnit.
  prefs: []
  type: TYPE_NORMAL
- en: Unit testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Unit testing** is a type of software testing where individual units or components
    of a software application are tested in isolation to ensure they function correctly.
    A *unit* typically refers to the smallest testable part of the software, such
    as a function, method, or class. The main goal of unit testing is to validate
    that each unit of the software works as expected and produces the correct output
    for a given input. By testing units independently, developers can identify and
    fix bugs or issues in the early stages of development, making it easier to maintain
    and improve (hence, to refactor) the code base.'
  prefs: []
  type: TYPE_NORMAL
- en: 'There are several benefits to adopting unit testing, some of which are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Velocity**: Unit tests are fast! They focus on testing small, isolated units
    of code, typically individual functions or methods, in isolation from the rest
    of the system. This isolation allows unit tests to execute quickly because they
    don’t rely on external dependencies or perform complex setup and teardown processes.
    This helps developers to run them often and get quick feedback.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Isolation**: Each unit test is designed to run independently of the rest
    of the application. This isolation ensures that if a test fails, the cause is
    likely within the specific unit being tested, making it easier to pinpoint and
    fix the issue.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Automation**: Unit tests are usually automated, meaning they can be run automatically
    and regularly as part of the development process. This automation helps ensure
    that new code changes don’t introduce regressions or break existing functionality.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Early detection of issues**: Unit testing facilitates the early detection
    of defects, which can significantly reduce the cost and effort required for debugging
    and maintenance later in the development cycle.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Documentation**: Unit tests serve as living documentation, providing examples
    of how units are expected to behave. Developers can refer to these tests to understand
    the intended functionality of a unit and its possible edge cases. This is crucial;
    a well-written unit test can be better than 10 pages of documentation.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Refactoring support**: Of course, that’s why we’re talking about tests in
    this book! When refactoring code, unit tests act as a safety net. If the refactored
    code breaks any functionality, the unit tests will catch it, helping ensure the
    changes do not introduce bugs.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In practice, in a unit test, nothing else is done except executing a certain
    portion of code (for example, a method) and verifying that, starting from a specific
    input, the same output is always produced. Easy, right? Well, not always, and
    soon we’ll see why.
  prefs: []
  type: TYPE_NORMAL
- en: 'To test our unit, we will write – in fact – a Java class with several methods
    (each of which is a unit test) that will test the various functionalities. It
    is always advisable to be organized even in the design of test classes; by convention,
    to test, for example, the `com.acme.demo.MyClass` class, we will create a class
    called `com.acme.demo.MyClassTest`. The former will be placed under the `main`
    folder, while the latter will be under the `test` folder. Inside each unit test,
    it is advisable to follow a fairly established pattern, called **AAA**, or the
    three As:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Arrange**: This phase involves preparing the objects that will be subjected
    to testing. During this phase, you establish the desired condition of the system
    under test and set up its dependencies. This can involve directly creating instances
    of the necessary objects or getting them ready by creating their test counterparts.
    This may include initializing resources (collaborators) needed for the class under
    test, and so on.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Act**: This is where you interact with the system under test. In this phase,
    you invoke one of its methods, providing any required dependencies, and capturing
    any resulting output values if applicable.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Assert**: This is where you check Boolean expressions (assertions) that must
    be true if the test is successful; that is, the observed output data and/or post-conditions
    are different from the expected ones. Sometimes, it is not only the output that
    is evaluated, but it is also possible to verify the method’s execution flow by
    making assertions regarding whether a certain component – present *inside* the
    class under test – has been called, how many times, and with what input.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let’s go through a trivial example. Let’s suppose we have a `Calculator` class,
    which has a method that takes two integers and returns their sum (I said it was
    trivial!):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s now write a test class for `Calculator`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we have created a test method called `testAddition`. The test
    method creates an instance of the `Calculator` class, calls `testAddition` with
    a specific input, and then compares the result with the expected output. When
    you run the `CalculatorTest` class, it will output whether the test has passed
    or failed based on the comparison of the actual results and expected results.
  prefs: []
  type: TYPE_NORMAL
- en: Keep in mind that this is just a basic example to demonstrate how unit tests
    can be written without using a testing framework such as JUnit. In real-world
    scenarios, using a testing framework such as JUnit provides many additional features
    and benefits, such as easier test organization, assertions, test reporting, and
    integration with build tools and CI/CD pipelines.
  prefs: []
  type: TYPE_NORMAL
- en: JUnit framework
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: JUnit is a popular testing framework for Java that is primarily used to perform
    unit testing of Java applications. It provides a set of annotations, assertions,
    and test runners that make writing and executing tests easier and more organized.
    JUnit is widely used in the Java development community and has become a standard
    for writing unit tests.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are some key features and concepts of JUnit:'
  prefs: []
  type: TYPE_NORMAL
- en: '`@Test`, `@Before`, `@After`, `@BeforeClass`, and `@AfterClass`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@Test` and are responsible for verifying specific functionality in the code
    being tested. Each test method should be independent and focus on testing a specific
    part of the code base.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@Before` and `@After` annotations are used to mark methods that will be executed
    before and after each test method. They are used for setting up the test environment
    (e.g., initializing objects) and cleaning up resources after each test.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`BlockJUnit4ClassRunner`, but `org.junit.platform.runner.JUnitPlatform`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`assertEquals`, `assertTrue`, `assertFalse`, etc.) to perform various types
    of assertions to check the expected outcomes of the tests.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@RunWith` and `@``Suite` annotations.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Parameterized tests**: **JUnit 4** introduced the concept of parameterized
    tests, allowing you to run the same test with multiple sets of data.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: JUnit 5 is the next major version of JUnit and introduced several new features
    and improvements over JUnit 4\. It offers a more modular and extensible architecture,
    better support for `@BeforeEach`, `@AfterEach`, and `@DisplayName`.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we wanted to rewrite the `CalculatorTest` class using JUnit, the result
    would be as follows. The example is straightforward, but it helps us understand
    how the framework works:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: You can notice the `@Test` annotation, which allows the framework to “understand”
    that that is a unit test. `@DisplayName` is utilized to specify a personalized
    name for the annotated test class or test method; these display names are commonly
    employed for test reporting within IDEs and build tools, and they have the flexibility
    to include spaces, special characters, and emojis.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is how the IntelliJ IDE represents the execution of a successful JUnit
    test:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.1 – Execution of a successful JUnit test in the IntelliJ IDE](img/B20912_04_1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.1 – Execution of a successful JUnit test in the IntelliJ IDE
  prefs: []
  type: TYPE_NORMAL
- en: Now, it is quite intuitive, I believe, to understand how an automated test suite
    can be integrated into the code development process; frameworks such as JUnit
    help developers test their code, find bugs, and potentially improve performance.
    JUnit (and unit testing in general) reaches its full potential when integrated
    through tools such as **Maven** or **Gradle** (which allow code build management
    and automated test execution) and **Jenkins** or **GitHub**, which handle **Continuous
    Integration** (**CI**), a practice that involves automatically and regularly integrating
    code changes into a shared repository and running automated tests to detect integration
    issues early. CI is a very broad topic, so I refer you to the *Further reading*
    section, where there is a related Wikipedia entry. Unfortunately, it is challenging
    to find *agnostic*, meaning not tied to specific products, material online that
    explains the concepts. I hope this can serve as a starting point and stimulate
    your curiosity.
  prefs: []
  type: TYPE_NORMAL
- en: Writing unit tests is hard and complicated, much more than it may seem from
    these few simple examples. It is also a crucial task, essential both for a smooth
    production release and to be able to perform any desired refactoring. One of the
    most challenging aspects is imagining all possible test cases (i.e., all potential
    behaviors of the application, all the “flows” it can follow – think of all the
    `if` statements and polymorphism you have used in your code); fortunately, we
    don’t have to imagine, as we can use tools designed for this purpose.
  prefs: []
  type: TYPE_NORMAL
- en: Integration testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Integration testing involves checking how various pieces, modules, or parts
    of a software application work together, even if different programmers coded them.
  prefs: []
  type: TYPE_NORMAL
- en: The goal of integration testing is to examine the connections between these
    modules and uncover any issues that might pop up when these components come together
    and have to work together.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is usually performed downstream of unit tests; assuming that individual
    software modules (be they projects, classes, or entire applications) are tested
    individually, we begin to test the interactions they have with other modules with
    which they collaborate, as shown in *Figure 4**.2*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.2 – Unit tests concern each module individually, while integration
    tests concern interactions](img/B20912_04_2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.2 – Unit tests concern each module individually, while integration
    tests concern interactions
  prefs: []
  type: TYPE_NORMAL
- en: To carry out integration testing, testers use test drivers and *stubs*, that
    is, placeholder programs that step in for any absent modules and mimic data exchange
    between modules for testing. There are several frameworks that can help you along
    the way; you don’t have to do all the work by yourself! The most famous framework
    used to perform integration testing (at least on a basic and widespread level)
    is JUnit (which we just saw) in combination with Mockito.
  prefs: []
  type: TYPE_NORMAL
- en: Mockito
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Mockito is a widely used Java-based open source framework for creating and
    configuring mock objects in both unit testing and integration testing. In the
    context of Java software development, Mockito is favored for its ability to facilitate
    testing by creating mock objects that mimic the behavior of real components. These
    mock objects are especially valuable in integration testing for several reasons:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Firstly, Mockito aids in isolating specific parts of an application. It allows
    developers to create mock objects that simulate the behavior of real components,
    thereby enabling them to test particular modules, components, or services in isolation.
    This isolation is crucial when you want to verify the behavior of a specific part
    of your application without involving the entire system or interacting with real
    dependencies, such as databases, web services, or external APIs. In the following
    code snippet, we can get an idea of how Mockito works:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Secondly, Mockito provides control and verification capabilities. Developers
    can define the behavior of mock objects, specify what methods should return, and
    record interactions with these objects during the test. This level of control
    and verification ensures that the component under test correctly interacts with
    its dependencies. To verify something, you just have to write something such as
    the following:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Additionally, Mockito contributes to the efficiency and speed of integration
    tests. Using real external dependencies in integration tests can be slow and complex
    to set up, and may result in undesirable side effects. In contrast, Mockito’s
    mock objects are lightweight and do not rely on external resources, making integration
    tests faster, more efficient, and less prone to side effects.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Lastly, Mockito offers test flexibility. Developers can create customizable
    mock objects that allow them to specify different behaviors for various test cases.
    This flexibility simplifies the simulation of various scenarios in integration
    tests.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We have left some material in the *Further Readings* section to deep dive into
    the magic of Mockito.
  prefs: []
  type: TYPE_NORMAL
- en: Contract testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have seen that integration tests are also used to test external services,
    services that are probably not in our code base and that may not even be maintained
    by us. You then create a stub, or mock, that returns a “fake” answer, based on
    documentation or, often, on the real answers exchanged at runtime between the
    two services. But what happens if something changes, if one of the two changes
    the contract? How do you make sure that the mock we’ve created is really a representation
    of the outside service? Contract testing helps us.
  prefs: []
  type: TYPE_NORMAL
- en: Contract testing aims to ensure compatibility and agreement between different
    services or components within a distributed system. It is particularly useful
    in scenarios such as microservices architectures where different services need
    to communicate seamlessly. In contract testing, services communicate with each
    other based on well-defined interfaces or contracts. These contracts outline how
    data is exchanged, specify available methods or endpoints, and describe expected
    responses.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two primary roles in contract testing: consumers and providers. Consumers
    are the services or components that utilize data or functionality from another
    service, known as the provider. Contracts define what the consumer expects from
    the provider; that is why it is said that contract tests are consumer-driven.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The process starts with the definition of contracts, which can take various
    forms, such as API specifications or interface documentation. Contract testing
    primarily focuses on the consumer’s perspective. Consumer tests are written to
    ensure that the provider’s behavior aligns with the contract. These tests are
    typically managed by the consumer’s team. Provider tests, on the other hand, are
    written by the provider’s team. They verify that the provider complies with the
    contract specifications. Automated contract tests run continuously as part of
    the build and deployment process. They help detect compatibility issues early
    whenever changes occur in either the consumer or provider service. Here is a diagram
    to help understand contract testing:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.3 – Contract testing](img/B20912_04_3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.3 – Contract testing
  prefs: []
  type: TYPE_NORMAL
- en: Various tools and libraries support contract testing, depending on the project’s
    technology stack and requirements. Some popular options include Pact, Spring Cloud
    Contract, and Pacto.
  prefs: []
  type: TYPE_NORMAL
- en: Be safe – checking and improving your test coverage
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Testing is important, but we need to make sure we test our code thoroughly,
    not just a part of it; covering all the code doesn’t only mean all the classes,
    but also all possible execution paths. We might think it’s easy to keep all possible
    cases in mind, and perhaps this is true for very small projects; but as the project
    grows and inevitably becomes more complex (for example, the number of features
    increases or the possible execution paths multiply), it becomes difficult to understand
    the efficiency of our tests for keeping us safe. This is why we introduce the
    concept of test coverage and a tool to measure it.
  prefs: []
  type: TYPE_NORMAL
- en: What is test coverage?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Test coverage**, also known as **code coverage**, is a metric used to measure
    the extent to which the source code of a program is executed by a set of test
    cases. It is a quantitative measure that helps developers and testers understand
    how much of the code is being exercised during testing.'
  prefs: []
  type: TYPE_NORMAL
- en: Test coverage is usually expressed as a percentage, representing the proportion
    of code lines, branches, statements, or methods that have been executed by the
    test suite compared to the total number of such elements in the code base.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are different types of coverage metrics:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Line coverage**: This measures the percentage of lines of code that have
    been executed at least once during testing.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`if` instances in your code) that have been taken or not taken during testing.
    It ensures that both true and false branches of conditional statements are tested.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Statement coverage**: This measures the percentage of executable statements
    that have been executed during testing.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Method coverage**: Method coverage measures the percentage of methods or
    functions that have been called during testing.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Test coverage is not a definitive measure of software quality but provides valuable
    insights into the thoroughness of testing efforts. High coverage indicates that
    a significant portion of the code has been tested, increasing confidence in the
    correctness of the application. However, even 100% coverage does not guarantee
    a bug-free application, as it is possible to have untested edge cases or incorrect
    assumptions in the test cases.
  prefs: []
  type: TYPE_NORMAL
- en: By improving test coverage, developers can mitigate the risk of undiscovered
    defects and make their code more robust and maintainable. We use code coverage
    tools to generate coverage reports, which can be analyzed to identify areas of
    the code that need more testing.
  prefs: []
  type: TYPE_NORMAL
- en: A Java code coverage tool – JaCoCo
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**JaCoCo** (short for **Java Code Coverage**) is a widely used open source
    code coverage library for Java projects. It provides a comprehensive and detailed
    analysis of code coverage, allowing developers to understand how much of their
    Java code is exercised by their tests.'
  prefs: []
  type: TYPE_NORMAL
- en: JaCoCo offers various types of code coverage analysis, including line coverage,
    branch coverage, and method coverage. It instruments the Java bytecode during
    the build process to collect execution data, which is then used to generate coverage
    reports.
  prefs: []
  type: TYPE_NORMAL
- en: 'JaCoCo primarily provides three significant metrics:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Line coverage** indicates the extent of code that has been executed based
    on the number of Java bytecode instructions called by the tests'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`if`/`else` and `switch` statements'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Cyclomatic complexity** reflects the code’s complexity by quantifying the
    number of paths required to cover all the possible code paths through a linear
    combination'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To illustrate with a simple example, if the code contains no `if` or `switch`
    statements, the cyclomatic complexity will be 1, as only one execution path is
    needed to cover the entire code. In general, the cyclomatic complexity represents
    the number of test cases required to achieve full code coverage.
  prefs: []
  type: TYPE_NORMAL
- en: To illustrate how JaCoCo works, let’s start with a very simple example. It is
    not my intention to create a tutorial on this tool here – there are already plenty
    of them online – but I would like to show you its main features so that you can
    get a rough idea of how it works.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s suppose we have a project consisting of only one class named `Calculator`,
    defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, the `Calculator` class exposes three very simple methods that
    take two integers as input and return, respectively, their sum, difference, and
    product. Let’s proceed to write the corresponding test class, which we will define
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The test class creates an instance of `Calculator` and then performs two unit
    tests, one for the sum and the other for the difference. Using the JUnit framework,
    we verify that the expected result matches the actual result.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are many ways to use a tool like JaCoCo, but in my opinion, the best
    approach is to integrate it into the development cycle. Assuming we are using
    Maven, we will configure our `pom.xml` file so that the plugin is executed and
    reports are generated:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The execution of JaCoCo’s Maven plugin will create a report inside the `target/site`
    folder, which can be easily viewed through any web browser.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.4 – The mini-website created by JaCoCo shows the test coverage for
    each class](img/B20912_04_4.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.4 – The mini-website created by JaCoCo shows the test coverage for
    each class
  prefs: []
  type: TYPE_NORMAL
- en: 'In this table, we find the only class in our project. We can see from the report
    that the `Calculator` class has `multiply` method. Let’s add a third unit test
    to our test class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, let’s run the JaCoCo Maven plugin again. The report will now look like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.5 – After adding a test case, coverage is now 100%](img/B20912_04_5.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.5 – After adding a test case, coverage is now 100%
  prefs: []
  type: TYPE_NORMAL
- en: All the methods of `Calculator` have been tested. The coverage is **100%**.
  prefs: []
  type: TYPE_NORMAL
- en: 'What happens if we make changes? Let’s say, for example, we decide not to support
    negative results in the subtraction operation by adding a check that throws an
    exception when the subtrahend (the number that is subtracted from another number)
    is greater than the minuend (the number from which another number is subtracted):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'If we run JaCoCo again, we can notice something very interesting:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.6 – By adding a new feature without adding the relative test, the
    coverage decreases](img/B20912_04_6.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.6 – By adding a new feature without adding the relative test, the coverage
    decreases
  prefs: []
  type: TYPE_NORMAL
- en: The coverage has decreased, and specifically, the `if`-`else` statements and
    `switch`-`case` statements.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can see which method is affected by clicking on `Calculator`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.7 – By clicking on the Calculator entry, it is clearer which of
    its methods is not fully covered](img/B20912_04_7.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.7 – By clicking on the Calculator entry, it is clearer which of its
    methods is not fully covered
  prefs: []
  type: TYPE_NORMAL
- en: 'We can even click on the method to see which part of the code is not covered:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.8 – Clicking on the single method entry, it’s possible to see where
    the test coverage is missing](img/B20912_04_8.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.8 – Clicking on the single method entry, it’s possible to see where
    the test coverage is missing
  prefs: []
  type: TYPE_NORMAL
- en: 'Since we have added an `if` statement, we have created a branch. Whenever a
    branch is created, which represents a new possible execution flow, we must cover
    it with tests. Let’s do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s regenerate the report to see the changes:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.9 – Again, full coverage](img/B20912_04_9.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.9 – Again, full coverage
  prefs: []
  type: TYPE_NORMAL
- en: The coverage is now back to **100%**.
  prefs: []
  type: TYPE_NORMAL
- en: This is just the tip of the iceberg. JaCoCo is highly configurable (for example,
    you can configure branches and missed instructions) and can be used to completely
    block the build when a minimum coverage threshold is not met. You can exclude
    individual classes, class patterns, packages, and more. I strongly encourage you
    to explore this tool further.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have roughly seen how JaCoCo works and, above all, what test coverage
    is, let’s delve further into our reasoning and try to understand why it is convenient,
    sensible, and extremely advantageous, when developing, not only to write tests
    but also to... start with them!
  prefs: []
  type: TYPE_NORMAL
- en: Test-driven development
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As the name suggests, **test-driven development**, abbreviated as **TDD**, is
    a widely used software development practice in Agile methodologies, especially
    in **Extreme Programming**. It is widely regarded as a fundamental technique for
    achieving higher-quality software.
  prefs: []
  type: TYPE_NORMAL
- en: 'As the name itself suggests, development is driven by tests, not the other
    way around. The classic development cycle involves the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.10 – The classic development cycle involves designing, coding, and
    then testing](img/B20912_04_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.10 – The classic development cycle involves designing, coding, and
    then testing
  prefs: []
  type: TYPE_NORMAL
- en: 'This is flipped around. We start with the tests to arrive at defining the design;
    of course, writing the code in between:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.11 – The TDD cycle starts with the tests](img/B20912_04_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.11 – The TDD cycle starts with the tests
  prefs: []
  type: TYPE_NORMAL
- en: 'Attention is given to the functional aspects of the code, specifically the
    method signatures, before the actual implementation of the code. To start with
    the tests, you need to take the perspective of the “client” of your code and primarily
    consider the public methods:'
  prefs: []
  type: TYPE_NORMAL
- en: The methodology involves immediately writing a test; by executing this test
    (which requires defining an input, invoking a method, and asserting the result),
    the outcome will inevitably be a failure since the implementation does not exist
    yet. This phase is called **Red** (the color that commonly indicates a failure
    of a unit test in many IDEs).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The next step is to implement the missing functionality by writing the bare
    minimum to make the test pass as quickly as possible. When the test passes, you
    are in the so-called **Green** phase. Don’t worry if the code you wrote is not
    perfect or if you think it could be improved; that will be addressed in the next
    phase.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The third and final phase of TDD is **Refactor**, which allows you to transform
    your code by adapting, simplifying, streamlining, and removing duplicates. In
    this phase, you do not add new features, as it is purely a refactoring process.
    If you want to add new features, you must go back to the Red phase and start again
    from there.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Here is a diagram of the TDD process:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.12 – The TDD cycle](img/B20912_04_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.12 – The TDD cycle
  prefs: []
  type: TYPE_NORMAL
- en: I think that by this point, you will have understood how cool this technique
    is; however, as with all things, there are not just advantages. Let’s take a closer
    look at the pros and cons of this methodology so that you can form your own opinion.
    As usual, don’t expect an exhaustive list; even though I tried to refer to the
    existing literature on the subject, much of it is influenced by my personal experience.
  prefs: []
  type: TYPE_NORMAL
- en: Advantages of TDD
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here are some advantages of TDD:'
  prefs: []
  type: TYPE_NORMAL
- en: '**You only write code that’s needed**: According to the principles, it’s important
    to avoid writing production code right after all your tests pass. Instead, when
    your project requires a new feature, you should create a test first to guide the
    implementation process. The code you write should be the most straightforward
    and minimal necessary to fulfill the feature’s requirements. In this way, only
    the essential code to implement the features will end up in the final product.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Fast failing**: The distinctive aspect of TDD is its ability to facilitate
    rapid failure. This shortens the feedback loop, allowing the development team
    to quickly determine whether the code is correct. Developers can conduct self-assessments
    and manual acceptance tests, while also engaging in peer-to-peer reviews. The
    outcome is a reduced turnaround time, leading to minimal defects during testing.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Continuous change**: As usual, most developers collaborate on the same code
    base. Whenever an individual developer starts working, CI tools detect the changes
    and promptly execute the unit tests, assessing the code within a few minutes.
    If any failures occur, they are promptly reported to the developers, who resolve
    the issues before proceeding to manual or integrated testing, ensuring that end
    users do not encounter these problems.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Easier to maintain and refactor the code base**: Decoupling and clear interfaces
    make code more manageable. You can replace microfeature implementations without
    affecting other modules and rewrite the entire application with preserved tests.
    Thorough testing for each feature eliminates the fear of making changes. A complete
    test suite allows confident code improvements without breaking the application.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Clear documentation**: TDD uses unit tests, which act as effective documentation,
    sparing the need for time-consuming and difficult-to-maintain written documentation.
    This aspect is a key characteristic of good test coverage overall. TDD significantly
    contributes to achieving comprehensive test coverage.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Nudge to refactoring**: There is a dedicated Refactor step as part of the
    Red-Green-Refactor cycle, ensuring that developers think about improvements in
    the design for every single line of code that they write.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Development speed – a note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Especially at the beginning, the feeling is that of progressing very slowly.
    TDD is more focused on delivering quality code rather than delivering code quickly.
    People might also write too many tests that are similar or redundant, or perhaps
    write tests that are too simple or test trivial parts of the code. Until the mindset
    is well integrated within the team, it may take some time to proceed at a decent
    pace.
  prefs: []
  type: TYPE_NORMAL
- en: Anyway, when developers delay the creation of tests, it may initially appear
    to expedite the development process. However, this approach frequently results
    in tightly coupled code, rendering certain portions untestable. In the event of
    discovering bugs, the debugging phase can become a time-consuming and unpredictable
    task. Consequently, choosing to replace the uncertain and variable debugging process
    with a more predictable and structured testing procedure is often a better idea.
  prefs: []
  type: TYPE_NORMAL
- en: 'To summarize, TDD is a software development methodology in which developers
    create automated tests before writing the actual code. This process involves three
    main steps: writing a failing test that defines the desired functionality, writing
    the minimum code required to pass the test, and then refining the code while ensuring
    all tests continue to pass. It can be implemented over unit tests and also other
    kind of tests, such as integration tests. TDD encourages iterative development,
    improves code quality, and helps catch bugs early in the development process.'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: I hope I have conveyed to you the importance of testing, not only as a necessary
    condition for refactoring but also as a cornerstone of quality code. In this chapter,
    we have understood why testing is crucial and why it is beneficial to do it frequently,
    allowing us to fail as early as possible – this may appear like a paradox, but
    it isn’t.
  prefs: []
  type: TYPE_NORMAL
- en: We have various types of tests at our disposal, but we focused particularly
    on unit testing, for which a framework such as JUnit is of great help.
  prefs: []
  type: TYPE_NORMAL
- en: Since testing is essential, it is crucial to have as much of our code base covered
    by tests as possible. For this purpose, we have the assistance of another tool,
    JaCoCo.
  prefs: []
  type: TYPE_NORMAL
- en: Furthermore, we introduced the fundamental methodology TDD, reversing the traditional
    development flow to start with tests and then proceeding to write the code.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have covered all the fundamentals, we can move on to the next chapter,
    where we will finally analyze some refactoring techniques, delving deeper into
    topics that we only briefly touched upon in the chapter on code smells – [*Chapter
    3*](B20912_03.xhtml#_idTextAnchor070).
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**The Confusion: Error vs. Fault vs. Bug vs. Defect vs.** **Failure**: [https://farhan-labib.medium.com/the-confusion-error-vs-fault-vs-bug-vs-defect-vs-failure-c557af04726b](https://farhan-labib.medium.com/the-confusion-error-vs-fault-vs-bug-vs-defect-vs-failure-c557af04726b)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Getting started with Apache JMeter: [https://jmeter.apache.org/usermanual/get-started.html](https://jmeter.apache.org/usermanual/get-started.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Customer satisfaction: [https://www.linkedin.com/advice/1/what-key-performance-indicators-measuring-customer](https://www.linkedin.com/advice/1/what-key-performance-indicators-measuring-customer)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Continuous integration: [https://en.wikipedia.org/wiki/Continuous_integration](https://en.wikipedia.org/wiki/Continuous_integration
    )'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Continuous Delivery: Reliable Software Releases through Build, Test, and Deployment
    Automation* by Jez Humble and David Farley (Addison-Weasley, 2010)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The JUnit framework’s official website: [https://junit.org/junit5/](https://junit.org/junit5/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Getting started with Mockito: [https://www.baeldung.com/mockito-series](https://www.baeldung.com/mockito-series)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'JaCoCo website: [https://www.jacoco.org/jacoco/](https://www.jacoco.org/jacoco/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
